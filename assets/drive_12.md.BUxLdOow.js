import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,m,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-4bf7c48b"]]),S=JSON.parse('[{"question":"# Coding Assessment Question Scenario: You\'re working on a data analysis project where you need to summarize time series data efficiently. Given a list of timestamps, you need to implement a function to count the number of occurrences of each unique timestamp, while maintaining the original order of their first appearance in the list. Problem Statement: Implement a Python function `count_timestamps(timestamps: List[str]) -> List[Tuple[str, int]]` that receives a list of timestamps in string format and returns a list of tuples. Each tuple should contain a timestamp and its count, preserving the order of first occurrence. Requirements: 1. The function should handle both empty and non-empty lists. 2. Non-list inputs should raise a `TypeError`. 3. Each timestamp in the input list is a string representing a valid date-time format. 4. The result should preserve the order of first appearances of timestamps. 5. Optimize for efficient counting and order preservation. Input: - A list of strings `timestamps`, where each string is a timestamp in any valid date-time format. Output: - A list of tuples: Each tuple contains a string (timestamp) and an integer (count of occurrences). Constraints: - You may assume that input list size is up to (10^5). - The solution should efficiently handle counting and ordering simultaneously with a complexity not exceeding (O(n log n)). Function Signature: ```python from typing import List, Tuple def count_timestamps(timestamps: List[str]) -> List[Tuple[str, int]]: ``` Example Cases: ```python assert count_timestamps([]) == [] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-01T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 2), (\\"2023-01-02T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-03T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 1), (\\"2023-01-02T00:00:00\\", 1), (\\"2023-01-03T00:00:00\\", 1)] assert count_timestamps([\\"2023-01-01T00:00:00\\", \\"2023-01-02T00:00:00\\", \\"2023-01-01T00:00:00\\", \\"2023-01-01T00:00:00\\"]) == [(\\"2023-01-01T00:00:00\\", 3), (\\"2023-01-02T00:00:00\\", 1)] ``` Additional Information: - Make sure to use efficient data structures for counting and order preservation. - Consider edge cases such as single element lists and repeated timestamps as part of your implementation. Implement the `count_timestamps` function as per the outlined requirements.","solution":"from typing import List, Tuple from collections import OrderedDict def count_timestamps(timestamps: List[str]) -> List[Tuple[str, int]]: if not isinstance(timestamps, list): raise TypeError(\\"Input must be a list\\") count_dict = OrderedDict() for ts in timestamps: if ts in count_dict: count_dict[ts] += 1 else: count_dict[ts] = 1 return list(count_dict.items())"},{"question":"# Coding Challenge: Enhance Binary Search Tree with Additional Functionalities Context You have a robust implementation of a Binary Search Tree (BST), which supports the basic operations such as insertion, deletion, and search efficiently. However, there are some additional operations that can extend the versatility and usability of your BST. Task Extend the `BinarySearchTree` class by implementing two additional functions: 1. **Find K-th Smallest Element**: This operation finds and returns the k-th smallest element in the BST. 2. **Count Nodes in Range**: This operation counts and returns the number of nodes that fall within a specified range [low, high]. Specifications **Operation 1: Find K-th Smallest Element** - **Function Signature**: `def find_kth_smallest(self, k):` - **Input**: `k` - The position of the smallest element to find. - **Output**: The k-th smallest element in the BST. **Constraints**: - `k` is a positive integer such that `1 <= k <= n`, where `n` is the number of nodes in the tree. **Operation 2: Count Nodes in Range** - **Function Signature**: `def count_nodes_in_range(self, low, high):` - **Input**: `low` - The lower bound of the range, `high` - The upper bound of the range. - **Output**: The count of nodes whose values fall within the range [low, high]. Additional Requirements - Ensure that standard BST properties are maintained. - Optimize for both time and space complexity. # Example Usage ```python # Initialize a binary search tree bst = BinarySearchTree() # Insert elements bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(15) bst.insert(25) # Find the 3rd smallest element print(bst.find_kth_smallest(3)) # Should print 7 # Count nodes in the range [7, 20] print(bst.count_nodes_in_range(7, 20)) # Should print 4 ``` # Constraints - Do not use any additional data structures beyond what is required for the operations. - Handle edge cases such as k being out of range or empty tree scenarios gracefully. - Performance expectations are O(h) for the basic operations, where h is the height of the tree, and O(n) for any traversal-based solutions, where n is the number of nodes in the tree. **Note**: You may modify the `Node` and `BinarySearchTree` classes as necessary to implement these functionalities. **Class Definitions** (hypothetical structure for clarity): ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): # Your implementation here def delete(self, key): # Your implementation here def search(self, key): # Your implementation here def find_kth_smallest(self, k): # Your implementation here def count_nodes_in_range(self, low, high): # Your implementation here ``` **Hint**: For the `find_kth_smallest` function, consider using an in-order traversal to exploit the BST\'s inherent ordering of nodes.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def find_kth_smallest(self, k): def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) elements = in_order_traversal(self.root) if 0 < k <= len(elements): return elements[k - 1] return None def count_nodes_in_range(self, low, high): def count_nodes(node): if node is None: return 0 if low <= node.val <= high: return 1 + count_nodes(node.left) + count_nodes(node.right) elif node.val < low: return count_nodes(node.right) else: return count_nodes(node.left) return count_nodes(self.root)"},{"question":"# Problem Statement You need to create a class named `MaxHeap` that implements a max heap data structure. A max heap is a binary tree where each parent node\'s value is greater than or equal to the values of its children, and the highest value node is at the root. The class should include methods for insertion, deletion (of the maximum element), heapifying, and viewing the maximum element. This problem will help you practice manipulating heap data structures. Implement the following methods in the `MaxHeap` class: 1. Adding an element. 2. Removing the maximum element. 3. Viewing the maximum element. 4. Heapifying an array. 5. Extracting max element. # Function Specifications 1. **Add Function** ```python def add(self, value: int) -> None: ``` - **Input**: An integer value to be added to the heap. - **Output**: None. The value is added to the heap while maintaining the max heap property. - **Constraints**: The heap can have duplicates. 2. **Remove Max Function** ```python def remove_max(self) -> int: ``` - **Input**: None. - **Output**: An integer value which is the max value in the heap. This value is removed from the heap. - **Constraints**: Raises IndexError if the heap is empty. 3. **Get Max Function** ```python def get_max(self) -> int: ``` - **Input**: None. - **Output**: The max value in the heap without removing it. - **Constraints**: Raises IndexError if the heap is empty. 4. **Heapify Function** ```python def heapify(self, arr: List[int]) -> None: ``` - **Input**: A list of integers. - **Output**: None. The list is reorganized into the max heap order. - **Constraints**: In-place transformation of the input list. 5. **Extract Max Function** ```python def extract_max(self) -> int: ``` - **Input**: None. - **Output**: The max element from the heap. - **Constraints**: Raises IndexError if the heap is empty. # Examples ```python h = MaxHeap() h.add(5) h.add(10) h.add(3) assert h.get_max() == 10 h.add(15) assert h.get_max() == 15 assert h.remove_max() == 15 assert h.get_max() == 10 h.add(8) assert h.get_max() == 10 h.heapify([4, 10, 3, 5, 1]) assert h.get_max() == 10 assert h.extract_max() == 10 assert h.get_max() == 5 ```","solution":"import heapq class MaxHeap: def __init__(self): self.heap = [] def add(self, value: int) -> None: Add a value to the max heap. heapq.heappush(self.heap, -value) def remove_max(self) -> int: Remove and return the maximum value from the heap. Raise IndexError if the heap is empty. if not self.heap: raise IndexError(\\"remove_max from an empty heap\\") return -heapq.heappop(self.heap) def get_max(self) -> int: Return the maximum value from the heap without removing it. Raise IndexError if the heap is empty. if not self.heap: raise IndexError(\\"get_max from an empty heap\\") return -self.heap[0] def heapify(self, arr) -> None: Transform a list into a max heap. self.heap = [-x for x in arr] heapq.heapify(self.heap) def extract_max(self) -> int: Return the max value from the heap. Raise IndexError if the heap is empty. return self.remove_max()"},{"question":"# Binary Search Tree (BST) Iterator Objective: Your task is to create a `BSTIterator` class for an initially given binary search tree (BST). This iterator should provide an interface to iterate over the elements of the BST in ascending order. Requirements: 1. Implement the `BSTIterator` class with an initializer that accepts the root of a BST. 2. Include methods `has_next` and `next`: - `has_next()` returns `True` if there are still elements to be traversed and `False` otherwise. - `next()` returns the next smallest element in the BST. Class Definition: ```python class BSTIterator: def __init__(self, root: Optional[TreeNode]) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node: Optional[TreeNode]) -> None: while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise ValueError(\\"No more elements in BST\\") topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val ``` Testing: - Construct multiple BSTs and test the iterator: 1. Fully populated tree. 2. Empty tree. 3. Single-node tree. - Verify the output of `BSTIterator` matches in-order traversal of the BST. Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(7, TreeNode(3), TreeNode(15, TreeNode(9), TreeNode(20))) iterator = BSTIterator(root) print(iterator.next()) # 3 print(iterator.next()) # 7 print(iterator.has_next()) # True print(iterator.next()) # 9 print(iterator.has_next()) # True print(iterator.next()) # 15 print(iterator.has_next()) # True print(iterator.next()) # 20 print(iterator.has_next()) # False ``` **Output**: ```shell 3 7 True 9 True 15 True 20 False ``` Ensure to handle edge cases and that the iterator traverses the tree correctly in ascending order.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, node: TreeNode) -> None: while node: self.stack.append(node) node = node.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise ValueError(\\"No more elements in BST\\") topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Dijkstra\'s Algorithm for Shortest Path in a Graph You have been provided with a directed weighted graph, represented by an adjacency matrix, and your task is to implement Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in the graph. **Function Signature**: ```python def dijkstra_shortest_path(graph: List[List[int]], source: int) -> List[int]: ``` **Input**: - `graph`: A 2D list of integers where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If there is no edge between `i` and `j`, the value will be `float(\'inf\')`. - `source`: An integer representing the starting vertex (0-indexed). **Output**: - A list of integers where the ith element represents the shortest distance from the source vertex to the ith vertex. **Constraints**: - The graph will have no negative weight cycles. - The size of the `graph` will not exceed 1000 vertices. **Example**: ```python graph = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] source = 0 distances = dijkstra_shortest_path(graph, source) print(distances) # Output: [0, 3, 10, 5] ``` Write your implementation for the `dijkstra_shortest_path` function below, ensuring adherence to the above specifications and requirements. # Implementation: ```python def dijkstra_shortest_path(graph: List[List[int]], source: int) -> List[int]: import heapq n = len(graph) dist = [float(\'inf\')] * n dist[source] = 0 pq = [(0, source)] # priority queue to hold the (distance, vertex) while pq: current_dist, current_vertex = heapq.heappop(pq) # If the current distance is greater than the already found shortest distance, skip if current_dist > dist[current_vertex]: continue # Explore neighbors for neighbor in range(n): weight = graph[current_vertex][neighbor] if weight < float(\'inf\'): # There is an edge distance = current_dist + weight # Only consider this new path if its better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist ```","solution":"from typing import List def dijkstra_shortest_path(graph: List[List[int]], source: int) -> List[int]: import heapq n = len(graph) dist = [float(\'inf\')] * n dist[source] = 0 pq = [(0, source)] # priority queue to hold the (distance, vertex) while pq: current_dist, current_vertex = heapq.heappop(pq) # If the current distance is greater than the already found shortest distance, skip if current_dist > dist[current_vertex]: continue # Explore neighbors for neighbor in range(n): weight = graph[current_vertex][neighbor] if weight < float(\'inf\'): # There is an edge distance = current_dist + weight # Only consider this new path if its better if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return dist"},{"question":"# Scenario You are tasked with creating a system to analyze customer feedback from a series of online reviews. Each review contains both the text of the feedback and a numerical rating. Your goal is to categorize these reviews based on their sentiment (positive, negative, neutral) and analyze the overall rating trends. # Problem Statement Implement the `analyze_reviews` function which processes a list of review data, categorizes each review sentiment, and calculates the average rating for each sentiment category. # Function Signature ```python def analyze_reviews(reviews: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[float, Dict[str, float]]]: ``` # Input * `reviews` (List[Dict[str, Union[str, int]]]): A list of dictionaries where each dictionary contains: - `review` (str): The text of the customer\'s review. - `rating` (int): The customer\'s rating, an integer between 1 and 5. # Output * Returns a dictionary containing: - An average rating for \'positive\' reviews: Reviews with ratings greater than 3. - An average rating for \'negative\' reviews: Reviews with ratings less than 3. - An average rating for \'neutral\' reviews: Reviews with ratings equal to 3. - A dictionary summarizing the number of reviews in each sentiment category. # Exception Handling * Handle cases where the `rating` is not within the range of 1 to 5 appropriately by ignoring those entries. # Constraints * Ensure to process a large number of reviews efficiently. # Example ```python # Example usage of analyze_reviews reviews = [ {\\"review\\": \\"Great product, very useful!\\", \\"rating\\": 5}, {\\"review\\": \\"Not what I expected, quality could be better\\", \\"rating\\": 2}, {\\"review\\": \\"Average experience\\", \\"rating\\": 3}, {\\"review\\": \\"Excellent quality and fast shipping\\", \\"rating\\": 4}, {\\"review\\": \\"Terrible service, very disappointed\\", \\"rating\\": 1} ] expected_output = { \\"positive_avg_rating\\": 4.5, \\"negative_avg_rating\\": 1.5, \\"neutral_avg_rating\\": 3, \\"summary\\": { \\"positive\\": 2, \\"negative\\": 2, \\"neutral\\": 1 } } result = analyze_reviews(reviews) assert result == expected_output ``` # Test Cases Ensure your function passes the following test cases: 1. `analyze_reviews([{\\"review\\": \\"Decent product\\", \\"rating\\": 3}])` should return `{\'positive_avg_rating\': None, \'negative_avg_rating\': None, \'neutral_avg_rating\': 3.0, \'summary\': {\'positive\': 0, \'negative\': 0, \'neutral\': 1}}` 2. `analyze_reviews([{\\"review\\": \\"Excellent!\\", \\"rating\\": 5}, {\\"review\\": \\"Bad experience\\", \\"rating\\": 1}])` should return `{\'positive_avg_rating\': 5.0, \'negative_avg_rating\': 1.0, \'neutral_avg_rating\': None, \'summary\': {\'positive\': 1, \'negative\': 1, \'neutral\': 0}}` 3. `analyze_reviews([])` should return `{\'positive_avg_rating\': None, \'negative_avg_rating\': None, \'neutral_avg_rating\': None, \'summary\': {\'positive\': 0, \'negative\': 0, \'neutral\': 0}}`","solution":"from typing import List, Dict, Union def analyze_reviews(reviews: List[Dict[str, Union[str, int]]]) -> Dict[str, Union[float, Dict[str, float]]]: positive_reviews = [review[\'rating\'] for review in reviews if 4 <= review[\'rating\'] <= 5] negative_reviews = [review[\'rating\'] for review in reviews if 1 <= review[\'rating\'] <= 2] neutral_reviews = [review[\'rating\'] for review in reviews if review[\'rating\'] == 3] positive_avg_rating = sum(positive_reviews) / len(positive_reviews) if positive_reviews else None negative_avg_rating = sum(negative_reviews) / len(negative_reviews) if negative_reviews else None neutral_avg_rating = sum(neutral_reviews) / len(neutral_reviews) if neutral_reviews else None summary = { \\"positive\\": len(positive_reviews), \\"negative\\": len(negative_reviews), \\"neutral\\": len(neutral_reviews) } return { \\"positive_avg_rating\\": positive_avg_rating, \\"negative_avg_rating\\": negative_avg_rating, \\"neutral_avg_rating\\": neutral_avg_rating, \\"summary\\": summary }"},{"question":"**Scenario**: You are given a string where each character represents a type of task. Some tasks are repeatable, and some tasks must be completed only once. The tasks must be completed in one go without breaks. However, if a task appears more than once in the given string, you must leave a gap of at least one other task between them. # Task Write a function `task_scheduler(tasks: str) -> bool` that takes a string of characters representing tasks and returns a boolean indicating whether it is possible to schedule the tasks such that no task is repeated without a gap of at least one task in between. # Input * A string `tasks` where 1 <= `len(tasks)` <= 10^5. # Output * A boolean value `True` if it is possible to schedule the tasks as required, otherwise `False`. # Constraints * The function must consider the possible presence of different types of tasks and their required gaps. * Aim for O(n) time complexity. # Examples ```python >>> task_scheduler(\\"abac\\") True >>> task_scheduler(\\"aa\\") False >>> task_scheduler(\\"abcabc\\") True >>> task_scheduler(\\"ab\\") True >>> task_scheduler(\\"aaa\\") False ``` # Note * In the first example, tasks can be scheduled as \\"abac\\". * In the second example, it\'s impossible to schedule tasks without violating the gap requirement. * Consider edge cases, such as a string with a single character or strings with multiple repeating characters. **Function Signature** ```python def task_scheduler(tasks: str) -> bool: ```","solution":"def task_scheduler(tasks: str) -> bool: Returns True if it\'s possible to schedule the tasks without any task repeating without a gap of at least one task in between, otherwise False. from collections import Counter task_count = Counter(tasks) max_freq = max(task_count.values()) # Calculate number of potential slots between the most frequent task occurrences required_slots = (max_freq - 1) # Calculate number of tasks left excluding the most frequent task slots_fillable = len(tasks) - max_freq return slots_fillable >= required_slots"},{"question":"# **Question: Zigzag Traversal of a Binary Tree** You are provided with a binary tree, and you need to develop two functionalities: 1. **Zigzag Level Order Traversal**: Implement a function `zigzag_level_order` that returns the zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level, and alternate between). 2. **Retrieve Specific Level Nodes**: Implement a function `get_level_nodes(root, level)` that returns the list of node values at a specific level of the tree. TreeNode Class ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Input 1. For the zigzag traversal function: - `root`: The root node of the binary tree. 2. For the function to retrieve specific level nodes: - `root`: The root node of the binary tree. - `level`: An integer representing the level (0-indexed) to retrieve nodes from. Output 1. For the zigzag traversal function: - A list of lists, where each inner list contains node values of one level. 2. For the function to retrieve nodes of a specific level: - Returns a list of integers located at the specified level in the binary tree. # Example 1. **Zigzag Level Order Traversal**: ```python # Binary Tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(zigzag_level_order(root)) # Output: [[3], [20, 9], [15, 7]] ``` 2. **Retrieve Specific Level Nodes**: ```python # Using the same binary tree as above level = 1 print(get_level_nodes(root, level)) # Output: [9, 20] level = 2 print(get_level_nodes(root, level)) # Output: [15, 7] ``` # Requirements * Implement the `zigzag_level_order` function. * Implement the `get_level_nodes` function. * Ensure proper handling of edge cases. * Maintain efficient time and space complexity.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def zigzag_level_order(root): if not root: return [] result = [] current_level = [root] left_to_right = True while current_level: level_values = [node.val for node in current_level] result.append(level_values if left_to_right else level_values[::-1]) next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level left_to_right = not left_to_right return result def get_level_nodes(root, level): if not root: return [] current_level = [root] current_depth = 0 while current_level and current_depth < level: next_level = [] for node in current_level: if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) current_level = next_level current_depth += 1 return [node.val for node in current_level] if current_depth == level else []"},{"question":"# Programming Assessment: Task Management API You are tasked with enhancing an existing class `TaskManager` to add new functionalities for managing tasks more efficiently and ensure data integrity. The `TaskManager` class handles creation, retrieval, and deletion of tasks managed using an internal task list. Scenario Your company has a task management application, and you need to implement additional features to improve the task management functionality. Specifically, you need to ensure the tasks can be added, retrieved, and managed efficiently, with data integrity controls for concurrent access. # Task Details: 1. **Function Implementation**: - **Method 1**: Implement `add_task` method to add a new task to the task list with a unique task ID. - **Method 2**: Implement `get_all_tasks` method to retrieve all tasks concurrently. - **Method 3**: Implement `delete_task` method to remove a task by its ID with data integrity checks for concurrent modifications. 2. **Expected Input and Output**: - **add_task**: - Input: `task_name` (str), `task_details` (dict) - Output: Unique task ID (str) - **get_all_tasks**: - Input: None - Output: List of all tasks (List[dict]) - **delete_task**: - Input: `task_id` (str) - Output: Boolean indicating success or failure of the operation. 3. **Constraints and Limitations**: - Ensure the methods handle concurrent access and modifications gracefully. - Use appropriate data structures and locking mechanisms to ensure data integrity. 4. **Performance Requirements**: - Efficiently manage tasks with minimal latency and ensure thread-safe operations. - Use concurrent programming techniques where applicable. # Method Signatures: ```python import threading from typing import List, Dict class TaskManager: def __init__(self): self.tasks = {} self.lock = threading.Lock() self.task_id_counter = 0 def add_task(self, task_name: str, task_details: dict) -> str: pass def get_all_tasks(self) -> List[dict]: pass def delete_task(self, task_id: str) -> bool: pass ``` # Notes: - Use Python’s `threading` library for managing concurrent modifications. - Ensure that the class and methods are thread-safe. - Tasks can be represented as dictionaries with at least `task_name`, `task_details`, and `task_id` keys. # Example: ```python # Example usage of the TaskManager class task_manager = TaskManager() # Adding a task task_id = task_manager.add_task(\\"Sample Task\\", {\\"description\\": \\"This is a sample task\\"}) print(f\\"Task added with ID: {task_id}\\") # Retrieving all tasks tasks = task_manager.get_all_tasks() print(\\"All tasks:\\", tasks) # Deleting a task success = task_manager.delete_task(task_id) if success: print(f\\"Task with ID {task_id} deleted successfully.\\") else: print(f\\"Failed to delete task with ID {task_id}.\\") ``` Complete the methods and ensure they work as described.","solution":"import threading from typing import List, Dict class TaskManager: def __init__(self): self.tasks = {} self.lock = threading.Lock() self.task_id_counter = 0 def add_task(self, task_name: str, task_details: dict) -> str: with self.lock: self.task_id_counter += 1 task_id = str(self.task_id_counter) self.tasks[task_id] = { \'task_id\': task_id, \'task_name\': task_name, \'task_details\': task_details } return task_id def get_all_tasks(self) -> List[dict]: with self.lock: return list(self.tasks.values()) def delete_task(self, task_id: str) -> bool: with self.lock: if task_id in self.tasks: del self.tasks[task_id] return True return False"},{"question":"# Array Manipulation: Find the Missing Number Context Jamie is working on a numerical puzzle where she needs to figure out a missing number from an array containing a sequence of distinct integers. The array represents a range of numbers starting from 0 to `n`, but one number is missing from this sequence. Jamie needs an efficient way to identify this missing number. Task Implement a function `find_missing_number(arr: List[int]) -> int` that takes a list of integers `arr` and finds the single missing number in the sequence. Input Format - A list of integers `arr` where `0 <= len(arr) <= 10^5` and each integer is between `0` and `len(arr)` inclusive. Output Format - Return the missing integer from the array. Constraints - The array contains distinct integers starting from 0 up to `n` with exactly one integer missing. Examples ```python assert find_missing_number([3, 0, 1]) == 2 assert find_missing_number([9, 7, 5, 6, 3, 4, 8, 2, 0, 1]) == 10 assert find_missing_number([0]) == 1 assert find_missing_number([1, 2]) == 0 assert find_missing_number([]) == 0 ``` Requirements 1. Implement the `find_missing_number` function to determine the missing number efficiently. 2. Ensure the function performs well within the given constraints and handles edge cases properly.","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Given an array of size n containing distinct integers in the range [0, n], returns the single missing integer. n = len(arr) total_sum = n * (n + 1) / 2 actual_sum = sum(arr) return int(total_sum - actual_sum)"},{"question":"# Problem Statement You are tasked with implementing a function `merge_alternately` that takes two input strings and returns a new string formed by merging the characters of the input strings alternately. # Requirements * The function should take two strings as input and validate that both inputs are indeed strings. * It should merge characters from each string alternately. When one of the strings runs out of characters, the remaining characters from the other string should be appended to the result. # Function Signature ```python def merge_alternately(str1: str, str2: str) -> str: ``` # Input * `str1` (str): A string of any length (0 <= len(str1) <= 10^3). * `str2` (str): A string of any length (0 <= len(str2) <= 10^3). # Output * (str): A new string formed by merging the characters of `str1` and `str2` alternately. # Constraints * If either string is empty, the function should return the other string. * Both inputs must be strings. The function should assert this as part of its validation process. * Ensure your implementation handles edge cases and optimizes performance where feasible. # Examples ```python >>> merge_alternately(\\"abcd\\", \\"efgh\\") \\"aebfcgdh\\" >>> merge_alternately(\\"abc\\", \\"defgh\\") \\"adbecfgh\\" >>> merge_alternately(\\"\\", \\"xyz\\") \\"xyz\\" ``` # Notes * Ensure the function raises an error if either input is not a string: * Example: `merge_alternately(\\"abc\\", 123)` should raise an assertion error.","solution":"def merge_alternately(str1: str, str2: str) -> str: Merges two strings alternately character by character. When one string runs out of characters, the remaining characters of the other string are appended. Args: str1 (str): First input string. str2 (str): Second input string. Returns: str: A new string formed by merging characters of str1 and str2 alternately. assert isinstance(str1, str), \\"First input must be a string\\" assert isinstance(str2, str), \\"Second input must be a string\\" result = [] len_str1 = len(str1) len_str2 = len(str2) for i in range(max(len_str1, len_str2)): if i < len_str1: result.append(str1[i]) if i < len_str2: result.append(str2[i]) return \'\'.join(result)"},{"question":"# Problem: Implement a Fibonacci Sequence Generator with Memoization You are tasked with creating a class that generates Fibonacci numbers using memoization to optimize performance. The class should allow for computation of any n-th Fibonacci number efficiently by storing previously computed values to avoid redundant calculations. # Class Definition ```python class Fibonacci: def __init__(self): self.memo = {} def fib(self, n: int) -> int: pass ``` # Requirements 1. Implement the `fib` method in the `Fibonacci` class. 2. Use a recursive approach with memoization to optimize the calculation of Fibonacci numbers. 3. Store computed values in the `self.memo` dictionary to avoid recalculating them. 4. The method should handle edge cases: - `n` must be a non-negative integer. - If `n` is 0, it should return 0. - If `n` is 1, it should return 1. 5. Raise appropriate exceptions for any invalid inputs: - `n` not being a non-negative integer. # Example ```python >>> fib_gen = Fibonacci() >>> fib_gen.fib(10) 55 >>> fib_gen.fib(20) 6765 >>> fib_gen.fib(30) 832040 ``` # Constraints - `n` is a non-negative integer (0 <= n <= 10^5).","solution":"class Fibonacci: def __init__(self): self.memo = {} def fib(self, n: int) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n in self.memo: return self.memo[n] if n == 0: self.memo[n] = 0 elif n == 1: self.memo[n] = 1 else: self.memo[n] = self.fib(n - 1) + self.fib(n - 2) return self.memo[n]"},{"question":"# Problem Statement You are provided with a knapsack problem involving items with different weights and values. Given a knapsack with a fixed capacity, your task is to find the maximum total value of items that can fit into the knapsack without exceeding its capacity. You need to implement a function to solve the problem using dynamic programming. # Input and Output Format - **Input**: - An integer `W` representing the capacity of the knapsack. - Two lists `weights` and `values`, both of length `n` representing the weights and values of `n` items respectively. - **Output**: An integer representing the maximum total value that can be accommodated in the knapsack. # Constraints - The number of items `n` is in the range [1, 1000]. - The knapsack capacity `W` is in the range [1, 1000]. - The weights of items and their values are positive integers. # Performance Requirements - The algorithm should ideally run within O(n*W) time complexity. # Task Implement a function `knapsack(W: int, weights: List[int], values: List[int]) -> int` to solve the knapsack problem. # Example **Example 1:** ```python W = 4 weights = [1, 2, 3] values = [10, 15, 40] ``` Output: 50 **Example 2:** ```python W = 5 weights = [2, 3, 4] values = [4, 5, 7] ``` Output: 9","solution":"def knapsack(W, weights, values): Solve the knapsack problem to find the maximum total value of items that can fit into the knapsack. Parameters: W (int): Capacity of the knapsack weights (list): List of weights of the items values (list): List of values of the items Returns: int: The maximum total value that can be accommodated in the knapsack n = len(weights) dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(W + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][W]"},{"question":"# Problem Statement You are given a string `s` that consists of lowercase English letters and another string `t` that is also composed of lowercase English letters. You need to transform the string `s` into the string `t` using the minimum number of operations, where in one operation, you can: 1. Insert a character 2. Delete a character 3. Replace a character Implement a function `min_operations_to_transform(s: str, t: str) -> int` that returns the minimum number of operations required to transform `s` into `t`. # Input - Two strings `s` and `t` consisting only of lowercase English letters. # Output - An integer representing the minimum number of operations required to convert `s` into `t`. # Example ```python >>> min_operations_to_transform(\\"kitten\\", \\"sitting\\") 3 >>> min_operations_to_transform(\\"flaw\\", \\"lawn\\") 2 >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 ``` # Constraints - `1 ≤ len(s), len(t) ≤ 1000` # Performance Requirements - Your implementation should be efficient to handle strings of length up to 1000. Specifically, ensure your solution runs in `O(n * m)` time complexity, where `n` and `m` are the lengths of `s` and `t` respectively. # Notes - This problem is a classic dynamic programming problem known as the \\"Edit Distance\\" or \\"Levenshtein Distance\\". - Consider using a 2D array to keep track of the minimum operations needed for substrings of `s` and `t`. --- # Solution Skeleton This is an outline of how the solution should be structured: ```python def min_operations_to_transform(s: str, t: str) -> int: n, m = len(s), len(t) # Initialize the DP table dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the first row and first column for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Delete dp[i][j - 1] + 1, # Insert dp[i - 1][j - 1] + 1 # Replace ) return dp[n][m] ``` Ensure the function is thoroughly tested with various cases to validate its correctness and performance requirements.","solution":"def min_operations_to_transform(s: str, t: str) -> int: n, m = len(s), len(t) # Initialize the DP table dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the first row and first column for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Delete dp[i][j - 1] + 1, # Insert dp[i - 1][j - 1] + 1 # Replace ) return dp[n][m]"},{"question":"# Bubble Sort Optimization Challenge Context Bubble sort is a simple sorting algorithm where elements are repeatedly swapped if they are in the wrong order. While it is straightforward, it can be made more efficient by recognizing when the list is already sorted. If no swaps are made during a pass, the algorithm can terminate early. Task Write a function `optimized_bubble_sort(arr: list[int]) -> list[int]` that sorts a list of integers using an optimized version of the Bubble Sort algorithm. The optimization should stop the algorithm if it detects that the list is already sorted. Input/Output Formats * **Input**: A list of integers `arr`. * Example: `[64, 34, 25, 12, 22, 11, 90]` * **Output**: A list of integers sorted in ascending order. * Example: `[11, 12, 22, 25, 34, 64, 90]` Constraints * The input list can have up to 10^4 elements. * Each integer in the list can range between -10^6 and 10^6. Performance Requirements * The function should run efficiently for the given constraints, with an average-case time complexity of O(n^2) and a best-case complexity closer to O(n) when the input list is already sorted or nearly sorted. Example Code ```python def optimized_bubble_sort(arr: list[int]) -> list[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr # Test Cases print(optimized_bubble_sort([64, 34, 25, 12, 22, 11, 90])) # Output: [11, 12, 22, 25, 34, 64, 90] print(optimized_bubble_sort([5, 1, 4, 2, 8])) # Output: [1, 2, 4, 5, 8] print(optimized_bubble_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(optimized_bubble_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] ``` Note * The function should handle edge cases such as an empty list and lists with a single element. * Ensure the algorithm is optimized to terminate early for already sorted lists.","solution":"def optimized_bubble_sort(arr: list[int]) -> list[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr"},{"question":"# Validate an Inorder Sequence of Binary Search Tree (BST) Alice is a computer science student learning about Binary Search Trees (BST). She has an array representing the inorder traversal of a BST and wants to verify if the given array satisfies the properties of a BST\'s inorder traversal. Your task is to write a function that checks if the given array is a valid inorder traversal of a BST. Function Signature: ```python def is_valid_bst_inorder(inorder: List[int]) -> bool: pass ``` # Input * `inorder`: A list of integers representing the inorder traversal of a BST. # Output * A boolean value `True` if the given array is a valid inorder traversal, otherwise `False`. # Constraints * `1 <= len(inorder) <= 1000` * `-10^9 <= inorder[i] <= 10^9` # Example ```python assert is_valid_bst_inorder([2, 5, 8, 10, 12, 15]) == True assert is_valid_bst_inorder([2, 5, 8, 10, 10, 15]) == False # Duplicate values are not allowed in a BST assert is_valid_bst_inorder([10, 5, 15, 20]) == False # Inorder property violated ``` # Additional Requirements 1. Consider edge cases such as an empty array, arrays with a single element, and arrays with duplicate values. 2. Ensure the function runs efficiently within the constraint limits. 3. A short explanation of your approach is encouraged, including any potential edge cases considered. Implement the `is_valid_bst_inorder` function to achieve the above requirements.","solution":"from typing import List def is_valid_bst_inorder(inorder: List[int]) -> bool: Check if the given array is a valid inorder traversal of a BST. if not inorder: return True for i in range(1, len(inorder)): if inorder[i] <= inorder[i - 1]: return False return True"},{"question":"# Problem Description You are given a string containing a mix of characters and digits. Your task is to write a function that extracts all the digits from the string, concatenates them into a new string, and then converts this concatenated string into an integer. If the input string does not contain any digits, the function should return 0. # Task Write a function `extract_and_convert` that takes a single string as input and returns an integer formed by concatenating all the digits found in the input string. # Input * `input_str` (String): A string containing a mix of characters and digits. # Output * (Integer): An integer formed by concatenating all the digits found in the input string. If no digits are found, return 0. # Constraints * The input string length will be between 1 and 1000 characters. * The input string will contain only printable ASCII characters. # Performance Requirements * The solution should have a linear time complexity, i.e., O(n), where n is the length of the input string. # Example ```python def extract_and_convert(input_str: str) -> int: pass # Example usage: print(extract_and_convert(\\"abc123xyz\\")) # Output: 123 print(extract_and_convert(\\"a1b2c3\\")) # Output: 123 print(extract_and_convert(\\"abcdef\\")) # Output: 0 print(extract_and_convert(\\"123abc456\\")) # Output: 123456 ```","solution":"def extract_and_convert(input_str: str) -> int: Extracts digits from the input string, concatenates them, and returns as an integer. If no digits are found, returns 0. digits = [char for char in input_str if char.isdigit()] if digits: return int(\'\'.join(digits)) return 0"},{"question":"# Coding Assessment Question You are asked to write a function that analyzes a given network of computers and identifies whether there exists at least one path connecting every pair of computers directly or indirectly. You will be supplied with a list of connections, where each connection is represented by a tuple of two strings indicating direct communication between two computers. Assume all computer names are unique. # Function Specification Function: `is_network_connected` **Input**: - A list of tuples, where each tuple contains two strings representing a direct connection between two computers. **Output**: - A boolean indicating whether the entire network is connected (i.e., there is a path between every pair of computers). **Constraints**: - If the input list is empty, return `False` (no computers are connected). # Example ```python # Example connections = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"C\\", \\"D\\"), (\\"D\\", \\"A\\")] print(is_network_connected(connections)) # Output: True disjoint_connections = [(\\"A\\", \\"B\\"), (\\"B\\", \\"C\\"), (\\"D\\", \\"E\\")] print(is_network_connected(disjoint_connections)) # Output: False empty_connections = [] print(is_network_connected(empty_connections)) # Output: False single_connection = [(\\"A\\", \\"B\\")] print(is_network_connected(single_connection)) # Output: True ``` # Approach - Use graph theory concepts (e.g., Depth-First Search (DFS) or Breadth-First Search (BFS)) to analyze the connectivity of the network. - Ensure efficient traversal of the network with a goal of linear time complexity relative to the number of connections.","solution":"def is_network_connected(connections): if not connections: return False # Create an adjacency list from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # Use a set to track visited nodes visited = set() # Perform DFS/BFS from any node (let\'s use the first node from connections) def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Start traversal from the first node in the connections list start_node = connections[0][0] visited.add(start_node) bfs(start_node) # All nodes in the graph should be visited if the network is connected return len(visited) == len(graph)"},{"question":"# Question: Neural Network Layer Implementation In the context of deep learning, you are tasked with implementing a custom dense (fully connected) layer that can be used as part of a neural network. This layer should be able to perform forward passes as well as backward passes during training, updating its parameters using gradient descent. # Function Requirements 1. **Dense Layer Implementation**: - **Class Name**: `DenseLayer` - **Initialize Parameters**: - `input_dim` (int): Number of input features. - `output_dim` (int): Number of output features. - `learning_rate` (float): The learning rate for updating the weights during training. - **Methods**: 1. **`__init__(self, input_dim, output_dim, learning_rate)`**: - Initialize the weights and biases randomly. Weights should be of shape `(input_dim, output_dim)` and biases should be of shape `(output_dim,)`. 2. **`forward(self, input_data)`**: - Perform the forward pass. - **Parameters**: - `input_data` (ndarray): A 2D NumPy array of shape `(n_samples, input_dim)`. - **Returns**: - A 2D NumPy array of shape `(n_samples, output_dim)`. 3. **`backward(self, input_data, grad_output)`**: - Perform the backward pass, computing the gradients and updating the weights and biases. - **Parameters**: - `input_data` (ndarray): A 2D NumPy array of shape `(n_samples, input_dim)`. - `grad_output` (ndarray): A 2D NumPy array of shape `(n_samples, output_dim)` representing the gradient of the loss with respect to the output of this layer. - **Returns**: - A 2D NumPy array of shape `(n_samples, input_dim)` representing the gradient of the loss with respect to the input of this layer. # Constraints - `input_dim` and `output_dim` will always be positive integers. - `learning_rate` will always be a positive floating point number. - Use only NumPy; any other dependency will cause the solution to be rejected. # Performance Requirements - The forward and backward passes should be optimized to handle up to `n_samples = 1000` and `input_dim = 1000` efficiently. # Example Given the input data as shown below: ```python input_data = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]) grad_output = np.array([[1.0, 2.0], [3.0, 4.0]]) ``` **Initialization Example Call**: ```python layer = DenseLayer(input_dim=3, output_dim=2, learning_rate=0.01) ``` **Forward Pass Example Call**: ```python output = layer.forward(input_data) ``` **Backward Pass Example Call**: ```python grad_input = layer.backward(input_data, grad_output) ``` Write your implementation for the `DenseLayer` class, ensuring that it correctly performs both forward and backward operations as specified.","solution":"import numpy as np class DenseLayer: def __init__(self, input_dim, output_dim, learning_rate): self.input_dim = input_dim self.output_dim = output_dim self.learning_rate = learning_rate self.weights = np.random.randn(input_dim, output_dim) * 0.01 self.biases = np.zeros(output_dim) def forward(self, input_data): self.input_data = input_data return np.dot(input_data, self.weights) + self.biases def backward(self, input_data, grad_output): grad_input = np.dot(grad_output, self.weights.T) grad_weights = np.dot(input_data.T, grad_output) grad_biases = np.sum(grad_output, axis=0) # Update parameters self.weights -= self.learning_rate * grad_weights self.biases -= self.learning_rate * grad_biases return grad_input"},{"question":"# Coding Assessment Question Context You are given a class `RangedSet` that represents ranges of integers with inclusion and exclusion intervals. Problem Statement Implement the following function: ```python def find_intersection(range_a: RangedSet, range_b: RangedSet) -> List[Tuple[int, int]]: Finds the intersection of two ranged sets. Args: range_a (RangedSet): The first ranged set. range_b (RangedSet): The second ranged set. Returns: List[Tuple[int, int]]: A list of tuples representing the intersecting ranges. pass ``` Definition The intersection of two ranges is the set of integers that are common to both ranged sets. Input - `range_a` and `range_b`: Instances of the `RangedSet` class representing ranged sets. Output - A list of tuples where each tuple is of the form `(start, end)`, representing the intersecting ranges. Constraints - ( -10^6 leq text{start}, text{end} leq 10^6 ) - A range is represented as `(start, end)` where `start <= end` - You may assume the list of ranges in each `RangedSet` instance is sorted by start points and non-overlapping. Examples ```python # Example 1 range_a = RangedSet([(1, 5), (10, 15)]) range_b = RangedSet([(3, 7), (12, 18)]) assert find_intersection(range_a, range_b) == [(3, 5), (12, 15)] # Example 2 range_c = RangedSet([(-5, -3), (0, 2)]) range_d = RangedSet([(-10, -6), (1, 3)]) assert find_intersection(range_c, range_d) == [(-5, -6), (1, 2)] ``` Notes 1. The intersection of two ranges `(a, b)` and `(c, d)` is `(max(a, c), min(b, d))` if they overlap. 2. Empty intersections should not be included in the output. 3. Handle edge cases where there might be multiple intersecting sub-ranges within the given ranges.","solution":"from typing import List, Tuple class RangedSet: def __init__(self, ranges: List[Tuple[int, int]]): self.ranges = ranges def find_intersection(range_a: RangedSet, range_b: RangedSet) -> List[Tuple[int, int]]: a_ranges = range_a.ranges b_ranges = range_b.ranges i, j = 0, 0 intersections = [] while i < len(a_ranges) and j < len(b_ranges): a_start, a_end = a_ranges[i] b_start, b_end = b_ranges[j] # Find the intersection start = max(a_start, b_start) end = min(a_end, b_end) if start <= end: intersections.append((start, end)) # Move to the next interval if a_end < b_end: i += 1 else: j += 1 return intersections"},{"question":"# Coding Question: Sentence Capitalization in a Document Your task is to implement a feature for a text editor that capitalizes the first letter of each sentence within a document. A sentence is considered to end with any one of the following punctuation marks: `.`, `?`, `!`. After a punctuation mark, the next non-space character should be capitalized if it is a letter. Ensure that multiple consecutive spaces do not affect the function\'s operation. You will write a function `capitalize_sentences(document: str) -> str`. Input: * The function will take a single argument, `document`, which is a string containing sentences. Output: * The function should return the document with the first letter of each sentence capitalized. Constraints: * The `document` can contain uppercase and lowercase letters, digits, spaces, and punctuation marks. * The `document` length will not exceed 10,000 characters. * There may be multiple consecutive punctuation marks and spaces. # Example: ```python def capitalize_sentences(document: str) -> str: >>> capitalize_sentences(\\"hello world. this is a test! do you understand?great.\\") \'Hello world. This is a test! Do you understand?Great.\' >>> capitalize_sentences(\\" hello .this is another test.\\") \' Hello .This is another test.\' >>> capitalize_sentences(\\"multiple...spaces! confusion? spaces.\\") \'Multiple...Spaces! Confusion? Spaces.\' # Your solution should go here ``` # Notes: * Make sure to handle edge cases, such as multiple consecutive punctuation marks and spaces. * The function should be optimized to handle large documents efficiently. * Special characters and digits should not be capitalized. Only alphabetical characters after a sentence-ending punctuation mark are subject to capitalization.","solution":"def capitalize_sentences(document: str) -> str: Capitalizes the first letter of each sentence in a given document. A sentence is considered to end with ., ?, or ! if not document: return document # Convert the document string to a list to mutate characters efficiently result = list(document) capitalize_next = True for i in range(len(result)): if capitalize_next and result[i].isalpha(): result[i] = result[i].upper() capitalize_next = False if result[i] in \'.!?\': capitalize_next = True return \\"\\".join(result)"},{"question":"# Sorting Colors in Linear Time Problem Statement: You are given an array `nums` containing `n` objects colored red, white, or blue, represented by integers `0`, `1`, and `2` respectively. Your task is to sort the array in-place so that objects of the same color are adjacent and in the order of red, white, and blue. This problem is often referred to as the Dutch National Flag problem. Function Signature: ```python def sort_colors(nums: list[int]) -> None: ``` Parameters: - `nums (list[int])`: A list of integers representing the color of each object. The integers are `0` for red, `1` for white, and `2` for blue. Constraints: - `1 <= len(nums) <= 300` - `nums[i]` is either `0`, `1`, or `2`. Notes: - You should implement the sorting in a single pass and in-place, using a constant amount of extra space. Examples: ```python sort_colors([2, 0, 2, 1, 1, 0]) # After function call, nums will be modified to [0, 0, 1, 1, 2, 2] sort_colors([2, 0, 1]) # After function call, nums will be modified to [0, 1, 2] sort_colors([0]) # After function call, nums will be modified to [0] ```","solution":"def sort_colors(nums: list[int]) -> None: Sorts the colors in-place such that objects of the same color are adjacent, with the order being red (0), white (1), and blue (2). low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Objective Implement a function that simulates a simple bank transaction system, allowing for deposits, withdrawals, and balance checks, incorporating basic error checking and ensuring account consistency. # Scenario You need to develop a class `SimpleBankAccount` that supports basic banking operations with account balance management and error handling for invalid operations. # Task - Implement the `SimpleBankAccount` class with the following methods: 1. `__init__(self, initial_balance: float = 0.0) -> None`: Initializes the bank account with an optional initial balance. 2. `deposit(self, amount: float) -> None`: Adds a specified amount to the account balance. 3. `withdraw(self, amount: float) -> None`: Subtracts a specified amount from the account balance, provided sufficient funds are available. 4. `get_balance(self) -> float`: Returns the current account balance. # Implementation Details 1. **Characteristics**: - The initial balance can be zero or any positive value. - Deposit amounts must be positive. - Withdrawals must not exceed the available balance. 2. **Input/Output**: - `__init__`: Initializes the bank account with an optional initial balance. - Input: initial_balance (optional, default: 0.0) - Output: None - `deposit`: Adds amount to the account balance. - Input: amount: float - Output: None - `withdraw`: Deducts amount from the account balance. - Input: amount: float - Output: None - `get_balance`: Returns the current account balance. - Input: None - Output: current balance: float 3. **Constraints**: - All monetary amounts should be non-negative. - Withdrawals should not result in a negative balance. - Ensure precision for financial calculations (use appropriate data types or handling methods). # Example ```python account = SimpleBankAccount(initial_balance=100.0) print(account.get_balance()) # Output: 100.0 account.deposit(50.0) print(account.get_balance()) # Output: 150.0 account.withdraw(20.0) print(account.get_balance()) # Output: 130.0 account.withdraw(200.0) # Should raise an error or print a message indicating insufficient funds. ``` 4. **Performance Requirements**: - The solution should be efficient in terms of both processing speed and memory, handling numerous transactions smoothly. ****** Your task is to ensure the implementation of the `SimpleBankAccount` class adheres to the described specifications and handles all edge cases appropriately.","solution":"class SimpleBankAccount: def __init__(self, initial_balance: float = 0.0) -> None: if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self._balance = initial_balance def deposit(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Deposit amount must be positive.\\") self._balance += amount def withdraw(self, amount: float) -> None: if amount <= 0: raise ValueError(\\"Withdrawal amount must be positive.\\") if amount > self._balance: raise ValueError(\\"Insufficient funds for withdrawal.\\") self._balance -= amount def get_balance(self) -> float: return self._balance"},{"question":"# Coding Assessment Question Question: Balanced Bracket Sequence You are required to implement the function `is_balanced_bracket_sequence`. Given a string consisting of brackets `({[`, and `]})`, the function should return `True` if the sequence of brackets is balanced and `False` otherwise. A sequence is considered balanced if the brackets are opened and closed in a correctly nested manner. Function Signature ```python def is_balanced_bracket_sequence(s: str) -> bool: ``` Input - `s` (str): A string consisting of only these characters `({[`, and `]})`. Output - returns: `True` if the bracket sequence is balanced, `False` otherwise. Constraints - The input string length can be up to (10^3) characters. - The string consists of only the characters `({[`, and `]})`. Examples ```python assert is_balanced_bracket_sequence(\\"()\\") == True assert is_balanced_bracket_sequence(\\"([{}])\\") == True assert is_balanced_bracket_sequence(\\"{[}\\") == False assert is_balanced_bracket_sequence(\\"\\") == True assert is_balanced_bracket_sequence(\\"{[(])}\\") == False ``` # Scenario You have been tasked to write a function validating the usage of brackets in the coding materials being submitted to ensure that the syntax of code snippets follows a balanced and nested structure. This will help in pre-validating code before passing it to the compiler or interpreter.","solution":"def is_balanced_bracket_sequence(s: str) -> bool: Checks if the bracket sequence is balanced. Parameters: - s (str): A string consisting of only the characters ({[ and ]}) Returns: - bool: True if the bracket sequence is balanced, False otherwise. stack = [] bracket_map = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} for char in s: if char in bracket_map: stack.append(char) else: if not stack or bracket_map[stack.pop()] != char: return False return not stack"},{"question":"Problem: Spell Checker with Trie Implement a basic spell checker using a Trie data structure. The spell checker will allow adding words to the dictionary and checking if a given word exists in the dictionary. # Input 1. A list of strings **dictionary** containing the words to be added to the trie initially. (1 <= |dictionary| <= 10^4, 1 <= |dictionary[i]| <= 100) 2. A list of strings **words** to be checked if they exist in the dictionary. (1 <= |words| <= 10^3, 1 <= |words[i]| <= 100) # Output 1. A list of boolean values indicating if each word in the **words** list exists in the dictionary. # Function Signature ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: pass def search_word(self, word: str) -> bool: pass def spell_checker(dictionary: List[str], words: List[str]) -> List[bool]: pass ``` # Constraints - All words in the dictionary and the words list will consist of lowercase alphabetical characters only. # Examples Example 1: ```python dictionary = [\\"apple\\", \\"banana\\", \\"grape\\", \\"kiwi\\"] words = [\\"apple\\", \\"grapefruit\\", \\"kiwi\\", \\"banana\\", \\"pear\\"] print(spell_checker(dictionary, words)) # Output: [True, False, True, True, False] ``` Example 2: ```python dictionary = [\\"hello\\", \\"world\\"] words = [\\"hello\\", \\"wrld\\"] print(spell_checker(dictionary, words)) # Output: [True, False] ``` # Notes 1. You should implement a `Trie` class containing methods to add words and search for words. 2. The `spell_checker` function should create a `Trie`, add all words from the dictionary to the `Trie`, and then check each word in the `words` list for existence in the `Trie`. Return the results as a list of boolean values. 3. Efficiently handling the large input size will be crucial for performance.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search_word(self, word: str) -> bool: current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def spell_checker(dictionary: List[str], words: List[str]) -> List[bool]: trie = Trie() for word in dictionary: trie.add_word(word) return [trie.search_word(word) for word in words]"},{"question":"# Merge K Sorted Lists Problem Statement: You are given `k` sorted linked lists, each represented by a `ListNode` object. Your task is to merge all these lists into one sorted linked list. Implement this using both a **priority queue (min-heap)** approach and a **divide and conquer** approach. Function Signatures: 1. `def merge_k_lists(lists: list[ListNode]) -> ListNode` Input: - `lists`: A list of `ListNode` objects representing the heads of `k` sorted linked lists. Output: - Return the head of the merged sorted linked list. Constraints: - The total number of nodes across all `k` lists will be in the range [0, 10^4]. - The values of the nodes are in the range [-10^4, 10^4]. Performance Requirements: - Ensure that your solution achieves O(N log k) time complexity for merging, where N is the total number of nodes. - The space complexity should be optimized accordingly. Testing: You should validate your solutions using various test cases including edge cases such as: - Empty lists - Lists with single elements - Lists with a large number of nodes Example: ```python # Define the ListNode class class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example Input lists = [ ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6)) ] # Example Output # Merged list should be: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 # Function call result = merge_k_lists(lists) # Output the merged list while result: print(result.val, end=\\" -> \\") result = result.next # Expected output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 -> ``` # Additional Requirements: - Implement the `ListNode` class if not provided as part of the environment. - Ensure the input linked lists are properly initialized and connected in your test cases. - Provide detailed comments and document your approach for each method used (priority queue and divide and conquer). Integrate the new question seamlessly with the original set of questions while maintaining the style, length, complexity, and scope.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into a single sorted linked list using a priority queue. if not lists: return None # Priority queue to manage list heads min_heap = [] for idx, l in enumerate(lists): if l: heapq.heappush(min_heap, (l.val, idx, l)) head = ListNode(None) current = head while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return head.next"},{"question":"# Problem You are tasked with developing a basic file system simulation with the ability to navigate directories, create files, and retrieve file contents. Your job is to implement a function that processes a series of commands to manipulate a virtual file system and returns the result of any file reads. # Function Signature ```python def simulate_file_system(commands: List[str]) -> List[str]: pass ``` # Parameters - **commands** `(List[str])`: List of strings representing commands to be executed on the file system. Each command is formatted as follows: - `\\"mkdir <directory>\\"`: Creates a new directory at the current path. - `\\"cd <directory>\\"`: Changes the current directory to the specified one (use `\\"..\\"` to move up one level). - `\\"touch <file>\\"`: Creates a new file at the current path. - `\\"write <file> <content>\\"`: Writes the specified content to the file (overwrites if the file already has content). - `\\"read <file>\\"`: Reads the content of the specified file and outputs it. # Returns - **result** `(List[str])`: A list of strings representing the output of `read` commands in the order they were executed. # Detailed Requirements 1. **Initialization**: - Start with a root directory `\\"/\\"`. 2. **Command Processing**: - `\\"mkdir <directory>\\"`: Create a new directory within the current directory. - `\\"cd <directory>\\"`: Navigate to the specified directory or move up one level with `\\"..\\"`. - `\\"touch <file>\\"`: Create a new file within the current directory. - `\\"write <file> <content>\\"`: Overwrite the content of the specified file with new content. - `\\"read <file>\\"`: Output the content of the specified file. If the file does not exist, output an empty string. 3. **Support Nested Directories**: - Allow for creation and navigation through nested directories. 4. **Return Outputs**: - Collect and return the results of all `read` commands as a list of strings. # Example ```python commands = [ \\"mkdir home\\", \\"cd home\\", \\"mkdir user\\", \\"cd user\\", \\"touch notes.txt\\", \\"write notes.txt Hello\\", \\"read notes.txt\\", \\"cd ..\\", \\"touch log.txt\\", \\"write log.txt System Log\\", \\"read log.txt\\", \\"cd ..\\", \\"read nonexistent.txt\\" ] result = simulate_file_system(commands) print(result) # Output: [\'Hello\', \'System Log\', \'\'] ``` In this example, the function processes the series of commands, creates directories, navigates through them, creates files, writes to files, and reads from them. The output list contains the results of the `read` commands, in the order they were executed.","solution":"from typing import List class FileSystem: def __init__(self): self.root = {} self.current_dir = self.root self.path = [] def mkdir(self, directory: str): if directory not in self.current_dir: self.current_dir[directory] = {} def cd(self, directory: str): if directory == \\"..\\": if self.path: self.current_dir = self.root for dir in self.path[:-1]: self.current_dir = self.current_dir[dir] self.path.pop() else: if directory in self.current_dir: self.current_dir = self.current_dir[directory] self.path.append(directory) def touch(self, file: str): self.current_dir[file] = \\"\\" def write(self, file: str, content: str): if file in self.current_dir: self.current_dir[file] = content def read(self, file: str) -> str: return self.current_dir.get(file, \\"\\") def simulate_file_system(commands: List[str]) -> List[str]: fs = FileSystem() result = [] for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"mkdir\\": fs.mkdir(parts[1]) elif cmd == \\"cd\\": fs.cd(parts[1]) elif cmd == \\"touch\\": fs.touch(parts[1]) elif cmd == \\"write\\": fs.write(parts[1], \\" \\".join(parts[2:])) elif cmd == \\"read\\": result.append(fs.read(parts[1])) return result"},{"question":"Problem Statement You are given an array of integers, `arr`, and a target integer, `target`. Your task is to determine if there are two distinct integers in the array whose sum is exactly equal to the target. # Function Signature ```python def two_sum(arr: List[int], target: int) -> bool: ``` # Input * A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5). * An integer `target` (|target| ≤ 10^9). # Output * Return `True` if there are two distinct integers in the array whose sum equals `target`, otherwise return `False`. # Examples ```python # Example 1 arr = [2, 7, 11, 15] target = 9 print(two_sum(arr, target)) # Expected output: True (2 + 7 = 9) # Example 2 arr = [1, 2, 3, 4, 5] target = 10 print(two_sum(arr, target)) # Expected output: False (No two numbers sum up to 10) # Example 3 arr = [5, 1, -3, 8, 12] target = 9 print(two_sum(arr, target)) # Expected output: True (1 + 8 = 9) ``` # Explanation: * Utilize a hash set to store the numbers we\'ve seen so far. * For each number in the array, check if the complement (target - current number) exists in the hash set. * If the complement is found, return `True`. * If no such pair is found after checking all numbers, return `False`. # Note - Ensure that the solution has an optimal time complexity for large arrays (up to O(n)).","solution":"def two_sum(arr, target): Returns True if there are two distinct integers in the array whose sum equals the target, otherwise returns False. seen = set() for num in arr: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"# Question You are required to implement a function that calculates the number of distinct prime factors of a given integer. This function will leverage the Sieve of Eratosthenes for efficient prime number generation. # Objective Write a function `count_distinct_prime_factors(n: int) -> int` that returns the number of distinct prime factors of `n`. # Specifications - **Input**: - `n` (int): A positive integer where 2 ≤ n ≤ 10^5. - **Output**: - An integer representing the number of distinct prime factors of `n`. # Constraints - Your solution should be efficient in terms of time and space complexity, considering the input constraints. - Handle edge cases appropriately. # Example ```python >>> count_distinct_prime_factors(28) 2 >>> count_distinct_prime_factors(18) 2 >>> count_distinct_prime_factors(29) 1 ``` # Notes You can use the following helper function for generating a list of prime numbers up to a given limit using the Sieve of Eratosthenes: ```python def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers ```","solution":"def count_distinct_prime_factors(n: int) -> int: Returns the number of distinct prime factors of n. def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while p * p <= limit: if is_prime[p]: for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers primes = sieve_of_eratosthenes(int(n**0.5)) count = 0 for prime in primes: if n % prime == 0: count += 1 while n % prime == 0: n //= prime if n > 1: count += 1 return count"},{"question":"# Problem Statement Objective Write a function `reverse_substrings(input_str: str, separator: str) -> str` that reverses the order of substrings in the given input string based on the specified separator. Constraints - The function must take two arguments: a string `input_str` and a string `separator`. - The function should raise a `ValueError` if the `separator` is an empty string. - The function should raise a `TypeError` if either `input_str` or `separator` are not strings. Input - `input_str` (str): The input string which may contain multiple substrings separated by the `separator`. - `separator` (str): The delimiter used to split the `input_str` into substrings. Output - The function should return a string with substrings in reverse order, while maintaining their individual content intact. Examples ```python >>> reverse_substrings(\\"hello-world-this-is-python\\", \\"-\\") \'python-is-this-world-hello\' >>> reverse_substrings(\\"123|456|789\\", \\"|\\") \'789|456|123\' >>> reverse_substrings(\\"one.two.three.four\\", \\".\\") \'four.three.two.one\' >>> reverse_substrings(\\"a b c d\\", \\" \\") \'d c b a\' >>> reverse_substrings(\\"example\\", \\";\\") \'example\' >>> reverse_substrings(\\"example\\", \\"\\") Traceback (most recent call last): ... ValueError: Separator cannot be an empty string >>> reverse_substrings(12345, \\";\\") Traceback (most recent call last): ... TypeError: Input value of [input_str=12345] must be a string >>> reverse_substrings(\\"example\\", 5) Traceback (most recent call last): ... TypeError: Input value of [separator=5] must be a string ``` # Performance Requirements - The function should operate in O(n) time complexity, where n is the length of the input string. - The function should use O(n) additional space.","solution":"def reverse_substrings(input_str: str, separator: str) -> str: Reverses the order of substrings in the given input string based on the specified separator. Parameters: - input_str (str): The input string containing substrings separated by the separator. - separator (str): The delimiter used to split the input_str into substrings. Returns: - str: A string with substrings in reverse order. Raises: - ValueError: If the separator is an empty string. - TypeError: If either input_str or separator are not strings. if not isinstance(input_str, str): raise TypeError(f\\"Input value of [input_str={input_str}] must be a string\\") if not isinstance(separator, str): raise TypeError(f\\"Input value of [separator={separator}] must be a string\\") if separator == \\"\\": raise ValueError(\\"Separator cannot be an empty string\\") substrings = input_str.split(separator) reversed_substrings = substrings[::-1] return separator.join(reversed_substrings)"},{"question":"# Question: Implement a Memory-Optimized Version of the Dijkstra\'s Shortest Path Algorithm **Background:** Dijkstra\'s Algorithm is a popular method used to find the shortest path from a source node to all other nodes in a weighted graph with non-negative weights. However, it can be memory-intensive for very large graphs. **Task:** Implement a memory-optimized version of Dijkstra\'s Algorithm in Python. The optimization should include only storing necessary predecessors and distances to reduce space complexity. **Function Signature:** ```python import heapq class Graph: def __init__(self, num_of_nodes: int) -> None: # Initialization function def add_edge(self, u_node: int, v_node: int, weight: int) -> None: # Adds a directed edge to the graph def dijkstra(self, start_node: int) -> list[int]: # Executes Dijkstra\'s Algorithm and returns the shortest distances from the start_node ``` **Expected Input and Output Formats:** - `__init__(num_of_nodes: int)`: initializes a graph with `num_of_nodes` nodes. - `add_edge(u_node: int, v_node: int, weight: int)`: adds a directed edge from `u_node` to `v_node` with the given `weight`. - `dijkstra(start_node: int) -> list[int]`: executes Dijkstra\'s Algorithm from `start_node` and returns a list of the shortest distances from `start_node` to each node. If a node is unreachable, the distance should be represented as `float(\'inf\')`. **Constraints:** 1. All edges will have non-negative weights. 2. The graph may be disconnected. 3. The number of nodes `n` will be between 2 and 1000. 4. The number of edges `m` will be between 1 and 10000. **Performance Requirements:** The solution should handle graphs up to the given limits efficiently, utilizing O(E log V) time complexity with reduced memory usage. **Example:** ```python g = Graph(5) for u, v, w in [(0, 1, 10), (0, 4, 5), (1, 2, 1), (2, 3, 4), (3, 0, 7), (4, 1, 3), (4, 2, 9), (4, 3, 2)]: g.add_edge(u, v, w) distances = g.dijkstra(0) print(distances) # Expected output: [0, 8, 9, 7, 5] ``` Implement the methods in the `Graph` class to complete the memory-optimized version of Dijkstra\'s Algorithm, ensuring it meets the constraints and performance requirements.","solution":"import heapq class Graph: def __init__(self, num_of_nodes: int) -> None: # Initialize the graph with a given number of nodes self.num_of_nodes = num_of_nodes self.adj_list = [[] for _ in range(num_of_nodes)] def add_edge(self, u_node: int, v_node: int, weight: int) -> None: # Adds a directed edge from u_node to v_node with the given weight self.adj_list[u_node].append((v_node, weight)) def dijkstra(self, start_node: int) -> list[int]: # Executes Dijkstra\'s Algorithm from start_node and returns shortest distances dist = [float(\'inf\')] * self.num_of_nodes dist[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_dist, u = heapq.heappop(priority_queue) if current_dist > dist[u]: continue for v, weight in self.adj_list[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(priority_queue, (distance, v)) return dist"},{"question":"# Problem Statement You are tasked to write a program that finds the optimal path through a grid, starting from the top-left corner and moving to the bottom-right corner. The grid contains weights for each cell, and you can only move right or down at each step. The goal is to find the path with the minimum total weight. # Function Signature ```python def find_min_path(grid: list[list[int]]) -> int: ... ``` # Input: 1. `grid` (list[list[int]]): A 2D list of integers representing the weights of the cells in the grid. All weights are non-negative integers. # Output: * Returns an integer representing the minimum total weight path from the top-left to the bottom-right corner of the grid. # Constraints: * The grid will have dimensions between 1x1 and 100x100. * The weights in the grid will be between 0 and 1000. # Performance Requirements: * Your solution should efficiently compute the minimum path for grids up to the maximum constraints. # Examples: ```python print(find_min_path([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ])) # Expected output: 7, the optimal path is 1→3→1→1→1 with the sum 7. print(find_min_path([ [1, 2], [1, 1] ])) # Expected output: 3, the optimal path is 1→2→1 with the sum 3. print(find_min_path([ [2, 2, 1], [3, 8, 1], [5, 0, 1] ])) # Expected output: 7, the optimal path is 2→2→1→1→1 with the sum 7. ``` # Notes: 1. Ensure your code handles grids of varying sizes efficiently. 2. Consider edge cases such as single-cell grids, all cells having the same weight, and large grids. 3. Your implementation should use dynamic programming to compute the minimum total weight path effectively.","solution":"def find_min_path(grid): Finds the minimum path from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0]*cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[rows-1][cols-1]"},{"question":"# Problem Statement In this task, you are required to implement a function that checks if a given string contains all the characters of another string (case-insensitive) in the correct order but potentially with other characters in between. This type of sequence check is referred to as a \\"subsequence verification.\\" # Function Signature ```python def is_subsequence(s: str, t: str) -> bool: pass ``` # Input * `s`: A string containing the target sequence. * `t`: A string in which you need to check for the presence of the sequence `s`. # Output * A boolean value `True` if `s` is a subsequence of `t`, `False` otherwise. # Constraints * All characters in both strings `s` and `t` are ASCII letters. * The function should correctly handle case insensitivity (i.e., \'A\' should be treated the same as \'a\'). * The length of `t` will be between 0 and 10^4. * The length of `s` will be between 0 and 100. # Examples ```python >>> is_subsequence(\\"abc\\", \\"aXbYcZ\\") True >>> is_subsequence(\\"AbC\\", \\"aXbYcZ\\") True >>> is_subsequence(\\"abc\\", \\"acb\\") False >>> is_subsequence(\\"ace\\", \\"aabbccaaee\\") True >>> is_subsequence(\\"xyz\\", \\"abcdef\\") False ``` # Additional Information Your function should efficiently check for the presence of the sequence `s` within `t`, respecting the order of characters but allowing for other characters in between. Focus on the correct handling of edge cases and its computational efficiency when processing longer strings.","solution":"def is_subsequence(s: str, t: str) -> bool: Checks if the string \'s\' is a subsequence of string \'t\'. This means that the characters of \'s\' are present in \'t\' in the same order, but not necessarily consecutively. s = s.lower() t = t.lower() it = iter(t) return all(char in it for char in s)"},{"question":"# Question: Evaluating Astronomical Coordinates **Context:** In an astronomical observatory, it is crucial to accurately evaluate the position of celestial objects in the night sky. Given right ascension (RA) and declination (Dec) as primary coordinates, scientists need a reliable system to convert these into a different coordinate format, such as Altitude and Azimuth, for observation. **Problem Statement:** Write a function `convert_coordinates(ra: float, dec: float, lat: float, lon: float, timestamp: int) -> tuple` that converts right ascension and declination into Altitude and Azimuth given the observer\'s latitude, longitude, and the current timestamp. The function should use the observer\'s geographical position to accurately compute the conversion for a specific moment in time. **Requirements:** 1. The function should handle invalid latitude or longitude inputs by raising a `ValueError` with an appropriate error message. 2. The function should consider the observer\'s position on Earth and the current time for accurate conversion. 3. Parameters `lat` and `lon` should represent geographical coordinates in degrees. **Function Signature:** ```python def convert_coordinates(ra: float, dec: float, lat: float, lon: float, timestamp: int) -> tuple: pass ``` **Input:** * `ra`: A float representing the right ascension in degrees. * `dec`: A float representing the declination in degrees. * `lat`: A float representing the observer\'s latitude in degrees. Must be within the range [-90, 90]. * `lon`: A float representing the observer\'s longitude in degrees. Must be within the range [-180, 180]. * `timestamp`: An integer representing the Unix timestamp in seconds indicating the current time. **Output:** * A tuple of two floats representing the Altitude and Azimuth in degrees. **Constraints:** * The `lat` must be within the range [-90, 90]. * The `lon` must be within the range [-180, 180]. * The conversion must accurately consider the Earth\'s rotation and position at the given timestamp. **Examples:** ```python # Example 1: convert_coordinates(180.0, 45.0, 52.5, 13.4, 1609459200) # Expected output: (30.0, 60.0) # Example 2: convert_coordinates(90.0, -30.0, -33.9, 151.2, 1609455600) # Expected output: (-10.0, 150.0) # Example 3: convert_coordinates(225.0, 88.0, 45.0, -93.0, 1609452000) # Expected output: (75.0, 210.0) # Example 4: convert_coordinates(-20.0, 45.0, 52.5, 13.4, 1609459200) # Expected output: ValueError: Invalid coordinates. # Example 5: convert_coordinates(180.0, 45.0, 120.0, 13.4, 1609459200) # Expected output: ValueError: Invalid latitude. ``` Ensure that your implementation accurately converts the coordinates considering the timestamp and observer\'s location.","solution":"import math from datetime import datetime, timezone import numpy as np def convert_coordinates(ra: float, dec: float, lat: float, lon: float, timestamp: int) -> tuple: Converts right ascension and declination into Altitude and Azimuth. Parameters: ra (float): Right ascension in degrees. dec (float): Declination in degrees. lat (float): Observer\'s latitude in degrees. lon (float): Observer\'s longitude in degrees. timestamp (int): Unix timestamp in seconds. Returns: tuple: (altitude, azimuth) in degrees. if not (-90 <= lat <= 90): raise ValueError(\\"Invalid latitude. Must be between -90 and 90 degrees.\\") if not (-180 <= lon <= 180): raise ValueError(\\"Invalid longitude. Must be between -180 and 180 degrees.\\") # Convert RA and Dec to radians ra_rad = math.radians(ra) dec_rad = math.radians(dec) lat_rad = math.radians(lat) lon_rad = math.radians(lon) # Convert timestamp to datetime and then calculate the Greenwich Mean Sidereal Time (GMST) utc_time = datetime.fromtimestamp(timestamp, timezone.utc) jd = 367 * utc_time.year - (7 * (utc_time.year + (utc_time.month + 9) // 12)) // 4 + (275 * utc_time.month) // 9 + utc_time.day + 1721013.5 + (utc_time.hour + utc_time.minute / 60 + utc_time.second / 3600) / 24 T = (jd - 2451545.0) / 36525 GMST = 280.46061837 + 360.98564736629 * (jd - 2451545) + 0.000387933 * T**2 - T**3 / 38710000 GMST = math.radians(GMST % 360) # Calculate Local Sidereal Time (LST) LST = GMST + lon_rad LST = LST % (2 * math.pi) # Normalize the LST # Convert RA to Hour Angle (HA) HA = LST - ra_rad HA = HA % (2 * math.pi) # Normalize the HA # Perform the conversion from equatorial to horizontal coordinates sin_alt = math.sin(dec_rad) * math.sin(lat_rad) + math.cos(dec_rad) * math.cos(lat_rad) * math.cos(HA) altitude = math.degrees(math.asin(sin_alt)) cos_az = (math.sin(dec_rad) - math.sin(math.radians(altitude)) * math.sin(lat_rad)) / (math.cos(math.radians(altitude)) * math.cos(lat_rad)) # Check for edge cases where the arccos might not work properly due to floating point arithmetic issues. if cos_az > 1: cos_az = 1 elif cos_az < -1: cos_az = -1 azimuth = math.degrees(math.acos(cos_az)) if math.sin(HA) > 0: azimuth = 360 - azimuth return (altitude, azimuth)"},{"question":"# Problem Statement **Prime Factorization:** You are to implement a function that computes the prime factorization of a given positive integer. The function should return a dictionary where the keys are the prime factors and the values are their respective powers in the prime factorization of the number. # Function Signature ```python def prime_factors(n: int) -> dict: ``` # Input - `n` (int): The positive integer for which to compute the prime factorization. # Output - (dict): A dictionary with the prime factors of `n` as keys and their powers as values. # Constraints - `1 <= n <= 10^6` - The function should handle large numbers efficiently. # Examples ```python assert prime_factors(1) == {} assert prime_factors(12) == {2: 2, 3: 1} assert prime_factors(30) == {2: 1, 3: 1, 5: 1} assert prime_factors(60) == {2: 2, 3: 1, 5: 1} assert prime_factors(101) == {101: 1} assert prime_factors(1000000) == {2: 6, 5: 6} ``` # Guideline 1. Handle the edge case where `n` is 1. 2. Use efficient algorithms (sieve, trial division, etc.) to find the prime factors and their powers. 3. Return the result as a dictionary with prime factors and their corresponding powers. This question tests your ability to work with number theory concepts like prime factorization and efficiently handle large inputs using appropriate algorithms.","solution":"def prime_factors(n: int) -> dict: Compute the prime factorization of a given positive integer `n`. Returns a dictionary where the keys are the prime factors and the values are their respective powers. if n <= 1: return {} factors = {} # Check for number of 2s in n while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Check for odd numbers from 3 onwards factor = 3 while factor * factor <= n: while n % factor == 0: factors[factor] = factors.get(factor, 0) + 1 n //= factor factor += 2 # If n is still a prime number greater than 2 if n > 2: factors[n] = 1 return factors"},{"question":"# Minimum Edit Distance Given two strings `word1` and `word2`, write a function to calculate the **minimum edit distance** required to transform `word1` into `word2`. You should implement the solution using **dynamic programming**. The permissible operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. Function Signature ```python def min_edit_distance(word1: str, word2: str) -> int: pass ``` Input - `word1`: A string, the first word (1 ≤ len(word1) ≤ 1000). - `word2`: A string, the second word (1 ≤ len(word2) ≤ 1000). Output - Return the minimum number of operations required to transform `word1` into `word2`. Constraints - The function should handle inputs within reasonable time limits. - The solution must use dynamic programming to ensure efficiency. Examples ```python # Example 1 word1 = \\"horse\\" word2 = \\"ros\\" # Expected Output: 3 # Example 2 word1 = \\"intention\\" word2 = \\"execution\\" # Expected Output: 5 ``` Notes 1. You can assume that both words consist of lowercase English letters only. 2. Consider using a 2D table where dp[i][j] represents the minimum edit distance between the first `i` characters of `word1` and the first `j` characters of `word2`. 3. Ensure that your implementation handles various test cases, including when one word is empty, efficiently.","solution":"def min_edit_distance(word1: str, word2: str) -> int: # Initialize dimensions of DP table m, n = len(word1), len(word2) # Create a DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the first row and first column of the DP table for i in range(m + 1): dp[i][0] = i # Deletion for j in range(n + 1): dp[0][j] = j # Insertion # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # No operation required else: dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1) # Replacement # The result is the value in the bottom-right corner of the DP table return dp[m][n]"},{"question":"# Coding Assessment Question: Optimized String Reversal Scenario You\'re part of a team developing a text processing application, and one of the frequently required operations is reversing very large strings efficiently. This feature is critical due to its widespread usage across various modules within the application. Problem Statement Write a function `reverse_string(s: str) -> str` that returns the reversed version of the input string using an optimal algorithm. Your solution should handle very large strings effectively. Expected Input and Output Formats * **Input**: - Single string `s` (0 <= len(s) <= 10^6) * **Output**: - Single string which is the reversed version of `s`. Constraints 1. The input string can be of any length within the given range. 2. The function must efficiently handle strings up to the maximum limit. Examples ```python >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"This is a very large string for testing performance.\\") \\".ecnamrofret ep gnitset rof gnirts egral y re ve si sihT\\" ``` Performance Requirements * Your solution should execute in less than a second for strings of length up to 10^6. Instructions * Define the function `reverse_string(s: str) -> str` in a code block. * Ensure the function handles the constraints effectively. * Optimize for performance to meet the execution time requirement. Implementation Plan 1. **String Reversal**: Implement reversing logic using Python\'s slicing capabilities for efficient performance. 2. **Edge Cases**: Handle empty strings and single-character strings gracefully. 3. **Testing**: Provide example test cases to validate the implementation.","solution":"def reverse_string(s: str) -> str: Returns the reversed version of the input string. return s[::-1]"},{"question":"# Coding Assessment Question Scenario Understanding and converting date and time formats is crucial for various applications, such as logging events, scheduling tasks, or analyzing temporal data. You are tasked with implementing a function that converts a given date-time string from one format to another, accounting for different international formats and edge cases. Problem Statement Create the function `convert_datetime_format` that takes in a date-time string and converts it from the original format to a target format while handling possible edge cases such as invalid dates and times. Function Signature ```python def convert_datetime_format(dt_str: str, from_format: str, to_format: str) -> str: Converts a given date-time string from one format to another. :param dt_str: The date-time string to be converted. :param from_format: The original format of the date-time string. :param to_format: The target format to convert the date-time string to. :return: The date-time string in the target format. Example Usage: >>> dt_str = \\"2023-10-21 14:30:00\\" >>> from_format = \\"%Y-%m-%d %H:%M:%S\\" >>> to_format = \\"%b %d, %Y %I:%M %p\\" >>> convert_datetime_format(dt_str, from_format, to_format) \'Oct 21, 2023 02:30 PM\' >>> dt_str = \\"21/10/2023 14:30\\" >>> from_format = \\"%d/%m/%Y %H:%M\\" >>> to_format = \\"%Y-%m-%d %H:%M:%S\\" >>> convert_datetime_format(dt_str, from_format, to_format) \'2023-10-21 14:30:00\' ``` Requirements 1. **Format Conversion**: The function must accurately convert the given date-time string from the specified `from_format` to the `to_format`. 2. **Error Handling**: Gracefully handle errors such as: - Invalid date-time strings that don\'t match the `from_format`. - Invalid date-time values (e.g., February 30th). - Unsupported or malformed format strings. 3. **Case Insensitivity**: Handle case insensitivity for month and AM/PM representations where applicable. 4. **Edge Case Handling**: Manage edge cases such as different time zones and varying lengths of date and time components. Constraints * The input date-time string `dt_str` will contain between 1 and 100 characters. * The `from_format` and `to_format` strings will contain valid Python `strftime` and `strptime` directives for date-time formatting. * Ensure your implementation efficiently handles the conversion and error-checking within the given constraints. Performance Requirement * The solution should have a time complexity of O(1) for the typical case but handle edge cases and validation within a reasonable time. The space complexity should be kept minimal and only use what is necessary for the conversion process.","solution":"from datetime import datetime def convert_datetime_format(dt_str: str, from_format: str, to_format: str) -> str: Converts a given date-time string from one format to another. :param dt_str: The date-time string to be converted. :param from_format: The original format of the date-time string. :param to_format: The target format to convert the date-time string to. :return: The date-time string in the target format. try: dt = datetime.strptime(dt_str, from_format) return dt.strftime(to_format) except (ValueError, TypeError) as e: return f\\"Error: {e}\\""},{"question":"# Context You have been assigned the task of developing a feature for a library management system. The feature requires you to track books that are overdue. Each book is recorded with its title and the number of days it has been overdue. # Task Write a function `filter_overdue_books(records: list[tuple[str, int]], threshold: int) -> list[tuple[str, int]]` that filters the list of overdue books based on a given number of days. # Function Signature ```python def filter_overdue_books(records: list[tuple[str, int]], threshold: int) -> list[tuple[str, int]]: Filters a list of overdue books based on a given threshold. :param records: A list of tuples, each containing a string (book title) and an integer (number of days overdue). :param threshold: An integer threshold of days to filter the overdue books. :return: The filtered list based on the threshold. ``` # Input * `records`: A list of tuples, where each tuple consists of a string (the book title) and an integer (the number of days overdue). For example: `[(\\"Harry Potter\\", 10), (\\"Moby Dick\\", 3), (\\"War and Peace\\", 15)]` * `threshold`: An integer representing the threshold of days overdue. For example: `7` # Output * A filtered list of tuples where each overdue book\'s days exceed the threshold. # Constraints * 0 ≤ len(records) ≤ 10^3 * Each tuple will have a non-negative integer and a non-empty string. * Book titles are unique and contain only alphabetical characters. # Examples 1. Input: `[(\\"Harry Potter\\", 10), (\\"Moby Dick\\", 3), (\\"War and Peace\\", 15)]`, `threshold = 7` Output: `[(\\"Harry Potter\\", 10), (\\"War and Peace\\", 15)]` 2. Input: `[(\\"1984\\", 5), (\\"To Kill a Mockingbird\\", 8)]`, `threshold = 6` Output: `[(\\"To Kill a Mockingbird\\", 8)]` # Notes Consider potential edge cases like an empty list or a list with one element, and ensure that your function handles these appropriately.","solution":"def filter_overdue_books(records, threshold): Filters a list of overdue books based on a given threshold. :param records: A list of tuples, each containing a string (book title) and an integer (number of days overdue). :param threshold: An integer threshold of days to filter the overdue books. :return: The filtered list based on the threshold. return [(title, days) for title, days in records if days > threshold]"},{"question":"# Sum of Digits in a Number You are required to write a function that calculates the sum of the digits of a given number. Your implementation should handle both positive and negative integers. Function Signature ```python def sum_of_digits(number: int) -> int: ``` Input - `number` (int): The number whose digits sum need to be computed. Constraints: -10^9 ≤ number ≤ 10^9 Output - (int): The sum of the digits of the given number. If the number is negative, sum the digits of the absolute value of the number. Constraints - Your function should raise a `TypeError` if the input is not an integer. - Ensure that the function works efficiently for large inputs within the specified range. Examples ```python print(sum_of_digits(0)) # Output: 0 print(sum_of_digits(123)) # Output: 6 print(sum_of_digits(-456)) # Output: 15 print(sum_of_digits(98765)) # Output: 35 print(sum_of_digits(-10101)) # Output: 3 ``` Notes - Edge cases such as zero and negative inputs should be handled appropriately by summing the digits of the number\'s absolute value. - Focus on efficient computation methods for performing digit extraction and summation. - Be mindful of the function\'s performance, especially for large input values.","solution":"def sum_of_digits(number: int) -> int: Returns the sum of the digits of the given integer number. If the number is negative, it sums the digits of its absolute value. Parameters: number (int): The integer number whose digits are to be summed. Returns: int: The sum of the digits. Raises: TypeError: If the input is not an integer. if not isinstance(number, int): raise TypeError(\\"Input must be an integer\\") # Use absolute value to handle negative numbers number = abs(number) # Convert the number to a string, iterate over its characters, convert them back to integers and sum them return sum(int(digit) for digit in str(number))"},{"question":"# Question: Implement and Evaluate Decision Tree Algorithms In this task, you will implement the Decision Tree algorithm from scratch for both classification and regression tasks. Decision Trees are non-parametric supervised learning methods used for classification and regression. Objectives: 1. Implement the following Decision Tree algorithms: 1. **Decision Tree Classifier** 2. **Decision Tree Regressor** 2. Your implementations should handle edge cases and raise appropriate errors for invalid inputs. Function Specifications: **Decision Tree Classifier** ```python def decision_tree_classifier(X: np.ndarray, y: np.ndarray, max_depth: int = None, min_samples_split: int = 2) -> dict: Parameters: - X: Input features of shape (n_samples, n_features) - y: Target labels of shape (n_samples,) - max_depth: The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure. - min_samples_split: The minimum number of samples required to split an internal node. Returns: - dict: Dictionary representing the decision tree ``` **Decision Tree Regressor** ```python def decision_tree_regressor(X: np.ndarray, y: np.ndarray, max_depth: int = None, min_samples_split: int = 2) -> dict: Parameters: - X: Input features of shape (n_samples, n_features) - y: Target values of shape (n_samples,) - max_depth: The maximum depth of the tree. If None, then nodes are expanded until all leaves are pure. - min_samples_split: The minimum number of samples required to split an internal node. Returns: - dict: Dictionary representing the decision tree ``` Constraints: 1. Ensure the input arrays (`X` and `y`) are numpy arrays. 2. Handle mismatched lengths or shapes of input arrays using appropriate error messages. 3. Implement utility functions to calculate entropy and information gain for the classifier. 4. Implement utility functions to calculate mean squared error (MSE) for the regressor. 5. Implement a function to find the best split. 6. Use recursion to build the tree in a depth-first manner. 7. Ensure the depth and minimum sample split constraints are respected. Example Usage: ```python X = np.array([[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]) y = np.array([0, 1, 0, 1, 0]) classifier_tree = decision_tree_classifier(X, y, max_depth=3, min_samples_split=2) print(classifier_tree) # Output: A dictionary representing the decision tree X = np.array([[1, 3], [2, 2], [3, 4], [4, 5], [5, 7]]) y = np.array([2.5, 3.6, 1.8, 2.9, 4.1]) regressor_tree = decision_tree_regressor(X, y, max_depth=3, min_samples_split=2) print(regressor_tree) # Output: A dictionary representing the decision tree ``` You need to write these functions from scratch. You are encouraged to use recursion and appropriate utility functions for efficient and correct tree building. Good luck!","solution":"import numpy as np def entropy(y): Calculate the entropy of a label array y. hist = np.bincount(y) ps = hist / len(y) return -np.sum([p * np.log2(p) for p in ps if p > 0]) def information_gain(parent, left, right): Calculate the information gain of a split. num_parent = len(parent) num_left = len(left) num_right = len(right) entropy_parent = entropy(parent) entropy_left = entropy(left) entropy_right = entropy(right) weighted_avg_entropy = (num_left / num_parent) * entropy_left + (num_right / num_parent) * entropy_right return entropy_parent - weighted_avg_entropy def mse(y): Calculate the mean squared error of a label array y. return np.mean((y - np.mean(y)) ** 2) def split(X, y, feature_index, threshold): Split the dataset based on a feature and a threshold. left_indices = np.where(X[:, feature_index] <= threshold) right_indices = np.where(X[:, feature_index] > threshold) return X[left_indices], X[right_indices], y[left_indices], y[right_indices] def best_split(X, y, is_classification=True): Find the best split for the dataset. best_feature = None best_threshold = None best_gain = -np.inf n_samples, n_features = X.shape for feature_index in range(n_features): thresholds = np.unique(X[:, feature_index]) for threshold in thresholds: X_left, X_right, y_left, y_right = split(X, y, feature_index, threshold) if len(y_left) == 0 or len(y_right) == 0: continue if is_classification: gain = information_gain(y, y_left, y_right) else: total_mse = len(y_left) * mse(y_left) + len(y_right) * mse(y_right) gain = mse(y) - total_mse / n_samples if gain > best_gain: best_gain = gain best_feature = feature_index best_threshold = threshold return best_feature, best_threshold, best_gain def build_tree(X, y, max_depth, min_samples_split, is_classification=True, depth=0): Build the decision tree recursively. n_samples, n_features = X.shape if n_samples >= min_samples_split and (max_depth is None or depth <= max_depth): best_feature, best_threshold, best_gain = best_split(X, y, is_classification) if best_gain > 0: X_left, X_right, y_left, y_right = split(X, y, best_feature, best_threshold) left_subtree = build_tree(X_left, y_left, max_depth, min_samples_split, is_classification, depth + 1) right_subtree = build_tree(X_right, y_right, max_depth, min_samples_split, is_classification, depth + 1) return {\\"feature_index\\": best_feature, \\"threshold\\": best_threshold, \\"left\\": left_subtree, \\"right\\": right_subtree} if is_classification: return {\\"value\\": np.argmax(np.bincount(y))} else: return {\\"value\\": np.mean(y)} def decision_tree_classifier(X, y, max_depth=None, min_samples_split=2): Build a decision tree classifier. if not isinstance(X, np.ndarray) or not isinstance(y, np.ndarray): raise ValueError(\\"X and y must be numpy arrays\\") if len(X) != len(y): raise ValueError(\\"The lengths of X and y must be the same\\") return build_tree(X, y, max_depth, min_samples_split, is_classification=True) def decision_tree_regressor(X, y, max_depth=None, min_samples_split=2): Build a decision tree regressor. if not isinstance(X, np.ndarray) or not isinstance(y, np.ndarray): raise ValueError(\\"X and y must be numpy arrays\\") if len(X) != len(y): raise ValueError(\\"The lengths of X and y must be the same\\") return build_tree(X, y, max_depth, min_samples_split, is_classification=False)"},{"question":"# Problem Statement You are given an array of integers. Your task is to preprocess the array for range minimum queries (RMQ) using the Sparse Table method, and then efficiently answer multiple RMQ queries. Input Format 1. An integer `n` representing the number of elements in the array. 2. `n` integers representing the elements of the array. 3. An integer `q` representing the number of RMQ queries. 4. `q` pairs of integers `(l, r)` representing the range `[l, r]` for each RMQ query. Output Format Print `q` integers, each representing the minimum value in the array within the given range `[l, r]`. Constraints - (1 leq n leq 10^5) - (1 leq q leq 10^5) - (0 leq l leq r < n) Example **Input** ``` 10 1 5 2 4 3 7 8 6 9 0 3 1 3 4 8 0 9 ``` **Output** ``` 2 3 0 ``` Task Implement the following function: ```python def range_minimum_queries(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: # Your implementation here ``` In this function, `n` is the number of elements in the array, `array` is the list of `n` integers, and `queries` is the list of `q` RMQ queries. **Performance Notes**: - Ensure that the preprocessing (Sparse Table creation) is optimal. - Ensure that each query is answered in logarithmic time.","solution":"from typing import List, Tuple def range_minimum_queries(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Preprocess the array for Range Minimum Queries (RMQ) using the Sparse Table method and answer multiple RMQ queries. import math # Initialize sparse table log = [0] * (n + 1) for i in range(2, n + 1): log[i] = log[i // 2] + 1 # P is our sparse table, where P[i][j] stores the index of the minimum value # in array[i .. i + (1 << j) - 1] p = [[0] * (log[n] + 1) for _ in range(n)] # Initialize for the intervals of length 1 for i in range(n): p[i][0] = array[i] # Compute the sparse table entries j = 1 while (1 << j) <= n: i = 0 while (i + (1 << j) - 1) < n: p[i][j] = min(p[i][j - 1], p[i + (1 << (j - 1))][j - 1]) i += 1 j += 1 # Function to get the minimum value in the range [L, R] def query(l, r): j = log[r - l + 1] return min(p[l][j], p[r - (1 << j) + 1][j]) # Answer the queries results = [] for l, r in queries: results.append(query(l, r)) return results"},{"question":"# Running Average Streams You are tasked with creating a running average from a streaming data source. Your function will maintain the running average as new numbers are provided sequentially. # Function Signature: ```python class RunningAverage: def __init__(self): pass def add_number(self, number: float) -> None: pass def get_average(self) -> float: pass ``` # Methods: - `add_number(number: float) -> None`: This method will take a floating point number and add it to the stream of numbers. - `get_average() -> float`: This method will return the current average of all numbers that have been added to the stream. # Example: ```python ra = RunningAverage() ra.add_number(10) print(ra.get_average()) # Output: 10.0 ra.add_number(20) print(ra.get_average()) # Output: 15.0 ra.add_number(40) print(ra.get_average()) # Output: 23.333333333333332 ``` # Notes: - Ensure the class retains the average accurate to floating-point precision. - Optimize for both time and space with respect to the number of elements added to the stream.","solution":"class RunningAverage: def __init__(self): self.sum = 0.0 self.count = 0 def add_number(self, number: float) -> None: self.sum += number self.count += 1 def get_average(self) -> float: if self.count == 0: return 0.0 return self.sum / self.count"},{"question":"# Scenario You are designing a word prediction feature for a text editor. The feature will provide suggestions based on a dictionary of words. You want to efficiently find words that start with a given prefix to help assist with autocomplete functionality. To achieve this, you decide to implement a Trie data structure. # Challenge Implement a custom Trie class with necessary methods to support adding words and searching words by prefix. Ensure the structure supports efficient insertion and prefix searching operations. # Task 1. Implement the `insert` method to add a word into the trie. 2. Implement the `search` method to check if a word exists in the trie. 3. Implement the `starts_with` method to check if there are any words in the trie that start with a given prefix. # Requirements - Implement the Trie data structure with the required methods. - Ensure that the insertions and searches operate efficiently. - Handle edge cases like empty strings or nonexistent prefixes. - Optimize for average-case performance while considering potential worst-case scenarios. # Input and Output - Input: Series of operations to insert words and search by prefixes. - Output: For each `search` and `starts_with` operation, output a boolean indicating the result. # Example Suppose you have the following sequence of operations: ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ``` # Constraints - Words are non-empty strings consisting of lowercase English letters. - The trie methods will be called multiple times with various inputs. Implement the `Trie` with the required methods and ensure it efficiently manages word insertion and prefix searching.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current = self.root for ch in word: if ch not in current.children: current.children[ch] = TrieNode() current = current.children[ch] current.is_end_of_word = True def search(self, word: str) -> bool: current = self.root for ch in word: if ch not in current.children: return False current = current.children[ch] return current.is_end_of_word def starts_with(self, prefix: str) -> bool: current = self.root for ch in prefix: if ch not in current.children: return False current = current.children[ch] return True"},{"question":"# Context You have been tasked with developing a feature for a financial software application that requires precise currency conversion. The application works with various currencies, and you need to write a function that formats a given amount into a specified currency format. # Task Write a function `format_currency(amount: float, currency_code: str) -> str` that takes a floating-point number representing an amount of money and a string representing a currency code, and returns the amount formatted according to the currency\'s conventions. # Specifications 1. **Input Format**: - A float `amount` representing the amount of money. - A string `currency_code` consisting of a 3-letter uppercase currency code (e.g., \\"USD\\", \\"EUR\\", \\"JPY\\"). 2. **Output Format**: - A string representing the formatted currency amount. # Constraints * The currency code will be one of the following: \\"USD\\", \\"EUR\\", \\"JPY\\". * The amount will be in the range from -1,000,000 to 1,000,000. * For \\"USD\\" and \\"EUR\\", the amount should be formatted with two decimal places and a dollar or euro sign (, €) respectively. * For \\"JPY\\", the amount should be formatted with no decimal places and a yen sign (¥). * The function should properly handle negative amounts, placing the minus sign before the currency symbol. # Performance Requirements * The solution should be efficient in terms of both time and space complexity, smoothly handling the maximum input size within a reasonable time frame. # Examples * `format_currency(1234.56, \\"USD\\")` should return `\'1,234.56\'` * `format_currency(1234.56, \\"EUR\\")` should return `\'€1,234.56\'` * `format_currency(1234.56, \\"JPY\\")` should return `\'¥1,235\'` * `format_currency(-1234.56, \\"USD\\")` should return `\'- 1,234.56\'` * `format_currency(-1234.56, \\"EUR\\")` should return `\'- €1,234.56\'` * `format_currency(-1234.56, \\"JPY\\")` should return `\'- ¥1,235\'` # Additional Notes * You may assume that the input currency code is always valid and one of the specified codes. * The function should properly format large numbers with commas as thousand separators where applicable. * The formatting should adhere to conventions typical for the respective currencies as outlined in the constraints.","solution":"def format_currency(amount: float, currency_code: str) -> str: Formats the given amount into the specified currency format. Args: amount (float): The amount of money. currency_code (str): The 3-letter currency code (e.g., \\"USD\\", \\"EUR\\", \\"JPY\\"). Returns: str: The formatted currency amount. if currency_code == \\"USD\\": symbol = \\"\\" formatted_amount = f\\"{symbol}{abs(amount):,.2f}\\" elif currency_code == \\"EUR\\": symbol = \\"€\\" formatted_amount = f\\"{symbol}{abs(amount):,.2f}\\" elif currency_code == \\"JPY\\": symbol = \\"¥\\" formatted_amount = f\\"{symbol}{abs(amount):,.0f}\\" else: raise ValueError(\\"Unsupported currency code\\") if amount < 0: return f\\"- {formatted_amount}\\" return formatted_amount"},{"question":"# Water Tank Filling Time Calculation **Context:** You are working on a project that involves filling a large tank with water using a pump. To determine how long it will take to fill the entire tank, you need to write a function that calculates the required time based on the pump\'s flow rate and the tank\'s volume. **Problem Statement:** Write a Python function `filling_time` that calculates the time required to fill a tank based on the tank\'s volume and the pump\'s flow rate. The function should handle invalid input cases gracefully by raising appropriate exceptions. **Function Signature:** ```python def filling_time(tank_volume: float, flow_rate: float) -> float: Calculate the time required to fill a tank using a pump. Parameters: - tank_volume (float): The volume of the tank in liters. Must be positive. - flow_rate (float): The flow rate of the pump in liters per second. Must be positive. Returns: - float: The time required to fill the tank in seconds. Raises: - ValueError: If any input parameter does not meet the specified constraints. ``` **Constraints:** - Both parameters must be positive. - Precision up to 2 decimal places for the return value. **Examples:** ```python >>> filling_time(1000, 10) 100.00 >>> filling_time(500, 1.5) 333.33 >>> filling_time(2000, 50) 40.00 >>> filling_time(0, 10) Traceback (most recent call last): ... ValueError: Tank volume must be positive. >>> filling_time(1000, -5) Traceback (most recent call last): ... ValueError: Flow rate must be positive. >>> filling_time(1500, 0) Traceback (most recent call last): ... ValueError: Flow rate must be positive. ``` **Notes:** - You should validate all input parameters and raise a `ValueError` for invalid inputs. - Calculate the result by dividing the tank volume by the flow rate. - Make sure to round the output to two decimal places.","solution":"def filling_time(tank_volume: float, flow_rate: float) -> float: Calculate the time required to fill a tank using a pump. Parameters: - tank_volume (float): The volume of the tank in liters. Must be positive. - flow_rate (float): The flow rate of the pump in liters per second. Must be positive. Returns: - float: The time required to fill the tank in seconds with 2 decimal precision. Raises: - ValueError: If any input parameter does not meet the specified constraints. if tank_volume <= 0: raise ValueError(\\"Tank volume must be positive.\\") if flow_rate <= 0: raise ValueError(\\"Flow rate must be positive.\\") time_required = tank_volume / flow_rate return round(time_required, 2)"},{"question":"# Hotel Room Booking System You are required to design a simple hotel room booking system. Implement methods to add rooms, book rooms, and check the availability of rooms based on room type. The system should handle single, double, and suite room types. Function Signatures: 1. `def add_room(room_type: str, room_number: int) -> None` 2. `def book_room(room_type: str, customer_name: str) -> int` 3. `def check_availability(room_type: str) -> List[int]` Description: - `add_room(room_type: str, room_number: int)`: This function accepts a room type (`\'single\'`, `\'double\'`, `\'suite\'`) and a room number (an integer) and adds the room to the system\'s inventory. - `book_room(room_type: str, customer_name: str)`: This function accepts a room type (`\'single\'`, `\'double\'`, `\'suite\'`) and a customer\'s name (a string), books the first available room of the specified type for the customer and returns the booked room number. If no rooms of the specified type are available, return -1. - `check_availability(room_type: str)`: This function accepts a room type (`\'single\'`, `\'double\'`, `\'suite\'`) and returns a list of available room numbers of that type. Example: ```python >>> add_room(\'single\', 101) >>> add_room(\'single\', 102) >>> add_room(\'suite\', 201) >>> add_room(\'double\', 301) >>> check_availability(\'single\') [101, 102] >>> book_room(\'single\', \'Alice\') 101 >>> check_availability(\'single\') [102] >>> book_room(\'suite\', \'Bob\') 201 >>> book_room(\'suite\', \'Charlie\') -1 >>> check_availability(\'double\') [301] ```","solution":"from typing import List, Dict class HotelRoomBookingSystem: def __init__(self): self.rooms = {\'single\': [], \'double\': [], \'suite\': []} self.booked_rooms = {\'single\': {}, \'double\': {}, \'suite\': {}} def add_room(self, room_type: str, room_number: int) -> None: Adds a room of the specified type and room number to the system\'s inventory. if room_number not in self.rooms[room_type]: self.rooms[room_type].append(room_number) self.rooms[room_type].sort() # ensure room numbers are sorted for consistency def book_room(self, room_type: str, customer_name: str) -> int: Books the first available room of the specified type for the customer. Returns the booked room number or -1 if no rooms of the specified type are available. available_rooms = self.rooms[room_type] if not available_rooms: return -1 # no available rooms in the given type room_number = available_rooms.pop(0) # book the first available room self.booked_rooms[room_type][room_number] = customer_name return room_number def check_availability(self, room_type: str) -> List[int]: Returns a list of available room numbers of the specified type. return self.rooms[room_type][:]"},{"question":"# Problem Statement Write a function that receives a list of integers and returns the length of the longest subarray that forms a consecutive sequence. A consecutive sequence is defined as a sequence where each element can be arranged such that they constitute a consecutive increasing order of integers. For example, in the array `[1, 9, 3, 10, 2, 20]`, the longest consecutive subarray is `[1, 2, 3]` with a length of 3. # Input * A list of integers `arr` where `0 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. # Output * Return an integer representing the length of the longest consecutive subarray. # Implementation Implement the following function: ```python def longest_consecutive_subarray(arr: list[int]) -> int: Find the length of the longest consecutive sequence subarray. :param arr: List of integers :return: Integer length of the longest consecutive sequence subarray >>> longest_consecutive_subarray([1, 9, 3, 10, 2, 20]) 3 >>> longest_consecutive_subarray([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subarray([5, 4, 3, 2, 1]) 5 >>> longest_consecutive_subarray([1, 1, 1, 1]) 1 >>> longest_consecutive_subarray([]) 0 pass ``` # Constraints * The list can be empty. * The list can contain up to `10^5` integers. # Edge Cases * Lists with all elements the same should return `1`. * Empty list should return `0`. * List already ordered consecutively should return its length. # Example ```python print(longest_consecutive_subarray([1, 9, 3, 10, 2, 20])) # Output: 3 print(longest_consecutive_subarray([1, 2, 3, 4, 5])) # Output: 5 print(longest_consecutive_subarray([1, 1, 1, 1])) # Output: 1 print(longest_consecutive_subarray([])) # Output: 0 ```","solution":"def longest_consecutive_subarray(arr: list[int]) -> int: Find the length of the longest consecutive sequence subarray. :param arr: List of integers :return: Integer length of the longest consecutive sequence subarray >>> longest_consecutive_subarray([1, 9, 3, 10, 2, 20]) 3 >>> longest_consecutive_subarray([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_subarray([5, 4, 3, 2, 1]) 5 >>> longest_consecutive_subarray([1, 1, 1, 1]) 1 >>> longest_consecutive_subarray([]) 0 if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Coding Assessment Question: Prime Factorization **Objective**: Write a function that computes the prime factorization of a given integer `n`. # Problem Statement You are given a positive integer `n`. Implement a function `prime_factorization(n)` that returns a list of tuples representing the prime factors of `n` and their respective counts. # Input * A single integer `n` such that 2 ≤ `n` ≤ 10^9 # Output * A list of tuples where each tuple `(p, c)` represents a prime factor `p` of `n` and its count `c`. # Examples 1. `prime_factorization(56)` should return `[(2, 3), (7, 1)]` since 56 = 2^3 * 7^1. 2. `prime_factorization(100)` should return `[(2, 2), (5, 2)]`. 3. `prime_factorization(97)` should return `[(97, 1)]` since 97 is a prime number. 4. `prime_factorization(360)` should return `[(2, 3), (3, 2), (5, 1)]`. # Constraints 1. 2 ≤ `n` ≤ 10^9 2. The function should handle large values efficiently. # Function Signature ```python def prime_factorization(n: int) -> List[Tuple[int, int]]: # Your code here ``` # Additional Notes * Consider using an efficient algorithm such as trial division to find the prime factors. * The output list should be sorted by the prime factors in ascending order. # Guidance To implement this, you may start with the smallest prime number (2) and iteratively test for divisibility, counting the number of times each prime divides `n` before proceeding to the next potential prime factor. Don\'t forget to handle the case when `n` itself is prime.","solution":"def prime_factorization(n): Returns the prime factorization of a given integer n as a list of tuples where each tuple (p, c) represents a prime factor p of n and its count c. factors = [] count = 0 # Check for number of 2s in n while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # Check for odd factors starting from 3 p = 3 while p * p <= n: count = 0 while n % p == 0: n = n // p count += 1 if count > 0: factors.append((p, count)) p += 2 # If n becomes a prime number greater than 2 if n > 2: factors.append((n, 1)) return factors"},{"question":"# Coding Assessment Task Scenario You have been tasked with developing a feature for a text-based game. In this game, players input commands to navigate through a grid-like dungeon. One of the core mechanics involves tracking the player\'s moves and determining their final position on the grid after executing a series of commands. This helps to maintain accurate game state and rendering positions. Question Write a function `final_position(moves: str) -> Tuple[int, int]` that takes a string of comma-separated commands and returns the player\'s final position on the grid. The grid initially has the player at position `(0, 0)`, and the available commands are `UP`, `DOWN`, `LEFT`, and `RIGHT`, which move the player one unit in the respective direction. Input * A string `moves` consisting of comma-separated commands `UP`, `DOWN`, `LEFT`, `RIGHT`. Output * A tuple of two integers representing the player\'s final position on the grid. Constraints 1. The input string will consist of only the mentioned commands separated by commas. 2. Commands will be in uppercase and there will be no extra spaces. 3. Proper handling of an empty input string, which should return the initial position `(0, 0)`. Examples ```python assert final_position(\\"UP,UP,LEFT,DOWN,RIGHT,RIGHT\\") == (1, 1) assert final_position(\\"LEFT,LEFT,DOWN,DOWN\\") == (-2, -2) assert final_position(\\"UP,RIGHT,DOWN,LEFT\\") == (0, 0) assert final_position(\\"UP,UP,UP,UP\\") == (0, 4) assert final_position(\\"\\") == (0, 0) ``` Requirements * Your solution should have a time complexity of O(n), where n is the number of commands. * Your solution should have a space complexity of O(1). * Proper handling of edge cases and valid input inspection is required.","solution":"from typing import Tuple def final_position(moves: str) -> Tuple[int, int]: x, y = 0, 0 if not moves: return (x, y) commands = moves.split(\',\') for move in commands: if move == \'UP\': y += 1 elif move == \'DOWN\': y -= 1 elif move == \'LEFT\': x -= 1 elif move == \'RIGHT\': x += 1 return (x, y)"},{"question":"You are required to implement a function that calculates the minimum number of edits (operations) needed to convert one string into another. This operation is known as the Levenshtein distance and supports three types of edits: insertion, deletion, and substitution. # Function Signature ```python def levenshtein_distance(str1: str, str2: str) -> int: pass ``` # Input * Two strings `str1` and `str2`, both consisting of lowercase alphabets. # Output * Return an integer that represents the minimum number of operations required to convert `str1` into `str2`. # Constraints * 1 <= len(str1), len(str2) <= 1000 # Examples ```python >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") 3 >>> levenshtein_distance(\\"flaw\\", \\"lawn\\") 2 >>> levenshtein_distance(\\"intention\\", \\"execution\\") 5 ``` # Explanation To solve this problem: 1. Use dynamic programming to build a matrix `dp` where `dp[i][j]` represents the minimum number of operations required to convert the first `i` characters of `str1` to the first `j` characters of `str2`. 2. The state transition involves considering: - Insertion: `dp[i][j-1] + 1` - Deletion: `dp[i-1][j] + 1` - Substitution: `dp[i-1][j-1]` if `str1[i-1] == str2[j-1]` else `dp[i-1][j-1] + 1` 3. Initialize `dp[0][j] = j` for all `j` and `dp[i][0] = i` for all `i`, since transforming a string to an empty string (or vice versa) requires `j` (or `i`) operations. 4. The value of `dp[len(str1)][len(str2)]` holds the final answer.","solution":"def levenshtein_distance(str1: str, str2: str) -> int: len_str1 = len(str1) len_str2 = len(str2) # Create a 2D list to store the distances dp = [[0 for _ in range(len_str2 + 1)] for _ in range(len_str1 + 1)] # Initialize the distance for the first row and first column for i in range(len_str1 + 1): dp[i][0] = i for j in range(len_str2 + 1): dp[0][j] = j # Fill the dp table for i in range(1, len_str1 + 1): for j in range(1, len_str2 + 1): if str1[i - 1] == str2[j - 1]: cost = 0 else: cost = 1 dp[i][j] = min(dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + cost) # Substitution return dp[len_str1][len_str2]"},{"question":"# File Directory Management Context Efficiently managing file directories programmatically is a common requirement in many software applications. Often, there is a need to create a directory structure, move files into corresponding directories, and ensure that the operations perform correctly. Task Write a Python function `manage_directory_structure` that accepts a list of file paths and organizes them into a given directory structure based on their extensions. Function Signature ```python def manage_directory_structure(file_paths: List[str], directory: str) -> None: pass ``` Input * `file_paths` (List[str]): A list of file paths to be organized. * `directory` (str): The base directory where the new structure will be created. Output * The function should create directories based on file extensions within the base directory. * Move the files from `file_paths` to the respective directories. * If `file_paths` contains \\"example.txt\\" and the base directory is \\"organized_files\\", then \\"example.txt\\" should be moved to \\"organized_files/txt/\\". Constraints * Create a subdirectory for each unique file extension. * Handle cases where files already exist in the target location by appending a unique suffix. * If any directory or file cannot be created or moved, handle the error gracefully without stopping the execution. Requirements * Ensure that directory creation and file movements are efficient. * Handle edge cases such as empty input lists and invalid paths. Example ```python # Example usage manage_directory_structure([\\"/path/to/file1.txt\\", \\"/path/to/file2.jpg\\", \\"/path/to/file3.txt\\"], \\"organized_files\\") # Creates directories \\"organized_files/txt/\\" and \\"organized_files/jpg/\\" # Moves \\"file1.txt\\" and \\"file3.txt\\" to \\"organized_files/txt/\\" # Moves \\"file2.jpg\\" to \\"organized_files/jpg/\\" ```","solution":"import os import shutil from typing import List def manage_directory_structure(file_paths: List[str], directory: str) -> None: if not os.path.exists(directory): os.makedirs(directory) for file_path in file_paths: if not os.path.isfile(file_path): continue _, ext = os.path.splitext(file_path) ext = ext.lstrip(\'.\').lower() ext_dir = os.path.join(directory, ext) if not os.path.exists(ext_dir): os.makedirs(ext_dir) base_name = os.path.basename(file_path) target_path = os.path.join(ext_dir, base_name) counter = 1 while os.path.exists(target_path): base_name_without_ext, extension = os.path.splitext(base_name) new_base_name = f\\"{base_name_without_ext}_{counter}{extension}\\" target_path = os.path.join(ext_dir, new_base_name) counter += 1 shutil.move(file_path, target_path)"},{"question":"# Question: URL Shortener Service You are tasked with creating a simplified URL shortener service using Python. This service will take long URLs and convert them into shorter versions. The structure should support maintaining a record of the shortened URLs and their corresponding original URLs, as well as retrieving the original URL when provided with the shortened version. Requirements: 1. **Input**: - The long URL should be provided by the user. If a long URL is not provided, prompt the user for input. - Optionally, the user can input a short code to retrieve the original URL. 2. **URL Storage**: - Maintain an in-memory dictionary to store the mappings between long URLs and their shortened versions. 3. **URL Shortening**: - Implement a method to generate a short code (e.g., a unique string of 6 characters) for each long URL provided. - Ensure the short code is unique and not previously used. 4. **URL Retrieval**: - Allow users to retrieve the original URL by inputting the corresponding short code. - Handle cases where a non-existent short code is requested. 5. **Error Handling**: - Inform the user if there are errors in the URL (e.g., invalid URL format) or if the short code provides no corresponding long URL. Implementation Details: 1. **Helper Functions**: - Implement helper functions to generate unique short codes and perform URL validations. 2. **Constraints**: - Python 3 must be used. - URLs provided must be valid HTTP/HTTPS URLs. 3. **In-Memory Storage**: - Use a dictionary for the storage of URL mappings for simplicity. - Note that this storage will not persist across different runtime instances. Usage Examples: ```sh python url_shortener.py Enter a long URL to shorten: https://www.openai.com/research/gpt-3/ Shortened URL: http://short.url/abc123 Enter a short code to retrieve the original URL: abc123 Original URL: https://www.openai.com/research/gpt-3/ ``` # Code Implementation: Implement your solution with the function signatures given below: ```python def shorten_url(long_url: str) -> str: pass def retrieve_original_url(short_code: str) -> str: pass ```","solution":"import random import string import re url_mapping = {} short_code_length = 6 def shorten_url(long_url: str) -> str: Takes a long URL and returns a shortened version. if not validate_url(long_url): raise ValueError(\\"Invalid URL\\") short_code = generate_unique_short_code() url_mapping[short_code] = long_url return f\\"http://short.url/{short_code}\\" def retrieve_original_url(short_code: str) -> str: Takes a short code and returns the original URL. if short_code in url_mapping: return url_mapping[short_code] raise ValueError(\\"Short code not found\\") def generate_unique_short_code() -> str: Generates a unique short code. characters = string.ascii_letters + string.digits while True: short_code = \'\'.join(random.choices(characters, k=short_code_length)) if short_code not in url_mapping: return short_code def validate_url(url: str) -> bool: Validates if the provided URL is an HTTP/HTTPS URL. regex = re.compile( r\'^https?://\' # http:// or https:// r\'(w+(-w+)*.)*w+(-w+)*(?::d+)?(/.*)?\', re.IGNORECASE) return re.match(regex, url) is not None"},{"question":"# Problem Statement You are responsible for developing a function that evaluates a numerical expression provided as a string and computes its result. However, the expression adheres to a specific set of rules and restrictions. The function must correctly handle the operators and precedence as described. # Expected Behavior You need to implement a function `evaluate_expression(expression: str) -> float` that processes a given mathematical expression and calculates its result based on the following rules: 1. The expression contains only the following characters: - Digits (`0-9`) - Decimal points (`.`) - Operators (`+`, `-`, `*`, `/`) - Parentheses (`(`, `)`) 2. Operators have the usual precedence: - Multiplication and division first (`*`, `/`), from left to right. - Addition and subtraction (`+`, `-`), from left to right. 3. Parentheses override operator precedence. 4. Decimal numbers are allowed. # Input and Output **Input**: - `expression`: A non-empty string representing a mathematical expression. **Output**: - A floating-point number representing the evaluated result of the expression. # Constraints - The expression is a valid mathematical expression. - The expression contains at least one digit. # Performance Requirements - The solution should process the input in time complexity responsive to the length of the input, O(n), where n is the length of the expression. # Example ```python def evaluate_expression(expression: str) -> float: # Write your implementation here # Example Usage expression1 = \\"3+5*2\\" result1 = evaluate_expression(expression1) # Expected Output: 13.0 expression2 = \\"(2+7)/3\\" result2 = evaluate_expression(expression2) # Expected Output: 3.0 expression3 = \\"10-2*5+3*(2-1)\\" result3 = evaluate_expression(expression3) # Expected Output: 3.0 ``` Implement the function according to the specified behavior and constraints.","solution":"def evaluate_expression(expression: str) -> float: def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 def apply_op(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return a / b def calculate(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue elif tokens[i] == \'(\': ops.append(tokens[i]) elif tokens[i].isdigit() or tokens[i] == \'.\': val = 0 decimal_place = 0.1 is_decimal = False while (i < len(tokens) and (tokens[i].isdigit() or tokens[i] == \'.\')): if tokens[i] == \'.\': is_decimal = True i += 1 continue if is_decimal: val += int(tokens[i]) * decimal_place decimal_place *= 0.1 else: val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while len(ops) != 0 and ops[-1] != \'(\': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(tokens[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1] return calculate(expression)"},{"question":"# Problem Statement You are tasked with implementing a basic memory-efficient Set data structure using a Hash Table with Separate Chaining to handle collisions. The Set should support standard set operations such as addition, removal, and membership checks. # Requirements 1. **Class Definition**: Create a class called `CustomSet`. 2. **Methods**: - `__init__(self)`: Initializes the set. - `add(self, element: T)`: Adds an element to the set. - `remove(self, element: T)`: Removes an element from the set. If the element does not exist, raise a `KeyError`. - `contains(self, element: T) -> bool`: Checks if the element exists in the set. - `__len__(self) -> int`: Returns the number of elements in the set. - `__iter__(self)`: Returns an iterator to iterate over the elements of the set. 3. **Data Management**: Store the elements in a dynamic array with automatic resizing functionality. 4. **Collision Handling**: Use separate chaining (list) to handle collisions. 5. **Performance Requirements**: * Ensure that element lookups, additions, and removals have average-case constant time complexity. 6. **Memory Efficiency**: Optimize for minimal memory usage while maintaining efficiency. # Constraints - The elements of the set will be unique identifiers and can include integers, strings, or any hashable type. - The set will not exceed 10,000 elements. - The input will always be well-formed and valid. # Input/Output Structure * **Input**: N/A (The input parameters will be method parameters) * **Output**: The return values depend on the specific method called. # Example ```python # Example Usage custom_set = CustomSet() custom_set.add(10) custom_set.add(20) custom_set.add(\\"apple\\") print(custom_set.contains(10)) # Output: True print(custom_set.contains(\\"banana\\")) # Output: False custom_set.remove(10) print(custom_set.contains(10)) # Output: False print(len(custom_set)) # Output: 2 for element in custom_set: print(element) # Output: 20, apple (order may vary based on implementation) ``` Implement the `CustomSet` class as described, ensuring to properly handle collisions and resizing. This question tests your understanding of hash tables, separate chaining, and basic set operations.","solution":"from typing import List, Hashable, Optional class CustomSet: def __init__(self): self.initial_capacity = 8 self.bucket_array: List[Optional[List[Hashable]]] = [None] * self.initial_capacity self.size = 0 self.load_factor_threshold = 0.75 def _hash(self, key: Hashable) -> int: return hash(key) % len(self.bucket_array) def _resize(self): old_bucket_array = self.bucket_array new_capacity = len(self.bucket_array) * 2 self.bucket_array = [None] * new_capacity self.size = 0 for bucket in old_bucket_array: if bucket: for element in bucket: self.add(element) def add(self, element: Hashable): if self.size / len(self.bucket_array) > self.load_factor_threshold: self._resize() bucket_index = self._hash(element) if self.bucket_array[bucket_index] is None: self.bucket_array[bucket_index] = [] if element not in self.bucket_array[bucket_index]: self.bucket_array[bucket_index].append(element) self.size += 1 def remove(self, element: Hashable): bucket_index = self._hash(element) bucket = self.bucket_array[bucket_index] if bucket and element in bucket: bucket.remove(element) self.size -= 1 else: raise KeyError(f\\"Element {element} not found\\") def contains(self, element: Hashable) -> bool: bucket_index = self._hash(element) bucket = self.bucket_array[bucket_index] return bucket is not None and element in bucket def __len__(self) -> int: return self.size def __iter__(self): for bucket in self.bucket_array: if bucket: for element in bucket: yield element"},{"question":"# Date Representation Format Conversion In many applications, especially those dealing with international audiences, converting dates between different representation formats is crucial. This task involves writing a function that converts a given date from one format to another specified format. **Problem Statement**: Given a date string and its current format, implement the `convert_date_format` function to convert it to another specified format. The function should handle various formats including but not limited to: - \\"YYYY-MM-DD\\" - \\"MM/DD/YYYY\\" - \\"DD-MM-YYYY\\" - \\"Month DD, YYYY\\" # Function Signature: ```python def convert_date_format(date: str, from_format: str, to_format: str) -> str: pass ``` # Input: * `date` (str): The date string to be converted. * `from_format` (str): The format string that specifies the current format of the date. * `to_format` (str): The format string that specifies the desired format of the date. # Output: * Returns a string representing the converted date in the desired format. # Constraints: * Assume valid date strings for the provided formats. * All formats are case-sensitive. * Consider leap years and vary month lengths when appropriate. * Handle all common months and day representations (e.g., \\"January\\", \\"Jan\\"). * The input and output formats are guaranteed to be valid. # Example: ```python # Converts date from \\"YYYY-MM-DD\\" to \\"MM/DD/YYYY\\" print(convert_date_format(\\"2023-10-05\\", \\"YYYY-MM-DD\\", \\"MM/DD/YYYY\\")) # Output: \\"10/05/2023\\" # Converts date from \\"MM/DD/YYYY\\" to \\"YYYY-MM-DD\\" print(convert_date_format(\\"10/05/2023\\", \\"MM/DD/YYYY\\", \\"YYYY-MM-DD\\")) # Output: \\"2023-10-05\\" # Converts date from \\"DD-MM-YYYY\\" to \\"Month DD, YYYY\\" print(convert_date_format(\\"05-10-2023\\", \\"DD-MM-YYYY\\", \\"Month DD, YYYY\\")) # Output: \\"October 05, 2023\\" # Converts date from \\"Month DD, YYYY\\" to \\"YYYY-MM-DD\\" print(convert_date_format(\\"October 5, 2023\\", \\"Month DD, YYYY\\", \\"YYYY-MM-DD\\")) # Output: \\"2023-10-05\\" ``` # Tests: Provide additional test cases covering edge cases like: - Valid but non-standard formats. - Leap year considerations. - Correct handling of single digit months and days. - Ensure correct transformation of date parts and delimiters.","solution":"from datetime import datetime def convert_date_format(date: str, from_format: str, to_format: str) -> str: # Mapping custom date formats to strftime/strptime compatible formats format_mappings = { \\"YYYY-MM-DD\\": \\"%Y-%m-%d\\", \\"MM/DD/YYYY\\": \\"%m/%d/%Y\\", \\"DD-MM-YYYY\\": \\"%d-%m-%Y\\", \\"Month DD, YYYY\\": \\"%B %d, %Y\\", } # Convert custom formats to strftime compatible formats from_format_dt = format_mappings[from_format] to_format_dt = format_mappings[to_format] # Parse the date with the from_format parsed_date = datetime.strptime(date, from_format_dt) # Convert the date to the desired format return parsed_date.strftime(to_format_dt)"},{"question":"# Coding Assessment Question Context A radix is a base of a numeration system. You are to implement an algorithm that converts a given number from one radix (base) to another. This problem requires you to convert a number represented as a string in a given source base to its string representation in a target base. Task Implement a function `convert_base(number: str, source_base: int, target_base: int) -> str` that converts `number` from the `source_base` to the `target_base`. Function Signature ```python def convert_base(number: str, source_base: int, target_base: int) -> str: pass ``` Input * `number`: A string representing the number in the source_base. * `source_base`: An integer (2 <= source_base <= 36) representing the base of the input number. * `target_base`: An integer (2 <= target_base <= 36) representing the base to convert the input number into. Output * Returns a string representing the `number` in the `target_base`. Examples ```python assert convert_base(\\"101\\", 2, 10) == \\"5\\" assert convert_base(\\"5\\", 10, 2) == \\"101\\" assert convert_base(\\"A\\", 16, 2) == \\"1010\\" assert convert_base(\\"123\\", 8, 10) == \\"83\\" assert convert_base(\\"Z\\", 36, 10) == \\"35\\" ``` Constraints * The input `number` will be a non-empty string and a valid representation in the given `source_base`. * The maximum length of `number` is 10 characters. * The `source_base` and `target_base` will be between 2 and 36 inclusive. Performance Requirements * Ensure your implementation efficiently handles the conversion within the constraints. Python\'s built-in functions may be utilized where applicable for conversions.","solution":"def convert_base(number: str, source_base: int, target_base: int) -> str: Converts a number from a given source_base to a target_base. if not (2 <= source_base <= 36) or not (2 <= target_base <= 36): raise ValueError(\\"Base should be between 2 and 36 inclusively.\\") # Convert number to base 10 base_10_decimal = int(number, source_base) # Convert base 10 number to target_base if target_base == 10: return str(base_10_decimal) result = \\"\\" while base_10_decimal > 0: remainder = base_10_decimal % target_base base_10_decimal //= target_base if remainder < 10: result = chr(remainder + ord(\'0\')) + result else: result = chr(remainder - 10 + ord(\'A\')) + result return result or \\"0\\""},{"question":"LRU Cache Implementation Background Scenario An LRU (Least Recently Used) cache is a data structure that stores a fixed number of items. When the cache reaches its limit, it removes the least recently accessed item before inserting a new one. You are tasked with implementing an LRU Cache from scratch. Function Description Implement a class `LRUCache` with the following methods: 1. `__init__(capacity: int) -> None`: Initializes the cache with a given capacity. 2. `get(key: int) -> int`: Retrieves the value of the key if it is in the cache; otherwise, returns -1. 3. `put(key: int, value: int) -> None`: Updates the value of the key if the key exists. Otherwise, it inserts the key-value pair into the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. Expected Input and Output: 1. `__init__(capacity: int) -> None` * **Input**: An integer `capacity` which is the maximum number of items the cache can hold. * **Output**: None. 2. `get(key: int) -> int` * **Input**: An integer `key`. * **Output**: The value associated with `key` if present in the cache; otherwise, -1. 3. `put(key: int, value: int) -> None` * **Input**: Two integers `key` and `value`. * **Output**: None. Constraints: 1. The capacity is between 1 and 1000. 2. The number of `get` and `put` operations is between 1 and 10^5. 3. The keys and values are integers between 1 and 10^5. Specification: ```python class LRUCache: def __init__(self, capacity: int) -> None: Initializes the LRU cache with a given capacity. Parameters: capacity (int): The capacity of the cache. # Task implementation here pass def get(self, key: int) -> int: Retrieves the value associated with the given key if it exists, else returns -1. Parameters: key (int): The key to look up in the cache. Returns: int: The value associated with the key or -1 if the key is not found. # Task implementation here pass def put(self, key: int, value: int) -> None: Inserts or updates the key-value pair in the cache. If the cache exceeds its capacity, the least recently used item will be removed. Parameters: key (int): The key to be added or updated in the cache. value (int): The value to be associated with the key. # Task implementation here pass ``` Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # The cache is full, remove key 2. print(cache.get(2)) # Output: -1 (not found) cache.put(4, 4) # Remove key 1. print(cache.get(1)) # Output: -1 (not found) print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ```","solution":"class LRUCache: def __init__(self, capacity: int) -> None: Initializes the LRU cache with a given capacity. Parameters: capacity (int): The capacity of the cache. self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: Retrieves the value associated with the given key if it exists, else returns -1. Parameters: key (int): The key to look up in the cache. Returns: int: The value associated with the key or -1 if the key is not found. if key in self.cache: self.order.remove(key) self.order.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: Inserts or updates the key-value pair in the cache. If the cache exceeds its capacity, the least recently used item will be removed. Parameters: key (int): The key to be added or updated in the cache. value (int): The value to be associated with the key. if key in self.cache: self.cache[key] = value self.order.remove(key) self.order.append(key) else: if len(self.cache) >= self.capacity: lru_key = self.order.pop(0) del self.cache[lru_key] self.cache[key] = value self.order.append(key)"},{"question":"# Scenario You are developing a feature for an e-commerce application that requires computing the moving average of sales data to help with demand forecasting. The moving average helps smooth out short-term fluctuations and highlight longer-term trends. # Task Implement a function that computes the simple moving average (SMA) of a list of sales figures. The SMA is calculated by taking the average of the data points in a specified window size. # Specifications * Write a function `moving_average` which takes two parameters: - `data` (list of floats): A list of sales figures. - `window_size` (int): The number of data points to consider for each average. * Output should be a list of floats where each element represents the SMA of the sales data within the specified window. * Ensure the function handles edge cases such as: - The window size being larger than the length of the data list. - The data list being empty. # Formula ( SMA_i = frac{1}{n} sum_{j=i}^{i+n-1} data[j] ) where ( n ) is the window size. # Assumptions - The `window_size` will always be a positive integer. - The `data` list can have arbitrary length. # Examples ```python >>> moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], window_size=3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] >>> moving_average([10, 20, 30, 40, 50, 60], window_size=4) [25.0, 35.0, 45.0] >>> moving_average([5, 10, 15], window_size=5) [] ```","solution":"def moving_average(data, window_size): Computes the simple moving average of the sales data within the specified window size. :param data: List of sales figures (floats). :param window_size: The number of data points to consider for each average (int). :return: List of floats representing the moving average. if len(data) < window_size or window_size <= 0: return [] moving_averages = [] for i in range(len(data) - window_size + 1): window = data[i:i + window_size] window_average = sum(window) / window_size moving_averages.append(window_average) return moving_averages"},{"question":"# Assessment Question **Q2**: Write a function `flatten_json_structure` that takes a nested dictionary representing a JSON-like structure and flattens it into a single-level dictionary. The keys in the flattened dictionary should be the paths to the original keys, joined by a dot (`.`). ```python def flatten_json_structure(nested_dict: dict) -> dict: Flatten a nested dictionary representing a JSON-like structure. The function should traverse the dictionary and produce a flattened version where the keys are the paths from the root to the original key, joined by dots. Args: nested_dict (dict): A nested dictionary to flatten. Returns: dict: A single-level dictionary with dot-separated paths as keys. Example: >>> flatten_json_structure({ ... \\"a\\": { ... \\"b\\": { ... \\"c\\": 1 ... }, ... \\"d\\": 2 ... }, ... \\"e\\": 3 ... }) {\'a.b.c\': 1, \'a.d\': 2, \'e\': 3} >>> flatten_json_structure({\\"key1\\": {\\"key2\\": {\\"key3\\": 4}}, \\"key4\\": 5}) {\'key1.key2.key3\': 4, \'key4\': 5} pass ``` **Constraints and Notes**: - The provided dictionary can be arbitrarily nested. - Keys in the nested dictionary are strings, and values can be either another dictionary or any standard data type (e.g., int, float, string). - The function should handle deeply nested structures efficiently without causing recursion depth errors. **Expected Input and Output**: ```python assert flatten_json_structure({\'a\': {\'b\': {\'c\': 1}, \'d\': 2}, \'e\': 3}) == {\'a.b.c\': 1, \'a.d\': 2, \'e\': 3} assert flatten_json_structure({\'key1\': {\'key2\': {\'key3\': 4}}, \'key4\': 5}) == {\'key1.key2.key3\': 4, \'key4\': 5} assert flatten_json_structure({\'x\': {\'y\': {\'z\': {\'a\': 10}}}, \'b\': 20}) == {\'x.y.z.a\': 10, \'b\': 20} ```","solution":"def flatten_json_structure(nested_dict, parent_key=\'\', sep=\'.\'): items = {} for k, v in nested_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.update(flatten_json_structure(v, new_key, sep=sep)) else: items[new_key] = v return items"},{"question":"# Coding Assessment Question Context In database systems, indexing is a critical feature for optimizing query performance. One common type of index is a \\"unique index,\\" which ensures that no two rows in a table have the same value for the indexed column. For this task, you need to simulate part of this functionality by creating a function that validates uniqueness across multiple entries. Task Write a function `has_unique_entries(entries: List[str]) -> bool` that takes a list of strings and returns `True` if all the strings are unique, otherwise returns `False`. Optimize your solution for performance. Input * A list of strings `entries` where `0 <= len(entries) <= 10^5`. Output * A boolean value: `True` if all strings in `entries` are unique, otherwise `False`. Constraints * Each string in the list will consist of ASCII characters only. *Optimize for O(n) time complexity. * Consider edge cases, such as an empty list or very large lists. Examples ```python assert has_unique_entries([\\"entry1\\", \\"entry2\\", \\"entry3\\"]) == True assert has_unique_entries([\\"entry1\\", \\"entry2\\", \\"entry1\\"]) == False assert has_unique_entries([]) == True assert has_unique_entries([\\"a\\", \\"A\\", \\"\\"]) == True assert has_unique_entries([\\"unique\\", \\"entries\\", \\"check\\"]) == True assert has_unique_entries([\\"duplicate\\", \\"duplicate\\"]) == False ``` **Note**: You may use additional data structures like sets or hashmaps to store and check for duplicate entries.","solution":"def has_unique_entries(entries): Returns True if all strings in the list are unique, otherwise False. return len(entries) == len(set(entries))"},{"question":"```markdown # Coding Assessment Question You are given two different implementations to find the number of occurrences of a target value within a list. One implementation uses a simple iterative method, and the other uses a recursive method. # Task Write a Python function that performs the following steps: 1. Reads a list of integers and a target value. 2. Counts the occurrences of the target value using both the iterative and recursive methods. 3. If the counts match, return a string \\"Matching Counts: [count]\\". 4. If they don\'t match, identify which method found the higher count and return a string \\"Discrepancy: Iterative found [iterative_count], Recursive found [recursive_count]\\". # Requirements 1. **Input**: A list of integers and a target integer. 2. **Output**: A string message as specified above. 3. **Constraints**: * The list input can have up to 5,000,000 elements. * If the input list is empty, the function should return the string \\"Empty list provided\\". * The target value may or may not be present in the list. # Performance: * The function must handle large lists efficiently, maintaining optimal space and time complexity. Examples: ```python # Example 1: input_list = [1, 3, 1, 7, 1, 2, 1, 6, 1, 10] target = 1 find_target_count(input_list, target) # Output: \\"Matching Counts: 5\\" # Example 2: input_list = [4, -2, 19, -30, 0, 18, 19] target = 19 find_target_count(input_list, target) # Output: \\"Matching Counts: 2\\" # Example 3: input_list = [] target = 3 find_target_count(input_list, target) # Output: \\"Empty list provided\\" ``` ```","solution":"def iterative_count(input_list, target): Counts the occurrences of the target value using an iterative method. count = 0 for num in input_list: if num == target: count += 1 return count def recursive_count(input_list, target, index=0): Counts the occurrences of the target value using a recursive method. if index == len(input_list): return 0 return (1 if input_list[index] == target else 0) + recursive_count(input_list, target, index + 1) def find_target_count(input_list, target): if not input_list: return \\"Empty list provided\\" iter_count = iterative_count(input_list, target) recur_count = recursive_count(input_list, target) if iter_count == recur_count: return f\\"Matching Counts: {iter_count}\\" else: return f\\"Discrepancy: Iterative found {iter_count}, Recursive found {recur_count}\\""},{"question":"# Prime Number Finder **Background**: Prime numbers are numbers greater than 1 that have no divisors other than 1 and themselves. They play a crucial role in various fields, including cryptography, number theory, and computer algorithms, due to their unique properties. **Task**: You are to implement a function that generates all prime numbers up to a given limit using the Sieve of Eratosthenes algorithm. This algorithm efficiently finds all primes less than or equal to a specified integer. # Function Specification 1. **Prime Finder Function (find_primes)** - **Input**: - `n` (int): An integer representing the upper limit (inclusive) for finding prime numbers. - **Output**: - List of integers representing all prime numbers less than or equal to `n` (e.g., `[2, 3, 5, 7, 11]`). # Constraints - You may assume that the input integer `n` will be greater than or equal to 2. - The function should follow the Sieve of Eratosthenes algorithm to ensure efficiency, particularly for large values of `n`. **Example**: ```python >>> find_primes(10) [2, 3, 5, 7] >>> find_primes(20) [2, 3, 5, 7, 11, 13, 17, 19] ``` *To implement the Sieve of Eratosthenes, you may find it useful to use list operations, loops, and boolean arrays to track prime numbers.*","solution":"def find_primes(n): Finds all prime numbers up to and including n using the Sieve of Eratosthenes algorithm. Args: n (int): The upper limit (inclusive) for finding prime numbers. Returns: List[int]: A list of all prime numbers less than or equal to n. if n < 2: return [] primes = [True] * (n + 1) p = 2 while p * p <= n: if primes[p]: for i in range(p * p, n + 1, p): primes[i] = False p += 1 return [p for p in range(2, n + 1) if primes[p]]"},{"question":"# Dynamic Memory Allocation Simulation **Objective:** You are tasked with implementing a simple dynamic memory allocation simulator. Your function will manage memory blocks and handle allocation, deallocation, and status queries that mimic the behavior of a dynamic memory allocator. **Function Signature:** ```python def memory_allocator(operations: list[tuple[str, int]]) -> list[int]: # Your implementation here ``` **Input:** - `operations`: A list of tuples representing operations on the memory allocator. Each tuple has the format: 1. `\\"ALLOC\\"` and an integer size indicating a memory allocation request. 2. `\\"FREE\\"` and an integer block_id indicating a memory deallocation request. 3. `\\"STATUS\\"` with -1 indicating a query for the current state of memory blocks. **Output:** - Returns a list of integers: * For each `\\"ALLOC\\"` operation, return the allocated block ID (an integer). * For each `\\"FREE\\"` operation, return -1 to indicate successful deallocation. * For each `\\"STATUS\\"` operation, return a list of sizes of all allocated blocks. **Constraints:** 1. Block IDs are zero-based and increment sequentially with each allocation. 2. Memory deallocation requests will be valid and refer to previously allocated blocks. 3. Ensure the allocator handles consecutive operations efficiently. **Performance Requirements:** - Your solution should manage memory blocks optimally with respect to both space and time, handling multiple operations gracefully. - Leverage appropriate data structures to maintain and update the state of memory blocks dynamically. **Instructions:** 1. Implement a data structure to keep track of allocated and free memory blocks. 2. Handle each operation by updating the state of memory blocks and outputting the results in the required format. 3. Ensure your implementation correctly and efficiently processes all valid operations. # Example Given the following operations: Operations: `[(\\"ALLOC\\", 10), (\\"ALLOC\\", 20), (\\"STATUS\\", -1), (\\"FREE\\", 0), (\\"STATUS\\", -1), (\\"ALLOC\\", 15)]` **Returns:** ``` [0, 1, [10, 20], -1, [20], 2] ``` Explanation: 1. Allocate 10 units: returns block ID 0. 2. Allocate 20 units: returns block ID 1. 3. Query status: returns [10, 20]. 4. Free block ID 0: returns -1. 5. Query status: returns [20]. 6. Allocate 15 units: returns block ID 2. Implement the above function in Python and thoroughly test your solution. *Note: You can use additional helper functions if needed to structure your memory allocation logic effectively.* By creating a problem that focuses on simulating dynamic memory allocation, we ensure complexity and scope alignment with the existing question, offering a practical and algorithm-based challenge.","solution":"def memory_allocator(operations): blocks = [] block_sizes = [] results = [] for operation in operations: if operation[0] == \\"ALLOC\\": size = operation[1] block_id = len(block_sizes) block_sizes.append(size) results.append(block_id) elif operation[0] == \\"FREE\\": block_id = operation[1] block_sizes[block_id] = None results.append(-1) elif operation[0] == \\"STATUS\\": status = [size for size in block_sizes if size is not None] results.append(status) return results"},{"question":"Implementing AVL Tree Insert Operation Overview You are required to implement an AVL Tree, a self-balancing binary search tree where the difference between the heights of left and right subtrees cannot be more than one for all nodes. The problem focuses on inserting nodes while maintaining the AVL property. Problem Statement Write a Python class `AVLTree` with the following methods: - `insert(self, key: int) -> None`: Inserts a node with the given key into the AVL Tree. - `inorder_traversal(self) -> list[int]`: Returns a list of keys in the tree in inorder sequence. Implement the necessary balancing operations (single and double rotations) to ensure the tree remains balanced after each insertion. Input - `key`: An integer representing the key to be inserted into the AVL Tree. Output - `inorder_traversal` should return a list of integers representing an inorder traversal of the AVL tree. Constraints - The keys will be unique integers. - The keys will be within the range of -10^5 to 10^5. - You will ensure that the AVL property is maintained after each insertion. Performance Your implementation should efficiently manage the balancing of the tree to ensure that insertion operations maintain O(log n) complexity. Example ```python class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, key: int) -> None: # Function to insert key and balance the tree ... def inorder_traversal(self) -> list[int]: # Function to print inorder traversal ... # Helper methods to maintain AVL properties def _height(self, node: AVLTreeNode) -> int: ... def _rotate_left(self, z: AVLTreeNode) -> AVLTreeNode: ... def _rotate_right(self, z: AVLTreeNode) -> AVLTreeNode: ... def _get_balance(self, node: AVLTreeNode) -> int: ... def _insert_node(self, node: AVLTreeNode, key: int) -> AVLTreeNode: ... # Example Test Cases avl = AVLTree() avl.insert(10) avl.insert(20) avl.insert(30) assert avl.inorder_traversal() == [10, 20, 30] avl.insert(5) avl.insert(15) assert avl.inorder_traversal() == [5, 10, 15, 20, 30] avl.insert(25) assert avl.inorder_traversal() == [5, 10, 15, 20, 25, 30] ``` Implement the necessary methods and logic to ensure the AVL Tree maintains balance after each insertion and correctly performs an inorder traversal of the nodes.","solution":"class AVLTreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def insert(self, key: int) -> None: if not self.root: self.root = AVLTreeNode(key) else: self.root = self._insert_node(self.root, key) def inorder_traversal(self) -> list[int]: result = [] self._inorder_helper(self.root, result) return result # Helper methods to maintain AVL properties def _height(self, node: AVLTreeNode) -> int: return node.height if node else 0 def _rotate_left(self, z: AVLTreeNode) -> AVLTreeNode: y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _rotate_right(self, z: AVLTreeNode) -> AVLTreeNode: y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _get_balance(self, node: AVLTreeNode) -> int: return self._height(node.left) - self._height(node.right) if node else 0 def _insert_node(self, node: AVLTreeNode, key: int) -> AVLTreeNode: if not node: return AVLTreeNode(key) elif key < node.key: node.left = self._insert_node(node.left, key) else: node.right = self._insert_node(node.right, key) node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _inorder_helper(self, node: AVLTreeNode, result: list[int]) -> None: if node: self._inorder_helper(node.left, result) result.append(node.key) self._inorder_helper(node.right, result)"},{"question":"# Word Frequency Histogram Background: Text analysis often involves generating frequency histograms of words to understand text composition and identify commonly used terms. A histogram in this context is a representation that shows how frequently each word occurs within a given piece of text. Task: Implement a function `word_frequency_histogram` that takes in a string of text and returns a dictionary representing the frequency histogram of words in the text. Words should be considered case-insensitive, and punctuation should be ignored. Function Signature: ```python def word_frequency_histogram(text: str) -> dict: Generate a word frequency histogram from the input text. Input Parameters: text (str): A string of text to analyze. Returns: dict: A dictionary where the keys are words (in lowercase) and the values are their frequencies in the text. ``` Example Tests: ```python >>> word_frequency_histogram(\\"Hello, World! Hello World!\\") {\'hello\': 2, \'world\': 2} >>> word_frequency_histogram(\\"This is a test. This test is only a test.\\") {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} >>> word_frequency_histogram(\\"Python is great. Isn\'t it? Yes, Python is great!\\") {\'python\': 2, \'is\': 2, \'great\': 2, \'isnt\': 1, \'it\': 1, \'yes\': 1} >>> word_frequency_histogram(\\"To be, or not to be, that is the question.\\") {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1} >>> word_frequency_histogram(\\"\\") {} ``` Constraints: * The function should ignore case (i.e., treat \\"Word\\" and \\"word\\" as the same word). * Ignore punctuation and special characters, considering only alphanumeric characters and spaces. * Handle empty input texts gracefully (return an empty dictionary). Notes: * Words are sequences of alphanumeric characters separated by spaces. * Normalize the text to lowercase and remove punctuation before counting word frequencies. * Consider corner cases like an input consisting solely of punctuation or various spacing issues (e.g., multiple spaces). This question requires understanding string manipulation, case normalization, and use of dictionaries to store and count word frequencies, which aligns with typical coding assessments\' focus on text processing and data structures.","solution":"import re from collections import Counter def word_frequency_histogram(text: str) -> dict: Generate a word frequency histogram from the input text. Input Parameters: text (str): A string of text to analyze. Returns: dict: A dictionary where the keys are words (in lowercase) and the values are their frequencies in the text. # Normalize text to lowercase text = text.lower() # Remove punctuation and special characters text = re.sub(r\'[^a-z0-9s]\', \'\', text) # Split text into words words = text.split() # Count word frequencies frequency = Counter(words) return dict(frequency)"},{"question":"# Problem Statement You need to create a function that returns the sum of all unique prime factors of a given positive integer `n`. Prime factors of a number are prime numbers that divide the number exactly without leaving a remainder. For example, the prime factors of `60` are `2`, `3`, and `5`, and the sum of these prime factors is `10`. # Function Signature ```python def sum_unique_prime_factors(n: int) -> int: ``` # Input * `n`: A positive integer greater than `1`. # Output * Returns the sum of all unique prime factors of `n`. # Constraints * `n` is always a positive integer greater than `1`. # Examples ```python assert sum_unique_prime_factors(60) == 10 # Prime factors are 2, 3, and 5 assert sum_unique_prime_factors(28) == 5 # Prime factors are 2 and 7 assert sum_unique_prime_factors(49) == 7 # Prime factor is 7 assert sum_unique_prime_factors(17) == 17 # Prime factor is 17 assert sum_unique_prime_factors(100) == 5 # Prime factors are 2 and 5 ``` # Explanation 1. **Example 1**: For `n = 60`, the prime factors are `2`, `3`, and `5`. Their sum is `2 + 3 + 5 = 10`. 2. **Example 2**: For `n = 28`, the prime factors are `2` and `7`. Their sum is `2 + 7 = 9`. 3. **Example 3**: For `n = 49`, the only prime factor is `7`. Thus, the sum is `7`. 4. **Example 4**: For `n = 17`, the only prime factor is `17`. Thus, the sum is `17`. 5. **Example 5**: For `n = 100`, the prime factors are `2` and `5`. Their sum is `2 + 5 = 7`.","solution":"def sum_unique_prime_factors(n: int) -> int: Returns the sum of all unique prime factors of n. def prime_factors(n): i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors unique_factors = prime_factors(n) return sum(unique_factors)"},{"question":"**Question: \\"Predicting Rabbit Population Dynamics using the Logistic Growth Model\\"** **Context**: In ecology, predicting changes in population size over time is crucial for understanding species dynamics. The logistic growth model, in particular, is a common way to simulate population changes for a species in a limited environment with carrying capacity. Imagine studying a rabbit population in a confined nature reserve. **Task**: Implement the function `rabbit_population_simulation` using the Explicit Euler method to estimate population changes over a given period. # Function Signature: ```python def rabbit_population_simulation(initial_population: int, time_span: float, step_size: float, carrying_capacity: int, growth_rate: float) -> np.ndarray: ``` # Input: - `initial_population` (int): The initial number of rabbits at the start of the simulation (t=0). Must be non-negative. - `time_span` (float): The total time for which the simulation runs. Must be positive. - `step_size` (float): The increment of time for each step in the simulation. Must be positive. - `carrying_capacity` (int): The maximum number of rabbits the nature reserve can support. Must be positive. - `growth_rate` (float): The intrinsic growth rate of the rabbit population. # Output: - Return a numpy array containing the estimated rabbit populations at each timestep. # Constraints: - The logistic growth differential equation modeling the population change is `dP/dt = rP(1 - P/K)` (Where `P` is the population, `r` is the growth rate, and `K` is the carrying capacity). # Requirements: - Use the Explicit Euler method to solve for the populations over the given time span. - Handle edge cases such as non-positive `time_span`, `step_size`, and `carrying_capacity` or non-negative `initial_population`. # Example: ```python # Example input initial_population = 50 time_span = 10.0 step_size = 0.5 carrying_capacity = 500 growth_rate = 0.1 # Call the function population_estimations = rabbit_population_simulation(initial_population, time_span, step_size, carrying_capacity, growth_rate) ``` In this example, if the `step_size` is small enough, the array `population_estimations` should show an initial exponential growth that gradually slows as the population approaches the carrying capacity of 500 over the 10 time units. Note: Your solution should accurately implement the Explicit Euler method to model the changes in the rabbit population according to the provided logistic growth differential equation, and should correctly handle the provided input scenarios.","solution":"import numpy as np def rabbit_population_simulation(initial_population: int, time_span: float, step_size: float, carrying_capacity: int, growth_rate: float) -> np.ndarray: Estimates population changes using the Explicit Euler method for the logistic growth model. Parameters: - initial_population (int): Initial number of rabbits (P0) - time_span (float): Total time to simulate - step_size (float): Time increment per step - carrying_capacity (int): Maximum population the environment can support (K) - growth_rate (float): Intrinsic growth rate (r) Returns: - np.ndarray: Array of estimated rabbit populations at each timestep # Calculate the number of steps n_steps = int(time_span / step_size) + 1 # Initialize population array populations = np.zeros(n_steps) populations[0] = initial_population # Perform simulation using Explicit Euler method for i in range(1, n_steps): P = populations[i-1] dP_dt = growth_rate * P * (1 - P / carrying_capacity) # Logistic growth differential equation populations[i] = P + step_size * dP_dt return populations"},{"question":"# Advanced Data Structures: Priority Queue Operations You have been tasked with implementing a priority queue to manage tasks based on their priority levels. Task: Implement a class `PriorityQueue` with the following methods: 1. **`insert(task: str, priority: int) -> None`**: Insert a new task with the given priority into the priority queue. 2. **`extract_max() -> str`**: Remove and return the task with the highest priority. If there are multiple tasks with the same highest priority, return the one that was inserted first. 3. **`get_max() -> str`**: Return the task with the highest priority without removing it from the queue. If there are multiple tasks with the same highest priority, return the one that was inserted first. 4. **`remove(task: str) -> bool`**: Remove a specific task from the priority queue by its name. Return `True` if the task was successfully removed, or `False` if the task was not found. 5. **`change_priority(task: str, new_priority: int) -> bool`**: Change the priority of an existing task. Return `True` if the priority was successfully changed, or `False` if the task was not found. Specifications: * **Input Format**: - Various method calls will be made to the `PriorityQueue` class with parameters as described. * **Output Format**: - For `extract_max` and `get_max`, return the task name. - For `remove` and `change_priority`, return a boolean indicating success. * **Constraints**: - Task names will be non-empty strings. - Priorities will be integer values. - The priority queue should handle at least 1000 tasks efficiently. Example: ```python pq = PriorityQueue() pq.insert(\\"Task1\\", 3) pq.insert(\\"Task2\\", 2) pq.insert(\\"Task3\\", 1) pq.insert(\\"Task4\\", 3) print(pq.get_max()) # Output: \\"Task1\\" print(pq.extract_max()) # Output: \\"Task1\\" print(pq.extract_max()) # Output: \\"Task4\\" print(pq.remove(\\"Task2\\")) # Output: True print(pq.change_priority(\\"Task3\\", 5)) # Output: True print(pq.get_max()) # Output: \\"Task3\\" print(pq.change_priority(\\"NonExistentTask\\", 10)) # Output: False ``` Additional Information: 1. You should use an efficient data structure that supports the priority queue operations mentioned above. 2. Handle edge cases such as removing or changing the priority of a task not in the queue and extracting from an empty queue. 3. Maintain the stability of the queue such that tasks with the same priority are handled based on their insertion order. Keep in mind the importance of optimal performance for all operations in this question.","solution":"import heapq class PriorityQueue: def __init__(self): self._heap = [] self._entry_finder = {} self._counter = 0 self._REMOVED = \'<removed-task>\' def insert(self, task: str, priority: int) -> None: if task in self._entry_finder: self.remove(task) self._counter += 1 entry = [-priority, self._counter, task] self._entry_finder[task] = entry heapq.heappush(self._heap, entry) def extract_max(self) -> str: while self._heap: priority, count, task = heapq.heappop(self._heap) if task is not self._REMOVED: del self._entry_finder[task] return task raise KeyError(\'extract_max from an empty priority queue\') def get_max(self) -> str: while self._heap: priority, count, task = self._heap[0] if task is not self._REMOVED: return task heapq.heappop(self._heap) raise KeyError(\'get_max from an empty priority queue\') def remove(self, task: str) -> bool: if task in self._entry_finder: entry = self._entry_finder.pop(task) entry[-1] = self._REMOVED return True return False def change_priority(self, task: str, new_priority: int) -> bool: if self.remove(task): self.insert(task, new_priority) return True return False"},{"question":"# Coding Assessment Question: Design a LRU Cache You need to design a data structure that represents a Least Recently Used (LRU) Cache. The cache should have the following properties: 1. You are given a `CacheNode` class which contains `key`, `value`, and pointers to `prev` and `next` nodes. 2. Implement an `LRUCache` class that supports the following operations: - `get(key: int) -> int`: Return the value corresponding to the key if the key exists in the cache, otherwise return -1. - `set(key: int, value: int)`: Insert or update the value of the key. If the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. Requirements: * The `get` method should move the node to the front indicating it was recently used. * The `set` method should also handle the least recently used logic, adding a new node to the front and possibly removing from the rear. Function Signature: ```python class CacheNode: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def set(self, key: int, value: int): pass ``` Input: * `key` (int): The key for which to get or set the value. * `value` (int): The value to be set for the key. * `capacity` (int): The total capacity of the LRU cache. Output: * For `get` method: An integer representing the value of the key if it exists, otherwise -1. * For `set` method: None (it only modifies the cache). Constraints: * The total number of operations will be less than or equal to 10⁵. * The cache\'s capacity will be at most 10⁴. * Keys and values will be non-negative integers. Example: ```python # Example usage and expected output cache = LRUCache(2) cache.set(1, 1) # Cache is {1=1} cache.set(2, 2) # Cache is {1=1, 2=2} print(cache.get(1)) # Returns 1 cache.set(3, 3) # LRU key was 2, evicts key 2, Cache is {1=1, 3=3} print(cache.get(2)) # Returns -1 (not found) cache.set(4, 4) # LRU key was 1, evicts key 1, Cache is {3=3, 4=4} print(cache.get(1)) # Returns -1 (not found) print(cache.get(3)) # Returns 3 print(cache.get(4)) # Returns 4 ``` Additional Information: You should ensure to maintain the existing class structure, implementing the `LRUCache` to include the `get` and `set` methods. Make sure to handle the edge cases such as cache full and accessing keys that do not exist appropriately.","solution":"class CacheNode: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = CacheNode(-1, -1) self.tail = CacheNode(-1, -1) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add_to_front(self, node): first_real_node = self.head.next self.head.next = node node.prev = self.head node.next = first_real_node first_real_node.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add_to_front(node) return node.value return -1 def set(self, key: int, value: int): if key in self.cache: node = self.cache[key] node.value = value self._remove(node) self._add_to_front(node) else: if len(self.cache) >= self.capacity: lru_node = self.tail.prev self._remove(lru_node) del self.cache[lru_node.key] new_node = CacheNode(key, value) self._add_to_front(new_node) self.cache[key] = new_node"},{"question":"# Question **Context**: The Fibonacci sequence is a popular numeric sequence characterized by the fact that every number after the first two is the sum of the two preceding ones. This sequence has many applications in computer science, such as in recursive function exercises and dynamic programming problems. **Task**: You are required to write a function that computes the nth Fibonacci number. Your function should be efficient and able to compute results for large n within reasonable time constraints. **Function Signature**: ```python def fibonacci_optimized(n: int) -> int: pass ``` **Input**: * An integer `n` such that ( n geq 0 ). **Output**: * An integer that represents the nth Fibonacci number. **Constraints**: 1. ( 0 leq n leq 50 ). **Requirements**: 1. Your implementation should include error handling for invalid inputs. 2. Aim to optimize performance so that it can handle the upper constraint efficiently. **Example**: ```python >>> fibonacci_optimized(0) 0 >>> fibonacci_optimized(1) 1 >>> fibonacci_optimized(10) 55 >>> fibonacci_optimized(20) 6765 ``` Explanation: 1. The first number in the Fibonacci sequence is `0`. 2. The second number in the sequence is `1`. 3. To find any subsequent number, you sum the previous two numbers in the sequence. **Edge cases to consider**: * Handling of negative and non-integer inputs. * Ensuring the function performs efficiently for large values of `n`. **Hints**: - Consider using an iterative approach with a loop to handle large `n` values efficiently. - Alternatively, dynamic programming with a memoization technique might help in optimizing the computation.","solution":"def fibonacci_optimized(n: int) -> int: Returns the nth Fibonacci number. If the input is invalid (negative or non-integer), an exception is raised. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Challenge: Rotate Matrix by 90 Degrees **Context**: In computer graphics and digital image processing, it\'s often necessary to rotate a matrix representing an image by 90 degrees clockwise. **Problem**: Given an `n x n` 2D matrix representing an image, implement a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that rotates the matrix by 90 degrees clockwise. **Constraints**: 1. The matrix is a non-empty `n x n` matrix (1 ≤ n ≤ 1000). 2. The rotation should be done in place if possible, or use extra space proportional to the size of the input. **Input**: - An `n x n` 2D list `matrix` representing an image where `matrix[i][j]` is an integer. **Output**: - Return the rotated `n x n` matrix. **Example**: ```python >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix([ ... [1] ... ]) [[1]] ``` **Hints**: 1. Consider how elements are shifted to achieve the rotation. 2. Think about how the indices of elements change positions after the rotation.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix by 90 degrees clockwise. n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[j][n-1-i] = matrix[i][j] return result"},{"question":"# Maze Solver - Recursive Pathfinding A new game development project at your company involves generating and solving mazes. You are tasked to implement a function that finds a path through a maze using recursion. The maze is represented as a grid where \'0\' represents an open path and \'1\' represents a wall. The path should start at the top-left corner of the grid and end at the bottom-right corner. # Task You need to implement a function `solve_maze(maze: list[list[int]]) -> bool` that recursively finds a path from the top-left to the bottom-right of the maze. # Input and Output Formats * **Input**: - `maze`: a list of lists of integers representing the maze grid. * **Output**: - Return `True` if a path exists from the top-left to the bottom-right of the maze. Otherwise, return `False`. # Example: ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] print(solve_maze(maze)) # Should return True ``` # Constraints: * The maze will always have at least one cell (1x1). * The maze can contain a maximum of 100x100 cells. * The function should handle edge cases where start or end cells are walls. * The function should not modify the input maze. # Performance: * Optimize for readability and efficiency. * Ensure the recursion handles larger mazes without exceeding recursion depth limits. # Hints: 1. You can move only one cell at a time in four possible directions: up, down, left, and right. 2. Keep track of visited cells to avoid infinite loops. 3. Check if the current path leads to a solution and backtrack if it doesn\'t.","solution":"def solve_maze(maze): def is_valid_move(x, y, visited, maze): return 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 0 and (x, y) not in visited def find_path(x, y, visited, maze): if (x, y) == (len(maze) - 1, len(maze[0]) - 1): return True directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited.add((x, y)) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny, visited, maze): if find_path(nx, ny, visited, maze): return True visited.remove((x, y)) return False if not maze or maze[0][0] == 1 or maze[-1][-1] == 1: return False visited = set() return find_path(0, 0, visited, maze)"},{"question":"# Problem Statement Given a set of denominations for currency and a target amount, determine if it is possible to achieve the exact target amount using any number of coins from the given set, including zero. You may assume that you have an infinite number of coins available for each denomination. Write a function `canAchieveTarget` that checks if the exact target amount can be formed using the given denominations of coins. # Input * A list of integers `denominations` representing the available coin denominations. Each denomination is guaranteed to be a positive integer. * An integer `target` representing the amount of money we want to form (0 ≤ target ≤ 1000). # Output * A boolean value, `True` if it is possible to form the `target` amount with the given denominations, and `False` otherwise. # Constraints * All elements in `denominations` are positive integers. * The length of `denominations` will not exceed 100. * The maximum value of any element in `denominations` and `target` will not exceed 1000. # Example For example, with `denominations = [1, 2, 5]` and `target = 11`: - We can form 11 using [1, 5, 5] or [5, 2, 2, 2]. The function would return: * ```python def canAchieveTarget(denominations: List[int], target: int) -> bool: Determines if the exact target amount can be achieved using the given denominations of coins. >>> canAchieveTarget([1, 2, 5], 11) Returns True # Your code here. pass ``` # Explanation Your implementation should utilize dynamic programming to determine whether it is possible to form the exact target amount with the given denominations. You should carefully handle cases where the target is zero or when no combinations of the denominations can form the target. Ensure that your solution efficiently handles the upper limit constraints.","solution":"def canAchieveTarget(denominations, target): Determines if the exact target amount can be achieved using the given denominations of coins. Parameters: - denominations (List[int]): The available coin denominations. - target (int): The amount of money we want to form (0 ≤ target ≤ 1000). Returns: - bool: True if it is possible to form the target amount with the given denominations. dp = [False] * (target + 1) dp[0] = True for value in range(1, target + 1): for coin in denominations: if value - coin >= 0 and dp[value - coin]: dp[value] = True break return dp[target]"},{"question":"# Problem: Find the K Nearest Points You are tasked with implementing a function that identifies the k nearest points to a given reference point from a set of given points in an n-dimensional space. This task will test your knowledge of spatial data, distance calculations, and sorting algorithms. Function Signature ```python def k_nearest_points(points: np.ndarray, reference_point: np.ndarray, k: int) -> np.ndarray: Finds the k nearest points to the given reference point in n-dimensional space. Args: points (np.ndarray): A NumPy array of shape (num_points, num_dimensions) containing the points. reference_point (np.ndarray): A NumPy array of shape (num_dimensions,) representing the reference point. k (int): Number of nearest points to find. Returns: np.ndarray: An array of shape (k, num_dimensions) containing the k nearest points. pass ``` Input: * **points (np.ndarray)**: A NumPy array of shape `(num_points, num_dimensions)`, where `1 <= num_points <= 10^5` and `1 <= num_dimensions <= 100`. * **reference_point (np.ndarray)**: A NumPy array of shape `(num_dimensions,)`, where `1 <= num_dimensions <= 100`. * **k (int)**: The number of nearest points to find, where `1 <= k <= num_points`. Output: * Returns a NumPy array of shape `(k, num_dimensions)` containing the k nearest points. Constraints: * The points should be compared using the Euclidean distance. * Ensure the output contains exactly k points. * Use efficient array operations for distance calculations and sorting. Context: Imagine you are working on a spatial data analysis project where you need to find the nearest neighbors to a given data point. This problem frequently arises in areas like machine learning for k-nearest neighbors algorithms and geospatial data processing. Examples: ```python >>> points = np.array([[2.0, 3.0], [1.0, 2.0], [4.0, 6.0], [7.0, 8.0]]) >>> reference_point = np.array([3.0, 3.0]) >>> k_nearest_points(points, reference_point, 2) array([[2.0, 3.0], [1.0, 2.0]]) >>> points = np.array([[1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4]]) >>> reference_point = np.array([1, 1, 2]) >>> k_nearest_points(points, reference_point, 3) array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) ``` Notes: * Utilize appropriate distance calculation using NumPy\'s operations to improve performance. * Ensure that you handle edge cases, such as when `k > num_points`, gracefully by raising appropriate error messages. * Sorting and selecting the nearest points efficiently is key to solving this problem within the constraints.","solution":"import numpy as np def k_nearest_points(points: np.ndarray, reference_point: np.ndarray, k: int) -> np.ndarray: Finds the k nearest points to the given reference point in n-dimensional space. Args: points (np.ndarray): A NumPy array of shape (num_points, num_dimensions) containing the points. reference_point (np.ndarray): A NumPy array of shape (num_dimensions,) representing the reference point. k (int): Number of nearest points to find. Returns: np.ndarray: An array of shape (k, num_dimensions) containing the k nearest points. if k > points.shape[0]: raise ValueError(\\"k cannot be greater than the number of points\\") # Calculate Euclidean distances distances = np.linalg.norm(points - reference_point, axis=1) # Get the indices of the k closest points nearest_indices = np.argsort(distances)[:k] return points[nearest_indices]"},{"question":"# Problem Statement You need to write a function `smallest_difference_pair` that finds a pair of integers from two separate lists such that the absolute difference between them is minimized. The function should return this pair. # Function Signature ```python def smallest_difference_pair(list1: list[int], list2: list[int]) -> tuple[int, int]: Given two lists of integers, return a pair of integers (one from each list) such that their absolute difference is minimized. Args: - list1 (list[int]): first list of integers. - list2 (list[int]): second list of integers. Returns: - tuple of two integers, one from each list, whose absolute difference is minimized. Examples: >>> smallest_difference_pair([1, 3, 15, 11, 2], [23, 127, 235, 19, 8]) (11, 8) >>> smallest_difference_pair([10, 5, 40], [50, 90, 80]) (40, 50) >>> smallest_difference_pair([-1, 5, 10, 20, 3], [26, 134, 135, 15, 17]) (20, 17) >>> smallest_difference_pair([], [1, 2, 3]) () >>> smallest_difference_pair([4, 3, 2], [7, 8, 5]) (3, 2) pass ``` # Constraints - Your function should handle input lists with up to (10^5) elements each. - Elements of the lists can be any integer (positive, negative, or zero). - You must aim for a solution with a time complexity no worse than (O(N log N + M log M)), where (N) and (M) are the lengths of the two lists respectively. **Note**: Your implementation will be judged on both correctness and efficiency. Sorting both arrays and using a two-pointer technique should help achieve the desired complexity. # Requirements - Handle edge cases such as empty arrays or arrays with single elements appropriately. - Ensure the function returns a pair as a tuple in the format `(value_from_list1, value_from_list2)`, or an empty tuple if either list is empty.","solution":"def smallest_difference_pair(list1: list[int], list2: list[int]) -> tuple[int, int]: Given two lists of integers, return a pair of integers (one from each list) such that their absolute difference is minimized. Args: - list1 (list[int]): first list of integers. - list2 (list[int]): second list of integers. Returns: - tuple of two integers, one from each list, whose absolute difference is minimized. if not list1 or not list2: return () # Sort both lists list1.sort() list2.sort() i, j = 0, 0 min_diff = float(\'inf\') result_pair = (0, 0) # Use two pointers to find the smallest difference while i < len(list1) and j < len(list2): diff = abs(list1[i] - list2[j]) if diff < min_diff: min_diff = diff result_pair = (list1[i], list2[j]) if list1[i] < list2[j]: i += 1 else: j += 1 return result_pair"},{"question":"# Problem Statement A company needs a tool to manage employee data where each employee is identified by their unique employee ID. The company wishes to analyze the data to determine the average age, the minimum and maximum ages, and the average years of experience for their employees. Write a Python function named `employee_analysis()` that accepts a list of dictionaries where each dictionary contains information about an employee. The function should return a dictionary containing the following keys: - `average_age`: The average age of employees. - `min_age`: The minimum age of employees. - `max_age`: The maximum age of employees. - `average_experience`: The average years of experience of employees. Each employee dictionary has the following structure: ```python { \\"employee_id\\": int, \\"name\\": str, \\"age\\": int, \\"years_of_experience\\": int } ``` # Input - A list of dictionaries where each dictionary contains: - `employee_id`: An integer ( 1 leq employee_id leq 10^6 ). - `name`: A string representing the employee\'s name. - `age`: An integer ( 18 leq age leq 65 ). - `years_of_experience`: An integer ( 0 leq years_of_experience leq 47 ). # Output - A dictionary containing the average age, minimum age, maximum age, and average years of experience as described above. # Constraints - The input list will contain at least one employee. # Example ```python # Example usage employees = [ {\\"employee_id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"years_of_experience\\": 5}, {\\"employee_id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 45, \\"years_of_experience\\": 20}, {\\"employee_id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 28, \\"years_of_experience\\": 3}, ] result = employee_analysis(employees) print(result) # Output: # { # \\"average_age\\": 34.33, # \\"min_age\\": 28, # \\"max_age\\": 45, # \\"average_experience\\": 9.33 # } # Additional Test employees = [ {\\"employee_id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 22, \\"years_of_experience\\": 1}, {\\"employee_id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 32, \\"years_of_experience\\": 10} ] result = employee_analysis(employees) print(result) # Output: # { # \\"average_age\\": 27.0, # \\"min_age\\": 22, # \\"max_age\\": 32, # \\"average_experience\\": 5.5 # } ``` # Note - Ensure that the average values are rounded to 2 decimal places. - Raise a ValueError if any employee\'s age or years of experience is out of the specified bounds.","solution":"def employee_analysis(employees): Analyzes employee data to determine the average age, min age, max age, and average years of experience. :param employees: List of dictionaries containing employee data :return: Dictionary containing average age, min age, max age, and average years of experience if not employees: raise ValueError(\\"The employee list should contain at least one employee.\\") total_age = 0 min_age = float(\'inf\') max_age = float(\'-inf\') total_experience = 0 for employee in employees: age = employee.get(\\"age\\") experience = employee.get(\\"years_of_experience\\") if age < 18 or age > 65: raise ValueError(f\\"Invalid age {age} for employee {employee[\'employee_id\']}. Age should be between 18 and 65.\\") if experience < 0 or experience > 47: raise ValueError(f\\"Invalid years of experience {experience} for employee {employee[\'employee_id\']}. Experience should be between 0 and 47.\\") total_age += age total_experience += experience if age < min_age: min_age = age if age > max_age: max_age = age average_age = round(total_age / len(employees), 2) average_experience = round(total_experience / len(employees), 2) return { \\"average_age\\": average_age, \\"min_age\\": min_age, \\"max_age\\": max_age, \\"average_experience\\": average_experience }"},{"question":"# Problem Statement You are required to implement a function that performs a depth-first search (DFS) on a given graph, starting from a given node. The function should return the list of nodes in the order they were visited. # Input * A dictionary `graph` representing the adjacency list of the graph, where keys are node identifiers and values are lists of adjacent nodes. * A string `start` representing the starting node. # Output * A list of strings representing the nodes in the order they were visited during DFS traversal. # Constraints * The graph is connected. * The graph is undirected. * Node identifiers are strings. * The starting node will always be present in the graph. # Performance Requirements * The function should have a time complexity of O(V + E), where V is the number of vertices and E is the number of edges. * The function should have a space complexity of O(V). # Scenario: Consider the graph represented as an adjacency list: ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], \\"C\\": [\\"A\\", \\"F\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"B\\", \\"F\\"], \\"F\\": [\\"C\\", \\"E\\"], } ``` The starting node is `\\"A\\"`. One possible valid DFS traversal order is `[\\"A\\", \\"B\\", \\"D\\", \\"E\\", \\"F\\", \\"C\\"]`. # Function Signature ```python def dfs(graph: dict[str, list[str]], start: str) -> list[str]: pass ```","solution":"def dfs(graph, start): Perform depth-first search (DFS) on a graph starting from the given node. Parameters: graph (dict): Adjacency list of the graph. start (str): The starting node. Returns: list: List of nodes in the order they were visited. visited = set() result = [] def dfs_visit(node): if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: dfs_visit(neighbor) dfs_visit(start) return result"},{"question":"# Problem: Removing Consecutive Duplicates You are tasked with creating a function that can take an input list and return a new list with consecutive duplicate elements removed. This is a common task in data preprocessing where cleansing datasets to avoid redundancy is crucial. # Function Signature ```python def remove_consecutive_duplicates(input_list: List[int]) -> List[int]: pass ``` # Input 1. `input_list` (list of integers): The list containing integers that might have consecutive duplicates. # Output * A list of integers where all consecutive duplicates have been removed. If the input list is empty, return an empty list. # Constraints 1. The input list will have at most (10^5) elements. 2. Each element of the list is an integer. # Example ```python # Example with consecutive duplicates print(remove_consecutive_duplicates([1, 1, 2, 2, 3, 3, 3, 2, 2, 1])) # Expected Output: [1, 2, 3, 2, 1] # Example without consecutive duplicates print(remove_consecutive_duplicates([1, 2, 3, 4, 5])) # Expected Output: [1, 2, 3, 4, 5] # Example with an empty list print(remove_consecutive_duplicates([])) # Expected Output: [] # Example with every element being a consecutive duplicate print(remove_consecutive_duplicates([5, 5, 5, 5, 5])) # Expected Output: [5] ``` # Scenario You are tasked with developing a data preprocessing tool that can clean large datasets before analysis. Consecutive duplicate entries in the data can cause erroneous analysis results, and thus, it is critical to identify and remove these duplicates efficiently. The function you implement will be a part of the larger data cleansing pipeline to ensure high-quality and accurate datasets.","solution":"from typing import List def remove_consecutive_duplicates(input_list: List[int]) -> List[int]: Removes consecutive duplicate elements from the input list. Parameters: input_list (List[int]): List of integers that may have consecutive duplicates. Returns: List[int]: List with consecutive duplicates removed. if not input_list: return [] result = [input_list[0]] for i in range(1, len(input_list)): if input_list[i] != input_list[i - 1]: result.append(input_list[i]) return result"},{"question":"# Coding Assessment Question **Longest Consecutive Path in a Matrix** Problem Statement Given a matrix of integers, you need to find the length of the longest incremental path where each step involves moving to one of the four adjacent cells (left, right, up, or down) and the values in the cells along the path are strictly increasing. The path must start from any cell in the matrix and can end in any cell, but each move must be to an adjacent cell with a larger value. Write a function `longest_consecutive_path(matrix: List[List[int]]) -> int` that takes a matrix and returns the length of the longest consecutive incremental path. Input: * `matrix`: A list of lists of integers, where `matrix[i][j]` is the integer in row `i` and column `j`. Output: * An integer representing the length of the longest incremental path in the matrix. Constraints: * The matrix will have at least one cell and at most 100 rows and 100 columns. * Each cell\'s value is an integer between -100 and 1000. Example: ```python matrix = [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] assert longest_consecutive_path(matrix) == 4 # Path: 1 -> 2 -> 6 -> 9 ``` Note: The algorithm should correctly handle edge cases such as: * Matrices with all cells having the same value. * Single row or single column matrices. * Entries with large differences in values.","solution":"from typing import List def longest_consecutive_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) dp = [[-1] * cols for _ in range(rows)] def dfs(x, y): if dp[x][y] != -1: return dp[x][y] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) dp[x][y] = max_length return max_length longest_path = 0 for i in range(rows): for j in range(cols): longest_path = max(longest_path, dfs(i, j)) return longest_path"},{"question":"# Coding Assessment Question **Scenario**: You have been given a task to create a class `ShoppingCart` that simulates online shopping cart operations. This class should be capable of adding items, removing items, checking out, and calculating the total price including applicable discounts. **Requirements**: 1. **Cart Management**: Implement methods to add items, remove items, and display the current items in the cart. 2. **Total Calculation**: Calculate the total cost of items in the cart, considering possible discounts. 3. **Discount Application**: Apply a discount rule: If the total cost exceeds 100, a 10% discount is applied; otherwise, no discount. 4. **Item Representation**: Each item added to the cart must be represented as a dictionary with keys for \'name\', \'price\', and \'quantity\'. **Function Implementation**: 1. **add_item(name: str, price: float, quantity: int) -> None** - Parameters: - `name`: The name of the item. - `price`: The price of a single unit of the item. - `quantity`: Number of units of the item to add. - If the item is already in the cart, update its quantity. 2. **remove_item(name: str, quantity: int) -> None** - Parameters: - `name`: The name of the item. - `quantity`: Number of units of the item to remove. - If the quantity to remove is equal or greater than the existing quantity, remove the item from the cart. Otherwise, reduce the quantity. 3. **calculate_total() -> float** - Calculate the total price of the items in the cart. Apply a 10% discount if the total price exceeds 100. 4. **display_cart() -> None** - Print out the items in the cart in the format: \\"Item Name: Quantity @ Price Each\\". **Example**: ```python cart = ShoppingCart() cart.add_item(\\"Laptop\\", 900.0, 1) cart.add_item(\\"Mouse\\", 50.0, 2) cart.add_item(\\"Keyboard\\", 45.0, 1) cart.display_cart() # Output: # Laptop: 1 @ 900.0 each # Mouse: 2 @ 50.0 each # Keyboard: 1 @ 45.0 each print(cart.calculate_total()) # Output: 1035.0 cart.remove_item(\\"Mouse\\", 1) cart.display_cart() # Output: # Laptop: 1 @ 900.0 each # Mouse: 1 @ 50.0 each # Keyboard: 1 @ 45.0 each print(cart.calculate_total()) # Output: 995.0 print(cart.calculate_total()) # Should apply 10% discount # Output: 895.5 ``` **Constraints**: - The price is a non-negative float and quantity is a non-negative integer. - Ensure no negative quantity of items or negative total price in the cart. - The cart can contain up to 100 distinct items.","solution":"class ShoppingCart: def __init__(self): Initializes an empty shopping cart. self.cart = {} def add_item(self, name: str, price: float, quantity: int) -> None: Adds the item to the cart or updates its quantity if it\'s already in the cart. if name in self.cart: self.cart[name][\'quantity\'] += quantity else: self.cart[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name: str, quantity: int) -> None: Removes the specified quantity of the item from the cart. if name in self.cart: if self.cart[name][\'quantity\'] <= quantity: del self.cart[name] else: self.cart[name][\'quantity\'] -= quantity def calculate_total(self) -> float: Calculates the total price of the items and applies discounts if applicable. total = sum(item[\'price\'] * item[\'quantity\'] for item in self.cart.values()) if total > 100: total *= 0.9 # Apply 10% discount return total def display_cart(self) -> None: Displays the items in the cart. for name, details in self.cart.items(): print(f\\"{name}: {details[\'quantity\']} @ {details[\'price\']} each\\")"},{"question":"# Coding Assessment Question Scenario You work as a data analyst and often need to process and analyze large datasets. One recurring task involves evaluating the performance of different teams in a company based on certain statistics. Specifically, you need to calculate the median performance score of each team given their performance data. Task Write a function `calculate_median_performance` that takes as input a dictionary where keys are team names and values are lists of performance scores. The function should return a new dictionary where the keys are team names and the values are the median performance score for each team. Implement this in Python. Function Signature ```python def calculate_median_performance(data: dict[str, list[float]]) -> dict[str, float]: ``` Input - `data` (dict): A dictionary where keys are team names (strings) and values are lists of performance scores (floats). Each list of performance scores will contain at least one value. Output - (dict): A dictionary where keys are team names (strings) and values are the median performance score (float) for each team. Constraints - The function should handle cases where the performance scores list contains an even or odd number of elements appropriately. - The function should raise a `ValueError` if the input is not a dictionary or if any value in the dictionary is not a list of floats. Example ```python >>> data = { >>> \\"TeamA\\": [1.0, 2.0, 3.0, 4.0, 5.0], >>> \\"TeamB\\": [2.1, 3.4, 1.5], >>> \\"TeamC\\": [7.0, 8.5, 6.3, 5.4] >>> } >>> calculate_median_performance(data) { \\"TeamA\\": 3.0, \\"TeamB\\": 2.1, \\"TeamC\\": 6.65 } >>> data_invalid = { >>> \\"TeamA\\": [1.0, 2.0, \'three\', 4.0, 5.0], >>> \\"TeamB\\": [2.1, 3.4, 1.5] >>> } >>> calculate_median_performance(data_invalid) Traceback (most recent call last): ... ValueError: Each value in the dictionary must be a list of floats ``` Note that the median is defined as the middle value in a list of numbers ordered from least to greatest. If the list has an even number of elements, the median is the average of the two middle numbers. Your implementation should correctly handle invalid inputs and edge cases as demonstrated in the example.","solution":"def calculate_median_performance(data: dict[str, list[float]]) -> dict[str, float]: Calculate the median performance score for each team. Parameters: data (dict): A dictionary where keys are team names and values are lists of performance scores. Returns: dict: A dictionary where keys are team names and values are the median performance score for each team. Raises: ValueError: If the input is not a dictionary or any value in the dictionary is not a list of floats. if not isinstance(data, dict): raise ValueError(\\"Input must be a dictionary\\") medians = {} for team, scores in data.items(): if not isinstance(scores, list) or not all(isinstance(score, (int, float)) for score in scores): raise ValueError(\\"Each value in the dictionary must be a list of floats\\") sorted_scores = sorted(scores) n = len(sorted_scores) if n % 2 == 1: median = sorted_scores[n // 2] else: median = (sorted_scores[n // 2 - 1] + sorted_scores[n // 2]) / 2.0 medians[team] = median return medians"},{"question":"# Coding Question: **Find the Smallest Number with Unique Digits** A number is said to have unique digits if no digit in the number repeats. Task: Write a function `find_smallest_unique_digit_number(length: int) -> int` that returns the smallest number having `length` unique digits. If no such number exists, return 0. Function Signature: ```python def find_smallest_unique_digit_number(length: int) -> int: ``` Input: - `length` (1 <= length <= 10): An integer representing the length of the number. Output: - An integer representing the smallest number with `length` unique digits, or 0 if none exists. Constraints: - It is guaranteed that 1 <= length <= 10. - The unique digits should be from 0 to 9 without repetition. - If `length` is 10, the result will be 1023456789 because 10 means using all digits from 0-9. Example: ```python assert find_smallest_unique_digit_number(1) == 0 assert find_smallest_unique_digit_number(2) == 10 assert find_smallest_unique_digit_number(3) == 102 assert find_smallest_unique_digit_number(10) == 1023456789 ``` Hints: - The smallest number with unique digits will start with the smallest non-zero digit and be filled up with the next smallest available digits. - Consider handling the case for `length` = 1 separately since it can only be a single digit number from 0 to 9.","solution":"def find_smallest_unique_digit_number(length: int) -> int: Returns the smallest number having `length` unique digits. If no such number exists, returns 0. if length < 1 or length > 10: return 0 # If length is 1, the smallest unique digit number is 0 if length == 1: return 0 # Initialize the smallest unique number as a list of digits digits = [] # The first digit should be 1 (since 0 as the first digit doesn\'t make sense) digits.append(1) # Fill in the rest of the digits ensuring they are unique for i in range(1, length): digits.append(i if i != 1 else 0) # Convert the list of digits to a single integer smallest_number = int(\'\'.join(map(str, digits))) return smallest_number"},{"question":"# Coding Challenge Problem Statement In this challenge, you need to implement a function `find_complementary_pairs` that, given an array of integers and a target integer, finds all unique pairs in the array that sum up to the target. Two pairs (a, b) and (b, a) are considered the same and should be counted only once. Function Signature ```python def find_complementary_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: pass ``` Input - `arr` (List[int]): A list of integers. - `target` (int): The target sum for the pairs. Output - Returns a list of tuples, each containing two integers that form a pair whose sum equals the target. Ensure each pair is unique and sorted in ascending order within the tuple. Example ```python print(find_complementary_pairs([1, 2, 3, 4, 3], 6)) # Output: [(2, 4), (3, 3)] print(find_complementary_pairs([0, -1, 2, -3, 1], -2)) # Output: [(-3, 1)] print(find_complementary_pairs([1, 1, 1, 1], 2)) # Output: [(1, 1)] ``` Constraints - The input list `arr` will have a length between 1 and 10,000 elements. - Each element in `arr` will be within the range of `-10000` to `10000`. - The output list order does not matter. - Each pair should be sorted in ascending order within the tuple, and duplicates should be avoided. Notes - Consider edge cases where no pairs exist. - Focus on optimizing your solution, especially regarding time complexity for larger input sizes.","solution":"from typing import List, Tuple def find_complementary_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: seen = {} result = set() for num in arr: complement = target - num if complement in seen: result.add(tuple(sorted((num, complement)))) seen[num] = True return list(result)"},{"question":"# Problem Statement In a given grid representing urban blocks, certain blocks contain buildings of height given in terms of non-negative integers. You can visualize this grid as a 2D matrix where each element represents the height of the building at that position. You are required to count how many buildings are visible in the skyline from both the left view (looking from the left edge towards the right edge) and the top view (looking from the top edge towards the bottom edge). # Input You will receive the following: - `heights`: A list of lists of integers where each inner list represents a row of buildings, and each integer represents a building height. # Output The function should return a tuple of two integers representing the number of distinct buildings visible from the left view and the top view, respectively. # Constraints - The grid (matrix) can be assumed to be non-empty. - The number of rows and columns will be between 1 and 100. - Building heights are non-negative integers between 0 and 10,000. # Function Signature ```python def skyline_views(heights: List[List[int]]) -> Tuple[int, int]: pass ``` # Examples ```python >>> skyline_views([[3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0]]) (4, 4) # Explanation: # Left view: The visible buildings are at heights [3, 2, 9, 0]. # Top view: The visible buildings are at heights [9, 4, 8, 7]. ``` **Note**: This question tests the ability to traverse and analyze a 2D matrix, understanding the concept of visibility from different perspectives, and working with list and tuple data structures in Python. Ensure that different heights and aligned buildings in rows and columns are correctly identified and counted.","solution":"def skyline_views(heights): Returns the number of distinct buildings visible from the left view and the top view. num_rows = len(heights) num_cols = len(heights[0]) # Left view - maximum in each row left_view = set() for row in heights: left_view.add(max(row)) # Top view - maximum in each column top_view = set() for col in range(num_cols): max_in_col = max(heights[row][col] for row in range(num_rows)) top_view.add(max_in_col) return (len(left_view), len(top_view))"},{"question":"# Question: Matrix Multiplication Implementation You are required to implement a function that performs matrix multiplication on two given matrices. The matrices will be presented as lists of lists, where each list represents a row of the matrix. Your function should handle edge cases and ensure proper dimensional compatibility. Function Signature ```python def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: pass ``` # Input 1. `matrix_a`: A list of lists where each sublist represents a row of the first matrix. 2. `matrix_b`: A list of lists where each sublist represents a row of the second matrix. # Output * Returns a list of lists where each sublist represents a row of the resulting matrix after multiplication. # Constraints - Ensure the number of columns in `matrix_a` is equal to the number of rows in `matrix_b` to allow for matrix multiplication (i.e., matrix (A) dimension is (m times n) and matrix (B) dimension is (n times p)). - Handle edge cases where one or both matrices are empty. - Do not use any external libraries; the solution must be implemented using fundamental programming constructs. # Example ```python matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiplication(matrix_a, matrix_b) print(result) # Output: [[58, 64], [139, 154]] ``` # Explanation In this example: - `matrix_a` is a (2 times 3) matrix. - `matrix_b` is a (3 times 2) matrix. - The resulting matrix will be a (2 times 2) matrix after performing the matrix multiplication. - Calculation: - First row: (1*7 + 2*9 + 3*11 = 58), (1*8 + 2*10 + 3*12 = 64) - Second row: (4*7 + 5*9 + 6*11 = 139), (4*8 + 5*10 + 6*12 = 154) This question assesses the understanding of matrix operations, nested loops, and computational efficiency.","solution":"from typing import List def matrix_multiplication(matrix_a: List[List[int]], matrix_b: List[List[int]]) -> List[List[int]]: Perform matrix multiplication on two given matrices. :param matrix_a: First matrix as a list of lists. :param matrix_b: Second matrix as a list of lists. :return: Resulting matrix after multiplication. if not matrix_a or not matrix_b or not matrix_b[0]: return [] # Number of rows in matrix_a rows_a = len(matrix_a) # Number of columns in matrix_a (or rows in matrix_b) cols_a = len(matrix_a[0]) # Number of columns in matrix_b cols_b = len(matrix_b[0]) # Check if we can multiply the matrices if cols_a != len(matrix_b): raise ValueError(\\"Number of columns in matrix_a must equal number of rows in matrix_b\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# Binary Search Tree Insertion and Depth Calculation You are asked to implement a simplified version of a Binary Search Tree (BST) data structure in Python. This will test your understanding of fundamental data structures, recursion, and tree traversal algorithms. Problem Statement Design and implement two functions: 1. `insert_bst(root, value)`: Inserts a value into the BST while maintaining the BST property. 2. `bst_depth(root)`: Calculates the depth (or height) of the BST. # Function Definitions: 1. **`insert_bst(root, value)`**: - **Input**: A root node of the BST and an integer `value` to be inserted. - **Output**: The root node of the BST after insertion. - **Constraints**: The BST must not contain duplicate values. 2. **`bst_depth(root)`**: - **Input**: The root node of a BST. - **Output**: An integer representing the depth of the BST. The depth of an empty tree is 0. - **Constraints**: None. Example: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right root = None values = [5, 3, 8, 1, 4, 7, 10] for value in values: root = insert_bst(root, value) depth = bst_depth(root) print(f\\"Depth of the BST: {depth}\\") ``` Expected Output: - Depth of the BST: 3 # Additional Requirements: - Handle edge cases such as inserting into an empty tree. - Ensure that insertion maintains the Binary Search Tree property. - Your implementation should be as efficient as possible, especially for the depth calculation. You may use the following helper class for defining `TreeNode`. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def insert_bst(root, value): Inserts a value into the BST while maintaining the BST property. :param root: TreeNode, the root node of the BST :param value: int, the value to be inserted :return: TreeNode, the root node of the BST after insertion if root is None: return TreeNode(value) if value < root.value: root.left = insert_bst(root.left, value) elif value > root.value: root.right = insert_bst(root.right, value) return root def bst_depth(root): Calculates the depth (or height) of the BST. :param root: TreeNode, the root node of the BST :return: int, the depth of the BST if root is None: return 0 left_depth = bst_depth(root.left) right_depth = bst_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Fibonacci Number Calculation Context The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. This sequence is prevalent in various fields of mathematics, computer science, and natural sciences. Problem Statement You are required to write a function that returns the nth Fibonacci number. The sequence starts with F0 = 0 and F1 = 1, with each subsequent number being the sum of the previous two. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Input - `n` (int): A non-negative integer representing the index of the Fibonacci sequence. Output - An integer representing the nth Fibonacci number. Constraints - 0 ≤ n ≤ 10^5. Example ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(20) == 6765 assert fibonacci(50) == 12586269025 ``` Notes - Ensure that your solution is efficient and can handle large values of `n` up to 10^5 without significant performance degradation. - Considering the large value of `n`, iterative or matrix exponentiation techniques may be more appropriate than a simple recursive approach.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Problem Statement # Longest Increasing Subsequence Given an integer array `arr`, find the length of the longest increasing subsequence. A subsequence is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. **Input:** * An integer `n`: the number of elements in the array (1 <= n <= 1000). * A list of integers `arr` of length `n`. **Output:** * An integer representing the length of the longest increasing subsequence. **Example:** ```plaintext Input: n = 6 arr = [10, 9, 2, 5, 3, 7, 101, 18] Output: 4 ``` In this example, the longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. # Constraints: * The elements in the array will be within the range of a 32-bit signed integer. * The array can be empty, in which case the longest increasing subsequence length is 0. # Task: 1. Implement a function `length_of_lis` that solves the problem using dynamic programming. 2. Ensure your solution follows the provided input and output formats. 3. Optimize your function to handle larger inputs efficiently. # Function Signature: ```python def length_of_lis(n: int, arr: List[int]) -> int: # your code here ``` **Note:** Consider edge cases and ensure your code can handle them gracefully. Pay attention to performance to avoid time limits being exceeded with larger inputs.","solution":"from typing import List def length_of_lis(n: int, arr: List[int]) -> int: if n == 0: return 0 # Initialize a list to store the length of the longest increasing subsequence ending at each position lis = [1] * n # Build the lis array for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # The length of the longest increasing subsequence will be the maximum value in the lis array return max(lis)"},{"question":"# Randomized Set Operations In this task, you will need to implement a custom data structure that supports insertion, deletion, and random retrieval of elements. This structure combines properties of a set and a list. RandomizedSet Implement the following methods: 1. `__init__(self)`: Initializes an empty set and an empty list. 2. `insert(self, val: int) -> bool`: Inserts the element `val` into the set if it is not already present. Returns `True` if the element was inserted, and `False` if it was already present. 3. `remove(self, val: int) -> bool`: Removes the element `val` from the set if it is present. Returns `True` if the element was removed, and `False` if it was not present. 4. `getRandom(self) -> int`: Returns a random element from the set. All elements should have an equal probability of being returned. Raises `ValueError` if the set is empty. 5. `__str__(self) -> str`: Returns a string representation of the elements in the set. # Input and Output * `insert(val)` accepts an integer value and returns a boolean indicating the success of the operation. * `remove(val)` accepts an integer value and returns a boolean indicating the success of the operation. * `getRandom()` returns a random integer from the set. * `__str__()` returns a string representing the elements in the set. # Performance Requirements Ensure that your implementation meets the specified time complexities: * `insert`: O(1) * `remove`: O(1) * `getRandom`: O(1) * String representation should be efficient. # Example ```python rs = RandomizedSet() print(rs) # {} print(rs.insert(1)) # True print(rs.insert(2)) # True print(rs.insert(2)) # False print(rs) # {1, 2} print(rs.remove(1)) # True print(rs.remove(1)) # False print(rs) # {2} print(rs.getRandom()) # 2 (since only one element is present) print(rs.insert(3)) # True print(rs) # {2, 3} print(rs.getRandom()) # Randomly returns either 2 or 3 ``` Implement the class `RandomizedSet` with the specified methods and ensure your code passes the above examples.","solution":"import random class RandomizedSet: def __init__(self): self.num_list = [] self.num_dict = {} def insert(self, val: int) -> bool: if val in self.num_dict: return False self.num_dict[val] = len(self.num_list) self.num_list.append(val) return True def remove(self, val: int) -> bool: if val not in self.num_dict: return False index = self.num_dict[val] last_element = self.num_list[-1] self.num_list[index] = last_element self.num_dict[last_element] = index self.num_list.pop() del self.num_dict[val] return True def getRandom(self) -> int: if not self.num_list: raise ValueError(\\"The set is empty\\") return random.choice(self.num_list) def __str__(self) -> str: return \\"{\\" + \\", \\".join(map(str, self.num_list)) + \\"}\\""},{"question":"# Question: Binary Subarray with Target Sum Objective Write a function that finds the number of contiguous binary subarrays (subarrays containing only 0s and 1s) that sum to a given target sum `S`. Task 1. **Implement a function, `num_subarrays_with_sum(nums: list[int], S: int) -> int`,** that returns the number of contiguous subarrays whose elements sum up to the given target `S`. Function Signature ```python def num_subarrays_with_sum(nums: list[int], S: int) -> int: # Determine the number of subarrays which sum to target S pass ``` Expected Input and Output - **Input**: - `nums`: A list of integers consisting only of `0`s and `1`s (1 ≤ len(nums) ≤ 30000). - `S`: An integer target sum (0 ≤ S ≤ len(nums)). - **Output**: The integer count of subarrays summing exactly to the target `S`. Constraints - The array `nums` will only contain `0`s and `1`s. - The length of `nums` will be at least 1 and at most 30000. - The target sum `S` is an integer between 0 and the length of `nums`. Example ```python >>> num_subarrays_with_sum([1,0,1,0,1], 2) 4 >>> num_subarrays_with_sum([0,0,0,0,0], 0) 15 ``` Explanation - For the input `[1,0,1,0,1]` with target sum `2`, the valid subarrays are `[1,0,1]` (twice), `[0,1,0]`, and `[1,0,1]` (again). - For the input `[0,0,0,0,0]` with target sum `0`, each zero serves as a valid subarray whenever it stands alone, or combines in multiple combinations, totalling 15 possible subarrays.","solution":"def num_subarrays_with_sum(nums, S): from collections import defaultdict count = defaultdict(int) prefix_sum = 0 result = 0 count[0] = 1 # There\'s one way to have a prefix sum of 0, by doing nothing. for num in nums: prefix_sum += num if (prefix_sum - S) in count: result += count[prefix_sum - S] count[prefix_sum] += 1 return result"},{"question":"# Coding Assessment Question: String Pattern Matching and Transformation You have been assigned the task of implementing two critical functions related to string pattern matching and transformation. These functions involve checking for a specific pattern in a string and transforming that string based on provided criteria. - **Function 1: `matches_pattern(s: str, pattern: str) -> bool`** - **Description**: Check if the string `s` contains the exact sequence of characters specified in `pattern`. - **Input**: Two strings, `s` and `pattern`. - **Output**: A boolean indicating if the `pattern` is found within `s` in the exact sequence. - **Constraints**: - Both inputs must be non-empty strings. - **Edge Cases**: - Raise a `ValueError` for invalid input types. - Handle case sensitivity as specified (consider \'A\' and \'a\' as different characters). - **Function 2: `transform_string(s: str, transformations: dict) -> str`** - **Description**: Transform the string `s` according to the rules specified in the `transformations` dictionary. - **Input**: A string `s` and a dictionary `transformations` where keys are single characters and values are strings representing the transformations. - **Output**: A new string where each character in `s` is replaced by the corresponding transformation specified in the dictionary. - **Constraints**: - The input string and dictionary must be valid and non-empty. - **Edge Cases**: - Raise a `ValueError` for invalid input types or empty inputs. - Ignore characters in `s` that do not have a corresponding key in the `transformations` dictionary. Example: ```python # Example Function Call: print(matches_pattern(\\"openai\\", \\"pen\\")) # Output: True print(transform_string(\\"openai\\", {\\"o\\": \\"O\\", \\"e\\": \\"E\\", \\"a\\": \\"A\\"})) # Output: \\"OpEnAi\\" # Example Invalid Call: print(matches_pattern(4, \\"pattern\\")) # Output: Raises ValueError # Empty string example: print(transform_string(\\"\\", {\\"a\\": \\"b\\"})) # Output: Raises ValueError ``` Performance Requirement: - Both functions should operate efficiently considering the length of the string and size of the transformation dictionary. **Notes**: - You can assume input strings will have fewer than 10^5 characters. - Ensure to implement proper exception handling to manage invalid input scenarios. Implement the functions according to the given specifications.","solution":"def matches_pattern(s: str, pattern: str) -> bool: Check if the string `s` contains the exact sequence of characters specified in `pattern`. if not isinstance(s, str) or not isinstance(pattern, str) or not s or not pattern: raise ValueError(\\"Invalid input types or empty strings\\") return pattern in s def transform_string(s: str, transformations: dict) -> str: Transform the string `s` according to the rules specified in the `transformations` dictionary. if not isinstance(s, str) or not isinstance(transformations, dict) or not s or not transformations: raise ValueError(\\"Invalid input types or empty inputs\\") transformed = [] for char in s: if char in transformations: transformed.append(transformations[char]) else: transformed.append(char) return \'\'.join(transformed)"},{"question":"# Question: Least Used Character in a String You are given a string, and your task is to implement a function `least_used_character(s: str) -> str` that finds the least frequently occurring alphanumeric character in the string. If there is a tie, return the character that appears first in the order of their first occurrences. Instructions: 1. **Input**: The function `least_used_character(s)` accepts a single string `s` (1 <= len(s) <= 10^6). 2. **Output**: Returns a single character, the least frequently occurring alphanumeric character. Requirements: * The solution must efficiently handle the frequency counting within the given constraint. * The function should ignore non-alphanumeric characters during the frequency count. * Handle edge cases gracefully: - For an empty string or a string with no alphanumeric characters, raise a `ValueError` with the message `\\"Input must contain at least one alphanumeric character.\\"`. - For non-string values, raise a `TypeError` with the message `\\"Input must be a string.\\"`. Examples: Here are some examples of the expected outputs: ```python >>> least_used_character(\'abracadabra\') \'c\' >>> least_used_character(\'hello world! 123\') \'h\' >>> least_used_character(\'!@#%^&*()\') ValueError: Input must contain at least one alphanumeric character. >>> least_used_character(123456) TypeError: Input must be a string. >>> least_used_character(\'aA1bB2\') \'1\' ``` Additional Context: When counting character frequencies, consider only alphanumeric characters (letters and digits) and ignore the case sensitivity (i.e., \'A\' and \'a\' should be treated as the same character). Constraints: * Aim to achieve O(n) time complexity where n is the length of the string, keeping space usage in mind due to the large potential input size. ```python def least_used_character(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string.\\") filtered_s = \'\'.join(filter(str.isalnum, s)).lower() if not filtered_s: raise ValueError(\\"Input must contain at least one alphanumeric character.\\") from collections import Counter freq = Counter(filtered_s) min_freq = min(freq.values()) for char in s: if char.isalnum() and freq[char.lower()] == min_freq: return char.lower() ```","solution":"def least_used_character(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"Input must be a string.\\") # Filter only alphanumeric characters and convert to lowercase filtered_s = \'\'.join(filter(str.isalnum, s)).lower() if not filtered_s: raise ValueError(\\"Input must contain at least one alphanumeric character.\\") from collections import Counter # Count frequencies of each character freq = Counter(filtered_s) # Find the minimum frequency min_freq = min(freq.values()) # Find the first character with the minimum frequency in the original string for char in s: if char.isalnum() and freq[char.lower()] == min_freq: return char.lower()"},{"question":"# Coding Question You have been chosen to assist a supermarket in managing its inventory of discounted items. Each item has a discount rate, and the supermarket wants to display the items sorted by their final price in ascending order. Your task is to implement a solution that calculates the final price of each item after applying the discount and sorts the items accordingly. Function Implementations 1. `calculate_final_price(item_names: list, original_prices: list, discount_rates: list, no_of_items: int) -> list` 2. `sort_items_by_final_price(final_prices: list, item_names: list, no_of_items: int) -> list` # Input - `item_names`: A list of strings representing the item names. - `original_prices`: A list of floats representing the original prices of the items. - `discount_rates`: A list of floats representing the discount rates (in percentage) for the items. - `no_of_items`: An integer representing the number of items. # Output - For `calculate_final_price`: - A list of floats, where each float represents the final price of the corresponding item after applying the discount. - For `sort_items_by_final_price`: - A list of strings, where each string represents the item name sorted based on the final price in ascending order. # Constraints - Original prices will be positive numbers. - Discount rates will be in the range [0, 100]. - The input lists will have the same length equal to `no_of_items`. Example ```python # Input no_of_items = 3 item_names = [\\"Milk\\", \\"Bread\\", \\"Butter\\"] original_prices = [2.50, 1.00, 5.00] discount_rates = [10, 20, 5] # Function Calls final_prices = calculate_final_price(item_names, original_prices, discount_rates, no_of_items) sorted_items = sort_items_by_final_price(final_prices, item_names, no_of_items) # Output print(\\"Final Prices: \\", final_prices) # Expected: [2.25, 0.80, 4.75] print(\\"Sorted Items: \\", sorted_items) # Expected: [\\"Bread\\", \\"Milk\\", \\"Butter\\"] ``` Your task is to correctly implement the `calculate_final_price` and `sort_items_by_final_price` functions to compute the final prices after discount and sort the items based on these prices.","solution":"def calculate_final_price(item_names, original_prices, discount_rates, no_of_items): Compute the final prices after applying the discount rates. Parameters: item_names (list): A list of item names (not used in the calculation). original_prices (list): A list of original prices of the items. discount_rates (list): A list of discount rates for the items. no_of_items (int): Number of items. Returns: list: A list of final prices after discounts. final_prices = [] for i in range(no_of_items): discount = original_prices[i] * (discount_rates[i] / 100) final_price = original_prices[i] - discount final_prices.append(final_price) return final_prices def sort_items_by_final_price(final_prices, item_names, no_of_items): Sort items based on their final prices in ascending order. Parameters: final_prices (list): A list of final prices of the items. item_names (list): A list of item names. no_of_items (int): Number of items. Returns: list: A list of item names sorted by final price. items_with_prices = list(zip(final_prices, item_names)) items_with_prices.sort() # Sort by final prices because it\'s the first element in the tuple sorted_item_names = [item[1] for item in items_with_prices] return sorted_item_names"},{"question":"# Coding Assessment Question Context A common task in text processing is to determine the longest contiguous sequence within a string where the same character repeats. Implement a function to identify the length of such a sequence. Task Implement a function `longest_repeating_substring(data: str) -> int` that computes the length of the longest contiguous sequence of a single repeated character in the given string `data`. Function Signature ```python def longest_repeating_substring(data: str) -> int: pass ``` Input * `data`: A string for which the longest contiguous repeating character sequence length needs to be found. Output * Returns an integer representing the length of the longest contiguous substring where the same character repeats. Examples ```python assert longest_repeating_substring(\\"aaabbcccccdd\\") == 5 assert longest_repeating_substring(\\"abcd\\") == 1 assert longest_repeating_substring(\\"\\") == 0 assert longest_repeating_substring(\\"a\\") == 1 assert longest_repeating_substring(\\"aaaabbbbcccaa\\") == 4 ``` Constraints * The input string `data` length should not exceed (10^6) characters. Performance Requirements * Ensure your implementation runs efficiently with a time complexity of O(n) where n is the length of `data`. * The space complexity should be O(1), aside from the input string storage.","solution":"def longest_repeating_substring(data: str) -> int: if not data: return 0 max_length = 1 current_length = 1 for i in range(1, len(data)): if data[i] == data[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 return max_length"},{"question":"# Data Transformation and Aggregation You are working on a data science team where part of your job is to process and analyze data. One common task is transforming and aggregating data across different dimensions. You need to create a function that processes a list of dictionaries and produces a summary based on specified aggregation rules. **Your task** is to write a function that groups the data by a specified key and aggregates the values of another specified key with a provided aggregation function (such as sum, average, minimum, or maximum). **Function Signature:** ```python def aggregate_data(data: List[Dict[str, Any]], group_by: str, aggregate_by: str, operation: str) -> Dict[Any, float]: Group the data by a specified key and aggregate the values of another key with a given operation. :param data: A list of dictionaries containing the data. :param group_by: The key to group by (e.g., \\"category\\"). :param aggregate_by: The key to aggregate by (e.g., \\"value\\"). :param operation: The aggregation operation to perform (e.g., \\"sum\\", \\"average\\", \\"min\\", \\"max\\"). :return: A dictionary with the grouped key and the aggregated value. pass ``` **Input:** - `data` (List[Dict[str, Any]]): A list of dictionaries containing the data to process. - `group_by` (str): The key to group the data by. - `aggregate_by` (str): The key to aggregate the data by. - `operation` (str): The aggregation operation to apply (\\"sum\\", \\"average\\", \\"min\\", \\"max\\"). **Output:** - Returns a dictionary where the keys are the unique values of the `group_by` key and the values are the results of the aggregation. **Constraints:** - The `data` list can be empty, in which case the function should return an empty dictionary. - If the `group_by` or `aggregate_by` key is not present in the dictionaries, it should raise an appropriate exception. - The `operation` can only be one of [\\"sum\\", \\"average\\", \\"min\\", \\"max\\"]. **Example Cases:** 1. Aggregating by sum: ```python data = [ {\\"category\\": \\"A\\", \\"value\\": 10}, {\\"category\\": \\"A\\", \\"value\\": 15}, {\\"category\\": \\"B\\", \\"value\\": 20} ] print(aggregate_data(data, \\"category\\", \\"value\\", \\"sum\\")) # Output: {\\"A\\": 25, \\"B\\": 20} ``` 2. Aggregating by average: ```python data = [ {\\"category\\": \\"A\\", \\"value\\": 10}, {\\"category\\": \\"A\\", \\"value\\": 20}, {\\"category\\": \\"B\\", \\"value\\": 30} ] print(aggregate_data(data, \\"category\\", \\"value\\", \\"average\\")) # Output: {\\"A\\": 15.0, \\"B\\": 30.0} ``` 3. Aggregating by minimum: ```python data = [ {\\"category\\": \\"A\\", \\"value\\": 10}, {\\"category\\": \\"A\\", \\"value\\": 5}, {\\"category\\": \\"B\\", \\"value\\": 20} ] print(aggregate_data(data, \\"category\\", \\"value\\", \\"min\\")) # Output: {\\"A\\": 5, \\"B\\": 20} ``` 4. Aggregating by maximum: ```python data = [ {\\"category\\": \\"A\\", \\"value\\": 10}, {\\"category\\": \\"A\\", \\"value\\": 20}, {\\"category\\": \\"B\\", \\"value\\": 5} ] print(aggregate_data(data, \\"category\\", \\"value\\", \\"max\\")) # Output: {\\"A\\": 20, \\"B\\": 5} ``` Develop the `aggregate_data` function that adheres to the specification given above.","solution":"from typing import List, Dict, Any from statistics import mean def aggregate_data(data: List[Dict[str, Any]], group_by: str, aggregate_by: str, operation: str) -> Dict[Any, float]: Group the data by a specified key and aggregate the values of another key with a given operation. :param data: A list of dictionaries containing the data. :param group_by: The key to group by (e.g., \\"category\\"). :param aggregate_by: The key to aggregate by (e.g., \\"value\\"). :param operation: The aggregation operation to perform (e.g., \\"sum\\", \\"average\\", \\"min\\", \\"max\\"). :return: A dictionary with the grouped key and the aggregated value. # Check if operation is valid if operation not in {\\"sum\\", \\"average\\", \\"min\\", \\"max\\"}: raise ValueError(\\"Invalid operation. Only \'sum\', \'average\', \'min\', \'max\' are allowed.\\") # Dictionary to store grouped data grouped_data = {} for entry in data: if group_by not in entry or aggregate_by not in entry: raise KeyError(f\\"One or both keys \'{group_by}\' and \'{aggregate_by}\' not found in the data entry.\\") key = entry[group_by] value = entry[aggregate_by] if key not in grouped_data: grouped_data[key] = [] grouped_data[key].append(value) # Perform the aggregation result = {} for key, values in grouped_data.items(): if operation == \\"sum\\": result[key] = sum(values) elif operation == \\"average\\": result[key] = mean(values) elif operation == \\"min\\": result[key] = min(values) elif operation == \\"max\\": result[key] = max(values) return result"},{"question":"# Question: Longest Consecutive Subarray of 1s Create a function that finds the length of the longest subarray that contains only 1s in a given list of binary integers (0s and 1s). **Function Signature:** ```python def longest_consecutive_ones(nums: List[int]) -> int: ``` **Input:** * A list of integers `nums` where each element is either 0 or 1. **Output:** * An integer representing the length of the longest consecutive subarray consisting entirely of 1s. **Constraints:** * The list `nums` will contain between 1 and 10^6 elements. **Example:** ```python >>> longest_consecutive_ones([1, 1, 0, 1, 1, 1]) 3 >>> longest_consecutive_ones([0, 0, 0]) 0 >>> longest_consecutive_ones([1, 1, 1, 1, 1]) 5 >>> longest_consecutive_ones([1, 0, 1, 0, 1]) 1 ``` **Explanation:** 1. In the array `[1, 1, 0, 1, 1, 1]`, the longest subarray of consecutive 1s is `[1, 1, 1]` with a length of 3. 2. In the array `[0, 0, 0]`, there are no 1s, so the result is 0. 3. The entire array `[1, 1, 1, 1, 1]` consists of 1s, making the length 5. 4. In the array `[1, 0, 1, 0, 1]`, all 1s are separated by 0s, so the maximum length of consecutive 1s is just 1. **Performance Considerations:** * Ensure the function runs efficiently for large lists up to 10^6 elements.","solution":"from typing import List def longest_consecutive_ones(nums: List[int]) -> int: max_length = 0 current_length = 0 for num in nums: if num == 1: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"# Scenario You are working on a text-processing tool that needs to count the occurrences of each unique word within a given text while ignoring case. Additionally, the words should be sorted in the output based on their frequencies in descending order. If two words have the same frequency, they should be sorted alphabetically. # Problem Statement Write a function `word_frequencies(text: str) -> List[Tuple[str, int]]` that takes a string `text` and returns a list of tuples. Each tuple should contain a word and its frequency, and the list should be sorted by descending frequency and then alphabetically. # Input/Output Format * **Input**: * A string `text` which represents the input text to be processed. The string consists of words separated by spaces and may include punctuation. The text will contain between 1 and 100,000 characters. * **Output**: * A list of tuples where each tuple contains: * A lowercase string representing a unique word from the input text. * An integer representing the count of occurrences of that word in the text. * The list should be sorted by descending frequency and then alphabetically by the word. # Constraints * The function should handle punctuation appropriately, considering words case-insensitively. * The function should execute efficiently given the upper limit of the input size. # Example ```python >>> word_frequencies(\\"Hello world! Hello universe.\\") [(\'hello\', 2), (\'world\', 1), (\'universe\', 1)] >>> word_frequencies(\\"To be, or not to be! That is the question.\\") [(\'be\', 2), (\'to\', 2), (\'is\', 1), (\'not\', 1), (\'or\', 1), (\'question\', 1), (\'that\', 1), (\'the\', 1)] ``` # Guidance Consider using regular expressions to handle punctuation and to split the text into words properly. Utilize appropriate data structures for counting and sorting the words as required. Optimize for readability and performance within the given constraints.","solution":"from typing import List, Tuple import re from collections import Counter def word_frequencies(text: str) -> List[Tuple[str, int]]: Returns a list of tuples containing unique words and their frequencies in the given text. The list is sorted by frequency in descending order, then alphabetically for same frequency. # Convert text to lowercase text = text.lower() # Remove punctuation and split by whitespace to get words words = re.findall(r\'bw+b\', text) # Use Counter to count the occurrences of each word word_count = Counter(words) # Sort by frequency (descending) and then alphabetically sorted_word_count = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_word_count"},{"question":"# Problem: Inventory Management System for a Warehouse Scenario: You are designing an inventory management system for a warehouse that handles a variety of products. The system needs to support operations such as adding new inventory, removing inventory, and checking current stock levels. Each product is represented by a unique identifier and has associated quantities. Task: 1. Implement a class `Warehouse` that provides the following methods: * `add_product(product_id: str, quantity: int) -> None`: Adds a specified quantity of a product to the inventory. If the product does not exist, it is added to the inventory. * `remove_product(product_id: str, quantity: int) -> bool`: Removes a specified quantity of a product from the inventory. If the product does not exist or the quantity to be removed exceeds the available stock, the operation should not be performed and the function should return `False`. Otherwise, the operation should succeed and return `True`. * `check_stock(product_id: str) -> int`: Returns the current stock level for the specified product. If the product does not exist, it should return `0`. 2. Consider a warehouse that may have up to 10^5 products, each with identifiers and associated quantities. Input: 1. Product identifiers as strings: `product_id` (1 <= len(product_id) <= 20). 2. Quantities as integers: `quantity` (0 <= quantity <= 10^6). Output: 1. The `add_product` method should update the inventory but not return any value. 2. The `remove_product` method should return a boolean indicating the success (`True`) or failure (`False`) of the operation. 3. The `check_stock` method should return the quantity of the specified product in stock. Constraints: * Ensure efficient handling of large inventories, especially when adding, removing, and checking stock levels. * Consider edge cases where products may not exist in the inventory. Class Signature: ```python class Warehouse: def __init__(self): # Your code here pass def add_product(self, product_id: str, quantity: int) -> None: # Your code here pass def remove_product(self, product_id: str, quantity: int) -> bool: # Your code here return False def check_stock(self, product_id: str) -> int: # Your code here return 0 ``` Example: ```python # Example usage: warehouse = Warehouse() warehouse.add_product(\'apple\', 50) warehouse.add_product(\'banana\', 30) print(warehouse.check_stock(\'apple\')) # Output: 50 print(warehouse.check_stock(\'banana\')) # Output: 30 print(warehouse.check_stock(\'orange\')) # Output: 0 print(warehouse.remove_product(\'apple\', 20)) # Output: True print(warehouse.check_stock(\'apple\')) # Output: 30 print(warehouse.remove_product(\'banana\', 50)) # Output: False print(warehouse.check_stock(\'banana\')) # Output: 30 ``` Notes: * Implement efficient data structures to manage the inventory, ensuring optimal performance for each method. * Validation for input values should respect the constraints provided. Good luck, and ensure your code is robust, efficient, and handles edge cases effectively!","solution":"class Warehouse: def __init__(self): # Initialize the inventory as a dictionary self.inventory = {} def add_product(self, product_id: str, quantity: int) -> None: if product_id in self.inventory: self.inventory[product_id] += quantity else: self.inventory[product_id] = quantity def remove_product(self, product_id: str, quantity: int) -> bool: if product_id not in self.inventory or self.inventory[product_id] < quantity: return False self.inventory[product_id] -= quantity if self.inventory[product_id] == 0: del self.inventory[product_id] return True def check_stock(self, product_id: str) -> int: return self.inventory.get(product_id, 0)"},{"question":"# Problem Statement You are required to implement a simple file system that supports basic file operations such as creating files, writing to files, reading from files, and deleting files. The file system should handle an arbitrary number of files and manage the memory space dynamically. Requirements 1. **`create(file_name: str) -> bool`**: - Create a new empty file with the given name. - Return `True` if the file was created successfully. - Return `False` if a file with the same name already exists. 2. **`write(file_name: str, content: str) -> bool`**: - Write the given content to the file with the specified name. - If the file does not exist, create it and then write the content. - Return `True` if the content was written successfully, `False` otherwise. 3. **`read(file_name: str) -> Optional[str]`**: - Return the content of the specified file. - If the file does not exist, return `None`. 4. **`delete(file_name: str) -> bool`**: - Delete the file with the specified name. - Return `True` if the file was found and deleted, `False` otherwise. Constraints * File names are unique and case-sensitive. * The `content` to write can be any string. * Assume the total available memory is virtually unlimited for the purposes of this simulation. * Handle edge cases such as writing to non-existent files, reading deleted files, and deleting non-existent files. Example ```python class SimpleFileSystem: def __init__(self): # Initialize the file system with an empty directory. def create(self, file_name): # Implement the create method. def write(self, file_name, content): # Implement the write method def read(self, file_name): # Implement the read method def delete(self, file_name): # Implement the delete method ``` Testing * Initialize the file system and perform a series of file operations. * Test creating files and ensuring no duplicates are created. * Write content to files and ensure content is correctly saved. * Read from existing and non-existing files. * Delete files and validate the successful deletion of files. * Ensure the file system maintains consistency after multiple operations.","solution":"class SimpleFileSystem: def __init__(self): self.files = {} def create(self, file_name: str) -> bool: if file_name in self.files: return False self.files[file_name] = \\"\\" return True def write(self, file_name: str, content: str) -> bool: if file_name not in self.files: self.files[file_name] = content return True self.files[file_name] = content return True def read(self, file_name: str) -> str: return self.files.get(file_name, None) def delete(self, file_name: str) -> bool: if file_name in self.files: del self.files[file_name] return True return False"},{"question":"# Scenario You are responsible for implementing a system to manage a set of events. Each event will have a unique identifier, a start time, and an end time. Your objective is to track these events and provide functionalities to add new events, find the next event to occur, and check the availability of a required time slot. # Task Description Implement an `EventManager` class that can efficiently handle event management. The `EventManager` class should include the following functionalities: 1. Add a new event. 2. Retrieve the next event to occur, based on the current time. 3. Check if a given time interval is free, meaning no events conflict with that interval. # Input and Output Formats `EventManager` class should have the following methods: - `add_event(identifier: str, start_time: int, end_time: int)`: Adds a new event with the given identifier, start time, and end time. The start time and end time are integers representing the time in minutes from the start of the day (0 to 1440). - `get_next_event(current_time: int) -> str`: Returns the identifier of the next event to occur after the given current time. If no events are pending, return \\"No upcoming events\\". - `is_time_slot_free(start_time: int, end_time: int) -> bool`: Checks if the given time slot (from start_time to end_time) is free of any events. Returns True if free, otherwise False. # Constraints - Event identifiers are unique. - The start time and end time are within 0 to 1440 (representing minutes in a day). - The number of events (`n`) will not exceed (10^4). # Example ```python manager = EventManager() manager.add_event(\\"Meeting\\", 540, 600) manager.add_event(\\"Workshop\\", 630, 720) manager.add_event(\\"Lunch\\", 720, 780) assert manager.get_next_event(500) == \\"Meeting\\" assert manager.is_time_slot_free(600, 630) == True assert manager.is_time_slot_free(590, 620) == False manager.add_event(\\"Daily Standup\\", 600, 615) assert manager.get_next_event(600) == \\"Daily Standup\\" ``` # Requirements Implement the `EventManager` class efficiently, ensuring it handles all edge cases appropriately.","solution":"class EventManager: def __init__(self): self.events = [] def add_event(self, identifier: str, start_time: int, end_time: int): self.events.append((start_time, end_time, identifier)) self.events.sort(key=lambda x: (x[0], x[1])) def get_next_event(self, current_time: int) -> str: for start, end, identifier in self.events: if start > current_time: return identifier return \\"No upcoming events\\" def is_time_slot_free(self, start_time: int, end_time: int) -> bool: for event_start, event_end, _ in self.events: if start_time < event_end and end_time > event_start: return False return True"},{"question":"# Problem Statement You are given a list of integers where each integer represents the temperature on a particular day. Your task is to find the first day that is warmer than the current day for each day. If such a day does not exist, return -1 for that day. Write a function `next_warmer_day` that receives a list of integers representing daily temperatures and returns a list of integers of the same length where each element is the number of days until a warmer temperature. If there is no future day with a warmer temperature, return -1 for that day. # Input - A list of integers `temperatures` where 1 ≤ len(temperatures) ≤ 10^5 and -100 ≤ temperatures[i] ≤ 100. # Output - A list of integers where each element corresponds to the number of days until a warmer temperature or -1 if no such day exists. # Example ```python def test_next_warmer_day(): assert next_warmer_day([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, -1, -1] assert next_warmer_day([30, 40, 50, 60]) == [1, 1, 1, -1] assert next_warmer_day([30, 20, 10, 0]) == [-1, -1, -1, -1] assert next_warmer_day([50, 30, 40, 20, 35]) == [-1, 1, -1, 1, -1] def next_warmer_day(temperatures): # Implementation ``` # Notes - Utilize a stack to efficiently determine the first warmer day for each temperature in the list. - Always ensure handling of edge cases such as temperatures being in non-increasing order.","solution":"def next_warmer_day(temperatures): Given a list of temperatures, return a list of the same length where each element is the number of days until a warmer temperature. If there is no future day with a warmer temperature, return -1 for that day. n = len(temperatures) result = [-1] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: j = stack.pop() result[j] = i - j stack.append(i) return result"},{"question":"# Coding Question Problem Statement You are tasked with creating a function `is_palindrome_permutation` that determines if a given string is a permutation of a palindrome. Your function should ignore whitespace and be case-insensitive. Function Signature ```python def is_palindrome_permutation(s: str) -> bool: pass ``` Input and Output Requirements * **Input**: - `s` (str): A string which can contain letters and whitespace. * **Output**: - Returns `True` if the input string is a permutation of a palindrome; otherwise, returns `False`. Constraints * The function should ignore spaces and be case-insensitive. * The function should return `False` if the input string is empty. Examples 1. `is_palindrome_permutation(\\"Tact Coa\\")` should return `True` (permutations: \\"tacocat\\", \\"atcocta\\", etc.) 2. `is_palindrome_permutation(\\"Able was I ere I saw Elba\\")` should return `True` 3. `is_palindrome_permutation(\\"Random\\")` should return `False` 4. `is_palindrome_permutation(\\" \\")` should return `False` 5. `is_palindrome_permutation(\\"A Santa at Nasa\\")` should return `True` Make sure your implementation is efficient and handles potential edge cases, such as strings with only whitespace or varying case.","solution":"def is_palindrome_permutation(s: str) -> bool: Determines if a given string is a permutation of a palindrome. Ignores whitespace and is case-insensitive. if not s.strip(): return False s = s.replace(\\" \\", \\"\\").lower() from collections import Counter char_counts = Counter(s) odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Scenario You have been working on an e-commerce website that needs an efficient way to filter out fraudulent transactions. You are required to write a function that identifies transactions exceeding a specified threshold value and returns their indices. # Task Write a function `flag_fraudulent_transactions` that scans through a list of transaction amounts and flags transactions that exceed a given threshold. The function should return a list of indices where fraudulent transactions occur. # Function Signature ```python from typing import List def flag_fraudulent_transactions(transactions: List[float], threshold: float) -> List[int]: pass ``` # Input - `transactions` (List[float]): a list of transaction amounts (positive floats). - `threshold` (float): the threshold value above which a transaction is considered fraudulent. # Output - Returns a list of integers representing the indices of the transactions that exceed the given threshold. # Constraints - The transactions list may be empty. - The list\'s size does not exceed 10^6 elements. - Each transaction amount is a positive floating point number. - The threshold is a positive floating point number. # Performance Requirements - Ensure the solution efficiently handles large lists of transactions. # Examples ```python print(flag_fraudulent_transactions([], 100.0)) # Output: [] print(flag_fraudulent_transactions([50.0, 200.0, 150.0, 300.0, 20.0], 100.0)) # Output: [1, 2, 3] print(flag_fraudulent_transactions([10.0, 20.0, 30.0], 25.0)) # Output: [2] ``` # Hint Iterate through the list of transactions and use a list comprehension or a loop to gather indices where the transaction amount exceeds the threshold.","solution":"from typing import List def flag_fraudulent_transactions(transactions: List[float], threshold: float) -> List[int]: Returns a list of indices where the transactions exceed the given threshold. return [i for i, amount in enumerate(transactions) if amount > threshold]"},{"question":"**Scenario**: You\'re part of a team developing a logistics management system for a large e-commerce company. One of the tasks is to efficiently manage and track packages in a warehouse where packages are stacked in multiple rows. You need to implement a function that takes an initial configuration of package rows and a series of operations to either add a package to a specific row or remove the topmost package from a row. The code should correctly handle the addition and removal of packages from specific rows, and return the final state of the rows after all operations have been completed. # Function Signature ```python def manage_packages(initial_rows: List[List[str]], operations: List[Tuple[str, int, Optional[str]]]) -> List[List[str]]: pass ``` # Input - `initial_rows`: A list of lists where each inner list represents a row of packages. - `operations`: A list of tuples representing operations. Each tuple contains: - A string (`\\"add\\"` or `\\"remove\\"`) indicating the operation type. - An integer representing the row number (0-indexed) where the operation should be performed. - An optional string representing the package to be added (only applicable for the \\"add\\" operation). # Output - A list of lists representing the final state of the rows after all operations. # Constraints - The function should assume valid input: row indices will be within valid range, and \\"remove\\" operations will only be called on non-empty rows. # Example Usage ```python >>> initial_rows = [[\\"pkg1\\", \\"pkg2\\"], [\\"pkg3\\"], []] >>> operations = [(\\"add\\", 0, \\"pkg4\\"), (\\"remove\\", 1, None), (\\"add\\", 2, \\"pkg5\\"), (\\"remove\\", 0, None)] >>> manage_packages(initial_rows, operations) [[\'pkg1\', \'pkg2\'], [], [\'pkg5\']] ``` # Additional Notes - The function should correctly maintain the order of packages within each row after each operation. - If the operation is \\"add\\", the package should be appended to the end of the specified row. - If the operation is \\"remove\\", the last package from the specified row should be removed. - Optimize the function to handle a large number of rows and operations efficiently.","solution":"from typing import List, Tuple, Optional def manage_packages(initial_rows: List[List[str]], operations: List[Tuple[str, int, Optional[str]]]) -> List[List[str]]: for operation in operations: action, row, package = operation if action == \\"add\\": initial_rows[row].append(package) elif action == \\"remove\\": if initial_rows[row]: initial_rows[row].pop() return initial_rows"},{"question":"# Question: Implement a Custom Queue Data Structure Your task is to implement a custom queue data structure with additional capabilities. This queue should not only support the typical enqueue and dequeue operations but also include a method to retrieve the maximum value in the queue in constant time. **Definition**: 1. The queue should support `enqueue(value)` to add an element to the end of the queue. 2. The queue should support `dequeue()` to remove and return the element at the front of the queue. 3. It should include a method `max_value()` that returns the maximum value in the queue in constant time. The task is broken down as follows: 1. Implement the `enqueue(value)`, `dequeue()`, and `max_value()` methods. 2. Ensure that all operations adhere to the constant or average-case time complexity as described. **Expected Input and Output**: * `enqueue(value)`: Adds `value` (an integer) to the end of the queue. * `dequeue()`: Removes and returns the front element of the queue. * `max_value()`: Returns the maximum value in the queue in O(1) time. **Constraints**: * You may assume that all input values are integers. * If `dequeue()` is called on an empty queue, it should raise an Exception. * If `max_value()` is called on an empty queue, it should raise an Exception. # Example ```python # Example of usage: custom_queue = CustomQueue() custom_queue.enqueue(1) custom_queue.enqueue(3) custom_queue.enqueue(2) print(custom_queue.max_value()) # Expected output: 3 print(custom_queue.dequeue()) # Expected output: 1 print(custom_queue.max_value()) # Expected output: 3 custom_queue.dequeue() print(custom_queue.max_value()) # Expected output: 2 ``` # Performance Requirements - `enqueue(value)` should ideally run in O(1) time complexity. - `dequeue()` should ideally run in O(1) time complexity. - `max_value()` must run in O(1) time complexity. Your task: 1. Implement the `CustomQueue` class with the specified methods. 2. Write appropriate test cases to validate the solution. Good luck!","solution":"from collections import deque class CustomQueue: def __init__(self): self.queue = deque() self.max_vals = deque() def enqueue(self, value): self.queue.append(value) while self.max_vals and self.max_vals[-1] < value: self.max_vals.pop() self.max_vals.append(value) def dequeue(self): if not self.queue: raise Exception(\\"Queue is empty\\") value = self.queue.popleft() if value == self.max_vals[0]: self.max_vals.popleft() return value def max_value(self): if not self.max_vals: raise Exception(\\"Queue is empty\\") return self.max_vals[0]"},{"question":"# Question: Track User Activity for Course Enrollment You are tasked with developing a Python function that tracks the activity of users enrolling in different courses. The function should log the enrollments and provide a summary of the total enrollments for each course. Function Signature ```python def track_enrollments(enrollments: list[tuple[str, str]]) -> dict[str, int]: pass ``` Input: - `enrollments` (list of tuples): Each tuple contains two strings - (`user_id`, `course_id`), where `user_id` is the ID of the user who enrolled in the course, and `course_id` is the ID of the course. Output: - A dictionary where the key is `course_id`, and the value is the total number of enrollments for that course. Constraints: - A user can enroll in the same course multiple times, and each enrollment should be counted. - Assume `user_id` and `course_id` are non-empty strings. Sample Execution: ```python enrollments = [ (\'user1\', \'course1\'), (\'user2\', \'course1\'), (\'user1\', \'course2\'), (\'user1\', \'course1\'), (\'user2\', \'course2\') ] summary = track_enrollments(enrollments) print(summary) # Expected: {\'course1\': 3, \'course2\': 2} ``` Background: This exercise is designed to test your understanding of: - Processing list of tuples and aggregating data using dictionaries. - Counting occurrences and managing data integrity. - Handling multiple entries and summing counts accurately. **Example of the input `enrollments` list**: ```python [ (\'user1\', \'course1\'), (\'user2\', \'course1\'), (\'user1\', \'course2\'), (\'user1\', \'course1\'), (\'user2\', \'course2\') ] ``` The `track_enrollments` function will then output: ```python {\'course1\': 3, \'course2\': 2} ```","solution":"def track_enrollments(enrollments: list[tuple[str, str]]) -> dict[str, int]: Tracks the enrollments and returns a summary of the total enrollments for each course. Args: enrollments (list of tuples): A list of tuples where each tuple contains (`user_id`, `course_id`). Returns: dict: A dictionary where the keys are `course_id`, and the values are the total number of enrollments for that course. course_counts = {} for user_id, course_id in enrollments: if course_id in course_counts: course_counts[course_id] += 1 else: course_counts[course_id] = 1 return course_counts"},{"question":"# Coding Assessment Question # Scenario Your team is working on a file processing application that includes features for sorting and filtering data based on specific rules. You are required to implement a system that can process a list of records, where each record is a tuple of strings and integers, and support filtering and sorting operations. # Task Implement two functions: 1. `filter_records(records: List[Tuple], threshold: int) -> List[Tuple]` 2. `sort_records(records: List[Tuple], key_index: int, reverse: bool) -> List[Tuple]` **Function Details**: 1. **filter_records**: Filters the given `records` to include only those where the integer value (the second element of the tuple) is greater than the provided `threshold`. * **Input**: * `records` (List[Tuple]): A list of tuples, where each tuple consists of a string and an integer. * `threshold` (int): The integer threshold for filtering records. * **Output**: * (List[Tuple]): A list of tuples that meet the filtering criteria. 2. **sort_records**: Sorts the given `records` based on the value located at the provided `key_index` in each tuple. The sorting can be done in ascending or descending order as specified by the `reverse` flag. * **Input**: * `records` (List[Tuple]): A list of tuples, each containing mixed data types (strings and integers). * `key_index` (int): The index of the tuple element to sort by (0 for strings, 1 for integers). * `reverse` (bool): A boolean flag that indicates whether to sort in descending order. * **Output**: * (List[Tuple]): The sorted list of tuples. # Constraints and Requirements * The element at `key_index` within each tuple can either be a string or an integer. * The list of records will contain at least one tuple. * The `threshold` for the `filter_records` function will be a non-negative integer. * For the `sort_records` function, `key_index` will be a valid index within the tuples. * Both functions should handle edge cases such as empty lists gracefully. * Both functions should aim to have a performant and efficient implementation in terms of time complexity. **Example**: ```python records = [(\\"Alice\\", 34), (\\"Bob\\", 23), (\\"Charlie\\", 45), (\\"David\\", 27)] filter_records(records, 30) → [(\\"Alice\\", 34), (\\"Charlie\\", 45)] sort_records(records, 1, False) → [(\\"Bob\\", 23), (\\"David\\", 27), (\\"Alice\\", 34), (\\"Charlie\\", 45)] sort_records(records, 0, True) → [(\\"David\\", 27), (\\"Charlie\\", 45), (\\"Bob\\", 23), (\\"Alice\\", 34)] ``` # Additional Requirements 1. Implement error handling for invalid inputs (e.g., invalid `key_index` values). 2. Your solution should be efficient and strive to minimize unnecessary operations. 3. Write at least 3 test cases for both functions to ensure correctness and handle various scenarios.","solution":"from typing import List, Tuple def filter_records(records: List[Tuple[str, int]], threshold: int) -> List[Tuple[str, int]]: Filters given records to include only those where the integer value (the second element of the tuple) is greater than the provided threshold. Parameters: records (List[Tuple[str, int]]): List of tuples where each tuple consists of a string and an integer. threshold (int): The integer threshold for filtering records. Returns: List[Tuple[str, int]]: List of tuples that meet the filtering criteria. return [record for record in records if record[1] > threshold] def sort_records(records: List[Tuple[str, int]], key_index: int, reverse: bool) -> List[Tuple[str, int]]: Sorts the given records based on the value located at the provided key_index in each tuple. Parameters: records (List[Tuple[str, int]]): List of tuples with mixed data types (strings and integers). key_index (int): The index of the tuple element to sort by (0 for strings, 1 for integers). reverse (bool): A boolean flag indicating whether to sort in descending order. Returns: List[Tuple[str, int]]: The sorted list of tuples. if not records: return [] if not 0 <= key_index < len(records[0]): raise ValueError(\\"Invalid key index\\") return sorted(records, key=lambda x: x[key_index], reverse=reverse)"},{"question":"# Problem Statement You have been given an undirected graph represented as an edge list. Your task is to transform it into an adjacency list representation and then implement the BFS (Breadth-First Search) algorithm to traverse the graph starting from a given node. The BFS should return the order in which the nodes are visited. # Function Signature Here\'s the function signature you should implement: ```python def bfs_traversal(edge_list: List[Tuple[int, int]], start: int) -> List[int]: pass ``` # Input/Output Format - The `edge_list` parameter is a list of tuples, where each tuple represents an edge in the graph. For example, `(a, b)` means there is an edge between node `a` and node `b`. - The `start` parameter is an integer representing the starting node for BFS traversal. - The function should return a list of integers representing the order of nodes visited during the BFS traversal. # Constraints - The number of nodes, `n`, is such that `1 <= n <= 1000`. - The `edge_list` can have up to `10000` edges. - The graph is undirected and can have disconnected components. - Nodes are labeled with integers starting from `0`. # Examples ```python # Example 1 edges = [(0, 1), (0, 2), (1, 3), (2, 4)] start = 0 print(bfs_traversal(edges, start)) # Output: [0, 1, 2, 3, 4] # Example 2 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] start = 3 print(bfs_traversal(edges, start)) # Output: [3, 2, 4, 1, 5, 0, 6] # Example 3 edges = [(0, 3), (1, 3), (4, 5), (5, 6)] start = 4 print(bfs_traversal(edges, start)) # Output: [4, 5, 6] # Example 4 edges = [] start = 0 print(bfs_traversal(edges, start)) # Output: [0] ``` # Notes - A queue should be used to facilitate the BFS traversal. - You may assume that all node labels in the edge list are valid and within the range of the number of nodes. - If the start node does not have any edges, it should still be included in the output as the only node visited.","solution":"from typing import List, Tuple from collections import deque, defaultdict def bfs_traversal(edge_list: List[Tuple[int, int]], start: int) -> List[int]: # Create an adjacency list from the edge list adj_list = defaultdict(list) for u, v in edge_list: adj_list[u].append(v) adj_list[v].append(u) # Perform BFS traversal visited = set() queue = deque([start]) traversal_order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) traversal_order.append(node) for neighbor in sorted(adj_list[node]): if neighbor not in visited: queue.append(neighbor) return traversal_order"},{"question":"# Graph Shortest Path with Specific Node Exclusion You are required to implement a function that computes the shortest path from a given start node to a given end node in a graph, with the constraint that the path must exclude a specific node. This will help in scenarios where certain nodes are temporarily unavailable or need to be bypassed. **Expected Input and Output Formats**: * **Input**: - A dictionary representing the adjacency list of the graph (`graph: Dict[int, List[int]]`), where keys are node identifiers and values are lists of adjacent nodes. - Start node identifier (`start: int`). - End node identifier (`end: int`). - The node to be excluded (`excluded_node: int`). * **Output**: A list of node identifiers representing the shortest path from the start node to the end node, excluding the excluded node. If no such path exists, return an empty list. **Constraints/Limitations**: * The graph is unweighted. * The nodes are represented by unique integer identifiers. * The function should handle cases where the start or end node is the same as the excluded node by returning an empty list. * Ensure that the implementation efficiently finds the shortest path, potentially leveraging BFS. **Function Signature**: ```python def shortest_path_exclude_node(graph: dict[int, list[int]], start: int, end: int, excluded_node: int) -> list[int]: ... ``` # Example: ```python # Example input graph as an adjacency list graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3, 5], 5: [4] } # Example 1 start = 1 end = 5 excluded_node = 3 result = shortest_path_exclude_node(graph, start, end, excluded_node) print(result) # Possible output: [1, 2, 4, 5] # Example 2 start = 1 end = 3 excluded_node = 1 result = shortest_path_exclude_node(graph, start, end, excluded_node) print(result) # Output: [] # Example 3 start = 1 end = 5 excluded_node = 2 result = shortest_path_exclude_node(graph, start, end, excluded_node) print(result) # Possible output: [] ``` **Notes**: * Utilize the Breadth-First Search (BFS) algorithm for finding the shortest path in the graph. * Account for and appropriately handle scenarios where the start or end node cannot be a part of the path due to the exclusion constraint. * Ensure efficient implementation by minimizing unnecessary computations.","solution":"from collections import deque def shortest_path_exclude_node(graph: dict[int, list[int]], start: int, end: int, excluded_node: int) -> list[int]: Computes the shortest path from start node to end node in an unweighted graph, excluding a specific node. :param graph: Dictionary representing the graph as an adjacency list. :param start: Start node identifier. :param end: End node identifier. :param excluded_node: Node to be excluded in the path. :return: List of node identifiers representing the shortest path, or an empty list if no path exists. if start == excluded_node or end == excluded_node: return [] queue = deque([start]) visited = {start: None} while queue: current = queue.popleft() if current == end: path = [] while current is not None: path.append(current) current = visited[current] return path[::-1] # reverse the path to get from start to end for neighbor in graph.get(current, []): if neighbor != excluded_node and neighbor not in visited: queue.append(neighbor) visited[neighbor] = current return []"},{"question":"Detect Cycles in a Directed Graph You are working for a company that deals with complex networking systems. One of your tasks involves analyzing the structure of the network to ensure there are no cyclic dependencies. **Your task** is to write a function that takes a directed graph represented as an adjacency list and returns whether the graph contains any cycles. **Function Signature:** ```python def has_cycle(graph: dict) -> bool: Determine if the directed graph contains any cycles. :param graph: A dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of nodes to which it points. :return: True if there are cycles in the graph, otherwise False. pass ``` **Input:** - `graph` (dict): A dictionary where each key is a node, and the associated value is a list of nodes that the key node has directed edges to. **Output:** - Returns `True` if the graph contains any cycles, otherwise `False`. **Constraints:** - The graph can have at most 1000 nodes. - The graph can have at most 5000 edges. - Nodes are represented by integers. **Example Cases:** 1. Graph with a cycle: ```python graph = { 0: [1, 2], 1: [2], 2: [0, 3], 3: [3] } print(has_cycle(graph)) # True ``` 2. Graph without a cycle: ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } print(has_cycle(graph)) # False ``` 3. Graph with disconnected nodes and no cycles: ```python graph = { 0: [1], 1: [], 2: [3], 3: [] } print(has_cycle(graph)) # False ``` Implement the `has_cycle` function that adheres to the specification given above.","solution":"def has_cycle(graph: dict) -> bool: def visit(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if visit(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in graph: if visit(node): return True return False"},{"question":"# Coding Question: Implement the following two functions for the `TreeNode` class provided: 1. **Function to check if the tree is a Binary Search Tree (BST)**: Implement a method `is_bst` that checks whether the tree is a binary search tree. A binary search tree is defined as a binary tree in which, for every node, the value of all the nodes in its left subtree is less than the node\'s value, and the value of all the nodes in its right subtree is greater than the node\'s value. ```python class TreeNode: # existing methods... def is_bst(self) -> bool: Check if the tree is a binary search tree (BST). Returns: True if the tree is a BST, otherwise False. >>> TreeNode(2, TreeNode(1), TreeNode(3)).is_bst() True >>> TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6))).is_bst() False >>> TreeNode(1).is_bst() True # Your implementation here ``` 2. **Function to find the lowest common ancestor (LCA) of two nodes**: Implement a method `lowest_common_ancestor` that finds the lowest common ancestor of two nodes in the tree. The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself). ```python class TreeNode: # existing methods... def lowest_common_ancestor(self, p: int, q: int) -> \'TreeNode\': Find the lowest common ancestor (LCA) of two nodes in the binary search tree. Args: p: The value of the first node. q: The value of the second node. Returns: The LCA of node p and node q. >>> root = TreeNode(3, TreeNode(5, TreeNode(6), TreeNode(2, TreeNode(7), TreeNode(4))), TreeNode(1, TreeNode(0), TreeNode(8))) >>> root.lowest_common_ancestor(5, 1).val 3 >>> root.lowest_common_ancestor(6, 4).val 5 >>> root.lowest_common_ancestor(7, 8).val 3 # Your implementation here ``` # Constraints: * The tree node values are integers. * The tree may be unbalanced. * The maximum depth of the tree is not greater than 1000. * The values `p` and `q` are guaranteed to exist in the tree. # Examples: ```python root = TreeNode(6, TreeNode(2, TreeNode(0), TreeNode(4, TreeNode(3), TreeNode(5))), TreeNode(8, TreeNode(7), TreeNode(9))) print(root.is_bst()) # Output: True print(root.lowest_common_ancestor(2, 8).val) # Output: 6 print(root.lowest_common_ancestor(2, 4).val) # Output: 2 ``` # Additional Notes: * Ensure the methods correctly handle trees with only one node and empty subtrees (`null` nodes). * The `is_bst` method should consider trees with duplicates as not valid BSTs. * The implementation should be efficient in both time and space complexity for large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(self): Check if the tree is a binary search tree (BST). Returns: True if the tree is a BST, otherwise False. def validate(node, low=-float(\'inf\'), high=float(\'inf\')): if not node: return True if node.val <= low or node.val >= high: return False return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(self) def lowest_common_ancestor(self, p, q): Find the lowest common ancestor (LCA) of two nodes in the binary tree. Args: p: The value of the first node. q: The value of the second node. Returns: The LCA of node p and node q. def find_lca(node, p, q): if not node: return None if node.val == p or node.val == q: return node left = find_lca(node.left, p, q) right = find_lca(node.right, p, q) if left and right: return node return left if left else right return find_lca(self, p, q)"},{"question":"Anagram Pair Detection An anagram is a rearrangement of letters of one word to form another word. For example, \\"listen\\" and \\"silent\\" are anagrams of each other. You need to find all unique pairs of indices `(i, j)` in a given list of words such that the words at these indices are anagrams of each other. # Task Write a function `find_anagram_pairs(words: List[str]) -> List[Tuple[int, int]]` that takes a list of words and returns a list of tuples containing index pairs `(i, j)`, where `words[i]` and `words[j]` are anagrams of each other. Ensure that each pair is unique and `(i, j)` is considered the same as `(j, i)`. # Function Signature ```python def find_anagram_pairs(words: List[str]) -> List[Tuple[int, int]]: ``` # Input * A list of strings `words` (1 <= len(words) <= 1000, 1 <= len(words[i]) <= 100). Each string contains only lowercase alphabetic characters. # Output * A list of tuples containing pairs of indices `(i, j)` such that the words at these indices are anagrams of each other. Only unique pairs should be returned, and they should be in ascending order (e.g., the pair `(i, j)` should always satisfy `i < j`). # Examples ```python find_anagram_pairs([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"goo\\", \\"oo\\"]) → [(0, 1), (0, 2), (2, 1)] find_anagram_pairs([\\"abc\\", \\"bca\\", \\"cab\\", \\"abd\\", \\"dab\\"]) → [(0, 1), (0, 2), (1, 2)] find_anagram_pairs([\\"abc\\", \\"def\\", \\"ghi\\"]) → [] ``` # Constraints * You should optimize for performance to handle the maximum constraint efficiently. # Note Use appropriate data structures to ensure that your solution is both clear and efficient. Consider the properties of anagrams to guide your implementation.","solution":"from typing import List, Tuple from collections import defaultdict def find_anagram_pairs(words: List[str]) -> List[Tuple[int, int]]: # Dictionary to store the sorted version of words as keys and their original indices as values anagram_dict = defaultdict(list) # Populate the dictionary with indices of each sorted word for index, word in enumerate(words): sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(index) result = [] # Generate pairs of indices for words that have the same sorted word for indices in anagram_dict.values(): for i in range(len(indices)): for j in range(i+1, len(indices)): result.append((indices[i], indices[j])) return result"},{"question":"# Task: Validate and Normalize Email Addresses **Scenario**: In this task, you\'ll validate and normalize email addresses from a given list. Email validation will follow standard rules, and normalization will involve converting to lowercase and removing any spaces. **Function Details**: * **Function Name**: `validate_and_normalize` * **Input Parameters**: - `emails` (List[str]): A list of strings where each string is an email address. * **Output**: - A list of normalized email addresses that have been validated. Invalid email addresses should be omitted from the resulting list. * **Error Handling**: - If the input list is empty, raise a `ValueError` with the message \\"No emails provided\\". - If any email address does not comply with the basic format, raise a `ValueError` with the message \\"Invalid email format: {email}\\", where {email} should be replaced by the actual invalid email address. * **Example Usage**: ```python >>> validate_and_normalize([ ... \\"Example.Email@domain.COM\\", ... \\" user@domain.com \\", ... \\"invalid-email\\", ... \\"valid.email@domain.co\\" ... ]) [\'example.email@domain.com\', \'user@domain.com\', \'valid.email@domain.co\'] >>> validate_and_normalize([ ... \\" VALID@D.oM \\", ... \\"invalid@\\", ... \\"another.valid@domain.org\\" ... ]) [\'valid@d.om\', \'another.valid@domain.org\'] >>> validate_and_normalize([]) Traceback (most recent call last): ... ValueError: No emails provided >>> validate_and_normalize([ ... \\"invalid_email\\", ... \\"another@invalid.email\\" ... ]) Traceback (most recent call last): ... ValueError: Invalid email format: invalid_email ``` # Constraints: - The number of email addresses (n) will be in the range of 1 ≤ n ≤ 10^5. - Each email address can contain up to 320 characters. - Email validation will follow the basic rules: - It must contain exactly one \\"@\\" symbol. - The local part (before the @) and the domain part (after the @) must not be empty. - The domain part must contain at least one \\".\\" after the \\"@\\". - No spaces should be present in the email address, though spaces at the start or end should be trimmed. Consider the edge cases and ensure your solution handles them efficiently.","solution":"import re def validate_and_normalize(emails): Validates and normalizes a list of email addresses. if not emails: raise ValueError(\\"No emails provided\\") def is_valid(email): email_regex = r\'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,}\' return re.match(email_regex, email) is not None normalized_emails = [] for email in emails: email = email.strip().lower() if is_valid(email): normalized_emails.append(email) else: raise ValueError(f\\"Invalid email format: {email}\\") return normalized_emails"},{"question":"# Problem: Ecommerce Order Validation and Discount Application You are given an existing ecommerce system that processes customer orders. Each order contains details such as the list of items, quantities, prices, and the customer\'s membership status (regular, silver, gold, or platinum). The system needs an enhancement to validate the orders based on the available stock and apply discounts based on the customer’s membership level. Your tasks are as follows: 1. **Order Validation**: Ensure that the quantities of each item ordered do not exceed the available stock. 2. **Discount Application**: Apply the appropriate discount based on the customer\'s membership status. The discount rates are: - Silver: 5% - Gold: 10% - Platinum: 20% # Input - `order` (dictionary): A dictionary containing the order details. The structure is as follows: ```python { \\"customer_member_status\\": \\"gold\\", # can be one of \'regular\', \'silver\', \'gold\', \'platinum\' \\"items\\": [ {\\"item_id\\": 1, \\"quantity\\": 2, \\"price\\": 20.00}, # item_id is unique for each item {\\"item_id\\": 2, \\"quantity\\": 1, \\"price\\": 100.00}, ] } ``` - `stock` (dictionary): A dictionary mapping each `item_id` to the available stock quantity. Example: ```python { 1: 5, # item_id: available_quantity 2: 0, } ``` # Output - A dictionary with the key `status` which can be \\"success\\" or \\"failure\\", and a message. If successful, also include the `total` amount after discount. Example for a successful order: ```python { \\"status\\": \\"success\\", \\"total\\": 108.00 } ``` And for a failed order due to insufficient stock: ```python { \\"status\\": \\"failure\\", \\"message\\": \\"Item 2 is out of stock.\\" } ``` # Constraints - Ensure the order validation is done first, and an appropriate error message is provided if the order is invalid. - If valid, apply the discount to the total order cost based on the customer\'s membership status. - Handle edge cases such as empty orders or unknown membership statuses gracefully. # Example Usage ```python order = { \\"customer_member_status\\": \\"gold\\", \\"items\\": [ {\\"item_id\\": 1, \\"quantity\\": 2, \\"price\\": 20.00}, {\\"item_id\\": 2, \\"quantity\\": 1, \\"price\\": 100.00}, ] } stock = { 1: 5, 2: 0, } result = process_order(order, stock) print(result) # Expected output: { # \\"status\\": \\"failure\\", # \\"message\\": \\"Item 2 is out of stock.\\" # } ``` # Implementation Tips - Use conditional checks to compare item quantities in the order with available stock quantities. - Calculate the total cost of the order before discounts. - Apply the discount based on the membership status and ensure the final price is rounded to two decimal places. - Consider using dictionary methods such as `get()` to handle cases where an item_id might not be in the stock dictionary.","solution":"def process_order(order, stock): Validates the order based on the available stock and applies discount based on membership status. Parameters: order (dict): The order details including customer membership status and items. stock (dict): A dictionary mapping item_id to available stock quantities. Returns: dict: A result dictionary with status and either a total amount or an error message. status = order.get(\\"customer_member_status\\", \\"regular\\") items = order.get(\\"items\\", []) # First, validate the order based on the available stock for item in items: item_id = item[\\"item_id\\"] quantity = item[\\"quantity\\"] if item_id not in stock or stock[item_id] < quantity: return { \\"status\\": \\"failure\\", \\"message\\": f\\"Item {item_id} is out of stock.\\" } # If validation passes, calculate the total price total_price = 0.0 for item in items: total_price += item[\\"quantity\\"] * item[\\"price\\"] # Apply the discount based on membership status discounts = { \\"regular\\": 0.0, \\"silver\\": 0.05, \\"gold\\": 0.10, \\"platinum\\": 0.20, } discount_rate = discounts.get(status, 0.0) total_price = total_price * (1 - discount_rate) # Return the success result with the total_price rounded to 2 decimal places return { \\"status\\": \\"success\\", \\"total\\": round(total_price, 2) }"},{"question":"# Problem Statement Scenario: You\'re developing an inventory management system for a retail store. One of the requirements is to track the inventory of products and efficiently find the most frequently sold product within a specific time frame. The products are represented as a list of strings, where each string is the name of a product sold in a particular transaction. Efficient lookup and counting are crucial, especially for long lists of transactions. Task: Implement a function that finds the most frequently sold product from a list of transaction records. If there is a tie, return any one of the most frequent products. # Function Signature: ```python def most_frequent_product(transactions: List[str]) -> str: ``` Input: - `transactions`: A list of strings (1 ≤ len(transactions) ≤ 10^5, 1 ≤ len(transactions[i]) ≤ 100), where each string is the name of a product. Output: - Returns the string that is the most frequently sold product. If there are multiple products with the highest frequency, return any one of them. Constraints: - Optimize for both time and space complexity. Example: ```python most_frequent_product([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) # Expected Output: \\"apple\\" most_frequent_product([\\"shampoo\\", \\"soap\\", \\"shampoo\\"]) # Expected Output: \\"shampoo\\" most_frequent_product([\\"milk\\", \\"milk\\", \\"bread\\", \\"bread\\", \\"butter\\"]) # Expected Output: any one of \\"milk\\" or \\"bread\\" ``` # Note: 1. Aim for the most efficient approach considering both time and space complexity. 2. Handle edge cases such as single product lists or empty transactions.","solution":"from typing import List from collections import Counter def most_frequent_product(transactions: List[str]) -> str: Returns the most frequently sold product from the transactions list. If there are multiple products with the highest frequency, returns any one of them. if not transactions: return \\"\\" count = Counter(transactions) most_frequent = max(count.keys(), key=lambda k: count[k]) return most_frequent"},{"question":"# Problem Statement You are to implement a binary search algorithm to find the position of a target value within a sorted list. Write a function `binary_search` that performs this task. The function should use an iterative approach to avoid excessive recursion depth. # Input Format The function `binary_search` should accept the following parameters: ```python def binary_search(arr: list, target: int) -> int: # Implementation here ``` - `arr`: A list of integers sorted in ascending order. - `target`: An integer value representing the element to search for in the list. # Output Format The function should return: - An integer representing the 0-based index of the target value in the list if it is present. - If the target value is not present in the list, the function should return -1. # Example ```python arr = [1, 3, 5, 7, 9, 11] target = 5 index = binary_search(arr, target) print(index) # Output: 2 ``` ```python arr = [2, 4, 6, 8, 10] target = 7 index = binary_search(arr, target) print(index) # Output: -1 ``` # Constraints - The length of the list `arr` is between 0 and 10,000 inclusive. - The values in `arr` are between -10,000 and 10,000 inclusive. - If the list `arr` is empty, return -1. # Explanation A binary search algorithm works by repeatedly dividing the search interval in half. If the target value is less than the middle element of the interval, the search continues on the lower half, otherwise, it continues on the upper half. This process repeats until the target value is found or the interval is empty. Your task is to implement the `binary_search` function using an iterative method to ensure efficiency and avoid recursion. # Task Implement the `binary_search` function to perform an efficient search, ensuring to handle edge cases, such as an empty list or a target value not in the list. Confirm that your implementation is optimal within the provided constraints.","solution":"def binary_search(arr: list, target: int) -> int: Perform a binary search to find the position of the target value within a sorted list. Parameters: arr (list): A sorted list of integers in ascending order. target (int): The integer value to search for in the list. Returns: int: The index of the target value if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 mid_value = arr[mid] if mid_value == target: return mid elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Question: You are required to implement a function that uses the binary search method to find the square root of a given non-negative number. The square root of a number ( a ) is a value ( x ) such that ( x^2 = a ). Implement the following function: ```python def sqrt_binary_search(a: float, max_iter: int = 9999, tolerance: float = 1e-14) -> float: Square root approximated using binary search method. :param a: The non-negative number to find the square root of. :param max_iter: The maximum number of iterations to run (default = 9999). :param tolerance: The tolerance level for considering the approximation as sufficiently accurate (default = 1e-14). :return: Approximated square root of the given number. >>> all(abs(sqrt_binary_search(i) - math.sqrt(i)) <= 1e-14 for i in range(500)) True >>> sqrt_binary_search(4) 2.0 >>> sqrt_binary_search(2) 1.414213562373095 >>> sqrt_binary_search(0.25) 0.5 >>> sqrt_binary_search(100) 10.0 pass ``` # Requirements: 1. **Function Signature**: - The function should take a float number `a` and optional parameters `max_iter` for maximum iterations and `tolerance` for accuracy. - The function will return the square root of the number as a float. 2. **Input Constraints**: - ( a ) must be a non-negative real number. - ( max_iter ) will always be a positive integer (defaults to 9999). - ( tolerance ) will be a small positive float (defaults to ( 1e-14 )). 3. **Output**: - The function should return the square root of the input number. - The result should match the true value within the given tolerance. 4. **Performance**: - The function should converge quickly towards the solution using binary search. # Important Notes: - Ensure the function handles the edge case where the input is zero. - Validate the input and handle any potential errors according to the input constraints.","solution":"def sqrt_binary_search(a: float, max_iter: int = 9999, tolerance: float = 1e-14) -> float: Square root approximated using binary search method. :param a: The non-negative number to find the square root of. :param max_iter: The maximum number of iterations to run (default = 9999). :param tolerance: The tolerance level for considering the approximation as sufficiently accurate (default = 1e-14). :return: Approximated square root of the given number. if a < 0: raise ValueError(\\"Input must be a non-negative number.\\") if a == 0 or a == 1: return a lower_bound = 0 upper_bound = max(1, a) mid = (lower_bound + upper_bound) / 2 iter_count = 0 while abs(mid**2 - a) > tolerance and iter_count < max_iter: if mid**2 < a: lower_bound = mid else: upper_bound = mid mid = (lower_bound + upper_bound) / 2 iter_count += 1 return mid"},{"question":"# Question Problem Statement You are to implement a library tracking system for a small community library. The library wants to keep track of their collection of books and allow users to borrow and return books. Each book has a title, an author, and a unique identifier (ISBN). Implement a system to manage the borrowing and returning of books, ensuring that a book cannot be borrowed if it is already checked out. Function Signatures ```python class Library: def __init__(self): # Your code here def add_book(self, title: str, author: str, isbn: str): # Your code here def borrow_book(self, isbn: str) -> str: # Your code here def return_book(self, isbn: str) -> str: # Your code here ``` Definitions - `add_book(title, author, isbn)`: Adds a new book to the library collection. Each book has a title, an author, and a unique ISBN identifier. - `borrow_book(isbn)`: Allows a user to borrow a book given its ISBN. Returns a message indicating success or failure (e.g., \\"Book borrowed successfully\\" or \\"Book already borrowed\\"). - `return_book(isbn)`: Allows a user to return a borrowed book given its ISBN. Returns a message indicating success or failure (e.g., \\"Book returned successfully\\" or \\"Book was not borrowed\\"). Output - The methods should return appropriate messages as strings based on the operations performed. Constraints - Each book can only be added to the library once. Duplicate ISBN additions should be handled gracefully. - Borrow and return operations should check the status of the book (whether it is already borrowed or not). - Ensure thread-safety assuming multiple users might borrow and return books concurrently (consider using locks or similar mechanisms). Example Usage ```python library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", \\"1234567890\\") library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"2345678901\\") print(library.borrow_book(\\"1234567890\\")) # Output: \\"Book borrowed successfully\\" print(library.borrow_book(\\"1234567890\\")) # Output: \\"Book already borrowed\\" print(library.return_book(\\"1234567890\\")) # Output: \\"Book returned successfully\\" print(library.return_book(\\"1234567890\\")) # Output: \\"Book was not borrowed\\" print(library.return_book(\\"1111111111\\")) # Output: \\"Book not found in the library\\" ``` Notes - Ensure the library can handle a large collection of books efficiently. - Consider how you might extend the system in the future, such as tracking due dates or handling multiple copies of the same title. - Testing should cover typical operations as well as edge cases like attempting to borrow or return a non-existent book.","solution":"from threading import Lock class Library: def __init__(self): self.books = {} self.borrowed_books = {} self.lock = Lock() def add_book(self, title: str, author: str, isbn: str): with self.lock: if isbn not in self.books: self.books[isbn] = { \\"title\\": title, \\"author\\": author, \\"borrowed\\": False } return \\"Book added successfully\\" else: return \\"Book with this ISBN already exists in the library\\" def borrow_book(self, isbn: str) -> str: with self.lock: if isbn not in self.books: return \\"Book not found in the library\\" elif self.books[isbn][\\"borrowed\\"]: return \\"Book already borrowed\\" else: self.books[isbn][\\"borrowed\\"] = True return \\"Book borrowed successfully\\" def return_book(self, isbn: str) -> str: with self.lock: if isbn not in self.books: return \\"Book not found in the library\\" elif not self.books[isbn][\\"borrowed\\"]: return \\"Book was not borrowed\\" else: self.books[isbn][\\"borrowed\\"] = False return \\"Book returned successfully\\""},{"question":"# Problem Statement Write a function that converts a given integer from decimal (base-10) to any specified base (B) (2 through 16). The conversion must be achieved without using any built-in base conversion functions. Instead, implement the conversion manually using loops and string or list manipulations. # Function Signature ```python def convert_to_base(n: int, B: int) -> str: ``` # Input - An integer `n`, where (0 leq n leq 10^6). - An integer `B`, where (2 leq B leq 16). # Output - Return a string representing the number (n) in the base (B) notation. # Constraints - `0 leq n leq 10^6` - `2 leq B leq 16` - Use the digits `0-9` and the letters `A-F` for bases higher than 10. # Example 1. Example 1: - Input: `n = 31`, `B = 16` - Output: `\\"1F\\"` - Explanation: The base-16 representation of the decimal number 31 is 1F. 2. Example 2: - Input: `n = 255`, `B = 2` - Output: `\\"11111111\\"` - Explanation: The base-2 representation of the decimal number 255 is 11111111. 3. Example 3: - Input: `n = 0`, `B = 8` - Output: `\\"0\\"` - Explanation: The base-8 representation of the decimal number 0 is 0. # Additional Notes - Carefully handle the conversion to ensure accuracy for all possible input values. - Validate the input to ensure the base is within the proper range and handle invalid inputs gracefully. # Testing Utilize provided test cases and edge cases to verify the correctness of your implementation. ```python def convert_to_base(n: int, B: int) -> str: if not (0 <= n <= 10**6 and 2 <= B <= 16): raise ValueError(\\"Invalid inputnn must be between 0 and 10^6, B must be between 2 and 16.\\") if n == 0: return \\"0\\" digits = \\"0123456789ABCDEF\\" result = [] while n > 0: result.append(digits[n % B]) n //= B result.reverse() return \'\'.join(result) if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` This question integrates well with the existing set, requiring participants to understand and apply fundamental principles of number bases along with string manipulation and control structures in Python.","solution":"def convert_to_base(n: int, B: int) -> str: if not (0 <= n <= 10**6 and 2 <= B <= 16): raise ValueError(\\"Invalid input\\") if n == 0: return \\"0\\" digits = \\"0123456789ABCDEF\\" result = [] while n > 0: result.append(digits[n % B]) n //= B result.reverse() return \'\'.join(result)"},{"question":"# Coding Assessment Question Context: You are developing a file management system that sorts files based on their sizes. The size of each file is given in a human-readable format (e.g., KB, MB, GB). You need to implement a function to sort these files by their size, regardless of the unit. Task: Write a function `sort_files_by_size(file_list: list[str]) -> list[str]` that accepts a list of filenames with their respective sizes and returns a new list sorted by size in ascending order. Function Signature: ```python def sort_files_by_size(file_list: list[str]) -> list[str]: ``` Input: * A list of strings `file_list` where each string represents a file with its size in the format `filename_size.extension`. * The size is given in human-readable format with a suffix indicating the unit (B for bytes, KB for kilobytes, MB for megabytes, GB for gigabytes). * Example: `[\\"report_10MB.pdf\\", \\"image_500KB.png\\", \\"video_1GB.mp4\\", \\"text_5KB.txt\\"]` Output: * A new list of strings sorted by file size in ascending order. * Example: `[\\"text_5KB.txt\\", \\"image_500KB.png\\", \\"report_10MB.pdf\\", \\"video_1GB.mp4\\"]` Constraints: * The input list will contain between 1 and 10^5 filenames. * Filenames are non-empty strings that will always contain a size indicator in the format described above. * Sizes can range from 1B to 999GB. Example: ```python file_list = [\\"image_1MB.jpg\\", \\"text_500B.txt\\", \\"video_2GB.mp4\\"] assert sort_files_by_size(file_list) == [\\"text_500B.txt\\", \\"image_1MB.jpg\\", \\"video_2GB.mp4\\"] ``` Performance Requirements: * The solution should operate within O(n log n) time complexity for sorting. Summary: Implement the `sort_files_by_size` function to achieve sorting of the file list based on their sizes, handling various units (B, KB, MB, GB) and ensuring accurate comparison across different units.","solution":"def sort_files_by_size(file_list): Sorts a list of filenames by their sizes in ascending order. :param file_list: List of filenames with their respective sizes in the format \\"filename_size.extension\\". :type file_list: list of str :return: Sorted list of filenames by size in ascending order. :rtype: list of str def parse_size(size): units = {\\"B\\": 1, \\"KB\\": 1024, \\"MB\\": 1024**2, \\"GB\\": 1024**3} size = size.upper().strip() number = \'\'.join(filter(str.isdigit, size)) unit = \'\'.join(filter(str.isalpha, size)) return int(number) * units[unit] def extract_size(file): temp = file.split(\'_\')[-1] size = temp.split(\'.\')[0] return parse_size(size) return sorted(file_list, key=extract_size)"},{"question":"# Minimum Depth of Binary Tree Coding Assessment Question Context As part of a software team developing applications that involve data organization and retrieval, you often work with binary trees. An essential aspect in processing binary trees is determining certain properties, such as their depth, which can help optimize and balance the structures. Your task is to write a function that computes the minimum depth of a binary tree. Description Write a function `min_depth(root: TreeNode | None) -> int` that returns the minimum depth of a binary tree. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. Each node of the tree is represented by: ```python @dataclass class TreeNode: value: int = 0 left: TreeNode | None = None right: TreeNode | None = None ``` # Input - A reference to the root node of a binary tree. # Output - An integer representing the minimum depth of the binary tree. # Constraints - The number of nodes in the tree is within the range `[0, 5000]`. - Node values are unique integers. - If the input root is `None`, the function should return `0`. # Example ```python # Given the following binary tree structure # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) node9 = TreeNode(9) node20 = TreeNode(20) node15 = TreeNode(15) node7 = TreeNode(7) root.left = node9 root.right = node20 node20.left = node15 node20.right = node7 min_depth_result = min_depth(root) # The function should return 2, indicating the minimum depth of the binary tree ``` # Notes - Ensure your function runs efficiently and can handle both balanced and unbalanced trees. - A leaf is a node with no children. Implement the `min_depth` function to achieve the above requirements.","solution":"from typing import Optional from dataclasses import dataclass @dataclass class TreeNode: value: int left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None def min_depth(root: Optional[TreeNode]) -> int: if not root: return 0 if not root.left and not root.right: return 1 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1"},{"question":"# Problem Statement Develop a function to determine if a given matrix (2D list) contains a specified submatrix. Your algorithm should check whether there exists any submatrix in the given matrix that matches the specified submatrix entirely. **Description**: Given a matrix represented as a list of lists and a submatrix (which is also a list of lists), you must determine if the submatrix can be found within the main matrix. The submatrix should match exactly in any portion of the larger matrix without any rotations. # Function Signature ```python def contains_submatrix(matrix: List[List[int]], submatrix: List[List[int]]) -> bool: :param matrix: A list of lists representing the main matrix. :param submatrix: A list of lists representing the submatrix to find. :return: True if the submatrix is contained within the matrix, otherwise False. ``` # Input * `matrix`: A list of lists of integers where each list represents a row of the matrix, with size `m x n` (1 <= m, n <= 100). * `submatrix`: A list of lists of integers representing the submatrix with size `p x q` (1 <= p, q <= 100). # Output * A boolean value (`True` or `False`) indicating whether the submatrix is found within the main matrix. # Constraints * Both `matrix` and `submatrix` will contain integers. * It is assumed that `1 <= p <= m` and `1 <= q <= n`. # Example ```python main_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] submatrix_1 = [ [6, 7], [10, 11] ] submatrix_2 = [ [7, 8], [11, 12] ] submatrix_3 = [ [1, 2], [3, 4] ] assert contains_submatrix(main_matrix, submatrix_1) == True # Submatrix is present in the main matrix. assert contains_submatrix(main_matrix, submatrix_2) == True # Submatrix is present in the main matrix. assert contains_submatrix(main_matrix, submatrix_3) == False # Submatrix is not present in the main matrix. ``` # Approach 1. Iterate through the main matrix to find a possible starting point for the submatrix. 2. Once a potential starting point is identified, check if the submatrix matches completely from that position. 3. Return `True` if a match is found; otherwise, after complete verification, return `False`. # Edge Cases * A submatrix that is a single element would need a single element match in the upper bound. * Consider the smallest and largest dimensions of matrix and submatrix and ensure optimal performance. Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality.","solution":"def contains_submatrix(matrix, submatrix): m, n = len(matrix), len(matrix[0]) p, q = len(submatrix), len(submatrix[0]) for i in range(m - p + 1): for j in range(n - q + 1): if all(matrix[i + x][j + y] == submatrix[x][y] for x in range(p) for y in range(q)): return True return False"},{"question":"# Coding Assessment Question Problem Statement A company is trying to optimize their meeting schedules. They need to merge overlapping and adjacent time intervals in a schedule. You are provided with a list of intervals where each interval is a tuple of two integers representing the start and end time of a meeting. Your task is to implement a function `merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that merges any overlapping or adjacent intervals and returns a list of the merged intervals. Two intervals ((a, b)) and ((c, d)) are considered overlapping or adjacent if ((a le d text{ and } b ge c)) or (b = c). Requirements 1. Maintain the input and output formats as described. 2. Consider edge cases, such as empty input or intervals with zero length. 3. Ensure your solution works efficiently, aiming for a time complexity of (O(n log n)). Constraints * `intervals` is a list of tuples, each containing two integers (a) and (b) where (a le b). * The number of intervals does not exceed (10^4). * The values of (a) and (b) are within the range (-10^9 le a, b le 10^9). Input * A list of intervals `intervals` where each interval is defined by a tuple of two integers. Output * A list of merged intervals, where each interval is defined by a tuple of two integers. # Examples ```python >>> merge_intervals([(1, 3), (2, 6), (8, 10), (15, 18)]) [(1, 6), (8, 10), (15, 18)] >>> merge_intervals([(1, 4), (4, 5)]) [(1, 5)] >>> merge_intervals([(1, 3)]) [(1, 3)] >>> merge_intervals([]) [] >>> merge_intervals([(5, 10), (4, 6), (1, 2)]) [(1, 2), (4, 10)] ``` Implementation Template ```python def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass # You can add additional functions if required. if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [] # First we sort the intervals based on the starting time intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] # If the current interval overlaps with the last merged interval, merge them if current[0] <= last_merged[1]: merged_intervals[-1] = (last_merged[0], max(last_merged[1], current[1])) else: merged_intervals.append(current) return merged_intervals"},{"question":"# Question Write a function in Python that simulates a simple Finite State Machine (FSM). The function should take two inputs: a string representing the sequence of events and a dictionary defining the FSM transitions. The function should return the final state after processing all the events. Each input event is a single character, and the FSM dictionary has the following structure: - Keys are tuples of the form `(current_state, event)`. - Values are the next state to transition to. Consider the following rules: - The initial state is always \'S0\'. - If a transition for a given state and event does not exist, the FSM stays in the current state. Function Signature ```python def simulate_fsm(events: str, transitions: dict) -> str: ``` Input - `events`: A string of characters representing the sequence of events (1 ≤ len(events) ≤ 10^6). - `transitions`: A dictionary representing the state transitions. Output - Return a string representing the final state of the FSM after processing all the events. Example ```python events = \'abac\' transitions = { (\'S0\', \'a\'): \'S1\', (\'S0\', \'b\'): \'S2\', (\'S1\', \'a\'): \'S1\', (\'S1\', \'b\'): \'S2\', (\'S2\', \'a\'): \'S1\', (\'S2\', \'c\'): \'S3\', } print(simulate_fsm(events, transitions)) # Should return \'S3\' ``` # Additional Notes - Ensure the function processes large inputs efficiently. - Thoroughly test the FSM with typical sequences and edge cases where transitions may not be defined.","solution":"def simulate_fsm(events: str, transitions: dict) -> str: Simulates a Finite State Machine (FSM) and returns the final state. Parameters: events (str): Sequence of events. transitions (dict): Dictionary defining the FSM transitions. Returns: str: Final state after processing all the events. state = \'S0\' # Initial state for event in events: if (state, event) in transitions: state = transitions[(state, event)] return state"},{"question":"# Coding Assessment Question Scenario: You are required to implement an algorithm that determines if a given mathematical expression containing pairs of parentheses, brackets, and curly braces is balanced. In a balanced expression, every opening symbol has a corresponding closing symbol in the correct order. Problem Statement: Implement a Python function `is_balanced(expression: str) -> bool` that determines if a given string expression is balanced. Requirements: 1. The function should return `True` if the expression is balanced, and `False` otherwise. 2. The function should handle various types of brackets: `()`, `{}`, and `[]`. 3. Non-character inputs should raise a `TypeError`. 4. The function should efficiently process the string using a stack-based approach. Input: - A string `expression` containing the mathematical expression to be checked. The string can include any of the characters `()`, `{}`, and `[]` as well as any other alphanumeric characters. Output: - A boolean value: `True` if the expression is balanced, `False` otherwise. Constraints: - The length of the `expression` should not exceed (10^6) characters. - Your solution should operate in linear time complexity, (O(n)), where (n) is the length of the `expression`. Function Signature: ```python def is_balanced(expression: str) -> bool: ``` Example Cases: ```python assert is_balanced(\\"()\\") == True assert is_balanced(\\"([])\\") == True assert is_balanced(\\"{[()]}\\") == True assert is_balanced(\\"{[(])}\\") == False assert is_balanced(\\"{[}\\") == False assert is_balanced(\\"([]{}[({})])[]\\") == True assert is_balanced(\\"([]{}[({})])[]a\\") == True # including alphanumeric characters assert is_balanced(\\"[(({})\\") == False ``` Additional Information: - Use a stack data structure to efficiently determine the balance of the parentheses, brackets, and braces in the expression. - Consider edge cases, such as an expression containing only opening symbols or only closing symbols. Implement the `is_balanced` function as per the outlined requirements.","solution":"def is_balanced(expression: str) -> bool: Determines if a given string expression containing parentheses, brackets, and curly braces is balanced. :param expression: The input string containing the mathematical expression :return: True if the expression is balanced, otherwise False if not isinstance(expression, str): raise TypeError(\\"The input should be a string.\\") stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in \\"({[\\": stack.append(char) elif char in \\")}]\\": if stack and stack[-1] == matching_bracket[char]: stack.pop() else: return False # Ignore other alphanumeric characters return not stack"},{"question":"# Circular Queue Implementation You are required to implement a circular queue data structure that effectively utilizes the space by allowing the enqueue and dequeue operations to be performed in a circular fashion. Scenario: Imagine you are developing a real-time messaging system that processes incoming messages using a circular queue. The message processing component needs to handle bursts of incoming messages efficiently, ensuring that no data is lost or overwritten due to excessive data inflow. Your task is to create and demonstrate a circular queue with typical queue operations. Requirements: 1. **Class Definition**: Define a class `CircularQueue` with the necessary methods. 2. **Initialization**: * The queue should be initialized with a maximum capacity. * Raise a `ValueError` if the given capacity is not a positive integer. 3. **Enqueue Method**: * Implement an `enqueue` method to add an item to the circular queue. * If the queue is full, raise an `OverflowError`. 4. **Dequeue Method**: * Implement a `dequeue` method to remove and return the front item of the circular queue. * If the queue is empty, raise an `IndexError`. 5. **Peek Method**: * Implement a `peek` method to return the front item of the queue without removing it. * If the queue is empty, return `None`. 6. **IsEmpty and IsFull Methods**: * Implement `is_empty` and `is_full` methods to check the status of the queue. 7. **Display Method**: * Implement a `display` method to print the current items in the queue in order from front to rear. Input and Output Formats: * **Input**: * `enqueue` method: Takes one argument `item` of any type. * `dequeue` and `peek` methods: Take no arguments. * **Output**: * `dequeue` and `peek` methods: Return the front item or `None` if the queue is empty. * `is_empty` and `is_full` methods: Return `True` or `False`. * `display` method: Prints all items in the queue in order from front to rear. Constraints: * Maximum queue size should be greater than 0. * Items can be of any data type supported by Python. Example Usage: ```python queue = CircularQueue(3) print(queue.is_empty()) # Output: True queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) queue.display() # Output: [10, 20, 30] print(queue.is_full()) # Output: True try: queue.enqueue(40) except OverflowError: print(\\"Queue is full\\") # Output: Queue is full print(queue.dequeue()) # Output: 10 queue.display() # Output: [20, 30] print(queue.peek()) # Output: 20 queue.display() # Output: [20, 30] queue.enqueue(40) queue.display() # Output: [20, 30, 40] print(queue.is_full()) # Output: True ```","solution":"class CircularQueue: def __init__(self, capacity): if capacity <= 0: raise ValueError(\\"Capacity must be a positive integer\\") self.capacity = capacity self.queue = [None] * capacity self.front = 0 self.rear = 0 self.count = 0 def enqueue(self, item): if self.is_full(): raise OverflowError(\\"Queue is full\\") self.queue[self.rear] = item self.rear = (self.rear + 1) % self.capacity self.count += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue[self.front] self.queue[self.front] = None self.front = (self.front + 1) % self.capacity self.count -= 1 return item def peek(self): if self.is_empty(): return None return self.queue[self.front] def is_empty(self): return self.count == 0 def is_full(self): return self.count == self.capacity def display(self): if self.is_empty(): print(\\"[]\\") return items = [] for i in range(self.count): items.append(self.queue[(self.front + i) % self.capacity]) print(items)"},{"question":"# Context You are given the task of writing a utility function to help format strings based on a specific pattern. The pattern consists of placeholder tokens within curly braces `{}` that should be replaced by corresponding arguments. # Task Implement a function `format_string(template: str, *args) -> str` that takes a template string and a variable number of arguments. The function should replace every `{}` in the template with the corresponding argument in the same order. # Function Signature ```python def format_string(template: str, *args) -> str: pass ``` # Input - `template`: A string containing `{}` as placeholders. - `args`: A variable number of arguments that will replace the placeholders in order. # Output - A formatted string, where each `{}` in the template is replaced by the corresponding argument. # Constraints - The number of placeholders `{}` in the template will match the number of provided arguments exactly. - Arguments are guaranteed to be strings or can be converted to string using the `str()` function. # Performance Requirements - The function must efficiently handle strings of length up to `1000` with up to `100` placeholders. # Example Example 1: ```python >>> format_string(\\"Hello, {}. Welcome to {}!\\", \\"Alice\\", \\"Wonderland\\") \\"Hello, Alice. Welcome to Wonderland!\\" ``` Example 2: ```python >>> format_string(\\"{} + {} = {}\\", \\"1\\", \\"1\\", \\"2\\") \\"1 + 1 = 2\\" ``` # Notes - You can assume that all placeholders `{}` will have corresponding arguments. - The function should handle any type of arguments by converting them to strings before substitution.","solution":"def format_string(template: str, *args) -> str: Replaces each \'{}\' in the template with corresponding arguments. Parameters: - template (str): A string containing \'{}\' as placeholders - args: A variable number of arguments to replace the placeholders Returns: - str: The formatted string with placeholders replaced by arguments for arg in args: template = template.replace(\\"{}\\", str(arg), 1) return template"},{"question":"# Array Rotation Context: You are designing a feature for a visual presentation application, which allows users to rotate arrays that represent content on slides. Implementing array rotation functionality is crucial to support this feature. Task: Implement a function `rotate_array(arr: List[List[int]], k: int) -> List[List[int]]` that rotates a given 2D array `k` times clockwise. Each rotation operation shifts each element of the array by one position to the right. When an element reaches the end of a row, it wraps around to the beginning of the next row. If the element is at the last position of the array, it wraps to the first position of the array in the next rotation. Input: - `arr`: A 2D list of integers representing the array to be rotated. The dimensions are `M x N` where `1 <= M, N <= 1000`. - `k`: An integer representing the number of times the array should be rotated. Output: - Should return the rotated array as a 2D list of integers, each properly shifted according to the number of rotations. Constraints: - The input array dimensions are `M x N` where `1 <= M, N <= 1000`. - Each rotation moves an element to the adjacent position. - Input values in `arr` and the rotation count `k` are integers, with no specific constraints on the values contained within `arr`. Example: ```python arr = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] k = 1 rotate_array(arr, k) Output: [ [9, 1, 2], [3, 4, 5], [6, 7, 8] ] arr = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] k = 3 rotate_array(arr, k) Output: [ [10, 11, 12, 1], [2, 3, 4, 5], [6, 7, 8, 9] ] ``` Notes: - Make sure the rotation logic is correct for all possible values of `k`, especially for large values. - Consider edge cases like arrays with the minimum dimensions. - Optimize for performance, keeping in mind the constraints of `M`, `N`, and `k`. --- This question maintains consistency with the original sample question by focusing on image processing using array manipulation and maintaining similar constraints and example complexity.","solution":"def rotate_array(arr, k): Rotates a 2D array k times clockwise. Args: arr: List[List[int]] - The 2D array to be rotated. k: int - The number of times to rotate the array. Returns: List[List[int]] - The rotated 2D array. if not arr or k <= 0: return arr m, n = len(arr), len(arr[0]) total_elements = m * n k %= total_elements # only need to rotate k % total_elements times # Flatten the 2D array to a 1D list flat_arr = [arr[i // n][i % n] for i in range(total_elements)] # Perform rotation in the flattened array flat_arr = flat_arr[-k:] + flat_arr[:-k] # Convert the flat array back to 2D array rotated_arr = [[flat_arr[i * n + j] for j in range(n)] for i in range(m)] return rotated_arr"},{"question":"# Problem Statement: You are given a list of integers where each integer represents the number of steps you can move forward, backward, or stay in place from that position. Starting from the first position in the list, determine if you can reach the end of the list. Implement the function `can_reach_end(nums: List[int]) -> bool` to solve this problem. # Input: - `nums`: A list of non-negative integers. # Output: - A boolean value `True` if it\'s possible to reach the end of the list, otherwise `False`. # Constraints: 1. The list `nums` will have at least one element and at most 10^5 elements. 2. Each integer in the list is within the range `[0, 1000]`. # Performance Requirements: - Your solution should handle the maximum input size within a reasonable time frame, with linear time complexity O(n). # Example: Consider the list: ``` nums = [3, 2, 1, 0, 4] ``` Starting from index 0, you can move: - 3 steps to indices: 1, 2, or 3 From index 3, `nums[3]` is 0, meaning you cannot move any further. Therefore, it\'s not possible to reach the end of the list, and the function should return `False`. # Function Signature: ```python def can_reach_end(nums: List[int]) -> bool: pass ``` # Notes: - You can only move to a valid position within the list bounds. - Consider edge cases where the list has only one element. # Example Test Case: ```python def test_can_reach_end(): nums = [2, 3, 1, 1, 4] assert can_reach_end(nums) == True nums = [3, 2, 1, 0, 4] assert can_reach_end(nums) == False # Additional tests are recommended for thorough verification. ``` Develop code that correctly implements the above logic, potentially using a greedy strategy to continually update the farthest index you can reach as you iterate through the list.","solution":"def can_reach_end(nums): Function to determine if you can reach the last index of the list. Parameters: nums (List[int]): A list of non-negative integers where each integer represents the number of steps you can move forward from that position. Returns: bool: True if you can reach the last index, False otherwise. max_reachable = 0 last_index = len(nums) - 1 for i, num in enumerate(nums): if i > max_reachable: break max_reachable = max(max_reachable, i + num) if max_reachable >= last_index: return True return False"},{"question":"# Question You are developing a resource management system. One of the core functionalities is to identify underutilized systems in a network by comparing the actual usage with expected usage benchmarks. Your task is to implement a function `identify_underutilized_systems` that determines which systems are underutilized. Your function should: 1. Read the actual usage data and the benchmark data from provided JSON files. 2. Compare each system\'s actual usage to the benchmark. 3. Return a list of system identifiers that are under-utilized (i.e., actual usage is less than the benchmark). **Function Signature:** ```python def identify_underutilized_systems(usage_file: pathlib.Path, benchmark_file: pathlib.Path) -> list[str]: pass ``` # Input: - `usage_file`: A `pathlib.Path` object pointing to a JSON file with actual usage data. - `benchmark_file`: A `pathlib.Path` object pointing to a JSON file with benchmark usage data. # Output: - Returns a list of strings representing under-utilized system identifiers. # Constraints: - Both JSON files will contain dictionaries where keys are system identifiers and values are usage values (integer or float). - Raise appropriate errors if critical issues occur, e.g., file not found or invalid file structure. # Example: Given the usage and benchmark files: **Usage File Content (usage.json)**: ```json { \\"system_1\\": 50, \\"system_2\\": 80, \\"system_3\\": 30 } ``` **Benchmark File Content (benchmark.json)**: ```json { \\"system_1\\": 60, \\"system_2\\": 75, \\"system_3\\": 35 } ``` ```python # Example Usage: from pathlib import Path result = identify_underutilized_systems(Path(\\"usage.json\\"), Path(\\"benchmark.json\\")) print(result) # Output: [\'system_1\', \'system_3\'] as their usage is below benchmark ```","solution":"import json from pathlib import Path def identify_underutilized_systems(usage_file: Path, benchmark_file: Path) -> list[str]: Identifies and returns a list of underutilized systems by comparing actual usage with benchmark usage. :param usage_file: Path to the JSON file containing actual usage data :param benchmark_file: Path to the JSON file containing benchmark usage data :return: List of underutilized system identifiers try: with open(usage_file, \'r\') as uf, open(benchmark_file, \'r\') as bf: usage_data = json.load(uf) benchmark_data = json.load(bf) except FileNotFoundError as e: raise FileNotFoundError(f\\"File not found: {e.filename}\\") except json.JSONDecodeError: raise ValueError(\\"Invalid JSON format in one of the files.\\") underutilized_systems = [] for system, actual_usage in usage_data.items(): benchmark_usage = benchmark_data.get(system) if benchmark_usage is not None and actual_usage < benchmark_usage: underutilized_systems.append(system) return underutilized_systems"},{"question":"# Question: Implement a Custom HashMap with Dynamic Resizing **Context**: You are tasked with implementing a custom HashMap that supports dynamic resizing when the load factor exceeds a certain threshold. This HashMap should handle basic operations such as insertion, deletion, and lookup. Additionally, it should resize (double the capacity) dynamically to maintain efficient performance as more elements are added. **Function to Implement**: Implement the following class and methods: ```python class CustomHashMap: def __init__(self, initial_capacity=16, load_factor=0.75): Initialize the hash map with the given initial capacity and load factor. Parameters: initial_capacity: Initial size of the hash map. load_factor: The load factor threshold for resizing the hash map. def put(self, key, value): Inserts the (key, value) pair into the hash map. If the key already exists, update the value. Parameters: key: The key to be inserted or updated. value: The value associated with the key. def get(self, key): Retrieves the value associated with the given key. Parameters: key: The key to be looked up. Returns: The value associated with the key, or None if the key does not exist. def remove(self, key): Removes the (key, value) pair from the hash map if it exists. Parameters: key: The key to be removed. def _resize(self): Resizes the hash map when the load factor exceeds the threshold. ``` **Input/Output**: - **Operations**: - `put(key, value)`: Inserts or updates the key-value pair. - `get(key)`: Retrieves the value for the given key or `None` if the key does not exist. - `remove(key)`: Removes the key-value pair if the key exists. - **Initial Parameters**: - `initial_capacity`: Default initial size is 16. - `load_factor`: Default load factor threshold is 0.75. **Constraints**: - Keys and values are generic. - Avoid using Python\'s built-in dictionary functionalities directly. - Efficiently handle collisions using chaining or open addressing. - Resizing should double the capacity and redistribute the existing key-value pairs. **Requirements**: 1. Implement the hash map using arrays or lists as the underlying storage. 2. Ensure that the `put`, `get`, and `remove` operations are implemented efficiently. 3. Implement the `_resize` method to handle dynamic resizing based on the load factor. **Performance Considerations**: - `put`, `get`, and `remove` operations should be average O(1) time complexity. - The resizing operation should efficiently rehash and redistribute the existing elements.","solution":"class CustomHashMap: def __init__(self, initial_capacity=16, load_factor=0.75): self.capacity = initial_capacity self.load_factor = load_factor self.size = 0 self.buckets = [[] for _ in range(initial_capacity)] def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity >= self.load_factor: self._resize() bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return None def remove(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return def _resize(self): new_capacity = self.capacity * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for k, v in bucket: new_index = hash(k) % new_capacity new_buckets[new_index].append((k, v)) self.capacity = new_capacity self.buckets = new_buckets"},{"question":"# Connect 4 Winning Check **Context:** You are tasked with designing a function to determine the winner in a Connect 4 game, given the current state of the board. Connect 4 is a two-player game where players take turns dropping colored discs into a vertical grid. The objective is to be the first to form a horizontal, vertical, or diagonal line of four of one\'s own discs. # Problem Statement Given a 6x7 board representing the current state of a Connect 4 game, implement a function `check_winner(board: List[List[str]]) -> str` that determines whether there is a winner. The board is represented as a list of lists containing characters \'R\' for red, \'Y\' for yellow, and \'.\' for empty cells. 1. **Input:** - A 6x7 list of lists `board` where each element is either \'R\', \'Y\', or \'.\'. 2. **Output:** - A string representing the winner (\'R\' or \'Y\') or \'None\' if there\'s no winner yet. 3. **Constraints:** - The given board will always be a valid 6x7 list of lists. - There will be at most one winner in the provided board configuration. 4. **Examples:** ```python board1 = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'R\', \'Y\', \'.\', \'.\', \'.\'], [\'.\', \'R\', \'Y\', \'Y\', \'.\', \'.\', \'.\'], [\'R\', \'Y\', \'Y\', \'Y\', \'.\', \'.\', \'.\'] ] assert check_winner(board1) == \'Y\' board2 = [ [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'R\', \'Y\', \'R\', \'.\', \'.\', \'.\'], [\'.\', \'R\', \'R\', \'Y\', \'R\', \'.\', \'.\'], [\'.\', \'R\', \'Y\', \'Y\', \'Y\', \'R\', \'.\'] ] assert check_winner(board2) == \'None\' ``` # Solution Template ```python from typing import List def check_winner(board: List[List[str]]) -> str: Determine the winner in a Connect 4 game from the current board state. Parameters: board (List[List[str]]): 6x7 Connect 4 board Returns: str: \'R\', \'Y\' or \'None\' def check_line(line: List[str]) -> str: for i in range(len(line) - 3): if line[i] != \'.\' and line[i] == line[i + 1] == line[i + 2] == line[i + 3]: return line[i] return \'None\' # Check horizontal lines for row in board: result = check_line(row) if result != \'None\': return result # Check vertical lines for col in range(7): result = check_line([board[row][col] for row in range(6)]) if result != \'None\': return result # Check diagonals (top-left to bottom-right) for row in range(3): for col in range(4): result = check_line([board[row + i][col + i] for i in range(4)]) if result != \'None\': return result # Check diagonals (bottom-left to top-right) for row in range(3, 6): for col in range(4): result = check_line([board[row - i][col + i] for i in range(4)]) if result != \'None\': return result return \'None\' ```","solution":"from typing import List def check_winner(board: List[List[str]]) -> str: Determine the winner in a Connect 4 game from the current board state. Parameters: board (List[List[str]]): 6x7 Connect 4 board Returns: str: \'R\', \'Y\' or \'None\' def check_line(line: List[str]) -> str: for i in range(len(line) - 3): if line[i] != \'.\' and line[i] == line[i + 1] == line[i + 2] == line[i + 3]: return line[i] return \'None\' # Check horizontal lines for row in board: result = check_line(row) if result != \'None\': return result # Check vertical lines for col in range(7): result = check_line([board[row][col] for row in range(6)]) if result != \'None\': return result # Check diagonals (top-left to bottom-right) for row in range(3): for col in range(4): result = check_line([board[row + i][col + i] for i in range(4)]) if result != \'None\': return result # Check diagonals (bottom-left to top-right) for row in range(3, 6): for col in range(4): result = check_line([board[row - i][col + i] for i in range(4)]) if result != \'None\': return result return \'None\'"},{"question":"# Bounded Circular Buffer # Problem Statement You need to implement a bounded circular buffer which is a data structure that efficiently handles a fixed-size buffer. When the buffer is full and new data is added, the oldest data in the buffer is overwritten. # Task Implement a `CircularBuffer` class that: 1. Initializes with a fixed capacity (maximum number of elements the buffer can hold). 2. Supports appending new elements. 3. Allows overwriting the oldest elements when the buffer is full. 4. Provides methods to retrieve elements and the current size of the buffer. # Class Definition ```python class CircularBuffer: def __init__(self, capacity: int): Initializes the circular buffer with the given capacity. pass def append(self, value: int): Appends an element to the circular buffer. If the buffer is full, it overwrites the oldest element. pass def get_elements(self) -> list: Returns all the elements in the buffer in their respective order. pass def size(self) -> int: Returns the current number of elements in the buffer. pass ``` # Constraints - The buffer\'s capacity is a positive integer. (1 ≤ capacity ≤ 10^5) - Elements appended to the buffer are integers. (-10^9 ≤ value ≤ 10^9) - Implement the class methods with efficient time complexity. # Example ```python buffer = CircularBuffer(3) buffer.append(1) buffer.append(2) buffer.append(3) print(buffer.get_elements()) # Output: [1, 2, 3] print(buffer.size()) # Output: 3 buffer.append(4) print(buffer.get_elements()) # Output: [2, 3, 4] print(buffer.size()) # Output: 3 buffer.append(5) buffer.append(6) print(buffer.get_elements()) # Output: [4, 5, 6] print(buffer.size()) # Output: 3 ``` # Special Scenarios to Consider * Initializing buffer with varying capacities and checking its behavior with a variety of operations. * Handling the situation where buffer size is queried immediately after initialization. * Appending multiple elements to ensure old elements are appropriately overwritten while maintaining the circular buffer invariant.","solution":"class CircularBuffer: def __init__(self, capacity: int): Initializes the circular buffer with the given capacity. self.capacity = capacity self.buffer = [None] * capacity self.start = 0 self.end = 0 self.size = 0 def append(self, value: int): Appends an element to the circular buffer. If the buffer is full, it overwrites the oldest element. self.buffer[self.end] = value if self.size < self.capacity: self.size += 1 else: self.start = (self.start + 1) % self.capacity self.end = (self.end + 1) % self.capacity def get_elements(self) -> list: Returns all the elements in the buffer in their respective order. if self.size == 0: return [] elements = [] index = self.start for _ in range(self.size): elements.append(self.buffer[index]) index = (index + 1) % self.capacity return elements def current_size(self) -> int: Returns the current number of elements in the buffer. return self.size"},{"question":"# Task You are asked to implement a function to balance the given binary tree. The function should rearrange the nodes of the tree such that it becomes height-balanced while maintaining the in-order sequence of the original nodes. # Function Signature ```python def balance_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: ... ``` # Input - `root` (Optional[TreeNode]): The root node of the binary tree. # Constraints: - The definition for a binary tree node is already provided and includes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - It is guaranteed that the values of the nodes in the binary tree are unique. - The tree can be empty, in which case `root` is `None`. # Output - Returns the new root of the height-balanced binary tree. # Example ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> new_root = balance_tree(root) >>> is_balanced(new_root) True ``` # Considerations: - Ensure that the new tree is height-balanced, meaning the depths of the two subtrees of any node never differ by more than one. - Maintain an in-order sequence of the original nodes (i.e., the left subtree values are less, and the right subtree values are greater than the node\'s value). # Hint: - You may find it helpful to first extract the nodes, sort them, and then construct the balanced binary tree. # Function to Check Balance (For Testing): ```python def is_balanced(root: Optional[TreeNode]) -> bool: def check(node): if not node: return 0, True left_height, left_balanced = check(node.left) right_height, right_balanced = check(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return 1 + max(left_height, right_height), balanced _, balanced = check(root) return balanced ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_tree(root: Optional[TreeNode]) -> Optional[TreeNode]: # Helper function to perform in-order traversal and collect nodes. def inorder_traversal(node: Optional[TreeNode], nodes: List[TreeNode]): if not node: return inorder_traversal(node.left, nodes) nodes.append(node) inorder_traversal(node.right, nodes) # Helper function to construct the balanced binary tree. def sorted_array_to_bst(start: int, end: int, nodes: List[TreeNode]) -> Optional[TreeNode]: if start > end: return None mid = (start + end) // 2 node = nodes[mid] node.left = sorted_array_to_bst(start, mid - 1, nodes) node.right = sorted_array_to_bst(mid + 1, end, nodes) return node # Extract nodes in in-order sequence. nodes = [] inorder_traversal(root, nodes) # Construct balanced BST from the sorted nodes. return sorted_array_to_bst(0, len(nodes) - 1, nodes)"},{"question":"# Coding Assessment Question Scenario You are given a string of lowercase alphabets. To enhance text processing efficiency, you need to find out the frequency of each character in the string. Task Implement a function `character_frequency_count` that computes the frequency of each character in the string. Function Signature ```python def character_frequency_count(s: str) -> dict: Computes the frequency of each character in the input string. :param s: String, the input string containing lowercase alphabets. :return: Dictionary, where keys are characters and values are their respective frequencies in the string. ``` Input - A string `s`, where: * `1 <= len(s) <= 10^5` * All characters in the string are lowercase English letters (\'a\' to \'z\'). Output - A dictionary where the keys are characters and the values are the counts of their occurrences in the string. Constraints - Optimize the computation to ensure it performs efficiently even for the largest possible input size. Examples - Example 1: ```python s = \\"examplestring\\" return = {\'e\': 2, \'x\': 1, \'a\': 1, \'m\': 1, \'p\': 1, \'l\': 1, \'s\': 1, \'t\': 1, \'r\': 1, \'i\': 1, \'n\': 1, \'g\': 1} ``` - Example 2: ```python s = \\"aaaaaaa\\" return = {\'a\': 7} ``` - Example 3: ```python s = \\"abcdef\\" return = {\'a\': 1, \'b\': 1, \'c\': 1, \'d\': 1, \'e\': 1, \'f\': 1} ``` Notes - Ensure to handle edge cases such as when all characters in the string are the same or when the string size is at its maximum. - Aim for a solution with linear time complexity for optimal performance. Explanation: 1. Iterate through each character in the string. 2. Use a dictionary to count the occurrences of each character. 3. Return the dictionary containing the frequencies of all characters present in the string.","solution":"def character_frequency_count(s: str) -> dict: Computes the frequency of each character in the input string. :param s: String, the input string containing lowercase alphabets. :return: Dictionary, where keys are characters and values are their respective frequencies in the string. frequency_dict = {} for char in s: if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Professional Email Template Generator **Objective**: Write a function that generates a professional email template based on input parameters. The function should format the given information to produce a coherent and professional email body. Function Signature ```python def generate_email(subject: str, recipient_name: str, sender_name: str, body: str) -> str: ``` Input * A string `subject` representing the subject of the email. * A string `recipient_name` representing the name of the email recipient. * A string `sender_name` representing the name of the person sending the email. * A string `body` representing the main content of the email body. Output * A single formatted string that represents the whole email, structured as follows: ``` Subject: {subject} Dear {recipient_name}, {body} Sincerely, {sender_name} ``` Constraints * The function should handle any input strings, including those with special characters or multiple lines. * The maximum length of `subject`, `recipient_name` and `sender_name` is 100 characters. * The maximum length of `body` is 1000 characters. Example ```python >>> generate_email( subject=\\"Project Update\\", recipient_name=\\"John Doe\\", sender_name=\\"Jane Doe\\", body=\\"I wanted to give you a quick update on the project...\\" ) \'\'\' Subject: Project Update Dear John Doe, I wanted to give you a quick update on the project... Sincerely, Jane Doe \'\'\' >>> generate_email( subject=\\"Meeting Reminder\\", recipient_name=\\"Dr. Smith\\", sender_name=\\"Andrea\\", body=\\"This is a reminder for our meeting scheduled at 10 AM tomorrow. Please confirm your availability.\\" ) \'\'\' Subject: Meeting Reminder Dear Dr. Smith, This is a reminder for our meeting scheduled at 10 AM tomorrow. Please confirm your availability. Sincerely, Andrea \'\'\' >>> generate_email( subject=\\"Hello!\\", recipient_name=\\"Mark\\", sender_name=\\"Lucy\\", body=\\"Just wanted to say hi and see how you\'re doing. Hope all is well!\\" ) \'\'\' Subject: Hello! Dear Mark, Just wanted to say hi and see how you\'re doing. Hope all is well! Sincerely, Lucy \'\'\' >>> generate_email( subject=\\"Job Application\\", recipient_name=\\"Hiring Manager\\", sender_name=\\"Alice\\", body=\\"I am writing to apply for the software engineering position at your esteemed company. Attached are my resume and cover letter. Looking forward to hearing from you.\\" ) \'\'\' Subject: Job Application Dear Hiring Manager, I am writing to apply for the software engineering position at your esteemed company. Attached are my resume and cover letter. Looking forward to hearing from you. Sincerely, Alice \'\'\' ``` Scenario You are tasked with creating a feature for an email client where users can easily generate professional email templates. The function should take user inputs and format them into a standardized email structure. This feature will help users quickly create well-formatted emails for various professional scenarios. Performance Requirements * The function should handle string manipulations efficiently. * Ensure the output is correctly formatted and adheres to the constraints.","solution":"def generate_email(subject: str, recipient_name: str, sender_name: str, body: str) -> str: Generates a professional email template based on input parameters. Parameters: subject (str): Subject of the email. recipient_name (str): Name of the email recipient. sender_name (str): Name of the person sending the email. body (str): Main content of the email body. Returns: str: Formatted email string. return f Subject: {subject} Dear {recipient_name}, {body} Sincerely, {sender_name} .strip()"},{"question":"# Sum of All Distinct Prime Factors # Problem Statement You are required to implement a function `sum_of_distinct_prime_factors` which computes the sum of all distinct prime factors of a given non-negative integer. If the input integer is `0` or `1`, the function should return `0` as they have no prime factors. # Function Signature ```python def sum_of_distinct_prime_factors(number: int) -> int: pass ``` # Input * A single integer `number`, where `0 <= number <= 10^6`. # Output * Return the sum of all distinct prime factors of the given number. * If the number is `0` or `1`, return `0`. # Constraints * The function should handle non-negative integers only. * Input should be validated and appropriate exceptions should be raised for invalid inputs (`ValueError` for non-integers or negative integers). # Examples ```python >>> sum_of_distinct_prime_factors(0) 0 >>> sum_of_distinct_prime_factors(1) 0 >>> sum_of_distinct_prime_factors(28) 10 >>> sum_of_distinct_prime_factors(100) 5 >>> sum_of_distinct_prime_factors(97) 97 >>> sum_of_distinct_prime_factors(\'Hello\') Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> sum_of_distinct_prime_factors(-10) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> sum_of_distinct_prime_factors(3.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` # Explanation Consider the prime factorization of the numbers: * `28` is `2^2 * 7` -> distinct primes are `2` and `7`, sum is `9` * `100` is `2^2 * 5^2` -> distinct primes are `2` and `5`, sum is `7` * `97` is a prime itself, so the sum is `97` * `0` and `1` have no prime factors, so the sum is `0` You can use efficient algorithms to find the prime factors and ensure use of distinct primes only. # Implementation Notes * Validate input and raise `ValueError` if input is not an integer or is negative. * Use efficient algorithms to factorize the number and sum distinct prime factors. * Consider edge cases like `0` and `1` where the sum of prime factors should be `0`.","solution":"def sum_of_distinct_prime_factors(number: int) -> int: Returns the sum of all distinct prime factors of a given non-negative integer. If the input integer is 0 or 1, the function returns 0. if not isinstance(number, int) or number < 0: raise ValueError(\\"Input must be a non-negative integer\\") if number in (0, 1): return 0 def prime_factors(n): i = 2 factors = set() while i * i <= n: if n % i: i += 1 else: n //= i factors.add(i) if n > 1: factors.add(n) return factors factors = prime_factors(number) return sum(factors)"},{"question":"Binary Search and Sorting Algorithms You are required to implement two functions from scratch: one for performing insertions using binary search and another for sorting a list using an insertion sort algorithm enhanced with binary search for finding the correct position. Implement the following functions: 1. **binary_search_insert_position** - To find the position where an element should be inserted in a sorted list using binary search. 2. **binary_insertion_sort** - To sort a list of integers using insertion sort combined with binary search for insertion point determination. # Function Definitions Function 1: binary_search_insert_position ```python def binary_search_insert_position(arr: list[int], val: int, start: int, end: int) -> int: Find the index to insert val in arr[start:end] using binary search. Args: - arr (list[int]): The list in which to search for the insertion position. - val (int): The value to be inserted. - start (int): The starting index of the search range (inclusive). - end (int): The ending index of the search range (inclusive). Returns: - int: The index at which val should be inserted in order. ``` Function 2: binary_insertion_sort ```python def binary_insertion_sort(arr: list[int]) -> list[int]: Sort the list arr using insertion sort enhanced with binary search for finding the correct insertion position. Args: - arr (list[int]): The list of integers to be sorted. Returns: - list[int]: The sorted list of integers. ``` # Input and Output - **Input**: - arr: List of integers to be sorted. - **Output**: - For `binary_search_insert_position`: Index at which the value should be inserted to keep the list sorted. - For `binary_insertion_sort`: Sorted list of integers. # Constraints - Each integer in the input array is within the range [-10^4, 10^4]. - The input array has a length within the range [1, 1000]. # Additional Notes - Optimize your code for both time and space complexities. - Handle edge cases such as arrays with duplicate values or arrays that are already sorted. - Ensure your implementation handles both ascending and descending order inputs. - Comments and docstrings are encouraged for code clarity. # Example Usage ```python arr = [5, 2, 9, 1, 5, 6] # Binary Insertion Sort sorted_arr = binary_insertion_sort(arr) print(sorted_arr) # Output: [1, 2, 5, 5, 6, 9] ```","solution":"def binary_search_insert_position(arr: list[int], val: int, start: int, end: int) -> int: Find the index to insert val in arr[start:end] using binary search. Args: - arr (list[int]): The list in which to search for the insertion position. - val (int): The value to be inserted. - start (int): The starting index of the search range (inclusive). - end (int): The ending index of the search range (inclusive). Returns: - int: The index at which val should be inserted in order. while start <= end: mid = (start + end) // 2 if arr[mid] < val: start = mid + 1 else: end = mid - 1 return start def binary_insertion_sort(arr: list[int]) -> list[int]: Sort the list arr using insertion sort enhanced with binary search for finding the correct insertion position. Args: - arr (list[int]): The list of integers to be sorted. Returns: - list[int]: The sorted list of integers. for i in range(1, len(arr)): val = arr[i] j = binary_search_insert_position(arr, val, 0, i-1) arr[j + 1:i + 1] = arr[j:i] arr[j] = val return arr"},{"question":"# Context You have been tasked with developing a software module to manage customer orders for an online bookstore. One of the requirements is to generate a detailed invoice based on the list of purchased items and their prices. # Task Implement a Python function called `generate_invoice` that produces a formatted invoice as a string. Your function should adhere to the following requirements: # Requirements * Define the function as `generate_invoice(items: List[Tuple[str, float]], discount_rate: float) -> str`. * The function should accept a list of tuples, where each tuple contains the item name as a string and its price as a float. * The function should also accept a discount rate as a float, representing the discount percentage applied to the total cost. * The function should return a string representing a detailed invoice that includes: - A list of all items with their prices. - The total cost before discount. - The discount amount. - The total cost after discount. * The function should raise a `ValueError` if the `discount_rate` is less than 0 or greater than 100, with an appropriate error message. * Assume that input prices will be of type `float`. # Example Usage ```python >>> items = [(\\"Book A\\", 12.99), (\\"Book B\\", 8.50), (\\"Book C\\", 15.75)] >>> discount_rate = 10.0 >>> generate_invoice(items, discount_rate) \\"Items: Book A: 12.99 Book B: 8.50 Book C: 15.75 Total before discount: 37.24 Discount (10.0%): 3.72 Total after discount: 33.52\\" >>> items = [(\\"Book D\\", 20.0)] >>> discount_rate = -5 >>> generate_invoice(items, discount_rate) Traceback (most recent call last): ... ValueError: Discount rate must be between 0 and 100 >>> items = [(\\"Book E\\", 10.0)] >>> discount_rate = 105 >>> generate_invoice(items, discount_rate) Traceback (most recent call last): ... ValueError: Discount rate must be between 0 and 100 ``` # Constraints * The list of items will have at least one item. * Prices will be positive floating-point numbers. * Only valid discount rates between 0 and 100 are allowed. # Performance Requirements * The function must efficiently handle lists of up to 1000 items. * Ensure that the resulting invoice is well-formatted and easy to read.","solution":"from typing import List, Tuple def generate_invoice(items: List[Tuple[str, float]], discount_rate: float) -> str: if discount_rate < 0 or discount_rate > 100: raise ValueError(\\"Discount rate must be between 0 and 100\\") invoice_lines = [\\"Items:\\"] total_before_discount = 0.0 for item, price in items: invoice_lines.append(f\\"{item}: {price:.2f}\\") total_before_discount += price discount_amount = total_before_discount * (discount_rate / 100) total_after_discount = total_before_discount - discount_amount invoice_lines.append(f\\"Total before discount: {total_before_discount:.2f}\\") invoice_lines.append(f\\"Discount ({discount_rate}%): {discount_amount:.2f}\\") invoice_lines.append(f\\"Total after discount: {total_after_discount:.2f}\\") return \\"n\\".join(invoice_lines)"},{"question":"Coding Assessment Question You are given a problem where you need to analyze a grid of characters and identify the length of the longest word that can be constructed by moving to adjacent (horizontally or vertically) characters. Words are formed in a \\"snake-like\\" manner, where you can revisit characters but cannot use the same cell consecutively. Write a program to perform the following tasks: 1. Implement `get_neighbors(x: int, y: int, grid: List[List[str]]) -> List[Tuple[int, int]]`, which returns a list of valid neighboring cells for the cell at position (x, y). 2. Implement `longest_word_from(x: int, y: int, grid: List[List[str]], visited: Set[Tuple[int, int]]) -> int`, which returns the length of the longest word starting from the cell (x, y). 3. Implement `longest_snake_word(grid: List[List[str]]) -> int`, which returns the length of the longest snake-like word that can be formed in the grid. **Function Specifications** 1. **get_neighbors(x: int, y: int, grid: List[List[str]]) -> List[Tuple[int, int]]** * **Input**: Two integers `x` and `y` representing the current cell position, and a list of lists of characters `grid`. * **Output**: A list of tuples representing the valid neighboring cells. * **Example**: * `get_neighbors(1, 1, [[\'a\', \'b\'], [\'c\', \'d\']])` should return `[(0, 1), (2, 1), (1, 0), (1, 2)]`. 2. **longest_word_from(x: int, y: int, grid: List[List[str]], visited: Set[Tuple[int, int]]) -> int** * **Input**: Two integers `x` and `y` representing the starting cell position, a list of lists of characters `grid`, and a set `visited` containing previously visited cells. * **Output**: An integer which is the length of the longest word that can be formed starting from the cell (x, y). * **Example**: * `longest_word_from(0, 0, [[\'a\', \'b\'], [\'c\', \'d\']], set())` should return `4`. * `longest_word_from(1, 1, [[\'a\', \'a\'], [\'a\', \'a\']], set())` should return `2`. 3. **longest_snake_word(grid: List[List[str]]) -> int** * **Input**: A list of lists of characters `grid`. * **Output**: An integer which is the length of the longest snake-like word that can be formed in the grid. * **Example**: * `longest_snake_word([[\'a\', \'b\', \'c\'], [\'d\', \'e\', \'f\'], [\'g\', \'h\', \'i\']])` should return `9`. **Constraints** - The grid dimensions are between `1x1` and `1000x1000`. - The grid contains only lowercase alphabetical characters. - Ensure handling of edge cases like isolated characters or repetitive sequences. - Optimize for performance to handle large grids efficiently. **Scenario/Context** Imagine you are generating puzzle grids where players need to find the longest possible word by moving from letter to letter. This problem tests your ability to navigate grids, employ recursion or dynamic programming, and handle constraints effectively.","solution":"from typing import List, Tuple, Set def get_neighbors(x: int, y: int, grid: List[List[str]]) -> List[Tuple[int, int]]: neighbors = [] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] rows, cols = len(grid), len(grid[0]) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols: neighbors.append((nx, ny)) return neighbors def longest_word_from(x: int, y: int, grid: List[List[str]], visited: Set[Tuple[int, int]]) -> int: visited.add((x, y)) max_length = 1 for neighbor in get_neighbors(x, y, grid): if neighbor not in visited: max_length = max(max_length, 1 + longest_word_from(neighbor[0], neighbor[1], grid, visited)) visited.remove((x, y)) return max_length def longest_snake_word(grid: List[List[str]]) -> int: max_length = 0 for i in range(len(grid)): for j in range(len(grid[0])): max_length = max(max_length, longest_word_from(i, j, grid, set())) return max_length"},{"question":"# Check if Lists are Rotations Given two lists of integers, determine if one list is a rotation of the other. A list is considered a rotation of another list if it can be obtained by performing cyclic permutations on the other list. For example, [1, 2, 3] is a rotation of [2, 3, 1] and [3, 1, 2]. # Function Signature ```python def are_rotations(list_a: list, list_b: list) -> bool: pass ``` # Input - `list_a` (list of int): The first list of integers. - `list_b` (list of int): The second list of integers. # Output - Returns a boolean indicating whether `list_b` is a rotation of `list_a`. # Constraints - Both lists are of same length, `n` where ( 1 leq n leq 10^3 ). - Elements within the lists are integers. # Example ```python assert are_rotations([1, 2, 3], [3, 1, 2]) == True assert are_rotations([1, 2, 3], [1, 3, 2]) == False assert are_rotations([1, 1, 2], [2, 1, 1]) == True assert are_rotations([1], [1]) == True assert are_rotations([1, 2], [1, 2]) == True ``` # Context This question requires you to understand how to manipulate lists and perform cyclic permutations. The goal is to assess your proficiency with list operations and your ability to implement an algorithm that compares cyclically permuted lists.","solution":"def are_rotations(list_a: list, list_b: list) -> bool: Determine if list_b is a rotation of list_a. if len(list_a) != len(list_b): return False concatenated = list_a + list_a return \' \'.join(map(str, list_b)) in \' \'.join(map(str, concatenated))"},{"question":"# Tensor Manipulation Assessment You are required to design a function that reshapes a given one-dimensional list (vector) into a two-dimensional matrix of integers, following matrix dimensions specified by the user. If the reshaping operation cannot be performed (i.e., the number of elements in the vector does not perfectly match the product of the dimensions), return an empty list. Function Signature: ```python def reshape_vector(vector: List[int], rows: int, cols: int) -> List[List[int]]: ``` Input: - `vector` (List[int]): A one-dimensional list of integers. - `rows` (int): The number of rows for the target matrix. - `cols` (int): The number of columns for the target matrix. Output: - A two-dimensional list of integers representing the reshaped matrix if possible, otherwise an empty list. Constraints: - 1 <= len(vector) <= 10^4 - 1 <= rows, cols <= 100 - All integers are within the range of -10^6 to 10^6. Examples: ```python >>> reshape_vector([1, 2, 3, 4, 5, 6], 2, 3) [[1, 2, 3], [4, 5, 6]] >>> reshape_vector([1, 2, 3, 4, 5, 6, 7], 3, 3) [] >>> reshape_vector([1, 2, 3, 4, 5, 6], 3, 2) [[1, 2], [3, 4], [5, 6]] ``` Description: 1. Implement the `reshape_vector` function to check if the reshaping is feasible by comparing `rows * cols` with the length of the vector. 2. If feasible, populate the two-dimensional matrix row by row with the elements from the vector. 3. If not feasible, return an empty list as specified. 4. Ensure that the function handles edge cases efficiently, including those involving very small or maximal vector sizes. Adhere to the function signature and the input-output format precisely, ensuring seamless integration with the rest of the examination\'s expectations.","solution":"from typing import List def reshape_vector(vector: List[int], rows: int, cols: int) -> List[List[int]]: Reshapes a one-dimensional list into a two-dimensional matrix based on given rows and columns. :param vector: A list of integers to reshape. :param rows: The number of rows in the new matrix. :param cols: The number of columns in the new matrix. :return: A two-dimensional list of integers if reshaping is possible, otherwise an empty list. if len(vector) != rows * cols: return [] reshaped_matrix = [] for row in range(rows): start_index = row * cols reshaped_matrix.append(vector[start_index:start_index + cols]) return reshaped_matrix"},{"question":"# Quadratic Equation Solver with Iterative Refinement Background Solving quadratic equations of the form ( ax^2 + bx + c = 0 ) is a common problem in mathematics. The quadratic formula ( x = frac{-b pm sqrt{b^2 - 4ac}}{2a} ) provides a direct solution, but numerical precision errors can arise, especially when dealing with very small or very large coefficients. Task Implement a quadratic equation solver that iteratively refines its solutions to handle potential precision issues. Your implementation should: 1. Compute initial solutions using the quadratic formula. 2. Refine the solutions iteratively to ensure accuracy up to a specified tolerance. 3. Handle cases where the quadratic formula could be unreliable due to floating-point precision limitations. Your function should have the following signature: ```python def refined_quadratic_solver( a: float, b: float, c: float, max_iter: int = 50, tolerance: float = 1e-7 ) -> tuple[float, float]: ``` Constraints * The function should handle cases where ( a = 0 ) or where the discriminant ( b^2 - 4ac < 0 ). * Iterative refinement should correct for precision errors up to the specified tolerance. * Make sure the function can manage scenarios where coefficients are very small or very large without causing overflow or underflow errors. Example Usage ```python # Example quadratic equations a1, b1, c1 = 1, -3, 2 # Roots: 2, 1 a2, b2, c2 = 1, -2, 1 # Roots: 1, 1 (repeated root) a3, b3, c3 = 1, 0, -1 # Roots: 1, -1 # Test cases root1_1, root1_2 = refined_quadratic_solver(a1, b1, c1) assert {root1_1, root1_2} == {1, 2}, \\"Test Case 1 Failed\\" root2_1, root2_2 = refined_quadratic_solver(a2, b2, c2) assert root2_1 == root2_2 == 1, \\"Test Case 2 Failed\\" root3_1, root3_2 = refined_quadratic_solver(a3, b3, c3) assert {root3_1, root3_2} == {-1, 1}, \\"Test Case 3 Failed\\" print(f\\"Roots for the first equation: {root1_1}, {root1_2}\\") print(f\\"Roots for the second equation: {root2_1}, {root2_2}\\") print(f\\"Roots for the third equation: {root3_1}, {root3_2}\\") ``` Notes * Write appropriate unit tests to ensure the effectiveness of your quadratic solver with iterative refinement. * Consider potential edge cases, such as nearly zero coefficients, and handle them appropriately to avoid numerical errors.","solution":"import math def refined_quadratic_solver(a: float, b: float, c: float, max_iter: int = 50, tolerance: float = 1e-7) -> tuple[float, float]: if a == 0: if b == 0: raise ValueError(\\"Invalid equation: Both a and b cannot be zero.\\") return -c / b, -c / b discriminant = b**2 - 4 * a * c if discriminant < 0: raise ValueError(\\"The equation has complex roots.\\") root1 = (-b + math.sqrt(discriminant)) / (2 * a) root2 = (-b - math.sqrt(discriminant)) / (2 * a) def refine_root(root, coef_a, coef_b, coef_c): for _ in range(max_iter): # Evaluate the quadratic polynomial and its derivative f_value = coef_a * root**2 + coef_b * root + coef_c f_derivative = 2 * coef_a * root + coef_b if f_derivative == 0: break new_root = root - f_value / f_derivative if abs(new_root - root) < tolerance: return new_root root = new_root return root refined_root1 = refine_root(root1, a, b, c) refined_root2 = refine_root(root2, a, b, c) return refined_root1, refined_root2"},{"question":"# Parking Lot Design Problem You are tasked with designing a parking lot management system that efficiently manages the parking and retrieval of cars. The parking lot has multiple floors, each with multiple slots. # Problem Statement Design a system with the following capabilities: 1. Ability to park a car in the nearest available slot. 2. Ability to retrieve a car from a specific slot. 3. Ability to check the availability of parking slots. # Requirements * Implement a class `ParkingLot`. Methods 1. `__init__(floors: int, slots_per_floor: int)` * Initializes the parking lot with the given number of floors and slots per floor. 2. `park(car_id: int) -> Tuple[int, int]` * Parks a car with the given `car_id` in the nearest available slot. * Returns a tuple `(floor, slot)` representing the position where the car is parked. * If the parking lot is full, returns `(-1, -1)`. 3. `retrieve(floor: int, slot: int) -> int` * Retrieves the car parked at the given `floor` and `slot`. * Returns the `car_id` of the retrieved car. * If the slot is empty, returns `-1`. 4. `is_available(floor: int, slot: int) -> bool` * Checks the availability of the given `floor` and `slot`. * Returns `True` if the slot is available, otherwise `False`. # Examples ```python parking_lot = ParkingLot(2, 2) # 2 floors, 2 slots per floor # Park cars assert parking_lot.park(101) == (0, 0) assert parking_lot.park(102) == (0, 1) assert parking_lot.park(103) == (1, 0) assert parking_lot.park(104) == (1, 1) # Check availability assert parking_lot.is_available(0, 0) == False assert parking_lot.is_available(1, 0) == False assert parking_lot.is_available(1, 1) == False assert parking_lot.is_available(1, 2) == False # Retrieve car assert parking_lot.retrieve(0, 1) == 102 assert parking_lot.is_available(0, 1) == True # Park car in the now available slot assert parking_lot.park(105) == (0, 1) # Full parking lot assert parking_lot.park(106) == (-1, -1) ``` # Notes * Make sure to handle edge cases such as attempting to park when the parking lot is full or retrieving from an empty slot. * Consider using a queue to manage the nearest available slots efficiently. * Aim for optimal time complexity for parking and retrieving operations.","solution":"from typing import List, Tuple class ParkingLot: def __init__(self, floors: int, slots_per_floor: int): self.floors = floors self.slots_per_floor = slots_per_floor self.parking_lot = [[None for _ in range(slots_per_floor)] for _ in range(floors)] self.available_slots = [(f, s) for f in range(floors) for s in range(slots_per_floor)] def park(self, car_id: int) -> Tuple[int, int]: if not self.available_slots: return (-1, -1) floor, slot = self.available_slots.pop(0) self.parking_lot[floor][slot] = car_id return (floor, slot) def retrieve(self, floor: int, slot: int) -> int: if floor >= self.floors or slot >= self.slots_per_floor or self.parking_lot[floor][slot] is None: return -1 car_id = self.parking_lot[floor][slot] self.parking_lot[floor][slot] = None self.available_slots.insert(0, (floor, slot)) return car_id def is_available(self, floor: int, slot: int) -> bool: if floor >= self.floors or slot >= self.slots_per_floor: return False return self.parking_lot[floor][slot] is None"},{"question":"# Substring Search in a Sentence Description Given a sentence and a substring, implement a function to determine the number of times the substring appears in the sentence. Your function should be case-sensitive and handle various edge cases appropriately including empty strings and overlapping substrings. Function Signature ```python def count_substring_occurrences(sentence: str, substring: str) -> int: pass ``` Input * `sentence` (str): The sentence in which to search for the substring. * `substring` (str): The substring to search for within the sentence. Output * (int): The number of times the substring appears in the sentence. Constraints * 1 ≤ len(sentence) ≤ 10^3 * 1 ≤ len(substring) ≤ 10^3 Examples ```python # Example 1 count_substring_occurrences(\\"hello world\\", \\"o\\") # should return 2 # Example 2 count_substring_occurrences(\\"hello world\\", \\"l\\") # should return 3 # Example 3 count_substring_occurrences(\\"hello world\\", \\"lo\\") # should return 1 # Example 4 count_substring_occurrences(\\"hello world\\", \\"abc\\") # should return 0 # Example 5 count_substring_occurrences(\\"abababab\\", \\"ab\\") # should return 4 # Example 6 count_substring_occurrences(\\"\\", \\"a\\") # should return 0 # Example 7 count_substring_occurrences(\\"abc\\", \\"\\") # should return 0 (or invalid input, considering the constraints) ``` Notes Carefully consider edge cases such as empty strings. Ensure the function handles overlapping substrings correctly, where the same substring might need to be counted more than once if it appears in overlapping positions.","solution":"def count_substring_occurrences(sentence: str, substring: str) -> int: Returns the number of times the substring appears in the sentence. This includes overlapping substrings. if not sentence or not substring: return 0 count = 0 start = 0 while True: start = sentence.find(substring, start) if start == -1: break count += 1 # Move to the next character after the current found substring start += 1 return count"},{"question":"# Sentence Anagram Count You are given a sentence and a target word. Your task is to write a function that counts how many times an anagram of the target word appears in the sentence. An anagram is a permutation of the letters of a word. For this problem, consider only the alphabetic characters and ignore case differences. # Function Signature ```python def count_anagrams(sentence: str, target: str) -> int: pass ``` # Input and Output * **Input**: - `sentence` (type: `str`): The sentence in which to look for anagrams. - `target` (type: `str`): The target word for which anagrams are counted. * **Output**: - (type: `int`): The number of anagrams of the target word found in the sentence. # Constraints * The sentence may contain uppercase and lowercase letters, digits, punctuation marks, and spaces. * The target word will contain only alphabetic characters and won\'t be empty. * Anagrams should be counted in a case-insensitive manner. # Example ```python # Test case 1: sentence = \\"bored Robed BoreD.\\" target = \\"Robed\\" # Expected output: 3 print(count_anagrams(sentence, target)) # Test case 2: sentence = \\"Listen, Silent and Enlist are anagrams.\\" target = \\"tinsel\\" # Expected output: 3 print(count_anagrams(sentence, target)) # Test case 3: sentence = \\"No anagram here.\\" target = \\"random\\" # Expected output: 0 print(count_anagrams(sentence, target)) ``` # Notes - Consider only whole words; substrings of words that form anagrams should not be counted. - The function should ignore case differences when comparing letters.","solution":"from collections import Counter import string def count_anagrams(sentence: str, target: str) -> int: Counts how many times an anagram of the target word appears in the sentence. Parameters: sentence (str): The sentence in which to look for anagrams. target (str): The target word for which anagrams are counted. Returns: int: The number of anagrams of the target word found in the sentence. # Convert target to lower case and get its letter frequency target = target.lower() target_counter = Counter(target) # Normalize sentence to lower case and split into words words = sentence.lower().split() # Remove punctuation from each word words = [\'\'.join(filter(str.isalpha, word)) for word in words] # Count and return the number of anagram matches return sum(1 for word in words if Counter(word) == target_counter)"},{"question":"# Number Array Transformation # Problem Description You are given an array of integers and a series of transformation operations. Each operation is defined by three parameters: starting index, ending index, and a value `K`. For each operation, you need to increment every element in the array from the starting index to ending index (inclusive) by `K`. Write a function that applies a list of these transformation operations to the array and returns the transformed array. # Function Signature ```python def transform_array(arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: ``` # Input * `arr` (List[int]): The initial array of integers. * `operations` (List[Tuple[int, int, int]]): A list of operations, where each operation is represented as a tuple `(start_index: int, end_index: int, k: int)`: - `start_index` (int): The starting index of the range to be incremented. - `end_index` (int): The ending index of the range to be incremented. - `k` (int): The value by which each element in the specified range should be incremented. # Output * (List[int]): The transformed array after applying all operations. # Constraints * `1 <= len(arr) <= 10^5` * `0 <= start_index <= end_index < len(arr)` * `-10^6 <= arr[i] <= 10^6` for all `i` * `-10^6 <= k <= 10^6` * `1 <= len(operations) <= 10^5` # Example Usage ```python assert transform_array([1, 2, 3, 4, 5], [(0, 2, 2), (1, 3, 3), (0, 4, 1)]) == [4, 8, 9, 8, 6] assert transform_array([0, 0, 0, 0], [(0, 1, 1), (1, 2, 2), (2, 3, 3)]) == [1, 3, 5, 3] ``` # Explanation In the first example: 1. After the first operation (0, 2, 2), the array becomes [3, 4, 5, 4, 5]. 2. After the second operation (1, 3, 3), the array becomes [3, 7, 8, 7, 5]. 3. After the third operation (0, 4, 1), the array becomes [4, 8, 9, 8, 6]. In the second example: 1. After the first operation (0, 1, 1), the array becomes [1, 1, 0, 0]. 2. After the second operation (1, 2, 2), the array becomes [1, 3, 2, 0]. 3. After the third operation (2, 3, 3), the array becomes [1, 3, 5, 3].","solution":"def transform_array(arr, operations): Applies a list of transformation operations to the array and returns the transformed array. Parameters: arr (List[int]): The initial array of integers. operations (List[Tuple[int, int, int]]): A list of operations, where each operation is represented as a tuple (start_index, end_index, k). start_index (int): The starting index of the range to be incremented. end_index (int): The ending index of the range to be incremented. k (int): The value by which each element in the specified range should be incremented. Returns: List[int]: The transformed array after applying all operations. for start_index, end_index, k in operations: for i in range(start_index, end_index + 1): arr[i] += k return arr"},{"question":"# Scenario: You are working on a new development project and are asked to create a function that determines if a number is a prime. The goal is to ensure that your solution is robust and efficient, especially for larger input values. # Task: Write a function `is_prime(n: int) -> bool` that returns `True` if the given number is prime, and `False` if it is not. Your function should optimize for both time and space complexity. # Input: * An integer `n` (0 <= n <= 10^9), the number to check for primality. # Output: * A boolean value - `True` if `n` is a prime number, `False` otherwise. # Example: ```python def is_prime(n: int) -> bool: pass print(is_prime(10)) # Output: False print(is_prime(7)) # Output: True print(is_prime(1)) # Output: False print(is_prime(0)) # Output: False print(is_prime(97)) # Output: True ``` # Constraints: * Your solution should emphasize efficiency in terms of both time and space complexities. * Ensure that your function handles the edge cases such as `n` being 0 or 1. * Avoid using excessive loops and unnecessary computations. **Hint**: Consider well-known algorithms such as the Sieve of Eratosthenes for precomputation of primes up to a certain limit, or optimized trial division up to the square root of `n`.","solution":"def is_prime(n: int) -> bool: Determines if a number n is prime. :param n: An integer to check for primality. :return: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Coding Question - Partition Equal Subset Sum Given a non-empty array `nums` containing only positive integers, determine if it can be partitioned into two subsets, such that the sum of the elements in both subsets is equal. Return a boolean value. # Function Signature ```python def can_partition(nums: List[int]) -> bool: ``` # Input - `nums` (List[int]): A list of positive integers. # Output - Returns a boolean value `True` if the array can be partitioned into two subsets with equal sum, otherwise returns `False`. # Constraints - `1 <= len(nums) <= 200` - `1 <= nums[i] <= 100` # Example ```python assert can_partition([1, 5, 11, 5]) == True assert can_partition([1, 2, 3, 5]) == False assert can_partition([3, 3, 3, 4, 5]) == True assert can_partition([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == False ``` # Notes - Use a dynamic programming approach to solve this problem efficiently. - Consider the total sum of the array elements, and check if it’s divisible by 2. If it isn’t, return `False`. - If it is divisible, use a boolean DP array to check if there is a subset with a sum equal to half of the total array sum. - Ensure your solution handles edge cases like arrays with all identical elements or having very few elements.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we cannot partition it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Coding Assessment Question Background A software application for managing employee data at a company requires a feature to implement promotions and salary increases. Each employee has a name, position, and salary. The application should have the capability to promote an employee based on a promotion list, which contains the names of employees to be promoted along with their new positions and new salaries. Objective Your task is to create a function that takes in a list of employee records and a list of promotions. It should update the employee records with the new positions and salaries provided in the promotion list. Function Signature ```python def promote_employees(employee_list: list, promotion_list: list) -> list: ``` Input * `employee_list` (list): A list of dictionaries where each dictionary represents an employee with the keys \'name\', \'position\', and \'salary\'. * `promotion_list` (list): A list of dictionaries where each dictionary contains an \'name\', \'new_position\', and \'new_salary\'. Output * Return the updated list of employee records after applying all promotions. Constraints 1. Each employee\'s name in the `promotion_list` must be present in the `employee_list`. 2. The `employee_list` will have unique employee names. Example 1 ```python employee_list = [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Developer\\", \\"salary\\": 70000}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Support\\", \\"salary\\": 50000} ] promotion_list = [ {\\"name\\": \\"Alice\\", \\"new_position\\": \\"Senior Developer\\", \\"new_salary\\": 85000}, {\\"name\\": \\"Charlie\\", \\"new_position\\": \\"Senior Support\\", \\"new_salary\\": 60000} ] print(promote_employees(employee_list, promotion_list)) ``` Expected Output: ```python [ {\\"name\\": \\"Alice\\", \\"position\\": \\"Senior Developer\\", \\"salary\\": 85000}, {\\"name\\": \\"Bob\\", \\"position\\": \\"Manager\\", \\"salary\\": 90000}, {\\"name\\": \\"Charlie\\", \\"position\\": \\"Senior Support\\", \\"salary\\": 60000} ] ``` Example 2 ```python employee_list = [ {\\"name\\": \\"Eric\\", \\"position\\": \\"Analyst\\", \\"salary\\": 40000}, {\\"name\\": \\"Diana\\", \\"position\\": \\"Marketing\\", \\"salary\\": 60000} ] promotion_list = [ {\\"name\\": \\"Diana\\", \\"new_position\\": \\"Senior Marketing\\", \\"new_salary\\": 75000} ] print(promote_employees(employee_list, promotion_list)) ``` Expected Output: ```python [ {\\"name\\": \\"Eric\\", \\"position\\": \\"Analyst\\", \\"salary\\": 40000}, {\\"name\\": \\"Diana\\", \\"position\\": \\"Senior Marketing\\", \\"salary\\": 75000} ] ``` Notes * Ensure that the function updates the `employee_list` in-place efficiently and operates within the given constraints. * Assume that the inputs are well-formed and contain correct data types.","solution":"def promote_employees(employee_list: list, promotion_list: list) -> list: Updates the employee_list with promotions based on the promotion_list. Parameters: - employee_list (list): A list of employee records with \'name\', \'position\', and \'salary\'. - promotion_list (list): A list of promotions with \'name\', \'new_position\', and \'new_salary\'. Returns: - list: The updated list of employee records after applying all promotions. # Convert employee_list to a dictionary for faster lookups employee_dict = {employee[\'name\']: employee for employee in employee_list} # Apply promotions for promotion in promotion_list: name = promotion[\'name\'] if name in employee_dict: employee_dict[name][\'position\'] = promotion[\'new_position\'] employee_dict[name][\'salary\'] = promotion[\'new_salary\'] # Convert back to list before returning return list(employee_dict.values())"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to efficiently manipulate and transform data structures, specifically a linked list. **Background**: Linked lists are fundamental data structures in computer science and are used to implement other dynamic data structures such as stacks, queues, and more elaborate data structures. The code snippet provided defines a singly linked list, and your task involves reversing the linked list and then checking if the reversed list is a palindrome. **Task**: 1. **Function Implementation**: - Implement a class `ListNode` representing a node in a singly linked list. - Implement a function called `reverse_and_check_palindrome` that: - Accepts the head of a singly linked list. - Returns `True` if the reversed linked list is a palindrome, `False` otherwise. 2. **Steps to Follow**: - Reverse the linked list. - Check if the reversed list forms a palindrome. 3. **Edge Cases**: Handle possible edge cases such as: - An empty linked list. - A linked list with a single node. - A linked list with an even or odd number of nodes. **ListNode Definition**: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Input/Output**: - Input: `reverse_and_check_palindrome(head: ListNode) -> bool` - `head`: A ListNode representing the head of the singly linked list. - Output: Returns `True` if the reversed list forms a palindrome, `False` otherwise. **Constraints**: - The number of nodes in the linked list is in the range [0, 10^5]. - `0 <= Node.val <= 9`. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_and_check_palindrome(head: ListNode) -> bool: pass # Example Usage # Linked list: 1 -> 2 -> 2 -> 1 node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(2) node4 = ListNode(1) node1.next = node2 node2.next = node3 node3.next = node4 assert reverse_and_check_palindrome(node1) == True # Linked list: 1 -> 2 node1 = ListNode(1) node2 = ListNode(2) node1.next = node2 assert reverse_and_check_palindrome(node1) == False # Ensure your solution handles different edge cases efficiently. ``` Provide a well-commented and efficient solution to this problem.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_and_check_palindrome(head: ListNode) -> bool: # Function to reverse the linked list def reverse(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev if head is None: return True # Find the middle of the linked list slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list second_half_start = reverse(slow) # Compare the first half and the reversed second half first_half_start = head while second_half_start: if first_half_start.val != second_half_start.val: return False first_half_start = first_half_start.next second_half_start = second_half_start.next return True"},{"question":"# Online Auction System You have been assigned the task of creating an online auction system. In this system, there are multiple items each with a unique item ID, and users can place bids on these items. You need to implement functionalities for placing bids and determining the highest bid for each item. Implement the following functions: Function 1: `place_bid(bids: Dict[int, List[Tuple[int, int]]], user_id: int, item_id: int, bid_amount: int) -> Dict[int, List[Tuple[int, int]]]` This function records a new bid for an item. If the user has already placed a bid on the same item, update their bid amount to the new bid. Each bid is represented as a tuple of user ID and bid amount. The function should return the updated dictionary of bids. * **Input**: * `bids`: A dictionary where the key is the item ID and the value is a list of tuples representing the bids for that item. * `user_id`: An integer representing the ID of the user placing the bid. * `item_id`: An integer representing the ID of the item being bid on. * `bid_amount`: An integer representing the bid amount. * **Output**: * The updated dictionary of bids. * **Constraints**: * 1 <= user_id, item_id <= 1000 * 1 <= bid_amount <= 100000 Function 2: `highest_bid(bids: Dict[int, List[Tuple[int, int]]], item_id: int) -> Tuple[int, int]` This function returns the highest bid for a given item. If there are no bids on the item, return (-1, -1). * **Input**: * `bids`: A dictionary where the key is the item ID and the value is a list of tuples representing the bids for that item. * `item_id`: An integer representing the ID of the item. * **Output**: * A tuple representing the highest bid, where the first element is the user ID and the second element is the bid amount. * **Constraints**: * 1 <= item_id <= 1000 Example ```python # Placing bids bids = {} bids = place_bid(bids, 1, 100, 500) bids = place_bid(bids, 2, 100, 600) bids = place_bid(bids, 1, 101, 700) bids = place_bid(bids, 1, 100, 650) # Bids dictionary after placing bids # Expected output: {100: [(2, 600), (1, 650)], 101: [(1, 700)]} # Getting the highest bid highest_bid_100 = highest_bid(bids, 100) # Expected output: (1, 650) highest_bid_101 = highest_bid(bids, 101) # Expected output: (1, 700) # Getting the highest bid for an item with no bids highest_bid_102 = highest_bid(bids, 102) # Expected output: (-1, -1) ``` Make sure your solution handles edge cases, such as multiple users bidding on the same item and users placing multiple bids on different items. Ensure the solution is efficient and clear.","solution":"def place_bid(bids, user_id, item_id, bid_amount): Records a new bid for an item. If the user has already placed a bid on the same item, update their bid amount to the new bid. Returns the updated dictionary of bids. :param bids: dict where the key is the item ID and the value is a list of tuples representing the bids for that item :param user_id: int representing the ID of the user placing the bid :param item_id: int representing the ID of the item being bid on :param bid_amount: int representing the bid amount :return: Updated dictionary of bids if item_id not in bids: bids[item_id] = [] updated = False for idx, (exist_user_id, exist_bid_amount) in enumerate(bids[item_id]): if exist_user_id == user_id: bids[item_id][idx] = (user_id, bid_amount) updated = True break if not updated: bids[item_id].append((user_id, bid_amount)) return bids def highest_bid(bids, item_id): Returns the highest bid for a given item. If there are no bids on the item, return (-1, -1). :param bids: dict where the key is the item ID and the value is a list of tuples representing the bids for that item :param item_id: int representing the ID of the item :return: Tuple representing the highest bid (user_id, bid_amount) if item_id not in bids or not bids[item_id]: return (-1, -1) highest = max(bids[item_id], key=lambda x: x[1]) return highest"},{"question":"# Task: Implement a Function to Sort Even and Odd Numbers Separately Context You are working on a data processing system that requires categorizing and sorting numerical data. The requirement is to separate the even and odd numbers into two different lists and then sort each list individually before combining them back together. This will help in further analyzing data patterns for different categories. Objective Write a function `sort_even_odd` that receives a list of integers, separates the even and odd numbers, sorts each of them in ascending order, and then combines them so that the evens come first, followed by the odd numbers. # Function Signature ```python def sort_even_odd(numbers: list[int]) -> list[int]: pass ``` # Input * **numbers** (list[int]): A list of integers which may include both positive and negative integers as well as zeros. # Output * **list[int]**: A new list where the even numbers are sorted in ascending order followed by the odd numbers sorted in ascending order. # Constraints * The length of the input list will be in the range [1, 1000]. * The integers in the list can range from -10000 to 10000. # Example Scenarios Example 1 * **Input**: [3, 1, 2, 4] * **Output**: [2, 4, 1, 3] * **Explanation**: The evens (2, 4) are sorted and placed first, followed by the sorted odds (1, 3). Example 2 * **Input**: [6, 5, 8, 7, 1, 2] * **Output**: [2, 6, 8, 1, 5, 7] * **Explanation**: The evens (2, 6, 8) are sorted and placed first, followed by the sorted odds (1, 5, 7). Example 3 * **Input**: [-1, -2, -3, -4, 0] * **Output**: [-4, -2, 0, -3, -1] * **Explanation**: The evens (-4, -2, 0) are sorted and placed first, followed by the sorted odds (-3, -1). # Performance Requirements * The function should operate efficiently, ideally in O(n log n) time complexity for full list sorting processes. # Points to Consider * Consider cases with negative numbers and zero. * Ensure the function handles lists with only even numbers, only odd numbers, or a combination of both.","solution":"def sort_even_odd(numbers: list[int]) -> list[int]: evens = sorted([x for x in numbers if x % 2 == 0]) odds = sorted([x for x in numbers if x % 2 != 0]) return evens + odds"},{"question":"# Question: Prime Sum Finder Given a range of integers defined by a lower bound `a` and an upper bound `b`, identify all prime numbers within this range and return their sum. A prime number is a natural number greater than 1 that cannot be formed by multiplying two smaller natural numbers. The provided solution should be optimized to handle large ranges efficiently. **Task**: Write an optimized Python function that computes the sum of all prime numbers within a given range `[a, b]` using an efficient prime-checking algorithm. Input: - Two integers `a` and `b` where `1 <= a <= b <= 10^7`. Output: - An integer representing the sum of all prime numbers between `a` and `b` inclusive. Function Signature: ```python def prime_sum_between(a: int, b: int) -> int: pass ``` Constraints: - Utilize efficient algorithms like the Sieve of Eratosthenes to identify primes. - Ensure your solution handles large ranges within the given constraints efficiently. - Avoid using brute-force methods that iterate through every number in the range. Example: ```python >>> prime_sum_between(1, 10) 17 >>> prime_sum_between(11, 20) 60 ``` **Hint**: Consider precomputing primes up to `b` using the Sieve of Eratosthenes, and then sum only those that fall within the range `[a, b]`.","solution":"def prime_sum_between(a: int, b: int) -> int: Returns the sum of all prime numbers in the range [a, b] inclusive. if a > b: return 0 # Sieve of Eratosthenes to find all primes up to b sieve = [True] * (b + 1) sieve[0], sieve[1] = False, False for start in range(2, int(b ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, b + 1, start): sieve[multiple] = False # Sum up all primes in the range [a, b] prime_sum = sum(i for i in range(a, b + 1) if sieve[i]) return prime_sum"},{"question":"# Problem: Optimizing Image Processing Pipeline Scenario You have been tasked with optimizing an existing image processing pipeline. The current implementation suffers from inefficiencies due to sequential processing and redundant I/O operations. Your goal is to enhance the pipeline using batch processing and parallel execution to significantly reduce the overall processing time. # Problem Statement Write a Python function `optimize_image_pipeline(file_paths, output_dir, batch_size, num_threads)` that optimizes the image processing pipeline. The function should read images in batches, process them in parallel, and save the processed images to the specified output directory. Requirements: 1. **Input**: - `file_paths`: a list of strings, where each string represents the path to an image file to be processed. - `output_dir`: a string representing the directory where processed images will be saved. - `batch_size`: an integer specifying the number of images to process in each batch. - `num_threads`: an integer representing the number of threads to use for parallel processing. 2. **Output**: - The function should save the processed images in the specified `output_dir` with the same filenames as the input images. 3. **Constraints**: - Ensure that the processing pipeline handles images in batches of size `batch_size`. - Use Python\'s `threading` or `concurrent.futures` modules to process images in parallel. - Minimize redundant I/O operations by reading and writing images in batches. 4. **Performance**: - Optimize the implementation to maximize CPU utilization and minimize I/O wait times. # Example: ```python optimize_image_pipeline( [\\"image1.jpg\\", \\"image2.png\\", \\"image3.bmp\\"], \\"output_directory/\\", batch_size=2, num_threads=4 ) ``` This call should process the images in batches of 2 using 4 threads and save the processed images to the `output_directory`. # Additional Notes: - Handle edge cases such as invalid file paths or inaccessible output directory. - Ensure that exceptions during image processing do not halt the entire pipeline. - Take advantage of any image processing libraries such as PIL/Pillow for reading, processing, and saving images. - Implement proper logging to monitor the progress and status of the pipeline.","solution":"import os from PIL import Image from concurrent.futures import ThreadPoolExecutor def process_image(image_path): Dummy image processing function. Replace with actual processing code. # Open an image file with Image.open(image_path) as img: # Perform some operations (example: convert to grayscale) processed_img = img.convert(\'L\') return processed_img def save_image(image, output_path): Save the processed image to the specified output path. image.save(output_path) def process_batch(batch, output_dir): Processes a batch of images and saves the processed images to the output directory. for image_path in batch: try: processed_img = process_image(image_path) output_path = os.path.join(output_dir, os.path.basename(image_path)) save_image(processed_img, output_path) except Exception as e: print(f\\"Error processing image {image_path}: {e}\\") def optimize_image_pipeline(file_paths, output_dir, batch_size, num_threads): Optimizes the image processing pipeline by using batching and parallel execution. os.makedirs(output_dir, exist_ok=True) with ThreadPoolExecutor(max_workers=num_threads) as executor: # Divide the file paths into batches for i in range(0, len(file_paths), batch_size): batch = file_paths[i:i+batch_size] executor.submit(process_batch, batch, output_dir)"},{"question":"# Problem Description You are given a matrix of integers and your task is to implement a function that calculates the sum of the elements in the matrix after removing the maximum and minimum elements from each row. If a row contains only one or zero elements after removal, consider the remaining elements as zero for that row. # Function Signature ```python def sum_after_removal(matrix: List[List[int]]) -> int: Sums up the elements in the matrix after removing the maximum and minimum values from each row. Parameters: - matrix: List[List[int]] A 2D list (matrix) where each sublist represents a row of integers. Returns: - int: The sum of the elements in the matrix after removing the maximum and minimum values in each row. ``` # Example ```python >>> sum_after_removal([[10, 20, 30], [5, 15, 25], [1, 2, 3, 4]]) 27 # Explanation: # First row: [20] (10 and 30 removed) # Second row: [15] (5 and 25 removed) # Third row: [2, 3] (1 and 4 removed) # Sum: 20 + 15 + 2 + 3 = 40 >>> sum_after_removal([[7, 8], [1, -1, 4], [4]]) 0 # Explanation: # First row: [] (7 and 8 removed, remaining elements are considered as zero) # Second row: [1] (4 and -1 removed) # Third row: [] (remaining element is considered as zero) # Sum: 0 + 1 + 0 = 0 ``` # Requirements 1. Iterate through each row of the matrix. 2. Remove the maximum and minimum elements from each row. 3. If a row has one or no elements remaining after removal, consider the remaining elements for that row as zero. 4. Calculate the sum of all the remaining elements in the matrix. # Constraints - The matrix can have dimensions ranging from (1 times 1) to (10^3 times 10^3). - Each integer in the matrix can range from (-10^5) to (10^5).","solution":"from typing import List def sum_after_removal(matrix: List[List[int]]) -> int: total_sum = 0 for row in matrix: if len(row) > 2: max_val = max(row) min_val = min(row) filtered_row = [x for x in row if x != max_val and x != min_val] # In case max and min are the same and removed completely if len(filtered_row) == 0: filtered_row = [0] elif len(row) == 2: # If row has exactly two elements, both are removed filtered_row = [0] elif len(row) == 1: # If row has exactly one element, it is considered zero after removal filtered_row = [0] else: # If the row is empty filtered_row = [0] total_sum += sum(filtered_row) return total_sum"},{"question":"# Problem Statement: You are provided with an implementation of a binary search tree (BST). You need to extend the BST class with the following functionalities: 1. **in_order_traversal()**: Implement a method to perform in-order traversal of the BST. The method should return a list of nodes in ascending order. 2. **find_kth_smallest(k)**: Implement a method to find the k-th smallest element in the BST. If `k` is greater than the number of nodes in the tree, return `None`. # Expected Input and Output Formats: * For `in_order_traversal()`: The method returns a list of integers representing the in-order traversal of the BST. * For `find_kth_smallest(k)`: * **Input**: * `k` (int): The position (1-based index) of the smallest element to find. * **Output**: * Returns an integer representing the k-th smallest element in the BST, or `None` if `k` is greater than the number of nodes. # Constraints: 1. Assume the tree nodes contain unique integer values. 2. The number of nodes in the tree can be up to `N = 10^4`. # Example: ```python bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.in_order_traversal()) # [2, 3, 4, 5, 6, 7, 8] print(bst.find_kth_smallest(3)) # 4 print(bst.find_kth_smallest(10)) # None ``` # Solution Template: You may start with the provided code snippet and extend the class as described in the task. ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current, key): if key < current.val: if current.left: self._insert(current.left, key) else: current.left = Node(key) else: if current.right: self._insert(current.right, key) else: current.right = Node(key) def in_order_traversal(self): # Perform in-order traversal and return a list of node values pass def find_kth_smallest(self, k): # Find and return the k-th smallest element in the BST pass ``` ```python # You can run your tests here bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.in_order_traversal()) # Expected: [2, 3, 4, 5, 6, 7, 8] print(bst.find_kth_smallest(3)) # Expected: 4 print(bst.find_kth_smallest(10)) # Expected: None ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, current, key): if key < current.val: if current.left: self._insert(current.left, key) else: current.left = Node(key) else: if current.right: self._insert(current.right, key) else: current.right = Node(key) def in_order_traversal(self): result = [] self._in_order_traversal_helper(self.root, result) return result def _in_order_traversal_helper(self, node, result): if not node: return self._in_order_traversal_helper(node.left, result) result.append(node.val) self._in_order_traversal_helper(node.right, result) def find_kth_smallest(self, k): traversal = self.in_order_traversal() if k <= 0 or k > len(traversal): return None return traversal[k - 1]"},{"question":"# Dictionary Word Count Objective Write a function that counts the occurrence of each word in a given list and returns a dictionary where the keys are the words and the values are their respective counts. Function Signature ```python def word_count(words: list) -> dict: ``` Input * `words` (list): A list of strings representing the words to count. Output * A dictionary where each key is a word from the input list, and the corresponding value is the count of that word\'s occurrences. Constraints * The input list will contain only strings. * Words inside the list are case-insensitive and should be counted in a case-insensitive manner. # Examples ```python >>> word_count([\\"apple\\", \\"banana\\", \\"Apple\\", \\"banana\\", \\"Cherry\\", \\"cherry\\", \\"cherry\\"]) {\\"apple\\": 2, \\"banana\\": 2, \\"cherry\\": 3} >>> word_count([\\"Test\\", \\"test\\", \\"TEST\\"]) {\\"test\\": 3} >>> word_count([\\"unique\\", \\"words\\", \\"only\\"]) {\\"unique\\": 1, \\"words\\": 1, \\"only\\": 1} >>> word_count([]) {} ``` # Requirements 1. The function should handle words in a case-insensitive manner, meaning \\"Apple\\" and \\"apple\\" should be considered the same word. 2. Performance should be handled efficiently for typical use cases, with input lists containing up to several thousand elements. # Hints - Use a dictionary to keep track of word counts. - Convert all words to lowercase to ensure case insensitivity. - Iterate through the list and update the dictionary with word counts.","solution":"def word_count(words: list) -> dict: Returns a dictionary with the count of each word in the input list, case-insensitive. count_dict = {} for word in words: lower_word = word.lower() if lower_word in count_dict: count_dict[lower_word] += 1 else: count_dict[lower_word] = 1 return count_dict"},{"question":"# Binary Tree Traversal Given a partially implemented binary tree as demonstrated in the provided code snippet, complete the following tasks to showcase your comprehension of this data structure. Implement the requested methods and ensure they work as expected within the binary tree. Task 1: Inorder Traversal Implement a method `inorder_traversal()` in the `BinaryTree` class that performs an inorder traversal and prints the value of each node in the tree. ```python def inorder_traversal(self) -> None: This function prints the values of the nodes in the binary tree using an inorder traversal. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.inorder_traversal() 1 2 3 4 5 ``` Task 2: Height of Tree Implement a method `tree_height()` in the `BinaryTree` class that calculates and returns the height of the tree. The height of a tree is the number of edges on the longest path from the root to a leaf node. ```python def tree_height(self) -> int: This function returns the height of the binary tree. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.tree_height() 2 ``` Task 3: Check Balanced Tree Implement a method `is_balanced()` in the `BinaryTree` class that determines if the tree is height-balanced. A binary tree is height-balanced if, for every node in the tree, the height difference of its left and right subtrees is at most 1. ```python def is_balanced(self) -> bool: This function checks if the binary tree is height-balanced. Returns True if the tree is balanced, False otherwise. >>> bt = BinaryTree() >>> bt.insert(4) >>> bt.insert(2) >>> bt.insert(5) >>> bt.insert(1) >>> bt.insert(3) >>> bt.is_balanced() True >>> bt.insert(6) >>> bt.is_balanced() True >>> bt.insert(0) >>> bt.is_balanced() False ``` Input and Output * **Input**: * For inorder_traversal(): No input arguments. * For tree_height(): No input arguments. * For is_balanced(): No input arguments. * **Output**: * For inorder_traversal(): Prints the values of nodes in inorder sequence. * For tree_height(): Returns an integer representing the height of the tree. * For is_balanced(): Returns a boolean indicating whether the tree is balanced. Ensure correctness and efficiency in your implementations. Consider edge cases like empty trees, trees with one node, and balanced/unbalanced trees.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = Node(value) else: self._insert(self.root, value) def _insert(self, node, value): if value < node.value: if node.left is None: node.left = Node(value) else: self._insert(node.left, value) else: if node.right is None: node.right = Node(value) else: self._insert(node.right, value) def inorder_traversal(self): def _inorder_traversal(node): if node: _inorder_traversal(node.left) print(node.value, end=\' \') _inorder_traversal(node.right) _inorder_traversal(self.root) print() def tree_height(self): def _tree_height(node): if node is None: return 0 left_height = _tree_height(node.left) right_height = _tree_height(node.right) return max(left_height, right_height) + 1 return _tree_height(self.root) - 1 def is_balanced(self): def _check_balance(node): if node is None: return 0, True left_height, left_balanced = _check_balance(node.left) right_height, right_balanced = _check_balance(node.right) current_height = max(left_height, right_height) + 1 current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced height, balanced = _check_balance(self.root) return balanced"},{"question":"# Problem Statement **Scenario**: You are organizing a charity marathon and need to process the registration records. Each participant submits their registration with a name and the timestamp of their registration. Due to the large number of participants, you need an efficient way to retrieve the list of participants who registered within a given time range. Your task is to implement a function that reads the participant registration records, stores them efficiently, and then allows querying the registration list by a given start and end time. # Task Implement a class `MarathonRegistration` with the following methods: 1. `register_participant(name: str, timestamp: int) -> None`: Registers a participant with a given name and registration timestamp. 2. `get_participants(start_time: int, end_time: int) -> List[str]`: Returns a list of participant names who registered within the specified time range, inclusive of the start and end times. # Requirements * Participants\' names are unique strings. * Registration timestamps are unique integers. * The time range for the query is inclusive. * Handle invalid input cases (e.g., end_time < start_time). * Ensure the solution is efficient for a large number of registrations and queries. # Class Signature ```python class MarathonRegistration: def __init__(self): Initialize the registration system. def register_participant(self, name: str, timestamp: int) -> None: Register a participant. Args: name (str): The name of the participant. timestamp (int): The registration timestamp. def get_participants(self, start_time: int, end_time: int) -> List[str]: Retrieve the list of participants registered within the time range. Args: start_time (int): The start of the time range. end_time (int): The end of the time range. Returns: List[str]: A list of names of the participants who registered within the time range. ``` # Constraints * Participant names are strings with a length of 1 to 100 characters. * Timestamps are integers from `0` to `10^9`. * The number of registrations and queries can be up to `10^6`. # Example ```python # Example usage: marathon = MarathonRegistration() marathon.register_participant(\\"Alice\\", 1598576321) marathon.register_participant(\\"Bob\\", 1598576325) marathon.register_participant(\\"Charlie\\", 1598576330) assert marathon.get_participants(1598576320, 1598576325) == [\\"Alice\\", \\"Bob\\"] assert marathon.get_participants(1598576326, 1598576330) == [\\"Charlie\\"] assert marathon.get_participants(1598576331, 1598576340) == [] ``` # Explanation - **Example 1**: By registering Alice, Bob, and Charlie with their respective timestamps, the queries retrieve the list of participants who registered within the specified time ranges. - **Example 2**: The second query returns an empty list as no one registered in that time frame. **Note**: Ensure your implementation is optimized to handle up to one million registrations and queries efficiently.","solution":"from bisect import bisect_left, bisect_right from typing import List class MarathonRegistration: def __init__(self): Initialize the registration system. self.participants = [] def register_participant(self, name: str, timestamp: int) -> None: Register a participant. Args: name (str): The name of the participant. timestamp (int): The registration timestamp. self.participants.append((timestamp, name)) self.participants.sort() def get_participants(self, start_time: int, end_time: int) -> List[str]: Retrieve the list of participants registered within the time range. Args: start_time (int): The start of the time range. end_time (int): The end of the time range. Returns: List[str]: A list of names of the participants who registered within the time range. if start_time > end_time: return [] left_index = bisect_left(self.participants, (start_time, \\"\\")) right_index = bisect_right(self.participants, (end_time, \\"{\\")) return [name for _, name in self.participants[left_index:right_index]]"},{"question":"# Coding Assessment Question Scenario You have joined a software development team that is building a search functionality for an e-commerce platform. One of the challenges they face is efficiently merging and sorting the results from multiple data sources. These sources return sorted lists of product IDs which must be combined into a single sorted list without duplicates. Task Write a function `merge_and_sort_unique` that takes a list of sorted lists containing product IDs, merges them into a single list, and removes any duplicates while maintaining the sorted order. # Function Signature ```python def merge_and_sort_unique(lists: list[list[int]]) -> list[int]: pass ``` # Input * `lists`: A list of sorted lists of integers, `lists` (0 ≤ len(lists) ≤ 1000). # Output * A new list of unique integers sorted in ascending order. # Constraints * All elements within each sublist are sorted in ascending order and are unique. * The function should have an average-case time complexity of O(n log k), where n is the total number of elements across all lists and k is the number of lists. * Aim to minimize auxiliary space usage. # Example ```python assert merge_and_sort_unique([[1, 3, 5], [2, 3, 4], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6] assert merge_and_sort_unique([[], [], []]) == [] assert merge_and_sort_unique([[10], [10, 20], [5, 15, 25]]) == [5, 10, 15, 20, 25] assert merge_and_sort_unique([[1, 2, 3], [4, 5], [6]]) == [1, 2, 3, 4, 5, 6] ``` # Notes * Your implementation should handle edge cases such as empty lists and lists with overlapping elements. * Aim to keep the solution efficient in terms of time complexity and space usage. * Write clean, readable code with appropriate comments.","solution":"from heapq import merge def merge_and_sort_unique(lists): This function takes a list of sorted lists of integers and returns a single sorted list of unique integers. Params: lists (list of lists): A list containing sorted lists of integers. Returns: list: A sorted list of unique integers. merged = merge(*lists) unique_sorted_list = [] previous_value = None for value in merged: if value != previous_value: unique_sorted_list.append(value) previous_value = value return unique_sorted_list"},{"question":"# Task In a database system, you may need to analyze query performance and optimize the way queries handle large datasets. Your task is to implement an efficient algorithm to find the median of a list of numbers using two heaps. # Problem Statement Given a stream of integers, design an algorithm to find the median of the current list of numbers after each insertion. Use a max-heap and a min-heap to maintain the lower and higher halves of the numbers, respectively. Input * An integer `q` representing the number of queries. * An array of integers where each integer `x` in the array represents a new number to be inserted into the list. Output * An array of float numbers where each number represents the median after each insertion. Constraints * `1 <= q <= 10^5` * Each number in the input array is a positive integer and fits within the range 1 to 10^9. Example ```plaintext Input: 5 5 15 1 3 2 Output: [5, 10, 5, 4, 3] ``` # Explanation - After inserting 5, the list is [5], and the median is 5. - After inserting 15, the list is [5, 15], and the median is 10. - After inserting 1, the list is [1, 5, 15], and the median is 5. - After inserting 3, the list is [1, 3, 5, 15], and the median is 4. - After inserting 2, the list is [1, 2, 3, 5, 15], and the median is 3. # Instructions * Implement the function `find_median(q: int, numbers: list[int]) -> list[float]`. * Ensure the implementation efficiently maintains the heaps and calculates the median after each insertion. * Use Python’s `heapq` library to manage the heaps. # Notes * A max-heap for the lower half can be simulated by using Python\'s `heapq` with negative values because `heapq` only provides a min-heap. * Be mindful of balancing the heaps after each insertion to ensure the size property is maintained.","solution":"import heapq def find_median(q, numbers): min_heap = [] # Right side heap: stores the larger half of numbers max_heap = [] # Left side heap: stores the smaller half of numbers (in negative) medians = [] for number in numbers: if not max_heap or number <= -max_heap[0]: heapq.heappush(max_heap, -number) else: heapq.heappush(min_heap, number) if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) if len(max_heap) == len(min_heap): median = (-max_heap[0] + min_heap[0]) / 2 else: median = -max_heap[0] medians.append(median) return medians"},{"question":"# Coding Assessment Question You are given two lists of integers, `a` and `b`, where both lists are sorted in non-decreasing order. Write a function `find_common_elements(a: List[int], b: List[int]) -> List[int]` that returns a list of the common elements between `a` and `b`. Ensure your solution has a time complexity of O(n+m), where n is the length of list `a` and m is the length of list `b`. # Input - `a`: A list of integers sorted in non-decreasing order. - `b`: A list of integers sorted in non-decreasing order. # Output - A list of integers representing the common elements between the two input lists in non-decreasing order. # Constraints - The length of each list can be up to 100,000. - The integers in the lists will be between -10^5 and 10^5. # Example ```python a1 = [1, 2, 4, 5, 6] b1 = [2, 3, 5, 7] print(find_common_elements(a1, b1)) # Output: [2, 5] a2 = [1, 3, 4, 6, 7, 9] b2 = [3, 5, 7, 8, 9] print(find_common_elements(a2, b2)) # Output: [3, 7, 9] a3 = [2, 4, 6, 8, 10] b3 = [1, 5, 9] print(find_common_elements(a3, b3)) # Output: [] a4 = [-5, -3, 0, 1, 2, 3] b4 = [-5, -3, -1, 1, 3, 5] print(find_common_elements(a4, b4)) # Output: [-5, -3, 1, 3] ``` # Skeleton Here is the skeleton of the function you need to implement: ```python from typing import List def find_common_elements(a: List[int], b: List[int]) -> List[int]: # Your implementation here pass def test_find_common_elements(): # Your test cases here pass if __name__ == \\"__main__\\": test_find_common_elements() ``` # Explanation Implement the function `find_common_elements` that efficiently finds the common elements between two sorted lists. The function should iterate through both lists by leveraging their sorted property to ensure a time complexity of O(n+m).","solution":"from typing import List def find_common_elements(a: List[int], b: List[int]) -> List[int]: Finds and returns the common elements between two sorted lists a and b. i, j = 0, 0 common_elements = [] while i < len(a) and j < len(b): if a[i] == b[j]: common_elements.append(a[i]) i += 1 j += 1 elif a[i] < b[j]: i += 1 else: j += 1 return common_elements"},{"question":"# Palindrome Check using Recursion You\'ve been approached to develop a solution to verify if a given string is a palindrome. A palindrome is a string that reads the same backward as forward. For example, \\"madam\\" and \\"racecar\\" are palindromes, whereas \\"hello\\" is not. Task: Write a function `is_palindrome(s: str) -> bool` that uses recursive logic to determine if the input string is a palindrome. **Parameters**: - `s` (str): The input string to be checked for being a palindrome. **Returns**: - `True` if the string is a palindrome. - `False` otherwise. Implementation Details: - Recursive logic should be used to check the palindrome property. - The function should handle both uppercase and lowercase letters as the same (case insensitive). - Ignore non-alphanumeric characters (e.g., punctuation, spaces) during the palindrome check. Constraints: - The maximum length of the input string will be 1000 characters. - Strings may be empty. - Non-alphanumeric characters should be ignored, but the internal order should be maintained. **Example**: ```python print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # prints True print(is_palindrome(\\"No \'x\' in Nixon\\")) # prints True print(is_palindrome(\\"Hello, World!\\")) # prints False ``` Performance Requirements: - Aim for O(n) time complexity where n is the length of the input string. - Use O(1) additional space complexity for the recursion (discounting input size). Remember to use a case-insensitive comparison, and ignore any characters that are not letters or numbers.","solution":"def is_palindrome(s: str) -> bool: Returns True if the given string s is a palindrome, otherwise False. The function is case insensitive and ignores non-alphanumeric characters. def clean_string(s: str) -> str: return \'\'.join(char.lower() for char in s if char.isalnum()) def check_palindrome(clean_s: str, left: int, right: int) -> bool: if left >= right: return True if clean_s[left] != clean_s[right]: return False return check_palindrome(clean_s, left + 1, right - 1) clean_s = clean_string(s) return check_palindrome(clean_s, 0, len(clean_s) - 1)"},{"question":"# Coding Assessment Question Design and implement a class called `Graph` that represents an undirected graph. The class should provide methods for adding vertices, adding edges, performing depth-first search (DFS), breadth-first search (BFS), and checking connectivity between nodes. The graph should be stored using an adjacency list. **Objective**: Implement the Graph class with the following specifications. # Graph Class Specifications: 1. **Constructor**: ```python def __init__(self) -> None ``` - Initializes an empty adjacency list. 2. **Methods**: - `add_vertex(self, vertex: Any) -> None`: Adds a vertex to the graph. - `add_edge(self, vertex1: Any, vertex2: Any) -> None`: Adds an undirected edge between `vertex1` and `vertex2`. - `dfs(self, start_vertex: Any) -> List[Any]`: Performs a depth-first search starting from `start_vertex` and returns a list of vertices in the order they are visited. - `bfs(self, start_vertex: Any) -> List[Any]`: Performs a breadth-first search starting from `start_vertex` and returns a list of vertices in the order they are visited. - `is_connected(self, vertex1: Any, vertex2: Any) -> bool`: Determines if there is a path between `vertex1` and `vertex2`. # Input and Output Formats: - Vertices are represented by any hashable type (e.g., integers, strings). - The adjacency list is stored as a dictionary. - Raise `ValueError` with descriptive messages for operations involving vertices that are not present in the graph. # Example Usage: ```python # Creating a graph graph = Graph() # Adding vertices graph.add_vertex(\\"A\\") graph.add_vertex(\\"B\\") graph.add_vertex(\\"C\\") graph.add_vertex(\\"D\\") # Adding edges graph.add_edge(\\"A\\", \\"B\\") graph.add_edge(\\"A\\", \\"C\\") graph.add_edge(\\"B\\", \\"D\\") # Performing searches dfs_order = graph.dfs(\\"A\\") bfs_order = graph.bfs(\\"A\\") # Checking connectivity connected = graph.is_connected(\\"A\\", \\"D\\") # Outputs print(dfs_order) # Possible output: [\'A\', \'B\', \'D\', \'C\'] print(bfs_order) # Possible output: [\'A\', \'B\', \'C\', \'D\'] print(connected) # Output: True ``` **Your task**: Implement the `Graph` class as per the above specifications.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, vertex1, vertex2): if vertex1 not in self.adjacency_list or vertex2 not in self.adjacency_list: raise ValueError(\\"One or both vertices not found in the graph.\\") self.adjacency_list[vertex1].append(vertex2) self.adjacency_list[vertex2].append(vertex1) def dfs(self, start_vertex): if start_vertex not in self.adjacency_list: raise ValueError(\\"The start vertex is not present in the graph.\\") visited = set() result = [] def _dfs(v): visited.add(v) result.append(v) for neighbor in self.adjacency_list[v]: if neighbor not in visited: _dfs(neighbor) _dfs(start_vertex) return result def bfs(self, start_vertex): if start_vertex not in self.adjacency_list: raise ValueError(\\"The start vertex is not present in the graph.\\") visited = set() result = [] queue = [start_vertex] visited.add(start_vertex) while queue: v = queue.pop(0) result.append(v) for neighbor in self.adjacency_list[v]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return result def is_connected(self, vertex1, vertex2): if vertex1 not in self.adjacency_list or vertex2 not in self.adjacency_list: raise ValueError(\\"One or both vertices not found in the graph.\\") def _dfs(v, visited): visited.add(v) for neighbor in self.adjacency_list[v]: if neighbor not in visited: _dfs(neighbor, visited) visited = set() _dfs(vertex1, visited) return vertex2 in visited"},{"question":"# Problem: Metric Conversion System Your task is to design a metric conversion system that provides functions to convert between various units of measurement. The goal is to develop functions for each of these conversions, ensuring proper input validation and accurate computation. Task Requirements: 1. **Function Signature**: - Implement functions that convert units between the following pairs: * Meters to Kilometers and vice versa * Grams to Kilograms and vice versa * Celsius to Fahrenheit and vice versa * Liters to Milliliters and vice versa * Kilobytes to Megabytes and vice versa - The function names should follow the format `convert_[source_unit]_to_[target_unit]` (e.g., `convert_meters_to_kilometers`). 2. **Input and Output**: - The conversion functions should accept `float` values and return the converted value as a `float`. - If invalid values are provided (e.g., negative for units that can\'t be negative, like absolute quantities), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All inputs must be non-negative floats (particularly for absolute quantities like length, mass, volume, and storage). 4. **Performance Requirements**: - Ensure that the functions run in constant time O(1) and use constant space O(1). Example Functions: 1. **Meters to Kilometers** ```python def convert_meters_to_kilometers(meters: float) -> float: if meters < 0: raise ValueError(\\"convert_meters_to_kilometers() only accepts non-negative values\\") return meters / 1000 ``` 2. **Kilobytes to Megabytes** ```python def convert_kilobytes_to_megabytes(kilobytes: float) -> float: if kilobytes < 0: raise ValueError(\\"convert_kilobytes_to_megabytes() only accepts non-negative values\\") return kilobytes / 1024 ``` 3. **Celsius to Fahrenheit** ```python def convert_celsius_to_fahrenheit(celsius: float) -> float: return (celsius * 9/5) + 32 ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct conversions. - Boundary inputs like zero. - Invalid inputs like negative dimensions raising appropriate errors. Provide at least one test example for each conversion function in the form of `assert` statements to validate their behavior. Examples: ```python assert convert_meters_to_kilometers(1000) == 1.0 assert convert_kilobytes_to_megabytes(2048) == 2.0 assert convert_celsius_to_fahrenheit(0) == 32.0 ```","solution":"def convert_meters_to_kilometers(meters: float) -> float: if meters < 0: raise ValueError(\\"convert_meters_to_kilometers() only accepts non-negative values\\") return meters / 1000 def convert_kilometers_to_meters(kilometers: float) -> float: if kilometers < 0: raise ValueError(\\"convert_kilometers_to_meters() only accepts non-negative values\\") return kilometers * 1000 def convert_grams_to_kilograms(grams: float) -> float: if grams < 0: raise ValueError(\\"convert_grams_to_kilograms() only accepts non-negative values\\") return grams / 1000 def convert_kilograms_to_grams(kilograms: float) -> float: if kilograms < 0: raise ValueError(\\"convert_kilograms_to_grams() only accepts non-negative values\\") return kilograms * 1000 def convert_celsius_to_fahrenheit(celsius: float) -> float: return (celsius * 9/5) + 32 def convert_fahrenheit_to_celsius(fahrenheit: float) -> float: return (fahrenheit - 32) * 5/9 def convert_liters_to_milliliters(liters: float) -> float: if liters < 0: raise ValueError(\\"convert_liters_to_milliliters() only accepts non-negative values\\") return liters * 1000 def convert_milliliters_to_liters(milliliters: float) -> float: if milliliters < 0: raise ValueError(\\"convert_milliliters_to_liters() only accepts non-negative values\\") return milliliters / 1000 def convert_kilobytes_to_megabytes(kilobytes: float) -> float: if kilobytes < 0: raise ValueError(\\"convert_kilobytes_to_megabytes() only accepts non-negative values\\") return kilobytes / 1024 def convert_megabytes_to_kilobytes(megabytes: float) -> float: if megabytes < 0: raise ValueError(\\"convert_megabytes_to_kilobytes() only accepts non-negative values\\") return megabytes * 1024"},{"question":"# Context You are working on a data analysis tool that processes large sets of numerical data. One of the core functionalities of this tool is to manage and manipulate statistical data distributions. # Problem Statement Write a Python class `Statistics` that supports the following functionalities: 1. **Initialization**: Should initialize with a list of numerical data points. 2. **Mean Calculation**: Implement a method to calculate the mean (average) of the data. 3. **Median Calculation**: Implement a method to calculate the median of the data. 4. **Variance Calculation**: Implement a method to calculate the variance of the data. 5. **Standard Deviation Calculation**: Implement a method to calculate the standard deviation of the data. 6. **String Representation**: A method to return a string representation showing a summary of the statistics. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases and error handling. # Implementation Details 1. **Initialization**: ```python class Statistics: def __init__(self, data: List[float]) -> None: ... ``` 2. **Mean Calculation**: ```python def mean(self) -> float: ... ``` 3. **Median Calculation**: ```python def median(self) -> float: ... ``` 4. **Variance Calculation**: ```python def variance(self) -> float: ... ``` 5. **Standard Deviation Calculation**: ```python def standard_deviation(self) -> float: ... ``` 6. **String Representation**: ```python def __str__(self) -> str: ... ``` # Constraints - The input data list is guaranteed to be non-empty. - Ensure that the implemented statistical methods handle typical edge cases, such as lists with a single element appropriately. # Unit Tests Create a test class `TestStatistics` using `unittest` that validates all aspects of your implementation. Address typical edge cases, such as ensuring computations are accurately handled for small datasets and precise calculations. # Example ```python data = [1, 2, 3, 4, 5] stats = Statistics(data) # Test Mean Calculation print(stats.mean()) # Should print the mean of the data. # Test Median Calculation print(stats.median()) # Should print the median of the data. # Test Variance Calculation print(stats.variance()) # Should print the variance of the data. # Test Standard Deviation Calculation print(stats.standard_deviation()) # Should print the standard deviation of the data. # Test String Representation print(str(stats)) # Should return a summary string. ```","solution":"import math from typing import List class Statistics: def __init__(self, data: List[float]) -> None: self.data = data def mean(self) -> float: return sum(self.data) / len(self.data) def median(self) -> float: sorted_data = sorted(self.data) n = len(self.data) mid = n // 2 if n % 2 == 0: return (sorted_data[mid - 1] + sorted_data[mid]) / 2.0 else: return sorted_data[mid] def variance(self) -> float: m = self.mean() return sum((x - m) ** 2 for x in self.data) / len(self.data) def standard_deviation(self) -> float: return math.sqrt(self.variance()) def __str__(self) -> str: return (f\\"Statistics Summary:n\\" f\\"Mean: {self.mean():.2f}n\\" f\\"Median: {self.median():.2f}n\\" f\\"Variance: {self.variance():.2f}n\\" f\\"Standard Deviation: {self.standard_deviation():.2f}\\")"},{"question":"# Matrix Rotation Checker Scenario: You are working on a data visualization project that involves displaying a series of image transformations. One common transformation is rotation. Your task is to determine if a given matrix `B` can be obtained by rotating another matrix `A` by 90, 180, or 270 degrees. Task: Implement the function `is_rotation_matrix(A: List[List[int]], B: List[List[int]]) -> bool`, which returns `True` if matrix `B` can be obtained by rotating matrix `A` by one of the allowed degrees (90, 180, 270). Otherwise, return `False`. Details: - Matrices `A` and `B` are both square matrices of size `n x n` (1 ≤ n ≤ 10). - Rotation is clockwise. Input: 1. **A (List[List[int]])**: Original matrix. 2. **B (List[List[int]])**: Matrix which may be a rotated version of `A`. Output: - **bool**: `True` if `B` can be obtained by rotating `A` by 90, 180, or 270 degrees, `False` otherwise. Examples: ```python # Example 1 A = [ [1, 2], [3, 4] ] B = [ [3, 1], [4, 2] ] # B can be obtained by rotating A 90 degrees clockwise print(is_rotation_matrix(A, B)) # Output: True # Example 2 A = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] B = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] # B can be obtained by rotating A 180 degrees clockwise print(is_rotation_matrix(A, B)) # Output: True # Example 3 A = [ [1, 2], [3, 4] ] B = [ [1, 2], [3, 4] ] # B is the same as A without rotation print(is_rotation_matrix(A, B)) # Output: False ``` Constraints: - Ensure your solution runs efficiently for `n` up to 10. Tips: 1. Implement a helper function to rotate the matrix by 90 degrees. 2. Compare matrix `B` with `A`, rotated once, twice, and three times to perform the check.","solution":"from typing import List def rotate_90(A: List[List[int]]) -> List[List[int]]: Rotates the matrix A by 90 degrees clockwise. n = len(A) return [[A[n - j - 1][i] for j in range(n)] for i in range(n)] def is_rotation_matrix(A: List[List[int]], B: List[List[int]]) -> bool: Returns True if matrix B is a rotation of matrix A by 90, 180, or 270 degrees. if A == B: return False rotated_90 = rotate_90(A) rotated_180 = rotate_90(rotated_90) rotated_270 = rotate_90(rotated_180) return B == rotated_90 or B == rotated_180 or B == rotated_270"},{"question":"# Scenario You are developing a file compression tool that utilizes a simple run-length encoding algorithm. Run-length encoding is a lossless data compression technique where consecutive elements of the same type are stored as a single element and a count. # Task Implement a function `compress_string` that takes a string as input and returns its run-length encoded representation. To ensure efficiency, the function should construct the compressed string directly from the input without using extra data structures for intermediate storage. # Function Signature ```python def compress_string(s: str) -> str: ``` # Input * `s`: A string of length `n` (1 ≤ n ≤ 10000), consisting of lowercase letters `a` to `z`. # Output * A run-length encoded string representing the input string. # Constraints * The function should be efficient in terms of both time and space complexity. # Example ```python compress_string(\\"aabcccccaaa\\") # Output: \\"a2b1c5a3\\" compress_string(\\"abc\\") # Output: \\"a1b1c1\\" compress_string(\\"aaabbbcccaaa\\") # Output: \\"a3b3c3a3\\" compress_string(\\"abca\\") # Output: \\"a1b1c1a1\\" ``` # Hints * Iterate through the string while keeping track of the current character and its count. * Build the output string incrementally to maintain efficiency.","solution":"def compress_string(s: str) -> str: Compresses a given string using run-length encoding. Parameters: s (str): The string to be compressed. Returns: str: The run-length encoded string. if not s: return \\"\\" compressed = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{prev_char}{count}\\") prev_char = char count = 1 # add the last run compressed.append(f\\"{prev_char}{count}\\") return \'\'.join(compressed)"},{"question":"# Coding Assessment Question Context You are designing a system that involves large datasets where efficient storage and quick lookup of unique values are crucial. One task involves removing duplicates from a dataset represented as a list while preserving the order of first occurrences. Objective Write a Python function called `remove_duplicates` that removes duplicate elements from a list while preserving the order of their first occurrences. Function Signature ```python def remove_duplicates(lst: list[int]) -> list[int]: pass ``` Input - A list of integers. The list can have a variable length. Output - A list of integers with duplicates removed, maintaining the order of their first occurrences. Constraints - The length of the list will not exceed 1000. - Integers in the list can range from (-10^6) to (10^6). Performance Requirements - The solution should handle large inputs efficiently. - Aim for an optimal time complexity to ensure fast processing. Example ```python >>> remove_duplicates([1, 2, 2, 3, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates([4, 5, 6, 7, 8, 8, 9, 10, 10, 10]) [4, 5, 6, 7, 8, 9, 10] >>> remove_duplicates([1, 1, 1, 1, 1]) [1] >>> remove_duplicates([]) [] >>> remove_duplicates([-1, -2, -3, -1, -2, -3]) [-1, -2, -3] ``` # Notes - The function should efficiently handle cases where there are many duplicates. - Assume the input list is properly formatted (no nested lists or non-integer elements). **Your task:** Implement `remove_duplicates` based on the above specifications.","solution":"def remove_duplicates(lst: list[int]) -> list[int]: Removes duplicate elements from the list while preserving the order of their first occurrences. Args: lst (list[int]): A list of integers. Returns: list[int]: A list with duplicates removed, maintaining the order of their first occurrences. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Problem Statement You are given a string representation of a mathematical expression that can contain integers, \'+\', \'-\', \'*\', \'/\', \'(\' and \')\'. The operators and the integers are separated by spaces. Your task is to evaluate the expression and return the result as an integer. The division should truncate towards zero. # Input - A single string `expression` containing the mathematical expression to be evaluated. # Output - An integer representing the evaluated result of the expression. # Constraints - The expression will always be a valid expression. - The integer operands and the evaluated result will fit in the range of a 32-bit signed integer. # Function Signature ```python def evaluate_expression(expression: str) -> int: pass ``` # Examples ```python >>> evaluate_expression(\\"3 + 2 * 2\\") 7 >>> evaluate_expression(\\"3 / 2\\") 1 >>> evaluate_expression(\\"3 + 5 / 2\\") 5 >>> evaluate_expression(\\"(1 + 2) * 3 - 4 / 2\\") 7 ``` **Note**: This question involves parsing arithmetic expressions with precedence rules, managing parentheses, and correctly implementing integer division truncation. Performance and precision should be handled appropriately to ensure accurate results across various test cases.","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operators, values): right = values.pop() left = values.pop() op = operators.pop() if op == \'+\': values.append(left + right) elif op == \'-\': values.append(left - right) elif op == \'*\': values.append(left * right) elif op == \'/\': values.append(int(left / right)) # Python division truncates towards zero by casting to int def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue elif expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_operator(operators, values) return values[-1]"},{"question":"**[Question 2]:** # Problem Statement You are required to write a function `find_smallest_missing_positive(arr: List[int]) -> int:` that finds the smallest positive integer missing from an unsorted list of integers. # Inputs - A single list of integers `arr` of size ( n ), where ( 1 leq n leq 10^6 ). # Outputs - An integer representing the smallest positive integer that is missing from the list. # Constraints & Performance - The list can have both negative and positive integers. - The list may contain duplicate values. - Time Complexity: Expected O(n) - Space Complexity: O(1) - You are allowed to modify the input list in-place. # Scenario for Context In a web application for tracking user tasks, each task can be associated with a unique positive integer ID. Your goal is to identify the smallest positive task ID that has not been assigned yet from a list of assigned task IDs. # Sample Tests **Input**: ```python assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert find_smallest_missing_positive([1, 2, 3, 4, 5]) == 6 ``` **Explanation**: - For the input ([1, 2, 0]), the smallest missing positive integer is 3. - For the input ([3, 4, -1, 1]), the smallest missing positive integer is 2. - For the input ([7, 8, 9, 11, 12]), the smallest missing positive integer is 1. - For the input ([1, 2, 3, 4, 5]), the smallest missing positive integer is 6.","solution":"from typing import List def find_smallest_missing_positive(arr: List[int]) -> int: n = len(arr) # Phase 1: Ensure all values are in the range [1, n] for i in range(n): if arr[i] <= 0 or arr[i] > n: arr[i] = n + 1 # Phase 2: Mark the presence of numbers for i in range(n): val = abs(arr[i]) if val <= n: arr[val - 1] = -abs(arr[val - 1]) # Phase 3: Find the first missing positive for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"# Task: Build a Personal Finance Tracker Scenario You are required to develop a personal finance tracking program that logs and categorizes transactions. The tool should allow users to input their transactions, categorize them, and provide summary reports of their spending in each category. Requirements 1. **Function Implementation**: Implement the function `track_transactions(transactions: List[Dict[str, str]]) -> Dict[str, float]` - **Input**: A list of transactions, where each transaction is represented as a dictionary with keys \\"date\\", \\"description\\", \\"amount\\", and \\"category\\". - **Output**: A dictionary summarizing total spending per category. Each key is a category name and each value is the total amount spent in that category. 2. **Constraints**: - Each transaction date should be in the format \'YYYY-MM-DD\'. - The \\"amount\\" value should be a float representing the expenditure amount. - The function should handle invalid input gracefully, such as missing keys or incorrect data types. - The function should ignore transactions with negative amounts. 3. **Performance Requirements**: - The function should be able to handle at least 1000 transactions efficiently. Example Usage ```python transactions = [ {\\"date\\": \\"2023-10-01\\", \\"description\\": \\"Grocery\\", \\"amount\\": \\"50.25\\", \\"category\\": \\"Food\\"}, {\\"date\\": \\"2023-10-02\\", \\"description\\": \\"Bus ticket\\", \\"amount\\": \\"2.50\\", \\"category\\": \\"Transport\\"}, # more transactions ] summary = track_transactions(transactions) print(summary) # Example output: {\'Food\': 50.25, \'Transport\': 2.50} ``` # Additional Considerations - Implement robust error handling and validate inputs. - Ensure the function is efficient and can handle large lists of transactions. - Implement unit tests to verify the function\'s correctness with different types of input data.","solution":"def track_transactions(transactions): Summarizes the total spending per category given a list of transactions. Args: transactions (list of dict): A list where each transaction is represented as a dictionary with keys \\"date\\", \\"description\\", \\"amount\\", and \\"category\\". Returns: dict: A dictionary where each key is a category and each value is the total amount spent in that category. summary = {} for transaction in transactions: try: # Extract and validate transaction details date = transaction.get(\'date\') description = transaction.get(\'description\') amount = float(transaction.get(\'amount\', 0)) category = transaction.get(\'category\') # Skip invalid transactions if not date or not description or not category or amount <= 0: continue # Update the summary dictionary if category in summary: summary[category] += amount else: summary[category] = amount except (ValueError, TypeError): # Skip transactions with invalid amount value or wrong data types continue return summary"},{"question":"# Fibonacci Prime Numbers Problem Statement A Fibonacci prime number is a Fibonacci number that is also a prime number. The sequence of Fibonacci numbers is defined by the recurrence relation: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n ≥ 2. Write a Python function that computes all Fibonacci prime numbers that do not exceed a given integer n. Return these Fibonacci prime numbers as a list in ascending order. Function Signature ```python def fibonacci_primes(n: int) -> list: pass ``` Input - An integer n (1 ≤ n ≤ 10^6) Output - A list of integers representing all Fibonacci primes that do not exceed the given integer n. Example ```python >>> fibonacci_primes(50) [2, 3, 5, 13] >>> fibonacci_primes(1000) [2, 3, 5, 13, 89, 233] >>> fibonacci_primes(10) [2, 3, 5] >>> fibonacci_primes(100) [2, 3, 5, 13, 89] >>> fibonacci_primes(1) [] ``` Constraints - Ensure your implementation is efficient enough to handle the upper limit of n within a reasonable time frame. - Your function should correctly identify prime numbers. Notes - Consider creating helper functions to generate Fibonacci numbers and to check for primality. - Optimize your solution to avoid redundant calculations and ensure efficiency. - Handle edge cases where there are no Fibonacci primes below n.","solution":"def fibonacci_primes(n: int) -> list: def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True fib_primes = [] a, b = 0, 1 while a <= n: if is_prime(a): fib_primes.append(a) a, b = b, a + b return fib_primes"},{"question":"# Question: Implement an Efficient K-Nearest Neighbors Search You are tasked with implementing an efficient k-nearest neighbors (k-NN) search function for a given set of points in a 2D space. Given a set of query points, the function should return the k nearest neighbors from the reference points for each query point. Requirements 1. **Function Name**: efficient_knn_search 2. **Input**: - A 2D array of reference points (numpy.ndarray) with shape (m, 2). - A 2D array of query points (numpy.ndarray) with shape (n, 2). - An integer k which specifies the number of nearest neighbors to find. 3. **Output**: A 2D array containing the indices of the k nearest neighbors from the reference points for each query point (numpy.ndarray) with shape (n, k). Constraints 1. Ensure the implementation is efficient in both time and space. 2. Use Euclidean distance as the metric for proximity. Example ```python >>> import numpy as np >>> reference_points = np.array([[1.0, 2.0], [3.0, 4.0], [4.0, 2.0], [5.0, 1.0], [0.0, 0.0]]) >>> query_points = np.array([[2.0, 3.0], [1.0, 1.0]]) >>> k = 2 >>> efficient_knn_search(reference_points, query_points, k) array([[0, 1], [0, 4]]) ``` Guidelines - Leverage numpy operations for vectorized computation to enhance performance. - Consider implementing with the help of efficient data structures like KD-tree or Ball-tree if needed. But for the context of the problem, efficient and direct numpy implementations are acceptable.","solution":"import numpy as np def efficient_knn_search(reference_points, query_points, k): Performs efficient k-nearest neighbors search. Args: - reference_points (numpy.ndarray): Array of shape (m, 2) representing the reference points. - query_points (numpy.ndarray): Array of shape (n, 2) representing the query points. - k (int): Number of nearest neighbors to find. Returns: - numpy.ndarray: A 2D array of shape (n, k) containing the indices of the k nearest neighbors. # Compute the distance matrix dist_matrix = np.sqrt(((query_points[:, np.newaxis, :] - reference_points[np.newaxis, :, :]) ** 2).sum(axis=2)) # Find the indices of the k nearest neighbors nearest_neighbors = np.argsort(dist_matrix, axis=1)[:, :k] return nearest_neighbors"},{"question":"# Problem Description: A company has implemented a queue data structure to manage tasks in the order they were added. However, they now need an additional feature to retrieve the current size of the queue without modifying its elements. **Task**: Implement a method `get_size` which returns the number of elements currently in the queue. ```python def get_size(self) -> int: Returns the number of elements in the queue. Time complexity: O(1) @returns: The number of elements currently in the queue. Example: >>> task_queue = Queue([1, 2, 3, 4]) >>> task_queue.get_size() 4 >>> task_queue.dequeue() 1 >>> task_queue.get_size() 3 ``` **Input**: - No input parameters **Output**: - An integer representing the number of elements in the queue. # Constraints: - All basic queue operations (enqueue, dequeue, etc.) must work properly. - The `get_size` method must return the current count of elements in the queue. - Proper handling of edge cases (e.g., empty queue). # Example Consider a sample usage below: ```python # Queue initialization q = Queue([5, 6, 7, 8]) # Getting size print(q.get_size()) # Output: 4 # Removing elements q.dequeue() # Removes the front element (5) print(q.get_size()) # Output: 3 # Adding elements q.enqueue(9) print(q.get_size()) # Output: 4 # When queue is empty q.dequeue() q.dequeue() q.dequeue() q.dequeue() print(q.get_size()) # Output: 0 ``` **Notes**: - Ensure the method efficiently retrieves the queue size with constant time complexity. - Handle both empty and populated queues effectively. - Maintain the overall integrity of the queue while implementing the size retrieval feature.","solution":"class Queue: def __init__(self, elements=None): if elements is None: self.elements = [] else: self.elements = list(elements) def enqueue(self, element): self.elements.append(element) def dequeue(self): if not self.is_empty(): return self.elements.pop(0) else: raise IndexError(\\"dequeue from an empty queue\\") def is_empty(self): return len(self.elements) == 0 def get_size(self): Returns the number of elements in the queue. Time complexity: O(1) @returns: The number of elements currently in the queue. return len(self.elements) # Example usage: # task_queue = Queue([1, 2, 3, 4]) # print(task_queue.get_size()) # Output: 4 # task_queue.dequeue() # print(task_queue.get_size()) # Output: 3"},{"question":"**Scenario**: You need to implement a function that determines if a given string is a permutation of a palindrome. This task will test your understanding of string manipulation and character frequency analysis. **Problem Statement**: Write a function `is_palindrome_permutation(s: str) -> bool` that checks whether any permutation of the input string `s` forms a palindrome. # Function Signature ```python def is_palindrome_permutation(s: str) -> bool: ``` # Input * `s` (1 <= len(s) <= 100): A string consisting of lowercase alphabetic characters and spaces. # Output * A boolean value indicating whether any permutation of the string can be rearranged to form a palindrome. # Constraints * Ignore spaces in the input string. * The function should have a time complexity of O(n), where n is the length of the string. # Example ```python >>> is_palindrome_permutation(\\"taco cat\\") True # \\"taco cat\\" can be rearranged to \\"atco cta\\", which is a palindrome. >>> is_palindrome_permutation(\\"racecar\\") True # \\"racecar\\" is already a palindrome. >>> is_palindrome_permutation(\\"palindrome\\") False # No permutation of \\"palindrome\\" forms a palindrome. >>> is_palindrome_permutation(\\"aabbccddeeff\\") True # Characters can be paired to form a palindrome like \\"abcdefgfedcba\\". >>> is_palindrome_permutation(\\"aabbcc\\") True # \\"aabbcc\\" can be rearranged into \\"abc cba\\", which is a palindrome. ``` # Note - A string is a permutation of a palindrome if at most one character has an odd count. - Consider edge cases where the string may already be a palindrome. - Ensure the function handles various inputs efficiently, even with mixed spaces.","solution":"def is_palindrome_permutation(s: str) -> bool: Checks if any permutation of the input string can form a palindrome. from collections import Counter # Remove spaces and lowercase all characters for uniformity cleaned_str = s.replace(\\" \\", \\"\\").lower() char_count = Counter(cleaned_str) # Count the number of characters with an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"# Coding Assessment Question **Problem Statement:** You are given the implementation of a `BookLibrary` class which maintains a collection of books. Each book is represented by a dictionary containing `title`, `author`, and `year` of publication. The class includes methods to add books, remove books, and search for books by various criteria. **Objective:** Write a function `manage_books` that takes a list of operations and performs them on an instance of `BookLibrary`. Each operation could be adding a book, removing a book by title, or searching for books by title or author. **Function Signature:** ```python def manage_books(operations: List[Tuple[str, Dict[str, str]]]) -> List[Dict[str, str]]: ``` **Input:** * `operations`: A list of tuples where each tuple contains: - A string indicating the operation type: `\\"add\\"`, `\\"remove\\"`, or `\\"search\\"`. - A dictionary representing the book details or search criteria. The dictionary will have keys: - For `\\"add\\"`: {\\"title\\": str, \\"author\\": str, \\"year\\": str} - For `\\"remove\\"`: {\\"title\\": str} - For `\\"search\\"`: {\\"criteria\\": str, \\"value\\": str} where `criteria` is either `\\"title\\"` or `\\"author\\"`. **Output:** * A list of dictionaries where each dictionary represents a book that matches the search criteria for `\\"search\\"` operations. For other operations, return an empty list. **Constraints:** * All operations are case-insensitive. * Search results should be returned in the order they were added to the library. * Any operation on an empty library should not cause errors. * Duplicate entries (books with the same title, author, and year) should not be allowed. **Example:** ```python operations = [ (\\"add\\", {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": \\"1925\\"}), (\\"add\\", {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": \\"1960\\"}), (\\"search\\", {\\"criteria\\": \\"author\\", \\"value\\": \\"F. Scott Fitzgerald\\"}), (\\"remove\\", {\\"title\\": \\"The Great Gatsby\\"}), (\\"search\\", {\\"criteria\\": \\"title\\", \\"value\\": \\"The Great Gatsby\\"}) ] result = manage_books(operations) print(result) # Output: [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": \\"1925\\"}, []] ``` **Requirements:** 1. Implement the function `manage_books` by leveraging the `BookLibrary` class methods. 2. Ensure proper handling of edge cases such as case sensitivity, duplicate entries, and operations on an empty library. 3. Thoroughly test the function with various inputs to cover different scenarios.","solution":"class BookLibrary: def __init__(self): self.books = [] def add_book(self, book): # Check for duplicates if not any(b[\'title\'].lower() == book[\'title\'].lower() for b in self.books): self.books.append(book) def remove_book(self, title): self.books = [book for book in self.books if book[\'title\'].lower() != title.lower()] def search_by_author(self, author): return [book for book in self.books if book[\'author\'].lower() == author.lower()] def search_by_title(self, title): return [book for book in self.books if book[\'title\'].lower() == title.lower()] def manage_books(operations): library = BookLibrary() results = [] for operation in operations: op_type = operation[0] details = operation[1] if op_type == \\"add\\": library.add_book(details) elif op_type == \\"remove\\": library.remove_book(details[\'title\']) elif op_type == \\"search\\": if details[\'criteria\'] == \'author\': results.append(library.search_by_author(details[\'value\'])) elif details[\'criteria\'] == \'title\': results.append(library.search_by_title(details[\'value\'])) return results"},{"question":"# Scenario You are developing a text processing tool that needs to simplify sentences by summarizing them into shorter versions. To achieve this, you\'ve decided to implement an algorithm that extracts the most important words from a sentence based on their frequency and position. # Task Implement a function that takes a sentence as input and returns a shortened version by selecting the most important words. Your algorithm should consider both the frequency of a word and its position in the sentence (i.e., words appearing earlier may be more important). # Function Signature ```python def summarize_sentence(sentence: str) -> str: pass ``` # Input * `sentence` (string): The input sentence to be summarized. # Output * A string representing the summarized sentence. # Constraints * The sentence will not exceed 200 characters. * The sentence will contain only lowercase alphabetic characters and spaces. * Words in the sentence are separated by a single space. * The function should preserve the order of words as they appear in the original sentence. # Performance Requirements * Must handle input sizes up to the maximum constraint efficiently (in terms of both time and space). # Examples ```python assert summarize_sentence(\\"the quick brown fox jumps over the lazy dog\\") == \\"the quick brown fox\\" assert summarize_sentence(\\"this is a test this test is only a test\\") == \\"this is a test only\\" assert summarize_sentence(\\"hello world hello universe\\") == \\"hello world\\" assert summarize_sentence(\\"a quick brown dog outpaces a quick fox\\") == \\"a quick brown dog\\" ``` Implement this algorithm in the function `summarize_sentence`.","solution":"from collections import Counter def summarize_sentence(sentence: str) -> str: Returns a summarized version of the input sentence by selecting the most important words based on their frequency and position. words = sentence.split() word_counts = Counter(words) summarized_words = [] seen_words = set() for word in words: if word not in seen_words: summarized_words.append(word) seen_words.add(word) return \\" \\".join(summarized_words)"},{"question":"**Problem Description**: You are asked to implement a function that determines if a given number is an \\"Armstrong number\\" or not. An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of digits. For example, the number 153 is an Armstrong number because: ``` 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153 ``` Your implementation should efficiently check if the provided integer satisfies this condition. **Function Signature**: ```python def is_armstrong_number(n: int) -> bool: Determines if the given number `n` is an Armstrong number. :param n: Integer, the number to check :return: Boolean, True if `n` is an Armstrong number, False otherwise ``` **Input and Output**: - **Input**: An integer `n` (1 ≤ n ≤ 10^8), representing the number to be checked. - **Output**: A boolean value, `True` if the number is an Armstrong number, `False` otherwise. **Constraints**: - The function should handle numbers up to 100,000,000 efficiently. **Example**: ```python assert is_armstrong_number(153) == True assert is_armstrong_number(9474) == True assert is_armstrong_number(123) == False ``` **Requirements**: - You should avoid unnecessary computations and ensure that your implementation is optimal for the given input constraints. - Do not use any external libraries. **Scenario**: You are developing a utility in a larger system to validate special numeric properties which are important for various mathematical analyses and cryptographic applications. An Armstrong number check is one of the commonly required functionalities. **Note**: Ensure your implementation is efficient and can handle the upper limits as described.","solution":"def is_armstrong_number(n: int) -> bool: Determines if the given number `n` is an Armstrong number. :param n: Integer, the number to check :return: Boolean, True if `n` is an Armstrong number, False otherwise digits = [int(d) for d in str(n)] num_digits = len(digits) sum_of_powers = sum(d ** num_digits for d in digits) return sum_of_powers == n"},{"question":"# Coding Assessment Question Scenario You are tasked with designing a function for a navigation system that frequently needs to normalize angles. An angle normalization function ensures that any provided angle is converted to an equivalent angle within a standard range, specifically from 0 to 360 degrees. This functionality is crucial for ensuring the system\'s calculations are consistent and reliable. Task Implement a Python function to normalize an angle so that it falls within the range [0, 360) degrees. Function Signature ```python def normalize_angle(angle: float) -> float: ``` Input - `angle`: A float representing an angle in degrees. The angle can be any real number, positive or negative. Output - A float representing the equivalent angle in the range [0, 360) degrees. Constraints - The input angle can be any real number, including extreme values. Example ```python assert normalize_angle(720) == 0.0 assert normalize_angle(-90) == 270.0 assert abs(normalize_angle(450) - 90.0) < 1e-7 assert abs(normalize_angle(1080) - 0.0) < 1e-7 assert abs(normalize_angle(-810) - 270.0) < 1e-7 ``` Note To normalize the angle, you may need to use modulo arithmetic and carefully handle negative values. Ensure that the returned angle is always within the specified range. Provide clear explanations for how your function performs the normalization to handle all cases effectively.","solution":"def normalize_angle(angle: float) -> float: Normalize an angle to be within the range [0, 360) degrees. Args: angle (float): A given angle in degrees, which can be any real number. Returns: float: The equivalent angle within the range [0, 360) degrees. # Use modulo to wrap the angle around 360 degrees normalized_angle = angle % 360 # If the result is negative, add 360 to get it within the [0, 360) range if normalized_angle < 0: normalized_angle += 360 return normalized_angle # Example usage of the function: print(normalize_angle(720)) # Output: 0.0 print(normalize_angle(-90)) # Output: 270.0 print(normalize_angle(450)) # Output: 90.0 print(normalize_angle(1080)) # Output: 0.0 print(normalize_angle(-810)) # Output: 270.0"},{"question":"# Problem Statement You are assisting in the development of a file management system that tracks file sizes and their access patterns. Your task is to write a function that calculates the total file size of a directory structure stored in a dictionary. The structure of the dictionary is as follows: - Each key is a file or folder name. - If the key is a file, the corresponding value is its size in bytes. - If the key is a folder, the corresponding value is a nested dictionary following the same pattern. # Task Design a function `total_file_size(directory: dict) -> int` that takes a dictionary representing the directory structure and returns the total size of all files in that structure. # Input - A dictionary `directory` where the keys are file or folder names and the values are either file sizes (integers) or nested dictionaries. # Output - An integer representing the total size in bytes of all files in the directory and its subdirectories. # Constraints - The directory structure will be non-empty. - The file sizes will be non-negative integers (`0 <= size <= 10^8`). - The depth of subdirectories will not exceed 10 levels. # Example ```python >>> directory = { ... \\"folder1\\": { ... \\"file1.txt\\": 1200, ... \\"file2.txt\\": 3000, ... \\"subfolder1\\": { ... \\"file3.txt\\": 1500 ... }, ... }, ... \\"file4.txt\\": 5000 ... } >>> total_file_size(directory) 10700 >>> directory = { ... \\"file1.txt\\": 1000, ... \\"file2.txt\\": 2000, ... \\"folder1\\": { ... \\"file3.txt\\": 3000, ... \\"subfolder1\\": { ... \\"file4.txt\\": 4000 ... } ... }, ... \\"folder2\\": { ... \\"file5.txt\\": 5000, ... } ... } >>> total_file_size(directory) 15000 ``` # Detailed Requirements 1. Your function should recursively compute the total file size if it encounters nested directories. 2. Utilize efficient mechanisms for handling the potential depth of the directory structure. 3. Ensure the function passes the provided example test cases.","solution":"def total_file_size(directory): Calculates the total size of all files in the given directory and subdirectories. Args: directory (dict): A dictionary representing the directory structure. Returns: int: The total size of all files in bytes. total_size = 0 for key, value in directory.items(): if isinstance(value, dict): total_size += total_file_size(value) else: total_size += value return total_size"},{"question":"# Problem Statement: Number Combination for a Target Sum in Array Given a sorted list of positive integers, find all unique combinations in the list where the sum of the elements equals a specific target number. # Task Write a function `combination_sum(arr: List[int], target: int) -> List[List[int]]` that returns a list of all unique combinations where each combination sums up to the target. Each number in the list may be used multiple times in the combination. The list should not contain duplicate combinations. # Input * `arr`: A sorted list of positive integers (1 <= len(arr) <= 20). * `target`: A positive integer (1 <= target <= 30). # Output * A list of lists containing all unique combinations where the sum of the combination is equal to the target. # Example ```python def combination_sum(arr: List[int], target: int) -> List[List[int]]: # Your code here print(combination_sum([2, 3, 6, 7], 7)) # Expected Output: [[2, 2, 3], [7]] print(combination_sum([2, 3, 5], 8)) # Expected Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] ``` # Constraints * The output should not contain duplicate combinations. * Ensure that the order of numbers in the inner lists does not matter. # Notes * Each combination should be sorted in ascending order. * Consider using backtracking or a similar algorithmic approach to find the combinations efficiently.","solution":"from typing import List def combination_sum(arr: List[int], target: int) -> List[List[int]]: def backtrack(start, path, remain): if remain == 0: result.append(path) return for i in range(start, len(arr)): if arr[i] > remain: break backtrack(i, path + [arr[i]], remain - arr[i]) result = [] arr.sort() backtrack(0, [], target) return result"},{"question":"# Assessment Question **Q2**: Write a function `extract_domain_counts` that takes a list of email addresses and returns a dictionary counting the occurrences of each domain. ```python def extract_domain_counts(emails: list[str]) -> dict[str, int]: Count the occurrences of each domain in a list of email addresses. Args: emails (list[str]): List of email addresses in the format [username@domain]. Returns: dict[str, int]: Dictionary with domains as keys and their counts as values. Example: >>> extract_domain_counts([\\"alice@example.com\\", \\"bob@example.com\\", \\"charles@test.org\\"]) {\'example.com\': 2, \'test.org\': 1} >>> extract_domain_counts([\\"john@domain.com\\", \\"jane@domain.com\\", \\"doe@another.com\\"]) {\'domain.com\': 2, \'another.com\': 1} pass ``` **Constraints and Notes**: - Assume all email addresses are correctly formatted. - Handle an empty input list by returning an empty dictionary. - Ensure the function is efficient and handles large lists of email addresses. **Expected Input and Output**: ```python assert extract_domain_counts([\\"alice@example.com\\", \\"bob@example.com\\", \\"charles@test.org\\"]) == {\'example.com\': 2, \'test.org\': 1} assert extract_domain_counts([\\"john@domain.com\\", \\"jane@domain.com\\", \\"doe@another.com\\"]) == {\'domain.com\': 2, \'another.com\': 1} assert extract_domain_counts([]) == {} assert extract_domain_counts([\\"single@onlyone.com\\"]) == {\'onlyone.com\': 1} ``` **Explanation**: - The function iterates through the provided list of email addresses. - It extracts the domain portion of each email address (the part after \'@\'). - It counts how many times each domain appears in the input list.","solution":"def extract_domain_counts(emails: list[str]) -> dict[str, int]: Count the occurrences of each domain in a list of email addresses. Args: emails (list[str]): List of email addresses in the format [username@domain]. Returns: dict[str, int]: Dictionary with domains as keys and their counts as values. domain_count = {} for email in emails: domain = email.split(\'@\')[1] if domain in domain_count: domain_count[domain] += 1 else: domain_count[domain] = 1 return domain_count"},{"question":"# Problem Statement You are given a list of integers representing the total sales in dollars made by different salespersons. Each integer corresponds to a single salesperson\'s total sales. Your task is to implement a function `most_frequent_sales` that returns the integer value of the total sales that occurred most frequently. If there are multiple sales values that have the same highest frequency, return the smallest one. Ensure your solution is efficient and can handle large inputs. # Function Definition ```python def most_frequent_sales(sales: list) -> int: :param sales: List of integers representing sales made by different salespersons. :return: Integer value that occurred most frequently (smallest one in case of a tie). ``` # Input * `sales` is a list of integers (1 ≤ len(sales) ≤ 10^5). * Each element in the list represents the sales made by a salesperson. # Output * Return the integer value that represents the most frequent sales amount. # Constraints * Ensure the algorithm handles large datasets efficiently. * If there are multiple sales amounts with the same highest frequency, return the smallest one. # Performance Requirements * The solution should not exceed a time complexity of O(n log n). # Example Example 1: ```python sales = [500, 900, 800, 500, 1200, 800, 800] # Output: 800 ``` Example 2: ```python sales = [300, 200, 200, 300, 100, 100, 100] # Output: 100 ``` # Note * The function should handle ties by returning the smallest sales amount with the highest frequency. * Efficient handling of large inputs is crucial for optimal performance. This question requires understanding of algorithms to determine the frequency of elements and manage ties based on ordering, ensuring the solution can handle large input sizes efficiently, while aligning with the complexity and style of the provided sample questions.","solution":"from collections import Counter def most_frequent_sales(sales: list) -> int: Returns the sales value that occurred most frequently in the sales list. If there is a tie, returns the smallest sales value among those with highest frequency. :param sales: List of integers representing sales made by different salespersons. :return: Integer value that occurred most frequently (smallest one in case of a tie). # Count the frequency of each sales value sales_count = Counter(sales) # Find the maximum frequency max_frequency = max(sales_count.values()) # Get all sales values with the maximum frequency most_frequent_sales_values = [key for key, count in sales_count.items() if count == max_frequency] # Return the smallest sales value among those with the highest frequency return min(most_frequent_sales_values)"},{"question":"# Problem: Matrix Operation Implementation Your task is to implement a matrix operation system that integrates various matrix manipulation functions into a unified module. The goal is to develop functions for common matrix operations, ensuring proper input validation, and efficient computation. Task Requirements: 1. **Function Signature**: - Implement functions corresponding to each of the following operations: * Matrix Addition * Matrix Subtraction * Matrix Multiplication * Matrix Transposition * Matrix Determinant (for 2x2 and 3x3 matrices) * Matrix Inversion (for 2x2 matrices) - The function names should be prefixed with `mat_` followed by the operation name (e.g., `mat_addition`). 2. **Input and Output**: - The functions should accept matrices (lists of lists with numeric elements) and return a matrix (list of lists) or a single numeric value in the case of determinant. - If invalid values or dimensions are provided (e.g., non-numeric elements, mismatched dimensions), the function should raise a `ValueError` with an appropriate message. 3. **Constraints**: - All matrix elements must be numeric (integers or floats). 4. **Performance Requirements**: - Ensure that the functions are optimized for common matrix sizes. Aim for efficient algorithms that are suitable for matrices up to 100x100 elements. Example Functions: 1. **Matrix Addition** ```python def mat_addition(mat1: list[list[float]], mat2: list[list[float]]) -> list[list[float]]: if not mat1 or not mat2: raise ValueError(\\"Matrices cannot be empty\\") if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]): raise ValueError(\\"Matrices must have the same dimensions\\") return [ [mat1[i][j] + mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1)) ] ``` 2. **Matrix Determinant (2x2)** ```python def mat_determinant_2x2(mat: list[list[float]]) -> float: if len(mat) != 2 or len(mat[0]) != 2: raise ValueError(\\"Matrix must be 2x2\\") return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] ``` 3. **Matrix Transposition** ```python def mat_transposition(mat: list[list[float]]) -> list[list[float]]: if not mat: raise ValueError(\\"Matrix cannot be empty\\") return [[mat[j][i] for j in range(len(mat))] for i in range(len(mat[0]))] ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct matrix operations. - Boundary conditions like empty matrices or zero elements. - Invalid inputs like non-numeric elements or mismatched dimensions raising appropriate errors. Provide at least one test example for each matrix operation function in the form of `assert` statements to validate their behavior.","solution":"def mat_addition(mat1, mat2): Returns the addition of two matrices mat1 and mat2. if not mat1 or not mat2: raise ValueError(\\"Matrices cannot be empty\\") if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]): raise ValueError(\\"Matrices must have the same dimensions\\") return [ [mat1[i][j] + mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1)) ] def mat_subtraction(mat1, mat2): Returns the subtraction of two matrices mat1 and mat2. if not mat1 or not mat2: raise ValueError(\\"Matrices cannot be empty\\") if len(mat1) != len(mat2) or len(mat1[0]) != len(mat2[0]): raise ValueError(\\"Matrices must have the same dimensions\\") return [ [mat1[i][j] - mat2[i][j] for j in range(len(mat1[0]))] for i in range(len(mat1)) ] def mat_multiplication(mat1, mat2): Returns the multiplication of two matrices mat1 and mat2. if not mat1 or not mat2: raise ValueError(\\"Matrices cannot be empty\\") if len(mat1[0]) != len(mat2): raise ValueError(\\"Number of columns of the first matrix must be equal to the number of rows of the second matrix\\") result = [[0 for _ in range(len(mat2[0]))] for _ in range(len(mat1))] for i in range(len(mat1)): for j in range(len(mat2[0])): for k in range(len(mat2)): result[i][j] += mat1[i][k] * mat2[k][j] return result def mat_transposition(mat): Returns the transpose of the matrix `mat`. if not mat: raise ValueError(\\"Matrix cannot be empty\\") return [[mat[j][i] for j in range(len(mat))] for i in range(len(mat[0]))] def mat_determinant_2x2(mat): Returns the determinant of a 2x2 matrix `mat`. if len(mat) != 2 or len(mat[0]) != 2: raise ValueError(\\"Matrix must be 2x2\\") return mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0] def mat_determinant_3x3(mat): Returns the determinant of a 3x3 matrix `mat`. if len(mat) != 3 or len(mat[0]) != 3: raise ValueError(\\"Matrix must be 3x3\\") return (mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) - mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) + mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0])) def mat_inversion_2x2(mat): Returns the inverse of a 2x2 matrix `mat`. if len(mat) != 2 or len(mat[0]) != 2: raise ValueError(\\"Matrix must be 2x2\\") det = mat_determinant_2x2(mat) if det == 0: raise ValueError(\\"Matrix is singular and cannot be inverted\\") return [[mat[1][1] / det, -mat[0][1] / det], [-mat[1][0] / det, mat[0][0] / det]]"},{"question":"# Problem Statement You are tasked with implementing a Circular Buffer data structure that supports fixed-size, FIFO (First-In-First-Out) behavior. Your implementation should efficiently handle common operations, such as adding and removing elements, while properly managing the buffer\'s capacity. # Requirements 1. **Append**: Implement a method to add a new element to the buffer. If the buffer is full, the oldest element should be overwritten. 2. **Pop**: Implement a method to remove and return the oldest element from the buffer. This method should handle the case when the buffer is empty gracefully. 3. **Peek**: Implement a method to get the oldest element without removing it from the buffer. 4. **Clear**: Implement a method to clear all elements from the buffer. 5. **Size**: Implement a method to get the current number of elements in the buffer. 6. **Is Full**: Implement a method to check if the buffer is full. 7. **Is Empty**: Implement a method to check if the buffer is empty. # Function Signatures You should define the following methods in a CircularBuffer class: ```python class CircularBuffer: def __init__(self, capacity: int) -> None: pass def append(self, value: int) -> None: pass def pop(self) -> int: pass def peek(self) -> int: pass def clear(self) -> None: pass def size(self) -> int: pass def is_full(self) -> bool: pass def is_empty(self) -> bool: pass ``` # Input/Output Format: - **Append**: Should take a single integer. - **Pop**: Should return the oldest integer in the buffer. - **Peek**: Should return the oldest integer in the buffer without removing it. - **Clear**: Should remove all elements from the buffer. - **Size**: Should return the current number of elements in the buffer as an integer. - **Is Full**: Should return a boolean indicating whether the buffer is full. - **Is Empty**: Should return a boolean indicating whether the buffer is empty. # Constraints - The capacity of the buffer will be a positive integer. - The buffer will store integer values. # Example Usage: ```python cb = CircularBuffer(3) cb.append(1) cb.append(2) cb.append(3) print(cb.peek()) # Output: 1 cb.append(4) print(cb.peek()) # Output: 2 print(cb.pop()) # Output: 2 print(cb.size()) # Output: 2 cb.clear() print(cb.is_empty()) # Output: True ``` # Notes: - Ensure that the methods handle edge cases, such as popping from an empty buffer, gracefully. - Include appropriate error handling and raise exceptions where applicable. - Make sure circular indexing is handled efficiently.","solution":"class CircularBuffer: def __init__(self, capacity: int) -> None: self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.count = 0 def append(self, value: int) -> None: if self.is_full(): self.tail = (self.tail + 1) % self.capacity else: self.count += 1 self.buffer[self.head] = value self.head = (self.head + 1) % self.capacity def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from empty buffer\\") value = self.buffer[self.tail] self.buffer[self.tail] = None self.tail = (self.tail + 1) % self.capacity self.count -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"peek from empty buffer\\") return self.buffer[self.tail] def clear(self) -> None: self.buffer = [None] * self.capacity self.head = 0 self.tail = 0 self.count = 0 def size(self) -> int: return self.count def is_full(self) -> bool: return self.count == self.capacity def is_empty(self) -> bool: return self.count == 0"},{"question":"# Problem Description Suppose you are given a list of integers representing elevations of water at various points on a plot of land. Write a function `trap_rain_water(height: List[int]) -> int` that calculates the maximum amount of water that can be trapped after raining. # Input * `height` (List[int]): A list of integers where 0 <= len(height) <= 1000 and 0 <= height[i] <= 1000. # Output * Returns an integer representing the maximum amount of water that can be trapped. # Constraints * The input list can be empty or non-empty. * The height values are non-negative integers. # Example ```python height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] print(trap_rain_water(height)) # Output should be 6 ``` # Explanation Your function should use a two-pointer approach or dynamic programming to calculate how much water can be trapped over the elevation map provided. The function should return the total amount of trapped water. # Note * Consider edge cases such as when the list is empty or when there is no elevation difference leading to no trapped water. * The solution should be efficient in terms of both time and space complexity.","solution":"from typing import List def trap_rain_water(height: List[int]) -> int: if not height: return 0 n = len(height) left_max, right_max = [0] * n, [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"# Question Description Write a function that takes a string representing an arithmetic expression involving positive integers and the \'+\' operator, and returns the result of that expression. This problem will test your understanding of basic string manipulation and arithmetic operations. # Function Signature ```python def evaluate_expression(expression: str) -> int: # Your code goes here ``` # Input - A string `expression` representing an arithmetic expression (1 <= |expression| <= 1000). - The expression will only contain positive integers and the \'+\' operator. - The expression will be a valid expression containing only positive integers separated by the \'+\' operator. # Output - An integer which is the result of the arithmetic expression. # Constraints - The function should handle expressions of any length up to 1000 characters efficiently. # Example ```python # Example 1: print(evaluate_expression(\\"1+2+3\\")) # Output: 6 # Example 2: print(evaluate_expression(\\"10+20+30\\")) # Output: 60 # Example 3: print(evaluate_expression(\\"100\\")) # Output: 100 # Example 4: print(evaluate_expression(\\"5+5+5+5\\")) # Output: 20 # Example 5: print(evaluate_expression(\\"999+1\\")) # Output: 1000 ``` # Notes * Ensure your function handles any valid input conforming to the problem constraints. * Do not use any eval or equivalent functions to directly evaluate expressions. * Focus on manually parsing and computing the result for robust solutions.","solution":"def evaluate_expression(expression: str) -> int: Returns the result of evaluating the given arithmetic expression. The expression will only contain positive integers and the \'+\' operator. # Split the expression by the \'+\' operator numbers = expression.split(\'+\') # Convert each substring to an integer and compute the sum total = sum(int(num) for num in numbers) return total"},{"question":"# Scenario You are working on a financial application that analyzes and processes large sets of transaction data. One of the common tasks is to detect fraudulent activities based on unusual patterns in the transaction amounts. To achieve this, you need to implement a data structure that allows efficient range sum queries and updates, which will help in identifying any anomalies quickly. # Task Implement a class `FenwickTree` (also known as Binary Indexed Tree) with the following methods: 1. `__init__(self, size: int)`: Constructor to initialize the Fenwick Tree with the given size. 2. `update(self, index: int, delta: int)`: Method to update the value at the given index by `delta`. 3. `query(self, index: int) -> int`: Method to get the prefix sum from the start to the given index. # Constraints * The size of the Fenwick Tree will be at most (10^5). * The index and delta will be integers such that the indices are within the valid range [0, size-1]. * There will be multiple calls to the `update` and `query` methods. # Input * Initialization of `FenwickTree` with an integer size. * Multiple calls to the `update(index, delta)` method depicting the changes in transactions. * Multiple calls to the `query(index)` method representing the sum of all transactions up to the given index. # Output * For each call to `query(index)`, return the sum of the elements from the start to the given index. # Examples ```python # Example usage ft = FenwickTree(10) ft.update(0, 5) ft.update(1, 3) ft.update(2, 7) print(ft.query(0)) # 5 print(ft.query(1)) # 8 print(ft.query(2)) # 15 ft.update(0, -2) print(ft.query(0)) # 3 print(ft.query(1)) # 6 print(ft.query(2)) # 13 ``` # Notes * Ensure your implementation efficiently handles the update and query operations. * Consider edge cases such as updating the first or the last index and querying the entire range of the tree. * Focus on optimizing both time and space complexity to handle large input sizes effectively.","solution":"class FenwickTree: def __init__(self, size: int): self.size = size self.tree = [0] * (size + 1) def update(self, index: int, delta: int): # Fenwick Tree index is 1-based, so we need to adjust the input index i = index + 1 while i <= self.size: self.tree[i] += delta i += i & -i def query(self, index: int) -> int: # Fenwick Tree index is 1-based, so we need to adjust the input index i = index + 1 total = 0 while i > 0: total += self.tree[i] i -= i & -i return total"},{"question":"# Coding Assessment Question You are required to implement a function that simulates a simple shopping cart system. The function should compute the total cost of items in the cart after applying a discount coupon. The function must handle edge cases such as invalid item prices, quantities, and invalid discount percentages. Task Implement a function `shopping_cart_total` that calculates the total price of the shopping cart after applying a discount. The function should take into account item prices, quantities, and a discount percentage. Function Signature ```python def shopping_cart_total(items: list[tuple[str, float, int]], discount: float) -> float: pass ``` Parameters - `items` (list of tuples): A list of tuples where each tuple represents an item in the cart. The tuple contains: - The item\'s name (str). - The item\'s price (float). Must be non-negative. - The item\'s quantity (int). Must be non-negative. - `discount` (float): Discount percentage to apply on the total cart value. Must be between 0 and 100. Returns - A float representing the total cost of the items in the cart after applying the discount. Constraints - Raise a `ValueError` if any item price or quantity is negative. - Raise a `ValueError` if the discount is not between 0 and 100 inclusive. Example ```python >>> shopping_cart_total([(\\"apple\\", 1.0, 4), (\\"banana\\", 0.5, 6)], 10) 5.85 >>> shopping_cart_total([(\\"milk\\", 2.5, 2), (\\"bread\\", 1.5, 1)], 0) 6.5 >>> shopping_cart_total([(\\"shirt\\", 20.0, 1), (\\"pants\\", 30.0, 1)], 50) 25.0 ``` Notes: - Ensure that your implementation correctly handles edge cases such as empty carts, zero discount, and maximum discount. - The discount percentage should be applied to the total cost of the cart. - Consider proper error handling to prevent negative prices, quantities, and invalid discount percentages. - The returned total cost should be rounded to two decimal places for currency format consistency.","solution":"def shopping_cart_total(items, discount): Calculates the total cart value after applying the discount. Parameters: items (list of tuples): Each tuple contains: - item\'s name (str) - item\'s price (float, non-negative) - item\'s quantity (int, non-negative) discount (float): Discount percentage to apply on the total cart value. Returns: float: The total cost of the items in the cart after applying the discount. # Validate discount if not (0 <= discount <= 100): raise ValueError(\\"Discount must be between 0 and 100 inclusive.\\") # Calculate the total cost before discount total_before_discount = 0.0 for item in items: name, price, quantity = item # Validate price and quantity if price < 0 or quantity < 0: raise ValueError(\\"Price and quantity must be non-negative.\\") total_before_discount += price * quantity # Apply discount total_after_discount = total_before_discount * (1 - discount / 100.0) # Return the total cost rounded to 2 decimal places return round(total_after_discount, 2)"},{"question":"# Coding Question: Timing Cache System Simulation Scenario You are building a simulation for a caching mechanism in a computing system. This simulation will model the time it takes to retrieve data from different levels of cache memory when accessed sequentially. Each cache level has a fixed lookup time and a probability of holding the requested data. Your task is to implement a function `simulate_cache_access` that predicts the total access time for a series of data requests. Task Implement the function `simulate_cache_access` in Python that calculates the total access time from the cache based on the given parameters. Function Signature ```python def simulate_cache_access( requests: list, cache_lookup_times: list, hit_probabilities: list, max_cache_levels: int ) -> list: ``` Parameters * `requests` (list of int): A list of data requests represented by integer values. * `cache_lookup_times` (list of float): Time taken (in milliseconds) to look up data in each cache level. The length of this list denotes the number of cache levels. * `hit_probabilities` (list of float): Probability of finding the requested data in each cache level, corresponding to `cache_lookup_times`. * `max_cache_levels` (int): Maximum number of cache levels to check before retrieving from the main memory. Returns * `list`: The total access time per request as a list of floats (in milliseconds). Constraints * (1 leq len(requests) leq 10^4) * (1 leq len(cache_lookup_times) leq 10) * (0.0 leq cache_lookup_times[i] leq 10.0) * (0.0 leq hit_probabilities[i] leq 1.0) * (1 leq max_cache_levels leq len(cache_lookup_times)) Example ```python # Example 1 result = simulate_cache_access( requests=[1, 2, 3], cache_lookup_times=[0.1, 0.2, 0.5], hit_probabilities=[0.5, 0.3, 0.2], max_cache_levels=2 ) # Output: [0.2, 0.6, 1.0] # Example 2 result = simulate_cache_access( requests=[5, 10, 15], cache_lookup_times=[0.05, 0.1, 0.25], hit_probabilities=[0.8, 0.6, 0.4], max_cache_levels=3 ) # Output: [0.05, 0.15, 0.35] ``` Notes 1. For each request, start from the first cache level and proceed to the next only if the requested data is not found, based on the hit probability. 2. Simulate the retrieval process and appropriately accumulate the lookup times. 3. The process stops either when the data is found or all allowed cache levels have been checked; assume main memory access is instant for the purpose of this task.","solution":"import random def simulate_cache_access(requests, cache_lookup_times, hit_probabilities, max_cache_levels): Simulates the cache access times for a series of requests. Parameters: requests (list of int): A list of data requests represented by integer values. cache_lookup_times (list of float): Time taken to look up data in each cache level. hit_probabilities (list of float): Probability of finding the requested data in each cache level. max_cache_levels (int): Maximum number of cache levels to check before retrieving from main memory. Returns: list: The total access time per request as a list of floats (in milliseconds). access_times = [] for request in requests: total_time = 0 found = False for i in range(min(max_cache_levels, len(cache_lookup_times))): total_time += cache_lookup_times[i] # Simulating a probabilistic cache hit if random.random() <= hit_probabilities[i]: found = True break # Add total time per request to the access_times list access_times.append(total_time) # If not found in the allowed cache levels, main memory access is considered instant in this simulation if not found: total_time += 0 return access_times"},{"question":"# Context You are a software engineer responsible for implementing a specialized data structure designed to efficiently handle dynamic intervals with union, intersection, and difference operations. For this task, you will be required to use an Interval Tree (or Segment Tree). # Problem Statement Implement an **IntervalTree** class that supports dynamic addition and removal of intervals, and implements union, intersection, and difference queries on the set of intervals. # Function Requirements 1. **Initializer**: `__init__(self) -> None` - Initialize the interval tree with no intervals. 2. **Add Interval**: `add_interval(self, start: int, end: int) -> None` - Add a closed interval [start, end] to the tree. - Time Complexity: (O(log n)) 3. **Remove Interval**: `remove_interval(self, start: int, end: int) -> None` - Remove a closed interval [start, end] from the tree. - Time Complexity: (O(log n)) 4. **Query Union**: `query_union(self) -> list[tuple[int, int]]` - Retrieve the list of intervals representing the union of all intervals in the tree. - Time Complexity: (O(n)) 5. **Query Intersection**: `query_intersection(self) -> list[tuple[int, int]]` - Retrieve the list of intervals representing the intersection of all intervals in the tree. - Time Complexity: (O(n)) 6. **Query Difference**: `query_difference(self, start: int, end: int) -> list[tuple[int, int]]` - Retrieve the list of intervals representing the difference of the interval [start, end] with the union of all intervals in the tree. - Time Complexity: (O(n)) # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - Outputs should match the function descriptions mentioned above. # Constraints - Each interval will have non-negative start and end points such that (0 leq text{start} leq text{end} leq 10^9). - The total number of intervals in the tree will not exceed (10^5). # Example ```python # Initializing the interval tree itree = IntervalTree() # Adding intervals itree.add_interval(1, 5) itree.add_interval(10, 15) itree.add_interval(20, 25) # Removing an interval itree.remove_interval(10, 15) # Querying the union of intervals print(itree.query_union()) # Outputs [(1, 5), (20, 25)] # Querying the intersection of intervals itree.add_interval(3, 6) print(itree.query_intersection()) # Outputs [(3, 5)] # Querying the difference of an interval with the union of the tree print(itree.query_difference(0, 30)) # Outputs [(0, 1), (5, 20), (25, 30)] ``` This question requires the candidate to implement a complex data structure with emphasis on efficient handling of intervals. It matches the style and complexity of the original question while introducing a complementary topic within data structures.","solution":"class IntervalTree: def __init__(self): self.intervals = [] def add_interval(self, start: int, end: int) -> None: self.intervals.append((start, end)) self.intervals.sort() def remove_interval(self, start: int, end: int) -> None: if (start, end) in self.intervals: self.intervals.remove((start, end)) def query_union(self) -> list[tuple[int, int]]: if not self.intervals: return [] merged_intervals = [] current_start, current_end = self.intervals[0] for start, end in self.intervals[1:]: if start <= current_end: current_end = max(current_end, end) else: merged_intervals.append((current_start, current_end)) current_start, current_end = start, end merged_intervals.append((current_start, current_end)) return merged_intervals def query_intersection(self) -> list[tuple[int, int]]: if not self.intervals: return [] self.intervals.sort() current_start, current_end = self.intervals[0] for start, end in self.intervals[1:]: if start <= current_end: current_start = max(current_start, start) current_end = min(current_end, end) else: return [] return [(current_start, current_end)] def query_difference(self, start: int, end: int) -> list[tuple[int, int]]: union_intervals = self.query_union() result = [] current_start = start for (u_start, u_end) in union_intervals: if current_start < u_start: result.append((current_start, min(u_start, end))) current_start = max(current_start, u_end) if current_start >= end: break if current_start < end: result.append((current_start, end)) return [i for i in result if i[0] < i[1]]"},{"question":"# Coding Assessment Question Context A sequence of numbers is called a \\"geometric progression\\" if the ratio between consecutive terms is constant. This sequence is often used in algorithmic problems and mathematical calculations. For example, the sequence ( [2, 6, 18, 54, ...] ) is a geometric progression where the first term is 2 and the common ratio is 3. Your task is to implement a function to generate the first N terms of a geometric progression given the first term and the common ratio. Problem Statement You need to write a Python function `generate_geometric_progression(first_term: int, common_ratio: int, length: int) -> list[int]` that returns a list of the first `length` terms of the geometric progression. The function should handle invalid inputs appropriately. # Constraints * The input `length` will be a positive integer (1 ≤ length ≤ 10^6). * The first term and common ratio can be any integer. # Expected Function Signature ```python def generate_geometric_progression(first_term: int, common_ratio: int, length: int) -> list[int]: ``` # Input * An integer `first_term` representing the first term of the geometric progression. * An integer `common_ratio` representing the common ratio of the geometric progression. * An integer `length` representing the number of terms to be generated. # Output * List of integers representing the first `length` terms of the geometric progression. # Example ```python print(generate_geometric_progression(2, 3, 5)) # Output: [2, 6, 18, 54, 162] print(generate_geometric_progression(5, 2, 4)) # Output: [5, 10, 20, 40] print(generate_geometric_progression(1, -1, 6)) # Output: [1, -1, 1, -1, 1, -1] print(generate_geometric_progression(0, 5, 3)) # Output: [0, 0, 0] print(generate_geometric_progression(7, 3, 0)) # Output: ValueError: Length must be a positive integer. ``` # Constraints 1. The function should raise a `ValueError` with the message \\"Length must be a positive integer.\\" if the input `length` is zero or a negative value. 2. The function should be efficient enough to handle large values of `length` up to 10^6 within a reasonable time frame. Additional Notes * Validate the input to ensure `length` is a positive integer. * Use list comprehensions or appropriate looping constructs for efficient computation.","solution":"def generate_geometric_progression(first_term: int, common_ratio: int, length: int) -> list[int]: Generates the first `length` terms of a geometric progression with given `first_term` and `common_ratio`. :param first_term: The first term of the geometric progression. :param common_ratio: The common ratio between consecutive terms. :param length: The number of terms to generate. :return: A list of the first `length` terms of the geometric progression. :raises ValueError: If the length is not a positive integer. if length <= 0: raise ValueError(\\"Length must be a positive integer.\\") progression = [first_term * (common_ratio ** i) for i in range(length)] return progression"},{"question":"# Scenario You are working on a text analysis tool that processes a large number of text files and generates a summary report. One critical feature of the tool is to count the frequency of each word in the text files, ignoring punctuation and variations in capitalization. The text files are read from a directory, and the word frequencies need to be consolidated into a single dictionary. # Task Write a function `count_word_frequencies(directory: str) -> dict` that: 1. Receives a directory path containing multiple text files. 2. Reads all text files in the specified directory. 3. Cleans the text to remove any punctuation. 4. Counts the frequency of each word, case-insensitively. 5. Returns a dictionary where keys are words and values are their respective frequencies. # Requirements 1. Implement a helper function `clean_text(text: str) -> str` that removes punctuation and normalizes text to lowercase. 2. Ensure the main function reads all `.txt` files in the specified directory and correctly aggregates word counts. 3. Test your implementation with mock file contents to ensure correctness. # Input & Output - **Input**: Directory path as a string. - **Output**: Dictionary with word frequencies. # Constraints - There can be a large number of files in the directory. - Words are case-insensitive and should be counted as such. - Punctuation should not be included in word counts. ```python import os import string def clean_text(text: str) -> str: # Remove punctuation and convert to lowercase translator = str.maketrans(\'\', \'\', string.punctuation) return text.translate(translator).lower() def count_word_frequencies(directory: str) -> dict: word_count = {} for filename in os.listdir(directory): if filename.endswith(\\".txt\\"): with open(os.path.join(directory, filename), \'r\') as file: for line in file: cleaned_line = clean_text(line) words = cleaned_line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count # Mock test function def test_count_word_frequencies(): import tempfile # Create a temporary directory with tempfile.TemporaryDirectory() as tmpdirname: # Create mock text files with open(os.path.join(tmpdirname, \'file1.txt\'), \'w\') as f: f.write(\\"Hello world! Hello everyone.\\") with open(os.path.join(tmpdirname, \'file2.txt\'), \'w\') as f: f.write(\\"This is a test. Testing the world.\\") # Expected word count expected = { \'hello\': 2, \'world\': 2, \'everyone\': 1, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 1, \'testing\': 1, \'the\': 1 } assert count_word_frequencies(tmpdirname) == expected # Run the test test_count_word_frequencies() ``` # Explanation - `clean_text`: Helper function to remove punctuation and convert text to lowercase. - `count_word_frequencies`: Main function to read all text files, clean the text, and count word frequencies. - `test_count_word_frequencies`: Mock test to ensure the correctness of the word counting logic using temporary files. This ensures the solution integrates file reading and text processing correctly.","solution":"import os import string def clean_text(text: str) -> str: Remove punctuation from the given text and convert it to lowercase. translator = str.maketrans(\'\', \'\', string.punctuation) return text.translate(translator).lower() def count_word_frequencies(directory: str) -> dict: Count the frequency of each word in all .txt files within the specified directory. Parameters: directory (str): path to the directory containing the text files Returns: dict: a dictionary with words as keys and their frequencies as values word_count = {} for filename in os.listdir(directory): if filename.endswith(\\".txt\\"): with open(os.path.join(directory, filename), \'r\') as file: for line in file: cleaned_line = clean_text(line) words = cleaned_line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 return word_count"},{"question":"# Find the Missing Number Context: In an array of integers ranging from 1 to N, one integer is missing. You are required to find the missing number efficiently. This is a common problem where sum formulas or XOR properties can be utilized to achieve the desired results in linear time with constant space. Task: Implement the function `find_missing_number(nums: List[int]) -> int` that finds the missing number from an array containing integers from 1 to N inclusive with one missing. Input: - **nums**: A list of integers `1 <= len(nums) <= 10^6` where the elements range from 1 to N (inclusive) and exactly one number is missing. Output: - A single integer representing the missing number in the array. Constraints: 1. The elements of the list are positive integers within the range from 1 to N. 2. There are no duplicates in the list. Example: ```python nums = [3, 7, 1, 2, 8, 4, 5] print(find_missing_number(nums)) # Output: 6 nums = [1, 2, 4, 5, 6] print(find_missing_number(nums)) # Output: 3 ``` Performance Requirements: - Your implementation should run in O(N) time complexity and use O(1) extra space, thus handling input lists with up to 1 million integers efficiently.","solution":"def find_missing_number(nums): Finds the missing number in the list of integers ranging from 1 to N. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Problem Description A sequence of numbers is said to be **non-decreasing** if each number is greater than or equal to the one preceding it. Given a list of integers, your task is to determine the longest non-decreasing subsequence (LNDS) within the provided list. # Function Definition Define a function `longest_non_decreasing_subsequence(arr: List[int]) -> List[int]` that takes a list of integers and returns the longest non-decreasing subsequence. # Input * **arr** (List[int]): A list of integers, where the size |arr| can be up to 10^3. # Output * **List[int]**: The longest non-decreasing subsequence derived from the input list. If there are multiple subsequences with the same length, return any one of them. # Constraints * `1 <= |arr| <= 1000` * The elements in `arr` can be any integer. # Examples Example 1: **Input**: ```python arr = [10, 5, 18, 7, 2, 9] ``` **Output**: ```python [5, 7, 9] ``` **Explanation**: The longest non-decreasing subsequence here is [5, 7, 9]. Other valid options could include [2, 9] as there may be multiple valid subsequences of the same length. Example 2: **Input**: ```python arr = [3, 4, 1, 2, 8, 5, 6] ``` **Output**: ```python [1, 2, 5, 6] ``` **Explanation**: The longest non-decreasing subsequence here is [1, 2, 5, 6]. Other valid options could include [3, 4, 5, 6] as there may be multiple valid subsequences of the same length. # Notes - You are expected to implement an efficient solution, though it is not strictly required to be optimal. - Ensure to handle edge cases such as a singleton list or a list with all elements equal. Implementation Details You may use dynamic programming or any other method you find appropriate to determine the longest non-decreasing subsequence. Make sure that your implementation handles the maximum input size efficiently within the given constraints. **Please provide your implementation below:**","solution":"def longest_non_decreasing_subsequence(arr): Find the longest non-decreasing subsequence in the given list of integers. :param arr: List[int] - List of integers :return: List[int] - Longest non-decreasing subsequence if not arr: return [] n = len(arr) dp = [1] * n # dp[i] will store the length of LNDS ending with arr[i] prev = [-1] * n # to store the previous index in the LNDS # Finding the length of LNDS for each element for i in range(n): for j in range(i): if arr[i] >= arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j # Finding the maximum length of LNDS and its ending index max_length = max(dp) index = dp.index(max_length) # Reconstructing the LNDS lnds = [] while index != -1: lnds.append(arr[index]) index = prev[index] lnds.reverse() # reversing to get the sequence in correct order return lnds"},{"question":"# Scenario You are enhancing a logging system that tracks user actions within an application. Each log message is tagged with a user ID and timestamp and should include information about the action performed. The goal is to parse a series of log messages and group them by user ID, presenting an ordered list of actions for each user, sorted by timestamp. # Objective Write a Python function named `group_logs_by_user` that accepts a list of log messages and returns a dictionary where each key is a user ID, and the value is a list of actions sorted by timestamp in ascending order. # Function Signature ```python def group_logs_by_user(logs: list) -> dict: pass ``` # Input * `logs` (list): A list of dictionary objects where each dictionary represents a log message with the following keys: - `user_id` (int): A positive integer representing the user ID. - `timestamp` (int): A non-negative integer representing the Unix timestamp of the log message. - `action` (str): A string describing the action performed. # Output * Returns a dictionary where: - Each key is a user ID (int). - Each value is a list of action strings (str), sorted by timestamp in ascending order. # Constraints * Each `user_id` is a positive integer. * Each `timestamp` is a non-negative integer. * Each `action` is a non-empty string. * The input list can contain up to 1000 log messages. # Requirements 1. The function should handle input validation and raise appropriate errors for invalid inputs. 2. The function must correctly sort actions for each user by their timestamps. # Examples ```python >>> logs = [ ... {\\"user_id\\": 1, \\"timestamp\\": 1622476800, \\"action\\": \\"login\\"}, ... {\\"user_id\\": 2, \\"timestamp\\": 1622476860, \\"action\\": \\"view_page\\"}, ... {\\"user_id\\": 1, \\"timestamp\\": 1622476900, \\"action\\": \\"logout\\"}, ... {\\"user_id\\": 1, \\"timestamp\\": 1622476805, \\"action\\": \\"click_button\\"}, ... {\\"user_id\\": 2, \\"timestamp\\": 1622476890, \\"action\\": \\"logout\\"}, ... ] >>> group_logs_by_user(logs) { 1: [\\"login\\", \\"click_button\\", \\"logout\\"], 2: [\\"view_page\\", \\"logout\\"] } >>> group_logs_by_user([]) {} >>> group_logs_by_user([{\\"user_id\\": 3, \\"timestamp\\": 1622476800, \\"action\\": \\"login\\"}]) { 3: [\\"login\\"] } >>> group_logs_by_user([{\\"user_id\\": 1, \\"timestamp\\": 1622476800, \\"action\\": \\"\\"}]) Traceback (most recent call last): ... ValueError: action cannot be an empty string >>> group_logs_by_user([{\\"user_id\\": -1, \\"timestamp\\": 1622476800, \\"action\\": \\"login\\"}]) Traceback (most recent call last): ... ValueError: user_id must be a positive integer >>> group_logs_by_user([{\\"user_id\\": 1, \\"timestamp\\": -1, \\"action\\": \\"login\\"}]) Traceback (most recent call last): ... ValueError: timestamp must be a non-negative integer >>> group_logs_by_user([1, 2, 3]) Traceback (most recent call last): ... TypeError: logs must be a list of dictionaries ``` # Notes * The solution should ensure robustness against malformed log entries. * Handling edge cases, such as an empty list or logs with identical timestamps, should be addressed. Provide well-documented code and include any assumptions made in your solution.","solution":"def group_logs_by_user(logs): Groups log messages by user ID and sorts actions by timestamp. Args: logs (list): A list of dictionary objects representing log messages with keys: - \'user_id\' (int): Positive integer representing the user ID. - \'timestamp\' (int): Non-negative integer representing the Unix timestamp of the log message. - \'action\' (str): Non-empty string describing the action performed. Returns: dict: A dictionary where each key is a user ID, and the value is a list of action strings sorted by timestamp in ascending order. if not isinstance(logs, list): raise TypeError(\\"logs must be a list of dictionaries\\") for log in logs: if not isinstance(log, dict): raise TypeError(\\"each log entry must be a dictionary\\") if \'user_id\' not in log or \'timestamp\' not in log or \'action\' not in log: raise ValueError(\\"every log entry must contain \'user_id\', \'timestamp\', and \'action\' keys\\") if not isinstance(log[\'user_id\'], int) or log[\'user_id\'] <= 0: raise ValueError(\\"user_id must be a positive integer\\") if not isinstance(log[\'timestamp\'], int) or log[\'timestamp\'] < 0: raise ValueError(\\"timestamp must be a non-negative integer\\") if not isinstance(log[\'action\'], str) or not log[\'action\']: raise ValueError(\\"action must be a non-empty string\\") from collections import defaultdict user_logs = defaultdict(list) for log in logs: user_logs[log[\'user_id\']].append((log[\'timestamp\'], log[\'action\'])) for user_id in user_logs: user_logs[user_id].sort() user_logs[user_id] = [action for timestamp, action in user_logs[user_id]] return dict(user_logs)"},{"question":"# Scenario As a software developer, one of your main priorities is to ensure the efficiency and reliability of the applications you create. One such application requires you to analyze the data structure and needs an efficient way to check for the existence of patterns. To this end, one useful tool is the balanced binary tree, which helps maintain ordered data and allows for quick searches, insertions, and deletions. # Task Write a function `is_balanced_binary_tree(root: TreeNode) -> bool` that checks whether a given binary tree is height-balanced. # Input * **root**: The root node of a binary tree, represented by a `TreeNode` class. # Output * Return `True` if the binary tree is height-balanced, and `False` otherwise. A height-balanced binary tree is defined as one where the depth of any two subtrees of every node never differs by more than one. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_binary_tree(root: TreeNode) -> bool: pass ``` # Examples * Given the binary tree: ``` 3 / 9 20 / 15 7 ``` `is_balanced_binary_tree(root)` should return `True`. * Given the binary tree: ``` 1 / 2 2 / 3 3 / 4 4 ``` `is_balanced_binary_tree(root)` should return `False`. # Constraints * The number of nodes in the tree is in the range `[0, 5000]`. * The value of each node is a unique integer in the range `[-10^4, 10^4]`. # Notes * You may define and use helper functions as needed to ensure clarity and efficiency of your solution. * Consider the efficiency of both time and space in your solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced_binary_tree(root: TreeNode) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height <= 1) height = 1 + max(left_height, right_height) return height, balanced _, balanced = check_balance(root) return balanced"},{"question":"# Matrix Transpose Calculation You are assigned to implement a function that calculates and returns the transpose of a given matrix. A matrix transpose swaps the rows and columns, i.e., the element at row i and column j is moved to row j and column i. Requirements: 1. **Function Definition**: - Implement the function to transpose a given 2D matrix. 2. **Input-Output Specifications**: - The function takes a single 2D list `matrix` representing an MxN matrix as input. - The function returns a new 2D list containing the transposed matrix. 3. **Constraints**: - The input matrix can have between 1 and 10^3 rows and columns. - Elements in the matrix will be integers between 0 and 10^3. - You must ensure the function handles rectangular matrices. 4. **Performance**: - Time Complexity: O(M * N), where M is the number of rows and N is the number of columns. - Space Complexity: O(M * N) for the output matrix. Function to Implement: ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: Transpose the given matrix. >>> transpose([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose([[1]]) [[1]] >>> transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] pass ``` Make sure to return a new matrix with the transposed values and do not modify the input matrix.","solution":"def transpose(matrix): Transpose the given matrix. Args: matrix (List[List[int]]): A 2D list representing the matrix. Returns: List[List[int]]: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"# Dictionary Value Sort Challenge You are given a dictionary containing string keys and integer values. Your task is to sort this dictionary by its values in ascending order and return a list of the keys arranged according to this order. Detailed Instructions: 1. Write a function `sort_dict_by_values` with the following parameter: - `input_dict`: A dictionary where keys are strings and values are integers. 2. The function should perform the following tasks: - Validate that the input is a dictionary with string keys and integer values. - Sort the dictionary by its values in ascending order. - Return a list of keys arranged according to the sorted order of their values. Constraints: - Do not use any additional libraries or modules. - Handle possible input errors gracefully by raising an appropriate ValueError. - Assume that the input dictionary is not empty. Function Signature: ```python def sort_dict_by_values(input_dict: dict[str, int]) -> list[str]: ``` Example: ```python # Example 1: input_dict = {\'apple\': 5, \'banana\': 2, \'cherry\': 8, \'date\': 3} print(sort_dict_by_values(input_dict)) # Output: [\'banana\', \'date\', \'apple\', \'cherry\'] # Example 2: input_dict = {\'kiwi\': 3, \'mango\': 1, \'pear\': 2} print(sort_dict_by_values(input_dict)) # Output: [\'mango\', \'pear\', \'kiwi\'] # Example 3: input_dict = {\'x\': 10, \'y\': 1, \'z\': 5} print(sort_dict_by_values(input_dict)) # Output: [\'y\', \'z\', \'x\'] ```","solution":"def sort_dict_by_values(input_dict): Sorts a dictionary by its values in ascending order and returns a list of keys arranged according to this order. :param input_dict: A dictionary with string keys and integer values. :return: A list of keys sorted by their corresponding values. if not isinstance(input_dict, dict): raise ValueError(\\"Input must be a dictionary.\\") for key, value in input_dict.items(): if not isinstance(key, str) or not isinstance(value, int): raise ValueError(\\"Dictionary must have string keys and integer values.\\") # Sort the dictionary by its values sorted_items = sorted(input_dict.items(), key=lambda item: item[1]) # Extract the keys from the sorted items sorted_keys = [key for key, _ in sorted_items] return sorted_keys"},{"question":"# Problem Statement: A car rental service manages a fleet of cars and tracks the bookings of customers in a reservation system. Each reservation consists of the customer\'s name, the start date, and the end date of the rental period. The company has a rule that no two reservations can overlap for the same car. Given a list of reservations and a new reservation request, write a function to determine if the new reservation can be accepted without any conflict. # Function Signature: ```python def can_accept_reservation(existing_reservations: List[Tuple[str, str, str]], new_reservation: Tuple[str, str, str]) -> bool: pass ``` # Parameters: - `existing_reservations` (List[Tuple[str, str, str]]): A list of tuples, where each tuple contains three strings: the customer\'s name, the start date, and the end date. - `new_reservation` (Tuple[str, str, str]): A tuple containing three strings: the customer\'s name, the start date, and the end date of the new reservation. # Returns: - `bool`: Returns `True` if the new reservation can be accepted, otherwise `False`. # Constraints: - The date strings are in the format \'YYYY-MM-DD\'. - There will be no more than 100 existing reservations. - The new reservation\'s end date is always equal to or after the start date. # Example: ```python existing_reservations = [ (\\"John Doe\\", \\"2023-05-01\\", \\"2023-05-10\\"), (\\"Jane Smith\\", \\"2023-05-11\\", \\"2023-05-20\\"), (\\"Alice Johnson\\", \\"2023-05-21\\", \\"2023-05-25\\") ] new_reservation = (\\"Bob Brown\\", \\"2023-05-10\\", \\"2023-05-12\\") assert can_accept_reservation(existing_reservations, new_reservation) == False new_reservation = (\\"Bob Brown\\", \\"2023-05-26\\", \\"2023-05-30\\") assert can_accept_reservation(existing_reservations, new_reservation) == True ``` **Note:** - Ensure to handle edge cases, such as reservations that start or end on the same date as an existing reservation. - The function should be efficient and handle the upper limit of the constraints within reasonable time and space limits.","solution":"from datetime import datetime from typing import List, Tuple def can_accept_reservation( existing_reservations: List[Tuple[str, str, str]], new_reservation: Tuple[str, str, str]) -> bool: def parse_date(date_str: str) -> datetime: return datetime.strptime(date_str, \'%Y-%m-%d\') new_start_date = parse_date(new_reservation[1]) new_end_date = parse_date(new_reservation[2]) for _, start_str, end_str in existing_reservations: start_date = parse_date(start_str) end_date = parse_date(end_str) if max(start_date, new_start_date) <= min(end_date, new_end_date): return False return True"},{"question":"# Working with File I/O and Data Processing You are to implement a script that processes a text file containing inventory data for an online store, calculates the total stock value, and identifies items with low stock. Specific Requirements 1. **Input**: A file path to a text file containing inventory data. 2. **Output**: * The total value of all items in stock. * A list of item names with stock below a specified threshold. 3. **Constraints**: * The text file is in the following format: `ItemName,Price,Quantity`, with one item per line. * The script should be able to handle large files efficiently. * Ensure proper error handling for file access issues. * The threshold for low stock should be configurable and default to 10. Performance Requirements * Optimize memory usage when processing large files by reading line by line. * Ensure accurate calculations and handle any potential edge cases gracefully (e.g., malformed lines, missing values). Scenario Your organization needs to optimize inventory management by monitoring stock levels and calculating inventory value. Implement a function that reads from a text file, processes the data, and returns key insights for inventory management. You are tasked with implementing the following function: ```python def process_inventory(file_path: str, low_stock_threshold: int = 10) -> dict: Given a file path to an inventory data file, calculate the total stock value and identify low stock items. Parameters: file_path (str): The path to the inventory data file. low_stock_threshold (int): The threshold for low stock items (default is 10). Returns: dict: A dictionary with \'total_value\' as the total stock value and \'low_stock_items\' as a list of item names with stock below the threshold. pass ``` **Example Usage:** ```python inventory_data = process_inventory(\\"inventory.txt\\", 5) print(\\"Total Inventory Value:\\", inventory_data[\'total_value\']) print(\\"Low Stock Items:\\", inventory_data[\'low_stock_items\']) ``` Ensure your solution handles large files efficiently and robustly manages file access errors and data integrity issues.","solution":"def process_inventory(file_path: str, low_stock_threshold: int = 10) -> dict: Given a file path to an inventory data file, calculate the total stock value and identify low stock items. Parameters: file_path (str): The path to the inventory data file. low_stock_threshold (int): The threshold for low stock items (default is 10). Returns: dict: A dictionary with \'total_value\' as the total stock value and \'low_stock_items\' as a list of item names with stock below the threshold. total_value = 0 low_stock_items = [] try: with open(file_path, \'r\') as file: for line in file: try: item_name, price, quantity = line.strip().split(\',\') price = float(price) quantity = int(quantity) total_value += price * quantity if quantity < low_stock_threshold: low_stock_items.append(item_name) except ValueError: continue # Skip malformed lines except FileNotFoundError: raise FileNotFoundError(f\\"File at path {file_path} not found.\\") except Exception as e: raise Exception(f\\"An error occurred: {e}\\") return {\'total_value\': total_value, \'low_stock_items\': low_stock_items}"},{"question":"# Coding Assessment Question: String Manipulation and Palindrome Detection Context String manipulation techniques are pivotal in numerous programming tasks involving text processing, data validation, and algorithm design. One common problem is detecting and handling palindromes—strings that read the same backward as forward. Task 1. **Function 1 - Palindrome Check** Implement the function `is_palindrome(s: str) -> bool:` which determines if a given string is a palindrome. - **Input**: A string `s`. - **Output**: A boolean value `True` if the string is a palindrome, otherwise `False`. 2. **Function 2 - Longest Palindromic Substring** Implement the function `longest_palindromic_substring(s: str) -> str:` that finds the longest palindromic substring within the given string. - **Input**: A string `s`. - **Output**: The longest palindromic substring as a string. - **Constraints**: The length of `s` is at most 10^3 (1000 characters). Requirements - Ensure `is_palindrome` handles edge cases such as empty strings and strings of varying cases. - For `longest_palindromic_substring`, optimize your solution to run efficiently within the given constraints. Examples ```python # Example for is_palindrome assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome(\\"A man, a plan, a canal, Panama\\") == True # Ignoring case and non-alphanumerics # Example for longest_palindromic_substring assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" # \\"aba\\" is also a valid answer assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" # Edge case assert is_palindrome(\\"\\") == True assert is_palindrome(\\" \\") == True # Single space character considered a palindrome assert longest_palindromic_substring(\\"\\") == \\"\\" assert longest_palindromic_substring(\\"abc\\") == \\"a\\" # Any single character is a valid longest palindrome ``` Implement both functions in your solution and ensure to handle edge cases appropriately. Test your functions with a variety of inputs to ensure correctness and performance.","solution":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome. # Remove non-alphanumeric characters and convert to lowercase filtered_chars = [c.lower() for c in s if c.isalnum()] return filtered_chars == filtered_chars[::-1] def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring within the given string. n = len(s) if n == 0: return \\"\\" start = 0 max_length = 1 # Create a 2D array to keep track of palindromes dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"# Coding Challenge: Fibonacci-Like Sequence Finder You are tasked with designing a function that will generate a \\"fibonacci-like\\" sequence of a given length `n`, where the sequence starts with two given integers and each subsequent number is defined as the sum of two preceding numbers. Context Given two initial integers `x` and `y`, the sequence follows the rule: ```python seq[i] = seq[i-1] + seq[i-2] ``` for all `i` from 3 to `n` (1-indexed). Define a function `fibonacci_like_sequence(x, y, n)` that generates such a sequence and returns it as a list of integers. Function Signature ```python def fibonacci_like_sequence(x: int, y: int, n: int) -> List[int]: pass ``` Input - **x** (`int`): The first integer in the sequence. - **y** (`int`): The second integer in the sequence. - **n** (`int`): A positive integer representing the length of the sequence (n ≥ 2). Output - **List[int]**: A list of integers representing the fibonacci-like sequence of length `n`. Constraints - The integers `x` and `y` can be any valid integer (positive, negative, or zero). - The sequence should have exactly `n` elements. - The length `n` is at least 2. Example Usage ```python print(fibonacci_like_sequence(1, 1, 10)) # Expected output: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] print(fibonacci_like_sequence(0, 1, 6)) # Expected output: [0, 1, 1, 2, 3, 5] print(fibonacci_like_sequence(3, 2, 5)) # Expected output: [3, 2, 5, 7, 12] ``` Notes - Ensure your function is efficient and concise. - Consider edge cases, such as when `x` or `y` is zero or negative. - KISS (Keep It Simple, Stupid) principle should be applied while designing your function. Compose the `fibonacci_like_sequence` function to match the requirements and constraints effectively.","solution":"from typing import List def fibonacci_like_sequence(x: int, y: int, n: int) -> List[int]: if n == 2: return [x, y] sequence = [x, y] for i in range(2, n): next_value = sequence[-1] + sequence[-2] sequence.append(next_value) return sequence"},{"question":"# Problem Scenario/Context A robot is designed to traverse a grid from the top-left corner to the bottom-right corner, attempting to navigate around obstacles placed within the grid. The robot can move either right or down at any point in time. You need to determine the number of distinct paths the robot can take to reach its destination without hitting any obstacles. # Task You are to write a function `robot_paths` that takes in an integer grid size `n` and a list of tuples `obstacles` where each tuple represents the coordinates of an obstacle. The function should return the number of distinct paths for the robot from the starting position to the goal position. Function Signature ```python def robot_paths(n: int, obstacles: List[Tuple[int, int]]) -> int: pass ``` Input * `n` (int): The size of the grid, 1 ≤ n ≤ 100. * `obstacles` (List[Tuple[int, int]]): List of coordinates representing obstacles, 0 ≤ len(obstacles) ≤ n*n. Output * `int`: Number of distinct paths from top-left to bottom-right of the grid avoiding the obstacles. # Constraints * The starting position (0, 0) and the goal position (n-1, n-1) will not be blocked. * The robot can only move right or down at any point in time. # Example ```python >>> robot_paths(3, [(1, 1)]) 2 >>> robot_paths(3, []) 6 ``` # Requirements * Consider edge cases, such as no obstacles or a maximum number of obstacles. * Ensure the function runs efficiently for maximum input size. # Explanation In a 3x3 grid with one obstacle at (1,1) there are two unique paths: * Right, Down, Right, Down * Down, Right, Down, Right","solution":"from typing import List, Tuple def robot_paths(n: int, obstacles: List[Tuple[int, int]]) -> int: # Initialize the grid grid = [[0] * n for _ in range(n)] # Mark obstacles in the grid for (x, y) in obstacles: grid[x][y] = -1 # Using -1 to indicate obstacle # Starting point (0, 0) if grid[0][0] != -1: grid[0][0] = 1 # Fill the grid with the number of ways to reach each point for i in range(n): for j in range(n): if grid[i][j] == -1: continue # Skip obstacles if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] # Return the number of distinct paths to the bottom-right corner return grid[n-1][n-1] if grid[n-1][n-1] != -1 else 0"},{"question":"# String Pattern Matching Context: You are building a minimalistic search engine for substrings within a body of text. To achieve this, you need to implement a function that finds all occurrences of a given pattern in a string using the Knuth-Morris-Pratt (KMP) string matching algorithm. The function should return the starting indices of each occurrence of the pattern in the text. Function Signature: ```python def kmp_search(text: str, pattern: str) -> list[int]: pass ``` Input: - A string `text` consisting of lower case English letters. - A string `pattern` consisting of lower case English letters, which is the substring pattern to search for within the `text`. Output: - A list of integers representing the starting indices of each occurrence of the pattern in the text. Constraints: - The length of `text` is between 0 and 10^5 characters. - The length of `pattern` is between 1 and 10^3 characters. - If the pattern is not found in the text, return an empty list. - Patterns are case-sensitive. Example: ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" print(kmp_search(text, pattern)) # Output: [10] ``` # Description: In the above example: - The pattern \\"ababd\\" is found at index 10 in the text \\"ababcabcabababd\\". # Requirements: - Implement the `kmp_search` function using the Knuth-Morris-Pratt (KMP) algorithm. - The KMP algorithm involves preprocessing the pattern to create a partial match table (also known as the π-table or lps array) to determine the next positions without unnecessary re-comparison. - Handle edge cases, such as the pattern being empty or the text being smaller than the pattern. # Note: - Do not include any print statements in your function. - Ensure your implementation is efficient and performs validations as necessary. ```python def kmp_search(text: str, pattern: str) -> list[int]: if not pattern: return [] n, m = len(text), len(pattern) lps = [0] * m # Preprocess the pattern to create the lps array j = 0 i = 1 while i < m: if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # KMP search algorithm i = 0 j = 0 result = [] while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result ``` This question tests the candidate\'s understanding of string algorithms, specifically the efficient search provided by the KMP algorithm, which is a common topic in computer science. The implementation requires managing arrays and iterating through the string efficiently, matching the complexity of the initial sample question.","solution":"def kmp_search(text: str, pattern: str) -> list[int]: if not pattern: return [] n, m = len(text), len(pattern) if m > n: return [] # Create the longest prefix suffix (lps) array for the pattern lps = [0] * m j = 0 # length of previous longest prefix suffix i = 1 # Preprocess the pattern to create the lps array while i < m: if pattern[i] == pattern[j]: j += 1 lps[i] = j i += 1 else: if j != 0: j = lps[j - 1] else: lps[i] = 0 i += 1 # KMP search algorithm result = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: result.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Finding the Mode in a List **Context**: The mode of a set of values is the value that appears most frequently. It is a measure of central tendency that is less sensitive to outliers compared to the mean or the median. **Task**: Write a function `find_mode(nums: list[int]) -> list[int]` that identifies the mode(s) in a list of integers. If the input list is empty, raise a `ValueError`. **Input**: * `nums`: A list of integers. Example: `[4, 1, 2, 2, 3, 3]` **Output**: * Return a list of integers representing the mode(s). If there are multiple modes with the same highest frequency, return all of them in ascending order. **Constraints**: * You may use Python\'s built-in libraries to assist with frequency counting. Requirements: 1. Utilize efficient data structures to keep track of frequencies. 2. Ensure the implementation runs in linear time, O(n). ```python def find_mode(nums: list[int]) -> list[int]: Return the mode(s) of a list of numbers. >>> find_mode([4, 1, 2, 2, 3, 3]) [2, 3] >>> find_mode([4, 4, 4, 1, 2, 2, 2]) [2, 4] >>> find_mode([-1, -1, -2, -3, -2, -1]) [-1] >>> find_mode([1]) [1] >>> find_mode([]) Traceback (most recent call last): ... ValueError: List is empty if not nums: raise ValueError(\\"List is empty\\") from collections import Counter freq = Counter(nums) max_freq = max(freq.values()) modes = [num for num, count in freq.items() if count == max_freq] return sorted(modes) if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Explanation**: 1. If the input list is empty, raise a `ValueError`. 2. Count the frequency of each number in the list using Python\'s `Counter` from the `collections` module. 3. Determine the highest frequency. 4. Identify all numbers that have this frequency. 5. Return these numbers sorted in ascending order. **Edge Cases to Consider**: 1. The list is empty. 2. The list contains one element. 3. The list contains all identical elements. 4. The list has multiple modes with the same highest frequency.","solution":"from collections import Counter from typing import List def find_mode(nums: List[int]) -> List[int]: Return the mode(s) of a list of numbers. Args: - nums: List[int] - a list of integers. Returns: - List[int] - a list of the mode(s) in ascending order. Example: >>> find_mode([4, 1, 2, 2, 3, 3]) [2, 3] >>> find_mode([4, 4, 4, 1, 2, 2, 2]) [2, 4] >>> find_mode([-1, -1, -2, -3, -2, -1]) [-1] >>> find_mode([1]) [1] >>> find_mode([]) Traceback (most recent call last): ... ValueError: List is empty if not nums: raise ValueError(\\"List is empty\\") freq = Counter(nums) max_freq = max(freq.values()) modes = [num for num, count in freq.items() if count == max_freq] return sorted(modes)"},{"question":"# Reverse Linked List Scenario You are tasked with developing software that performs various operations on linked lists. One of the key operations required is the ability to reverse a given linked list. Task Write a function `reverse_linked_list(head: Node) -> Node` that takes the head of a singly linked list and returns the head of the new linked list that is the reversed version of the original. Input The function will receive the head node of the linked list: - `head`: a `Node` instance where `Node` is defined as follows: ```python @dataclass class Node: data: int next: Node | None = None ``` Output The function should return: - `head`: the head node of the reversed linked list. Constraints - The linked list contains numerical values (integers). - The linked list can be empty. - The function should handle linked lists of varying lengths, including very large lists efficiently. Example ```python # Example of a linked list: 1 -> 2 -> 3 -> None head = Node(data=1, next=Node(data=2, next=Node(data=3))) # After reversing, it should be: 3 -> 2 -> 1 -> None reversed_head = reverse_linked_list(head) # Output: reversed_head should be a Node with the data train starting from 3 -> 2 -> 1 -> None ``` # Additional Notes - Ensure your solution manages edge cases, such as empty linked lists. - Optimize your code to handle both small and large linked lists without excessive space or time complexity. - Remember to handle the pointer manipulations correctly to avoid any memory leaks or infinite loops. In summary, write a robust function to reverse a linked list given its head. Validate functionality with edge cases and typical usage patterns.","solution":"from dataclasses import dataclass from typing import Optional @dataclass class Node: data: int next: Optional[\'Node\'] = None def reverse_linked_list(head: Optional[Node]) -> Optional[Node]: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"# Coding Assessment Question You are developing a game where players need to collect items within a grid. Each cell in the grid either contains an item or is empty. The goal is to determine the maximum number of items that can be collected if the player is allowed only one straight-line move (vertical, horizontal, or diagonal). Problem Statement Write a function `max_items_collected(grid: list[list[int]]) -> int` that takes a 2D list representing the grid, where `1` indicates a cell containing an item and `0` indicates an empty cell, and returns the maximum number of items that can be collected by making only one straight-line move. Input and Output Formats - **Input**: - `grid`: A list of lists representing the 2D grid. Each element in a sublist is either `1` (item) or `0` (empty). - **Output**: - An integer representing the maximum number of items that can be collected in a single straight-line move. Constraints - The grid dimensions will be between `1x1` and `50x50` inclusive. - The grid contains at least one item. Examples: ```python >>> grid = [ [1, 0, 1, 0], [0, 1, 0, 1], [1, 1, 1, 1], ] >>> max_items_collected(grid) 4 >>> grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0], ] >>> max_items_collected(grid) 3 ``` Function Signature ```python def max_items_collected(grid: list[list[int]]) -> int: ```","solution":"def max_items_collected(grid: list[list[int]]) -> int: rows = len(grid) cols = len(grid[0]) def count_items_in_direction(dx, dy): max_items = 0 for i in range(rows): for j in range(cols): if grid[i][j] == 1: count = 0 x, y = i, j while 0 <= x < rows and 0 <= y < cols and grid[x][y] == 1: count += 1 x += dx y += dy max_items = max(max_items, count) return max_items max_items = 0 for direction in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1)]: max_items = max(max_items, count_items_in_direction(*direction)) return max_items"},{"question":"**[Question 2]: Subsequence Product with Maximum Sum** **Problem Statement:** Write a function `max_subsequence_product_sum(arr: List[int], k: int) -> int` that finds the maximum sum of the products of all possible subsequences of length `k` from the given list `arr`. **Input:** - A list of integers `arr` where the length of `arr` is between 1 and 20 inclusive. - An integer `k` (1 <= k <= len(arr)): the length of subsequences to consider. **Output:** - Returns an integer representing the maximum sum of products of all possible subsequences of length `k`. **Constraints:** - The input list may contain negative numbers and zero. - The input list will not contain any floating-point numbers. **Function Signature:** ```python def max_subsequence_product_sum(arr: List[int], k: int) -> int: pass ``` **Example:** ```python assert max_subsequence_product_sum([1, 2, 3], 2) == 11 # 1*2 + 1*3 + 2*3 = 2 + 3 + 6 = 11 assert max_subsequence_product_sum([-1, -2, -3], 2) == -1 # (-1)*(-2) + (-1)*(-3) + (-2)*(-3) = 2 + 3 - 1 = -1 assert max_subsequence_product_sum([1, 0, -1], 2) == 1 # 1*0 + 1*(-1) + 0*(-1) = 0 - 1 + 0 = 1 ``` **Requirements:** - Handle edge cases such as the presence of zero and negative numbers. - Ensure the solution considers the performance and efficiently iterates the possible subsequences. - Utilize combinatorial methods to generate subsequences and compute their product sums. **Hint:** - Consider using combinatorial generators from libraries like `itertools` to efficiently create subsequences. - Evaluate the product of each subsequence and keep a running sum to determine the maximum value.","solution":"from itertools import combinations from typing import List def max_subsequence_product_sum(arr: List[int], k: int) -> int: def product(seq): result = 1 for num in seq: result *= num return result max_sum = float(\'-inf\') for subseq in combinations(arr, k): subseq_sum = product(subseq) if subseq_sum > max_sum: max_sum = subseq_sum return max_sum"},{"question":"# Implementing a Movie Theater Seat Reservation System Context You are developing a system for a movie theater to manage seat reservations. The theater has several rows of seats, and each row has a fixed number of seats. Customers should be able to reserve seats in a specified row, and the system should ensure that no two customers can reserve the same seat. Problem Statement Implement a class `MovieTheater` that offers the following functionalities: 1. Initialize the theater with a specified number of rows and seats per row. 2. Allow reservations of specific seats if they are available. 3. Provide the ability to cancel reservations. 4. Retrieve the current seating arrangement where reserved seats are marked. The class should include the following methods: - `__init__(self, rows: int, seats_per_row: int)`: Initializes the seating arrangement. - `reserve_seat(self, row: int, seat: int) -> bool`: Attempts to reserve the specified seat. Returns `True` if successful, `False` if the seat is already reserved or the input is invalid. - `cancel_reservation(self, row: int, seat: int) -> bool`: Cancels the reservation for the specified seat if it exists. Returns `True` if successful, `False` if the seat is not reserved or the input is invalid. - `get_seating(self) -> List[List[str]]`: Returns the current seating arrangement. Unreserved seats are indicated with \\".\\", and reserved seats with \\"R\\". Requirements 1. **Input and Output Formats**: - Input for `__init__(rows, seats_per_row)`: Two integers representing the number of rows and seats per row. - Output of `reserve_seat(row, seat)`: Boolean indicating if the reservation was successful. - Output of `cancel_reservation(row, seat)`: Boolean indicating if the cancellation was successful. - Output of `get_seating()`: List of lists representing the seating arrangement. 2. **Constraints**: - Rows and seats per row: 1 ≤ rows, seats_per_row ≤ 1000. - Row and seat indices for reservation and cancellation start from 0. - If the reservation or cancellation method is called with invalid row or seat indices, return `False`. 3. **Performance**: - Ensure operations handle large inputs efficiently within the given constraints. Example ```python class MovieTheater: def __init__(self, rows: int, seats_per_row: int): # Implement this method pass def reserve_seat(self, row: int, seat: int) -> bool: # Implement this method pass def cancel_reservation(self, row: int, seat: int) -> bool: # Implement this method pass def get_seating(self) -> List[List[str]]: # Implement this method pass # Example usage: theater = MovieTheater(5, 5) assert theater.reserve_seat(1, 1) == True assert theater.reserve_seat(1, 1) == False assert theater.cancel_reservation(1, 1) == True assert theater.cancel_reservation(1, 1) == False seating = theater.get_seating() # Expected output: # [ # [\'.\', \'.\', \'.\', \'.\', \'.\'], # [\'.\', \'.\', \'.\', \'.\', \'.\'], # [\'.\', \'.\', \'.\', \'.\', \'.\'], # [\'.\', \'.\', \'.\', \'.\', \'.\'], # [\'.\', \'.\', \'.\', \'.\', \'.\'] # ] ``` Notes - Handle edge cases such as reservations for out-of-bounds indices, cancellations of non-reserved seats, and attempts to reserve already reserved seats. - Focus on ensuring the class methods are efficient and handle real-time updates to the seating arrangement correctly.","solution":"class MovieTheater: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row self.seating = [[\'.\' for _ in range(seats_per_row)] for _ in range(rows)] def reserve_seat(self, row: int, seat: int) -> bool: if 0 <= row < self.rows and 0 <= seat < self.seats_per_row: if self.seating[row][seat] == \'.\': self.seating[row][seat] = \'R\' return True else: return False return False def cancel_reservation(self, row: int, seat: int) -> bool: if 0 <= row < self.rows and 0 <= seat < self.seats_per_row: if self.seating[row][seat] == \'R\': self.seating[row][seat] = \'.\' return True else: return False return False def get_seating(self) -> list: return self.seating"},{"question":"# Coding Assessment Question: Implement a Custom Batch Normalization Layer Context You are enhancing a neural network model for image classification tasks. To improve convergence and training stability, you decide to implement a custom batch normalization layer within your network architecture. Objective Write a Python function to implement Batch Normalization for a given layer output. Requirements 1. **Function Name**: `batch_normalization` 2. **Input**: A numpy array `X` of shape (m, n) representing the output of a neural network layer for `m` samples and `n` features. 3. **Output**: A numpy array of the same shape as the input, with batch normalization applied to each feature. Constraints * Do not use third-party libraries for the batch normalization (rely on numpy only). * Implement both the training and inference modes. Performance Requirements * Your function should process each feature efficiently. * The space complexity should be reasonable to handle in-memory data during training. Example ```python >>> import numpy as np >>> X = np.array([[1, 2], [3, 4], [5, 6]]) >>> gamma = np.array([1, 1]) >>> beta = np.array([0, 0]) >>> epsilon = 1e-8 >>> is_training = True >>> batch_normalization(X, gamma, beta, epsilon, is_training) array([[-1.22474487, -1.22474487], [ 0. , 0. ], [ 1.22474487, 1.22474487]]) ``` Additional Task Integrate your Batch Normalization implementation into a simple convolutional neural network using any machine learning framework of your choice (e.g., TensorFlow, PyTorch, or custom numpy code). The network should consist of: * An input layer to match the shape of input images (e.g., 28x28 for MNIST). * One convolutional layer followed by a batch normalization layer. * One fully connected layer for classification. Document your code and provide a short summary (not more than 200 words) of the benefits of batch normalization in neural network training. Hint Use the following equations for batch normalization: - For each feature `j`: ``` mean_j = mean(X[:, j]) variance_j = variance(X[:, j]) X_norm[:, j] = (X[:, j] - mean_j) / sqrt(variance_j + epsilon) out[:, j] = gamma[j] * X_norm[:, j] + beta[j] ```","solution":"import numpy as np def batch_normalization(X, gamma, beta, epsilon=1e-8, is_training=True, running_mean=None, running_var=None, momentum=0.9): Applies batch normalization to the input X. Args: - X (np.ndarray): Input data of shape (m, n). - gamma (np.ndarray): Scale parameter, shape (n,). - beta (np.ndarray): Shift parameter, shape (n,). - epsilon (float): Small constant for numerical stability. - is_training (bool): Flag for training or inference mode. - running_mean (np.ndarray): Running mean for inference, shape (n,). (Only used if is_training is False) - running_var (np.ndarray): Running variance for inference, shape (n,). (Only used if is_training is False) - momentum (float): Momentum for moving average. Returns: - np.ndarray: Batch-normalized output of same shape as X. - np.ndarray: Updated running mean (for training mode). - np.ndarray: Updated running variance (for training mode). if is_training: mean = X.mean(axis=0) variance = X.var(axis=0) X_norm = (X - mean) / np.sqrt(variance + epsilon) out = gamma * X_norm + beta if running_mean is None: running_mean = mean else: running_mean = momentum * running_mean + (1 - momentum) * mean if running_var is None: running_var = variance else: running_var = momentum * running_var + (1 - momentum) * variance return out, running_mean, running_var else: if running_mean is None or running_var is None: raise ValueError(\\"running_mean and running_var must be provided in inference mode\\") X_norm = (X - running_mean) / np.sqrt(running_var + epsilon) out = gamma * X_norm + beta return out"},{"question":"**Scenario**: Imagine you are building a library management system that keeps track of book availabilities across multiple branches of a library. Each branch can have multiple copies of the same book, and books can be borrowed or returned at any time. **Task**: Implement a class `LibraryManagement` with the following methods: 1. `add_book(branch: str, book_title: str, count: int) -> None`: Add a given number of copies of a book to a specific branch. 2. `borrow_book(branch: str, book_title: str) -> bool`: Borrow a book from a specific branch. Return `True` if the book is successfully borrowed, `False` if there are no available copies. 3. `return_book(branch: str, book_title: str) -> None`: Return a borrowed book to a specific branch. 4. `availability(branch: str, book_title: str) -> int`: Check how many copies of a book are available at a specific branch. * Expected input and output formats: * `add_book(branch, book_title, count)` -> None * `borrow_book(branch, book_title)` -> True/False * `return_book(branch, book_title)` -> None * `availability(branch, book_title)` -> int * Constraints: * The `branch` string will always be non-empty and contain only alphanumeric characters. * The `book_title` string will always be non-empty and contain only alphanumeric characters and spaces. * The `count` will always be a positive integer. * Ensure methods handle cases where the branch or book does not exist gracefully. Below is the starting code for the class: ```python class LibraryManagement: def __init__(self): # Implement the constructor to initialize the storage for branches and books. pass def add_book(self, branch: str, book_title: str, count: int) -> None: # Implement logic to add copies of a book to the specified branch. pass def borrow_book(self, branch: str, book_title: str) -> bool: # Implement logic to borrow a book from the specified branch. pass def return_book(self, branch: str, book_title: str) -> None: # Implement logic to return a borrowed book to the specified branch. pass def availability(self, branch: str, book_title: str) -> int: # Implement logic to check the availability of a book in the specified branch. pass ```","solution":"class LibraryManagement: def __init__(self): self.library = {} def add_book(self, branch: str, book_title: str, count: int) -> None: if branch not in self.library: self.library[branch] = {} if book_title not in self.library[branch]: self.library[branch][book_title] = 0 self.library[branch][book_title] += count def borrow_book(self, branch: str, book_title: str) -> bool: if branch in self.library and book_title in self.library[branch] and self.library[branch][book_title] > 0: self.library[branch][book_title] -= 1 return True return False def return_book(self, branch: str, book_title: str) -> None: if branch in self.library and book_title in self.library[branch]: self.library[branch][book_title] += 1 else: self.add_book(branch, book_title, 1) def availability(self, branch: str, book_title: str) -> int: if branch in self.library and book_title in self.library[branch]: return self.library[branch][book_title] return 0"},{"question":"# Scenario An aspiring data scientist is working on a machine learning application that involves extensive matrix operations. They need to frequently calculate the transpose of various matrices during their analysis. To streamline their workflow, they wish to implement an efficient function that can handle this task. The function must be designed to manage matrices of different dimensions while ensuring proper input validation. # Task Write a Python function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that computes the transpose of a given 2D matrix. The function must validate the input to ensure it represents a proper matrix before performing the transpose operation. # Requirements - The function must check if the input is a valid 2D matrix (i.e., all rows should have the same length) - Raise a `ValueError` with the message \\"Invalid matrix input.\\" if the input is not a valid 2D matrix - The function should handle matrices with varying sizes efficiently # Input and Output - **Input**: A list of lists of integers representing a 2D matrix - **Output**: A new list of lists of integers representing the transposed matrix # Constraints - The number of rows in the input matrix will be between 1 and 100 inclusive - The number of columns in the input matrix will be between 1 and 100 inclusive # Performance Requirements - The solution should be efficient in terms of time complexity, leveraging list comprehensions where appropriate # Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3], [4, 5], [7, 8, 9]]) Traceback (most recent call last): ... ValueError: Invalid matrix input. ``` **Notes** - It is recommended to use list comprehensions and built-in functions to achieve a clean and efficient solution. Create a Python function `transpose_matrix` following the described specifications.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Computes the transpose of a given 2D matrix. Args: matrix (List[List[int]]): A 2D list representing the matrix to be transposed. Returns: List[List[int]]: The transposed matrix. Raises: ValueError: If the input is not a valid 2D matrix. if not matrix or not all(isinstance(row, list) and len(row) == len(matrix[0]) for row in matrix): raise ValueError(\\"Invalid matrix input.\\") return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]"},{"question":"# Question: Develop a Booking System for Conference Rooms You are required to implement a booking system for a set of conference rooms in an office. Each room can have multiple bookings, but no two bookings can overlap within the same room. Implement the following three functions: 1. `initialize_rooms(num_rooms: int) -> None` * This function initializes the system with `num_rooms` conference rooms. 2. `book(room_id: int, start_time: int, end_time: int) -> bool` * This function attempts to book the room specified by `room_id` from `start_time` to `end_time`. * If the room is available for the entire requested time range, the booking should be successful and the function should return `True`. * If the room is not available, the booking should fail and the function should return `False`. * Raise an exception if the `room_id` is invalid or if `start_time` is not before `end_time`. 3. `is_available(room_id: int, start_time: int, end_time: int) -> bool` * This function checks if the room specified by `room_id` is available from `start_time` to `end_time`. * Return `True` if the room is available for the entire duration; otherwise, return `False`. * Raise an exception if the `room_id` is invalid or if `start_time` is not before `end_time`. # Constraints: * Assume there are at most 100 conference rooms. * Each booking request will be specified in hours as an integer value from 0 to 23. * Input times `start_time` and `end_time` are inclusive and should be between 0 and 23. * Maximum number of bookings per room will not exceed 1,000 bookings. # Example Usage: ```python >>> initialize_rooms(3) >>> book(1, 9, 12) True >>> book(1, 11, 13) False >>> book(2, 10, 11) True >>> is_available(1, 13, 14) True >>> is_available(1, 11, 13) False >>> book(4, 14, 16) # Raises exception: Invalid room_id >>> is_available(1, 12, 12) False ``` # Points to Implement: * Efficient data structures to manage room bookings. * Proper exception handling for invalid inputs. * Optimized performance for booking and availability checks.","solution":"class ConferenceRoomBookingSystem: def __init__(self): self.rooms = {} def initialize_rooms(self, num_rooms: int) -> None: if num_rooms < 1 or num_rooms > 100: raise ValueError(\\"Number of rooms must be between 1 and 100.\\") self.rooms = {i: [] for i in range(num_rooms)} def book(self, room_id: int, start_time: int, end_time: int) -> bool: if room_id not in self.rooms: raise ValueError(\\"Invalid room_id.\\") if start_time >= end_time or start_time < 0 or end_time > 23: raise ValueError(\\"Invalid time range.\\") if self.is_available(room_id, start_time, end_time): self.rooms[room_id].append((start_time, end_time)) self.rooms[room_id].sort() return True return False def is_available(self, room_id: int, start_time: int, end_time: int) -> bool: if room_id not in self.rooms: raise ValueError(\\"Invalid room_id.\\") if start_time >= end_time or start_time < 0 or end_time > 23: raise ValueError(\\"Invalid time range.\\") for booking in self.rooms[room_id]: if not (end_time <= booking[0] or start_time >= booking[1]): return False return True # Initialize an instance of the booking system booking_system = ConferenceRoomBookingSystem()"},{"question":"**Question:** You are working on a data validation system for inventory management where you often need to track the parity (odd or even status) of a multiset of integers to efficiently determine whether the multiset sums to an even or odd number, and to update the status as elements are modified. Use the Segment Tree data structure for these operations due to their efficient interval sum and update capabilities. **TASK**: Create a class called `InventoryManager` that includes the following methods: 1. `__init__(self, items: List[int])`: Initializes the class with a given list of inventory items, represented as a list of integers. 2. `update_item(self, index: int, value: int)`: Updates the item at the given index with a new value. 3. `get_item(self, index: int) -> int`: Retrieves the value of the item at the given index. 4. `is_even_sum_interval(self, start: int, end: int) -> bool`: Returns `True` if the sum of items within the interval `[start, end)` (inclusive of start, exclusive of end) is even, and `False` if the sum is odd. **Function Signature**: ```python class InventoryManager: def __init__(self, items: List[int]): pass def update_item(self, index: int, value: int): pass def get_item(self, index: int) -> int: pass def is_even_sum_interval(self, start: int, end: int) -> bool: pass ``` **Constraints**: - 0 <= index < len(items) - start <= end <= len(items) **Performance Requirements**: - Aim for O(log N) complexity for update and query operations. **Example**: ```python items = [3, 6, 5, 4, 2, 1] im = InventoryManager(items) # Update items im.update_item(2, 6) # Retrieve an item print(im.get_item(2)) # Output: 6 # Check if the sum of items in interval [1, 5) is even print(im.is_even_sum_interval(1, 5)) # Output: True (6 + 6 + 4 + 2 = 18, which is even) # Check if the sum of items in interval [0, 3) is even print(im.is_even_sum_interval(0, 3)) # Output: False (3 + 6 + 6 = 15, which is odd) ``` Write your solution below:","solution":"from typing import List class InventoryManager: def __init__(self, items: List[int]): self.n = len(items) self.tree = [0] * (2 * self.n) self.build(items) def build(self, items: List[int]): # Initialize leaves in the segment tree for i in range(self.n): self.tree[self.n + i] = items[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update_item(self, index: int, value: int): pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def get_item(self, index: int) -> int: return self.tree[self.n + index] def is_even_sum_interval(self, start: int, end: int) -> bool: start += self.n end += self.n interval_sum = 0 while start < end: if start % 2 == 1: interval_sum += self.tree[start] start += 1 if end % 2 == 1: end -= 1 interval_sum += self.tree[end] start //= 2 end //= 2 return interval_sum % 2 == 0"},{"question":"# Valid Parentheses with Annotations **Context**: You are contributing to a text editor that supports recognizing and validating parentheses in code snippets. Your task is to implement a function that verifies if a given string containing parentheses is valid. A valid string is one where every opening parenthesis has a corresponding closing parenthesis in the correct order. **Objective**: Implement the function `is_valid_parentheses` which takes as input a string and returns a boolean indicating whether the input string contains valid parentheses. # Requirements 1. **Input**: - A string `s` consisting only of characters `(` and `)` where `0 ≤ len(s) ≤ 10^4`. 2. **Output**: - A boolean, `True` if the parentheses in the string are valid, `False` otherwise. # Examples ```python assert is_valid_parentheses(\\"()\\") == True assert is_valid_parentheses(\\"()()\\") == True assert is_valid_parentheses(\\"(())\\") == True assert is_valid_parentheses(\\"(()\\") == False assert is_valid_parentheses(\\")(\\") == False assert is_valid_parentheses(\\"\\") == True ``` # Constraints - Your solution should work efficiently for large inputs. - Focus on correct handling of nested and sequential parentheses. # Function Signature ```python def is_valid_parentheses(s: str) -> bool: pass ``` # Implementation Notes - Use a stack-based approach to track opening parentheses. - Ensure that each closing parenthesis matches the most recent unmatched opening parenthesis. - Carefully handle edge cases, such as empty strings and strings with unbalanced parentheses.","solution":"def is_valid_parentheses(s: str) -> bool: Returns whether the given string of parentheses is valid. A valid string of parentheses is one where every opening parenthesis has a corresponding closing parenthesis in the correct order. Args: s (str): The input string consisting only of \'(\' and \')\'. Returns: bool: True if the input string is valid, False otherwise. stack = [] for char in s: if char == \'(\': stack.append(char) elif char == \')\': if not stack or stack.pop() != \'(\': return False return len(stack) == 0"},{"question":"# Binary Search Tree Deletion Background A Binary Search Tree (BST) is a node-based data structure in which each node has at most two children referred to as the left child and the right child. For each node, the left subtree of that node contains only nodes with keys less than the node\'s key, and the right subtree contains only nodes with keys greater than the node\'s key. In this task, you will implement the deletion operation for a Binary Search Tree. Deleting a node from a BST can be divided into three main cases: 1. The node to be deleted is a leaf node. 2. The node to be deleted has one child. 3. The node to be deleted has two children. When a node to be deleted has two children, replace the node with its inorder successor (smallest node in its right subtree). Task You need to implement a class `BST` with the following methods: 1. `insert`: This method inserts a given key into the BST. 2. `delete`: This method deletes a node with a given key from the BST. 3. `inorder_traversal`: This method performs an in-order traversal of the BST and returns a list of node values. You also need to create a main function to demonstrate the insertion, deletion, and traversal of the BST. Implementation 1. **insert**: - **Input**: An integer `key` representing the key to be inserted. - **Output**: None (the BST is modified in place). - **Example**: ```python bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) print(bst.inorder_traversal()) # Output: [30, 50, 70] ``` 2. **delete**: - **Input**: An integer `key` representing the key to be deleted. - **Output**: None (the BST is modified in place). - **Example**: ```python bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.delete(30) print(bst.inorder_traversal()) # Output: [50, 70] ``` 3. **inorder_traversal**: - **Output**: A list of integers representing the node values in in-order traversal. - **Example**: ```python bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) print(bst.inorder_traversal()) # Output: [30, 50, 70] ``` 4. **main**: - Perform a sequence of insertions and deletions. - Output the in-order traversal after each insertion/deletion to demonstrate the functionality. Constraints - All keys are unique. - The BST will have at most `1000` nodes. - Each key is an integer between `0` and `10^4`. Performance - Ensure the function efficiently handles the constraints. - Optimize the operations wherever possible. Example Implement the following: ```python class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def main(): bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) print(\\"Inorder traversal after insertions:\\", bst.inorder_traversal()) bst.delete(20) print(\\"Inorder traversal after deleting 20:\\", bst.inorder_traversal()) bst.delete(30) print(\\"Inorder traversal after deleting 30:\\", bst.inorder_traversal()) bst.delete(50) print(\\"Inorder traversal after deleting 50:\\", bst.inorder_traversal()) if __name__ == \\"__main__\\": main() ``` Explanation: This example builds a BST, performs several insertions, deletes nodes covering all 3 main cases, and shows the in-order traversal after each deletion to demonstrate the correctness of the operations.","solution":"class Node: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if node is None: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def inorder_traversal(self): result = [] self._inorder_traversal(self.root, result) return result def _inorder_traversal(self, node, result): if node is not None: self._inorder_traversal(node.left, result) result.append(node.key) self._inorder_traversal(node.right, result) def main(): bst = BST() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) print(\\"Inorder traversal after insertions:\\", bst.inorder_traversal()) bst.delete(20) print(\\"Inorder traversal after deleting 20:\\", bst.inorder_traversal()) bst.delete(30) print(\\"Inorder traversal after deleting 30:\\", bst.inorder_traversal()) bst.delete(50) print(\\"Inorder traversal after deleting 50:\\", bst.inorder_traversal()) if __name__ == \\"__main__\\": main()"},{"question":"# Problem: Extended String Manipulation Suite Your task is to design a suite of string manipulation functions that perform various transformations on input strings. The goal is to develop functions for each of the specified transformations, ensuring proper input validation, and efficient execution while adhering to the outlined behavior. Task Requirements: 1. **Function Signature**: - Implement functions for each of the following transformations: * Reverse String * Remove Vowels * Capitalize Words * Encode with Caesar Cipher * Palindromic Check * Anagram Check * Substring Check - The function names should be prefixed with `str_` followed by the operation name (e.g., `str_reverse`). 2. **Input and Output**: - The functions should accept and return strings, except for the Caesar Cipher encoding, which should also take an integer shift value as a second argument. - If invalid types are provided, functions should raise a `TypeError` with an appropriate message. 3. **Constraints**: - All inputs must be strings, except for the Caesar Cipher function which also takes an integer shift value. 4. **Performance Requirements**: - Ensure that the functions run in linear time O(n) relative to the length of the string and use linear space O(n). Example Functions: 1. **Reverse String** ```python def str_reverse(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_reverse() only accepts strings\\") return s[::-1] ``` 2. **Remove Vowels** ```python def str_remove_vowels(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_remove_vowels() only accepts strings\\") vowels = \\"aeiouAEIOU\\" return \'\'.join(char for char in s if char not in vowels) ``` 3. **Capitalize Words** ```python def str_capitalize_words(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_capitalize_words() only accepts strings\\") return \' \'.join(word.capitalize() for word in s.split()) ``` Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing correct transformations. - Inputs with mixed case, special characters, and numbers. - Empty strings. - Invalid inputs like non-string types raising appropriate errors. Provide at least one test example for each string manipulation function in the form of `assert` statements to validate their behavior.","solution":"def str_reverse(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_reverse() only accepts strings\\") return s[::-1] def str_remove_vowels(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_remove_vowels() only accepts strings\\") vowels = \\"aeiouAEIOU\\" return \'\'.join(char for char in s if char not in vowels) def str_capitalize_words(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"str_capitalize_words() only accepts strings\\") return \' \'.join(word.capitalize() for word in s.split()) def str_encode_caesar_cipher(s: str, shift: int) -> str: if not isinstance(s, str) or not isinstance(shift, int): raise TypeError(\\"str_encode_caesar_cipher() only accepts a string and an integer\\") def shift_char(c): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) return c return \'\'.join(shift_char(c) for c in s) def str_is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"str_is_palindrome() only accepts strings\\") stripped = \'\'.join(e for e in s if e.isalnum()).lower() return stripped == stripped[::-1] def str_is_anagram(s1: str, s2: str) -> bool: if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"str_is_anagram() only accepts strings\\") return sorted(s1) == sorted(s2) def str_is_substring(s1: str, s2: str) -> bool: if not isinstance(s1, str) or not isinstance(s2, str): raise TypeError(\\"str_is_substring() only accepts strings\\") return s1 in s2"},{"question":"# Question: File Type Counter You are tasked with implementing a script that counts the number of different file types in a given directory and its subdirectories. The goal is to recursively traverse the directory tree and return a dictionary with file extensions as keys and their respective counts as values. Requirements 1. Implement the function `file_type_counter(path: str) -> dict` 2. The function should: - Traverse the given directory and all its subdirectories. - Identify file types based on their extensions. - Count occurrences of each file type. - Return the results as a dictionary where keys are file extensions (e.g., `\'.txt\'`, `\'.py\'`) and values are the counts of those file types. Input * `path`: String representing the path to the directory to analyze. Output * A dictionary of file types (extensions) and their counts. Constraints * Handle directories with a large number of files efficiently. * Skip directories without read permissions gracefully. * Ensure the function can count hidden files and directories (those beginning with a dot). Example If the directory structure is: ``` /example file1.txt file2.py subdir/ file3.txt file4.cpp ``` The output might be: ```python { \'.txt\': 2, \'.py\': 1, \'.cpp\': 1 } ``` # Additional Notes * Use appropriate libraries and methods to handle filesystem operations and traversals. * Ensure the function is robust against various edge cases, such as empty directories and unusual file names. * Consider the performance implications of large directory trees and optimize for efficiency.","solution":"import os from collections import defaultdict def file_type_counter(path): Counts the number of different file types in the given directory and its subdirectories. Args: path (str): The directory path to analyze. Returns: dict: A dictionary with file extensions as keys and their respective counts as values. file_counts = defaultdict(int) for root, _, files in os.walk(path): for file in files: ext = os.path.splitext(file)[1] file_counts[ext] += 1 return dict(file_counts)"},{"question":"# Word Frequency Filter Scenario You\'re building a text analysis tool that is designed to help writers and editors for measuring the frequency of words. Given a block of text, you need to identify all words and their frequencies. Additionally, you should be able to filter the words by setting a minimum frequency threshold. Task Implement a function that counts the frequency of each unique word in a given text and filters out the words whose frequencies are below a specified threshold. Words are case-insensitive and punctuation should be ignored. You are given the skeleton of this function, and you need to implement it as described below. Function **Function `filter_word_frequencies`:** - **Input**: - `text`: A string of arbitrary length containing the text to be analyzed. - `threshold`: An integer specifying the minimum frequency a word must have to be included in the output. - **Output**: A dictionary where keys are words (in lowercase) and values are their respective counts, filtered by the given threshold. - **Punctuation**: Ignore punctuation marks during counting. Treat words as case-insensitive. ```python def filter_word_frequencies(text: str, threshold: int) -> dict[str, int]: Count word frequencies and filter by a given threshold. Parameters: - text (str): Text to be analyzed - threshold (int): Minimum frequency a word must have to be included Returns: - dict[str, int]: A dictionary where keys are words (in lowercase) and values are their counts # Your code here ``` Examples ```python # Example 1 text = \\"Hello, hello! This is a TEST. This test is only a test.\\" threshold = 1 print(filter_word_frequencies(text, threshold)) # Expected: {\'hello\': 2, \'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3, \'only\': 1} # Example 2 text = \\"Hello, hello! This is a TEST. This test is only a test.\\" threshold = 2 print(filter_word_frequencies(text, threshold)) # Expected: {\'hello\': 2, \'this\': 2, \'is\': 2, \'a\': 2, \'test\': 3} # Example 3 text = \\"To be, or not to be, that is the question.\\" threshold = 1 print(filter_word_frequencies(text, threshold)) # Expected: {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1} ``` Constraints * Ensure the function handles empty strings and returns an empty dictionary in such cases. * Make sure that the function handles large inputs within a reasonable time. **Note:** Raise meaningful exceptions if input values are not of expected types.","solution":"import re from collections import Counter def filter_word_frequencies(text: str, threshold: int) -> dict: Count word frequencies and filter by a given threshold. Parameters: - text (str): Text to be analyzed - threshold (int): Minimum frequency a word must have to be included Returns: - dict[str, int]: A dictionary where keys are words (in lowercase) and values are their counts if not isinstance(text, str): raise ValueError(\\"Text must be a string\\") if not isinstance(threshold, int) or threshold < 0: raise ValueError(\\"Threshold must be a non-negative integer\\") # Remove punctuation and convert to lower case words = re.findall(r\'bw+b\', text.lower()) # Count frequencies freq = Counter(words) # Filter based on threshold filtered_freq = {word: count for word, count in freq.items() if count >= threshold} return filtered_freq"},{"question":"# Problem: Text Analyzer System **Context**: You are tasked with developing a text analyzer system that can efficiently handle a series of operations related to word frequency and searching. The system should be optimized to handle large volumes of text data and provide quick responses to queries on word occurrences. Your task is to implement a class `TextAnalyzer` capable of the following operations: 1. **Add_Text**: Add a block of text to the system. 2. **Word_Frequency**: Return the frequency of a specified word. 3. **Top_K_Words**: Return the top `K` words by frequency. # Task: Implement the class `TextAnalyzer` with the following methods: 1. **__init__()**: Initialize the text analyzer. 2. **add_text(text: str) -> None**: - Add the given block of `text` to the system. - Update the internal data structures to keep track of word frequencies. 3. **word_frequency(word: str) -> int**: - Return the frequency of the specified `word`. - If the word does not exist, return 0. 4. **top_k_words(k: int) -> list[str]**: - Return a list of the top `k` words sorted by their frequency in descending order. - If multiple words have the same frequency, return them in alphabetical order. # Constraints: - Text additions and queries might include large volumes, consider performance optimization. - The words are case-sensitive (e.g., \\"word\\" and \\"Word\\" are different). - Assume words are separated by spaces and can include punctuation. - Words for queries and additions are only alphabets (A-Z, a-z). # Example: ```python analyzer = TextAnalyzer() analyzer.add_text(\\"apple banana apple orange\\") assert analyzer.word_frequency(\\"apple\\") == 2 assert analyzer.word_frequency(\\"banana\\") == 1 assert analyzer.word_frequency(\\"mango\\") == 0 analyzer.add_text(\\"banana apple grape\\") assert analyzer.word_frequency(\\"banana\\") == 2 assert analyzer.top_k_words(2) == [\\"apple\\", \\"banana\\"] assert analyzer.top_k_words(1) == [\\"apple\\"] assert analyzer.top_k_words(4) == [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\"] ``` *Implement `TextAnalyzer` below:* ```python class TextAnalyzer: def __init__(self): # Initialize the required internal data structures pass def add_text(self, text: str) -> None: # Implement the add_text functionality pass def word_frequency(self, word: str) -> int: # Implement the word_frequency functionality pass def top_k_words(self, k: int) -> list[str]: # Implement the top_k_words functionality pass # Example usage, such implementations must be tested thoroughly. ```","solution":"import collections class TextAnalyzer: def __init__(self): self.word_count = collections.Counter() def add_text(self, text: str) -> None: words = text.split() self.word_count.update(words) def word_frequency(self, word: str) -> int: return self.word_count[word] def top_k_words(self, k: int) -> list[str]: if k <= 0: return [] sorted_words = sorted(self.word_count.items(), key=lambda x: (-x[1], x[0])) return [word for word, count in sorted_words[:k]]"},{"question":"# Data Analysis with Pandas For this assessment, you are tasked with performing a series of data analysis operations on a given dataset using Pandas. The dataset provided consists of information about various products sold in different regions. **Problem**: 1. Implement a function `load_data` that reads the dataset from a CSV file. 2. Implement a function `data_analysis` that performs the following analysis: - Calculate the total sales for each region. - Determine the product with the highest sales in each region. - Identify the region with the highest overall sales. 3. Implement a `main` function to run the entire process and display the results. # Input: 1. A CSV file `sales_data.csv` with columns: * `Region` - Region where the product is sold. * `Product` - Name of the product. * `Sales` - Amount of sales for the product. # Output: 1. A dictionary with regions as keys and total sales as values. 2. A dictionary with regions as keys and the product with the highest sales as values. 3. The name of the region with the highest overall sales. # Constraints: * Use Pandas library for data manipulation and analysis. * Ensure the calculations are accurate and handle any missing or incorrect data rationally. * Assume the dataset is not exceedingly large (fits into memory). # Example: ```python # Expected CSV file format Region,Product,Sales North,WidgetA,1000 South,WidgetB,1500 East,WidgetA,2000 West,WidgetC,2500 North,WidgetB,1200 South,WidgetC,1300 East,WidgetB,2300 West,WidgetA,2700 # Define the functions def load_data(file_path): # Load dataset from CSV file pass def data_analysis(df): # Perform data analysis pass def main(): # Run the data analysis process pass if __name__ == \\"__main__\\": main() ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the function accurately calculate the required metrics? 2. Efficiency: Is your solution optimized for given constraints? 3. Robustness: Does your solution handle edge cases gracefully?","solution":"import pandas as pd def load_data(file_path): Load dataset from CSV file. Parameters: file_path (str): The path to the CSV file. Returns: pd.DataFrame: The loaded DataFrame. return pd.read_csv(file_path) def data_analysis(df): Perform data analysis. Parameters: df (pd.DataFrame): The DataFrame containing the sales data. Returns: tuple: dict: Total sales for each region. dict: Product with the highest sales in each region. str: The region with the highest overall sales. # Calculate the total sales for each region total_sales = df.groupby(\'Region\')[\'Sales\'].sum().to_dict() # Determine the product with the highest sales in each region max_sales_product = df.loc[df.groupby([\'Region\', \'Product\'])[\'Sales\'].idxmax()] highest_sales_products = max_sales_product.groupby(\'Region\')[[\'Product\', \'Sales\']].apply(lambda x: x.set_index(\'Product\')[\'Sales\'].idxmax()).to_dict() # Identify the region with the highest overall sales highest_sales_region = max(total_sales, key=total_sales.get) return total_sales, highest_sales_products, highest_sales_region def main(): # Load the data df = load_data(\'sales_data.csv\') # Perform the data analysis total_sales, highest_sales_products, highest_sales_region = data_analysis(df) # Display the results print(\\"Total Sales by Region:\\", total_sales) print(\\"Product with Highest Sales by Region:\\", highest_sales_products) print(\\"Region with Highest Overall Sales:\\", highest_sales_region) if __name__ == \\"__main__\\": main()"},{"question":"# Question: Find All Possible Permutations Context: Your task is to implement a function that generates all possible permutations of a given list of distinct integers. A permutation is an ordered arrangement of items and you must ensure that all permutations are unique and represented exactly once. Function Signature: ```python def generate_permutations(lst: list) -> list: ``` Parameters: - `lst`: a list of distinct integers for which we need to generate all permutations. Returns: - The function returns a list of lists, where each inner list is a unique permutation of the input list. Constraints: - The input list may contain up to 8 distinct integers. - Consider edge cases like an empty list or a list with only one element. Examples: ```python # Example 1 print(generate_permutations([1, 2, 3])) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] # Example 2 print(generate_permutations([0, 1])) # Output: [[0, 1], [1, 0]] # Example 3 print(generate_permutations([1])) # Output: [[1]] # Example 4 print(generate_permutations([])) # Output: [] ``` Note: You need to implement the function without using any built-in permutation functions or libraries like `itertools.permutations`. Focus on generating all permutations using a recursive or iterative approach. The function should be efficient enough to handle the upper constraint of 8 integers. Provide a clear and clean implementation ensuring that every permutation is unique and correctly organized.","solution":"def generate_permutations(lst): Generate all possible permutations of the given list. Parameters: lst (list): a list of distinct integers Returns: list: a list of lists, where each inner list is a unique permutation of the input list if len(lst) == 0: return [] if len(lst) == 1: return [lst] perms = [] for i in range(len(lst)): current = lst[i] remaining = lst[:i] + lst[i+1:] for p in generate_permutations(remaining): perms.append([current] + p) return perms"},{"question":"# Matrix Rotation Problem Imagine you are building a tool that transforms images by rotating them, and you need to implement core logic enabling rotation of a 2D matrix (which represents the image). Your task is to write a function that rotates a given square matrix 90 degrees clockwise. **Task**: Write a function `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]` that: 1. Takes a square matrix (List of List of integers) as an input. 2. Rotates the matrix 90 degrees clockwise. 3. Returns the rotated matrix. # Function Description and Example 1. **rotate_matrix** - **Input**: - `matrix` (List[List[int]]): a square matrix of integers. - **Output**: - Returns a new matrix (List[List[int]]) rotated 90 degrees clockwise. - **Examples**: ```python from math import isclose rotated_matrix = rotate_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) assert rotated_matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotated_matrix = rotate_matrix([ [1, 2], [3, 4] ]) assert rotated_matrix == [ [3, 1], [4, 2] ] ``` **Instructions**: 1. The function should take care of both even and odd dimensions of the square matrix. 2. Ensure that the function handles edge cases like a 1x1 matrix. 3. If the input matrix is not square, a `ValueError` should be raised with the message \\"Input must be a square matrix\\". This problem helps in testing the candidate\'s understanding and manipulation of multi-dimensional arrays, matrix transformations, and ability to implement algorithms that modify 2D data structures efficiently.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates a given square matrix 90 degrees clockwise and returns the resulting matrix. Arguments: matrix (List[List[int]]): A square matrix represented as a list of lists of integers. Returns: List[List[int]]: The rotated matrix. Raises: ValueError: If the input matrix is not square. n = len(matrix) # Check if matrix is square if not all(len(row) == n for row in matrix): raise ValueError(\\"Input must be a square matrix\\") # Perform the rotation rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"# Problem Statement You have been provided with an implementation of a basic function to calculate the factorial of an integer. However, the current implementation struggles with large inputs due to its sequential and non-optimized nature. Your task is to implement an optimized version that can handle very large numbers efficiently. # Detailed Requirements 1. **Input**: - An integer `K` which represents the number for which the factorial is to be computed. 2. **Output**: - An integer which is the factorial of `K`. 3. **Constraints**: - `1 ≤ K ≤ 1000` # Algorithm Efficient Factorial Calculation: To efficiently calculate the factorial of large numbers, use iterative multiplication rather than recursion. You can also take advantage of memoization if necessary to store intermediate results for very large inputs. # Instructions: 1. Implement the `factorial(K)` function to compute the factorial of `K`. Consider using algorithms that minimize the number of multiplications or intermediate results stored. 2. Ensure your implementation manages large integer arithmetic efficiently to handle the high magnitude of values. # Performance Your implementation should handle both small and large values of `K` efficiently, providing results without excessive delay. ```python def factorial(K: int) -> int: Calculate the factorial of the given number K. :param K: The number for which the factorial is to be calculated. :return: The factorial of K. if K == 0 or K == 1: return 1 result = 1 for i in range(2, K+1): result *= i return result # Example usage print(factorial(5)) # Expected output: 120 print(factorial(10)) # Expected output: 3628800 # Testing with very large value print(factorial(1000)) # Expected: (a very large number with 2568 digits) ``` Test your function with various values of K to ensure correctness and performance across a wide range.","solution":"def factorial(K: int) -> int: Calculate the factorial of the given number K. :param K: The number for which the factorial is to be calculated. :return: The factorial of K. if K == 0 or K == 1: return 1 result = 1 for i in range(2, K + 1): result *= i return result # Example usage # factorial(5) would be 120 # factorial(10) would be 3628800 # factorial(1000) results in a very large number with 2568 digits"},{"question":"# Problem Statement You are tasked with implementing a function to find the smallest contiguous subarray whose sum is greater than or equal to a given integer `s`. Your function should optimize for time complexity. # Requirements: - Function Name: `min_subarray_len` - Inputs: - `s`: an integer, the target sum (1 ≤ `s` ≤ 10^9). - `nums`: a list of integers, representing the array (1 ≤ len(`nums`) ≤ 10^5, 1 ≤ `nums[i]` ≤ 10^4). - Output: an integer, the length of the smallest contiguous subarray with a sum greater than or equal to `s`. If no such subarray exists, return 0. # Example ```python assert min_subarray_len(7, [2, 3, 1, 2, 4, 3]) == 2 # The subarray [4, 3] has the minimum length. assert min_subarray_len(15, [1, 2, 3, 4, 5]) == 5 # The entire array sums to 15. assert min_subarray_len(100, [1, 2, 3, 4, 5]) == 0 # No subarray sums to 100. assert min_subarray_len(11, [1, 2, 3, 4, 5, 6]) == 2 # The subarray [5, 6] has the minimum length. ``` # Constraints: - Ensure your solution has a time complexity of O(n), where n is the length of the `nums` array. - Use sliding window (or two-pointer) technique to achieve optimal performance. # Notes: You might need to implement helper functions to manage the sliding window effectively and keep track of the current sum as you explore different subarrays. ```python def min_subarray_len(s: int, nums: list[int]) -> int: from sys import maxsize as inf left = 0 total = 0 min_len = inf for right in range(len(nums)): total += nums[right] while total >= s: min_len = min(min_len, right - left + 1) total -= nums[left] left += 1 return min_len if min_len != inf else 0 ```","solution":"def min_subarray_len(s: int, nums: list[int]) -> int: from sys import maxsize as inf left = 0 total = 0 min_len = inf for right in range(len(nums)): total += nums[right] while total >= s: min_len = min(min_len, right - left + 1) total -= nums[left] left += 1 return min_len if min_len != inf else 0"},{"question":"# Task Write a function `is_perfect_square(num: int) -> bool` to determine if a given number `num` is a perfect square. Your solution should: 1. Avoid the use of floating-point arithmetic. 2. Employ an efficient algorithm suitable for very large integers. # Input - An integer `num` where ( 0 leq num leq 10^{18} ). # Output - Return a boolean indicating whether `num` is a perfect square. # Constraints - Your algorithm should run in O(log(num)) time complexity. - Avoid using library functions that could trivialize the problem (e.g., math.sqrt). # Example ```python >>> is_perfect_square(16) True >>> is_perfect_square(20) False >>> is_perfect_square(1) True >>> is_perfect_square(0) True >>> is_perfect_square(1000000000000000000) True ``` # Notes - Consider implementing a binary search to efficiently determine if the number is a perfect square. - Ensure that your solution handles the edge case where `num` is zero correctly.","solution":"def is_perfect_square(num: int) -> bool: Determines if a given number `num` is a perfect square. Uses binary search to achieve efficient determination. if num < 0: return False if num == 0: return True left, right = 1, num while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == num: return True elif mid_squared < num: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Graph Shortest Path Calculation Using Dijkstra\'s Algorithm Background Dijkstra\'s algorithm is an efficient method to compute the shortest path from a single source vertex to all other vertices in a graph with non-negative edge weights. This algorithm is commonly applied in network routing, geographical mapping, and a multitude of other areas where optimal paths are crucial. Problem Statement You are required to implement the Dijkstra\'s shortest path algorithm for a graph represented with an adjacency list. Your implementation should: 1. Accept an adjacency list representation of the graph. 2. Allow specification of the source vertex from which the shortest paths will be calculated. 3. Output the shortest path distances from the source to each vertex and the actual paths taken. Requirements 1. **Function Signatures and Definitions**: - `class Graph` to represent the graph structure. - `def add_edge(u, v, weight)`: Add an edge with a specified weight between vertices `u` and `v`. - `def dijkstra(source)`: Compute shortest paths from the source vertex to all other vertices. - `@property def shortest_paths()`: Return a dictionary where the keys are vertices and the values are tuples (shortest distance, path taken). 2. **Input/Output**: - Initialize the graph with `add_edge` to add edges between vertices. - Calculate the shortest paths using `dijkstra`. - Output the shortest distances and paths using `shortest_paths`. 3. **Constraints**: - Vertices are labeled with integers starting from 0. - Weights are non-negative integers. - The graph can have up to 1000 vertices and 5000 edges. Objectives - Understand the principles of Dijkstra\'s algorithm. - Implement and test graph traversal and shortest path calculation. - Ensure efficient handling of the graph with priority queue (min-heap) for the shortest path calculation. Implement the `Graph` class with the specified functionalities and optimizations. ```python class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, u, v, weight): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append((v, weight)) self.adjacency_list[v].append((u, weight)) def dijkstra(self, source): import heapq distances = {vertex: float(\'infinity\') for vertex in self.adjacency_list} previous_vertices = {vertex: None for vertex in self.adjacency_list} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_vertices[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) self.shortest_distances = distances self.shortest_path_tree = previous_vertices @property def shortest_paths(self): paths = {} for vertex in self.shortest_distances: path = [] current_vertex = vertex while current_vertex is not None: path.append(current_vertex) current_vertex = self.shortest_path_tree[current_vertex] paths[vertex] = (self.shortest_distances[vertex], path[::-1]) return paths ``` Test the implementation with a sample graph initialization and verify the output of the shortest paths.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, u, v, weight): if u not in self.adjacency_list: self.adjacency_list[u] = [] if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[u].append((v, weight)) self.adjacency_list[v].append((u, weight)) def dijkstra(self, source): import heapq distances = {vertex: float(\'infinity\') for vertex in self.adjacency_list} previous_vertices = {vertex: None for vertex in self.adjacency_list} distances[source] = 0 priority_queue = [(0, source)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in self.adjacency_list[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance previous_vertices[neighbor] = current_vertex heapq.heappush(priority_queue, (distance, neighbor)) self.shortest_distances = distances self.shortest_path_tree = previous_vertices @property def shortest_paths(self): paths = {} for vertex in self.shortest_distances: path = [] current_vertex = vertex while current_vertex is not None: path.append(current_vertex) current_vertex = self.shortest_path_tree[current_vertex] paths[vertex] = (self.shortest_distances[vertex], path[::-1]) return paths"},{"question":"# Rotating a 2D Matrix Clockwise Write a function that rotates a given n x n 2D matrix by 90 degrees clockwise. The function should take a single parameter, the 2D matrix, and modify it in place. The function should also validate the input and raise appropriate errors when necessary. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` Input * `matrix` (list[list[int]]): A 2D list where each inner list represents a row of the matrix. All rows are of equal length, and the number of rows is equal to the number of columns (n x n matrix). Output * The function does not return anything. The matrix should be modified in place to represent the rotated version. Constraints * `1 <= n <= 1000` (where n is the number of rows/columns of the matrix) Example ```python # Example usage matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [ 5, 1, 9, 11], [ 2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(matrix2) assert matrix2 == [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Error Scenarios * If the matrix is not square (i.e., number of rows is not equal to the number of columns), raise `ValueError(\\"The matrix must be square\\")`. * If the matrix contains non-integer elements, raise `ValueError(\\"Matrix must contain only integers\\")`. Additional Notes * Modify the matrix in place as described above. * Do not use extra space for another matrix of the same size. * Ensure efficient handling of rotation for the given constraints.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates the given n x n 2D matrix by 90 degrees clockwise in place. Args: matrix (list[list[int]]): The 2D matrix to be rotated. Raises: ValueError: If the matrix is not square or contains non-integer elements. # Validate the matrix n = len(matrix) # Check if the matrix is square and contains only integers if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be square\\") if any(not all(isinstance(item, int) for item in row) for row in matrix): raise ValueError(\\"Matrix must contain only integers\\") # Perform the rotation for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp"},{"question":"# Question: Next Permutation Reformulated Context Permutations of a sequence are essential in various fields of computer science, including algorithm design, optimization, and combinatorics. Finding the next lexicographical permutation can be challenging yet useful for numerous applications. Problem Given a list of integers, rearrange the list into its next lexicographical permutation. If such permutation is not possible (i.e., the list is sorted in descending order), re-arrange it into the smallest possible order (ascending order). Tasks Write a Python function `next_permutation(nums: List[int]) -> List[int]` which rearranges the elements into their next lexicographical permutation. Input Format A list of integers `nums` of length `n`. Output Format Return the list of integers rearranged into the next permutation. Constraints * ( 1 leq n leq 10^3 ) * ( -10^4 leq nums[i] leq 10^4 ) Examples ```python >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1, 1, 5]) [1, 5, 1] >>> next_permutation([1, 3, 2]) [2, 1, 3] ``` Explanation The goal is to find the next permutation in place: 1. Identify the longest non-increasing suffix, and find the pivot. 2. Swap the pivot with the smallest element in the suffix that is greater than the pivot. 3. Reverse the suffix to get the next smallest lexicographical order. Note Aim for an efficient in-place solution with a time complexity of (O(n)).","solution":"def next_permutation(nums): Rearranges the elements into their next lexicographical permutation. If such permutation is not possible, rearrange it to the smallest possible order. # Find the first decrement element from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 # If there is no such element, reverse the whole array if i == -1: nums.reverse() return nums # Find the smallest element in the suffix that is greater than nums[i] j = len(nums) - 1 while nums[j] <= nums[i]: j -= 1 # Swap the elements nums[i], nums[j] = nums[j], nums[i] # Reverse the suffix nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"# Question: Implement Binary Search Tree with Additional Operations Context: A Binary Search Tree (BST) is a data structure that maintains sorted data in a hierarchical manner. Each node has at most two children referred to as the left child and the right child. For every node, all the nodes in the left subtree have values less than the node\'s value, and all the nodes in the right subtree have values greater than the node\'s value. Task: Extend the `BinarySearchTree` class with additional operations that are crucial for advanced tree manipulation and query. Requirements: 1. **Finding k-th Smallest Element**: Implement a method `find_kth_smallest(k: int) -> int` that returns the k-th smallest element in the BST (1-indexed). - The method should assume that the BST does not contain duplicate elements. - Implement the method efficiently, preferably in O(H) time, where H is the height of the tree. 2. **Lowest Common Ancestor (LCA)**: Implement a method `find_lca(n1: int, n2: int) -> int` that finds and returns the lowest common ancestor of the two given nodes, n1 and n2, in the BST. - The LCA of two nodes is the deepest node that has both n1 and n2 as descendants. 3. **Tree Height**: Implement a method `tree_height() -> int` to compute the height of the BST. - The height of a binary tree is the number of edges on the longest path from the root to a leaf node. Implementations: - Update the `BinarySearchTree` class to include your new methods. - Add unit tests to validate the functionality of the new methods. - Ensure the existing functionality and new functionality do not interfere. Constraints: - Assume the tree contains no duplicate values for `find_kth_smallest` and `find_lca` methods. - The values for `find_lca` method are guaranteed to exist in the tree. - The value of `k` for `find_kth_smallest` method is always valid. Here is the starter skeleton for your updated class: ```python class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def find_kth_smallest(self, k: int) -> int: Find the k-th smallest element in the BST. Args: k: The k-th position (1-indexed) to find the smallest element. Returns: The k-th smallest element in the BST. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.insert(2) >>> bst.insert(4) >>> bst.find_kth_smallest(2) 3 pass def find_lca(self, n1: int, n2: int) -> int: Find the lowest common ancestor (LCA) of two given nodes in the BST. Args: n1: The first node\'s value. n2: The second node\'s value. Returns: The value of the lowest common ancestor of the two nodes. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(2) >>> bst.insert(8) >>> bst.insert(1) >>> bst.insert(3) >>> bst.find_lca(1, 3) 2 pass def tree_height(self) -> int: Compute the height of the BST. Returns: The height of the BST. Example: >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(3) >>> bst.insert(7) >>> bst.tree_height() 1 pass ``` Input and Output Format: - The input for the `find_kth_smallest` method is an integer representing the position `k`. - The input for the `find_lca` method is two integers representing the values of the nodes `n1` and `n2`. - The `tree_height` method does not require any inputs and returns an integer representing the height of the BST. Constraints: - Your solution should handle the tree efficiently. - The methods should be demonstrable with appropriate unit tests or doctests. Good luck!","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert_recursive(self.root, key) def _insert_recursive(self, root, key): if root is None: return Node(key) else: if key < root.val: root.left = self._insert_recursive(root.left, key) else: root.right = self._insert_recursive(root.right, key) return root def find_kth_smallest(self, k: int) -> int: def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] # Perform in-order traversal and get the k-th element in the list return inorder_traversal(self.root)[k-1] def find_lca(self, n1: int, n2: int) -> int: def lca_helper(root, n1, n2): if root is None: return None if root.val > n1 and root.val > n2: return lca_helper(root.left, n1, n2) if root.val < n1 and root.val < n2: return lca_helper(root.right, n1, n2) return root lca_node = lca_helper(self.root, n1, n2) return lca_node.val if lca_node else None def tree_height(self) -> int: def height_helper(root): if root is None: return -1 left_height = height_helper(root.left) right_height = height_helper(root.right) return 1 + max(left_height, right_height) return height_helper(self.root)"},{"question":"# Context You have been assigned to develop a function that implements insertion sort, which is a simple and efficient comparison-based algorithm ideal for small datasets or nearly sorted lists. # Task Implement the `insertion_sort` function such that it sorts a list of numbers in ascending order using the Insertion Sort algorithm. This algorithm builds the final sorted array one item at a time, with the benefit of being adaptive—you can stop early for an already sorted list. # Function Signature ```python def insertion_sort(data: list) -> list: pass ``` # Input * `data` (list): A list of integers, where the size can range from 0 to 1000 elements. # Output * A list of integers sorted in ascending order. # Constraints * The elements in the list are assumed to be integers. * Ensure that your algorithm handles edge cases like empty lists and lists with one element efficiently. # Examples ```python print(insertion_sort([4, 3, 2, 10, 12, 1, 5, 6])) # Output: [1, 2, 3, 4, 5, 6, 10, 12] print(insertion_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] print(insertion_sort([1, 2, 3, 4, 5])) # Output: [1, 2, 3, 4, 5] print(insertion_sort([])) # Output: [] print(insertion_sort([1])) # Output: [1] ``` # Performance Requirements The function should handle sorting within reasonable limits for inputs up to 1000 elements, given the constraints of the Insertion Sort algorithm. # Additional Instructions * Ensure your implementation is written purely in Python and does not rely on any external libraries. * Include inline comments to document the primary steps of your algorithm. * Include basic error handling and validation within your function to manage unexpected input types gracefully.","solution":"def insertion_sort(data): Sorts a list of integers in ascending order using the Insertion Sort algorithm. Args: data (list): The list of integers to be sorted. Returns: list: A sorted list of integers. if not isinstance(data, list): raise ValueError(\\"Input should be a list.\\") for element in data: if not isinstance(element, int): raise ValueError(\\"All elements in the list should be integers.\\") n = len(data) for i in range(1, n): key = data[i] j = i - 1 # Move elements of data[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and data[j] > key: data[j + 1] = data[j] j -= 1 data[j + 1] = key return data"},{"question":"# **Question: Implement a Modular Pathfinding Algorithm for Dynamic Grids** Your task is to develop a modular pathfinding algorithm that can navigate through a dynamic 2D grid. The grid may include obstacles, and you should find the shortest path from a starting point to a target point. **Requirements:** 1. **Grid Structure**: - Implement a `Pathfinder` class. - The grid can be represented as a 2D list, where `0` represents a free cell and `1` represents an obstacle. - The path should be found using the A* algorithm. 2. **Function Implementation**: - `add_obstacle(x, y)`: Adds an obstacle at the specified grid coordinates (x, y). - `remove_obstacle(x, y)`: Removes an obstacle from the specified grid coordinates (x, y). - `set_start(x, y)`: Sets the starting point of the path. - `set_target(x, y)`: Sets the target point of the path. - `find_path()`: Finds the shortest path from the start to the target. If a path exists, return a list of coordinates representing the path; otherwise, return `None`. - `display_grid()`: Prints the current grid configuration. 3. **I/O Specifications**: - **Input**: - Grid dimensions: `n` (rows) and `m` (columns). - Obstacles: A list of tuples representing the obstacles\' coordinates. - Start and target points: Coordinates for the start and target points. - **Output**: - A list of coordinates representing the shortest path, or `None` if no path is possible. **Constraints**: - Movement is allowed in four directions: up, down, left, right. - Ensure the pathfinding function efficiently handles grids up to 100x100 in size. - No use of libraries specifically designed for pathfinding (e.g., A* libraries). # Example Usage: ```python # Initialize a 5x5 grid grid = Pathfinder(5, 5) # Add obstacles grid.add_obstacle(1, 1) grid.add_obstacle(1, 2) grid.add_obstacle(1, 3) # Set start and target points grid.set_start(0, 0) grid.set_target(4, 4) # Find and display the path path = grid.find_path() print(\\"Path:\\", path) # Display the current grid grid.display_grid() ``` In the example above, the `Pathfinder` class should correctly calculate the shortest path considering the obstacles in the grid. The modular structure ensures dynamic updates to the grid and efficient pathfinding. --- This new question aligns with the coding assessment\'s style, length, and complexity, providing a comprehensive task that assesses the candidate\'s ability to work with algorithms, data structures, and object-oriented programming in a practical context.","solution":"import heapq class Pathfinder: def __init__(self, n, m): self.n = n self.m = m self.grid = [[0 for _ in range(m)] for _ in range(n)] self.start = None self.target = None def add_obstacle(self, x, y): self.grid[x][y] = 1 def remove_obstacle(self, x, y): self.grid[x][y] = 0 def set_start(self, x, y): self.start = (x, y) def set_target(self, x, y): self.target = (x, y) def heuristic(self, a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def find_path(self): if not self.start or not self.target: return None start, target = self.start, self.target heap = [(0 + self.heuristic(start, target), 0, start)] came_from = {start: None} cost_so_far = {start: 0} directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while heap: _, cost, current = heapq.heappop(heap) if current == target: path = [] while current: path.append(current) current = came_from[current] path.reverse() return path for d in directions: next_cell = (current[0] + d[0], current[1] + d[1]) if 0 <= next_cell[0] < self.n and 0 <= next_cell[1] < self.m: if self.grid[next_cell[0]][next_cell[1]] == 0: new_cost = cost + 1 if next_cell not in cost_so_far or new_cost < cost_so_far[next_cell]: cost_so_far[next_cell] = new_cost priority = new_cost + self.heuristic(next_cell, target) heapq.heappush(heap, (priority, new_cost, next_cell)) came_from[next_cell] = current return None def display_grid(self): for row in self.grid: print(\\" \\".join(str(cell) for cell in row))"},{"question":"# Problem: Sorting Words by Length Implement a function which sorts a list of words first by their length in ascending order, and if two words have the same length, sort them lexicographically. Function Signature ```python def sort_words(words: List[str]) -> List[str]: Sorts a list of words by their length and alphabetically. Args: words (List[str]): A list of words to sort. Returns: List[str]: Sorted list of words. pass ``` Input: * **words (List[str])**: A list of words where `1 <= len(words) <= 10^5` and each word contains only lowercase English letters and has length between 1 and 100. Output: * Returns a list of strings sorted by word length, and alphabetically for words of the same length. Constraints: * Each word contains only lowercase English letters. * The sorting must be stable, meaning that words of the same length appear in the same order in which they were found in the original list for the same length words before lexicographic sorting. Context: This function is useful for certain text processing applications where both the order and the lexicographic properties of words need to be managed, such as in creating word dictionaries, auto-complete features, or preparing data for linguistic analysis. Examples: ```python >>> sort_words([\\"apple\\", \\"pear\\", \\"melon\\", \\"banana\\", \\"kiwi\\", \\"cherry\\"]) [\'kiwi\', \'pear\', \'apple\', \'melon\', \'banana\', \'cherry\'] >>> sort_words([\\"dog\\", \\"ant\\", \\"bat\\", \\"cat\\", \\"bee\\", \\"eel\\", \\"are\\", \\"elf\\"]) [\'ant\', \'are\', \'bat\', \'bee\', \'cat\', \'dog\', \'eel\', \'elf\'] ``` Notes: * When two words have the same length, they should be sorted in lexicographic (alphabetical) order. * Python\'s built-in sorted function or list\'s sort method can be used with an appropriate key function to achieve this. --- This problem tests the ability to use basic sorting algorithms and handle multi-criteria sorting effectively. It also checks the familiarity with list operations and the ability to handle different constraints in input sizes.","solution":"def sort_words(words): Sorts a list of words by their length and alphabetically. Args: words (List[str]): A list of words to sort. Returns: List[str]: Sorted list of words. return sorted(words, key=lambda word: (len(word), word))"},{"question":"# Question You are given a list of integers representing the ages of students in a class. Write two functions to: 1. Determine if the list can be classified as an arithmetic series. 2. Calculate the average age of the students in the list. Requirements - Implement the function `is_arithmetic_series(series: list) -> bool`: * This function should return `True` if the given list forms an arithmetic series, else return `False`. * An empty list or list with fewer than two elements should raise a `ValueError`. * If the input is not a list or contains non-integer elements, raise a `ValueError`. - Implement the function `average_age(series: list) -> float`: * This function should return the average age of the students in the list. * An empty list should raise a `ValueError`. * If the input is not a list or contains non-integer elements, raise a `ValueError`. Input Format * `series`: A list of integers representing the ages of students. Output Format * `is_arithmetic_series`: Return a boolean value. * `average_age`: Return a float value that is the average of the ages in the list. # Examples ```python >>> is_arithmetic_series([10, 12, 14, 16, 18]) True >>> is_arithmetic_series([10, 12, 15, 16]) False >>> is_arithmetic_series([2, 4, 8]) False >>> is_arithmetic_series([5, 7, 9, 11, 13]) True >>> average_age([18, 20, 22, 24, 26]) 22.0 >>> average_age([10, 14, 18]) 14.0 >>> average_age([30]) 30.0 >>> average_age([15, 20, 25, 30]) 22.5 ``` Constraints * The input list must contain only integers representing ages (reasonable positive values). * The functions must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. Additional Information An arithmetic series is a sequence of numbers with a constant difference between consecutive terms. Identifying arithmetic series is useful in detecting patterns and trends in datasets, including age distributions. Calculating the average age helps understand the central tendency of ages in the class.","solution":"def is_arithmetic_series(series: list) -> bool: Determines if the given list forms an arithmetic series. :param series: List of integers representing ages. :return: True if the list forms an arithmetic series, False otherwise. :raises ValueError: If the input is not valid. if not isinstance(series, list): raise ValueError(\\"Input must be a list.\\") if len(series) < 2: raise ValueError(\\"List must contain at least two elements.\\") if not all(isinstance(x, int) for x in series): raise ValueError(\\"All elements in the list must be integers.\\") common_difference = series[1] - series[0] for i in range(1, len(series)): if series[i] - series[i-1] != common_difference: return False return True def average_age(series: list) -> float: Calculates the average age of the students in the list. :param series: List of integers representing ages. :return: Float value representing the average age. :raises ValueError: If the input is not valid. if not isinstance(series, list): raise ValueError(\\"Input must be a list.\\") if len(series) == 0: raise ValueError(\\"List must not be empty.\\") if not all(isinstance(x, int) for x in series): raise ValueError(\\"All elements in the list must be integers.\\") return sum(series) / len(series)"},{"question":"# K-means Clustering and Hierarchical Clustering Implementation In this assessment, you are required to implement functions for K-means Clustering and Hierarchical Clustering. Your implementation should focus on correctly executing the core steps of each algorithm, and you should include appropriate error handling for invalid inputs. Objectives: 1. Design the function for **K-means Clustering**. 2. Design the function for **Hierarchical Clustering** with optional linkage method customization. 3. Implement error handling, including assertion errors for invalid inputs. Input * A feature matrix (numpy array) with dimensions m x n. * Number of desired clusters for K-means. * Linkage type for Hierarchical Clustering (optional, default is \'single\'). Output * Cluster labels assigned to each data point (numpy array). Constraints * The feature matrix will have at least one row and column. * Number of clusters should be less than or equal to the number of data points. * Use numpy and scipy as necessary for matrix operations. Function Signature ```python def k_means_clustering(features: np.ndarray, clusters: int) -> np.ndarray: K-means Clustering. Parameters: * features: The features extracted from the dataset * clusters: Number of clusters to form Returns: Cluster labels of the data points def hierarchical_clustering(features: np.ndarray, clusters: int, linkage: str = \'single\') -> np.ndarray: Hierarchical Clustering. Parameters: * features: The features extracted from the dataset * clusters: Number of clusters to form * linkage: Type of linkage to use (\'single\', \'complete\', \'average\', \'ward\') Returns: Cluster labels of the data points ``` Example Usage ```python import numpy as np from sklearn.datasets import load_iris # Loading sample dataset data = load_iris() features = data[\'data\'] # K-means Implementation cluster_labels_kmeans = k_means_clustering(features, 3) print(np.unique(cluster_labels_kmeans)) # Hierarchical Clustering Implementation cluster_labels_hierarchical = hierarchical_clustering(features, 3, \'average\') print(np.unique(cluster_labels_hierarchical)) ``` Notes * Ensure that you include appropriate assertion checks within your functions. * Use the provided examples for testing your functions. * Aim for clean and readable code along with documentation where necessary. * For Hierarchical Clustering, you may leverage scipy\'s linkage and fcluster functions. This question mirrors the style, complexity, and scope of the initial questions by requiring a solid understanding of clustering techniques and ensuring proper implementation practices.","solution":"import numpy as np from scipy.cluster.hierarchy import linkage, fcluster from scipy.spatial.distance import pdist from sklearn.cluster import KMeans def k_means_clustering(features: np.ndarray, clusters: int) -> np.ndarray: K-means Clustering. Parameters: * features: The features extracted from the dataset * clusters: Number of clusters to form Returns: Cluster labels of the data points Raises: ValueError: If clusters is less than 1 or more than the number of data points if clusters < 1 or clusters > features.shape[0]: raise ValueError(\\"Number of clusters must be between 1 and the number of data points\\") kmeans = KMeans(n_clusters=clusters, random_state=0) kmeans.fit(features) return kmeans.labels_ def hierarchical_clustering(features: np.ndarray, clusters: int, linkage_method: str = \'single\') -> np.ndarray: Hierarchical Clustering. Parameters: * features: The features extracted from the dataset * clusters: Number of clusters to form * linkage_method: Type of linkage to use (\'single\', \'complete\', \'average\', \'ward\') Returns: Cluster labels of the data points Raises: ValueError: If clusters is less than 1 or more than the number of data points If linkage_method is not a valid option if clusters < 1 or clusters > features.shape[0]: raise ValueError(\\"Number of clusters must be between 1 and the number of data points\\") if linkage_method not in [\'single\', \'complete\', \'average\', \'ward\']: raise ValueError(\\"Linkage method must be one of \'single\', \'complete\', \'average\', \'ward\'\\") Z = linkage(features, method=linkage_method) return fcluster(Z, t=clusters, criterion=\'maxclust\')"},{"question":"# Problem Statement You are given a list of tuples, where each tuple contains an event\'s start and end time, both represented as strings in \\"HH:MM\\" format (24-hour clock). Your task is to implement a function `find_max_overlap` to determine the maximum number of events overlapping at any time. # Function Definition ```python def find_max_overlap(events: list) -> int: :param events: List of tuples, where each tuple (start, end) represents an event\'s start and end time. :return: Maximum number of overlapping events at any time. ``` # Input * `events` is a list of tuples, where each tuple contains two strings `start` and `end` (1 ≤ len(events) ≤ 10^5). - `start` is the start time in \\"HH:MM\\" format. - `end` is the end time in \\"HH:MM\\" format. # Output * Return the maximum number of events that are overlapping at any single point in time. # Constraints * Events start and end on the same day. * An event starts at a given time and ends at a given time. * `start` and `end` times conform to the \\"HH:MM\\" format (00:00 to 23:59). # Example Example 1: ```python events = [(\\"09:00\\", \\"10:30\\"), (\\"09:15\\", \\"11:00\\"), (\\"10:00\\", \\"10:45\\")] # Output: 3 ``` Example 2: ```python events = [(\\"09:00\\", \\"10:00\\"), (\\"10:00\\", \\"11:00\\"), (\\"09:30\\", \\"10:30\\")] # Output: 2 ``` # Note * You may assume that the input times are well-formed and valid. * Overlapping events mean that there is at least a one-minute interval that is common between events. * Ensure the function is optimized for large inputs.","solution":"def find_max_overlap(events): from collections import Counter def to_minutes(time_str): h, m = map(int, time_str.split(\':\')) return h * 60 + m timeline = [] for start, end in events: start_minutes = to_minutes(start) end_minutes = to_minutes(end) timeline.append((start_minutes, \'start\')) timeline.append((end_minutes, \'end\')) timeline.sort() overlap = 0 current_overlap = 0 for time, event_type in timeline: if event_type == \'start\': current_overlap += 1 overlap = max(overlap, current_overlap) else: current_overlap -= 1 return overlap"},{"question":"# Coding Assessment Question **Problem Statement:** You are given a grid of characters and a list of words. The task is to find all words from the list that can be constructed in the grid following the rules of Boggle: a word can be formed by sequentially adjacent letters, where \\"adjacent\\" letters are horizontal, vertical, or diagonal neighbors. Each letter must be used exactly once in forming the word, and a letter\'s position can only be used once per word. Write a function `find_words_in_grid(grid: List[List[str]], words: List[str]) -> List[str]` that takes a 2D grid of characters and a list of words, and returns the list of words that can be formed in the grid according to the described rules. Function Signature: ```python def find_words_in_grid(grid: List[List[str]], words: List[str]) -> List[str]: ``` # Inputs * `grid` (List[List[str]]): A 2D list of characters representing the grid (1 ≤ len(grid) ≤ 100, 1 ≤ len(grid[0]) ≤ 100). * `words` (List[str]): A list of words to search for (1 ≤ len(words) ≤ 500, 1 ≤ len(word) ≤ 20 for each word). # Outputs * Returns a list of strings representing the words found in the grid. # Example ```python grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] words = [\\"ABCCED\\", \\"SEE\\", \\"ABCB\\"] assert find_words_in_grid(grid, words) == [\\"ABCCED\\", \\"SEE\\"] ``` # Constraints * Each word in the list can be formed using the rules described. * A character in the grid can only be used once per word, i.e., the same cell cannot be reused. * Words may be found more than once in the grid, but should be returned only once in the final list. # Guidance 1. **DFS/BFS Search**: Utilize Depth-First Search or Breadth-First Search techniques to explore valid letter combinations in the grid. 2. **Word Dictionary**: Consider using a trie or prefix tree for efficient word search and validation. 3. **Grid Traversal**: Ensure all starting points and directions (horizontal, vertical, diagonal) are covered in searching for words. 4. **Optimization**: Given constraints, ensure performance optimizations to handle up to maximum input sizes efficiently. # Performance Requirements The function must handle the maximum input sizes (100x100 grid and 500 words) within a reasonable time frame, ensuring efficient handling of grid search and word validation.","solution":"from typing import List def find_words_in_grid(grid: List[List[str]], words: List[str]) -> List[str]: def dfs(board, word, i, j, k): if k == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]: return False tmp, board[i][j] = board[i][j], \'#\' found = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1) or dfs(board, word, i+1, j+1, k+1) or dfs(board, word, i+1, j-1, k+1) or dfs(board, word, i-1, j+1, k+1) or dfs(board, word, i-1, j-1, k+1) board[i][j] = tmp return found def exist(board, word): for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False result = [] for word in words: if exist(grid, word): result.append(word) return result"},{"question":"# Question You are tasked with developing a seating arrangement system for a wedding reception. Each table must seat a specific number of guests, and the guests have preferences on who they prefer to sit with. Your goal is to implement a function that assigns guests to tables such that the resulting seating arrangements are stable — that is, no guest would prefer to switch tables to be closer to more friends if that causes any other guest to be less happy. Function Specification ```python def stable_seating(tables: list[int], guest_pref: list[list[int]]) -> list[list[int]]: Finds a stable seating arrangement for wedding tables. The function accepts the tables (which provide the maximum number of guests at each table) and the preferences of each guest. It returns a list of lists where each inner list represents the guests assigned to a particular table. ``` # Input * `tables`: A list of integers representing the capacity of each table. The value `tables[i]` denotes the number of guests the i-th table can accommodate. * `guest_pref`: A list of lists representing the preference rankings of each guest. `guest_pref[i]` is the list containing the preferences of the i-th guest in order of priority. # Output * A list of lists, where each inner list contains the guests assigned to a particular table such that no guest would be happier by switching to a different table, disrupting others\' preferences. # Constraints * `1 ≤ m ≤ 100` - The number of tables is constrained between 1 and 100. * `1 ≤ c ≤ 10` - Each table can seat between 1 and 10 guests. * `c ≤ n ≤ 1000` - The number of guests `n` is such that the sum of capacities in `tables` equals `n`. The total number of guests matches the total number of seats available across all tables. * `guest_pref[i]` list contains unique integers from `0` to `n-1` (excluding `i`). # Example ```python tables = [3, 3, 4] guest_pref = [ [1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 3, 4, 5, 6, 7, 8, 9], [0, 1, 2, 4, 5, 6, 7, 8, 9], [0, 1, 2, 3, 5, 6, 7, 8, 9], [0, 1, 2, 3, 4, 6, 7, 8, 9], [0, 1, 2, 3, 4, 5, 7, 8, 9], [0, 1, 2, 3, 4, 5, 6, 8, 9], [0, 1, 2, 3, 4, 5, 6, 7, 9], [0, 1, 2, 3, 4, 5, 6, 7, 8] ] print(stable_seating(tables, guest_pref)) # Possible Output: [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]] ``` # Performance Requirements Your implementation should aim for an efficient solution given the constraints, ideally operating within O(n^2) time complexity to handle the upper limit of inputs efficiently. Explanation: In the example given: 1. The tables are set to accommodate [3, 3, 4] guests respectively. 2. Each guest lists their preferences for seating with other guests. 3. The output should ensure that no guest would prefer to change tables if it would cause any disturbance to the current seating arrangements. The seating arrangement should be such that it is stable, considering all guests\' preference lists.","solution":"def stable_seating(tables, guest_pref): Finds a stable seating arrangement for wedding tables. The function accepts the tables (which provide the maximum number of guests at each table) and the preferences of each guest. It returns a list of lists where each inner list represents the guests assigned to a particular table. # Number of guests n = sum(tables) # Assignments of guests to tables assignments = [[] for _ in tables] # Current index for filling guests in assignments current_idx = 0 # For simplicity, consider stable assignment by round-robin filling based on their preferences guest_assigned = [-1] * n # -1 means not yet assigned to any table for guest in range(n): for preferred_guest in guest_pref[guest]: if len(assignments[current_idx]) < tables[current_idx] and guest_assigned[preferred_guest] == -1: assignments[current_idx].append(guest) guest_assigned[guest] = current_idx break current_idx = (current_idx + 1) % len(tables) # Handling unassigned guests due to insufficient preference matching for guest in range(n): if guest_assigned[guest] == -1: for table_idx in range(len(tables)): if len(assignments[table_idx]) < tables[table_idx]: assignments[table_idx].append(guest) guest_assigned[guest] = table_idx break return assignments"},{"question":"# Question: Efficient Fibonacci Computation Context: In competitive programming, the computation of large Fibonacci numbers can often be a challenge due to the exponential growth of numbers in the Fibonacci sequence. A well-optimized approach is necessary to handle large inputs efficiently. Problem Statement: Write a function `efficient_fibonacci(n: int) -> int` that computes the nth Fibonacci number using matrix exponentiation for efficient computation. Function Signature: ```python def efficient_fibonacci(n: int) -> int: ``` Input: - An integer `n` (1 <= n <= 10^9) Output: - An integer representing the nth Fibonacci number. Constraints: - The function should handle large values of `n` up to 1,000,000,000 efficiently. - Use of Python\'s built-in arbitrary-precision integer type to avoid overflow issues. Example: ```python print(efficient_fibonacci(10)) # Output: 55 print(efficient_fibonacci(50)) # Output: 12586269025 print(efficient_fibonacci(100)) # Output: 354224848179261915075 ``` Explanation: For `n = 10`: - The Fibonacci sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55. Hence, the 10th Fibonacci number is `55`. **Your task** is to implement the function `efficient_fibonacci` using matrix exponentiation to ensure the computation is performed in logarithmic time complexity in terms of `n`.","solution":"def efficient_fibonacci(n: int) -> int: Computes the nth Fibonacci number using matrix exponentiation. if n <= 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): Multiplies two 2x2 matrices A and B. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, power): Raises a 2x2 matrix to the power using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power > 0: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"# Find the Kth Largest Element Context In competitive programming, being able to quickly find the Kth largest element in a dataset is a common and crucial skill. This is especially important because it can help in ranking winners, determining thresholds, and more. Task Implement a function `find_kth_largest` that returns the Kth largest element from a given list of integers. Function Signature ```python def find_kth_largest(nums: list, k: int) -> int: pass ``` Input Format - `nums`: A list of integers where the length of the list is between 1 and (10^5), and each integer is within the range ([-10^6, 10^6]). - `k`: An integer, (1 leq k leq) length of `nums`, representing the Kth position. Output Format - Returns the Kth largest integer from the list. Constraints - You may assume all elements in the list are distinct. - The list length is at most 10^5. Examples ```python print(find_kth_largest([3, 2, 1, 5, 6, 4], 2)) # Output: 5 print(find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4)) # Output: 4 print(find_kth_largest([1], 1)) # Output: 1 ``` # Points to Consider - **Edge cases**: Ensure your implementation handles edge cases such as the smallest and largest possible lists, and all numbers being either very high or very low. - **Efficiency**: Optimize your solution to ensure it runs efficiently even for the largest input sizes. - **Different Algorithms**: Consider and experiment with different algorithms such as sorting, using a min-heap, or quickselect to determine the most efficient approach. Note Include appropriate comments in your code and validate your solution with a variety of test cases to ensure correctness and performance.","solution":"def find_kth_largest(nums: list, k: int) -> int: Returns the Kth largest element in the list. :param nums: List of integers. :param k: The Kth position. :return: The Kth largest integer from the list. import heapq # Creating a min-heap of the first k elements heap = nums[:k] heapq.heapify(heap) # Traverse through the rest of the elements for num in nums[k:]: if num > heap[0]: heapq.heappop(heap) heapq.heappush(heap, num) # The root of the heap is the Kth largest element return heap[0]"},{"question":"# Problem Statement Write a function `combine_and_sort` that takes two lists of integers and returns one combined list with all the integers in ascending order. The original lists must remain unmodified. # Function Signature ```python def combine_and_sort(list1: list, list2: list) -> list: ``` # Input * `list1` (list): A list of integers. * `list2` (list): Another list of integers. # Output * Returns a new list containing all the integers from `list1` and `list2`, sorted in ascending order. # Constraints * The input lists can be of any length, including empty. * The integers in the lists will be within the range [-10^6, 10^6]. * The output list should be a completely new list, not a reference to the original list. # Examples ```python print(combine_and_sort([1, 4, 3], [9, 7, 2])) # [1, 2, 3, 4, 7, 9] print(combine_and_sort([5, 2, 1], [3, 6, 8])) # [1, 2, 3, 5, 6, 8] print(combine_and_sort([], [3, 2, 5])) # [2, 3, 5] print(combine_and_sort([4, 6], [])) # [4, 6] print(combine_and_sort([], [])) # [] ``` # Explanation of Examples 1. `[1, 4, 3]` and `[9, 7, 2]` are combined to produce `[1, 2, 3, 4, 7, 9]`. 2. `[5, 2, 1]` and `[3, 6, 8]` are combined to produce `[1, 2, 3, 5, 6, 8]`. 3. An empty list combined with `[3, 2, 5]` yields `[2, 3, 5]`. 4. `[4, 6]` combined with an empty list yields `[4, 6]`. 5. Two empty lists combined yield an empty list `[]`. # Instructions * Implement the function `combine_and_sort`. * Your solution should handle all mentioned constraints and edge cases. * Ensure that the original lists remain unmodified.","solution":"def combine_and_sort(list1, list2): Combines two lists of integers and returns a new list containing all integers in ascending order. The original lists remain unmodified. # Combine both lists combined_list = list1 + list2 # Sort the combined list combined_list.sort() # Return the sorted list return combined_list"},{"question":"# Binary Search and Sorted Arrays Context: You are given a list of sorted integers and a target integer. Your task is to implement a function that finds the index of the target integer in the list using binary search. If the target is not found in the list, the function should return the index where it would be if it were inserted in order, maintaining the list\'s sorted order. Function Signature: ```python def search_insert_position(nums: list[int], target: int) -> int: pass ``` Input: - A list of sorted integers `nums`. - An integer `target`. Output: - An integer representing the index of the `target` in the list if found; otherwise, the index where the `target` should be inserted to maintain the sort order. Constraints: - The list `nums` can have a length from 0 to 10^5. - The integers in `nums` can be between -10^4 and 10^4. - The `target` integer can be between -10^4 and 10^4. Example: ```python nums = [1, 3, 5, 6] target = 5 print(search_insert_position(nums, target)) # Output: 2 nums = [1, 3, 5, 6] target = 2 print(search_insert_position(nums, target)) # Output: 1 nums = [1, 3, 5, 6] target = 7 print(search_insert_position(nums, target)) # Output: 4 nums = [1, 3, 5, 6] target = 0 print(search_insert_position(nums, target)) # Output: 0 ``` # Description: In the above example: - For the list `[1, 3, 5, 6]` and `target` 5, the function returns `2` because the target is found at index `2`. - For the same list and `target` 2, the function returns `1` because the target 2 would be inserted at index `1` to maintain the sorted order. - For `target` 7, the function returns `4` as it would be inserted at the end of the list. - For `target` 0, the function returns `0` because the target would be inserted at the beginning of the list. # Requirements: - Implement the function `search_insert_position` using binary search for an efficient solution. - The solution should have a time complexity of O(log n).","solution":"def search_insert_position(nums: list[int], target: int) -> int: Uses binary search to find the index of the target in the list. If the target is not found, returns the index where it should be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"# Scenario: You are responsible for designing a feature of a text editor that counts the frequency of each word in a given block of text. This feature needs to handle punctuation and ignore case differences. The function must return the words in a case-insensitive manner and sorted by their frequency in descending order. In the case of ties, sort the words alphabetically. # Problem Statement: Create a function that takes a string of text and returns a list of tuples. Each tuple contains a word and its frequency from the given text. The words should be returned in lowercase and sorted first by frequency (highest to lowest) and then alphabetically in the case of ties. # Function Signature: ```python def word_frequency(text: str) -> List[Tuple[str, int]]: ``` # Input: * `text`: A string of length `n` containing words and punctuation. Punctuation marks are considered as part of word boundaries. # Output: * Returns a List of tuples, where each tuple contains a word in lowercase and its frequency in the text. # Constraints: * 1 <= n <= 10^5 # Example: ```python assert word_frequency(\\"To be, or not to be, that is the question.\\") == [(\'be\', 2), (\'is\', 1), (\'not\', 1), (\'or\', 1), (\'question\', 1), (\'that\', 1), (\'the\', 1), (\'to\', 2)] assert word_frequency(\\"Hello, world! Hello!\\") == [(\'hello\', 2), (\'world\', 1)] assert word_frequency(\\"A man, a plan, a canal, Panama.\\") == [(\'a\', 3), (\'canal\', 1), (\'man\', 1), (\'panama\', 1), (\'plan\', 1)] assert word_frequency(\\"\\") == [] ``` # Additional Instructions: * The function must handle punctuation by stripping them out before counting word occurrences. * The function should be able to handle large texts efficiently. * The returned list should be sorted according to the specified rules: by frequency first and then alphabetically by the words.","solution":"from typing import List, Tuple import re from collections import Counter def word_frequency(text: str) -> List[Tuple[str, int]]: # Tokenize the text words = re.findall(r\'bw+b\', text.lower()) # Count frequency of each word freq = Counter(words) # Sort by frequency and alphabetically sorted_freq = sorted(freq.items(), key=lambda x: (-x[1], x[0])) return sorted_freq"},{"question":"# Problem Statement You are required to implement a function that balances a binary search tree. The function will take a binary search tree (BST) as input and return a balanced binary search tree. Input - A binary search tree `root`, represented by a tree node class `TreeNode`. Output - The root node of the balanced binary search tree. Function Signature ```python def balance_bst(root: TreeNode) -> TreeNode: # Implementation here ``` TreeNode Class Definition ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Constraints 1. The number of nodes in the tree will be between `1` and `10^4`. 2. The value of each node is an integer in the range `-10^5` to `10^5`. 3. The input tree may be unbalanced. # Example Input ``` 1 2 3 4 5 ``` Output ``` 3 / 2 5 / / 1 4 ``` # Additional Information To balance a binary search tree: 1. Perform an in-order traversal to collect the nodes of the tree in a sorted list. 2. Use the sorted list to reconstruct the balanced binary search tree by choosing the middle element as the root, and recursively doing the same for the left and right subtrees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: # Helper function to perform in-order traversal and collect nodes def inorder_traversal(node): if not node: return [] return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Helper function to build a balanced BST from sorted values def sorted_list_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_list_to_bst(nums[:mid]) node.right = sorted_list_to_bst(nums[mid+1:]) return node sorted_values = inorder_traversal(root) return sorted_list_to_bst(sorted_values)"},{"question":"# Problem Statement You are tasked with implementing a **string pattern search** algorithm, specifically the **Knuth-Morris-Pratt (KMP) pattern matching** algorithm. This method efficiently searches for occurrences of a \\"pattern\\" string within a \\"text\\" string. Your function should return the starting indices of all occurrences of the pattern within the text. # Requirements Write a function `knuth_morris_pratt(text, pattern)` that utilizes the KMP algorithm to find all occurrences of the `pattern` string within the `text` string. Function Signature ```python def knuth_morris_pratt(text, pattern): pass ``` Expected Input and Output - **Input**: - `text`: A non-empty string within which to search for the `pattern`. - `pattern`: A non-empty string pattern to search for in the `text`. - **Output**: - Returns a list of integers indicating the starting indices of all occurrences of `pattern` in `text`. Example ```python text = \\"ababcabcabababd\\" pattern = \\"ababd\\" result = knuth_morris_pratt(text, pattern) print(result) # Output should be [10] text = \\"aabaabaaa\\" pattern = \\"aabaa\\" result = knuth_morris_pratt(text, pattern) print(result) # Output should be [0, 3] ``` Constraints 1. Both `text` and `pattern` are non-empty strings consisting of lowercase English letters. 2. The length of `pattern` is less than or equal to the length of `text`. # Notes - The KMP algorithm consists of two main parts: building the Partial Match Table (also known as the \\"longest prefix suffix\\" or LPS array) and using this table to perform efficient pattern searching. - Ensure that your function handles cases where the pattern does not occur in the text. - Your function should perform efficiently even for larger sizes of `text`. - Consider edge cases such as very large texts and patterns, or when `pattern` occurs at the very beginning or end of `text`.","solution":"def knuth_morris_pratt(text, pattern): Returns the starting indices of all occurrences of the pattern within the text using KMP algorithm. if not text or not pattern: return [] # Helper function to build the LPS (longest prefix suffix) array. def build_lps(pattern): lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = build_lps(pattern) result = [] i = j = 0 while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Coding Assessment Question Context You are tasked with developing a small utility as part of a data processing library. The utility involves manipulating and formatting dates. Specifically, you need to implement a function to convert dates from one string format to another. Problem Statement **Task**: Implement a `convert_date_format` function in Python that converts a date from the format `YYYY-MM-DD` to `DD.MM.YYYY` and vice versa, depending on the input format. The function should automatically detect the input format and convert it to the other format. * **Function Specifications**: - **Function**: `convert_date_format` - **Input**: A single string (`date_str`) representing a date in the format `YYYY-MM-DD` or `DD.MM.YYYY`. - **Output**: A single string representing the date in the converted format. * **Constraints**: - The input string will always be a valid date in one of the specified formats. - The function should raise a `ValueError` if the input format is not recognized. - You must use regular expressions to validate and parse the date formats. * **Performance Requirements**: - The solution should operate in O(1) time complexity for format conversions. Example Usage ```python import re def convert_date_format(date_str: str) -> str: # Implement function to convert date format >>> convert_date_format(\'2023-05-17\') \'17.05.2023\' >>> convert_date_format(\'17.05.2023\') \'2023-05-17\' >>> convert_date_format(\'2023/05/17\') Traceback (most recent call last): ... ValueError: Unrecognized date format # Your program should be able to execute the following if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Note**: Ensure your solution passes the provided doctest cases without modifications and adheres to the constraints and specifications listed.","solution":"import re def convert_date_format(date_str: str) -> str: Convert date from YYYY-MM-DD to DD.MM.YYYY and vice versa. :param date_str: str: Date string in either \'YYYY-MM-DD\' or \'DD.MM.YYYY\' format. :return: str: Date string in the converted format. :raises ValueError: If the input date format is unrecognized. >>> convert_date_format(\'2023-05-17\') \'17.05.2023\' >>> convert_date_format(\'17.05.2023\') \'2023-05-17\' >>> convert_date_format(\'2023/05/17\') Traceback (most recent call last): ... ValueError: Unrecognized date format # Regex patterns for date formats pattern_yyyy_mm_dd = re.compile(r\'^d{4}-d{2}-d{2}\') pattern_dd_mm_yyyy = re.compile(r\'^d{2}.d{2}.d{4}\') # Match the input date string with regex patterns and convert accordingly if pattern_yyyy_mm_dd.match(date_str): parts = date_str.split(\'-\') return f\\"{parts[2]}.{parts[1]}.{parts[0]}\\" elif pattern_dd_mm_yyyy.match(date_str): parts = date_str.split(\'.\') return f\\"{parts[2]}-{parts[1]}-{parts[0]}\\" else: raise ValueError(\\"Unrecognized date format\\")"},{"question":"You are given a list of non-negative integers representing a set of blocks, where each integer indicates the height of a block. Your task is to implement a function `trap_rainwater(blocks: list) -> int` that computes the total amount of rainwater that can be trapped between the blocks after it rains. # Function Signature ```python def trap_rainwater(blocks: list) -> int: pass ``` # Input * `blocks`: A list of non-negative integers representing the heights of the blocks. # Output * An integer denoting the total amount of rainwater trapped between the blocks. # Constraints * The length of the input list will be at least 1. * Values in the list are non-negative integers. # Example Example 1 Input: ```python blocks = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] ``` Output: `6` Explanation: The water trapped is - 1 unit between block 1 and 3 - 1 unit between block 5 and 7 - 4 units between block 7 and 11 Example 2 Input: ```python blocks = [4, 2, 0, 3, 2, 5] ``` Output: `9` Explanation: The water trapped is - 2 units between block 0 and 3 - 1 unit between block 3 and 5 - 6 units between block 0 and 5 # Additional Notes * Return `0` if the list is empty or contains only one block. * Optimize your solution to minimize time complexity and space usage. Testing Ensure your function passes the provided examples and considers edge cases.","solution":"def trap_rainwater(blocks): Computes the total amount of rainwater that can be trapped between the blocks after it rains. :param blocks: List of non-negative integers representing the heights of the blocks. :return: Integer denoting the total amount of rainwater trapped. if not blocks or len(blocks) < 3: return 0 n = len(blocks) left_max = [0] * n right_max = [0] * n left_max[0] = blocks[0] for i in range(1, n): left_max[i] = max(left_max[i-1], blocks[i]) right_max[n-1] = blocks[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], blocks[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - blocks[i] return total_water"},{"question":"# Problem Statement You are given a list of integers representing a series of tasks, where each task has an associated duration. Additionally, you are given a positive integer `T` which signifies the maximum duration you can spend on these tasks in a single session. Your task is to implement a Python function to partition tasks into separate sessions, such that the total duration of tasks in each session does not exceed `T`. # Function Signature ```python def partition_tasks(tasks: list, T: int) -> list: Partitions a list of task durations into sessions, each not exceeding total duration `T`. Parameters: tasks (list): A list of integers representing task durations. T (int): The maximum duration allowed for each session. Returns: list: A nested list, where each inner list contains the tasks for a single session. Raises: ValueError: If any task duration exceeds `T`. ``` # Requirements - Ensure that each task\'s duration does not exceed `T`. Raise a `ValueError` if this condition is violated. - Partition the tasks such that the total duration of tasks in each session does not exceed `T`. # Example ```python tasks = [2, 3, 4, 5, 1, 6, 3] T = 7 print(partition_tasks(tasks, T)) # Example output: [[2, 3], [4], [5, 1], [6], [3]] tasks = [8, 2, 3, 5] T = 10 print(partition_tasks(tasks, T)) # Example output: ValueError ``` # Constraints - The length of the list `tasks` will be between 1 and 10^5. - Task durations will be positive integers not exceeding 10^4. - Maximum duration `T` will be a positive integer not exceeding 10^5. # Hints - Consider using a greedy algorithm to help partition tasks optimally. - Iterate through the tasks and keep a running total of the current session\'s duration, starting a new session as needed.","solution":"def partition_tasks(tasks: list, T: int) -> list: Partitions a list of task durations into sessions, each not exceeding total duration `T`. Parameters: tasks (list): A list of integers representing task durations. T (int): The maximum duration allowed for each session. Returns: list: A nested list, where each inner list contains the tasks for a single session. Raises: ValueError: If any task duration exceeds `T`. sessions = [] current_session = [] current_duration = 0 for task in tasks: if task > T: raise ValueError(\\"Task duration cannot exceed T\\") if current_duration + task <= T: current_session.append(task) current_duration += task else: sessions.append(current_session) current_session = [task] current_duration = task if current_session: sessions.append(current_session) return sessions"},{"question":"# Problem Statement Implement a function to simulate a basic `queue` data structure using two stacks, providing the necessary functionalities to enqueue (push) and dequeue (pop) elements from the queue. The queue should follow the First-In-First-Out (FIFO) principle. **Function 1: `enqueue`** - **Input**: An `int` object `element`. - **Output**: None. This function should insert the `element` into the queue. **Function 2: `dequeue`** - **Input**: None. - **Output**: An `int` object representing the element at the front of the queue. - **Constraints**: - If the queue is empty, the function should raise an `IndexError` with the message \\"Queue is empty\\". # Example ```python class QueueUsingStacks: def __init__(self): \'\'\' Initializes the two stacks required for implementing the queue. \'\'\' self.stack1 = [] self.stack2 = [] def enqueue(self, element: int) -> None: \'\'\' This function adds an element to the queue. \'\'\' pass # TODO: Write the implementation here def dequeue(self) -> int: \'\'\' This function removes the first element from the queue. \'\'\' pass # TODO: Write the implementation here # Test Cases q = QueueUsingStacks() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 assert q.dequeue() == 2 q.enqueue(4) assert q.dequeue() == 3 assert q.dequeue() == 4 try: q.dequeue() except IndexError as e: assert str(e) == \'Queue is empty.\' ``` **Additional Note**: - Ensure your solution appropriately handles edge cases such as empty queues and large number of enqueues/dequeues. - The implementation should clearly demonstrate the usage of two stacks to mimic the behavior of a queue. - Ensure the time complexity for both `enqueue` and `dequeue` operations is within acceptable limits for queue operations using two stacks.","solution":"class QueueUsingStacks: def __init__(self): Initializes the two stacks required for implementing the queue. self.stack1 = [] self.stack2 = [] def enqueue(self, element: int) -> None: This function adds an element to the queue. self.stack1.append(element) def dequeue(self) -> int: This function removes the first element from the queue. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: raise IndexError(\\"Queue is empty\\") return self.stack2.pop()"},{"question":"# Context You are a software engineer tasked with implementing a specialized data structure that not only supports typical heap operations but also allows for efficient access, insertion, and deletion of elements at arbitrary positions. For this, you need to utilize a combination of a binary heap and a hash table for optimized operations. # Problem Statement Implement a **CustomHeap** class that supports heap operations (`push`, `pop`, `peek`) while also providing efficient access to elements by value and position. Your class should leverage both a binary heap for efficient priority queue operations and a hash table for fast access and updates. # Function Requirements 1. **Initializer**: `__init__(self, data: list[int] | None = None) -> None` - Initialize the heap with an optional list of integer values. 2. **Push**: `push(self, value: int) -> None` - Insert a value into the heap. - Time Complexity: (O(log n)) 3. **Pop**: `pop(self) -> int` - Remove and return the smallest value from the heap. - Time Complexity: (O(log n)) 4. **Peek**: `peek(self) -> int` - Return the smallest value from the heap without removing it. - Time Complexity: (O(1)) 5. **Contains**: `contains(self, value: int) -> bool` - Check if a value exists in the heap. - Time Complexity: (O(1)) 6. **Remove**: `remove(self, value: int) -> None` - Remove a specific value from the heap, if it exists. - Time Complexity: (O(log n)) 7. **Replace**: `replace(self, old_value: int, new_value: int) -> None` - Replace an old value with a new value in the heap. - Time Complexity: (O(log n)) # Input Format - Inputs differ for each function and are described above where applicable. # Output Format - Outputs should match the function descriptions mentioned above. # Constraints - You may assume that the elements in the heap will be integers. - No duplicate values will be pushed into the heap. - All values in the heap will be within the range ([-10^9, 10^9]). # Example ```python # Initializing the heap with a list of values heap = CustomHeap([5, 3, 8, 1]) # Pushing a new value into the heap heap.push(4) # Heap now represents [1, 3, 8, 5, 4] # Popping the smallest value from the heap print(heap.pop()) # Outputs 1, heap now represents [3, 4, 8, 5] # Peeking the smallest value without removing it print(heap.peek()) # Outputs 3 # Checking if a value exists in the heap print(heap.contains(4)) # Outputs True # Removing a specific value from the heap heap.remove(4) # Heap now represents [3, 5, 8] # Replacing an old value with a new value in the heap heap.replace(5, 2) # Heap now represents [2, 3, 8] ``` By following these guidelines, this new question should seamlessly fit into the existing set, offering a similar level of complexity and topic relevance.","solution":"import heapq class CustomHeap: def __init__(self, data=None): Initialize the heap with an optional list of integers. if data is None: self.heap = [] self.position_map = {} else: self.heap = data[:] self.position_map = {value: i for i, value in enumerate(self.heap)} heapq.heapify(self.heap) # Update position_map after heapifying for i, value in enumerate(self.heap): self.position_map[value] = i def push(self, value): Insert a value into the heap. heapq.heappush(self.heap, value) self.position_map[value] = len(self.heap) - 1 def pop(self): Remove and return the smallest value from the heap. smallest = heapq.heappop(self.heap) del self.position_map[smallest] return smallest def peek(self): Return the smallest value from the heap without removing it. return self.heap[0] def contains(self, value): Check if a value exists in the heap. return value in self.position_map def remove(self, value): Remove a specific value from the heap, if it exists. if value in self.position_map: index = self.position_map[value] last_element = self.heap.pop() if index < len(self.heap): self.heap[index] = last_element self.position_map[last_element] = index # Rebalance the heap at index heapq._siftup(self.heap, index) heapq._siftdown(self.heap, 0, index) del self.position_map[value] def replace(self, old_value, new_value): Replace an old value with a new value in the heap. self.remove(old_value) self.push(new_value)"},{"question":"# Coding Assessment Question **Objective**: Assess students\' ability to manipulate data structures and apply concepts of balanced binary search trees. **Background**: Balanced binary search trees (BST) are crucial in numerous applications due to their ability to maintain sorted data and allow fast updates and queries. In a balanced BST, operations such as insertion, deletion, and lookup can run in O(log n) time. Your task is to implement a basic version of a balanced binary search tree and provide functionality for insertion and validation. **Task**: 1. **Class Implementation**: Create a class `BalancedBST` that supports the following operations: - `insert(value: int)`: Inserts a value into the BST while maintaining balance. - `is_balanced() -> bool`: Returns `True` if the BST is balanced, otherwise returns `False`. 2. **Balance Check**: - Ensure that the tree supports height-balanced property, i.e., for each node, the heights of the left and right subtrees differ by at most 1. 3. **Edge Cases**: Consider edge cases such as: - Inserting duplicate values. - Checking balance on an empty tree. **Input/Output**: - The `insert` method should not return any value. - The `is_balanced` method should return a boolean indicating whether the tree is balanced. **Performance Requirements**: - Your solution should efficiently maintain the balance during insertion operations. # Example ```python class BalancedBST: def __init__(self): pass def insert(self, value: int): pass def is_balanced(self) -> bool: pass # Example Usage tree = BalancedBST() tree.insert(10) tree.insert(5) tree.insert(20) tree.insert(1) tree.insert(6) tree.insert(15) tree.insert(25) assert tree.is_balanced() == True tree.insert(30) tree.insert(35) assert tree.is_balanced() == False tree = BalancedBST() assert tree.is_balanced() == True ``` Provide a well-commented solution that includes the necessary adjustments to maintain the tree balanced after each insertion.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key self.height = 1 class BalancedBST: def __init__(self): self.root = None def insert(self, value: int): if not self.root: self.root = TreeNode(value) else: self.root = self._insert(self.root, value) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.val: node.left = self._insert(node.left, key) elif key > node.val: node.right = self._insert(node.right, key) else: return node # Duplicate values are ignored to maintain uniqueness. node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Balancing the tree if balance > 1 and key < node.left.val: return self._right_rotate(node) if balance < -1 and key > node.right.val: return self._left_rotate(node) if balance > 1 and key > node.left.val: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.val: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def is_balanced(self) -> bool: return self._is_balanced(self.root) def _is_balanced(self, node): if not node: return True left_height = self._get_height(node.left) right_height = self._get_height(node.right) if abs(left_height - right_height) > 1: return False return self._is_balanced(node.left) and self._is_balanced(node.right)"},{"question":"# Contiguous Subarray Sum Coding Challenge # Problem Statement Write a function `max_sum_subarray` that receives a list of integers and returns the maximum sum obtainable from a contiguous subarray. The function should be optimized for both time and space efficiency. # Detailed Requirements - **Function Signature**: `def max_sum_subarray(numbers: list[int]) -> int:` - The input list `numbers` may contain positive, negative, and zero values. - If the input is empty, or if it doesn\'t contain valid integers, return `0`. - Raise a `ValueError` with a meaningful error message if the input is not a list or tuple of integers. # Example Test Cases ```python def test_max_sum_subarray(): assert max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9, \\"Test case 1 failed\\" assert max_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) == 7, \\"Test case 2 failed\\" assert max_sum_subarray([-1]) == -1, \\"Test case 3 failed\\" assert max_sum_subarray([0]) == 0, \\"Test case 4 failed\\" assert max_sum_subarray([]) == 0, \\"Test case 5 failed\\" try: max_sum_subarray([2, 3, -2, \\"a\\", -1]) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 6 failed\\" try: max_sum_subarray(\\"DEF\\") except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 7 failed\\" try: max_sum_subarray(None) except ValueError as e: assert str(e) == \\"numbers must be an iterable of integers\\", \\"Test case 8 failed\\" print(\\"All test cases pass\\") ``` # Constraints * You must not use any built-in methods for array manipulation that trivialize the task (e.g., `sum`, `max`). * Your solution should handle lists of varying lengths and compositions efficiently. # Guidelines * Ensure your code handles edge cases such as empty input, non-integer inputs, and other invalid forms before processing. * Avoid using extra space unnecessarily; strive to implement the solution with O(1) additional space complexity.","solution":"def max_sum_subarray(numbers): Find the maximum sum of a contiguous subarray in the given list of integers. if not isinstance(numbers, (list, tuple)) or not all(isinstance(n, int) for n in numbers): raise ValueError(\\"numbers must be an iterable of integers\\") if not numbers: return 0 max_sum = float(\'-inf\') current_sum = 0 for number in numbers: current_sum = max(number, current_sum + number) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Scenario You are given an array of integers `arr` and an integer `d`. Your task is to determine the maximum possible sum that can be obtained by any contiguous subarray of `arr` that is of length `d`. **Instructions**: - Implement the `SubarraySum` class as described. - The `max_sum` method should compute the maximum possible sum of any contiguous subarray with length `d`. **Function Signature**: The function signature should be as follows: ```python class SubarraySum: def __init__(self, arr: List[int], d: int): # Initialization code goes here def max_sum(self) -> int: # Code to return maximum sum of any contiguous subarray with length d goes here ``` # Expected Input and Output **Input**: - `arr` (List[int]): An array of integers. - `d` (int): The length of the subarray. **Output**: - The `max_sum` method should return the maximum possible sum of any contiguous subarray with length `d`. # Sample Input: ```python arr = [1, -2, 3, 10, -4, 7, 2, -5] d = 3 s = SubarraySum(arr, d) print(s.max_sum()) # Output should be 15 ``` # Explanation: - The contiguous subarray with length 3 that has the maximum sum is [10, -4, 7], and the sum is 10 + (-4) + 7 = 13. **Constraints**: - The length of `arr` is `1 <= len(arr) <= 10^5`. - Each element of `arr` is within the range `[-1000, 1000]`. - The value of `d` is within the range `1 <= d <= len(arr)`. **Performance Requirements**: The solution should work efficiently with a time complexity of O(n), where n is the length of the array `arr`.","solution":"from typing import List class SubarraySum: def __init__(self, arr: List[int], d: int): self.arr = arr self.d = d def max_sum(self) -> int: n = len(self.arr) if self.d > n: raise ValueError(\\"The value of d should not exceed the length of the array\\") max_sum = float(\'-inf\') current_sum = 0 # Compute the sum of the first window of size d for i in range(self.d): current_sum += self.arr[i] max_sum = current_sum # Slide over the array for i in range(self.d, n): current_sum += self.arr[i] - self.arr[i - self.d] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"# Coding Challenge: Sum of Unique Paths in a Grid Problem Statement You are given a grid of size m x n. Each cell in the grid contains a non-negative integer representing the cost of stepping into that cell. Your task is to find the minimum sum of the unique paths that lead from the top-left corner to the bottom-right corner of the grid. Unique paths means no cell is visited more than once on any path from the start to the end. You can only move either down or right at any point in time. Write a function `min_cost_unique_paths(grid: List[List[int]]) -> int` that accepts a two-dimensional list `grid` and returns the minimum sum of the unique path from top-left to bottom-right. Input - `grid`: A 2D list of integers representing the cost grid. (1 ≤ grid dimensions ≤ 100) Output - Returns an integer representing the minimum sum of the unique path from the top-left to the bottom-right of the grid. Constraints 1. The function should handle grids up to 100 x 100 efficiently. 2. You are only allowed to move right or down at any point in time. Performance Requirements The solution should handle the input within a reasonable time frame, ideally within a second for the maximum grid size. Example ```python assert min_cost_unique_paths([[1,3,1],[1,5,1],[4,2,1]]) == 7 assert min_cost_unique_paths([[1,2,3],[4,5,6]]) == 12 ``` Detailed Steps 1. **Initialization**: Create a 2D list to store the minimum costs of reaching each cell. 2. **Boundary Condition**: Initialize the top row and left column as there\'s only one way to reach these cells (straight line). 3. **Dynamic Programming**: Fill up the rest of the grid using the relation `cost[i][j] = grid[i][j] + min(cost[i-1][j], cost[i][j-1])`. 4. **Return Result**: The minimum cost of reaching the bottom-right cell is the desired result. Good luck and Happy Coding!","solution":"from typing import List def min_cost_unique_paths(grid: List[List[int]]) -> int: Returns the minimum sum of the unique path from the top-left to the bottom-right of the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a 2D dp array for storing the minimum costs dp = [[0] * n for _ in range(m)] # Initialize the top-left cell with its cost dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Compute the minimum cost path for the rest of the cells for i in range(1, m): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"# Factorial Calculation Given a non-negative integer, write a function to compute its factorial. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. It is denoted by n! and is defined as follows: [ n! = n times (n-1) times (n-2) times ... times 1 ] For n = 0, the factorial is defined as: [ 0! = 1 ] Function Specification Implement the function: ```python def factorial(n: int) -> int: This function calculates the factorial of a non-negative integer. Parameters: n (int): A non-negative integer for which the factorial is to be computed. Returns: int: The factorial of the input integer n. Raises: ValueError: If the input value is negative. ``` Input - `n`: A non-negative integer, represents the number for which to compute the factorial. Output - A single integer value representing the factorial of the input integer. Constraints - The input integer must be non-negative. - Factorial values for inputs greater than 20 may become very large. Examples ```python factorial(5) # returns 120 factorial(7) # returns 5040 factorial(0) # returns 1 factorial(-2) # raises ValueError ``` # Performance Requirements - The function must complete its task optimally using iteration or recursion while handling large inputs efficiently. Your implementation should handle invalid input by raising appropriate errors. Ensure that you thoroughly test your function with both typical and edge case inputs.","solution":"def factorial(n: int) -> int: This function calculates the factorial of a non-negative integer. Parameters: n (int): A non-negative integer for which the factorial is to be computed. Returns: int: The factorial of the input integer n. Raises: ValueError: If the input value is negative. if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"# Coding Question: **Scenario:** You are developing a text processing tool that needs to calculate the frequency of each unique word in a given string. Your task is to write a function that takes a string as input, processes it to find the frequency of each word, and returns a dictionary containing the words as keys and their corresponding frequencies as values, ignoring the case. **Task:** Write a function `word_frequency` that takes a string and returns a dictionary with the frequency of each unique word, ignoring case. **Function Signature:** ```python def word_frequency(text: str) -> Dict[str, int]: pass ``` **Parameters:** * `text` (str): A string containing words separated by spaces. **Returns:** * Dict[str, int]: A dictionary where keys are words and values are their frequencies in the input string. **Example:** ```python text = \\"The quick brown fox jumps over the lazy dog. The fox was very quick.\\" assert word_frequency(text) == { \\"the\\": 3, \\"quick\\": 2, \\"brown\\": 1, \\"fox\\": 2, \\"jumps\\": 1, \\"over\\": 1, \\"lazy\\": 1, \\"dog\\": 1, \\"was\\": 1, \\"very\\": 1 } ``` **Constraints:** * Punctuation should be removed, and words should be considered case-insensitive (i.e., \\"The\\" and \\"the\\" should be treated as the same word). * You may assume the input text will only contain alphabetic characters and punctuation. * Do not use any external libraries for text processing. **Performance Requirements:** Your implementation should efficiently handle input strings up to 10,000 characters long, optimizing for both time and space complexity.","solution":"import re from typing import Dict def word_frequency(text: str) -> Dict[str, int]: # Normalize the text by converting to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Split the text into words words = text.split() frequency = {} for word in words: if word in frequency: frequency[word] += 1 else: frequency[word] = 1 return frequency"},{"question":"# Coding Assessment Question **Title**: Minimum Swaps to Sort an Array **Context**: In many algorithms, sorting plays a crucial role. However, sometimes it\'s not just about sorting the array but minimizing the number of operations required to do so. This problem tests your understanding of sorting algorithms and your ability to optimize the sorting process. **Objective**: Write a function `minimum_swaps_to_sort(arr: list[int]) -> int` that returns the minimum number of swaps required to sort the array in ascending order. **Input**: - `arr`: A list of integers containing `n1, n2, ..., nk`. The list is guaranteed to have unique integers. **Output**: - An integer representing the minimum number of swaps to sort the array. **Constraints**: - `1 ≤ len(arr) ≤ 1000`, ensuring a variety of test cases, from small to moderately large arrays. **Requirements**: - The function should determine the minimum number of swap operations needed to sort the array. **Example**: ```python def minimum_swaps_to_sort(arr: list[int]) -> int: # Your solution here # Example Usage: print(minimum_swaps_to_sort([4, 3, 1, 2])) # Expected output: 3 print(minimum_swaps_to_sort([1, 5, 4, 3, 2])) # Expected output: 2 ``` **Hints**: - You can track the indices and values of the sorted positions. - Consider the use of a cycle-based approach to identify and minimize the number of swaps.","solution":"def minimum_swaps_to_sort(arr: list[int]) -> int: n = len(arr) arr_pos = [(val, idx) for idx, val in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"# Coding Assessment Question Question: You are provided with a string of lowercase English letters and your task is to determine if it is possible to rearrange the characters of the string such that no two adjacent characters are the same. If possible, return one such rearranged string. Otherwise, return an empty string. Write a function `rearrange_string(s: str) -> str` that returns the rearranged string or an empty string if the rearrangement is not possible. Function Signature: ```python def rearrange_string(s: str) -> str: pass ``` Input: - `s` (str): A string of lowercase English letters. Output: - `str`: A rearranged string where no two adjacent characters are the same, or an empty string if no such rearrangement is possible. Constraints: - The input string can be of length 1 to 10^5. Performance Requirements: - Time Complexity should be O(n log n), where n is the length of the string. - Space Complexity should be O(n). Example: ```python >>> rearrange_string(\\"aabb\\") \'abab\' >>> rearrange_string(\\"aaab\\") \'\' >>> rearrange_string(\\"aaabb\\") \'ababa\' >>> rearrange_string(\\"a\\") \'a\' >>> rearrange_string(\\"\\") \'\' ``` # Additional Information: 1. You may find the use of a max heap (priority queue) and a greedy approach helpful to solve this problem. 2. Consider the frequency of characters and ensure that no character with a higher frequency becomes adjacent if a proper arrangement is possible. 3. Ensure the implementation handles edge cases, such as very short strings and scenarios where no valid arrangement exists.","solution":"from heapq import heappush, heappop from collections import Counter def rearrange_string(s: str) -> str: if not s: return \\"\\" # Count frequency of each character counter = Counter(s) # Add all characters to the max heap with negative frequencies to simulate a max heap max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) result = [] prev_freq, prev_char = 0, \'\' while max_heap: freq, char = heappop(max_heap) result.append(char) # If previous character frequency is not zero, push it back to the heap if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update previous character frequency, at next iteration it can be pushed back to the heap if needed. prev_freq = freq + 1 prev_char = char rearranged = \'\'.join(result) return rearranged if len(rearranged) == len(s) else \\"\\" # Sample usage: this should not be included in the submission # print(rearrange_string(\\"aabb\\")) # Output: \\"abab\\" # print(rearrange_string(\\"aaab\\")) # Output: \\"\\" # print(rearrange_string(\\"aaabb\\")) # Output: \\"ababa\\" # print(rearrange_string(\\"a\\")) # Output: \\"a\\" # print(rearrange_string(\\"\\")) # Output: \\"\\""},{"question":"# Task You are provided with an implementation of a Min-Heap. You need to implement a function that can perform a \\"k-th smallest element\\" query. The function should return the k-th smallest element in the heap efficiently without modifying the original heap. # Function Signature ```python class MinHeap: # ... (existing methods) def kth_smallest_element(self, k: int) -> int: Return the k-th smallest element in the Min-Heap in O(k log N) Parameters: k (int): The k-th index (1-based) to find the smallest element Returns: int: The k-th smallest element in the heap Example Usage: >>> h = MinHeap([7, 10, 4, 3, 20, 15]) >>> h.kth_smallest_element(3) 7 pass ``` # Specifications 1. Implement the `kth_smallest_element` method that extracts the k-th smallest element from the Min-Heap without modifying the original heap. 2. Ensure that the method uses an efficient approach, achieving a complexity of O(k log N). # Input - **k**: An integer representing the position (1-based index) of the smallest element to find in the heap. # Output - The method should return the k-th smallest element as an integer. # Example 1. Create a Min-Heap with given elements: ```python h = MinHeap([7, 10, 4, 3, 20, 15]) ``` 2. Find the k-th smallest element: ```python assert h.kth_smallest_element(3) == 7 assert h.kth_smallest_element(1) == 3 assert h.kth_smallest_element(5) == 15 ``` # Constraints - You can assume that `1 <= k <= N` where `N` is the number of elements in the heap. - The heap can contain duplicate elements.","solution":"import heapq class MinHeap: def __init__(self, array): Initialize the MinHeap heapq.heapify(array) self.heap = array def kth_smallest_element(self, k: int) -> int: Return the k-th smallest element in the Min-Heap without modifying it. # Create a copy of the heap to avoid modifying the original heap heap_copy = list(self.heap) # Extract the minimum k times for _ in range(k - 1): heapq.heappop(heap_copy) return heapq.heappop(heap_copy) # Helper function to create the MinHeap (to assist in the testing) def create_min_heap(elements): return MinHeap(elements)"},{"question":"# Problem Statement You are tasked with implementing functions to handle operations on matrix data. Specifically, you must write functions to calculate the matrix product and the transpose of a given matrix. # Function Definitions 1. **matrix_product** ```python def matrix_product(A: list[list[float]], B: list[list[float]]) -> list[list[float]] | ValueError: Input Parameters: ----------------- A: A 2D list representing the first matrix (must be of dimensions m x n). B: A 2D list representing the second matrix (must be of dimensions n x p). Returns: -------- A 2D list representing the resultant matrix product (of dimensions m x p). Raises a ValueError if the matrices cannot be multiplied due to incompatible dimensions. ``` 2. **matrix_transpose** ```python def matrix_transpose(A: list[list[float]]) -> list[list[float]]: Input Parameters: ----------------- A: A 2D list representing the input matrix (of dimensions m x n). Returns: -------- A 2D list representing the transpose of the input matrix (of dimensions n x m). ``` # Constraints * All matrix elements are floating-point numbers and can be both positive or negative. * The input matrices for `matrix_product` should meet the dimension requirements for matrix multiplication (i.e., if `A` is m x n, `B` must be n x p). * Results should be correctly formatted 2D lists (matrices). # Example Scenarios: **Example 1**: ```python # Matrix product of A and B A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] matrix_product(A, B) # Expected: [[19.0, 22.0], [43.0, 50.0]] # Transpose of matrix A matrix_transpose(A) # Expected: [[1.0, 3.0], [2.0, 4.0]] ``` **Example 2**: ```python # Invalid input will result in ValueError for matrix_product A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10] ] matrix_product(A, B) # Expected: ValueError(\'Input Error: Incompatible dimensions for matrix multiplication.\') ```","solution":"def matrix_product(A: list[list[float]], B: list[list[float]]) -> list[list[float]] | ValueError: Input Parameters: ----------------- A: A 2D list representing the first matrix (must be of dimensions m x n). B: A 2D list representing the second matrix (must be of dimensions n x p). Returns: -------- A 2D list representing the resultant matrix product (of dimensions m x p). Raises a ValueError if the matrices cannot be multiplied due to incompatible dimensions. # Get dimensions of A and B m, n = len(A), len(A[0]) b_rows, p = len(B), len(B[0]) # Check if dimensions are compatible if n != b_rows: raise ValueError(\'Input Error: Incompatible dimensions for matrix multiplication.\') # Initialize result matrix with zeros result = [[0.0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result def matrix_transpose(A: list[list[float]]) -> list[list[float]]: Input Parameters: ----------------- A: A 2D list representing the input matrix (of dimensions m x n). Returns: -------- A 2D list representing the transpose of the input matrix (of dimensions n x m). m, n = len(A), len(A[0]) # Initialize the transpose matrix transpose = [[0.0 for _ in range(m)] for _ in range(n)] # Perform transpose for i in range(m): for j in range(n): transpose[j][i] = A[i][j] return transpose"},{"question":"# **Coding Assessment Question** Context: A popular social media application stores users\' data as a list of dictionaries where each dictionary contains information about a user, including their `username`, `follower_count`, and other related attributes. To improve the recommendation algorithm, you need to implement a feature that finds users who meet certain criteria based on their follower count. Given the vast number of users, the application needs an efficient way to filter this data. Task: Implement a function to find all users whose `follower_count` falls within a specific range. Your solution should also keep the result sorted in descending order of `follower_count` and in the order users appeared in the original list if they have the same follower count. Function Signature: - `def filter_users(users: list[dict], lower_bound: int, upper_bound: int) -> list[dict]:` # Input: - `users`: a list of dictionaries where each dictionary represents a user with keys including `username` and `follower_count`, for example: `{\'username\': \'user1\', \'follower_count\': 150}` - `lower_bound`: an integer indicating the inclusive lower bound of the follower count range. - `upper_bound`: an integer indicating the inclusive upper bound of the follower count range. # Output: - Return a list of dictionaries representing users whose `follower_count` is within the given range `[lower_bound, upper_bound]`, sorted first by `follower_count` in descending order and then in the order they appeared in the original list if there is a tie. # Constraints: - The input list will have at most `10^5` elements. - Each user dictionary will always have the `username` and `follower_count` keys. # Examples: ```python users = [ {\'username\': \'user1\', \'follower_count\': 200}, {\'username\': \'user2\', \'follower_count\': 450}, {\'username\': \'user3\', \'follower_count\': 150}, {\'username\': \'user4\', \'follower_count\': 250}, ] assert filter_users(users, 150, 250) == [ {\'username\': \'user4\', \'follower_count\': 250}, {\'username\': \'user1\', \'follower_count\': 200}, {\'username\': \'user3\', \'follower_count\': 150} ] assert filter_users(users, 300, 500) == [ {\'username\': \'user2\', \'follower_count\': 450} ] assert filter_users(users, 50, 100) == [] ``` **Note**: Handle edge cases such as an empty user list and no users matching the criteria. Additional Requirements: - Ensure the code performs efficiently even with the upper limit of input size. - Write unit tests to verify the correctness of your implementation.","solution":"def filter_users(users: list[dict], lower_bound: int, upper_bound: int) -> list[dict]: Filters the users based on their follower count range [lower_bound, upper_bound] and returns the filtered users sorted by follower count in descending order. filtered_users = [ user for user in users if lower_bound <= user[\'follower_count\'] <= upper_bound ] # Sort by follower count in descending order, preserve order in case of tie filtered_users.sort(key=lambda user: -user[\'follower_count\']) return filtered_users"},{"question":"# Question Implement a function that checks if a given string contains any balanced triplets of parentheses, braces, and square brackets. A triplet is considered balanced if each opening bracket has a corresponding closing bracket and they are properly nested. Requirements - Implement the function `has_balanced_triplets(s: str) -> bool`: * This function should return `True` if the string contains one or more balanced triplets, else return `False`. * An empty string should return `False`. * If the input is not a string, raise a `ValueError`. Input Format * `s`: A string containing characters, which may include parentheses `()`, braces `{}`, and brackets `[]`. Output Format * Return a boolean value indicating whether the string contains balanced triplets. # Examples ```python >>> has_balanced_triplets(\\"([{}])\\") True >>> has_balanced_triplets(\\"(([]){})\\") True >>> has_balanced_triplets(\\"([]){}\\") True >>> has_balanced_triplets(\\"(([]){}})\\") False >>> has_balanced_triplets(\\"(){}[]\\") True >>> has_balanced_triplets(\\"((){[[]]})\\") True >>> has_balanced_triplets(\\"([)]\\") False >>> has_balanced_triplets(\\"(({}[)\\") False >>> has_balanced_triplets(\\"()\\") False >>> has_balanced_triplets(\\"\\") False ``` Constraints * The input string can contain any characters, but only `()`, `{}`, and `[]` are considered for balanced triplets. * The function must handle erroneous inputs gracefully by raising `ValueError` with appropriate messages. Additional Information Balanced triplets are useful in syntax validation in code compilation and interpretation, ensuring that all kinds of bracket pairs are correctly nested and matched.","solution":"def has_balanced_triplets(s: str) -> bool: Checks if the string contains balanced triplets of parentheses (), braces {}, and brackets []. Parameters: s (str): The input string Returns: bool: True if the string contains balanced triplets, else False Raises: ValueError: If the input is not a string if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if len(s) < 6: # Minimum length to form one complete balanced set of triplets is 6. return False stack = [] pairs = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} open_brackets = set(pairs.keys()) close_brackets = set(pairs.values()) for char in s: if char in open_brackets: stack.append(char) elif char in close_brackets: if stack and pairs[stack[-1]] == char: stack.pop() else: return False # Check if the stack is empty and reduced to valid triplets length. return len(stack) == 0"},{"question":"# Problem Description You are tasked to work with matrices and perform a specific matrix transformation. Given an `n x n` matrix, you need to rotate the matrix 90 degrees clockwise. Function: Rotate Matrix Implement `rotate_matrix(matrix: List[List[int]]) -> List[List[int]]`: * **Input**: - `matrix`: A 2D list of integers representing an `n x n` matrix. * **Output**: A new 2D list of integers representing the matrix after a 90-degree clockwise rotation. # Constraints 1. The matrix will have dimensions of `n x n` where `1 <= n <= 300`. 2. The matrix elements will be in the range of `-1000 <= matrix[i][j] <= 1000`. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # After a 90-degree clockwise rotation: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] assert rotate_matrix(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Notes - The function should not modify the original matrix. - Consider the typical matrix rotation strategy involving transposition followed by reversal of rows.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the given n x n matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the rotated values rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - i - 1] = matrix[i][j] return rotated"},{"question":"Count Distinct Substrings Objective This task requires you to write a function that counts the number of distinct substrings of a given string. Scenario You are developing a feature for a text analysis tool. One of the requirements is to count the number of distinct substrings in a string to analyze the diversity of content. Function Signature ```python def count_distinct_substrings(s: str | None = None) -> int: ``` Input and Output - **Input**: A single parameter, `s`, which is a string. If `s` is None or an empty string, the function should raise a `ValueError` with the message \\"Input string should not be empty\\". - **Output**: Returns an integer representing the number of distinct substrings in the input string. Constraints - The string can include any characters (including lowercase, uppercase, digits, and special characters). - The function should aim to perform efficiently even for larger strings (with lengths up to 10^5). Examples 1. `count_distinct_substrings(\\"abc\\")` should return `6` because the distinct substrings are: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\". 2. `count_distinct_substrings(\\"aaa\\")` should return `3` because the distinct substrings are: \\"a\\", \\"aa\\", \\"aaa\\". 3. `count_distinct_substrings(\\"\\")` should raise a `ValueError` with the message \\"Input string should not be empty\\". Instructions 1. Implement the `count_distinct_substrings` function. 2. The implementation must handle edge cases like an empty string. 3. The implementation should pass the provided examples and other edge cases effectively. Testing - Ensure to test your implementation with the provided examples. - Evaluate other potential edge cases to ensure robustness. --- This new question aligns with the original problem by maintaining a similar structure and tone, presenting comparable length and complexity, and testing relevant skills through a unique problem scenario.","solution":"def count_distinct_substrings(s: str | None) -> int: if s is None or s == \\"\\": raise ValueError(\\"Input string should not be empty\\") n = len(s) suffix_array = sorted(s[i:] for i in range(n)) lcp = [0] * n def _lcp_length(a, b): min_len = min(len(a), len(b)) for i in range(min_len): if a[i] != b[i]: return i return min_len for i in range(1, n): lcp[i] = _lcp_length(suffix_array[i], suffix_array[i - 1]) total_substrings = (n * (n + 1)) // 2 lcp_sum = sum(lcp) return total_substrings - lcp_sum"},{"question":"# Question: Implement a Basic Markdown Processor Context You are tasked with developing a basic markdown processor for a simple text editor. The processor needs to convert certain markdown syntax into HTML. Specifically, it should handle headers, bold text, italic text, and links. Task 1. Implement a function `markdown_to_html(markdown: str) -> str` that: - Takes a string `markdown` containing markdown formatted text. - Returns a string containing the equivalent HTML. 2. The markdown processor should handle: - Headers: Convert markdown headers (`#`, ``, `#`, up to ``) to their corresponding HTML header tags (`<h1>`, `<h2>`, etc.). - Bold text: Convert text surrounded by double asterisks (`**text**`) to HTML bold tags (`<b>text</b>`). - Italic text: Convert text surrounded by single asterisks or underscores (`*text*` or `_text_`) to HTML italic tags (`<i>text</i>`). - Links: Convert markdown links (`[label](url)`) to HTML anchor tags (`<a href=\\"url\\">label</a>`). Implementation Constraints - Assume that the input markdown text is valid and well-formed. - Ensure the markdown syntax is properly converted into HTML without introducing any additional characters. - The processing time should be linear, O(n), where n is the length of the markdown string. Input and Output - **Input**: A string `markdown` containing markdown formatted text. - **Output**: A string containing the equivalent HTML. Examples ```python assert markdown_to_html(\\"# Header 1\\") == \\"<h1>Header 1</h1>\\" assert markdown_to_html(\\" Header 2\\") == \\"<h2>Header 2</h2>\\" assert markdown_to_html(\\"**bold text**\\") == \\"<b>bold text</b>\\" assert markdown_to_html(\\"*italic text*\\") == \\"<i>italic text</i>\\" assert markdown_to_html(\\"_italic text_\\") == \\"<i>italic text</i>\\" assert markdown_to_html(\\"[Google](https://www.google.com)\\") == \'<a href=\\"https://www.google.com\\">Google</a>\' assert markdown_to_html(\\"# Mixed **bold** and *italic* text\\") == \\"<h3>Mixed <b>bold</b> and <i>italic</i> text</h3>\\" assert markdown_to_html(\\"No convert required here.\\") == \\"No convert required here.\\" ``` Notes 1. Carefully handle nested and mixed markdown syntax that may appear within the same line. 2. Ensure the order of application of markdown rules is correct to avoid incorrect HTML conversion. 3. Consider edge cases where markdown symbols might appear in isolation or at the beginning/end of the string without affecting the formatting.","solution":"import re def markdown_to_html(markdown: str) -> str: Converts markdown formatted text to HTML. # Convert headers for i in range(6, 0, -1): markdown = re.sub(r\'^{0} (.+)\'.format(\'#\' * i), r\'<h{0}>1</h{0}>\'.format(i), markdown, flags=re.MULTILINE) # Convert bold text markdown = re.sub(r\'**(.+?)**\', r\'<b>1</b>\', markdown) # Convert italic text using single asterisks markdown = re.sub(r\'*(.+?)*\', r\'<i>1</i>\', markdown) # Convert italic text using underscores markdown = re.sub(r\'_(.+?)_\', r\'<i>1</i>\', markdown) # Convert links markdown = re.sub(r\'[(.+?)]((http.+?))\', r\'<a href=\\"2\\">1</a>\', markdown) return markdown"},{"question":"# Prime Number Checker Using Sieve of Eratosthenes Problem Statement You need to implement a function that checks whether numbers in a given list are prime or not, using the Sieve of Eratosthenes algorithm. The function should return a list of boolean values, where `True` indicates that the number is prime and `False` indicates that it is not. Function Specification ```python def prime_checker(numbers: list) -> list: Determine if each number in the list is prime using the Sieve of Eratosthenes algorithm. Parameters: numbers (list): A list of integers to check for primality. Returns: list: A list of boolean values indicating whether each corresponding number is prime (True) or not (False). ``` Input & Output Format * **Input**: * A list of `n` integers (0 <= numbers[i] <= 10^6), with 1 <= n <= 1000. * **Output**: * A list of boolean values where each value represents whether the respective integer in the input list is a prime number. Constraints: * The function should handle cases where the number is 0, 1. * The maximum value for any number is 10^6 to ensure the function runs efficiently on reasonable input sizes. * Handle any invalid input, such as negative integers or non-integer lists, and raise a ValueError with a suitable message. Example ```python >>> prime_checker([0, 1, 2, 3, 4, 5, 17, 19, 20]) [False, False, True, True, False, True, True, True, False] >>> prime_checker([23, 29, 31, 37, 41, 43, 47, 53, 59, 61]) [True, True, True, True, True, True, True, True, True, True] >>> prime_checker([4, 6, 8, 9, 10, 12, 14, 15, 16, 18]) [False, False, False, False, False, False, False, False, False, False] ``` Additional Notes * Leverage the Sieve of Eratosthenes for an optimized solution. * Consider handling invalid inputs appropriately, such as non-integer elements in the list. * Ensure that your function is efficient in terms of both time and space complexity within the given constraints.","solution":"def prime_checker(numbers: list) -> list: Determine if each number in the list is prime using the Sieve of Eratosthenes algorithm. Parameters: numbers (list): A list of integers to check for primality. Returns: list: A list of boolean values indicating whether each corresponding number is prime (True) or not (False). if not all(isinstance(num, int) and num >= 0 for num in numbers): raise ValueError(\\"Input list must contain non-negative integers only.\\") # Maximum possible number max_num = max(numbers) if numbers else 0 # Sieve of Eratosthenes sieve = [True] * (max_num + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(max_num**0.5) + 1): if sieve[start]: for i in range(start*start, max_num + 1, start): sieve[i] = False # Prepare the result results = [sieve[num] for num in numbers] return results"},{"question":"# Coding Assessment Question Context You are requested to design a system that can effectively manage and monitor the usage of shared resources in a networked environment. A crucial part of this system involves implementing an algorithm that can accurately detect and resolve the optimal consumption sequence to keep track of the resource allocation, ensuring that minimal resource contention occurs. Objective Write a function that simulates the Least Recently Used (LRU) cache replacement policy. The LRU cache should be able to store a fixed number of items and efficiently handle cache hits and misses. Function Signature ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. pass def get(self, key: int) -> int: Retrieve the value associated with the given key from the cache if it exists. Args: key (int): The key of the item to retrieve. Returns: int: The value associated with the key if it exists in the cache; otherwise, return -1. pass def put(self, key: int, value: int) -> None: Insert or update the value associated with the given key in the cache. Args: key (int): The key of the item to insert or update. value (int): The value to associate with the key. pass ``` Input & Output * **Input**: The class constructor takes an integer representing the capacity of the cache. The `get` method takes an integer key and returns the value associated with the key if it exists, or -1 otherwise. The `put` method takes an integer key and value, and updates the cache accordingly. * **Output**: The `get` method returns the value associated with the key, or -1 if the key is not found. The `put` method does not return anything. Constraints * 1 <= capacity <= 10^5 * -10^9 <= key, value <= 10^9 * At most 2 * 10^5 calls will be made to `get` and `put`. Example ```python # Example usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Performance Requirements * Your implementation should prioritize efficiency and handle the constraints provided without significant performance degradation.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. Args: capacity (int): The maximum number of items the cache can hold. self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: Retrieve the value associated with the given key from the cache if it exists. Args: key (int): The key of the item to retrieve. Returns: int: The value associated with the key if it exists in the cache; otherwise, return -1. if key in self.cache: self.cache.move_to_end(key) # Mark this key as recently used return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Insert or update the value associated with the given key in the cache. Args: key (int): The key of the item to insert or update. value (int): The value to associate with the key. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Remove least recently used item"},{"question":"# Dijkstra\'s Shortest Path Algorithm Implementation Objective Implement Dijkstra\'s algorithm to find the shortest paths from a given source vertex to all other vertices in a weighted, directed graph. Scenario In network routing, it is crucial to determine the most efficient paths to ensure data packets are transmitted through the optimal routes. Implement Dijkstra\'s algorithm to identify these shortest paths. Instructions 1. Implement the following functions in the provided `dijkstra()` method: * `initialize_single_source(graph, source)` * Input: * `graph` (dict): The graph represented as an adjacency list where keys are nodes and values are lists of tuples (neighbor, weight). * `source` (int): The source vertex. * Output: * `distances` (dict): Dictionary of minimum distances from source to each vertex, initialized with infinity. * `previous` (dict): Dictionary of previous nodes, initialized with None. * `relax(u, v, weight, distances, previous)` * Input: * `u` (int): The current vertex. * `v` (int): The adjacent vertex. * `weight` (float): Weight of the edge from `u` to `v`. * `distances` (dict): Current distance estimates. * `previous` (dict): Current previous node mappings. * Output: * `None`: Modification happens in-place. * `extract_min(queue, distances)` * Input: * `queue` (set): Set of all vertices in the unprocessed queue. * `distances` (dict): Current distance estimates. * Output: * `u` (int): Vertex with the smallest distance in the queue. * `dijkstra(graph, source)` * Input: * `graph` (dict): The graph represented as an adjacency list. * `source` (int): The source vertex. * Output: * `distances` (dict): Dictionary of minimum distances from source to each vertex. * `paths` (dict): Dictionary of paths from the source to each vertex. Constraints * Assume the graph is represented as a valid adjacency list where each key is a vertex and its value is a list of tuples representing its neighbors and the edge weights. * All edge weights are non-negative. * Use `heapq` for efficient extraction of the minimum element. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 distances, paths = dijkstra(graph, source) print(distances) # Output: {0: 0, 1: 3, 2: 1, 3: 4} print(paths) # Output: {0: [0], 1: [0, 2, 1], 2: [0, 2], 3: [0, 2, 1, 3]} ``` Note: Utilize the example outputs to verify the correctness of your implementation.","solution":"import heapq def initialize_single_source(graph, source): Initializes the distance and previous vertices for the graph. distances = {vertex: float(\'inf\') for vertex in graph} previous = {vertex: None for vertex in graph} distances[source] = 0 return distances, previous def relax(u, v, weight, distances, previous): Relaxes the edge and updates the distances and previous vertices if a shorter path is found. if distances[v] > distances[u] + weight: distances[v] = distances[u] + weight previous[v] = u def extract_min(queue, distances): Extracts the vertex with the smallest distance from the queue. min_vertex = min(queue, key=lambda vertex: distances[vertex]) queue.remove(min_vertex) return min_vertex def dijkstra(graph, source): Implements Dijkstra\'s algorithm to find the shortest paths from source to all other vertices in the graph. distances, previous = initialize_single_source(graph, source) queue = set(graph.keys()) while queue: u = extract_min(queue, distances) for v, weight in graph[u]: relax(u, v, weight, distances, previous) # Build paths paths = {vertex: [] for vertex in graph} for vertex in graph: if distances[vertex] != float(\'inf\'): current = vertex while current is not None: paths[vertex].insert(0, current) current = previous[current] return distances, paths"},{"question":"Given the following snippet of a program that is supposed to implement the A* search algorithm for finding the shortest path in a graph: ```python class Node: def __init__(self, name: str, neighbors: dict[str, int]) -> None: self.name = name self.neighbors = neighbors self.g = float(\'inf\') self.f = float(\'inf\') self.came_from = None def heuristic(node1: Node, node2: Node) -> int: Implement a heuristic function suitable for the problem. Without prior knowledge of the domain, assume that it simply returns 0 for now. return 0 def a_star(start: Node, goal: Node) -> list[str]: open_set = set() closed_set = set() start.g = 0 start.f = heuristic(start, goal) open_set.add(start) while open_set: current = min(open_set, key=lambda node: node.f) if current == goal: return reconstruct_path(current) open_set.remove(current) closed_set.add(current) for neighbor_name, cost in current.neighbors.items(): neighbor = ... # obtain the neighbor Node object if neighbor in closed_set: continue tentative_g = current.g + cost if neighbor not in open_set: open_set.add(neighbor) elif tentative_g >= neighbor.g: continue neighbor.came_from = current neighbor.g = tentative_g neighbor.f = neighbor.g + heuristic(neighbor, goal) return [] def reconstruct_path(current: Node) -> list[str]: total_path = [current.name] while current.came_from is not None: current = current.came_from total_path.append(current.name) return total_path[::-1] ``` # Task Implement the following functionalities to complete the A* algorithm: - A heuristic function suitable to the graph. For the sake of this problem, we\'ll use the Manhattan distance between the nodes, given their coordinates. - Code to obtain the Neighbor Node object, which will involve resolving neighbors by looking them up from a list or dictionary of nodes. **Input**: - `start`: A `Node` object representing the start node. - `goal`: A `Node` object representing the goal node. **Output**: - A list of node names, representing the path from start to goal. # Example ```python nodes = { \\"A\\": Node(\\"A\\", {\\"B\\": 1, \\"C\\": 3}), \\"B\\": Node(\\"B\\", {\\"A\\": 1, \\"D\\": 2}), \\"C\\": Node(\\"C\\", {\\"A\\": 3, \\"D\\": 1}), \\"D\\": Node(\\"D\\", {\\"B\\": 2, \\"C\\": 1, \\"E\\": 4}), \\"E\\": Node(\\"E\\", {\\"D\\": 4}) } def heuristic(node1: Node, node2: Node) -> int: coordinates = { \\"A\\": (0, 0), \\"B\\": (1, 0), \\"C\\": (0, 3), \\"D\\": (1, 3), \\"E\\": (2, 3) } x1, y1 = coordinates[node1.name] x2, y2 = coordinates[node2.name] return abs(x1 - x2) + abs(y1 - y2) start = nodes[\\"A\\"] goal = nodes[\\"E\\"] path = a_star(start, goal, nodes) # assuming nodes dict is passed to a_star to resolve neighbors print(path) # Output: [\'A\', \'C\', \'D\', \'E\'] ``` # Constraints - Each node name is a unique string. - The graph is represented using a dictionary of nodes. - Assume the heuristic function provided computes a valid heuristic value based on the coordinates. - Ensure proper management of `open_set` and `closed_set` to avoid infinite loops or incorrect paths. This question checks understanding of pathfinding algorithms, specifically the A* search, and includes the need to utilize heuristics and manage sets for path resolution. It requires the applicant to complete two parts of the algorithm - the heuristic and neighbor resolution.","solution":"class Node: def __init__(self, name: str, neighbors: dict[str, int]) -> None: self.name = name self.neighbors = neighbors self.g = float(\'inf\') self.f = float(\'inf\') self.came_from = None def heuristic(node1: Node, node2: Node) -> int: coordinates = { \\"A\\": (0, 0), \\"B\\": (1, 0), \\"C\\": (0, 3), \\"D\\": (1, 3), \\"E\\": (2, 3) } x1, y1 = coordinates[node1.name] x2, y2 = coordinates[node2.name] return abs(x1 - x2) + abs(y1 - y2) def a_star(start: Node, goal: Node, nodes: dict[str, Node]) -> list[str]: open_set = set() closed_set = set() start.g = 0 start.f = heuristic(start, goal) open_set.add(start) while open_set: current = min(open_set, key=lambda node: node.f) if current == goal: return reconstruct_path(current) open_set.remove(current) closed_set.add(current) for neighbor_name, cost in current.neighbors.items(): neighbor = nodes[neighbor_name] # obtain the neighbor Node object if neighbor in closed_set: continue tentative_g = current.g + cost if neighbor not in open_set: open_set.add(neighbor) elif tentative_g >= neighbor.g: continue neighbor.came_from = current neighbor.g = tentative_g neighbor.f = neighbor.g + heuristic(neighbor, goal) return [] def reconstruct_path(current: Node) -> list[str]: total_path = [current.name] while current.came_from is not None: current = current.came_from total_path.append(current.name) return total_path[::-1]"},{"question":"# Problem Statement You are required to implement a function that checks whether a given string representing a time follows the 24-hour HH:MM format. The following conditions must be satisfied for a valid time string: 1. The time string must be in the format \\"HH:MM\\". 2. The \'HH\' part represents the hour and must be between 00 and 23 inclusive. 3. The \'MM\' part represents the minutes and must be between 00 and 59 inclusive. 4. Leading zeros are mandatory for both hours and minutes. # Function Signature ```python def is_valid_time(time_str: str) -> bool: Determines if the provided time string is a valid 24-hour formatted time. :param time_str: Input time string in HH:MM format :return: Boolean indicating whether the time string is valid according to the defined rules ``` # Input * `time_str` (string): A string representing the time to be validated. # Output * A boolean value: - `True` if the time string is in a valid 24-hour format. - `False` otherwise. # Example ```python >>> is_valid_time(\\"14:30\\") True >>> is_valid_time(\\"09:45\\") True >>> is_valid_time(\\"23:59\\") True >>> is_valid_time(\\"24:00\\") False >>> is_valid_time(\\"12:60\\") False >>> is_valid_time(\\"7:30\\") False >>> is_valid_time(\\"14:3\\") False ``` # Constraints - The input time string will be a non-empty string. - The solution should utilize regular expressions to validate the format. - Ensure that the solution handles time strings with correct lengths and values for hours and minutes. # Additional Notes - Pay attention to edge cases such as incorrect lengths, missing leading zeros, and values that are out of the valid range for hours and minutes. - Despite regex ensuring a majority of the checks, validate that time values fall within the specified ranges.","solution":"import re def is_valid_time(time_str): Determines if the provided time string is a valid 24-hour formatted time. :param time_str: Input time string in HH:MM format :return: Boolean indicating whether the time string is valid according to the defined rules pattern = r\\"^(2[0-3]|[01]d):([0-5]d)\\" if re.match(pattern, time_str): return True return False"},{"question":"# Question: Sum of Nested Lists You are given a nested list of integers. Your task is to write a function that calculates the sum of all integers present in the nested list, no matter the level of nesting. # Function Signature ```python def sum_of_nested_lists(nested_list: list) -> int: Computes the sum of all integers in the nested list. Parameters: nested_list (list): A list which may contain integers and other lists of integers. Returns: int: The sum of all integers in the nested list. ``` # Input - A single nested list containing integers and other nested lists (1 ≤ len(nested_list) ≤ 1000). Each inner list or sublist may contain more lists or integers. The nesting can be arbitrarily deep. # Output - An integer representing the sum of all integers in the nested list. # Constraints - The total number of integers in all the nested lists combined does not exceed 1000. - Integers can be positive or negative. - Example of a nested list: - `[1, [2, 3], [4, [5, 6]], 7]` should produce `1 + 2 + 3 + 4 + 5 + 6 + 7 = 28` # Example ```python # Input nested_list = [1, [2, 3], [4, [5, 6]], 7] # Output 28 ``` # Notes - Ensure to handle lists within lists recursively. - Focus on writing a clear and efficient function to correctly compute the sum, regardless of how deeply nested the lists are.","solution":"def sum_of_nested_lists(nested_list: list) -> int: Computes the sum of all integers in the nested list. Parameters: nested_list (list): A list which may contain integers and other lists of integers. Returns: int: The sum of all integers in the nested list. total_sum = 0 for element in nested_list: if isinstance(element, int): total_sum += element elif isinstance(element, list): total_sum += sum_of_nested_lists(element) return total_sum"},{"question":"# Binary Tree Operations As a software developer, you are tasked with implementing multiple binary tree operations. Task: Implement the following functions: 1. **In-order Traversal**: Print all nodes of the binary tree in in-order. 2. **Pre-order Traversal**: Print all nodes of the binary tree in pre-order. 3. **Post-order Traversal**: Print all nodes of the binary tree in post-order. 4. **Level-order Traversal**: Print all nodes of the binary tree in level-order. 5. **Height of Tree**: Find and print the height of the binary tree. Specifications: - **Input Format**: - Number of nodes: `n` - For each node: - Node value: `val` - Left child: `left` - Right child: `right` - **Output Format**: - **In-order Traversal**: Sequence of node values. - **Pre-order Traversal**: Sequence of node values. - **Post-order Traversal**: Sequence of node values. - **Level-order Traversal**: Sequence of node values. - **Height of Tree**: An integer representing the height. - **Constraints**: - 0 ≤ n ≤ 1000 - Node values are unique integers. - The tree will not contain cycles. Additional Information: 1. Ensure the construction of the binary tree from the input data before performing the operations. 2. Handle edge cases such as an empty tree. Example: ```python Input: Number of nodes: 5 Nodes: 1 - left: 2, right: 3 2 - left: 4, right: 5 3 - left: None, right: None 4 - left: None, right: None 5 - left: None, right: None Output: In-order Traversal: 4 2 5 1 3 Pre-order Traversal: 1 2 4 5 3 Post-order Traversal: 4 5 2 3 1 Level-order Traversal: 1 2 3 4 5 Height of Tree: 3 ``` This new question fits with the style, complexity, and scope of the provided sample question and requires understanding and implementing core tree traversal techniques, similar to dealing with various graph traversal and pathfinding in the previous example.","solution":"class TreeNode: A class representing a node in a binary tree. def __init__(self, x): self.val = x self.left = None self.right = None def inorderTraversal(root): Returns the in-order traversal of the binary tree. result = [] def inorder(node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result def preorderTraversal(root): Returns the pre-order traversal of the binary tree. result = [] def preorder(node): if node: result.append(node.val) preorder(node.left) preorder(node.right) preorder(root) return result def postorderTraversal(root): Returns the post-order traversal of the binary tree. result = [] def postorder(node): if node: postorder(node.left) postorder(node.right) result.append(node.val) postorder(root) return result def levelOrderTraversal(root): Returns the level-order traversal of the binary tree. result = [] if not root: return result queue = [root] while queue: node = queue.pop(0) result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def heightOfTree(root): Returns the height of the binary tree. if not root: return 0 left_height = heightOfTree(root.left) right_height = heightOfTree(root.right) return max(left_height, right_height) + 1"},{"question":"# Array Rotation Utility **Context**: Array rotation is a common technique used to manipulate an array so that its elements are shifted left or right by a given number of positions. This operation is useful in various applications, including data processing, cryptography, and algorithm design. **Objective**: Implement an `rotate_array` function that rotates an array of integers to the left by a specified number of positions. The function should handle cases efficiently for both small and large arrays. **Function Signature**: ```python def rotate_array(arr: list[int], positions: int) -> list[int]: pass ``` **Expected Input and Output**: * Input: A list of integers and an integer indicating the number of positions to rotate. * Output: A new list of integers with the elements rotated to the left by the given number of positions. **Performance Requirements**: * The function should run in linear time, `O(n)`, where `n` is the length of the array. * The function should use a constant amount of extra space, `O(1)`. **Constraints**: * The function should handle empty arrays and rotation by zero gracefully. * Ensure the code raises `TypeError` if the input array is not a list of integers or if the positions value is not an integer. **Example Cases**: * Input: `[1, 2, 3, 4, 5]`, `2` * Output: `[3, 4, 5, 1, 2]` * Input: `[10, 20, 30, 40, 50]`, `3` * Output: `[40, 50, 10, 20, 30]` * Input: `[1, 2, 3]`, `0` * Output: `[1, 2, 3]` **Test Cases**: Provide a complete set of tests ensuring that the function handles all typical and edge cases, including: * Rotations exceeding the length of the array. * Negative rotation values. * Empty arrays and arrays with a single element. * Handling invalid inputs for both the array and positions. **Implementation Example**: ```python def rotate_array(arr: list[int], positions: int) -> list[int]: if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"Input must be a list of integers\\") if not isinstance(positions, int): raise TypeError(\\"Positions value must be an integer\\") n = len(arr) if n == 0: return [] # Normalize the positions to avoid unnecessary full rotations positions = positions % n # Perform the rotation return arr[positions:] + arr[:positions] def test_rotate_array() -> None: assert rotate_array([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert rotate_array([10, 20, 30, 40, 50], 3) == [40, 50, 10, 20, 30] assert rotate_array([1, 2, 3], 0) == [1, 2, 3] assert rotate_array([], 5) == [] assert rotate_array([1], 3) == [1] assert rotate_array([5, 6, 7, 8], 6) == [7, 8, 5, 6] if __name__ == \\"__main__\\": print(rotate_array([1, 2, 3, 4, 5], 2)) # Expected output: [3, 4, 5, 1, 2] print(rotate_array([10, 20, 30, 40, 50], 3)) # Expected output: [40, 50, 10, 20, 30] print(rotate_array([1, 2, 3], 0)) # Expected output: [1, 2, 3] ```","solution":"def rotate_array(arr: list[int], positions: int) -> list[int]: Rotates an array of integers to the left by a specified number of positions. if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise TypeError(\\"Input must be a list of integers\\") if not isinstance(positions, int): raise TypeError(\\"Positions value must be an integer\\") n = len(arr) if n == 0: return [] # Normalize the positions to avoid unnecessary full rotations positions = positions % n # Perform the rotation return arr[positions:] + arr[:positions]"},{"question":"# Filtered Array Sum Create a function that takes an array of integers and a value `threshold` as inputs and returns the sum of elements that are greater than the threshold. The function should handle edge cases and provide meaningful error messages for invalid inputs. Function Signature ```python def sum_filtered_array(arr: list, threshold: int) -> int: pass ``` Input * `arr` (list): A list of integers. It may be empty. * `threshold` (int): The threshold value. All elements greater than this value will be included in the sum. Output * Returns the sum of the integers in the list that are greater than the threshold value. Constraints * `-10^6 <= arr[i] <= 10^6` for any element `arr[i]` in `arr` * `-10^6 <= threshold <= 10^6` Performance Requirements The function should process the input list in linear time relative to its size. Example ```python # Example Usage assert sum_filtered_array([1, 2, 3, 4, 5], 3) == 9 assert sum_filtered_array([-1, -2, -3, -4, -5], -4) == -6 assert sum_filtered_array([0, 0, 0, 0], -1) == 0 assert sum_filtered_array([100, 200, 300], 150) == 500 assert sum_filtered_array([], 10) == 0 ``` Error Scenarios * If `arr` is not a list of integers, raise `ValueError(\\"Input array must be a list of integers\\")`. * If `threshold` is not an integer, raise `ValueError(\\"Threshold must be an integer\\")`. Additional Notes * Assume that elements of the array can be positive, negative, or zero. * Ensure to handle empty arrays appropriately, returning 0 in such cases. * Properly handle the edge case when no elements are greater than the threshold, resulting in a return value of 0. This problem tests the candidate’s ability to engage in fundamental list manipulations and conditional filtering within a list, and to handle validation of inputs effectively.","solution":"def sum_filtered_array(arr, threshold): Returns the sum of elements in `arr` that are greater than `threshold`. Parameters: arr (list): A list of integers. threshold (int): The threshold value. Returns: int: Sum of elements greater than the threshold. Raises: ValueError: If `arr` is not a list of integers or `threshold` is not an integer. if not isinstance(arr, list): raise ValueError(\\"Input array must be a list.\\") if not all(isinstance(x, int) for x in arr): raise ValueError(\\"Input array must be a list of integers.\\") if not isinstance(threshold, int): raise ValueError(\\"Threshold must be an integer.\\") return sum(x for x in arr if x > threshold)"},{"question":"# Coding Assessment Question: Implement a Decision Tree Classifier You are required to implement a simple Decision Tree Classifier from scratch. The model should be able to train on a given dataset and predict the class of new instances. Your implementation should follow the basic principles of Decision Trees, including constructing the tree based on entropy and information gain. Task Requirements: 1. **Function 1**: Calculate the entropy of a dataset. - **Function Name**: `calculate_entropy` - **Input**: Labels (`list of int`) - **Output**: Entropy value (`float`). 2. **Function 2**: Calculate the information gain of a split dataset. - **Function Name**: `calculate_information_gain` - **Input**: Original Labels (`list of int`), Split Labels (`tuple of list of int`) - **Output**: Information gain value (`float`). 3. **Function 3**: Split the dataset based on a feature and threshold. - **Function Name**: `split_dataset` - **Input**: Dataset (`list of list of float`), Labels (`list of int`), Feature Index (`int`), Threshold (`float`) - **Output**: Two subsets of the dataset (`tuple containing two lists of lists of float`) and corresponding labels (`tuple containing two lists of int`). 4. **Function 4**: Build the Decision Tree based on the dataset. - **Function Name**: `build_tree` - **Input**: Dataset (`list of list of float`), Labels (`list of int`), Depth (`int`) - **Output**: Decision Tree (nested dictionary). 5. **Function 5**: Make predictions for new instances using the Decision Tree. - **Function Name**: `predict` - **Input**: Decision Tree (`dict`), New Instances (`list of list of float`) - **Output**: Predicted Labels (`list of int`). 6. **Function 6**: Evaluate the accuracy of predictions. - **Function Name**: `accuracy` - **Input**: Actual Labels (`list of int`), Predicted Labels (`list of int`) - **Output**: Accuracy percentage (`float`). Constraints: 1. Assume the input data is well-formed and free of missing values. 2. Implement error handling for invalid inputs. 3. Optimize your solution for readability and simplicity rather than performance. 4. Limit the maximum depth of the Decision Tree to prevent overfitting. Example: ```python # Example 1. Calculating entropy entropy = calculate_entropy(labels=[1, 0, 1, 1, 0, 0]) # Example 2. Calculating information gain information_gain = calculate_information_gain( original_labels=[1, 0, 1, 1, 0, 0], split_labels=([1, 1, 1], [0, 0, 0]) ) # Example 3. Splitting the dataset left_subset, right_subset, left_labels, right_labels = split_dataset( dataset=[[1.5, 2.0], [1.0, 1.0], [1.2, 1.5], [0.5, 1.0], [0.3, 0.5], [0.8, 1.2]], labels=[1, 0, 1, 1, 0, 0], feature_index=1, threshold=1.0 ) # Example 4. Building the Decision Tree tree = build_tree( dataset=[[1.5, 2.0], [1.0, 1.0], [1.2, 1.5], [0.5, 1.0], [0.3, 0.5], [0.8, 1.2]], labels=[1, 0, 1, 1, 0, 0], depth=3 ) # Example 5. Making predictions using the tree predicted_labels = predict( decision_tree=tree, new_instances=[[1.0, 1.0], [0.7, 0.8]] ) # Example 6. Calculating accuracy acc = accuracy( actual_labels=[0, 0], predicted_labels=predicted_labels ) ``` You are allowed to use any standard libraries in Python to accomplish your task.","solution":"import math from collections import Counter def calculate_entropy(labels): Calculate the entropy of a dataset. :param labels: List of labels (int) :return: Entropy value (float) total_count = len(labels) label_counts = Counter(labels) entropy = 0.0 for count in label_counts.values(): probability = count / total_count entropy -= probability * math.log2(probability) return entropy def calculate_information_gain(original_labels, split_labels): Calculate the information gain of a split dataset. :param original_labels: List of original labels (int) :param split_labels: Tuple containing two lists of labels (int) :return: Information gain value (float) original_entropy = calculate_entropy(original_labels) total_count = len(original_labels) weighted_entropy = 0.0 for subset_labels in split_labels: weighted_entropy += (len(subset_labels) / total_count) * calculate_entropy(subset_labels) information_gain = original_entropy - weighted_entropy return information_gain def split_dataset(dataset, labels, feature_index, threshold): Split the dataset based on a feature and threshold. :param dataset: List of lists of features (float) :param labels: List of labels (int) :param feature_index: Index of the feature to split on (int) :param threshold: Threshold value to split on (float) :return: Tuple containing two lists of datasets and two lists of labels left_dataset, right_dataset = [], [] left_labels, right_labels = [], [] for i, data_point in enumerate(dataset): if data_point[feature_index] <= threshold: left_dataset.append(data_point) left_labels.append(labels[i]) else: right_dataset.append(data_point) right_labels.append(labels[i]) return (left_dataset, right_dataset), (left_labels, right_labels) def build_tree(dataset, labels, depth=1, max_depth=None): Build the Decision Tree based on the dataset. :param dataset: List of lists of features (float) :param labels: List of labels (int) :param depth: Current depth of the tree (int) :param max_depth: Maximum depth of the tree (int) :return: Decision Tree (nested dictionary) # Stop condition for recursion if len(set(labels)) == 1: return labels[0] # Return the class label if all are the same if max_depth is not None and depth > max_depth: return Counter(labels).most_common(1)[0][0] # Return majority class if max depth reached # Initialize variables to find best split best_gain = 0 best_split = None current_entropy = calculate_entropy(labels) num_features = len(dataset[0]) for feature_index in range(num_features): # Get all unique values for the feature to consider as thresholds feature_values = set(data_point[feature_index] for data_point in dataset) for threshold in feature_values: (left_dataset, right_dataset), (left_labels, right_labels) = split_dataset( dataset, labels, feature_index, threshold) if not left_labels or not right_labels: continue gain = calculate_information_gain(labels, (left_labels, right_labels)) if gain > best_gain: best_gain = gain best_split = { \'feature_index\': feature_index, \'threshold\': threshold, \'left\': (left_dataset, left_labels), \'right\': (right_dataset, right_labels) } if not best_split: return Counter(labels).most_common(1)[0][0] left_tree = build_tree(*best_split[\'left\'], depth + 1, max_depth) right_tree = build_tree(*best_split[\'right\'], depth + 1, max_depth) return { \'feature_index\': best_split[\'feature_index\'], \'threshold\': best_split[\'threshold\'], \'left\': left_tree, \'right\': right_tree } def predict(decision_tree, new_instances): Make predictions for new instances using the Decision Tree. :param decision_tree: Decision tree (nested dictionary) :param new_instances: List of lists of features (float) :return: Predicted labels (list of int) def classify(instance, tree): if isinstance(tree, int): return tree feature_index = tree[\'feature_index\'] threshold = tree[\'threshold\'] if instance[feature_index] <= threshold: return classify(instance, tree[\'left\']) else: return classify(instance, tree[\'right\']) return [classify(instance, decision_tree) for instance in new_instances] def accuracy(actual_labels, predicted_labels): Evaluate the accuracy of predictions. :param actual_labels: List of actual labels (int) :param predicted_labels: List of predicted labels (int) :return: Accuracy percentage (float) correct_count = sum(1 for actual, predicted in zip(actual_labels, predicted_labels) if actual == predicted) return correct_count / len(actual_labels) * 100"},{"question":"# Fibonacci Series Sum Problem Problem Statement: Write a function `fibonacci_sum` that calculates the sum of the first `n` Fibonacci numbers. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. That means the sequence starts as 0, 1, 1, 2, 3, 5, 8, 13, ... Input: - An integer `n` (1 ≤ n ≤ 50), representing the number of Fibonacci numbers to sum. Output: - An integer representing the sum of the first `n` Fibonacci numbers. Constraints: - The input `n` must be a positive integer. - Ensure the solution is efficient and handles the input limits seamlessly. Example: **Input:** ```python 6 ``` **Output:** ```python 20 ``` Notes: - The first Fibonacci number is 0, the second is 1, and the sequence continues as described. - The sum of the first 6 Fibonacci numbers (0, 1, 1, 2, 3, 5) is 12. Here is another example for clarity: **Input:** ```python 10 ``` **Output:** ```python 88 ``` - The sum of the first 10 Fibonacci numbers (0, 1, 1, 2, 3, 5, 8, 13, 21, 34) is 88.","solution":"def fibonacci_sum(n): Returns the sum of the first n Fibonacci numbers. if n < 1: return 0 # Initialize the first two Fibonacci numbers a, b = 0, 1 sum = a # Start with the first Fibonacci number (0) for _ in range(1, n): sum += b # Add the current Fibonacci number (b) a, b = b, a + b # Move to the next Fibonacci number return sum"},{"question":"# Problem Statement You are tasked with implementing a function that evaluates the given polynomial at a specified value of (x). The polynomial will be provided as a list of coefficients, where the index represents the power of (x). The function should handle a given value for (x) and compute the polynomial\'s value accurately. Implement the function: `evaluate_polynomial(coefficients: List[float], x: float) -> float` Function Definition - **Input**: - `coefficients` (List[float]): A list of coefficients where the (i)-th element represents the coefficient for (x^i). - `x` (float): The value of (x) to evaluate the polynomial at. - **Output**: - `float`: The computed value of the polynomial for the provided (x). Constraints - The `coefficients` list should contain at least one element. - The length of the `coefficients` list should not exceed 1000. - The input `x` should be a float or an integer. Error Handling - If `coefficients` is not a list or is empty, raise a `ValueError` with the message: `\\"evaluate_polynomial() requires a non-empty list of coefficients\\"`. - If an element of `coefficients` is not a float, raise a `ValueError` with the message: `\\"evaluate_polynomial() requires all coefficients to be floats\\"`. - If `x` is not a float or integer, raise a `ValueError` with the message: `\\"evaluate_polynomial() requires either an int or float for x\\"`. Examples - `evaluate_polynomial([2, 3, 1], 2)` should return `12.0` (since (2 + 3x + x^2) evaluated at (x = 2) is (2 + 6 + 4 = 12)). - `evaluate_polynomial([1, -1], -1)` should return `2.0`. - `evaluate_polynomial([], 2)` should raise a `ValueError`. Implement the function carefully to match the provided guidelines and example behaviors.","solution":"def evaluate_polynomial(coefficients, x): Evaluates the given polynomial at the specified value of x. Parameters: coefficients (List[float]): A list of coefficients where the ith element represents the coefficient for x^i. x (float): The value of x to evaluate the polynomial at. Returns: float: The computed value of the polynomial for the provided x. Raises: ValueError: If the coefficients list is empty or if any coefficient is not a float or if x is not a float or an integer. if not isinstance(coefficients, list) or not coefficients: raise ValueError(\\"evaluate_polynomial() requires a non-empty list of coefficients\\") if not all(isinstance(c, (float, int)) for c in coefficients): raise ValueError(\\"evaluate_polynomial() requires all coefficients to be floats or int\\") if not isinstance(x, (float, int)): raise ValueError(\\"evaluate_polynomial() requires either an int or float for x\\") return sum(c * (x ** i) for i, c in enumerate(coefficients))"},{"question":"# Problem Statement Write a function that takes a list of integers and returns a new list containing only the prime numbers from the original list in reverse order. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Function Definition ```python def reverse_primes(numbers: list) -> list: Returns a list of prime numbers found in \'numbers\', in reverse order. Parameters: numbers (list): A list of integers. Returns: list: A list of prime numbers in reverse order. Raises: TypeError: If \'numbers\' is not a list. ValueError: If the list contains non-integer elements. ``` Requirements * The function must iterate through the list and identify prime numbers. * The prime numbers must be returned in the reverse order of their appearance in the original list. * If the list contains elements that are not integers, the function should raise a **ValueError**. * If the input is not a list, the function should raise a **TypeError**. Example Usage ```python >>> reverse_primes([2, 4, 3, 9, 5, 7, 6]) [7, 5, 3, 2] >>> reverse_primes([10, 15, 20, 25]) [] >>> reverse_primes([31, 51, 29, 23, 13, 19]) [19, 13, 23, 29, 31] ``` Constraints * The function should handle a minimum of 0 elements and a maximum of 1000 elements in the list. * Each number in the list will be between -10000 and 10000. * The implementation should be efficient and minimize unnecessary calculations. Context Identifying and working with prime numbers is a fundamental concept in mathematics and computer science. This problem reinforces knowledge of prime number determination and list manipulations in Python, such as filtering and reversing lists.","solution":"def reverse_primes(numbers: list) -> list: Returns a list of prime numbers found in \'numbers\', in reverse order. Parameters: numbers (list): A list of integers. Returns: list: A list of prime numbers in reverse order. Raises: TypeError: If \'numbers\' is not a list. ValueError: If the list contains non-integer elements. if not isinstance(numbers, list): raise TypeError(\\"Input must be a list\\") for num in numbers: if not isinstance(num, int): raise ValueError(\\"All elements in the list must be integers\\") def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [num for num in numbers if is_prime(num)] return primes[::-1]"},{"question":"# Coding Question: Anagram Checker Write a Python function `count_anagrams(file_path)` that reads a file containing a list of words and returns the number of pairs of words that are anagrams of each other. Input: - `file_path` (string): The path to the file containing the list of words. Each word in the file is on a separate line. Output: - Returns an integer representing the number of pairs of words that are anagrams. Constraints: - Each line in the file contains a single word consisting of lowercase English letters. - The length of each word is at most 100. - The file contains no more than 10,000 words. Example: If the file contains the following words: ``` listen silent enlist banana adobe abode ``` The function should return 3 (since \\"listen\\", \\"silent\\", and \\"enlist\\" form 3 pairs, and \\"adobe\\" and \\"abode\\" form 1 pair). Notes: * An anagram of a word is another word formed by rearranging the letters of the original word using exactly once all the original letters. **Hint**: You may want to use a dictionary to group words that are anagrams of each other. # Evaluation Criteria 1. **Correctness**: The function should correctly count pairs of anagrams. 2. **Efficiency**: The solution should handle large input files efficiently. 3. **Robustness**: The function should manage various edge cases (e.g., empty files) gracefully. 4. **Clarity**: The code should be readable and well-commented. **Sample Implementation Skeleton**: ```python def count_anagrams(file_path): from collections import defaultdict def normalize(word): return \'\'.join(sorted(word)) # Read file and process words try: with open(file_path, \'r\') as file: words = [line.strip() for line in file] # Group words by their normalized form anagram_groups = defaultdict(list) for word in words: anagram_groups[normalize(word)].append(word) # Count pairs anagram_pairs_count = 0 for group in anagram_groups.values(): n = len(group) anagram_pairs_count += (n * (n - 1)) // 2 # Combination of n items taken 2 at a time return anagram_pairs_count except Exception as e: print(f\\"An error occurred: {e}\\") return 0 # Example usage: # print(count_anagrams(\'path_to_file.txt\')) ```","solution":"def count_anagrams(file_path): from collections import defaultdict def normalize(word): return \'\'.join(sorted(word)) # Read file and process words try: with open(file_path, \'r\') as file: words = [line.strip() for line in file.readlines()] if not words: return 0 # Group words by their normalized form anagram_groups = defaultdict(list) for word in words: anagram_groups[normalize(word)].append(word) # Count pairs anagram_pairs_count = 0 for group in anagram_groups.values(): n = len(group) anagram_pairs_count += (n * (n - 1)) // 2 # Combination of n items taken 2 at a time return anagram_pairs_count except Exception as e: print(f\\"An error occurred: {e}\\") return 0"},{"question":"# Coding Question: Sum of Digits in a Number Context: Bob is working on a numerical analysis project and needs to frequently calculate the sum of the digits of very large numbers. To aid his work, he requires a function that can efficiently compute the sum of digits for any given non-negative integer. Your task is to implement a function that performs this calculation. Task: Write a function `sum_of_digits(number: int) -> int` that returns the sum of the digits of a given non-negative integer. If the input is not an integer or is negative, the function should raise a `TypeError`. Input and Output Format: * **Input**: A single non-negative integer `number`. * Constraints: * `0 <= number <= 10^100` (Note: Ensure your function handles extremely large integers efficiently.) * **Output**: An integer representing the sum of the digits of the given number. Example Cases: ```python >>> sum_of_digits(12345) 15 >>> sum_of_digits(0) 0 >>> sum_of_digits(987654321) 45 >>> sum_of_digits(1) 1 >>> sum_of_digits(-1) Traceback (most recent call last): ... TypeError: Input value must be a non-negative \'int\' type ``` Constraints: * Handle edge cases, including zero and extremely large integers. Performance Requirements: * Your solution should run efficiently for input values up to (10^{100}). Good luck and ensure your code passes the provided example cases!","solution":"def sum_of_digits(number): Returns the sum of the digits of the given non-negative integer. Raises a TypeError if the input is not an integer or is negative. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input value must be a non-negative \'int\' type\\") return sum(int(digit) for digit in str(number))"},{"question":"# Question: Schedule Task Optimally You are developing a scheduling module for a project management application. The goal is to assign tasks to the optimal time slot based on their priorities and durations. Each time slot can accommodate tasks that fit within its duration. Implement a function to schedule a list of tasks into the available time slots in a way that maximizes the total priority of the scheduled tasks. Specifications: * Each task has a duration and a priority. * Each time slot has a maximum duration it can accommodate. * Tasks must fit entirely within a single time slot. * Tasks cannot be split across multiple time slots. Input: * A list of tuples representing tasks, where each tuple contains two integers: the first integer is the duration of the task, and the second is the priority of the task. * A list of integers representing the durations of available time slots. Output: * A list of lists, where each inner list contains the tasks (represented as tuples of duration and priority) that fit within a respective time slot. Examples: ```python def schedule_tasks(tasks: list[tuple[int, int]], slots: list[int]) -> list[list[tuple[int, int]]]: pass # Example Usage: tasks = [(4, 50), (2, 30), (1, 20), (3, 40), (2, 60)] slots = [5, 3, 2] print(schedule_tasks(tasks, slots)) # Output: [[(3, 40)], [(2, 60)], [(2, 30)]] ```","solution":"def schedule_tasks(tasks, slots): Schedules tasks to time slots to maximize total priority. Parameters: tasks (list of tuple): List where each tuple contains (duration, priority). slots (list of int): List of available time slot durations. Returns: list of list of tuple: A list of lists, where each inner list contains the scheduled tasks for a respective time slot. # Sort tasks by priority in descending order tasks.sort(key=lambda x: x[1], reverse=True) # Prepare the result list schedule = [[] for _ in slots] # Fill slots with tasks for i in range(len(slots)): for task in tasks: if task[0] <= slots[i]: schedule[i].append(task) tasks.remove(task) break # Move to the next slot after finding a fit return schedule"},{"question":"# Coding Assessment Question Scenario You need to create a functionality for an e-commerce application that includes a feature to suggest products based on user reviews. A part of this functionality involves summarizing the sentiments expressed in a collection of reviews. Your task is to develop a helper function to count the number of positive and negative words in a given review. Task Implement a function `count_sentiment_words(review: str, positive_words: List[str], negative_words: List[str]) -> Tuple[int, int]` following the signature: ```python def count_sentiment_words(review: str, positive_words: List[str], negative_words: List[str]) -> Tuple[int, int]: pass ``` Your implementation should count how many times words from the `positive_words` and `negative_words` lists appear in the `review`. The function should return a tuple containing two integers: the first being the count of positive words and the second being the count of negative words. Constraints * The input `review` will be a string containing up to 1000 characters. * The input lists `positive_words` and `negative_words` will each contain up to 100 words. * The words in the input lists contain only lowercase letters with no spaces or special characters. * Words in the `review` are separated by spaces and punctuation should be ignored. Input/Output Format * **Input**: A string `review` and two lists of strings `positive_words`, `negative_words`. * **Output**: A tuple of two integers representing the counts of positive and negative words in the review. Edge cases to consider * Case insensitivity of the review (e.g., \\"Excellent\\" and \\"excellent\\" should be considered the same word). * Punctuation around words in the review should be ignored. * A word that is both in positive and negative lists should count towards both. Performance Requirements * The function should efficiently handle the review and word lists within the given constraints. Examples ```python count_sentiment_words(\\"The product is excellent and wonderful but not good.\\", [\\"excellent\\", \\"wonderful\\", \\"good\\"], [\\"bad\\", \\"poor\\"]) -> (3, 0) count_sentiment_words(\\"Terrible service, the worst I\'ve ever experienced.\\", [\\"amazing\\", \\"great\\"], [\\"terrible\\", \\"worst\\", \\"bad\\"]) -> (0, 2) count_sentiment_words(\\"Okay, it was an average buy, nothing too special.\\", [\\"amazing\\", \\"excellent\\", \\"superb\\"], [\\"average\\", \\"poor\\", \\"bad\\"]) -> (0, 1) ``` Implementation Develop your solution considering all constraints and edge cases. Ensure your function correctly processes the review while ignoring punctuation, and handles the input lists effectively.","solution":"import re from typing import List, Tuple def count_sentiment_words(review: str, positive_words: List[str], negative_words: List[str]) -> Tuple[int, int]: # Convert the review to lowercase and remove punctuation review_clean = re.sub(r\'[^ws]\', \'\', review.lower()) # Split the cleaned review into words words = review_clean.split() # Initialize counters positive_count = 0 negative_count = 0 # Count occurrences of positive and negative words for word in words: if word in positive_words: positive_count += 1 if word in negative_words: negative_count += 1 return (positive_count, negative_count)"},{"question":"# Problem Statement You are required to implement a basic version of a calculator that can evaluate simple mathematical expressions. The calculator should support the four fundamental arithmetic operations: addition, subtraction, multiplication, and division. Additionally, the calculator should respect the order of operations. # Requirements 1. **Expression Handling**: The input is a single string containing a mathematical expression. 2. **Operation Support**: Your calculator should handle addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`). 3. **Order of Operations**: Implement the correct order of operations (i.e., multiplication and division take precedence over addition and subtraction). # Input * A string `expression` containing a valid mathematical expression. # Output * A float representing the result of evaluating the input expression. # Constraints 1. The input expression will be at most 200 characters long. 2. Use only standard Python libraries. 3. The input expression will be a valid mathematical expression, consisting of non-negative numbers, operators (`+`, `-`, `*`, `/`), and parentheses for grouping. 4. The result should be rounded to two decimal places. 5. Handle edge cases where division by zero might occur. 6. Your implementation should process the input efficiently. # Example **Input**: ``` \\"3 + 5 * 2 - 10 / 2\\" ``` **Output**: ``` 6.00 ``` **Input**: ``` \\"(3 + 5) * 2 - 10 / (2 + 3)\\" ``` **Output**: ``` 13.00 ``` # Function Signature ```python def evaluate_expression(expression: str) -> float: pass ``` # Note 1. Focus on accurately implementing the parsing and evaluation of the expression. 2. Your function should properly handle different edge cases and varied input lengths. 3. Document your code clearly to explain each step of the evaluation process.","solution":"import operator import re def evaluate_expression(expression: str) -> float: def parse_expression(expression): tokens = re.findall(r\'d+.?d*|[+-*/()]\', expression) return tokens def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(OPERATORS[operator](left, right)) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def calculate(expression): tokens = parse_expression(expression) values = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i].isdigit() or re.match(r\'d+.d*\', tokens[i]): values.append(float(tokens[i])) elif tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # Remove \'(\' else: while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return values[-1] OPERATORS = { \'+\': operator.add, \'-\': operator.sub, \'*\': operator.mul, \'/\': operator.truediv } try: result = calculate(expression) return round(result, 2) except ZeroDivisionError: return float(\'inf\')"},{"question":"# Problem Statement You are given a dictionary representing the items in a shopping cart, where the keys are the item names and the values are the quantities of each item. Write a function that calculates the total cost of the items in the cart based on the given prices. The function should handle any edge cases as specified in the requirements. # Function Signature ```python def calculate_total(cart: dict[str, int], prices: dict[str, float]) -> float: Calculates the total cost of the items in the cart based on the given prices. :param cart: Dictionary where keys are item names, and values are their respective quantities. :param prices: Dictionary where keys are item names, and values are their respective prices per unit. :return: Total cost as a float. Requirements: - If an item in the cart does not exist in the prices dictionary, raise a KeyError with the message \\"Item not found\\". - Quantities in the cart must be non-negative integers. If any quantity is negative, raise a ValueError with the message \\"Quantities must be non-negative integers\\". - If the cart is empty, return 0.0. Examples: >>> calculate_total({\\"apple\\": 2, \\"banana\\": 3}, {\\"apple\\": 0.5, \\"banana\\": 0.75}) 3.25 >>> calculate_total({}, {\\"apple\\": 0.5, \\"banana\\": 0.75}) 0.0 >>> calculate_total({\\"apple\\": 1, \\"banana\\": 1, \\"cherry\\": 1}, {\\"apple\\": 0.5, \\"banana\\": 0.75}) Traceback (most recent call last): ... KeyError: \'Item not found\' >>> calculate_total({\\"apple\\": -1, \\"banana\\": 3}, {\\"apple\\": 0.5, \\"banana\\": 0.75}) Traceback (most recent call last): ... ValueError: Quantities must be non-negative integers >>> calculate_total({\\"orange\\": 2}, {\\"apple\\": 0.5, \\"banana\\": 0.75, \\"orange\\": 1.25}) 2.5 pass ``` # Constraints - Focus on ensuring that your implementation handles all specified edge cases correctly. - Use dictionary lookups and arithmetic operations to compute the total cost efficiently. - Ensure robustness by validating inputs according to the requirements. - Make sure your function produces the correct output for all provided examples and any additional edge cases you consider. # Submission Please submit your function implementation along with a brief explanation of your approach and any additional test cases you added to ensure correctness.","solution":"def calculate_total(cart: dict[str, int], prices: dict[str, float]) -> float: Calculates the total cost of the items in the cart based on the given prices. :param cart: Dictionary where keys are item names, and values are their respective quantities. :param prices: Dictionary where keys are item names, and values are their respective prices per unit. :return: Total cost as a float. Raises: - KeyError if an item in cart does not exist in the prices dictionary with the message \\"Item not found\\". - ValueError if any quantity is negative with the message \\"Quantities must be non-negative integers\\". total_cost = 0.0 for item, quantity in cart.items(): if quantity < 0: raise ValueError(\\"Quantities must be non-negative integers\\") if item not in prices: raise KeyError(\\"Item not found\\") total_cost += quantity * prices[item] return total_cost"},{"question":"# Bulk Image Downloader You need to build a script that will download images from a given list of URLs. Your function should implement the following requirements: 1. Accept a list of URLs pointing to images. 2. For each image URL, download the image and save it locally. 3. Implement error handling for potential network issues or invalid URLs. 4. Maintain a log of the status (success or failure) of each download. The function signature should be: ```python def bulk_image_downloader(image_urls: list[str], save_dir: str) -> list[tuple[str, str]]: Downloads images from the provided list of URLs and saves them to the specified directory. Args: image_urls (list[str]): A list of URLs pointing to images. save_dir (str): The directory where the images will be saved. Returns: list[tuple[str, str]]: A list of tuples, each containing the URL and the status of the download (\'Success\' or \'Error: <error message>\'). ``` Input: - `image_urls` (list[str]): A list of strings where each string is a URL pointing to an image. - `save_dir` (str): The directory path where the images will be saved. Output: - Returns a list of tuples. Each tuple contains: - The original image URL (str). - The status of the download which can be \'Success\' or \'Error: <error message>\'. Constraints: - Ensure the directory exists before starting the downloads. - Handle network issues, invalid URLs, and file write errors gracefully. - Ensure filenames for images are formatted correctly with no spaces and safe for file systems. Example: Given a list of image URLs and a directory, the function should download each image and return a list of URLs with their download status. For example: ```python image_urls = [ \\"https://example.com/image1.jpg\\", \\"https://example.com/image2.png\\", \\"https://example.com/invalid.jpg\\" ] save_dir = \\"/path/to/save\\" bulk_image_downloader(image_urls, save_dir) ``` Example output: ```python [ (\\"https://example.com/image1.jpg\\", \\"Success\\"), (\\"https://example.com/image2.png\\", \\"Success\\"), (\\"https://example.com/invalid.jpg\\", \\"Error: 404 Not Found\\") ] ``` Here’s a code snippet to help you get started: ```python import os import requests from fake_useragent import UserAgent def bulk_image_downloader(image_urls: list[str], save_dir: str) -> list[tuple[str, str]]: Downloads images from the provided list of URLs and saves them to the specified directory. Args: image_urls (list[str]): A list of URLs pointing to images. save_dir (str): The directory where the images will be saved. Returns: list[tuple[str, str]]: A list of tuples, each containing the URL and the status of the download (\'Success\' or \'Error: <error message>\'). if not os.path.exists(save_dir): os.makedirs(save_dir) results = [] for url in image_urls: _, image_extension = os.path.splitext(os.path.basename(url)) image_title = url.split(\'/\')[-1] save_path = os.path.join(save_dir, image_title) headers = {\\"User-Agent\\": UserAgent().random} try: response = requests.get(url, headers=headers, timeout=10) response.raise_for_status() with open(save_path, \\"wb\\") as file: file.write(response.content) results.append((url, \\"Success\\")) except requests.RequestException as e: results.append((url, f\\"Error: {str(e)}\\")) except Exception as e: results.append((url, f\\"Error: {str(e)}\\")) return results ``` Test your function with various scenarios, including: - Valid and invalid URLs - Network failure cases - Attempting to save in a non-existent directory Good luck!","solution":"import os import requests def bulk_image_downloader(image_urls: list[str], save_dir: str) -> list[tuple[str, str]]: Downloads images from the provided list of URLs and saves them to the specified directory. Args: image_urls (list[str]): A list of URLs pointing to images. save_dir (str): The directory where the images will be saved. Returns: list[tuple[str, str]]: A list of tuples, each containing the URL and the status of the download (\'Success\' or \'Error: <error message>\'). if not os.path.exists(save_dir): os.makedirs(save_dir) results = [] for url in image_urls: try: response = requests.get(url, timeout=10) response.raise_for_status() # Use the basename of the URL to create a valid filename image_title = os.path.basename(url).replace(\' \', \'_\') save_path = os.path.join(save_dir, image_title) with open(save_path, \'wb\') as file: file.write(response.content) results.append((url, \\"Success\\")) except requests.RequestException as e: results.append((url, f\\"Error: {str(e)}\\")) except Exception as e: results.append((url, f\\"Error: {str(e)}\\")) return results"},{"question":"# Context: You are developing an inventory management system for a warehouse, which needs to dynamically adjust product positioning based on operational constraints. Part of the requirements includes efficiently handling bulk updates to product quantities. # Problem: Implement a function that updates the quantities of products in a warehouse following a specific list of operations. Each operation specifies an adjustment to the quantity of a product identified by its ID. Ensure your solution handles edge cases such as operations on non-existent product IDs and operations that reduce quantities below zero, which should be treated as setting the quantity to zero. # Function Signature: ```python def update_quantities(products: dict[int, int], operations: list[tuple[int, int]]) -> dict[int, int]: Updates the quantities of products based on a list of operations. :param products: Dictionary of product IDs and their current quantities. :param operations: List of tuples where each tuple contains a product ID and the quantity adjustment. :return: Updated dictionary with adjusted quantities for the products. ``` # Input: - `products`: A dictionary where keys are product IDs (integers) and values are their quantities (integers). - `operations`: A list of operations represented as tuples. Each tuple contains: - `product_id` (int): The product ID. - `quantity_adjustment` (int): The quantity adjustment which can be positive (increasing quantity) or negative (decreasing quantity). # Output: - A dictionary with product IDs as keys and updated quantities as values. # Constraints: 1. All product IDs in `products` are unique. 2. Initial quantities in `products` and adjustments in `operations` can be zero or positive integers. 3. Adjustments resulting in negative quantities should be treated as setting the quantity to zero. 4. Operations referencing non-existent product IDs should be ignored. # Examples: ```python >>> products = {1: 10, 2: 5, 3: 2} >>> operations = [(1, -3), (2, 6), (4, 5), (3, -3)] >>> update_quantities(products, operations) {1: 7, 2: 11, 3: 0} ``` # Notes: - Make sure your solution efficiently handles updates, especially for large datasets. - Handle operations for product IDs not in the initial inventory gracefully by ignoring them. - Ensure the quantities are never negative; any operation resulting in a negative quantity should set the quantity to zero instead.","solution":"def update_quantities(products: dict[int, int], operations: list[tuple[int, int]]) -> dict[int, int]: Updates the quantities of products based on a list of operations. :param products: Dictionary of product IDs and their current quantities. :param operations: List of tuples where each tuple contains a product ID and the quantity adjustment. :return: Updated dictionary with adjusted quantities for the products. for product_id, adjustment in operations: if product_id in products: products[product_id] += adjustment if products[product_id] < 0: products[product_id] = 0 return products"},{"question":"# A Program to Determine Leap Years Your task is to write a function that determines if a given year is a leap year or not. Leap years are special years that have a different number of days than common years, and the rules for determining if a year is a leap year are as follows: 1. A year is a leap year if it is divisible by 4, but centuries (multiples of 100) are not leap years unless they are divisible by 400. 2. This means that the years 1600 and 2000 are leap years, but 1700, 1800, and 1900 are not. Function Signature ```python def is_leap_year(year: int) -> bool: ``` Expected Input and Output * **Input**: * `year` (int): The year to be checked, between 1 and 9999 (inclusive). * **Output**: * A boolean value indicating whether the year is a leap year (`True`) or not (`False`). Constraints * The year should be between 1 and 9999 (inclusive). Examples ```python assert is_leap_year(2020) == True assert is_leap_year(2019) == False assert is_leap_year(2000) == True assert is_leap_year(1900) == False assert is_leap_year(1600) == True assert is_leap_year(1700) == False assert is_leap_year(2400) == True ``` Instructions 1. **Implement the function**: Implement the `is_leap_year` function using the rules described. 2. **Edge cases**: Ensure your function correctly handles century years and the lower and upper bounds of the given range. 3. **Validation**: Validate input to ensure the provided year is within the specified range. 4. **Performance**: Ensure your implementation is efficient and clean, with time complexity of O(1).","solution":"def is_leap_year(year: int) -> bool: Determine if a given year is a leap year. A year is a leap year if: - It is divisible by 4, and: - It is not a century year (i.e., not divisible by 100) unless it is also divisible by 400. Args: year (int): The year to check. Should be between 1 and 9999 (inclusive). Returns: bool: True if the year is a leap year, False otherwise. if year < 1 or year > 9999: raise ValueError(\\"Year must be between 1 and 9999 (inclusive)\\") if (year % 4 == 0) and (year % 100 != 0 or year % 400 == 0): return True return False"},{"question":"# Question: Implement a Comprehensive Error Logging System You are tasked with improving the error handling and logging capabilities of an existing system to ensure better maintainability and debugability of the code. Problem Statement Extend the `ErrorLogger` class to include functionality for dynamically managing different log levels (INFO, WARNING, ERROR) and appropriately handling errors within the system. Requirements 1. **Extend ErrorLogger\'s logging function**: - Implement dynamic log levels (INFO, WARNING, ERROR). - Ensure that each log entry contains a timestamp, log level, and a descriptive message. - Implement a method to retrieve logs by a specific level or time range. 2. **Add Exception Handling and Logging**: - Modify the `SafeOperation` class so that any exceptions raised during operations are caught and logged using the `ErrorLogger`. Input and Output - The logging function should accept inputs for the message and log level, and store logs with timestamps. - The method `get_logs` should allow retrieval of logs by level or time range. Constraints - Avoid performance overhead while adding logging capabilities. - Ensure compatibility with the existing system. - Handle edge cases where log entries might be large or frequent. Testing and Performance - Ensure that the extended functionality does not introduce significant performance degradation. - Add test cases to validate the log levels and retrieval functionality. Example ```python logger = ErrorLogger() logger.log(\\"This is an info message.\\", level=\\"INFO\\") logger.log(\\"This is a warning message.\\", level=\\"WARNING\\") logger.log(\\"This is an error message.\\", level=\\"ERROR\\") def safe_division(a, b): try: return a / b except ZeroDivisionError as e: logger.log(f\\"Division by zero occurred: {e}\\", level=\\"ERROR\\") return float(\'inf\') with SafeOperation(logger) as tracker: result = safe_division(10, 0) info_logs = logger.get_logs(level=\\"INFO\\") error_logs = logger.get_logs(level=\\"ERROR\\") print(\\"Info Logs:\\", info_logs) print(\\"Error Logs:\\", error_logs) ``` Output: ```plaintext Info Logs: [\'[Timestamp] INFO: This is an info message.\'] Error Logs: [\'[Timestamp] ERROR: Division by zero occurred: division by zero\'] ``` Implement the above solution and validate using test cases to handle various logging levels and correct retrieval of log messages.","solution":"import logging import datetime class ErrorLogger: def __init__(self): self.logs = [] self.log_levels = {\\"INFO\\": logging.INFO, \\"WARNING\\": logging.WARNING, \\"ERROR\\": logging.ERROR} def log(self, message, level=\\"INFO\\"): if level not in self.log_levels: raise ValueError(\\"Invalid log level\\") timestamp = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") log_entry = f\\"[{timestamp}] {level}: {message}\\" self.logs.append((timestamp, level, log_entry)) def get_logs(self, level=None, start_time=None, end_time=None): filtered_logs = self.logs if level: filtered_logs = [log for log in filtered_logs if log[1] == level] if start_time: filtered_logs = [log for log in filtered_logs if log[0] >= start_time] if end_time: filtered_logs = [log for log in filtered_logs if log[0] <= end_time] return [log[2] for log in filtered_logs] class SafeOperation: def __init__(self, logger): self.logger = logger def __enter__(self): return self def __exit__(self, exc_type, exc_val, exc_tb): if exc_type is not None: self.logger.log(f\\"An exception occurred: {exc_val}\\", level=\\"ERROR\\") def safe_division(a, b, logger): try: return a / b except ZeroDivisionError as e: logger.log(f\\"Division by zero occurred: {e}\\", level=\\"ERROR\\") return float(\'inf\') # Example usage: # logger = ErrorLogger() # logger.log(\\"This is an info message.\\", level=\\"INFO\\") # logger.log(\\"This is a warning message.\\", level=\\"WARNING\\") # logger.log(\\"This is an error message.\\", level=\\"ERROR\\") # with SafeOperation(logger) as tracker: # result = safe_division(10, 0) # print(logger.get_logs(level=\\"INFO\\")) # print(logger.get_logs(level=\\"ERROR\\"))"},{"question":"Task Data Structures: Implementing a Linked List Queue You are required to implement a Queue using a Linked List in Python. The Queue should follow the FIFO (First In, First Out) principle where elements are added to the end and removed from the front. Your implementation should include standard queue operations, methods for checking empty status and queue length, and a method to convert the queue to a list for testing convenience. # Requirements: 1. **Node Class** - Implement a `Node` class to represent each element in the queue. - The node should have two attributes: `data` and `next`. 2. **Queue Class** - Create a `Queue` class to manage the linked list queue. The class should have the following methods: - `__init__(self)`: Initializes an empty queue. - `enqueue(self, data: any) -> None`: Adds an element to the end of the queue. - `dequeue(self) -> any`: Removes and returns an element from the front of the queue. If the queue is empty, raise an appropriate exception. - `is_empty(self) -> bool`: Checks if the queue is empty. - `size(self) -> int`: Returns the number of elements in the queue. - `to_list(self) -> list`: Converts the queue to a list for easy comparison and testing. # Constraints: - Ensure that the `enqueue` and `dequeue` operations have a time complexity of O(1). - Handle edge cases such as performing a `dequeue` operation on an empty queue by raising an appropriate exception. - You are not permitted to use Python\'s built-in collections like `list`, `deque`, or any other module that provides direct queue functionalities. # Example Usage: ```python class Node: def __init__(self, data): self.data = data self.next = None class Queue: def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, data: any) -> None: new_node = Node(data) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self._size += 1 def dequeue(self) -> any: if self.is_empty(): raise Exception(\\"Queue is empty\\") removed_data = self.front.data self.front = self.front.next if self.front is None: self.rear = None self._size -= 1 return removed_data def is_empty(self) -> bool: return self.front is None def size(self) -> int: return self._size def to_list(self) -> list: elements = [] current = self.front while current: elements.append(current.data) current = current.next return elements # Example test cases if __name__ == \'__main__\': q = Queue() assert q.is_empty() == True q.enqueue(10) q.enqueue(20) assert q.size() == 2 assert q.dequeue() == 10 assert q.dequeue() == 20 assert q.is_empty() == True try: q.dequeue() except Exception as e: assert str(e) == \\"Queue is empty\\" q.enqueue(30) q.enqueue(40) assert q.to_list() == [30, 40] print(\\"All tests passed!\\") ``` Implement these methods ensuring they adhere to the constraints, and test them using the provided example cases.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class Queue: def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, data: any) -> None: new_node = Node(data) if self.rear is None: self.front = self.rear = new_node else: self.rear.next = new_node self.rear = new_node self._size += 1 def dequeue(self) -> any: if self.is_empty(): raise Exception(\\"Queue is empty\\") removed_data = self.front.data self.front = self.front.next if self.front is None: self.rear = None self._size -= 1 return removed_data def is_empty(self) -> bool: return self.front is None def size(self) -> int: return self._size def to_list(self) -> list: elements = [] current = self.front while current: elements.append(current.data) current = current.next return elements"},{"question":"# Task: Create a Custom Merge Function for Sorted Lists Develop a function to merge two sorted lists into one sorted list. Your function should handle various edge cases and ensure that the merged list retains the sorted order. Specifically: 1. **Sorted Inputs**: Assume both input lists are already sorted in non-decreasing order. 2. **Handling Duplicates**: The function should preserve duplicates from the input lists in the merged list. 3. **Empty Lists**: If one or both input lists are empty, the resulting list should be correctly handled and still sorted. # Function Signature ```python def merge_sorted_lists(list1, list2): Merge two sorted lists into one sorted list. :param list1: List[int] :param list2: List[int] :return: List[int] - The merged sorted list >>> merge_sorted_lists([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_lists([1, 2, 2], [2, 2, 3]) [1, 2, 2, 2, 2, 3] >>> merge_sorted_lists([], [1, 2]) [1, 2] >>> merge_sorted_lists([], []) [] >>> merge_sorted_lists([1, 1], [1, 1]) [1, 1, 1, 1] # Your implementation here ``` # Constraints 1. The input lists are sorted in non-decreasing order. 2. The function should handle lists of any length, including zero. # Example Usages - `merge_sorted_lists([1, 3], [2, 4])` should return `[1, 2, 3, 4]`. - `merge_sorted_lists([1, 1], [1, 1])` should return `[1, 1, 1, 1]`. - `merge_sorted_lists([1, 2, 3], [])` should return `[1, 2, 3]`. - `merge_sorted_lists([], [1, 2, 3])` should return `[1, 2, 3]`. - `merge_sorted_lists([], [])` should return `[]`.","solution":"def merge_sorted_lists(list1, list2): Merge two sorted lists into one sorted list. :param list1: List[int] :param list2: List[int] :return: List[int] - The merged sorted list merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < len(list1): merged_list.append(list1[i]) i += 1 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Problem Description You are given a list of integers and you need to find the minimum number of jumps required to reach the end of the list, starting at the first position. Each element in the list represents the maximum number of steps you can jump forward from that position. # Task Implement two functions to solve this problem using both dynamic programming and a greedy approach. Both functions should adhere to the constraints and provide the expected output. # Function Signature ```python def min_jumps_dp(arr: list[int]) -> int: pass def min_jumps_greedy(arr: list[int]) -> int: pass ``` # Input - `arr` (list): A list of integers where the value at each index represents the maximum number of steps you can jump forward from that index. # Output - Return the minimum number of jumps needed to reach the end of the list. If it is not possible to reach the end, return -1. # Constraints - The list `arr` will contain at least one element and at most 1000 elements. - Each element in the list will be a non-negative integer. # Examples ```python # Main function signatures def min_jumps_dp(arr): pass def min_jumps_greedy(arr): pass # Minimum Jumps using Dynamic Programming assert min_jumps_dp([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3 assert min_jumps_dp([1, 1, 1, 1, 1]) == 4 assert min_jumps_dp([0, 1, 2, 3, 4]) == -1 assert min_jumps_dp([4, 1, 1, 1]) == 1 # Minimum Jumps using Greedy Approach assert min_jumps_greedy([1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9]) == 3 assert min_jumps_greedy([1, 1, 1, 1, 1]) == 4 assert min_jumps_greedy([0, 1, 2, 3, 4]) == -1 assert min_jumps_greedy([4, 1, 1, 1]) == 1 ``` # Hints - **Dynamic Programming Approach:** Build a `jumps` array where `jumps[i]` defines the minimum number of jumps required to reach position `i` from the start. - **Greedy Approach:** Track the farthest position that can be reached byte taking a given number of jumps. Use a variable to keep track of the current range within which we need a jump to reach as far as possible. Adjust jump count accordingly as you extend beyond the current range. # Notes - Ensure your solution is optimal and handles edge cases such as empty arrays, single-element arrays, or arrays where it is impossible to reach the end. - Test your functions with various scenarios to ensure accuracy and performance, especially for larger arrays.","solution":"def min_jumps_dp(arr: list[int]) -> int: n = len(arr) if n == 0 or arr[0] == 0: return -1 jumps = [float(\'inf\')] * n jumps[0] = 0 for i in range(1, n): for j in range(i): if i <= j + arr[j] and jumps[j] != float(\'inf\'): jumps[i] = min(jumps[i], jumps[j] + 1) break return -1 if jumps[-1] == float(\'inf\') else jumps[-1] def min_jumps_greedy(arr: list[int]) -> int: n = len(arr) if n == 0 or arr[0] == 0: return -1 jumps = 0 farthest = 0 current_end = 0 for i in range(n - 1): farthest = max(farthest, i + arr[i]) if i == current_end: jumps += 1 current_end = farthest if current_end >= n - 1: break return jumps if current_end >= n - 1 else -1"},{"question":"# Find the First Missing Positive Integer You are tasked to implement a function that finds the smallest positive integer missing from an unsorted array. This problem requires efficient algorithms to handle potentially large datasets within time and space constraints. Your solution should demonstrate knowledge of array manipulations and sorting mechanisms while keeping the implementation optimal. Function Signature ```python def first_missing_positive(nums: List[int]) -> int: ``` Input * `nums` - A list of integers which can contain both positive and negative numbers, as well as zero. Output * Returns the smallest missing positive integer from the array. Constraints * The function should handle arrays of length up to 10^5 efficiently. * The solution should have a time complexity of O(n) and space complexity of O(1). * Ensure only integer inputs are processed; if the input is non-integral or non-list, raise an appropriate exception. # Example Scenarios ```python >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive(\'123\') Traceback (most recent call last): ... TypeError: first_missing_positive() only accepts a list of integers >>> first_missing_positive([1.2, 2, 3]) Traceback (most recent call last): ... TypeError: first_missing_positive() only accepts a list of integers ``` # Guidelines 1. Develop an algorithm that can find the first missing positive integer in linear time. 2. Ensure the function is robust against incorrect input types and handles edge cases gracefully. 3. Implement the solution to run with constant additional space usage, without relying on extra data structures like sets or dictionaries. Happy coding!","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: if not isinstance(nums, list) or any(not isinstance(x, int) for x in nums): raise TypeError(\\"first_missing_positive() only accepts a list of integers\\") n = len(nums) # Place each number in its right place (i.e., nums[i] should be i+1) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Now, the first place where its number is not right, return the place + 1 for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Scenario You are developing a system that processes a large number of transactions in a financial application. One of the critical tasks is to ensure that the transaction ID generated is unique and follows a specific pattern. The transaction ID must be a unique identifier that contains both letters and digits with a fixed length. Your task is to implement a Python class that generates such transaction IDs and checks their validity. # Task 1. **Implement `TransactionIDGenerator` class** - Attributes: - `length`: An integer representing the length of the transaction ID. - `used_ids`: A set to store the IDs that have already been generated. - Methods: - `generate_id(self) -> str`: Generates a unique transaction ID of specified length. - `validate_id(self, id: str) -> bool`: Validates if the given ID is of correct length and contains only alphanumeric characters. # Requirements - The ID should be a string of specified length containing only alphanumeric characters (both uppercase and lowercase letters). - Ensure the generated ID is unique by storing previously generated IDs in a set. - The `validate_id` method should check if the ID length matches the specified length and if it contains only alphanumeric characters. # Constraints - The `length` attribute must be an integer greater than 0. - Raise a `ValueError` if the `length` is not a positive integer during class instantiation. - Raise a `ValueError` if the `validate_id` method receives an ID that does not meet the length criteria. # Example Usage ```python gen = TransactionIDGenerator(length=10) new_id = gen.generate_id() print(new_id) # Example output: \'a8N3Ks7Zl2\' is_valid = gen.validate_id(new_id) print(is_valid) # True # Invalid ID Check invalid_id = \'abc123\' is_valid = gen.validate_id(invalid_id) print(is_valid) # False ```","solution":"import random import string class TransactionIDGenerator: def __init__(self, length): if not isinstance(length, int) or length <= 0: raise ValueError(\\"Length must be a positive integer.\\") self.length = length self.used_ids = set() def generate_id(self): while True: new_id = \'\'.join(random.choices(string.ascii_letters + string.digits, k=self.length)) if new_id not in self.used_ids: self.used_ids.add(new_id) return new_id def validate_id(self, id): if len(id) != self.length: return False if not id.isalnum(): return False return True"},{"question":"**Scenario**: You are developing a role-playing game (RPG) with various types of characters such as warriors, mages, and archers. For the game logic, you need to implement a system that manages character attributes and skills, along with the inheritance of these properties in specific character types. **Requirements**: 1. Implement a base class `Character` with properties for name, health, attack power, and defense. 2. Implement two derived classes: `Warrior` and `Mage`, which inherit from `Character`. 3. Add unique skills for each derived character class (`Berserk` for Warrior and `CastSpell` for Mage). 4. Ensure that health, attack power, and defense can be modified through specific methods in the `Character` class. 5. Provide a string representation of each character detailing their name, health, attack power, defense, and skills. **Function Specifications**: - **__init__(name, health, attack_power, defense):** - Input: String representing the character\'s name, integers for health, attack power, and defense. - Initializes the character\'s properties. - **modify_health(amount):** - Input: Integer value to modify the character\'s health. - Output: None. Directly updates the health property. - **modify_attack_power(amount):** - Input: Integer value to modify the character\'s attack power. - Output: None. Directly updates the attack power property. - **modify_defense(amount):** - Input: Integer value to modify the character\'s defense. - Output: None. Directly updates the defense property. - **__str__():** - Input: None. - Output: String representing the character\'s details (name, health, attack power, defense, and skills). - **Berserk() (Warrior specific method):** - Input: None. - Output: String indicating that Berserk skill has been activated. - **CastSpell() (Mage specific method):** - Input: None. - Output: String indicating that CastSpell skill has been activated. ```python class Character: def __init__(self, name, health, attack_power, defense): self.name = name self.health = health self.attack_power = attack_power self.defense = defense def modify_health(self, amount): self.health += amount def modify_attack_power(self, amount): self.attack_power += amount def modify_defense(self, amount): self.defense += amount def __str__(self): return (f\\"Character: {self.name}, Health: {self.health}, Attack Power: {self.attack_power}, \\" f\\"Defense: {self.defense}\\") class Warrior(Character): def __init__(self, name, health, attack_power, defense): super().__init__(name, health, attack_power, defense) def Berserk(self): return f\\"{self.name} has activated Berserk!\\" def __str__(self): return super().__str__() + \\", Skill: Berserk\\" class Mage(Character): def __init__(self, name, health, attack_power, defense): super().__init__(name, health, attack_power, defense) def CastSpell(self): return f\\"{self.name} has cast a spell!\\" def __str__(self): return super().__str__() + \\", Skill: Cast Spell\\" ``` **Constraints**: 1. Health, attack power, and defense should always be non-negative. 2. String representation should be meaningful and accurately reflect the character\'s current state. **Example**: ```python warrior = Warrior(\\"Thor\\", 100, 25, 15) mage = Mage(\\"Merlin\\", 80, 30, 10) print(warrior) # Output: Character: Thor, Health: 100, Attack Power: 25, Defense: 15, Skill: Berserk print(mage) # Output: Character: Merlin, Health: 80, Attack Power: 30, Defense: 10, Skill: Cast Spell print(warrior.Berserk()) # Output: Thor has activated Berserk! print(mage.CastSpell()) # Output: Merlin has cast a spell! warrior.modify_health(-20) mage.modify_attack_power(5) print(warrior) # Output: Character: Thor, Health: 80, Attack Power: 25, Defense: 15, Skill: Berserk print(mage) # Output: Character: Merlin, Health: 80, Attack Power: 35, Defense: 10, Skill: Cast Spell ```","solution":"class Character: def __init__(self, name, health, attack_power, defense): self.name = name self.health = max(0, health) self.attack_power = max(0, attack_power) self.defense = max(0, defense) def modify_health(self, amount): self.health = max(0, self.health + amount) def modify_attack_power(self, amount): self.attack_power = max(0, self.attack_power + amount) def modify_defense(self, amount): self.defense = max(0, self.defense + amount) def __str__(self): return (f\\"Character: {self.name}, Health: {self.health}, Attack Power: {self.attack_power}, \\" f\\"Defense: {self.defense}\\") class Warrior(Character): def __init__(self, name, health, attack_power, defense): super().__init__(name, health, attack_power, defense) def Berserk(self): return f\\"{self.name} has activated Berserk!\\" def __str__(self): return super().__str__() + \\", Skill: Berserk\\" class Mage(Character): def __init__(self, name, health, attack_power, defense): super().__init__(name, health, attack_power, defense) def CastSpell(self): return f\\"{self.name} has cast a spell!\\" def __str__(self): return super().__str__() + \\", Skill: Cast Spell\\""},{"question":"# Question: Implement a class `RecentCounter` that calculates the number of recent requests in the past `t` milliseconds. The `RecentCounter` has the following methods: - `__init__()`: Initializes the counter with an empty list of requests. - `ping(t: int) -> int`: Adds a new request at time `t` (in milliseconds) and returns the number of requests that has taken place in the past `3000` milliseconds (including the new request). # Class Definition ```python class RecentCounter: def __init__(self): # Initialize your data structure here pass def ping(self, t: int) -> int: # Returns the number of pings within the last 3000 milliseconds pass ``` # Example: ```python >>> recentCounter = RecentCounter() >>> recentCounter.ping(1) 1 >>> recentCounter.ping(100) 2 >>> recentCounter.ping(3001) 3 >>> recentCounter.ping(3002) 3 ``` # Explanation: 1. At `t = 1`, there is only 1 request in the past `3000` milliseconds. 2. At `t = 100`, the requests are `[1, 100]`, both are within `3000` milliseconds. 3. At `t = 3001`, the requests are `[1, 100, 3001]`, all are within `3000` milliseconds. 4. At `t = 3002`, the requests are `[100, 3001, 3002]`, only the last three are within `3000` milliseconds. # Constraints: - The input is guaranteed to always be greater than any previous input (non-decreasing order). - The function should scale to handle a large number of ping requests efficiently.","solution":"from collections import deque class RecentCounter: def __init__(self): self.requests = deque() def ping(self, t: int) -> int: self.requests.append(t) while self.requests and self.requests[0] < t - 3000: self.requests.popleft() return len(self.requests)"},{"question":"# Problem: String Sequence Transformation with Dynamic Programming Context: You are working on a text processing tool, and an essential feature is transforming one string into another with the minimum number of operations. These operations can include insertions, deletions, and substitutions. Given the importance of performance, an efficient solution using dynamic programming is required. Task: 1. Implement an algorithm to find the minimum number of operations required to transform one string into another. 2. The function must utilize dynamic programming for efficiency. Requirements: * Validate the input strings to ensure they are both non-empty. * Use a 2D dynamic programming table to compute the minimum operations. * Properly handle edge cases, such as one string being empty. * Return the minimum number of operations needed to transform the first string into the second one. Function Signature: ```python def min_operations_to_transform(str1: str, str2: str) -> int: pass ``` Input: * `str1` - The source string to be transformed, a non-empty string. * `str2` - The target string to transform into, a non-empty string. Output: * An integer representing the minimum number of operations necessary to transform `str1` into `str2`. Constraints: * The length of both strings will not exceed 100. * The strings will contain only lowercase alphabetical characters. Examples: 1. For strings: ```python str1 = \\"horse\\" str2 = \\"ros\\" ``` The result should be: ```python 3 ``` Explanation: - \\"horse\\" -> \\"rorse\\" (substitute \'h\' with \'r\') - \\"rorse\\" -> \\"rose\\" (remove the \'r\') - \\"rose\\" -> \\"ros\\" (remove the \'e\') 2. For strings: ```python str1 = \\"intention\\" str2 = \\"execution\\" ``` The result should be: ```python 5 ``` Explanation: - \\"intention\\" -> \\"inention\\" (remove the \'t\') - \\"inention\\" -> \\"enention\\" (substitute \'i\' with \'e\') - \\"enention\\" -> \\"exention\\" (insert \'x\') - \\"exention\\" -> \\"exection\\" (substitute \'n\' with \'c\') - \\"exection\\" -> \\"execution\\" (insert \'u\')","solution":"def min_operations_to_transform(str1: str, str2: str) -> int: Computes the minimum number of operations needed to transform str1 into str2 using dynamic programming. m = len(str1) n = len(str2) # Initialize the DP table dp = [[0] * (n + 1) for _ in range(m + 1)] # Base case initialization for i in range(m + 1): dp[i][0] = i # cost of deleting all characters from str1 to match empty str2 for j in range(n + 1): dp[0][j] = j # cost of inserting all characters of str2 into empty str1 # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # no operation needed if characters match else: dp[i][j] = min(dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + 1) # substitution return dp[m][n]"},{"question":"# List Rotation Challenge Given a list of integers, write a function `rotate_list(nums: List[int], k: int) -> List[int]` that rotates the list to the right by `k` positions. The rotation should be done in-place and must be optimized for time complexity. Input * A list `nums` containing `n` integers where (1 ≤ n ≤ 10^5). * An integer `k` which denotes the number of positions to rotate the list (0 ≤ k < 10^5). Output * A list of integers that has been rotated to the right by `k` positions. Constraints * The input list can contain both positive and negative integers. * The function should handle cases where `k` is larger than the length of the list by rotating only the necessary amount. For example, rotating by the length of the list or any multiple of it results in the same list. * You should avoid using extra space for another list. Example ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([-1, -100, 3, 99], 1) == [99, -1, -100, 3] assert rotate_list([1], 0) == [1] assert rotate_list([1, 2], 5) == [2, 1] ``` # Context You are working on a project where cyclic shifts of data are a common operation, and you need an efficient way to rotate lists without additional memory overhead. # Notes Consider the edge cases such as: * The list with a single element. * Rotations for large `k` values. * The relationship between `k` and the list length to minimize unnecessary computations. * Ensure your solution handles large inputs efficiently within the given constraints.","solution":"from typing import List def rotate_list(nums: List[int], k: int) -> List[int]: Rotates the list to the right by k positions. n = len(nums) k = k % n # Handle the case where k is greater than list length if k == 0: return nums # No rotation needed if k is 0 # Reverse helpers def reverse(start: int, end: int): while start < end: nums[start], nums[end] = nums[end], nums[start] start, end = start + 1, end - 1 # Step 1: Reverse the entire list reverse(0, n-1) # Step 2: Reverse the first k elements reverse(0, k-1) # Step 3: Reverse the rest n-k elements reverse(k, n-1) return nums"},{"question":"# Problem Description You are tasked with implementing two functions to find the longest substring of a given string that contains at most `k` distinct characters. Function 1: Simple Sliding Window Approach Implement `longest_substring_with_k_distinct(s: str, k: int) -> str`: * **Input**: - `s`: A string containing only lowercase English letters. - `k`: An integer representing the maximum number of distinct characters. * **Output**: The longest substring of `s` that contains at most `k` distinct characters. Function 2: Optimized Sliding Window with Hash Map Implement `longest_substring_with_k_distinct_optimized(s: str, k: int) -> str`: * **Input**: - `s`: A string containing only lowercase English letters. - `k`: An integer representing the maximum number of distinct characters. * **Output**: The longest substring of `s` that contains at most `k` distinct characters. # Constraints 1. The length of the string `s` will be up to 10^5. 2. `k` will be in the range of 1 to 26. # Performance Requirements * Both functions should be capable of processing the input string efficiently within a reasonable time frame, ideally in linear time complexity, O(n). # Example ```python s = \\"eceba\\" k = 2 assert longest_substring_with_k_distinct(s, k) == \\"ece\\" assert longest_substring_with_k_distinct_optimized(s, k) == \\"ece\\" ``` Your task is to ensure both methods produce the correct longest substring for the given input constraints.","solution":"def longest_substring_with_k_distinct(s, k): Returns the longest substring with at most `k` distinct characters using the simple sliding window approach. if not s or k == 0: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 max_substr = \\"\\" char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr def longest_substring_with_k_distinct_optimized(s, k): Returns the longest substring with at most `k` distinct characters using the optimized sliding window approach. if not s or k == 0: return \\"\\" n = len(s) left = 0 right = 0 max_length = 0 max_substr = \\"\\" char_index_map = {} while right < n: char_index_map[s[right]] = right while len(char_index_map) > k: left_most = min(char_index_map.values()) del char_index_map[s[left_most]] left = left_most + 1 if right - left + 1 > max_length: max_length = right - left + 1 max_substr = s[left:right + 1] right += 1 return max_substr"},{"question":"# Task Description You need to create a function that simulates a simplified stock market analysis. The function should determine the best days to buy and sell a stock to maximize profit, given a list of daily stock prices. # Problem Statement Given a list of integers representing daily stock prices, implement a function to identify the best possible days to buy and sell on a single transaction to achieve the maximum profit. If no profit can be made, return zero. # Function Signature ```python def max_profit(prices: list) -> int: Finds the maximum profit that can be achieved from a single buy and sell transaction. ``` # Input * `prices` (List[int]): A list of integers representing the stock prices on each day. # Output * An integer representing the maximum profit that can be made from a single transaction. If no profit is possible, return 0. # Constraints * The length of the list (n) will be between 1 and 10^5. * Each stock price will be an integer between 1 and 10^5. # Examples ```python >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([3, 6, 1, 9, 2, 8]) 8 ``` # Additional Requirements 1. Implement the function with a time complexity of (O(n)) to efficiently handle the maximum input size. 2. The algorithm should traverse the list only once and use constant space. 3. Emphasize on computing the earliest best time to buy and sell for a maximum profit intuitively. # Scenario You need to devise an optimal strategy to maximize your returns from a one-time buy and sell transaction based solely on the provided stock prices over several days. Consider dynamic approaches to minimize time and computational complexity while evaluating possible profits.","solution":"def max_profit(prices: list) -> int: Finds the maximum profit that can be achieved from a single buy and sell transaction. :param prices: List of daily stock prices. :return: Maximum profit, or 0 if no profit can be made. if not prices: return 0 min_price = float(\'inf\') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Question Context You are working with a company that processes large datasets representing different events at specific timestamps. Management wants to find contiguous segments of time during which events maintain consistent behavior. Problem Given a list of tuples, where each tuple represents an event with a timestamp and a value, write a Python function `longest_streak` that returns the length of the longest contiguous sub-array where all values are equal. Requirements 1. Your function should handle edge cases such as an empty list and lists with varying timestamps and values. 2. The solution should be efficient with regard to both time and space complexity. Input and Output Formats * **Input**: A list of tuples, each containing a timestamp (integer) and an event value (integer or string). ```python def longest_streak(events: list) -> int: pass ``` * **Output**: An integer representing the length of the longest contiguous sub-array where all event values are the same. Constraints * The list may contain up to (10^6) tuples. * Event values (2nd element of each tuple) will be either integers or strings. Example ```python assert longest_streak([(1, \'a\'), (2, \'a\'), (3, \'b\'), (4, \'b\'), (5, \'b\'), (6, \'a\')]) == 3 assert longest_streak([(1, \'x\'), (2, \'x\'), (3, \'x\'), (4, \'y\'), (5, \'y\'), (6, \'x\')]) == 3 assert longest_streak([(1, 1), (2, 2), (3, 2), (4, 2), (5, 1), (6, 1), (7, 1)]) == 3 assert longest_streak([(1, \'a\'), (2, \'b\'), (3, \'a\'), (4, \'a\'), (5, \'a\')]) == 3 assert longest_streak([(1, \'a\')]) == 1 assert longest_streak([]) == 0 ``` **Note**: Your solution should prioritize performance to efficiently handle large datasets, ensuring correct identification of longest contiguous segments with consistent values.","solution":"def longest_streak(events): if not events: return 0 max_streak = 1 current_streak = 1 for i in range(1, len(events)): if events[i][1] == events[i - 1][1]: current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 return max(max_streak, current_streak)"},{"question":"# K-Nearest Neighbors (KNN) Algorithm Implementation In this assessment, you are required to implement a function for the K-Nearest Neighbors (KNN) classification algorithm. Your implementation should include proper distance calculation, neighbor selection, and class prediction. Objectives: 1. Design the function for **K-Nearest Neighbors (KNN)** classification. 2. Include error handling, including assertion errors for invalid inputs. Input * A feature matrix (numpy array) with dimensions m x n. * Labels array corresponding to the features. * A matrix of input samples to classify (numpy array) with dimensions k x n. * Number of neighbors to consider (k). Output * An array of predicted class labels for the input samples (numpy array). Constraints * The feature matrix will have at least one row and column. * The number of neighbors (k) should be a positive integer less than or equal to the number of training samples. Function Signature ```python def knn_classification(features: np.ndarray, labels: np.ndarray, samples: np.ndarray, k: int) -> np.ndarray: K-Nearest Neighbors Classification. Parameters: * features: The features extracted from the dataset (training data) * labels: The class labels of the training data * samples: The input samples to classify (testing data) * k: Number of neighbors to consider for classification Returns: Predicted class labels for the input samples ``` Example Usage ```python import numpy as np from sklearn.datasets import load_iris # Loading sample dataset data = load_iris() features = data[\'data\'] labels = data[\'target\'] # Creating test samples (taking first two samples from the dataset as test cases) samples = features[:2] # KNN Implementation predicted_labels = knn_classification(features, labels, samples, 3) print(predicted_labels) ``` Notes * Ensure that you include appropriate assertion checks within your function. * Use the provided examples for testing your function. * Aim for clean and readable code along with documentation where necessary.","solution":"import numpy as np from collections import Counter def knn_classification(features: np.ndarray, labels: np.ndarray, samples: np.ndarray, k: int) -> np.ndarray: K-Nearest Neighbors Classification. Parameters: * features: The features extracted from the dataset (training data) as numpy array of shape (m, n) * labels: The class labels of the training data as numpy array of shape (m,) * samples: The input samples to classify (testing data) as numpy array of shape (k, n) * k: Number of neighbors to consider for classification Returns: Predicted class labels for the input samples as numpy array of shape (k,) # Check input validity assert len(features) >= k > 0, \\"k must be a positive integer less than or equal to the number of training samples\\" assert len(features) == len(labels), \\"Features and labels must have the same length\\" assert features.shape[1] == samples.shape[1], \\"Feature dimension and sample dimension must match\\" def euclidean_distance(a, b): return np.sqrt(np.sum((a - b) ** 2)) def find_nearest_neighbors(sample): distances = [euclidean_distance(sample, feature) for feature in features] nearest_indices = np.argsort(distances)[:k] nearest_labels = labels[nearest_indices] return nearest_labels predictions = [] for sample in samples: nearest_labels = find_nearest_neighbors(sample) common_label = Counter(nearest_labels).most_common(1)[0][0] predictions.append(common_label) return np.array(predictions)"},{"question":"# Coding Assessment Question: **Problem Description**: You are tasked to implement a simplified version of a Convolutional Neural Network (CNN) from scratch. The primary goal of this exercise is to ensure your comprehension of the fundamental components of CNN and your ability to implement the convolutional and pooling layers manually. Specifically, your implementation will focus on building a CNN with one convolutional layer followed by a max-pooling layer. **Requirements**: Implement the `SimpleConvolutionalNeuralNetwork` class to perform image classification using a basic CNN structure. The implementation should include the following methods: 1. **Constructor `__init__(self, num_filters: int, filter_size: int, pool_size: int)`** - Initialize the CNN with the specified number of filters, filter size for the convolutional layer, and pool size for the max-pooling layer. 2. **Method `convolve(self, image: np.ndarray, filter: np.ndarray) -> np.ndarray`** - Perform convolution on the input image using the given filter. 3. **Method `max_pool(self, feature_map: np.ndarray, pool_size: int) -> np.ndarray`** - Perform max-pooling on the feature map using the given pool size. 4. **Method `forward(self, image: np.ndarray) -> np.ndarray`** - Perform a forward pass of the CNN on the input image, applying convolution followed by max-pooling. **Input/Output**: 1. **Constructor Parameters**: - `num_filters` (int): Number of convolutional filters. - `filter_size` (int): Size of the convolutional filters (assume square filters). - `pool_size` (int): Size of the pooling window (assume square pooling). 2. **Method Parameters for `convolve`**: - `image` (np.ndarray): Input image represented as a 2D array. - `filter` (np.ndarray): Convolutional filter represented as a 2D array of size (filter_size, filter_size). 3. **Method Parameters for `max_pool`**: - `feature_map` (np.ndarray): Feature map obtained after the convolution operation. - `pool_size` (int): Size of the max-pooling window. 4. **Method Output for `forward`**: - Return (np.ndarray): The feature maps after applying convolution and max-pooling. 5. **Constraints**: - Assume grayscale images for simplicity. - Assume stride of 1 for convolution. - The max-pooling operation should use non-overlapping windows. - The implementation should handle typical edge cases and provide efficient computation. **Performance Requirements**: - Ensure the solution is efficient in terms of computation for the convolution and pooling operations as discussed in the design. **Example**: ```python import numpy as np class SimpleConvolutionalNeuralNetwork: def __init__(self, num_filters: int, filter_size: int, pool_size: int): self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size # Randomly initialize filters self.filters = [np.random.randn(filter_size, filter_size) for _ in range(num_filters)] def convolve(self, image: np.ndarray, filter: np.ndarray) -> np.ndarray: # Implement convolution operation pass def max_pool(self, feature_map: np.ndarray, pool_size: int) -> np.ndarray: # Implement max-pooling operation pass def forward(self, image: np.ndarray) -> np.ndarray: # Implement forward pass pass if __name__ == \\"__main__\\": # Sample image (3x3) for demonstration purposes sample_image = np.array([[1, 2, 1], [2, 1, 0], [1, 0, 2]]) # Initialize the CNN model cnn = SimpleConvolutionalNeuralNetwork(num_filters=1, filter_size=2, pool_size=2) # Perform forward pass on the sample image output = cnn.forward(sample_image) print(\\"Output feature map after forward pass:n\\", output) ``` **Objective**: Ensure that you thoroughly understand the basic components of a convolutional neural network and can implement these components to solve simple image classification tasks.","solution":"import numpy as np class SimpleConvolutionalNeuralNetwork: def __init__(self, num_filters: int, filter_size: int, pool_size: int): self.num_filters = num_filters self.filter_size = filter_size self.pool_size = pool_size # Randomly initialize filters self.filters = [np.random.randn(filter_size, filter_size) for _ in range(num_filters)] def convolve(self, image: np.ndarray, filter: np.ndarray) -> np.ndarray: image_height, image_width = image.shape filter_height, filter_width = filter.shape output_height = image_height - filter_height + 1 output_width = image_width - filter_width + 1 output = np.zeros((output_height, output_width)) for i in range(output_height): for j in range(output_width): region = image[i:i + filter_height, j:j + filter_width] output[i, j] = np.sum(region * filter) return output def max_pool(self, feature_map: np.ndarray, pool_size: int) -> np.ndarray: fm_height, fm_width = feature_map.shape output_height = fm_height // pool_size output_width = fm_width // pool_size output = np.zeros((output_height, output_width)) for i in range(output_height): for j in range(output_width): region = feature_map[i * pool_size:(i + 1) * pool_size, j * pool_size:(j + 1) * pool_size] output[i, j] = np.max(region) return output def forward(self, image: np.ndarray) -> np.ndarray: features = [] for filter in self.filters: convolved = self.convolve(image, filter) pooled = self.max_pool(convolved, self.pool_size) features.append(pooled) return np.array(features) if __name__ == \\"__main__\\": # Sample image (3x3) for demonstration purposes sample_image = np.array([[1, 2, 1], [2, 1, 0], [1, 0, 2]]) # Initialize the CNN model cnn = SimpleConvolutionalNeuralNetwork(num_filters=1, filter_size=2, pool_size=2) # Perform forward pass on the sample image output = cnn.forward(sample_image) print(\\"Output feature map after forward pass:n\\", output)"},{"question":"# Scenario In computational geometry, the concept of vector normalization is frequently used. Normalizing a vector scales it to unit length while preserving its direction, which can be critical in graphics, physics simulations, and machine learning. # Problem Create a function: 1. `normalize_vector(vector: List[float]) -> List[float]`: This function should take a vector in the form of a list of floats and return a new vector that has been normalized. # Requirements - Implement the function to correctly handle the normalization process. - Raise a `ValueError` with an appropriate message if the input vector has a magnitude of zero or if any non-numeric value is found in the input list. # Function Signature ```python from typing import List def normalize_vector(vector: List[float]) -> List[float]: ... ``` # Input and Output - **Input**: A list of floats `vector` representing the components of the vector. - **Output**: A list of floats representing the normalized vector. # Constraints - The vector will have a length between 2 and 10 inclusive. - The values in the vector will range from -10^9 to 10^9. - Handling of input validation for zero magnitude and non-numeric values is required. # Examples - `normalize_vector([3.0, 4.0])` should return `[0.6, 0.8]`. - `normalize_vector([0.0, 0.0, 0.0])` should raise a `ValueError` with the message \\"Cannot normalize a zero vector.\\" - `normalize_vector([1.0, \'a\'])` should raise a `ValueError` with the message \\"All elements of the vector must be numeric.\\" # Testing Use Python\'s built-in `doctest` module to provide test cases demonstrating the usage and correctness of the function. ```python def normalize_vector(vector: List[float]) -> List[float]: >>> normalize_vector([3.0, 4.0]) [0.6, 0.8] >>> normalize_vector([0.0, 0.0, 0.0]) Traceback (most recent call last): ... ValueError: Cannot normalize a zero vector. >>> normalize_vector([1.0, \'a\']) Traceback (most recent call last): ... ValueError: All elements of the vector must be numeric. import math # Check for non-numeric values if any(not isinstance(x, (int, float)) for x in vector): raise ValueError(\\"All elements of the vector must be numeric.\\") # Compute the magnitude of the vector magnitude = math.sqrt(sum(x**2 for x in vector)) # Check for zero magnitude if magnitude == 0: raise ValueError(\\"Cannot normalize a zero vector.\\") # Normalize the vector return [x / magnitude for x in vector] ```","solution":"from typing import List def normalize_vector(vector: List[float]) -> List[float]: Normalizes a vector to unit length. Args: vector (List[float]): The vector to be normalized. Returns: List[float]: The normalized vector. Raises: ValueError: If the vector has a magnitude of zero or contains non-numeric values. import math # Check for non-numeric values if any(not isinstance(x, (int, float)) for x in vector): raise ValueError(\\"All elements of the vector must be numeric.\\") # Compute the magnitude of the vector magnitude = math.sqrt(sum(x**2 for x in vector)) # Check for zero magnitude if magnitude == 0: raise ValueError(\\"Cannot normalize a zero vector.\\") # Normalize the vector return [x / magnitude for x in vector]"},{"question":"# Optimizing Warehouse Inventory with Hash Maps You are working on an inventory system for a warehouse that needs to efficiently manage stock levels of various items. Your task is to implement a class `InventoryManager` which uses a hash map (dictionary) to keep track of the quantity of each item in the inventory. **Class Definition**: ```python class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, item: str, quantity: int) -> None: Adds the specified quantity of the item to the inventory. If the item already exists, increment its quantity by the specified amount. Otherwise, add the item to the inventory with the specified quantity. :param item: A string representing the name of the item. :param quantity: An integer representing the quantity of the item to be added. def remove_item(self, item: str, quantity: int) -> bool: Removes the specified quantity of the item from the inventory. If the item does not exist in the inventory or if the specified quantity exceeds the current stock, the method returns False and the inventory remains unchanged. Otherwise, decrement the item\'s quantity by the specified amount and return True. :param item: A string representing the name of the item. :param quantity: An integer representing the quantity of the item to be removed. :return: A boolean indicating whether the removal was successful. def get_stock(self, item: str) -> int: Returns the current quantity of the specified item in the inventory. If the item does not exist, return 0. :param item: A string representing the name of the item. :return: An integer representing the quantity of the item currently in stock. ``` **Constraints**: - Item names are unique and are case-sensitive. - Item quantities are always non-negative integers. - Invalid operations (like removing more items than available or removing a non-existing item) should be correctly handled. # Example ```python # Initializing the InventoryManager inventory_manager = InventoryManager() # Adding items to the inventory inventory_manager.add_item(\\"apple\\", 50) inventory_manager.add_item(\\"banana\\", 30) inventory_manager.add_item(\\"apple\\", 20) # Removing items from the inventory print(inventory_manager.remove_item(\\"apple\\", 40)) # Output: True print(inventory_manager.remove_item(\\"banana\\", 40)) # Output: False # Checking stock levels print(inventory_manager.get_stock(\\"apple\\")) # Output: 30 print(inventory_manager.get_stock(\\"banana\\")) # Output: 30 print(inventory_manager.get_stock(\\"cherry\\")) # Output: 0 ``` Write the implementation for the `InventoryManager` class ensuring it adheres to the above specifications and requirements.","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, item: str, quantity: int) -> None: Adds the specified quantity of the item to the inventory. If the item already exists, increment its quantity by the specified amount. Otherwise, add the item to the inventory with the specified quantity. :param item: A string representing the name of the item. :param quantity: An integer representing the quantity of the item to be added. if item in self.inventory: self.inventory[item] += quantity else: self.inventory[item] = quantity def remove_item(self, item: str, quantity: int) -> bool: Removes the specified quantity of the item from the inventory. If the item does not exist in the inventory or if the specified quantity exceeds the current stock, the method returns False and the inventory remains unchanged. Otherwise, decrement the item\'s quantity by the specified amount and return True. :param item: A string representing the name of the item. :param quantity: An integer representing the quantity of the item to be removed. :return: A boolean indicating whether the removal was successful. if item not in self.inventory or self.inventory[item] < quantity: return False self.inventory[item] -= quantity if self.inventory[item] == 0: del self.inventory[item] return True def get_stock(self, item: str) -> int: Returns the current quantity of the specified item in the inventory. If the item does not exist, return 0. :param item: A string representing the name of the item. :return: An integer representing the quantity of the item currently in stock. return self.inventory.get(item, 0)"},{"question":"# Problem Description In a game, every player is given a sequence of moves, where each move is represented by a string. A move can be one of the following: - \\"up\\" moves the player one step up. - \\"down\\" moves the player one step down. - \\"left\\" moves the player one step left. - \\"right\\" moves the player one step right. The player starts at position (0, 0) on an infinite grid. Your task is to write a function `final_position` that computes the player\'s final position after executing all the moves. # Function Signature ```python def final_position(moves: list[str]) -> tuple[int, int]: pass ``` # Input - `moves` (list of str): A list of moves the player makes, where each move is one of \\"up\\", \\"down\\", \\"left\\", or \\"right\\". # Output - tuple[int, int]: The final position of the player on the grid after all moves have been executed. The tuple represents the (x, y) coordinates. # Constraints - The length of the moves list will be at most 10,000. - All moves in the list are guaranteed to be valid strings from the set {\\"up\\", \\"down\\", \\"left\\", \\"right\\"}. # Examples ```python assert final_position([\\"up\\", \\"up\\", \\"left\\", \\"down\\", \\"right\\", \\"right\\"]) == (1, 1) assert final_position([\\"up\\", \\"up\\", \\"down\\", \\"down\\"]) == (0, 0) assert final_position([\\"left\\", \\"left\\", \\"left\\", \\"right\\"]) == (-2, 0) assert final_position([\\"up\\", \\"right\\", \\"right\\", \\"down\\", \\"left\\"]) == (1, 0) assert final_position([]) == (0, 0) ``` **Note**: The function should handle cases where no moves are made, and the player remains at the starting position (0, 0). Ensure your solution efficiently processes the moves list within the given constraints.","solution":"def final_position(moves: list[str]) -> tuple[int, int]: Computes the final position on the grid after executing all the moves. Arguments: moves -- a list of move strings (\\"up\\", \\"down\\", \\"left\\", \\"right\\") Returns: A tuple representing the final (x, y) coordinates on the grid. x, y = 0, 0 for move in moves: if move == \\"up\\": y += 1 elif move == \\"down\\": y -= 1 elif move == \\"left\\": x -= 1 elif move == \\"right\\": x += 1 return (x, y)"},{"question":"# Data Processing and Transformation **Scenario**: You are part of a team developing a data analytics platform. One of the tasks involves transforming datasets into different formats to facilitate various analytical processes. Your current task is to implement a function that converts a list of dictionaries into a list of tuples based on specified keys. **Task**: Implement the `DataTransformer` class with methods to transform and revert data structures while ensuring robust performance and error handling. **Function Signatures**: ```python class DataTransformer: @staticmethod def dicts_to_tuples(data: list[dict], keys: list[str]) -> list[tuple]: pass @staticmethod def tuples_to_dicts(tuples: list[tuple], keys: list[str]) -> list[dict]: pass ``` **Requirements**: 1. **Dicts to Tuples Function (`dicts_to_tuples`)**: - Takes a list of dictionaries `data` and a list of keys `keys` as input. - Returns a list of tuples, where each tuple contains the values corresponding to the specified keys in each dictionary. - Handle missing keys by raising a `KeyError` and ensure edge cases like empty lists are handled gracefully. 2. **Tuples to Dicts Function (`tuples_to_dicts`)**: - Takes a list of tuples `tuples` and a list of keys `keys`. - Returns a list of dictionaries, where each dictionary is reconstructed from the tuple values and corresponding keys. - Ensure that the length of each tuple matches the number of keys, raising a `ValueError` if not. **Constraints**: - The `data` input to the `dicts_to_tuples` function will have dictionaries with string keys and values of various types. - The `tuples` input to the `tuples_to_dicts` function will be lists of tuples with lengths matching the `keys` list. - The lengths of `data` and `keys` lists will be between 0 and 10,000. **Example**: ```python data = [ {\\"name\\": \\"Alice\\", \\"age\\": 30, \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"city\\": \\"San Francisco\\"} ] keys = [\\"name\\", \\"age\\"] >>> DataTransformer().dicts_to_tuples(data, keys) [(\\"Alice\\", 30), (\\"Bob\\", 25)] >>> tuples = [(\\"Alice\\", 30), (\\"Bob\\", 25)] >>> keys = [\\"name\\", \\"age\\"] >>> DataTransformer().tuples_to_dicts(tuples, keys) [{\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\', \'age\': 25}] ``` Ensure your implementation is efficient and handles errors gracefully. Validate your solution with multiple test cases covering different edge cases and potential errors.","solution":"class DataTransformer: @staticmethod def dicts_to_tuples(data: list[dict], keys: list[str]) -> list[tuple]: result = [] for item in data: try: result.append(tuple(item[key] for key in keys)) except KeyError as e: raise KeyError(f\\"Missing key in data: {e}\\") return result @staticmethod def tuples_to_dicts(tuples: list[tuple], keys: list[str]) -> list[dict]: if not all(len(t) == len(keys) for t in tuples): raise ValueError(\\"All tuples must have the same length as keys.\\") return [dict(zip(keys, values)) for values in tuples]"},{"question":"**Context**: You are asked to develop a command line application that simulates a simplified version of a task management system. This system needs to handle user inputs, store tasks, and allow users to add, remove, and list tasks. **Objective**: Implement a class `TaskManager` that provides methods for handling tasks and simulating a command line interface to interact with the task list. # Requirements: 1. **Class Definition**: Create a class `TaskManager` that will keep track of the tasks. 2. **Methods to Implement**: * `add_task(self, task: str) -> None`: Adds a new task to the task list. * `remove_task(self, task: str) -> bool`: Removes the specified task from the list. Returns `True` if the task was removed, `False` otherwise. * `list_tasks(self) -> List[str]`: Returns a list of all tasks. 3. **Command Line Interface**: Implement a static method `main` to simulate user interaction: * Handle commands `add <task>`, `remove <task>`, and `list` to manipulate and view the tasks. * Utilize a loop to keep processing user commands until the `exit` command is entered. # Define Class Structure ```python from typing import List class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task: str) -> None: Add a new task to the task list. self.tasks.append(task) def remove_task(self, task: str) -> bool: Remove the specified task from the task list. if task in self.tasks: self.tasks.remove(task) return True return False def list_tasks(self) -> List[str]: List all tasks. return self.tasks @staticmethod def main(): Simulate the command line interface for task management. manager = TaskManager() while True: command = input(\\"Enter command: \\").strip().split(\' \', 1) action = command[0] if action == \'exit\': break elif action == \'add\': if len(command) > 1: manager.add_task(command[1]) print(f\\"Task \'{command[1]}\' added.\\") else: print(\\"No task provided to add.\\") elif action == \'remove\': if len(command) > 1: if manager.remove_task(command[1]): print(f\\"Task \'{command[1]}\' removed.\\") else: print(f\\"Task \'{command[1]}\' not found.\\") else: print(\\"No task provided to remove.\\") elif action == \'list\': tasks = manager.list_tasks() if tasks: for idx, task in enumerate(tasks, 1): print(f\\"{idx}. {task}\\") else: print(\\"No tasks available.\\") else: print(\\"Unknown command. Use add, remove, list, or exit.\\") # Example usage # TaskManager.main() ``` # Instructions 1. **Initialization**: The `TaskManager` class should be initialized without any parameters. 2. **Adding Tasks**: The `add_task` method should append a new task to the list of tasks. 3. **Removing Tasks**: The method `remove_task` should find and remove the task if it exists, returning `True` if the task was successfully removed. 4. **Listing Tasks**: The `list_tasks` method should return a list of all tasks. 5. **Command Line Interface**: The `main` method should keep reading user commands until the `exit` command is entered. It should handle the user commands accurately and provide feedback. # Constraints * Individual tasks are strings with a maximum length of 255 characters. * Task names are case-sensitive. * The command line interface runs in a loop until the `exit` command is entered. # Example ``` # Example usage # When running TaskManager.main() Enter command: add Task 1 Task \'Task 1\' added. Enter command: add Task 2 Task \'Task 2\' added. Enter command: list 1. Task 1 2. Task 2 Enter command: remove Task 1 Task \'Task 1\' removed. Enter command: list 1. Task 2 Enter command: exit ``` Your task is to implement the `TaskManager` class and ensure the command line interface behaves as described.","solution":"from typing import List class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task: str) -> None: Add a new task to the task list. self.tasks.append(task) def remove_task(self, task: str) -> bool: Remove the specified task from the task list. if task in self.tasks: self.tasks.remove(task) return True return False def list_tasks(self) -> List[str]: List all tasks. return self.tasks @staticmethod def main(): Simulate the command line interface for task management. manager = TaskManager() while True: command = input(\\"Enter command: \\").strip().split(\' \', 1) action = command[0] if action == \'exit\': break elif action == \'add\': if len(command) > 1: manager.add_task(command[1]) print(f\\"Task \'{command[1]}\' added.\\") else: print(\\"No task provided to add.\\") elif action == \'remove\': if len(command) > 1: if manager.remove_task(command[1]): print(f\\"Task \'{command[1]}\' removed.\\") else: print(f\\"Task \'{command[1]}\' not found.\\") else: print(\\"No task provided to remove.\\") elif action == \'list\': tasks = manager.list_tasks() if tasks: for idx, task in enumerate(tasks, 1): print(f\\"{idx}. {task}\\") else: print(\\"No tasks available.\\") else: print(\\"Unknown command. Use add, remove, list, or exit.\\")"},{"question":"# Problem Statement You are required to simulate a simple file system where files and directories can be created, listed, and have their sizes calculated. The file system should support hierarchical structure and basic operations such as adding files, deleting files, creating directories, and file size calculation. # Requirements Implement a class `FileSystem` with the following methods: 1. `create_directory(path: str) -> None` - Creates a new directory at the specified `path`, where `path` is a string representing the hierarchy separated by slashes `/`. 2. `create_file(path: str, size: int) -> None` - Creates a new file at the specified `path` with the given `size` in bytes. All parent directories in the path must exist. 3. `list_directory(path: str) -> list[str]` - Lists all files and directories at the specified `path`. 4. `delete(path: str) -> None` - Deletes the file or directory at the specified `path`. If the path is a directory, all its contents must be deleted recursively. 5. `calculate_size(path: str) -> int` - Returns the cumulative size of the directory at the specified `path` in bytes. If the path is a file, return its size in bytes. # Components - **Path**: A string representing the hierarchy of directories and/or files, similar to file paths in operating systems. - **Directory Structure**: Directories can contain other directories or files. - **File Size**: Size of each file in bytes. # Input Constraints: - `path`: A string with valid directory and file names separated by slashes `/`. - `size`: An integer representing the size of a file in bytes which will be a non-negative integer less than or equal to (2^{30}). # Expected Output: The class should support the operations to manipulate and query the file system structure. # Example: ```python fs = FileSystem() # Create directories fs.create_directory(\\"/docs\\") fs.create_directory(\\"/docs/personal\\") fs.create_directory(\\"/docs/work\\") # Create files fs.create_file(\\"/docs/personal/note.txt\\", 100) fs.create_file(\\"/docs/work/report.pdf\\", 200) fs.create_file(\\"/docs/work/summary.docx\\", 150) # List directory contents print(fs.list_directory(\\"/docs\\")) # Output: [\\"personal\\", \\"work\\"] # Calculate sizes print(fs.calculate_size(\\"/docs/personal\\")) # Output: 100 print(fs.calculate_size(\\"/docs/work\\")) # Output: 350 # Delete a file fs.delete(\\"/docs/personal/note.txt\\") print(fs.calculate_size(\\"/docs/personal\\")) # Output: 0 # Delete a directory fs.delete(\\"/docs/work\\") print(fs.calculate_size(\\"/docs\\")) # Output: 0 assuming only \\"personal\\" directory was present with no contents. ``` # Notes: 1. Handle errors in cases such as creating a file or directory where the parent directory does not exist, or deleting a file or directory that does not exist. 2. Ensure that the methods enforce valid operations. For example, trying to create a file where a directory should exist or vice versa should raise an error. 3. Optimize for performance, particularly for operations involving size calculations and recursive deletions.","solution":"class FileSystem: def __init__(self): self.fs = {\'/\': {}} def _parse_path(self, path): parts = path.strip(\\"/\\").split(\\"/\\") current = self.fs[\'/\'] for part in parts[:-1]: if part not in current or not isinstance(current[part], dict): raise ValueError(f\\"Directory {path} does not exist.\\") current = current[part] return current, parts[-1] def create_directory(self, path: str) -> None: current, name = self._parse_path(path) if name in current: raise ValueError(f\\"{path} already exists.\\") current[name] = {} def create_file(self, path: str, size: int) -> None: if size < 0 or size > (2 ** 30): raise ValueError(\\"Invalid file size.\\") current, name = self._parse_path(path) if name in current: raise ValueError(f\\"{path} already exists.\\") current[name] = size def list_directory(self, path: str) -> list[str]: current, name = self._parse_path(path) if name not in current or not isinstance(current[name], dict): raise ValueError(f\\"Directory {path} does not exist.\\") return list(current[name].keys()) def _delete_recursive(self, current, name): if isinstance(current[name], dict): for sub_name in list(current[name].keys()): self._delete_recursive(current[name], sub_name) del current[name] def delete(self, path: str) -> None: current, name = self._parse_path(path) if name not in current: raise ValueError(f\\"{path} does not exist.\\") self._delete_recursive(current, name) def _calculate_size_recursive(self, current): size = 0 for name in current: if isinstance(current[name], dict): size += self._calculate_size_recursive(current[name]) else: size += current[name] return size def calculate_size(self, path: str) -> int: current, name = self._parse_path(path) if name not in current: raise ValueError(f\\"{path} does not exist.\\") if isinstance(current[name], dict): return self._calculate_size_recursive(current[name]) return current[name]"},{"question":"# Problem Statement You are tasked with creating a function to validate email addresses based on specific criteria similar to the Sri Lankan phone number validation. The function should return `True` for valid email addresses and `False` otherwise. The email validation must conform to the criteria described below. # Valid Email Address Criteria 1. The email must contain exactly one `\'@\'` symbol. 2. The local part (the string before the `\'@\'`) may contain: - Alphabets (both uppercase and lowercase) - Digits - Dots (`.`) provided they are not consecutive or at the start/end. 3. The domain part (the string after the `\'@\'`) must: - Start and end with an alphabet or digit. - Contain one or more dot-separated parts, each part being alphabetic only. - Each part should be between 2 to 6 characters long. # Input - `email` (string): A string that represents the email address to verify. # Output - A boolean. `True` if the email address is valid, `False` otherwise. # Constraints - The input string length will be at most 320 characters. - The string will only contain printable ASCII characters. # Function Signature ```python def is_valid_email(email: str) -> bool: ``` # Example ```python >>> is_valid_email(\\"example.email@domain.com\\") True >>> is_valid_email(\\"username@some-domain.org\\") False >>> is_valid_email(\\"user.name@domain.co\\") True >>> is_valid_email(\\"username@domain..com\\") False >>> is_valid_email(\\"username@domain.c3m\\") False >>> is_valid_email(\\".user.name@domain.com\\") False >>> is_valid_email(\\"user..name@domain.com\\") False >>> is_valid_email(\\"username@domain.a\\") False ``` # Clarifications 1. Ensure to handle possible edge cases like consecutive dots in the local part. 2. Consider performance implications when dealing with very long strings. 3. Avoid overfitting the regex to special cases that could break the general validation logic.","solution":"import re def is_valid_email(email: str) -> bool: Validates if the given email address is valid based on certain criteria. Args: email (str): The email address to validate. Returns: bool: True if the email address is valid based on the given criteria, False otherwise. # Regex pattern to match valid email addresses based on the given criteria pattern = re.compile( r\'^(?!.*..)(?!^.)[A-Za-z0-9]+[A-Za-z0-9.-]*[A-Za-z0-9]+@[A-Za-z0-9]+(.[A-Za-z]{2,6})+\' ) return bool(pattern.match(email))"},{"question":"# Coding Assessment Question Question: You are given the task of implementing an algorithm to find the k most frequent elements in an array. The algorithm should be capable of efficiently handling large arrays with potential repeated elements. 1. **Input**: - An integer `n` representing the number of elements in the array. - A list `arr` of length `n` containing the elements. - An integer `k` representing the number of most frequent elements to return. 2. **Output**: - A list containing the `k` most frequent elements in the array. The order of the elements in the output list does not matter. 3. **Constraints**: - `1 <= n <= 10^5` - `0 <= arr[i] <= 10^9` - `1 <= k <= n` 4. **Performance Requirements**: - Optimize the algorithm to handle large input sizes efficiently. - Aim for a time complexity of O(n log k) or better. Implementation: Write a function `top_k_frequent_elements` in Python that takes the above inputs and outputs the `k` most frequent elements. Function signature: ```python def top_k_frequent_elements(n: int, arr: List[int], k: int) -> List[int]: ``` Example: ```python # Input n = 6 arr = [1, 1, 1, 2, 2, 3] k = 2 # Output [1, 2] # Input n = 8 arr = [4, 4, 4, 6, 6, 6, 6, 8] k = 1 # Output [6] ``` Description: Implement an algorithm to identify the k most frequent elements in the given array. In case of ties (elements with the same frequency), the order of the elements in the output list does not matter. Make sure the solution efficiently handles cases where the array contains a large number of elements. Consider using data structures like hash maps and priority queues to optimize the solution.","solution":"from typing import List from collections import Counter import heapq def top_k_frequent_elements(n: int, arr: List[int], k: int) -> List[int]: Return the k most frequent elements in the array. Parameters: n (int): Number of elements in the array arr (List[int]): List containing the elements k (int): Number of most frequent elements to return Returns: List[int]: List containing the k most frequent elements if n == 0: return [] # Count the frequency of each element frequency_map = Counter(arr) # Create a heap of the k most frequent elements most_frequent = heapq.nlargest(k, frequency_map.keys(), key=frequency_map.get) return most_frequent"},{"question":"# Problem Statement You are tasked with implementing a program that compresses a given string using a basic compression technique. Specifically, the program should count consecutive occurrences of characters in the string and compress the string by replacing these sequences with the character followed by its count. For example, the string \\"aaabbccccd\\" would be compressed to \\"a3b2c4d1\\". Note: - If the \\"compressed\\" string would not become shorter than the original string, return the original string. - Assume the input string contains only lowercase alphabetical characters. # Input Format 1. A single string `s`, where ( text{1} leq text{len(s)} leq 10^6 ). # Output Format - A string representing the compressed version of the input string, or the original string if the compressed version is not shorter. # Constraints * The input string `s` will contain only lowercase letters (`a-z`). * The length of the string `s` will be between 1 and (10^6). # Performance Requirements * Your solution should run efficiently even for the maximum input size of (10^6) characters. # Examples 1. **Input**: ``` s = \\"aaabbccccd\\" ``` **Output**: ``` \\"a3b2c4d1\\" ``` 2. **Input**: ``` s = \\"abcd\\" ``` **Output**: ``` \\"abcd\\" ``` 3. **Input**: ``` s = \\"aabbcc\\" ``` **Output**: ``` \\"aabbcc\\" ``` 4. **Input**: ``` s = \\"\\" ``` **Output**: ``` \\"\\" ``` # Function Signature ```python def compress_string(s: str) -> str: # Your code here ``` # Notes - Ensure your implementation correctly handles edge cases such as an empty string or a string with no repeated characters. - Aim for clean and readable code while maintaining optimal performance.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question Context You are developing a dynamic programming algorithm to solve the classic \\"coin change problem\\". The goal is to determine the minimum number of coins required to make up a given amount. Your implementation should efficiently handle different sets of coin denominations and various total amounts, including handling scenarios where it is impossible to make the exact amount with the given denominations. Task Implement a function `min_coins(coins: List[int], amount: int) -> int` that calculates the minimum number of coins required to make up the specified amount. 1. If the amount is 0, the function should return 0 (no coins are needed). 2. If it is impossible to make up the amount with the given coin denominations, the function should return -1. 3. The function should be efficient and handle large amounts gracefully. Input - `coins` (List[int]): A list of integers representing the different coin denominations available. - `amount` (int): The total amount you need to make up, which is a non-negative integer. Output - (int): The minimum number of coins needed to make up the given amount, or -1 if it\'s not possible. Constraints - 1 <= len(coins) <= 100 - 1 <= coins[i] <= 10,000 - 0 <= amount <= 1,000,000 Example ```python >>> min_coins([1, 2, 5], 11) 3 >>> min_coins([2], 3) -1 >>> min_coins([1, 2, 5], 0) 0 >>> min_coins([1], 1) 1 ``` # Notes: - You may use dynamic programming to optimize the solution. - Consider edge cases, such as when there are no coins available or when the amount is zero.","solution":"from typing import List def min_coins(coins: List[int], amount: int) -> int: Returns the minimum number of coins required to make up a given amount. If not possible, returns -1. # Edge case: if amount is 0, no coins are needed if amount == 0: return 0 # Initialize DP array with amount + 1 (a value larger than any possible minimum number of coins) dp = [amount + 1] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 # Compute the minimum coins for all amounts from 1 to the target amount for a in range(1, amount + 1): for coin in coins: if coin <= a: dp[a] = min(dp[a], dp[a - coin] + 1) # If dp[amount] is still amount + 1, it means it\'s not possible to make that amount return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"# Directory Size Calculator **Description**: You are tasked with creating a utility function to calculate the total size of files within a given directory. The function must recursively traverse the directory, including all its subdirectories, to sum up the sizes of each file. **Objective**: Write a function that calculates the total size of files in a directory, including all subdirectories. The function should: 1. Accept a single parameter: the path to the directory. 2. Return the total size in bytes of all files within the directory. **Input**: * A string representing the path to the directory (e.g., `\\"/Users/username/Documents\\"`). **Output**: * An integer representing the total size in bytes of all files within the directory. **Constraints**: * The directory path is a valid path on the system. * Handle large directories efficiently. * Your solution should handle symbolic links and avoid infinite loops caused by them. * Include error handling for scenarios such as permission denied or invalid directory paths. **Performance Requirements**: * The traversal and size calculation should be performed efficiently. * Ensure proper handling of edge cases such as empty directories, directories with no read permissions, etc. **Example**: Given a directory structure: ``` /example_dir file1.txt (100 bytes) file2.txt (200 bytes) subdir1/ file3.txt (300 bytes) subdir2/ file4.txt (400 bytes) ``` Calling `calculate_directory_size(\\"/example_dir\\")` should return `1000`. # Implementation Complete the function `calculate_directory_size(directory: str) -> int`: ```python import os def calculate_directory_size(directory: str) -> int: total_size = 0 for dirpath, dirnames, filenames in os.walk(directory): for file in filenames: file_path = os.path.join(dirpath, file) # Skip if it\'s a symbolic link to avoid infinite loops if not os.path.islink(file_path): try: total_size += os.path.getsize(file_path) except OSError: # Handle potential errors such as permission issues pass return total_size if __name__ == \\"__main__\\": directory_path = \\"/example_dir\\" size = calculate_directory_size(directory_path) print(f\\"The total size of the directory \'{directory_path}\' is {size} bytes\\") ``` Handle scenarios such as permission denied or invalid directory paths gracefully while ensuring proper handling of symbolic links to avoid infinite loops caused by recursive links. Happy coding!","solution":"import os def calculate_directory_size(directory: str) -> int: Calculates the total size in bytes of all files within the given directory, including all its subdirectories. Args: directory (str): Path to the directory. Returns: int: Total size in bytes. total_size = 0 for dirpath, dirnames, filenames in os.walk(directory): for file in filenames: file_path = os.path.join(dirpath, file) # Skip symbolic links to avoid infinite loops if not os.path.islink(file_path): try: total_size += os.path.getsize(file_path) except OSError: # Handle potential errors such as permission issues, missing files, etc. continue return total_size"},{"question":"# Binary Search Tree Operations **Scenario**: A Binary Search Tree (BST) is a data structure that maintains ordered data to allow for fast insertion, deletion, and lookup operations. In addition to the basic capabilities of a BST, supporting additional operations such as finding the k-th smallest/largest element and computing the rank of a given value can be highly useful. You are required to implement a class that models a BST and supports a variety of operations to enhance your understanding of the BST properties and use cases. **Task**: 1. Implement the `BST` class with the following methods: ```python class BST: def __init__(self): Initialize an empty BST. def insert(self, value: int) -> None: Insert a new value into the BST. Args: value (int): The value to insert into the BST. def delete(self, value: int) -> bool: Delete a value from the BST if it exists. Args: value (int): The value to delete from the BST. Returns: bool: True if the value was deleted, False if the value was not found. def find(self, value: int) -> bool: Check if a value exists in the BST. Args: value (int): The value to search for in the BST. Returns: bool: True if the value exists, False otherwise. def kth_smallest(self, k: int) -> int: Find the k-th smallest element in the BST. Args: k (int): The rank of the smallest element to find. Returns: int: The k-th smallest element. def kth_largest(self, k: int) -> int: Find the k-th largest element in the BST. Args: k (int): The rank of the largest element to find. Returns: int: The k-th largest element. def rank(self, value: int) -> int: Compute the rank of a given value in the BST (number of elements less than the value). Args: value (int): The value to compute the rank for. Returns: int: The rank of the value. ``` **Constraints**: - You may assume that the BST does not contain duplicate values. - The BST should handle up to 10^5 operations of insertion, deletion, and search efficiently. - Ensure your methods handle edge cases such as the tree being empty or the value not existing in the BST. **Input Format**: - `value` (int): The integer value to insert, delete, find, or compute rank for. - `k` (int): The rank position (starting from 1) for finding the k-th smallest/largest element. **Output Format**: - For `insert`, `delete`, and `find`: No output required, return relevant values according to the method specifications. - For `kth_smallest` and `kth_largest`: Return the integer value of the k-th smallest/largest element. - For `rank`: Return the integer rank of the provided value. **Examples**: ```python # Example usage of the BST class bst = BST() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) bst.insert(4) print(bst.find(4)) # Expected: True print(bst.find(6)) # Expected: False print(bst.kth_smallest(1)) # Expected: 1 print(bst.kth_smallest(3)) # Expected: 4 print(bst.kth_largest(1)) # Expected: 7 print(bst.kth_largest(3)) # Expected: 4 print(bst.rank(5)) # Expected: 4 bst.delete(3) print(bst.find(3)) # Expected: False ``` **Note**: Thoroughly test your implementation to ensure correctness and performance for various operations and edge cases within a BST.","solution":"class BSTNode: def __init__(self, value): self.value = value self.left = None self.right = None self.size = 1 # size of the subtree rooted with this node class BST: def __init__(self): self.root = None def _update_size(self, node): if node: node.size = 1 + (node.left.size if node.left else 0) + (node.right.size if node.right else 0) def insert(self, value: int) -> None: def _insert(node, value): if not node: return BSTNode(value) if value < node.value: node.left = _insert(node.left, value) else: node.right = _insert(node.right, value) self._update_size(node) return node self.root = _insert(self.root, value) def delete(self, value: int) -> bool: def _min_value_node(node): current = node while current.left: current = current.left return current def _delete(node, value): if not node: return node, False if value < node.value: node.left, deleted = _delete(node.left, value) elif value > node.value: node.right, deleted = _delete(node.right, value) else: if not node.left: return node.right, True elif not node.right: return node.left, True temp = _min_value_node(node.right) node.value = temp.value node.right, _ = _delete(node.right, temp.value) deleted = True if node: self._update_size(node) return node, deleted self.root, deleted = _delete(self.root, value) return deleted def find(self, value: int) -> bool: def _find(node, value): if not node: return False if value < node.value: return _find(node.left, value) elif value > node.value: return _find(node.right, value) else: return True return _find(self.root, value) def kth_smallest(self, k: int) -> int: def _kth_smallest(node, k): left_size = node.left.size if node.left else 0 if k <= left_size: return _kth_smallest(node.left, k) elif k == left_size + 1: return node.value else: return _kth_smallest(node.right, k - left_size - 1) if not self.root or k <= 0 or k > self.root.size: raise ValueError(\\"k is out of bounds\\") return _kth_smallest(self.root, k) def kth_largest(self, k: int) -> int: def _kth_largest(node, k): right_size = node.right.size if node.right else 0 if k <= right_size: return _kth_largest(node.right, k) elif k == right_size + 1: return node.value else: return _kth_largest(node.left, k - right_size - 1) if not self.root or k <= 0 or k > self.root.size: raise ValueError(\\"k is out of bounds\\") return _kth_largest(self.root, k) def rank(self, value: int) -> int: def _rank(node, value): if not node: return 0 if value < node.value: return _rank(node.left, value) elif value > node.value: left_size = node.left.size if node.left else 0 return left_size + 1 + _rank(node.right, value) else: left_size = node.left.size if node.left else 0 return left_size return _rank(self.root, value)"},{"question":"# **Coding Assessment Question: Shortest Path in Weighted Directed Graph** You are a software engineer at a delivery company, and your task is to develop a system that finds the shortest paths from the company\'s headquarters to various delivery locations, given a directed and weighted graph of roads connecting these locations. Your goal is to implement Dijkstra\'s algorithm to find the shortest path from a starting node to all other nodes in the graph efficiently. **Task**: Design and implement a function `dijkstra_shortest_paths(graph: GraphDirectedWeighted[T], start: T) -> tuple[dict[T, int], dict[T, T | None]]` that uses an enhanced priority queue to find the shortest paths from the starting node to all other nodes. **Input and Notes**: 1. The input parameter, `graph`, is an instance of the `GraphDirectedWeighted`: ```python class GraphDirectedWeighted(Generic[T]): def add_node(self, node: T) -> None: # Adds the node to the graph def add_edge(self, node1: T, node2: T, weight: int) -> None: # Adds a directed edge from node1 to node2 with the given weight ``` 2. Each node in the graph is unique, and the graph uses non-negative integer weights. 3. Assume all nodes are reachable from the starting node, and the graph is non-empty. **Output**: 1. `dist`: A dictionary where `dist[node]` represents the shortest distance from the start node to the node. 2. `parent`: A dictionary where `parent[node]` is the preceding node in the shortest path from the start node or `None` if it’s the start node. **Constraints**: * **Performance**: The solution should be efficient in time and space complexity, optimized for larger graphs with up to 10^5 nodes and 10^6 edges. **Example**: ```python graph = GraphDirectedWeighted() graph.add_edge(\\"A\\", \\"B\\", 1) graph.add_edge(\\"A\\", \\"C\\", 4) graph.add_edge(\\"B\\", \\"C\\", 2) graph.add_edge(\\"B\\", \\"D\\", 7) graph.add_edge(\\"C\\", \\"D\\", 3) dist, parent = dijkstra_shortest_paths(graph, start=\\"A\\") assert dist == {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 6} assert parent == {\'A\': None, \'B\': \'A\', \'C\': \'B\', \'D\': \'C\'} ``` Implement the `dijkstra_shortest_paths` function and ensure it provides correct and efficient results.","solution":"from typing import TypeVar, Generic, Dict, Tuple, List, Optional import heapq T = TypeVar(\'T\') class GraphDirectedWeighted(Generic[T]): def __init__(self): self.edges: Dict[T, List[Tuple[T, int]]] = {} def add_node(self, node: T) -> None: if node not in self.edges: self.edges[node] = [] def add_edge(self, node1: T, node2: T, weight: int) -> None: if node1 not in self.edges: self.edges[node1] = [] self.edges[node1].append((node2, weight)) def dijkstra_shortest_paths(graph: GraphDirectedWeighted[T], start: T) -> Tuple[Dict[T, int], Dict[T, Optional[T]]]: dist: Dict[T, int] = {start: 0} parent: Dict[T, Optional[T]] = {start: None} priority_queue = [(0, start)] visited: Dict[T, bool] = {} while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_node in visited: continue visited[current_node] = True for neighbor, weight in graph.edges.get(current_node, []): if neighbor in visited: continue new_dist = current_dist + weight if neighbor not in dist or new_dist < dist[neighbor]: dist[neighbor] = new_dist parent[neighbor] = current_node heapq.heappush(priority_queue, (new_dist, neighbor)) for node in graph.edges: if node not in dist: dist[node] = float(\'inf\') parent[node] = None return dist, parent"},{"question":"# Question: Sparse Matrix Multiplication You are given two sparse matrices represented as lists of tuples. Each tuple consists of three integers ((r, c, v)), where (r) is the row index, (c) is the column index, and (v) is the non-zero value at that position in the matrix. The matrices will be small enough to fit in memory but may have many zero entries. **Objective:** Write a function `sparse_matrix_mult(a: List[Tuple[int, int, int]], b: List[Tuple[int, int, int]], n: int, m: int, p: int) -> List[Tuple[int, int, int]]` that multiplies two sparse matrices (A) and (B), and returns the resulting sparse matrix in the same format. Requirements: 1. Use a dictionary-based approach to store and perform operations efficiently on non-zero elements. 2. Ensure the time complexity aligns with the nature of sparse matrices, focusing on non-zero values. Input: 1. `a`: List of tuples representing the first sparse matrix. 2. `b`: List of tuples representing the second sparse matrix. 3. `n`: Integer representing the number of rows in matrix (A). 4. `m`: Integer representing the number of columns in matrix (A) and the number of rows in matrix (B). 5. `p`: Integer representing the number of columns in matrix (B). Output: - A list of tuples representing the non-zero elements of the resulting matrix after multiplication. Constraints: - (1 leq n, m, p leq 10^2) - Matrices (A) and (B) are valid for multiplication ((n times m) cdot (m times p)) - Values in the input tuples can be negative, zero, or positive. Example: ```python >>> sparse_matrix_mult([(0, 1, 3), (1, 0, 2)], [(1, 0, 4), (0, 1, 3)], 2, 2, 2) [(0, 0, 12), (1, 1, 6)] >>> sparse_matrix_mult([(0, 1, 2), (1, 2, 3)], [(1, 0, 1), (2, 0, 4)], 2, 3, 1) [(0, 0, 2), (1, 0, 12)] >>> sparse_matrix_mult([(0, 0, 1), (0, 1, 2)], [(0, 0, 3), (1, 1, 4)], 1, 2, 2) [(0, 0, 3), (0, 1, 8)] ``` # Notes: - Your implementation should focus on the efficient handling of sparse matrices, reducing unnecessary computations. - Consider edge cases such as when one or both matrices are entirely zero or when they have dimensions that result in an empty product matrix.","solution":"from typing import List, Tuple from collections import defaultdict def sparse_matrix_mult(a: List[Tuple[int, int, int]], b: List[Tuple[int, int, int]], n: int, m: int, p: int) -> List[Tuple[int, int, int]]: Multiplies two sparse matrices A and B where A is represented by list of tuples (r, c, v) and B is represented by a list of tuples (r, c, v). n is the number of rows in matrix A, m is the number of columns in matrix A (and rows in matrix B), p is the number of columns in matrix B. Returns the resulting sparse matrix in the same format. # Dictionary to store the resulting non-zero values result_dict = defaultdict(int) # Convert matrix B to a dict format with (row, col) as key and value as its value b_dict = defaultdict(int) for row, col, val in b: b_dict[(row, col)] = val # Perform multiplication for a_row, a_col, a_val in a: for k in range(p): if b_dict[(a_col, k)] != 0: result_dict[(a_row, k)] += a_val * b_dict[(a_col, k)] # Convert the result_dict back to the list of tuples format result = [(r, c, v) for (r, c), v in result_dict.items() if v != 0] return result"},{"question":"# Problem Statement You are tasked with implementing a function `interleave_lists(list1: list, list2: list) -> list` that takes two lists of integers and returns a new list that interleaves the elements of the given lists. If the lists are of unequal length, the remaining elements of the longer list should be appended at the end. # Requirements: - The function should handle cases where either list is empty. - Ensure the interleaving maintains the order of elements from both lists. - Preserve the order of elements in the output list as they appear in the input lists. # Input - Two lists, `list1` and `list2`, containing integers. # Output - A single list containing the interleaved elements of `list1` and `list2`. # Constraints - The total number of elements in both lists combined will not exceed 10^6. # Example ```python >>> interleave_lists([1, 2, 3], [4, 5, 6]) [1, 4, 2, 5, 3, 6] >>> interleave_lists([1, 2], [3, 4, 5, 6]) [1, 3, 2, 4, 5, 6] >>> interleave_lists([1, 2, 3, 4], []) [1, 2, 3, 4] >>> interleave_lists([], [4, 5, 6]) [4, 5, 6] >>> interleave_lists([], []) [] ``` # Performance Requirements - The function should efficiently interleave the lists and handle cases where lists have a large number of elements. - Ensure the function runs within a reasonable time frame for very large inputs.","solution":"def interleave_lists(list1, list2): Interleaves elements from list1 and list2. If the lists are of unequal lengths, the remaining elements of the longer list are appended at the end. :param list1: First list of integers :param list2: Second list of integers :return: A list containing interleaved elements from both lists combined_list = [] i = 0 len1, len2 = len(list1), len(list2) # Interleave elements until the end of one of the lists is reached while i < len1 and i < len2: combined_list.append(list1[i]) combined_list.append(list2[i]) i += 1 # Append remaining elements from the longer list if i < len1: combined_list.extend(list1[i:]) elif i < len2: combined_list.extend(list2[i:]) return combined_list"},{"question":"# Problem Statement You are given an array of integers, `arr`, and an integer `k`. Your task is to write a function, `find_k_combination(arr: list, k: int) -> List[List[int]]`, that finds all unique combinations in `arr` where the sum of the integers in each combination is equal to `k`. Each number in `arr` may only be used once in each combination, but the result can contain duplicate numbers in different combinations. # Input * `arr`: A list of integers. * `k`: An integer representing the target sum. # Output * A list of lists of integers, where each list is a unique combination from `arr` that sums up to `k`. # Constraints * The list `arr` will contain at least one element. * The list can contain both positive and negative integers. * The number of combinations that meet the criteria could be large. * In case of an invalid input such as `None` or a negative integer for `k`, the function should raise a `TypeError`. # Example ```python >>> find_k_combination([10, 1, 2, 7, 6, 1, 5], 8) [ [1, 1, 6], [1, 2, 5], [1, 7], [2, 6] ] >>> find_k_combination([2, 5, 2, 1, 2], 5) [ [1, 2, 2], [5] ] >>> find_k_combination([2, 4, 6], -1) Traceback (most recent call last): ... TypeError: The target sum cannot be negative >>> find_k_combination(None, 5) Traceback (most recent call last): ... TypeError: Invalid input: None >>> find_k_combination([2, 5, 2, 1, 2], None) Traceback (most recent call last): ... TypeError: Invalid input: None ``` # Notes * The combinations should be returned in any order. * Ensure the function raises a `TypeError` if `arr` is `None` or if `k` is a negative integer. * The solution should avoid generating duplicate combinations.","solution":"from typing import List def find_k_combination(arr: List[int], k: int) -> List[List[int]]: if arr is None or k is None or not isinstance(k, int): raise TypeError(\\"Invalid input: None\\") if k < 0: raise TypeError(\\"The target sum cannot be negative\\") arr.sort() res = [] def backtrack(start, path, target): if target == 0: res.append(path) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue backtrack(i + 1, path + [arr[i]], target - arr[i]) backtrack(0, [], k) return res"},{"question":"# Coding Assessment Question AVL Tree Insertion and Deletion Given the code snippet for constructing an AVL Tree (a self-balancing binary search tree), your task is to implement functions to insert a new value and delete an existing value while maintaining the tree\'s balanced properties. Function Signatures: ```python def insert(root: AVLNode, key: int) -> AVLNode: pass def delete(root: AVLNode, key: int) -> AVLNode: pass ``` Input: - `root`: The root node of the AVL Tree. - `key`: An integer representing the value to insert or delete. Output: - Each function should return the new root node of the AVL Tree after insertion or deletion. Constraints: - Values are unique within the tree. - Ensure that the tree remains balanced after each insertion or deletion operation. - Provide efficient implementation aiming for O(log n) complexity. Example: ```python # Example of inserting values root = None values_to_insert = [10, 20, 30, 40, 50, 25] for value in values_to_insert: root = insert(root, value) # The AVL Tree should balance itself after each insertion. # Example of deleting a value root = delete(root, 40) # The result should maintain the balanced AVL Tree properties. # You should verify the tree structure to ensure it\'s balanced. ``` Requirements: - Implement the rotation operations (left rotation, right rotation) required to maintain the balance of the AVL Tree. - Ensure that the height of the tree nodes is correctly updated after each modification. - Handle edge cases such as inserting into an empty tree or deleting a non-existent value gracefully. Hints: - Use helper functions to update the height of the nodes and to balance the tree. - Utilize the classic tree traversal methods (in-order, pre-order, post-order) to verify the correctness of your tree during debugging. - Test your implementation thoroughly with small and large datasets to ensure correctness and efficiency. Good luck!","solution":"class AVLNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def get_height(node): if not node: return 0 return node.height def update_height(node): if node: node.height = 1 + max(get_height(node.left), get_height(node.right)) def get_balance(node): if not node: return 0 return get_height(node.left) - get_height(node.right) def left_rotate(z): y = z.right T2 = y.left y.left = z z.right = T2 update_height(z) update_height(y) return y def right_rotate(y): x = y.left T2 = x.right x.right = y y.left = T2 update_height(y) update_height(x) return x def insert(root, key): if not root: return AVLNode(key) elif key < root.key: root.left = insert(root.left, key) else: root.right = insert(root.right, key) update_height(root) balance = get_balance(root) if balance > 1 and key < root.left.key: return right_rotate(root) if balance < -1 and key > root.right.key: return left_rotate(root) if balance > 1 and key > root.left.key: root.left = left_rotate(root.left) return right_rotate(root) if balance < -1 and key < root.right.key: root.right = right_rotate(root.right) return left_rotate(root) return root def min_value_node(node): current = node while current.left is not None: current = current.left return current def delete(root, key): if not root: return root if key < root.key: root.left = delete(root.left, key) elif key > root.key: root.right = delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = min_value_node(root.right) root.key = temp.key root.right = delete(root.right, temp.key) if root is None: return root update_height(root) balance = get_balance(root) if balance > 1 and get_balance(root.left) >= 0: return right_rotate(root) if balance > 1 and get_balance(root.left) < 0: root.left = left_rotate(root.left) return right_rotate(root) if balance < -1 and get_balance(root.right) <= 0: return left_rotate(root) if balance < -1 and get_balance(root.right) > 0: root.right = right_rotate(root.right) return left_rotate(root) return root"},{"question":"Question: Breast Cancer Diagnosis Using Random Forest You are tasked with developing a model to diagnose breast cancer based on a dataset using the Random Forest classifier. Your goal is to train the Random Forest model on the given dataset and then evaluate its performance based on accuracy, precision, and recall. # Task 1. **Data Handling** - Write a function `data_handling(data: dict) -> tuple` that takes a dictionary containing the dataset and target values. This function should return a tuple containing the feature data (`data[\\"data\\"]`) and the target values (`data[\\"target\\"]`). 2. **Model Training and Prediction** - Write a function `random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray` that: - Initializes and trains a Random Forest classifier on the provided training features and target values. - Predicts the target values for the given test features. - Returns the predictions. 3. **Main Function** - Write a function `main()` that: - Loads the breast cancer dataset. - Handles the dataset using the `data_handling` function. - Splits the data into training and testing sets. - Trains the model and makes predictions using the `random_forest` function. - Computes and prints the accuracy, precision, and recall of the predictions. # Constraints - Do not alter the structure of the dataset. - Ensure reproducibility with a fixed random state of 42. - Handle edge cases where the dataset might have missing or NaN values. # Example ```python import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: return (data[\\"data\\"], data[\\"target\\"]) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: rf = RandomForestClassifier(random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: breast_cancer = load_breast_cancer() data, target = data_handling(breast_cancer) x_train, x_test, y_train, y_test = train_test_split(data, target, test_size=0.25, random_state=1) predictions = random_forest(x_train, y_train, x_test) print(f\\"Accuracy: {accuracy_score(y_test, predictions)}\\") print(f\\"Precision: {precision_score(y_test, predictions)}\\") print(f\\"Recall: {recall_score(y_test, predictions)}\\") if __name__ == \\"__main__\\": main() ``` # Expected Results You should expect the following metrics: - **Accuracy**: ~0.97 - **Precision**: ~0.98 - **Recall**: ~0.97","solution":"import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score from sklearn.model_selection import train_test_split def data_handling(data: dict) -> tuple: Splits the dataset dictionary into features and target arrays. Parameters: data (dict): A dictionary containing \'data\' and \'target\' keys. Returns: tuple: A tuple containing the feature data and target values. return (data[\\"data\\"], data[\\"target\\"]) def random_forest(features: np.ndarray, target: np.ndarray, test_features: np.ndarray) -> np.ndarray: Trains a Random Forest on the features and target, then predicts target values on test features. Parameters: features (np.ndarray): Training features. target (np.ndarray): Training target values. test_features (np.ndarray): Features to predict target values. Returns: np.ndarray: Predicted target values. rf = RandomForestClassifier(random_state=42) rf.fit(features, target) predictions = rf.predict(test_features) return predictions def main() -> None: Main function to load the dataset, split it, train a Random Forest model, and print evaluation metrics. breast_cancer = load_breast_cancer() data, target = data_handling(breast_cancer) # Split the dataset into training and testing sets with a fixed random state. x_train, x_test, y_train, y_test = train_test_split(data, target, test_size=0.25, random_state=42) predictions = random_forest(x_train, y_train, x_test) # Compute the evaluation metrics. accuracy = accuracy_score(y_test, predictions) precision = precision_score(y_test, predictions) recall = recall_score(y_test, predictions) print(f\\"Accuracy: {accuracy}\\") print(f\\"Precision: {precision}\\") print(f\\"Recall: {recall}\\") if __name__ == \\"__main__\\": main()"},{"question":"# Coding Question: Longest Common Suffix You are required to implement a function that finds the longest common suffix of two strings. The suffix is defined as a substring that appears at the end of both strings. The function should handle cases where the strings have different lengths and varying characters. Input and Output Format * **Input**: Two strings `str1` and `str2`. * **Output**: A string representing the longest common suffix. Example ```python >>> longest_common_suffix(\\"programming\\", \\"ming\\") \\"ming\\" >>> longest_common_suffix(\\"abcdef\\", \\"xyzdef\\") \\"def\\" >>> longest_common_suffix(\\"hello\\", \\"world\\") \\"\\" ``` Constraints - The strings will only contain printable ASCII characters. - The maximum length of the strings will not exceed 10^5. Function Signature ```python def longest_common_suffix(str1: str, str2: str) -> str: pass ``` Implement the function `longest_common_suffix(str1: str, str2: str) -> str` to solve the problem as described.","solution":"def longest_common_suffix(str1: str, str2: str) -> str: Returns the longest common suffix between two strings str1 and str2. min_length = min(len(str1), len(str2)) suffix = [] for i in range(1, min_length + 1): if str1[-i] == str2[-i]: suffix.append(str1[-i]) else: break return \'\'.join(reversed(suffix))"},{"question":"# Coding Assessment Question Context You are working on a real-time messaging application. To enhance the app\'s performance, you need to implement a data structure that can efficiently store and retrieve the k most recent messages sent in a chat. Problem Statement Design and implement a data structure that supports the following operations: - **add_message**: Add a new message to the chat. - **get_recent_messages**: Retrieve the k most recent messages. Your implementation should optimize for both adding messages and retrieving the k most recent messages. Input - `k` (Integer): The number of most recent messages to retrieve. - `messages` (List of Strings): A list where each string represents a message to be added sequentially. Output - A list of strings representing the k most recent messages after all messages have been added. Constraints - `1 <= k <= 10^5` - `0 <= len(messages) <= 10^6` - All messages are non-empty strings. Function Signature ```python class RecentMessages: def __init__(self, k: int): pass def add_message(self, message: str) -> None: pass def get_recent_messages(self) -> List[str]: pass ``` Example ```python input: k = 3 messages = [ \\"Hello\\", \\"How are you?\\", \\"Good morning\\", \\"What\'s up?\\", \\"Have a great day!\\", ] # Scenario demonstrating usage: rm = RecentMessages(k) for message in messages: rm.add_message(message) output: [\\"What\'s up?\\", \\"Have a great day!\\", \\"How are you?\\"] ``` Notes * Ensure that your implementation handles adding messages and retrieving the k most recent messages efficiently, even under the constraint limits. * Consider using appropriate data structures to maintain the k most recent messages in a way that facilitates efficient operations.","solution":"from collections import deque class RecentMessages: def __init__(self, k: int): self.k = k self.messages = deque(maxlen=k) # Using deque with a maxlen to manage the message buffer def add_message(self, message: str) -> None: self.messages.append(message) # Automatically evicts oldest messages if maxlen is reached def get_recent_messages(self) -> list: return list(self.messages)[-self.k:] # Converting deque to list to return the messages # Example usage: # rm = RecentMessages(3) # rm.add_message(\\"Hello\\") # rm.add_message(\\"How are you?\\") # rm.add_message(\\"Good morning\\") # rm.add_message(\\"What\'s up?\\") # rm.add_message(\\"Have a great day!\\") # print(rm.get_recent_messages()) # Expected output: [\\"Good morning\\", \\"What\'s up?\\", \\"Have a great day!\\"]"},{"question":"# Problem Statement You are to develop a function that performs matrix multiplication, a fundamental operation in many numerical and computational applications. Your task is to write the function `matrix_multiplication` that computes the product of two matrices. # Requirements Write a function `matrix_multiplication(A, B)` that takes two matrices `A` and `B` and returns their product. Function Signature ```python def matrix_multiplication(A, B): pass ``` Expected Input and Output - **Input**: - `A`: A list of lists representing an (m times n) matrix. - `B`: A list of lists representing an (n times p) matrix. - **Output**: - A list of lists representing the resulting (m times p) matrix after multiplying `A` and `B`. Example ```python A = [[1, 2], [3, 4], [5, 6]] B = [[7, 8, 9], [10, 11, 12]] result = matrix_multiplication(A, B) print(result) # Output should be [[27, 30, 33], [61, 68, 75], [95, 106, 117]] ``` Constraints 1. The number of columns in matrix `A` should be equal to the number of rows in matrix `B`. 2. Matrices `A` and `B` will contain only integer values. 3. Matrix dimensions should be reasonable enough to compute within a few seconds. # Notes - Ensure that your function correctly handles edge cases, such as when matrices have only one row or one column or are empty. - Validate the input to make sure that the dimensions of `A` and `B` are compatible for multiplication. - Pay attention to the efficiency of your algorithm. The naive approach has a time complexity of ( O(m cdot n cdot p) ).","solution":"def matrix_multiplication(A, B): Function to multiply two matrices A and B :param A: list of lists representing the first matrix (m x n) :param B: list of lists representing the second matrix (n x p) :return: list of lists representing the resulting matrix (m x p) if len(A) == 0 or len(B) == 0 or len(A[0]) != len(B): raise ValueError(\\"Matrices A and B cannot be multiplied\\") m, n, p = len(A), len(A[0]), len(B[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Scenario: You have been hired by an online book library to create a feature that suggests books based on the reading preferences of a user. One way to achieve this is to analyze the genres of the books a user has read and provide a recommendation for the user\'s most preferred genre. Your task is to design and implement a function that takes a list of books read by the user and returns the genre that the user reads the most. # Problem Description: Implement a function `recommend_genre` that takes a list of books with their genres and returns the genre that the user has read the most. If there is a tie, return all genres sorted in alphabetical order. # Function Signature: `def recommend_genre(books: List[Tuple[str, str]]) -> Union[str, List[str]]:` # Input: - `books`: A list of tuples where each tuple consists of two elements: - The first element is a string representing the book title. - The second element is a string representing the genre of the book. # Output: - Returns a string representing the most read genre if there is only one. If there are multiple genres with the same highest reading count, return a list of these genres sorted alphabetically. # Constraints: - The list of books will contain at least one book. - Book titles and genres are case-sensitive (i.e., \'fiction\' and \'Fiction\' are considered different). # Example: ```python print(recommend_genre([(\'The Hobbit\', \'Fantasy\'), (\'1984\', \'Dystopian\'), (\'Hobbit\', \'Fantasy\'), (\'Brave New World\', \'Dystopian\')])) # Output: [\'Dystopian\', \'Fantasy\'] ``` # Notes: - Ensure your function handles edge cases, such as multiple genres having the same highest count. - The example given shows a case with a tie, returning the genres in alphabetical order.","solution":"from typing import List, Tuple, Union from collections import Counter def recommend_genre(books: List[Tuple[str, str]]) -> Union[str, List[str]]: Recommend the most read genre(s) based on the list of books. :param books: List of tuples, where each tuple contains a book title and its genre. :return: The genre that is most read, or a list of genres if there is a tie. genre_count = Counter(genre for _, genre in books) max_count = max(genre_count.values()) most_read_genres = [genre for genre, count in genre_count.items() if count == max_count] if len(most_read_genres) == 1: return most_read_genres[0] return sorted(most_read_genres)"},{"question":"# Objective: Develop an efficient algorithm to search for an element in a sorted, rotated array using the binary search technique, assessing your understanding of modified binary search algorithms for solving complex search problems. # Question: Design a function called `search_in_rotated_array(arr: List[int], target: int) -> int` that searches for a given target element in a sorted, rotated array and returns its index. If the target is not found, return -1. # Requirements: * **Input**: A list of integers `arr` (0 ≤ len(arr) ≤ 10^6) which is sorted but rotated at some pivot unknown to you beforehand, and an integer `target`. * **Output**: The index of `target` in `arr`, or -1 if `target` is not found. # Constraints: * The algorithm must have a time complexity of O(log n). * The array does not contain duplicate elements. # Example: ```python def search_in_rotated_array(arr: List[int], target: int) -> int: # Your code here # Example Usage print(search_in_rotated_array([4,5,6,7,0,1,2], 0)) # Expected: 4 print(search_in_rotated_array([4,5,6,7,0,1,2], 3)) # Expected: -1 ``` # Function Signature: ```python def search_in_rotated_array(arr: List[int], target: int) -> int: ``` # Notes: * A sorted, rotated array is an array that was originally sorted in increasing order but then rotated (shifted) by some pivot unknown to you beforehand (e.g., [0, 1, 2, 4, 5, 6, 7] becomes [4, 5, 6, 7, 0, 1, 2]). * Efficiently determine the rotated segments and apply binary search within the appropriate segment. * Pay special attention to handling different edge cases, like when the array is empty or when the target is not present.","solution":"from typing import List def search_in_rotated_array(arr: List[int], target: int) -> int: Searches for a target element in a sorted, rotated array using binary search. Returns the index of the target if found, otherwise returns -1. if not arr: return -1 low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] == target: return mid # Determine which part is sorted if arr[low] <= arr[mid]: # Left part is sorted if arr[low] <= target < arr[mid]: # Target is in the left part high = mid - 1 else: # Target is in the right part low = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[high]: # Target is in the right part low = mid + 1 else: # Target is in the left part high = mid - 1 return -1"},{"question":"# Combining and Generating New Strings Task You are working on a software component that combines multiple strings and then generates new strings based on certain patterns. To ensure the integrity and functionality of this component, you need to implement two specific functionalities: concatenating strings and generating new strings based on a key pattern. Task Implement two functions: 1. `concatenate(strings: list[str]) -> str` 2. `generate_from_pattern(pattern: str, count: int, key: str) -> list[str]` # Input - `concatenate` - `strings`: A list of strings to concatenate (list of strings). - `generate_from_pattern` - `pattern`: A string containing the pattern with a placeholder `{key}` to be replaced (string). - `count`: The number of new strings to generate using the pattern (integer). - `key`: The string to replace the `{key}` placeholder in the pattern (string). # Output - `concatenate` returns the single concatenated string (string). - `generate_from_pattern` returns a list of generated strings based on the pattern (list of strings). # Constraints - The list provided to `strings` in `concatenate` has at least one string. - The pattern provided to `generate_from_pattern` contains exactly one occurrence of `{key}`. - The `count` parameter is always a non-negative integer. - The `key` parameter is a non-empty string. # Examples ```python assert concatenate([\'Hello\', \' \', \'World\']) == \'Hello World\' assert concatenate([\'Python\', \'3.8\']) == \'Python3.8\' assert generate_from_pattern(\'Item-{key}\', 3, \'X\') == [\'Item-X-1\', \'Item-X-2\', \'Item-X-3\'] assert generate_from_pattern(\'Hello-{key}\', 2, \'User\') == [\'Hello-User-1\', \'Hello-User-2\'] ``` # Notes Ensure your implementation handles: - Proper input validation to prevent errors. - Efficient string operations, even for larger sets of strings. - Generating accurate sequences without missing or duplicating any elements based on the provided count and key. # Hints - Use Python string methods to handle string concatenation and pattern replacement effectively. - Consider edge cases, such as very large counts or empty initial lists for concatenation.","solution":"def concatenate(strings: list[str]) -> str: Concatenates a list of strings into a single string. :param strings: List of strings to concatenate :return: Concatenated single string return \'\'.join(strings) def generate_from_pattern(pattern: str, count: int, key: str) -> list[str]: Generates a list of new strings based on a given pattern, count, and key. :param pattern: String pattern containing a placeholder `{key}` :param count: Number of strings to generate :param key: The string to replace the `{key}` placeholder in the pattern :return: List of generated strings return [pattern.replace(\'{key}\', f\'{key}-{i+1}\') for i in range(count)]"},{"question":"# Coding Assessment Question # Scenario You\'ve been hired by a company to help with data processing related to their sales records. They\'ve stored each sale as a dictionary with detailed information about the transaction. Your task is to analyze these records and provide a summary report based on certain criteria. # Task Implement a function `sales_summary` that processes a list of sales records and returns a summary report. The summary should include the total number of sales, total revenue, the average sale value, and the highest single sale amount. # Function Signature ```python def sales_summary(sales_records: List[Dict[str, Any]]) -> Dict[str, Any]: ``` # Input * `sales_records` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a sale. Each dictionary has the following key-value pairs: * `sale_id` (str): The ID of the sale. * `customer_name` (str): The name of the customer. * `amount` (float): The amount of the sale. * `date` (str): The date of the sale in the format \\"YYYY-MM-DD\\". # Output * A dictionary containing the following key-value pairs: * `total_sales` (int): The total number of sales. * `total_revenue` (float): The total revenue from all sales. * `average_sale_value` (float): The average value of a sale. * `highest_sale_amount` (float): The highest single sale amount. # Constraints 1. You may assume the `sales_records` list will always contain at least one sale. 2. The `amount` field will always be a positive float. 3. The `date` field will always be in the format \\"YYYY-MM-DD\\". # Example ```python sales_records = [ {\\"sale_id\\": \\"001\\", \\"customer_name\\": \\"Alice\\", \\"amount\\": 250.0, \\"date\\": \\"2023-01-15\\"}, {\\"sale_id\\": \\"002\\", \\"customer_name\\": \\"Bob\\", \\"amount\\": 300.75, \\"date\\": \\"2023-01-16\\"}, {\\"sale_id\\": \\"003\\", \\"customer_name\\": \\"Charlie\\", \\"amount\\": 150.5, \\"date\\": \\"2023-01-17\\"} ] result = sales_summary(sales_records) print(result) # Output should be: # { # \\"total_sales\\": 3, # \\"total_revenue\\": 701.25, # \\"average_sale_value\\": 233.75, # \\"highest_sale_amount\\": 300.75 # } ``` # Requirements 1. Your function should correctly compute the summary based on the provided sales records. 2. Ensure that the average sale value is rounded to 2 decimal places. 3. Handle edge cases such as sales with varying amounts correctly. # Performance Considerations * Aim for an efficient processing of the sales records list, ensuring minimal iterations where possible. * Consider the impact of large lists on memory and processing time, although you may assume a reasonable list size for this context.","solution":"from typing import List, Dict, Any def sales_summary(sales_records: List[Dict[str, Any]]) -> Dict[str, Any]: total_sales = len(sales_records) total_revenue = sum(sale[\'amount\'] for sale in sales_records) average_sale_value = round(total_revenue / total_sales, 2) highest_sale_amount = max(sale[\'amount\'] for sale in sales_records) return { \\"total_sales\\": total_sales, \\"total_revenue\\": total_revenue, \\"average_sale_value\\": average_sale_value, \\"highest_sale_amount\\": highest_sale_amount }"},{"question":"# Coding Assessment Question Problem Statement Write a function `find_shortest_subarray(arr)` that takes an array of integers and returns the smallest contiguous subarray length that, when sorted, results in the entire array being sorted. If the array is already sorted, the function should return 0. Function Signature ```python def find_shortest_subarray(arr: list) -> int: pass ``` Input - `arr`: A list of integers. E.g., `[2, 6, 4, 8, 10, 9, 15]` Output - An integer representing the length of the smallest contiguous subarray that, when sorted, results in the entire array being sorted. E.g., `5` Constraints - The length of the array: ( 1 leq text{len}(arr) leq 10^4 ) - The integers in the array: (-10^5 leq text{arr[i]} leq 10^5 ) Example ```python arr = [2, 6, 4, 8, 10, 9, 15] print(find_shortest_subarray(arr)) # Output: 5 arr = [1, 2, 3, 4] print(find_shortest_subarray(arr)) # Output: 0 arr = [1, 3, 5, 2, 4, 6] print(find_shortest_subarray(arr)) # Output: 4 ``` Notes - To achieve the desired output, examine the array to identify the bounds of the shortest subarray that needs sorting. - Ensure that your algorithm efficiently handles arrays with lengths up to 10,000. - Edge cases include already sorted arrays and arrays where the elements are in a completely random order.","solution":"def find_shortest_subarray(arr: list) -> int: Finds the length of the shortest subarray, that when sorted, results in the entire array being sorted. sorted_arr = sorted(arr) n = len(arr) # Check if the array is already sorted if arr == sorted_arr: return 0 left = 0 while left < n and arr[left] == sorted_arr[left]: left += 1 right = n - 1 while right >= 0 and arr[right] == sorted_arr[right]: right -= 1 return right - left + 1"},{"question":"# Longest Consecutive Subsequence Given an unsorted list of integers, you are tasked with finding the length of the longest consecutive subsequence (LCS). A subsequence is defined as a set of integers from the list such that if `x` is in the set, `x+1` is also in the set (and so on). The order of elements in the list does not matter. # Your Task: Write a function `find_longest_consecutive_subsequence(nums)` that: 1. Computes the length of the longest consecutive subsequence within the list. 2. Returns the length as an integer. ```python def find_longest_consecutive_subsequence(nums: list[int]) -> int: # Your implementation here pass ``` # Input: - `nums`: A list of integers representing the input list. # Output: - The function returns an integer representing the length of the longest consecutive subsequence. # Constraints: - 0 <= len(nums) <= 10^5 - -10^9 <= nums[i] <= 10^9 # Example: ```python nums = [100, 4, 200, 1, 3, 2] print(find_longest_consecutive_subsequence(nums)) ``` Output: ``` 4 ``` Explanation: The longest consecutive subsequence is [1, 2, 3, 4], and its length is 4. # Notes: - The function should handle edge cases such as an empty list, lists with one element, and lists with all elements being the same. - Aim for an efficient solution that can handle large input sizes within reasonable time limits.","solution":"def find_longest_consecutive_subsequence(nums: list[int]) -> int: if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # check if num is the start of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Matrix Transposition **Problem Statement**: Implement a function `transpose_matrix` that takes a rectangular matrix (a list of lists) and returns its transpose. The transpose of a matrix is obtained by swapping its rows and columns. **Input**: * A list of lists representing a rectangular matrix. Each inner list has the same length. **Output**: * A list of lists representing the transposed matrix. **Constraints**: * Each inner list (row of the matrix) will have at least one element and at most 100 elements. * There will be at least one inner list and at most 100 inner lists. * Elements of the matrix will be integers between (-10^3) and (10^3). **Examples**: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[7]]) [[7]] ``` **Implementation Note**: * Students should not use any built-in functions specifically designed for transposing matrices. They should manually swap rows and columns by iterating through the matrix.","solution":"def transpose_matrix(matrix): Returns the transpose of the input matrix. :param matrix: List[List[int]] - A list of lists representing a rectangular matrix. :return: List[List[int]] - The transposed matrix. # Get number of rows (m) and columns (n) m, n = len(matrix), len(matrix[0]) # Initialize the transposed matrix with n rows and m columns transposed = [[0] * m for _ in range(n)] # Fill in the transposed matrix for i in range(m): for j in range(n): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Sum of Odd Indexed Elements in a List Objective: Develop a Python function to calculate the sum of elements that are located at odd indices in a given list. Problem Description: You need to write a function `sum_odd_indexed_elements(lst: list[int]) -> int` that returns the sum of elements from the input list that are located at odd indices (1, 3, 5, etc.). Input: - `lst`: a list of integers. Output: - An integer representing the sum of elements at odd indices. Constraints: - The input list can be empty or have up to 10^5 elements. - The integers in the list can be in the range of -10^9 to 10^9. Requirements: 1. Ensure that the function correctly iterates over the list and considers only odd-indexed positions. 2. Handle edge cases where the list might be empty. 3. Optimize the solution for performance to handle large input sizes efficiently. Example Usage: ```python print(sum_odd_indexed_elements([1, 2, 3, 4, 5])) # Output: 6 (2 + 4) print(sum_odd_indexed_elements([10])) # Output: 0 (no elements at odd indices) print(sum_odd_indexed_elements([0, -1, 3, -2, 5])) # Output: -3 (-1 + -2) print(sum_odd_indexed_elements([])) # Output: 0 (empty list) ``` Implementation Strategy: 1. Initialize a variable to hold the sum of the odd-indexed elements. 2. Iterate over the list while checking the index of each element. 3. Add the elements at odd indices to the sum variable. 4. Return the final sum after completing the iteration. ```python def sum_odd_indexed_elements(lst: list[int]) -> int: Calculate the sum of elements that are located at odd indices in the given list. :param lst: The list of integers. :return: The sum of integers at odd indices. odd_sum = 0 for i in range(1, len(lst), 2): odd_sum += lst[i] return odd_sum ``` Note: Implement the function and include appropriate error handling, performance optimizations, and detailed comments/documentation.","solution":"def sum_odd_indexed_elements(lst: list[int]) -> int: Calculate the sum of elements that are located at odd indices in the given list. :param lst: The list of integers. :return: The sum of integers at odd indices. return sum(lst[i] for i in range(1, len(lst), 2))"},{"question":"# Student Management System Scenario In a student management system, you need to keep track of students\' grades and perform some analytics on their performance. Task You are required to implement functionalities for managing students and their grades. Function Signature ```python class StudentManagement: def __init__(self) -> None: pass def add_student(self, student_id: int, name: str) -> None: pass def add_grade(self, student_id: int, course: str, grade: float) -> None: pass def get_average_grade(self, student_id: int) -> float: pass def get_students_above_grade(self, grade: float) -> List[str]: pass ``` Requirements 1. **Initialization**: No initial setup parameters needed. 2. **Add Student**: Add a student to the system with a unique student ID and their name. 3. **Add Grade**: Add a grade for a particular course to a student\'s record. 4. **Get Average Grade**: Calculate and return the average grade for a student. 5. **Get Students Above Grade**: Return a list of student names whose average grade is above a specified threshold. Constraints * 1 ≤ student_id ≤ 10^5 * 1 ≤ name length ≤ 100 * 1 ≤ grade ≤ 100 * The functions should run efficiently even with a large number of students and grades. Examples ```python # Example 1 management = StudentManagement() management.add_student(1, \\"Alice\\") management.add_student(2, \\"Bob\\") management.add_grade(1, \\"Math\\", 90) management.add_grade(1, \\"Science\\", 85) management.add_grade(2, \\"Math\\", 80) management.add_grade(2, \\"Science\\", 82) assert management.get_average_grade(1) == 87.5 assert management.get_average_grade(2) == 81.0 assert management.get_students_above_grade(85) == [\\"Alice\\"] # Example 2 management.add_student(3, \\"Charlie\\") management.add_grade(3, \\"Math\\", 95) management.add_grade(3, \\"Science\\", 100) assert management.get_average_grade(3) == 97.5 assert management.get_students_above_grade(90) == [\\"Charlie\\"] ```","solution":"from typing import List, Dict, Tuple class StudentManagement: def __init__(self) -> None: self.students = {} # student_id -> name self.grades = {} # student_id -> List of (course, grade) def add_student(self, student_id: int, name: str) -> None: self.students[student_id] = name self.grades[student_id] = [] def add_grade(self, student_id: int, course: str, grade: float) -> None: if student_id in self.grades: self.grades[student_id].append((course, grade)) def get_average_grade(self, student_id: int) -> float: if student_id in self.grades and self.grades[student_id]: total_grades = sum(grade for course, grade in self.grades[student_id]) return total_grades / len(self.grades[student_id]) return 0.0 def get_students_above_grade(self, grade: float) -> List[str]: result = [] for student_id in self.students: if self.get_average_grade(student_id) > grade: result.append(self.students[student_id]) return result"},{"question":"# Task: Finding Top K Frequent Elements in an Array Objective You are provided with an unsorted array of integers. Your task is to find the top K most frequent elements in that array. Return the elements in descending order of their frequency. If two elements have the same frequency, the larger element comes first. Requirements 1. **Function Definition**: Implement a function `topKFrequent(nums: List[int], k: int) -> List[int]` that performs the task. 2. **Input Format**: * `nums`: A list of integers representing the input array. * `k`: An integer representing the number of top frequent elements to return. 3. **Output Format**: * A list of integers representing the top K most frequent elements. 4. **Constraints**: * The length of the array, `n`, will be non-negative and reasonably sized (1 <= n <= 10^5). * Each element in the array will be an integer in the range of -10^4 to 10^4. * `1 <= k <= n` Performance Requirements The function should efficiently handle arrays up to the maximum constraint. Scenario You are working on an analytics feature for a social media platform that tracks the usage of hashtags. Given a list of hashtags used in a series of posts, you need a way to identify the top K hashtags that were used most frequently. Implement the solution to ensure it is performant and accurate, particularly when the input list is large.","solution":"from typing import List from collections import Counter def topKFrequent(nums: List[int], k: int) -> List[int]: Finds the top K most frequent elements in an array. :param nums: List[int] - The input array of integers. :param k: int - The number of top frequent elements to return. :return: List[int] - List of top K frequent elements. # Count the frequency of each element in nums count = Counter(nums) # Sort elements by frequency and by value in descending order for items with the same frequency sorted_elements = sorted(count.keys(), key=lambda x: (-count[x], -x)) # Return the top k frequent elements return sorted_elements[:k]"},{"question":"# Problem Statement You are given a function `count_ways_to_sum(n: int) -> int` that calculates the number of distinct ways to write the integer `n` as a sum of positive integers. # Objective Implement the function to meet the following requirements: 1. The function should work efficiently for values of `n` up to 1,000. 2. Maintain the same input and output formats. 3. The function should account for different permutations that result in the same set of integers as a single way. # Input and Output * **Input**: An integer `n` where 1 ≤ `n` ≤ 1,000. * **Output**: An integer representing the number of distinct ways to sum up to `n`. # Constraints - Use efficient algorithms to avoid excessive computations, focusing on dynamic programming techniques. - Ensure the function counts permutations of the same set of integers only once. # Example ```python >>> count_ways_to_sum(4) 5 # Explanation: 4 can be written as 4, 3+1, 2+2, 2+1+1, 1+1+1+1 >>> count_ways_to_sum(5) 7 # Explanation: 5 can be written as 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1 >>> count_ways_to_sum(6) 11 # Explanation: 6 can be written as 6, 5+1, 4+2, 4+1+1, 3+3, 3+2+1, 3+1+1+1, 2+2+2, 2+2+1+1, 2+1+1+1+1, 1+1+1+1+1+1 ``` # Notes - The function should make use of dynamic programming to handle the overlapping subproblems efficiently. - Pay attention to avoid counting permutations more than once to ensure accurate results. Good luck, and ensure your solution meets the specified constraints and performs efficiently!","solution":"def count_ways_to_sum(n): Calculate the number of distinct ways to write the integer `n` as a sum of positive integers. This uses a dynamic programming approach. # Initialize a list to store the number of ways to write the numbers dp = [0] * (n + 1) # There is only one way to write 0, which is using no numbers dp[0] = 1 # Iterate over every number from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"# Binary Tree Level Order Traversal The goal is to implement a function that performs a level order traversal on a binary tree, where each level of the tree is printed on a new line. Input: * The root node of a binary tree. Output: * A list of lists, where each inner list contains the values of the nodes at that level of the tree. Constraints: * The number of nodes in the binary tree will be between 1 and 1000. * Node values are integers between -1000 and 1000. # Function Signature: ```python def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: pass ``` # Example: ```python # Example binary tree # 3 # / # 9 20 # / # 15 7 # TreeNode definition for the example: class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert level_order_traversal(root) == [[3], [9, 20], [15, 7]] ``` # Additional Information: * You should make sure to handle edge cases, such as a tree with only one node or an empty tree (where the root node is `None`). * Consider time and space complexity in your implementation. Use efficient data structures to achieve optimal performance.","solution":"from typing import Optional, List import collections class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"# Context You are tasked with implementing a simplified version of a Doubly Linked List in Python that supports basic operations such as insertion, deletion, lookup, and iteration. # Problem Statement Implement a `DoublyLinkedList` class that supports the following methods: - `append(self, value)`: Adds a new node with the specified value to the end of the list. - `prepend(self, value)`: Adds a new node with the specified value to the beginning of the list. - `delete(self, value)`: Removes the first node with the given value from the list. If the value is not found, raises a `ValueError`. - `find(self, value)`: Returns the index of the first node containing the value. If the value is not found, returns -1. - `__len__(self)`: Returns the number of nodes in the list. - `__iter__(self)`: Returns an iterator that yields values in the list from head to tail. # Constraints - Your implementation should handle nodes and links directly without using Python\'s built-in list. - The list should support both forward and backward traversal. # Input/Output - There is no direct input/output. Implement the class and methods as specified below: ```python class Node: def __init__(self, value=None): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def append(self, value): # Append a new node to the end pass def prepend(self, value): # Prepend a new node to the beginning pass def delete(self, value): # Delete the first node with the given value pass def find(self, value): # Find the index of the first node with the given value pass def __len__(self): # Return the number of nodes pass def __iter__(self): # Return an iterator to traverse the list pass ``` # Example Usage ```python dll = DoublyLinkedList() dll.append(1) dll.append(2) dll.prepend(0) print(len(dll)) # Output: 3 dll.delete(1) print(list(dll)) # Output: [0, 2] print(dll.find(2)) # Output: 1 print(dll.find(3)) # Output: -1 ```","solution":"class Node: def __init__(self, value=None): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def append(self, value): new_node = Node(value) if self.tail is None: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node self.size += 1 def prepend(self, value): new_node = Node(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node self.size += 1 def delete(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev self.size -= 1 return current = current.next raise ValueError(\\"Value not found in the list\\") def find(self, value): current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def __len__(self): return self.size def __iter__(self): current = self.head while current: yield current.value current = current.next"},{"question":"# Coding Assessment Question: Custom Sorting Algorithm Context In many applications, sorting data in a specific order is crucial for performance and accuracy. While standard sorting algorithms are effective for general use, there are scenarios where a custom sorting mechanism is needed to meet unique requirements. You are provided with a list of objects, each having multiple attributes such as name, age, and salary. The goal is to sort these objects based on a specified order of attributes given as input. Task Implement a custom sorting function that sorts a list of objects based on a provided list of attributes. The sorting should follow the order of attributes as given in the list. If two objects have the same value for the first attribute, the second attribute should be considered, and so on. Function Signature ```python def custom_sort(objects: List[Dict[str, Any]], attributes: List[str]) -> List[Dict[str, Any]]: Sorts objects based on the specified attributes in the given order. Args: objects (List[Dict[str, Any]]): A list of objects to sort, where each object is represented as a dictionary. attributes (List[str]): A list of attribute names specifying the order of sorting. Returns: List[Dict[str, Any]]: The sorted list of objects. ``` Input - `objects`: A list of dictionaries, where each dictionary represents an object with various attributes, e.g., `[{\'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'name\': \'Bob\', \'age\': 25, \'salary\': 7000}]` - `attributes`: A list of strings, representing the order of attributes to sort by, e.g., `[\'age\', \'salary\']` Output - A list of dictionaries sorted based on the specified attribute order. Constraints - Each object in the `objects` list has the same set of attributes. - The `attributes` list will contain valid attribute names present in the objects. - Handle edge cases such as an empty list of `objects` or `attributes`. Example ```python # Example 1 objects1 = [ {\'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'name\': \'Bob\', \'age\': 25, \'salary\': 7000}, {\'name\': \'Charlie\', \'age\': 25, \'salary\': 6000} ] attributes1 = [\'age\', \'salary\'] print(custom_sort(objects1, attributes1)) # Expected output: [{\'name\': \'Charlie\', \'age\': 25, \'salary\': 6000}, {\'name\': \'Bob\', \'age\': 25, \'salary\': 7000}, {\'name\': \'Alice\', \'age\': 30, \'salary\': 5000}] # Example 2 objects2 = [ {\'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'name\': \'Bob\', \'age\': 30, \'salary\': 7000}, {\'name\': \'Charlie\', \'age\': 30, \'salary\': 5000} ] attributes2 = [\'salary\', \'name\'] print(custom_sort(objects2, attributes2)) # Expected output: [{\'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'name\': \'Charlie\', \'age\': 30, \'salary\': 5000}, {\'name\': \'Bob\', \'age\': 30, \'salary\': 7000}] # Example 3 objects3 = [] attributes3 = [\'name\'] print(custom_sort(objects3, attributes3)) # Expected output: [] ``` Additional Notes - You can utilize Python\'s built-in sorting functions and see how the key parameter can be used with multiple sorting criteria. - The function should be able to handle any number of attributes in the sorting criteria. - Consider the stability of the sorting algorithm when designing your solution.","solution":"from typing import List, Dict, Any def custom_sort(objects: List[Dict[str, Any]], attributes: List[str]) -> List[Dict[str, Any]]: Sorts objects based on the specified attributes in the given order. Args: objects (List[Dict[str, Any]]): A list of objects to sort, where each object is represented as a dictionary. attributes (List[str]): A list of attribute names specifying the order of sorting. Returns: List[Dict[str, Any]]: The sorted list of objects. if not attributes: return objects def sort_key(obj): return tuple(obj[attr] for attr in attributes) return sorted(objects, key=sort_key)"},{"question":"# Problem Statement You are tasked with extending a previous stack implementation provided. Specifically, create a function `next_greater_elements` within the `Stack` class, which returns a list of the \\"next greater elements\\" for elements in the stack. The \\"next greater element\\" for an element `x` is the first greater element to the right of `x` in the input elements. If no such element exists for `x`, output `-1` for that position. # Function Signature ```python def next_greater_elements(self) -> List[int]: ``` # Requirements 1. Implement the `next_greater_elements` method within the `Stack` class. 2. If the stack is empty, the function should return an empty list. 3. The stack can hold any numerical data type in the elements. # Input/Output Format * **Input**: - No direct input. This function will be called on an instance of the `Stack` class. * **Output**: - A list of integers representing the next greater elements for each element in the stack, from top to bottom. If no such element exists, output `-1` for that position. # Constraints - Try to achieve this with a time complexity of O(n), where n is the number of elements in the stack. # Example ```python stack = Stack() stack.push(2) stack.push(5) stack.push(3) stack.push(7) stack.push(8) output = stack.next_greater_elements() # Output: [8, 7, 7, 8, -1] stack.pop() output = stack.next_greater_elements() # Output: [8, 7, 7, -1] ``` Demonstrate correct handling of edge cases such as empty stacks, stacks with elements in descending order, etc. **Additional Notes**: - Feel free to use any auxiliary method within the class if needed but avoid making unnecessary modifications to the existing methods.","solution":"class Stack: def __init__(self): self.items = [] def is_empty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): if not self.is_empty(): return self.items.pop() def peek(self): if not self.is_empty(): return self.items[-1] def size(self): return len(self.items) def next_greater_elements(self): if self.is_empty(): return [] n = self.size() result = [-1] * n stack_helper = [] for i in range(n): while stack_helper and self.items[stack_helper[-1]] < self.items[i]: index = stack_helper.pop() result[index] = self.items[i] stack_helper.append(i) return result"},{"question":"# Tic-Tac-Toe Winner Check As a skilled developer, you know that designing classic games like Tic-Tac-Toe involves not only creating the game but also implementing the logic to determine the winner. Your task is to write a function that checks if there\'s a winner on a Tic-Tac-Toe board. Function Signature ```python def check_winner(board: list) -> str: ``` # Input - `board` (list): A 3x3 list, where each element is either \'X\', \'O\', or an empty string (\'\'), representing the current state of the Tic-Tac-Toe game board. # Output - Returns a string that represents the winner of the game: - \'X\' if player X has won, - \'O\' if player O has won, - \'Draw\' if the board is full and there is no winner, - \'Pending\' if the board has empty spaces and no winner yet. # Constraints 1. The input list will always be a 3x3 list. 2. The elements of the list are \'X\', \'O\', or \'\' (empty string). 3. The function should return immediately if a win condition is detected. # Example ```python print(check_winner([ [\'X\', \'O\', \'X\'], [\'O\', \'X\', \'\'], [\'O\', \'\', \'X\'] ])) # Output: \'X\' print(check_winner([ [\'X\', \'O\', \'O\'], [\'O\', \'X\', \'X\'], [\'O\', \'X\', \'O\'] ])) # Output: \'O\' print(check_winner([ [\'X\', \'O\', \'X\'], [\'X\', \'O\', \'O\'], [\'O\', \'X\', \'X\'] ])) # Output: \'Draw\' print(check_winner([ [\'X\', \'O\', \'X\'], [\'O\', \'X\', \'\'], [\'\', \'\', \'\'] ])) # Output: \'Pending\' ``` # Detailed Requirements 1. Implement an auxiliary function `check_line(line: list) -> str` within `check_winner()` to handle the logic of verifying if a line (row, column, or diagonal) has the same non-empty character. 2. The main function should check all rows, columns, and both diagonals. 3. If no win is detected in any row, column, or diagonal, the function should check if the board is full. 4. The function should return \'Pending\' if there are empty cells and no winner is found. 5. The final result should be returned based on the checks described above. # Edge Cases to Consider 1. Boards where no moves are made. 2. Boards where the last move determines the winner. 3. Boards with only one move left and it\'s a winning move. 4. Edge cases where the board might be already in a winning state from the input.","solution":"def check_winner(board: list) -> str: def check_line(line: list) -> str: if line[0] == line[1] == line[2] and line[0] != \'\': return line[0] return \'\' # Check rows for row in board: result = check_line(row) if result: return result # Check columns for col in range(3): result = check_line([board[row][col] for row in range(3)]) if result: return result # Check diagonals result = check_line([board[i][i] for i in range(3)]) if result: return result result = check_line([board[i][2-i] for i in range(3)]) if result: return result # Check for draw or pending status if any(\'\' in row for row in board): return \'Pending\' else: return \'Draw\'"},{"question":"# Morse Code Converter Objective Implement a Morse code converter which translates English sentences into Morse code. Task Write a function `morse_converter(sentence: str) -> str`: * **Input**: - A string `sentence` containing an English sentence (1 ≤ len(sentence) ≤ 1000). * **Output**: - A string where each letter of the input sentence is replaced with its corresponding Morse code, with each character\'s Morse code representation separated by a single space. Function Details # Parameters: `sentence`: A string representing the sentence to be converted into Morse code. # Returns: A string representing the input sentence translated into Morse code. # Description: - Use the standard International Morse code for English letters. - Ignore punctuation and convert only letters (both uppercase and lowercase) and numbers. - Each letter’s Morse code should be separated by a single space. - Convert all characters to uppercase before translating to Morse code. Example ```python >>> morse_converter(\\"Hello World\\") \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" >>> morse_converter(\\"SOS\\") \\"... --- ...\\" ``` # Constraints - The function should handle non-alphabetic characters by leaving them unchanged. - Ensure the function converts all characters to uppercase before processing. # Notes: - The function should handle whitespace appropriately, ensuring words are separated by three spaces in Morse code. - Treat numbers similar to letters, converting them accordingly based on the Morse code standard.","solution":"def morse_converter(sentence: str) -> str: morse_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } result = [] for char in sentence.upper(): if char == \' \': result.append(\' \') # Word separation will be handled in the join logic elif char in morse_dict: result.append(morse_dict[char]) else: result.append(char) # Preserve non-alphabetic and non-numeric characters as is # Join the Morse code by ensuring three spaces between words and one space between characters joined_result = \' \'.join(result).replace(\' \', \' \') return joined_result.replace(\' \', \' \')"},{"question":"# Problem Statement Write a function that calculates the maximum product of a contiguous subsequence within a given list of integers. This challenge requires a deep understanding of dynamic programming, array manipulation, and optimization techniques to handle both positive and negative numbers effectively. # Function Signature ```python def max_product_subarray(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray within the given list of integers. :param nums: A list of integers, which may contain both positive and negative numbers. :return: An integer, the maximum product of any contiguous subsequence of the given list. Example: >>> max_product_subarray([2, 3, -2, 4]) 6 >>> max_product_subarray([-2, 0, -1]) 0 pass ``` # Constraints 1. The length of the `nums` list will be between 1 and (10^5). 2. Each integer in `nums` will be in the range (-10^4) to (10^4). # Requirements - Do not use libraries or functions that explicitly perform the task – the goal is to demonstrate algorithmic implementation. - Ensure that the solution optimizes for both time and space complexity. # Example **Input**: ```python nums = [2, 3, -2, 4] ``` **Output**: ```python 6 ``` **Explanation**: - The maximum product is achieved with the subarray [2, 3], which gives a product of 6. **Input**: ```python nums = [-2, 0, -1] ``` **Output**: ```python 0 ``` **Explanation**: - The maximum product is 0, achieved with the subarray [0].","solution":"from typing import List def max_product_subarray(nums: List[int]) -> int: Returns the maximum product of a contiguous subarray within the given list of integers. if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"# Context You need to solve a problem related to sequences and permutations. You are given a sequence of integers and required to determine if it can be rearranged to form an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. # Problem Statement You are given: 1. An integer `N` representing the length of the sequence. 2. A list of integers `sequence` of length `N`. Write a Python function: ```python def can_form_arithmetic_progression(N, sequence): pass ``` The function should return `True` if the sequence can be rearranged to form an arithmetic progression, and `False` otherwise. # Input Format - An integer `N` - the length of the sequence. - A list of integers `sequence`: - A list of `N` integers. # Output Format - A boolean value: `True` if the sequence can be rearranged to form an arithmetic progression, `False` otherwise. # Constraints - (1 leq N leq 10^4) - Each element in `sequence` is a non-negative integer. # Example ```python def can_form_arithmetic_progression(N, sequence): # implementation goes here pass # Example N = 5 sequence = [3, 1, 2, 5, 4] output = can_form_arithmetic_progression(N, sequence) print(output) # Should print True ``` # Explanation For the example provided: - The sequence `[3, 1, 2, 5, 4]` can be rearranged to `[1, 2, 3, 4, 5]`, which forms an arithmetic progression with a common difference of `1`. Another example: ```python N = 4 sequence = [2, 6, 4, 10] output = can_form_arithmetic_progression(N, sequence) print(output) # Should print False ``` # Explanation For the example provided: - The sequence `[2, 6, 4, 10]` cannot be rearranged to form an arithmetic progression. # Edge Cases - Minimal length sequence (e.g., N = 1). - Sequence with repeated elements (e.g., `[0, 0, 0, 0]` forms an arithmetic progression with a difference of `0`). # Notes Consider sorting the sequence and checking the differences between consecutive terms to determine if they form a constant difference which defines an arithmetic progression.","solution":"def can_form_arithmetic_progression(N, sequence): Determine if the sequence can be rearranged to form an arithmetic progression. Args: N: An integer representing the length of the sequence. sequence: A list of integers of length N. Returns: A boolean: True if the sequence can be rearranged to form an arithmetic progression, False otherwise. if N <= 1: return True sequence.sort() diff = sequence[1] - sequence[0] for i in range(2, N): if sequence[i] - sequence[i-1] != diff: return False return True"},{"question":"**Question:** You are developing a feature for an e-commerce platform that requires determining the maximum value that can be obtained from a list of items, each with a weight and value, without exceeding a given weight capacity. This is a classic \\"0/1 Knapsack Problem.\\" **Task:** Write a Python function `knapsack(values: List[int], weights: List[int], capacity: int) -> int` that calculates the maximum value achievable within the specified weight capacity. Use Dynamic Programming to implement this function. **Input:** * `values`: A list of positive integers representing the values of items (1 ≤ len(values) ≤ 1000) * `weights`: A list of positive integers representing the weights of each item, corresponding to the values list (1 ≤ len(weights) ≤ 1000) * `capacity`: A positive integer representing the maximum weight capacity (1 ≤ capacity ≤ 10000) **Output:** * Returns the maximum value that can be achieved without exceeding the weight capacity. **Example:** ```python knapsack([60, 100, 120], [10, 20, 30], 50) ``` Output: ```python 220 ``` **Constraints:** * Each item can either be taken or not (0/1), meaning you cannot take fractional parts of an item. * The number of items and the capacity must be positive integers. **Hint:** Utilize a dynamic programming approach where the state represents the maximum value obtainable with a given weight capacity. Build up the solution by iterating over all items and capacities incrementally.","solution":"from typing import List def knapsack(values: List[int], weights: List[int], capacity: int) -> int: n = len(values) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): for w in range(capacity + 1): if weights[i - 1] <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Stock Price Prediction with Moving Average # Background: The moving average is a widely used technique in time series analysis to smooth out short-term fluctuations and highlight longer-term trends or cycles. This is particularly useful in stock price prediction to identify the trend direction. # Your Task: Implement the `moving_average_prediction` function to forecast the next day\'s stock price based on the moving average of the past `n` days. # Function Signature: ```python def moving_average_prediction( stock_prices: list[float], n: int ) -> float: ``` # Input: 1. **stock_prices (list[float])**: A list of historical stock prices where each element represents the closing price of the stock on that particular day. 2. **n (int)**: The number of previous days to include in the moving average calculation. # Output: - **next_day_prediction (float)**: The predicted stock price for the next day based on the calculated moving average. # Constraints: - The list of stock prices must contain at least `n` elements. - All stock prices are positive floating-point numbers. - The value of `n` will always be a positive integer. # Requirements: 1. Calculate and return the moving average of the last `n` days from the provided stock prices. 2. Ensure proper validation of inputs, handling cases where the number of stock prices is less than `n`. 3. Implement efficient computation methods to handle large lists of historical data. # Example: ```python stock_prices = [150.0, 152.5, 153.0, 149.5, 155.0, 157.0, 156.5] n = 3 predicted_price = moving_average_prediction(stock_prices, n) print(\\"Predicted next day\'s stock price:\\", predicted_price) # Output should be 156.17 (average of last 3 prices: 155.0, 157.0, 156.5) ``` # Additional Task: Write automated tests to validate your moving_average_prediction implementation against known moving averages using known inputs and expected outputs.","solution":"def moving_average_prediction(stock_prices: list[float], n: int) -> float: Forecast the next day\'s stock price based on the moving average of the past n days. Parameters: - stock_prices: List of historical stock prices - n: Number of days to include in the moving average calculation Returns: - Predicted stock price for the next day based on the moving average of the last n days if len(stock_prices) < n: raise ValueError(\\"The list of stock prices must contain at least {} elements.\\".format(n)) moving_avg = sum(stock_prices[-n:]) / n return moving_avg"},{"question":"# Problem Description: You are given an implementation of a function that merges two sorted linked lists into one sorted linked list. Your task is to implement a function that identifies and removes duplicate nodes from the merged list while maintaining its sorted order. Consider the following requirements: 1. **Function Signature**: ```python def remove_duplicates(head: Node) -> Node: ``` 2. **Parameters**: - `head`: The head node of the linked list. 3. **Output**: - Returns the head node of the linked list after removing duplicates. 4. **Constraints**: - The list can contain between 1 and 200 nodes. # Implementation Details - The function should be optimized for O(n) time complexity where n is the number of nodes in the list. - Ensure the function utilizes no more than O(1) extra space. # Example ```python >>> head1 = insert_node(None, 1) >>> head1 = insert_node(head1, 3) >>> head1 = insert_node(head1, 5) >>> head2 = insert_node(None, 2) >>> head2 = insert_node(head2, 3) >>> head2 = insert_node(head2, 6) >>> merged_head = merge_lists(head1, head2) >>> print_linked_list(merged_head) 1->2->3->3->5->6 >>> new_head = remove_duplicates(merged_head) >>> print_linked_list(new_head) 1->2->3->5->6 ``` # Hints 1. Traverse the linked list and compare each node with its next node to check for duplicates. 2. If any duplicates are found, bypass the duplicate node(s) by adjusting the links accordingly.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def remove_duplicates(head: Node) -> Node: if head is None: return None current = head while current and current.next: if current.value == current.next.value: current.next = current.next.next else: current = current.next return head"},{"question":"# Binary Search Tree (BST) Operations Problem Statement Design and implement a class `BinarySearchTree` that supports the following operations: 1. Insert an integer into the BST. 2. Delete an integer from the BST. 3. Check if a given integer exists in the BST. 4. Find the integer with the minimum value in the BST. 5. Find the integer with the maximum value in the BST. # Constraints 1. Assume that there are no duplicate values in the BST. 2. Assume the operations are performed on integers only. 3. The tree should self-balance using AVL Tree for efficiency or you can handle balancing using simple methods. 4. The insert and delete operations should maintain the properties of the BST. # Class and Method Definitions Class `BinarySearchTree` * `insert(value: int) -> None` * `delete(value: int) -> None` * `exists(value: int) -> bool` * `find_min() -> int` * `find_max() -> int` # Example ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) print(bst.exists(5)) # Output: True print(bst.exists(20)) # Output: False bst.delete(10) print(bst.find_min()) # Output: 5 print(bst.find_max()) # Output: 15 ``` # Notes * Use recursion or iteration as needed to perform the tree operations. * For the delete operation, handle the three cases: 1. Node to be deleted is a leaf (no children). 2. Node to be deleted has only one child. 3. Node to be deleted has two children. * Ensure the implemented methods have efficient time complexity typical for BST operations.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if not node.left: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if not node.right: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def delete(self, value): self.root, _ = self._delete_recursive(self.root, value) def _delete_recursive(self, node, value): if not node: return node, None if value < node.value: node.left, _ = self._delete_recursive(node.left, value) elif value > node.value: node.right, _ = self._delete_recursive(node.right, value) else: if not node.left: return node.right, node elif not node.right: return node.left, node # Node with two children: Get the inorder successor (smallest in the right subtree) min_val_node = self._find_min(node.right) node.value = min_val_node.value node.right, _ = self._delete_recursive(node.right, min_val_node.value) return node, None def exists(self, value): return self._exists_recursive(self.root, value) def _exists_recursive(self, node, value): if not node: return False if value == node.value: return True elif value < node.value: return self._exists_recursive(node.left, value) else: return self._exists_recursive(node.right, value) def find_min(self): if not self.root: raise ValueError(\\"The BST is empty\\") return self._find_min(self.root).value def _find_min(self, node): current = node while current.left is not None: current = current.left return current def find_max(self): if not self.root: raise ValueError(\\"The BST is empty\\") return self._find_max(self.root).value def _find_max(self, node): current = node while current.right is not None: current = current.right return current"},{"question":"Challenge: Make Pyramid You are required to implement a function, `make_pyramid`, that constructs a pyramid shape using a given character up to a specified height. The function should return a string representing the pyramid. # Function Signature ```python def make_pyramid(character: str, height: int) -> str: ``` # Input - `character` (str): A single character string to build the pyramid. - `height` (int): A positive integer indicating the height of the pyramid. # Output - (str): A string representing the pyramid shape. # Constraints - `character` will be a single printable character. - `height` will be a positive integer. - 1 ≤ `height` ≤ 50 # Error Handling - Raise a `ValueError` if `character` is not a single character string or if `height` is not a positive integer. # Examples ```python assert make_pyramid(\'*\', 3) == \\" *n ***n*****\\" assert make_pyramid(\'#\', 5) == \\" #n #n #n #n#\\" assert make_pyramid(\'@\', 2) == \\" @n@@@\\" # Edge cases assert make_pyramid(\'*\', 1) == \\"*\\" assert make_pyramid(\'#\', 4) == \\" #n #n #n#\\" ``` # Explanation - `make_pyramid(\'*\', 3)` returns: ``` * *** ***** ``` - Creates a pyramid with 3 levels and \'*\' as the building block. - `make_pyramid(\'#\', 5)` returns: ``` # # # # # ``` - Creates a pyramid with 5 levels and \'#\' as the building block. # Additional Notes - Ensure that every level of the pyramid is centered properly. - Use efficient string operations to construct the pyramid. - Consider handling edge cases such as minimum and maximum height gracefully.","solution":"def make_pyramid(character: str, height: int) -> str: Constructs a pyramid shape using the given character up to a specified height. Parameters: character (str): A single character string to build the pyramid. height (int): A positive integer indicating the height of the pyramid. Returns: str: A string representing the pyramid shape. if not isinstance(character, str) or len(character) != 1: raise ValueError(\\"The character must be a single character string.\\") if not isinstance(height, int) or height <= 0: raise ValueError(\\"Height must be a positive integer.\\") pyramid_lines = [] for i in range(height): spaces = \' \' * (height - i - 1) chars = character * (2 * i + 1) pyramid_lines.append(spaces + chars) return \'n\'.join(pyramid_lines)"},{"question":"# Problem Statement Write a function that takes a list of integers and finds the length of the longest subarray that contains at most two distinct elements. This problem is similar to finding the longest substring with at most two distinct characters, but for arrays. # Function Signature ```python def longest_subarray_with_two_distinct(nums: list[int]) -> int: pass ``` # Input and Output * **Input**: * `nums` (list of int): A list of integers where each integer represents an element in the array. * **Output**: * Returns an integer representing the length of the longest subarray with at most two distinct elements. # Constraints * The input list `nums` will have at least 1 and at most 100,000 elements. * Each element in the list `nums` will be an integer. # Example ```python >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 # The longest subarray is [1, 2, 1, 2] >>> longest_subarray_with_two_distinct([1, 2, 3, 4, 5]) 2 # Any pair of adjacent elements like [1, 2] or [4, 5] >>> longest_subarray_with_two_distinct([1, 1, 1, 1, 1]) 5 # The entire array as it contains only one distinct element >>> longest_subarray_with_two_distinct([1, 2, 2, 3]) 3 # The longest subarray is [2, 2, 3] ``` # Performance Requirements * Your solution should run in O(n) time and use O(1) space, where n is the length of the input list `nums`. # Context This problem improves your understanding of using the sliding window technique on arrays to optimize the solution for linear time complexity. It tests your ability to handle and manage multiple pointers or indices to keep track of conditions for subarrays dynamically.","solution":"def longest_subarray_with_two_distinct(nums: list[int]) -> int: from collections import defaultdict count_map = defaultdict(int) left = 0 max_length = 0 for right in range(len(nums)): count_map[nums[right]] += 1 while len(count_map) > 2: count_map[nums[left]] -= 1 if count_map[nums[left]] == 0: del count_map[nums[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Context In the context of optimizing performance, it\'s common to profile code to identify bottlenecks. Profiling helps understand where the most time and resources are being consumed. One basic way to profile is by timing the execution of different parts of the code. Your task is to write a function that profiles another function by measuring its execution time. # Problem Statement Implement a function `profile_function` that profiles another function by measuring its execution time. # Requirements 1. **Function Signature**: ```python def profile_function(func: Callable, *args, **kwargs) -> Tuple[float, Any]: ``` 2. **Input**: - `func` (Callable): The function to be profiled. - `*args` (Any): Positional arguments to be passed to `func`. - `**kwargs` (Any): Keyword arguments to be passed to `func`. 3. **Output**: - Returns a tuple of two elements: a) A float representing the time taken in seconds to execute the function. b) The result returned by the function `func`. 4. **Constraints**: - The provided function `func` must be a callable object. - The profiling should be accurate to the nearest microsecond. 5. **Error Handling**: - Raise `TypeError` if the provided `func` is not callable. # Examples ```python >>> def sample_function(x, y): ... return x + y >>> profile_function(sample_function, 3, 5) (Execution Time in seconds, 8) >>> def wait_function(seconds): ... from time import sleep ... sleep(seconds) ... return \\"Done\\" >>> profile_function(wait_function, 2) (Approximation of 2.0 seconds, \\"Done\\") >>> profile_function(12345) Traceback (most recent call last): ... TypeError: Provided func is not callable ``` # Notes - Use the `time` module to measure the execution time. - Ensure the function accurately measures the time taken for the provided function `func` to execute, including time consumed by both positional and keyword arguments.","solution":"import time from typing import Callable, Any, Tuple def profile_function(func: Callable, *args, **kwargs) -> Tuple[float, Any]: Profiles the execution time of a given function. Parameters: func (Callable): The function to be profiled. *args (Any): Positional arguments to be passed to func. **kwargs (Any): Keyword arguments to be passed to func. Returns: Tuple[float, Any]: A tuple containing the execution time and the function\'s result. Raises: TypeError: If the func is not callable. if not callable(func): raise TypeError(\\"Provided func is not callable\\") start_time = time.time() result = func(*args, **kwargs) end_time = time.time() execution_time = end_time - start_time return execution_time, result"},{"question":"# Problem: Detect and Remove Cycle in a Linked List You are tasked with detecting and removing a cycle in a singly linked list. A cycle in a linked list occurs when a node\'s next pointer references a previous node in the list, creating a loop of nodes that can be traversed indefinitely. # Function Signature ```python def remove_cycle_in_linked_list(head: ListNode) -> None: This function takes the head of a singly linked list, detects if there is a cycle, and removes the cycle if it exists. Parameters: - head : ListNode : the head node of the singly linked list. Returns: None. The linked list should be modified in-place to remove the cycle. ``` # Input Format - `head`: The head node of a singly linked list. Each node is an instance of the `ListNode` class. # ListNode Class Definition ```python class ListNode: def __init__(self, x): self.val = x self.next = None ``` # Output Format - The function modifies the linked list in place to remove any cycle present. No return value is necessary. # Constraints - The list may contain up to 10^4 nodes. - You must solve the problem using O(1) extra space. # Performance Requirements - The solution should be efficient with respect to both time and space complexity. - The solution should use Floyd’s Cycle-Finding Algorithm (tortoise and hare algorithm) to detect the cycle efficiently. # Scenario Imagine you are developing a memory-efficient algorithm to troubleshoot a singly linked list that might have inadvertently formed a cycle. Your task is to detect if a cycle exists and remove it so that the list becomes linear again. # Example ```python # Helper Code to Create a Linked List with a Cycle for Testing def create_cycle_list(values, pos): head = ListNode(values[0]) current = head cycle_entry = None if pos == 0: cycle_entry = head for i in range(1, len(values)): current.next = ListNode(values[i]) current = current.next if i == pos: cycle_entry = current current.next = cycle_entry return head # Creating a linked list with cycle for testing: # values = [3, 2, 0, -4], pos = 1 # The linked list is 3 -> 2 -> 0 -> -4 -> 2 (cycle) head = create_cycle_list([3, 2, 0, -4], 1) remove_cycle_in_linked_list(head) # After removing the cycle, the linked list should be: 3 -> 2 -> 0 -> -4 -> None ``` Implement the function to solve the problem described.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def remove_cycle_in_linked_list(head: ListNode) -> None: This function takes the head of a singly linked list, detects if there is a cycle, and removes the cycle if it exists. Parameters: - head : ListNode : the head node of the singly linked list. Returns: None. The linked list should be modified in-place to remove the cycle. if not head or not head.next: return # Detect cycle using Floyd\'s Tortoise and Hare algorithm slow = head fast = head # Move slow by 1 step and fast by 2 steps until they meet or until fast reaches the end while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: # No cycle detected return # To remove the cycle, we need to find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # Now `slow` and `fast` both point to the start of the cycle # To remove the cycle, we need to find the node just before the start of the cycle while fast.next != slow: fast = fast.next # Remove the cycle fast.next = None"},{"question":"# Find Largest Three Numbers **Background**: Finding the largest three numbers in an array is a common problem that can be solved using various approaches, such as sorting or a more optimized algorithm. This task aims to develop an efficient method for identifying the three largest distinct numbers in an array without sorting the entire array. # Task Given a list of unique integers, write a function to return a list containing the three largest distinct integers from the input list in descending order. If the input list contains fewer than three numbers, return the list sorted in descending order. # Function Signature ```python def find_largest_three(arr: list) -> list: Identifies the three largest distinct integers from the list. Args: arr (list): List of unique integers. Returns: list: List containing the three largest distinct integers in descending order. If there are fewer than three distinct integers, return them sorted in descending order. Examples: >>> find_largest_three([10, 4, 3, 50, 23, 90]) [90, 50, 23] >>> find_largest_three([5, 1, -5, 3, 2]) [5, 3, 2] >>> find_largest_three([1, 2]) [2, 1] ``` # Constraints * The length of the input list `n` will be in the range `[0, 10^5]`. * All numbers in the input list are unique. * All numbers are integers and can be negative or positive. # What to Do 1. **Understand the Objective**: Develop a function that identifies the three largest distinct numbers using an efficient approach (not by simply sorting the entire array). 2. **Respect Edge Cases**: * An empty list should return an empty list. * Lists with fewer than three elements should return those elements sorted in descending order. 3. **Optimized Implementation**: Ensure your function runs efficiently in terms of time and space complexity. 4. **Include Examples and Testing**: Provide test cases to demonstrate your solution and edge cases. **Example** ```python >>> find_largest_three([10, 4, 3, 50, 23, 90]) [90, 50, 23] >>> find_largest_three([5, 1, -5, 3, 2]) [5, 3, 2] >>> find_largest_three([1, 2]) [2, 1] ``` Write your function below: ```python def find_largest_three(arr: list) -> list: if len(arr) < 3: return sorted(arr, reverse=True) first, second, third = float(\'-inf\'), float(\'-inf\'), float(\'-inf\') for num in arr: if num > first: third = second second = first first = num elif num > second: third = second second = num elif num > third: third = num return [first, second, third if third != float(\'-inf\') else None] ```","solution":"def find_largest_three(arr: list) -> list: if len(arr) < 3: return sorted(arr, reverse=True) first, second, third = float(\'-inf\'), float(\'-inf\'), float(\'-inf\') for num in arr: if num > first: third = second second = first first = num elif num > second: third = second second = num elif num > third: third = num return [first, second, third]"},{"question":"**Question:** You are developing a reporting system for a shipping company that needs to keep track of shipment statuses and be able to update or query shipment data efficiently. You have a list of shipments, where each shipment\'s status can be one of several predefined statuses, such as \\"Pending\\", \\"In Transit\\", \\"Delivered\\", etc. A particularly useful data structure for this task is the Segment Tree due to its ability to handle range queries and updates effectively. **TASK**: Create a class called `ShipmentTracker` that includes the following methods: 1. `__init__(self, statuses: List[str], all_statuses: List[str])`: Initializes the class with a given list of shipment statuses and a list of all possible statuses. 2. `update_status(self, index: int, status: str)`: Updates the status of the shipment at the given index to the new status. 3. `get_status(self, index: int) -> str`: Retrieves the current status of the shipment at the given index. 4. `count_status_in_interval(self, status: str, start: int, end: int) -> int`: Returns the count of shipments with the specified status within the interval `[start, end)` (inclusive of start, exclusive of end). **Function Signature**: ```python class ShipmentTracker: def __init__(self, statuses: List[str], all_statuses: List[str]): pass def update_status(self, index: int, status: str): pass def get_status(self, index: int) -> str: pass def count_status_in_interval(self, status: str, start: int, end: int) -> int: pass ``` **Constraints**: - 0 <= index < len(statuses) - start <= end <= len(statuses) - The length of `all_statuses` is a fixed set of valid status strings. **Performance Requirements**: - Aim for efficient update and query operations (hint: segment tree can achieve O(log N) complexity for updates and queries). **Example**: ```python statuses = [\\"Pending\\", \\"Delivered\\", \\"In Transit\\", \\"Pending\\", \\"Delivered\\"] all_statuses = [\\"Pending\\", \\"In Transit\\", \\"Delivered\\"] st = ShipmentTracker(statuses, all_statuses) # Update shipment status st.update_status(2, \\"Delivered\\") # Retrieve shipment status print(st.get_status(2)) # Output: \\"Delivered\\" # Count status \\"Pending\\" in interval [0, 3) print(st.count_status_in_interval(\\"Pending\\", 0, 3)) # Output: 1 ``` Write your solution below:","solution":"from collections import defaultdict from typing import List class ShipmentTracker: def __init__(self, statuses: List[str], all_statuses: List[str]): self.statuses = statuses self.all_statuses = all_statuses self.segment_tree = defaultdict(lambda: defaultdict(int)) self.size = len(statuses) self._build_segment_tree(0, 0, self.size - 1) def _build_segment_tree(self, node, start, end): if start == end: self.segment_tree[node][self.statuses[start]] += 1 else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build_segment_tree(left_child, start, mid) self._build_segment_tree(right_child, mid + 1, end) for status in self.all_statuses: self.segment_tree[node][status] = ( self.segment_tree[left_child][status] + self.segment_tree[right_child][status] ) def _update(self, node, start, end, index, old_status, new_status): if start == end: self.segment_tree[node][old_status] -= 1 self.segment_tree[node][new_status] += 1 else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= index <= mid: self._update(left_child, start, mid, index, old_status, new_status) else: self._update(right_child, mid + 1, end, index, old_status, new_status) self.segment_tree[node][old_status] = ( self.segment_tree[left_child][old_status] + self.segment_tree[right_child][old_status] ) self.segment_tree[node][new_status] = ( self.segment_tree[left_child][new_status] + self.segment_tree[right_child][new_status] ) def update_status(self, index: int, status: str): old_status = self.statuses[index] self.statuses[index] = status self._update(0, 0, self.size - 1, index, old_status, status) def _query(self, node, start, end, l, r, status): if r < start or l > end: return 0 if l <= start and end <= r: return self.segment_tree[node][status] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_count = self._query(left_child, start, mid, l, r, status) right_count = self._query(right_child, mid + 1, end, l, r, status) return left_count + right_count def get_status(self, index: int) -> str: return self.statuses[index] def count_status_in_interval(self, status: str, start: int, end: int) -> int: return self._query(0, 0, self.size - 1, start, end - 1, status)"},{"question":"# Problem: List Product Exclusion You need to write a function that takes a list of integers and returns a new list where each element at index `i` is the product of all numbers in the original list except the one at `i`. This is a common interview problem that tests your understanding of array manipulation and optimization. Function Signature ```python def product_except_self(nums: List[int]) -> List[int]: Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Parameters: nums (List[int]): List of integers. Returns: List[int]: List of products such that each index i in the output list has the product of all numbers in the input list except nums[i]. Example: >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([0, 1, 2, 3]) [6, 0, 0, 0] >>> product_except_self([1, 2, 3, 0]) [0, 0, 0, 6] ``` Input * A list of integers `nums` (1 <= len(nums) <= 1000) where each element is a positive integer or zero. Output * A list of integers such that each element is the product of all the elements in the input list except the one at the corresponding index. Constraints * You must handle edge cases such as the presence of zero in the input list. * The result should be computed without using division. Examples ```python product_except_self([1, 2, 3, 4]) # Should output: [24, 12, 8, 6] product_except_self([0, 1, 2, 3]) # Should output: [6, 0, 0, 0] product_except_self([1, 2, 3, 0]) # Should output: [0, 0, 0, 6] product_except_self([1, 2, 3, 4, 5]) # Should output: [120, 60, 40, 30, 24] ```","solution":"def product_except_self(nums): Given an array nums of n integers, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Parameters: nums (List[int]): List of integers. Returns: List[int]: List of products such that each index i in the output list has the product of all numbers in the input list except nums[i]. length = len(nums) result = [1] * length # Calculate prefix products prefix_product = 1 for i in range(length): result[i] = prefix_product prefix_product *= nums[i] # Calculate suffix products and multiply with prefix products suffix_product = 1 for i in reversed(range(length)): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"# Coding Assessment Question **Context**: You are managing a software system that logs user activities. One of the tasks is to determine active users based on their activity periods. Each user is associated with a list of time intervals (denoted by start and end times) during which they were active. Your goal is to merge overlapping intervals for each user to optimize the logging process. **Problem Statement**: Write a function `merge_activity_periods` that merges overlapping time intervals for each user. Each user\'s activity periods are given as a list of tuples where each tuple represents a start and end time. Return a dictionary with user IDs as keys and their merged activity periods as values. **Function Signature**: ```python def merge_activity_periods(logs: dict[int, list[tuple[int, int]]]) -> dict[int, list[tuple[int, int]]]: pass ``` **Input**: * A dictionary `logs` where each key is a user ID (an integer) and the value is a list of tuples. Each tuple contains two integers, the start and end times of an activity period. The start time is always less than the end time. * The total number of users `u` is such that `1 <= u <= 100`. * Each user has a total of `p` activity periods where `1 <= p <= 10^3`. **Output**: * A dictionary with user IDs as keys and lists of merged activity periods as values. **Constraints**: * The start and end times of activity periods are non-negative integers. * Time intervals with the same start time should be merged. **Performance Requirements**: * The function should complete within a reasonable time frame for a maximum of 10^5 total intervals. **Example**: ```python logs = { 1: [(1, 5), (3, 7), (10, 14)], 2: [(8, 10), (2, 4), (1, 2), (6, 8)], 3: [(0, 1)] } assert merge_activity_periods(logs) == { 1: [(1, 7), (10, 14)], 2: [(1, 4), (6, 10)], 3: [(0, 1)] } ``` **Explanation**: * For user 1, intervals (1, 5) and (3, 7) overlap, so they are merged into (1, 7). The interval (10, 14) does not overlap with any other interval. * For user 2, intervals (1, 2), (2, 4), (6, 8), and (8, 10) are merged into (1, 4) and (6, 10). * For user 3, there is only one interval so no merging is required.","solution":"def merge_activity_periods(logs): def merge_intervals(intervals): # Sort intervals based on the start time sorted_intervals = sorted(intervals, key=lambda x: x[0]) merged = [] for interval in sorted_intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged merged_logs = {} for user_id, periods in logs.items(): merged_logs[user_id] = merge_intervals(periods) return merged_logs"},{"question":"# Array Rotation Challenge Overview Array rotation is a common task that involves shifting elements of an array to either the left or the right. In this question, you will work on rotating the array to the right by a given number of steps. Problem Statement Implement a function `rotate_array(arr: list, steps: int) -> list` that rotates an array to the right by a specified number of steps. The rotation should be performed in-place, i.e., using constant space. Input - `arr`: A list of integers. - `steps`: An integer representing the number of steps by which the array should be rotated to the right. Output - A list of integers representing the array after it has been rotated. Constraints - The array can have a length ranging from 0 to 10^5. - The steps can range from 0 to 10^5. - The integer elements in the array can range from -10^9 to 10^9. Example ```python arr = [1, 2, 3, 4, 5, 6, 7] steps = 3 output = [5, 6, 7, 1, 2, 3, 4] assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] ``` ```python arr = [-1, -100, 3, 99] steps = 2 output = [3, 99, -1, -100] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] ``` Notes - Make sure to handle cases where the number of steps is greater than the length of the array. - Ensure that the in-place rotation is optimized for performance and minimizes the use of extra space.","solution":"def rotate_array(arr, steps): Rotates the array to the right by the given number of steps. This is done in-place to minimize the use of extra space. n = len(arr) if n == 0 or steps == 0: return arr # Effective steps may be more than size of the array steps = steps % n # Pythonic way to rotate list using slicing arr[:] = arr[-steps:] + arr[:-steps] return arr"},{"question":"# Coding Assessment Question You are tasked with implementing a basic LinkedList class supporting essential operations. The class should include methods for inserting an element at the head or tail, removing elements, and retrieving elements based on specific criteria. **Objective**: Implement the LinkedList class with the following specifications. # LinkedList Class Specifications: 1. **Constructor**: ```python def __init__(self) -> None ``` - Initializes an empty linked list. 2. **Methods**: - `insert_head(self, value: int) -> None`: Inserts an element at the head of the list. - `insert_tail(self, value: int) -> None`: Inserts an element at the tail of the list. - `remove(self, value: int) -> bool`: Removes the first occurrence of the specified element from the list, returns `True` if the element was removed, `False` otherwise. - `find(self, value: int) -> int`: Returns the index of the first occurrence of the specified element, or `-1` if the element is not in the list. - `get(self, index: int) -> int`: Returns the element at the specified index, raises `IndexError` if the index is out of bounds. - `is_empty(self) -> bool`: Returns `True` if the list is empty, `False` otherwise. - `size(self) -> int`: Returns the number of elements in the list. # Input and Output Formats: - Values are integers. - Methods that modify the list return `None`. - Methods that query the list\'s contents return appropriate types (integer, boolean). - Raise `IndexError` with a descriptive message for out-of-bound access attempts. # Example Usage: ```python # Creating a new linked list ll = LinkedList() # Inserting elements ll.insert_head(1) ll.insert_tail(3) ll.insert_head(2) # Accessing elements val = ll.get(1) # Should return 1 index = ll.find(3) # Should return 2 # Removing elements removed = ll.remove(1) # Should return True # Checking size and emptiness size = ll.size() # Should return 2 empty = ll.is_empty() # Should return False ``` **Your task**: Implement the `LinkedList` class as per the above specifications.","solution":"class Node: def __init__(self, value: int) -> None: self.value = value self.next = None class LinkedList: def __init__(self) -> None: self.head = None self._size = 0 def insert_head(self, value: int) -> None: new_node = Node(value) new_node.next = self.head self.head = new_node self._size += 1 def insert_tail(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node self._size += 1 def remove(self, value: int) -> bool: current = self.head prev = None while current: if current.value == value: if prev: prev.next = current.next else: self.head = current.next self._size -= 1 return True prev = current current = current.next return False def find(self, value: int) -> int: current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def get(self, index: int) -> int: if index < 0 or index >= self._size: raise IndexError(\'Index out of bounds\') current = self.head for _ in range(index): current = current.next return current.value def is_empty(self) -> bool: return self._size == 0 def size(self) -> int: return self._size"},{"question":"# Problem Statement You are tasked with implementing an enhanced version of the LinkedList class. This new version will include support for several advanced operations. Specifically, you will: 1. Modify the existing methods to enhance performance where necessary. 2. Implement additional methods to: - Find the middle element of the list. - Reverse the entire list. - Detect if the list has a cycle. - Merge two sorted linked lists into one sorted linked list. # Requirements - Modify the `LinkedList` class to include the following new methods: * `find_middle` to find the middle element of the list. * `reverse` to reverse the entire list. * `has_cycle` to detect if there is a cycle in the list. * `merge_sorted` that merges another sorted linked list into the current one, maintaining sorted order. # Function Implementation Method Header 1. **Finding the middle element**: ```python def find_middle(self) -> Node: ``` - **returns**: The middle node of the linked list. 2. **Reversing the linked list**: ```python def reverse(self) -> None: ``` - Reverses the linked list in place. 3. **Cycle detection**: ```python def has_cycle(self) -> bool: ``` - **returns**: True if there is a cycle in the linked list, False otherwise. 4. **Merging another sorted linked list**: ```python def merge_sorted(self, other: \'LinkedList\') -> None: ``` - **other**: Another instance of a linked list that is sorted. - Merges the other linked list into the current linked list, maintaining sorted order. # Input and Output Formats - The linked list nodes can be any comparable type that supports ordering. - The `find_middle` method should return the exact middle element or one of the two middle elements if the list has an even number of elements. - The `reverse` method should not return anything but reverse the list in place. - The `has_cycle` method should return a boolean indicating whether a cycle is found. - The `merge_sorted` method should modify the current linked list to include elements from the other linked list while keeping it sorted. # Constraints - The linked list can contain up to 10^5 nodes. - Operations should be efficient in terms of both time and space complexity. # Example ```python # Example usage of the enhanced LinkedList class implementation ll1 = LinkedList() ll1.append(1) ll1.append(3) ll1.append(5) ll2 = LinkedList() ll2.append(2) ll2.append(4) ll2.append(6) ll1.merge_sorted(ll2) print(ll1.to_list()) # Expected Output: [1, 2, 3, 4, 5, 6] ll1.reverse() print(ll1.to_list()) # Expected Output: [6, 5, 4, 3, 2, 1] print(ll1.find_middle().value) # Expected Output: 4 print(ll1.has_cycle()) # Expected Output: False ``` # Notes - Ensure your methods handle edge cases, such as a list with no nodes, a single node, two nodes, etc. - You may define additional helper methods if needed to keep the implementation clean and modular. This is your additional problem statement that aligns with the existing set in terms of style, complexity, and scope.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): new_node = Node(value) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def to_list(self): nodes = [] current = self.head while current: nodes.append(current.value) current = current.next return nodes def find_middle(self): slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def has_cycle(self): slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge_sorted(self, other): dummy = Node(0) tail = dummy a, b = self.head, other.head while a and b: if a.value <= b.value: tail.next = a a = a.next else: tail.next = b b = b.next tail = tail.next tail.next = a or b self.head = dummy.next"},{"question":"# Coding Assessment Question Objective You are tasked with finding the Kth smallest integer in a sorted matrix. The matrix is sorted in ascending order both row-wise and column-wise. Write a function that implements this solution efficiently. Function Signature ```python def kth_smallest(matrix: List[List[int]], K: int) -> int: :param matrix: List[List[int]], a 2D list representing a sorted matrix of integers. :param K: int, the position (1-indexed) of the smallest integer to find. :return: int, the Kth smallest integer in the sorted matrix. Constraints: 1 <= len(matrix) <= 100 1 <= len(matrix[0]) <= 100 -10^9 <= matrix[i][j] <= 10^9 All the rows and columns of the matrix are sorted in ascending order. Example: >>> matrix = [ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ] >>> kth_smallest(matrix, 8) 13 >>> kth_smallest(matrix, 1) 1 >>> kth_smallest(matrix, 6) 12 ``` Guidelines 1. **Core Requirements**: - Implement an efficient algorithm to find the Kth smallest integer in the sorted matrix. - Ensure that the input parameters fall within the constraints: - The number of rows and columns in the matrix should not exceed 100. - The values in the matrix range between -10^9 and 10^9. 2. **Expected Input/Output**: - Input: A 2D list `matrix` containing sorted integers and an integer `K`. - Output: An integer representing the Kth smallest element in the matrix. 3. **Performance**: - The solution should handle the largest possible matrix size within a reasonable time. - Utilize an efficient search or data organization strategy to achieve optimal performance. 4. **Edge Cases**: - Properly handle scenarios where `K` is less than 1 or greater than the number of elements in the matrix. - Ensure the solution is robust against edge conditions within the specified constraints. 5. **Error Handling**: - Throw appropriate error messages for invalid input values that do not align with the specified constraints. Good Luck!","solution":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], K: int) -> int: Returns the Kth smallest integer in a sorted matrix. # Using a min-heap to keep track of the smallest elements min_heap = [] n = len(matrix) # Initialize the min-heap with the first element of each row for r in range(min(n, K)): # No need to push more than K rows as K <= total elements heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract the smallest element from the heap K times for _ in range(K - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Coding Assessment Question Problem Statement: You are given a list of integers representing the heights of buildings on a street, and you need to determine the amount of water that would be trapped after a rainstorm. This problem is known as the \\"Trapping Rain Water\\" problem. Write a function `trap(height)` that returns the total amount of water that can be trapped between the buildings. Function Signature: ```python def trap(height: [int]) -> int: ``` Parameters: - `height` (list of int): A list of non-negative integers representing the height of the buildings. Returns: - `int`: The total amount of water that can be trapped. Example: ```python assert trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 ``` Constraints: - The length of the `height` list will be between 0 and 10000. - Each height value will be a non-negative integer up to 10^4. Performance Requirements: - Your solution should have a time complexity of O(n) and space complexity of O(1), where `n` is the number of buildings. Scenario: Consider a street where buildings of different heights are lined up. After a heavy rainfall, water accumulates between the buildings, and your task is to find out how much water can be trapped. This is useful for urban planning to anticipate drainage requirements and avoid flooding issues.","solution":"def trap(height): Calculate the amount of water that can be trapped between the buildings. if not height: return 0 n = len(height) left_max = 0 right_max = 0 left = 0 right = n - 1 water_trapped = 0 while left < right: if height[left] < height[right]: if height[left] >= left_max: left_max = height[left] else: water_trapped += left_max - height[left] left += 1 else: if height[right] >= right_max: right_max = height[right] else: water_trapped += right_max - height[right] right -= 1 return water_trapped"},{"question":"**Introduction**: You are tasked with determining whether two singly linked lists intersect at some node. An intersection is defined by two nodes from different linked lists pointing to the same location in memory. This problem will test your understanding of linked list traversal and memory handling. **Problem**: Implement the method `find_intersection(self, other: \'LinkedList\') -> Optional[Node]` within the `LinkedList` class. The method should return the intersection node if two linked lists intersect, or `None` if they do not. **Input**: - Two instances of the `LinkedList` class. **Output**: - The intersecting `Node` if there exists an intersection, otherwise `None`. **Constraints**: - Each linked list can have up to 1000 nodes. - The linked lists do not have cycles. - The nodes\' values are not guaranteed to be unique. **Example**: ```python >>> ll1 = LinkedList([1, 2, 3, 4, 5]) >>> ll2 = LinkedList([9, 8]) >>> ll2.head.next.next = ll1.head.next.next # Creating intersection at node with value 3 >>> result_node = ll1.find_intersection(ll2) >>> result_node.value if result_node else None 3 >>> ll3 = LinkedList([1, 2, 3]) >>> ll4 = LinkedList([4, 5, 6]) >>> result_node = ll3.find_intersection(ll4) >>> result_node if result_node else None None ``` **Requirements**: - Optimize the traversal to ensure that the solution works efficiently even for the upper constraint limits. - Consider edge cases like one or both linked lists being empty. - Ensure no extra memory is used that may violate the constraints of singly linked lists. **Additional**: - You may use helper methods if needed. - Modify provided `LinkedList` and `Node` classes to suit the problem, but adhere to input and output constraints outlined.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def __init__(self, values=None): self.head = None if values: self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def find_intersection(self, other): def get_length(head): length = 0 current = head while current: length += 1 current = current.next return length if not self.head or not other.head: return None len1 = get_length(self.head) len2 = get_length(other.head) longer = self.head if len1 >= len2 else other.head shorter = other.head if len1 >= len2 else self.head difference = abs(len1 - len2) for _ in range(difference): longer = longer.next while longer and shorter: if longer is shorter: return longer longer = longer.next shorter = shorter.next return None"},{"question":"# Coding Question: Longest Common Substring in a List of Strings Scenario: You are developing a text processing library, and a crucial feature is to find the longest common substring shared among a list of strings. This feature is particularly useful for applications in bioinformatics, text comparison, and data deduplication. Problem Statement: Write a function `longest_common_substring(str_list)` that takes in a single parameter: - `str_list`: A list of strings, where each string consists of lowercase alphabets. The function should return a string representing the longest common substring found in all the strings provided in the input list. If there are multiple substrings with the same maximum length, return any one of them. Input: - `str_list` is a list of strings `[s1, s2, ..., sn]` with `1 <= len(str_list) <= 100` and `1 <= len(si) <= 100`. Output: - The function should return a string representing the longest common substring among the input strings. Constraints: - If `str_list` contains only one string, the function should return that string. - If there is no common substring, the function should return an empty string. Examples: ```python def longest_common_substring(str_list): >>> longest_common_substring([\\"bicycle\\", \\"tricycle\\", \\"motorcycle\\"]) \'cycle\' >>> longest_common_substring([\\"abc\\", \\"def\\"]) \'\' >>> longest_common_substring([\\"florida\\", \\"flow\\", \\"flight\\"]) \'fl\' >>> longest_common_substring([\\"apple\\", \\"apple\\", \\"apple\\"]) \'apple\' >>> longest_common_substring([\\"abcd\\", \\"bcda\\", \\"cdab\\", \\"dabc\\"]) \'a\' >>> longest_common_substring([\\"a\\"]) \'a\' if not str_list: return \'\' def common_prefix(str1, str2): min_len = min(len(str1), len(str2)) for i in range(min_len): if str1[i] != str2[i]: return str1[:i] return str1[:min_len] def find_lcs(base_str, comparisons): lcs = \'\' base_len = len(base_str) for i in range(base_len): for j in range(i + 1, base_len + 1): subst = base_str[i:j] if all(subst in other for other in comparisons): if len(subst) > len(lcs): lcs = subst return lcs smallest_str = min(str_list, key=len) comparisons = [s for s in str_list if s != smallest_str] return find_lcs(smallest_str, comparisons) ```","solution":"def longest_common_substring(str_list): Finds the longest common substring in a list of strings. if not str_list: return \\"\\" # Initialize the smallest string from the list smallest_str = min(str_list, key=len) def is_common_substring(substr, strings): return all(substr in string for string in strings) def find_longest_common_substring(base, strings): n = len(base) longest_common = \\"\\" for i in range(n): for j in range(i + 1, n + 1): candidate = base[i:j] if is_common_substring(candidate, strings): if len(candidate) > len(longest_common): longest_common = candidate return longest_common # Exclude the smallest string from the comparisons other_strings = [s for s in str_list if s != smallest_str] return find_longest_common_substring(smallest_str, other_strings)"},{"question":"# Coding Assessment Question: Design and Implement a To-Do List Manager You are tasked with designing and implementing a simple To-Do List Manager in Python. The manager should be capable of handling different operations such as adding tasks, removing tasks, updating tasks, and marking tasks as complete or incomplete. # Task Write a `ToDoListManager` class that supports the following functionalities: 1. Adding a new task with a unique identifier, description, and a flag for completion status (initially set to `False`). 2. Removing an existing task by its unique identifier. 3. Updating the description of an existing task by its unique identifier. 4. Marking an existing task as complete or incomplete by its unique identifier. 5. Listing all tasks with their details. # Details * **Input**: The inputs will be the calls to the methods of the `ToDoListManager` class. * **Output**: The outputs will be based on methods called to the `ToDoListManager` and their functionalities. # Example **Input**: ```python manager = ToDoListManager() manager.add_task(1, \\"Buy groceries\\") manager.add_task(2, \\"Read a book\\") manager.mark_task_complete(1) manager.update_task(2, \\"Read two books\\") manager.remove_task(1) manager.list_tasks() ``` **Output**: ```plaintext Task ID: 2, Description: Read two books, Completed: False ``` # Implementation Requirements 1. Implement the `ToDoListManager` class with the above-mentioned functionalities. 2. Ensure that task IDs are unique. 3. Provide meaningful error messages if attempting to update, remove, or mark a non-existing task. # Constraints - Task descriptions will have a maximum length of 255 characters. - Unique identifiers are non-negative integers. # Template ```python class ToDoTask: def __init__(self, task_id, description): self.task_id = task_id self.description = description self.completed = False class ToDoListManager: def __init__(self): self.tasks = {} def add_task(self, task_id, description): # Add implementation here def remove_task(self, task_id): # Add implementation here def update_task(self, task_id, description): # Add implementation here def mark_task_complete(self, task_id): # Add implementation here def mark_task_incomplete(self, task_id): # Add implementation here def list_tasks(self): # Add implementation here ``` Complete the `ToDoListManager` class by implementing the methods to manage the tasks as described.","solution":"class ToDoTask: def __init__(self, task_id, description): self.task_id = task_id self.description = description self.completed = False class ToDoListManager: def __init__(self): self.tasks = {} def add_task(self, task_id, description): if task_id in self.tasks: raise ValueError(f\\"Task ID {task_id} already exists.\\") if len(description) > 255: raise ValueError(\\"Description is too long.\\") self.tasks[task_id] = ToDoTask(task_id, description) def remove_task(self, task_id): if task_id not in self.tasks: raise ValueError(f\\"Task ID {task_id} does not exist.\\") del self.tasks[task_id] def update_task(self, task_id, description): if task_id not in self.tasks: raise ValueError(f\\"Task ID {task_id} does not exist.\\") if len(description) > 255: raise ValueError(\\"Description is too long.\\") self.tasks[task_id].description = description def mark_task_complete(self, task_id): if task_id not in self.tasks: raise ValueError(f\\"Task ID {task_id} does not exist.\\") self.tasks[task_id].completed = True def mark_task_incomplete(self, task_id): if task_id not in self.tasks: raise ValueError(f\\"Task ID {task_id} does not exist.\\") self.tasks[task_id].completed = False def list_tasks(self): task_list = [] for task in self.tasks.values(): task_list.append((task.task_id, task.description, task.completed)) return task_list"},{"question":"# Background Binary strings are sequences of only \'0\'s and \'1\'s. Some operations can be performed on these strings to check certain properties. # Problem Write a function `is_alternating` that determines if a given binary string contains alternating \'0\'s and \'1\'s. An alternating binary string is one in which no two adjacent bits are the same. # Function Signature ```python def is_alternating(bin_str: str) -> bool: pass ``` # Input - `bin_str` (str): A string consisting of characters \'0\' and \'1\' only. # Output - Returns `True` if the given binary string is alternating, otherwise returns `False`. # Example ```python is_alternating(\\"1010\\") # Returns True because no adjacent bits are the same. is_alternating(\\"1111\\") # Returns False because all bits are the same. is_alternating(\\"0010\\") # Returns False because there are two consecutive \'0\'s. is_alternating(\\"01010101\\") # Returns True because bits alternate. ``` # Constraints - The length of `bin_str` will be between 1 and 1,000,000. # Additional Notes - Ensure the function handles edge cases, such as an empty string or a string with length 1.","solution":"def is_alternating(bin_str: str) -> bool: Determines if a given binary string contains alternating \'0\'s and \'1\'s. Args: bin_str (str): A string consisting of characters \'0\' and \'1\'. Returns: bool: True if the given binary string is alternating, otherwise False. for i in range(1, len(bin_str)): if bin_str[i] == bin_str[i - 1]: return False return True"},{"question":"# Question You are tasked with implementing a similar trie-based data structure, but for managing email addresses. This will require additional functionality to handle typical email operations, such as validating email format and querying emails by domain. Your goal is to create an `EmailTrie` class that includes: 1. **Email Insertion**: Insert email addresses into the trie while validating the email format. 2. **Domain Query**: Retrieve a list of all email addresses that belong to a specific domain. 3. **Count Email Addresses**: Count the number of email addresses in the trie that belong to a specific domain. # Function Specifications: EmailTrie Class - **Method**: `insert_email(self, email: str) -> None` - **Description**: Inserts the given email address into the trie after validating its format. - **Input**: `email` (a string containing the email address to insert) - **Output**: None - **Method**: `get_emails_by_domain(self, domain: str) -> list` - **Description**: Retrieves a list of all email addresses in the trie that belong to the given domain. - **Input**: `domain` (a string containing the domain to search for) - **Output**: A list of email addresses that belong to the given domain. - **Method**: `count_emails_by_domain(self, domain: str) -> int` - **Description**: Counts the number of email addresses in the trie that belong to the given domain. - **Input**: `domain` (a string containing the domain to count email addresses for) - **Output**: An integer count of email addresses belonging to the given domain. # Constraints - Email addresses must be validated to ensure they are in the format `local_part@domain_part` where `local_part` can contain letters, numbers, and certain special characters (e.g., \'.\', \'-\', \'_\') and `domain_part` follows standard domain name rules. - Ensure case-insensitivity for email insertion and queries. ```python import re END = \\"#\\" class EmailTrie: def __init__(self) -> None: self._trie = {} def _is_valid_email(self, email: str) -> bool: pattern = r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\" return re.match(pattern, email) is not None def insert_email(self, email: str) -> None: Inserts the given email address into the trie after validating its format. email = email.lower() if not self._is_valid_email(email): raise ValueError(\\"Invalid email format\\") trie = self._trie for char in email: if char not in trie: trie[char] = {} trie = trie[char] trie[END] = True def _get_emails_from_trie(self, trie: dict, prefix: str) -> list: emails = [] for char, child in trie.items(): if char == END: emails.append(prefix) else: emails.extend(self._get_emails_from_trie(child, prefix + char)) return emails def get_emails_by_domain(self, domain: str) -> list: Retrieves a list of all email addresses in the trie that belong to the given domain. domain = domain.lower() trie = self._trie for char in domain: if char not in trie: return [] trie = trie[char] return self._get_emails_from_trie(trie, domain) def _count_emails_from_trie(self, trie: dict) -> int: count = 0 for char, child in trie.items(): if char == END: count += 1 else: count += self._count_emails_from_trie(child) return count def count_emails_by_domain(self, domain: str) -> int: Counts the number of email addresses in the trie that belong to the given domain. domain = domain.lower() trie = self._trie for char in domain: if char not in trie: return 0 trie = trie[char] return self._count_emails_from_trie(trie) def main() -> None: email_trie = EmailTrie() emails = [ \\"alice@example.com\\", \\"bob@example.com\\", \\"charlie@test.com\\", \\"david@another.com\\" ] for email in emails: email_trie.insert_email(email) print(email_trie.get_emails_by_domain(\\"example.com\\")) # Should list emails from example.com print(email_trie.count_emails_by_domain(\\"example.com\\")) # Should return 2 if __name__ == \\"__main__\\": main() ```","solution":"import re END = \\"#\\" class EmailTrie: def __init__(self) -> None: self._trie = {} def _is_valid_email(self, email: str) -> bool: pattern = r\\"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\\" return re.match(pattern, email) is not None def insert_email(self, email: str) -> None: Inserts the given email address into the trie after validating its format. email = email.lower() if not self._is_valid_email(email): raise ValueError(\\"Invalid email format\\") parts = email.split(\'@\') domain = parts[1] trie = self._trie for char in domain: if char not in trie: trie[char] = {} trie = trie[char] local_part_trie = trie for char in parts[0]: if char not in local_part_trie: local_part_trie[char] = {} local_part_trie = local_part_trie[char] local_part_trie[END] = email def _get_emails_from_trie(self, trie: dict) -> list: emails = [] for char, child in trie.items(): if isinstance(child, str): emails.append(child) else: emails.extend(self._get_emails_from_trie(child)) return emails def get_emails_by_domain(self, domain: str) -> list: Retrieves a list of all email addresses in the trie that belong to the given domain. domain = domain.lower() trie = self._trie for char in domain: if char not in trie: return [] trie = trie[char] return self._get_emails_from_trie(trie) def count_emails_by_domain(self, domain: str) -> int: Counts the number of email addresses in the trie that belong to the given domain. domain = domain.lower() trie = self._trie for char in domain: if char not in trie: return 0 trie = trie[char] return len(self._get_emails_from_trie(trie))"},{"question":"# Coding Assessment: Implement Dijkstra\'s Algorithm Context You are given the task of finding the shortest path in a graph for a travel logistics company. The company\'s network is represented as a graph, where nodes represent locations, and edges represent the travel time between locations. To facilitate this, you need to implement Dijkstra\'s algorithm. Task Write a function `dijkstra_shortest_path` that takes in a graph as an adjacency matrix and a starting node, and returns a dictionary with the shortest distance from the starting node to every other node in the graph. Input - `graph`: A 2D list of integers where `graph[i][j]` represents the travel time from node `i` to node `j`. If there is no direct path, the value will be a large number (e.g., 9999999). - `start_node`: An integer representing the starting node. Output - A dictionary with node indices as keys and the shortest travel time from the start node as values. Constraints - The graph will have at least 2 nodes and at most 100 nodes. - The travel time between different nodes is non-negative. - The graph representation ensures there are no negative cycles. Example ```python def dijkstra_shortest_path(graph: list[list[int]], start_node: int) -> dict[int, int]: # Your implementation here pass # Example Usage graph = [ [0, 4, 9999999, 9999999, 9999999, 9999999, 9999999, 8, 9999999], [4, 0, 8, 9999999, 9999999, 9999999, 9999999, 11, 9999999], [9999999, 8, 0, 7, 9999999, 4, 9999999, 9999999, 2], [9999999, 9999999, 7, 0, 9, 14, 9999999, 9999999, 9999999], [9999999, 9999999, 9999999, 9, 0, 10, 9999999, 9999999, 9999999], [9999999, 9999999, 4, 14, 10, 0, 2, 9999999, 9999999], [9999999, 9999999, 9999999, 9999999, 9999999, 2, 0, 1, 6], [8, 11, 9999999, 9999999, 9999999, 9999999, 1, 0, 7], [9999999, 9999999, 2, 9999999, 9999999, 9999999, 6, 7, 0] ] start_node = 0 print(dijkstra_shortest_path(graph, start_node)) # Expected Output: {0: 0, 1: 4, 2: 12, 3: 19, 4: 21, 5: 11, 6: 9, 7: 8, 8: 14} ``` In your solution: 1. Initialize the distances from the start node to all nodes as infinite, except for the start node itself, which should be 0. 2. Use a priority queue to efficiently get the node with the smallest distance. 3. Relax the edges and update the shortest distances. 4. Continue until all the nodes\' shortest distances from the starting point are found.","solution":"import heapq def dijkstra_shortest_path(graph: list[list[int]], start_node: int) -> dict[int, int]: Implements Dijkstra\'s Algorithm to find the shortest path from a start node to all other nodes in a graph. :param graph: A 2D list representing the adjacency matrix of the graph. :param start_node: An integer representing the starting node. :return: A dictionary with node indices as keys and the shortest travel time from the start node as values. n = len(graph) distances = {i: float(\'inf\') for i in range(n)} distances[start_node] = 0 priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in enumerate(graph[current_node]): if weight != 9999999 and weight != 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Problem Statement Given an integer array `arr` of size `n`, write a function `findPeakElement(arr: List[int]) -> int` to find a peak element and return its index. An element is a peak if it is greater than its neighbors. For corner elements, consider only one neighbor. Return the index of any one of the peak elements. You may assume that the array contains at least one peak element. # Input Format - A list of integers `arr` with size `n`, where (1 ≤ n ≤ 10^5). # Output Format - An integer representing the index of one of the peak elements. # Example ```python >>> findPeakElement([1, 2, 3, 1]) 2 >>> findPeakElement([1, 3, 20, 4, 1, 0]) 2 >>> findPeakElement([10, 20, 15, 2, 23, 90, 67]) 1 or 5 ``` # Constraints - You must use logarithmic time complexity O(log n). - An array element is a peak if its value is strictly greater than the value of its neighbors. If the element has only one neighbor, that neighbor should be considered. # Guidelines - Think about binary search and how it can be applied to find a peak efficiently. - Compare the middle element with its neighbors to decide the direction to move in to find a peak element.","solution":"from typing import List def findPeakElement(arr: List[int]) -> int: Find a peak element in the array and return its index. low, high = 0, len(arr) - 1 while low < high: mid = (low + high) // 2 if arr[mid] > arr[mid + 1]: high = mid else: low = mid + 1 return low"},{"question":"Data Science - Logistic Regression Classification Task Your task is to implement a logistic regression model utilizing stochastic gradient descent (SGD) for classification tasks. Extend the provided framework to support training on a specified dataset and to evaluate its performance. Objectives: 1. **Classification Model Design and Training**: - Develop a logistic regression model for binary classification tasks. - The model should accept datasets with arbitrary input feature sizes. 2. **Implementation Requirements**: - Implement a new **LogisticRegression** class supporting SGD. - Implement an **evaluation function** to assess model performance on a test set based on accuracy. - Extend the `LogisticRegression` class to support **binary cross-entropy loss** and **regularization techniques** (such as L2 regularization). 3. **Input and Output Formats**: - **Input**: * **Training Data**: (X_{train}) (shape: (N times K)), (Y_{train}) (shape: (N times 1)) * **Test Data**: (X_{test}) (shape: (N\' times K)), (Y_{test}) (shape: (N\' times 1)) - **Output**: * Final accuracy score on the test data. 4. **Data Constraints**: - (N), (N\') (number of samples) ≤ 2000 - (K) (number of features) ≤ 50 5. **Performance Requirement**: - The model should be trained within a maximum of 500 epochs. - Ensure the model can prevent overfitting using regularization techniques. Context: You are building a logistic regression model to classify whether patients have a specific medical condition based on input features such as age, blood pressure, etc. Extend the basic functionality of the logistic regression framework to support this specific classification task, ensuring your model achieves high accuracy on a given test dataset. You do not need to implement the data generation or pre-processing steps. Focus on extending the logistic regression framework to meet the specified requirements. Example Usage: ```python import numpy as np # Dummy Data X_train = np.random.normal(size=(150, 10)) Y_train = np.random.randint(0, 2, size=(150, 1)) X_test = np.random.normal(size=(30, 10)) Y_test = np.random.randint(0, 2, size=(30, 1)) # Model Building and Training model = LogisticRegression(learning_rate=0.01, regularization=\'l2\', lambda_=0.01) model.train(X_train, Y_train, epochs=500) final_accuracy = model.evaluate(X_test, Y_test) print(f\'Final Accuracy on Test Data: {final_accuracy}\') ``` LogisticRegression Class Skeleton ```python class LogisticRegression: def __init__(self, learning_rate=0.01, regularization=None, lambda_=0.01): self.learning_rate = learning_rate self.regularization = regularization self.lambda_ = lambda_ self.weights = None self.bias = None def _initialize_weights(self, feature_size): self.weights = np.zeros((feature_size, 1)) self.bias = 0 def _sigmoid(self, z): return 1 / (1 + np.exp(-z)) def _loss(self, y_true, y_pred): m = y_true.shape[0] loss = -(1 / m) * np.sum(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) if self.regularization == \'l2\': loss += self.lambda_ * np.sum(self.weights ** 2) / (2 * m) return loss def _gradient_descent(self, X, y_true, y_pred): m = X.shape[0] dw = (1 / m) * np.dot(X.T, (y_pred - y_true)) if self.regularization == \'l2\': dw += self.lambda_ * self.weights / m db = (1 / m) * np.sum(y_pred - y_true) self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db def train(self, X, y, epochs=100): feature_size = X.shape[1] self._initialize_weights(feature_size) for _ in range(epochs): linear_pred = np.dot(X, self.weights) + self.bias y_pred = self._sigmoid(linear_pred) self._gradient_descent(X, y, y_pred) def evaluate(self, X, y): linear_pred = np.dot(X, self.weights) + self.bias y_pred = self._sigmoid(linear_pred) y_pred_labels = [1 if i > 0.5 else 0 for i in y_pred] accuracy = np.mean([y_pred_labels[i] == y[i] for i in range(y.shape[0])]) return accuracy ```","solution":"import numpy as np class LogisticRegression: def __init__(self, learning_rate=0.01, regularization=None, lambda_=0.01): self.learning_rate = learning_rate self.regularization = regularization self.lambda_ = lambda_ self.weights = None self.bias = None def _initialize_weights(self, feature_size): self.weights = np.zeros((feature_size, 1)) self.bias = 0 def _sigmoid(self, z): return 1 / (1 + np.exp(-z)) def _loss(self, y_true, y_pred): m = y_true.shape[0] loss = -(1 / m) * np.sum(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred)) if self.regularization == \'l2\': loss += self.lambda_ * np.sum(self.weights ** 2) / (2 * m) return loss def _gradient_descent(self, X, y_true, y_pred): m = X.shape[0] dw = (1 / m) * np.dot(X.T, (y_pred - y_true)) if self.regularization == \'l2\': dw += self.lambda_ * self.weights / m db = (1 / m) * np.sum(y_pred - y_true) self.weights -= self.learning_rate * dw self.bias -= self.learning_rate * db def train(self, X, y, epochs=100): feature_size = X.shape[1] self._initialize_weights(feature_size) for _ in range(epochs): linear_pred = np.dot(X, self.weights) + self.bias y_pred = self._sigmoid(linear_pred) self._gradient_descent(X, y, y_pred) def evaluate(self, X, y): linear_pred = np.dot(X, self.weights) + self.bias y_pred = self._sigmoid(linear_pred) y_pred_labels = [1 if i > 0.5 else 0 for i in y_pred] accuracy = np.mean([y_pred_labels[i] == y[i] for i in range(y.shape[0])]) return accuracy"},{"question":"# Neural Network from Scratch **Objective**: Implement a simple feedforward neural network from scratch to solve a binary classification problem. # Background Neural networks are a set of algorithms, modeled loosely after the human brain, that are designed to recognize patterns. They interpret sensory data through a kind of machine perception, labeling, and clustering of raw input. A neural network consists of input and output layers, as well as one or more hidden layers. # Problem Statement You need to implement a function `simple_neural_network` that builds and trains a simple feedforward neural network. The function should be able to: 1. Train on the provided dataset. 2. Predict the class labels for a test dataset. # Function Signature ```python def simple_neural_network(train_data: np.ndarray, test_data: np.ndarray, hidden_units: int, learning_rate: float, epochs: int) -> np.ndarray: Train a simple feedforward neural network and predict class labels for the test data. Args: train_data (np.ndarray): Training data with the first column as labels (0 or 1) and remaining as features. test_data (np.ndarray): Test data with features only. hidden_units (int): Number of units in the hidden layer. learning_rate (float): Learning rate for weight updates. epochs (int): Number of training iterations. Returns: np.ndarray: Predicted class labels for the test data. pass ``` # Input 1. `train_data` (np.ndarray): The training dataset where the first column contains the class labels (0 or 1) and the rest are feature columns. 2. `test_data` (np.ndarray): The test dataset containing only the feature columns. 3. `hidden_units` (int): The number of units in the hidden layer. 4. `learning_rate` (float): The learning rate for the weight updates. 5. `epochs` (int): Number of epochs for training. # Output An array of predicted class labels (0 or 1) for the test dataset. # Example ```python import numpy as np train_data = np.array([ [1, 2.0, 3.0], [0, 1.0, 1.0], [1, 2.5, 3.5], [0, 1.5, 1.5] ]) test_data = np.array([ [2.0, 2.5], [1.2, 1.3] ]) hidden_units = 5 learning_rate = 0.01 epochs = 10000 predictions = simple_neural_network(train_data, test_data, hidden_units, learning_rate, epochs) print(predictions) # Output: [1, 0] (depending on the implementation) ``` # Constraints 1. The number of features in train and test data should not exceed 1000. 2. The number of samples in train data should not exceed 10,000. 3. The learning rate should be a small positive number. 4. The number of epochs should be a positive integer. # Performance Requirements Your implementation should be efficient enough to handle datasets up to the constraints mentioned. Use numerical libraries like NumPy for matrix operations to ensure performance and scalability. **Hint**: Implement helper functions for activation functions (e.g., sigmoid) and their derivatives. Use gradient descent for weight updates.","solution":"import numpy as np def sigmoid(x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(x): return x * (1 - x) def simple_neural_network(train_data: np.ndarray, test_data: np.ndarray, hidden_units: int, learning_rate: float, epochs: int) -> np.ndarray: np.random.seed(42) # For reproducibility # Separate input features and labels X_train = train_data[:, 1:] y_train = train_data[:, 0].reshape(-1, 1) input_units = X_train.shape[1] output_units = 1 # Binary classification # Initialize weights W1 = np.random.rand(input_units, hidden_units) - 0.5 W2 = np.random.rand(hidden_units, output_units) - 0.5 for epoch in range(epochs): # Forward propagation Z1 = np.dot(X_train, W1) A1 = sigmoid(Z1) Z2 = np.dot(A1, W2) A2 = sigmoid(Z2) # Compute the loss (optional, for monitoring) loss = np.mean((y_train - A2) ** 2) # Backpropagation dZ2 = A2 - y_train dW2 = np.dot(A1.T, dZ2 * sigmoid_derivative(A2)) dZ1 = np.dot(dZ2 * sigmoid_derivative(A2), W2.T) dW1 = np.dot(X_train.T, dZ1 * sigmoid_derivative(A1)) # Update weights W2 -= learning_rate * dW2 W1 -= learning_rate * dW1 # Prediction on test data Z1_test = np.dot(test_data, W1) A1_test = sigmoid(Z1_test) Z2_test = np.dot(A1_test, W2) A2_test = sigmoid(Z2_test) predictions = (A2_test > 0.5).astype(int) return predictions.flatten()"},{"question":"# Question Description Context Data manipulation often involves identifying unique elements within a dataset and removing duplicates. This is a fundamental operation in many data processing and analysis tasks. Task You are required to design a function to remove all duplicate elements from a list while preserving the order of the first occurrence of each element. Detailed Instructions * **Function Signature**: ```python def remove_duplicates(lst: list) -> list: Remove duplicate elements from a list, preserving the order of first occurrences. :param lst: List from which to remove duplicates. :return: List with duplicates removed, in order of first occurrence. ``` * **Expected Input and Output Formats**: * The function accepts a single list `lst`. * The function returns a new list with duplicates removed. * **Constraints**: * The input list can contain any hashable elements. * The input list may be empty. * **Performance Requirements**: The function should run in linear time, i.e., O(n), where n is the length of the list. Examples: ```python >>> remove_duplicates([1, 2, 3, 2, 1, 4]) [1, 2, 3, 4] >>> remove_duplicates([\'a\', \'b\', \'a\', \'c\', \'b\', \'a\']) [\'a\', \'b\', \'c\'] >>> remove_duplicates([]) [] >>> remove_duplicates([1, 1, 1, 1]) [1] >>> remove_duplicates([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\", \\"banana\\", \\"date\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] ``` Edge Cases: 1. If the input list is empty, the function should return an empty list. 2. If the input list contains all unique elements, the function should return the original list. 3. The function should handle lists containing mixed data types (as long as the elements are hashable).","solution":"def remove_duplicates(lst): Remove duplicate elements from a list, preserving the order of first occurrences. :param lst: List from which to remove duplicates. :return: List with duplicates removed, in order of first occurrence. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Task: User Authentication System Scenario You are tasked with developing a basic user authentication system for a web application. Write a class `UserAuth` that allows users to sign up, log in, and log out. The system should store user information in memory (consider a dictionary to store user credentials with usernames as keys). Construct the class `UserAuth` with the following methods: 1. `sign_up(username: str, password: str) -> str` - Registers a new user with the given username and password. - Returns a success message if the registration is successful. - Returns an error message if the username already exists. 2. `log_in(username: str, password: str) -> str` - Authenticates a user with the given username and password. - Returns a success message if the login is successful. - Returns an error message if the username does not exist or the password is incorrect. 3. `log_out(username: str) -> str` - Logs out the specified user. - Returns a success message if the logout is successful. - Returns an error message if the user is not currently logged in. Constraints - Passwords are to be stored as plain text for simplicity (in a real-world application, this would be a security risk and is not recommended). - Assume the username must be unique. - Assume all usernames and passwords are non-empty strings. Example ```python auth_system = UserAuth() # Sign up new users print(auth_system.sign_up(\\"user1\\", \\"password1\\")) # Returns \\"Sign up successful\\" print(auth_system.sign_up(\\"user2\\", \\"password2\\")) # Returns \\"Sign up successful\\" print(auth_system.sign_up(\\"user1\\", \\"password3\\")) # Returns \\"Username already exists\\" # Log in with existing users print(auth_system.log_in(\\"user1\\", \\"password1\\")) # Returns \\"Login successful\\" print(auth_system.log_in(\\"user2\\", \\"wrongpassword\\")) # Returns \\"Invalid credentials\\" print(auth_system.log_in(\\"user3\\", \\"password3\\")) # Returns \\"Invalid credentials\\" # Log out existing users print(auth_system.log_out(\\"user1\\")) # Returns \\"Logout successful\\" print(auth_system.log_out(\\"user2\\")) # Returns \\"User not logged in\\" ``` # Implementation Implement the class `UserAuth` with the described methods and consider the edge cases, such as attempting to sign up with an existing username or logging in with incorrect credentials. ```python class UserAuth: def __init__(self): self.users = {} self.logged_in_users = set() def sign_up(self, username: str, password: str) -> str: if username in self.users: return \\"Username already exists\\" self.users[username] = password return \\"Sign up successful\\" def log_in(self, username: str, password: str) -> str: if username not in self.users or self.users[username] != password: return \\"Invalid credentials\\" self.logged_in_users.add(username) return \\"Login successful\\" def log_out(self, username: str) -> str: if username not in self.logged_in_users: return \\"User not logged in\\" self.logged_in_users.remove(username) return \\"Logout successful\\" # Example usage if __name__ == \\"__main__\\": auth_system = UserAuth() print(auth_system.sign_up(\\"user1\\", \\"password1\\")) # Sign up successful print(auth_system.log_in(\\"user1\\", \\"password1\\")) # Login successful print(auth_system.log_out(\\"user1\\")) # Logout successful ```","solution":"class UserAuth: def __init__(self): self.users = {} self.logged_in_users = set() def sign_up(self, username: str, password: str) -> str: if username in self.users: return \\"Username already exists\\" self.users[username] = password return \\"Sign up successful\\" def log_in(self, username: str, password: str) -> str: if username not in self.users or self.users[username] != password: return \\"Invalid credentials\\" self.logged_in_users.add(username) return \\"Login successful\\" def log_out(self, username: str) -> str: if username not in self.logged_in_users: return \\"User not logged in\\" self.logged_in_users.remove(username) return \\"Logout successful\\""},{"question":"# Problem Description You are given a list of transactions where each transaction is represented by a tuple (customer_id, transaction_amount). Your task is to group the transactions by customer and return a dictionary where the keys are customer IDs and the values are lists of corresponding transaction amounts. # Function Signature ```python def group_transactions_by_customer(transactions: list[tuple[int, float]]) -> dict[int, list[float]]: Group transactions by customer ID. Parameters: transactions (list[tuple[int, float]]): List of transactions where each transaction is represented as a tuple (customer_id, transaction_amount). Returns: dict[int, list[float]]: Dictionary where each key is a customer ID and the value is a list of transaction amounts for that customer. ``` # Input * A list of tuples where each tuple contains: * An integer `customer_id` representing the ID of the customer. * A float `transaction_amount` representing the amount of the transaction. # Output * A dictionary where keys are customer IDs and values are lists of transaction amounts for each customer. # Constraints * `1 <= len(transactions) <= 1000` * Each `transaction_amount` will be a non-negative float. * `0 <= customer_id <= 10000` * Customers may have one or more transactions. # Requirements * The function should group the transactions efficiently. * If a customer has no transactions, they should not appear in the output dictionary. # Example ```python # Example 1 transactions = [(1, 100.0), (2, 150.5), (1, 200.0), (3, 300.75), (2, 50.0)] print(group_transactions_by_customer(transactions)) # Expected Output: # { # 1: [100.0, 200.0], # 2: [150.5, 50.0], # 3: [300.75] # } # Example 2 transactions = [(4, 500.0), (4, 250.0), (5, 1000.0)] print(group_transactions_by_customer(transactions)) # Expected Output: # { # 4: [500.0, 250.0], # 5: [1000.0] # } ``` # Instructions 1. Your task is to complete the `group_transactions_by_customer` function which groups the transactions by customer. 2. Ensure that the function efficiently processes the transactions. 3. The function must return the correct grouping of transactions for given input lists. 4. You will be evaluated based on the accuracy and efficiency of your solution.","solution":"def group_transactions_by_customer(transactions): Group transactions by customer ID. Parameters: transactions (list[tuple[int, float]]): List of transactions where each transaction is represented as a tuple (customer_id, transaction_amount). Returns: dict[int, list[float]]: Dictionary where each key is a customer ID and the value is a list of transaction amounts for that customer. grouped_transactions = {} for customer_id, transaction_amount in transactions: if customer_id in grouped_transactions: grouped_transactions[customer_id].append(transaction_amount) else: grouped_transactions[customer_id] = [transaction_amount] return grouped_transactions"},{"question":"# Coding Assessment Question Description You are given the task of implementing an image pyramiding technique commonly used in computer vision tasks such as multi-scale object detection and image blending. The process involves creating a set of images with increasingly lower resolutions until a specified number of levels is reached. Each successive level in the pyramid reduces the image\'s width and height by half, while maintaining aspect ratio. Given an image, your task is to create a function that constructs its Gaussian pyramid. Task Implement the function: ```python def gaussian_pyramid(image: np.ndarray, levels: int) -> list: :param image: 2D numpy array representing a grayscale image. :param levels: Integer specifying the number of pyramid levels. :return: List of 2D numpy arrays representing the different levels of the Gaussian pyramid. ``` This function should: * Create a list where each element is a 2D numpy array representing a level in the Gaussian pyramid. * The first level should be the original image. * Each subsequent level should be obtained by downsampling the previous level by a factor of 2 in both dimensions. * If a dimension is odd while downsampling, truncate the additional pixel (i.e., use floor operation). Input * `image`: 2D numpy array representing a grayscale image. * `levels`: Integer specifying the number of levels to generate in the Gaussian pyramid. Output * Return a list of 2D numpy arrays. Each element in the list corresponds to an image in the Gaussian pyramid, starting from the original image and downsampled to the specified number of levels. Constraints * 1 <= levels <= 8 * The input image will have dimensions at most 1024x1024. Performance Requirements * The function should handle images up to 1024x1024 efficiently and produce results within reasonable time limits. Example: ```python import numpy as np image = np.array([ [255, 255, 255, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255] ]) levels = 3 result = gaussian_pyramid(image, levels) ``` The `result` would be a list of numpy arrays representing the different levels of the Gaussian pyramid. For the provided example: - result[0] would be the original image, - result[1] would be a 2x2 downsampled version, - result[2] would be a 1x1 downsampled version. The structure of the `result` list in the example will be: ```python [ array([[255, 255, 255, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255]]), array([[255, 255], [255, 0]]), array([[255]]) ] ```","solution":"import numpy as np def gaussian_pyramid(image: np.ndarray, levels: int) -> list: Constructs a Gaussian pyramid from the given image. :param image: 2D numpy array representing a grayscale image. :param levels: Integer specifying the number of pyramid levels. :return: List of 2D numpy arrays representing the different levels of the Gaussian pyramid. pyramid = [image] current_image = image for _ in range(1, levels): # Calculate new dimensions new_height = current_image.shape[0] // 2 new_width = current_image.shape[1] // 2 # Downsample image by taking every second pixel downsampled_image = current_image[0:new_height*2:2, 0:new_width*2:2] pyramid.append(downsampled_image) current_image = downsampled_image return pyramid"},{"question":"Frequency of Characters in String You are tasked with developing a function that takes a string as input and returns a dictionary with the frequency count of each character in the string. Spaces should not be counted. The output dictionary should contain characters as keys and their respective counts as values. **Expected Input and Output Formats**: * **Input**: A string containing any characters, including spaces. * **Output**: A dictionary with characters as keys and their frequencies as values. **Constraints/Limitations**: * The input string may be empty; if so, return an empty dictionary. * All characters (alphabetic, numeric, punctuation, etc.) should be counted except spaces. **Function Signature**: ```python def count_character_frequencies(input_string: str) -> dict[str, int]: ... ``` # Example: ```python # Example input and validation input_str = \\"hello world\\" freq_dict = count_character_frequencies(input_str) print(freq_dict) # Should output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} # Edge case: empty string empty_input_str = \\"\\" empty_freq_dict = count_character_frequencies(empty_input_str) print(empty_freq_dict) # Should output: {} ``` **Notes**: * Ensure to handle empty string input gracefully. * Ignore spaces while counting the character frequencies.","solution":"def count_character_frequencies(input_string: str) -> dict[str, int]: Returns a dictionary with the frequency count of each character in the input string, excluding spaces. frequency = {} for char in input_string: if char != \' \': if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Scenario You are developing an educational software that assists students in learning and practicing sorting algorithms. The software allows students to implement and test various sorting algorithms with given input arrays. An important feature of the software is to allow the students to visually compare the sorting steps of Bubble Sort and Selection Sort side by side. # Task Write a function `compare_sorting_algorithms` that takes an array of integers and outputs the intermediate steps of both Bubble Sort and Selection Sort algorithms. The function should return a dictionary with two keys, `\\"Bubble Sort\\"` and `\\"Selection Sort\\"`, each mapping to a list of lists, where each list represents the state of the array after each pass of the respective sorting algorithm. # Function Signature ```python def compare_sorting_algorithms(arr: list[int]) -> dict[str, list[list[int]]]: ``` # Input - `arr`: A list of integers that needs to be sorted. # Output - Returns a dictionary with: - `\\"Bubble Sort\\"`: A list of lists showing the state of the array after each pass of Bubble Sort. - `\\"Selection Sort\\"`: A list of lists showing the state of the array after each pass of Selection Sort. # Constraints - The input array will have at least 2 and at most 20 elements. - Do not modify the original input array. # Examples ```python print(compare_sorting_algorithms([4, 3, 1, 5])) # Output: # { # \\"Bubble Sort\\": [ # [3, 1, 4, 5], # [1, 3, 4, 5], # [1, 3, 4, 5] # ], # \\"Selection Sort\\": [ # [1, 3, 4, 5], # [1, 3, 4, 5], # [1, 3, 4, 5] # ] # } print(compare_sorting_algorithms([20, 5, 13, 2])) # Output: # { # \\"Bubble Sort\\": [ # [5, 13, 2, 20], # [5, 2, 13, 20], # [2, 5, 13, 20], # [2, 5, 13, 20] # ], # \\"Selection Sort\\": [ # [2, 5, 13, 20], # [2, 5, 13, 20], # [2, 5, 13, 20] # ] # } print(compare_sorting_algorithms([6, 2, 8, 1])) # Output: # { # \\"Bubble Sort\\": [ # [2, 6, 1, 8], # [2, 1, 6, 8], # [1, 2, 6, 8], # [1, 2, 6, 8] # ], # \\"Selection Sort\\": [ # [1, 2, 8, 6], # [1, 2, 8, 6], # [1, 2, 6, 8] # ] # } ``` # Notes - Ensure your solution shows intermediate steps correctly after each pass. - You should not alter the original array in-place, make sure to work on copies of the array. - An intermediate step is the state of the array after completing each outer loop pass in both sorting algorithms.","solution":"def compare_sorting_algorithms(arr): def bubble_sort_steps(array): n = len(array) steps = [] arr_copy = array[:] for i in range(n-1): for j in range(n-i-1): if arr_copy[j] > arr_copy[j+1]: arr_copy[j], arr_copy[j+1] = arr_copy[j+1], arr_copy[j] steps.append(arr_copy[:]) return steps def selection_sort_steps(array): n = len(array) steps = [] arr_copy = array[:] for i in range(n-1): min_idx = i for j in range(i+1, n): if arr_copy[j] < arr_copy[min_idx]: min_idx = j arr_copy[i], arr_copy[min_idx] = arr_copy[min_idx], arr_copy[i] steps.append(arr_copy[:]) return steps result = { \\"Bubble Sort\\": bubble_sort_steps(arr), \\"Selection Sort\\": selection_sort_steps(arr) } return result"},{"question":"# Coding Assessment Question **Objective**: Implement a function that rotates elements of a list to the right by a given number of positions. **Function Signature**: ```python def rotate_list_right(elements: list, k: int) -> list: pass ``` # Input & Output * **Input Format**: * `elements`: A list of elements. Elements may be of any type (integers, strings, etc.). * `k`: An integer representing the number of positions to rotate the list to the right. * **Output Format**: * A single list where elements are rotated to the right by the specified number of positions. # Constraints * The total number of elements in the list does not exceed (10^6). * (0 leq k leq 10^6) # Performance Requirements * Your implementation should be able to handle the length efficiently within the given constraints. # Example 1. **Example 1**: * Input: `[1, 2, 3, 4, 5]`, `2` * Output: `[4, 5, 1, 2, 3]` 2. **Example 2**: * Input: `[\\"A\\", \\"B\\", \\"C\\"]`, `1` * Output: `[\\"C\\", \\"A\\", \\"B\\"]` 3. **Example 3**: * Input: `[7, 8, 9]`, `3` * Output: `[7, 8, 9]` 4. **Example 4**: * Input: `[1, 2, 3]`, `0` * Output: `[1, 2, 3]` # Instructions * Implement the `rotate_list_right` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * Do not print anything in the function; return the result directly.","solution":"def rotate_list_right(elements: list, k: int) -> list: Rotates the elements of the list to the right by k positions. :param elements: List of elements to be rotated. :param k: Number of positions to rotate the list to the right. :return: A new list with elements rotated to the right by k positions. if not elements: return elements n = len(elements) k = k % n # To handle cases where k >= n return elements[-k:] + elements[:-k]"},{"question":"# Given Problem Create a function that simulates a very basic banking system where users can deposit, withdraw, and check balances. The system should handle multiple users and associate transactions with specific users. # Requirements 1. **Function Names and Structure**: - `create_account` (creates a new user account) - `deposit` (adds money to a user’s account) - `withdraw` (removes money from a user’s account) - `check_balance` (returns the current balance of a user\'s account) 2. **Details**: - `create_account` should take a `username` (str) and return `True` if successful; if the user already exists, return `False`. - `deposit` should take a `username` (str) and `amount` (float) and return the new balance if successful; if the user does not exist, raise a `ValueError`. - `withdraw` should take a `username` (str) and `amount` (float) and return the new balance if successful; if the user does not exist, raise a `ValueError`; if the balance is insufficient, return `None`. - `check_balance` should take a `username` (str) and return the current balance if successful; if the user does not exist, raise a `ValueError`. 3. **Global Variables**: - Use a dictionary to store users and their balances. # Examples ```python # Creating accounts create_account(\'Alice\') # Output: True create_account(\'Bob\') # Output: True create_account(\'Alice\') # Output: False # Depositing money deposit(\'Alice\', 50.0) # Output: 50.0 deposit(\'Bob\', 100.0) # Output: 100.0 # Withdrawing money withdraw(\'Alice\', 30.0) # Output: 20.0 withdraw(\'Alice\', 30.0) # Output: None (insufficient balance) # Checking balance check_balance(\'Alice\') # Output: 20.0 check_balance(\'Bob\') # Output: 100.0 ``` # Implementation Write the functions `create_account`, `deposit`, `withdraw`, and `check_balance` to meet the above requirements. **Function Signatures**: ```python def create_account(username: str) -> bool: pass def deposit(username: str, amount: float) -> float: pass def withdraw(username: str, amount: float) -> float: pass def check_balance(username: str) -> float: pass ```","solution":"# Global dictionary to store user balances user_balances = {} def create_account(username: str) -> bool: Creates a new user account. Returns True if successful, False if the user already exists. if username in user_balances: return False user_balances[username] = 0.0 return True def deposit(username: str, amount: float) -> float: Adds money to a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. if username not in user_balances: raise ValueError(\\"User does not exist.\\") user_balances[username] += amount return user_balances[username] def withdraw(username: str, amount: float) -> float: Removes money from a user’s account. Returns the new balance if successful. Raises ValueError if the user does not exist. Returns None if the balance is insufficient. if username not in user_balances: raise ValueError(\\"User does not exist.\\") if user_balances[username] < amount: return None user_balances[username] -= amount return user_balances[username] def check_balance(username: str) -> float: Returns the current balance of a user\'s account. Raises ValueError if the user does not exist. if username not in user_balances: raise ValueError(\\"User does not exist.\\") return user_balances[username]"},{"question":"# Context You have been hired as a software developer for an e-commerce platform. One of your tasks is to implement a feature that calculates the total price of items in a customer\'s cart after applying any applicable discounts. The discount rules can vary and sometimes the total price can exceed a predefined budget, in which case, an adjustment is needed. # Task Write a function `calculate_cart_total(cart: List[Tuple[str, float, int]], discount: float, budget: float) -> float` that calculates the final price of a cart taking into account a discount and a budget constraint. The function must perform the following tasks: # Specifications 1. **Input Format**: * `cart`: A list of tuples with each tuple representing an item in the cart, where each tuple contains: * `item_name` (a string) * `item_price` (a float representing the price of one unit of the item) * `quantity` (an integer representing the number of units of the item) * `discount`: A float representing the discount percentage to be applied (between 0 and 100). * `budget`: A float representing the maximum budget allowed for the cart total. 2. **Output Format**: * A float representing the final total price of the cart after applying the discount and, if necessary, adjusting to the budget. # Constraints * `cart` will contain at most 1000 items. * Each `item_price` in the cart will be a positive float. * Each `quantity` in the cart will be a positive integer. * `discount` will be a float between 0 and 100 inclusive. * `budget` will be a positive float. # Performance Requirements * The solution should efficiently handle the maximum input size within a reasonable time frame. # Examples * `calculate_cart_total([(\'item1\', 10.0, 2), (\'item2\', 5.0, 4)], 10.0, 50.0)` should return `40.5` * `calculate_cart_total([(\'item1\', 15.0, 3), (\'item2\', 20.0, 1)], 20.0, 60.0)` should return `54.0` * `calculate_cart_total([(\'item1\', 100.0, 1)], 50.0, 45.0)` should return `45.0` # Additional Notes * The function should strictly validate the inputs and handle edge cases. * If the discounted total exceeds the budget, adjust the total to equal the budget. * Ensure that all floating-point arithmetic is handled precisely. * The function does not need to handle invalid inputs as part of the constraints guarantee validity.","solution":"from typing import List, Tuple def calculate_cart_total(cart: List[Tuple[str, float, int]], discount: float, budget: float) -> float: Calculates the final price of the cart after applying a discount and enforcing a budget constraint. Parameters: cart (List[Tuple[str, float, int]]): A list of tuples where each tuple contains the item name, price per unit, and quantity. discount (float): The discount percentage to be applied (between 0 and 100 inclusive). budget (float): The maximum budget allowed for the cart total. Returns: float: The final total price of the cart after applying the discount and adjusting to the budget if necessary. # Calculate the initial total price of the cart initial_total = sum(item_price * quantity for item_name, item_price, quantity in cart) # Apply the discount discounted_total = initial_total * (1 - discount / 100) # Enforce the budget constraint final_total = min(discounted_total, budget) return final_total"},{"question":"# Coding Assessment Question Context You are tasked with implementing a stack data structure that supports a new functionality: returning the minimum element in the stack in constant time. This will test your ability to design algorithms that maintain auxiliary data to ensure efficiency. Task Implement a class `MinStack` that supports the following methods: * `push(val)`: Pushes the value `val` onto the stack. * `pop()`: Removes the element on the top of the stack. * `top()`: Gets the top element of the stack. * `getMin()`: Retrieves the minimum element in the stack. Function Specifications ```python class MinStack: def __init__(self): Initializes the stack. Examples: >>> stack = MinStack() >>> stack.push(-2) >>> stack.push(0) >>> stack.push(-3) >>> stack.getMin() -3 >>> stack.pop() >>> stack.top() 0 >>> stack.getMin() -2 Returns: None self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes the value \'val\' onto the stack. Args: val (int): Value to be added to the stack Returns: None self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack. Returns: None if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Gets the top element of the stack. Returns: int: Top element of the stack if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieves the minimum element in the stack. Returns: int: Minimum element of the stack if self.min_stack: return self.min_stack[-1] ``` Constraints * You must implement all methods to achieve O(1) time complexity. Input Format The methods are called in the following order: `push`, `pop`, `top`, `getMin`. Each method has its specific inputs and outputs as described. Output Format Return values of the methods according to their specifications. For `push` and `pop`, there\'s no return value. For `top` and `getMin`, return the appropriate element. Examples * Input: ```python stack = MinStack() stack.push(-2) stack.push(0) stack.push(-3) ``` * Expected Output: ```python stack.getMin() # returns -3 stack.pop() stack.top() # returns 0 stack.getMin() # returns -2 ```","solution":"class MinStack: def __init__(self): Initializes the stack. self.stack = [] self.min_stack = [] def push(self, val: int) -> None: Pushes the value \'val\' onto the stack. Args: val (int): Value to be added to the stack Returns: None self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: Removes the element on the top of the stack. Returns: None if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: Gets the top element of the stack. Returns: int: Top element of the stack if self.stack: return self.stack[-1] def getMin(self) -> int: Retrieves the minimum element in the stack. Returns: int: Minimum element of the stack if self.min_stack: return self.min_stack[-1]"},{"question":"# Coding Task: Efficient Graph Traversal with Shortest Path Detection __Context:__ You need to develop a program that finds the shortest path in a weighted, directed graph. This program will help in various applications such as network routing, road maps, and project management. Ensure that your implementation can handle graphs with various edge weights, including negative weights, provided there are no negative weight cycles. __Question:__ Implement the algorithm to find the shortest path from a given start node to a destination node in a weighted, directed graph using Bellman-Ford Algorithm. Your function should detect negative weight cycles, and, if found, return a message indicating the presence of such cycles. __Expected Input and Output:__ - **Input**: 1. An integer `n` representing the number of nodes (0-indexed). 2. A list of tuples representing the edges in the graph, where each tuple contains three integers `(u, v, w)` describing an edge from node `u` to node `v` with weight `w`. 3. An integer `start` representing the starting node. 4. An integer `end` representing the destination node. - **Output**: 1. If there\'s a negative weight cycle, return the string \\"Negative weight cycle detected\\". 2. Otherwise, return a tuple containing the length of the shortest path and the path as a list of nodes. __Constraints:__ - The number of nodes `n` will be within the range of 1 to 5000. - The number of edges will be within the range of 0 to 10000. - Edge weights can be any integer including negative values. __Performance Requirements:__ - The algorithm should perform within O(V * E) time complexity, where V is the number of vertices and E is the number of edges. __Function Signature:__ ```python def find_shortest_path(n: int, edges: list[tuple[int, int, int]], start: int, end: int) -> str or tuple[int, list[int]]: pass ``` __Example:__ ```python >>> find_shortest_path(5, [(0, 1, 5), (1, 2, 2), (2, 3, -1), (3, 4, 3)], 0, 4) (9, [0, 1, 2, 3, 4]) >>> find_shortest_path(3, [(0, 1, 1), (1, 2, 3), (2, 0, -6)], 0, 2) \\"Negative weight cycle detected\\" >>> find_shortest_path(4, [(0, 1, 4), (0, 2, 5), (1, 2, 1)], 0, 2) (5, [0, 2]) ``` __Additional Notes:__ 1. Validate your solution with different types of graphs, including those with negative weights and those without any cycles. 2. Ensure the path returned is the actual shortest path from the `start` node to the `end` node.","solution":"def find_shortest_path(n: int, edges: list[tuple[int, int, int]], start: int, end: int) -> str or tuple[int, list[int]]: # Initialize distances from start to all other vertices as infinity and distance to itself as 0 dist = [float(\'inf\')] * n dist[start] = 0 # Initialize the predecessor list to store the path predecessor = [-1] * n # Relax all edges |V| - 1 times for _ in range(n - 1): for u, v, w in edges: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: dist[v] = dist[u] + w predecessor[v] = u # Check for negative-weight cycles for u, v, w in edges: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: return \\"Negative weight cycle detected\\" # Reconstruct the path if dist[end] == float(\'inf\'): return (float(\'inf\'), []) path = [] crawl = end while crawl != -1: path.append(crawl) crawl = predecessor[crawl] path.reverse() return (dist[end], path)"},{"question":"# Problem Statement: You have been given the task to write a function that takes in a string and returns the string with all vowels (a, e, i, o, u) duplicated. This problem tests your ability to manipulate strings and iterate through their characters efficiently. # Function Signature: ```python def duplicate_vowels(input_string: str) -> str: ``` # Input: - `input_string` (str): A non-empty string consisting of lowercase and uppercase English letters and spaces. # Output: - (str): A new string where every vowel in the original string is duplicated. # Constraints: - The input string will have at most length 10^5. # Example: ```python >>> duplicate_vowels(\'Hello World\') \'Heelloo Woorld\' >>> duplicate_vowels(\'Python\') \'Pythoon\' ``` # Requirements: 1. Identify vowels in the string (both uppercase and lowercase). 2. Efficiently create a new string where each vowel in the input string is duplicated. 3. Consider edge cases such as strings with no vowels or strings entirely made of vowels. # Notes: - The input string can have any combination of characters including vowels in both cases, consonants, and spaces. - Ensure the function processes strings up to the maximum length constraint optimally in terms of time and space complexity. Good luck with your implementation!","solution":"def duplicate_vowels(input_string: str) -> str: vowels = \\"aeiouAEIOU\\" result = [] for char in input_string: result.append(char) if char in vowels: result.append(char) return \'\'.join(result)"},{"question":"# Scenario: You have been hired by an environmental research organization to create a tool that helps monitor temperatures in various cities. An essential feature of this tool is to analyze temperature readings and determine the difference between the highest and lowest temperatures for a given city. # Task: Implement a function `temperature_range(readings: List[float]) -> float` that takes a list of temperature readings in Celsius for a particular day in a city and returns the difference between the highest and lowest temperatures. # Requirements: * **Inputs**: * `readings`: A list of temperature readings in Celsius (float). There can be multiple readings throughout the day. * **Output**: * The function should return the difference between the highest and lowest temperatures (float). # Constraints: * If the provided list is empty, the function should raise a `ValueError` with the message `\\"Temperature readings list cannot be empty\\"`. # Function Signature: ```python def temperature_range(readings: List[float]) -> float: ``` # Examples: ```python >>> round(temperature_range([25.3, 18.7, 30.5, 22.1, 28.8]), 1) 11.8 >>> round(temperature_range([10.0, 15.5, 20.2, 15.5, 10.0]), 1) 10.2 >>> round(temperature_range([-5.0, -10.3, 0.0, -3.2]), 1) 10.3 >>> round(temperature_range([35.5, 35.5, 35.5]), 1) 0.0 >>> round(temperature_range([17.7]), 1) 0.0 ``` # Additional Challenge: Consider optimizing the function to handle very large lists of temperature readings efficiently.","solution":"from typing import List def temperature_range(readings: List[float]) -> float: if not readings: raise ValueError(\\"Temperature readings list cannot be empty\\") max_temp = max(readings) min_temp = min(readings) return max_temp - min_temp"},{"question":"# Problem Statement You are given an array of integers. Your task is to implement a function that finds the three largest unique integers in the array and returns them in descending order. # Function Signature ```python def three_largest_unique_integers(arr: list[int]) -> list[int]: ``` # Input * A list of integers ( arr ) # Output * A list of three integers representing the three largest unique integers in the input list in descending order. If there are fewer than three unique integers, return those integers in descending order. # Constraints * The array contains at least one element. * The array length does not exceed ( 10^5 ). * Array elements are within the range (-10^9 leq x leq 10^9). # Example ```python assert three_largest_unique_integers([10, 5, 9, 10, 12]) == [12, 10, 9] assert three_largest_unique_integers([1, 1, 1]) == [1] assert three_largest_unique_integers([-1, -2, -3, -4]) == [-1, -2, -3] assert three_largest_unique_integers([7]) == [7] assert three_largest_unique_integers([5, 5, 4, 3]) == [5, 4, 3] assert three_largest_unique_integers([4, 4, 4, 4, 4, 4, 4]) == [4] ``` # Explanation For each test case: 1. Identify unique integers in the array. 2. Find the three largest integers among them. 3. Return these integers in descending order. # Notes * The function should handle arrays containing both positive and negative integers. * Ensure your implementation is optimized for performance given the constraint on array length. * If there are fewer than three unique integers, return all of them in descending order.","solution":"def three_largest_unique_integers(arr: list[int]) -> list[int]: Finds the three largest unique integers in the array and returns them in descending order. If there are fewer than three unique integers, returns those integers in descending order. unique_numbers = list(set(arr)) unique_numbers.sort(reverse=True) return unique_numbers[:3]"},{"question":"# Scenario: You have been tasked to analyze the performance metrics of a company’s various products over different quarters. The company wants to visualize the total sales for each product over the quarters in the form of a simple bar graph. However, the data provided is in a nested list format, and you need to process this data accordingly. # Task: Write a function that calculates the total sales for each product across all quarters and returns the results in a format suitable for plotting a bar graph. The function should also provide the labels for each product to be used on the bar graph. # Function Signature: ```python def calculate_total_sales(sales_data: List[List[float]], product_names: List[str]) -> Tuple[List[str], List[float]]: pass ``` # Input: - `sales_data`: A list of lists containing the sales figures for each product per quarter. Each inner list represents a product, and its elements represent sales figures for consecutive quarters. The length of each inner list is the same. - `product_names`: A list of strings representing the names of the products corresponding to each inner list in `sales_data`. # Output: - Returns a tuple containing: - A list of product names. - A list of total sales for each product. # Constraints: - The number of products (length of `sales_data` and `product_names`) will not exceed 1000. - Each product will have sales data for at most 10 quarters. # Example: ```python >>> sales_data = [ [1500.0, 1600.0, 1700.0, 1800.0], [2000.0, 2100.0, 2200.0, 2300.0], [2500.0, 2400.0, 2600.0, 2700.0] ] >>> product_names = [\\"Product A\\", \\"Product B\\", \\"Product C\\"] >>> calculate_total_sales(sales_data, product_names) ([\\"Product A\\", \\"Product B\\", \\"Product C\\"], [6600.0, 8600.0, 10200.0]) ``` # Notes: - Ensure the function handles lists efficiently and correctly calculates the total sales for each product. - The sales data are always valid and will contain no missing values. - Focus on making the function easy to understand and maintain while also being efficient.","solution":"from typing import List, Tuple def calculate_total_sales(sales_data: List[List[float]], product_names: List[str]) -> Tuple[List[str], List[float]]: Calculate the total sales for each product across all quarters. Parameters: sales_data (List[List[float]]): A list of lists containing quarterly sales for each product. product_names (List[str]): A list of product names corresponding to each product in sales_data. Returns: Tuple[List[str], List[float]]: A tuple containing a list of the product names and a list of their total sales. total_sales = [sum(product_sales) for product_sales in sales_data] return product_names, total_sales"},{"question":"# Subset Sum Problem Objective: Implement a function to solve the subset sum problem using a backtracking approach. The function should determine if there exists a subset of a given list of integers that sums up to a given target value. Function Signature: ```python def subset_sum(nums: list[int], target: int) -> bool: ``` Input: - `nums`: A list of integers. - `target`: An integer representing the target sum. Output: - A boolean value: `True` if there exists a subset of `nums` that sums up to `target`, otherwise `False`. Constraints: - The number of elements in `nums` (`n`): `1 <= n <= 20` - Each integer in `nums` (`ai`): `-1000 <= ai <= 1000` - The target value (`target`): `-10000 <= target <= 10000` Example: ```python nums = [3, 34, 4, 12, 5, 2] target = 9 assert subset_sum(nums, target) == True nums = [3, 34, 4, 12, 5, 2] target = 30 assert subset_sum(nums, target) == False ``` Details: - The function should account for edge cases such as an empty list or a single-element list. - Implement the backtracking approach efficiently to handle all possible subsets within the given constraints. - Consider different scenarios such as negative numbers, positive numbers as well as a mix of both. Implement the function and test it against the provided examples and additional cases to ensure its correctness and efficiency.","solution":"def subset_sum(nums: list[int], target: int) -> bool: def backtrack(index, current_sum): if current_sum == target: return True if index >= len(nums): return False # Include nums[index] in the subset include = backtrack(index + 1, current_sum + nums[index]) # Exclude nums[index] from the subset exclude = backtrack(index + 1, current_sum) return include or exclude return backtrack(0, 0)"},{"question":"# Question: Find the Single Non-repeated Element You are given a list of integers where every element appears twice, except for one element that appears only once. Your task is to find that single element. Requirements: Write a function `find_single_element` that: - Accepts a list of integers `nums`. - Returns the single element that does not have a duplicate in the list. # Input: - `nums` (List[int]): A list of integers where every integer appears twice except for one integer that appears only once. The list will always have an odd number of elements. # Output: - (int): The single element that appears only once. # Constraints: - The list `nums` should have at least three elements. - The solution should have a linear runtime complexity (O(n)) and use constant space complexity (O(1)). # Example: ```python assert find_single_element([2, 2, 1]) == 1 assert find_single_element([4, 1, 2, 1, 2]) == 4 assert find_single_element([1, 3, 1, 4, 4, 5, 5]) == 3 ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python def find_single_element(nums: list) -> int: # Start by initializing the variable that will contain the single element. single_element = 0 # To find the single element, iterate over the list and apply XOR operation. for num in nums: single_element ^= num return single_element # Test your implementation if __name__ == \\"__main__\\": assert find_single_element([2, 2, 1]) == 1 assert find_single_element([4, 1, 2, 1, 2]) == 4 assert find_single_element([1, 3, 1, 4, 4, 5, 5]) == 3 ```","solution":"def find_single_element(nums: list) -> int: Returns the single element that does not have a duplicate in the list. The function uses the XOR operation to achieve O(n) runtime complexity and O(1) space complexity. single_element = 0 for num in nums: single_element ^= num return single_element"},{"question":"# Coding Assessment Question Scenario A common problem in computer science is to determine if a list of integers is strictly increasing, meaning each subsequent integer in the list is greater than the one before it. This property is frequently needed in algorithms where maintaining or verifying order is crucial, such as in sorting functions or when analyzing time-based data. Task Write a Python function named `is_strictly_increasing` that determines whether a given list of integers is strictly increasing. The function should handle edge cases and incorrect input types gracefully. Function Signature ```python def is_strictly_increasing(lst: list) -> bool: pass ``` Input - `lst`: A list of integers. Output - A boolean value. Return `True` if the list is strictly increasing, and `False` otherwise. - If the input list is empty, return `True`. - For non-list input types, raise a `TypeError` with an appropriate error message. - If the input list contains non-integer types, raise a `ValueError` with an appropriate error message. Constraints - The length of the list will be between 0 and (10^6). Performance Requirements - The solution should be efficient with a linear time complexity O(n). Examples ```python print(is_strictly_increasing([1, 2, 3, 4, 5])) # Should return True print(is_strictly_increasing([1, 2, 2, 4, 5])) # Should return False print(is_strictly_increasing([5, 6, 7, 8, 9])) # Should return True print(is_strictly_increasing([])) # Should return True print(is_strictly_increasing([1])) # Should return True ``` Constraints and Error Handling - If the input is not a list, raise a `TypeError` stating \\"Input value must be a list\\". - If any element in the list is not an integer, raise a `ValueError` stating \\"List elements must be integers\\".","solution":"def is_strictly_increasing(lst): Determines if the given list of integers is strictly increasing. Parameters: lst: list - A list of integers Returns: bool - True if the list is strictly increasing, False otherwise. if not isinstance(lst, list): raise TypeError(\\"Input value must be a list\\") for i in lst: if not isinstance(i, int): raise ValueError(\\"List elements must be integers\\") for i in range(len(lst) - 1): if lst[i] >= lst[i + 1]: return False return True"},{"question":"# Question: Implementing Dijkstra\'s Algorithm for Shortest Path You are tasked with implementing Dijkstra\'s algorithm to find the shortest path from a given start node to all other nodes in a weighted, directed graph. The graph will be represented as an adjacency list, where each key is a node and its value is a list of tuples representing its neighboring nodes and the weights of the edges connecting them. Function Signature ```python def dijkstra(graph: dict[int, list[tuple[int, float]]], start: int) -> dict[int, float]: ``` Input * `graph`: A dictionary where keys are node identifiers (integers) and values are lists of tuples `(neighbor, weight)` representing the neighboring node and the weight of the edge connecting the current node to that neighbor. * `start`: An integer representing the start node from which to calculate shortest paths. Output * Returns a dictionary where keys are node identifiers and values are the shortest distances from the start node to that node. If a node is not reachable from the start node, its distance should be `float(\'inf\')`. Constraints * All nodes and weights are non-negative integers. * The graph may be disconnected. * The graph contains no negative weight edges. Example ```python graph1 = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } # Expected to return: {0: 0, 1: 3, 2: 1, 3: 4} print(dijkstra(graph1, 0)) graph2 = { 0: [(1, 2)], 1: [(2, 3)], 2: [(3, 4)], 3: [] } # Expected to return: {0: 0, 1: 2, 2: 5, 3: 9} print(dijkstra(graph2, 0)) graph3 = { 0: [(1, 1)], 1: [(2, 2)], 2: [(3, 1)], 3: [(0, 4)] } # Expected to return: {0: 0, 1: 1, 2: 3, 3: 4} print(dijkstra(graph3, 0)) ``` Note * Ensure that your implementation can handle larger graphs efficiently. * Handle cases where the start node does not connect to all nodes; such nodes should have a distance of `float(\'inf\')`. * It is permissible to import necessary modules such as `heapq` for priority queue operations. * The function should be robust to handle the example cases and potential edge cases effectively.","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra\'s algorithm to find the shortest path from start node. Args: graph (dict): A dictionary where keys are node identifiers (integers) and values are lists of tuples (neighbor, weight) representing the edges. start (int): The starting node identifier. Returns: dict: A dictionary where keys are node identifiers and values are the shortest distances from the start node to that node. # Initialize distances with infinity distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue to process nodes priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Nodes can appear multiple times in the priority queue # We need to skip the processing for nodes we\'ve already seen if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Sorting and Deduplication of a List You are given a function that processes a list of integers. Your task is to write a Python function that will sort the list in non-decreasing order and remove any duplicates from the list before returning it. The list will be provided as an array of integers, where each integer can be any valid integer within the range of -10^6 to 10^6. Your function should first remove duplicates from the list, then sort it in non-decreasing order, and finally return the processed list. Function Signature ```python def sort_and_deduplicate(nums: List[int]) -> List[int]: ``` Input - `nums`: A list of integers. Length of the list will be between 1 and 10^6, inclusive. Output - Return a list of integers sorted in non-decreasing order with all duplicates removed. Constraints - The `nums` array can contain any integer within the range of -10^6 to 10^6. - The input list may contain duplicate integers. Example ```python >>> sort_and_deduplicate([4, 2, 7, 3, 2, 2, 4, 5]) [2, 3, 4, 5, 7] >>> sort_and_deduplicate([-1, -3, -2, 2, 0, 2, -3]) [-3, -2, -1, 0, 2] >>> sort_and_deduplicate([1, 3, 3, 2, 1, 1, 4]) [1, 2, 3, 4] >>> sort_and_deduplicate([0]) [0] ``` Explanation - In the first example, the list `[4, 2, 7, 3, 2, 2, 4, 5]` is processed as follows: - Remove duplicates: `[2, 3, 4, 5, 7]` - Sorted list: `[2, 3, 4, 5, 7]` - In the second example: - Remove duplicates: `[-3, -2, -1, 0, 2]` - Sorted list: `[-3, -2, -1, 0, 2]` - In the third example: - Remove duplicates: `[1, 2, 3, 4]` - Sorted list: `[1, 2, 3, 4]` - In the fourth example: - List already contains one element which is deduplicated: `[0]` - Sorted list: `[0]`","solution":"from typing import List def sort_and_deduplicate(nums: List[int]) -> List[int]: Return a list of integers sorted in non-decreasing order with all duplicates removed. return sorted(set(nums))"},{"question":"# Employee Productivity Tracker **Scenario**: You are asked to implement a function to track the productivity of employees in a company. Each employee has a unique ID and a list of tasks they have completed on a given day. Each task has a certain complexity level, and the productivity of an employee is defined as the sum of complexity levels of all the tasks they have completed. **Objective**: Your job is to implement a function `track_productivity(tasks: list[tuple[int, int]]) -> dict[int, int]` that computes the total productivity for each employee and returns a dictionary mapping employee IDs to their respective productivity scores. **Function Signature**: ```python def track_productivity(tasks: list[tuple[int, int]]) -> dict[int, int]: # your code here ``` **Input**: * `tasks`: A list of tuples where each tuple contains two integers. The first integer is the employee ID, and the second integer is the complexity level of a task completed by that employee. **Output**: * Returns a dictionary where the keys are employee IDs and the values are the total productivity scores for those employees. **Constraints**: * Employee IDs are unique within the list. * There can be multiple tasks per employee. * Complexity levels are positive integers. **Edge Cases**: * No tasks are provided (empty list). * All tasks belong to a single employee. # Example ```python tasks = [ (1, 5), (1, 3), (2, 7), (2, 2), (3, 10) ] track_productivity(tasks) # Returns: {1: 8, 2: 9, 3: 10} tasks = [ (4, 4), (4, 1), (4, 3) ] track_productivity(tasks) # Returns: {4: 8} tasks = [] track_productivity(tasks) # Returns: {} ``` Write your function considering the provided scenarios and constraints. Ensure your implementation efficiently computes the total productivity for each employee and handles all edge cases correctly.","solution":"def track_productivity(tasks: list[tuple[int, int]]) -> dict[int, int]: Computes the total productivity for each employee based on the complexity levels of tasks they have completed. :param tasks: A list of tuples where each tuple contains two integers, the employee ID and the complexity level of a task. :return: A dictionary where keys are employee IDs and values are total productivity scores. productivity = {} for employee_id, complexity in tasks: if employee_id in productivity: productivity[employee_id] += complexity else: productivity[employee_id] = complexity return productivity"},{"question":"# Airline Reservation System Scenario: You are developing a simple airline reservation system. This system should allow users to book, cancel, and view their reservations for flights. The program will need to manage the reservations in an organized manner and ensure no duplicate bookings for the same user on the same flight. Task: Write a Python class `AirlineReservation` that provides the following functionalities: 1. `book_seat(user_id: int, flight_id: int) -> bool`: Books a seat for the user on the given flight if available. Returns `True` if the booking is successful, otherwise returns `False`. 2. `cancel_seat(user_id: int, flight_id: int) -> bool`: Cancels the seat reservation for the user on the given flight. Returns `True` if the cancellation is successful, otherwise returns `False`. 3. `view_reservations(user_id: int) -> List[int]`: Returns a list of flight IDs for the flights reserved by the given user. Requirements: 1. Use a dictionary to store reservations with `user_id` as the key and a set of `flight_ids` as the value. 2. Ensure no duplicate reservations (user cannot book the same flight more than once). 3. Handle the cancellation appropriately (user can only cancel a flight they have booked). 4. Provide meaningful feedback based on the success or failure of the operations. # Class Definition ```python class AirlineReservation: def __init__(self): self.reservations = {} def book_seat(self, user_id: int, flight_id: int) -> bool: pass def cancel_seat(self, user_id: int, flight_id: int) -> bool: pass def view_reservations(self, user_id: int) -> List[int]: pass ``` Input * `user_id`: An integer representing the ID of the user. * `flight_id`: An integer representing the ID of the flight. Constraints * Each function should execute efficiently given typical input sizes. * You can assume `user_id` and `flight_id` are unique integers. Output * `book_seat` returns `True` or `False` based on the booking success. * `cancel_seat` returns `True` or `False` based on the cancellation success. * `view_reservations` returns a list of integers representing flight IDs. Notes * Ensure no duplicate reservations for the same flight by the same user. * Maintain consistency and integrity of the reservation data. * Handle cases where user tries to cancel a non-existent reservation gracefully.","solution":"class AirlineReservation: def __init__(self): self.reservations = {} def book_seat(self, user_id: int, flight_id: int) -> bool: if user_id not in self.reservations: self.reservations[user_id] = set() if flight_id not in self.reservations[user_id]: self.reservations[user_id].add(flight_id) return True else: return False def cancel_seat(self, user_id: int, flight_id: int) -> bool: if user_id in self.reservations and flight_id in self.reservations[user_id]: self.reservations[user_id].remove(flight_id) if not self.reservations[user_id]: del self.reservations[user_id] return True else: return False def view_reservations(self, user_id: int) -> list: if user_id in self.reservations: return list(self.reservations[user_id]) return []"},{"question":"# Problem Statement You are tasked with implementing a feature for a data analysis application that involves processing time series data. One common operation is to compute a moving average, which smooths out short-term fluctuations and highlights longer-term trends or cycles. Your task is to implement a function `moving_average` that takes a list of floating-point numbers and an integer `k` representing the window size. The function should return a list of floating-point numbers representing the moving average of the input list. # Requirements 1. Implement the `moving_average(data: list[float], k: int) -> list[float]` function. 2. The function should compute the moving average in a way that handles edge cases gracefully, including when the window size `k` is larger than the length of the input list. 3. Return a list of the computed moving averages. # Input Format * A list of floating-point numbers representing the time series data. * An integer `k` representing the window size for the moving average. # Output Format * A list of floating-point numbers representing the moving average of the input list. # Constraints * The length of the input list `data` will be between 1 and 10^5. * The window size `k` will be a positive integer that is less than or equal to the length of the input list. * Each floating-point number in the input list will be in the range [-10^4, 10^4]. # Example ```python # Input data = [1.0, 2.0, 3.0, 4.0, 5.0] k = 3 # Output output = [2.0, 3.0, 4.0] ``` In the example above, the moving average is computed using a window size of 3: - The first window is [1.0, 2.0, 3.0] with an average of (1.0 + 2.0 + 3.0) / 3 = 2.0. - The second window is [2.0, 3.0, 4.0] with an average of (2.0 + 3.0 + 4.0) / 3 = 3.0. - The third window is [3.0, 4.0, 5.0] with an average of (3.0 + 4.0 + 5.0) / 3 = 4.0. Implement the function `moving_average` that meets the above requirements.","solution":"def moving_average(data: list[float], k: int) -> list[float]: Computes the moving average of the input list with the specified window size k. Parameters: - data: list of floating-point numbers representing the time series data. - k: integer representing the window size for the moving average. Returns: - list of floating-point numbers representing the moving average. if k <= 0 or k > len(data): return [] averages = [] window_sum = sum(data[:k]) averages.append(window_sum / k) for i in range(k, len(data)): window_sum += data[i] - data[i - k] averages.append(window_sum / k) return averages"},{"question":"# Problem Statement You are tasked with implementing a combination of data structures for efficient operations on a dynamic map of strings to integers. The structure, `DynamicStringIntMap`, should support the following operations: 1. **Initialization**: Construct the data structure with an optional initial dictionary of string-integer pairs. 2. **Insert/Update Value**: Insert a new key-value pair or update the value of an existing key. 3. **Delete Key**: Remove a key-value pair from the map. 4. **Get Value**: Retrieve the value associated with a given key. 5. **Check Key**: Verify if a particular key exists in the map. 6. **Longest Key**: Return the string key with the most characters in the map. # Function Signatures ```python class DynamicStringIntMap: def __init__(self, initial_data: dict[str, int] = None) -> None: Initializes the data structure with an optional initial map. def insert_or_update(self, key: str, value: int) -> None: Inserts a new key-value pair or updates the value of an existing key. def delete(self, key: str) -> None: Deletes the key-value pair associated with the given key. def get_value(self, key: str) -> int: Returns the value associated with the given key. If the key does not exist, raise a KeyError. def contains_key(self, key: str) -> bool: Returns True if the key exists in the map, False otherwise. def longest_key(self) -> str: Returns the key with the most characters. If there are multiple, return any one of them. ``` # Input Constraints - Keys and values are non-empty strings and integers, respectively. - The length of each key will be at most 1000 characters. - The initial map can contain up to `10^5` key-value pairs. - Operations will be frequent and should maintain efficient performance. # Example Usage ```python # Initialize the data structure with an optional initial data dmap = DynamicStringIntMap({\\"apple\\": 1, \\"banana\\": 2}) # Insert a new key-value pair dmap.insert_or_update(\\"cherry\\", 3) print(dmap.get_value(\\"cherry\\")) # Output: 3 # Update the value of an existing key dmap.insert_or_update(\\"banana\\", 5) print(dmap.get_value(\\"banana\\")) # Output: 5 # Delete a key-value pair dmap.delete(\\"apple\\") print(dmap.contains_key(\\"apple\\")) # Output: False # Check existence of a key print(dmap.contains_key(\\"banana\\")) # Output: True # Get the longest key print(dmap.longest_key()) # Output: \\"banana\\" or \\"cherry\\" ``` # Constraints - You must handle edge cases such as empty initial data, non-existent keys for get_value and delete operations. - Ensure efficient handling of frequent updates and queries to maintain overall performance.","solution":"class DynamicStringIntMap: def __init__(self, initial_data: dict[str, int] = None) -> None: Initializes the data structure with an optional initial map. self.map = initial_data if initial_data else {} def insert_or_update(self, key: str, value: int) -> None: Inserts a new key-value pair or updates the value of an existing key. self.map[key] = value def delete(self, key: str) -> None: Deletes the key-value pair associated with the given key. if key in self.map: del self.map[key] else: raise KeyError(f\\"Key {key} not found\\") def get_value(self, key: str) -> int: Returns the value associated with the given key. If the key does not exist, raise a KeyError. if key in self.map: return self.map[key] else: raise KeyError(f\\"Key {key} not found\\") def contains_key(self, key: str) -> bool: Returns True if the key exists in the map, False otherwise. return key in self.map def longest_key(self) -> str: Returns the key with the most characters. If there are multiple, return any one of them. return max(self.map.keys(), key=len) if self.map else None"},{"question":"# Problem: Implement Binary Search with Custom Comparator Context You are working on a library that provides utility functions for various data manipulation tasks. One of the essential components of this library is a binary search function that operates on sorted collections. Additionally, you want this binary search function to be versatile by allowing custom comparison logic. Task 1. **Implement a Binary Search function** that accepts an optional comparator to define custom comparison logic. 2. **Handle edge cases** such as empty collections gracefully. Details 1. **Functionality**: - You will implement the `binary_search` function that supports custom comparators. 2. **Input and Output Formats**: - `binary_search(arr: List[int], target: int, comparator: Callable[[int, int], int] = None) -> int`: - `arr`: A sorted list of integers where the search will be performed. - `target`: The value to search for in the list. - `comparator`: An optional comparator function that returns: - A negative number if the first argument is less than the second. - Zero if the arguments are equal. - A positive number if the first argument is greater than the second. 3. **Constraints and Requirements**: - The search function should return the index of the target if found, otherwise -1. - Ensure that the default comparison works correctly for integers. - Custom comparators should be used if provided. - Handle cases where the list is empty or the target is not present. 4. **Example Usage**: - `binary_search([1, 2, 3, 4, 5], 3)` should return the index `2`. - `binary_search([1, 2, 3, 4, 5], 6)` should return `-1`. - With custom comparator: `binary_search([5, 4, 3, 2, 1], 3, lambda a, b: b - a)` should return the index `2`. Implementation ```python from typing import List, Callable def binary_search(arr: List[int], target: int, comparator: Callable[[int, int], int] = None) -> int: Implementation of Binary Search Algorithm with optional custom comparator. if not comparator: comparator = lambda a, b: a - b left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 comparison = comparator(arr[mid], target) if comparison == 0: return mid elif comparison < 0: left = mid + 1 else: right = mid - 1 return -1 # Example to test print(binary_search([1, 2, 3, 4, 5], 3)) # Expected: 2 print(binary_search([1, 2, 3, 4, 5], 6)) # Expected: -1 # Testing with a descendingly sorted array and a custom comparator print(binary_search([5, 4, 3, 2, 1], 3, lambda a, b: b - a)) # Expected: 2 ``` Write your implementation and ensure it passes all test cases provided.","solution":"from typing import List, Callable def binary_search(arr: List[int], target: int, comparator: Callable[[int, int], int] = None) -> int: Implementation of Binary Search Algorithm with optional custom comparator. if not comparator: comparator = lambda a, b: a - b left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 comparison = comparator(arr[mid], target) if comparison == 0: return mid elif comparison < 0: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Context As a software engineer for a financial technology company, you need to develop functions to process currency conversions and manage multiple exchange rates. You will implement functions to convert an amount from one currency to another and to find the best conversion rate among a set of offered rates. Requirements Write two functions, `convert_currency` and `best_conversion_rate`, based on the following specifications: # Function 1: convert_currency **Input**: - `amount`: A float representing the amount to be converted. - `current_currency`: A string representing the current currency code (e.g., \\"USD\\"). - `target_currency`: A string representing the target currency code (e.g., \\"EUR\\"). - `exchange_rate`: A float representing the exchange rate from the current currency to the target currency. **Output**: - Returns a float representing the converted amount in the target currency. **Constraints**: - `amount` must be a positive float. - Raise a `ValueError` with the message `\\"amount must be a positive float.\\"` if `amount` is not positive. - `current_currency` and `target_currency` must be valid ISO 4217 currency codes. - Raise a `ValueError` with the message `\\"Invalid currency code.\\"` if either code is invalid. - `exchange_rate` must be a positive float. - Raise a `ValueError` with the message `\\"exchange_rate must be a positive float.\\"` if `exchange_rate` is not positive. # Function 2: best_conversion_rate **Input**: - `exchange_rates`: A list of tuples, each containing a pair of currency codes and the corresponding exchange rate (e.g., [(\\"USD\\", \\"EUR\\", 0.85), (\\"USD\\", \\"JPY\\", 110.0)]). **Output**: - Returns a tuple containing the pair of currency codes and the best exchange rate among the provided rates. **Constraints**: - `exchange_rates` must be a non-empty list. - Raise a `ValueError` with the message `\\"exchange_rates must be a non-empty list.\\"` if `exchange_rates` is empty. - Each exchange rate must be a positive float. - Raise a `ValueError` with the message `\\"Each exchange rate must be a positive float.\\"` if any rate is not positive. - Each currency code pair must be valid ISO 4217 codes. - Raise a `ValueError` with the message `\\"Invalid currency code.\\"` if any code is invalid. Example Usage ```python assert convert_currency(100, \\"USD\\", \\"EUR\\", 0.85) == 85.0 assert convert_currency(50, \\"USD\\", \\"JPY\\", 110.0) == 5500.0 assert best_conversion_rate([(\\"USD\\", \\"EUR\\", 0.85), (\\"USD\\", \\"JPY\\", 110.0)]) == (\\"USD\\", \\"JPY\\", 110.0) assert best_conversion_rate([(\\"EUR\\", \\"GBP\\", 0.75), (\\"USD\\", \\"EUR\\", 0.85)]) == (\\"USD\\", \\"EUR\\", 0.85) ``` Make sure to handle edge cases and validate inputs as specified.","solution":"import re CURRENCY_CODE_REGEX = re.compile(r\\"^[A-Z]{3}\\") def convert_currency(amount, current_currency, target_currency, exchange_rate): Converts amount from current_currency to target_currency using the exchange_rate. :param amount: float, amount to be converted, must be positive :param current_currency: str, current currency code, must be a valid ISO 4217 code :param target_currency: str, target currency code, must be a valid ISO 4217 code :param exchange_rate: float, exchange rate from current_currency to target_currency, must be positive :return: float, converted amount in target_currency if amount <= 0: raise ValueError(\\"amount must be a positive float.\\") if not CURRENCY_CODE_REGEX.match(current_currency): raise ValueError(\\"Invalid currency code.\\") if not CURRENCY_CODE_REGEX.match(target_currency): raise ValueError(\\"Invalid currency code.\\") if exchange_rate <= 0: raise ValueError(\\"exchange_rate must be a positive float.\\") return amount * exchange_rate def best_conversion_rate(exchange_rates): Finds the best exchange rate among the provided exchange rates. :param exchange_rates: list of tuples, each containing a pair of currency codes and the exchange rate :return: tuple, containing the pair of currency codes and the best exchange rate if not exchange_rates: raise ValueError(\\"exchange_rates must be a non-empty list.\\") best_rate = None best_pair = None for current_currency, target_currency, rate in exchange_rates: if not CURRENCY_CODE_REGEX.match(current_currency) or not CURRENCY_CODE_REGEX.match(target_currency): raise ValueError(\\"Invalid currency code.\\") if rate <= 0: raise ValueError(\\"Each exchange rate must be a positive float.\\") if best_rate is None or rate > best_rate: best_rate = rate best_pair = (current_currency, target_currency, rate) return best_pair"},{"question":"# Question You are given a list of string dates in the format \\"DD/MM/YYYY\\". Your task is to implement a function that sorts these dates in non-decreasing order. You must write your own function to parse and compare the dates without using Python\'s built-in date sorting utilities. Function Signature ```python def sort_dates(dates: list[str]) -> list[str]: pass ``` Input * dates: a list of strings where each string is a date in the format \\"DD/MM/YYYY\\". The length of the list, 0 ≤ len(dates) ≤ 10^5. Output * A list of strings with the dates sorted in non-decreasing order. Constraints * You cannot use any built-in functions for directly sorting date strings (like Python\'s `datetime` module). * Your solution should handle a large number of dates efficiently. Example ```python assert sort_dates([\\"12/05/2019\\", \\"01/11/2020\\", \\"25/12/2018\\", \\"01/11/2018\\"]) == [\\"01/11/2018\\", \\"25/12/2018\\", \\"12/05/2019\\", \\"01/11/2020\\"] assert sort_dates([\\"31/12/2020\\", \\"01/01/2020\\", \\"15/07/2020\\"]) == [\\"01/01/2020\\", \\"15/07/2020\\", \\"31/12/2020\\"] assert sort_dates([]) == [] ``` Explanation In this task, you need to sort a list of dates represented as strings. The sorting should be done in a non-decreasing manner, considering the day, month, and year parts of each date. You must devise a method to compare the dates as strings correctly, ensuring the sorting respects logical date order rather than lexicographical string order.","solution":"def sort_dates(dates: list[str]) -> list[str]: def date_key(date_str: str): day, month, year = map(int, date_str.split(\'/\')) return (year, month, day) return sorted(dates, key=date_key)"},{"question":"**String Permutations without Recursion** In this exercise, you are required to generate all permutations of a given string without using recursion. You will utilize an iterative approach to ensure efficiency and avoid recursion depth limits associated with deep recursion. # Function Signature ```python def iterative_permutations(s: str) -> List[str]: pass ``` # Input * `s` (str): A string for which permutations are to be generated. # Output * **Returns** (List[str]): A list of all permutations of the input string. # Constraints * The function should handle strings with up to `8` characters. * The permutations should be generated efficiently without using recursion. * All characters in the provided string are unique. # Examples ```python >>> iterative_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> iterative_permutations(\\"a\\") [\'a\'] >>> iterative_permutations(\\"\\") [\'\'] >>> iterative_permutations(\\"ab\\") [\'ab\', \'ba\'] ``` # Guidelines 1. **Iterative Approach**: Implement a method to generate permutations using loops instead of recursion. 2. **Efficiency**: Ensure your implementation is efficient even for strings at the higher end of the constraint limit. **Tasks**: 1. Implement the `iterative_permutations` function to generate all permutations of the provided string without using recursion. 2. Ensure your solution handles edge cases such as empty strings and single-character strings gracefully and efficiently.","solution":"from typing import List def iterative_permutations(s: str) -> List[str]: Generate all permutations of the input string using an iterative approach. Parameters: s (str): The input string for which permutations are to be generated. Returns: List[str]: A list of all permutations of the input string. # Handle special case for empty string if not s: return [\'\'] # Initialize a list with the first character of the string permutations = [s[0]] # Iterate over the string characters starting from the second character for char in s[1:]: new_permutations = [] # Generate new permutations by inserting the character into every possible position for perm in permutations: for i in range(len(perm) + 1): new_permutations.append(perm[:i] + char + perm[i:]) permutations = new_permutations return permutations"},{"question":"**Dijkstra\'s Algorithm for Shortest Path** # Background: Dijkstra\'s algorithm is a well-known algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. The algorithm helps in finding the shortest path from a source vertex to all other vertices in the graph. # Problem Statement: You are required to implement a function that applies Dijkstra\'s algorithm to find the shortest path from a given starting vertex to a target vertex in a graph. The function will return the length of the shortest path and the path itself as a list of vertices. # Function Signature: ```python def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, target: int) -> Tuple[int, List[int]]: :param graph: A dictionary where the keys are vertex identifiers and the values are lists of tuples. Each tuple represents a neighboring vertex and the weight of the edge to that neighbor. :param start: The starting vertex identifier. :param target: The target vertex identifier. :return: A tuple where the first element is the length of the shortest path, and the second element is the list of vertices in the shortest path from start to target. # Example Graph Representation: Consider a graph represented as: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } ``` In this representation: - There is a vertex 0 connected to vertex 1 with an edge of weight 4, and to vertex 2 with an edge of weight 1. - Vertex 1 is connected to vertex 3 with an edge of weight 1. - Vertex 2 is connected to vertex 1 with an edge of weight 2, and to vertex 3 with an edge of weight 5. - Vertex 3 has no outgoing edges. # Requirements: 1. Implement the `dijkstra` function that: - Uses a priority queue to efficiently retrieve the next vertex with the current shortest path estimate. - Keeps track of the shortest path estimates from the start vertex to all other vertices. - Reconstructs the shortest path from the start vertex to the target vertex, using parent pointers (or similar) to track the path. 2. Ensure that your solution handles graphs with cycles and different edge weights properly. # Constraints: - The number of vertices (`n`) and the number of edges (`m`) in the graph will satisfy 1 ≤ n, m ≤ 1000. - The graph is represented as an adjacency list. - All edge weights are non-negative integers. # Example: ```python shortest_distance, shortest_path = dijkstra(graph, start=0, target=3) print(shortest_distance) # Output: 4 print(shortest_path) # Output: [0, 2, 1, 3] ``` This function should find the shortest path from vertex `0` to vertex `3` in the given graph, and return the total distance of the shortest path and the sequence of vertices in that path. # Note: * Ensure your solution is efficient and can handle graphs up to the given constraints. * Consider edge cases such as disconnected graphs where a path might not exist between the start and target vertices.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int, target: int) -> Tuple[int, List[int]]: Uses Dijkstra\'s algorithm to find the shortest path from start to target in a weighted graph. :param graph: A dictionary where the keys are vertex identifiers and the values are lists of tuples. Each tuple represents a neighboring vertex and the weight of the edge to that neighbor. :param start: The starting vertex identifier. :param target: The target vertex identifier. :return: A tuple where the first element is the length of the shortest path, and the second element is the list of vertices in the shortest path from start to target. # Priority queue: stores (distance, vertex) tuples pq = [(0, start)] # Dictionary to store the shortest distance to each vertex distances = {vertex: float(\'infinity\') for vertex in graph} distances[start] = 0 # Dictionary to store the path to reconstruct the shortest path parent = {vertex: None for vertex in graph} while pq: current_distance, current_vertex = heapq.heappop(pq) # If we reached the target, we can reconstruct the path if current_vertex == target: path = [] while current_vertex is not None: path.append(current_vertex) current_vertex = parent[current_vertex] path.reverse() return current_distance, path # Skip if a better path to current_vertex was already found if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance parent[neighbor] = current_vertex heapq.heappush(pq, (distance, neighbor)) # If the target was not reached, return infinity distance and empty path return float(\'infinity\'), []"},{"question":"# Implementing Dijkstra\'s Algorithm **Context:** You are provided a graph with \'n\' vertices and \'m\' edges, along with a starting vertex \'s\'. Your task is to implement Dijkstra\'s algorithm to find the shortest path from the starting vertex to all other vertices in the graph. **Function Signature:** ```python def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: ``` **Input:** * `n`: An integer representing the number of vertices (1 <= n <= 10^5). * `edges`: A list of tuples, where each tuple (u, v, w) represents a directed edge from vertex u to vertex v with weight w. * `s`: An integer representing the starting vertex (0 <= s < n). **Output:** * A list of integers where the i-th element represents the shortest distance from the starting vertex `s` to vertex `i`. If a vertex is unreachable from the starting vertex, the distance should be set to infinity (`float(\'inf\')`). **Constraints:** * 1 <= m <= 2*10^5 * The vertices are zero-indexed. * Edge weights are positive integers. **Performance Requirements:** * The solution must be efficient both in terms of time and space to handle the upper constraint limits. **Example:** ```python # Example 1 n = 5 edges = [(0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2), (3, 2, 6), (2, 3, 4)] s = 0 dijkstra(n, edges, s) # Output: [0, 8, 9, 7, 5] # Example 2 n = 3 edges = [(0, 1, 1), (1, 2, 2), (0, 2, 4)] s = 0 dijkstra(n, edges, s) # Output: [0, 1, 3] ``` **Assignment:** Implement the `dijkstra` function to find the shortest paths from the starting vertex using Dijkstra\'s algorithm based on the provided signature. **Evaluation Criteria:** * Correctness and Efficiency of the solution. * Handling of edge cases. * Clarity and readability of the implemented code.","solution":"from typing import List, Tuple import heapq def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest path from vertex s to all other vertices. # Create adjacency list graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Distance array, initialize all distances as infinity dist = [float(\'inf\')] * n dist[s] = 0 # Min-heap priority queue to get the vertex with the smallest distance heap = [(0, s)] # (distance, vertex) while heap: current_dist, u = heapq.heappop(heap) # If the popped vertex has a distance greater than the already found smallest distance, # it means we have processed this vertex before with a smaller distance if current_dist > dist[u]: continue # Process each neighbor of current vertex for v, weight in graph[u]: distance = current_dist + weight # If found a shorter path to vertex v, update its distance and push into the heap if distance < dist[v]: dist[v] = distance heapq.heappush(heap, (distance, v)) return dist"},{"question":"# Problem Description Write a function that calculates the minimum number of swaps required to sort an array of integers in ascending order. Each swap consists of exchanging the positions of two elements in the array. You must use the Cycle Decomposition method to achieve the optimal solution. # Function Definition Define the function `minimum_swaps(arr: List[int]) -> int` that takes a list of integers `arr` and returns the minimum number of swaps needed to sort the array. # Input * `arr` (List[int]): An array of integers. # Output * `int`: The minimum number of swaps required to sort the array in ascending order. # Constraints * `1 <= len(arr) <= 10^5` * `1 <= arr[i] <= 10^5` # Examples Example 1: **Input**: ```python arr = [4, 3, 2, 1] ``` **Output**: ```python 2 ``` **Explanation**: 1. Swap 4 and 1 -> [1, 3, 2, 4] 2. Swap 3 and 2 -> [1, 2, 3, 4] Example 2: **Input**: ```python arr = [1, 5, 4, 3, 2] ``` **Output**: ```python 2 ``` **Explanation**: 1. Swap 5 and 2 -> [1, 2, 4, 3, 5] 2. Swap 4 and 3 -> [1, 2, 3, 4, 5] # Notes - The function should aim for an optimal solution, such as Cycle Decomposition, to minimize the number of swaps. Implementation Details You can assume that the input list will have unique values, and the values will be within a reasonable range for the problem scope. Use helper functions as needed to break down the problem and ensure clarity in your solution. **Please provide your implementation below:**","solution":"from typing import List def minimum_swaps(arr: List[int]) -> int: Returns the minimum number of swaps required to sort the array in ascending order using the Cycle Decomposition method. n = len(arr) arr_pos = [(value, index) for index, value in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = {k: False for k in range(n)} swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 x = i while not visited[x]: visited[x] = True x = arr_pos[x][1] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"# Problem Statement You are tasked with implementing a function to manage a limited capacity cache using the Least Frequently Used (LFU) replacement policy. The cache should store key-value pairs and remove the least frequently accessed items when it reaches its capacity. # Classes and Methods to Implement 1. `class LFUCache`: - `__init__(self, capacity: int) -> None` - `get(self, key: int) -> int` - `put(self, key: int, value: int) -> None` Requirements * **LFUCache**: - **Attributes**: * `capacity` (int): Limits the number of items the cache can hold. * `cache` (Dict[int, int]): Stores the key-value pairs. * `frequency` (Dict[int, int]): Stores the frequency count of each key. * `min_freq` (int): Tracks the minimum frequency of the keys in the cache. - **Methods**: - `__init__(self, capacity: int) -> None`: - Initializes the LFUCache with the specified capacity. - `get(self, key: int) -> int`: - Returns the value of the key if it exists in the cache, otherwise returns -1. - Updates the frequency count of the key if it is found. - `put(self, key: int, value: int) -> None`: - Inserts the key-value pair into the cache. - If the cache is full, it removes the least frequently used key. - Updates the frequency count appropriately. Constraints - Both `get` and `put` must run in O(1) average time complexity. - The cache capacity will be a non-negative integer. Example ```python def test_lfu_cache(): cache = LFUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 since it is least frequently used assert cache.get(2) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 test_lfu_cache() ``` **Note**: Ensure that the `get` and `put` methods are implemented such that they adhere to the O(1) average time complexity requirement and manage the cache eviction policy as specified.","solution":"class LFUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.frequency = {} self.freq_list = {} self.min_freq = 1 def get(self, key: int) -> int: if key not in self.cache: return -1 value = self.cache[key] self._update_freq(key) return value def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.cache: self.cache[key] = value self._update_freq(key) else: if len(self.cache) >= self.capacity: self._evict() self.cache[key] = value self.frequency[key] = 1 if 1 not in self.freq_list: self.freq_list[1] = set() self.freq_list[1].add(key) self.min_freq = 1 def _update_freq(self, key: int) -> None: freq = self.frequency[key] self.frequency[key] += 1 self.freq_list[freq].remove(key) if not self.freq_list[freq]: del self.freq_list[freq] if self.min_freq == freq: self.min_freq += 1 new_freq = freq + 1 if new_freq not in self.freq_list: self.freq_list[new_freq] = set() self.freq_list[new_freq].add(key) def _evict(self) -> None: keys_to_evict = self.freq_list[self.min_freq] evict_key = keys_to_evict.pop() if not keys_to_evict: del self.freq_list[self.min_freq] del self.cache[evict_key] del self.frequency[evict_key]"},{"question":"# Problem Statement Given a list of words, you are tasked with creating an acronym for each word. An acronym is formed by taking the first letter of each word in a word list and converting it to uppercase. Write a function `create_acronyms(word_lists: List[List[str]]) -> List[str]` that takes a list of lists, where each sublist represents a series of words, and returns a list of strings where each string is the acronym for the corresponding sublist in the input. Input * A list `word_lists` of `m` sublists, where each sublist contains `k` words (`1 ≤ m, k ≤ 10^3`). Each word consists of lowercase letters only and has a length between `1` and `20`. Output * A list `acronyms` of `m` strings, where each string is the acronym formed from the words in the corresponding sublist of `word_lists`. Example ``` Input: word_lists = [[\\"national\\", \\"aeronautics\\", \\"space\\", \\"administration\\"], [\\"portable\\", \\"network\\", \\"graphics\\"], [\\"central\\", \\"processing\\", \\"unit\\"], [\\"random\\", \\"access\\", \\"memory\\"]] Output: [\\"NASA\\", \\"PNG\\", \\"CPU\\", \\"RAM\\"] ``` In this example: - The acronym for `[\\"national\\", \\"aeronautics\\", \\"space\\", \\"administration\\"]` is \\"NASA\\". - The acronym for `[\\"portable\\", \\"network\\", \\"graphics\\"]` is \\"PNG\\". - The acronym for `[\\"central\\", \\"processing\\", \\"unit\\"]` is \\"CPU\\". - The acronym for `[\\"random\\", \\"access\\", \\"memory\\"]` is \\"RAM\\". Constraints * Ensure that each acronym is formed correctly and that the function completes in a reasonably efficient manner given the constraints. Implement the function `create_acronyms(word_lists: List[List[str]]) -> List[str]` that adheres to these requirements.","solution":"from typing import List def create_acronyms(word_lists: List[List[str]]) -> List[str]: Given a list of lists where each sublist is a series of words, this function returns a list of strings where each string is the acronym formed by the first letter of each word in the corresponding sublist. acronyms = [] for words in word_lists: acronym = \\"\\".join(word[0].upper() for word in words) acronyms.append(acronym) return acronyms"},{"question":"# Matrix Transposition You are tasked to perform mathematical transformations on matrices, specifically, to transpose a given matrix. Transposing a matrix involves flipping the matrix over its diagonal, switching the row and column indices of the matrix. Objective Write a function `transpose` that takes a 2D list of integers representing a matrix and returns its transpose. Function Signature ```python def transpose(matrix: List[List[int]]) -> List[List[int]]: ``` # Input - An `m x n` matrix represented as a list of lists, where each inner list has `n` integers. # Output - An `n x m` matrix represented as a list of lists, which is the transpose of the input matrix. # Constraints - `1 <= m, n <= 10^3` - `-10^9 <= matrix[i][j] <= 10^9` for all valid indices `i` and `j`. # Examples ```python assert transpose([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] assert transpose([[7, 8], [9, 10], [11, 12]]) == [[7, 9, 11], [8, 10, 12]] assert transpose([[1]]) == [[1]] assert transpose([[0, 0], [0, 0], [0, 0]]) == [[0, 0, 0], [0, 0, 0]] ``` **Explanation**: 1. For the first example, the original matrix `[[1, 2, 3], [4, 5, 6]]` transposes to `[[1, 4], [2, 5], [3, 6]]`. 2. For the second example, the original matrix `[[7, 8], [9, 10], [11, 12]]` transposes to `[[7, 9, 11], [8, 10, 12]]`. # Requirements - Ensure your implementation handles large matrices efficiently. - Consider and handle edge cases such as matrices with only one element or matrices with zero values. # Note - Transposition should exchange rows with columns. - Ensure your code is optimized for performance, especially for the upper constraint limits.","solution":"from typing import List def transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. if not matrix or not matrix[0]: return [] rows = len(matrix) cols = len(matrix[0]) # Create a new matrix with transposed dimensions transposed = [[0] * rows for _ in range(cols)] # Fill the transposed matrix for i in range(rows): for j in range(cols): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Sorting Nearly Sorted Array Context A nearly sorted or K-sorted array is an array where every element is at most `k` positions away from its target position. A common example of this would be an array that has been sorted, but then each element is allowed to be moved up to `k` positions away from its sorted position. Problem Statement You are required to implement a function `sort_k_sorted_array` that sorts a nearly sorted array. The function should use a min-heap to achieve an efficient sorting process. Function Signature ```python def sort_k_sorted_array(arr: List[int], k: int) -> List[int]: pass ``` Parameters - `arr` (List[int]): A list of integers representing the nearly sorted array. - `k` (int): A non-negative integer representing how far each element might be from its sorted position. Returns - List[int]: A list of integers representing the sorted array. Constraints - The function should handle arrays of various sizes, including edge cases such as empty arrays. - Ensure the input `k` is valid for the given array constraints. Examples ```python >>> sort_k_sorted_array([3, 2, 6, 5, 4], 2) [2, 3, 4, 5, 6] >>> sort_k_sorted_array([10, 9, 8, 7, 4], 3) [4, 7, 8, 9, 10] >>> sort_k_sorted_array([1, 4, 3, 2], 1) [1, 2, 3, 4] >>> sort_k_sorted_array([], 3) [] ``` Notes - Utilize a min-heap for an efficient sorting approach. - Consider the implications of larger values of `k` and ensure the algorithm performs efficiently for these cases. - Validate that `k` is appropriate for array length, i.e., it should not be greater than the length of the array.","solution":"from typing import List import heapq def sort_k_sorted_array(arr: List[int], k: int) -> List[int]: Sorts a nearly sorted array where each element is at most k positions away from its target position. Parameters: arr (List[int]): The nearly sorted array. k (int): Maximum distance from the target position. Returns: List[int]: The sorted array. if not arr or k == 0: return arr min_heap = [] result = [] for i in range(k + 1): if i < len(arr): heapq.heappush(min_heap, arr[i]) for i in range(k + 1, len(arr)): heapq.heappush(min_heap, arr[i]) result.append(heapq.heappop(min_heap)) while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"# Array Manipulation and Segregation Context Array manipulation and segregation problems are common in programming assessments. They test one\'s ability to perform in-place modifications and handle different conditions efficiently. Such problems often involve organizing data under certain rules or constraints. Task Given an array of integers, write a function that segregates even and odd numbers, such that all even numbers appear before all odd numbers. The relative order of the even and odd numbers within their respective groups should be the same as in the original array. Function Signature ```python def segregate_even_odd(arr: list[int]) -> list[int]: Segregates even and odd numbers in an array such that all even numbers come before all odd numbers and the relative order of the numbers within their groups is preserved. :param arr: List of integers to be segregated :return: New list with even numbers before odd numbers, maintaining relative order Constraints: - The length of the input list will be at most 1000. - All integers will be in the range of [-100000, 100000]. ``` Explanation **Input:** - A list of integers `arr`. **Output:** - A new list with all even numbers before all odd numbers, preserving their relative order from the original list. **Example:** ```python assert segregate_even_odd([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5] assert segregate_even_odd([12, 34, 45, 9, 8, 90, 3]) == [12, 34, 8, 90, 45, 9, 3] assert segregate_even_odd([0, 1, 2, -3, -4, 5]) == [0, 2, -4, 1, -3, 5] assert segregate_even_odd([]) == [] ``` Constraints - The function should handle arrays containing up to 1000 elements efficiently. - The input list is guaranteed not to be `None`. Hints - Use two lists to separately collect even and odd numbers and then concatenate them. - Another approach can be to use a single list and rearrange elements in place using additional space constraints.","solution":"def segregate_even_odd(arr: list[int]) -> list[int]: Segregates even and odd numbers in an array such that all even numbers come before all odd numbers and the relative order of the numbers within their groups is preserved. :param arr: List of integers to be segregated :return: New list with even numbers before odd numbers, maintaining relative order evens = [num for num in arr if num % 2 == 0] odds = [num for num in arr if num % 2 != 0] return evens + odds"},{"question":"# Background The Knuth-Morris-Pratt (KMP) algorithm is an efficient string matching algorithm that finds occurrences of a pattern within a text. It preprocesses the pattern by creating a longest prefix suffix (LPS) array that helps in avoiding unnecessary comparisons during the search phase. # Problem Statement Write a function `kmp_search(pattern: str, text: str) -> List[int]` that implements the KMP algorithm to find all occurrences of a pattern string within a given text string. Return a list of starting indices where the pattern is found in the text. # Input - `pattern`: A string representing the pattern to be searched. - `text`: A string representing the text in which the pattern is to be searched. # Output - A list of integers representing the starting indices of each occurrence of the pattern in the text. # Constraints - The pattern and text should be non-empty strings. - The pattern length should be less than or equal to the text length. # Example ```python pattern = \\"abc\\" text = \\"ababcabc\\" result = kmp_search(pattern, text) print(result) # Output should be [2, 5] ``` # Notes - Implement the construction of the LPS array in a helper function. - Handle edge cases where the pattern is not found in the text. # Hints - Focus on understanding how the LPS array is built and how it is used to skip unnecessary comparisons. - Make sure to iterate through both the pattern and the text efficiently using the precomputed LPS array.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array used in the KMP algorithm. LPS array is the longest proper prefix which is also a suffix. lps = [0] * len(pattern) length = 0 # Length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(pattern: str, text: str) -> List[int]: Implements the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of a pattern in a text. if not pattern or not text: return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Problem Description You are working on developing functionality for a basic e-commerce platform. One of the critical features is constructing a receipt given the items purchased and their categories. Each category has a specific discount percentage that should be applied to the total cost of items in that category. Your goal is to write a function that calculates the total cost after applying necessary discounts and generates a detailed receipt. # Function to Implement Write a Python function `generate_receipt(items: List[Tuple[str, float, str]], discounts: Dict[str, float]) -> str:` that: 1. Processes a list of items where each item is represented by a tuple `(item_name, price, category)`. 2. Applies the discount to each category as specified in the `discounts` dictionary. 3. Calculates the total cost after discounts. 4. Constructs a receipt string listing each item with its final price after discount and the grand total at the end. # Example ```python from typing import List, Tuple, Dict def generate_receipt(items: List[Tuple[str, float, str]], discounts: Dict[str, float]) -> str: # Your implementation here # Example Usage items = [(\\"Laptop\\", 1000, \\"Electronics\\"), (\\"T-shirt\\", 20, \\"Clothing\\"), (\\"Headphones\\", 200, \\"Electronics\\")] discounts = {\\"Electronics\\": 10, \\"Clothing\\": 5} print(generate_receipt(items, discounts)) # Expected Output: # \\"Item: Laptop, Final Price: 900.00nItem: T-shirt, Final Price: 19.00nItem: Headphones, Final Price: 180.00nTotal: 1099.00\\" ``` # Input * `items`: A list of tuples where each tuple contains: * `item_name` (str): The name of the item. * `price` (float): The price of the item before discount. * `category` (str): The category of the item. * `discounts`: A dictionary where the key is the category (str) and the value is the discount percentage (float). # Output * A string representing the receipt, with each item listed in the format: * \\"Item: {item_name}, Final Price: {final_price}\\" * The final price should be rounded to two decimal places after applying the discount. * At the end, include a line for the total cost: * \\"Total: {total_cost}\\" # Constraints * Use basic arithmetic to apply discounts. * Consider edge cases such as items with no applicable discount or empty input lists. * Ensure the calculation is efficient and accurate to two decimal places.","solution":"from typing import List, Tuple, Dict def generate_receipt(items: List[Tuple[str, float, str]], discounts: Dict[str, float]) -> str: receipt_lines = [] total_cost = 0.0 for item_name, price, category in items: discount = discounts.get(category, 0) final_price = price * (1 - discount / 100) receipt_lines.append(f\\"Item: {item_name}, Final Price: {final_price:.2f}\\") total_cost += final_price receipt_lines.append(f\\"Total: {total_cost:.2f}\\") return \'n\'.join(receipt_lines)"},{"question":"# Question Statement Implement a Two Sum Solution Using Hash Map In this exercise, you need to implement a function that finds indices of two numbers in a list such that they add up to a specific target. You should use a hash map (dictionary) to achieve an efficient solution. # Function Signature ```python def two_sum(nums: list[int], target: int) -> list[int]: pass ``` # Input - A list of integers `nums` (0 <= len(nums) <= 10^4). - A single integer `target`. # Output - A list containing exactly two integers which are the indices of the two numbers in `nums` that add up to the `target`. # Constraints - Each input would have exactly one solution. - You may not use the same element twice. - Indices returned should be in any order. # Example - `two_sum([2, 7, 11, 15], 9)` should return `[0, 1]` because `nums[0] + nums[1]` equals `9`. - `two_sum([3, 2, 4], 6)` should return `[1, 2]` because `nums[1] + nums[2]` equals `6`. - `two_sum([3, 3], 6)` should return `[0, 1]` because `nums[0] + nums[1]` equals `6`. # Explanation Your implementation should: 1. Initialize an empty hash map to store the value and its index. 2. Iterate through the list, checking if the complement `target - nums[i]` exists in the hash map. 3. If it exists, return the current index and the stored index from the hash map. 4. Otherwise, store the current value and its index in the hash map and continue. # Testing The function should handle edge cases, such as: - List with two elements. - All elements in the list being the same. - Large input size with the solution located at the ends of the list. - Negative and zero values where applicable.","solution":"def two_sum(nums: list[int], target: int) -> list[int]: Returns the indices of two numbers in the list `nums` that add up to the target value `target`. num_map = {} # Value to index dictionary for i, num in enumerate(nums): complement = target - num if complement in num_map: return [num_map[complement], i] num_map[num] = i"},{"question":"# Binary Search Tree (BST): Operations Analysis **Scenario**: You are given a binary search tree (BST) containing integer values. Your task is to implement a set of functions to perform various operations on the BST, including insertion, deletion, search, and finding the minimum and maximum values. **Function Specifications**: Function 1: `insert_into_bst(root: TreeNode, val: int) -> TreeNode` 1. **Input**: * `root` (TreeNode): The root node of the BST. * `val` (int): The integer value to be inserted into the BST. 2. **Output**: * Returns the root node of the BST after insertion. Function 2: `delete_from_bst(root: TreeNode, val: int) -> TreeNode` 1. **Input**: * Same as Function 1. 2. **Output**: * Returns the root node of the BST after deletion. Function 3: `search_bst(root: TreeNode, val: int) -> bool` 1. **Input**: * Same as Function 1. 2. **Output**: * Returns `True` if the value exists in the BST, otherwise `False`. Function 4: `find_min(root: TreeNode) -> int` 1. **Input**: * `root` (TreeNode): The root node of the BST. 2. **Output**: * Returns the minimum value in the BST. Function 5: `find_max(root: TreeNode) -> int` 1. **Input**: * Same as Function 4. 2. **Output**: * Returns the maximum value in the BST. **Tasks**: 1. Implement the five functions as specified. Verify the correctness of each through test cases. 2. Analyze the time and space complexity of each function. 3. Ensure the BST properties are maintained after each insert and delete operation. **Constraints**: * The values in the BST nodes are unique integers. * The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Performance Requirements**: * Verify that all operations are within O(log n) time complexity for a balanced BST. ```python # You may utilize the test cases provided in the following main function. def main(): # Create an initial BST root = TreeNode(10) root = insert_into_bst(root, 5) root = insert_into_bst(root, 15) root = insert_into_bst(root, 3) root = insert_into_bst(root, 7) root = insert_into_bst(root, 12) root = insert_into_bst(root, 18) # Test search operation assert search_bst(root, 7) == True assert search_bst(root, 20) == False # Test find minimum and maximum assert find_min(root) == 3 assert find_max(root) == 18 # Test delete operation and search again root = delete_from_bst(root, 5) assert search_bst(root, 5) == False print(\\"All test cases passed!\\") if __name__ == \\"__main__\\": main() ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root def delete_from_bst(root, val): if root is None: return root if val < root.val: root.left = delete_from_bst(root.left, val) elif val > root.val: root.right = delete_from_bst(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left min_larger_node = get_min(root.right) root.val = min_larger_node.val root.right = delete_from_bst(root.right, root.val) return root def search_bst(root, val): if root is None: return False if root.val == val: return True elif val < root.val: return search_bst(root.left, val) else: return search_bst(root.right, val) def find_min(root): current = root while current.left is not None: current = current.left return current.val def find_max(root): current = root while current.right is not None: current = current.right return current.val def get_min(node): current = node while current.left is not None: current = current.left return current"},{"question":"Question: Restore Original Array from Differences # Background You are tasked with developing capabilities for data restoration and transformation. One of your first assignments is to reconstruct an original array of integers given the differences between consecutive elements. This task will help enhance the library\'s functionality for working with numeric data and sequences. # Task Write a Python function that reconstructs the original array from an array of differences between consecutive elements. # Specifications 1. **Method Definition**: - Implement the method `def restore_array(diffs: List[int], first: int) -> List[int]`: - `diffs`: a list of integers where `diffs[i]` represents the difference between element `i+1` and element `i` in the original array. - `first`: the first element of the original array. 2. **Reconstruction Logic**: - Use the differences and the first element to reconstruct the original array. # Requirements - **Input**: - A list `diffs` of `n` integers where `1 <= n <= 10,000`. - An integer `first` representing the first element of the original array. Constraints: `-10^4 <= first <= 10^4`. - **Output**: - Return a list of integers representing the reconstructed original array. # Example ```python def restore_array(diffs, first): arr = [first] for diff in diffs: arr.append(arr[-1] + diff) return arr # Example usage: print(restore_array([1, 2, -1, 2], 3)) # Output: [3, 4, 6, 5, 7] print(restore_array([-3, 3, 1], 0)) # Output: [0, -3, 0, 1] ``` # Evaluation - Ensure your code runs efficiently for the upper limits of the input constraints. - Correctly reconstruct the original array for all types of input differences. - Handle edge cases, including negative differences and starting values. This question requires understanding of basic arithmetic operations and list manipulations and is designed to test your ability to work with sequences and iterative logic.","solution":"from typing import List def restore_array(diffs: List[int], first: int) -> List[int]: Reconstructs the original array from the given differences between consecutive elements and the first element of the original array. Parameters: diffs (List[int]): A list of differences between consecutive elements. first (int): The first element of the original array. Returns: List[int]: The reconstructed original array. # Initialize the original array with the first element arr = [first] # Iterate over the differences to reconstruct the original array for diff in diffs: # The next element is the last element plus the current difference arr.append(arr[-1] + diff) return arr"},{"question":"# Question You are implementing a unique variant of the binary search algorithm called the \\"Ternary Search\\". This algorithm works on a sorted array and divides the search interval into three parts instead of two. Implement a function to perform a ternary search and determine the position of a target integer within a sorted array. Function Signature ```python def ternary_search(arr: list, target: int) -> int: pass ``` Requirements 1. **Input**: - `arr`: A list of sorted integers. - `target`: An integer representing the value to search for in the list. 2. **Output**: - Return an integer representing the index of the `target` in the list if present; otherwise, return `-1`. 3. **Constraints**: - The length of `arr` is at least 1. 4. **Performance**: - Aim for a solution that runs in (O(log_3 n)) time complexity, where (n) is the length of the list. Examples ```python # Example 1: # Search for 5 in the list [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> ternary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) Output: 4 # Example 2: # Search for 1 in the list [1, 3, 5, 7, 9, 11, 13] >>> ternary_search([1, 3, 5, 7, 9, 11, 13], 1) Output: 0 # Example 3: # Search for 14 in the list [2, 4, 6, 8, 10] >>> ternary_search([2, 4, 6, 8, 10], 14) Output: -1 ``` Notes * Your implementation should handle edge cases such as an empty array or a target value that is not present in the list. * Ensure that the division of the search interval is done such that it covers all possible index positions within the array.","solution":"def ternary_search(arr: list, target: int) -> int: def search(left: int, right: int) -> int: if left > right: return -1 one_third = left + (right - left) // 3 two_third = right - (right - left) // 3 if arr[one_third] == target: return one_third if arr[two_third] == target: return two_third if target < arr[one_third]: return search(left, one_third - 1) elif target > arr[two_third]: return search(two_third + 1, right) else: return search(one_third + 1, two_third - 1) return search(0, len(arr) - 1)"},{"question":"# Coding Assessment Question **Title**: Sorting Algorithm Optimization for Nearly Sorted Arrays **Objective**: You are tasked with optimizing a sorting function for nearly sorted arrays. Nearly sorted arrays are arrays where each element is at a position close to its target position in the sorted array. This optimization is crucial for applications where slight deviations from order can occur, such as time-sensitive data streams or real-time systems. **Task**: Implement the function `optimized_sort_nearly_sorted` that sorts nearly sorted arrays efficiently. Utilize an appropriate sorting algorithm that takes advantage of the near orderliness to minimize the time complexity. **Specifications**: 1. **Function Signature**: `def optimized_sort_nearly_sorted(arr: List[int], k: int) -> List[int]` 2. **Input**: * `arr`: List of integers, the nearly sorted array. * `k`: Integer, the maximum distance an element is away from its target position. 3. **Output**: * Returns a sorted list of integers. 4. **Constraints & Requirements**: * Ensure the algorithm is optimized for nearly sorted arrays. * Handle large arrays efficiently. 5. **Edge Cases**: * Consider empty arrays, arrays with one element, or arrays where elements are already sorted. **Example**: ```python arr = [3, 1, 2, 5, 4, 6] k = 2 assert optimized_sort_nearly_sorted(arr, k) == [1, 2, 3, 4, 5, 6] ``` ```python # Your implementation here ``` **Performance Requirements**: * The expected time complexity should be better than O(n log n) for nearly sorted arrays. * Ensure the correctness and efficiency of your implementation. **Context**: This function will be pivotal in systems where data arrives in a nearly sorted manner, and the need for quick reordering is essential to maintain optimal performance and data integrity.","solution":"import heapq from typing import List def optimized_sort_nearly_sorted(arr: List[int], k: int) -> List[int]: Sorts a nearly sorted array where each element is at most k positions away from its target position. Args: arr (List[int]): The nearly sorted array. k (int): The maximum distance any element is from its sorted position. Returns: List[int]: A sorted list of integers. if not arr: return [] # Initialize a min heap with the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) sorted_array = [] for i in range(k+1, len(arr)): # Extract the smallest element from the heap and add it to the result list smallest = heapq.heappop(min_heap) sorted_array.append(smallest) # Add the next element from the array to the heap heapq.heappush(min_heap, arr[i]) # Extract the remaining elements in the heap and add them to the result list while min_heap: sorted_array.append(heapq.heappop(min_heap)) return sorted_array"},{"question":"# Coding Assessment Question Objective Implement an algorithm to find all possible word break combinations of a given string using a given set of words. The function should explore all valid word break patterns. Problem Statement You are given a string `s` and a dictionary `wordDict` containing a list of non-empty words. Write a function: `wordBreakCombinations(s: str, wordDict: List[str]) -> List[str]`: - This function should return all possible ways to break the given string `s` by inserting spaces to form words present in `wordDict`. Input * `s`: A non-empty string consisting of lowercase English letters. * `wordDict`: A list of non-empty strings consisting of lowercase English letters (the dictionary). Output * A list of strings representing all possible word break combinations. If no combination is possible, return an empty list. Constraints * `1 <= len(s) <= 20` * `1 <= len(wordDict) <= 10` * `1 <= len(wordDict[i]) <= 10` * `All strings in `wordDict` are unique. Example Cases **Case 1: Multiple Combinations** Input: ```python s = \\"catsanddog\\" wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] ``` Output: ```python [\\"cat sand dog\\", \\"cats and dog\\"] ``` **Case 2: Single Combination** Input: ```python s = \\"pineapplepenapple\\" wordDict = [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"] ``` Output: ```python [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] ``` **Case 3: No Combination** Input: ```python s = \\"catsandog\\" wordDict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] ``` Output: ```python [] ``` Implementation Note * Consider using memoization to optimize the recursive solution. * Ensure to handle cases where the string cannot be segmented by any combination of words from the dictionary. This task will help assess your ability to implement efficient algorithms, work with recursion and memoization, and process string manipulation based on a dictionary look-up.","solution":"from typing import List def wordBreakCombinations(s: str, wordDict: List[str]) -> List[str]: word_set = set(wordDict) memo = {} def backtrack(start: int) -> List[str]: if start in memo: return memo[start] if start == len(s): return [\\"\\"] partitions = [] for end in range(start + 1, len(s) + 1): word = s[start:end] if word in word_set: for sub_partition in backtrack(end): if sub_partition: partitions.append(word + \\" \\" + sub_partition) else: partitions.append(word) memo[start] = partitions return partitions return backtrack(0)"},{"question":"# Question: **Context**: In competitive programming, a common task involves manipulating strings for faster computation during searches. One such technique is the construction of the Knuth-Morris-Pratt (KMP) algorithm\'s partial match (pi) table, which is used to speed up the search within a text. **Objective**: Implement a function `build_kmp_table` that takes a string pattern and returns the computed pi table array, which indicates the longest proper prefix which is also a suffix. **Function Signature**: ```python def build_kmp_table(pattern: str) -> List[int]: pass ``` # Input: * **pattern**: A string pattern for which the KMP pi table is to be computed. # Output: * Returns a list of integers representing the KMP pi table. # Constraints: * The input pattern can have a maximum length of 10^6. # Example: ```python pattern = \\"ababc\\" result = build_kmp_table(pattern) print(result) # Expected: [0, 0, 1, 2, 0] ``` # Notes: * The implementation should efficiently calculate the pi table in O(n) time complexity, where n is the length of the pattern. * The pi table helps to avoid redundant comparisons during the string search, effectively reducing the time complexity. * Strive to handle edge cases such as single-character patterns and patterns with repeated sequences gracefully.","solution":"from typing import List def build_kmp_table(pattern: str) -> List[int]: Computes the KMP (Knuth-Morris-Pratt) partial match table (pi table) for a given pattern. :param pattern: The pattern string for which the KMP table is to be computed. :return: The list of integers representing the KMP pi table. if not pattern: # Handle edge case for empty pattern return [] pi = [0] * len(pattern) j = 0 # Length of the previous longest prefix suffix for i in range(1, len(pattern)): while (j > 0) and (pattern[i] != pattern[j]): # Fallback to the last possible position j = pi[j - 1] # If characters match, increment the length of the current prefix suffix end if pattern[i] == pattern[j]: j += 1 pi[i] = j return pi"},{"question":"**Problem Statement**: You need to create a program to schedule tasks within a given time constraint. Each task has a specific duration and an associated profit. The goal is to maximize the total profit by selecting tasks that can fit within the provided time limit. Implement a function `maximize_task_profit` that takes a list of tasks (each represented by a tuple of duration and profit), and a time limit, and returns the maximum profit that can be achieved and the list of selected tasks. **Function Signature**: ```python def maximize_task_profit( tasks: list[tuple[int, int]], time_limit: int ) -> tuple[int, list[tuple[int, int]]]: ``` **Input**: * `tasks` (list of tuples): Each tuple contains two integers. The first integer represents the duration of the task, and the second integer represents the profit of the task. `(duration, profit)` * `time_limit` (int): The maximum allowable time to complete the chosen tasks. **Output**: * A tuple containing: - The maximum profit that can be achieved. - The list of tasks that were selected to achieve this profit, in the order they were considered. **Constraints**: * The duration and profit of tasks are positive integers. * The time limit is a positive integer. * The sum of durations of the selected tasks should not exceed the time limit. **Performance Requirements**: - The solution should aim for a polynomial time complexity, suitable for typical task scheduling problems. **Example**: ```python tasks = [(2, 100), (1, 50), (3, 70), (2, 40)] time_limit = 4 result = maximize_task_profit(tasks, time_limit) print(result) # Output: (150, [(2, 100), (1, 50)]) or (120, [(1, 50), (3, 70)] depending on algorithm) ``` **Detailed Steps**: 1. Implement a dynamic programming approach to solve the task selection problem. 2. Create a table `dp` where `dp[i]` represents the maximum profit achievable with a time limit `i`. 3. Iterate through the tasks and update the dp table accordingly. 4. Backtrack from the dp table to determine the list of selected tasks that contribute to the maximum profit. **Note**: Ensure your solution effectively manages the state transitions and handles cases where no task can fit within the given time limit, returning a zero profit and an empty list in such scenarios. Also, aim for clarity and conciseness in your implementation.","solution":"def maximize_task_profit( tasks: list[tuple[int, int]], time_limit: int ) -> tuple[int, list[tuple[int, int]]]: # Number of tasks n = len(tasks) # Initialize the dp array to store maximum profit for each time limit from 0 to time_limit dp = [0] * (time_limit + 1) # For storing the trace of tasks selected task_selection = [[] for _ in range(time_limit + 1)] # Iterate over each task and update dp array for duration, profit in tasks: # Traverse dp array backwards so we do not reuse the same task for t in range(time_limit, duration - 1, -1): if dp[t - duration] + profit > dp[t]: dp[t] = dp[t - duration] + profit # Update the selected tasks list task_selection[t] = task_selection[t - duration] + [(duration, profit)] # The maximum profit max_profit = dp[time_limit] # List of tasks selected to achieve this profit selected_tasks = task_selection[time_limit] return max_profit, selected_tasks"},{"question":"# Scenario As a software engineer in a healthcare tech company, you are tasked with creating a utility to manage patient temperature records. The system needs to support conversions between Celsius, Fahrenheit, and Kelvin. Your role is to implement a core function that accurately performs these conversions. # Task Implement the function `convert_temperature`, which converts a given temperature value from one unit to another. This requires understanding and using conversion formulas among different temperature units. # Requirements 1. **Function Signature**: ```python def convert_temperature(temp: float, unit_from: str, unit_to: str) -> float: pass ``` 2. **Parameters**: - `temp` (float): The temperature value to convert. - `unit_from` (str): The unit of the temperature value to convert from. - `unit_to` (str): The unit of the temperature value to convert to. 3. **Returns**: - (float): The converted temperature value, rounded to two decimal places. 4. **Constraints**: - `unit_from` and `unit_to` will be one of `\\"C\\"`, `\\"F\\"`, `\\"K\\"`. - Raise a `ValueError` if the `unit_from` or `unit_to` is not one of the above units. 5. Use the following conversion formulas: - Celsius to Fahrenheit: ( F = frac{9}{5}C + 32 ) - Fahrenheit to Celsius: ( C = frac{5}{9}(F - 32) ) - Celsius to Kelvin: ( K = C + 273.15 ) - Kelvin to Celsius: ( C = K - 273.15 ) # Examples ```python >>> convert_temperature(100, \\"C\\", \\"F\\") 212.00 >>> convert_temperature(32, \\"F\\", \\"C\\") 0.00 >>> convert_temperature(273.15, \\"K\\", \\"C\\") 0.00 >>> convert_temperature(300, \\"K\\", \\"F\\") 80.33 ``` # Additional Notes Consider edge cases such as: - Invalid units. - Extremely high or low temperatures. - Exact zero points for conversions.","solution":"def convert_temperature(temp: float, unit_from: str, unit_to: str) -> float: Converts a temperature value from one unit to another. :param temp: float: The temperature value to convert. :param unit_from: str: The unit of the temperature value to convert from (\'C\', \'F\', \'K\'). :param unit_to: str: The unit of the temperature value to convert to (\'C\', \'F\', \'K\'). :return: float: The converted temperature value, rounded to two decimal places. if unit_from not in [\'C\', \'F\', \'K\'] or unit_to not in [\'C\', \'F\', \'K\']: raise ValueError(\'Invalid unit for temperature conversion.\') if unit_from == unit_to: return round(temp, 2) # Convert from unit_from to Celsius if unit_from == \'F\': temp_in_c = (temp - 32) * 5 / 9 elif unit_from == \'K\': temp_in_c = temp - 273.15 else: temp_in_c = temp # Convert from Celsius to unit_to if unit_to == \'F\': result = temp_in_c * 9 / 5 + 32 elif unit_to == \'K\': result = temp_in_c + 273.15 else: result = temp_in_c return round(result, 2)"},{"question":"# Scenario You are developing a utility to rearrange strings based on the frequency of characters. The target is to generate a new string where characters that appear more frequently are placed earlier than characters that appear less frequently. In the event of a tie in frequency, characters should be arranged in alphabetical order. # Task Write a function `rearrange_by_frequency` that takes a string as input and returns a new string rearranged according to the specified rules. # Input/Output - **Input**: A single string `s` containing only lowercase alphabetical characters. - **Output**: A string rearranged such that characters appear in order of their frequency, with ties broken by alphabetical order. # Constraints - The length of the input string `s` will be between 1 and 1000 characters. - The string will consist only of lowercase English letters. # Function Signature ```python def rearrange_by_frequency(s: str) -> str: ``` # Example ```python s = \\"tree\\" # The frequency of characters are: # \'t\': 1, \'r\': 1, \'e\': 2 # Characters \'t\' and \'r\' have the same frequency, sorted by alphabetical order, they appear before \'t\' and \'r\'. Thus, the expected output is \\"eert\\" or \\"reet\\". print(rearrange_by_frequency(s)) # Output: \\"eert\\" or \\"reet\\" s = \\"banana\\" # The frequency of characters are: # \'b\': 1, \'a\': 3, \'n\': 2 # Thus, the expected output would be \\"aaannb\\" print(rearrange_by_frequency(s)) # Output: \\"aaannb\\" ``` # Notes - Handle character frequencies carefully and ensure the output meets both frequency and lexical order criteria. - Sorting correctly based on dual criteria will be critical to solving this problem.","solution":"def rearrange_by_frequency(s: str) -> str: from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Sort characters first by frequency (in descending order) and then by alphabetical order sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Build the result string by repeating characters based on their frequency result = \'\'.join(char * count for char, count in sorted_chars) return result"},{"question":"# Scenario You are working on a data processing tool that needs to transform multi-line textual data into a simplified format for analysis. One of your tasks is to implement a function that normalizes the text by removing all white spaces (spaces, tabs, and newlines) and converting all characters to lowercase. This will help in consistent data analysis. # Task Implement a function `normalize_text(s: str) -> str` that extends the functionality of a simple string manipulation function: 1. Remove all types of whitespace characters (including spaces, tabs, and newlines) from the input string. 2. Convert all characters in the input string to lowercase. 3. Handle edge cases such as empty or non-string inputs by returning an empty string instead of raising an error. # Function Signature ```python def normalize_text(s: str) -> str: pass ``` # Input * `s`: A string (0 ≤ |s| ≤ 10^6) # Output * Returns a new string that is the normalized version of the input string. # Examples ```python >>> normalize_text(\\" Hello World \\") \\"helloworld\\" >>> normalize_text(\\"HELLOnWORLDt\\") \\"helloworld\\" >>> normalize_text(\\" \\") \\"\\" >>> normalize_text(\\"\\") \\"\\" >>> normalize_text(123) \\"\\" >>> normalize_text(\\"PyThOnt3.8n\\") \\"python3.8\\" ``` # Constraints * Do not use any external libraries. * Ensure the function performs efficiently for large input sizes. * The function should handle edge cases effectively.","solution":"def normalize_text(s): Remove all whitespace characters and convert the string to lowercase. Handle non-string input by returning an empty string. Args: s: Input string Returns: str: A normalized string with no whitespace and all lowercase characters if not isinstance(s, str): return \\"\\" return \'\'.join(s.split()).lower()"},{"question":"Word Frequency Analysis Write a Python function that takes a string of text and an integer `n` as input. The function should return a list of the top `n` most frequent words in the text. If there are multiple words with the same frequency, return them in alphabetical order. # Function Signature ```python def top_n_words(text: str, n: int) -> List[str]: ``` # Function Requirements - Count the frequency of each word in the text. - Return a list of the top `n` most frequent words. - Sort words with the same frequency alphabetically. # Example ```python # Example usage: print(top_n_words(\\"the quick brown fox jumps over the lazy dog the quick brown fox\\", 3)) # Expected output: [\'the\', \'brown\', \'fox\'] ``` # Constraints - Words are case-insensitive and should be treated as lowercase. - The input text will contain only alphabetic characters and spaces. - Assume `n` is always less than or equal to the number of unique words in the text. # Notes - You can use Python libraries such as `collections` to efficiently achieve the task. - The function should be optimized for performance with large input texts. # Hint Consider using a dictionary to count word frequencies and a sorted list or heap to manage the top `n` words efficiently.","solution":"from typing import List from collections import Counter def top_n_words(text: str, n: int) -> List[str]: Returns a list of the top `n` most frequent words in the given text. Words are considered case-insensitive and should be treated as lowercase. # Normalize text to lowercase and split into words words = text.lower().split() # Count the frequency of each word word_count = Counter(words) # Sort words first alphabetically, then by frequency (in descending order) sorted_words = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) # Extract the top n words top_n = [word for word, count in sorted_words[:n]] return top_n"},{"question":"**Repeating Pattern Detection in a String** You are required to implement a function `detect_repeating_pattern` that identifies the smallest repeating pattern in a given string and its frequency. Specifically, the function should analyze the input string to find the shortest substring that, when repeated, forms the entire original string. Write the function `detect_repeating_pattern` with the following signature: ```python def detect_repeating_pattern(s: str) -> Union[Tuple[str, int], str]: # Your implementation here ``` # Input: - `s` (str): The input string to be analyzed. The string consists of lowercase English letters only and has a length between 1 and 1000. # Output: - Returns a tuple (`pattern`, `frequency`) where `pattern` is the smallest repeating substring and `frequency` is the number of times it repeats to form the original string. - If no repeating pattern exists, return the original string as is. # Constraints: - The input string consists only of lowercase English letters. - The length of the input string is between 1 and 1000. # Examples: Example 1: ```python result = detect_repeating_pattern(\\"ababab\\") print(result) # Output: (\\"ab\\", 3) ``` Example 2: ```python result = detect_repeating_pattern(\\"abcd\\") print(result) # Output: \\"abcd\\" ``` Example 3: ```python result = detect_repeating_pattern(\\"aaa\\") print(result) # Output: (\\"a\\", 3) ``` Example 4: ```python result = detect_repeating_pattern(\\"abcabcabcabc\\") print(result) # Output: (\\"abc\\", 4) ```","solution":"from typing import Union, Tuple def detect_repeating_pattern(s: str) -> Union[Tuple[str, int], str]: Identifies the smallest repeating pattern in a string and its frequency. If no repeating pattern exists, returns the original string. n = len(s) # Iterate over every possible pattern length from 1 to n/2 for i in range(1, n // 2 + 1): if n % i == 0: # Pattern length should divide the total length of the string pattern = s[:i] multiplier = n // i if pattern * multiplier == s: return (pattern, multiplier) # If no pattern found, return the original string return s"},{"question":"# Sparse Matrix Implementation In this exercise, you will implement a class `SparseMatrix` to efficiently store and perform operations on a sparse matrix. A sparse matrix is a matrix in which the majority of the elements are zero. We will store only the non-zero elements to save space. Task Implement the following methods for the `SparseMatrix` class: 1. **Initialization (`__init__`)**: - Initializes a sparse matrix of given dimensions. Non-zero elements are stored in a dictionary where keys are tuples representing the element positions, and values are the non-zero elements. 2. **Addition (`__add__`)**: - Adds two sparse matrices and returns the resulting sparse matrix. Handle matrices of the same dimensions only. 3. **Subtraction (`__sub__`)**: - Subtracts one sparse matrix from another and returns the resulting sparse matrix. 4. **Scalar Multiplication (`scalar_multiply`)**: - Multiplies the sparse matrix by a scalar and returns the resulting sparse matrix. 5. **Matrix Multiplication (`__mul__`)**: - Multiplies two sparse matrices and returns the resulting sparse matrix. Ensure you handle the proper dimensions for matrix multiplication. 6. **Transpose (`transpose`)**: - Transposes the sparse matrix and returns the resulting sparse matrix. 7. **Element Retrieval (`get_item`)**: - Retrieves an element at a given position. Return 0 if the position is not in the dictionary. 8. **Element Setting (`set_item`)**: - Sets an element value at a given position. Automatically remove positions where value is set to 0 to maintain sparsity. Input and Output Formats - **Input**: - Initialization: `SparseMatrix(rows: int, cols: int, elements: Dict[Tuple[int, int], float])` - Operations: As per operator overloading for `+`, `-`, `*`, methods for `scalar_multiply`, `transpose`, `get_item`, and `set_item`. - **Output**: - Returns new `SparseMatrix` instances or results as specified by the operations. Example ```python # Initialization mat1 = SparseMatrix(2, 3, {(0, 0): 1, (1, 2): 3}) mat2 = SparseMatrix(2, 3, {(0, 1): 2, (1, 2): 4}) # Addition print(mat1 + mat2) # Should output: {(0, 0): 1, (0, 1): 2, (1, 2): 7} # Subtraction print(mat1 - mat2) # Should output: {(0, 0): 1, (0, 1): -2, (1, 2): -1} # Scalar Multiplication print(mat1.scalar_multiply(2)) # Should output: {(0, 0): 2, (1, 2): 6} # Matrix Multiplication mat3 = SparseMatrix(3, 2, {(0, 1): 1, (2, 0): 2}) print(mat1 * mat3) # Should output: {(1, 1): 3, (1, 0): 6} # Transpose print(mat1.transpose()) # Should output: {(0, 0): 1, (2, 1): 3} # Element Retrieval print(mat1.get_item(0, 0)) # Should output: 1 print(mat1.get_item(0, 2)) # Should output: 0 # Element Setting mat1.set_item(0, 2, 4) print(mat1) # Should output: {(0, 0): 1, (1, 2): 3, (0, 2): 4} mat1.set_item(0, 0, 0) print(mat1) # Should output: {(1, 2): 3, (0, 2): 4} ``` Notes - Ensure proper dimension checking for all operations and raise appropriate errors for dimension mismatches. - Only store and work with non-zero elements internally to maintain efficient storage and operations.","solution":"class SparseMatrix: def __init__(self, rows, cols, elements=None): self.rows = rows self.cols = cols self.elements = elements if elements is not None else {} def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions are not the same.\\") result = {} for key in set(self.elements.keys()).union(other.elements.keys()): result[key] = self.elements.get(key, 0) + other.elements.get(key, 0) if result[key] == 0: del result[key] return SparseMatrix(self.rows, self.cols, result) def __sub__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrices dimensions are not the same.\\") result = {} for key in set(self.elements.keys()).union(other.elements.keys()): result[key] = self.elements.get(key, 0) - other.elements.get(key, 0) if result[key] == 0: del result[key] return SparseMatrix(self.rows, self.cols, result) def scalar_multiply(self, scalar): result = {key: val * scalar for key, val in self.elements.items()} return SparseMatrix(self.rows, self.cols, result) def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions are not aligned for multiplication.\\") result = {} for (i, k), v in self.elements.items(): for (k2, j), w in other.elements.items(): if k == k2: if (i, j) not in result: result[(i, j)] = 0 result[(i, j)] += v * w if result[(i, j)] == 0: del result[(i, j)] return SparseMatrix(self.rows, other.cols, result) def transpose(self): result = {(col, row): val for (row, col), val in self.elements.items()} return SparseMatrix(self.cols, self.rows, result) def get_item(self, row, col): return self.elements.get((row, col), 0) def set_item(self, row, col, value): if value != 0: self.elements[(row, col)] = value elif (row, col) in self.elements: del self.elements[(row, col)] def __repr__(self): return f\\"SparseMatrix({self.rows}, {self.cols}, {self.elements})\\""},{"question":"# Coding Assessment Question **Objective**: To assess your capability to solve problems using recursion and understanding base conversion between different radix representations. **Problem Statement**: Implement a function to convert a given decimal number into its equivalent representation in a given base-radix between 2 and 36. **Function Signature**: ```python def decimal_to_base(n: int, base: int) -> str: pass ``` **Input**: * `n`: An integer representing the decimal number to be converted. The range of `n` is `0 <= n <= 10^6`. * `base`: An integer representing the base to which the decimal number should be converted. The base can range from `2` to `36`. **Output**: * Returns a string representing the number `n` in the specified base. **Constraints**: 1. `0 <= n <= 10^6` 2. `2 <= base <= 36` **Example**: ```python n = 255 base = 16 print(decimal_to_base(n, base)) # Output \\"FF\\" n = 10 base = 2 print(decimal_to_base(n, base)) # Output \\"1010\\" ``` **Requirements**: 1. Write your implementation inside the `decimal_to_base` function. 2. The conversion should be implemented using a recursive approach. 3. Characters from 0-9 and A-Z should be used for bases greater than 10 (i.e., for bases 10 < b <= 36). **Note**: - Ensure your solution handles the conversion correctly for all bases within the specified constraint. - Optimize where necessary for efficiency. - Test your implementation with a variety of inputs to verify its correctness, particularly edge cases.","solution":"def decimal_to_base(n: int, base: int) -> str: Convert a given decimal number n to its equivalent representation in the given base. :param n: the decimal number to be converted. :param base: the base to which the decimal number should be converted. :return: the base representation of the decimal number as a string. if n == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def convert(n): if n < base: return digits[n] else: return convert(n // base) + digits[n % base] return convert(n)"},{"question":"# Problem Statement You are given two lists of integers. Your task is to implement a function that finds the intersection of these two lists. The intersection of two lists is a new list that contains only the elements that are present in both lists. The elements in the intersection list should be unique and appear in the order of their first occurrence in the first list. # Requirements Implement the function `list_intersection(list_a: list, list_b: list) -> list` such that: 1. The function accepts two lists of integers. 2. It returns a list containing the unique elements that are present in both `list_a` and `list_b`. 3. The order of elements in the output list should match their order of first occurrence in `list_a`. 4. If either input is not a list, the function should raise a `TypeError` with a message. # Input Format - `list_a` and `list_b`: Two lists of integers. # Output Format - A list of integers representing the intersection of `list_a` and `list_b`. # Constraints - You may assume the elements in the lists are integers within the range [-10^6, 10^6]. - The sizes of the lists, `n` and `m`, for `list_a` and `list_b` respectively will be such that `1 <= n, m <= 1000`. # Performance Requirements Ensure that the function is optimized to handle the upper constraint limits efficiently. # Example 1. Example 1: - Input: `list_a = [1, 2, 3, 4]`, `list_b = [3, 4, 5, 6]` - Output: `[3, 4]` 2. Example 2: - Input: `list_a = [5, 1, 2, 7, 9]`, `list_b = [6, 5, 9, 3]` - Output: `[5, 9]` 3. Example 3: - Input: `list_a = [10, 20, 30, 40]`, `list_b = [50, 60, 70, 80]` - Output: `[]` # Edge Cases - One or both of the lists are empty. - Non-list input types. - Lists with very large numbers and varying lengths. ```python def list_intersection(list_a: list, list_b: list) -> list: :param list_a: a list of numbers :param list_b: a list of numbers :return: a list containing the unique elements that are present in both list_a and list_b in the order of their first occurrence in list_a Raises: TypeError: If either input is not a list. if not isinstance(list_a, list): raise TypeError(f\\"The input value of [list_a={list_a}] is not a list\\") if not isinstance(list_b, list): raise TypeError(f\\"The input value of [list_b={list_b}] is not a list\\") set_b = set(list_b) return [x for x in list_a if x in set_b and list_a.count(x) == 1] # Testing the function with provided examples print(list_intersection([1, 2, 3, 4], [3, 4, 5, 6])) # Output: [3, 4] print(list_intersection([5, 1, 2, 7, 9], [6, 5, 9, 3])) # Output: [5, 9] print(list_intersection([10, 20, 30, 40], [50, 60, 70, 80])) # Output: [] ``` Test your function with edge cases and various inputs to ensure robustness and correctness.","solution":"def list_intersection(list_a: list, list_b: list) -> list: Finds the unique elements that are present in both list_a and list_b and returns them in the order of their first occurrence in list_a. :param list_a: a list of numbers :param list_b: a list of numbers :return: a list containing unique elements present in both lists :raises TypeError: If either input is not a list. if not isinstance(list_a, list): raise TypeError(f\\"The input value of [list_a={list_a}] is not a list\\") if not isinstance(list_b, list): raise TypeError(f\\"The input value of [list_b={list_b}] is not a list\\") set_b = set(list_b) seen = set() intersection = [] for elem in list_a: if elem in set_b and elem not in seen: intersection.append(elem) seen.add(elem) return intersection"},{"question":"# Depth-First Search (DFS) in Graphs Context Graph traversal algorithms are crucial for navigating through graphs, for tasks such as searching, topological sorting, and finding connected components. Depth-First Search (DFS) is one such algorithm that explores as far as possible along each branch before backtracking. Problem Statement You are required to implement the Depth-First Search (DFS) algorithm for a given graph and return the sequence of nodes visited during the search. Specifications 1. Implement a `Graph` class that uses an adjacency list representation. 2. Implement methods to add vertices and edges, and to perform DFS from a given starting node. 3. Ensure your graph handles undirected edges and non-existent vertices gracefully. 4. Return the traversal path as a list of visited nodes. Expected Methods 1. `add_vertex(self, vertex: int) -> None`: Adds a vertex to the graph. 2. `add_edge(self, u: int, v: int) -> None`: Adds an undirected edge between vertices `u` and `v`. 3. `dfs(self, start: int) -> List[int]`: Performs DFS starting from the vertex `start` and returns a list of nodes in the order they were visited. Input and Output Formats - **Input**: Vertices and edges for the graph, starting node for DFS. - **Output**: A list of nodes in the sequence of their DFS visitation. Constraints - Ensure that the DFS handles graphs with cycles without entering infinite loops. - The graph vertices are assumed to be non-negative integers. - If the start vertex is not in the graph, return an empty list. Example Usage ```python graph = Graph() graph.add_vertex(0) graph.add_vertex(1) graph.add_vertex(2) graph.add_edge(0, 1) graph.add_edge(1, 2) assert graph.dfs(0) == [0, 1, 2] assert graph.dfs(1) == [1, 2, 0] assert graph.dfs(3) == [] # DFS from a non-existent vertex ```","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, u, v): if u not in self.adjacency_list: self.add_vertex(u) if v not in self.adjacency_list: self.add_vertex(v) self.adjacency_list[u].append(v) self.adjacency_list[v].append(u) def dfs(self, start): if start not in self.adjacency_list: return [] visited = [] stack = [start] while stack: vertex = stack.pop() if vertex not in visited: visited.append(vertex) stack.extend([neighbor for neighbor in self.adjacency_list[vertex] if neighbor not in visited]) return visited"},{"question":"# Coding Challenge: Smart Home Sensor Data Analysis You are given a dataset of sensor readings from a smart home system. Each reading includes the sensor ID, the sensor type, the timestamp of the reading, and the reading value. Your task is to implement a function that calculates the average reading value for each type of sensor over a specified time period. # Function Signature ```python def average_sensor_readings(data: list[list], start_time: int, end_time: int) -> dict: pass ``` # Input - `data`: A list of lists, where each sublist represents a sensor reading `[sensor_id, sensor_type, timestamp, reading_value]`. For example: ```python [ [101, \\"temperature\\", 1627776000, 22.5], [102, \\"humidity\\", 1627776060, 55], [101, \\"temperature\\", 1627776120, 23.0], [103, \\"light\\", 1627776180, 400], [102, \\"humidity\\", 1627776240, 60] ] ``` - `start_time`: An integer representing the start time of the period for which to calculate the averages. - `end_time`: An integer representing the end time of the period for which to calculate the averages. # Output - A dictionary where each key is a sensor type and the corresponding value is the average reading value for that type over the specified time period. For example: ```python { \\"temperature\\": 22.75, \\"humidity\\": 57.5, \\"light\\": 400 } ``` # Constraints - 1 ≤ len(data) ≤ 10^4 - Each sublist contains exactly 4 elements: an integer sensor ID, a string sensor type, an integer timestamp, and a float reading value. - Timestamps are within the range from 0 to 10^10. - Sensor types are non-empty strings, and each reading value is a non-negative float. - `start_time` and `end_time` are valid timestamps where 0 ≤ start_time < end_time ≤ 10^10. # Requirements - Implement and validate the `average_sensor_readings` function. - Ensure appropriate handling of edge cases (e.g., no readings in the specified time period). - The implementation must work within the specified constraints efficiently. # Example ```python data = [ [101, \\"temperature\\", 1627776000, 22.5], [102, \\"humidity\\", 1627776060, 55], [101, \\"temperature\\", 1627776120, 23.0], [103, \\"light\\", 1627776180, 400], [102, \\"humidity\\", 1627776240, 60] ] start_time = 1627776000 end_time = 1627776180 print(average_sensor_readings(data, start_time, end_time)) # Output: { # \\"temperature\\": 22.75, # \\"humidity\\": 55, # \\"light\\": 400 # } ```","solution":"def average_sensor_readings(data, start_time, end_time): from collections import defaultdict # Dictionary to store the sum of values and count of readings per sensor type readings_sum = defaultdict(float) readings_count = defaultdict(int) for sensor_id, sensor_type, timestamp, reading_value in data: if start_time <= timestamp <= end_time: readings_sum[sensor_type] += reading_value readings_count[sensor_type] += 1 # Compute the average for each sensor type averages = {} for sensor_type in readings_sum: averages[sensor_type] = readings_sum[sensor_type] / readings_count[sensor_type] return averages"},{"question":"# Coding Assessment: Substring Anagram Detection Context You are developing a text analysis tool that needs to identify anagrams within a given text. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. As part of your tool’s functionality, you need to find out if a smaller string (pattern) is an anagram of any substring in a larger string (text). Task Write a function `is_anagram_in_substring` that takes two strings as input: `text` and `pattern`. The function should return a boolean indicating whether any substring of the `text` is an anagram of the `pattern`. Input - `text`: A string of alphanumeric characters. - `pattern`: A string of alphanumeric characters. Output - A boolean value: - `True` if there exists at least one substring in `text` that is an anagram of `pattern`. - `False` otherwise. Constraints - Both `text` and `pattern` will have a length of at most 10,000 characters. - The function should be efficient in terms of time and space complexity. Example ```python def is_anagram_in_substring(text: str, pattern: str) -> bool: # Your implementation here pass # Example Usage print(is_anagram_in_substring(\\"cbaebabacd\\", \\"abc\\")) # Expected Output: True, because \\"cba\\", \\"bac\\" are anagrams of \\"abc\\". print(is_anagram_in_substring(\\"hello\\", \\"oell\\")) # Expected Output: True, because \\"lo\\" is an anagram of \\"oell\\" when extra characters \\"o\\" and \\"e\\" are removed or ignored. print(is_anagram_in_substring(\\"aaaaaa\\", \\"aaa\\")) # Expected Output: True, because every substring of length 3 is \\"aaa\\", which is an anagram of \\"aaa\\". print(is_anagram_in_substring(\\"abcdef\\", \\"gh\\")) # Expected Output: False, because no substring of \\"abcdef\\" is an anagram of \\"gh\\". ``` In your solution: 1. Use a sliding window approach to iterate over the `text` with a window of size equal to the length of `pattern`. 2. Use arrays or dictionaries to count the frequency of each character in the `pattern` and in the current window of the `text`. 3. Compare the counts to determine if any window is an anagram of the `pattern`.","solution":"def is_anagram_in_substring(text: str, pattern: str) -> bool: from collections import Counter len_pattern = len(pattern) len_text = len(text) if len_pattern > len_text: return False pattern_counter = Counter(pattern) window_counter = Counter(text[:len_pattern]) if pattern_counter == window_counter: return True for i in range(len_pattern, len_text): window_counter[text[i]] += 1 window_counter[text[i - len_pattern]] -= 1 if window_counter[text[i - len_pattern]] == 0: del window_counter[text[i - len_pattern]] if pattern_counter == window_counter: return True return False"},{"question":"# Objective Create an efficient solution to rotate a square matrix by 90 degrees clockwise. This task will demonstrate your understanding of matrix operations and manipulation. # Question You\'ve been asked to implement a function that rotates a given n x n matrix by 90 degrees clockwise. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotate the given n x n matrix by 90 degrees clockwise. Parameters: - matrix (List[List[int]]): A 2D list representing the square matrix. Returns: - List[List[int]]: The rotated matrix. ``` # Input/Output - **Input**: A 2D list of integers representing an n x n matrix. - **Output**: The rotated 2D list of integers. # Constraints - The input will be a square matrix with dimensions n x n, where 1 <= n <= 1000. - You are required to perform the rotation in-place, altering the original matrix without using extra space for another matrix. # Performance Requirement - Aim to perform the rotation with O(n^2) time complexity and O(1) additional space complexity. # Context Consider the following example input and expected output: # Example ```python def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix # Example usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = rotate_matrix(matrix) print(result) # Output should be [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` # Notes: 1. Ensure that you handle matrix boundaries and edge cases appropriately. 2. Validate your function with various test cases to handle different matrix sizes and content. # Additional Test Case ```python matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] result = rotate_matrix(matrix) print(result) # Output should be: # [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] ```","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"# Matrix Transpose and Sum Function Implementation Problem Statement You are tasked with writing a function `transpose_and_sum` that calculates the transpose of a given matrix and then returns the sum of its diagonal elements (from top-left to bottom-right). Requirements 1. **Function Name**: `transpose_and_sum` 2. **Input**: A 2D list (a list of lists) representing an integer matrix. 3. **Output**: An integer representing the sum of the diagonal elements of the transposed matrix. # Constraints * The input matrix will be a non-empty square matrix (i.e., same number of rows and columns). * Implement proper error handling for non-square matrices or inputs that are not 2D lists. * Each element in the matrix is guaranteed to be within the range -10^6 ≤ element ≤ 10^6. # Performance * Aim for a time complexity of O(N^2), where N is the dimension of the matrix. * Ensure space complexity is kept to O(1) for the transpose operation, modifying in place. # Edge Cases to Handle * Non-square matrices. * Empty input or non-2D list structures. * Large matrices within the given constraints. * Varying integer values, including negative numbers. # Example Inputs and Outputs ```python >>> transpose_and_sum([[1, 2], [3, 4]]) 4 # (Transposed matrix [[1, 3], [2, 4]] diagonal elements are 1 and 3) >>> transpose_and_sum([[5, -3, 2], [-1, 4, 0], [7, 6, 3]]) 12 # (Transposed matrix [[5, -1, 7], [-3, 4, 6], [2, 0, 3]] diagonal elements are 5, 4, and 3) >>> transpose_and_sum([[]]) ValueError: Input must be a non-empty square matrix >>> transpose_and_sum([[1, 2, 3], [4, 5, 6]]) ValueError: Input must be a square matrix >>> transpose_and_sum(\\"matrix\\") TypeError: Input must be a 2D list >>> transpose_and_sum([[1, 2], [3, \\"4\\"]]) ValueError: Matrix elements must be integers ``` # Notes * Ensure your function passes all the example test cases provided. * Add additional test cases to verify the robustness of your implementation. * Avoid using any built-in libraries or functions explicitly designed for the transpose or diagonal summation.","solution":"def transpose_and_sum(matrix): Transposes the given square matrix and returns the sum of its diagonal elements. :param matrix: A 2D list (square matrix) of integers. :return: The sum of the diagonal elements of the transposed matrix. :raises ValueError: If the input is not a non-empty square matrix. :raises TypeError: If the input is not a 2D list. # Check if input is a 2D list if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise TypeError(\\"Input must be a 2D list\\") # Check if it\'s a non-empty square matrix if len(matrix) == 0 or any(len(row) != len(matrix) for row in matrix): raise ValueError(\\"Input must be a non-empty square matrix\\") # Check all elements are integers for row in matrix: for element in row: if not isinstance(element, int): raise ValueError(\\"Matrix elements must be integers\\") n = len(matrix) transposed_diagonal_sum = 0 # Calculate sum of diagonal elements of transposed matrix for i in range(n): transposed_diagonal_sum += matrix[i][i] return transposed_diagonal_sum"},{"question":"# Sentence Checker Problem Statement Write a function `is_phrase_possible(words: List[str], sentence: List[str]) -> bool` that determines whether it is possible to form the exact sentence (provided as a list of words) using each word from a given list exactly once. Input - A list of strings `words` where each element represents a word (1 ≤ len(words) ≤ 10^4). - A list of strings `sentence` where each element represents a word (1 ≤ len(sentence) ≤ 10^4). Output - A boolean indicating whether the sentence can be formed using the words in the list exactly once. Constraints - The words in both `words` and `sentence` will only contain lowercase alphabetic characters. - You may assume that word comparison is case-sensitive. Example ```python >>> is_phrase_possible([\\"you\\", \\"have\\", \\"been\\", \\"programmed\\", \\"you\\", \\"have\\"], [\\"you\\", \\"have\\", \\"been\\", \\"programmed\\"]) True >>> is_phrase_possible([\\"an\\", \\"apple\\", \\"a\\", \\"day\\"], [\\"an\\", \\"apple\\", \\"a\\", \\"day\\", \\"keeps\\", \\"the\\", \\"doctor\\", \\"away\\"]) False ``` Explanation In the first example, each word in the sentence can be matched with words in the list exactly once. In the second example, the sentence contains extra words (\\"keeps\\", \\"the\\", \\"doctor\\", \\"away\\") which are not present in the list of words. Hence, it is not possible to form the sentence exactly.","solution":"from typing import List from collections import Counter def is_phrase_possible(words: List[str], sentence: List[str]) -> bool: Determines whether it\'s possible to form the exact sentence using each word from the given list exactly once. words_counter = Counter(words) sentence_counter = Counter(sentence) for word, count in sentence_counter.items(): if words_counter[word] < count: return False return True"},{"question":"# Coding Assessment Question **Context:** You are given an implementation of a Weighted Directed Graph in Python. This graph supports operations such as adding vertices, adding and removing weighted edges, as well as traversing nodes using DFS (Depth-First Search) and BFS (Breadth-First Search). **Task:** **Implement a function, `dijkstra_shortest_path(graph, start, end)`,**, that employs Dijkstra\'s algorithm to find the shortest path between the `start` and `end` nodes in the given weighted directed graph. The function should return the shortest path as a list of nodes along with the total path cost. If there\'s no path from start to end, return an empty list and cost as infinity. **Input & Output**: - **graph**: An instance of `WeightedDirectedGraph`. - **start**: The starting node (integer). - **end**: The target node (integer). **Requirements**: - Implement the function such that it utilizes Dijkstra\'s algorithm to find the shortest path efficiently. - Ensure performance and consider edge cases like: - Unreachable nodes. - Non-existent nodes. - Graph with cycles and varying weights. **Example**: ```python class WeightedDirectedGraph: def __init__(self): self.edges = defaultdict(list) self.weights = {} def add_vertex(self, value): self.edges[value] = [] def add_edge(self, from_node, to_node, weight): self.edges[from_node].append(to_node) self.weights[(from_node, to_node)] = weight graph = WeightedDirectedGraph() graph.add_vertex(1) graph.add_vertex(2) graph.add_vertex(3) graph.add_edge(1, 2, 1) graph.add_edge(2, 3, 2) graph.add_edge(1, 3, 4) print(dijkstra_shortest_path(graph, 1, 3)) # Output: ([1, 2, 3], 3) graph2 = WeightedDirectedGraph() graph2.add_vertex(1) graph2.add_vertex(2) graph2.add_vertex(3) graph2.add_edge(1, 2, 2) graph2.add_edge(2, 3, 2) print(dijkstra_shortest_path(graph2, 1, 3)) # Output: ([1, 2, 3], 4) print(dijkstra_shortest_path(graph2, 3, 1)) # Output: ([], float(\'inf\')) # since there\'s no path back ``` **Hints**: - You can use a priority queue to optimize the selection of the next node with the lowest tentative distance. - Maintain a dictionary to keep track of the shortest paths and their costs during the algorithm.","solution":"import heapq from collections import defaultdict class WeightedDirectedGraph: def __init__(self): self.edges = defaultdict(list) self.weights = {} def add_vertex(self, value): self.edges[value] = [] def add_edge(self, from_node, to_node, weight): self.edges[from_node].append(to_node) self.weights[(from_node, to_node)] = weight def dijkstra_shortest_path(graph, start, end): # Priority queue to store the nodes to be processed queue = [(0, start)] # Dictionary to store the shortest known distance to each node distances = {start: 0} # Dictionary to store the path taken to get to each node previous_nodes = {start: None} while queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(queue) if current_node == end: # Build the path path = [] while current_node is not None: path.insert(0, current_node) current_node = previous_nodes[current_node] return path, current_distance for neighbor in graph.edges[current_node]: weight = graph.weights[(current_node, neighbor)] distance = current_distance + weight # If a shorter path to the neighbor is found if neighbor not in distances or distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) return [], float(\'inf\')"},{"question":"# Flatten a Nested List Context Nested lists are common in various data structures and need to be processed efficiently. Flattening a nested list involves converting it to a single list containing all elements in the original nested structure, in the same order. Task Write a Python function that takes a nested list of integers and returns a flattened list of integers. The function should handle arbitrary levels of nesting. Input - A nested list of integers. The nested list can be empty. Output - A single list of integers containing all elements from the nested list, in the same order. Constraints - The nested list can have any level of nesting. - The function should handle empty lists at any level of nesting. - Raise a `ValueError` with an appropriate message if the input is not a list. Examples ```python >>> flatten([1, [2, [3, 4], 5], [6]]) [1, 2, 3, 4, 5, 6] >>> flatten([1, [2, [], 4], 5]) [1, 2, 4, 5] >>> flatten([1, [2, [3, [4, [5]]]], [6]]) [1, 2, 3, 4, 5, 6] >>> flatten([]) [] >>> flatten(\\"Not a list\\") Traceback (most recent call last): ... ValueError: Input must be a list ``` Function Signature ```python def flatten(nested_list: list) -> list: pass ``` # Requirements 1. The function should properly handle any level of list nesting. 2. Proper exception handling should be implemented for invalid inputs. 3. Recursion or iterative stack approaches can be used for efficient flattening.","solution":"def flatten(nested_list): Flattens a nested list of integers into a single list of integers. Args: nested_list (list): The nested list of integers. Returns: list: A flat list containing all integers from the nested list in the same order. Raises: ValueError: If the input is not a list. if not isinstance(nested_list, list): raise ValueError(\\"Input must be a list\\") flat_list = [] def _flatten_helper(lst): for item in lst: if isinstance(item, list): _flatten_helper(item) else: flat_list.append(item) _flatten_helper(nested_list) return flat_list"},{"question":"# Coding Assessment Question Scenario You are developing a file management system where users can upload, categorize, and search for files based on specific tags. One of the features you need to implement is a tag-based search functionality that allows users to find files that match a given set of tags. The search should return files that contain all the specified tags. Task Implement a function that takes a list of files, each represented by a dictionary containing the file\'s name and a list of tags associated with it. The function should also take a list of search tags. Your task is to return a list of file names that contain all the specified search tags. Function Signature ```python def search_files_by_tags(files: List[Dict[str, Union[str, List[str]]]], search_tags: List[str]) -> List[str]: Search for files that contain all the specified search tags. :param files: List of dictionaries, each containing \'name\' (str) and \'tags\' (List[str]). :param search_tags: List of strings representing the tags to search for. :return: List of file names that match all search tags. ``` Inputs and Outputs * **Input Format**: * `files`: List of dictionaries, where each dictionary contains: * \'name\': String - The name of the file. * \'tags\': List of strings - The tags associated with the file. * `search_tags`: List of strings - The tags to search for. * **Output Format**: * A list of file names (strings) that contain all the specified search tags. Constraints * Each file will only have unique tags. * The search_tags list will have at least one tag. * The length of the files list and the search_tags list will adhere to reasonable limits for processing within a typical runtime environment. Performance Requirements * Ensure that the search operation is performed efficiently to handle typical usage scenarios. Example ```python # Example input files = [ {\'name\': \'file1.txt\', \'tags\': [\'tag1\', \'tag2\', \'tag3\']}, {\'name\': \'file2.txt\', \'tags\': [\'tag3\', \'tag4\', \'tag5\']}, {\'name\': \'file3.txt\', \'tags\': [\'tag1\', \'tag3\', \'tag5\']}, ] search_tags = [\'tag1\', \'tag3\'] # Expected output [\'file1.txt\', \'file3.txt\'] ``` Evaluation Criteria: 1. Correctness: The function should return the correct list of file names that match all search tags. 2. Efficiency: The function should handle input sizes and constraints efficiently. 3. Code Quality: Code should be clean, well-documented, and adhere to best practices. # Solution ```python def search_files_by_tags(files: List[Dict[str, Union[str, List[str]]]], search_tags: List[str]) -> List[str]: Search for files that contain all the specified search tags. result = [] search_set = set(search_tags) for file in files: if search_set.issubset(file[\'tags\']): result.append(file[\'name\']) return result # Example usage files = [ {\'name\': \'file1.txt\', \'tags\': [\'tag1\', \'tag2\', \'tag3\']}, {\'name\': \'file2.txt\', \'tags\': [\'tag3\', \'tag4\', \'tag5\']}, {\'name\': \'file3.txt\', \'tags\': [\'tag1\', \'tag3\', \'tag5\']}, ] search_tags = [\'tag1\', \'tag3\'] # Running the function with the example input print(search_files_by_tags(files, search_tags)) # Output: [\'file1.txt\', \'file3.txt\'] ``` This question maintains a consistent tone and style with the provided sample, focusing on programming concepts such as dictionaries, lists, and set operations. It also matches the complexity and length of the sample questions.","solution":"from typing import List, Dict, Union def search_files_by_tags(files: List[Dict[str, Union[str, List[str]]]], search_tags: List[str]) -> List[str]: Search for files that contain all the specified search tags. :param files: List of dictionaries, each containing \'name\' (str) and \'tags\' (List[str]). :param search_tags: List of strings representing the tags to search for. :return: List of file names that match all search tags. result = [] search_set = set(search_tags) for file in files: if search_set.issubset(file[\'tags\']): result.append(file[\'name\']) return result"},{"question":"# Problem: Rearrange Array Alternately Context You are provided with an array of `n` positive integers sorted in non-decreasing order. Your task is to rearrange the elements of the array alternately such that the resulting array consists of the maximum element followed by the minimum element, then the second maximum element followed by the second minimum element, and so on. Question Write a function `rearrange_alternately(arr: List[int]) -> List[int]` that rearranges the array elements as described above and returns the resulting array. Input - A list of integers `arr` sorted in non-decreasing order. Output - A list of integers where the elements are rearranged alternately between the maximum and minimum possible values. Algorithm Requirements 1. Ensure the time complexity is efficient, ideally O(n). 2. Ensure the space complexity is efficient, with the possibility of modifying the array in-place if necessary. Constraints - The array should contain at least 1 and at most 10^5 elements. - Each element in the array should be a positive integer within the range 1 to 10^9. Example ```python def rearrange_alternately(arr: List[int]) -> List[int]: pass # Example usage: print(rearrange_alternately([1, 2, 3, 4, 5, 6])) # Expected output: [6, 1, 5, 2, 4, 3] print(rearrange_alternately([10, 20, 30, 40, 50])) # Expected output: [50, 10, 40, 20, 30] ``` Performance Requirements - Analyze the runtime performance of your function and ensure it is within acceptable limits for the given constraints. - Optimize memory usage as required, with a possibility of modifying the input array in place.","solution":"from typing import List def rearrange_alternately(arr: List[int]) -> List[int]: Rearranges the elements of the array alternately between the maximum and minimum possible values. Args: arr (List[int]): A list of integers sorted in non-decreasing order. Returns: List[int]: A list of integers rearranged alternately. n = len(arr) result = [0] * n left, right = 0, n - 1 for i in range(n): if i % 2 == 0: result[i] = arr[right] right -= 1 else: result[i] = arr[left] left += 1 return result"},{"question":"# Question: Rotate Matrix (In-Place) Implement a function that rotates an NxN matrix 90 degrees clockwise in-place. The rotation should be done without using any additional array or lists. Function Signature ```python def rotate_matrix(matrix: list[list[int]]) -> None: pass ``` Input * `matrix`: A list of lists of integers representing an NxN matrix. (1 ≤ N ≤ 10^3) Output * The function does not return anything. It modifies the matrix in-place. Constraints * The function should perform the rotation with O(1) extra space. * Time complexity should not exceed O(N^2). Example ```python matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix1) assert matrix1 == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix2 = [ [1] ] rotate_matrix(matrix2) assert matrix2 == [ [1] ] matrix3 = [ [1, 2], [3, 4] ] rotate_matrix(matrix3) assert matrix3 == [ [3, 1], [4, 2] ] ``` # Guidelines and Tips 1. **Understanding the Coordinates**: Identify how the coordinates change when rotating the matrix by 90 degrees. 2. **Layer-by-Layer Rotation**: Rotate the matrix layer by layer, starting from the outermost layer and working inwards. 3. **Four-Way Swap**: Implement a four-way swap for the elements in the matrix. For each element at position (i, j), perform a cyclic swap among the four corresponding elements. 4. **Edge Cases**: Ensure your function handles edge cases such as Nx1 matrices. The solution should demonstrate an efficient in-place manipulation strategy without using additional space and should maintain O(N^2) time complexity efficiency.","solution":"def rotate_matrix(matrix: list[list[int]]) -> None: Rotates an NxN matrix 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Sudoku Solver Problem Description You are tasked with implementing a function to solve a classic 9x9 Sudoku puzzle. The input will be a partially filled 9x9 grid, and the function should fill in the empty cells such that each row, column, and 3x3 subgrid contains all digits from 1 to 9 exactly once. Implementation Details 1. **Grid Representation**: * Represent the Sudoku grid as a list of lists (a 2D array) where empty cells are denoted by 0. 2. **Validation Function**: * Implement a `is_valid(grid, row, col, num)` function to check if it\'s legal to place a number at the given position. 3. **Solver Function**: * Implement a `solve_sudoku(grid)` function that applies a backtracking algorithm to fill in the empty cells. 4. **Main Function**: * Read an input 9x9 grid from the user. * Use the `solve_sudoku` function to solve the puzzle and print the solved grid. Input Format * **Grid Input**: A 9x9 grid with integers (0-9) where 0 represents empty cells. Output Format * **Solved Grid**: A 9x9 grid with all cells filled according to Sudoku rules. Constraints * The input grid will always be a valid Sudoku puzzle with at least one empty cell. * The input will always be a 9x9 grid. # Example Input ``` Type your 9x9 Sudoku grid (rows separated by newline and numbers separated by space): [[5, 3, 0, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]] ``` Output ``` [[5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9]] ``` Your Task Implement the functions `is_valid`, `solve_sudoku`, and the main functionality to read the grid and print the result after solving it. Ensure the solution follows the Sudoku rules strictly.","solution":"def is_valid(grid, row, col, num): Check whether it\'s valid to place num at position (row, col) in the Sudoku grid. for i in range(9): if grid[row][i] == num or grid[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(start_row, start_row + 3): for j in range(start_col, start_col + 3): if grid[i][j] == num: return False return True def solve_sudoku(grid): Solve the given Sudoku puzzle using backtracking. for row in range(9): for col in range(9): if grid[row][col] == 0: for num in range(1, 10): if is_valid(grid, row, col, num): grid[row][col] = num if solve_sudoku(grid): return True grid[row][col] = 0 return False return True def print_grid(grid): for row in grid: print(row)"},{"question":"# Question: You are given the task of implementing a function that sorts a list of dictionaries based on a specified key. The function should sort the dictionaries in ascending order by default, but it should also provide an option to sort them in descending order. Additionally, handle edge cases such as empty lists and dictionaries that do not contain the specified key. Below are the specifications: Function Signature ```python def sort_dict_list(dict_list: list, sort_key: str, descending: bool = False) -> list: pass ``` Input - `dict_list` (list): A list of dictionaries to be sorted. - `sort_key` (str): The key in the dictionaries by which to sort. - `descending` (bool): If `True`, sort the list in descending order; otherwise, sort in ascending order. Output - Returns a new list of dictionaries sorted based on the specified key. Constraints - Each dictionary must have the specified `sort_key`; if not, they should be placed at the end of the list. - The input list may be empty. - The dictionaries will not have nested structures. - Keys and values may be of any type that supports comparison. Example ```python >>> sort_dict_list([{\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 20}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}], \\"age\\") [{\'name\': \'Bob\', \'age\': 20}, {\'name\': \'Charlie\', \'age\': 25}, {\'name\': \'Alice\', \'age\': 30}] >>> sort_dict_list([{\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 20}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}], \\"age\\", descending=True) [{\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Charlie\', \'age\': 25}, {\'name\': \'Bob\', \'age\': 20}] >>> sort_dict_list([{\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\"}, {\\"name\\": \\"Charlie\\", \\"age\\": 25}], \\"age\\") [{\'name\': \'Charlie\', \'age\': 25}, {\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\'}] >>> sort_dict_list([{\\"name\\": \\"Alice\\"}, {\\"name\\": \\"Bob\\"}], \\"age\\") [{\'name\': \'Alice\'}, {\'name\': \'Bob\'}] >>> sort_dict_list([], \\"age\\") [] >>> sort_dict_list([{\\"name\\": \\"Charlie\\", \\"age\\": 25}, {\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Bob\\", \\"age\\": 20}], \\"name\\") [{\'name\': \'Alice\', \'age\': 30}, {\'name\': \'Bob\', \'age\': 20}, {\'name\': \'Charlie\', \'age\': 25}] The function must be robust and appropriately place dictionaries missing the sort key at the end, sorting the rest based on the specified key in the given order.","solution":"def sort_dict_list(dict_list: list, sort_key: str, descending: bool = False) -> list: Sorts a list of dictionaries based on a specified key. Places dictionaries without the key at the end of the list. :param dict_list: List of dictionaries to sort. :param sort_key: Key in the dictionaries to sort by. :param descending: If True, sort in descending order. Default is ascending. :return: Sorted list of dictionaries. # Separate dictionaries that have the sort_key from those that don\'t with_key = [d for d in dict_list if sort_key in d] without_key = [d for d in dict_list if sort_key not in d] # Sort the list with_key based on the sort_key with_key.sort(key=lambda d: d[sort_key], reverse=descending) # Return the concatenation of the sorted list and the list without the key return with_key + without_key"},{"question":"# Question: Weather Data Processing You need to create a program that fetches and processes weather data using the OpenWeatherMap API. Your program should include the following functionalities: 1. **Get current weather for a city** by accessing the appropriate endpoint. 2. **Get a 5-day weather forecast** for a city, showing daily summaries. Functional Requirements: - **Function 1**: `get_current_weather(city: str) -> dict` - `city`: A string specifying the city\'s name. - Returns a dictionary containing: ```python { \\"city\\": \\"City name\\", \\"temperature\\": Current temperature in Celsius, \\"description\\": \\"Weather description\\" } ``` - **Function 2**: `get_weather_forecast(city: str) -> list` - `city`: A string specifying the city\'s name. - Returns a list of 5 dictionaries, where each dictionary follows the format from Function 1 but represents a summarized daily forecast. Input and Output - **Input**: The functions take the city name as a parameter. - **Output**: The functions should return the expected data structures as outlined above. Constraints: - Your implementation should handle network errors gracefully, returning `None` or an empty list in case of failures. - You must use the `requests` library. - Consider network timeout by setting a timeout value of 10 seconds for your API calls. - You need to use your own API key from OpenWeatherMap. Example ```python current_weather = get_current_weather(\\"London\\") # Expected output: {\'city\': \'London\', \'temperature\': 15.0, \'description\': \'clear sky\'} forecast = get_weather_forecast(\\"London\\") # Expected output: [ # {\'city\': \'London\', \'temperature\': 15.0, \'description\': \'clear sky\'}, # {\'city\': \'London\', \'temperature\': 14.0, \'description\': \'partly cloudy\'}, # {\'city\': \'London\', \'temperature\': 16.0, \'description\': \'scattered showers\'}, # {\'city\': \'London\', \'temperature\': 17.0, \'description\': \'light rain\'}, # {\'city\': \'London\', \'temperature\': 13.0, \'description\': \'clear sky\'} # ] ``` Write the function implementations for `get_current_weather(city: str)` and `get_weather_forecast(city: str)`.","solution":"import requests API_KEY = \'your_openweather_api_key\' BASE_URL = \'http://api.openweathermap.org/data/2.5/\' def get_current_weather(city: str) -> dict: try: response = requests.get( f\\"{BASE_URL}weather\\", params={\'q\': city, \'appid\': API_KEY, \'units\': \'metric\'}, timeout=10 ) response.raise_for_status() data = response.json() return { \\"city\\": data[\\"name\\"], \\"temperature\\": data[\\"main\\"][\\"temp\\"], \\"description\\": data[\\"weather\\"][0][\\"description\\"] } except (requests.RequestException, KeyError): return None def get_weather_forecast(city: str) -> list: try: response = requests.get( f\\"{BASE_URL}forecast\\", params={\'q\': city, \'appid\': API_KEY, \'units\': \'metric\'}, timeout=10 ) response.raise_for_status() data = response.json() forecast = [] days = set() for entry in data[\'list\']: date = entry[\'dt_txt\'].split()[0] if date not in days: days.add(date) forecast.append({ \\"city\\": data[\\"city\\"][\\"name\\"], \\"temperature\\": entry[\\"main\\"][\\"temp\\"], \\"description\\": entry[\\"weather\\"][0][\\"description\\"] }) if len(forecast) >= 5: break return forecast except (requests.RequestException, KeyError): return []"},{"question":"# Flatten a Nested List Context In many coding scenarios, you may encounter nested lists (lists that contain other lists as elements). Your task in this problem is to flatten a nested list structure into a single, one-dimensional list. Task Description You need to complete the function `flatten_list` that takes a nested list as input and returns a flattened list containing all the elements from the nested list in the same order. The input nested list can contain integers and/or other lists, which in turn may contain more lists, and so on. Input - A nested list `nested` containing integers and/or other lists of arbitrary depth. Output - A single, one-dimensional list containing all the integers from the nested list, in the same order. Constraints - The function must be able to handle nested lists of any depth. - The input list and its nested lists contain only integers. - The order of elements in the flattened list must reflect their order in the input list. Examples ```python >>> flatten_list([1, [2, [3, 4], [5, 6]], 7]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_list([1, [4, [6]], 7, 8]) [1, 4, 6, 7, 8] >>> flatten_list([[1, 2, [3, 4]], 5, [6, [7, [8]]]]) [1, 2, 3, 4, 5, 6, 7, 8] ``` Complete the `flatten_list` function so that it fulfills the described requirements.","solution":"def flatten_list(nested): Flatten a nested list containing integers into a single one-dimensional list. Args: nested (list): A nested list containing integers and/or other lists. Returns: list: A flattened one-dimensional list containing all integers from the nested list. flat_list = [] for item in nested: if isinstance(item, list): flat_list.extend(flatten_list(item)) else: flat_list.append(item) return flat_list"},{"question":"# Question: Implement a Unique Character Substring Finder Scenario: You are working for a company that analyzes large chunks of text data. Your current task is to identify substrings within a given string that contain all unique characters. This feature is essential for some analyses that focus on identifying specific patterns within texts. Task: Write a function `unique_char_substr(text: str) -> int`, which finds the length of the longest substring in the given string that consists of all unique characters. Function Signature: ```python def unique_char_substr(text: str) -> int: pass ``` Input: * `text` (str): A string comprised of ASCII characters. Output: * Returns: An integer representing the length of the longest substring with all unique characters. Constraints: * The input string `text` can have a length up to 10^5. * Substrings are contiguous sequences of characters within the main string. Example: ```python >>> unique_char_substr(\\"abcabcbb\\") 3 >>> unique_char_substr(\\"bbbbb\\") 1 >>> unique_char_substr(\\"pwwkew\\") 3 >>> unique_char_substr(\\"abcdef\\") 6 ``` Hints: * Consider using a sliding window technique to efficiently find the longest substring with unique characters. * Use a data structure like a set to keep track of characters within the current window.","solution":"def unique_char_substr(text: str) -> int: Finds the length of the longest substring in the given string that consists of all unique characters. :param text: A string comprised of ASCII characters. :return: An integer representing the length of the longest substring with all unique characters. char_set = set() left = 0 max_length = 0 for right in range(len(text)): while text[right] in char_set: char_set.remove(text[left]) left += 1 char_set.add(text[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Check If Graph Is Bipartite Given an undirected graph, determine if the graph is bipartite. A bipartite graph is one whose vertices can be divided into two independent sets, U and V such that every edge (u, v) either connects a vertex from U to V or a vertex from V to U. # Function Specifications Your task is to implement a function `is_bipartite` which contains the following method: - `is_bipartite(graph: List[List[int]]) -> bool`: Takes a graph represented as a list of adjacency lists and returns `True` if the graph is bipartite and `False` otherwise. # Constraints * The number of vertices in the graph will be less than 1000. * The graph might be disconnected. * The adjacency lists will contain vertex indices ranging from 0 to n-1 where n is the number of vertices. # Example ```python # Example 1 graph = [ [1, 3], [0, 2], [1, 3], [0, 2] ] assert is_bipartite(graph) == True # This graph is bipartite # Example 2 graph = [ [1, 2, 3], [0, 2], [0, 1, 3], [0, 2] ] assert is_bipartite(graph) == False # This graph is not bipartite # Example 3 graph = [ [1], [0, 3], [3], [1, 2] ] assert is_bipartite(graph) == True # This graph is bipartite ``` # Notes * The function should handle graphs with multiple components. * Consider using a queue or two-coloring strategy to determine if the graph is bipartite. * Pay attention to edge cases such as empty graphs or single-node graphs.","solution":"from typing import List from collections import deque def is_bipartite(graph: List[List[int]]) -> bool: Determines if the given undirected graph is bipartite. if not graph: return True n = len(graph) colors = [-1] * n # -1 indicates uncolored, 0 and 1 will be used for two colors for i in range(n): if colors[i] == -1: # Node i has not been colored yet queue = deque([i]) colors[i] = 0 # Start coloring node i with color 0 while queue: node = queue.popleft() current_color = colors[node] for neighbor in graph[node]: if colors[neighbor] == -1: colors[neighbor] = 1 - current_color # Assign opposite color to neighbor queue.append(neighbor) elif colors[neighbor] == current_color: return False # Found a conflict in colors return True"},{"question":"# Problem Statement You are given a list of integers representing a series of temperature records from a monitoring station. Your task is to write a function, `find_longest_increasing_subsequence`, that computes the length of the longest strictly increasing subsequence in the given list. # Function Signature ```python def find_longest_increasing_subsequence(temps: list[int]) -> int: ``` # Input - `temps`: List of integers representing daily temperature readings. Length of the list (n) will be between 0 and 10^4 inclusive. # Output - Returns an integer representing the length of the longest strictly increasing subsequence in the list. # Examples ```python assert find_longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert find_longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert find_longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 assert find_longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 10 assert find_longest_increasing_subsequence([]) == 0 assert find_longest_increasing_subsequence([10, 20, 10, 30, 10, 40, 10, 50]) == 5 ``` # Constraints & Notes - If the list is empty, the result should be 0. - Ensure to find strictly increasing subsequence. - Consider utilizing dynamic programming or patience sorting techniques for efficiency. - Aim for a solution with a time complexity of O(n log n) if possible and space complexity of O(n).","solution":"def find_longest_increasing_subsequence(temps): if not temps: return 0 # List to store the longest increasing subsequence found so far subseq = [] # Iterate through each temperature in the list for temp in temps: # Use binary search to find the position where `temp` should be inserted left, right = 0, len(subseq) while left < right: mid = (left + right) // 2 if subseq[mid] < temp: left = mid + 1 else: right = mid # If `temp` is larger than any element in `subseq`, append it if right >= len(subseq): subseq.append(temp) else: # Otherwise, replace the first element that is not less than `temp` subseq[right] = temp # The length of the subseq list is the length of the longest increasing subsequence return len(subseq)"},{"question":"# Task: You are required to implement a function that finds the nth number in a specific pattern sequence. The sequence follows this logic: Start with the number 1, and add the previous number in the sequence to itself, then add 1 every time you move to a new number. For example, the pattern starts with 1, then the next number is 2 (1 + 1), then 3 (2 + 1), then 4 (3 + 1), and so on. # Task: Write a function `find_nth_number_in_pattern` that takes an integer `n` and returns the nth number in this pattern sequence. # Specifications: * **Input**: A single integer `n` (1 ≤ n ≤ 10^6). * **Output**: An integer representing the nth number in the pattern sequence. # Requirements: * Your function must handle large inputs efficiently. * Avoid unnecessary calculations by leveraging arithmetic properties. * Minimize the use of loop constructs to ensure optimal performance. # Example: ```python def find_nth_number_in_pattern(n: int) -> int: pass # Example Usage: # find_nth_number_in_pattern(1) should return 1 # find_nth_number_in_pattern(5) should return 5 # find_nth_number_in_pattern(10) should return 10 ``` # Constraints: * Focus on time complexity. * Ensure the use of efficient arithmetic operations to compute the nth number directly.","solution":"def find_nth_number_in_pattern(n: int) -> int: Returns the nth number in the pattern sequence. # Since the sequence is linear and each number is simply (index + 1), # we can directly return n as the nth number in the sequence. return n"},{"question":"# Problem Statement **Binary Tree Tilt Calculation** You are given the root of a binary tree. A node\'s tilt is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. The tilt of the whole tree is the sum of all node tilts. # Task Write a function `findTilt` that takes the root of a binary tree and returns the tilt of the whole tree. # Input Format * The input is given as a binary tree node where each node has the attributes `val`, `left`, and `right`. # Output Format * An integer representing the tilt of the whole tree. # Definition for a binary tree node ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Example *Example 1:* Given the following binary tree: ``` 1 / 2 3 ``` Input: ``` root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) ``` Output: ``` 1 ``` Explanation: ``` Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of the whole tree is 0 + 0 + 1 = 1 ``` *Example 2:* Given the following binary tree: ``` 4 / 2 9 / 3 5 7 ``` Input: ``` root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(9) root.left.left = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(7) ``` Output: ``` 15 ``` Explanation: ``` Tilt of node 3 : 0 Tilt of node 5 : 0 Tilt of node 7 : 0 Tilt of node 2 : |3-5| = 2 Tilt of node 9 : |0-7| = 7 Tilt of node 4 : |10-16| = 6 Tilt of the whole tree = 0 + 0 + 0 + 2 + 7 + 6 = 15 ``` # Notes * You can assume the tree will have at least one node. * The function should handle large and imbalanced trees efficiently. Implement the `findTilt` function as specified: ```python def findTilt(root: TreeNode) -> int: pass ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findTilt(root): Calculate the tilt of the entire binary tree. :param root: TreeNode, the root of the binary tree. :return: int, the tilt of the tree. def traverse(node): if not node: return 0, 0 left_sum, left_tilt = traverse(node.left) right_sum, right_tilt = traverse(node.right) node_tilt = abs(left_sum - right_sum) total_tilt = left_tilt + right_tilt + node_tilt total_sum = node.val + left_sum + right_sum return total_sum, total_tilt _, total_tilt = traverse(root) return total_tilt"},{"question":"**Question:** Given a binary tree, implement a function to flatten it to a pseudo linked list in place. The \\"linked list\\" should use the same TreeNode class where the right pointer points to the next node in the list and the left pointer is always null. The linked list should be in the same order as a pre-order traversal of the binary tree. # Task: Implement the function `flatten_binary_tree` that takes the root of the binary tree as its argument and flattens the tree in-place to a linked list. # Input: - **Type**: TreeNode - **Description**: The root node of the binary tree. # Output: - **Return Type**: None - **Description**: You do not need to return anything. Modify the tree in-place. # TreeNode Class Definition: The TreeNode class is defined as follows: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Example: 1. Given the binary tree: ``` 1 / 2 5 / 3 4 6 ``` After calling `flatten_binary_tree(root)`, the tree should be flattened to: ``` 1 2 3 4 5 6 ``` 2. Given the binary tree: ``` 1 / 2 3 / 4 5 / 6 7 8 ``` After calling `flatten_binary_tree(root)`, the tree should be flattened to: ``` 1 2 4 6 3 5 7 8 ``` # Constraints and Notes: - The given binary tree will have at most 100 nodes. - You must perform the flattening in-place without using any extra space for storing nodes (other than the function call stack). # Function Signature: ```python def flatten_binary_tree(root: TreeNode) -> None: # implement the function here ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def flatten_binary_tree(root: TreeNode) -> None: Flattens the binary tree to a pseudo linked list in pre-order traversal order. Modifies the tree in-place. if not root: return def flatten(node): # Base case if not node: return None left_tail = flatten(node.left) right_tail = flatten(node.right) if node.left: if left_tail: left_tail.right = node.right node.right = node.left node.left = None return right_tail if right_tail else (left_tail if left_tail else node) flatten(root)"},{"question":"# Problem Statement Write a function to calculate the maximum profit that can be made by performing at most `k` transactions on a list of stock prices, where each transaction consists of buying one unit of stock and selling one unit of stock on later days. You are not allowed to engage in multiple transactions simultaneously (you must sell the stock before you buy again). # Function Signature ```python def max_profit_with_k_transactions(prices: list[int], k: int) -> int: pass ``` # Input - `prices`: A list of integers where the `i-th` element represents the stock price on the `i-th` day. - `k`: An integer representing the maximum number of transactions allowed. # Output - Return the maximum profit that can be achieved by performing at most `k` buy-sell transactions. # Constraints - 1 ≤ len(prices) ≤ 1000 - 0 ≤ prices[i] ≤ 10000 - 0 ≤ k ≤ 100 # Example ```python prices = [3, 2, 6, 5, 0, 3] k = 2 output = max_profit_with_k_transactions(prices, k) # Expected output: 7 # Explanation: # Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. # Buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. # Total profit = 4 + 3 = 7. ``` # Implementation Details - Make use of dynamic programming to solve the problem efficiently. - Create a 2-dimensional table where `dp[i][j]` represents the maximum profit achievable with `i` transactions by day `j`. - Update the table iteratively by considering the scenarios of making a transaction on each specific day and keeping track of the best profit possible.","solution":"def max_profit_with_k_transactions(prices, k): Calculate the maximum profit that can be made with at most k transactions. :param prices: List[int] - list of stock prices :param k: int - maximum number of transactions allowed :return: int - maximum profit achievable if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: # In this scenario, we can conduct unlimited number of transactions return sum(max(prices[i] - prices[i-1], 0) for i in range(1, n)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[-1][-1]"},{"question":"# Problem Description You are tasked with developing a function to simulate a network of nodes and find the shortest path between two given nodes. The network is represented using an adjacency matrix where each value denotes the weight of the edge between nodes. If there is no edge between two nodes, the weight is represented by a large number (indicating infinity). # Input - An integer `n` representing the number of nodes. - A 2D list `graph` representing the adjacency matrix of size `n x n`, where `graph[i][j]` denotes the weight from node `i` to node `j`. - Two integers `start` and `end` representing the starting node and the ending node, respectively. # Output - Return a tuple `(shortest_distance, path)` where: - `shortest_distance` is an integer representing the shortest distance from the starting node to the ending node. - `path` is a list of integers showing the sequence of nodes forming the shortest path from `start` to `end`. # Constraints - 2 ≤ n ≤ 100 - 0 ≤ graph[i][j] ≤ 1000 for all valid i, j - The input graph is guaranteed to be non-negative. - The starting and ending nodes are distinct and valid within the range. # Example ```python def find_shortest_path(n, graph, start, end): # Implementation goes here pass # Example Usage n = 4 graph = [ [0, 5, 999, 10], [999, 0, 3, 999], [999, 999, 0, 1], [999, 999, 999, 0] ] start, end = 0, 3 shortest_distance, path = find_shortest_path(n, graph, start, end) print(shortest_distance) # Expected Output: 8 print(path) # Expected Output: [0, 1, 2, 3] ``` # Notes 1. Use Dijkstra\'s algorithm to solve the problem efficiently. 2. Ensure the output path is the actual sequence of nodes traversed to achieve the shortest distance. 3. Your implementation should account for the possible presence of unreachable nodes.","solution":"import heapq def find_shortest_path(n, graph, start, end): Uses Dijkstra\'s algorithm to find the shortest path from start to end node in a graph. Parameters: n (int): Number of nodes. graph (list): 2D list representing the adjacency matrix of the graph. start (int): Starting node. end (int): Ending node. Returns: tuple: (shortest_distance, path) # Initialize distances and parent pointers distances = [float(\'inf\')] * n distances[start] = 0 parents = [None] * n # Priority queue to store (current_distance, node) priority_queue = [(0, start)] heapq.heapify(priority_queue) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reached the end node, we can reconstruct the path if current_node == end: break # Explore neighbors for neighbor in range(n): weight = graph[current_node][neighbor] if weight < float(\'inf\'): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance parents[neighbor] = current_node heapq.heappush(priority_queue, (distance, neighbor)) # Reconstruct the path from start to end path = [] current = end if distances[end] < float(\'inf\'): # if end is reachable while current is not None: path.insert(0, current) current = parents[current] return distances[end], path"},{"question":"# Problem: Implement a Custom Pow Function You are building a mathematical library and need to implement the power function that raises a number to a specific power. Your function should handle positive and negative exponents efficiently. Function Signature ```python def custom_pow(base: float, exponent: int) -> float: ... ``` Input * The function takes two arguments: * `base` (float): A real number where -100 ≤ `base` ≤ 100 * `exponent` (int): An integer where -1,000 ≤ `exponent` ≤ 1,000 Output * The function should return a float, which is the result of raising `base` to the power of `exponent`. Constraints * Avoid using the built-in `pow` function. * The output values should be accurate within 0.000001 of the true value for positive bases. * Time complexity should be O(log n), where n is the absolute value of the exponent. * Handle special cases such as exponent = 0, base = 0, and negative exponents properly. # Example ```python assert custom_pow(2, 3) == 8 assert custom_pow(5, -2) == 0.04 assert custom_pow(3, 0) == 1 assert custom_pow(0, 4) == 0 ``` Explanation: For `custom_pow(2, 3)`: - ( 2^3 = 8 ) For `custom_pow(5, -2)`: - ( 5^{-2} = frac{1}{5^2} = 0.04 ) For `custom_pow(3, 0)`: - Any number raised to the power of 0 is 1. For `custom_pow(0, 4)`: - 0 raised to any positive power is 0. Use an efficient algorithm such as Exponentiation by Squaring to calculate the result. This approach reduces the number of multiplications needed and ensures the function runs in logarithmic time relative to the exponent.","solution":"def custom_pow(base: float, exponent: int) -> float: Custom implementation of the power function that raises a number to a specific power. if exponent == 0: return 1.0 if base == 0: return 0.0 def power(x: float, n: int) -> float: if n == 0: return 1.0 half = power(x, n // 2) if n % 2 == 0: return half * half else: return half * half * x result = power(base, abs(exponent)) return result if exponent > 0 else 1 / result"},{"question":"# Coding Assessment Question - 2 Context: You are provided with a simplified graph class that can store an unweighted, undirected graph using an adjacency list representation. The `Graph` class includes methods to add nodes, add edges, and retrieve the adjacent nodes of a given node. Task: Implement a method named `find_shortest_path` within the `Graph` class, which calculates the shortest path between two nodes using the Breadth-First Search (BFS) algorithm. The method should return a list of nodes representing the path from the start node to the end node, inclusive. If no path exists, return an empty list. Expected Input and Output Formats: Function signature: ```python class Graph: ... def find_shortest_path(self, start: int, end: int) -> typing.List[int]: # your implementation here ``` - **Input**: - `start` (int) - The starting node of the path. - `end` (int) - The destination node of the path. - **Output**: A list of integer nodes representing the shortest path from `start` to `end`. Constraints and Assumptions: - Nodes are represented by unique integers. - There are no duplicate edges. - The graph is connected; if a path exists, it can be found. - The graph is unweighted; the shortest path is the one with the fewest edges. - Assume all node identifiers provided are valid and exist in the graph. Example Usage: ```python g = Graph() g.add_node(1) g.add_node(2) g.add_node(3) g.add_node(4) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 4) g.add_edge(1, 4) print(g.find_shortest_path(1, 4)) # Output: [1, 4] print(g.find_shortest_path(1, 3)) # Output: [1, 2, 3] ``` Example Implementation: ```python import collections from typing import List, Dict, Set class Graph: def __init__(self): self.adjacency_list: Dict[int, Set[int]] = collections.defaultdict(set) def add_node(self, node: int) -> None: self.adjacency_list[node] def add_edge(self, node1: int, node2: int) -> None: self.adjacency_list[node1].add(node2) self.adjacency_list[node2].add(node1) def get_adjacent_nodes(self, node: int) -> Set[int]: return self.adjacency_list[node] def find_shortest_path(self, start: int, end: int) -> List[int]: if start == end: return [start] queue = collections.deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in self.get_adjacent_nodes(current_node): if neighbor == end: return path + [end] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] # if no path found # Example Usage g = Graph() g.add_node(1) g.add_node(2) g.add_node(3) g.add_node(4) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 4) g.add_edge(1, 4) print(g.find_shortest_path(1, 4)) # Output: [1, 4] print(g.find_shortest_path(1, 3)) # Output: [1, 2, 3] ``` **Note**: Ensure your implementation effectively uses the Breadth-First Search algorithm to guarantee finding the shortest path in an unweighted graph.","solution":"import collections from typing import List, Dict, Set class Graph: def __init__(self): self.adjacency_list: Dict[int, Set[int]] = collections.defaultdict(set) def add_node(self, node: int) -> None: self.adjacency_list[node] def add_edge(self, node1: int, node2: int) -> None: self.adjacency_list[node1].add(node2) self.adjacency_list[node2].add(node1) def get_adjacent_nodes(self, node: int) -> Set[int]: return self.adjacency_list[node] def find_shortest_path(self, start: int, end: int) -> List[int]: if start == end: return [start] queue = collections.deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in self.get_adjacent_nodes(current_node): if neighbor == end: return path + [end] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] # if no path found"},{"question":"# Problem Statement: You are given a string `expression` consisting of lowercase letters, digits, and parentheses. A valid string is one where every opening parenthesis has a corresponding closing parenthesis and they are nested correctly. Your task is to implement the `is_valid_expression` function that determines whether the given string is a valid expression or not. # Function Signature: ```python def is_valid_expression(expression: str) -> bool: pass ``` # Input: - `expression`: a string (1 <= len(expression) <= 10^5) # Output: - A boolean value `True` if the expression is valid, `False` otherwise. # Example: ```python assert is_valid_expression(\\"a(b)c\\") == True assert is_valid_expression(\\"((123))\\") == True assert is_valid_expression(\\"a(b)c)\\") == False assert is_valid_expression(\\"(((1)\\") == False ``` # Constraints: - The function should handle strings up to length `10^5` efficiently. # Considerations: - Ensure to iterate through the string only once for optimal performance. - Use a stack data structure to keep track of the parentheses for efficient matching. - Ensure your solution handles all edge cases, such as empty strings or strings with no parentheses at all. Explanation: The function should iterate over the string and handle parentheses checking using a stack. Whenever an opening parenthesis is encountered, it should be pushed onto the stack. When a closing parenthesis is encountered, the stack should be checked to ensure it has a matching opening parenthesis to pop. If any mismatch is found or if the stack is not empty at the end, the string is not a valid expression.","solution":"def is_valid_expression(expression: str) -> bool: Determines whether the given string `expression` is a valid expression or not. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"# Coding Assessment Question Scenario You have been employed as a software engineer at a logistics company. One of the routine operations involves processing orders and calculating the shipping costs. The shipping cost is determined by the type and quantity of items in an order. There are different shipping rates for different item categories, and bulk orders have a discounted rate. You need to write a function to compute the shipping cost for a given list of orders. Task Implement a function `calculate_shipping_cost` that computes the total shipping cost for all ordered items given their quantities and categories. The categories and corresponding rates are as follows: - \'standard\': 5 per item - \'express\': 10 per item - \'bulk-standard\': 4 per item - \'bulk-express\': 8 per item Bulk rates apply when the quantity of any item is 10 or more. Function Signature ```python def calculate_shipping_cost(orders: List[Tuple[str, int]]) -> int: ``` Input * `orders (List[Tuple[str, int]])`: A list of tuples where each tuple contains a string representing the item category and an integer representing the quantity of items ordered. Output * Returns the total shipping cost (int) computed based on the given orders. Constraints * Each order contains a valid category string and a non-negative integer quantity. * The order list is non-empty, and at least one item exists. Example ```python You have the following list of orders: [(\'standard\', 5), (\'express\', 2), (\'bulk-standard\', 12), (\'bulk-express\', 20)] The shipping cost breakdown should be: - 5 \'standard\' items at 5 each: 5 * 5 = 25 - 2 \'express\' items at 10 each: 2 * 10 = 20 - 12 \'bulk-standard\' items at 4 each: 12 * 4 = 48 - 20 \'bulk-express\' items at 8 each: 20 * 8 = 160 The function call should return the total shipping cost, which is 25 + 20 + 48 + 160 = 253. orders = [(\'standard\', 5), (\'express\', 2), (\'bulk-standard\', 12), (\'bulk-express\', 20)] total_cost = calculate_shipping_cost(orders) print(total_cost) # Output should be 253 ``` Notes * Ensure to handle edge cases, specifically orders with zero quantities. * Focus on clarity and efficiency in developing the solution.","solution":"from typing import List, Tuple def calculate_shipping_cost(orders: List[Tuple[str, int]]) -> int: Computes the total shipping cost for the given list of orders. Args: orders (List[Tuple[str, int]]): A list of tuples where each tuple contains a string representing the item category and an integer representing the quantity of items ordered. Returns: int: Total shipping cost. total_cost = 0 rates = { \'standard\': 5, \'express\': 10, \'bulk-standard\': 4, \'bulk-express\': 8 } for category, quantity in orders: if quantity >= 10: if category == \'standard\': rate = rates[\'bulk-standard\'] elif category == \'express\': rate = rates[\'bulk-express\'] else: rate = rates[category] else: rate = rates[category] total_cost += rate * quantity return total_cost"},{"question":"# Question You are tasked with creating a scheduling algorithm for a set of competing events at a conference. Each event has a fixed start time and end time, and due to resource constraints, no two events can overlap. Your goal is to implement a function that schedules the maximum number of non-overlapping events. Function Specification ```python def maximum_non_overlapping_events(events: list[tuple[int, int]]) -> list[tuple[int, int]]: Finds the maximum number of non-overlapping events from the given list of events. Each event is represented as a tuple with a start and end time. The function returns a list of events that can be attended without any time conflicts. ``` # Input * `events`: A list of tuples where each tuple `(start_time, end_time)` represents an event with a fixed start and end time. The `start_time` and `end_time` are integers representing the time in a 24-hour format (e.g., `0` to `1439` for minutes in a day). # Output * A list of tuples representing the maximum set of non-overlapping events that can be attended. # Constraints * `1 ≤ len(events) ≤ 10^4` - The number of events is constrained between 1 and 10,000. * For any tuple `(start_time, end_time)`, it holds that `0 ≤ start_time < end_time ≤ 1439`. # Example ```python events = [(1, 4), (2, 5), (3, 8), (10, 12), (9, 11)] print(maximum_non_overlapping_events(events)) # Output: [(1, 4), (10, 12)] ``` # Performance Requirements Your implementation should aim for an O(n log n) time complexity to handle the upper limit of inputs efficiently. Explanation: In the example given: 1. The first event starts at time 1 and ends at time 4. 2. The second event starts at time 2 and ends at time 5. 3. The third event starts at time 3 and ends at time 8. 4. The fourth event starts at time 10 and ends at time 12. 5. The fifth event starts at time 9 and ends at time 11. By choosing the first event `(1, 4)` and the fourth event `(10, 12)`, you can attend two non-overlapping events. The algorithm ensures that the function returns the maximum possible number of non-overlapping events.","solution":"def maximum_non_overlapping_events(events): Finds the maximum number of non-overlapping events from the given list. Each event is represented as a tuple with a start and end time. The function returns a list of events that can be attended without conflicts. # Sort events by their end time sorted_events = sorted(events, key=lambda x: x[1]) # List to store the maximum set of non-overlapping events max_events = [] # End time of the last added event last_end_time = -1 for start, end in sorted_events: if start >= last_end_time: max_events.append((start, end)) last_end_time = end return max_events"},{"question":"# Problem Statement A Fibonacci-like sequence is defined such that each term in the sequence (starting from the third term) is the sum of the previous three terms. The first three terms of the sequence are given as 0, 1, and 1. For example, the sequence starts as 0, 1, 1, 2, 4, 7, 13, and so on. Write a function `find_fibonacci_like_sequence` that takes an integer `n` as input and returns a list of the first `n` terms of this Fibonacci-like sequence. The function should handle edge cases, such as when `n` is zero or negative gracefully by returning an empty list in such cases. If `n` is not an integer, raise a `TypeError` with an appropriate message. Input Format - An integer `n` which represents the number of terms to generate in the Fibonacci-like sequence. Output Format - A list containing the first `n` terms of the Fibonacci-like sequence. Constraints - The function should be efficient and handle up to large values of `n` within practical limits. Example ```python assert find_fibonacci_like_sequence(5) == [0, 1, 1, 2, 4] assert find_fibonacci_like_sequence(0) == [] assert find_fibonacci_like_sequence(-1) == [] assert find_fibonacci_like_sequence(3) == [0, 1, 1] assert find_fibonacci_like_sequence(7) == [0, 1, 1, 2, 4, 7, 13] ```","solution":"def find_fibonacci_like_sequence(n): Returns the first n terms of a Fibonacci-like sequence, where each term is the sum of the previous three terms. :param n: Integer, the number of terms to generate :return: List of the first n terms of the sequence if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n <= 0: return [] # Starting terms of the sequence sequence = [0, 1, 1] # Generate the sequence until it contains n terms for i in range(3, n): next_term = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_term) return sequence[:n]"},{"question":"# Coding Assessment Question: Scenario: As a part of a software engineering team, you are tasked with building a feature that validates user passwords against a set of security guidelines. The guidelines ensure that passwords are strong enough by meeting several criteria. Task: Write a function `validate_password(password)` that checks if the provided password meets the following criteria: - It must be at least 8 characters long. - It must have at least one lowercase letter. - It must have at least one uppercase letter. - It must have at least one digit. - It must have at least one special character from the set `!@#%^&*()-+`. Function Specifications: 1. **Function**: validate_password - **Input**: - `password` (str): The password string to be validated. - **Output**: - (bool): Returns `True` if the password is valid according to the criteria; `False` otherwise. Constraints: - `1 <= len(password) <= 100` - Passwords may contain any printable ASCII characters. # Example: ```python password_1 = \\"Passw0rd!\\" is_valid_1 = validate_password(password_1) print(is_valid_1) # Output: True password_2 = \\"Password\\" is_valid_2 = validate_password(password_2) print(is_valid_2) # Output: False (no digit, no special character) ``` **Note**: Your solution should correctly handle various edge cases such as very short passwords, passwords with only special characters, or passwords missing one or more required categories. Ensure your function is efficient and covers all the specified requirements.","solution":"import re def validate_password(password): Validates a password based on the following criteria: - It must be at least 8 characters long. - It must have at least one lowercase letter. - It must have at least one uppercase letter. - It must have at least one digit. - It must have at least one special character from the set !@#%^&*()-+. if len(password) < 8: return False if not re.search(\\"[a-z]\\", password): return False if not re.search(\\"[A-Z]\\", password): return False if not re.search(\\"[0-9]\\", password): return False if not re.search(\\"[!@#%^&*()-+]\\", password): return False return True"},{"question":"# Bubble Sort Implementation As a computer science student, you are given the task to implement the bubble sort algorithm. Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted. The algorithm gets its name because smaller elements \\"bubble\\" to the top of the list. Write a function `bubble_sort(arr: List[int]) -> List[int]` that takes a list of integers and sorts them in ascending order using the bubble sort algorithm. Input - `arr`: A list of integers of length `n` where `1 <= n <= 1000` and `-10^6 <= arr[i] <= 10^6`. Output - Return the sorted list in ascending order. Example ```python >>> bubble_sort([5, 1, 4, 2, 8]) [1, 2, 4, 5, 8] >>> bubble_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> bubble_sort([1]) [1] >>> bubble_sort([5, 5, 3]) [3, 5, 5] ``` Constraints - The list will have at least one integer and at most 1000 integers. Notes - You should manually implement the bubble sort algorithm without using built-in sort functions. - Consider the efficiency of your implementation, even though bubble sort is not the most efficient sorting algorithm for large datasets. Your implementation should ensure correctness and handle typical input scenarios efficiently.","solution":"def bubble_sort(arr): Sorts a list of integers in ascending order using the bubble sort algorithm. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list in ascending order. n = len(arr) for i in range(n): # Flag to detect whether any elements were swapped during this pass swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: # Swap elements if they are in the wrong order arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True # If no elements were swapped, the list is already sorted if not swapped: break return arr"},{"question":"# Problem Statement: You are given a matrix of integers where each row is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Implement a function that searches for a given target value in the matrix. If the target exists in the matrix, return its coordinates (row, column); otherwise, return (-1, -1). # Function Signature: ```python def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: pass ``` # Input: - `matrix` (List[List[int]]): A 2D list of integers, where each row and each column is sorted. - `target` (int): The integer value to search for. # Output: - (Tuple[int, int]): A tuple of two integers representing the row and column of the target in the matrix. If the target is not found, return (-1, -1). # Constraints: - The number of rows and columns of the matrix is at most 1000. - Each element in the matrix is distinct. - The matrix contains only integers. # Performance Requirements: - Your solution should use a logarithmic approach to achieve better performance. # Examples: ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) == (1, 1) assert search_matrix(matrix, 20) == (-1, -1) ``` # Explanation of the Examples: - The target value 5 is located at coordinates (1, 1). - The target value 20 is not found in the matrix, so the function returns (-1, -1). # Additional Notes: - To optimize the search, you can start from the top right or bottom left corner of the matrix and eliminate rows or columns based on comparison with the target. - Ensure that your solution handles edge cases such as an empty matrix or targets outside the matrix bounds effectively.","solution":"from typing import List, Tuple def search_matrix(matrix: List[List[int]], target: int) -> Tuple[int, int]: if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Coding Assessment Question Context You have been asked to develop a solution for employees\' age-based categorization for a company\'s administration system. Given a list of employees\' ages, you need to count how many employees fall within specified age brackets. Task Write a function `age_categorization(ages: List[int], age_brackets: List[Tuple[int, int]]) -> List[int]` that takes a list of integers representing employees\' ages, and a list of tuples where each tuple specifies an inclusive age bracket (start_age, end_age). The function should return a list where each element corresponds to the count of employees that fall within each respective age bracket. Input * `ages`, a list of integers where each integer (0 ≤ age ≤ 120) represents an employee\'s age. * `age_brackets`, a list of tuples where each tuple `(start_age, end_age)` (0 ≤ start_age ≤ end_age ≤ 120) represents an inclusive age bracket. Output * A list of integers where each integer is the count of employees falling within each respective age bracket specified in `age_brackets`. # Sample Input 1 ```python ages = [23, 29, 34, 42, 47, 51, 56, 60, 61, 78, 83, 85] age_brackets = [(20, 30), (31, 40), (41, 50), (51, 60), (61, 70), (71, 80), (81, 90)] ``` # Sample Output 1 ```python [2, 1, 2, 3, 2, 1, 2] ``` # Explanation The employees\' ages are categorized as follows: - `(20, 30)`: 23, 29 (count = 2) - `(31, 40)`: 34 (count = 1) - `(41, 50)`: 42, 47 (count = 2) - `(51, 60)`: 51, 56, 60 (count = 3) - `(61, 70)`: 61 (count = 1) - `(71, 80)`: 78 (count = 1) - `(81, 90)`: 83, 85 (count = 2) # Constraints * The number of ages in `ages` can be up to 10^5. * The number of age brackets in `age_brackets` can be up to 100. # Edge Cases * If all employees fall outside all age brackets. * If `ages` is empty. * If `age_brackets` contain very narrow or very broad ranges. Function Signature ```python from typing import List, Tuple def age_categorization(ages: List[int], age_brackets: List[Tuple[int, int]]) -> List[int]: pass # Implement a function that fulfills the conditions mentioned in the task statement. ```","solution":"from typing import List, Tuple def age_categorization(ages: List[int], age_brackets: List[Tuple[int, int]]) -> List[int]: Categorize the ages into the given age brackets. Parameters: ages (List[int]): List of employees\' ages. age_brackets (List[Tuple[int, int]]): List of tuples where each tuple specifies an inclusive age bracket (start_age, end_age). Returns: List[int]: A list where each element is the count of employees in each age bracket. # Initialize the count list with zeros for each age bracket counts = [0] * len(age_brackets) # Loop over each age and increment the appropriate bracket count for age in ages: for i, (start_age, end_age) in enumerate(age_brackets): if start_age <= age <= end_age: counts[i] += 1 break # Once counted, no need to check further brackets for this age return counts"},{"question":"**Network Delay Time** Given a network of `N` nodes labeled from `1` to `N`, and a list of times represented by a list of tuples, where each tuple `(u, v, w)` represents a directed edge from node `u` to node `v` with transmission time `w`, your task is to calculate the time it will take for all nodes to receive a signal from a given starting node `K`. Your function should return the minimum time it takes for all nodes to receive the signal. If it\'s impossible for all nodes to receive the signal, return `-1`. # Constraints: - The integer `N` is between `1` and `100`. - The starting node `K` is between `1` and `N`. - The directed edge list `times` has at most `6000` edges. - The transmission time `w` is a positive integer. # Example: ```python def network_delay_time(times: list[tuple[int, int, int]], N: int, K: int) -> int: pass # Example 1 print(network_delay_time([(2, 1, 1), (2, 3, 1), (3, 4, 1)], 4, 2)) # Output: 2 # Example 2 print(network_delay_time([(1, 2, 1), (2, 3, 2), (1, 3, 2)], 3, 1)) # Output: 2 # Example 3 print(network_delay_time([(1, 2, 1), (2, 3, 2), (3, 4, 1)], 4, 1)) # Output: 4 # Example 4 print(network_delay_time([(1, 2, 1), (2, 3, 2)], 4, 1)) # Output: -1 ``` # Notes: - You are expected to implement the `network_delay_time` function. - Aim for clarity, efficiency, and correctness in your solution. - Consider edge cases and optimize where necessary.","solution":"import heapq def network_delay_time(times, N, K): Computes the time it takes for all nodes to receive the signal starting from node K. Returns -1 if it is impossible for all nodes to receive the signal. :param times: List of tuples, where each (u, v, w) represents a directed edge from node u to node v with weight w :param N: Total number of nodes in the network :param K: Starting node :return: Minimum time for all nodes to receive the signal or -1 if not all nodes can receive the signal # Create adjacency list graph = {i: [] for i in range(1, N + 1)} for u, v, w in times: graph[u].append((v, w)) # Min-heap to extract the node with the smallest time heap = [(0, K)] # (time, node) dist = {} while heap: time, node = heapq.heappop(heap) if node in dist: continue dist[node] = time for neighbor, weight in graph[node]: if neighbor not in dist: heapq.heappush(heap, (time + weight, neighbor)) if len(dist) == N: return max(dist.values()) return -1"},{"question":"# Binary Tree Level Order Traversal Problem Statement: You are given a binary tree and your task is to implement a function that conducts a level order traversal (breadth-first traversal) of the tree. Task: 1. Implement the `level_order_traversal` function to traverse the given binary tree. 2. Return a list of lists, where each internal list contains the values of nodes at a specific level from left to right. Expected Function Signature: ```python def level_order_traversal(root: TreeNode) -> list[list[int]]: ``` Example: ```python # Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Create binary tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) result = level_order_traversal(root) print(result) # Output should be [[3], [9, 20], [15, 7]] ``` Constraints: 1. The number of nodes in the tree is in the range [0, 2000]. 2. The tree nodes will contain integer values. Hint: You may use a queue to implement the level order traversal.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root: TreeNode) -> list[list[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_values = [] for _ in range(level_size): node = queue.popleft() level_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_values) return result"},{"question":"# Problem Statement **Objective**: Write a function that determines if it is possible to complete all courses given the prerequisites using the topological sorting algorithm. You are provided with the number of courses and a list of prerequisite pairs. Each pair specifies a course that you must complete before you can take the given course. Your task is to return `True` if it is possible to complete all courses, otherwise return `False`. # Function Signature ```python def can_finish_courses(num_courses: int, prerequisites: List[Tuple[int, int]]) -> bool: pass ``` # Input - **num_courses** (int): The total number of courses. - **prerequisites** (List[Tuple[int, int]]): The list of prerequisite pairs (course, prerequisite). # Output - Returns a boolean value (bool) indicating whether all courses can be completed. # Constraints - The number of courses, num_courses, is in the range [1, 2000]. - The number of prerequisite pairs, E, is in the range [0, 5000]. - Each pair (a, b) in prerequisites implies you must complete course `b` before course `a`. # Example ```python num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2)] # Output # True # Explanation: # To complete course 1, you need to complete course 0 first. # To complete course 2, you need to complete course 1. # To complete course 3, you need to complete course 2. # There is a possible way to complete all courses following the order: [0, 1, 2, 3]. num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2), (1, 3)] # Output # False # Explanation: # There is no way to complete all courses because course 1 depends on course 3, # which in turn depends on course 2, which depends on course 1. This forms a cycle. ``` # Notes 1. If there are no prerequisites, it is trivially possible to complete all courses. 2. The graph representation used is a Directed Acyclic Graph (DAG) if there are no cycles. 3. Consider edge cases, such as when the number of courses is 1 or when there are no prerequisite pairs. # Additional Requirements - Include detailed docstrings with examples and explanations for your function, as well as for any helper functions or classes used. - Ensure to handle edge cases where the number of courses is minimal (e.g., 1) or where there are no prerequisites.","solution":"from typing import List, Tuple from collections import defaultdict, deque def can_finish_courses(num_courses: int, prerequisites: List[Tuple[int, int]]) -> bool: Determine if it is possible to complete all the courses given the prerequisites. Parameters: num_courses (int): The total number of courses. prerequisites (List[Tuple[int, int]]): The list of prerequisite pairs (course, prerequisite). Returns: bool: True if it is possible to complete all courses, otherwise False. Example: >>> can_finish_courses(4, [(1, 0), (2, 1), (3, 2)]) True >>> can_finish_courses(4, [(1, 0), (2, 1), (3, 2), (1, 3)]) False # Initialize graph and indegree array graph = defaultdict(list) indegree = [0] * num_courses # Build the graph and compute indegree of each course for course, pre in prerequisites: graph[pre].append(course) indegree[course] += 1 # Initialize queue with courses having no prerequisites queue = deque([i for i in range(num_courses) if indegree[i] == 0]) # Number of courses for which prerequisites are satisfied satisfied_courses = 0 while queue: current_course = queue.popleft() satisfied_courses += 1 for neighbor in graph[current_course]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If the number of satisfied courses is equal to num_courses, return True return satisfied_courses == num_courses"},{"question":"# Context You are working on a text processing application that often needs to determine the longest palindromic subsequence within a given string. A palindromic subsequence is a sequence that reads the same backward as forward, and it can be derived from the original string by deleting some or no characters without changing the order of the remaining characters. # Task Implement a function `longestPalindromicSubsequence(s: str) -> int` that computes the length of the longest palindromic subsequence in a given string `s`. # Specifications: `longestPalindromicSubsequence(s: str) -> int` - *Input*: A single string `s` of length (n) (1 <= (n) <= 1000) - *Output*: An integer representing the length of the longest palindromic subsequence in the given string `s` # Example ```python # Example usage: s = \\"bbbab\\" assert longestPalindromicSubsequence(s) == 4 # The longest palindromic subsequence is \\"bbbb\\" s = \\"cbbd\\" assert longestPalindromicSubsequence(s) == 2 # The longest palindromic subsequence is \\"bb\\" s = \\"agbdba\\" assert longestPalindromicSubsequence(s) == 5 # The longest palindromic subsequence is \\"abdba\\" s = \\"character\\" assert longestPalindromicSubsequence(s) == 5 # The longest palindromic subsequence is \\"carac\\" ``` # Notes: - You need to ensure your implementation is efficient with respect to both time and space considerations. - Consider using dynamic programming to help solve this problem effectively.","solution":"def longestPalindromicSubsequence(s: str) -> int: n = len(s) # Create a table to store the lengths of the longest palindromic subsequence dp = [[0] * n for _ in range(n)] # Base case: A single character is always a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the table for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1]"},{"question":"# Context: You are working on a data processing pipeline that involves manipulating lists of integers. You need to implement a function that finds the maximum sum of a contiguous subarray within a one-dimensional array of integers, which is a crucial part of performance analytics in financial datasets. # Problem Statement: Implement an efficient version of the function `max_subarray_sum` that calculates the maximum sum of any contiguous subarray within the input array. # Function Signature: ```python def max_subarray_sum(array: list[int]) -> int: # Your implementation here ``` # Input: - A list of integers `array` of length N (0 <= N <= 10^5). # Output: - An integer representing the maximum sum of any contiguous subarray. # Constraints: 1. The array may contain both positive and negative numbers, including zero. 2. The function should be efficient enough to handle large inputs in a reasonable time frame. 3. Aim for an O(N) time complexity for optimal performance with large datasets. # Examples: ```python assert max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) == 6 # Subarray: [4, -1, 2, 1] assert max_subarray_sum([1]) == 1 assert max_subarray_sum([5, 4, -1, 7, 8]) == 23 # Subarray: [5, 4, -1, 7, 8] assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([]) == 0 ``` # Guidelines: - Consider well-known algorithms such as Kadane\'s algorithm for an efficient solution. - Address edge cases, such as when the input array is empty. - Ensure that your solution is not only correct but also optimized in terms of execution speed and memory usage. - Provide comments in your code to clarify the main steps of your algorithm and any assumptions you have made.","solution":"def max_subarray_sum(array: list[int]) -> int: Returns the maximum sum of any contiguous subarray within the input array. Parameters: array (list of int): A list of integers. Returns: int: The maximum sum of any contiguous subarray. if not array: # Edge case: an empty array return 0 max_current = max_global = array[0] for element in array[1:]: max_current = max(element, max_current + element) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Scheduling Problem Context: In many computer applications and real-life scenarios, tasks need to be scheduled without conflicts. Each task has a start and end time and should not overlap with other tasks. You need to implement a task scheduler that takes a list of tasks and determines whether a new task can be added to the existing schedule without causing conflicts. Tasks: 1. Implement a class `TaskScheduler` that supports the following functionalities. - `add_task(start: int, end: int) -> bool`: This method takes the start and end time of a new task and returns `True` if the task can be added without conflicts, otherwise `False`. - `is_conflict(start: int, end: int) -> bool`: This method checks if a new task conflicts with the existing schedule without adding it. Input: - The `add_task` and `is_conflict` methods will receive integers `start` and `end` where `0 <= start < end <= 10^6`. Output: - `add_task` should return a boolean indicating whether the task was added. - `is_conflict` should return a boolean indicating whether the task causes conflicts. Constraints: - The number of tasks will not exceed 1000. - Time intervals are in integer format representing units of time. Example: ```python class TaskScheduler: def __init__(self): self.tasks = [] def add_task(self, start: int, end: int) -> bool: # Implement the add_task method def is_conflict(self, start: int, end: int) -> bool: # Implement the is_conflict method # Example Usage: scheduler = TaskScheduler() print(scheduler.add_task(1, 5)) # Output: True print(scheduler.add_task(4, 10)) # Output: False print(scheduler.is_conflict(2, 6)) # Output: True print(scheduler.add_task(10, 20)) # Output: True ``` Your task is to provide an implementation for the `TaskScheduler` class, including the methods `add_task` and `is_conflict`, which should ensure tasks are scheduled without conflicts.","solution":"class TaskScheduler: def __init__(self): self.tasks = [] def add_task(self, start: int, end: int) -> bool: if not self.is_conflict(start, end): self.tasks.append((start, end)) return True return False def is_conflict(self, start: int, end: int) -> bool: for s, e in self.tasks: if start < e and end > s: return True return False"},{"question":"# Coding Assessment Question: Implementing a Rate Limiter System for API Requests **Scenario**: You are tasked with designing a rate limiter system that restricts the number of API calls a user can make to an application within a specific time window. The rate limiter should track requests and ensure that each user does not exceed a given request limit within the defined time window. **Objective**: Develop a class `RateLimiter` in Python that uses a token bucket algorithm to allow or deny API requests based on the conditions provided below. You need to implement functions to initialize the rate limiter, process requests, and manage token buckets dynamically. Input: - `user_id`: A unique string representing the user making the API request. - `max_requests`: An integer representing the maximum number of requests allowed per user within `time_window` seconds. - `time_window`: An integer representing the time window in seconds within which `max_requests` API calls are allowed per user. The `RateLimiter` class definition is provided. You will expand this class with your token bucket algorithm logic. Output: - `True` if the API request is allowed. - `False` if the API request is denied. ```python import time from collections import defaultdict, deque class RateLimiter: def __init__(self, max_requests: int, time_window: int): Initialize the rate limiter with max_requests and time_window. self.max_requests = max_requests self.time_window = time_window self.user_request_timestamps = defaultdict(deque) def is_request_allowed(self, user_id: str) -> bool: Processes an API request for the user_id and determines if it is allowed based on the rate limits. current_time = time.time() user_queue = self.user_request_timestamps[user_id] # Remove timestamps that are outside the time window while user_queue and user_queue[0] <= current_time - self.time_window: user_queue.popleft() if len(user_queue) < self.max_requests: user_queue.append(current_time) return True else: return False def __call__(self, user_id: str) -> bool: return self.is_request_allowed(user_id) # Example usage: if __name__ == \\"__main__\\": rate_limiter = RateLimiter(max_requests=5, time_window=60) # Allow max 5 requests per user per 60 seconds user_id = \'user_123\' # Test with burst of requests for i in range(7): if rate_limiter(user_id): print(f\\"Request {i+1} for {user_id}: Allowed\\") else: print(f\\"Request {i+1} for {user_id}: Denied\\") time.sleep(10) # Simulate time between requests ``` Constraints: 1. The `max_requests` should be a positive integer. 2. The `time_window` should be a positive integer representing seconds. 3. Handle concurrent requests efficiently. 4. Ensure requests outside the time window are appropriately pruned from the tracking data. Requirements: - Correctly implement the `is_request_allowed` method. - Ensure your solution handles multiple user IDs and tracks their requests independently. - Verify the system can handle edge cases such as bursts of requests followed by periods of no activity. - Optimize for performance considering the possibility of high frequency of API calls. - Write additional test cases to validate the logic thoroughly. **Note**: This question assesses your ability to design and implement a rate-limiting algorithm effectively and efficiently, critical for ensuring fair usage of system resources and preventing abuse. ----- The provided question tests the ability of the candidates to implement a crucial system component for real-world applications, ensuring they understand rate-limiting concepts and can handle performance constraints.","solution":"import time from collections import defaultdict, deque class RateLimiter: def __init__(self, max_requests: int, time_window: int): Initialize the rate limiter with max_requests and time_window. self.max_requests = max_requests self.time_window = time_window self.user_request_timestamps = defaultdict(deque) def is_request_allowed(self, user_id: str) -> bool: Processes an API request for the user_id and determines if it is allowed based on the rate limits. current_time = time.time() user_queue = self.user_request_timestamps[user_id] # Remove timestamps that are outside the time window while user_queue and user_queue[0] <= current_time - self.time_window: user_queue.popleft() if len(user_queue) < self.max_requests: user_queue.append(current_time) return True else: return False def __call__(self, user_id: str) -> bool: return self.is_request_allowed(user_id)"},{"question":"# Problem Statement Imagine you are developing a navigation system that helps vehicles avoid traffic congestion by determining the shortest path between two points. The navigation system represents a city as a grid of nodes, where the time to travel between directly connected nodes can vary due to traffic conditions. You are required to implement an algorithm to find the shortest travel time from a starting node to a destination node in this grid. The city grid is represented as an adjacency matrix `G`, where `G[i][j]` indicates the travel time from node `i` to node `j`. If `i` and `j` are not directly connected, `G[i][j]` is set to a large number (1000000) to signify no direct connection. # Function Signature ```python def find_shortest_path(G, start, end): Finds the shortest path from start node to end node in a city grid represented as an adjacency matrix. Arguments: G -- adjacency matrix representing the grid start -- the starting node end -- the destination node Returns: An integer representing the shortest travel time from start to end. pass ``` # Input * `G` (List[List[int]]): The adjacency matrix representing travel times between nodes. `G[i][j]` indicates the travel time from node `i` to node `j`. If `i` and `j` are not directly connected, `G[i][j]` is set to 1000000. * `start` (int): The starting node index. * `end` (int): The destination node index. # Output * An integer representing the shortest travel time from `start` to `end`. # Constraints * (1 leq text{len}(G) leq 100) * Each entry in `G` is either an integer between 1 and 10000 or 1000000, except diagonal elements `G[i][i]` which are 0. * (0 leq text{start}, text{end} < text{len}(G)) # Performance Requirements * Your solution should run efficiently within the given constraints. # Example ```python # Define the adjacency matrix G = [ [0, 10, 1000000, 30, 100], [10, 0, 50, 1000000, 1000000], [1000000, 50, 0, 20, 10], [30, 1000000, 20, 0, 60], [100, 1000000, 10, 60, 0] ] # Define the start and end nodes start = 0 end = 4 # Call the function shortest_time = find_shortest_path(G, start, end) # Example output # 60 ``` # Explanation The function calculates the shortest travel time from node `0` (start) to node `4` (end) by considering the minimal travel times between directly and indirectly connected nodes. The solution uses an algorithm like Dijkstra\'s to efficiently find the shortest path in the grid.","solution":"import heapq def find_shortest_path(G, start, end): Finds the shortest path from start node to end node in a city grid represented as an adjacency matrix using Dijkstra\'s algorithm. Arguments: G -- adjacency matrix representing the grid start -- the starting node end -- the destination node Returns: An integer representing the shortest travel time from start to end. n = len(G) # Priority queue to store (distance, node) tuples pq = [(0, start)] # List to store the shortest distance from start to each node min_dist = [float(\'inf\')] * n min_dist[start] = 0 while pq: current_distance, current_node = heapq.heappop(pq) # If we reach the end node, return the distance if current_node == end: return current_distance # If the current distance is greater than the recorded minimum, skip processing if current_distance > min_dist[current_node]: continue # Explore neighbors for neighbor in range(n): if G[current_node][neighbor] < 1000000: # There\'s a connection distance = current_distance + G[current_node][neighbor] # If we find a shorter path to the neighbor, update it if distance < min_dist[neighbor]: min_dist[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) # If we exit the loop without finding the end node, return infinity or a large number return -1 # Indicating no path found"},{"question":"# Coding Assessment Question Problem: You are developing a simple recommendation system for a movie streaming service. Users rate movies on a scale from 1 to 5. You need to implement a function that determines the top N movies with the highest average ratings. Assume you have access to a dataset using the following format: `user_ratings`: A dictionary where keys are movie titles (strings) and values are lists of user ratings (integers from 1 to 5). Function Signature: ```python def top_n_movies(user_ratings: dict, n: int) -> list: Determine the top N movies with the highest average ratings. Input Parameters: ----------------- user_ratings: A dictionary where keys are movie titles (strings) and values are lists containing user ratings (integers from 1 to 5). n: The number of top-rated movies to return (positive integer). Returns: -------- A list containing the titles of the top N movies sorted in descending order of their average ratings. If two or more movies have the same average rating, their relative order in the result does not matter. pass ``` Input: - `user_ratings` is a dictionary with: - keys: strings representing movie titles. - values: lists of integers (each between 1 and 5, inclusive). - `n` is a positive integer representing the number of top-rated movies to return. Output: - Return a list containing the titles of the top N movies sorted by their average rating in descending order. Constraints: * There will always be at least N movies in the input dictionary. * No movie will have more than one billion ratings. Example: ```python user_ratings = { \\"Movie A\\": [4, 3, 5, 5, 2], \\"Movie B\\": [5, 5, 4], \\"Movie C\\": [3, 2, 4], \\"Movie D\\": [5, 5, 5, 4], \\"Movie E\\": [4, 4, 4, 2, 3, 4] } top_n_movies(user_ratings, 3) # Output: [\\"Movie D\\", \\"Movie B\\", \\"Movie A\\"] top_n_movies(user_ratings, 1) # Output: [\\"Movie D\\"] ``` You should catch and handle any potential exceptions that may arise due to invalid inputs (although well-formed inputs will be assumed).","solution":"def top_n_movies(user_ratings: dict, n: int) -> list: Determine the top N movies with the highest average ratings. Input Parameters: ----------------- user_ratings: A dictionary where keys are movie titles (strings) and values are lists containing user ratings (integers from 1 to 5). n: The number of top-rated movies to return (positive integer). Returns: -------- A list containing the titles of the top N movies sorted in descending order of their average ratings. If two or more movies have the same average rating, their relative order in the result does not matter. # Calculate the average rating for each movie average_ratings = {movie: sum(ratings) / len(ratings) for movie, ratings in user_ratings.items()} # Sort the movies by average rating in descending order sorted_movies = sorted(average_ratings.keys(), key=lambda x: average_ratings[x], reverse=True) # Return the top N movies return sorted_movies[:n] # Example usage user_ratings_example = { \\"Movie A\\": [4, 3, 5, 5, 2], \\"Movie B\\": [5, 5, 4], \\"Movie C\\": [3, 2, 4], \\"Movie D\\": [5, 5, 5, 4], \\"Movie E\\": [4, 4, 4, 2, 3, 4] } print(top_n_movies(user_ratings_example, 3))"},{"question":"# Question: Most Frequent Even Element You are given a list of integers. Your task is to find the most frequent even number in the list. If there are multiple even numbers with the same highest frequency, return the smallest one. If no even number exists, return -1. Function Signature: ```python def most_frequent_even(arr: list) -> int: ``` Input: - `arr` (list): A list of integers. Output: - (int): Returns the most frequent even number. If no even number exists, return -1. Constraints: 1. The length of the list will be between 1 and 10^5. 2. The list elements can be any integer within the range of -10^9 to 10^9. Example Usage: ```python assert most_frequent_even([3, 4, 4, 2, 2, 8, 8, 8]) == 8 assert most_frequent_even([1, 3, 5, 7]) == -1 assert most_frequent_even([2, 2, 1, 1, 3, 4, 6]) == 2 assert most_frequent_even([10, 10, 10, 20, 20, 20]) == 10 assert most_frequent_even([-2, -4, 2, 2, -4, -4]) == -4 ``` Additional Notes: - Utilize a dictionary to keep track of the frequency count of even numbers. - Sort the even numbers by their frequency and then by their value to determine the correct output in case of a tie.","solution":"def most_frequent_even(arr: list) -> int: from collections import Counter # Filter even numbers even_numbers = [num for num in arr if num % 2 == 0] # If no even numbers, return -1 if not even_numbers: return -1 # Count frequencies frequencies = Counter(even_numbers) # Find the most frequent even number with a tie-breaking by smallest number most_frequent = min(even_numbers, key=lambda x: (-frequencies[x], x)) return most_frequent"},{"question":"# Scenario A company managing a large fleet of delivery trucks wants to optimize the coordination between different trucks in the fleet. Specifically, they need a function to calculate the shortest travel distance between two points on a grid city map, considering potential obstacles that trucks may encounter such as buildings or construction zones. # Problem Statement Write a function called `shortestPath(grid: List[List[int]]) -> int` that takes a 2D grid representing a city map and returns the length of the shortest path from the top-left corner to the bottom-right corner. The grid contains integers where `0` represents an open cell and `1` represents an obstacle. Movement is only allowed horizontally and vertically, not diagonally. If there\'s no valid path, return -1. # Function Signature ```python def shortestPath(grid: List[List[int]]) -> int: ``` # Input * `grid` (List[List[int]], 1 ≤ len(grid), len(grid[0]) ≤ 100): The 2D integer grid where `0` is an open cell and `1` is an obstacle. # Output * Returns the length of the shortest path from the top-left to the bottom-right corner. If no valid path exists, return -1. # Examples ```python assert shortestPath([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) == 4 assert shortestPath([[0, 0, 1], [1, 0, 0], [0, 0, 0]]) == 4 assert shortestPath([[0, 1], [1, 0]]) == -1 ``` # Constraints * You can assume all edges are of equal length. * The function should account for edge cases where there is no valid path. # Notes * Consider using algorithms such as Breadth-First Search (BFS) which is suitable for shortest path problems on unweighted grids. * Ensure to handle large grids efficiently within the given constraints. # Hints * Using a queue can help you explore the cells layer by layer. * Keep track of visited cells to avoid reprocessing and looping. This question integrates seamlessly with the existing set by maintaining a focus on similar key concepts such as grid navigation, algorithmic strategy, handling of obstacles, and the use of basic data structures efficiently.","solution":"from typing import List, Tuple from collections import deque def shortestPath(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows - 1][cols - 1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows - 1 and c == cols - 1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"# Coding Assessment Question: You have been given a dataset with a large number of integer values representing the hourly temperatures recorded over a year. Your task is to implement a pair of functions to determine two key metrics for a given list of temperatures. Firstly, your task is to calculate the average temperature from the given list. Secondly, write a function to determine the longest streak (i.e., the maximum number of successive hours) where the temperature was below a given threshold value. # Function Signature: ```python def average_temperature(temperatures: list) -> float: Returns the average of the temperature values in the list `temperatures`. :param temperatures: list - a list of integers representing temperatures for each hour :return: float - the average temperature Example: >>> average_temperature([30, 25, 35, 20, 15, 40]) 27.5 pass def longest_streak_below_threshold(temperatures: list, threshold: int) -> int: Returns the length of the longest streak where the temperature remained below the given threshold. :param temperatures: list - a list of integers representing temperatures for each hour :param threshold: int - a threshold temperature value :return: int - the length of the longest streak below the threshold Example: >>> longest_streak_below_threshold([30, 25, 20, 15, 35, 40, 10, 5, 0, 2], 20) 4 pass ``` # Requirements: 1. Implement `average_temperature` function to calculate and return the average temperature from the list `temperatures`. 2. Implement `longest_streak_below_threshold` function to calculate and return the length of the longest consecutive streak with temperatures below the specified `threshold`. # Constraints: - The length of `temperatures` list can be up to 8,760 (number of hours in a year). - Temperature values are integers and can range from `-100` to `100` degrees Fahrenheit. - `1 <= threshold <= 100` - Ensure the solution has efficient performance and properly handles edge cases. # Notes: - Attention should be paid to the handling of edge cases such as an empty list of temperatures. - Consider the efficiency of the algorithm in terms of time and space complexity. - You may assume there will be at least one temperature value in practical scenarios.","solution":"def average_temperature(temperatures: list) -> float: Returns the average of the temperature values in the list `temperatures`. :param temperatures: list - a list of integers representing temperatures for each hour :return: float - the average temperature if not temperatures: return 0.0 return sum(temperatures) / len(temperatures) def longest_streak_below_threshold(temperatures: list, threshold: int) -> int: Returns the length of the longest streak where the temperature remained below the given threshold. :param temperatures: list - a list of integers representing temperatures for each hour :param threshold: int - a threshold temperature value :return: int - the length of the longest streak below the threshold longest_streak = 0 current_streak = 0 for temp in temperatures: if temp < threshold: current_streak += 1 if current_streak > longest_streak: longest_streak = current_streak else: current_streak = 0 return longest_streak"},{"question":"# Problem Statement You are tasked with finding the element in an array that, after removing all of its instances, would result in reducing the array\'s maximum frequency. Write a function `find_element_to_reduce_frequency(arr: List[int]) -> int` that takes an array of integers `arr` and returns the integer that, when all its instances are removed, most effectively reduces the maximum frequency of the remaining elements in the array. # Input * `arr`: a list of integers where 1 ≤ len(arr) ≤ 10^5 and all elements are in the range 1 to 10^5. # Output * An integer representing the value whose removal would most reduce the maximum frequency of any single element in the resulting array. # Constraints * If multiple elements could reduce the max frequency to the same extent, return the one that appears first in the input array. * Consider performance and optimize appropriately given the constraints on the size of the array. # Example ```python >>> find_element_to_reduce_frequency([1, 1, 1, 2, 2, 3]) 1 >>> find_element_to_reduce_frequency([4, 4, 4, 4, 5, 6, 7, 7, 7]) 4 >>> find_element_to_reduce_frequency([10, 20, 20, 20, 20, 30, 30, 30]) 20 ``` # Notes * The solution should consider all elements of the array to identify the optimal one for removal. * For example, removing all instances of `1` from `[1, 1, 1, 2, 2, 3]` changes the frequency of the most common element from 3 (for `1`) to 2 (for `2` or `3`).","solution":"from collections import Counter from typing import List def find_element_to_reduce_frequency(arr: List[int]) -> int: Finds the element in an array that, after removing all of its instances, would result in the maximum reduction of the array\'s maximum frequency. if not arr: return None freq = Counter(arr) max_freq = max(freq.values()) best_element = arr[0] best_reduction = 0 for elem in freq: reduced_freq = Counter(arr) del reduced_freq[elem] if reduced_freq: new_max_freq = max(reduced_freq.values()) else: new_max_freq = 0 reduction = max_freq - new_max_freq if reduction > best_reduction: best_reduction = reduction best_element = elem return best_element"},{"question":"# Longest Palindromic Substring Context: You are given a lengthy string representing a company\'s diverse portfolio of unique project names concatenated in sequence. Your task is to determine the longest palindromic substring within this combined string. Task: Implement a function that efficiently finds and returns the longest palindromic substring in the given string using dynamic programming or another efficient algorithm. Requirements: 1. **Function**: `longest_palindromic_substring(s: str) -> str` - Input: A string `s` representing the concatenated project names. - Output: The longest palindromic substring. - Constraints: The input string will have at least one character and at most 1,000 characters. - Performance: The solution should be efficient in terms of both time and space complexity. Example: ```python assert longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" assert longest_palindromic_substring(\\"banana\\") == \\"anana\\" assert longest_palindromic_substring(\\"abcdefedcba\\") == \\"abcdefedcba\\" ``` Explanation: - **\\"abacdfgdcaba\\"** contains \\"aba\\" as the longest palindromic substring. - **\\"banana\\"** contains \\"anana\\" as the longest palindromic substring. - **\\"abcdefedcba\\"** itself is a palindrome, so it is the longest palindromic substring.","solution":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. n = len(s) if n == 0: return \\"\\" # Initialize a 2D list to store the dynamic programming table dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # Every single character is a palindrome for i in range(n): dp[i][i] = True # Check for palindromes of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for palindromes greater than length 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True start = i max_length = length return s[start:start + max_length]"},{"question":"# Sum of Consecutive Integers Problem Statement Given a non-negative integer `n`, write a function to calculate the sum of all consecutive integers from 1 to `n` (inclusive) which can be expressed using the formula: [ text{sum} = frac{n times (n + 1)}{2} ] You need to enhance the existing implementation to handle additional functionalities: 1. Ensure that the function can process input values efficiently, even for very large `n`. 2. Provide comprehensive exception handling for any erroneous inputs (e.g., negative values, non-integer types). Functional Specification 1. **Function Name**: `sum_consecutive_integers` 2. **Input**: A non-negative integer `n`. 3. **Output**: The summation of consecutive integers from 1 to `n`. 4. **Exceptions**: - Raise a `ValueError` if the input is negative. - Raise a `TypeError` if the input type is not an integer. Constraints 1. The input number `n` is a non-negative integer. 2. Utilize the formula for arithmetic series sum for efficient computation. 3. Implement error handling as specified to manage improper inputs. Examples ```python >>> sum_consecutive_integers(10) 55 >>> sum_consecutive_integers(100) 5050 >>> sum_consecutive_integers(0) 0 >>> sum_consecutive_integers(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> sum_consecutive_integers(2_147_483_647) 2305843008139952128 >>> sum_consecutive_integers(\\"string\\") Traceback (most recent call last): ... TypeError: Input must be an integer ``` Implementation Implement the function `sum_consecutive_integers` according to the specifications above: ```python def sum_consecutive_integers(n): Returns the sum of consecutive integers from 1 to n. Args: n: A non-negative integer. Returns: The summation of integers from 1 to n. Raises: TypeError: If n is not an integer. ValueError: If n is negative. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") return n * (n + 1) // 2 if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` This question aligns with the set by focusing on integer arithmetic, efficiency, and error handling while introducing a small twist on the typical sum computation problem.","solution":"def sum_consecutive_integers(n): Returns the sum of consecutive integers from 1 to n. Args: n: A non-negative integer. Returns: The summation of integers from 1 to n. Raises: TypeError: If n is not an integer. ValueError: If n is negative. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") return n * (n + 1) // 2"},{"question":"# Problem Statement: As a data analyst, you are tasked with analyzing and summarizing a list of sales transactions. Each transaction consists of a product name, its price, and its quantity sold. Your goal is to calculate the total sales for each unique product and identify the product with the highest and lowest total sales. # Objective: Write a function that: 1. Calculates the total sales for each product. 2. Identifies the product with the highest and lowest total sales. # Function Signature: ```python def analyze_sales(transactions: List[Tuple[str, float, int]]) -> Tuple[Dict[str, float], str, str]: ``` # Input: * `transactions` (List[Tuple[str, float, int]]): A list of tuples, where each tuple contains: * `product_name` (str): The name of the product (non-empty string). * `price` (float): The price of the product (must be positive). * `quantity_sold` (int): The quantity of the product sold (must be non-negative). # Output: * Returns a tuple containing: * A dictionary with product names as keys and their respective total sales as values. * A string indicating the product with the highest total sales. * A string indicating the product with the lowest total sales. # Constraints: * `price` must be greater than 0. * `quantity_sold` must be greater than or equal to 0. * The function should raise a ValueError if: * `price` is not positive. * `quantity_sold` is negative. * `product_name` is an empty string. # Example: ```python >>> transactions = [(\\"apple\\", 2.0, 30), (\\"banana\\", 1.0, 50), (\\"apple\\", 2.0, 20), (\\"orange\\", 3.0, 30)] >>> result = analyze_sales(transactions) >>> print(result) ({\'apple\': 100.0, \'banana\': 50.0, \'orange\': 90.0}, \'apple\', \'banana\') >>> transactions = [(\\"apple\\", -2.0, 30)] >>> result = analyze_sales(transactions) Traceback (most recent call last): ... ValueError: price must be greater than 0 >>> transactions = [(\\"apple\\", 2.0, -30)] >>> result = analyze_sales(transactions) Traceback (most recent call last): ... ValueError: quantity_sold must be non-negative >>> transactions = [(\\"\\", 2.0, 30)] >>> result = analyze_sales(transactions) Traceback (most recent call last): ... ValueError: product_name must not be empty ``` # Note: * Ensure robust error handling for invalid inputs as described in the constraints. * Provide clear and meaningful output for all valid inputs. * Assume there are no ties for the highest and lowest total sales.","solution":"from typing import List, Tuple, Dict def analyze_sales(transactions: List[Tuple[str, float, int]]) -> Tuple[Dict[str, float], str, str]: Analyzes sales transactions and returns a summary of total sales, product with the highest total sales, and product with the lowest total sales. Args: transactions (List[Tuple[str, float, int]]): List of sales transactions. Returns: Tuple[Dict[str, float], str, str]: A tuple containing: - A dictionary with product names as keys and their total sales as values. - The product name with the highest total sales. - The product name with the lowest total sales. Raises: ValueError: If price is not positive, quantity_sold is negative, or product_name is empty. sales_summary = {} for product_name, price, quantity_sold in transactions: if not product_name: raise ValueError(\\"product_name must not be empty\\") if price <= 0: raise ValueError(\\"price must be greater than 0\\") if quantity_sold < 0: raise ValueError(\\"quantity_sold must be non-negative\\") if product_name in sales_summary: sales_summary[product_name] += price * quantity_sold else: sales_summary[product_name] = price * quantity_sold if not sales_summary: return {}, None, None highest_sales_product = max(sales_summary, key=sales_summary.get) lowest_sales_product = min(sales_summary, key=sales_summary.get) return sales_summary, highest_sales_product, lowest_sales_product"},{"question":"# Question Style Context You are working on a simple date management utility, and one of the fundamental functions you need is to calculate the number of leap years that have occurred within a given range of years. This is a basic yet essential part of date-based computations. Task Implement a function that calculates the number of leap years between two given years, inclusive. The function must handle leap years according to the Gregorian calendar rules. Function Specification ```python def count_leap_years(start_year: int, end_year: int) -> int: This function should calculate the number of leap years between the start_year and end_year inclusive. Arguments: start_year (int): the starting year in the range. end_year (int): the ending year in the range. Returns: int: The number of leap years between start_year and end_year inclusive. Example: >>> count_leap_years(2000, 2020) 6 >>> count_leap_years(2016, 2020) 2 >>> count_leap_years(1900, 1900) 0 >>> count_leap_years(2000, 2000) 1 pass # Your code here ``` Constraints 1. The `start_year` will be less than or equal to `end_year`. 2. The `start_year` and `end_year` will be between 1 and 9999 inclusive. 3. Only integers should be used or returned. Performance Requirements The expected time complexity should be O(1) and the space complexity should be O(1). Your Task Implement the function `count_leap_years` as specified. Ensure that your function passes all the given test cases.","solution":"def count_leap_years(start_year: int, end_year: int) -> int: This function should calculate the number of leap years between the start_year and end_year inclusive. Arguments: start_year (int): the starting year in the range. end_year (int): the ending year in the range. Returns: int: The number of leap years between start_year and end_year inclusive. def is_leap_year(year): if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return True return False count = 0 for year in range(start_year, end_year + 1): if is_leap_year(year): count += 1 return count"},{"question":"# Coding Problem: Maximize Stock Profits with Limited Transactions Context: A stock trader wants to maximize their profits from a given list of daily stock prices, but they are limited to making a fixed number of transactions (buy/sell). A transaction consists of buying one unit of stock and then later selling it. The trader aims to determine the maximum profit achievable with the given constraints. Task: Write a function `max_profit_with_k_transactions(prices, k)` that: 1. Computes the maximum profit achievable from performing at most `k` transactions on the given `prices` array. 2. Returns the maximum profit. **Function to Implement**: - **max_profit_with_k_transactions**: This function takes in the list of prices and the number of allowed transactions and returns the maximum profit achievable. # Example: ```python def max_profit_with_k_transactions(prices: list[int], k: int) -> int: # Write your implementation here. pass ``` Given: ```python prices = [3, 2, 6, 5, 0, 3] k = 2 ``` For the input: ```python max_profit_with_k_transactions(prices, k) ``` Expected Output: ```python 7 ``` Explanation: - The trader can buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. - Then, buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. - Total profit = 4 + 3 = 7. Constraints: * Length of the prices list (0 ≤ length ≤ 1000). * Number of transactions (0 ≤ k ≤ length // 2). * Each price ( 0 ≤ price ≤ 10,000). Performance Requirements: - Ensure the solution is efficient to handle the upper limits in terms of both time and space complexities. - Handle edge cases such as no transactions allowed or no price fluctuations. Implementation Notes: - Use dynamic programming to compute the maximum profit considering at most `k` transactions. - The solution must accurately track the state of each transaction to ensure optimal profit calculation. - Take into consideration that no transactions can be performed if `k` is zero.","solution":"def max_profit_with_k_transactions(prices, k): if not prices or k == 0: return 0 n = len(prices) if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) # Initialize the DP table profits = [[0] * n for _ in range(k + 1)] # Fill the DP table for t in range(1, k + 1): max_diff = -prices[0] for d in range(1, n): profits[t][d] = max(profits[t][d - 1], prices[d] + max_diff) max_diff = max(max_diff, profits[t - 1][d] - prices[d]) return profits[k][n - 1]"},{"question":"# Circle and Point Inclusion Check You are required to implement a `Circle` class that represents a circle in a 2D plane and includes methods for calculating its area and checking if a given point lies inside the circle. Requirements: 1. **Class Definition**: - Implement the `Circle` class with the following: - An initializer method `__init__(self, x_center, y_center, radius)` that sets up the circle using its center `(x_center, y_center)` and its `radius`. - A method `area(self)` that returns the area of the circle. - A method `is_point_inside(self, x, y)` that takes coordinates `(x, y)` of a point and returns `True` if the point lies inside or on the boundary of the circle, otherwise `False`. 2. **Formulas**: - The area of the circle should be calculated using the formula: [ text{area} = pi times text{radius}^2 ] - A point `(x, y)` is inside the circle if the distance from the point to the center of the circle is less than or equal to the radius. Use the distance formula: [ text{distance} = sqrt{(x - x_{text{center}})^2 + (y - y_{text{center}})^2} ] Input: * A list of circle definitions `[x_center, y_center, radius]`. * Multiple points to check `[x, y]`. Output: * For each point, output `True` if the point lies inside or on the boundary of any of the circles, otherwise `False`. Constraints: * The coordinates and radius are all floating-point numbers where (-10^3 ≤ x_{text{center}}, y_{text{center}}, x, y ≤ 10^3) and (0 < text{radius} ≤ 10^3). * The number of circles and points to check can be large, so efficiency should be considered. Example: ```python # Define a circle circle = Circle(0, 0, 5) # Calculate area assert round(circle.area(), 2) == 78.54 # Point inclusion checks assert circle.is_point_inside(3, 4) == True # Lies on the boundary assert circle.is_point_inside(0, 0) == True # Lies inside assert circle.is_point_inside(6, 0) == False # Lies outside assert circle.is_point_inside(4, 5) == False ``` Implementation: ```python import math class Circle: def __init__(self, x_center: float, y_center: float, radius: float): self.x_center = x_center self.y_center = y_center self.radius = radius def area(self) -> float: return math.pi * (self.radius ** 2) def is_point_inside(self, x: float, y: float) -> bool: distance = math.sqrt((x - self.x_center) ** 2 + (y - self.y_center) ** 2) return distance <= self.radius ``` Note: Ensure precision in floating-point comparisons to avoid inaccuracies due to the nature of floating-point arithmetic.","solution":"import math class Circle: def __init__(self, x_center: float, y_center: float, radius: float): Initialize the Circle with center coordinates (x_center, y_center) and radius. self.x_center = x_center self.y_center = y_center self.radius = radius def area(self) -> float: Calculate and return the area of the circle. return math.pi * (self.radius ** 2) def is_point_inside(self, x: float, y: float) -> bool: Check whether the point (x, y) is inside or on the boundary of the circle. distance_sq = (x - self.x_center) ** 2 + (y - self.y_center) ** 2 return distance_sq <= self.radius ** 2"},{"question":"# Question: Efficient Fibonacci Sequence Calculation Given the problem of calculating the `n`-th Fibonacci number, you are tasked to implement a function `fibonacci(n: int) -> int` that computes and returns the `n`-th Fibonacci number using an optimized approach to save space. Instructions: 1. **Input**: The function `fibonacci(n)` takes a single integer `n` (0 <= n <= 10,000). 2. **Output**: Returns an integer representing the `n`-th Fibonacci number. Requirements: * The solution should employ an iterative approach to optimize space complexity. * Must handle edge cases gracefully: - For `n < 0`, raise a `ValueError` with the message `\\"Input must be a non-negative integer.\\"`. - For non-integer values, raise a `TypeError` with the message `\\"Input must be an integer.\\"`. Examples: Here are some examples of the expected outputs: ```python >>> fibonacci(5) 5 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(-3) ValueError: Input must be a non-negative integer. >>> fibonacci(2.5) TypeError: Input must be an integer. ``` Additional Context: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The `n`-th Fibonacci number is commonly denoted as F(n). Constraints: * To achieve optimal space complexity, avoid using full array or list storage for previous Fibonacci numbers. Use only a few variables to keep track of the necessary state.","solution":"def fibonacci(n): if not isinstance(n, int): raise TypeError(\\"Input must be an integer.\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") a, b = 0, 1 for _ in range(n): a, b = b, a + b return a"},{"question":"# Question: Implement a Course Scheduler using Topological Sort Given a set of courses and their prerequisites, design a system to determine if it is possible to complete all courses, and if so, provide a possible order in which to take them. Problem: You are given a list of courses represented by integers from `0` to `n-1` and a list of prerequisite pairs. Each pair indicates that to take course `b`, you must take course `a` first. This can be represented as a directed edge in a graph. Implement two methods in the `CourseScheduler` class: 1. **Can Complete Courses**: Implement a method `can_complete_courses(self) -> bool` that determines if it is possible to complete all courses given the prerequisites. 2. **Find Course Order**: Implement a method `find_course_order(self) -> List[int]` that returns a possible order in which you can take the courses such that all prerequisites are satisfied. If it is not possible, return an empty list. # Implementation: Method Definitions: ```python class CourseScheduler: def __init__(self, num_courses: int, prerequisites: List[Tuple[int, int]]) -> None: self.num_courses = num_courses self.prerequisites = prerequisites self.graph = [[] for _ in range(num_courses)] self.indegree = [0] * num_courses for dest, src in prerequisites: self.graph[src].append(dest) self.indegree[dest] += 1 def can_complete_courses(self) -> bool: Determine if it is possible to complete all courses. :return: True if all courses can be completed, otherwise False. def find_course_order(self) -> List[int]: Return an order in which to take courses such that all prerequisites are satisfied. :return: A list of course order if possible, otherwise an empty list. ``` Expected Input/Output: 1. **can_complete_courses(self) -> bool** - **Input**: The number of courses and their prerequisite pairs. - **Output**: A boolean value `True` if it is possible to complete all courses, otherwise `False`. - **Example**: ```python scheduler = CourseScheduler(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) scheduler.can_complete_courses() ``` If there are 4 courses and the prerequisites are `[(1, 0), (2, 0), (3, 1), (3, 2)]`, the output should be: ```python True ``` 2. **find_course_order(self) -> List[int]** - **Input**: The number of courses and their prerequisite pairs. - **Output**: A list representing a valid order of courses to complete them all, or an empty list if it is not possible. - **Example**: ```python scheduler = CourseScheduler(4, [(1, 0), (2, 0), (3, 1), (3, 2)]) scheduler.find_course_order() ``` If there are 4 courses and the prerequisites are `[(1, 0), (2, 0), (3, 1), (3, 2)]`, the output should be: ```python [0, 1, 2, 3] ``` or `[0, 2, 1, 3]`. # Constraints: 1. The number of courses, `n`, is a positive integer up to `10,000`. 2. The prerequisite list can be empty, indicating no prerequisites. 3. Courses are represented by integers from `0` to `n-1`. # Performance Requirements: 1. Both methods should be optimized for large datasets. 2. Ensure minimal memory overhead while maintaining clarity and simplicity in the solution.","solution":"from typing import List, Tuple class CourseScheduler: def __init__(self, num_courses: int, prerequisites: List[Tuple[int, int]]) -> None: Initialize graph and indegree array based on number of courses and prerequisites. self.num_courses = num_courses self.prerequisites = prerequisites self.graph = [[] for _ in range(num_courses)] self.indegree = [0] * num_courses for dest, src in prerequisites: self.graph[src].append(dest) self.indegree[dest] += 1 def can_complete_courses(self) -> bool: Determine if it is possible to complete all courses. :return: True if all courses can be completed, otherwise False. # Perform topological sort using Kahn\'s algorithm. zero_indegree_queue = [i for i in range(self.num_courses) if self.indegree[i] == 0] visited_count = 0 while zero_indegree_queue: node = zero_indegree_queue.pop(0) visited_count += 1 for neighbor in self.graph[node]: self.indegree[neighbor] -= 1 if self.indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If we have visited all the courses, we can complete them. return visited_count == self.num_courses def find_course_order(self) -> List[int]: Return an order in which to take courses such that all prerequisites are satisfied. :return: A list of course order if possible, otherwise an empty list. # Prepare toposort result list and indegree processing queue. zero_indegree_queue = [i for i in range(self.num_courses) if self.indegree[i] == 0] toposort_result = [] while zero_indegree_queue: node = zero_indegree_queue.pop(0) toposort_result.append(node) for neighbor in self.graph[node]: self.indegree[neighbor] -= 1 if self.indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) # If toposort_result contains all courses, we have a valid order. if len(toposort_result) == self.num_courses: return toposort_result else: return []"},{"question":"# Problem Statement: Write a function called `find_missing_integer` that takes an array of integers, which contains all the numbers from 1 to `n` except one missing number, and finds that missing number. The array will not be in sorted order. # Input: - `nums` (List[int]): A list of integers of length `n-1` where `1 <= nums[i] <= n` and `numbers` are unique. # Output: - Return the missing integer from the list. # Constraints: - The length of `nums` is `n-1` where `1 <= n <= 10^5`. - The numbers are unique and range from 1 to `n`. # Example: ```python def find_missing_integer(nums: List[int]) -> int: # Implementation here print(find_missing_integer([1, 2, 4, 6, 3, 7, 8])) # Output: 5 print(find_missing_integer([2, 3, 1, 5])) # Output: 4 print(find_missing_integer([1])) # Output: 2 ``` # Note: - Utilize efficient ways to compute the missing number without sorting the array or using additional data structures unnecessarily. - Consider both time and space complexity of your solution.","solution":"def find_missing_integer(nums): Finds the missing integer in a list containing numbers from 1 to n with one missing. Args: nums (List[int]): The input list of integers. Returns: int: The missing integer. n = len(nums) + 1 total_sum = n * (n + 1) // 2 # Sum of all numbers from 1 to n actual_sum = sum(nums) # Sum of numbers in the input list return total_sum - actual_sum"},{"question":"# Steps in a Matrix Typewriter Pattern Description Implement a function that generates a matrix of size `n x n` filled with integers from 1 up to `n^2` in a typewriter pattern. A typewriter pattern starts at the top-left corner and fills the matrix row by row from left to right and then from right to left alternately. Function Signature ```python def typewriter_pattern(n: int) -> List[List[int]]: pass ``` Input * `n` (int): The size of the matrix (both the number of rows and columns). You can assume `n` will always be a positive integer. Output * (List[List[int]]): The `n x n` matrix filled following the typewriter pattern. Constraints * 1 ≤ n ≤ 100 Examples ```python # Example 1 typewriter_pattern(3) # should return # [[1, 2, 3], # [6, 5, 4], # [7, 8, 9]] # Example 2 typewriter_pattern(4) # should return # [[1, 2, 3, 4], # [8, 7, 6, 5], # [9, 10, 11, 12], # [16, 15, 14, 13]] # Example 3 typewriter_pattern(1) # should return # [[1]] ``` Notes - The sequence should start at 1 and increment to `n^2`. - Rows are filled alternatively from left-to-right and right-to-left. - Ensure your solution is optimized for the given constraints.","solution":"from typing import List def typewriter_pattern(n: int) -> List[List[int]]: Generates a matrix of size n x n filled with integers 1 to n^2 in a typewriter pattern. matrix = [[0] * n for _ in range(n)] current_val = 1 for i in range(n): if i % 2 == 0: # Left to right for j in range(n): matrix[i][j] = current_val current_val += 1 else: # Right to left for j in range(n-1, -1, -1): matrix[i][j] = current_val current_val += 1 return matrix"},{"question":"# Coding Assessment Question Scenario You are developing an application to generate friendly greetings based on a given list of names. The application must ensure that certain rules are followed when constructing these greetings: 1. If the name starts with a vowel (a, e, i, o, u), the greeting should start with \\"Hello, [name]!\\". 2. If the name starts with a consonant, the greeting should start with \\"Hi, [name]!\\". Your task is to write a function that takes a list of names and returns a list of greetings following the above rules. Task Write a function `generate_greetings` that creates a friendly greeting for each name in an input list based on the first letter of each name. Input - The function takes a single parameter: - `names`: a list of strings containing names, where each name consists of alphabetic characters only. Output - The function should return a list of strings, where each string is a personalized greeting based on the rules specified. Constraints - The length of each name will not exceed 100 characters. - The length of the names list will not exceed 1000 elements. Performance Requirements - The function should perform efficiently within the given input size constraints. Function Signature ```python def generate_greetings(names: list) -> list: ``` Example ```python assert generate_greetings([\\"Alice\\", \\"Bob\\", \\"Eve\\", \\"Charlie\\"]) == [\\"Hello, Alice!\\", \\"Hi, Bob!\\", \\"Hello, Eve!\\", \\"Hi, Charlie!\\"] ``` Implement the function to meet the requirements given.","solution":"def generate_greetings(names): Generates a friendly greeting for each name based on its starting letter. If the name starts with a vowel (a, e, i, o, u), greeting starts with \\"Hello, [name]!\\". If the name starts with a consonant, greeting starts with \\"Hi, [name]!\\". :param names: List of strings, where each string is a name consisting of alphabetic characters. :return: List of strings, where each string is a personalized greeting. greetings = [] for name in names: if name[0].lower() in \'aeiou\': greetings.append(f\\"Hello, {name}!\\") else: greetings.append(f\\"Hi, {name}!\\") return greetings"},{"question":"# Scenario As a software engineer, you have been assigned to optimize a section of a large application that performs extensive numerical computations. One important task is to replace any negative values in a given matrix with their absolute values so that the computations run smoother downstream. # Problem Statement Write a function called `matrix_abs` that takes a 2-dimensional NumPy array (matrix) and returns a new matrix where all the negative values have been converted to their absolute values. # Function Signature ```python import numpy as np def matrix_abs(matrix: np.ndarray) -> np.ndarray: pass ``` # Input - `matrix` (np.ndarray): A 2-dimensional NumPy array containing integer or float values. # Output - Returns a NumPy array of the same shape as the input `matrix` with all negative values converted to their absolute values. # Constraints - The values in the matrix can range from `-10^9` to `10^9`. - The matrix can have dimensions up to 1000 x 1000. - Ensure your function handles matrices of any size (including empty matrices) gracefully. - Aim for a time complexity of O(n*m), where n is the number of rows and m is the number of columns. # Examples ```python >>> matrix_abs(np.array([[1, -2, 3], [-4, 5, -6]])) array([[1, 2, 3], [4, 5, 6]]) >>> matrix_abs(np.array([[0, -7], [-8, 9]])) array([[0, 7], [8, 9]]) ``` # Notes Make sure to utilize NumPy\'s vectorized operations to ensure efficient computation.","solution":"import numpy as np def matrix_abs(matrix: np.ndarray) -> np.ndarray: Returns a new matrix where all negative values have been converted to their absolute values. Parameters: - matrix (np.ndarray): A 2-dimensional NumPy array containing integer or float values. Returns: - np.ndarray: A 2-dimensional NumPy array with the same shape as the input matrix, with all negative values converted to their absolute values. return np.abs(matrix)"},{"question":"# String Manipulation and Pattern Matching Develop a class that provides various string manipulation and pattern matching functionalities. Each method will be designed to handle specific types of string-related tasks, such as checking for palindromes, finding substrings, converting cases, and verifying patterns. # Specifications: * **Class Name**: `StringUtil` * **Methods**: - `is_palindrome(s)`: Checks if the given string is a palindrome. - `find_substring(s, sub)`: Finds all starting indices of the substring `sub` in the string `s`. - `to_uppercase(s)`: Converts the entire string `s` to uppercase. - `verify_pattern(s, pattern)`: Verifies if the given string `s` matches the provided regular expression `pattern`. # Constraints: * Input strings will contain ASCII characters. * Methods should raise appropriate Python exceptions for invalid inputs: - `TypeError` if inputs are not strings or if the pattern is not a valid regular expression string. # Example Usage: ```python str_util = StringUtil() # Palindrome Check result_palindrome = str_util.is_palindrome(\\"racecar\\") print(result_palindrome) # Output: True # Finding Substrings result_find = str_util.find_substring(\\"abracadabra\\", \\"abra\\") print(result_find) # Output: [0, 7] # Convert to Uppercase result_upper = str_util.to_uppercase(\\"hello world\\") print(result_upper) # Output: \\"HELLO WORLD\\" # Verify Pattern result_pattern = str_util.verify_pattern(\\"123-45-6789\\", r\\"^d{3}-d{2}-d{4}\\") print(result_pattern) # Output: True ``` # Performance Requirements: * Methods should handle string inputs up to a length of 10^6 characters efficiently. * Ensure that the pattern matching is optimized for performance and handles large input sizes without significant slowdowns. # Implementation: Implement the `StringUtil` class with the specified methods. Ensure each method performs the required string manipulations or pattern matching accurately. Validate inputs and raise appropriate exceptions for invalid cases. Pay attention to edge cases such as empty strings or invalid regular expressions.","solution":"import re class StringUtil: @staticmethod def is_palindrome(s): if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return s == s[::-1] @staticmethod def find_substring(s, sub): if not isinstance(s, str) or not isinstance(sub, str): raise TypeError(\\"Inputs must be strings\\") return [i for i in range(len(s)) if s.startswith(sub, i)] @staticmethod def to_uppercase(s): if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return s.upper() @staticmethod def verify_pattern(s, pattern): if not isinstance(s, str) or not isinstance(pattern, str): raise TypeError(\\"Both string and pattern must be strings\\") try: return bool(re.match(pattern, s)) except re.error: raise ValueError(\\"Invalid regular expression pattern\\")"},{"question":"# Problem Statement: You are tasked with identifying the best milestone day for a project, given the dependencies between tasks. Each task must be completed before certain other tasks can begin. # Function Signature: ```python def best_milestone_day(tasks: int, dependencies: List[Tuple[int, int]]) -> List[int] ``` # Input: - `tasks` (int): The number of tasks. (1 ≤ `tasks` ≤ 100) - `dependencies` (List[Tuple[int, int]]): A list of pairs representing dependencies between tasks, where each pair (a, b) indicates task `a` must be completed before task `b` can begin. # Output: - (List[int]): A list of integers representing the milestone days for each task such that the number at index `i` denotes the day task `i` can be best completed, considering all dependencies. The first task to complete should be assigned day 1, the next independent task day 2, and so on. # Constraints: - Assume that if a task `a` must be completed before task `b`, it implies that `a < b`. - Tasks without any dependencies can be completed on any day before their dependent tasks. - Consider edge cases such as tasks with circular dependencies or tasks in a fully linear sequence. # Example: ```python # Example 1: tasks = 4 dependencies = [(1, 2), (2, 3), (3, 4)] best_milestone_day(tasks, dependencies) # Returns: [1, 2, 3, 4] # Example 2: tasks = 6 dependencies = [(1, 3), (2, 3), (3, 4), (4, 5), (4, 6)] best_milestone_day(tasks, dependencies) # Returns: [1, 1, 2, 3, 4, 4] ``` # Hints: - Use topological sorting to determine the order of task completion respecting all dependencies. - For tasks that can occur simultaneously (i.e., no direct dependencies between them), assign them the smallest available milestone day. - Carefully handle cycles in the dependency graph, as they could indicate erroneous dependencies. # Additional Context: Understanding the most efficient way to order tasks given their dependencies helps in project management and resource allocation. The goal is to optimize task scheduling so that all tasks are completed in the shortest time possible while respecting their dependencies.","solution":"from typing import List, Tuple from collections import deque, defaultdict def best_milestone_day(tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: # Create adjacency list and in-degree count adj_list = defaultdict(list) in_degree = [0] * tasks for dep in dependencies: u, v = dep[0] - 1, dep[1] - 1 # converting to 0-based index adj_list[u].append(v) in_degree[v] += 1 # Topological sorting using Kahn\'s algorithm zero_in_degree_queue = deque() for i in range(tasks): if in_degree[i] == 0: zero_in_degree_queue.append(i) milestone_days = [0] * tasks current_day = 1 while zero_in_degree_queue: for _ in range(len(zero_in_degree_queue)): task = zero_in_degree_queue.popleft() milestone_days[task] = current_day for neighbor in adj_list[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) current_day += 1 return milestone_days"},{"question":"# Graph Depth Calculation Exercise Graphs are fundamental data structures used to represent relationships between entities. In this task, you are required to perform an analysis of the given directed graph implementation by adding features that calculate the depth of each node. # Problem Statement Enhance the given Directed Graph implementation by adding the following functionalities: 1. **Node Depth Calculation**: - Implement a `node_depths(start_node: T) -> Dict[T, int]` method that returns a dictionary where the keys are the nodes and the values are the depths of these nodes from the specified start node. 2. **Maximum Depth Calculation**: - Implement a `max_depth(start_node: T) -> int` method to return the maximum depth encountered from the specified start node. # Expected Methods Implementation `node_depths` Method - **Input**: A starting node `start_node` of type `T`. - **Output**: A dictionary `Dict[T, int]` mapping each node to its depth from the `start_node`. - **Constraints**: Ensure O(V + E) time complexity for node depth calculation, where V is the number of vertices and E is the number of edges. `max_depth` Method - **Input**: A starting node `start_node` of type `T`. - **Output**: An integer representing the maximum depth from the `start_node`. - **Constraints**: Should utilize the results from `node_depths` and should run in O(V) time. # Example Here\'s an example scenario and expected output: ```python graph = DirectedGraph() graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(2, 5) graph.add_edge(3, 6) # Starting from node 1, we expect these depths: # 1: 0 (itself) # 2: 1 # 3: 1 # 4: 2 # 5: 2 # 6: 2 assert graph.node_depths(1) == {1: 0, 2: 1, 3: 1, 4: 2, 5: 2, 6: 2} assert graph.max_depth(1) == 2 # After adding a new edge graph.add_edge(3, 7) assert graph.node_depths(1) == {1: 0, 2: 1, 3: 1, 4: 2, 5: 2, 6: 2, 7: 2} assert graph.max_depth(1) == 2 ``` *Your task is to implement the `node_depths` and `max_depth` methods without modifying the original structure of DirectedGraph class or the methods provided.*","solution":"from typing import Dict, List, Set, TypeVar, Generic T = TypeVar(\'T\') class DirectedGraph(Generic[T]): def __init__(self): self._adjacency_list: Dict[T, List[T]] = {} def add_edge(self, u: T, v: T): if u not in self._adjacency_list: self._adjacency_list[u] = [] self._adjacency_list[u].append(v) if v not in self._adjacency_list: self._adjacency_list[v] = [] def node_depths(self, start_node: T) -> Dict[T, int]: depths = {start_node: 0} queue = [(start_node, 0)] while queue: current, depth = queue.pop(0) for neighbor in self._adjacency_list[current]: if neighbor not in depths: depths[neighbor] = depth + 1 queue.append((neighbor, depth + 1)) return depths def max_depth(self, start_node: T) -> int: depths = self.node_depths(start_node) return max(depths.values(), default=0)"},{"question":"# Context You are developing an application where users can efficiently manage and manipulate various shapes. Each shape should support area and perimeter calculations, and they should be easily exportable to other formats. # Problem Statement Write a Python class hierarchy that supports the following functionalities: 1. **Shape Initialization**: Abstract base class `Shape` and derived classes `Rectangle`, `Circle`, and `Triangle` for initializing specific shapes. 2. **Area Calculation**: Implement a method to calculate the area for each shape. 3. **Perimeter Calculation**: Implement a method to calculate the perimeter for each shape. 4. **String Representation**: A method to return a string representation of each shape with its properties. 5. **To Dictionary**: A method to export shape properties as a dictionary. Additionally, implement a proper unit test suite to validate these functionalities. Ensure to cover edge cases and any notable error handling. # Implementation Details 1. **Shape Initialization**: ```python from abc import ABC, abstractmethod from math import pi, sqrt from typing import Dict class Shape(ABC): @abstractmethod def area(self) -> float: ... @abstractmethod def perimeter(self) -> float: ... @abstractmethod def to_dict(self) -> Dict: ... @abstractmethod def __str__(self) -> str: ... class Rectangle(Shape): def __init__(self, length: float, width: float) -> None: ... class Circle(Shape): def __init__(self, radius: float) -> None: ... class Triangle(Shape): def __init__(self, a: float, b: float, c: float) -> None: ... ``` 2. **Area Calculation**: ```python def area(self) -> float: # For Rectangle: # return self.length * self.width ... ``` 3. **Perimeter Calculation**: ```python def perimeter(self) -> float: # For Rectangle: # return 2 * (self.length + self.width) ... ``` 4. **String Representation**: ```python def __str__(self) -> str: # For Rectangle: # return f\\"Rectangle(length={self.length}, width={self.width})\\" ... ``` 5. **To Dictionary**: ```python def to_dict(self) -> Dict: # For Rectangle: # return {\\"type\\": \\"Rectangle\\", \\"length\\": self.length, \\"width\\": self.width} ... ``` # Constraints - The area and perimeter methods should handle typical edge cases, such as ensuring positive dimensions. - String representation should clearly describe the shape and its main properties. - Dictionary export should include a \\"type\\" key to identify the shape. # Unit Tests Create a test class `TestShapes` using `unittest` that validates all aspects of your implementation. Cover typical edge cases and error scenarios like negative dimensions or incorrect triangle side lengths. # Example ```python # Test Rectangle rect = Rectangle(4, 5) print(rect.area()) # Should print 20. print(rect.perimeter()) # Should print 18. print(str(rect)) # Should print \\"Rectangle(length=4, width=5)\\". print(rect.to_dict()) # Should print {\\"type\\": \\"Rectangle\\", \\"length\\": 4, \\"width\\": 5}. # Test Circle circle = Circle(3) print(circle.area()) # Should print ~28.27 print(circle.perimeter()) # Should print ~18.85 print(str(circle)) # Should print \\"Circle(radius=3)\\". print(circle.to_dict()) # Should print {\\"type\\": \\"Circle\\", \\"radius\\": 3}. # Test Triangle triangle = Triangle(3, 4, 5) print(triangle.area()) # Should print 6. print(triangle.perimeter()) # Should print 12. print(str(triangle)) # Should print \\"Triangle(a=3, b=4, c=5)\\". print(triangle.to_dict()) # Should print {\\"type\\": \\"Triangle\\", \\"a\\": 3, \\"b\\": 4, \\"c\\": 5}. ```","solution":"from abc import ABC, abstractmethod from math import pi, sqrt from typing import Dict class Shape(ABC): @abstractmethod def area(self) -> float: pass @abstractmethod def perimeter(self) -> float: pass @abstractmethod def to_dict(self) -> Dict: pass @abstractmethod def __str__(self) -> str: pass class Rectangle(Shape): def __init__(self, length: float, width: float) -> None: assert length > 0 and width > 0, \\"Length and width must be positive.\\" self.length = length self.width = width def area(self) -> float: return self.length * self.width def perimeter(self) -> float: return 2 * (self.length + self.width) def __str__(self) -> str: return f\\"Rectangle(length={self.length}, width={self.width})\\" def to_dict(self) -> Dict: return {\\"type\\": \\"Rectangle\\", \\"length\\": self.length, \\"width\\": self.width} class Circle(Shape): def __init__(self, radius: float) -> None: assert radius > 0, \\"Radius must be positive.\\" self.radius = radius def area(self) -> float: return pi * self.radius * self.radius def perimeter(self) -> float: return 2 * pi * self.radius def __str__(self) -> str: return f\\"Circle(radius={self.radius})\\" def to_dict(self) -> Dict: return {\\"type\\": \\"Circle\\", \\"radius\\": self.radius} class Triangle(Shape): def __init__(self, a: float, b: float, c: float) -> None: assert a > 0 and b > 0 and c > 0, \\"Sides must be positive.\\" assert a + b > c and a + c > b and b + c > a, \\"Triangle inequality must hold.\\" self.a = a self.b = b self.c = c def area(self) -> float: s = self.perimeter() / 2 return sqrt(s * (s - self.a) * (s - self.b) * (s - self.c)) def perimeter(self) -> float: return self.a + self.b + self.c def __str__(self) -> str: return f\\"Triangle(a={self.a}, b={self.b}, c={self.c})\\" def to_dict(self) -> Dict: return {\\"type\\": \\"Triangle\\", \\"a\\": self.a, \\"b\\": self.b, \\"c\\": self.c}"},{"question":"# Problem Statement: You need to implement a function that determines whether a given string pattern matches a given text entirely, using regular expression matching with support for two special characters: 1. `.` (dot) which matches any single character. 2. `*` (asterisk) which matches zero or more of the preceding element. The matching should cover the entire text (not just parts of it). # Function Signature: ``` def isMatch(text: str, pattern: str) -> bool: ``` # Input: - `text`: a string, the text to be matched. - `pattern`: a string, the regular expression pattern. # Output: - A boolean value indicating whether the text matches the pattern. # Constraints: * `text` will only contain lowercase letters (a-z). * `pattern` will only contain lowercase letters (a-z), `.` and `*`. * The length of `text` will be in the range [0, 2000]. * The length of `pattern` will be in the range [0, 2000]. # Example: Example 1: ``` Input: text = \\"aab\\", pattern = \\"c*a*b\\" Output: True ``` Example 2: ``` Input: text = \\"mississippi\\", pattern = \\"mis*is*p*.\\" Output: False ``` Example 3: ``` Input: text = \\"ab\\", pattern = \\".*\\" Output: True ``` # Requirements: - Implement efficient solutions to handle the given constraints. - Do not use any built-in regular expression libraries. - Ensure that the algorithm covers all possible edge cases. # Hint: Consider using dynamic programming to handle the variations and combinations of `.` and `*` in the pattern.","solution":"def isMatch(text: str, pattern: str) -> bool: # Create a DP table with dimensions (len(text) + 1) x (len(pattern) + 1) dp = [[False] * (len(pattern) + 1) for _ in range(len(text) + 1)] dp[0][0] = True # Both text and pattern are empty # Handle patterns like a*, a*b*, a*b*c* which can match with an empty text for j in range(2, len(pattern) + 1): if pattern[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, len(text) + 1): for j in range(1, len(pattern) + 1): if pattern[j-1] == text[i-1] or pattern[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif pattern[j-1] == \'*\': dp[i][j] = dp[i][j-2] # * means 0 occurrence if pattern[j-2] == text[i-1] or pattern[j-2] == \'.\': dp[i][j] |= dp[i-1][j] # * means 1 or more occurrence return dp[len(text)][len(pattern)]"},{"question":"# Question: Evaluate Mathematical Expressions with Variables You need to write a function `evaluate_expressions(variables, expressions)` that receives a dictionary of variables with their integer values and a list of strings representing mathematical expressions. Each expression may contain variables (as keys in the dictionary) and basic arithmetic operators (`+`, `-`, `*`, `/`). The function should return a list of evaluated results for each expression. Function Signature ```python def evaluate_expressions(variables: Dict[str, int], expressions: List[str]) -> List[float]: ``` Input * `variables` (Dict[str, int]): A dictionary where keys are variable names (strings) and values are their corresponding integer values. * `expressions` (List[str]): A list of strings, where each string represents a mathematical expression that can contain variables and basic arithmetic operators. Output * A list of floating-point numbers, each representing the evaluated result of the corresponding expression in the input list. Constraints * The variable names in the dictionary will be valid Python identifiers. * Expressions will always be valid and will not contain division by zero. * Expressions may contain spaces. * The length of the input list `expressions` will not exceed 100. * The possible operations in expressions are limited to `+`, `-`, `*`, `/`. Example ```python variables = {\'a\': 5, \'b\': 10, \'c\': 2} expressions = [\'a + b\', \'b * c\', \'a / c\'] evaluate_expressions(variables, expressions) # Should return [15.0, 20.0, 2.5] ``` Notes 1. Implement the function to handle the proper substitution of variables into the expressions. 2. Ensure that the function correctly evaluates the arithmetic expressions. 3. **Performance requirements**: Time complexity should be considered to ensure efficiency as you might need to substitute variables in potentially large expressions. This problem assesses the ability to interpret and evaluate mathematical expressions with variable substitutions, incorporating dictionary lookups and arithmetic computations.","solution":"from typing import Dict, List def evaluate_expressions(variables: Dict[str, int], expressions: List[str]) -> List[float]: results = [] for expression in expressions: # Create a local environment to evaluate the expression local_env = {var: value for var, value in variables.items()} try: result = eval(expression, {}, local_env) results.append(float(result)) except Exception as e: raise ValueError(f\\"Error evaluating expression \'{expression}\': {e}\\") return results"},{"question":"# Coding Assessment Question Scenario & Context You are a software developer working for a logistics company focused on optimizing route planning for delivery trucks. One of your tasks is to design a system that calculates the shortest possible route for a truck to deliver packages to multiple locations. The system should use a given list of delivery points (represented by their coordinates in a 2D plane) and find the optimal path that minimizes the total travel distance, returning back to the starting point. Problem Statement Implement a function `find_shortest_route` that computes the shortest delivery route using a simplified version of the Travelling Salesman Problem (TSP) algorithm. Function Specifications 1. **find_shortest_route** function: - **Input**: - `points` (list of tuples): A list where each tuple represents the coordinates (x, y) of a delivery point, including the starting point. - **Output**: - (list of tuples): The list of points in the order they should be visited to minimize the total distance, starting and ending at the first point in the list. - **Constraints**: - The list must contain at least 2 points and no more than 10 points. - Each point is a tuple of two floats. - **Error Handling**: - Raise an error if the number of points is less than 2 or exceeds 10. - Raise an error if any point does not contain exactly two float values. # Example ```python # Example 1 find_shortest_route([(0.0, 0.0), (2.0, 3.0), (5.0, 1.0)]) # Output: [(0.0, 0.0), (2.0, 3.0), (5.0, 1.0), (0.0, 0.0)] # Example 2 find_shortest_route([(1.0, 1.0), (4.0, 5.0), (7.0, 2.0), (6.0, 6.0)]) # Output: [(1.0, 1.0), (4.0, 5.0), (6.0, 6.0), (7.0, 2.0), (1.0, 1.0)] ``` Note * Use a brute-force approach for simplicity, as the number of points is constrained. * Ensure appropriate error handling, raising exceptions where necessary. * You may use Python\'s itertools library to generate permutations.","solution":"import itertools import math def find_shortest_route(points): Returns the shortest route to visit all points and return to the starting point. Args: points (list of tuples): A list where each tuple represents the coordinates (x, y). Returns: list of tuples: The list of points in the order they should be visited to minimize the total distance. if not (2 <= len(points) <= 10): raise ValueError(\\"The number of points must be between 2 and 10 inclusive.\\") for point in points: if not (isinstance(point, tuple) and len(point) == 2 and all(isinstance(coord, (int, float)) for coord in point)): raise ValueError(\\"Each point must be a tuple of two float values.\\") def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def total_distance(route): return sum(distance(route[i], route[i+1]) for i in range(len(route) - 1)) + distance(route[-1], route[0]) shortest_route = None min_distance = float(\'inf\') for perm in itertools.permutations(points[1:]): current_route = [points[0]] + list(perm) current_distance = total_distance(current_route) if current_distance < min_distance: shortest_route = current_route min_distance = current_distance return shortest_route + [points[0]]"},{"question":"# Unique Elements in a Sorted Array You are tasked with implementing a function that takes a sorted list of integers and returns a list containing only the unique elements in the same order. Function Signature ```python def unique_sorted_elements(arr: list[int]) -> list[int]: pass ``` Description 1. The function `unique_sorted_elements` receives a sorted list of integers, `arr`. 2. It returns a list of integers containing only the unique elements from `arr`, maintaining the given order. Input - A sorted list of integers `arr` where each integer ( |arr[i]| leq 10^6 ). Output - A list of integers containing only the unique elements from `arr`. Constraints - The function should handle input efficiently given the potentially large range and size of the list. - The input list can have up to ( 10^6 ) elements. Performance Requirements - The function should operate with a time complexity of (O(n)), where (n) is the length of the input list. # Example ```python print(unique_sorted_elements([1, 1, 2, 2, 3, 3])) Output: [1, 2, 3] print(unique_sorted_elements([0, 0, 0, 0, 0])) Output: [0] print(unique_sorted_elements([-3, -2, -2, -1, 0, 1, 1, 2, 3])) Output: [-3, -2, -1, 0, 1, 2, 3] ``` # Edge Cases 1. **Empty list**: The output should be an empty list. 2. **All elements are the same**: The output should only have one of those elements. 3. **One element list**: The output should be the list itself. By crafting your question this way, it remains consistent in style, complexity, and scope with the existing questions and checks a core programming concept of handling sorted arrays efficiently.","solution":"def unique_sorted_elements(arr: list[int]) -> list[int]: Given a sorted list of integers, returns a list containing only the unique elements in the same order. if not arr: return [] unique_elements = [arr[0]] for i in range(1, len(arr)): if arr[i] != arr[i - 1]: unique_elements.append(arr[i]) return unique_elements"},{"question":"# Binary Tree Inorder Traversal You are given a binary tree and your task is to implement an inorder traversal function. The inorder traversal of a binary tree is a depth-first traversal that visits the nodes in the following order: left subtree, root node, and right subtree. # Function Signature ```python def inorder_traversal(root: Optional[TreeNode]) -> List[int]: pass ``` # Input and Output * **Input**: - `root` (type: `Optional[TreeNode]`): The root node of the binary tree. A `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` * **Output**: - (type: `List[int]`): A list of integers representing the values of the nodes in inorder traversal order. # Constraints * The number of nodes in the binary tree is in the range `[0, 100]`. * `-100 <= Node.val <= 100` # Example ```python # Test case 1: # Input: root = [1, None, 2, 3] # Expected output: # [1, 3, 2] # Test case 2: # Input: root = [] # Expected output: # [] # Test case 3: # Input: root = [1] # Expected output: [1] # Test case 4: # Input: root = [1, 2] # Expected output: [2, 1] # Test case 5: # Input: root = [1, None, 2] # Expected output: [1, 2] # Test case to construct tree and call function: # Constructing the tree for test case 1 root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) # Expected output is [1, 3, 2] print(inorder_traversal(root)) ``` # Note - You should be able to handle an empty binary tree. - Make sure to handle the tree\'s traversal recursively or iteratively without creating unnecessary data structures or overhead.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: def inorder(node: Optional[TreeNode], result: List[int]): if not node: return inorder(node.left, result) result.append(node.val) inorder(node.right, result) result = [] inorder(root, result) return result"},{"question":"# Binary Tree Level Order Traversal Given the partially implemented `TreeNode` and `BinaryTree` class above, your task is to extend the functionality to implement a level order (breadth-first) traversal of a binary tree. You will need to: 1. **Implement the `level_order_traversal` method** in the `BinaryTree` class to return the values of the nodes in a level order sequence. # Implementation Details: 1. **`level_order_traversal` method** should: - Start from the root of the binary tree. - Traverse the tree level by level from left to right. - Collect and return a list of lists, where each list contains the values of each level. # Input/Output: - **Input**: ```python def level_order_traversal(self): # No input parameters required ``` - **Output**: - Return a list of lists of node values at each level, e.g., [[1], [2, 3], [4, 5, 6, 7]]. # Constraints: 1. The input assumes a valid binary tree structure initialized with the `TreeNode` and `BinaryTree` classes. 2. The tree can have any number of nodes, and values are integers. # Example Scenario: ```python # Assuming a binary tree is created and nodes are added root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) tree = BinaryTree(root) result = tree.level_order_traversal() print(result) # Output: [[1], [2, 3], [4, 5, 6, 7]] ``` # Notes: - Focus on implementing an efficient traversal method using a queue to achieve the level order traversal. - The method should handle trees of various sizes and depths. # TreeNode and BinaryTree Class Definitions: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): # Your implementation goes here ```","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self): if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_length = queue.__len__() current_level = [] for _ in range(level_length): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"As a software developer involved in data analytics, you need to efficiently analyze textual data to extract valuable insights. One common task is to count the frequency of words in a given text, which can be useful for identifying trends, user interests, or common issues in user feedback. Your task is to implement a function that counts the occurrences of each word in a list of text strings. # Function Description Implement the function `word_count(text_list)`. # Input - `text_list`: A list of strings, where each string represents a text document. # Output - Returns a dictionary where the keys are words (all in lowercase) and the values are the counts of occurrences of each word across all documents provided in `text_list`. # Constraints - Consider realistic practical limits to handle large text data effectively: - The list can contain up to 10,000 text strings. - Each text string can be up to 1,000 words long. - The function should handle special cases effectively: - If `text_list` is empty, return an empty dictionary. - Ignore punctuation and special characters. - Treat words as case-insensitive (e.g., \'Hello\' and \'hello\' should be counted as the same word). # Examples ```python word_count([\\"Hello world\\", \\"hello HELLO\\"]) # Output: {\'hello\': 3, \'world\': 1} word_count([\\"Data analytics is useful\\", \\"Analytics and data science\\"]) # Output: {\'data\': 2, \'analytics\': 2, \'is\': 1, \'useful\': 1, \'and\': 1, \'science\': 1} word_count([\\"\\"]) # Output: {} word_count([\\"This is a test\\", \\"This is only a test\\", \\"Test test test\\"]) # Output: {\'this\': 2, \'is\': 2, \'a\': 2, \'test\': 5, \'only\': 1} word_count([\\"@Hello world!\\", \\"Special: characters& should* be ignored.\\"]) # Output: {\'hello\': 1, \'world\': 1, \'special\': 1, \'characters\': 1, \'should\': 1, \'be\': 1, \'ignored\': 1} ``` During the implementation, be mindful of text preprocessing steps to effectively normalize the text, handle case sensitivity, and remove unwanted characters.","solution":"import re from collections import defaultdict def word_count(text_list): Counts the frequency of each word in a list of text strings. Parameters: text_list (list of str): A list of text documents. Returns: dict: A dictionary where keys are words and values are their counts. word_freq = defaultdict(int) for text in text_list: # Normalize text by removing special characters and converting to lowercase words = re.findall(r\'bw+b\', text.lower()) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"# Robotic Navigation in a Grid Problem Description You are tasked with implementing a navigation system for a robot in a two-dimensional grid. The grid is represented by a matrix of integers where `0` represents an empty cell, and `1` represents an obstacle. The robot can start at any cell containing a `0` and navigate to another destination cell containing a `0`, avoiding obstacles (cells with `1`). For this problem, you will implement functions to: 1. Find the shortest path (if any) from the start cell to the destination cell using Breadth-First Search (BFS) algorithm. 2. Generate a visual representation of the path found, marking the visited cells. Requirements: 1. **Shortest Path Function**: Implement the function `shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]` that finds and returns the shortest path from the `start` cell to the `end` cell. Each cell in the path should be represented as a tuple of its `(row, column)` indices. 2. **Path Visualization Function**: Implement the function `visualize_path(grid: list[list[int]], path: list[tuple[int, int]]) -> list[list[str]]` that generates a visual representation of the grid showing the path with a specific marker (e.g., `\'P\'`). Unvisited empty cells should be marked as `\'.\'`, obstacles as `\'#\'`, and visited cells that are part of the path should be marked as `\'P\'`. 3. **Main Function**: - Create `navigate_robot` that accepts the grid, the starting coordinates, and the destination coordinates, then returns the visual representation of the path if a path exists. If no path exists, the function should return a message indicating that. Constraints: - The grid will be a non-empty list of lists with dimensions up to 50x50. - The start and end coordinates will always be valid cells within the grid. - The cells of coordinates are zero-indexed. - The robot can only move up, down, left, and right (no diagonal moves). Example: ```python grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) end = (4, 3) visual_grid = navigate_robot(grid, start, end) for row in visual_grid: print(\' \'.join(row)) ``` Expected Output: ``` P P # . # P # . . P P P . # # P . . . P ``` Or if no path is found: ``` No valid path available from the start to the end. ``` Solution Template ```python from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: # Implement the function pass def visualize_path(grid: List[List[int]], path: List[Tuple[int, int]]) -> List[List[str]]: # Implement the function pass def navigate_robot(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[List[str]]: path = shortest_path(grid, start, end) if path: return visualize_path(grid, path) else: return \\"No valid path available from the start to the end.\\" # Example Usage grid = [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] start = (0, 0) end = (4, 3) visual_grid = navigate_robot(grid, start, end) if isinstance(visual_grid, str): print(visual_grid) else: for row in visual_grid: print(\' \'.join(row)) ```","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start, [start])]) visited = set(start) while queue: (current, path) = queue.popleft() if current == end: return path for d in directions: r, c = current[0] + d[0], current[1] + d[1] if 0 <= r < rows and 0 <= c < cols and grid[r][c] == 0 and (r, c) not in visited: visited.add((r, c)) queue.append(((r, c), path + [(r, c)])) return [] def visualize_path(grid: List[List[int]], path: List[Tuple[int, int]]) -> List[List[str]]: rows, cols = len(grid), len(grid[0]) visual_grid = [[\'.\' if grid[r][c] == 0 else \'#\' for c in range(cols)] for r in range(rows)] for r, c in path: visual_grid[r][c] = \'P\' return visual_grid def navigate_robot(grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> List[List[str]]: path = shortest_path(grid, start, end) if path: return visualize_path(grid, path) else: return \\"No valid path available from the start to the end.\\""}]'),N={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},L={class:"search-container"},O={class:"card-container"},R={key:0,class:"empty-state"},F=["disabled"],z={key:0},D={key:1};function P(r,e,l,m,s,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",L,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",O,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,F)):u("",!0)])}const j=c(N,[["render",P],["__scopeId","data-v-f7cad0b5"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/12.md","filePath":"drive/12.md"}'),Y={name:"drive/12.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,V as default};
