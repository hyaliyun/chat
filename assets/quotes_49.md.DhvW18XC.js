import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as w,e as v,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-a4c73ed5"]]),S=JSON.parse('[{"question":"# Task: Implement a Custom Sorting Algorithm with Custom Comparator Scenario You are tasked with implementing a custom sorting algorithm using a provided comparator function. The comparator function defines how to compare two elements and must be used with your sorting algorithm. Core Requirements Create a custom sorting function that accepts a list of elements and a comparator function. Your sorting function should be able to sort any list of elements based on the rules defined in the comparator function. Function Specifications You need to implement the following function: 1. `custom_sort(arr: list, comparator: Callable[[Any, Any], int]) -> list` Input - `arr` (list): The list of elements to be sorted. The elements can be of any type, depending on the comparator. - `comparator` (Callable[[Any, Any], int]): A comparator function that takes two arguments and returns a negative number if the first argument is less than the second, zero if they are equal, and a positive number if the first argument is greater. Output - Returns a list of elements sorted according to the comparator function. Constraints - The function should handle edge cases such as an empty list or lists with only one element. - The comparator function should be used to define the order of the elements. - Assume the comparator function will be provided and correctly implemented. Performance Requirements - The sorting algorithm should aim for an average time complexity of (O(n log n)) where `n` is the number of elements in the list. Example ```python # Custom comparator function for sorting numbers in descending order def descending_comparator(x, y): return y - x # Example usage arr = [5, 3, 8, 1, 2] sorted_arr = custom_sort(arr, descending_comparator) print(sorted_arr) # Output should be [8, 5, 3, 2, 1] # Custom comparator function for sorting strings by length def length_comparator(x, y): return len(x) - len(y) # Example usage arr = [\\"apple\\", \\"banana\\", \\"pear\\", \\"kiwi\\"] sorted_arr = custom_sort(arr, length_comparator) print(sorted_arr) # Output should be [\\"pear\\", \\"kiwi\\", \\"apple\\", \\"banana\\"] ``` # Explanation In this task, your custom sorting function should use the provided comparator to determine the order of elements in the list. The output should be a list of elements sorted according to the comparator\'s logic. Test cases must verify that the sorting adheres to the comparator\'s rules under different types and orders of input data.","solution":"from typing import List, Callable, Any def custom_sort(arr: List[Any], comparator: Callable[[Any, Any], int]) -> List[Any]: Custom sort function that sorts an array based on a provided comparator. Parameters: arr (list): The list of elements to be sorted. comparator (function): A comparator function that takes two arguments and returns a negative number if the first argument is less than the second, zero if they are equal, and a positive number if the first argument is greater. Returns: list: Sorted list according to the comparator function. def merge_sort(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left, right): sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if comparator(left[i], right[j]) <= 0: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 sorted_list.extend(left[i:]) sorted_list.extend(right[j:]) return sorted_list return merge_sort(arr)"},{"question":"# Coding Question: Merge Two Sorted Arrays **Scenario**: You are working on a project that requires combining data from two different sorted sources. Your task is to merge two sorted arrays into a single sorted array without using any additional libraries. This operation is critical for maintaining the overall data consistency and performance of the system. **Problem Statement**: Implement a function `merge_sorted_arrays` that takes two sorted arrays and returns a single sorted array by merging them. # Requirements: - **Input**: - Two sorted arrays of integers, `array1` and `array2`. - **Output**: - A single sorted array containing all elements from `array1` and `array2`. # Constraints: 1. Both input arrays are sorted in non-decreasing order. 2. The output array must be sorted in non-decreasing order. 3. The function should handle empty arrays gracefully. # Function Signature: ```python def merge_sorted_arrays(array1: list[int], array2: list[int]) -> list[int]: pass ``` # Implementation Details: Your function should handle various edge cases including: - Both arrays are empty. - One array is empty and the other is non-empty. - Both arrays contain elements. - Arrays of different lengths. # Examples: 1. **Example 1**: ```python array1 = [1, 3, 5] array2 = [2, 4, 6] assert merge_sorted_arrays(array1, array2) == [1, 2, 3, 4, 5, 6] ``` 2. **Example 2**: ```python array1 = [] array2 = [1, 2, 3] assert merge_sorted_arrays(array1, array2) == [1, 2, 3] ``` 3. **Example 3**: ```python array1 = [5, 10, 15] array2 = [10, 20, 30] assert merge_sorted_arrays(array1, array2) == [5, 10, 10, 15, 20, 30] ``` 4. **Example 4**: ```python array1 = [1, 2, 2] array2 = [2, 2, 3] assert merge_sorted_arrays(array1, array2) == [1, 2, 2, 2, 2, 3] ``` **Note**: Consider using a two-pointer technique to merge the arrays efficiently in terms of time complexity.","solution":"def merge_sorted_arrays(array1: list[int], array2: list[int]) -> list[int]: Merges two sorted arrays into a single sorted array. Parameters: array1 (list of int): First sorted array. array2 (list of int): Second sorted array. Returns: list of int: Merged sorted array. merged_array = [] i = 0 j = 0 while i < len(array1) and j < len(array2): if array1[i] < array2[j]: merged_array.append(array1[i]) i += 1 else: merged_array.append(array2[j]) j += 1 while i < len(array1): merged_array.append(array1[i]) i += 1 while j < len(array2): merged_array.append(array2[j]) j += 1 return merged_array"},{"question":"# Context You are given a list of integers, and you need to find the maximum sum that can be obtained by summing up a subsequence of the list such that no two elements in the subsequence are adjacent in the original list. # Function Signature Write a function called `max_non_adjacent_sum` that takes in a list of integers and returns an integer. # Input * A list ( nums ) of integers. - ( 0 leq |nums| leq 10^5 ) - ( -10^4 leq text{nums}[i] leq 10^4 ) # Output * Returns an integer representing the maximum sum of a non-adjacent subsequence. # Constraints 1. Your implementation should strive for efficient time and space complexity. 2. Consider edge cases such as an empty list or a list with a single element. # Examples * `max_non_adjacent_sum([3, 2, 5, 10, 7])` should return `15`. * `max_non_adjacent_sum([-1, 2, 4, 6, -3, 2])` should return `10`. * `max_non_adjacent_sum([2, 1, 4, 9, 7])` should return `13`. * `max_non_adjacent_sum([5, 5, 10, 100, 10, 5])` should return `110`. # Implementation Ensure to handle edge cases appropriately and aim for clear and efficient code.","solution":"def max_non_adjacent_sum(nums): Returns the maximum sum of a non-adjacent subsequence. Args: nums (list of int): Input list of integers. Returns: int: Maximum sum of a non-adjacent subsequence. if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = 0 # Maximum sum including the current element exclude = 0 # Maximum sum excluding the current element for num in nums: new_exclude = max(include, exclude) include = exclude + num exclude = new_exclude return max(include, exclude)"},{"question":"# Scenario You are developing a data manipulation library designed to handle various data structures. The library currently supports basic operations such as adding or removing elements from lists, but it lacks the ability to perform advanced list transformations. Your task is to implement a function that efficiently flattens a nested list of arbitrary depth. # Problem Statement Implement a function `flatten_list(nested_list: List[Any]) -> List[Any]` that takes a nested list and returns a single flat list containing all the elements. The original order of elements must be preserved, and only the nesting structure should be removed. # Specifications * **Input**: A nested list `nested_list` which can contain elements of any type, including other lists, and is potentially deeply nested. * **Output**: A single flat list with all elements from the input list in the same order. * **Constraints**: * The nested list can have elements of various depths and data types. * The function should handle lists with up to 10^5 total elements efficiently. * **Performance**: Aim for a time complexity of O(n), where n is the total number of elements in the nested list. # Example ```python # Example 1 input_list = [1, [2, [3, 4]], 5] output_list = flatten_list(input_list) print(output_list) # Expected output: [1, 2, 3, 4, 5] # Example 2 input_list = [[[\'a\'], \'b\'], \'c\', [[[\'d\']]]] output_list = flatten_list(input_list) print(output_list) # Expected output: [\'a\', \'b\', \'c\', \'d\'] # Example 3 input_list = [1, [2, [3, [4, [5, [6]]]]]] output_list = flatten_list(input_list) print(output_list) # Expected output: [1, 2, 3, 4, 5, 6] ``` # Bonus Enhance the function to support flattening generators or other iterable types, making it more flexible for different use cases.","solution":"from typing import Any, List def flatten_list(nested_list: List[Any]) -> List[Any]: This function takes in a nested list and returns a single flat list containing all the elements. flat_list = [] def _flatten(inner_list): for element in inner_list: if isinstance(element, list): _flatten(element) else: flat_list.append(element) _flatten(nested_list) return flat_list"},{"question":"# Coding Assessment Question **Matrix Transpose with Inplace Constraint** Implement an efficient algorithm to transpose a square matrix in-place. The transpose of a matrix flips a matrix over its diagonal, which means switching the row and column indices of the matrix. Your function should modify the input matrix directly and should not return anything. Your task is to write a function: 1. **transpose(matrix: List[List[int]]) -> None**: - Implement the in-place transposing of the matrix. - **Input**: A list of lists `matrix` representing a square matrix of size n x n, where each element is an integer. - **Output**: The function returns `None`. It modifies the input matrix in place to be its own transpose. Be sure to handle potential edge cases appropriately, and use efficient methods to minimize the time complexity, especially since the matrix can be large. **Example**: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> transpose(matrix) >>> matrix [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` **Constraints**: - Assume the input matrix will always be a square matrix. - The matrix elements will only consist of integers. - The matrix size can be large, so focus on an efficient algorithm.","solution":"def transpose(matrix): Transposes the given square matrix in-place. Args: matrix (List[List[int]]): n x n matrix Returns: None n = len(matrix) for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Problem Statement You are tasked with designing a function that helps a library system categorize books into various sections based on genre. Each genre section should contain an equal number of books as much as possible. Any remainder books should be distributed starting from the first section. Objective Implement a function `categorize_books` that takes in a list of `books` and organizes them into `genres` sections as evenly as possible. Function Signature ```python def categorize_books(books: list[str], genres: int) -> list[list[str]]: pass ``` Input * `books` (list[str]): A list of book titles to be categorized, where 1 <= len(books) <= 10^6. * `genres` (int): The number of genre sections to divide the books into, where 1 <= genres <= len(books). Output * A list of lists, where each inner list contains book titles assigned to that genre section. Constraints * If `genres <= 0`, raise a `ValueError` with the message \\"genres must be a positive number!\\". * If `genres > len(books)`, raise a `ValueError` with the message \\"genres can not be greater than the number of books!\\". Example ```python assert categorize_books([\\"Book1\\", \\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book5\\"], 2) == [[\\"Book1\\", \\"Book2\\", \\"Book3\\"], [\\"Book4\\", \\"Book5\\"]] assert categorize_books([\\"Book1\\", \\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book5\\", \\"Book6\\"], 3) == [[\\"Book1\\", \\"Book2\\"], [\\"Book3\\", \\"Book4\\"], [\\"Book5\\", \\"Book6\\"]] try: categorize_books([\\"Book1\\", \\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book5\\"], 10) except ValueError as e: assert str(e) == \\"genres can not be greater than the number of books!\\" try: categorize_books([\\"Book1\\", \\"Book2\\", \\"Book3\\", \\"Book4\\", \\"Book5\\"], 0) except ValueError as e: assert str(e) == \\"genres must be a positive number!\\" ``` # Requirements 1. You must handle edge cases where `genres` is greater than the number of books or where `genres` is non-positive. 2. The solution must ensure optimal distribution of books with minimal discrepancies in the number of books per genre section.","solution":"def categorize_books(books: list[str], genres: int) -> list[list[str]]: Categorizes books into the specified number of genre sections as evenly as possible. Parameters: books (list of str): List of book titles. genres (int): Number of genre sections. Returns: list of list of str: List of genre sections, each containing book titles. Raises: ValueError: If genres <= 0 or genres > len(books). if genres <= 0: raise ValueError(\\"genres must be a positive number!\\") if genres > len(books): raise ValueError(\\"genres can not be greater than the number of books!\\") # Initialize the genre sections with empty lists book_sections = [[] for _ in range(genres)] num_books = len(books) books_per_genre = num_books // genres remainder_books = num_books % genres # Distribute books evenly across sections index = 0 for i in range(genres): # Each genre gets at least books_per_genre books for _ in range(books_per_genre): book_sections[i].append(books[index]) index += 1 # Distribute any remaining books to the first (remainder_books) sections if remainder_books > 0: book_sections[i].append(books[index]) index += 1 remainder_books -= 1 return book_sections"},{"question":"# Coding Question You are tasked with implementing a function that transforms a given list of integers such that every element in the list becomes the product of all the integers in the original list except the one at the current index. To achieve this, you must do so without using division and in O(n) time complexity. # Task Implement the function `product_except_self()` which takes a list of integers as input and returns a list of integers where each element is the product of all elements in the input list except for the element at the same index. # Function Signature ```python def product_except_self(nums: list[int]) -> list[int]: ``` # Input - `nums`: A list of integers. # Output - A list of integers where each index `i` contains the product of all integers in the input list except the one at `i`. # Constraints - The function should handle lists efficiently. - Number of elements in the list, `n` can range from 1 to 10^5. - Elements can be negative, zero, or positive. # Example ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] >>> product_except_self([1]) [1] ``` # Performance Requirements - Ensure the solution avoids using division and achieves the transformation in O(n) time complexity.","solution":"def product_except_self(nums: list[int]) -> list[int]: n = len(nums) # Initialize the answer array with 1 results = [1] * n # Calculate left products left_product = 1 for i in range(n): results[i] = left_product left_product *= nums[i] # Calculate right products and multiply with left products right_product = 1 for i in range(n-1, -1, -1): results[i] *= right_product right_product *= nums[i] return results"},{"question":"# Coding Assessment Question Context You have been tasked to manipulate lists which are frequently required in data manipulation tasks. One such task is to flatten a nested list. For example, the list `[1, [2, [3, 4], [5]], 6, [[7, 8]]]` should be flattened to `[1, 2, 3, 4, 5, 6, 7, 8]`. Problem Description Write a function `flatten_list` that takes a list with potentially nested sub-lists and returns a new list with all the values flattened into a single level. Input and Output - **Input**: - A potentially nested list `nested_list`. - **Output**: - Returns a flattened list containing all values from the input list. - Raises a `TypeError` if the input is not a list. Constraints - You are only allowed to use standard Python libraries. - The function should be able to handle multiple levels of nesting. - Elements in the list can be of any data type, but will not themselves be lists. Examples ``` >>> flatten_list([1, [2, [3, 4], [5]], 6, [[7, 8]]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> flatten_list([1, [2, [3], 4], 5]) [1, 2, 3, 4, 5] >>> flatten_list([1, [2, \'hello\', [3.5, 4], [5]], 6, [[7, 8]]]) [1, 2, \'hello\', 3.5, 4, 5, 6, 7, 8] >>> flatten_list(123) Traceback (most recent call last): ... TypeError: Input must be a list. ``` Hints - Consider writing a helper function to handle the flattening process recursively. - You might use type-checking to ensure the input is a list and correctly handle nested structures.","solution":"def flatten_list(nested_list): Flattens a nested list into a single-level list. Args: nested_list (list): A potentially nested list. Returns: list: A flattened list containing all values from the input list. Raises: TypeError: If the input is not a list. if not isinstance(nested_list, list): raise TypeError(\\"Input must be a list.\\") def _flatten(inner_list): for item in inner_list: if isinstance(item, list): yield from _flatten(item) else: yield item return list(_flatten(nested_list))"},{"question":"Task Description You are given a list of integers representing the ages of participants in a marathon. Implement a function `median_age_participants(ages: list[int]) -> float` that returns the median age of the participants. # Function Signature ```python def median_age_participants(ages: list[int]) -> float: ``` # Input - **ages**: A list of integers where each integer represents the age of a participant. # Output - A float representing the median age of the participants. # Constraints - Each age is a positive integer from 1 to 100. - The list `ages` will have at most `10^5` elements. - The list may be empty, in which case the function should return `0.0`. # Example Given the list of ages: ``` [34, 29, 35, 30, 32] ``` The sorted list is: ``` [29, 30, 32, 34, 35] ``` The median age is `32.0`. For another example, given the list of ages: ``` [34, 29, 35, 30] ``` The sorted list is: ``` [29, 30, 34, 35] ``` The median age is `(30 + 34) / 2 = 32.0`. # Notes - Ensure your solution handles both even and odd numbers of elements correctly. - Consider performance optimizations for large lists. - Ensure your solution returns a float, even if the median is an integer. # Implementation Implement the function `median_age_participants` in Python. The function should handle large inputs efficiently and cover edge cases like an empty list.","solution":"def median_age_participants(ages): Returns the median age of the participants. if not ages: return 0.0 sorted_ages = sorted(ages) n = len(sorted_ages) middle = n // 2 if n % 2 == 0: # if even, average of the two middle numbers median = (sorted_ages[middle - 1] + sorted_ages[middle]) / 2.0 else: # if odd, the middle number median = float(sorted_ages[middle]) return median"},{"question":"# Coding Challenge: String Compression Algorithm Objective Create a function that implements a simple lossless string compression algorithm, which compresses repeated characters in a string. Problem Statement Write a function `compress_string(text: str) -> str` that takes a string `text` as input and returns a compressed version of the string where consecutive occurrences of the same character are replaced with the character followed by the number of occurrences. If the compressed string is not shorter than the original string, return the original string. Function Signature ```python def compress_string(text: str) -> str: # Your code here ``` Input - `text`: a string `text` (0 <= len(text) <= 10^6) - the string to be compressed. Output - Returns the compressed string if it is shorter than the original string, otherwise returns the original string. Constraints - The function should handle both upper and lower case letters. - The function must operate efficiently, even for the largest allowable input sizes. Example ```python >>> compress_string(\\"aabcccccaaa\\") \\"2a1b5c3a\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"a\\") \\"a\\" >>> compress_string(\\"\\") \\"\\" ``` Performance Requirements - The function should have linear time complexity, O(n), where n is the length of the input string. Detailed Instructions 1. Traverse the input string and keep track of consecutive characters and their counts. 2. Build the compressed version of the string using the character and its count. 3. Compare the length of the compressed string with the original string. 4. Return the compressed string if it is shorter, otherwise return the original string. Edge Cases to Consider - Testing strings with no repeated characters. - Very short strings, including the empty string. - Strings where the compressed version may be longer than or equal to the original string. - Large strings with repetitive patterns for performance testing.","solution":"def compress_string(text: str) -> str: if not text: return text compressed = [] count = 1 prev_char = text[0] for char in text[1:]: if char == prev_char: count += 1 else: compressed.append(f\\"{count}{prev_char}\\") prev_char = char count = 1 compressed.append(f\\"{count}{prev_char}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(text) else text"},{"question":"Context You are working on a web application that involves user authentication and session management. Your task is to ensure that sessions are properly managed to prevent unauthorized access and to track user activity. Task Implement a function named `manage_user_sessions` that performs the following steps: 1. Takes in a list of user activity logs and a list of authorized user IDs. 2. Each activity log is a dictionary containing `user_id`, `timestamp`, and `action`. 3. The function should: - Filter out activity logs where the user is not in the list of authorized user IDs. - For each remaining log, check if the action is `start_session` or `end_session`. - Maintain an active session for each user by updating a dictionary with session start and end times. 4. Compute the total duration of active sessions for each user and return a dictionary with user IDs as keys and their total session durations as values. Implementation Requirements - **Function Signature**: `def manage_user_sessions(activity_logs: list[dict], authorized_user_ids: list[int]) -> dict[int, int]:` - **Input**: - `activity_logs`: List of dictionaries. Each dictionary contains: - `user_id` (int): ID of the user performing the action. - `timestamp` (int): Timestamp of the action in seconds. - `action` (str): Action performed, either \'start_session\' or \'end_session\'. - `authorized_user_ids`: List of integers representing IDs of authorized users. - **Output**: A dictionary where each key is a user ID and the value is the total session duration in seconds for that user. Example ```python # Example usage: activity_logs = [ {\\"user_id\\": 1, \\"timestamp\\": 1609459200, \\"action\\": \\"start_session\\"}, {\\"user_id\\": 2, \\"timestamp\\": 1609459260, \\"action\\": \\"start_session\\"}, {\\"user_id\\": 1, \\"timestamp\\": 1609462800, \\"action\\": \\"end_session\\"}, {\\"user_id\\": 2, \\"timestamp\\": 1609466400, \\"action\\": \\"end_session\\"} ] authorized_user_ids = [1, 2] # Expected output { 1: 3600, # 1 hour session 2: 7140 # 1 hour 59 minutes session } ``` Constraints - Assume that `start_session` and `end_session` actions are well-formed (i.e., each `start_session` has a corresponding `end_session`). - Each user ID will have at most one active session at a time (i.e., no overlapping sessions). - Unauthorized activity logs should be ignored. - If a `start_session` action is recorded and no `end_session` action is present for that user in the logs, it should be ignored. Notes - Optimize for large lists of activity logs (up to (10^6) logs). - Handle potential edge cases like empty input lists or logs that belong to unauthorized users. - Ensure proper error handling for malformed log entries (e.g., missing keys or incorrect data types).","solution":"def manage_user_sessions(activity_logs, authorized_user_ids): Manage user sessions based on activity logs and authorized user IDs. Args: - activity_logs (list of dict): List of user activity logs. - authorized_user_ids (list of int): List of authorized user IDs. Returns: - dict of int: int: Dictionary with user ids as keys and total session durations in seconds as values. authorized_user_sessions = {user_id: [] for user_id in authorized_user_ids} user_sessions = {user_id: 0 for user_id in authorized_user_ids} session_starts = {} for log in activity_logs: user_id = log.get(\\"user_id\\") timestamp = log.get(\\"timestamp\\") action = log.get(\\"action\\") if user_id not in authorized_user_ids: continue if action == \\"start_session\\": session_starts[user_id] = timestamp elif action == \\"end_session\\": if user_id in session_starts: duration = timestamp - session_starts[user_id] user_sessions[user_id] += duration del session_starts[user_id] return user_sessions"},{"question":"# Longest Consecutive Sequence Context You are developing a feature for a social media application that tracks daily user activities on the platform. One of the metrics you\'re interested in analyzing is the longest streak of consecutive days a user has been active. This feature can be represented by finding the longest sequence of consecutive integers in a list. Task Implement a function `longest_consecutive_sequence` that takes an unordered list of integers representing the days a user was active and returns the length of the longest consecutive sequence of days. Function Signature ```python def longest_consecutive_sequence(days: list[int]) -> int: ``` Input - `days` (list of int): A list of integers representing days a user was active. The list can be empty. Output - The function should return an integer representing the length of the longest consecutive sequence of days in the list. - If the input list is empty, return `0`. Constraints - The input array can have up to 10^5 elements. - The elements of the array are integers within the range of 1 to 10^6. Examples 1. `longest_consecutive_sequence([100, 4, 200, 1, 3, 2])` - Returns: `4`, the longest consecutive sequence is `[1, 2, 3, 4]`. 2. `longest_consecutive_sequence([5, 6, 7, 8, 9, 10, 1])` - Returns: `6`, the longest consecutive sequence is `[5, 6, 7, 8, 9, 10]`. 3. `longest_consecutive_sequence([1, 3, 5, 7, 9])` - Returns: `1`, each number is its own consecutive sequence. 4. `longest_consecutive_sequence([10, 5, 7, 12, 3])` - Returns: `1`, each number is its own consecutive sequence. 5. `longest_consecutive_sequence([])` - Returns: `0`, since the array is empty. Performance Requirement The implementation should efficiently handle large inputs. An `O(n)` solution that leverages a set data structure is expected.","solution":"def longest_consecutive_sequence(days): if not days: return 0 days_set = set(days) longest_streak = 0 for day in days_set: if day - 1 not in days_set: current_day = day current_streak = 1 while current_day + 1 in days_set: current_day += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Integer Partition Sum Given an integer `n`, write a function `count_partitions(n: int) -> int` that returns the number of distinct ways to partition `n` into sums of positive integers. Two partitions that only differ in the order of their summands should be considered the same. Function Signature: ```python def count_partitions(n: int) -> int: ``` Input: * `n`: An integer where `1 ≤ n ≤ 100` Output: * An integer representing the number of distinct partitions of `n`. Example: ```python assert count_partitions(4) == 5 # The partitions are: [4], [3,1], [2,2], [2,1,1], [1,1,1,1] ``` # Notes: * Ensure your function is optimized to handle the upper limit of the input constraint. * Discuss any possible recursive or iterative approaches you considered in your documentation. * Handle the edge case where `n` is at its minimum constraint correctly (e.g., `n = 1`).","solution":"def count_partitions(n: int) -> int: Returns the number of distinct ways to partition n into sums of positive integers. # Create a table to store results of subproblems dp = [0] * (n + 1) dp[0] = 1 # Base case: There is one way to partition 0 (with no parts) # Fill the dp table for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"**Introduction**: You are tasked with developing a solution to evaluate mathematical expressions represented as strings. These expressions may include integers, addition, and subtraction operators. This problem will test your understanding of string processing and basic arithmetic evaluation. **Problem**: Implement the method `evaluate_expression(expression: str) -> int`. The method should parse and evaluate the given string expression which contains integers and the \'+\' and \'-\' operators, returning the computation result. **Input**: - A string `expression` consisting of non-negative integers, \'+\' and \'-\' operators, and possibly with whitespace characters. **Output**: - An integer which is the result of the evaluated expression. **Constraints**: - The length of the `expression` is at most 1000 characters. - The `expression` is a valid arithmetic expression and may have leading or trailing spaces. - All intermediate results and final result fit within the standard 32-bit integer range. **Example**: ```python >>> evaluate_expression(\\"3 + 2 - 4\\") 1 >>> evaluate_expression(\\"10+ 20 - 5 + 3\\") 28 ``` **Requirements**: - Manage and ignore any whitespace characters in the `expression`. - Ensure the method correctly follows the order of operations (left-to-right for addition and subtraction). **Additional**: - You are encouraged to create helper methods if needed. - Avoid using the built-in `eval` function for this task.","solution":"def evaluate_expression(expression: str) -> int: Evaluate a simple mathematical expression containing integers, \'+\' and \'-\' operators. tokens = [] current_number = \'\' # Remove all whitespaces from the expression expression = expression.replace(\' \', \'\') for ch in expression: if ch.isdigit(): current_number += ch else: if current_number: tokens.append(int(current_number)) current_number = \'\' tokens.append(ch) if current_number: tokens.append(int(current_number)) # Evaluate the tokens result = tokens[0] index = 1 while index < len(tokens): operator = tokens[index] next_number = tokens[index + 1] if operator == \'+\': result += next_number elif operator == \'-\': result -= next_number index += 2 return result"},{"question":"Coding Question # Problem You are given a list of non-negative integers `nums` where each item represents the maximum number of steps you can jump forward from that position. Implement a function `can_reach_end(nums: list[int]) -> bool` to determine if you can reach the last index starting from the first index. # Input * A list of non-negative integers `nums` where `1 <= len(nums) <= 10^5` and `0 <= nums[i] <= 10^4`. # Output * A boolean value `True` if it is possible to reach the last index, otherwise `False`. # Constraints * The function should execute in O(n) time complexity. # Examples 1. Input: `nums = [2, 3, 1, 1, 4]` Output: `True` (You can jump 1 step from index 0 to 1, then 3 steps to the last index.) 2. Input: `nums = [3, 2, 1, 0, 4]` Output: `False` (You will always arrive at index 3 but there is no way to go beyond it.) # Notes * Consider edge cases such as a single-element list or lists where the first element is zero. # Implementation Requirements * The function must handle all edge cases and constraints efficiently. * Do not use additional data structures that grow with the input size.","solution":"def can_reach_end(nums): Determines if it is possible to reach the last index from the first index in the given list of numbers. :param nums: List of non-negative integers where each item represents the maximum number of steps you can jump forward from that position. :return: Boolean value indicating whether it is possible to reach the last index from the first index. farthest = 0 for i in range(len(nums)): if i > farthest: return False farthest = max(farthest, i + nums[i]) return True"},{"question":"Problem Statement You are given a list of integers. A triplet (a, b, c) is called a \\"Pythagorean triplet\\" if it satisfies the equation a^2 + b^2 = c^2. The task is to determine if there exists any Pythagorean triplet in the given list. # Task Write a function `has_pythagorean_triplet` that determines if there are three numbers in the list that form a Pythagorean triplet. # Input Format - A list of integers `lst` representing the given list of numbers. # Output Format - A boolean value `True` if there exists a Pythagorean triplet in the list, otherwise `False`. # Constraints - 1 <= len(lst) <= 10^3 - 1 <= lst[i] <= 10^3 for all i # Function Signature ```python def has_pythagorean_triplet(lst: list) -> bool: pass ``` # Example Input ```python lst = [3, 1, 4, 6, 5] ``` Output ```python True ``` Explanation The numbers 3, 4, and 5 form a Pythagorean triplet because 3^2 + 4^2 = 5^2 -> 9 + 16 = 25. Input ```python lst = [10, 4, 6, 12, 5] ``` Output ```python False ``` Explanation There are no three numbers in this list that satisfy the Pythagorean triplet condition.","solution":"def has_pythagorean_triplet(lst: list) -> bool: Determines if there exists any Pythagorean triplet in the list. :param lst: List of integers. :return: True if there exists a Pythagorean triplet, otherwise False. # Square all the elements and store in a set for efficient lookup squares = {x**2 for x in lst} n = len(lst) # Check all pairs (a, b) to see if a^2 + b^2 is in the squares set for i in range(n): for j in range(i + 1, n): a2 = lst[i] ** 2 b2 = lst[j] ** 2 if a2 + b2 in squares: return True return False"},{"question":"# Problem Statement You are developing a software for a virtual art gallery that needs to manage and visualize paintings in different frames. Each painting has specific dimensions, such as height and width, and must fit within frames that have their dimensions. The system must determine whether a painting can fit into a given frame based on its dimensions. Write a Python function `can_fit` that takes a `Painting` instance and a `Frame` instance and determines if the painting can fit within the frame both vertically and horizontally. The painting can only fit if both the height and width of the painting are less than or equal to the frame dimensions. # Input Format - An instance of the `Painting` class, with integer attributes `height` and `width` representing the dimensions of the painting. - An instance of the `Frame` class, with integer attributes `height` and `width` representing the dimensions of the frame. # Output Format - A single boolean value: `True` if the painting can fit within the frame, `False` otherwise. # Constraints - Each dimension (height and width) for both paintings and frames is an integer in the range [1, 1000]. # Example ```python # Example 1 painting1 = Painting(10, 20) frame1 = Frame(15, 25) print(can_fit(painting1, frame1)) # Output: True # Example 2 painting2 = Painting(30, 40) frame2 = Frame(25, 35) print(can_fit(painting2, frame2)) # Output: False # Example 3 painting3 = Painting(1000, 1000) frame3 = Frame(1000, 1000) print(can_fit(painting3, frame3)) # Output: True ``` # Implementation Below is the provided code snippet for the class definitions and function: ```python class Painting: def __init__(self, height, width): self.height = height self.width = width def __repr__(self) -> str: return f\\"Painting({self.height}, {self.width})\\" class Frame: def __init__(self, height, width): self.height = height self.width = width def __repr__(self) -> str: return f\\"Frame({self.height}, {self.width})\\" def can_fit(painting: Painting, frame: Frame) -> bool: Determine if the painting can fit within the frame based on its dimensions. return painting.height <= frame.height and painting.width <= frame.width ``` Your task is to write a function `can_fit` as specified above.","solution":"class Painting: def __init__(self, height, width): self.height = height self.width = width def __repr__(self) -> str: return f\\"Painting({self.height}, {self.width})\\" class Frame: def __init__(self, height, width): self.height = height self.width = width def __repr__(self) -> str: return f\\"Frame({self.height}, {self.width})\\" def can_fit(painting: Painting, frame: Frame) -> bool: Determine if the painting can fit within the frame based on its dimensions. return painting.height <= frame.height and painting.width <= frame.width"},{"question":"# Problem Statement: Create a function `format_date` that converts a date string from one format to another. The function should take three arguments: the input date string, the input format string, and the output format string. Use the following format codes: - `%Y`: Year with century (e.g., 2023) - `%m`: Month as a zero-padded decimal number (e.g., 01 for January) - `%d`: Day of the month as a zero-padded decimal number (e.g., 05) - `%H`: Hour in 24-hour clock as a zero-padded decimal number (e.g., 15) - `%M`: Minute as a zero-padded decimal number (e.g., 09) - `%S`: Second as a zero-padded decimal number (e.g., 05) The function should correctly parse the input date string based on the input format and then convert it to the output format. **Function Signature**: ```python def format_date(date_string: str, input_format: str, output_format: str) -> str: pass ``` # Requirements: * Implement the `format_date` function. * Validate that the date string matches the input format. If it doesn\'t, raise a `ValueError` with an appropriate message. * Handle cases where the formats are incorrect or unsupported, raising a `ValueError` with a descriptive message. * Ensure the function correctly transforms the date string into the specified output format. * Consider edge cases such as leap years and different month lengths. # Example Usage: ```python >>> format_date(\\"2023-01-05\\", \\"%Y-%m-%d\\", \\"%d/%m/%Y\\") \\"05/01/2023\\" >>> format_date(\\"12:30:45\\", \\"%H:%M:%S\\", \\"%H-%M-%S\\") \\"12-30-45\\" >>> format_date(\\"05/01/2023\\", \\"%d/%m/%Y\\", \\"%Y-%m-%d\\") \\"2023-01-05\\" >>> format_date(\\"2023/01/05 15:30:10\\", \\"%Y/%m/%d %H:%M:%S\\", \\"%d-%m-%Y %H:%M:%S\\") \\"05-01-2023 15:30:10\\" ``` # Constraints: * Assume the input date string, input format, and output format are non-empty strings. * Focus on the correctness of the date transformation and format validation. * The function should be efficient and handle common edge cases related to date formatting.","solution":"from datetime import datetime def format_date(date_string: str, input_format: str, output_format: str) -> str: Converts a date string from one format to another. Parameters: date_string (str): The input date string. input_format (str): The format of the input date string. output_format (str): The desired output date format. Returns: str: The formatted date string. Raises: ValueError: If the date string does not match the input format. try: date_obj = datetime.strptime(date_string, input_format) return date_obj.strftime(output_format) except ValueError: raise ValueError(\\"The date string does not match the specified input format\\")"},{"question":"# Problem Statement You are given an integer `n` representing the size of a circular array. The values in the array are incrementing integers starting from 1 up to `n`. You are also given a starting position `start` and a step count `k`. Your task is to implement a function that simulates a sequence of `k` steps in the array, starting from position `start`. Each step involves moving to the next position in the array (considering it circular). The function should return the value at the final position after completing the sequence of steps. # Requirements Implement the function `circular_step(n: int, start: int, k: int) -> int` such that: 1. The function accepts three integers: the size of the array `n`, the starting position `start`, and the number of steps `k`. 2. It returns the value at the final position after performing `k` steps from the start position in a circular manner. 3. If any input does not adhere to the given constraints, the function should raise a `ValueError` with a message. # Input Format - `n`: An integer representing the size of the circular array. - `start`: An integer representing the starting position (1-based index) in the array. - `k`: An integer representing the number of circular steps. # Output Format - An integer representing the value at the final position in the circular array after `k` steps. # Constraints - You may assume the following constraints for the input: - `1 <= n <= 10^6` - `1 <= start <= n` - `0 <= k <= 10^9` # Example 1. Example 1: - Input: `n = 5`, `start = 2`, `k = 3` - Output: `5` Explanation: The circular array is [1, 2, 3, 4, 5]. Starting at position 2 (value=2), taking 3 steps will land you at position 5 (value=5). 2. Example 2: - Input: `n = 10`, `start = 10`, `k = 15` - Output: `5` Explanation: The circular array is [1, 2, 3, ..., 10]. Starting at position 10 (value=10), taking 15 steps will land you at position 5 (value=5). 3. Example 3: - Input: `n = 7`, `start = 3`, `k = 0` - Output: `3` Explanation: No steps are taken, so the value at the start position is returned. # Edge Cases - If `n=1`, the only possible output is 1 regardless of `start` and `k`. - If `k=0`, the function should return the value at the `start` position. - Large values of `n` and `k`. ```python def circular_step(n: int, start: int, k: int) -> int: :param n: the size of the circular array :param start: the starting position (1-based index) :param k: the number of steps :return: the value at the final position after k steps Raises: ValueError: If any input does not adhere to the constraints. if not (1 <= n <= 10**6): raise ValueError(f\\"The input value of [n={n}] is out of bounds\\") if not (1 <= start <= n): raise ValueError(f\\"The input value of [start={start}] is out of bounds\\") if not (0 <= k <= 10**9): raise ValueError(f\\"The input value of [k={k}] is out of bounds\\") final_position = (start + k - 1) % n + 1 return final_position # Test cases for the function print(circular_step(5, 2, 3)) # Expected output: 5 print(circular_step(10, 10, 15)) # Expected output: 5 print(circular_step(7, 3, 0)) # Expected output: 3 ```","solution":"def circular_step(n: int, start: int, k: int) -> int: Simulates a sequence of k steps in a circular array starting from position start. :param n: The size of the circular array :param start: The starting position (1-based index) :param k: The number of circular steps :return: The value at the final position after k steps Raises: ValueError: If any input does not adhere to the constraints. if not (1 <= n <= 10**6): raise ValueError(f\\"The input value of [n={n}] is out of bounds\\") if not (1 <= start <= n): raise ValueError(f\\"The input value of [start={start}] is out of bounds\\") if not (0 <= k <= 10**9): raise ValueError(f\\"The input value of [k={k}] is out of bounds\\") final_position = (start + k - 1) % n + 1 return final_position"},{"question":"# Coding Assessment Question You are tasked with implementing a function that finds the first missing positive integer from an unsorted list. # Problem Statement Write a function `find_first_missing_positive(nums: List[int]) -> int` that returns the smallest positive integer that does not appear in the list. # Input - A list `nums` of integers where the length of the list is between 1 and 100,000, and the values can range from -1,000,000 to 1,000,000. # Output - An integer representing the smallest positive integer that is not present in the list. # Constraints - The list can contain duplicates and both positive and negative numbers. - The function should execute in linear time complexity O(n) and with constant space complexity O(1) (excluding the input and output). # Example ```python >>> find_first_missing_positive([3, 4, -1, 1]) 2 >>> find_first_missing_positive([1, 2, 0]) 3 >>> find_first_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_first_missing_positive([-1, -2, -3]) 1 ``` # Notes - You should not use any extra space other than variables to hold integers. In particular, you are not allowed to use extra arrays or hash maps. - Modify the input array in place if necessary to achieve the desired space complexity. # Implementation Hints 1. Consider placing each positive integer `x` in its corresponding index `x-1` position, if such a position exists and is within bounds. 2. Iterate through the list afterwards to find the first index where the element does not match the index.","solution":"def find_first_missing_positive(nums): Finds the first missing positive integer from the given list. Args: - nums (List[int]): List of integers where the length of the list is between 1 and 100,000, and the values can range from -1,000,000 to 1,000,000. Returns: - int: The smallest positive integer that is not present in the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Shortest Path in a Weight-Directed Graph Problem Statement: You are given a directed graph represented by an adjacency matrix `graph`, where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If `graph[i][j]` is `0`, it means there is no direct edge from vertex `i` to vertex `j`. Your task is to determine the shortest path from a specified source vertex `src` to a destination vertex `dest`. Task: Implement a function `shortest_path` that determines the shortest path distance from the given source vertex to the destination vertex. The function should return the shortest path distance as an integer. If no path exists, return `-1`. Function Signature: ```python def shortest_path(graph: list[list[int]], src: int, dest: int) -> int: ``` Input: * `graph`: A 2D list representing an adjacency matrix of a directed graph (N x N grid where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`; `0` if no edge exists). * `src`: An integer representing the source vertex (0-based index). * `dest`: An integer representing the destination vertex (0-based index). Output: * An integer representing the shortest path distance from `src` to `dest`, or `-1` if no such path exists. Constraints: * `2 <= N <= 100`, where `N` is the number of vertices in the graph. * `1 <= graph[i][j] <= 100` for all `i` and `j` if there is an edge from `i` to `j`. Example: ```python graph = [ [0, 10, 0, 30, 100], [0, 0, 50, 0, 0], [0, 0, 0, 0, 10], [0, 0, 20, 0, 60], [0, 0, 0, 0, 0] ] src = 0 dest = 4 print(shortest_path(graph, src, dest)) # Output: 60 graph = [ [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0] ] src = 0 dest = 3 print(shortest_path(graph, src, dest)) # Output: 3 graph = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] src = 0 dest = 2 print(shortest_path(graph, src, dest)) # Output: -1 ``` Hints: To implement the algorithm, you may: 1. Consider using Dijkstra\'s algorithm or the Bellman-Ford algorithm to find the shortest path in a weighted directed graph. 2. Use a priority queue to keep track of the vertices to be explored in the case of Dijkstra’s algorithm.","solution":"import heapq def shortest_path(graph: list[list[int]], src: int, dest: int) -> int: Returns the shortest path distance from the source vertex to the destination vertex in a directed graph. n = len(graph) distances = [float(\'inf\')] * n distances[src] = 0 priority_queue = [(0, src)] # (distance, vertex) while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Early exit if we reach the destination if current_vertex == dest: return current_distance if current_distance > distances[current_vertex]: continue for neighbor in range(n): weight = graph[current_vertex][neighbor] if weight > 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return -1 if distances[dest] == float(\'inf\') else distances[dest]"},{"question":"# Scenario You are building an autocomplete feature for a search engine. The feature suggests the top k most frequent search queries that start with a given prefix, considering the historical search data available. The suggested queries should be sorted in decreasing order of frequency, and if frequencies are the same, in lexicographically increasing order. # Task Implement an AutocompleteSystem class that supports the following operations: 1. **Constructor**: Initialize the system with a list of historical search queries and their frequencies. 2. **Input Method**: Process each character input by the user to update and provide the current autocomplete suggestions based on the characters typed so far. # Input and Output Format - **Input**: 1. A list of tuples `historicalData` where each tuple consists of a string (query) and an integer (frequency). 2. For the `input` method: - A string `typed` representing the current prefix typed by the user. - An integer `k` indicating the number of suggestions to return. - **Output**: - For each call to the `input` method, return a list of the top k query suggestions based on the current prefix. # Constraints - Historical search queries will have a maximum length of 100 characters. - Prefix queries will have a maximum length of 100 characters. - The number of historical queries will be up to (10^5). - The number of inputs for the `input` method will be up to (10^4). # Example ```python from typing import List, Tuple class AutocompleteSystem: def __init__(self, historicalData: List[Tuple[str, int]]): # Initialize system with historical data pass def input(self, typed: str, k: int) -> List[str]: # Return top k autocomplete suggestions for the current `typed` prefix pass # Example usage: historical_data = [ (\\"apple\\", 5), (\\"app\\", 3), (\\"apricot\\", 2), (\\"banana\\", 4), (\\"orange\\", 2), (\\"apply\\", 1) ] autocomplete_system = AutocompleteSystem(historical_data) print(autocomplete_system.input(\\"ap\\", 3)) # Expected output: [\\"apple\\", \\"app\\", \\"apricot\\"] print(autocomplete_system.input(\\"ba\\", 2)) # Expected output: [\\"banana\\"] print(autocomplete_system.input(\\"ora\\", 2)) # Expected output: [\\"orange\\"] ``` The AutocompleteSystem class should efficiently handle the addition of new characters and return relevant autocomplete suggestions based on the frequency and lexicographical order of historical queries.","solution":"from typing import List, Tuple from collections import defaultdict class AutocompleteSystem: def __init__(self, historicalData: List[Tuple[str, int]]): self.prefix_map = defaultdict(list) self.current_typing = \\"\\" for query, freq in historicalData: for i in range(1, len(query) + 1): self.prefix_map[query[:i]].append((freq, query)) for prefix in self.prefix_map: self.prefix_map[prefix].sort(key=lambda x: (-x[0], x[1])) def input(self, typed: str, k: int) -> List[str]: self.current_typing += typed if self.current_typing in self.prefix_map: suggestions = self.prefix_map[self.current_typing][:k] return [query for _, query in suggestions] else: return []"},{"question":"Implement a Function to Reverse a LinkedDeque Given a `LinkedDeque` instance, implement a function called `reverse_deque` that reverses the order of all elements in the deque. The operation should be performed in place, modifying the input deque directly. # Function Signature ```python def reverse_deque(deque: LinkedDeque) -> None: ``` # Parameters and Constraints - `deque` is an instance of `LinkedDeque`. - You cannot use any additional Python data structures like `list`, `deque` from `collections`, etc. - The function should run in O(n) time complexity where n is the number of elements in the deque. # Example ```python d = LinkedDeque() d.add_first(1) d.add_last(2) d.add_last(3) d.add_last(4) reverse_deque(d) assert d.remove_first() == 4 assert d.remove_first() == 3 assert d.remove_first() == 2 assert d.remove_first() == 1 assert d.is_empty() ``` # Additional Notes - Ensure that the function operates correctly even if the deque is empty. - Handle scenarios where the deque has an odd or even number of elements correctly.","solution":"class Node: def __init__(self, element=None, prev_node=None, next_node=None): self.element = element self.prev = prev_node self.next = next_node class LinkedDeque: def __init__(self): self.header = Node() # Sentinel node at the front self.trailer = Node() # Sentinel node at the back self.header.next = self.trailer self.trailer.prev = self.header self.size = 0 def is_empty(self): return self.size == 0 def add_first(self, element): self._insert_between(element, self.header, self.header.next) def add_last(self, element): self._insert_between(element, self.trailer.prev, self.trailer) def remove_first(self): if self.is_empty(): raise ValueError(\\"Deque is empty\\") return self._delete_node(self.header.next) def remove_last(self): if self.is_empty(): raise ValueError(\\"Deque is empty\\") return self._delete_node(self.trailer.prev) def _insert_between(self, element, predecessor, successor): new_node = Node(element, predecessor, successor) predecessor.next = new_node successor.prev = new_node self.size += 1 def _delete_node(self, node): predecessor = node.prev successor = node.next predecessor.next = successor successor.prev = predecessor self.size -= 1 element = node.element node.prev = node.next = node.element = None # Clean up node return element def reverse_deque(deque: LinkedDeque) -> None: if deque.is_empty(): return curr = deque.header.next while curr != deque.trailer: curr.prev, curr.next = curr.next, curr.prev curr = curr.prev deque.header.next, deque.trailer.prev = deque.trailer.prev, deque.header.next deque.header.next.prev, deque.trailer.prev.next = deque.header, deque.trailer"},{"question":"# Problem Statement You are working on a data processing application that involves compressing a sequence of characters. The compression algorithm replaces consecutive repeated characters with the character followed by the count of repetitions. Your task is to implement this algorithm. Write a function named `compress_string` that takes a string and returns a compressed version of the string according to the algorithm described. # Input * `s` (str): A string consisting of lowercase English letters. # Output * A string representing the compressed version of the input string. # Examples ```python # Example 1 assert compress_string(\\"aaabbbccc\\") == \\"a3b3c3\\" # Example 2 assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" # Example 3 assert compress_string(\\"abcd\\") == \\"a1b1c1d1\\" # Example 4 assert compress_string(\\"aabbcc\\") == \\"a2b2c2\\" # Example 5 assert compress_string(\\"\\") == \\"\\" ``` # Constraints * The length of the input string will be between 0 and 10^5. * The input string will only contain lowercase English letters. # Performance Requirements * The algorithm should run in O(n) time complexity where n is the length of the input string. # Additional Notes * If the input string is empty, the function should return an empty string.","solution":"def compress_string(s): Compresses a string by replacing consecutive repeated characters with the character followed by the count of repetitions. Args: s (str): The input string. Returns: str: The compressed version of the input string. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(current_char + str(count)) current_char = char count = 1 compressed.append(current_char + str(count)) # For the last group return \'\'.join(compressed)"},{"question":"# Context You\'re given a collection of customer transactions for an online store. Each transaction consists of the customer ID, the transaction amount, and the date. Your task is to calculate the average transaction amount per customer and identify the highest spender. # Requirements 1. Implement a function to compute the average transaction amount for each customer. 2. Implement a function to determine the highest spender based on the total transaction amounts. 3. Ensure proper data handling and calculations. # Input/Output 1. **Function**: `transaction_analysis(transactions)` - **Arguments**: - `transactions`: List of tuples `[(customer_id, transaction_amount, date), ...]`. - **Returns**: A dictionary with customer IDs as keys and their average transaction amounts as values, and also the customer ID of the highest spender. # Constraints - Each customer ID is unique and non-null. - Transaction amounts are positive floats. - Dates are in the format \'YYYY-MM-DD\'. # Example ```python transactions = [ (1, 100.0, \'2023-09-12\'), (1, 150.0, \'2023-09-15\'), (2, 200.0, \'2023-09-13\'), (2, 50.0, \'2023-09-14\'), (3, 300.0, \'2023-09-12\') ] average_transactions, highest_spender = transaction_analysis(transactions) print(average_transactions) # Output: {1: 125.0, 2: 125.0, 3: 300.0} print(highest_spender) # Output: 3 ``` # Criteria - Correct calculation of average transaction amounts. - Accurate identification of the highest spender. - Efficient processing to handle potentially large datasets.","solution":"def transaction_analysis(transactions): Analyzes a list of transactions to compute the average transaction amount per customer and identifies the highest spender. :param transactions: List of tuples (customer_id, transaction_amount, date) :return: Tuple containing a dictionary with customer IDs as keys and their average transaction amounts as values, and the customer ID of the highest spender. from collections import defaultdict # Initialize dictionaries to store total amounts and transaction counts customer_totals = defaultdict(float) transaction_counts = defaultdict(int) # Process each transaction for customer_id, amount, _ in transactions: customer_totals[customer_id] += amount transaction_counts[customer_id] += 1 # Calculate average transaction amounts average_transactions = {customer_id: customer_totals[customer_id] / count for customer_id, count in transaction_counts.items()} # Identify the highest spender highest_spender = max(customer_totals, key=customer_totals.get) return average_transactions, highest_spender"},{"question":"# Coding Assessment Question Context: In many computational applications, efficient matrix manipulation is vital to handle large datasets. You are required to implement a feature of a matrix multiplication library that assists in multiplying sparse matrices efficiently. Problem Statement: Your task is to implement the two critical functions for sparse matrix multiplication: `compress_sparse_matrix` and `multiply_sparse_matrices`. **Function 1: Compress Sparse Matrix** Implement a function `compress_sparse_matrix(matrix: List[List[int]]) -> dict` that compresses a given 2D sparse matrix into a dictionary of non-zero elements. **Function 2: Sparse Matrix Multiplication** Implement a function `multiply_sparse_matrices(mat1: dict, mat2: dict, rows1: int, cols2: int) -> List[List[int]]` that multiplies two compressed sparse matrices. **Constraints and Requirements:** 1. **Compress Sparse Matrix**: - A sparse matrix is defined as a matrix where a significant number of elements are zero. - The function should convert the matrix into a dictionary where the keys are tuples representing the positions of non-zero elements, and the values are the corresponding elements. 2. **Sparse Matrix Multiplication**: - The two matrices are provided in compressed dictionary format. - The dimensions of the input matrices are valid for matrix multiplication (i.e., the number of columns in the first matrix equals the number of rows in the second matrix). - The function should return the resultant matrix in a 2D list format. **Expected Input and Output:** 1. `compress_sparse_matrix(matrix: List[List[int]]) -> dict`: - **Input**: A 2D list representing a sparse matrix. - **Output**: A dictionary with tuples as keys representing positions (row, col) and non-zero values. 2. `multiply_sparse_matrices(mat1: dict, mat2: dict, rows1: int, cols2: int) -> List[List[int]]`: - **Input**: Two dictionaries (compressed representations of the matrices), the number of rows in the first matrix, and the number of columns in the second matrix. - **Output**: A 2D list representing the resulting matrix. **Performance Requirements:** - Efficiently handle large sparse matrices to avoid memory and time consumption issues. - Ensure correct implementation of matrix multiplication rules. - Handle edge cases such as empty matrices or matrices with no non-zero elements. **Example Usage:** ```python # Example usage: # Compressing a sparse matrix sparse_matrix = [ [0, 0, 3], [4, 0, 0], [0, 0, 5] ] compressed = compress_sparse_matrix(sparse_matrix) print(compressed) # Output: {(0, 2): 3, (1, 0): 4, (2, 2): 5} # Multiplying two sparse matrices mat1 = {(0, 1): 2, (1, 0): 1} mat2 = {(1, 0): 1, (0, 2): 3} result = multiply_sparse_matrices(mat1, mat2, 2, 3) print(result) # Output: [[0, 0, 0], [1, 0, 0]] ```","solution":"from typing import List, Dict, Tuple def compress_sparse_matrix(matrix: List[List[int]]) -> Dict[Tuple[int, int], int]: Compresses a given 2D sparse matrix into a dictionary of non-zero elements. compressed = {} for i in range(len(matrix)): for j in range(len(matrix[i])): if matrix[i][j] != 0: compressed[(i, j)] = matrix[i][j] return compressed def multiply_sparse_matrices(mat1: Dict[Tuple[int, int], int], mat2: Dict[Tuple[int, int], int], rows1: int, cols2: int) -> List[List[int]]: Multiplies two compressed sparse matrices. result = [[0] * cols2 for _ in range(rows1)] for (i, k1), v1 in mat1.items(): for (k2, j), v2 in mat2.items(): if k1 == k2: result[i][j] += v1 * v2 return result"},{"question":"# Question Scenario: You are given an array of integers where every element appears twice except for one element, which appears only once. Your task is to find and return the element that appears only once. Task: Write a function `find_single_number(nums: List[int]) -> int:` that finds the single element in the array where every other element appears exactly twice. The solution should have a linear runtime complexity and use only constant extra space. **Input:** - `nums` (List[int]): A list of integers where every element appears exactly twice except for one element which appears only once. **Output:** - `int`: The single integer that appears only once in the array. **Constraints:** - `1 <= len(nums) <= 3 * 10^4` - `-3 * 10^4 <= nums[i] <= 3 * 10^4` **Performance Requirement:** - Your solution should have O(n) time complexity. - Your solution should use only O(1) extra space. Example: ```python assert find_single_number([2, 2, 1]) == 1 assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 ``` Hint: Consider using bitwise operations to achieve the desired time and space complexity. # Additional Context: - Using the XOR bitwise operator is key, as `a ^ a = 0` and `a ^ 0 = a`. Therefore, XOR-ing all elements of the array will cancel out the numbers appearing in pairs and leave the single number.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Finds the single element in the array where every other element appears twice. Args: nums (List[int]): A list of integers where every element appears exactly twice except for one element which appears only once. Returns: int: The single integer that appears only once in the array. unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Task You need to implement a function that efficiently finds all unique triplets in a list of integers that sum up to zero. Each triplet should be sorted in ascending order, and the resulting list of triplets should not contain any duplicate triplets. # Problem Statement **Function Signature**: ```python def find_zero_sum_triplets(arr: List[int]) -> List[List[int]]: \'\'\' Parameters: arr (List[int]): A list of integers. Returns: List[List[int]]: A list of unique triplets [a, b, c] where a, b, and c are elements from arr, such that a + b + c = 0. \'\'\' ``` Your task is to implement the `find_zero_sum_triplets` function. The function should operate efficiently even with larger lists and should carefully avoid discovering duplicate triplets. # Constraints - The length of the list `arr` is between 0 and 10^4. - Each element in the list is an integer ranging from -10^5 to 10^5. # Examples Example 1: * Input: ```python arr = [-1, 0, 1, 2, -1, -4] ``` * Output: ```python [[-1, -1, 2], [-1, 0, 1]] ``` Example 2: * Input: ```python arr = [0, 0, 0, 0] ``` * Output: ```python [[0, 0, 0]] ``` # Notes - The input list may contain zeros, positive, and negative numbers. - The resulting triplets must be in ascending order, and the list itself must not contain any duplicate triplets. - Pay attention to the efficiency of the implementation. The function should have a time complexity of approximately O(n^2).","solution":"from typing import List def find_zero_sum_triplets(arr: List[int]) -> List[List[int]]: arr.sort() # Sort the array to make sure we can use the two pointer approach triplets = [] length = len(arr) for i in range(length - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicate values left, right = i + 1, length - 1 while left < right: total_sum = arr[i] + arr[left] + arr[right] if total_sum == 0: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 # Skip duplicate values on the left while left < right and arr[right] == arr[right - 1]: right -= 1 # Skip duplicate values on the right left += 1 right -= 1 elif total_sum < 0: left += 1 # Move the left pointer to the right else: right -= 1 # Move the right pointer to the left return triplets"},{"question":"# Coding Assessment Question Problem Statement **Context**: Bob, a computer science enthusiast, is keen on exploring various string manipulation techniques. During one of his programming adventures, he stumbled upon a challenge where he needs to find the length of the longest substring in a given string that contains only unique characters. Bob decides to write a program to solve this problem efficiently. **Task**: Implement a function `longest_unique_substring(s: str) -> int` that computes the length of the longest substring of `s` that contains only unique characters. **Function Signature**: ```python def longest_unique_substring(s: str) -> int: ``` **Parameters**: - `s` (str): The input string consisting of English letters, digits, and punctuation of length `1 <= len(s) <= 10^5`. **Returns**: - (int): The length of the longest substring that contains only unique characters. **Examples**: ```python assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 assert longest_unique_substring(\\"\\") == 0 ``` **Notes**: * The function should be efficient and capable of handling strings up to the maximum length constraint. * A sliding window or two-pointer technique might be useful to achieve the desired performance. * Pay close attention to edge cases, such as the empty string and strings with all unique characters. **Constraints**: * `1 <= len(s) <= 100000` **Scenario**: Bob is preparing for a coding competition and needs to refine his skills in string manipulation. Assist him by implementing this efficient function.","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with unique characters in the given string s. char_index_map = {} longest = 0 left = 0 for right in range(len(s)): if s[right] in char_index_map and char_index_map[s[right]] >= left: left = char_index_map[s[right]] + 1 char_index_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"# Question: Implement a Library Management System with Book Borrowing Functionality **Context**: You are tasked with developing a part of a library management system that allows users to borrow books. The system must track which books are available for borrowing and which are currently loaned out. The goal is to design a function that will handle the borrowing process while ensuring books are correctly tracked and cannot be borrowed by multiple users simultaneously. You will implement a function `borrow_book` that updates the borrowing status of books in the library. **Function Signature**: ```python def borrow_book(book_catalog: dict, user_requests: list) -> dict: pass ``` **Input**: - `book_catalog`: A dictionary where keys are book titles and values are lists containing two elements: the total number of copies and the number of copies currently available. - `user_requests`: A list of tuples where each tuple contains the user id (int) and the book title (string) the user wants to borrow. **Output**: - Returns a dictionary where keys are book titles and values are lists containing two elements: the total number of copies and the number of copies currently available after processing all requests. **Constraints**: - The book titles in user requests will always exist in the `book_catalog`. - The `user_requests` list can have multiple requests for the same book from different users. - A request should only be fulfilled if there is at least one available copy of the book; otherwise, it should be ignored. - No partial processing of requests; either all requests are processed, or none in case of incorrect input. **Example**: ```python book_catalog = { \\"Harry Potter\\": [10, 5], # 10 total copies, 5 available \\"The Hobbit\\": [6, 0], # 6 total copies, 0 available \\"1984\\": [8, 3] # 8 total copies, 3 available } user_requests = [ (1, \\"Harry Potter\\"), # User 1 requests \\"Harry Potter\\" (2, \\"The Hobbit\\"), # User 2 requests \\"The Hobbit\\" (3, \\"1984\\") # User 3 requests \\"1984\\" ] borrow_book(book_catalog, user_requests) # Expected output: { # \\"Harry Potter\\": [10, 4], # One less available copy # \\"The Hobbit\\": [6, 0], # No change, as no copies available # \\"1984\\": [8, 2] # One less available copy # } ``` # Guidelines: 1. Ensure to update the availability status of books accurately based on user requests. 2. Handle cases where multiple requests are made for the same book. 3. Preserve the integrity of the `book_catalog` by ensuring books cannot be borrowed beyond their available count. 4. Develop an efficient solution to handle the book borrowing process in a reasonable time complexity.","solution":"def borrow_book(book_catalog: dict, user_requests: list) -> dict: Updates the borrowing status of books in the library based on user requests. Parameters: - book_catalog (dict): A dictionary where keys are book titles and values are lists containing two elements: [total number of copies, number of copies currently available]. - user_requests (list): A list of tuples where each tuple contains the user id (int) and the book title (string) the user wants to borrow. Returns: - dict: A dictionary reflecting the updated book availability status after processing the requests. for user_id, requested_book in user_requests: if book_catalog[requested_book][1] > 0: book_catalog[requested_book][1] -= 1 return book_catalog"},{"question":"# Task: Implement a Dynamic Programming Solution for Fibonacci Sequence Scenario You are provided with the task of generating the Fibonacci sequence up to the `n`-th term. The Fibonacci sequence is defined as: * F(0) = 0, F(1) = 1 * F(n) = F(n-1) + F(n-2), for n > 1 A naive recursive approach to compute the Fibonacci sequence can be highly inefficient due to repeated calculations. Therefore, you need to implement an optimized version using dynamic programming to store the results of subproblems and avoid redundant computations. Requirements 1. **Function Implementation**: Implement the function `fibonacci(n)` in Python that achieves the following: * Takes as input: - `n`: an integer representing the term of the Fibonacci sequence to compute. * Returns: - An integer which is the `n`-th term of the Fibonacci sequence. Input and Output Format * **Input**: * `n`: a non-negative integer. * **Output**: * Integer representing the `n`-th term of the Fibonacci sequence. Constraints * `0 <= n <= 50` * You should use an iterative approach and leverage a list or array to store intermediate results of the Fibonacci sequence for optimal performance. Example Usage * **Input**: `n = 10` * **Output**: `55` Performance Requirements Your implementation should minimize time complexity to O(n) and space complexity to O(n), ensuring it efficiently handles the upper limit of the input range.","solution":"def fibonacci(n): Returns the n-th Fibonacci number using dynamic programming. if n <= 0: return 0 elif n == 1: return 1 # Initialize base values fib = [0, 1] # Compute Fibonacci using bottom-up DP approach for i in range(2, n + 1): fib.append(fib[i - 1] + fib[i - 2]) return fib[n]"},{"question":"# Context You are developing a system to track and manage stock prices over a period of time. The system should be able to handle real-time updates of stock prices and provide functionalities to get the current price, maximum price, and minimum price of a stock efficiently. # Task Implement a class `StockPriceTracker` to manage stock prices. The tracker should support the following operations: 1. **Update a stock price**: Given a timestamp and price, update the stock price at the given timestamp. If the timestamp already exists, update the existing price. 2. **Get the current price**: Retrieve the most recent stock price. 3. **Get the maximum price**: Retrieve the highest stock price recorded. 4. **Get the minimum price**: Retrieve the lowest stock price recorded. The timestamps are unique integers, and the prices are floating-point numbers. Implement methods with the following signatures: ```python class StockPriceTracker: def update(self, timestamp: int, price: float) -> None: pass def get_current_price(self) -> float: pass def get_max_price(self) -> float: pass def get_min_price(self) -> float: pass ``` # Requirements 1. Your methods should efficiently handle dynamic updates and queries. 2. Ensure that `update` has a time complexity of O(1). 3. Ensure that `get_current_price`, `get_max_price`, and `get_min_price` have time complexities of O(1). # Constraints * Timestamps are integers within the range [1, 10^9]. * Prices are floating-point numbers within the range [0.0, 10^6.0]. # Example ```python tracker = StockPriceTracker() tracker.update(1, 100.0) tracker.update(2, 102.5) tracker.update(3, 97.5) print(tracker.get_current_price()) # Output: 97.5 print(tracker.get_max_price()) # Output: 102.5 print(tracker.get_min_price()) # Output: 97.5 tracker.update(3, 105.0) print(tracker.get_current_price()) # Output: 105.0 print(tracker.get_max_price()) # Output: 105.0 print(tracker.get_min_price()) # Output: 100.0 ``` Submission Submit a class `StockPriceTracker` implemented in Python, with the specified methods handling stock prices efficiently as described.","solution":"class StockPriceTracker: def __init__(self): self.prices = {} self.current_time = -1 self.current_price = None self.min_price = float(\'inf\') self.max_price = float(\'-inf\') def update(self, timestamp: int, price: float) -> None: if timestamp >= self.current_time: self.current_time = timestamp self.current_price = price self.prices[timestamp] = price self.max_price = max(self.prices.values()) self.min_price = min(self.prices.values()) def get_current_price(self) -> float: return self.current_price def get_max_price(self) -> float: return self.max_price def get_min_price(self) -> float: return self.min_price"},{"question":"# Problem Statement You are given a list of strings, where each string represents a valid DNS domain name. Implement the function `group_domains` which takes a list of domain names as input and returns a dictionary grouping these domains by their top-level domains (TLDs). # Function Signature ```python def group_domains(domains: list[str]) -> dict[str, list[str]]: ``` # Input - A list of strings `domains` where (1 leq len(domains) leq 10^3) and each domain is a valid DNS domain name following standard domain name conventions. # Output - A dictionary where the keys are top-level domains (TLDs), and the values are lists of domains that belong to each respective TLD. - The domain names in each list must retain their original order from the input. # Examples ```python assert group_domains([\\"example.com\\", \\"test.org\\", \\"website.net\\", \\"example.org\\", \\"example.net\\"]) == { \\"com\\": [\\"example.com\\"], \\"org\\": [\\"test.org\\", \\"example.org\\"], \\"net\\": [\\"website.net\\", \\"example.net\\"] } assert group_domains([\\"hello.world\\", \\"another.world\\", \\"example.com\\"]) == { \\"world\\": [\\"hello.world\\", \\"another.world\\"], \\"com\\": [\\"example.com\\"] } assert group_domains([\\"my.website\\", \\"another.website\\", \\"new.site\\"]) == { \\"website\\": [\\"my.website\\", \\"another.website\\"], \\"site\\": [\\"new.site\\"] } assert group_domains([]) == {} ``` # Constraints - The domain names will always include at least two parts (e.g., `example.com`), with each part separated by a dot (`.`). - Top-level domains (TLDs) will consist of alphabetic characters only. - The input list of domains may be empty, in which case the function should return an empty dictionary. # Notes - The TLD is defined as the last segment of the domain name after the final dot (e.g., in `example.com`, the TLD is `com`). - Ensure the order of domains in the grouped lists matches the order they appeared in the input list. # Edge Cases - Handle cases where multiple domains have the same TLD. - An empty input list should return an empty dictionary. - All domains will be in lowercase, following DNS convention, so there is no need to handle case-sensitivity.","solution":"def group_domains(domains: list[str]) -> dict[str, list[str]]: Groups a list of domain names by their top-level domains (TLDs). Parameters: domains (list of str): List of domain names. Returns: dict of str: list of str: Dictionary where keys are TLDs and values are lists of associated domains. grouped_domains = {} for domain in domains: # Split the domain by the last \'.\' to get the TLD tld = domain.split(\'.\')[-1] # If the TLD is not in the dictionary, add it with an empty list if tld not in grouped_domains: grouped_domains[tld] = [] # Append the domain to the appropriate TLD list grouped_domains[tld].append(domain) return grouped_domains"},{"question":"# Unique Array Checker Background Arrays are fundamental data structures in programming, and ensuring array elements meet specific conditions is a common task. One such condition is verifying that all elements in an array are unique. Task Write a function `is_unique_array` that checks whether all elements in a given array are unique. Implementation Details * **Function Signature**: `def is_unique_array(arr: [int]) -> bool` * **Input**: An array of integers `arr` (with length 0 ≤ |arr| ≤ 10^5 and -10^9 ≤ arr[i] ≤ 10^9). * **Output**: A boolean value `True` if all elements are unique, otherwise `False`. Function Specifics 1. Initialize an empty set to keep track of seen elements. 2. Iterate over each element in the array: * If the element is already in the set, return `False`. * Otherwise, add the element to the set. 3. If no duplicates are found, return `True`. Edge Cases * Handle empty arrays by returning `True`. * Ensure the function works efficiently with the given constraints. Example ```python def is_unique_array(arr: [int]) -> bool: seen = set() for num in arr: if num in seen: return False seen.add(num) return True # Example Usage print(is_unique_array([1, 2, 3, 4, 5])) # Output: True print(is_unique_array([1, 2, 2, 4, 5])) # Output: False print(is_unique_array([])) # Output: True print(is_unique_array([1000000000, -1000000000])) # Output: True ``` **Constraints**: * Time Complexity: O(n), where n is the length of the input array. * Space Complexity: O(n) for storing elements in a set. Note This function is useful for applications where the uniqueness of array elements is a fundamental requirement.","solution":"def is_unique_array(arr): This function checks if all elements in the given array are unique. :param arr: List[int] - An array of integers :return: bool - True if all elements are unique, otherwise False seen = set() for num in arr: if num in seen: return False seen.add(num) return True # Example Usage print(is_unique_array([1, 2, 3, 4, 5])) # Output: True print(is_unique_array([1, 2, 2, 4, 5])) # Output: False print(is_unique_array([])) # Output: True print(is_unique_array([1000000000, -1000000000])) # Output: True"},{"question":"# Binary Tree Serialization You are required to implement a solution for serializing and deserializing a binary tree. Serialization is the process of converting a tree to a single string, while deserialization converts the string back to the original tree structure. Implement both functionalities. Specifically, you need to: 1. Implement the `serialize` function that takes the root of a binary tree and returns a string representation. 2. Implement the `deserialize` function that takes a string representation and reconstructs the original binary tree. Your functions should: - Handle empty trees (where the root is `None`). - Use a pre-order traversal method for serialization. - Ensure that `deserialize(serialize(root))` returns a deeply equivalent tree to `root`. Input - `serialize` function: A binary tree node, potentially `None`. - `deserialize` function: A string representation of the binary tree. Output - `serialize` function: A string that represents the binary tree. - `deserialize` function: The root node of the reconstructed binary tree. # Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example usage: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) data = serialize(root) print(data) # Example Output: \\"1,2,#,#,3,4,#,#,5,#,#\\" root_copy = deserialize(data) print(serialize(root_copy)) # Output: \\"1,2,#,#,3,4,#,#,5,#,#\\" (same as input data) ``` # Constraints - Tree nodes contain integers (their values). - The number of nodes in the tree is at most 10^5. # Helper Class You may assume the given `TreeNode` class for tree structure. # Signature ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: def deserialize(data: str) -> TreeNode: ``` Ensure your solution efficiently handles large input sizes and correctly reconstructs the binary tree structure.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root: TreeNode) -> str: Encodes a tree to a single string. def helper(node): if node is None: result.append(\'#\') else: result.append(str(node.val)) helper(node.left) helper(node.right) result = [] helper(root) return \',\'.join(result) def deserialize(data: str) -> TreeNode: Decodes your encoded data to tree. def helper(): val = next(vals) if val == \'#\': return None node = TreeNode(int(val)) node.left = helper() node.right = helper() return node vals = iter(data.split(\',\')) return helper()"},{"question":"# Coding Assessment Question: Implementing Dynamic Word Counter Context: A social media platform wants to add a feature to dynamically count specific words in user-generated posts. This feature would assist in generating real-time statistics about how often specific terms are mentioned. Your task is to help them by implementing a function that tracks the count of multiple keywords in a single post efficiently. Your Task: Write a function called `dynamic_word_counter` that: 1. **Sanitizes** the post by: - Converting it to lowercase. - Removing any non-alphanumeric characters. 2. **Counts occurrences** of multiple sanitized keywords in the sanitized post. Function Signature: ```python def dynamic_word_counter(post: str, keywords: List[str]) -> Dict[str, int]: Counts the occurrences of each keyword from the \'keywords\' list in the \'post\' after sanitization. :param post: A string representing the user-generated post. :param keywords: A list of strings representing the search keywords. :return: A dictionary with keywords as keys and their respective counts as values. Example: >>> dynamic_word_counter(\\"This social platform is great! I love this platform.\\", [\\"social\\", \\"platform\\", \\"love\\"]) {\'social\': 1, \'platform\': 2, \'love\': 1} >>> dynamic_word_counter(\\"Amazing experience, fantastic service, and great food!\\", [\\"great\\", \\"service\\"]) {\'great\': 1, \'service\': 1} >>> dynamic_word_counter(\\"No matching keywords here.\\", [\\"foo\\", \\"bar\\"]) {\'foo\': 0, \'bar\': 0} ``` # Constraints: * The length of the post will not exceed 10,000 characters. * Each keyword is a non-empty string and the number of keywords will not exceed 100. * The total length of all keywords combined will not exceed 1,000 characters. You are provided with a `sanitize_text` helper function that sanitizes the text by converting it to lowercase and removing any non-alphanumeric characters. You may use this function directly in your solution. Implementation: Make sure to sanitize the text and keywords efficiently, count the occurrences using appropriate data structures (such as a dictionary or counter), and handle edge cases correctly for optimal performance and accuracy.","solution":"from typing import List, Dict import re def sanitize_text(text: str) -> str: Sanitizes the input text by converting to lowercase and removing non-alphanumeric characters. :param text: The text to sanitize. :return: A sanitized string. return re.sub(r\'[^a-z0-9s]\', \'\', text.lower()) def dynamic_word_counter(post: str, keywords: List[str]) -> Dict[str, int]: Counts the occurrences of each keyword from the \'keywords\' list in the \'post\' after sanitization. :param post: A string representing the user-generated post. :param keywords: A list of strings representing the search keywords. :return: A dictionary with keywords as keys and their respective counts as values. sanitized_post = sanitize_text(post) sanitized_keywords = [sanitize_text(keyword) for keyword in keywords] word_count = {} for keyword in sanitized_keywords: word_count[keyword] = sanitized_post.split().count(keyword) return word_count"},{"question":"# Coding Exercise: Distinct Subsequences Context Given two strings `s` and `t`, you need to count the number of distinct subsequences of the string `s` which equals the string `t`. A subsequence of a string is obtained by deleting some (or none) of the characters without disturbing the relative positions of the remaining characters. # Task Implement the function `num_distinct(s: str, t: str) -> int` that calculates the number of distinct subsequences of `s` that match `t`. # Input * `s`: A string consisting of lowercase English letters. * `t`: A string consisting of lowercase English letters. # Output * An integer representing the number of distinct subsequences in `s` that equals `t`. # Constraints * All input strings are non-empty. * The length of `s` is at most 1000. * The length of `t` is at most 1000. # Example ```python s = \\"rabbbit\\" t = \\"rabbit\\" num_distinct(s, t) # Output: 3 # Explanation: There are 3 distinct subsequences of s that match t: # \\"rabbbit\\", \\"raBbit\\" (where B represents a removed character), and \\"rabbit\\". ``` # Requirements * Your solution should efficiently handle the constraints considering both time and space complexity. * Utilize dynamic programming techniques to solve this problem. # Performance * Aim for an optimal solution with the best possible time and space complexity given the constraints. * Consider the use of a 2D dynamic programming table for tracking subsequences.","solution":"def num_distinct(s: str, t: str) -> int: Returns the number of distinct subsequences of `s` which equals `t`. m, n = len(s), len(t) # Edge case: if t is longer than s, there can\'t be any subsequences of s that match t if n > m: return 0 # DP table where dp[i][j] represents the number of distinct subsequences of s[:i] that equals t[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Every string has exactly one subsequence (empty) that matches an empty string for i in range(m + 1): dp[i][0] = 1 # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): # If the characters match, add the subsequences that don\'t use the current char of s (dp[i-1][j]) # and those that do (dp[i-1][j-1]) if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"# Question **Symmetric Pair Sum** Given an integer array `arr` and a target sum `s`, write a function `find_unique_symmetric_pairs(arr: List[int], s: int) -> List[Tuple[int, int]]` that finds all unique pairs `(a, b)` in the array such that `a + b = s` and `a ≤ b`. The pairs should be sorted in ascending order based on the first element of the pair, and each pair `(a, b)` should appear only once in the output. Input * A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6) where `arr` is the array of integers. * An integer `s` (-2*10^6 ≤ s ≤ 2*10^6) which is the target sum. Output * Return a list of tuples, where each tuple contains two integers `(a, b)` such that `a` and `b` are elements from the array, `a + b = s`, and `a ≤ b`. The list should be sorted in ascending order based on the first element of the pairs. Constraints * Ensure the solution can handle the upper bounds of the input size efficiently. * The pairs should not contain duplicate elements from the array if they sum to the target. Examples ```python >>> find_unique_symmetric_pairs([1, 3, 2, 2, -1, 0], 3) [(1, 2), (0, 3)] >>> find_unique_symmetric_pairs([4, 5, -1, 3, 7, -4, -3], 4) [(-1, 5), (-3, 7)] ``` # Scenario Suppose you are building a feature for a financial application where you need to identify pairs of transactions that sum up to a specific target value. The solution to this problem will help in efficiently finding and reporting these pairs for further analysis, such as fraud detection or reconciliation processes. Requirements * The implementation should consider edge cases such as having multiple duplicate elements. * Ensure that the solution is optimized to handle large lists efficiently. Performance * Aim for an optimal solution with a time complexity better than O(n^2), leveraging data structures like hash sets for fast look-up.","solution":"from typing import List, Tuple def find_unique_symmetric_pairs(arr: List[int], s: int) -> List[Tuple[int, int]]: # Use a set to track seen elements and a set to store unique pairs seen = set() pairs = set() # Iterate through elements in the array for num in arr: target = s - num # Check if the required complement exists if target in seen: # Create the pair such that a <= b pair = (min(num, target), max(num, target)) pairs.add(pair) # Record this number as seen seen.add(num) # Convert the set of pairs to a sorted list return sorted(pairs)"},{"question":"# Word Search Puzzle Solver You are tasked with developing a function to solve a word search puzzle. The puzzle is represented as a grid of letters, and you are given a list of words to search for in the grid. A word can be formed by connecting letters in the grid horizontally, vertically, or diagonally. You need to determine if each word exists in the grid. Function Signature ```python def word_search(grid: List[List[str]], words: List[str]) -> List[bool]: ``` # Input - `grid` (List[List[str]]): A 2D list of characters representing the word search grid. The grid has dimensions m (rows) by n (cols). - `words` (List[str]): A list of strings representing the words to search for in the grid. # Output - Returns a list of boolean values. Each boolean indicates whether the corresponding word in the `words` list exists in the grid (True) or not (False). # Constraints - (1 leq m, n leq 100) - (1 leq text{length of each word} leq 10) - All characters in the grid and words are lowercase English letters. # Example ```python grid = [ [\'o\', \'a\', \'b\', \'n\'], [\'o\', \'t\', \'a\', \'e\'], [\'a\', \'h\', \'k\', \'r\'], [\'a\', \'f\', \'l\', \'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] assert word_search(grid, words) == [True, False, True, False] ``` # Requirements - Implement the function `word_search` using depth-first search (DFS) to explore potential word paths in the grid. - Ensure the function efficiently handles the search for multiple words by potentially reusing parts of the grid exploration. - Take care to handle edge cases where words might wrap around or cover extended regions of the grid. # Notes - Words cannot wrap around the edges of the grid. - The same cell in the grid cannot be used more than once when forming a single word.","solution":"from typing import List def word_search(grid: List[List[str]], words: List[str]) -> List[bool]: def dfs(board, word, index, x, y, visited): if index == len(word): return True if (x < 0 or y < 0 or x >= len(board) or y >= len(board[0]) or word[index] != board[x][y] or visited[x][y]): return False visited[x][y] = True # Search in all 8 possible directions (horizontally, vertically, and diagonally) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: if dfs(board, word, index + 1, x + dx, y + dy, visited): return True visited[x][y] = False return False result = [] for word in words: found = False for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == word[0]: visited = [[False] * len(grid[0]) for _ in range(len(grid))] if dfs(grid, word, 0, i, j, visited): found = True break if found: break result.append(found) return result"},{"question":"# Problem Statement You are given a list of words and a target word. Your task is to find the word from the list that is most similar to the target word in terms of the number of characters and their order of occurrence. The similarity is defined by the longest contiguous subsequence of characters that appear in the same order in both words. # Function Signature ```python def find_most_similar_word(words: list, target: str) -> str: Find the word most similar to the target word based on the longest contiguous subsequence of characters. Parameters: - words (list): A list of strings containing the words to compare. - target (str): A string representing the target word. Returns: - str: The word from the list that has the longest contiguous subsequence of characters appearing in the same order as in the target word. pass ``` # Input - `words` is a list of strings, each with a length between 1 and 100 characters. - `target` is a string with a length between 1 and 100 characters. # Output - A string from `words` that has the longest contiguous subsequence of characters appearing in the same order as in `target`. # Constraints - Each string in the `words` list and the `target` string consists only of lowercase English letters. # Example ```python find_most_similar_word([\\"apple\\", \\"apply\\", \\"ape\\", \\"pineapple\\"], \\"applesauce\\") # Output: \\"apple\\" find_most_similar_word([\\"hello\\", \\"world\\", \\"hell\\", \\"hold\\"], \\"holdon\\") # Output: \\"hold\\" find_most_similar_word([\\"great\\", \\"grate\\", \\"greeting\\", \\"greet\\"], \\"greatness\\") # Output: \\"great\\" ``` # Notes - The function should return the first word from the list that has the longest contiguous subsequence match with the target. - If no words in the list have any matching subsequences with the target, an empty string should be returned.","solution":"def find_most_similar_word(words, target): def longest_contiguous_subsequence_length(word, target): max_len = 0 len_word = len(word) len_target = len(target) for i in range(len_word): for j in range(len_target): k = 0 while i + k < len_word and j + k < len_target and word[i + k] == target[j + k]: k += 1 max_len = max(max_len, k) return max_len max_length = 0 most_similar_word = \\"\\" for word in words: length = longest_contiguous_subsequence_length(word, target) if length > max_length: max_length = length most_similar_word = word return most_similar_word"},{"question":"# Bike Sharing Data Analysis Context You are working on a bike-sharing project, and you need to analyze trip data to obtain insights about user habits. The trip data contains information about the start and end times of each trip, bike IDs, and user IDs. Your task is to aggregate this data to find out the total duration of trips taken by each bike and the user who used each bike for the longest total duration. Task Write a function that reads a list of trip records, each record containing the start time, end time, bike ID, and user ID, and returns two dictionaries. The first dictionary maps each bike ID to the total duration of trips taken by that bike. The second dictionary maps each bike ID to the user who used it for the longest total duration. Function Signature ```python def analyze_bike_trips(trip_data: list) -> tuple[dict, dict]: ... ``` Input - `trip_data` (list of list): List of trip records, where each record is a list containing: - `start_time` (str): Trip start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - `end_time` (str): Trip end time in the format \\"YYYY-MM-DD HH:MM:SS\\". - `bike_id` (int): ID of the bike used. - `user_id` (int): ID of the user who took the trip. Output - A tuple containing two dictionaries: - The first dictionary maps each `bike_id` (int) to the total trip duration (int, in seconds) for that bike. - The second dictionary maps each `bike_id` (int) to the `user_id` who used it for the longest total duration. Constraints - The `start_time` and `end_time` are valid timestamps. - The `end_time` is always later than the `start_time`. - There are no overlapping trips for the same bike. Example ```python trip_data = [ [\\"2023-01-01 08:00:00\\", \\"2023-01-01 08:30:00\\", 1, 101], [\\"2023-01-01 09:00:00\\", \\"2023-01-01 09:15:00\\", 2, 102], [\\"2023-01-01 10:00:00\\", \\"2023-01-01 10:45:00\\", 1, 103], [\\"2023-01-01 11:00:00\\", \\"2023-01-01 11:20:00\\", 2, 101] ] bike_duration, user_max_duration = analyze_bike_trips(trip_data) // Output: // bike_duration = {1: 4500, 2: 2100} // user_max_duration = {1: 103, 2: 101} ``` The `bike_duration` dictionary shows the total duration of trips for each bike, and the `user_max_duration` dictionary shows the user who had the longest total duration of trips for each bike.","solution":"from datetime import datetime def analyze_bike_trips(trip_data): Analyzes a list of trip records to find the total duration of trips taken by each bike and the user who used each bike for the longest total duration. Arguments: - trip_data: list of lists, where each inner list contains: - start_time (str): Trip start time in the format \\"YYYY-MM-DD HH:MM:SS\\". - end_time (str): Trip end time in the format \\"YYYY-MM-DD HH:MM:SS\\". - bike_id (int): ID of the bike used. - user_id (int): ID of the user who took the trip. Return: - A tuple containing two dictionaries: - The first dictionary maps each bike_id to the total duration of trips taken by that bike. - The second dictionary maps each bike_id to the user who used it for the longest total duration. bike_duration = {} user_durations = {} for record in trip_data: start_time = datetime.strptime(record[0], \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(record[1], \\"%Y-%m-%d %H:%M:%S\\") duration = int((end_time - start_time).total_seconds()) bike_id = record[2] user_id = record[3] if bike_id not in bike_duration: bike_duration[bike_id] = 0 bike_duration[bike_id] += duration if bike_id not in user_durations: user_durations[bike_id] = {} if user_id not in user_durations[bike_id]: user_durations[bike_id][user_id] = 0 user_durations[bike_id][user_id] += duration user_max_duration = {} for bike_id, durations in user_durations.items(): max_duration_user = max(durations, key=durations.get) user_max_duration[bike_id] = max_duration_user return bike_duration, user_max_duration"},{"question":"# Merge K Sorted Lists **Background**: Merging sorted lists is a common problem in data processing and algorithms. It has applications in various areas such as file merging, data stream merging, and memory management. # Task Given `k` sorted linked lists, merge them into a single sorted linked list. # Function Signature ```python from typing import List class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: Merges k sorted linked lists into a single sorted linked list. Args: lists (List[ListNode]): List of ListNodes, each representing the head of a sorted linked list. Returns: ListNode: Head of the merged sorted linked list. Examples: >>> l1 = ListNode(1, ListNode(4, ListNode(5))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> l3 = ListNode(2, ListNode(6)) >>> merge_k_sorted_lists([l1, l2, l3]) 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 >>> merge_k_sorted_lists([]) None >>> merge_k_sorted_lists([None]) None ``` # Constraints * The number of linked lists `k` will be in the range `[0, 10^4]`. * The total number of nodes across all linked lists will be in the range `[0, 10^5]`. * The values in each linked list are in the range `[-10^4, 10^4]`. # What to Do 1. **Understand the Objective**: Implement a function that can handle multiple sorted linked lists and merge them into one sorted linked list efficiently. 2. **Respect Edge Cases**: * No linked lists should return `None`. * Lists with only one input list or empty lists should be handled accordingly. 3. **Optimized Implementation**: Ensure your function minimizes time complexity, ideally using a priority queue or min-heap for optimal merging. 4. **Include Examples and Testing**: Provide test cases to demonstrate your solution and cover edge cases. **Example** ```python >>> l1 = ListNode(1, ListNode(4, ListNode(5))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> l3 = ListNode(2, ListNode(6)) >>> def print_linked_list(node): ... while node: ... print(node.val, end=\\" -> \\" if node.next else \\"n\\") ... node = node.next ... >>> result = merge_k_sorted_lists([l1, l2, l3]) >>> print_linked_list(result) 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 >>> merge_k_sorted_lists([]) None >>> merge_k_sorted_lists([None]) None ``` Write your function below: ```python import heapq def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: if not lists: return None min_heap = [] for l in lists: if l: heapq.heappush(min_heap, (l.val, id(l), l)) head = ListNode(0) current = head while min_heap: val, node_id, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, id(node.next), node.next)) return head.next ```","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into a single sorted linked list. Args: lists (List[ListNode]): List of ListNodes, each representing the head of a sorted linked list. Returns: ListNode: Head of the merged sorted linked list. Examples: >>> l1 = ListNode(1, ListNode(4, ListNode(5))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> l3 = ListNode(2, ListNode(6)) >>> result = merge_k_sorted_lists([l1, l2, l3]) >>> while result: ... print(result.val, end=\\" -> \\" if result.next else \\"n\\") ... result = result.next 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 >>> merge_k_sorted_lists([]) None >>> merge_k_sorted_lists([None]) None if not lists: return None min_heap = [] for l in lists: if l: heapq.heappush(min_heap, (l.val, id(l), l)) head = ListNode(0) current = head while min_heap: val, node_id, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, id(node.next), node.next)) return head.next"},{"question":"# Question: Implement a Linked List Cycle Detection Context You are developing a software that frequently manipulates linked lists. One common issue is the presence of cycles within linked lists, which can cause infinite loops and other issues. To ensure robust operations on linked lists, you need to implement functionality to detect cycles within them. Requirements 1. **Function: has_cycle** ```python class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Takes the head of a singly linked list. \'head\' is the starting node of the linked list. Detects if there is a cycle in the linked list. Returns True if there is a cycle, False otherwise. Example: >>> # Creating a linked list 3 -> 2 -> 0 -> -4 and making a cycle (tail connects to the second node) >>> head = ListNode(3) >>> second = ListNode(2) >>> third = ListNode(0) >>> fourth = ListNode(-4) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = second # Cycle here >>> has_cycle(head) True >>> # Creating a linked list 1 -> 2 with no cycle >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = None >>> has_cycle(head) False ``` Constraints - The input linked list can be empty (head is None). - Each node consists of an integer value and a pointer to the next node. - Utilize an efficient algorithm with linear time complexity. Performance Requirements - Aim for O(n) time complexity where n is the number of nodes in the linked list. - Use constant O(1) extra space. Edge Cases - Handle the edge case where the linked list is empty (head is None). - Consider edge cases where the cycle is immediate (single node pointing to itself). Write code that detects cycles within a given singly linked list, verifying through provided examples.","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Problem Statement Alex is participating in a 24-hour hackathon and needs to perform analysis on large datasets stored in a file. The datasets are stored as newline-delimited JSON objects (NDJSON). Each JSON object represents a record containing a \\"value\\" key with an integer value. Alex needs your help to write a function that reads the file and calculates the sum of all the \\"value\\" fields from these JSON objects. # Function Signature ```python def sum_values_from_file(file_path: str) -> int: ``` # Input * `file_path`: A string representing the file path to a text file containing the newline-delimited JSON objects. # Output * An integer representing the sum of all the \\"value\\" fields from the JSON objects in the file. # Constraints * Each line in the file contains a valid JSON object. * Each JSON object contains a single key \\"value\\", whose value is an integer. * The file may contain a large number of lines (up to 1,000,000 lines). # Example Assume the file `data.ndjson` contains the following lines: ``` {\\"value\\": 10} {\\"value\\": 20} {\\"value\\": 30} {\\"value\\": 40} ``` Running the function should give: ```python print(sum_values_from_file(\\"data.ndjson\\")) # Output: 100 ``` **Note**: Your function will not directly access `data.ndjson`. Use the input parameter to read the file. # Requirements * Efficiently read and process the file to handle large datasets. * Employ error handling to manage potential JSON parsing errors.","solution":"import json def sum_values_from_file(file_path: str) -> int: total_sum = 0 try: with open(file_path, \'r\') as file: for line in file: data = json.loads(line) total_sum += data.get(\\"value\\", 0) except (IOError, json.JSONDecodeError) as e: print(f\\"An error occurred: {e}\\") return total_sum"},{"question":"# Question Context In many applications, it’s crucial to ensure that a sequence of data maintains certain properties, such as being strictly increasing. This kind of validation helps in tasks ranging from sorting algorithms to data consistency checks in databases. Task You are to implement a function `is_strictly_increasing` that checks whether a list of numbers is strictly increasing. A strictly increasing list is a list where each element is greater than the preceding one. Function Signature ```python def is_strictly_increasing(sequence: List[int]) -> bool: Determine if the list of integers is strictly increasing. :param sequence: A list of integers. :return: A boolean value, True if the list is strictly increasing, otherwise False. Raises: TypeError: If the input is not a list of integers. Examples: >>> is_strictly_increasing([1, 2, 3, 4, 5]) True >>> is_strictly_increasing([1, 1, 2, 3, 4]) False >>> is_strictly_increasing([10, 9, 8, 7]) False >>> is_strictly_increasing([1]) True >>> is_strictly_increasing([]) True ``` Constraints - The input will be a list of integers with a length ranging from 0 to 10^5. - Ensure the function raises a `TypeError` if the input is not a list of integers. - The function should efficiently handle lists with a large number of elements. Requirements - Validate the type of input to ensure it is a list of integers. - Consider edge cases such as empty lists and lists with a single element. - The implementation should be efficient in terms of time complexity. Example ```python sequence = [1, 3, 5, 7, 9] # The sequence is strictly increasing because each element is greater than the one before it. print(is_strictly_increasing(sequence)) # Output: True sequence = [2, 2, 3, 4, 5] # The sequence is not strictly increasing because 2 is not greater than the preceding 2. print(is_strictly_increasing(sequence)) # Output: False ``` Notes - Include proper docstrings and comments in your implementation to clarify the logic. - Ensure to handle invalid inputs gracefully by raising appropriate exceptions.","solution":"from typing import List def is_strictly_increasing(sequence: List[int]) -> bool: Determine if the list of integers is strictly increasing. :param sequence: A list of integers. :return: A boolean value, True if the list is strictly increasing, otherwise False. Examples: >>> is_strictly_increasing([1, 2, 3, 4, 5]) True >>> is_strictly_increasing([1, 1, 2, 3, 4]) False >>> is_strictly_increasing([10, 9, 8, 7]) False >>> is_strictly_increasing([1]) True >>> is_strictly_increasing([]) True if not isinstance(sequence, list): raise TypeError(\\"The input must be a list\\") if not all(isinstance(x, int) for x in sequence): raise TypeError(\\"All elements in the list must be integers\\") for i in range(1, len(sequence)): if sequence[i] <= sequence[i - 1]: return False return True"},{"question":"# Problem Statement: Develop a software module to convert temperatures between different scales (Celsius, Fahrenheit, and Kelvin). # Requirements: Implement a class `TemperatureConverter` that allows conversion between Celsius, Fahrenheit, and Kelvin. The class should: 1. Have instance methods to convert a given temperature from Celsius to Fahrenheit, Celsius to Kelvin, Fahrenheit to Celsius, Fahrenheit to Kelvin, Kelvin to Celsius, and Kelvin to Fahrenheit. 2. Raise a `ValueError` with a descriptive message if any of the temperatures provided in the conversion are below absolute zero (-273.15°C, -459.67°F, 0K). # Temperature Conversion Formulas: - Celsius to Fahrenheit: (F = (C times 9/5) + 32) - Celsius to Kelvin: (K = C + 273.15) - Fahrenheit to Celsius: (C = (F - 32) times 5/9) - Fahrenheit to Kelvin: (K = (F - 32) times 5/9 + 273.15) - Kelvin to Celsius: (C = K - 273.15) - Kelvin to Fahrenheit: (F = (K - 273.15) times 9/5 + 32) # Example Implementation: ```python class TemperatureConverter: @staticmethod def celsius_to_fahrenheit(celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Celsius temperature cannot be below -273.15\\") return (celsius * 9/5) + 32 @staticmethod def celsius_to_kelvin(celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Celsius temperature cannot be below -273.15\\") return celsius + 273.15 @staticmethod def fahrenheit_to_celsius(fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Fahrenheit temperature cannot be below -459.67\\") return (fahrenheit - 32) * 5/9 @staticmethod def fahrenheit_to_kelvin(fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Fahrenheit temperature cannot be below -459.67\\") return (fahrenheit - 32) * 5/9 + 273.15 @staticmethod def kelvin_to_celsius(kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Kelvin temperature cannot be below 0\\") return kelvin - 273.15 @staticmethod def kelvin_to_fahrenheit(kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Kelvin temperature cannot be below 0\\") return (kelvin - 273.15) * 9/5 + 32 ``` # Constraints: * The input for conversion is a float number. * The conversions must handle invalid inputs gracefully by raising appropriate errors. # Example Usage: ```python converter = TemperatureConverter() # Example conversions print(converter.celsius_to_fahrenheit(0)) # Output: 32.0 print(converter.celsius_to_kelvin(100)) # Output: 373.15 print(converter.fahrenheit_to_celsius(32)) # Output: 0.0 print(converter.fahrenheit_to_kelvin(212)) # Output: 373.15 print(converter.kelvin_to_celsius(273.15)) # Output: 0.0 print(converter.kelvin_to_fahrenheit(0)) # Raises ValueError: \\"Kelvin temperature cannot be below 0\\" ``` # Note: * Ensure accurate conversion results. * Proper error handling for invalid temperature inputs is crucial.","solution":"class TemperatureConverter: @staticmethod def celsius_to_fahrenheit(celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Celsius temperature cannot be below -273.15\\") return (celsius * 9/5) + 32 @staticmethod def celsius_to_kelvin(celsius: float) -> float: if celsius < -273.15: raise ValueError(\\"Celsius temperature cannot be below -273.15\\") return celsius + 273.15 @staticmethod def fahrenheit_to_celsius(fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Fahrenheit temperature cannot be below -459.67\\") return (fahrenheit - 32) * 5/9 @staticmethod def fahrenheit_to_kelvin(fahrenheit: float) -> float: if fahrenheit < -459.67: raise ValueError(\\"Fahrenheit temperature cannot be below -459.67\\") return (fahrenheit - 32) * 5/9 + 273.15 @staticmethod def kelvin_to_celsius(kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Kelvin temperature cannot be below 0\\") return kelvin - 273.15 @staticmethod def kelvin_to_fahrenheit(kelvin: float) -> float: if kelvin < 0: raise ValueError(\\"Kelvin temperature cannot be below 0\\") return (kelvin - 273.15) * 9/5 + 32"},{"question":"**Context**: You are tasked with creating a simple search engine for a collection of documents. Each document is represented by a string of text. The search engine needs to return the top-k documents that contain a given search term, ranked by the frequency of the term within each document. # Task: Implement a function `search_documents(documents: List[str], term: str, k: int) -> List[str]` that processes the documents, searches for the term, and returns the top-k documents sorted by the frequency of the term in descending order. # Detailed Steps: 1. Process each document to count the occurrences of the search term. 2. Rank the documents based on the frequency of the term. 3. Return the top-k documents with the highest frequency of the term. # Input: * `documents`: A list of strings where each string represents a document. * `term`: A string representing the search term. * `k`: An integer representing the number of top documents to return. # Output: * Returns a list of top-k documents (strings) sorted by the frequency of the search term in descending order. If fewer than k documents contain the term, return all such documents. # Constraints: * The `documents` list can contain up to 10,000 documents. * Each `document` can be up to 1,000 characters long. * The `term` will be a single word consisting of lowercase alphabetical characters. * The frequency comparison should be case-insensitive. # Example: ```python def search_documents(documents: List[str], term: str, k: int) -> List[str]: # Your implementation here # Usage docs = [ \\"the quick brown fox jumps over the lazy dog\\", \\"the quick brown fox\\", \\"the quick\\", \\"the\\", \\"dog\\" ] term = \\"the\\" top_k = 3 result = search_documents(docs, term, top_k) print(result) # Expected output: [\\"the quick brown fox jumps over the lazy dog\\", \\"the quick brown fox\\", \\"the quick\\"] ``` # Performance Requirements: * Your solution should handle up to 10,000 documents efficiently, within acceptable runtime limits.","solution":"from typing import List def search_documents(documents: List[str], term: str, k: int) -> List[str]: Returns the top-k documents containing the search term sorted by frequency of the term. Frequency comparison is case-insensitive. term = term.lower() term_count = [] # Process each document to count occurrences of the search term for doc in documents: count = doc.lower().split().count(term) if count > 0: term_count.append((count, doc)) # Rank the documents based on the frequency of the term term_count.sort(key=lambda x: x[0], reverse=True) # Return the top-k documents return [doc for _, doc in term_count[:k]]"},{"question":"# Smallest Window to Sort Scenario: You are given an integer array that represents the heights of students standing in a line. To allow all the students to get a clear view of the front, it\'s required that their heights be in non-decreasing order. Determine the smallest subarray, which, when sorted, results in the entire array being sorted. Task: Implement a function `find_unsorted_subarray(nums: list[int]) -> tuple` that finds the shortest contiguous subarray that, when sorted, results in the whole array being sorted. The function should return a tuple of its start and end indices. If the array is already sorted, return `(-1, -1)`. Input: * A list of integers `nums` representing the heights of students. Output: * A tuple containing two integers denoting the start and end indices of the shortest subarray which needs sorting. If the array is already sorted, return `(-1, -1)`. Constraints: * The elements in `nums` are distinct. * The length of `nums` is at least 1 and up to 10,000. Performance Requirements: * The function should run in O(n) time complexity. Examples: ```python >>> find_unsorted_subarray([2, 6, 4, 8, 10, 9, 15]) (1, 5) >>> find_unsorted_subarray([1, 2, 3, 4]) (-1, -1) >>> find_unsorted_subarray([2, 3, 3, 2, 4]) (1, 3) >>> find_unsorted_subarray([1, 3, 2, 2, 2]) (1, 4) >>> find_unsorted_subarray([1]) (-1, -1) >>> find_unsorted_subarray([5, 4, 3, 2, 1]) (0, 4) >>> find_unsorted_subarray([1, 5, 3, 4, 2, 6]) (1, 4) ``` Use scanning techniques from both ends of the array to implement an efficient solution that adheres to the given constraints.","solution":"def find_unsorted_subarray(nums): Finds the shortest subarray which, when sorted, results in the entire array being sorted. Args: nums (list of int): List of integers representing heights of students. Returns: tuple of int: Start and end indices of the subarray. If already sorted, return (-1, -1). n = len(nums) if n == 1: return (-1, -1) # Initialize the indices start_index = 0 end_index = -1 # Scan from left to right to find the first disorder max_seen = nums[0] for i in range(1, n): if nums[i] < max_seen: end_index = i else: max_seen = nums[i] # Scan from right to left to find the first disorder min_seen = nums[n-1] for i in range(n-2, -1, -1): if nums[i] > min_seen: start_index = i else: min_seen = nums[i] if end_index == -1: return (-1, -1) return (start_index, end_index)"},{"question":"Coding Assessment Question **Question: Implement a Custom HashMap** You are tasked with implementing a simplified version of a hash map to store key-value pairs. Your hash map should support basic operations such as insertion, deletion, and retrieval. # Function Signatures ```python class CustomHashMap: def __init__(self, initial_capacity: int = 100) -> None: pass def put(self, key: int, value: int) -> None: pass def get(self, key: int) -> int: pass def remove(self, key: int) -> None: pass ``` # Input * Each method will receive its respective inputs as follows: - `put(key, value)`: inserts the key-value pair into the hash map. - `get(key)`: retrieves the value associated with the key from the hash map, or returns -1 if the key does not exist. - `remove(key)`: removes the key-value pair from the hash map if the key exists. # Output * For `put` and `remove` methods, no output is required. * The `get` method should return the value associated with the key, or -1 if the key does not exist in the map. # Requirements * Your implementation should: * Handle collisions using chaining (linked lists). * Dynamically resize the underlying data structure when the load factor exceeds a certain threshold (e.g., 0.7). * Support efficient operations for insertion, deletion, and retrieval. # Example ```python custom_hash_map = CustomHashMap() custom_hash_map.put(1, 10) assert custom_hash_map.get(1) == 10 custom_hash_map.put(2, 20) assert custom_hash_map.get(2) == 20 custom_hash_map.put(1, 15) # Updating value of the existing key assert custom_hash_map.get(1) == 15 custom_hash_map.remove(1) assert custom_hash_map.get(1) == -1 assert custom_hash_map.get(2) == 20 ``` # Explanation * Initialize an instance of `CustomHashMap` with an optional `initial_capacity`. * Implement the `put` method to insert key-value pairs, handling collisions using linked lists. * Implement the `get` method to retrieve the value associated with the key. * Implement the `remove` method to delete the key-value pair from the map if it exists. * Remember to handle edge cases such as updating existing keys, removing non-existing keys, and dynamically resizing the hash map when necessary. *Note*: Think about the efficiency of collision handling and the dynamic resizing mechanism to ensure the operations remain efficient even as the hash map grows in size.","solution":"class CustomHashMap: def __init__(self, initial_capacity: int = 100) -> None: self.capacity = initial_capacity self.size = 0 self.load_factor_threshold = 0.7 self.buckets = [[] for _ in range(self.capacity)] def _hash(self, key: int) -> int: return key % self.capacity def _resize(self): new_capacity = self.capacity * 2 new_buckets = [[] for _ in range(new_capacity)] for bucket in self.buckets: for key, value in bucket: new_hash = key % new_capacity new_buckets[new_hash].append((key, value)) self.buckets = new_buckets self.capacity = new_capacity def put(self, key: int, value: int) -> None: if self.size / self.capacity > self.load_factor_threshold: self._resize() hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) # Update existing key return bucket.append((key, value)) # Insert new key-value pair self.size += 1 def get(self, key: int) -> int: hash_key = self._hash(key) bucket = self.buckets[hash_key] for k, v in bucket: if k == key: return v return -1 def remove(self, key: int) -> None: hash_key = self._hash(key) bucket = self.buckets[hash_key] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 return"},{"question":"# Problem Statement Create a file system simulation where directories and files can be added, and the size of directories can be computed. You need to implement a class `FileSystem` that can add directories and files, and calculate the total size of any directory. # Class Definition ```python class FileSystem: def __init__(self): Initializes the file system with a root directory. pass def add_directory(self, path: str) -> None: Adds a new directory to the file system. :param path: The path where the directory will be added (e.g., \\"/dir1/dir2\\"). :raises ValueError: If parent directory does not exist. pass def add_file(self, path: str, size: int) -> None: Adds a new file to the file system. :param path: The path where the file will be added (e.g., \\"/dir1/dir2/file.txt\\"). :param size: The size of the file in bytes. :raises ValueError: If parent directory does not exist or if size is negative. pass def calculate_directory_size(self, path: str) -> int: Calculates the total size of a directory including all its subdirectories and files. :param path: The path of the directory (e.g., \\"/dir1/dir2\\"). :returns: The total size of the directory in bytes. :raises ValueError: If the directory does not exist. pass ``` # Example ```python fs = FileSystem() fs.add_directory(\\"/dir1\\") fs.add_directory(\\"/dir1/dir2\\") fs.add_file(\\"/dir1/file1.txt\\", 120) fs.add_file(\\"/dir1/dir2/file2.txt\\", 230) fs.add_file(\\"/dir1/dir2/file3.txt\\", 340) print(fs.calculate_directory_size(\\"/dir1\\")) # Output: 690 print(fs.calculate_directory_size(\\"/dir1/dir2\\")) # Output: 570 fs.add_directory(\\"/dir3\\") fs.add_file(\\"/dir3/file4.txt\\", 100) print(fs.calculate_directory_size(\\"/dir3\\")) # Output: 100 ``` # Notes 1. Your implementation should raise a `ValueError` if trying to add a file or directory under a non-existent parent directory. 2. The size of a file must be a non-negative integer. 3. All directory paths start from the root directory (`\\"/\\"`). The root directory is considered to always exist. # Constraints - Directory and file names only contain alphanumeric characters and `\\"_\\", \\"-\\", \\".\\"`. - The maximum depth of the directory structure is 100. - All operations (add_file, add_directory, calculate_directory_size) should be efficient in terms of time and space complexity.","solution":"class FileSystem: def __init__(self): Initializes the file system with a root directory. self.file_system = {\'/\': {}} self.sizes = {} def add_directory(self, path: str) -> None: Adds a new directory to the file system. :param path: The path where the directory will be added (e.g., \\"/dir1/dir2\\"). :raises ValueError: If parent directory does not exist. components = path.strip(\'/\').split(\'/\') current = self.file_system[\'/\'] for comp in components: if comp not in current: if comp == components[-1]: current[comp] = {} else: raise ValueError(f\\"Parent directory does not exist: {path}\\") current = current[comp] def add_file(self, path: str, size: int) -> None: Adds a new file to the file system. :param path: The path where the file will be added (e.g., \\"/dir1/dir2/file.txt\\"). :param size: The size of the file in bytes. :raises ValueError: If parent directory does not exist or if size is negative. if size < 0: raise ValueError(f\\"File size cannot be negative: {size}\\") components = path.strip(\'/\').split(\'/\') filename = components.pop() current = self.file_system[\'/\'] for comp in components: if comp not in current: raise ValueError(f\\"Parent directory does not exist: {path}\\") current = current[comp] current[filename] = size def calculate_directory_size(self, path: str) -> int: Calculates the total size of a directory including all its subdirectories and files. :param path: The path of the directory (e.g., \\"/dir1/dir2\\"). :returns: The total size of the directory in bytes. :raises ValueError: If the directory does not exist. components = path.strip(\'/\').split(\'/\') current = self.file_system[\'/\'] for comp in components: if comp not in current: raise ValueError(f\\"Directory does not exist: {path}\\") current = current[comp] def calculate_size(directory): total_size = 0 for k, v in directory.items(): if isinstance(v, dict): total_size += calculate_size(v) else: total_size += v return total_size return calculate_size(current)"},{"question":"Dynamic Programming for Knapsack Problem You are tasked with implementing a function to solve the 0/1 Knapsack problem using dynamic programming. Given a set of items, each with a weight and a value, determine the maximum value that can be achieved for a given weight limit. # Specifications 1. **Function Name**: `knapsack(max_weight: int, weights: List[int], values: List[int]) -> int` 2. **Input**: - `max_weight`: an integer representing the maximum weight capacity of the knapsack. - `weights`: a list of integers, where `weights[i]` represents the weight of the (i^{th}) item. - `values`: a list of integers, where `values[i]` represents the value of the (i^{th}) item. - ( 1 leq text{len(weights)} = text{len(values)} leq 1000 ) - ( 1 leq text{weights[i]} leq 1000 ) - ( 1 leq text{values[i]} leq 1000 ) 3. **Output**: - The function should return an integer representing the maximum value that can be achieved without exceeding the weight limit. 4. **Constraints**: - Use dynamic programming to achieve an efficient solution. - Consider edge cases such as an empty list of items or a `max_weight` of 0. # Instructions 1. Implement the function using a dynamic programming approach. 2. Create a DP table where `dp[w]` represents the maximum value that can be achieved with a knapsack capacity of `w`. 3. Iterate through the items, updating the DP table accordingly. 4. Ensure your solution runs efficiently given the constraints. # Example ```python def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: pass # Your code goes here # Example weights = [2, 3, 4, 5] values = [3, 4, 5, 6] max_weight = 5 # Explanation: The best solution is to take item 1 and item 3 (weights [2, 3], values [3, 4]) # Total weight: 5, Total value: 7 expected_output = 7 print(knapsack(max_weight, weights, values)) # Should print: 7 ``` # Evaluation Ensure your implementation correctly calculates the maximum value for various combinations of weights and values, and handles edge cases effectively. Comments and clean, readable code are highly appreciated.","solution":"from typing import List def knapsack(max_weight: int, weights: List[int], values: List[int]) -> int: Solves the 0/1 Knapsack problem using dynamic programming. Args: max_weight (int): The maximum weight capacity of the knapsack. weights (List[int]): The weights of the items. values (List[int]): The values of the items. Returns: int: The maximum value that can be achieved without exceeding the weight limit. n = len(weights) dp = [0] * (max_weight + 1) for i in range(n): for w in range(max_weight, weights[i] - 1, -1): dp[w] = max(dp[w], dp[w - weights[i]] + values[i]) return dp[max_weight]"},{"question":"# Balanced Parentheses Removal Context In programming, ensuring that the parentheses in a string are balanced is crucial for correctly interpreting code and expressions. Sometimes, it is necessary to remove the minimum number of parentheses to make a string valid (balanced and correctly nested). Task Given a string `s` containing only the characters `\'(\'` and `\')\'`, write a function `remove_invalid_parentheses(s)` that removes the minimum number of parentheses to make the string valid. Return all possible valid strings in any order. ```python def remove_invalid_parentheses(s: str) -> list: Given a string `s` containing only \'(\' and \')\', return all possible valid strings obtained by removing the minimum number of invalid parentheses. :param s: The input string containing parentheses :type s: str :return: A list of all possible valid strings after parentheses removal :rtype: list Examples: >>> remove_invalid_parentheses(\\"()())()\\") [\\"()()()\\", \\"(())()\\"] >>> remove_invalid_parentheses(\\"(a)())()\\") [\\"(a)()()\\", \\"(a())()\\"] >>> remove_invalid_parentheses(\\")(\\") [\\"\\"] >>> remove_invalid_parentheses(\\"(((abc)\\") [\\"(abc)\\", \\"(abc)\\", \\"(abc\\"] >>> remove_invalid_parentheses(\\"()\\") [\\"()\\"] pass ``` Constraints - The length of the input string `s` will not exceed 300. - Handle cases with multiple valid outputs. - Aim to return the results efficiently in terms of time and space.","solution":"from collections import deque def remove_invalid_parentheses(s: str) -> list: Given a string `s` containing only \'(\' and \')\', return all possible valid strings obtained by removing the minimum number of invalid parentheses. :param s: The input string containing parentheses :type s: str :return: A list of all possible valid strings after parentheses removal :rtype: list def is_valid(string): balance = 0 for char in string: if char == \'(\': balance += 1 elif char == \')\': balance -= 1 if balance < 0: return False return balance == 0 if is_valid(s): return [s] visited = set() queue = deque([s]) found = False valid_expressions = [] while queue: current = queue.popleft() if is_valid(current): valid_expressions.append(current) found = True if found: continue for i in range(len(current)): if current[i] not in (\'(\', \')\'): continue next_state = current[:i] + current[i+1:] if next_state not in visited: visited.add(next_state) queue.append(next_state) return valid_expressions"},{"question":"# Coding Assessment Question Context You are developing a library management system that needs to reassign unique IDs to books whenever a new shipment arrives. Each new shipment comes with books identified by their global unique IDs, but the library also uses local IDs. Your task is to assign the smallest possible unique local IDs to the new books in a manner that no two books have the same local ID, and the IDs start from 1. Task Implement a function `assign_local_ids(arrivals: List[int]) -> List[int]` that takes a list of integer book IDs representing new arrivals and returns a list of local IDs assigned to these books. Input - `arrivals`: A list of integers, where each integer represents a unique global ID of a book. Output - Return a list of integers, each representing the local ID assigned to the corresponding book in the arrivals list. The local IDs should start from 1 and must be unique within the list. Constraints - The length of the list `arrivals` is between 1 and 10^5. - Each global ID in `arrivals` is a positive integer less than 10^9. Example ```python def assign_local_ids(arrivals: List[int]) -> List[int]: pass # Example Usage arrivals = [12345, 67890, 23456] assert assign_local_ids(arrivals) == [1, 2, 3] arrivals = [54321, 12345, 67890, 12345] assert assign_local_ids(arrivals) == [1, 2, 3, 4] ``` Requirements - Your solution should run efficiently even for the upper constraint limits. - Ensure the local IDs are assigned incrementally starting from 1 and without any gaps. - The function should handle duplicate global IDs in the input and ensure the local IDs assigned are unique.","solution":"from typing import List def assign_local_ids(arrivals: List[int]) -> List[int]: Assigns local IDs to each incoming book from the arrivals list. The local IDs start from 1 and correspond to the order of the arrivals. Args: arrivals (List[int]): List of unique global IDs for the books. Returns: List[int]: List of local IDs assigned starting from 1. local_ids = [i + 1 for i in range(len(arrivals))] return local_ids"},{"question":"# Problem Description: Your task is to implement a function that takes a 2D grid of characters and returns all words from a given list that can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. # Function Signature: ```python def find_words(board: list[list[str]], words: list[str]) -> list[str]: pass ``` # Input: - `board`: A 2D grid `n x m` (2D list) consisting of lowercase English letters. - `words`: A list of strings representing the words to be searched in the board. # Output: - Returns a list of strings representing the words found in the board. # Constraints: - `1 <= board.length <= 15` - `1 <= board[i].length <= 15` - `1 <= words.length <= 1000` - `1 <= words[i].length <= 15` - All the strings in `words` and characters in `board` are lowercase English letters. # Example: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\", \\"pea\\", \\"eat\\", \\"rain\\"] # find_words(board, words) should return: # [\\"oath\\", \\"eat\\"] assert set(find_words(board, words)) == {\\"oath\\", \\"eat\\"} --- board = [ [\'a\',\'b\'], [\'c\',\'d\'] ] words = [\\"abcb\\"] # find_words(board, words) should return: # [] assert set(find_words(board, words)) == set() ``` # Notes: - Ensure your implementation handles cases where multiple words overlap in the same grid area. - Words may share letters. - The order of words in the output list does not matter.","solution":"def find_words(board: list[list[str]], words: list[str]) -> list[str]: def dfs(board, word, index, x, y, visited): if index == len(word): return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or (x, y) in visited or board[x][y] != word[index]: return False visited.add((x, y)) res = (dfs(board, word, index + 1, x + 1, y, visited) or dfs(board, word, index + 1, x - 1, y, visited) or dfs(board, word, index + 1, x, y + 1, visited) or dfs(board, word, index + 1, x, y - 1, visited)) visited.remove((x, y)) return res found_words = [] for word in words: if any(dfs(board, word, 0, i, j, set()) for i in range(len(board)) for j in range(len(board[0]))): found_words.append(word) return found_words"},{"question":"# Question: Roman Numeral Validator You are tasked with writing a Python function `is_valid_roman(input_str: str) -> bool` that verifies if the given input string is a valid Roman numeral. The function should return `True` if the input is a valid Roman numeral and `False` otherwise. Requirements: 1. **Input Type Validation**: - The function should raise a `ValueError` if the input is not a string. - The function should raise a `ValueError` if the input string contains characters other than `I, V, X, L, C, D, and M`. 2. **Format Validation**: - The function should validate the order and repetition rules for Roman numerals. - Roman numerals must be composed according to the rules (e.g., `IIII` is invalid, but `IV` is valid). Function Signature: ```python def is_valid_roman(input_str: str) -> bool: ``` Input: - `input_str (str)`: A string potentially representing a Roman numeral. Output: - Returns `True` if `input_str` is a valid Roman numeral, else `False`. Constraints: - The input string can have a length from `1` to `15` characters. Examples: ```python >>> is_valid_roman(\\"XIV\\") # Valid Roman numeral True >>> is_valid_roman(\\"IIII\\") # Invalid repetition False >>> is_valid_roman(\\"MMCDXLIV\\") # Valid Roman numeral True >>> is_valid_roman(\\"IIIIXYZ\\") # Invalid characters False >>> is_valid_roman(\\"LC\\") # Invalid order False >>> is_valid_roman(\\"MCMXCIV\\") # Valid Roman numeral True ``` Notes: Ensure your solution efficiently handles the given input constraints and correctly implements the verification algorithm as described.","solution":"def is_valid_roman(input_str: str) -> bool: Returns True if the input_str is a valid Roman numeral, otherwise False. if not isinstance(input_str, str): raise ValueError(\\"Input must be a string\\") valid_characters = \\"IVXLCDM\\" for c in input_str: if c not in valid_characters: raise ValueError(\\"Input contains invalid characters\\") roman_numerals_pattern = \\"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\\" import re if re.match(roman_numerals_pattern, input_str): return True else: return False"},{"question":"# Background You are working on a project that involves processing and analyzing large text files. One common task is to identify and extract all unique words from these files while ignoring case and punctuation. The goal is to create a data structure that allows efficient checking of word existence and easy retrieval of the list of unique words. # Problem Statement Write a function named `extract_unique_words` in Python that performs the following tasks: 1. Accepts a string representing the file path to a text file. 2. Reads the content of the specified file. 3. Processes the text to extract unique words, ignoring case and punctuation. 4. Returns a sorted list of unique words. # Function Signature ```python def extract_unique_words(file_path: str) -> List[str]: # your code here ``` # Input - `file_path` (string): A valid file path to a text file containing arbitrary text. # Output - (List of strings): A sorted list containing all unique words from the text file, in lowercase. # Constraints - Assume the file contains only printable ASCII characters. - Words are defined as contiguous sequences of alphabets (`a-z`, `A-Z`). - Ignore any punctuations and other characters while extracting words. - The input file may be very large, so consider memory-efficient processing. # Example Usage ```python words = extract_unique_words(\\"example.txt\\") print(words) # Output: A sorted list of unique words from the file \\"example.txt\\" ``` # Example Assume the content of \\"example.txt\\" is: ``` Hello world! Hello again, world. ``` The function\'s output should be: ```python [\'again\', \'hello\', \'world\'] ``` # Notes - You may use Python\'s `re` module to help with splitting and cleaning the text. - Ensure the function handles possible errors, such as the file not existing.","solution":"import re from typing import List def extract_unique_words(file_path: str) -> List[str]: Reads the specified file, extracts unique words ignoring case and punctuation, and returns a sorted list of these unique words. try: with open(file_path, \'r\') as file: text = file.read() except FileNotFoundError: raise FileNotFoundError(f\\"The file {file_path} does not exist.\\") # Use regex to find all words, ignoring punctuation and case words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Get unique words by converting the list to a set unique_words = sorted(set(words)) return unique_words"},{"question":"# Coding Assessment Question Objective: Develop a function that simulates a basic text editor with undo and redo operations. Problem Statement: You need to create a class `TextEditor` that simulates a simple text editor. The editor should support basic operations such as adding text, deleting text, and undoing and redoing actions. Input: - The class `TextEditor` should have the following methods: - `def __init__(self) -> None`: Initializes an empty text editor. - `def add_text(self, text: str) -> None`: Adds the provided `text` at the end of the current text. - `def delete_text(self, count: int) -> None`: Deletes the last `count` characters from the current text. - `def undo(self) -> None`: Undoes the last operation (add or delete). - `def redo(self) -> None`: Redoes the last undone operation. - `def get_text(self) -> str`: Returns the current text. Output: - The output for each method is as follows: - `add_text(text: str)`: No output. - `delete_text(count: int)`: No output. - `undo()`: No output. - `redo()`: No output. - `get_text()`: Returns a string representing the current text in the editor. Constraints: - The given `text` in `add_text` will be a non-empty string made up of lowercase alphabets only. - The `count` in `delete_text` will be a non-negative integer and will not exceed the length of the current text. - Consecutive undo or redo operations should handle boundaries seamlessly without throwing errors. - If there is no operation to undo or redo, the respective method should have no effect. Example: ```python editor = TextEditor() editor.add_text(\\"hello\\") print(editor.get_text()) # Expected output: \\"hello\\" editor.add_text(\\" world\\") print(editor.get_text()) # Expected output: \\"hello world\\" editor.delete_text(5) print(editor.get_text()) # Expected output: \\"hello\\" editor.undo() print(editor.get_text()) # Expected output: \\"hello world\\" editor.redo() print(editor.get_text()) # Expected output: \\"hello\\" editor.undo() editor.undo() print(editor.get_text()) # Expected output: \\"\\" ``` Requirements: - Implement the class `TextEditor` according to the described methods and functionalities. - Ensure efficient handling of undo and redo operations. - Maintain clean and efficient code with appropriate error checking where needed. - Emphasize on immutability of strings by not altering the original text directly but maintaining versions/history as necessary.","solution":"class TextEditor: def __init__(self) -> None: self.text = \\"\\" self.history = [] self.redo_stack = [] def add_text(self, text: str) -> None: self.history.append(self.text) self.text += text self.redo_stack.clear() def delete_text(self, count: int) -> None: self.history.append(self.text) self.text = self.text[:-count] self.redo_stack.clear() def undo(self) -> None: if self.history: self.redo_stack.append(self.text) self.text = self.history.pop() def redo(self) -> None: if self.redo_stack: self.history.append(self.text) self.text = self.redo_stack.pop() def get_text(self) -> str: return self.text"},{"question":"# Problem Description You are given an implementation of a version-controlled document system that allows collaborative editing. In this system, each edit is recorded as a version, and users can revert to any previous version of the document. Your task is to extend the implementation to add additional functionality for practical use cases. # Tasks 1. Implement a method to merge changes from a specified version into the current version. 2. Implement a method to display the difference between two versions of the document. 3. Add a method to list all the changes made by a specific user. # Function Specifications 1. **merge(version: int)**: Merge changes from a specified version into the current document version. - **Input**: An integer `version` representing the version number to merge from. - **Output**: None - **Behavior**: Merge the content from the specified version into the current version while preserving changes made after the specified version. 2. **diff(version1: int, version2: int) -> str**: Display the difference between two versions. - **Input**: Two integers `version1` and `version2` representing the version numbers to compare. - **Output**: A string representing the differences between the two versions. The output can be in a format similar to Unix `diff` command. - **Behavior**: Compare the contents of the specified versions and return the differences between them. 3. **changes_by_user(user: str) -> List[str]**: List all changes made by a specific user. - **Input**: A string `user` representing the username of the user. - **Output**: A list of strings, each representing a change made by the user. - **Behavior**: Return all the changes (as descriptions) made by the specified user across all document versions. # Constraints - Versions will always be non-negative integers. - The document is represented as a list of strings, where each string is a line in the document. - Each edit is recorded with metadata, including the user who made the change. - The `diff` method should handle line-level differences. # Example ```python doc_system = DocumentSystem() doc_system.edit(\\"Alice\\", [\\"Line 1\\", \\"Line 2\\", \\"Line 3\\"]) doc_system.edit(\\"Bob\\", [\\"Line 1\\", \\"Line 2 changed\\", \\"Line 3\\"]) doc_system.edit(\\"Alice\\", [\\"Line 1\\", \\"Line 2 changed\\", \\"Line 3\\", \\"Line 4\\"]) print(doc_system.get_current_version()) # Version 3: [\\"Line 1\\", \\"Line 2 changed\\", \\"Line 3\\", \\"Line 4\\"] # Merge changes from version 1 doc_system.merge(1) print(doc_system.get_current_version()) # Merged Version 3: [\\"Line 1\\", \\"Line 2\\", \\"Line 3\\", \\"Line 4\\"] # Compare versions diff = doc_system.diff(1, 3) print(diff) # Output the difference between version 1 and version 3 # List changes by Alice alice_changes = doc_system.changes_by_user(\\"Alice\\") print(alice_changes) # [\\"Added Line 1\\", \\"Added Line 2\\", \\"Added Line 3\\", \\"Added Line 4\\"] ``` # Requirements - Your implementation should be efficient, with a focus on handling a reasonable number of versions and edits. - Consider edge cases such as merging from versions that have no changes or comparing the same versions in the `diff` method. - Handle user-specific querying in the `changes_by_user` method effectively.","solution":"class DocumentSystem: def __init__(self): self.versions = [] self.current_version_index = -1 self.users = [] def edit(self, user, content): self.versions.append(content) self.current_version_index += 1 self.users.append(user) def get_current_version(self): if self.current_version_index == -1: return None return self.versions[self.current_version_index] def merge(self, version): if version < 0 or version > self.current_version_index: raise ValueError(\\"Invalid version number\\") merge_version_content = self.versions[version] current_content = self.get_current_version() merged_content = list(merge_version_content) # Ensure unique lines from current version are preserved for line in current_content: if line not in merged_content: merged_content.append(line) self.versions.append(merged_content) self.current_version_index += 1 def diff(self, version1, version2): if version1 < 0 or version1 > self.current_version_index or version2 < 0 or version2 > self.current_version_index: raise ValueError(\\"Invalid version number\\") content1 = self.versions[version1] content2 = self.versions[version2] diff_result = \\"\\" for i in range(max(len(content1), len(content2))): line1 = content1[i] if i < len(content1) else \\"\\" line2 = content2[i] if i < len(content2) else \\"\\" if line1 != line2: diff_result += f\\"- {line1}n+ {line2}n\\" return diff_result.strip() def changes_by_user(self, user): changes = [] for i, u in enumerate(self.users): if u == user: changes.append(f\\"Version {i}: {self.versions[i]}\\") return changes"},{"question":"**Objective**: Implement and analyze a program that manages hotel room booking and availability. **Scenario**: You are given a set of hotel rooms, each with a unique identifier and a specific capacity. Implement a system to handle room bookings, ensuring that the requested number of guests can be accommodated. Your system should include a function `book_rooms` that processes a list of bookings, automatically assigns rooms based on their availability, and returns a summary with room assignments. **Guidelines**: - Implement a class `Hotel` to maintain the list of rooms and their capacities. - Include methods for adding rooms, checking availability, and booking rooms. - Ensure proper handling of edge cases, such as overbooking attempts. - Your system should be scalable and able to handle a large number of room booking requests efficiently. **Function Signatures**: ```python class Hotel: def __init__(self): self.rooms = {} def add_room(self, room_id: str, capacity: int) -> None: pass def book_rooms(self, bookings: List[int]) -> Dict[int, List[str]]: pass def available_rooms(self, guests: int) -> List[str]: pass ``` **Input Format for `add_room`**: - `room_id`: A string representing the unique identifier of the room. - `capacity`: An integer representing the maximum number of guests the room can accommodate. **Input Format for `book_rooms`**: - `bookings`: A list of integers, each representing the number of guests for a booking. **Output Format for `book_rooms`**: - A dictionary where each key represents the booking index, and the value is a list of room identifiers assigned to that booking. **Constraints**: - Room capacities and booking guest numbers are positive integers. - The system should handle overlapping bookings efficiently by checking and updating room availability. **Examples**: ```python hotel = Hotel() hotel.add_room(\\"101\\", 2) hotel.add_room(\\"102\\", 4) hotel.add_room(\\"103\\", 2) >>> bookings = [2, 4, 2] >>> hotel.book_rooms(bookings) {0: [\'101\'], 1: [\'102\'], 2: [\'103\']} >>> bookings = [1, 3, 2] >>> hotel.book_rooms(bookings) {0: [\'103\'], 1: [\'102\'], 2: [\'101\']} ``` **Important Considerations**: - Handle situations where a booking cannot be accommodated (e.g., return an empty list for that booking entry in the output dictionary). - Ensure the system maintains a list of available rooms for future bookings and updates their statuses accordingly. **Note**: Focus on efficient room allocation to minimize the number of rooms used and ensure availability for a variety of booking sizes.","solution":"from typing import List, Dict class Hotel: def __init__(self): self.rooms = {} self.available_rooms_list = [] def add_room(self, room_id: str, capacity: int) -> None: self.rooms[room_id] = { \\"capacity\\": capacity, \\"available\\": True } self.available_rooms_list.append((capacity, room_id)) self.available_rooms_list.sort() def available_rooms(self, guests: int) -> List[str]: suitable_rooms = [] for capacity, room_id in self.available_rooms_list: if capacity >= guests and self.rooms[room_id][\\"available\\"]: suitable_rooms.append(room_id) return suitable_rooms def book_rooms(self, bookings: List[int]) -> Dict[int, List[str]]: booking_result = {} for booking_id, guests in enumerate(bookings): suitable_rooms = self.available_rooms(guests) if suitable_rooms: room_id = suitable_rooms[0] self.rooms[room_id][\\"available\\"] = False booking_result[booking_id] = [room_id] self.available_rooms_list.remove((self.rooms[room_id][\\"capacity\\"], room_id)) else: booking_result[booking_id] = [] return booking_result"},{"question":"# Word Ladder Transformation Your task is to implement a function that determines if it is possible to transform a given word into another word by changing exactly one letter at a time, with each intermediate step being a valid word from a provided dictionary. # Objective Develop the function `word_ladder` to check if a sequence of single-letter transformations exists from a starting word to an ending word using words from the given dictionary. # Implementation Details 1. Implement the `word_ladder` function. 2. The function should return True if it\'s possible to transform the `start_word` into the `end_word` by changing one letter at a time and ensuring each intermediate word is in the `dictionary`. 3. If no such sequence exists, return False. # Function Signature ```python def word_ladder(start_word: str, end_word: str, dictionary: set[str]) -> bool: ... ``` # Inputs - **start_word**: a string representing the starting word. - **end_word**: a string representing the end word. - **dictionary**: a set of strings representing the dictionary of valid words. # Output - Return `True` if the transformation is possible, or `False` otherwise. # Constraints - All words (start_word, end_word, and dictionary words) are lowercase. - All words have the same length. - The dictionary can contain up to 10,000 words. - The maximum length of any word is 10. # Example Given inputs: ```python start_word = \\"hit\\" end_word = \\"cog\\" dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"} ``` The function should return: ```python True ``` Given inputs: ```python start_word = \\"hit\\" end_word = \\"cog\\" dictionary = {\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\"} ``` The function should return: ```python False ``` Ensure your implementation is efficient and can handle the upper limits of the input constraints effectively. Consider using appropriate data structures and algorithms to achieve optimal performance.","solution":"from collections import deque def word_ladder(start_word: str, end_word: str, dictionary: set[str]) -> bool: Determines if it is possible to transform the start_word into the end_word by changing exactly one letter at a time, with each intermediate step being a valid word from the provided dictionary. if end_word not in dictionary: return False queue = deque([(start_word, 1)]) visited = set([start_word]) while queue: current_word, steps = queue.popleft() if current_word == end_word: return True for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in dictionary and next_word not in visited: queue.append((next_word, steps + 1)) visited.add(next_word) return False"},{"question":"# Prime Number Position Calculator You need to write a function that calculates the position of a given prime number in the sequence of prime numbers. For example, the prime number 2 is the 1st prime number, 3 is the 2nd prime number, 5 is the 3rd prime number, and so on. Write a function `prime_position(prime_number: int) -> int` that: 1. Takes an integer `prime_number`, where `prime_number` is a positive prime number. 2. Returns the position of the `prime_number` in the sequence of prime numbers (starting from 1). 3. Raises a `ValueError` if the input is not a prime number. 4. Raises a `ValueError` if the input is less than 2. # Constraints 1. The function must handle inputs up to at least the 1000th prime number efficiently. 2. Ensure your implementation is clear and handles edge cases according to the error specifications. # Input * `prime_number`: An integer representing a prime number (2 <= `prime_number`). # Output * An integer representing the position of the given prime number in the sequence of prime numbers. # Examples ```python >>> prime_position(2) 1 >>> prime_position(3) 2 >>> prime_position(11) 5 >>> prime_position(29) 10 >>> prime_position(1) Traceback (most recent call last): ... ValueError: Input must be a prime number greater than or equal to 2 >>> prime_position(4) Traceback (most recent call last): ... ValueError: Input must be a prime number >>> prime_position(15) Traceback (most recent call last): ... ValueError: Input must be a prime number ``` Write your solution below: ```python import math def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_position(prime_number: int) -> int: if not is_prime(prime_number): raise ValueError(\\"Input must be a prime number\\") if prime_number < 2: raise ValueError(\\"Input must be a prime number greater than or equal to 2\\") count = 0 current_number = 2 while True: if is_prime(current_number): count += 1 if current_number == prime_number: return count current_number += 1 # You may add your own test cases to validate the implementation: if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"import math def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def prime_position(prime_number: int) -> int: if prime_number < 2: raise ValueError(\\"Input must be a prime number greater than or equal to 2\\") if not is_prime(prime_number): raise ValueError(\\"Input must be a prime number\\") count = 0 current_number = 2 while True: if is_prime(current_number): count += 1 if current_number == prime_number: return count current_number += 1"},{"question":"# Problem Statement Suppose you are given a list of strings representing dates in the format `DD/MM/YYYY`. Your task is to implement a function that calculates the number of days between each consecutive date in the list. The function should return a list of integers, where each integer represents the number of days between two consecutive dates. # Function Signature ```python def days_between_dates(dates: List[str]) -> List[int]: ... ``` # Input - `dates`: A list of strings, each string formatted as `DD/MM/YYYY`. The list contains at least two dates, and dates are provided in chronological order. # Output A list of integers where each integer represents the number of days between two consecutive dates in the input list. # Constraints - Dates will be valid dates from January 1, 1900 to December 31, 2100. - The input list `dates` will always contain at least two dates. # Requirements 1. Implement proper input validation to ensure date format compliance. 2. Calculate the number of days accurately accounting for leap years and different month lengths. 3. Return a list of integers representing the number of days between each consecutive date. # Example ```python >>> days_between_dates([\\"01/01/2020\\", \\"15/01/2020\\", \\"07/02/2020\\"]) [14, 23] >>> days_between_dates([\\"28/02/2020\\", \\"01/03/2020\\", \\"15/03/2020\\"]) [2, 14] >>> days_between_dates([\\"30/12/2019\\", \\"02/01/2020\\"]) [3] ``` # Note Ensure that your implementation properly handles varying month lengths and leap years, and provides accurate results for the number of days between given dates.","solution":"from datetime import datetime from typing import List def days_between_dates(dates: List[str]) -> List[int]: Calculate the number of days between each consecutive date in the list. Parameters: dates (List[str]): List of date strings in the format \'DD/MM/YYYY\'. Returns: List[int]: A list of integers representing the number of days between each consecutive date. date_format = \\"%d/%m/%Y\\" days_diff = [] for i in range(1, len(dates)): date1 = datetime.strptime(dates[i-1], date_format) date2 = datetime.strptime(dates[i], date_format) diff = (date2 - date1).days days_diff.append(diff) return days_diff"},{"question":"# Coding Assessment Question You have been tasked to develop a new system for managing the inventory of products in a retail store. One of the functionalities needed is a feature to reorder products when their quantities fall below a certain threshold. You need to write a function `reorder_products(inventory: dict, threshold: int) -> list` that determines which products need to be reordered. Create a function `reorder_products` that meets the following criteria: * **Input/Output Formats**: * **Input**: * `inventory` (dict): A dictionary where each key is a product name (string), and each value is the quantity of that product (int), each quantity must be non-negative. * `threshold` (int): The threshold quantity below which the product needs to be reordered, must be a non-negative integer. * **Output**: * (list): A list of product names (strings) that need to be reordered. * **Constraints and Limitations**: * The function should raise exceptions with meaningful messages if the inputs are invalid: * If any quantity in the `inventory` dictionary is negative, raise Exception with the message \\"Quantities must be non-negative\\". * If `threshold` is negative, raise Exception with the message \\"Threshold must be a non-negative integer\\". * If `inventory` is empty, raise Exception with the message \\"Inventory cannot be empty\\". * The function should return the product names in the order they appear in the input dictionary. * **Performance Requirements**: * Ensure the function runs efficiently with a time complexity of O(n) where n is the number of products in the inventory, and a space complexity of O(1) excluding the output list. * **Example**: ```python def reorder_products(inventory: dict, threshold: int) -> list: # your implementation here # Test Cases print(reorder_products({\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 2}, 6)) # Expected output: [\'bananas\', \'oranges\'] print(reorder_products({\\"apples\\": 10, \\"bananas\\": 12, \\"oranges\\": 15}, 10)) # Expected output: [] try: reorder_products({\\"apples\\": 10, \\"bananas\\": -1, \\"oranges\\": 2}, 6) # Expected output: Exception(\\"Quantities must be non-negative\\") except Exception as e: print(e) try: reorder_products({\\"apples\\": 10, \\"bananas\\": 5, \\"oranges\\": 2}, -5) # Expected output: Exception(\\"Threshold must be a non-negative integer\\") except Exception as e: print(e) try: reorder_products({}, 6) # Expected output: Exception(\\"Inventory cannot be empty\\") except Exception as e: print(e) ```","solution":"def reorder_products(inventory: dict, threshold: int) -> list: # Check for invalid inputs if any(quantity < 0 for quantity in inventory.values()): raise Exception(\\"Quantities must be non-negative\\") if threshold < 0: raise Exception(\\"Threshold must be a non-negative integer\\") if not inventory: raise Exception(\\"Inventory cannot be empty\\") # Determine which products need to be reordered reorder_list = [product for product, quantity in inventory.items() if quantity < threshold] return reorder_list"},{"question":"# Coding Challenge: Unique Character Subsequence Scenario You have been assigned to work on a new text-processing feature for a document analysis tool. Your task is to find the length of the longest subsequence in a given string where all characters are unique, without altering the order of the characters. Question Write a Python function that takes a string as input and returns the length of the longest subsequence in which no character repeats. Function Signature ```python def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence with all unique characters. Args: s (str): The input string Returns: int: The length of the longest subsequence with unique characters ``` Input/Output * **Input Format**: A string `s` of length n (1 ≤ n ≤ 1000) consisting of English letters (both uppercase and lowercase) and digits. * **Output Format**: An integer indicating the length of the longest subsequence with unique characters. Constraints 1. The characters in the subsequence must maintain their relative positions in the original string. 2. Uppercase and lowercase letters are considered distinct (e.g., \'A\' and \'a\' are different characters). Performance Requirement Ensure your solution efficiently handles strings up to the maximum length. Example ```python print(longest_unique_subsequence(\\"abacb\\")) # Expected output: 3 (one possible subsequence: \\"abc\\") print(longest_unique_subsequence(\\"abcdef\\")) # Expected output: 6 (subsequence: \\"abcdef\\") ```","solution":"def longest_unique_subsequence(s: str) -> int: Returns the length of the longest subsequence with all unique characters. Args: s (str): The input string Returns: int: The length of the longest subsequence with unique characters unique_set = set() longest_length = 0 # Iterate through the string and collect unique characters for char in s: if char not in unique_set: unique_set.add(char) longest_length += 1 return longest_length"},{"question":"# Context: A software company is working on a new data processing pipeline, which includes several data transformation steps. One of the key components is to perform complex matrix operations efficiently. They need your expertise to optimize the process of matrix multiplication for large datasets by implementing a custom matrix class that supports efficient multiplication. # Task: Extend the `Matrix` class to support optimized matrix multiplication, ensuring it can handle large datasets effectively. # Requirements: 1. **Function Implementation:** - Implement the `multiply` method for the `Matrix` class which performs matrix multiplication of two matrices. - Optimize the matrix multiplication to handle large matrices (e.g., using block multiplication or Strassen\'s algorithm). - Ensure the implementation is efficient in terms of both time and space complexity. 2. **Edge Case Handling:** - Handle cases where the matrices cannot be multiplied due to incompatible dimensions. - Ensure proper error messages are generated for invalid operations. 3. **Testing:** - Demonstrate the correctness and efficiency of your implementation with several test cases, including small and large matrices. **Input and Output formats:** - **Input:** Two Matrix objects, A and B. - **Output:** A new Matrix object representing the product of matrices A and B. **Constraints:** - Assume the `Matrix` class is pre-defined with necessary methods such as initializing the matrix and accessing its elements. - Use numpy or similar libraries for underlying numerical operations if necessary. # Example: ```python import numpy as np class Matrix: def __init__(self, data): self.data = np.array(data) def multiply(self, other): # Basic implementation (to be optimized) if self.data.shape[1] != other.data.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") return Matrix(np.dot(self.data, other.data)) # Example usage A = Matrix([[1, 2], [3, 4]]) B = Matrix([[5, 6], [7, 8]]) C = A.multiply(B) # Expected: Matrix([[19, 22], [43, 50]]) print(C.data) ``` **Note:** Ensure to include appropriate imports and optimize the `multiply` method within the `Matrix` class for handling large datasets efficiently.","solution":"import numpy as np class Matrix: def __init__(self, data): self.data = np.array(data) def multiply(self, other): # Check if matrices can be multiplied if self.data.shape[1] != other.data.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Implementing a block matrix multiplication algorithm def block_multiply(A, B, block_size): n = A.shape[0] C = np.zeros((n, n)) for i in range(0, n, block_size): for j in range(0, n, block_size): for k in range(0, n, block_size): A_block = A[i:i+block_size, k:k+block_size] B_block = B[k:k+block_size, j:j+block_size] C[i:i+block_size, j:j+block_size] += np.dot(A_block, B_block) return C block_size = 64 # Assuming block_size for better cache optimization result_data = block_multiply(self.data, other.data, block_size) return Matrix(result_data)"},{"question":"# Question: Implement a Character Frequency Counter **Scenario**: As a software developer, you are asked to create a function that analyzes the frequency of characters in a given string. This function is crucial for a text analysis tool that your team is developing. The string will only contain alphabetic characters and spaces. Your goal is to write a function `character_frequency` that calculates the frequency of each character in the input string (ignoring spaces) and returns the result as a dictionary. The keys of the dictionary should be the characters, and the values should be the corresponding frequencies. Characters should be case-insensitive, meaning \'A\' and \'a\' should be considered the same character. # Requirements: * **Function Name**: `character_frequency` * **Input**: A string consisting of alphabetic characters and spaces. * **Output**: A dictionary with character frequencies (case-insensitive). * **Constraints**: * Ignore spaces in the input string. * Treat uppercase and lowercase letters as the same character. # Function Signature: ```python def character_frequency(text: str) -> dict: pass ``` # Example: ```python >>> character_frequency(\\"Hello World\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} >>> character_frequency(\\"Programming\\") {\'p\': 1, \'r\': 2, \'o\': 1, \'g\': 2, \'a\': 1, \'m\': 2, \'i\': 1, \'n\': 1} >>> character_frequency(\\"Data Analysis\\") {\'d\': 1, \'a\': 4, \'t\': 1, \'n\': 1, \'l\': 1, \'y\': 1, \'s\': 1} ``` # Constraints: 1. The function should be case-insensitive. 2. Ignore spaces in the input string. You are encouraged to write clear and efficient code, ensuring that the algorithm runs with time complexity of (O(n)) and space complexity of (O(n)), where (n) is the length of the input string.","solution":"def character_frequency(text: str) -> dict: Analyzes the frequency of characters in the input string, ignoring spaces and treating uppercase and lowercase letters as the same character. Parameters: text (str): The input string consisting of alphabetic characters and spaces. Returns: dict: A dictionary with characters as keys and their frequencies as values. frequency = {} for char in text: if char != \' \': char = char.lower() if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Minimum Cost to Reach Home **Context:** You are visiting a city and plan to take a taxi to get around. The city has `n` intersections, and some intersections are connected by roads with different travel costs. You will start from intersection `s` and need to reach intersection `d`. Your goal is to find the minimum cost to reach your destination `d` from `s`. **Task:** Write a function `min_cost(n: int, roads: List[Tuple[int, int, int]], s: int, d: int) -> int` that returns the minimum cost to travel from intersection `s` to intersection `d`. **Function Signature:** ```python def min_cost(n: int, roads: List[Tuple[int, int, int]], s: int, d: int) -> int: pass ``` **Input:** - `n` (1 ≤ n ≤ 1000): An integer representing the number of intersections. - `roads`: A list of tuples where each tuple `(a, b, c)` represents a road from intersection `a` to intersection `b` with a travel cost `c`. - `s` (0 ≤ s < n): An integer representing the starting intersection. - `d` (0 ≤ d < n): An integer representing the destination intersection. **Output:** - An integer representing the minimum cost to travel from intersection `s` to intersection `d`. If it\'s not possible to reach `d` from `s`, return -1. **Constraints:** - The function should use a shortest path algorithm such as Dijkstra\'s algorithm or any other efficient graph traversal algorithm to find the minimum cost path. - Handle edge cases where there are no connecting roads or if the destination is not reachable from the start. **Performance Requirements:** - Ensure the algorithm efficiently handles the given constraints of intersections and roads. **Example:** ```python assert min_cost(5, [(0, 1, 10), (1, 2, 10), (2, 3, 10), (3, 4, 10)], 0, 4) == 40 assert min_cost(5, [(0, 1, 10), (1, 2, 10), (2, 3, 5), (3, 4, 1)], 0, 4) == 26 assert min_cost(3, [(0, 1, 5), (1, 2, 5)], 2, 0) == -1 # No path from 2 to 0 ``` **Additional context:** Consider using priority queues to optimize the search for the shortest path. Conduct thorough testing with varying sizes and configurations of the road network to ensure correctness and performance.","solution":"import heapq from typing import List, Tuple def min_cost(n: int, roads: List[Tuple[int, int, int]], s: int, d: int) -> int: # Initialize adjacency list adj = [[] for _ in range(n)] for a, b, c in roads: adj[a].append((b, c)) # Priority queue for Dijkstra\'s algorithm (cost, node) pq = [(0, s)] # Costs array initialized to infinity costs = [float(\'inf\')] * n costs[s] = 0 while pq: curr_cost, node = heapq.heappop(pq) if node == d: return curr_cost for neighbor, travel_cost in adj[node]: new_cost = curr_cost + travel_cost if new_cost < costs[neighbor]: costs[neighbor] = new_cost heapq.heappush(pq, (new_cost, neighbor)) return -1 if costs[d] == float(\'inf\') else costs[d]"},{"question":"# Order Calculation Problem You are tasked with implementing functions in Python to calculate order totals for an e-commerce platform. Your platform sells items with bulk discount offers, and you need to compute the order total after applying the discounts, if applicable. Each item has a regular price and may be subject to a bulk discount. A bulk discount applies if the number of items purchased meets or exceeds a certain threshold. Your task is to implement the following two functions: 1. `calculate_order_total(items: List[Tuple[str, float, float, int, int]]) -> float`: This function computes the total cost of an order, applying bulk discounts where applicable. - **Input**: - `items` (List of Tuples): Each tuple contains: - `item_name` (str): The name of the item, - `regular_price` (float): The regular price of a single unit, - `bulk_price` (float): The price per unit if the bulk threshold is met, - `bulk_threshold` (int): The number of units required to get the bulk discount, - `quantity` (int): The number of units ordered. - **Output**: - Returns the total cost of the order (in dollars) as a float. - **Constraint**: - The function should raise a `ValueError` if the quantity ordered is negative, or if any prices or thresholds are negative. 2. `apply_discount(price: float, discount: float, minimum_quantity: int, quantity: int) -> float`: This helper function computes the discounted price for a given quantity of items. - **Input**: - `price` (float): The regular price per unit, - `discount` (float): The price per unit with the discount applied, - `minimum_quantity` (int): The minimum number of units required for the discount, - `quantity` (int): The number of units ordered. - **Output**: - Returns the total cost (in dollars) as a float after applying the discount, if applicable. - **Constraint**: - The function should raise a `ValueError` if any prices or thresholds are negative, or if the quantity ordered is negative. # Example ```python >>> calculate_order_total([ (\\"Widget\\", 10.0, 8.0, 10, 12), (\\"Gadget\\", 25.0, 20.0, 5, 4), (\\"Thing\\", 1.0, 0.95, 100, 150) ]) 171.0 # 96.0 from Widget, 100.0 from Gadget, 142.5 from Thing >>> calculate_order_total([ (\\"ItemA\\", 5.0, 4.5, 10, 9), (\\"ItemB\\", 3.0, 2.75, 10, 10), ]) 22.0 # 45.0 from ItemA, 27.5 from ItemB >>> calculate_order_total([ (\\"Product\\", 15.0, 13.0, -10, 5) ]) Traceback (most recent call last): ... ValueError: Threshold values or prices cannot be negative. >>> apply_discount(10.0, 8.0, 10, 12) 96.0 # Discounted price applied: 12 * 8.0 >>> apply_discount(25.0, 20.0, 5, 4) 100.0 # Regular price applied: 4 * 25.0 >>> apply_discount(1.0, 0.95, 100, 150) 142.5 # Discounted price applied: 150 * 0.95 ``` # Constraints - Ensure your code handles large lists of items efficiently. - Ensure the precision of floating-point calculations. # Performance - Time complexity for the calculate_order_total operation should be (O(n)), where (n) is the number of items. - Space complexity for the calculate_order_total operation should be (O(1)). Good luck, and remember to test edge cases such as zero and negative values!","solution":"from typing import List, Tuple def apply_discount(price: float, discount: float, minimum_quantity: int, quantity: int) -> float: Compute the total cost after applying a bulk discount if the quantity meets the threshold. :param price: Regular price per unit. :param discount: Discounted bulk price per unit. :param minimum_quantity: The minimum quantity required to get the bulk discount. :param quantity: The number of units ordered. :return: The total cost after applying the bulk discount (if applicable). :raises ValueError: If any of the prices, thresholds, or quantities are negative. if price < 0 or discount < 0 or minimum_quantity < 0 or quantity < 0: raise ValueError(\\"Threshold values, prices, or quantities cannot be negative.\\") if quantity >= minimum_quantity: return quantity * discount else: return quantity * price def calculate_order_total(items: List[Tuple[str, float, float, int, int]]) -> float: Compute the total cost of an order, applying bulk discounts where applicable. :param items: List of tuples, each containing item name, regular price, bulk price, bulk threshold, and quantity. :return: The total cost of the order. :raises ValueError: If any of the prices, thresholds, or quantities are negative. total_cost = 0.0 for item in items: _, regular_price, bulk_price, bulk_threshold, quantity = item if regular_price < 0 or bulk_price < 0 or bulk_threshold < 0 or quantity < 0: raise ValueError(\\"Threshold values, prices, or quantities cannot be negative.\\") total_cost += apply_discount(regular_price, bulk_price, bulk_threshold, quantity) return total_cost"},{"question":"# Array Manipulation Question **Scenario**: As a data analyst, you frequently transform and manipulate large datasets. One common operation you perform is applying a series of range increment operations to an array, which helps in simulating cumulative effects across a list of values over time. **Task**: Implement a function `apply_increment_operations` that processes a list of operations on an initially zeroed array. Each operation specifies a range within the array and an increment that should be added to all elements in that range. The function should return the array after all operations have been applied. **Function Signature**: ```python def apply_increment_operations(length: int, operations: List[Tuple[int, int, int]]) -> List[int]: Apply a series of range increment operations to an array of zeros of given length. Parameters: length (int): The length of the zeroed array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented by a tuple (start_idx, end_idx, increment). The range is inclusive of `start_idx` and `end_idx`. Returns: List[int]: The final array after all operations have been applied. Example Usage: >>> apply_increment_operations(5, [(1, 3, 2), (2, 4, 3)]) [0, 2, 5, 5, 3] >>> apply_increment_operations(3, [(0, 2, 1), (1, 1, 5)]) [1, 6, 1] # Your code here ``` **Constraints**: - The `length` is a positive integer no greater than 10^6. - `operations` is a list of tuples, each containing three integers. The first two integers in each tuple are the start and end indices of the range (inclusive), where 0 <= start_idx <= end_idx < length. The third integer is the increment value which is within the range [-1000, 1000]. - The list `operations` can have up to 10^5 elements. - The function should execute within a reasonable time limit and with optimal memory usage. Ensure your implementation handles large inputs efficiently, processes the increments correctly within the given range, and updates the array accordingly.","solution":"from typing import List, Tuple def apply_increment_operations(length: int, operations: List[Tuple[int, int, int]]) -> List[int]: Apply a series of range increment operations to an array of zeros of given length. Parameters: length (int): The length of the zeroed array. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented by a tuple (start_idx, end_idx, increment). The range is inclusive of `start_idx` and `end_idx`. Returns: List[int]: The final array after all operations have been applied. # Initialize the array with zeros array = [0] * length # Apply the operations using a difference array approach for start_idx, end_idx, increment in operations: array[start_idx] += increment if end_idx + 1 < length: array[end_idx + 1] -= increment # Compute the actual values of the array using prefix sum current_value = 0 for i in range(length): current_value += array[i] array[i] = current_value return array"},{"question":"# Data Transformation and Aggregation **Scenario**: You are part of a team developing software to perform financial data analysis. An essential feature of this software is to clean, transform, and aggregate data to derive meaningful insights. Specifically, you need to implement a function that standardizes transaction records by performing certain transformations and aggregations. # Task: Implement a function `transform_aggregate_transactions` to standardize and aggregate multiple transaction records. The function should take a list of transactions, each represented by a dictionary, and return the aggregated total for each item. # Function Signature: ```python def transform_aggregate_transactions(transactions: list) -> dict: ``` # Input: 1. `transactions` (list): A list of dictionaries, where each dictionary represents a transaction with the following structure: - `item` (str): The name of the item bought. - `quantity` (int): The quantity of the item bought. - `price` (float): The price per unit of the item. # Output: - Return a dictionary where the key is the item name and the value is the total amount spent on that item across all transactions. # Constraints: - Ensure the function handles cases where the same item appears in multiple transactions. - The output should be sorted by item name. # Example: ```python transactions = [ {\\"item\\": \\"apple\\", \\"quantity\\": 3, \\"price\\": 0.5}, {\\"item\\": \\"banana\\", \\"quantity\\": 2, \\"price\\": 0.25}, {\\"item\\": \\"apple\\", \\"quantity\\": 1, \\"price\\": 0.5}, {\\"item\\": \\"banana\\", \\"quantity\\": 5, \\"price\\": 0.25}, ] print(transform_aggregate_transactions(transactions)) # Output: {\'apple\': 2.0, \'banana\': 1.75} ``` # Notes: - You should multiply the `quantity` by `price` for each transaction and sum these products for each item. - Ensure the function is efficient and can handle large lists of transactions effectively.","solution":"def transform_aggregate_transactions(transactions: list) -> dict: from collections import defaultdict total_spent = defaultdict(float) for transaction in transactions: item = transaction[\\"item\\"] quantity = transaction[\\"quantity\\"] price = transaction[\\"price\\"] total_spent[item] += quantity * price return dict(sorted(total_spent.items()))"},{"question":"**Question**: You are required to implement the A* (A-star) algorithm to find the shortest path from a given source vertex to a target vertex in a weighted graph. Your implementation should use a heuristic function to estimate the distance to the target. # Input - An integer `V` (1 ≤ `V` ≤ 500) representing the number of vertices. - An integer `E` (0 ≤ `E` ≤ 5000) representing the number of edges. - A list of `E` edges, where each edge is represented by three integers: `src`, `dest`, and `weight`. - An integer `src` representing the source vertex. - An integer `tgt` representing the target vertex. - A list of `V` integers representing the heuristic estimates of distances from each vertex to the target vertex. # Output - A list of integers representing the vertices in the shortest path from the source vertex to the target vertex. - If the target vertex is not reachable from the source vertex, return an empty list. # Function Signature ```python def a_star(graph: list[dict[str, int]], vertex_count: int, edge_count: int, src: int, tgt: int, heuristic: list[int]) -> list[int]: pass ``` # Constraints - All vertices are numbered from 0 to V-1. - Weights are non-negative integers. - The heuristic estimates are non-negative integers. # Example ```python edges = [ {\\"src\\": 0, \\"dst\\": 1, \\"weight\\": 2}, {\\"src\\": 0, \\"dst\\": 2, \\"weight\\": 4}, {\\"src\\": 1, \\"dst\\": 2, \\"weight\\": 1}, {\\"src\\": 1, \\"dst\\": 3, \\"weight\\": 7}, {\\"src\\": 2, \\"dst\\": 3, \\"weight\\": 3} ] vertex_count = 4 edge_count = 5 src = 0 tgt = 3 heuristic = [7, 6, 2, 0] result = a_star(edges, vertex_count, edge_count, src, tgt, heuristic) print(result) # Output: [0, 2, 3] ``` In this example, the function should return the shortest path from the source vertex 0 to the target vertex 3 using the provided heuristic estimates to guide the search. If the target is not reachable, the function should return an empty list.","solution":"import heapq def a_star(graph, vertex_count, edge_count, src, tgt, heuristic): Implements the A* algorithm to find the shortest path from src to tgt. Parameters: graph (list[dict[str, int]]): List of edges where each edge is represented by a dict with keys \'src\', \'dst\', and \'weight\'. vertex_count (int): Number of vertices. edge_count (int): Number of edges. src (int): Source vertex. tgt (int): Target vertex. heuristic (list[int]): List of heuristic estimates of distances to the target vertex. Returns: list[int]: List of vertices in the shortest path from src to tgt. adj_list = {i: [] for i in range(vertex_count)} for edge in graph: adj_list[edge[\'src\']].append((edge[\'dst\'], edge[\'weight\'])) open_set = [] heapq.heappush(open_set, (0 + heuristic[src], 0, src)) came_from = {} g_score = {v: float(\\"inf\\") for v in range(vertex_count)} g_score[src] = 0 while open_set: _, curr_g, current = heapq.heappop(open_set) if current == tgt: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(src) path.reverse() return path for neighbor, weight in adj_list[current]: tentative_g_score = curr_g + weight if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic[neighbor] heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return [] # Example usage: # edges = [ # {\\"src\\": 0, \\"dst\\": 1, \\"weight\\": 2}, # {\\"src\\": 0, \\"dst\\": 2, \\"weight\\": 4}, # {\\"src\\": 1, \\"dst\\": 2, \\"weight\\": 1}, # {\\"src\\": 1, \\"dst\\": 3, \\"weight\\": 7}, # {\\"src\\": 2, \\"dst\\": 3, \\"weight\\": 3} # ] # vertex_count = 4 # edge_count = 5 # src = 0 # tgt = 3 # heuristic = [7, 6, 2, 0] # result = a_star(edges, vertex_count, edge_count, src, tgt, heuristic) # print(result) # Output: [0, 2, 3]"},{"question":"# Problem Statement Write a function that simulates a simple banking system with basic operations: creating an account, depositing money, withdrawing money, transferring money between accounts, and checking the balance. Implement classes to represent an individual account and the bank itself. The system should handle edge cases gracefully. # Task Description 1. **Class 1: `BankAccount`** - Represents an individual bank account. - Has attributes: `account_id` (a unique identifier), `account_holder` (name of the account holder), `balance` (starting at 0). - Methods: - `deposit(amount: int) -> None`: Adds the amount to the balance. - `withdraw(amount: int) -> None`: Subtracts the amount from the balance if enough balance exists, otherwise raises `ValueError`. - `get_balance() -> int`: Returns the current balance. 2. **Class 2: `Bank`** - Represents the bank which manages multiple accounts. - Methods: - `create_account(account_id: str, account_holder: str) -> None`: Creates a new account with the given ID and holder name. If the account ID already exists, raises `ValueError`. - `deposit(account_id: str, amount: int) -> None`: Deposits the amount to the specified account. If the account ID does not exist, raises `ValueError`. - `withdraw(account_id: str, amount: int) -> None`: Withdraws the amount from the specified account if enough balance exists. If the account ID does not exist, raises `ValueError`. - `transfer(from_account_id: str, to_account_id: str, amount: int) -> None`: Transfers the amount from one account to another if both accounts exist and the sender has sufficient balance. Raises `ValueError` appropriately. - `get_balance(account_id: str) -> int`: Returns the balance of the specified account. If the account ID does not exist, raises `ValueError`. # Input - String parameters for account IDs and account holders. - Integer parameters for monetary amounts. # Output - No explicit output. The functions should perform operations or raise exceptions as necessary. # Example ```python # Example usage bank = Bank() bank.create_account(\\"123\\", \\"Alice\\") bank.create_account(\\"456\\", \\"Bob\\") bank.deposit(\\"123\\", 1000) bank.deposit(\\"456\\", 500) bank.withdraw(\\"123\\", 200) assert bank.get_balance(\\"123\\") == 800 bank.transfer(\\"123\\", \\"456\\", 300) assert bank.get_balance(\\"123\\") == 500 assert bank.get_balance(\\"456\\") == 800 try: bank.withdraw(\\"123\\", 600) # Should raise ValueError for insufficient balance. except ValueError: pass try: bank.transfer(\\"123\\", \\"789\\", 100) # Should raise ValueError for non-existent recipient. except ValueError: pass ``` # Constraints - All account IDs are unique. - All account holder names are non-empty strings. - All monetary transactions involve non-negative integers. - The total number of accounts managed by the bank will not exceed 1000. # Exception Handling - Raise `ValueError` for invalid operations such as negative transactions, insufficient balance, and non-existent accounts.","solution":"class BankAccount: def __init__(self, account_id, account_holder): self.account_id = account_id self.account_holder = account_holder self.balance = 0 def deposit(self, amount): if amount < 0: raise ValueError(\\"Deposit amount must be non-negative\\") self.balance += amount def withdraw(self, amount): if amount < 0: raise ValueError(\\"Withdrawal amount must be non-negative\\") if amount > self.balance: raise ValueError(\\"Insufficient balance\\") self.balance -= amount def get_balance(self): return self.balance class Bank: def __init__(self): self.accounts = {} def create_account(self, account_id, account_holder): if account_id in self.accounts: raise ValueError(\\"Account ID already exists\\") self.accounts[account_id] = BankAccount(account_id, account_holder) def deposit(self, account_id, amount): if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist\\") self.accounts[account_id].deposit(amount) def withdraw(self, account_id, amount): if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist\\") self.accounts[account_id].withdraw(amount) def transfer(self, from_account_id, to_account_id, amount): if from_account_id not in self.accounts: raise ValueError(\\"Sender account ID does not exist\\") if to_account_id not in self.accounts: raise ValueError(\\"Recipient account ID does not exist\\") if amount <= 0: raise ValueError(\\"Transfer amount must be positive\\") self.accounts[from_account_id].withdraw(amount) self.accounts[to_account_id].deposit(amount) def get_balance(self, account_id): if account_id not in self.accounts: raise ValueError(\\"Account ID does not exist\\") return self.accounts[account_id].get_balance()"},{"question":"# Problem Statement: Robot Path on a Grid Write a function `can_reach_destination(n: int, commands: str) -> bool` to determine if a robot starting at the top-left corner of an `n x n` grid can reach the bottom-right corner following a specific sequence of commands. The robot can move: * \'U\' (up) * \'D\' (down) * \'L\' (left) * \'R\' (right) The robot starts at position (0, 0) and must avoid moving outside the grid boundaries. The bottom-right corner is at position (n-1, n-1). Function Signature ```python def can_reach_destination(n: int, commands: str) -> bool: ``` Input - `n`: an integer representing the grid dimension size (2 <= n <= 10^4). - `commands`: a string consisting of the commands \'U\', \'D\', \'L\', \'R\'. (1 <= len(commands) <= 10^6). Output - Returns `True` if the robot can reach the bottom-right corner with the given sequence of commands, `False` otherwise. Constraints - You must handle invalid input types by raising a `TypeError`. - You must check if the given sequence of commands is valid (consists solely of [\'U\', \'D\', \'L\', \'R\']). - Moves leading the robot out of the grid are forbidden and should return `False`. Example ```python assert can_reach_destination(3, \\"RRDD\\") == True # Move right twice and down twice assert can_reach_destination(3, \\"RRDDD\\") == False # Exceeds boundaries with an extra down assert can_reach_destination(3, \\"RURDLD\\") == True # Complex path that reaches destination assert can_reach_destination(2, \\"RR\\") == False # Exceeds horizontal boundary assert can_reach_destination(2, \\"DD\\") == False # Exceeds vertical boundary assert can_reach_destination(4, \\"DRDRRRDDLLLU\\") == False # Enters an invalid move leading out of the grid ``` Note - Validate the input type for `n` and `commands`. - Ensure that the robot follows a valid path without crossing boundaries. - Efficiently handle large grids and long command sequences. - Consider edge cases for minimal and maximal inputs for performance optimization.","solution":"def can_reach_destination(n: int, commands: str) -> bool: # Input validation if not isinstance(n, int) or not isinstance(commands, str): raise TypeError(\\"Invalid input types. \'n\' should be an integer and \'commands\' should be a string.\\") # Early exits based on constraints if n < 2 or n > 10**4: raise ValueError(\\"Invalid grid size. \'n\' should be between 2 and 10^4.\\") if len(commands) < 1 or len(commands) > 10**6: raise ValueError(\\"Invalid commands length. It should be between 1 and 10^6.\\") valid_commands = {\'U\', \'D\', \'L\', \'R\'} if not all(c in valid_commands for c in commands): raise ValueError(\\"Invalid commands. Commands should only contain \'U\', \'D\', \'L\', \'R\'.\\") x, y = 0, 0 # Starting position (top-left corner) for command in commands: if command == \'U\': x -= 1 elif command == \'D\': x += 1 elif command == \'L\': y -= 1 elif command == \'R\': y += 1 # Check boundaries if x < 0 or x >= n or y < 0 or y >= n: return False # Check if we reached the bottom-right corner return x == n-1 and y == n-1"},{"question":"You are required to implement a function that processes and analyzes a list of transactions to generate a summary report based on certain criteria. Each transaction includes a transaction ID, amount, type (either \'credit\' or \'debit\'), and a timestamp. # Function Definition Implement the function `transaction_summary(transactions)` that takes a list of transactions, where each transaction is represented as a dictionary with the following structure: - `transaction_id`: A unique identifier for the transaction (string) - `amount`: The amount of the transaction (float or integer, positive) - `type`: The type of transaction (\'credit\' or \'debit\') - `timestamp`: The time when the transaction occurred in format \'YYYY-MM-DD HH:MM:SS\' # Return Format The function should return a dictionary with the following keys and their corresponding values: - `\'total_credits\'`: The sum of all credit transactions. - `\'total_debits\'`: The sum of all debit transactions. - `\'net_balance\'`: The net balance calculated as `total_credits` minus `total_debits`. - `\'num_transactions\'`: The total number of transactions processed. - `\'first_transaction_time\'`: The timestamp of the earliest transaction (in the same format as given). - `\'last_transaction_time\'`: The timestamp of the latest transaction (in the same format as given). # Constraints - The `transactions` list will always contain at least one transaction and at most 10^6 transactions. - Each transaction has a unique ID. - All timestamps are valid and formatted correctly as \'YYYY-MM-DD HH:MM:SS\'. - Transactions may occur at any time, and the order in the list does not necessarily represent the chronological order of the transactions. # Example ```python transactions = [ {\'transaction_id\': \'t1\', \'amount\': 100.0, \'type\': \'credit\', \'timestamp\': \'2023-01-01 10:00:00\'}, {\'transaction_id\': \'t2\', \'amount\': 50.0, \'type\': \'debit\', \'timestamp\': \'2023-01-02 12:00:00\'}, {\'transaction_id\': \'t3\', \'amount\': 70.0, \'type\': \'credit\', \'timestamp\': \'2023-01-01 09:00:00\'} ] result = transaction_summary(transactions) # Expected Output: # { # \'total_credits\': 170.0, # \'total_debits\': 50.0, # \'net_balance\': 120.0, # \'num_transactions\': 3, # \'first_transaction_time\': \'2023-01-01 09:00:00\', # \'last_transaction_time\': \'2023-01-02 12:00:00\' # } ``` # Additional Information - Ensure that the function correctly handles and processes all provided transactions to generate the accurate summary. - Consider utilizing Python\'s built-in modules such as `datetime` for processing timestamps effectively.","solution":"from datetime import datetime def transaction_summary(transactions): Processes a list of transactions and returns a summary report. total_credits = 0.0 total_debits = 0.0 num_transactions = len(transactions) timestamps = [] for transaction in transactions: amount = transaction[\'amount\'] type_ = transaction[\'type\'] timestamp = transaction[\'timestamp\'] timestamps.append(timestamp) if type_ == \'credit\': total_credits += amount elif type_ == \'debit\': total_debits += amount net_balance = total_credits - total_debits first_transaction_time = min(timestamps) last_transaction_time = max(timestamps) return { \'total_credits\': total_credits, \'total_debits\': total_debits, \'net_balance\': net_balance, \'num_transactions\': num_transactions, \'first_transaction_time\': first_transaction_time, \'last_transaction_time\': last_transaction_time }"},{"question":"# Painting Robot Path Calculation A robot is tasked with painting a rectangular grid. The robot starts at the top-left corner (0,0) of the grid and can move right or down to paint the neighboring cell. Once the robot paints the bottom-right cell, it completes its task. # Task 1. Implement the function `robot_paths(m: int, n: int) -> int` that calculates how many unique paths the robot can take to paint the entire grid. - The robot can only move right or down at any point in time. - The grid has dimensions `m` rows by `n` columns. # Function Specifications 1. **Function `robot_paths`**: * Input: * `m`: integer representing the number of rows. * `n`: integer representing the number of columns. * Output: * Returns the total number of unique paths as an integer. # Constraints * 1 <= m, n <= 100 # Example ```python print(robot_paths(2, 2)) # Expected output: 2 print(robot_paths(3, 7)) # Expected output: 28 print(robot_paths(1, 1)) # Expected output: 1 ``` # Explanation 1. For `robot_paths(2, 2)`, the robot can follow two unique paths: - Right, Down - Down, Right 2. For `robot_paths(3, 7)`, the robot can follow 28 unique paths through the 3x7 grid. 3. For `robot_paths(1, 1)`, there\'s only one cell to paint, so there\'s only one unique path. # Hints * This problem can be approached using combinatorial mathematics: the binomial coefficient. * An alternative approach is using dynamic programming to build up the solution incrementally. # Additional Requirements - Ensure your solution is optimized and can handle the upper limits of the constraints. - Test your function thoroughly to ensure correctness. Write clean, efficient code and include comments to explain your approach where necessary.","solution":"def robot_paths(m, n): Calculate the number of unique paths from the top-left to the bottom-right of a m x n grid. The robot can only move right or down. Parameters: m (int): Number of rows n (int): Number of columns Returns: int: Number of unique paths # Create a 2D DP table filled with 0 dp = [[0 for _ in range(n)] for _ in range(m)] # The robot can only move right or down, so the first row and first column have only one path for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 # Fill the DP table using the relationship for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Problem Statement: Unique Character Subsequence Write a function `longest_unique_subsequence(s: str) -> str` that finds the longest subsequence in a given string in which all characters are unique. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Function Signature ```python def longest_unique_subsequence(s: str) -> str: ``` Input - `s`: A string containing only ASCII characters (upper and lower case letters, digits, and punctuation). Output - Returns the longest unique character subsequence found in the input string. Constraints - The length of the string `s` is at most `1000`. - If there are multiple subsequences with the maximum length, return any one of them. - Handle invalid input by raising a `TypeError`. Example ```python assert longest_unique_subsequence(\\"abcabcbb\\") == \\"abc\\" assert longest_unique_subsequence(\\"bbbbb\\") == \\"b\\" assert longest_unique_subsequence(\\"pwwkew\\") == \\"wke\\" or \\"pwe\\" assert longest_unique_subsequence(\\"abcdabc\\") == \\"abcd\\" assert longest_unique_subsequence(\\"\\") == \\"\\" assert longest_unique_subsequence(\\"aaconcise\\") == \\"acbde\\" ``` Note - The implementation should efficiently handle the constraints. - Ensure the solution considers edge cases and raises errors for invalid input types.","solution":"def longest_unique_subsequence(s: str) -> str: if not isinstance(s, str): raise TypeError(\'Input must be a string\') max_len = 0 max_subseq = \\"\\" char_set = set() current_subseq = \\"\\" for c in s: if c not in char_set: char_set.add(c) current_subseq += c else: if len(current_subseq) > max_len: max_len = len(current_subseq) max_subseq = current_subseq char_set = set(c) current_subseq = c if len(current_subseq) > max_len: max_subseq = current_subseq return max_subseq"},{"question":"# Find the Pivot Index A pivot index of a list of numbers is an index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Write a function `find_pivot_index(nums: List[int]) -> int` to find the pivot index. Input Format * A list of integers, `nums`. Output Format * An integer representing the pivot index. Constraints * The length of the list will be at most 10,000. * Each integer in the list will be between -1,000 and 1,000. Example ```python def find_pivot_index(nums: List[int]) -> int: # Your implementation here nums = [1, 7, 3, 6, 5, 6] print(find_pivot_index(nums)) # Should return 3 nums = [1, 2, 3] print(find_pivot_index(nums)) # Should return -1 ```","solution":"from typing import List def find_pivot_index(nums: List[int]) -> int: Finds the pivot index in a list of integers where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. Returns -1 if no such index exists. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): # Right sum can be calculated by total_sum - left_sum - num if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"# Question: Implement an A* Search Algorithm with Custom Heuristic You are assigned to implement the A* Search Algorithm to find the shortest path from a start node to a goal node in a given weighted graph. Additionally, the algorithm should accept a custom heuristic function to potentially improve the efficiency of the search. Your implementation should handle cases where no path exists between the start and goal nodes. Class and Function Signature ```python class Graph: def __init__(self): self.edges = {} def add_edge(self, node1, node2, weight): if node1 not in self.edges: self.edges[node1] = [] if node2 not in self.edges: self.edges[node2] = [] self.edges[node1].append((node2, weight)) self.edges[node2].append((node1, weight)) def a_star_search(graph: Graph, start: str, goal: str, heuristic) -> list: ``` Parameters * **graph**: An instance of the `Graph` class, representing the graph with nodes and weighted edges. * **start**: A string representing the starting node. * **goal**: A string representing the goal node. * **heuristic**: A function that takes two parameters (current node and goal node) and returns a float representing the estimated cost to reach the goal from the current node. Return * A list of nodes representing the shortest path from the start node to the goal node. If no path exists, return an empty list. Example ```python def simple_heuristic(node, goal): return abs(ord(goal) - ord(node)) # Create a graph graph = Graph() graph.add_edge(\'A\', \'B\', 1) graph.add_edge(\'B\', \'C\', 2) graph.add_edge(\'A\', \'D\', 4) graph.add_edge(\'C\', \'D\', 1) graph.add_edge(\'C\', \'E\', 3) graph.add_edge(\'D\', \'E\', 1) # Find the shortest path from \'A\' to \'E\' path = a_star_search(graph, \'A\', \'E\', simple_heuristic) print(\\"The shortest path found is:\\", path) # Expected output: The shortest path found is: [\'A\', \'D\', \'E\'] ``` # Requirements 1. Implement the `a_star_search` function to use the A* search algorithm. 2. Ensure your algorithm works efficiently with the given graph structure and custom heuristic function. 3. Handle cases where no path exists by returning an empty list.","solution":"import heapq class Graph: def __init__(self): self.edges = {} def add_edge(self, node1, node2, weight): if node1 not in self.edges: self.edges[node1] = [] if node2 not in self.edges: self.edges[node2] = [] self.edges[node1].append((node2, weight)) self.edges[node2].append((node1, weight)) def a_star_search(graph: Graph, start: str, goal: str, heuristic) -> list: open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {node: float(\'inf\') for node in graph.edges} g_score[start] = 0 f_score = {node: float(\'inf\') for node in graph.edges} f_score[start] = heuristic(start, goal) while open_set: current = heapq.heappop(open_set)[1] if current == goal: return reconstruct_path(came_from, current) for neighbor, weight in graph.edges.get(current, []): tentative_g_score = g_score[current] + weight if tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = g_score[neighbor] + heuristic(neighbor, goal) if not any(neighbor == item[1] for item in open_set): heapq.heappush(open_set, (f_score[neighbor], neighbor)) return [] def reconstruct_path(came_from, current): total_path = [current] while current in came_from: current = came_from[current] total_path.append(current) return total_path[::-1]"},{"question":"# Problem Description You are given an implementation of a priority queue using a min-heap. A priority queue is a data structure where each element has a priority, and elements are served based on their priority (lower value has higher priority). Your task is to extend this implementation to add additional functionality and improve its usability for typical use cases. Specifically, your tasks are: 1. Implement a method to merge another priority queue into the current priority queue. 2. Implement a method to find the `k`-th smallest element without altering the heap. 3. Add a method to dynamically change the priority of a given element. # Function Specifications 1. **merge(other: PriorityQueue)**: Merge another priority queue into the current one. - **Input**: An instance `other` of `PriorityQueue`. - **Output**: None - **Behavior**: Merge all elements from the `other` priority queue into the current priority queue, maintaining the heap property. The `other` queue should be empty after merging. 2. **kth_smallest(k: int) -> int**: Find the `k`-th smallest element in the priority queue. - **Input**: An integer `k` representing the position of the smallest element to find. - **Output**: An integer representing the `k`-th smallest element. - **Behavior**: Return the `k`-th smallest element without altering the heap structure. If `k` is out of the bounds of the heap size, return `None`. 3. **change_priority(element: int, new_priority: int)**: Change the priority of a given element. - **Input**: An integer `element` representing the element whose priority needs to be changed and an integer `new_priority` representing the new priority value. - **Output**: None - **Behavior**: Adjust the priority of the specified element to the new priority, maintaining the heap property. If the element is not present in the heap, do nothing. # Constraints - The priority queue can contain duplicate elements. - The elements are always integers. - The given `k` for the `kth_smallest` method will always be a positive integer. - The provided priority values will always be valid integers. # Example ```python queue = PriorityQueue() queue.enqueue(5) queue.enqueue(9) queue.enqueue(3) queue.enqueue(7) print(queue.heap) # [3, 7, 5, 9] # Merge another queue new_queue = PriorityQueue() new_queue.enqueue(6) new_queue.enqueue(2) queue.merge(new_queue) print(queue.heap) # [2, 3, 5, 7, 9, 6] # Find the 4th smallest element fourth_smallest = queue.kth_smallest(4) print(fourth_smallest) # 6 # Change priority queue.change_priority(6, 1) print(queue.heap) # [1, 3, 2, 7, 9, 5] ``` # Requirements - Ensure your implementation is efficient and can handle a reasonable number of elements. - Carefully consider edge cases throughout implementation.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} # map element to their priority def enqueue(self, priority): entry = [priority, priority] self.entry_finder[priority] = entry heapq.heappush(self.heap, entry) def dequeue(self): while self.heap: priority, element = heapq.heappop(self.heap) if element is not None: del self.entry_finder[element] return element raise KeyError(\'pop from an empty priority queue\') def merge(self, other): while other.heap: priority, element = heapq.heappop(other.heap) if element is not None: self.enqueue(priority) other.entry_finder.clear() def kth_smallest(self, k): if k > len(self.heap): return None copy = self.heap[:] heapq.heapify(copy) result = None for _ in range(k): result = heapq.heappop(copy)[1] return result def change_priority(self, element, new_priority): if element in self.entry_finder: entry = self.entry_finder.pop(element) entry[-1] = None # Mark the old entry as removed self.enqueue(new_priority)"},{"question":"# Dynamic Programming for Subset Sum Problem You are tasked to extend a given Python function to solve the subset sum problem using dynamic programming. The function should determine if there exists a subset of the given set such that the sum of its elements is equal to a specified target sum. Requirements: 1. Implement the function `subset_sum` which checks if a subset with the target sum exists. 2. You must use a 2D dynamic programming table to achieve this. 3. Optimize the space complexity if possible, but ensure the solution is based on dynamic programming approach. # Function Signature: ```python def subset_sum(arr: List[int], target: int) -> bool: pass ``` # Input and Output Formats: 1. **Input**: - `arr` (List[int]): A list of non-negative integers representing the set. - `target` (int): The target sum we want to achieve using the subset of `arr`. 2. **Output**: - (bool): Returns `True` if a subset with the target sum exists, otherwise `False`. # Constraints: - ( 1 leq text{len}(arr) leq 500 ) - ( 0 leq text{arr[i]} leq 1000 ) - ( 0 leq text{target} leq 10^5 ) # Testing and Performance: - Implement test cases with various sizes and values of `arr` and `target`. - The function should handle the upper limits of constraints efficiently. # Example: ```python # Example 1 arr = [3, 34, 4, 12, 5, 2] target = 9 assert subset_sum(arr, target) == True # Example 2 arr = [1, 2, 3, 7] target = 6 assert subset_sum(arr, target) == True # Example 3 arr = [9, 2, 6, 8] target = 5 assert subset_sum(arr, target) == False ``` ```python from typing import List def subset_sum(arr: List[int], target: int) -> bool: Determine if a subset with the target sum exists. Parameters: - arr (List[int]): A list of non-negative integers representing the set. - target (int): The target sum we want to achieve using the subset of arr. Returns: - bool: True if a subset with the target sum exists, otherwise False. n = len(arr) # Initialize a DP table with False values dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: A sum of 0 can always be made with an empty subset for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target] # Example usage and test cases if __name__ == \\"__main__\\": assert subset_sum([3, 34, 4, 12, 5, 2], 9) == True assert subset_sum([1, 2, 3, 7], 6) == True assert subset_sum([9, 2, 6, 8], 5) == False print(\\"All example cases passed.\\") ```","solution":"from typing import List def subset_sum(arr: List[int], target: int) -> bool: Determine if a subset with the target sum exists. Parameters: - arr (List[int]): A list of non-negative integers representing the set. - target (int): The target sum we want to achieve using the subset of arr. Returns: - bool: True if a subset with the target sum exists, otherwise False. n = len(arr) # Initialize a DP table with False values dp = [[False] * (target + 1) for _ in range(n + 1)] # Base case: A sum of 0 can always be made with an empty subset for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] <= j: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] else: dp[i][j] = dp[i-1][j] return dp[n][target]"},{"question":"# Prompt: You are required to extend the functionality of a simple text editor application by implementing a version control system that supports the following features: 1. **Saving Versions**: Keep track of different versions of the document. 2. **Reverting to Previous Versions**: Allow the user to revert to previously saved versions. 3. **Viewing History**: Provide a list of all saved versions along with their timestamps. Implement the following classes and methods: - `class TextEditor`: * `__init__(self)`: * Initializes an empty document and sets up the version control system. * `write(self, text: str) -> None`: * Appends the given `text` to the document. * `save_version(self) -> None`: * Saves the current state of the document along with a timestamp. * `revert_to_version(self, version_index: int) -> None`: * Reverts the document to the state of the specified version by `version_index`. * `view_history(self) -> list[tuple[str, str]]`: * Returns a list of tuples containing the saved versions and their timestamps. * `get_content(self) -> str`: * Returns the current content of the document. # Example: ```python from datetime import datetime # Create a new text editor editor = TextEditor() # Write some text and save versions editor.write(\\"Hello, World!\\") editor.save_version() # e.g., saves \\"Hello, World!\\" at timestamp \\"2023-01-01 00:00:00\\" editor.write(\\" This is a version control system.\\") editor.save_version() # e.g., saves \\"Hello, World! This is a version control system.\\" at timestamp \\"2023-01-01 01:00:00\\" # Modify the document again editor.write(\\" Let\'s test reverting.\\") editor.save_version() # e.g., saves \\"Hello, World! This is a version control system. Let\'s test reverting.\\" at timestamp \\"2023-01-01 02:00:00\\" # View history history = editor.view_history() print(history) # [(\'2023-01-01 00:00:00\', \'Hello, World!\'), (\'2023-01-01 01:00:00\', \'Hello, World! This is a version control system.\'), (\'2023-01-01 02:00:00\', \'Hello, World! This is a version control system. Let\'s test reverting.\')] # Revert to a previous version editor.revert_to_version(1) print(editor.get_content()) # \\"Hello, World! This is a version control system.\\" ``` # Constraints: * The `text` input for `write` will be a non-empty string of printable ASCII characters. * `version_index` for `revert_to_version` will always be valid based on the current history. * The `view_history` method should return the versions in the order they were saved.","solution":"from datetime import datetime class TextEditor: def __init__(self): self.document = \\"\\" self.versions = [] def write(self, text: str) -> None: self.document += text def save_version(self) -> None: timestamp = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.versions.append((timestamp, self.document)) def revert_to_version(self, version_index: int) -> None: _, self.document = self.versions[version_index] def view_history(self) -> list: return self.versions def get_content(self) -> str: return self.document"},{"question":"# Fibonacci Palindrome Checker Students are required to write a function that checks if a number is both a Fibonacci number and a palindrome. # Task: Write a function `fibonacci_palindrome(number)` that checks if the given `number` is both a Fibonacci number and a palindrome. If it is, return `\'Yes\'`, otherwise return `\'No\'`. # Guidelines: 1. **Determine Fibonacci numbers**: Implement a logic to check if a number is part of the Fibonacci sequence. 2. **Palindrome Check**: Implement a logic to check if a number reads the same forwards and backwards. 3. **Input**: A single integer `number` (0 <= number <= 10^6). 4. **Output**: Return the string `\'Yes\'` if the number is both a Fibonacci number and a palindrome, otherwise return `\'No\'`. # Input/Output Specifications: 1. **Input**: A single integer `number` where 0 <= number <= 10^6. 2. **Output**: A string `\'Yes\'` or `\'No\'`. # Examples: ```python >>> fibonacci_palindrome(121) \'No\' >>> fibonacci_palindrome(1) \'Yes\' >>> fibonacci_palindrome(1441) \'No\' ``` # Constraints: * You must implement efficient algorithms to check both Fibonacci sequence membership and palindrome property. * The function should be optimized to handle the upper limit constraints within reasonable time limits. # Edge Cases: * For `number=0`, the function should return `\'Yes\'` since 0 is a Fibonacci number and also a palindrome. # Notes: - This exercise assesses the student\'s ability to implement mathematical checks, conditional logic, and efficient algorithm design.","solution":"def is_fibonacci(number): Helper function to check if a number is a Fibonacci number. if number == 0 or number == 1: return True a, b = 0, 1 while b < number: a, b = b, a + b return b == number def is_palindrome(number): Helper function to check if a number is a palindrome. return str(number) == str(number)[::-1] def fibonacci_palindrome(number): Function to check if a number is both a Fibonacci number and a palindrome. if is_fibonacci(number) and is_palindrome(number): return \'Yes\' return \'No\'"},{"question":"# Problem Statement In data analysis, it’s often useful to identify significant changes or trends in a sequence of numbers. In this problem, you are required to identify the longest contiguous subarray with a specified sum within a given list of integers. You need to complete the implementation to find the length of the longest contiguous subarray that sums up to a given target sum. # Requirements 1. **Function Signature**: ```python def longest_subarray_with_sum(arr: list[int], target_sum: int) -> int: ``` - **Input**: * `arr`: A list of integers representing the array. * `target_sum`: An integer representing the target sum for the subarray. - **Output**: * Return an integer representing the length of the longest contiguous subarray whose elements sum up to `target_sum`. If no such subarray exists, return `0`. # Example ```python def test_longest_subarray_with_sum(): assert longest_subarray_with_sum([1, -1, 5, -2, 3], 3) == 4 assert longest_subarray_with_sum([-2, -1, 2, 1], 1) == 2 assert longest_subarray_with_sum([1, 2, 3, 4, 5], 15) == 5 assert longest_subarray_with_sum([1, 2, 3, 4, 5], 20) == 0 if __name__ == \\"__main__\\": test_longest_subarray_with_sum() ``` # Constraints and Performance Requirements 1. Assume 1 <= len(arr) <= 1000. 2. Each element of the array will be a valid integer in the range -1000 to 1000. 3. The solution should handle arrays efficiently, avoiding unnecessary computations to ensure optimal performance. Ensure your implementation correctly handles edge cases, such as arrays with negative numbers or the target sum being zero.","solution":"def longest_subarray_with_sum(arr: list[int], target_sum: int) -> int: Finds the length of the longest contiguous subarray with the sum equal to target_sum. Args: arr: List of integers representing the array. target_sum: Integer representing the target sum for the subarray. Returns: An integer representing the length of the longest contiguous subarray that sums up to target_sum. If no such subarray exists, returns 0. sum_indices = {0: -1} # Dictionary to store the first occurrence of a cumulative sum current_sum = 0 max_len = 0 for i, num in enumerate(arr): current_sum += num if current_sum not in sum_indices: sum_indices[current_sum] = i if current_sum - target_sum in sum_indices: max_len = max(max_len, i - sum_indices[current_sum - target_sum]) return max_len"},{"question":"# Question: Rotate an Array You are required to write a function `rotate_array` that rotates an array of integers to the right by a specified number of positions. The rotation should be efficient, with a focus on minimizing the number of operations and the use of extra space. Function Signature ```python def rotate_array(nums: List[int], k: int) -> List[int]: pass ``` # Input * `nums` (List[int]): A list of integers. * `k` (int): A non-negative integer representing the number of positions to rotate the list. # Output * `List[int]`: A new list representing the rotated array. # Constraints * 1 <= len(nums) <= 10^5 * 0 <= k <= 10^5 * The integers in the list can be negative, positive, or zero. # Examples ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([-1, -100, 3, 99], 2) == [3, 99, -1, -100] assert rotate_array([1], 0) == [1] assert rotate_array([1, 2], 3) == [2, 1] ``` # Notes * If `k` is greater than the length of `nums`, it should rotate `k % len(nums)` times. * You must implement the function with a time complexity of O(n) and space complexity of O(1), where n is the number of elements in `nums`. * Be mindful of edge cases like `k = 0`, `nums` being an empty list, or `k` being larger than the array length. # Implementation Hint * Reversing parts of the array can be a useful technique to achieve the rotation with minimal extra space. * Consider segmenting the array into parts that can be reversed individually and then combined correctly to produce the rotated array.","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(nums) if n == 0: return nums # Edge case for empty list k = k % n # To handle cases where k >= len(nums) if k == 0: return nums # No rotation needed # Reverse the entire array nums.reverse() # Reverse the first k elements nums[:k] = reversed(nums[:k]) # Reverse the rest of the array nums[k:] = reversed(nums[k:]) return nums"},{"question":"# Coding Assessment Question: Rotate a List by K Positions You have been provided with a list of integers `nums` and an integer `k`. Write a function `rotate_list(nums: list[int], k: int) -> list[int]` that rotates the list to the right by `k` positions. Rotation means that the elements from the end of the list will be moved to the beginning of the list, and all other elements will be shifted to the right. Input: * A list of integers `nums` where the length of the list `n` is greater than or equal to 0. * An integer `k` that specifies the number of positions to rotate the list. `k` can be positive, negative, or zero. Negative `k` would imply a left rotation. Output: * Return the list after rotating it to the right by `k` positions for positive `k` and to the left for negative `k`. Example: ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_list([0, 1, 2], 4) [2, 0, 1] >>> rotate_list([], 3) [] >>> rotate_list([1, 2, 3], 0) [1, 2, 3] ``` Constraints: * The input list `nums` can be empty or contain one or more elements. * The integer `k` can be any valid integer within a reasonable range. * Edge cases should be considered, such as empty lists or `k` being multiple times the length of the list. Performance Requirements: * Your solution should run in O(n) time complexity. * Your solution should use O(1) extra space. Notes: * Make sure to validate the input for satisfying the given constraints. * Consider scenarios where `k` is larger than the length of the list. Implement the `rotate_list` function based on the guidelines provided above: ```python def rotate_list(nums: list[int], k: int) -> list[int]: if not nums: return [] k %= len(nums) return nums[-k:] + nums[:-k] ```","solution":"def rotate_list(nums: list[int], k: int) -> list[int]: Rotates the list to the right by k positions. For negative k, rotate to the left by |k| positions. if not nums: return [] n = len(nums) k %= n # normalize k to be within the bounds of the list length return nums[-k:] + nums[:-k]"},{"question":"# Circular Buffer Implement a circular buffer class `CircularBuffer` that supports common buffer operations efficiently. A circular buffer, also known as a ring buffer, is a fixed-size data structure that treats the buffer as a continuous loop. When writing data to a full buffer, subsequent writes wrap around to the beginning and overwrite the old data in a circular fashion. Class Definition Your task is to implement the `CircularBuffer` class with the following methods: - `__init__(self, size: int)`: Initializes a circular buffer of the specified size. - `write(data: int)`: Writes an integer to the buffer. If the buffer is full, overwrite the oldest data. - `read() -> int`: Reads and returns the oldest integer from the buffer. Raise an `EmptyBufferError` if the buffer is empty. - `is_full() -> bool`: Returns `True` if the buffer is full, otherwise `False`. - `is_empty() -> bool`: Returns `True` if the buffer is empty, otherwise `False`. - `__str__() -> str`: Returns a string representation of the current buffer contents. Requirements: 1. The buffer should handle wrap-around logic to manage data efficiently. 2. Overwriting should only occur when the buffer is full. 3. Reading from an empty buffer should raise an `EmptyBufferError`. 4. Buffer operations should be efficient with constant time complexity where possible. Constraints: - The buffer size is a positive integer. - Data to be written to the buffer is an integer. - Reading an empty buffer should correctly raise an error. ```python class EmptyBufferError(Exception): pass class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def write(self, data: int) -> None: if self.is_full(): self.tail = (self.tail + 1) % self.size # Overwrite the oldest data else: self.count += 1 self.buffer[self.head] = data self.head = (self.head + 1) % self.size def read(self) -> int: if self.is_empty(): raise EmptyBufferError(\\"Buffer is empty.\\") data = self.buffer[self.tail] self.buffer[self.tail] = None self.tail = (self.tail + 1) % self.size self.count -= 1 return data def is_full(self) -> bool: return self.count == self.size def is_empty(self) -> bool: return self.count == 0 def __str__(self) -> str: if self.is_empty(): return \\"CircularBuffer([])\\" start = self.tail elements = [] for _ in range(self.count): elements.append(self.buffer[start]) start = (start + 1) % self.size return f\\"CircularBuffer({elements})\\" # Example usage: # cb = CircularBuffer(3) # cb.write(1) # cb.write(2) # cb.write(3) # print(cb) # assert cb.read() == 1 # cb.write(4) # print(cb) # assert cb.read() == 2 # assert cb.read() == 3 # cb.write(5) # cb.write(6) # print(cb) # try: # print(cb.read()) # print(cb.read()) # except EmptyBufferError: # print(\\"Buffer is empty\\") ```","solution":"class EmptyBufferError(Exception): pass class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 def write(self, data: int) -> None: if self.is_full(): self.tail = (self.tail + 1) % self.size # Overwrite the oldest data else: self.count += 1 self.buffer[self.head] = data self.head = (self.head + 1) % self.size def read(self) -> int: if self.is_empty(): raise EmptyBufferError(\\"Buffer is empty.\\") data = self.buffer[self.tail] self.buffer[self.tail] = None self.tail = (self.tail + 1) % self.size self.count -= 1 return data def is_full(self) -> bool: return self.count == self.size def is_empty(self) -> bool: return self.count == 0 def __str__(self) -> str: if self.is_empty(): return \\"CircularBuffer([])\\" start = self.tail elements = [] for _ in range(self.count): elements.append(self.buffer[start]) start = (start + 1) % self.size return f\\"CircularBuffer({elements})\\""},{"question":"# Coding Assessment Question **Scenario**: You have been tasked with designing an efficient and scalable data structure that supports interval scheduling while minimizing overlapping intervals. A self-adjusting binary search tree like a Splay Tree is a fantastic choice for this requirement due to its ability to provide amortized time complexity for various operations. **Task**: Implement the `SplayTree` class by completing the following methods: 1. **insert**: ```python def insert(self, interval: tuple[int, int]) -> None: ``` - **Input**: - `interval` (tuple[int, int]): A tuple representing the start and end of the interval to be added. - **Output**: None 2. **delete**: ```python def delete(self, interval: tuple[int, int]) -> bool: ``` - **Input**: - `interval` (tuple[int, int]): A tuple representing the start and end of the interval to be deleted. - **Output**: Boolean indicating the success of the deletion. 3. **find_max_non_overlapping_intervals**: ```python def find_max_non_overlapping_intervals(self) -> list[tuple[int, int]]: ``` - **Input**: None - **Output**: A list of tuples, each representing a non-overlapping interval scheduled to maximize the number of intervals. **Constraints**: - Intervals will be provided as tuples of two integers where the first integer is less than or equal to the second integer. - There will be at most `10^4` intervals to be handled by the tree. **Example**: ```python splay_tree = SplayTree() splay_tree.insert((1, 3)) splay_tree.insert((2, 4)) splay_tree.insert((3, 5)) print(splay_tree.find_max_non_overlapping_intervals()) # Output: [(1, 3), (3, 5)] splay_tree.delete((1, 3)) print(splay_tree.find_max_non_overlapping_intervals()) # Output: [(3, 5)] splay_tree.insert((0, 6)) print(splay_tree) # Output: [(0, 6), (2, 4), (3, 5)] ```","solution":"class Node: def __init__(self, interval): self.interval = interval self.max = interval[1] self.left = None self.right = None class SplayTree: def __init__(self): self.root = None def _zig(self, x): p = x.left x.left = p.right p.right = x self._update_max(x) self._update_max(p) return p def _zag(self, x): p = x.right x.right = p.left p.left = x self._update_max(x) self._update_max(p) return p def _update_max(self, node): if not node: return node.max = max(node.interval[1], node.left.max if node.left else float(\'-inf\'), node.right.max if node.right else float(\'-inf\')) def _splay(self, root, interval): if not root or root.interval == interval: return root if interval[0] < root.interval[0]: if not root.left: return root if interval[0] < root.left.interval[0]: root.left.left = self._splay(root.left.left, interval) root = self._zig(root) elif interval[0] > root.left.interval[0]: root.left.right = self._splay(root.left.right, interval) if root.left.right: root.left = self._zag(root.left) return root.left if not root.left else self._zig(root) else: if not root.right: return root if interval[0] > root.right.interval[0]: root.right.right = self._splay(root.right.right, interval) root = self._zag(root) elif interval[0] < root.right.interval[0]: root.right.left = self._splay(root.right.left, interval) if root.right.left: root.right = self._zig(root.right) return root.right if not root.right else self._zag(root) def insert(self, interval): node = Node(interval) if not self.root: self.root = node return self.root = self._splay(self.root, interval) if self.root.interval == interval: return if interval[0] < self.root.interval[0]: node.left = self.root.left node.right = self.root self.root.left = None else: node.right = self.root.right node.left = self.root self.root.right = None self._update_max(self.root) self.root = node self._update_max(self.root) def delete(self, interval): if not self.root: return False self.root = self._splay(self.root, interval) if self.root.interval != interval: return False if not self.root.left: self.root = self.root.right else: x = self._splay(self.root.left, interval) x.right = self.root.right self.root = x if self.root: self._update_max(self.root) return True def _inorder(self, node): if not node: return [] return self._inorder(node.left) + [node.interval] + self._inorder(node.right) def find_max_non_overlapping_intervals(self): intervals = self._inorder(self.root) intervals.sort(key=lambda x: x[1]) res, prev_end = [], float(\'-inf\') for interval in intervals: if interval[0] >= prev_end: res.append(interval) prev_end = interval[1] return res"},{"question":"# Problem Statement: # Context: Fractional sums are common in many scientific and financial applications, where precision in calculations is crucial. In this task, you need to compute the sum of the harmonic series up to a specified term. **Purpose**: Implement a function that accurately calculates the sum of the harmonic series up to the Nth term. # Task: Write a function `harmonic_sum(n: int) -> float` that takes in one argument: 1. An integer `n` which signifies the number of terms to include in the harmonic series sum. The function should return a float representing the sum of the first `n` terms of the harmonic series. # Input: - An integer `n` (1 <= n <= 10^6). # Output: - A float representing the sum of the first `n` terms of the harmonic series. # Constraints: - Ensure the function handles the precision of floating-point arithmetic accurately. - The function should efficiently compute the sum even for large `n`. # Performance Requirement: - Aim for a solution with a linear time complexity. # Example: ```python >>> harmonic_sum(5) 2.283333333333333 >>> harmonic_sum(10) 2.928968253968254 ``` **Note**: The harmonic series is defined as H(n) = 1 + 1/2 + 1/3 + ... + 1/n. Ensure your function maintains numerical accuracy, especially for large values of `n`.","solution":"def harmonic_sum(n: int) -> float: Returns the sum of the first n terms of the harmonic series. if n <= 0: raise ValueError(\'n must be a positive integer\') total = 0.0 for i in range(1, n + 1): total += 1 / i return total"},{"question":"# Question: Implement and Compare Sorting Algorithms You are provided with two well-known sorting algorithms: Merge Sort and Quick Sort. Your task is to implement an additional sorting algorithm (like Heap Sort) and benchmark its performance against the two provided algorithms on the same list of integers. **Function Signature**: ```python def heap_sort(arr: List[int]) -> List[int]: pass ``` # Objectives: 1. Implement the `heap_sort` function to sort a list of integers using the Heap Sort algorithm. 2. Benchmark the performance of your Heap Sort implementation against the provided Merge Sort and Quick Sort algorithms using the `benchmark_sorting_algorithms` function. # Constraints: * The input list `arr` will have at most 1000 integers. * The integers in the list will be between -10^6 and 10^6. * Your implementation should efficiently handle typical large lists within the constraint. # Example: ```python >>> heap_sort([37, 25, 21, 58, 0, -5]) [-5, 0, 21, 25, 37, 58] >>> heap_sort([10, 5, 2, 3]) [2, 3, 5, 10] >>> heap_sort([4, 1, 3, -2, 0]) [-2, 0, 1, 3, 4] >>> heap_sort([5, 1, 6, 2, 3, 4]) [1, 2, 3, 4, 5, 6] >>> heap_sort([10]) [10] >>> heap_sort([]) [] ``` # Guidelines: 1. Your `heap_sort` function should only use the Heap Sort algorithm and should not replicate the logic of Merge Sort or Quick Sort. 2. Ensure your implementation handles errors appropriately and efficiently. 3. Use the following `benchmark_sorting_algorithms` function to compare the performance of your implementation against the provided ones: ```python def benchmark_sorting_algorithms() -> None: Benchmark code for comparing 3 sorting functions, including a custom implementation. def do_benchmark(arr: List[int]) -> None: setup = \\"import __main__ as z\\" print(f\\"Benchmark for array = {arr}:\\") timing = timeit(lambda: z.merge_sort(arr.copy()), number=1000) print(f\\"{z.merge_sort(arr.copy()) = }, timeit() runs in {timing} seconds\\") timing = timeit(lambda: z.quick_sort(arr.copy()), number=1000) print(f\\"{z.quick_sort(arr.copy()) = }, timeit() runs in {timing} seconds\\") timing = timeit(lambda: z.heap_sort(arr.copy()), number=1000) print(f\\"{z.heap_sort(arr.copy()) = }, timeit() runs in {timing} seconds\\") for arr in ([37, 25, 21, 58, 0], [5, 3, 8, 6, 2, 7, 4, 1], [15, 20, 10, 5]): do_benchmark(arr) print() ``` # Existing Sorting Algorithms: ```python def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) ``` Implement your `heap_sort` function and use the benchmarking function to compare its performance against Merge Sort and Quick Sort.","solution":"from typing import List def heap_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Heap Sort algorithm. n = len(arr) # Build a maxheap for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr def heapify(arr, n, i): To heapify a subtree rooted with node i which is an index in arr[]. n is size of heap largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than the largest so far if right < n and arr[largest] < arr[right]: largest = right # Change root if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right) def merge(left: List[int], right: List[int]) -> List[int]: result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Scenario You are tasked with developing an algorithm for an e-commerce company to manage their discount system. The system should be capable of calculating the final price of items after applying possible discounts, which can be in the form of a percentage off or a fixed amount off. The discount can only be applied if the item price exceeds a certain threshold value. # Task Implement the function `calculate_discounted_price`, which computes the final price of an item after applying the applicable discounts based on the given rules. # Requirements 1. **Function Signature**: ```python def calculate_discounted_price(price: float, discount: Union[float, int], threshold: float, is_percentage: bool) -> float: pass ``` 2. **Parameters**: - `price` (float): The original price of the item. - `discount` (Union[float, int]): The discount value (either a fixed amount or a percentage). - `threshold` (float): The minimum item price required to apply the discount. - `is_percentage` (bool): True if the discount is a percentage, False if it is a fixed amount. 3. **Returns**: - (float): The final price of the item after applying the discount, rounded to two decimal places. 4. **Constraints**: - Ensure the final price is not negative. If the discount results in a negative price, return 0.00. - Raise a `ValueError` if the discount is negative, the price is negative, or the threshold is negative. # Examples ```python >>> calculate_discounted_price(200, 20, 100, True) 160.00 >>> calculate_discounted_price(80, 30, 50, False) 50.00 >>> calculate_discounted_price(100, 25, 150, True) 100.00 >>> calculate_discounted_price(100, 120, 50, False) 0.00 >>> calculate_discounted_price(75, 10, 80, True) 75.00 >>> calculate_discounted_price(500, 50, 200, False) 450.00 ``` # Additional Notes Consider edge cases such as: - Applying a discount that results in a negative final price. - Discounts with zero values or thresholds with zero values. - Large numbers for prices or discounts.","solution":"def calculate_discounted_price(price: float, discount: float, threshold: float, is_percentage: bool) -> float: Calculates the final price of an item after applying a discount if the price exceeds a threshold. Parameters: price (float): The original price of the item. discount (float): The discount value. threshold (float): The minimum price required to apply the discount. is_percentage (bool): True if the discount is a percentage, False if it is a fixed amount. Returns: float: The final price of the item after applying the discount, rounded to two decimal places. # Validating the parameters: if price < 0 or discount < 0 or threshold < 0: raise ValueError(\\"Price, discount, and threshold must all be non-negative.\\") # If the price does not meet the threshold, no discount is applied: if price < threshold: return round(price, 2) # Calculate the discounted price: if is_percentage: discounted_price = price * (1 - discount / 100) else: discounted_price = price - discount # Ensure the final price is not negative: final_price = max(discounted_price, 0) return round(final_price, 2)"},{"question":"# Coding Question **Objective**: Write a function to interpret and evaluate multiple boolean expressions involving AND, OR, and NOT operators. # Problem Statement You are given a list of boolean expressions represented as strings. You need to write a function `evaluate_boolean_expressions(expressions: List[str]) -> List[bool]` that takes this list as input and returns a list of evaluated results of the boolean expressions. # Input Format - A list of strings, each containing a boolean expression involving the operators AND (`&`), OR (`|`), and NOT (`!`). - Example: `[\\"1 & 0\\", \\"1 | 0\\", \\"!0\\", \\"1 & !0\\"]` # Output Format - A list of booleans corresponding to the evaluation of each boolean expression. - Example: `[False, True, True, True]` # Constraints - Each expression will be a valid boolean expression. - Operators will always be surrounded by spaces for clarity. - The list can be empty, in which case the output should also be an empty list. # Example ```python assert evaluate_boolean_expressions([\\"1 & 0\\", \\"1 | 0\\", \\"!0\\", \\"1 & !0\\"]) == [False, True, True, True] assert evaluate_boolean_expressions([]) == [] assert evaluate_boolean_expressions([\\"!1 & 0\\"]) == [False] ``` # Requirements - You must write the core logic to correctly parse and evaluate the boolean expressions. - Ensure that your implementation is efficient and handles all edge cases. ```python def evaluate_boolean_expressions(expressions): def eval_expr(expr): expr = expr.replace(\\"!\\", \\" not \\").replace(\\"&\\", \\" and \\").replace(\\"|\\", \\" or \\") return eval(expr) return [eval_expr(expr) for expr in expressions] ```","solution":"from typing import List def evaluate_boolean_expressions(expressions: List[str]) -> List[bool]: Evaluates a list of boolean expressions given as strings. Args: expressions (List[str]): List of boolean expressions. Returns: List[bool]: List of evaluated boolean results. def eval_expr(expr): # Replace the custom operators with Python\'s equivalent boolean operators expr = expr.replace(\\"!\\", \\" not \\").replace(\\"&\\", \\" and \\").replace(\\"|\\", \\" or \\") return eval(expr) # Evaluate each expression and collect the results return [eval_expr(expr) for expr in expressions]"},{"question":"# Question: Merge Sorted Linked Lists You are given two singly linked lists, each of which is sorted in ascending order. Your task is to merge these two linked lists into one sorted linked list and return the head of the merged list. Implement a function `merge_sorted_lists(list1: \'ListNode\', list2: \'ListNode\') -> \'ListNode\'`, where `ListNode` is a structure representing a node in a singly linked list. # Input: * `list1` and `list2`: the heads of two singly linked lists, where (0 leq text{len(list1)} + text{len(list2)} leq 10^5) and (-10^9 leq text{ListNode.val} leq 10^9). # Output: * The head of the merged singly linked list containing all elements from `list1` and `list2` sorted in ascending order. # Constraints: * Optimize for linear time complexity. # Performance Requirements: * Aim for a time complexity of (O(n + m)), where (n) and (m) are the lengths of `list1` and `list2`, respectively. # Examples: Example 1: ```python list1 = ListNode(1, ListNode(3, ListNode(5))) list2 = ListNode(2, ListNode(4, ListNode(6))) merged_list = merge_sorted_lists(list1, list2) # Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` Example 2: ```python list1 = ListNode(1, ListNode(3, ListNode(5))) list2 = ListNode(2) merged_list = merge_sorted_lists(list1, list2) # Output: 1 -> 2 -> 3 -> 5 ``` Example 3: ```python list1 = None list2 = ListNode(2, ListNode(4, ListNode(6))) merged_list = merge_sorted_lists(list1, list2) # Output: 2 -> 4 -> 6 ``` # Hints: * Utilize a dummy node to simplify list merging. * Traverse both lists simultaneously, adding the smaller node to the merged list each time until you reach the end of one of the lists. Then, attach the remaining nodes from the other list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_lists(list1: ListNode, list2: ListNode) -> ListNode: dummy = ListNode() tail = dummy while list1 and list2: if list1.val < list2.val: tail.next = list1 list1 = list1.next else: tail.next = list2 list2 = list2.next tail = tail.next tail.next = list1 if list1 else list2 return dummy.next"},{"question":"# Question: Efficient Matrix Diagonal Sum You are required to implement a function to compute the sum of the elements on the diagonals of a given square matrix. For a matrix, the primary diagonal consists of elements from the top-left to the bottom-right, while the secondary diagonal is from the top-right to the bottom-left. If the matrix is of odd dimensions, do not double-count the center element. __Requirements:__ * Your function should handle valid square matrices only. * Ensure the function computes results efficiently for matrices up to dimensions 1000x1000. __Function Signature:__ ```python def diagonal_sum(matrix: List[List[int]]) -> int: pass ``` __Input:__ * A square matrix consisting of `n` rows and `n` columns where `1 <= n <= 1000`. __Output:__ * Return the sum of the elements on both the primary and the secondary diagonals. __Constraints:__ * The input will be a valid square matrix. * Elements in the matrix will be integers between -10^5 and 10^5. __Example:__ ```python assert diagonal_sum([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 25 assert diagonal_sum([ [1, 2], [3, 4] ]) == 10 ``` __Explanation:__ * For the first matrix, the primary diagonal elements are 1, 5, 9 and the secondary diagonal elements are 3, 5, 7. The sum is 1 + 5 + 9 + 3 + 5 + 7 = 30, but since 5 is counted twice, the result is 25. * For the second matrix, the primary diagonal elements are 1, 4 and the secondary diagonal elements are 2, 3. The sum is 1 + 4 + 2 + 3 = 10.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) # Since the input is guaranteed to be a square matrix total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal total_sum += matrix[i][n-i-1] # Secondary diagonal # If n is odd, subtract the center element because it has been added twice if n % 2 != 0: center = matrix[n//2][n//2] total_sum -= center return total_sum"},{"question":"# Question **Context**: Lucas numbers form a sequence of integers similar to the Fibonacci sequence, with the first two terms of the series being 2 and 1. Each subsequent term is the sum of the two preceding terms. This sequence finds applications in number theory and has interesting properties. **Task**: You need to implement a function that calculates the nth number in the Lucas number sequence. The function should be efficient in both time and space complexity. **Function Signature**: ```python def lucas_number(n: int) -> int: pass ``` **Input**: * A single integer `n` such that ( n geq 0 ). **Output**: * An integer that represents the nth Lucas number. **Constraints**: 1. ( 0 leq n leq 30 ). **Requirements**: 1. The function should handle invalid inputs by raising appropriate errors. 2. Optimize the function to handle the upper limits of `n` effectively. **Example**: ```python >>> lucas_number(0) 2 >>> lucas_number(1) 1 >>> lucas_number(5) 11 >>> lucas_number(10) 123 ``` Explanation: The sequence starts with 2 and 1. Therefore: 1. The 0th Lucas number is 2. 2. The 1st Lucas number is 1. 3. The 2nd Lucas number is 2 + 1 = 3. 4. The 3rd Lucas number is 1 + 3 = 4, and so on. **Edge cases to consider**: * Handling negative inputs. * Ensuring the function is optimized for larger values within the constraint. **Hints**: - Consider using iterative approach or memoization to achieve optimal performance. - Validate inputs to handle erroneous cases.","solution":"def lucas_number(n: int) -> int: Calculate the nth Lucas number. :param n: Index of the Lucas number to calculate :type n: int :return: nth Lucas number :rtype: int :raises ValueError: If n is not within the valid range [0, 30] if n < 0 or n > 30: raise ValueError(\\"n must be between 0 and 30 inclusive\\") if n == 0: return 2 elif n == 1: return 1 # Initialize the first two Lucas numbers a, b = 2, 1 # Calculate Lucas numbers iteratively for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement: Counting Digits in a String You are required to implement a function `count_digits` that counts the number of digit characters (0-9) in a given string. The function should assume that non-digit characters are ignored. The function signature is as follows: ```python def count_digits(s: str) -> int: pass ``` # Function Signature: ```python def count_digits(s: str) -> int: Counts the number of digit characters in the input string. Parameters: s (str): The input string to be processed. Returns: int: The number of digit characters in the string. Raises: TypeError: If the input is not a string. pass ``` # Input: - A single parameter `s`, which is a string. # Output: - Returns an integer indicating the number of digit characters in the input string. # Constraints: - The function should handle an empty string as a valid input. - The function should raise a `TypeError` if the input is not a string. # Examples: ```python >>> count_digits(\\"there are 123 digits here\\") 3 >>> count_digits(\\"984skdjf93k4dfj\\") 6 >>> count_digits(\\"no digits\\") 0 >>> count_digits(\\"1234567890\\") 10 >>> count_digits(\\"\\") 0 >>> count_digits(12345) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Additional Notes: - Ensure the solution is efficient with respect to time and space complexity. - Include test cases that adequately cover edge cases and potential anomalies.","solution":"def count_digits(s: str) -> int: Counts the number of digit characters in the input string. Parameters: s (str): The input string to be processed. Returns: int: The number of digit characters in the string. Raises: TypeError: If the input is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") return sum(1 for char in s if char.isdigit())"},{"question":"# Weather Data Processor **Objective**: Implement a function to process weather data from an API, handling data parsing and error management efficiently. **Scenario**: In a weather forecast application, integrate with a weather data API to fetch current weather information based on the given city name. The function should format the result and handle common errors effectively. **Requirements**: - Define a function `fetch_weather_data(city: str, api_key: str) -> dict` that: - Takes a city name (string) and the weather API key (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"data\\"` (a dictionary with temperature, weather description, and humidity on success or an error message on failure). - Handle empty city names by returning an appropriate message. - Handle network errors or invalid API responses gracefully. - If the city is not found, return an appropriate message. **Function Signature**: ```python def fetch_weather_data(city: str, api_key: str) -> dict: pass ``` **Constraints**: - The API key provided is valid. - The input city name is a non-empty string of maximum length 100. **Examples**: 1. `fetch_weather_data(\\"London\\", \\"YOUR API KEY\\")` - Might return: ```python { \\"success\\": True, \\"data\\": { \\"temperature\\": \\"15°C\\", \\"description\\": \\"Clear sky\\", \\"humidity\\": \\"40%\\" } } ``` 2. `fetch_weather_data(\\"\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"City name cannot be empty.\\" } ``` 3. `fetch_weather_data(\\"NonexistentCity\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"City not found.\\" } ``` 4. On network failure: - Should return: ```python { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather data.\\" } ```","solution":"import requests def fetch_weather_data(city: str, api_key: str) -> dict: if not city: return { \\"success\\": False, \\"data\\": \\"City name cannot be empty.\\" } url = f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\" try: response = requests.get(url) response.raise_for_status() weather_data = response.json() if weather_data.get(\\"cod\\") != 200: return { \\"success\\": False, \\"data\\": \\"City not found.\\" } temperature = f\\"{weather_data[\'main\'][\'temp\']}°C\\" description = weather_data[\'weather\'][0][\'description\'] humidity = f\\"{weather_data[\'main\'][\'humidity\']}%\\" return { \\"success\\": True, \\"data\\": { \\"temperature\\": temperature, \\"description\\": description, \\"humidity\\": humidity } } except requests.exceptions.RequestException: return { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather data.\\" }"},{"question":"# Problem Statement: You are tasked to implement a `StringManipulator` class that provides functionalities to reverse strings, check for palindromes, and find the most frequent character. Ensure that your implementation handles all edge cases and adheres to the requirements below. # Requirements: 1. Implement a class `StringManipulator` with the following methods: - `str reverse_string(String text)`: Reverses the input string and returns it. - `bool is_palindrome(String text)`: Checks if the input string is a palindrome (reads the same forwards and backwards) and returns a boolean. - `str most_frequent_character(String text)`: Finds and returns the character that appears most frequently in the input string. In case of a tie, return the first character with the highest frequency. 2. Ensure that the `reverse_string` method handles strings of any length. 3. Ensure that the `is_palindrome` method considers case insensitivity and ignores non-alphanumeric characters. 4. Ensure that the `most_frequent_character` method is efficient, even for long strings. 5. Handle cases where the input string is empty or contains only non-alphabetic characters. # Input and Output Formats: - The `reverse_string` method accepts a single string `text` and returns a string. - The `is_palindrome` method accepts a single string `text` and returns a boolean. - The `most_frequent_character` method accepts a single string `text` and returns a single character string. # Constraints: - The input string `text` length will be between 0 and 10^5 characters. # Example: ```python class StringManipulator: @staticmethod def reverse_string(text: str) -> str: pass # Include your reverse string implementation here @staticmethod def is_palindrome(text: str) -> bool: pass # Include your is palindrome implementation here @staticmethod def most_frequent_character(text: str) -> str: pass # Include your most frequent character implementation here # Example usage: manipulator = StringManipulator() print(manipulator.reverse_string(\\"hello\\")) # Expected: \\"olleh\\" print(manipulator.is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Expected: True print(manipulator.most_frequent_character(\\"character\\")) # Expected: \\"c\\" (or any highest frequency character if there\'s a tie) ``` Complete the class `StringManipulator` based on the provided requirements and examples.","solution":"class StringManipulator: @staticmethod def reverse_string(text: str) -> str: Reverses the input string and returns it. return text[::-1] @staticmethod def is_palindrome(text: str) -> bool: Checks if the input string is a palindrome. Considers case insensitivity and ignores non-alphanumeric characters. # Filter only alphanumeric characters and convert to lower case filtered_text = \'\'.join(char.lower() for char in text if char.isalnum()) # Compare filtered text with its reverse return filtered_text == filtered_text[::-1] @staticmethod def most_frequent_character(text: str) -> str: Finds and returns the character that appears most frequently in the input string. In case of a tie, returns the first character with the highest frequency. if not text: return \'\' # If the text is empty, return an empty string from collections import Counter # Count frequency of each character frequency = Counter(text) # Find the most common character most_common_char = max(frequency, key=lambda key: (frequency[key], -text.index(key))) return most_common_char # Example usage: # manipulator = StringManipulator() # print(manipulator.reverse_string(\\"hello\\")) # Expected: \\"olleh\\" # print(manipulator.is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Expected: True # print(manipulator.most_frequent_character(\\"character\\")) # Expected: \\"c\\" (or any highest frequency character if there\'s a tie)"},{"question":"# Question: Implementing K-means Clustering You are given a dataset where each instance has a number of features. Your task is to implement the K-means algorithm to cluster the dataset into `K` clusters. Function Signature ```python def kmeans_clustering(data: list[list[float]], k: int, max_iterations: int) -> list[int]: ``` # Input 1. `data` (list of lists): Each inner list contains feature values of an instance. 2. `k` (int): The number of clusters to form. 3. `max_iterations` (int): The maximum number of iterations the algorithm should run. # Output * `assignments` (list): The list of cluster indices for each instance, indicating the cluster to which the instance belongs. # Constraints * All the elements in `data` will be floating-point numbers. * `0 < number of instances <= 10^3` * `0 < number of features <= 50` * `1 <= k <= 10` * `1 <= max_iterations <= 10^3` # Example ```python data = [ [1.0, 2.0], [2.0, 3.0], [1.1, 1.9], [10.0, 10.0], [10.1, 10.1], [9.9, 9.8] ] k = 2 max_iterations = 100 kmeans_clustering(data, k, max_iterations) ``` Expected Output: ```python [0, 0, 0, 1, 1, 1] ``` # Explanation 1. Data consists of 6 instances with 2 features each. 2. We aim to form 2 clusters (k=2). 3. The algorithm should run for at most 100 iterations. 4. The result indicates that the first three instances are assigned to cluster 0 and the last three instances are assigned to cluster 1. # Note 1. Initialize cluster centroids randomly from the data points. 2. Iterate the algorithm for the specified number of iterations or until the cluster assignments do not change. # Grading Criteria * Correctness: The function should correctly assign the instances to clusters. * Efficiency: The function should handle the input constraints within a reasonable time. Hints 1. In each iteration: * Assign each instance to the nearest centroid. * Recompute the centroids as the mean of the assigned instances. **Good Luck!**","solution":"import random from copy import deepcopy from math import sqrt def euclidean_distance(point1, point2): return sqrt(sum((coord1 - coord2) ** 2 for coord1, coord2 in zip(point1, point2))) def compute_centroids(data, assignments, k): clusters = [[] for _ in range(k)] for index, point in enumerate(data): clusters[assignments[index]].append(point) centroids = [] for cluster in clusters: if cluster: centroid = [sum(features)/len(features) for features in zip(*cluster)] else: centroid = [0] * len(data[0]) # if a cluster is empty, set its centroid to the origin centroids.append(centroid) return centroids def kmeans_clustering(data, k, max_iterations): n = len(data) dim = len(data[0]) # Randomly choose initial centroids from the data points centroids = random.sample(data, k) assignments = [-1] * n for _ in range(max_iterations): new_assignments = [] for point in data: distances = [euclidean_distance(point, centroid) for centroid in centroids] new_assignments.append(distances.index(min(distances))) if new_assignments == assignments: break assignments = new_assignments centroids = compute_centroids(data, assignments, k) return assignments"},{"question":"# Coding Assessment Question: You are tasked with building a simple text editor that can undo actions based on the input commands provided. The editor supports the following commands: 1. **ADD string**: Append the given string to the current text. 2. **DELETE k**: Delete the last `k` characters from the current text. 3. **UNDO**: Undo the last operation (either an ADD or DELETE operation). You need to implement a function that simulates the text editor based on the given list of commands and returns the final text after processing all commands. Function Signature: ```python def text_editor(commands: List[str]) -> str: Simulate a text editor with given commands and perform undo operations. Args: commands (List[str]): A list of string commands. Returns: str: The final text after processing all commands. ``` Input: - A list `commands` where each element is a string representing a command. - All commands are in the format described above (i.e., \\"ADD string\\", \\"DELETE k\\", \\"UNDO\\"). - Commands are provided in a valid sequence, no invalid commands are included. Output: - A string representing the final text after processing all commands. Example: ```python >>> text_editor([\\"ADD hello\\", \\"ADD world\\", \\"DELETE 5\\", \\"UNDO\\", \\"UNDO\\"]) \'hello\' >>> text_editor([\\"ADD programming\\", \\"DELETE 3\\", \\"ADD fun\\", \\"UNDO\\"]) \'programmin\' >>> text_editor([\\"ADD abc\\", \\"ADD def\\", \\"UNDO\\", \\"ADD xyz\\", \\"UNDO\\"]) \'abc\' ``` Constraints: 1. Each command is applied in sequence to the text. 2. All `ADD` and `DELETE` operations are reversible by the `UNDO` command. 3. The `UNDO` command should reverse the most recent operation that has not been undone yet. 4. If the `DELETE` command indicates removing more characters than currently in text, delete as many as possible. Additional Notes: - The input commands are guaranteed to be valid and properly formatted. - After processing all commands, return the final state of the text as a string. - Ensure efficient handling of up to 10^4 commands. Your task is to implement the function `text_editor` based on the given description and constraints.","solution":"def text_editor(commands): Simulate a text editor with given commands and perform undo operations. Args: commands (List[str]): A list of string commands. Returns: str: The final text after processing all commands. text = \\"\\" history = [] for command in commands: parts = command.split(maxsplit=1) action = parts[0] if action == \\"ADD\\": string_to_add = parts[1] history.append((\\"ADD\\", string_to_add)) text += string_to_add elif action == \\"DELETE\\": num_to_delete = int(parts[1]) deleted_part = text[-num_to_delete:] if num_to_delete <= len(text) else text history.append((\\"DELETE\\", deleted_part)) text = text[:-num_to_delete] if num_to_delete <= len(text) else \\"\\" elif action == \\"UNDO\\": if history: last_action = history.pop() if last_action[0] == \\"ADD\\": to_remove = len(last_action[1]) text = text[:-to_remove] elif last_action[0] == \\"DELETE\\": text += last_action[1] return text"},{"question":"# Binary Tree Level Order Traversal with Various Orders Scenario: You need to extend the classic level order traversal of a binary tree to include the following features: 1. **Reversed Order**: Optionally perform the traversal in the reverse order. 2. **Zigzag Level Order**: Optionally perform the traversal in a zigzag manner, where the nodes at every other level are traversed from right to left instead of left to right. 3. **Function-Based Processing**: Allow an optional processing function that will be applied to each node\'s value during the traversal. Task: Implement the function `enhanced_level_order_traversal` with the following signature: ```python from typing import List, Optional, Callable class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def enhanced_level_order_traversal(root: Optional[TreeNode], reversed_order: bool = False, zigzag: bool = False, process: Optional[Callable[[int], int]] = None) -> List[int]: ``` * **Parameters**: - `root`: The root node of the binary tree. - `reversed_order`: A boolean flag. If True, the traversal is performed in a reverse level order. Default is False. - `zigzag`: A boolean flag. If True, the traversal is performed in a zigzag (alternating levels). Default is False. - `process`: An optional processing function that takes an integer and returns a transformed integer. If not provided, no transformation is applied to node values. * **Returns**: - A list of integers representing the nodes\' values in the traversal order based on the given parameters. * **Constraints**: - The number of nodes in the tree can be up to (10^5). * **Example**: ```python root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) enhanced_level_order_traversal(root) # Returns: [1, 2, 3, 4, 5, 6, 7] enhanced_level_order_traversal(root, reversed_order=True) # Returns: [4, 5, 6, 7, 2, 3, 1] enhanced_level_order_traversal(root, zigzag=True) # Returns: [1, 3, 2, 4, 5, 6, 7] enhanced_level_order_traversal(root, process=lambda x: x * 2) # Returns: [2, 4, 6, 8, 10, 12, 14] ``` Note: - Ensure the traversal functions correctly handle edge cases, such as an empty tree or a tree with a single node. - Utilize breadth-first search (BFS) or similar techniques to implement the traversal efficiently.","solution":"from typing import List, Optional, Callable from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def enhanced_level_order_traversal(root: Optional[TreeNode], reversed_order: bool = False, zigzag: bool = False, process: Optional[Callable[[int], int]] = None) -> List[int]: if not root: return [] queue = deque([(root, 0)]) levels = [] while queue: node, level = queue.popleft() if len(levels) == level: levels.append(deque([node.val])) else: if zigzag and level % 2 != 0: levels[level].appendleft(node.val) else: levels[level].append(node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) result = [] for level in (reversed(levels) if reversed_order else levels): result.extend(level) if process: result = [process(val) for val in result] return result"},{"question":"# Question Scenario: As a software engineer, you are tasked with developing a utility that counts occurrences of specific words within a provided text. This utility will be part of a larger text analysis toolkit. Task: Implement the function `count_word_occurrences` that takes a string `text` and a string `word` and returns the count of how many times the specified `word` appears in the `text`. The search should be case-insensitive. Implementation: 1. Define the function `count_word_occurrences(text: str, word: str) -> int`. 2. Ensure the function handles the following: * Case insensitivity. * Partial matches should not be counted (e.g., searching for \\"cat\\" should not count \\"catalog\\"). * Input validation to confirm both `text` and `word` are strings. 3. Optimize for performance (ideally O(n) time complexity, where n is the length of `text`). Input: * A string `text` containing the text to search within. * A string `word` representing the word to count occurrences of. Output: * An integer representing the count of occurrences of the specified word within the input text. Constraints: * The length of `text` does not exceed 10^6 characters. * The length of `word` does not exceed 100 characters. * The input strings may include non-alphabetical characters. Examples: ```python >>> count_word_occurrences(\\"Hello world\\", \\"hello\\") 1 >>> count_word_occurrences(\\"Python is amazing. The python language is versatile.\\", \\"python\\") 2 >>> count_word_occurrences(\\"This is a test. Testing is essential.\\", \\"is\\") 2 >>> count_word_occurrences(\\"text analysis is fun\\", \\"word\\") 0 >>> count_word_occurrences(\\"Count the occurrences of specific words within a text.\\", \\"of\\") 1 ``` Performance Requirements: The function should be able to handle large inputs efficiently and accurately determine the word occurrences while maintaining a linear time complexity with respect to the input text\'s length.","solution":"def count_word_occurrences(text: str, word: str) -> int: Returns the count of how many times the specified word appears in the text. The search is case-insensitive and only counts whole word matches. if not isinstance(text, str) or not isinstance(word, str): raise ValueError(\\"Both text and word should be strings.\\") word = word.lower() text = text.lower() words = text.split() count = 0 for w in words: if w.strip(\'.,!?\\";:()[]{}\') == word: count += 1 return count"},{"question":"# Circular Array Rotation: Find Element at Position You are given the task of implementing a function that performs a series of right circular rotations on an array and returns the element at a specified position after all rotations. A circular rotation shifts each element of the array to the right by one index, with the last element wrapping around to the first position. Function Specifications: 1. **Find Element Function**: ```python def find_element_after_rotations(arr: list[int], rotations: int, position: int) -> int: Finds the element at a specified position after a series of right circular rotations. :param arr: The original array. :param rotations: The number of right circular rotations to perform. :param position: The index position (0-based) to find the element after rotations. :return: The element at the specified position after rotations. ``` Requirements: - The function should determine the element at the given position after performing the specified number of rotations. - Optimize the function to handle large numbers of rotations efficiently. Constraints: - Assume the length of the array (`n`) is between 1 and 100,000 inclusive. - The number of rotations (`rotations`) is a non-negative integer. - The `position` index (`position`) is a non-negative integer and less than `n`. Example Usage ```python def test_circular_array_rotation() -> None: arr = [1, 2, 3, 4, 5] rotations = 2 position = 1 result = find_element_after_rotations(arr, rotations, position) assert result == 4, f\\"Expected: 4, Got: {result}\\" if __name__ == \\"__main__\\": test_circular_array_rotation() ``` # Explanation: - For a given array of `[1, 2, 3, 4, 5]`, performing 2 right circular rotations would result in `[4, 5, 1, 2, 3]`. - The element at index 1 after both rotations is `5`. - Generalize the approach by noting that performing `k` rotations on an array of length `n` positions the element at index `i` to be at `(i + k) % n`.","solution":"def find_element_after_rotations(arr: list[int], rotations: int, position: int) -> int: Finds the element at a specified position after a series of right circular rotations. :param arr: The original array. :param rotations: The number of right circular rotations to perform. :param position: The index position (0-based) to find the element after rotations. :return: The element at the specified position after rotations. n = len(arr) effective_rotations = rotations % n # To handle large numbers of rotations efficiently new_position = (position - effective_rotations) % n return arr[new_position]"},{"question":"# Problem Statement You are provided with an array of integers and a list of update operations. Each update modifies all elements in a given range by adding a particular value. Your task is to implement a data structure that supports efficient range updates and range sum queries. You will implement: 1. A function to apply all updates to the array. 2. A function to perform range sum queries after the updates. # Function Specifications Function 1: `apply_updates` - **Input**: 1. A list of integers `number_list`. 2. A list of updates `updates`, where each update is represented as a tuple (left_bound, right_bound, value) indicating the range [L..R] to which `value` should be added. - **Output**: The updated list of integers after applying all the updates. ```python def apply_updates(number_list: list[int], updates: list[tuple[int, int, int]]) -> list[int]: pass ``` Function 2: `range_sum` - **Input**: 1. The updated list of integers `updated_list` (output of `apply_updates`). 2. Two integers `left_bound` and `right_bound` indicating the range [L..R] for the range sum query. - **Output**: The sum of the elements in the given range [L..R]. ```python def range_sum(updated_list: list[int], left_bound: int, right_bound: int) -> int: pass ``` # Constraints - The length of the input list will be between 1 and 100,000. - The number of updates will be between 1 and 10,000. - Each element in the updates list will have `left_bound` and `right_bound` as integers in the range [0, len(number_list) - 1]. - `value` in each update will be an integer between -10^9 and 10^9. - The elements in the `number_list` are integers ranging from -10^9 to 10^9. # Example ```python number_list = [2, 3, 7, 5, 1] updates = [(1, 3, 4), (0, 2, -2)] updated_list = apply_updates(number_list, updates) print(updated_list) # Expected output: [0, 5, 9, 9, 1] print(range_sum(updated_list, 1, 3)) # Expected output: 23 print(range_sum(updated_list, 0, 4)) # Expected output: 24 print(range_sum(updated_list, 2, 2)) # Expected output: 9 ``` # Notes - Carefully handle multiple overlapping updates to ensure the correct result. - Optimize your solution to handle the largest input sizes efficiently. - Pay attention to array bounds to avoid out-of-range errors when applying updates and performing range sum queries.","solution":"def apply_updates(number_list: list[int], updates: list[tuple[int, int, int]]) -> list[int]: # Initialize a difference array diff = [0] * (len(number_list) + 1) # Apply each update using the difference array concept for L, R, value in updates: diff[L] += value if R + 1 < len(number_list): diff[R + 1] -= value # Create the updated array using the difference array updated_list = number_list[:] current_addition = 0 for i in range(len(number_list)): current_addition += diff[i] updated_list[i] += current_addition return updated_list def range_sum(updated_list: list[int], left_bound: int, right_bound: int) -> int: return sum(updated_list[left_bound:right_bound + 1])"},{"question":"# Coding Assessment Question You are asked to implement two functions that involve examining and working with prime numbers and their sums. You need to validate if a number can be expressed as a sum of exactly two prime numbers, and compute the sum of unique prime factors of a given number. Task **Function 1:** `is_sum_of_two_primes(n: int) -> bool` Implement a function to determine if a given integer can be expressed as the sum of exactly two prime numbers. - **Input** - `n` (int): A positive integer to check. - **Output** - Returns `True` if the integer can be expressed as the sum of exactly two distinct prime numbers, and `False` otherwise. - **Constraints** - The input `n` must be a positive integer greater than or equal to 4. - **Examples** ```python assert is_sum_of_two_primes(10) == True # 10 can be expressed as 3 + 7 or 5 + 5 assert is_sum_of_two_primes(11) == False # 11 cannot be expressed as sum of any two prime numbers ``` **Function 2:** `sum_of_unique_prime_factors(n: int) -> int` Implement a function to compute the sum of all unique prime factors of a given integer. - **Input** - `n` (int): A positive integer to compute its unique prime factors sum. - **Output** - Returns the sum of all unique prime factors as an integer. - **Constraints** - The input `n` must be a positive integer greater than 1. - **Examples** ```python assert sum_of_unique_prime_factors(12) == 5 # Prime factors are 2, 3; 2 + 3 = 5 assert sum_of_unique_prime_factors(30) == 10 # Prime factors are 2, 3, 5; 2 + 3 + 5 = 10 ``` Implement these functions keeping in mind the constraints, edge cases and performance optimizations recommended in the analysis above.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def is_sum_of_two_primes(n: int) -> bool: if n < 4: return False for i in range(2, n): if is_prime(i) and is_prime(n - i): return True return False def prime_factors(num): i = 2 factors = set() while i * i <= num: if num % i: i += 1 else: num //= i factors.add(i) if num > 1: factors.add(num) return factors def sum_of_unique_prime_factors(n: int) -> int: return sum(prime_factors(n))"},{"question":"# Matrix Manipulation for Image Processing Scenario You are working as a software developer at an image processing company. Your team is tasked with implementing various algorithms to manipulate grayscale images represented as 2D matrices. One of the core tasks is to enhance the image clarity by applying a specific transformation to the matrix, which involves rotating the matrix and then incrementing all the pixel values by a given constant. Problem Implement a function `transform_image(matrix: List[List[int]], increment: int) -> List[List[int]]` that performs the following operations on the input grayscale image matrix: 1. **Rotation**: Rotate the matrix 90 degrees clockwise. 2. **Increment**: Add a constant value to each element of the rotated matrix. The function should perform these operations efficiently, even for large matrices. Input - `matrix`: A 2D list representing a grayscale image, where each element is an integer (0 ≤ element ≤ 255) and the dimensions of the matrix are within the range 1 ≤ rows, columns ≤ 500. - `increment`: An integer value by which each element of the rotated matrix should be incremented (-255 ≤ increment ≤ 255). Output - Return the transformed matrix after applying the above operations. Constraints - The function should handle edge cases, such as empty matrices and large matrices, efficiently. - If the `increment` results in values outside the range [0, 255], they should be clamped accordingly. - Values below 0 should be set to 0. - Values above 255 should be set to 255. Example ```python # Input: # matrix = [[1, 2, 3], # [4, 5, 6], # [7, 8, 9]] # increment = 10 # Rotate 90 degrees clockwise: # [[7, 4, 1], # [8, 5, 2], # [9, 6, 3]] # Increment by 10: # [[17, 14, 11], # [18, 15, 12], # [19, 16, 13]] assert transform_image([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 10) == [[17, 14, 11], [18, 15, 12], [19, 16, 13]] # Input: # matrix = [[100, 150], # [200, 250]] # increment = -50 # Rotate 90 degrees clockwise: # [[200, 100], # [250, 150]] # Increment by -50 and clamp to range [0, 255]: # [[150, 50], # [200, 100]] assert transform_image([[100, 150], [200, 250]], -50) == [[150, 50], [200, 100]] # Input: # matrix = [] # increment = 5 # Empty matrix does not change: assert transform_image([], 5) == [] ``` Notes * Ensure matrix manipulation (especially the rotation) is optimized for performance. * Take into account edge cases such as empty matrices. * Use clamping to ensure pixel values remain within the valid grayscale range after incrementing. Hint Consider using list comprehensions and Python\'s built-in functions efficiently to handle large matrices and keep the code concise.","solution":"from typing import List def transform_image(matrix: List[List[int]], increment: int) -> List[List[int]]: Rotates the given matrix 90 degrees clockwise and then increments each value by a given constant. If the result is out of [0, 255] range, it clamps the values to be within [0, 255]. if not matrix or not matrix[0]: return [] # Rotate 90 degrees clockwise n = len(matrix) m = len(matrix[0]) rotated_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated_matrix[j][n-1-i] = matrix[i][j] # Increment and clamp the values for i in range(m): for j in range(n): rotated_matrix[i][j] = max(0, min(255, rotated_matrix[i][j] + increment)) return rotated_matrix"},{"question":"**Context**: In the realm of algorithmic challenges, it is often useful to evaluate a function by its ability to handle strings and numerical operations efficiently. This problem involves encoding a sequence of lowercase English letters with each letter replaced by its position in the alphabet, concatenated together without any delimiters. **Problem**: Write a Python function that takes a string of lowercase English letters and converts it into a string of numbers, where each letter is replaced by its position in the alphabet (a=1, b=2, ..., z=26). **Task**: 1. Write a function `letter_to_number(letter)` that converts a single lowercase letter to its corresponding position in the alphabet. 2. Write a function `encode_string(s)` that encodes the entire string using `letter_to_number` and concatenates the results. **Input**: - `s` (a string) consisting of only lowercase English letters with a length of `1 <= len(s) <= 100`. **Output**: - A string representing the encoded sequence of numbers. **Constraints**: - `1 <= len(s) <= 100` **Function Signature**: ```python def letter_to_number(letter: str) -> int: pass def encode_string(s: str) -> str: pass ``` **Example**: ```python >>> encode_string(\'abc\') \'123\' >>> encode_string(\'xyz\') \'242526\' >>> encode_string(\'hello\') \'85121215\' ``` **Requirements**: - Ensure efficient string manipulation. - Handle edge cases, such as the smallest and largest possible inputs.","solution":"def letter_to_number(letter: str) -> int: Convert a single lowercase letter to its position in the alphabet (a=1, b=2, ..., z=26). return ord(letter) - ord(\'a\') + 1 def encode_string(s: str) -> str: Encode the string s by replacing each letter with its position in the alphabet and concatenating the results. encoded = \'\'.join(str(letter_to_number(letter)) for letter in s) return encoded"},{"question":"# Problem Statement Write a function that finds all possible permutations of a given list of unique integers. The permutations should be generated using backtracking. # Function Signature ```python def generate_permutations(nums: list[int]) -> list[list[int]]: pass ``` # Input * `nums` (list of integers): A list of unique integers from which permutations are to be generated. # Output * Returns a list of lists, with each inner list being a unique permutation of the input list. # Constraints * Validate that the input is a list of integers. * If the input list is empty, return an empty list. * The function should use backtracking to generate the permutations. # Requirements * The solution should consider the computational complexity of generating all permutations ( O(n!) ). * If the input is not a list of unique integers, raise a `ValueError` with the message \\"Input must be a list of unique integers\\". # Example ```python generate_permutations([1, 2, 3]) # Expected output: # [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] generate_permutations([]) # Expected output: # [] generate_permutations([5]) # Expected output: # [[5]] generate_permutations([1, 2, 2]) # Expected output: # Raises ValueError: Input must be a list of unique integers ``` # Notes * Ensure your solution is efficient and handles edge cases effectively. * Do not use any library function like `itertools.permutations` to generate perms directly. Implement the backtracking algorithm manually. * Focus on writing clean, modular, and efficient code.","solution":"def generate_permutations(nums): Returns all possible permutations of the given list of unique integers using backtracking. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums) or len(nums) != len(set(nums)): raise ValueError(\\"Input must be a list of unique integers\\") def backtrack(start=0): if start == len(nums): result.append(nums[:]) return for i in range(start, len(nums)): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1) nums[start], nums[i] = nums[i], nums[start] result = [] if nums: backtrack() return result"},{"question":"# Problem Statement You are given a 2D grid of characters representing an `mxn` board and a string `word`. Check if `word` exists in the grid. # Objective Write a function `word_search(board: List[List[str]], word: str) -> bool` that determines if the `word` can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. # Description - Your function should utilize a Depth First Search (DFS) approach. - The word can be constructed from letters of sequentially adjacent cells. Adjacent cells are those horizontally or vertically neighboring. - Individual cells in the board may contain any upper or lower case letter. - The same letter cell may not be used multiple times in constructing the word. # Input Format - A 2D list of characters `board` representing the `mxn` grid. - A string `word` representing the word to search in the grid. # Output Format - A boolean value indicating whether the `word` exists in the grid. # Constraints - The maximum value for `m` and `n` will not exceed 100. - The length of `word` will be at least 1 and not exceed 10^3. # Performance Requirements - The optimal approach should have a time complexity of O(m*n*L), where `L` is the length of the `word`. - Space complexity should ideally be O(L) due to the recursion stack during DFS. # Examples Example 1: ```python word_search([ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ], \\"ABCCED\\") ``` **Output:** ```python True ``` Example 2: ```python word_search([ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ], \\"SEE\\") ``` **Output:** ```python True ``` Example 3: ```python word_search([ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ], \\"ABCB\\") ``` **Output:** ```python False ``` # Edge Cases 1. If the `word` is longer than the total number of characters in the `board`, return False. 2. Ensure the function handles different case letters correctly. 3. If the `word` is an empty string, return True. # Scenario or Context Consider building a word puzzle-solving feature for a mobile game. This function helps in verifying if a word is present in the puzzle based on the specified rules. Such functionality is crucial for validating gameplay and ensuring the integrity of generated puzzles.","solution":"from typing import List def word_search(board: List[List[str]], word: str) -> bool: if not board: return False def dfs(board, word, i, j, index): if index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return False if board[i][j] != word[index]: return False tmp = board[i][j] board[i][j] = \\"#\\" found = (dfs(board, word, i + 1, j, index + 1) or dfs(board, word, i - 1, j, index + 1) or dfs(board, word, i, j + 1, index + 1) or dfs(board, word, i, j - 1, index + 1)) board[i][j] = tmp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"# **Question: Optimizing Restaurant Queue Management** You have been hired to create a system that helps a restaurant manage its waiting list efficiently. The restaurant keeps a waiting list for tables, and you need to design a function that helps in managing this waiting list. The queuing system should allow customers to be added to the waiting list, removed when they are seated, and handle priority seating for VIP customers. Regular customers are seated on a first-come, first-served basis, while VIP customers are seated as soon as they enter. **Your task:** Implement a class `RestaurantQueue` to manage the waiting list. The class should support the following operations: - `add_customer`: Add a customer to the waiting list. - `seat_customer`: Seat the next customer from the waiting list considering the priority given to VIP customers. - `get_waiting_list`: Get a list of all customers currently in the waiting list. **Class Signature:** ```python from typing import List, Tuple class RestaurantQueue: def __init__(self): pass def add_customer(self, customer_id: int, is_vip: bool = False) -> None: pass def seat_customer(self) -> int: pass def get_waiting_list(self) -> List[Tuple[int, bool]]: pass ``` **Requirements:** 1. **Methods**: - `add_customer(customer_id: int, is_vip: bool = False) -> None`: Adds a customer with the given `customer_id` to the waiting list. The `is_vip` flag indicates whether the customer is a VIP. - `seat_customer() -> int`: Seats the next customer, removing them from the waiting list, and returns their `customer_id`. Priority is given to VIP customers. - `get_waiting_list() -> List[Tuple[int, bool]]`: Returns a list of tuples where each tuple contains a `customer_id` and a boolean `is_vip` flag indicating if it\'s a VIP customer. 2. **Outputs**: - For `seat_customer`, return the `customer_id` of the seated customer. - For `get_waiting_list`, return the current waiting list as a list of tuples. 3. **Constraints**: - `customer_id` is a unique positive integer. - Assume no two customers have the same `customer_id`. - The system should handle up to 10,000 customers efficiently. 4. **Example Usage**: ```python # Example Usage queue = RestaurantQueue() queue.add_customer(1) queue.add_customer(2, True) queue.add_customer(3) queue.add_customer(4, True) print(queue.get_waiting_list()) # [(1, False), (2, True), (3, False), (4, True)] print(queue.seat_customer()) # 2 (seats the first VIP customer) print(queue.get_waiting_list()) # [(1, False), (3, False), (4, True)] ``` Design an efficient system to ensure the restaurant\'s waiting list is managed correctly and VIP customers are given priority seating.","solution":"from typing import List, Tuple class RestaurantQueue: def __init__(self): self.vip_queue = [] self.regular_queue = [] def add_customer(self, customer_id: int, is_vip: bool = False) -> None: if is_vip: self.vip_queue.append(customer_id) else: self.regular_queue.append(customer_id) def seat_customer(self) -> int: if self.vip_queue: return self.vip_queue.pop(0) if self.regular_queue: return self.regular_queue.pop(0) return None def get_waiting_list(self) -> List[Tuple[int, bool]]: return [(customer_id, True) for customer_id in self.vip_queue] + [(customer_id, False) for customer_id in self.regular_queue]"},{"question":"Sorting Log Entries You are required to implement a function `sort_log_entries` that sorts a list of log entries based on timestamps. Each log entry is a dictionary containing at least two fields: - `timestamp` (str): A timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". - `message` (str): The log message associated with the timestamp. The function should return a new list of log entries sorted in ascending order based on their timestamps. # Requirements 1. **Input Parameters and Constraints**: - `log_entries`: A list of dictionaries, each representing a log entry with the `timestamp` and `message` fields. 2. **Function Output**: - A list of dictionaries representing the sorted log entries. 3. **Performance Considerations**: - Ensure the solution efficiently handles larger lists of log entries. # Function Signature ```python def sort_log_entries(log_entries: list) -> list: ``` # Example Usage ```python # Example call to the function logs = [ {\'timestamp\': \'2023-06-01 14:24:35\', \'message\': \'System rebooted\'}, {\'timestamp\': \'2023-06-01 14:23:55\', \'message\': \'User login\'}, {\'timestamp\': \'2023-06-01 14:25:05\', \'message\': \'User logout\'} ] sorted_logs = sort_log_entries(logs) for log in sorted_logs: print(f\\"Timestamp: {log[\'timestamp\']}, Message: {log[\'message\']}\\") ``` # Expected Output ``` Timestamp: 2023-06-01 14:23:55, Message: User login Timestamp: 2023-06-01 14:24:35, Message: System rebooted Timestamp: 2023-06-01 14:25:05, Message: User logout ``` # Notes - Use Python\'s built-in sorting functionality for simplicity. - Assume that all timestamps are valid and in the correct format.","solution":"def sort_log_entries(log_entries): Sorts a list of log entries based on their timestamps. Parameters: log_entries (list): A list of dictionaries, each representing a log entry with the `timestamp` and `message` fields. Returns: list: A list of log entries sorted in ascending order based on their timestamps. return sorted(log_entries, key=lambda x: x[\'timestamp\'])"},{"question":"# Memory-Efficient Fibonacci Sequence Context As a software engineer, you need to implement an efficient algorithm to generate Fibonacci numbers. Given the limits in memory usage in some embedded systems, your goal is to generate the Fibonacci sequence up to the n-th term without using a large list to store all previous terms. Objective Implement a function that returns the n-th Fibonacci number using constant space. Input Format 1. An integer `n` representing the position in the Fibonacci sequence (0-based index). Output Format 1. An integer representing the n-th Fibonacci number. Constraints 1. `n` should be between 0 and 10,000. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Example ```python n = 10 result = fibonacci(n) print(\\"The 10th Fibonacci number is:\\", result) ``` In this example, calling `fibonacci(10)` should return 55, as it is the 10th term in the Fibonacci sequence starting from 0. # Requirements 1. Implement the function to compute the Fibonacci number at a given position using O(1) space complexity. 2. Avoid using recursion or any data structures that grow with `n`. 3. Ensure the function runs efficiently even for the highest constraints. # Hints 1. You can use two variables to keep track of the last two Fibonacci numbers and iteratively calculate the next number in the sequence. 2. Think of how you can update these variables in a loop to achieve the desired result. Good luck!","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using constant space. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Implement a Dictionary-Like Class with Default Values You are tasked with creating a custom dictionary class that mimics the behavior of a regular dictionary but with certain constraints and additional default value functionality. Scenario Imagine a class called `MyDict`. This class is designed to behave like a normal dictionary but has the ability to handle missing keys by returning a default value specified at the time of its creation. Features * `get(key)` - returns the value associated with the specified key. If the key does not exist, it returns the default value. * `set(key, value)` - sets the value for the specified key. * `delete(key)` - removes the specified key and its associated value. * `contains(key)` - checks if the key exists in the dictionary. Your task is to implement this class with the methods described above. Specification * **Class Name:** `MyDict` * **Methods:** * `__init__(self, default_value: Any) -> None`: Initializes the dictionary with a specified default value. * `get(self, key: Any) -> Any`: Returns the value associated with the key or the default value if the key does not exist. * `set(self, key: Any, value: Any) -> None`: Sets the key-value pair in the dictionary. * `delete(self, key: Any) -> None`: Deletes the key-value pair from the dictionary. * `contains(self, key: Any) -> bool`: Returns `True` if the key exists, otherwise `False`. Example Usage: ```python class MyDict: def __init__(self, default_value): self.default_value = default_value self.data = {} def get(self, key): return self.data.get(key, self.default_value) def set(self, key, value): self.data[key] = value def delete(self, key): if key in self.data: del self.data[key] def contains(self, key): return key in self.data # Example: my_dict = MyDict(default_value=\\"N/A\\") my_dict.set(\\"apple\\", 10) print(my_dict.get(\\"apple\\")) # Should output 10 print(my_dict.get(\\"banana\\")) # Should output \\"N/A\\" my_dict.delete(\\"apple\\") print(my_dict.get(\\"apple\\")) # Should output \\"N/A\\" print(my_dict.contains(\\"banana\\")) # Should output False ``` Constraints: * You may assume all keys and values are hashable and comparable. * The default value can be of any type. * Keys and values can be of different types. Your implementation should ensure efficiency and proper handling of edge cases.","solution":"class MyDict: def __init__(self, default_value): self.default_value = default_value self.data = {} def get(self, key): return self.data.get(key, self.default_value) def set(self, key, value): self.data[key] = value def delete(self, key): if key in self.data: del self.data[key] def contains(self, key): return key in self.data"},{"question":"# Coding Assessment Question **Scenario**: You are a data scientist working on a project to analyze user activity patterns on a social media platform. One of the key analyses involves identifying \\"active user streaks.\\" An active user streak is defined as a series of consecutive days where a user performs at least one action on the platform. **Task**: Implement a Python function `longest_active_streak` that receives a list of dates (in string format) representing the days when a user was active and returns the length of the longest streak of consecutive days. All dates are unique and provided in \\"YYYY-MM-DD\\" format. **Function Signature**: ```python def longest_active_streak(dates: List[str]) -> int: Find the longest streak of consecutive days the user was active. Parameters: - dates (List[str]): List of strings representing active dates in \\"YYYY-MM-DD\\" format. Returns: - int: Length of the longest streak of consecutive active days. Exceptions: - Raise ValueError if the date format is invalid. pass ``` **Constraints**: - The dates list will have at least one date. - No duplicate dates will be provided. - Dates should be sorted in ascending order. **Performance Requirements**: - The function should handle a list of up to 10,000 dates efficiently. **Examples**: ```python >>> longest_active_streak([\\"2022-12-01\\", \\"2022-12-02\\", \\"2022-12-03\\", \\"2022-12-07\\", \\"2022-12-08\\"]) 3 >>> longest_active_streak([\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-04\\", \\"2023-01-05\\", \\"2023-01-06\\"]) 3 >>> longest_active_streak([\\"2023-03-01\\", \\"2022-08-01\\", \\"2022-08-02\\", \\"2022-08-03\\"]) 3 >>> longest_active_streak([\\"2022-11-15\\"]) 1 ```","solution":"from datetime import datetime, timedelta from typing import List def longest_active_streak(dates: List[str]) -> int: Find the longest streak of consecutive days the user was active. Parameters: - dates (List[str]): List of strings representing active dates in \\"YYYY-MM-DD\\" format. Returns: - int: Length of the longest streak of consecutive active days. Exceptions: - Raise ValueError if the date format is invalid. if not dates: raise ValueError(\\"The dates list is empty\\") # Convert date strings to datetime objects and sort them try: dates = sorted(datetime.strptime(date, \\"%Y-%m-%d\\") for date in dates) except ValueError: raise ValueError(\\"Invalid date format\\") max_streak = 1 current_streak = 1 for i in range(1, len(dates)): if dates[i] - dates[i - 1] == timedelta(days=1): current_streak += 1 else: max_streak = max(max_streak, current_streak) current_streak = 1 max_streak = max(max_streak, current_streak) return max_streak"},{"question":"# Problem Description You are given a list of words and a list of queries. Each query consists of a prefix and a suffix. Your task is to find the number of words in the list that start with the given prefix and end with the given suffix for each query. Implement the `matching_words` function that receives the list of `words` and a list of `queries`. The function should return a list of integers where each integer represents the number of words that satisfy the corresponding query. # Input Format: - A list of strings `words` where each string is a word. - A list of tuples `queries` where each tuple is in the form (prefix, suffix). # Output Format: - A list of integers, each representing the count of words matching the corresponding query. # Constraints: - `1 <= len(words) <= 1000` (number of words) - `1 <= len(queries) <= 1000` (number of queries) - `1 <= len(words[i]) <= 100` (length of each word) - `1 <= len(queries[j][0]), len(queries[j][1]) <= 100` (length of prefix and suffix) # Example: ```python words = [\\"apple\\", \\"application\\", \\"apply\\", \\"banapple\\", \\"banana\\", \\"band\\"] queries = [(\\"app\\", \\"le\\"), (\\"ban\\", \\"na\\"), (\\"a\\", \\"e\\"), (\\"ba\\", \\"nd\\"), (\\"xy\\", \\"z\\")] print(matching_words(words, queries)) # Output: [1, 1, 1, 1, 0] ``` # Task: - Implement the `matching_words` function. Function Definition: ```python def matching_words(words, queries): # Implement the function to solve the problem ``` # Solution: ```python def matching_words(words, queries): results = [] for prefix, suffix in queries: count = sum(1 for word in words if word.startswith(prefix) and word.endswith(suffix)) results.append(count) return results # Example usage: words = [\\"apple\\", \\"application\\", \\"apply\\", \\"banapple\\", \\"banana\\", \\"band\\"] queries = [(\\"app\\", \\"le\\"), (\\"ban\\", \\"na\\"), (\\"a\\", \\"e\\"), (\\"ba\\", \\"nd\\"), (\\"xy\\", \\"z\\")] print(matching_words(words, queries)) # Output: [1, 1, 1, 1, 0] ``` - The function iterates over each query, checking each word to see if it matches the given prefix and suffix, then counts and returns the results. - This implementation maintains the pattern and complexity seen in the provided example.","solution":"def matching_words(words, queries): Returns a list of integers where each integer represents the number of words from the list that start with the given prefix and end with the given suffix as specified in the queries. results = [] for prefix, suffix in queries: count = sum(1 for word in words if word.startswith(prefix) and word.endswith(suffix)) results.append(count) return results"},{"question":"# Coding Question You have been assigned to create a software module that deals with processing logs from a network operation center. Each log entry consists of a timestamp (in the format \\"YYYY-MM-DD HH:MM:SS\\") and a message. Your task is to write a function `second_most_frequent_minute` that determines the minute (in HH:MM format) during which the second highest number of log entries were recorded. # Function Signature ```python def second_most_frequent_minute(logs: List[str]) -> str: Given a list of log entries, returns the HH:MM minute during which the second highest number of log entries were recorded. ``` # Parameters - `logs`: A list of strings, where each string represents a timestamp followed by a log message separated by a space. # Output The function should return: - A string representing the minute (in the format \\"HH:MM\\") that had the second highest number of log entries. # Constraints - If there is no clearly defined second most frequently occurring minute (e.g., in case of ties or if there are fewer than two different minutes logged), return an empty string `\\"\\"`. - Assume every log entry is well-formed and str strictly follows the \\"YYYY-MM-DD HH:MM:SS message\\" pattern. - Consider cases with edge inputs such as empty logs, single log entry, or multiple entries concentrated in very few minutes. # Example ```python logs = [ \\"2023-10-01 12:34:56 User login\\", \\"2023-10-01 12:34:57 User logout\\", \\"2023-10-01 12:35:02 File updated\\", \\"2023-10-01 12:36:15 User login\\", \\"2023-10-01 12:34:45 User logout\\" ] assert second_most_frequent_minute(logs) == \\"12:35\\" logs = [ \\"2023-10-01 12:34:56 User login\\", \\"2023-10-01 12:34:57 User logout\\", \\"2023-10-01 12:35:02 File updated\\", ] assert second_most_frequent_minute(logs) == \\"\\" ``` # Implementation Notes - Focus on parsing the given timestamps to extract the minute part accurately. - Use a dictionary or a `collections.Counter` to count the frequency of log entries per minute. - Carefully handle the case where there are fewer than two unique minutes. - Ensure the result is robust even for large input sizes by choosing efficient data structures and algorithms. # Scenario Imagine you are analyzing network logs to identify peak usage times and need to understand not only the highest but also the second highest traffic periods for performance tuning and alert threshold calibration. This problem will help you build a key module of such an analyzer.","solution":"from typing import List from collections import Counter def second_most_frequent_minute(logs: List[str]) -> str: Given a list of log entries, returns the HH:MM minute during which the second highest number of log entries were recorded. if not logs: return \\"\\" # Extract minutes from the log entries minute_counts = Counter() for log in logs: minute = log[11:16] minute_counts[minute] += 1 # Get the two most common minutes most_common_minutes = minute_counts.most_common() if len(most_common_minutes) < 2: return \\"\\" return most_common_minutes[1][0]"},{"question":"# Coding Assessment Question Scenario: You are working as a software developer at a logistics company. You are tasked with creating a scheduling system that ensures delivery vans are utilized optimally. Delivery vans have a fuel tank capacity, and each delivery route consumes a different amount of fuel. Your goal is to maximize the number of delivery routes a van can complete given its fuel capacity. Task: Write a Python function `max_deliveries(routes, fuel_capacity)` that calculates the maximum number of delivery routes a van can complete without exceeding its fuel capacity. Assume that partial routes are not allowed; the van must have enough fuel to complete a route entirely. **Function Signature**: ```python def max_deliveries(routes: list, fuel_capacity: int) -> int: ``` **Input**: - `routes`: A list of integers where each integer represents the fuel required to complete a delivery route. - `fuel_capacity`: An integer representing the maximum fuel capacity of the delivery van. **Output**: - An integer representing the maximum number of delivery routes the van can complete without exceeding the fuel capacity. **Constraints**: - All values in `routes` are positive integers. - `fuel_capacity` is a non-negative integer. **Edge Cases to Handle**: - If `fuel_capacity` is zero, the function should return 0 as the van can\'t complete any routes. - If any value in the `routes` list is negative, raise a `ValueError` with an appropriate message. **Examples**: ```python print(max_deliveries([10, 20, 30], 40)) # Expected Output: 2 print(max_deliveries([5, 10, 15, 20], 35)) # Expected Output: 3 print(max_deliveries([5, 10, 20], 25)) # Expected Output: 2 print(max_deliveries([25, 20, 10], 15)) # Expected Output: 1 print(max_deliveries([5, 10], 0)) # Expected Output: 0 ```","solution":"def max_deliveries(routes, fuel_capacity): Calculates the maximum number of delivery routes a van can complete without exceeding its fuel capacity. Parameters: routes (list): A list of integers where each integer represents fuel required to complete a delivery route. fuel_capacity (int): The maximum fuel capacity of the delivery van. Returns: int: Maximum number of delivery routes the van can complete. if fuel_capacity <= 0: return 0 if any(route < 0 for route in routes): raise ValueError(\\"All route values must be non-negative.\\") routes.sort() total_routes = 0 current_fuel = 0 for route in routes: if current_fuel + route > fuel_capacity: break current_fuel += route total_routes += 1 return total_routes"},{"question":"# Question: Tournament Winner Prediction You are tasked with implementing a function that predicts the winner of a tournament based on a series of match results. Each match result will indicate the winner and the loser. The function should return the name of the player who wins the most matches. Specifications: - **Function Name**: `tournament_winner` - **Input**: - `matches` (List of Tuples): Each tuple contains two elements - the winner\'s name (str) followed by the loser\'s name (str) for each match. - **Output**: - A string representing the name of the player with the most wins. Constraints: - The length of the list `matches` will be between 1 and 1000 inclusive. - Each player\'s name in the list `matches` will be a non-empty string consisting of letters and spaces, and will be at most 100 characters long. - No ties occur: there is always one player with the highest number of wins. Example: ```python >>> tournament_winner([(\\"Alice\\", \\"Bob\\"), (\\"Alice\\", \\"Charlie\\"), (\\"Bob\\", \\"Charlie\\")]) \\"Alice\\" >>> tournament_winner([(\\"Dave\\", \\"Eve\\"), (\\"Eve\\", \\"Mallory\\"), (\\"Eve\\", \\"Dave\\"), (\\"Mallory\\", \\"Dave\\")]) \\"Eve\\" >>> tournament_winner([(\\"Tom\\", \\"Jerry\\"), (\\"Mickey\\", \\"Donald\\"), (\\"Jerry\\", \\"Mickey\\"), (\\"Tom\\", \\"Donald\\")]) \\"Tom\\" ``` Instructions: 1. Analyze the given problem to understand how to track and compare the number of wins for each player. 2. Implement the `tournament_winner` function as specified. 3. Ensure the function correctly identifies and returns the player with the most wins for various test cases. Ensure efficient computation appropriate for the provided constraints, and handle edge cases such as variances in the number of matches or evenly distributed wins (except for the guarantee that there is always one clear winner).","solution":"def tournament_winner(matches): Determines the player with the most wins in the given tournament. :param matches: List of tuples, where each tuple indicates the winner and the loser of a match. :return: String representing the name of the player with the most wins. win_count = {} for winner, loser in matches: if winner in win_count: win_count[winner] += 1 else: win_count[winner] = 1 return max(win_count, key=win_count.get)"},{"question":"# Replace Negative Numbers with Zero You are given a 2D list of integers. Write a function `replace_negatives` that modifies this list such that any negative number is replaced by zero. Ensure the original structure of the 2D list is preserved. # Constraints: - The main list will contain between 1 and 100 sublists. - Each sublist will contain between 0 and 100 integers. - Integer values will be in the range -1000 to 1000. # Input Format: - A 2D list of integers. # Output Format: - The same 2D list where all negative values have been replaced with zero. ```python def replace_negatives(matrix: list[list[int]]) -> list[list[int]]: Replace negative numbers in a 2D list with zero. :param matrix: List of lists of integers :return: Modified list with negatives replaced by zero >>> replace_negatives([[1, -2, 3], [-4, 5], [6, -7, 8], []]) [[1, 0, 3], [0, 5], [6, 0, 8], []] >>> replace_negatives([[-10, 20], [30, -40]]) [[0, 20], [30, 0]] >>> replace_negatives([[0, 0], [-1, -1]]) [[0, 0], [0, 0]] >>> replace_negatives([[]]) [[]] >>> replace_negatives([[100, -500, 400], [-300, 200, -100]]) [[100, 0, 400], [0, 200, 0]] for i in range(len(matrix)): for j in range(len(matrix[i])): if matrix[i][j] < 0: matrix[i][j] = 0 return matrix ```","solution":"def replace_negatives(matrix: list[list[int]]) -> list[list[int]]: Replace negative numbers in a 2D list with zero. :param matrix: List of lists of integers :return: Modified list with negatives replaced by zero >>> replace_negatives([[1, -2, 3], [-4, 5], [6, -7, 8], []]) [[1, 0, 3], [0, 5], [6, 0, 8], []] >>> replace_negatives([[-10, 20], [30, -40]]) [[0, 20], [30, 0]] >>> replace_negatives([[0, 0], [-1, -1]]) [[0, 0], [0, 0]] >>> replace_negatives([[]]) [[]] >>> replace_negatives([[100, -500, 400], [-300, 200, -100]]) [[100, 0, 400], [0, 200, 0]] for i in range(len(matrix)): for j in range(len(matrix[i])): if matrix[i][j] < 0: matrix[i][j] = 0 return matrix"},{"question":"# Anagram Groups Sorting Challenge You have been given a list of strings and tasked with grouping all the anagrams together. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once. Your function should sort these groups of anagrams lexicographically and return the grouped anagrams sorted by the first element of each group. Function Signature ```python def group_anagrams(words: List[str]) -> List[List[str]]: ``` Input - `words`: A list of strings, where each string may consist of lowercase English letters only. Output - Returns a list of lists of strings, where each sublist contains anagrams grouped together, and sublists are sorted lexicographically. Constraints - All strings in the input list are non-empty and consist of lowercase English letters. Examples ```python assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"ate\\", \\"eat\\", \\"tea\\"], [\\"bat\\"], [\\"nat\\", \\"tan\\"]] assert group_anagrams([\\"\\"]) == [[\\"\\"]] assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] assert group_anagrams([\\"looped\\", \\"poodle\\", \\"hello\\", \\"ollhe\\"]) == [[\\"hello\\", \\"ollhe\\"], [\\"looped\\", \\"poodle\\"]] assert group_anagrams([\\"racecar\\", \\"racerac\\", \\"abc\\", \\"bac\\", \\"cab\\"]) == [[\\"abc\\", \\"bac\\", \\"cab\\"], [\\"racecar\\", \\"racerac\\"]] ``` Additional Context To solve this problem: 1. Iterate through each word in the input list and compute a signature of the word (e.g., a sorted tuple of characters). 2. Use a dictionary to group words by their signature. 3. Sort each anagram group and then sort the list of groups by the first element of each group. Ensure the efficiency of your solution by minimizing unnecessary computations and leveraging data structures like dictionaries for fast lookups and groupings.","solution":"from typing import List from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: anagram_dict = defaultdict(list) # Group words by their anagram signature (sorted characters) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) # Sort each group lexicographically sorted_groups = [sorted(group) for group in anagram_dict.values()] # Sort the groups by the first element of each group sorted_groups.sort(key=lambda group: group[0]) return sorted_groups # Example usage #print(group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]))"},{"question":"# Problem Statement A famous mathematical game consists of constructing a sequence of integers from a given starting number and a set of allowed operations. You need to determine the minimum number of operations needed to transform a given number `n` to 1, using only the allowed operations: subtracting 1, dividing by 2 (if even), and dividing by 3 (if divisible by 3). Implement a function `fewest_operations(n: int) -> int`, which computes the minimum number of operations required to reduce the number `n` to 1. # Input - An integer `n` (1 ≤ `n` ≤ 10^6), which is the number you want to transform to 1. # Output - An integer representing the minimum number of operations needed to transform `n` to 1. # Requirements - You must use a dynamic programming approach to solve this problem. - Ensure your solution is efficient and handles large values gracefully. # Example ```python >>> fewest_operations(10) 3 Explanation: 10 → 9 → 3 → 1 >>> fewest_operations(15) 5 Explanation: 15 → 5 → 4 → 2 → 1 >>> fewest_operations(1) 0 Explanation: Since the number is already 1, no operations are needed. ``` # Constraints - Your solution should ideally have a time complexity of O(n). - Space complexity should be managed efficiently and should also be O(n). Write your code below: ```python def fewest_operations(n: int) -> int: if n == 1: return 0 dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n] # Example usage if __name__ == \\"__main__\\": print(fewest_operations(10)) print(fewest_operations(15)) print(fewest_operations(1)) ``` This problem tests dynamic programming and optimization, ensuring that the candidate can create an efficient solution for reducing a number to a lower value using specific operations. It matches the style, complexity, and requirements of the original set provided.","solution":"def fewest_operations(n: int) -> int: if n == 1: return 0 dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"# Question You are tasked with developing a pathfinding algorithm using Breadth-First Search (BFS) for a grid-based map. The map consists of open spaces and obstacles, and your goal is to determine the shortest path from a starting point to an ending point. # Requirements Your function should: 1. Represent the grid as a 2D list where `0` indicates an open space and `1` indicates an obstacle. 2. Implement BFS to navigate through the grid. 3. Return a list of coordinates representing the shortest path from the start to the end point, inclusive. 4. If there is no valid path, return an empty list. # Function Signature ```python def find_shortest_path(grid: [[int]], start: (int, int), end: (int, int)) -> [(int, int)]: Find the shortest path in a grid using BFS. :param grid: 2D list representing the grid :param start: Tuple (int, int) representing the starting coordinates :param end: Tuple (int, int) representing the ending coordinates :return: List of tuples representing the shortest path coordinates pass ``` # Input * `grid` (List of List of int): A 2D grid of integers where `0` is an open space and `1` is an obstacle. * `start` (Tuple of int): The starting coordinates in the form (row, column). * `end` (Tuple of int): The ending coordinates in the form (row, column). # Output * Returns a list of tuples representing the coordinates of the shortest path from start to end. If no path exists, return an empty list. # Constraints * The grid will be a non-empty 2D list. * There will be at least one path from start to end in valid cases. * The starting and ending points will always be open spaces (`0`). # Sample Scenario Given the grid: ``` [ [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [0, 1, 0, 0] ] ``` Start point: `(0, 0)` and End point: `(3, 3)` Your function should return the shortest path: ``` [(0,0), (0,1), (1,1), (2,1), (2,2), (2,3), (3,3)] ```","solution":"from collections import deque def find_shortest_path(grid, start, end): Find the shortest path in a grid using BFS. :param grid: 2D list representing the grid :param start: Tuple (int, int) representing the starting coordinates :param end: Tuple (int, int) representing the ending coordinates :return: List of tuples representing the shortest path coordinates # Directions for moving in the grid: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(start[0], start[1], [start])]) visited = set() visited.add(start) while queue: x, y, path = queue.popleft() # Check if we\'ve reached the end if (x, y) == end: return path # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0: if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) # No path found return []"},{"question":"# Question: Implement Depth-First Search with Preorder and Postorder Traversal You are given the task of implementing Depth-First Search (DFS) for a graph such that it returns two lists: one for the preorder traversal and one for the postorder traversal of the graph starting from a given node. Requirements 1. Implement a method `dfs_pre_post(self, start_vertex: int) -> tuple[list[int], list[int]]` inside the `Graph` class. 2. The method should return a tuple containing two lists: - The first list is the preorder traversal of the nodes. - The second list is the postorder traversal of the nodes. 3. If a node is not reachable from the start_vertex, it should not be included in either traversal list. Example ```python >>> g = Graph() >>> g.add_edge(0, 1) >>> g.add_edge(0, 2) >>> g.add_edge(1, 2) >>> g.add_edge(2, 3) >>> result = g.dfs_pre_post(0) >>> result[0] # Preorder traversal [0, 1, 2, 3] >>> result[1] # Postorder traversal [3, 2, 1, 0] ``` Constraints 1. The graph does not include any negative weights. 2. The graph is represented using an adjacency list. 3. The vertex identifiers are non-negative integers.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_edge(self, v, w): if v not in self.adjacency_list: self.adjacency_list[v] = [] self.adjacency_list[v].append(w) if w not in self.adjacency_list: self.adjacency_list[w] = [] def dfs_pre_post(self, start_vertex): preorder = [] postorder = [] visited = set() def dfs(v): visited.add(v) preorder.append(v) for neighbor in self.adjacency_list.get(v, []): if neighbor not in visited: dfs(neighbor) postorder.append(v) dfs(start_vertex) return (preorder, postorder)"},{"question":"# Array Rotation Problem Statement You are required to implement a function that takes in a list of integers and a positive integer `k`, and returns a new list where the elements have been rotated to the right by `k` positions. Function Signature ```python def rotate_array(nums: list, k: int) -> list: ``` Input - `nums` (list): a list of integers, where 0 <= len(nums) <= 10^5 - `k` (int) : the number of positions to rotate the list to the right, where 0 <= k <= 10^5 Output - A list of integers that has been rotated to the right by `k` positions. Constraints - If `k` is negative, raise a `ValueError` with the message \\"the value of k must be non-negative\\". - If `k` is not an integer, raise a `TypeError` with an appropriate message like \\"k must be a positive integer\\". - The function should handle cases where `k` is larger than the length of the list by using appropriate modulo operations. Examples ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 3) [1, 2, 3] >>> rotate_array([], 3) [] >>> rotate_array([1], 0) [1] >>> rotate_array([1], -1) Traceback (most recent call last): ... ValueError: the value of k must be non-negative >>> rotate_array([1, 2, 3], \\"3\\") Traceback (most recent call last): ... TypeError: \'str\' object cannot be interpreted as an integer >>> rotate_array([1, 2, 3], 2.5) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer ```","solution":"def rotate_array(nums: list, k: int) -> list: Rotates the elements of the list to the right by k positions. Parameters: nums (list): A list of integers k (int): Number of positions to rotate the list to the right Returns: list: Rotated list of integers if not isinstance(k, int): raise TypeError(\\"k must be a positive integer\\") if k < 0: raise ValueError(\\"the value of k must be non-negative\\") n = len(nums) if n == 0: return [] k = k % n # Handle the cases where k is larger than the length of nums return nums[-k:] + nums[:-k]"},{"question":"# Placeholder Transformation A content management system (CMS) uses placeholders in text documents to dynamically insert user-specific values. Placeholders are strings enclosed in double braces, like `{{name}}`, `{{email}}`, or `{{address}}`. Write a function `transform_placeholders` that takes a template string containing placeholders and a dictionary mapping placeholder names to their corresponding values. The function should replace each placeholder in the template with its associated value from the dictionary. # Input - A string `template` containing the text with placeholders enclosed in double braces. - A dictionary `values` where keys are placeholders (without braces) and values are the corresponding replacement strings. # Output - A string where all placeholders in the template have been replaced by their corresponding values from the dictionary. If a placeholder in the template does not have a corresponding value in the dictionary, it should be left unchanged. # Constraints - The length of `template` will not exceed 10,000 characters. - Placeholders within the template will only use alphabetic characters and are case-sensitive. - The size of the dictionary `values` will not exceed 1,000 entries. - The length of each key in the dictionary will not exceed 50 characters. - The length of each value in the dictionary will not exceed 1,000 characters. # Examples ```python >>> transform_placeholders(\\"Hello, {{name}}!\\", {\\"name\\": \\"Alice\\"}) \\"Hello, Alice!\\" >>> transform_placeholders(\\"Your email is {{email}}.\\", {\\"email\\": \\"alice@example.com\\"}) \\"Your email is alice@example.com.\\" >>> transform_placeholders(\\"Hello, {{name}}! Your email is {{email}} and your address is {{address}}.\\", {\\"name\\": \\"John\\", \\"email\\": \\"john@example.com\\", \\"address\\": \\"123 Main St\\"}) \\"Hello, John! Your email is john@example.com and your address is 123 Main St.\\" >>> transform_placeholders(\\"Welcome, {{username}}. You have {{count}} new messages.\\", {\\"username\\": \\"user123\\", \\"count\\": \\"5\\"}) \\"Welcome, user123. You have 5 new messages.\\" >>> transform_placeholders(\\"Welcome, {{user}}.\\", {\\"username\\": \\"user123\\"}) \\"Welcome, {{user}}.\\" ``` # Notes In solving this problem, ensure that placeholders are accurately and efficiently identified and replaced with correct values. Handle cases where placeholders in the template might not be covered by the dictionary.","solution":"def transform_placeholders(template, values): Replaces placeholders in the template with corresponding values from the dictionary. :param template: a string containing the text with placeholders enclosed in double braces :param values: a dictionary mapping placeholder names to their corresponding values :return: a string where all placeholders in the template have been replaced by their corresponding values def replace_match(match): placeholder = match.group(1) return values.get(placeholder, match.group(0)) import re pattern = re.compile(r\'{{(w+)}}\') return pattern.sub(replace_match, template) # Examples of usage: # print(transform_placeholders(\\"Hello, {{name}}!\\", {\\"name\\": \\"Alice\\"})) # print(transform_placeholders(\\"Your email is {{email}}.\\", {\\"email\\": \\"alice@example.com\\"})) # print(transform_placeholders(\\"Hello, {{name}}! Your email is {{email}} and your address is {{address}}.\\", # {\\"name\\": \\"John\\", \\"email\\": \\"john@example.com\\", \\"address\\": \\"123 Main St\\"})) # print(transform_placeholders(\\"Welcome, {{username}}. You have {{count}} new messages.\\", # {\\"username\\": \\"user123\\", \\"count\\": \\"5\\"})) # print(transform_placeholders(\\"Welcome, {{user}}.\\", {\\"username\\": \\"user123\\"}))"},{"question":"# Matrix Transpose Checker **Objective:** You need to write a function to determine whether a given matrix is equal to its transpose. **Function Signature:** ```python def is_symmetric(matrix: list[list[int]]) -> bool: # Your implementation here ``` **Input:** - `matrix`: A two-dimensional list of integers representing the matrix to be checked. **Output:** - Returns a boolean: * `True` if the given matrix is equal to its transpose. * `False` otherwise. **Constraints:** 1. The matrix will be a square matrix (number of rows == number of columns). 2. The size of the matrix `n` (i.e., both the number of rows and columns) will be in the range [1, 1000]. 3. The elements of the matrix will be integers in the range [-10^9, 10^9]. **Instructions:** 1. Iterate through the matrix and compare each element with its corresponding element in the transpose. 2. Ensure the function runs efficiently within the given constraints. # Example Given the following configuration: Matrix: ``` [ [1, 2, 3], [2, 4, 5], [3, 5, 6] ] ``` **Returns:** `True` Given another configuration: Matrix: ``` [ [1, 0, 3], [0, 4, 5], [7, 5, 6] ] ``` **Returns:** `False` Implement the `is_symmetric` function in Python, and perform thorough testing to ensure it operates correctly on all valid inputs. *Note: You can use additional helper functions if needed to facilitate the implementation.*","solution":"def is_symmetric(matrix: list[list[int]]) -> bool: This function checks whether a given square matrix is symmetric (equal to its transpose). Parameters: matrix (list[list[int]]): Two-dimensional list representing a square matrix. Returns: bool: True if the matrix is symmetric, False otherwise. n = len(matrix) for i in range(n): for j in range(i + 1, n): if matrix[i][j] != matrix[j][i]: return False return True"},{"question":"# Find the Largest Island You are given a grid of `1`s and `0`s, where `1` represents land and `0` represents water. An island is defined as a group of `1`s connected vertically or horizontally (not diagonally). Compute the area of the largest island in the grid. # Input Format - `grid`: A 2D list of integers (`1` and `0`), where `1` indicates land, and `0` indicates water. # Output Format - Return an integer representing the area of the largest island. # Constraints - The dimensions of `grid` are `m x n` with `1 <= m, n <= 1000`. - There will be at least one `1` in the grid. # Example ```python grid = [[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 0, 1], [0, 0, 0, 1, 1]] # There are three islands. The sizes are: # - The first island (top-left) has area 4. # - The second island (top-right) has area 1. # - The third island (bottom-right) has area 4. # The largest island has an area of 4. print(largest_island(grid)) # Output: 4 ``` # Implementation ```python def largest_island(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark the cell as visited area = 1 area += dfs(i + 1, j) area += dfs(i - 1, j) area += dfs(i, j + 1) area += dfs(i, j - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area ``` Your task is to implement the function `largest_island` that computes the area of the largest island in the given grid.","solution":"def largest_island(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark the cell as visited area = 1 area += dfs(i + 1, j) area += dfs(i - 1, j) area += dfs(i, j + 1) area += dfs(i, j - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"# Coding Assessment Question Scenario: You are building a library system that keeps track of books that users borrow and return. The library management software needs a feature to generate a list of books that are overdue based on the current date and provide the total penalty based on the number of overdue days for all books. Task: Implement a function that calculates the overdue books and total penalty. The function needs to identify which books are overdue based on their due dates compared to the current date and then calculate the penalty for each overdue book. The penalty is calculated as 1.00 per day for each day the book is overdue. Function: ```python from datetime import datetime from typing import List, Tuple def calculate_overdue_books(current_date: datetime, borrowed_books: List[Tuple[str, datetime, datetime]]) -> Tuple[List[str], float]: Calculates the list of overdue books and the total penalty. Args: current_date (datetime): The current date. borrowed_books (List[Tuple[str, datetime, datetime]]): A list of tuples where each tuple contains (book_title, borrow_date, due_date). Returns: Tuple[List[str], float]: A tuple containing a list of overdue book titles and the total penalty for overdue books. ``` Input: * `current_date` (datetime): The current date. * `borrowed_books` (List[Tuple[str, datetime, datetime]]): A list of tuples. Each tuple contains: * `book_title` (str): The title of the book. * `borrow_date` (datetime): The date when the book was borrowed. * `due_date` (datetime): The due date for returning the book. Output: * A tuple containing: * A list of overdue book titles. * The total penalty for all overdue books in dollars. Constraints: * `current_date` and `due_date` are valid datetime objects. * `borrowed_books` list is non-empty and contains valid tuples. * All due dates are in the past relative to `current_date`. Example: ```python from datetime import datetime borrowed_books = [ (\\"The Great Gatsby\\", datetime(2023, 1, 10), datetime(2023, 2, 10)), (\\"1984\\", datetime(2023, 2, 15), datetime(2023, 3, 15)), (\\"To Kill a Mockingbird\\", datetime(2023, 3, 1), datetime(2023, 4, 1)) ] current_date = datetime(2023, 4, 10) overdue_books, total_penalty = calculate_overdue_books(current_date, borrowed_books) print(overdue_books) # Expected: [\\"1984\\", \\"To Kill a Mockingbird\\"] print(total_penalty) # Expected: 36.00 (The penalties will vary based on the actual overdue days) ``` The function should correctly compute the list of overdue books and the overall penalty, reflecting accurate overdue days.","solution":"from datetime import datetime from typing import List, Tuple def calculate_overdue_books(current_date: datetime, borrowed_books: List[Tuple[str, datetime, datetime]]) -> Tuple[List[str], float]: overdue_books = [] total_penalty = 0.0 for book_title, borrow_date, due_date in borrowed_books: overdue_days = (current_date - due_date).days if overdue_days > 0: overdue_books.append(book_title) total_penalty += overdue_days return overdue_books, total_penalty"},{"question":"# Question: Counting Nested Parentheses Depth You are tasked with developing a Python function that computes the maximum nesting depth of parentheses in a given string. Function Signature ```python def max_parentheses_depth(s: str) -> int: pass ``` Input: - `s` (str): A string containing the parentheses to be analyzed. Output: - An integer representing the maximum depth of nested parentheses in the given string. Constraints: - The input string `s` can contain characters other than parentheses. - If there are no parentheses, the function should return 0. - The function should handle empty strings gracefully. Sample Execution: ```python print(max_parentheses_depth(\\"(a+(b*c)) + ((d/e)+f)\\")) # Expected Output: 2 print(max_parentheses_depth(\\"This is a test.\\")) # Expected Output: 0 print(max_parentheses_depth(\\"(1+(2*3)+((8)/4))+1\\")) # Expected Output: 3 print(max_parentheses_depth(\\"((())(()))\\")) # Expected Output: 3 print(max_parentheses_depth(\\")(\\")) # Expected Output: 1 (considering unbalanced parentheses as per depth) ``` Background: This exercise is meant to test your understanding of: - Analyzing and processing string data. - Calculating nested structures. - Handling edge cases and different input scenarios appropriately. - Efficiently managing iterations and maintaining counters to derive the solution. The goal is to create a robust and efficient solution that correctly identifies the nesting levels of parentheses, regardless of the presence of other characters.","solution":"def max_parentheses_depth(s: str) -> int: max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == \')\': if current_depth > 0: current_depth -= 1 return max_depth"},{"question":"# Problem Statement Valid Sudoku Checker You are given an NxN Sudoku board where some cells may already be filled with numbers (1 to N), and some cells may be empty (represented by a dot \'.\'). Your task is to determine if the given Sudoku board configuration is valid. A Sudoku board is valid if: 1. Each row contains the numbers 1 to N exactly once or leaves cells empty. 2. Each column contains the numbers 1 to N exactly once or leaves cells empty. 3. Each of the small sub-grids (which are divided into sqrt(N) x sqrt(N) regions) contain the numbers 1 to N exactly once or leaves cells empty. **Requirements**: * Implement a function to check the validity of the provided Sudoku board configuration. * Assume that a valid NxN Sudoku board will have N to be a perfect square (e.g., 4, 9, 16). **Input and Output Formats**: * Function Signature: `def is_valid_sudoku(board: List[List[str]]) -> bool:` * **Input**: A 2D list `board` representing the NxN Sudoku board. * **Output**: Return `True` if the board configuration is valid, otherwise return `False`. **Constraints**: * The input `board` is a square grid with dimensions NxN. * N will be a perfect square between 1 and 16 (both inclusive). * The board will only contain numbers from \'1\' to \'N\' and the \'.\' character representing empty cells. **Edge Cases to Consider**: * Smallest possible board (N=1 where the only cell could be empty or a single number). * Fully filled valid or invalid Sudoku board. **Scenario or Context**: Imagine you are developing a Sudoku puzzle game. A key feature in the game is to provide immediate feedback to the player on whether their current board configuration is valid as they solve the puzzle. Ensuring the correctness of this validation is paramount for a smooth gameplay experience. **Performance Requirements**: * The solution should check the validity in O(N^2) time complexity, efficiently managing the constraints provided by the NxN Sudoku board. Example ```python >>> board_4x4 = [ [\\"1\\", \\"2\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\"2\\", \\".\\"], [\\".\\", \\"4\\", \\".\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"3\\"] ] >>> is_valid_sudoku(board_4x4) True >>> board_9x9 = [ [\\"5\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] >>> is_valid_sudoku(board_9x9) True >>> invalid_board_9x9 = [ [\\"8\\", \\"3\\", \\".\\", \\".\\", \\"7\\", \\".\\", \\".\\", \\".\\", \\".\\"], [\\"6\\", \\".\\", \\".\\", \\"1\\", \\"9\\", \\"5\\", \\".\\", \\".\\", \\".\\"], [\\".\\", \\"9\\", \\"8\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\"], [\\"8\\", \\".\\", \\".\\", \\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\"3\\"], [\\"4\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\"3\\", \\".\\", \\".\\", \\"1\\"], [\\"7\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\".\\", \\".\\", \\".\\", \\"6\\"], [\\".\\", \\"6\\", \\".\\", \\".\\", \\".\\", \\".\\", \\"2\\", \\"8\\", \\".\\"], [\\".\\", \\".\\", \\".\\", \\"4\\", \\"1\\", \\"9\\", \\".\\", \\".\\", \\"5\\"], [\\".\\", \\".\\", \\".\\", \\".\\", \\"8\\", \\".\\", \\".\\", \\"7\\", \\"9\\"] ] >>> is_valid_sudoku(invalid_board_9x9) False # \'8\' is repeated in the first row ```","solution":"from typing import List import math def is_valid_sudoku(board: List[List[str]]) -> bool: N = len(board) sqrtN = int(math.sqrt(N)) def is_valid_group(group: List[str]) -> bool: elements = [x for x in group if x != \'.\'] return len(elements) == len(set(elements)) # Check rows for row in board: if not is_valid_group(row): return False # Check columns for col in range(N): column = [board[row][col] for row in range(N)] if not is_valid_group(column): return False # Check sub-grids for r in range(0, N, sqrtN): for c in range(0, N, sqrtN): sub_grid = [ board[i][j] for i in range(r, r + sqrtN) for j in range(c, c + sqrtN) ] if not is_valid_group(sub_grid): return False return True"},{"question":"# **Task Scheduling with Deadlines** You are asked to implement a task scheduling algorithm where each task has a specified duration and deadline. The goal is to maximize the number of tasks that can be completed before their respective deadlines. # Task **Implement the scheduling algorithm**: Write a function that takes a list of tasks, where each task is represented as a tuple containing the duration and deadline, and returns the maximum number of tasks that can be completed before their deadlines. # Function Signature Implement the function using the signature below: ```python def max_tasks(tasks: list[tuple[int, int]]) -> int: pass ``` # Input - **tasks**: A list of tuples where each tuple `(d, t)` represents a task with duration `d` (an integer) and deadline `t` (an integer). # Output - Return an integer representing the maximum number of tasks that can be completed before their deadlines. # Constraints - `1 <= len(tasks) <= 10^3` - `1 <= d, t <= 10^6` # Example ```python tasks = [(3, 9), (2, 4), (1, 6), (5, 10)] ``` - Task 1: duration = 3, deadline = 9 - Task 2: duration = 2, deadline = 4 - Task 3: duration = 1, deadline = 6 - Task 4: duration = 5, deadline = 10 Expected Output: `3` # Notes - Tasks are to be prioritized based on their deadlines to maximize the number of tasks completed on time. - Consider using a greedy approach where you schedule the shortest task that can be completed before its deadline at each step.","solution":"def max_tasks(tasks): # Sort the tasks based on their deadlines tasks.sort(key=lambda x: x[1]) current_time = 0 count = 0 for duration, deadline in tasks: if current_time + duration <= deadline: current_time += duration count += 1 return count"},{"question":"# Problem Description You are provided with a set of items, each with a weight and a value, and a maximum capacity for a knapsack. Your task is to determine the maximum total value that can be obtained by including a subset of these items in the knapsack without exceeding the capacity. This problem is known as the Knapsack Problem, which can be solved using dynamic programming. # Input A function `knapsack(items: list[tuple[int, int]], capacity: int) -> int` that takes: - `items`: A list of tuples where each tuple represents an item `(value, weight)`. - `capacity`: An integer representing the maximum capacity of the knapsack. # Output The function should return an integer representing the maximum total value of items that can be included in the knapsack without exceeding the capacity. # Constraints * The number of items, `n`, is between `1` and `100`. * The value and weight of each item are between `1` and `1000`. * The capacity of the knapsack is between `1` and `10000`. # Example ```python assert knapsack([(60, 10), (100, 20), (120, 30)], 50) == 220 assert knapsack([(10, 1), (20, 2), (30, 3)], 3) == 30 assert knapsack([(10, 5), (40, 4), (30, 6), (50, 3)], 10) == 90 ``` # Explanation 1. **Input**: `items = [(60, 10), (100, 20), (120, 30)]`, `capacity = 50` **Output**: `220` **Explanation**: The optimal set of items to include in the knapsack are the first two items with values 60 and 120, resulting in a total value of 220. 2. **Input**: `items = [(10, 1), (20, 2), (30, 3)]`, `capacity = 3` **Output**: `30` **Explanation**: The optimal set of items to include in the knapsack is the third item with value 30. 3. **Input**: `items = [(10, 5), (40, 4), (30, 6), (50, 3)]`, `capacity = 10` **Output**: `90` **Explanation**: The optimal set of items to include in the knapsack are the second and fourth items with values 40 and 50, resulting in a total value of 90. You need to ensure your implementation uses an optimized dynamic programming approach to handle the potential large input sizes efficiently.","solution":"def knapsack(items, capacity): Solves the knapsack problem using dynamic programming. Parameters: items (list of tuples): A list where each tuple represents an item as (value, weight). capacity (int): The maximum weight capacity of the knapsack. Returns: int: The maximum total value of items that can be included in the knapsack. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(1, capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Question: Number Matrix Operations You are tasked with implementing a set of functions to perform operations on a square matrix of numbers. A square matrix is a two-dimensional array where the number of rows is equal to the number of columns. Implement the Following Functions: **1. Function `transpose_matrix(matrix: list) -> list`:** * **Input**: A list of lists representing a square matrix of integers or floating-point numbers. * **Output**: A new list of lists representing the transpose of the input matrix. * **Constraints**: * Raise a `ValueError` for invalid or empty input. **2. Function `trace_matrix(matrix: list) -> float`:** * **Input**: A list of lists representing a square matrix of integers or floating-point numbers. * **Output**: A floating-point number representing the trace of the matrix (the sum of the diagonal elements). * **Constraints**: * Raise a `ValueError` for invalid or empty input. Example ```python >>> transpose_matrix([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose_matrix([[5, -1, 3], [2, 0, 7], [9, 4, 8]]) [[5, 2, 9], [-1, 0, 4], [3, 7, 8]] >>> transpose_matrix([[1]]) [[1]] >>> trace_matrix([[1, 2], [3, 4]]) 5.0 >>> trace_matrix([[5, -1, 3], [2, 0, 7], [9, 4, 8]]) 13.0 >>> trace_matrix([[1]]) 1.0 >>> trace_matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0.0 >>> trace_matrix([[1, 2, 3], [4, 5, 6]]) ValueError: Invalid matrix ``` Notes: * Ensure the matrix is square with a valid structure before performing operations, and handle improper input gracefully. * The trace of an empty matrix or a non-square matrix should raise a `ValueError`. Performance Requirements * Your implementations should be O(n^2) in time complexity and O(n^2) in space complexity. **Good Luck!**","solution":"def transpose_matrix(matrix: list) -> list: Returns the transpose of the given square matrix. # Check if matrix is valid if not matrix or not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\'Invalid matrix\') n = len(matrix) # Check if matrix is square if any(len(row) != n for row in matrix): raise ValueError(\'Invalid matrix\') return [[matrix[j][i] for j in range(n)] for i in range(n)] def trace_matrix(matrix: list) -> float: Returns the trace of the given square matrix. # Check if matrix is valid if not matrix or not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): raise ValueError(\'Invalid matrix\') n = len(matrix) # Check if matrix is square if any(len(row) != n for row in matrix): raise ValueError(\'Invalid matrix\') # Sum diagonal elements return sum(matrix[i][i] for i in range(n))"},{"question":"# Coding Question: Signal Denoising with Moving Average Filter Background In digital signal processing, a moving average filter is used to smooth data and reduce noise by averaging a number of adjacent signal points. This technique is particularly useful in removing random spikes and fluctuations from a noisy signal. Objective Implement a function that performs signal denoising using a simple moving average filter. The function should receive a list of signal data points and a window size for the moving average. Function Signature ```python def moving_average_filter(signal: List[float], window_size: int) -> List[float]: ``` Input 1. **signal**: A list of floats representing the raw signal data. * Constraints: 1 ≤ len(signal) ≤ 10^5; -1000 ≤ signal[i] ≤ 1000 2. **window_size**: An integer representing the size of the moving window used to calculate the average. * Constraints: 1 ≤ window_size ≤ len(signal) Output Return a list of floats representing the smoothed signal after applying the moving average filter. Examples ```python >>> moving_average_filter([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] >>> moving_average_filter([10, 20, 30, 40, 50], 2) [15.0, 25.0, 35.0, 45.0] >>> moving_average_filter([-1, 0, 1, 0, -1], 1) [-1.0, 0.0, 1.0, 0.0, -1.0] ``` Note * Use a simple moving average filter where each point in the output is the average of the points in the input within the window centered on that point. * If the window size causes the filter to overlap the edge of the signal, truncate the window at the edges. * Ensure your implementation handles edge cases and adheres to provided constraints.","solution":"from typing import List def moving_average_filter(signal: List[float], window_size: int) -> List[float]: Applies a simple moving average filter to the input signal. Parameters: signal (List[float]): The input signal data points. window_size (int): The size of the moving average window. Returns: List[float]: The denoised signal after applying the moving average filter. # Length of the signal n = len(signal) # List to store the resulting smoothed signal smoothed_signal = [] # Compute the moving average filter for i in range(n - window_size + 1): window = signal[i:i + window_size] average = sum(window) / window_size smoothed_signal.append(average) return smoothed_signal"},{"question":"# Question: You are implementing a numeric system in which you need to check if a number is \\"perfect.\\" A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Write a Python function `is_perfect_number` that returns `True` if the number is perfect, and `False` otherwise. Function Signature ```python def is_perfect_number(n: int) -> bool: ``` # Input - `n`: A positive integer (`1 <= n <= 10^6`). # Output - Returns `True` if `n` is a perfect number. - Returns `False` otherwise. # Constraints - The input integer `n` will always be within the range `[1, 10^6]`. # Examples ```python assert is_perfect_number(6) == True # 6 = 1 + 2 + 3 assert is_perfect_number(28) == True # 28 = 1 + 2 + 4 + 7 + 14 assert is_perfect_number(12) == False # 12 != 1 + 2 + 3 + 4 + 6 assert is_perfect_number(1) == False # 1 has no proper divisors ``` # Requirements 1. Ensure the function handles the smallest input (`n = 1`) correctly, as 1 does not have any proper divisors. 2. The function should be optimized for efficiency given the upper constraint of `10^6`. 3. Validate the input to accept only positive integers within the specified range, raising a `ValueError` for invalid inputs. # Scenario You are working on a project involving numerical analysis and need to frequently check for perfect numbers in a large data set. Implement this function to assist in efficiently identifying perfect numbers during your computations.","solution":"def is_perfect_number(n: int) -> bool: Returns True if n is a perfect number, otherwise False. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. :param n: int, a positive integer (1 <= n <= 10^6) :return: bool if n <= 1: return False sum_of_divisors = 1 sqrt_n = int(n ** 0.5) for i in range(2, sqrt_n + 1): if n % i == 0: sum_of_divisors += i if i != n // i: sum_of_divisors += n // i return sum_of_divisors == n"},{"question":"# Problem: Longest Unique Subarray **Objective**: Write a function `longest_unique_subarray` that takes a sequence of integers as input and returns the length of the longest subarray where all elements are unique. If the sequence is empty, the function should return 0. **Constraints**: - The input sequence will contain at most (10^5) elements. - Each element of the sequence will be an integer within the range ([-10^5, 10^5]). **Function Signature**: ```python def longest_unique_subarray(nums: Sequence[int]) -> int: pass ``` **Input**: - A sequence of integers `nums` (can be empty). **Output**: - An integer representing the length of the longest subarray with all unique elements. **Examples**: 1. Given the sequence [1, 2, 3, 1, 2, 3], the function should return 3. 2. Given the sequence [5, 1, 3, 5, 2, 3, 4, 1], the function should return 5. 3. Given the sequence [], the function should return 0. 4. Given the sequence [1, 2, 3, 4, 5], the function should return 5. # Hints: - Consider using a sliding window technique with a set to maintain the uniqueness constraint. - Ensure the window is adjusted efficiently when duplicate elements are encountered. Through this problem, you will demonstrate your ability to handle constraints related to array and set operations, and effectively manage edge cases.","solution":"from typing import Sequence def longest_unique_subarray(nums: Sequence[int]) -> int: Returns the length of the longest subarray with all unique elements. :param nums: Sequence of integers. :return: Length of the longest subarray with all unique elements. if not nums: return 0 num_set = set() max_length = 0 left = 0 for right in range(len(nums)): while nums[right] in num_set: num_set.remove(nums[left]) left += 1 num_set.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Evaluate and Sort Student Scores Coding Assessment Question Context You are a developer tasked with creating an automated system for managing and analyzing student grades in a university. One component of this system involves evaluating and sorting students\' scores to assist in grading. Your task is to write a function that can evaluate and sort student scores from multiple subjects. Description Write a function `evaluate_and_sort_scores(students: list[dict]) -> list[dict]` that takes a list of dictionaries representing students and their scores across various subjects, and returns the list of students sorted by their average scores in descending order. Each student dictionary has the following structure: ```python { \\"name\\": str, \\"scores\\": dict[str, float] } ``` # Input - A list of dictionaries, where each dictionary contains: - \\"name\\": a unique string representing the student\'s name. - \\"scores\\": a dictionary with subject names as keys (strings) and subject scores as values (floats). # Output - The input list of students sorted by their average scores in descending order. If two students have the same average score, their original order in the input list should be preserved. # Constraints - The number of students is within the range `[1, 1000]`. - Each student has scores in at least one subject. - Scores for each subject are within the range `[0, 100]`. - Subject names are unique per student but may differ between students. # Example ```python students = [ {\\"name\\": \\"Alice\\", \\"scores\\": {\\"Math\\": 90, \\"Science\\": 80}}, {\\"name\\": \\"Bob\\", \\"scores\\": {\\"Math\\": 70, \\"English\\": 85}}, {\\"name\\": \\"Charlie\\", \\"scores\\": {\\"Science\\": 95, \\"Math\\": 85}} ] sorted_students = evaluate_and_sort_scores(students) # The function should return the list of students sorted by their average scores in descending order # expected output: # [ # {\\"name\\": \\"Charlie\\", \\"scores\\": {\\"Science\\": 95, \\"Math\\": 85}}, # {\\"name\\": \\"Alice\\", \\"scores\\": {\\"Math\\": 90, \\"Science\\": 80}}, # {\\"name\\": \\"Bob\\", \\"scores\\": {\\"Math\\": 70, \\"English\\": 85}} # ] ``` # Notes - Ensure the function handles multiple subjects and varying subject names. - The function should calculate the average score for each student based on their scores across all subjects. - Use stable sorting to maintain the original order in case of tie scores. Implement the `evaluate_and_sort_scores` function to achieve the above requirements.","solution":"def evaluate_and_sort_scores(students): Sort students by their average scores in descending order. Parameters: students (list[dict]): List of dictionaries containing student name and their scores. Returns: list[dict]: Sorted list of students by average score in descending order. for student in students: scores = student[\'scores\'].values() student[\'avg_score\'] = sum(scores) / len(scores) sorted_students = sorted(students, key=lambda x: x[\'avg_score\'], reverse=True) for student in sorted_students: del student[\'avg_score\'] return sorted_students"},{"question":"# Question: Longest Zero Sequence in Binary Representation Write a function `longest_zero_sequence(n: int) -> int` that returns the length of the longest sequence of consecutive zeros in the binary representation of a non-negative integer `n`. Input * An integer `n (0 ≤ n ≤ 10^9)` Output * An integer representing the length of the longest sequence of consecutive zeros in the binary representation of `n`. Constraints * Your function should be efficient in both time and space complexity. Example ```python >>> longest_zero_sequence(9) 2 # Binary representation of 9 is \'1001\', longest sequence of zeros is \'00\' >>> longest_zero_sequence(32) 5 # Binary representation of 32 is \'100000\', longest sequence of zeros is \'00000\' >>> longest_zero_sequence(7) 0 # Binary representation of 7 is \'111\', there are no zeros ``` Note * The binary representation of numbers should be considered without leading zeros. For example, `9` in binary is `1001`, and the longest sequence of consecutive zeros is `00`. By providing this additional question, we ensure it follows the style, complexity, and scope of the given example question, involving efficient computation and string manipulation fundamentals.","solution":"def longest_zero_sequence(n: int) -> int: Returns the length of the longest sequence of consecutive zeros in the binary representation of a non-negative integer n. binary_rep = bin(n)[2:] zero_sequences = binary_rep.split(\'1\') return max(len(seq) for seq in zero_sequences) # Example usage # print(longest_zero_sequence(9)) # Output: 2 # print(longest_zero_sequence(32)) # Output: 5 # print(longest_zero_sequence(7)) # Output: 0"},{"question":"# Palindrome Permutation Your task is to write a function that determines whether the characters of a given string can be rearranged to form a palindrome. The function should return `True` if it is possible to rearrange the characters to form a palindrome, and `False` otherwise. The goal is to assess your ability to handle character counts and understand palindromic structures. Function Signature ```python def can_form_palindrome(s: str) -> bool: pass ``` Input - `s` (string): A string containing the characters you need to evaluate. The string will consist of lowercase alphabetic characters only (\'a\'-\'z\'). Output - Return `True` if the characters of the string can be rearranged to form a palindrome. - Return `False` otherwise. Constraints 1. The length of the string `s` will be between 1 and 10^5 characters. 2. The string will contain only lowercase alphabetic characters. Context A palindrome reads the same backward as forward. For a string to form a palindrome, characters must be symmetric around its center, which implies: - If the string\'s length is even, each character must appear an even number of times. - If the string\'s length is odd, at most one character can appear an odd number of times to be placed in the center. # Examples Example 1 **Input**: ```python \'aabb\' ``` **Output**: ```python True ``` (The characters can be rearranged to form \\"abba\\", which is a palindrome.) Example 2 **Input**: ```python \'abba\' ``` **Output**: ```python True ``` (The string is already a palindrome.) Example 3 **Input**: ```python \'abc\' ``` **Output**: ```python False ``` (It is not possible to rearrange \\"abc\\" to form a palindrome.) Example 4 **Input**: ```python \'carerac\' ``` **Output**: ```python True ``` (The characters can be rearranged to form \\"racecar\\", which is a palindrome.) # Instructions - Implement the function `can_form_palindrome` as described. - Ensure you handle edge cases such as minimal and maximal length strings. - Consider the frequency of each character to determine the possibility of forming a palindrome.","solution":"def can_form_palindrome(s: str) -> bool: Determines if the characters of the given string can be rearranged to form a palindrome. :param s: A string containing lowercase alphabetic characters only. :return: True if it is possible to rearrange the characters to form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"# Problem Statement You are developing a tool that helps evaluate company performance by analyzing monthly sales. One feature of this tool is to find the longest stable period in the sales data. A stable period is defined as the longest consecutive subarray where the sales don\'t vary more than a given amount (d). # Function Signature ```python def longest_stable_period(sales: List[int], d: int) -> int: pass ``` # Input - A list of integers `sales` (1 ≤ len(sales) ≤ 10^5) representing monthly sales figures. - An integer (d) (0 ≤ (d) ≤ 10^6) representing the maximum allowed difference in sales to be considered stable. # Output - Return an integer representing the length of the longest stable period in the sales data. # Constraints - The difference between the maximum and minimum values in a stable period should be less than or equal to (d). - The function should be efficient with a linear time complexity, (O(n)). # Examples 1. **Example 1:** - Input: `sales = [10, 12, 14, 18, 19, 20, 10, 8]`, `d = 2` - Output: `3` - Explanation: The longest stable subarray is `[18, 19, 20]` with length 3. 2. **Example 2:** - Input: `sales = [5, 5, 5, 5, 5]`, `d = 0` - Output: `5` - Explanation: The entire array is stable with length 5. 3. **Example 3:** - Input: `sales = [7, 10, 5, 7, 6, 8, 9]`, `d = 3` - Output: `4` - Explanation: The longest stable subarray is `[5, 7, 6, 8]` with length 4. # Performance Requirements Your solution should achieve a linear time complexity, (O(n)), by utilizing a sliding window approach to efficiently find the longest stable period.","solution":"from typing import List from collections import deque def longest_stable_period(sales: List[int], d: int) -> int: Find the length of the longest stable period in sales array where the difference between the maximum and minimum values in any subarray is less than or equal to d. n = len(sales) if n == 0: return 0 min_deque = deque() max_deque = deque() left = 0 max_length = 0 for right in range(n): while min_deque and sales[right] < sales[min_deque[-1]]: min_deque.pop() while max_deque and sales[right] > sales[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while sales[max_deque[0]] - sales[min_deque[0]] > d: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement You are given an array of integers where each value represents the height of a tower at that position. You need to determine how much \\"water\\" each tower can trap after raining. Water is trapped between towers based on their heights; think of the towers as forming a series of valleys and peaks where water can be collected. # Function Signature ```python def calculate_trapped_water(heights: List[int]) -> int: Calculates the amount of water trapped between towers after raining. Parameters: heights (List[int]): A list of non-negative integers representing the height of the towers. Returns: int: Total amount of water trapped between the towers. ``` # Input and Output Format Input * `heights`: A list of integers where each integer (0 ≤ `heights[i]` ≤ 100000) denotes the height of the tower at position `i`. The length of the list (0 ≤ len(heights) ≤ 100000). Output * An integer representing the total amount of water trapped between the towers after raining. # Constraints * The function should handle large lists efficiently. # Example ```python assert calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert calculate_trapped_water([4, 2, 0, 3, 2, 5]) == 9 assert calculate_trapped_water([1, 0, 2, 0, 1]) == 2 assert calculate_trapped_water([0, 0, 0, 0]) == 0 ``` # Explanation * For the first example, with heights `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the amount of water trapped is 6. Visualize the water trapped between the peaks and valleys formed by the towers. * For the second example, with heights `[4, 2, 0, 3, 2, 5]`, the amount of water trapped is 9. Again, visualize the heights to see multiple valleys where water can be trapped. * Trivial examples include a flat terrain like `[0, 0, 0, 0]` where no water is trapped, and simpler variations that must still consider boundary conditions properly. # Additional Notes * Use an efficient approach, such as two-pointer technique, to ensure the solution works well even for the largest inputs within the given constraints. * Ensure your solution runs efficiently, minimizing both time and space complexity.","solution":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: Calculates the amount of water trapped between towers after raining. Parameters: heights (List[int]): A list of non-negative integers representing the height of the towers. Returns: int: Total amount of water trapped between the towers. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] <= heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"# Question: Find the Non-Repeating Missing Number You are given a list that contains integers from 1 to `n`, inclusive, with one number missing, and one number repeated once. Your task is to create a solution that finds the missing number and the repeated number. **Tasks**: 1. Implement a function `find_missing_and_repeated(numbers: list) -> tuple` that finds the missing number and the repeated number. # Input - A list `numbers` containing integers from 1 to `n` where `n` is the length of the list and includes one missing number and one repeated number. # Output - The function should return a tuple of two integers: - The first integer is the missing number. - The second integer is the repeated number. # Constraints - The lengths of the list `numbers` is `n`. - All integers from 1 to `n` are included in the list except for one missing number, with one of the numbers being repeated once. Example Given the list: ``` numbers = [4, 3, 6, 2, 1, 6] ``` The output should be: ``` >>> find_missing_and_repeated([4, 3, 6, 2, 1, 6]) (5, 6) ``` In this example, the number 5 is missing from the list, and the number 6 is repeated. Thus, the function should output `(5,6)`.","solution":"def find_missing_and_repeated(numbers): This function finds and returns the missing and repeated numbers in the list. n = len(numbers) total_sum = n * (n + 1) // 2 total_sum_squares = n * (n + 1) * (2 * n + 1) // 6 actual_sum = sum(numbers) actual_sum_squares = sum(x * x for x in numbers) diff = total_sum - actual_sum diff_squares = total_sum_squares - actual_sum_squares sum_x_y = diff_squares // diff x = (sum_x_y + diff) // 2 y = sum_x_y - x return (x, y)"},{"question":"# Problem Description You are responsible for developing a function that processes and validates book inventories for a library management system. The system needs to check the stock levels and provide specific outputs based on the state of the inventory data. Your function should ensure that stock levels fall within an acceptable range and react accordingly. # Function to Implement Write a Python function `validate_and_notify(book_inventory: dict, min_stock: int, max_stock: int) -> str:` that: 1. Ensures the provided `book_inventory` is a dictionary with: * Keys as book titles (strings). * Values as stock levels (integers). 2. Ensures the input values are valid: * The `min_stock` should be a non-negative integer. * The `max_stock` should be greater than `min_stock`. 3. If the input values are invalid: * Return a specific string message describing the error. 4. If the inputs are valid: * For each book, check if its stock level falls within the range `[min_stock, max_stock]`. * Collect a list of books that are out of the specified stock range. * If all books are within the range, return \\"All books are within the acceptable stock levels.\\" * Otherwise, return a string listing the titles of the books that are out of stock range. # Example ```python def validate_and_notify(book_inventory: dict, min_stock: int, max_stock: int) -> str: # Your implementation here # Example Usage print(validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 0, \\"Book C\\": 15}, 1, 10)) # Expected: \\"Books out of stock range: [Book B, Book C]\\" print(validate_and_notify({\\"Book A\\": 7, \\"Book B\\": 3, \\"Book C\\": 8}, 1, 10)) # Expected: \\"All books are within the acceptable stock levels.\\" print(validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 10}, -1, 10)) # Expected: \\"Error: Minimum stock should be a non-negative integer\\" print(validate_and_notify({\\"Book A\\": 5, \\"Book B\\": 10}, 5, 3)) # Expected: \\"Error: Maximum stock should be greater than minimum stock\\" ``` # Input * `book_inventory` (dict): A dictionary containing book titles (keys as strings) and their corresponding stock levels (values as integers). * `min_stock` (int): The minimum acceptable stock level, should be a non-negative integer. * `max_stock` (int): The maximum acceptable stock level, should be greater than `min_stock`. # Output * If the input is invalid, the function should return a string in one of the following formats: * \\"Error: Minimum stock should be a non-negative integer\\" * \\"Error: Maximum stock should be greater than minimum stock\\" * If the input is valid: * If all books are within the stock range, return: * \\"All books are within the acceptable stock levels.\\" * Otherwise, return: * \\"Books out of stock range: [<books>]\\", where `<books>` is a comma-separated list of book titles out of range. # Constraints * Assume all book titles are unique. * The function should efficiently check and process the inventory. * Edge cases as mentioned need to be considered.","solution":"def validate_and_notify(book_inventory: dict, min_stock: int, max_stock: int) -> str: # Check if min_stock is a non-negative integer if not isinstance(min_stock, int) or min_stock < 0: return \\"Error: Minimum stock should be a non-negative integer\\" # Check if max_stock is greater than min_stock if not isinstance(max_stock, int) or max_stock <= min_stock: return \\"Error: Maximum stock should be greater than minimum stock\\" # List to collect books out of stock range out_of_range_books = [] # Check every book\'s stock level for book, stock in book_inventory.items(): if not (min_stock <= stock <= max_stock): out_of_range_books.append(book) # Return appropriate message based on the collected books if out_of_range_books: books_list = \\", \\".join(out_of_range_books) return f\\"Books out of stock range: [{books_list}]\\" else: return \\"All books are within the acceptable stock levels.\\""},{"question":"# Coding Assessment Question: Implement Insertion in a Sorted Linked List Context Building on the linked list structure, your task is to write a function within the `LinkedList` class to insert a new node into the already sorted linked list while maintaining the order. Input & Output *Input*: An integer value (the data of the new node to be inserted). *Output*: None. The function operates on the linked list instance. Constraints 1. The function should handle insertion in an empty list. 2. The function should work efficiently, maintaining the sorted order in O(n) time complexity. Function Signature ```python class LinkedList: # Assume all other methods are defined as in the given snippet def insert_sorted(self, data: int) -> None: Inserts a new node into the sorted linked list. Args: data (int): The data of the new node to be inserted. ``` Scenario Consider the following scenario to further illustrate: ```python link = LinkedList() link.push(10) link.push(5) link.push(1) link.insert_sorted(7) print(link.to_list()) # Expected output: [1, 5, 7, 10] ``` In the example above, the initial list is `1 -> 5 -> 10 -> None`. After inserting `7`, it becomes `1 -> 5 -> 7 -> 10 -> None`. Complete the `insert_sorted()` function to perform this task efficiently.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, data): new_node = Node(data) new_node.next = self.head self.head = new_node def to_list(self): result = [] current = self.head while current: result.append(current.data) current = current.next return result def insert_sorted(self, data): new_node = Node(data) if self.head is None or self.head.data >= new_node.data: new_node.next = self.head self.head = new_node return current = self.head while current.next and current.next.data < new_node.data: current = current.next new_node.next = current.next current.next = new_node"},{"question":"# Question: Longest Common Subsequence Challenge **Objective**: Write a program that determines the length of the longest common subsequence between two strings. **Scenario**: You are working on a text analysis tool that compares different versions of a document to find the longest common subsequence of characters between any two given versions. This measure helps in identifying the most significant similarities between document changes. Function Details: Implement the function `longest_common_subsequence(str1: str, str2: str) -> int`: 1. **Input**: - `str1` (str): The first input string. Must be non-empty. - `str2` (str): The second input string. Must be non-empty. - Constraints: `1 <= len(str1), len(str2) <= 1000` 2. **Output**: - Returns the length of the longest common subsequence between `str1` and `str2`. 3. **Error Handling**: - If either `str1` or `str2` is an empty string, raise a `ValueError` with the message \\"Input strings must be non-empty.\\" 4. **Performance Requirements**: - The solution should be optimized to handle strings up to the length constraint comfortably. Example Usage: ```python >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") ValueError: Input strings must be non-empty >>> longest_common_subsequence(\\"\\", \\"abc\\") ValueError: Input strings must be non-empty ``` # Requirements - Write clean and well-documented code. - Pay attention to algorithmic efficiency given the potential length of input strings. **Hints**: - Utilize dynamic programming approaches for optimal performance. - Think about utilizing a matrix / 2D list for intermediate calculations in dynamic programming.","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. Parameters: str1 (str): The first input string. str2 (str): The second input string. Returns: int: The length of the longest common subsequence. Raises: ValueError: If either of the input strings is empty. if not str1 or not str2: raise ValueError(\\"Input strings must be non-empty\\") m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"You are tasked with calculating the number of distinct words that can be formed using the letters of a given word. A word is considered distinct if its letter arrangement is unique. # Function Signature ```python def count_distinct_words(word: str) -> int: pass ``` # Input * `word` (str): A string representing the word from which we want to generate distinct words. It contains only lowercase English letters. # Output * Returns an integer representing the number of distinct words that can be formed using the letters of the given word. # Constraints * `1 <= len(word) <= 10^5` # Performance Requirements * Your solution should efficiently handle the given constraint. # Example ```python count_distinct_words(\\"aabc\\") # Expected output: 12 count_distinct_words(\\"aaa\\") # Expected output: 1 ``` # Hint Consider using factorials for permutations and handle the repeated characters appropriately to avoid overcounting. Use prime factorization for large computations to stay within performance limits.","solution":"from collections import Counter from math import factorial def count_distinct_words(word: str) -> int: Returns the number of distinct words that can be formed using the letters of the given word. if not word: return 0 # Count frequencies of each character in the word freq = Counter(word) # Calculate the factorial of the length of the word total_permutations = factorial(len(word)) # Divide by the factorial of the frequency of each character to handle repetitions for count in freq.values(): total_permutations //= factorial(count) return total_permutations"},{"question":"You need to implement a function that counts the number of unique vowels in a given string. Specifically, you need to create a function that determines how many vowels in the string are unique, regardless of their case. # Function Signature ```python def count_unique_vowels(s: str) -> int: ``` # Input * `s`: A string consisting of any characters. # Output * Returns an integer representing the number of unique vowels present in the input string. # Constraints * The input string can be empty. * Consider the vowels to be `a`, `e`, `i`, `o`, `u` (case insensitive). # Examples ```python print(count_unique_vowels(\\"hello\\")) # 2 (e, o) print(count_unique_vowels(\\"world\\")) # 1 (o) print(count_unique_vowels(\\"rhythm\\")) # 0 print(count_unique_vowels(\\"AEIOUaeiou\\")) # 5 (a, e, i, o, u) print(count_unique_vowels(\\"\\")) # 0 ``` # Additional Requirements 1. The function must handle both upper and lower case characters uniformly. 2. Ensure robustness and efficiency in your implementation. Contemplate edge cases and provide validation as necessary. # Notes * Focus on clarity and simplicity of your code. * Keep performance considerations in mind, especially for large input strings.","solution":"def count_unique_vowels(s: str) -> int: Returns the count of unique vowels in the given string `s`. Vowels are considered case insensitively. vowels = {\'a\', \'e\', \'i\', \'o\', \'u\'} unique_vowels_in_string = {char.lower() for char in s if char.lower() in vowels} return len(unique_vowels_in_string)"},{"question":"# Question Scenario You are required to implement a function that processes a list of transactions and returns the total balance of a simulated bank account. Each transaction can either be a deposit or a withdrawal. Task Write a Python function `calculate_balance` that computes the balance of an account after a series of transactions. Function Specification ```python def calculate_balance(transactions): Computes the balance of an account given a list of transactions. Args: transactions (list of tuples): A list where each tuple contains a transaction type (either \'deposit\' or \'withdraw\') and an amount (float). Returns: float: The final balance of the account after processing all transactions. ``` Constraints - Each transaction in the list is a tuple of exactly two elements: a string (\'deposit\' or \'withdraw\') and a float representing the amount. - The initial account balance is 0.0. - Transactions are processed in the order they appear in the list. - Each deposit increases the balance by the specified amount. - Each withdrawal decreases the balance by the specified amount. - You can assume that there will never be an attempt to withdraw more than the available balance. Example ```python transactions = [ (\'deposit\', 100.0), (\'withdraw\', 50.0), (\'deposit\', 20.0), (\'withdraw\', 10.0) ] assert calculate_balance(transactions) == 60.0 ``` Performance Requirements - The function should efficiently handle up to 10000 transactions. - Aim for a time complexity of O(n), where n is the number of transactions.","solution":"def calculate_balance(transactions): Computes the balance of an account given a list of transactions. Args: transactions (list of tuples): A list where each tuple contains a transaction type (either \'deposit\' or \'withdraw\') and an amount (float). Returns: float: The final balance of the account after processing all transactions. balance = 0.0 for transaction in transactions: transaction_type, amount = transaction if transaction_type == \'deposit\': balance += amount elif transaction_type == \'withdraw\': balance -= amount return balance"},{"question":"# Question: Context: You are helping develop a search engine for a large e-commerce platform. One key feature is to enhance the search functionality to quickly return all unique keywords from the search queries stored in the database. Task: Implement a function `find_unique_keywords(search_queries: List[str]) -> List[str]` which returns a list of unique keywords sorted in alphabetical order from the provided list of search queries. A search query is a string that consists of words separated by spaces. Keywords are case-insensitive. * Consider using helper functions as needed to modularize your solution. * Aim for efficiency, taking into account the size of the input data. Constraints: Consider the following constraints: * `1 <= len(search_queries) <= 10^5` * Each search query string can be between 1 to 256 characters long. * All characters in the search queries are alphanumeric or spaces. Input: * A list of search query strings `search_queries` where each query is between 1 and 256 characters long. Output: * A list of unique keywords sorted in alphabetical order. Example: ```python assert find_unique_keywords([\\"buy phone case\\", \\"buy charger\\", \\"phone case charger\\"]) == [\\"buy\\", \\"case\\", \\"charger\\", \\"phone\\"] assert find_unique_keywords([\\"Laptop\\", \\"laptop\\", \\"LAPTOP\\"]) == [\\"laptop\\"] ``` Requirements: * Ensure your solution is efficient, considering the constraints. * Handle edge cases such as empty search queries by returning an empty list.","solution":"from typing import List def find_unique_keywords(search_queries: List[str]) -> List[str]: This function takes a list of search queries and returns a list of unique keywords sorted. Keywords are case-insensitive. keywords = set() for query in search_queries: words = query.lower().split() for word in words: keywords.add(word) return sorted(keywords)"},{"question":"# Context You are working on a data processing tool that involves multiple transformations of data streams. One essential transformation is finding the longest contiguous subsequence that sums up to a given value, which often occurs in time series analysis or signal processing. # Task Implement a function in Python that finds the length of the longest contiguous subsequence in an input list of integers that sums up to a specific target value. Your function should optimize for efficiency to handle large datasets, processing both positive and negative integers. # Requirements - Function Name: `longest_subsequence_length` - **Input**: A list of integers and a target sum. - **Output**: Length of the longest contiguous subsequence that sums to the target value. - **Constraints**: - The maximum length of the list will be 10^5. - Each integer in the list will be a signed 32-bit integer. - If no such subsequence exists, return 0. # Example ```python # Example usage lst = [1, -1, 5, -2, 3] target = 3 print(longest_subsequence_length(lst, target)) # Output should be: 4 (the subsequence [1, -1, 5, -2]) lst = [-2, -1, 2, 1] target = 1 print(longest_subsequence_length(lst, target)) # Output should be: 2 (the subsequence [2, -1, 2]) lst = [3, 1, 0, -2, 6, -1, -3, 2] target = 4 print(longest_subsequence_length(lst, target)) # Output should be: 5 (the subsequence [3, 1, 0, -2, 6]) ``` # Notes: - Consider edge cases such as empty lists, lists with no such subsequence summing to the target, and lists with all identical elements. - Optimize your algorithm to handle large input sizes efficiently. # Implement the Function Below: ```python def longest_subsequence_length(lst, target): # your code here ```","solution":"def longest_subsequence_length(lst, target): Finds the length of the longest contiguous subsequence in lst that sums to the target value. :param lst: List of integers :param target: Target sum integer :return: Length of the longest contiguous subsequence that sums to the target value sum_indices = {} current_sum = 0 max_length = 0 for i in range(len(lst)): current_sum += lst[i] if current_sum == target: max_length = i + 1 if (current_sum - target) in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - target]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"# Problem Statement: You are tasked with implementing a simple compression algorithm known as **Run Length Encoding (RLE)**, which is a basic form of lossless data compression. The idea is to take a string and count consecutive occurrences of each character, encoding them as the character followed by its count. Implement the Run Length Encoding function in Python which takes a string as input and returns the encoded string. # Function Signature: ```python def run_length_encoding(input_string: str) -> str: Encodes the input string using Run Length Encoding (RLE). Parameters: input_string (str): The string to be encoded. Returns: str: The RLE encoded string. ``` # Input: - A string containing printable ASCII characters. - Constraints: The input string length will be between 1 and 10^6 characters. # Output: - A string representing the Run Length Encoded version of the input string. # Examples: ```python # Example 1 input_string = \\"aaabbcc\\" print(run_length_encoding(input_string)) # Expected Output: \\"a3b2c2\\" # Example 2 input_string = \\"a\\" print(run_length_encoding(input_string)) # Expected Output: \\"a1\\" # Example 3 input_string = \\"wwwwaaadexxxxxx\\" print(run_length_encoding(input_string)) # Expected Output: \\"w4a3d1e1x6\\" # Example 4 input_string = \\"abcd\\" print(run_length_encoding(input_string)) # Expected Output: \\"a1b1c1d1\\" ``` **Note**: Ensure the solution efficiently handles long strings and minimizes unnecessary computations and memory usage.","solution":"def run_length_encoding(input_string: str) -> str: Encodes the input string using Run Length Encoding (RLE). Parameters: input_string (str): The string to be encoded. Returns: str: The RLE encoded string. if not input_string: return \\"\\" encoded_string = [] current_char = input_string[0] count = 1 for char in input_string[1:]: if char == current_char: count += 1 else: encoded_string.append(current_char + str(count)) current_char = char count = 1 encoded_string.append(current_char + str(count)) return \\"\\".join(encoded_string)"},{"question":"# Binary Tree Level Order Traversal You are tasked with implementing a function that performs a level order traversal on a binary tree. Level order traversal visits all nodes of a binary tree level by level from left to right. Problem Statement Write a function `level_order_traversal(root)` that performs a level order traversal on a given binary tree and returns the values of the nodes in a list of lists, where each inner list contains the nodes at that level. Input: - `root`: The root node of the binary tree. Output: - A list of lists, with each inner list containing the values of the nodes at each level from top to bottom. Constraints: - The number of nodes in the binary tree will be at most 10,000. - Node values will be integers. - The binary tree can be empty (i.e., `root` can be `None`). Example: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) result = level_order_traversal(root) print(result) ``` Expected Output: ```python [[3], [9, 20], [15, 7]] ``` Performance Requirements: The algorithm should complete within a reasonable time for trees with up to 10,000 nodes. # Hints - Use a queue to keep track of nodes at each level. - Consider using a BFS (Breadth-First Search) approach for level order traversal.","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def level_order_traversal(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Question on String Manipulation and Regular Expressions Context String manipulation is a common task in programming, particularly when dealing with text data. Regular expressions (regex) are powerful tools for such tasks, enabling complex pattern matching and extraction. Problem Design a function `extract_emails(text)`, where `text` is a string, which extracts and returns all valid email addresses found in the input string. An email address is considered valid if it follows the general format: `username@domain`, where: - `username` can contain alphanumeric characters, dots (.), hyphens (-), and underscores (_). - `domain` can also contain alphanumeric characters and dots (.) but must end with a top-level domain such as \\".com\\", \\".org\\", \\".net\\", etc. Requirements To achieve this: 1. Use regular expressions to identify and extract email addresses from the input string. 2. Implement the function robustly to ensure that only valid emails, as per the given criteria, are included in the result. 3. Return the list of extracted email addresses. Input and Output * **Input**: - A string `text` (e.g., \\"Please contact us at support@example.com or sales@example.org for more information.\\"). * **Output**: - A list of strings, where each string is a valid email address found within the input text. Implementation Constraints * Ensure the function handles a variety of text formats, including multiple email addresses and different character cases. * The regular expression used must be efficient and accurate in capturing only valid email addresses. Example ```python import re def extract_emails(text): # Your code here # Example: text = \\"Please contact us at support@example.com or sales@example.org for more information.\\" print(extract_emails(text)) # Expected output: [\'support@example.com\', \'sales@example.org\'] ``` You are required to provide a function definition for `extract_emails(text)` and ensure it accurately produces the expected output for the given example case. Use regular expressions effectively to achieve precise email extraction while considering performance efficiency.","solution":"import re def extract_emails(text): Extracts and returns all valid email addresses from the input text. email_pattern = re.compile(r\'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}\') return email_pattern.findall(text)"},{"question":"# Task: Given a list of integers, you need to identify all pairs of numbers that sum up to a specific target value. Return a list of these pairs, where each pair is represented as a tuple of two integers. The pairs should be sorted in ascending order based on the first element of the pair, and then by the second element. # Function Specification: ```python def find_pairs(nums: list[int], target: int) -> list[tuple[int, int]]: Finds all pairs of integers in the given list that add up to the target value. Parameters: nums (list): A list of integers. target (int): The target sum value. Returns: list: A list of tuples, where each tuple contains two integers that sum up to the target value. Examples: >>> find_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs([1, -2, 3, 8, -1, 7], 6) [(-2, 8), (-1, 7)] >>> find_pairs([0, 0, 0, 0], 0) [(0, 0), (0, 0), (0, 0), (0, 0)] >>> find_pairs([1, 3, 2, 2], 4) [(1, 3), (2, 2)] >>> find_pairs([5], 10) [] # Your code here ``` # Requirements: 1. **Input**: - A list of integers, `nums`. - An integer, `target`, representing the target sum. 2. **Output**: - A list of tuples, where each tuple contains two integers from the list that add up to the target value. 3. **Constraints**: - Ensure no duplicate pairs are included in the output list. - Each pair in the output should be sorted in ascending order. - The output list itself should be sorted in ascending order based on the pairs. 4. **Error Handling**: - Handle cases where the input list is empty by returning an empty list. # Scenario: You are developing a feature for an analytical tool that identifies pairs of transactions whose combined amounts match a specified total. This is useful for detecting patterns and potential errors in financial datasets. # Hint: Use a hash map to track the occurrences of each number while iterating through the list to efficiently find the complement that adds up to the target value.","solution":"def find_pairs(nums, target): Finds all pairs of integers in the given list that add up to the target value. Parameters: nums (list): A list of integers. target (int): The target sum value. Returns: list: A list of tuples, where each tuple contains two integers that sum up to the target value. pairs = [] seen = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) if pair not in pairs: pairs.append(pair) seen.add(num) return sorted(pairs)"},{"question":"Coding Assessment Question Scenario You are tasked with developing a tree-like data structure that supports performing a series of operations efficiently on a dataset of integer values. The operations include adding a value to the elements of a subarray and finding the sum of values in any given range. Task Implement a class `RangeSumFenwickTree` that provides efficient range updates where you add a value to all elements in the specified range, and range queries where you get the sum of any specified range. # Class Definition ```python class RangeSumFenwickTree: def __init__(self, size: int) -> None: # Initialize the class with necessary properties def range_add(self, left: int, right: int, value: int) -> None: # Add the specified value to each element in the range [left, right] def range_sum(self, left: int, right: int) -> int: # Return the sum of elements in the range [left, right) ``` # Method Details * **`__init__(self, size: int) -> None`**: * Initializes the RangeSumFenwickTree with the specified size. * **`range_add(self, left: int, right: int, value: int) -> None`**: * Adds the specified `value` to each element in the range `[left, right)`. * **`range_sum(self, left: int, right: int) -> int`**: * Returns the sum of the elements in the range `[left, right)`. # Constraints * Array size `<= 10^5` * Value range `-10^9 <= value <= 10^9` * `0 <= left < right <= size` # Output Format * Method `range_sum` returns an integer. # Example ```python rsft = RangeSumFenwickTree(8) array = [0] * 8 # Adding 3 to elements in range [1, 4) -> array becomes [0, 3, 3, 3, 0, 0, 0, 0] rsft.range_add(1, 4, 3) # Adding 5 to elements in range [3, 6) -> array becomes [0, 3, 3, 8, 5, 5, 0, 0] rsft.range_add(3, 6, 5) assert rsft.range_sum(1, 5) == 19 # since array slice [1, 5) = [3, 3, 8, 5] assert rsft.range_sum(0, 8) == 24 # since array = [0, 3, 3, 8, 5, 5, 0, 0] ``` By creating a question that complements the style, complexity level, length, and scope of the prior questions, this new question regarding the `RangeSumFenwickTree` helps to test similar skills while exploring the related concept of range updates and sum queries in a data structure context.","solution":"class RangeSumFenwickTree: def __init__(self, size: int) -> None: self.size = size self.tree1 = [0] * (size + 1) self.tree2 = [0] * (size + 1) def __add(self, tree, index, value): while index <= self.size: tree[index] += value index += index & -index def __sum(self, tree, index): result = 0 while index > 0: result += tree[index] index -= index & -index return result def range_add(self, left: int, right: int, value: int) -> None: self.__add(self.tree1, left + 1, value) self.__add(self.tree1, right + 1, -value) self.__add(self.tree2, left + 1, value * left) self.__add(self.tree2, right + 1, -value * right) def __prefix_sum(self, index): return (self.__sum(self.tree1, index) * index - self.__sum(self.tree2, index)) def range_sum(self, left: int, right: int) -> int: return self.__prefix_sum(right) - self.__prefix_sum(left)"},{"question":"# Problem Description You have been assigned to create an efficient system for managing and retrieving book information in a library database. The database contains prices of the books sorted in non-decreasing order, and your task is to find the most expensive affordable book that does not exceed a given budget. # Task Implement a function that performs a binary search to efficiently find the most expensive book within the given budget. You should implement both an iterative and a recursive approach. # Function Signature ```python def search_most_expensive_affordable_book_iterative(prices: list[int], budget: int) -> int: pass def search_most_expensive_affordable_book_recursive(prices: list[int], budget: int) -> int: pass ``` # Input - `prices` (list): A list of integers representing the prices of books, sorted in non-decreasing order. - `budget` (int): An integer representing the budget within which the most expensive book should be found. # Output - Return the price of the most expensive book that does not exceed the budget. If no such book exists, return -1. # Constraints - You can assume the `prices` list is sorted in non-decreasing order. - The size of `prices` will be up to 10^5. - The budget will be a non-negative integer. # Examples ```python # Main function signature of iterative search def search_most_expensive_affordable_book_iterative(prices, budget): pass # Main function signature of recursive search def search_most_expensive_affordable_book_recursive(prices, budget): pass # Sample book prices book_prices = [3, 9, 14, 21, 30, 45, 60] # Iterative search test cases assert search_most_expensive_affordable_book_iterative(book_prices, 20) == 14 assert search_most_expensive_affordable_book_iterative(book_prices, 60) == 60 assert search_most_expensive_affordable_book_iterative(book_prices, 5) == 3 assert search_most_expensive_affordable_book_iterative(book_prices, 2) == -1 assert search_most_expensive_affordable_book_iterative([], 20) == -1 assert search_most_expensive_affordable_book_iterative(book_prices, 45) == 45 # Recursive search test cases assert search_most_expensive_affordable_book_recursive(book_prices, 20) == 14 assert search_most_expensive_affordable_book_recursive(book_prices, 60) == 60 assert search_most_expensive_affordable_book_recursive(book_prices, 5) == 3 assert search_most_expensive_affordable_book_recursive(book_prices, 2) == -1 assert search_most_expensive_affordable_book_recursive([], 20) == -1 assert search_most_expensive_affordable_book_recursive(book_prices, 45) == 45 ``` # Hints - The binary search algorithm should help efficiently narrow down the most appropriate book price. - Handle edge cases including no affordable books and exact matches with the budget.","solution":"def search_most_expensive_affordable_book_iterative(prices, budget): Returns the most expensive book price within the given budget using an iterative binary search. left, right = 0, len(prices) - 1 result = -1 while left <= right: mid = (left + right) // 2 if prices[mid] <= budget: result = prices[mid] left = mid + 1 else: right = mid - 1 return result def search_most_expensive_affordable_book_recursive(prices, budget): Returns the most expensive book price within the given budget using a recursive binary search. def binary_search(prices, budget, left, right, result): if left > right: return result mid = (left + right) // 2 if prices[mid] <= budget: return binary_search(prices, budget, mid + 1, right, prices[mid]) else: return binary_search(prices, budget, left, mid - 1, result) return binary_search(prices, budget, 0, len(prices) - 1, -1)"},{"question":"# Problem Statement Write a Python function `bitwise_left_rotate` that performs a left rotation on a given 8-bit integer. A left rotation by one position shifts each bit to the left by one place, with the leftmost bit wrapping around to the rightmost position. Additionally, write a `bitwise_operations_summary` function that accepts an 8-bit integer and generates a summary of its bitwise operations including its binary representation, bitwise NOT, and the results of left rotations by 1 to 3 positions. # Input and Output Input * `bitwise_left_rotate(num: int, shift: int) -> int` * Takes an 8-bit integer `num` (0 <= `num` < 256) and an integer `shift` (number of positions to rotate). * `bitwise_operations_summary(num: int) -> str` * Takes an 8-bit integer `num` and returns a summary string containing: * The binary representation of the input number. * The result of the bitwise NOT operation. * The results of left rotations by 1, 2, and 3 positions. Output * `bitwise_left_rotate` returns the integer representation of the rotated number. * `bitwise_operations_summary` returns a formatted string summary of the bitwise operations on the input number. Constraints - The input number `num` will be an 8-bit integer (0 <= `num` < 256). - The shift value will be between 0 and 7 (inclusive). # Example For `bitwise_left_rotate`: ```python >>> bitwise_left_rotate(13, 1) 26 >>> bitwise_left_rotate(13, 2) 52 >>> bitwise_left_rotate(13, 3) 104 ``` For `bitwise_operations_summary`: ```python >>> print(bitwise_operations_summary(13)) Bitwise Operations Summary for 13 (binary: 00001101): - Bitwise NOT: 242 (binary: 11110010) - Left Rotate by 1: 26 (binary: 00011010) - Left Rotate by 2: 52 (binary: 00110100) - Left Rotate by 3: 104 (binary: 01101000) ``` # Implement the functions below: ```python def bitwise_left_rotate(num: int, shift: int) -> int: # Implement the bitwise left rotation logic pass def bitwise_operations_summary(num: int) -> str: # Implement the bitwise operations summary pass ```","solution":"def bitwise_left_rotate(num: int, shift: int) -> int: Returns the result of left rotating an 8-bit integer `num` by `shift` positions. shift %= 8 # In case shift is greater than 7, it wraps around return ((num << shift) & 0xFF) | (num >> (8 - shift)) def bitwise_operations_summary(num: int) -> str: Generates a summary of bitwise operations on an 8-bit integer `num`. bin_repr = format(num, \'08b\') not_result = ~num & 0xFF not_result_bin = format(not_result, \'08b\') left_rotate_1 = bitwise_left_rotate(num, 1) left_rotate_1_bin = format(left_rotate_1, \'08b\') left_rotate_2 = bitwise_left_rotate(num, 2) left_rotate_2_bin = format(left_rotate_2, \'08b\') left_rotate_3 = bitwise_left_rotate(num, 3) left_rotate_3_bin = format(left_rotate_3, \'08b\') summary = ( f\\"Bitwise Operations Summary for {num} (binary: {bin_repr}):n\\" f\\"- Bitwise NOT: {not_result} (binary: {not_result_bin})n\\" f\\"- Left Rotate by 1: {left_rotate_1} (binary: {left_rotate_1_bin})n\\" f\\"- Left Rotate by 2: {left_rotate_2} (binary: {left_rotate_2_bin})n\\" f\\"- Left Rotate by 3: {left_rotate_3} (binary: {left_rotate_3_bin})n\\" ) return summary"},{"question":"# Array Manipulation: Find the Maximum Overlapping Intervals In this task, you are required to find the maximum number of overlapping intervals at any point in time, given a list of intervals. Scenario: You are working on a scheduling system that needs to allocate resources efficiently. Given multiple time slots represented as intervals, you want to find the maximum number of overlapping intervals to ensure adequate resource allocation. Objective: Implement a function `max_overlapping_intervals` that takes a list of intervals and returns the maximum number of intervals that overlap at any point in time. # Specifications: 1. Function: * `max_overlapping_intervals` - Takes a list of tuples where each tuple represents an interval with a start and end time (inclusive). It returns an integer representing the maximum number of overlapping intervals. 2. Input/Output Formats: * **Input**: * `intervals`: A list of tuples, where each tuple `(start, end)` represents an interval with `start` and `end` being non-negative integers. * **Output**: * An integer representing the maximum number of overlapping intervals. Function Signature: ```python def max_overlapping_intervals(intervals: list) -> int: pass ``` Example Usage: ```python intervals = [(1, 4), (2, 5), (9, 12), (5, 9), (5, 12)] assert max_overlapping_intervals(intervals) == 3 ``` Explanation: - In the given example, the intervals `(1, 4)` and `(2, 5)` overlap from `2` to `4`. - The intervals `(2, 5)`, `(5, 9)`, and `(5, 12)` overlap at `5`. - Therefore, the maximum number of overlapping intervals is `3`. Constraints: * Intervals are non-empty and consist of valid (start, end) pairs where `0 <= start <= end`. * The function should handle a large list of intervals efficiently. * The intervals list can have at most (10^5) intervals.","solution":"def max_overlapping_intervals(intervals): Finds the maximum number of overlapping intervals at any point in time. Parameters: intervals (list of tuples): List of intervals where each interval is represented as a tuple (start, end). Returns: int: The maximum number of overlapping intervals. events = [] for start, end in intervals: events.append((start, \'start\')) events.append((end + 1, \'end\')) events.sort() max_overlap = 0 current_overlap = 0 for time, event in events: if event == \'start\': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap"},{"question":"# Unique Element Finder Given an array `arr` of integers where every element appears twice except for one unique element that appears only once, your task is to find and return that unique element. Your solution should have a linear runtime complexity and use constant extra space. Input: - An array of integers `arr` where (2 leq |arr| leq 10^6) and all elements are between (-10^6 leq arr[i] leq 10^6). Output: - A single integer representing the unique element in the array. Constraints: - All elements in the array `arr` are integers. - Every element except for one appears exactly twice. Example: ```python >>> find_unique_element([2, 3, 5, 4, 5, 3, 4]) 2 >>> find_unique_element([12, 1, 12, 1, 2, 5, 5]) 2 >>> find_unique_element([7]) 7 ``` > **Scenario**: > Your cousin is working on a project that involves data filtering and needs an efficient way to find unique elements in a list of repeated entries. Assist them by implementing a function that meets these requirements. Function Signature ```python def find_unique_element(arr: list) -> int: pass ```","solution":"def find_unique_element(arr): Returns the unique element from the list where every other element appears twice. Args: arr (list): List of integers where every element except one appears twice. Returns: int: The unique element. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Employee Promotion Prediction You are part of the human resources team at a large corporation and tasked with developing a model to predict whether an employee is ready for promotion based on their performance metrics over the past year. The company wants to use historical data to make predictions about future promotions. Task 1. **Implement a function `predict_promotions` that uses logistic regression, decision tree, and random forest classifiers to predict whether employees are ready for promotion.** 2. **Implement a function `detect_outliers` that uses Z-score to determine if there are any outlier predictions in the classification results.** 3. **Implement a function `is_prediction_reliable` to return a boolean indicating if the prediction is reliable based on a majority vote of the classifiers.** Requirements 1. Implement the following functions: - `predict_promotions(train_features: List[List[float]], train_labels: List[int], test_features: List[List[float]]) -> List[int]`: This function should return a list of predicted promotion readiness labels (0 or 1) using Logistic Regression, Decision Tree, and Random Forest classifiers. - `detect_outliers(predictions: List[int]) -> List[int]`: This function should return the list of predictions without any outliers based on the Z-score method. - `is_prediction_reliable(predictions: List[int], actual_labels: List[int]) -> bool`: This function should compare the list of predictions to the actual labels and return whether the prediction is considered reliable based on majority votes from the classifiers. 2. **Constraints**: - `train_features` will have `n` rows and `m` columns, where `n` represents the number of training samples and `m` represents the number of features per sample. - `train_labels` will have `n` entries representing the promotion readiness label (0 or 1) for each sample. - `test_features` will have `k` rows and `m` columns, where `k` represents the number of test samples. - All the values in the training and test lists will be numeric and non-negative floats. - Training and test datasets will be reasonably sized, with up to 5000 samples. 3. **Performance Requirements**: - Efficient use of memory and computational resources, especially given larger datasets. - Adequate handling of numeric precision issues. Input - `train_features` (List[List[float]]): List of feature vectors for training data. - `train_labels` (List[int]): List of labels (0 or 1) for training data. - `test_features` (List[List[float]]): List of feature vectors for test data. - `actual_labels` (List[int]): List of actual labels for evaluating prediction reliability. Output - `predict_promotions` returns a list `[lr_predictions, dt_predictions, rf_predictions]`. - `detect_outliers` returns a list of predictions without outliers. - `is_prediction_reliable` returns a boolean indicating if the prediction is reliable. Example ```python train_features = [[3.5, 2.1, 5.7], [4.0, 2.5, 4.1], [3.8, 2.2, 5.9]] train_labels = [1, 0, 1] test_features = [[4.2, 2.3, 5.5], [3.7, 2.0, 5.1]] actual_labels = [1, 0] predictions = predict_promotions(train_features, train_labels, test_features) # Expected: [Logistic Regression Predictions, Decision Tree Predictions, Random Forest Predictions] filtered_predictions = detect_outliers(predictions) # Expected: List of filtered predictions without outliers. reliable = is_prediction_reliable(predictions, actual_labels) # Expected: True if predictions are considered reliable based on majority vote ```","solution":"from typing import List from sklearn.linear_model import LogisticRegression from sklearn.tree import DecisionTreeClassifier from sklearn.ensemble import RandomForestClassifier from scipy.stats import zscore import numpy as np def predict_promotions(train_features: List[List[float]], train_labels: List[int], test_features: List[List[float]]) -> List[List[int]]: Function to predict promotions using Logistic Regression, Decision Tree, and Random Forest classifiers. Returns a list of predictions from each classifier. # Initialize the models lr_model = LogisticRegression() dt_model = DecisionTreeClassifier() rf_model = RandomForestClassifier() # Train the models lr_model.fit(train_features, train_labels) dt_model.fit(train_features, train_labels) rf_model.fit(train_features, train_labels) # Make predictions lr_predictions = lr_model.predict(test_features).tolist() dt_predictions = dt_model.predict(test_features).tolist() rf_predictions = rf_model.predict(test_features).tolist() return [lr_predictions, dt_predictions, rf_predictions] def detect_outliers(predictions: List[int]) -> List[int]: Function to detect outliers in the predictions using the Z-score method. Returns the list of predictions without outliers. # Calculate the z-scores of predictions z_scores = zscore(predictions) # Filter out outliers (assumed to be those with z-score > 2 or < -2) filtered_predictions = [pred for pred, z in zip(predictions, z_scores) if abs(z) <= 2] return filtered_predictions def is_prediction_reliable(predictions: List[List[int]], actual_labels: List[int]) -> bool: Function to determine if the prediction is reliable based on a majority vote of classifiers. # Majority vote for each test sample majority_votes = [ int(sum(pred) > 1) for pred in zip(predictions[0], predictions[1], predictions[2]) ] # Compare majority votes to actual labels to determine reliability return majority_votes == actual_labels"},{"question":"# Infix to Postfix Conversion **Scenario**: You are tasked with implementing a function that converts an arithmetic expression from infix notation to postfix notation, also known as Reverse Polish Notation (RPN). In infix notation, operators are placed between operands (e.g., `a + b`). In postfix notation, operators follow their operands (e.g., `a b +`). Function: `infix_to_postfix` - **Input**: - `expression`: A string representing an arithmetic expression in infix notation. The expression may contain: - Single character variables (e.g., `a`, `b`, `c`) - Binary operators: `+`, `-`, `*`, `/` - Parentheses: `(`, `)` - **Output**: - A string representing the expression in postfix notation. - **Function Signature**: ```python def infix_to_postfix(expression: str) -> str: ``` Constraints - The input expression will be a valid infix expression with balanced parentheses. - The length of the expression will not exceed 1000 characters. - The expression will not contain any spaces or invalid characters. Example ```python # Input expression = \\"a+b*(c^d-e)^(f+g*h)-i\\" # Function Execution postfix_expression = infix_to_postfix(expression) # Expected Output print(postfix_expression) # \\"abcd^e-fgh*+^*+i-\\" ``` Your implementation will convert infix expressions to postfix notation accurately, handling the operator precedence and parentheses correctly. Ensure that your solution is efficient and can process any valid input within given constraints.","solution":"def infix_to_postfix(expression: str) -> str: precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2, \'^\': 3} output = [] stack = [] for char in expression: if char.isalnum(): # operand (letter or digit) output.append(char) elif char == \'(\': # left parenthesis stack.append(char) elif char == \')\': # right parenthesis while stack and stack[-1] != \'(\': output.append(stack.pop()) stack.pop() # Remove \'(\' from stack else: # operator while stack and stack[-1] != \'(\' and precedence[char] <= precedence.get(stack[-1], 0): output.append(stack.pop()) stack.append(char) while stack: output.append(stack.pop()) return \'\'.join(output)"},{"question":"# Problem Statement You are tasked with implementing a basic version of the k-nearest neighbors (k-NN) algorithm for regression. You will create a function that builds the model by storing the training data and then predicts the output for new data points by averaging the `k` nearest neighbors of the input points. # Requirements 1. **Input**: - `x_train`: A one-dimensional numpy array of floating point numbers representing the input features of the training data. - `y_train`: A one-dimensional numpy array of floating point numbers representing the target values (labels) of the training data. - `x_test`: A one-dimensional numpy array of floating point numbers representing the input features of the test data for which we want to predict the targets. - `k` (int): The number of nearest neighbors to consider for regression. Default value: 3. 2. **Output**: - You will create a function `k_nearest_neighbors_regression(x_train, y_train, x_test, k)` that returns a one-dimensional numpy array of predicted values for the test data. # Constraints - The length of `x_train` and `y_train` will be at least 2 and less than or equal to 10,000. - The length of `x_test` will be at least 1 and less than or equal to 1,000. - The input `x_train`, `y_train`, and `x_test` must be one-dimensional arrays with continuous values. - The values in `x_train` and `y_train` are uniformly distributed. # Example ```python # Sample inputs x_train = np.array([1.0, 2.0, 3.0, 4.0, 5.0]) y_train = np.array([1.1, 2.1, 3.1, 4.1, 5.1]) x_test = np.array([1.5, 2.5, 3.5]) k = 2 # Predicting values using k-NN regression predicted_values = k_nearest_neighbors_regression(x_train, y_train, x_test, k) print(f\\"Predicted values for {x_test}: {predicted_values}\\") ``` # Instructions: 1. Implement the function `k_nearest_neighbors_regression(x_train, y_train, x_test, k)` that performs the following steps: - For each test point in `x_test`, finds the `k` training points closest to it based on Euclidean distance. - Computes the average of the corresponding `y_train` values of these `k` nearest neighbors. - Returns an array of predicted values for the test points in `x_test`. 2. Ensure efficient handling of the nearest neighbor search.","solution":"import numpy as np def k_nearest_neighbors_regression(x_train, y_train, x_test, k=3): Predicts the output for new data points using the k-nearest neighbors algorithm for regression. Parameters: - x_train: A one-dimensional numpy array of floating point numbers (training data features). - y_train: A one-dimensional numpy array of floating point numbers (training data labels). - x_test: A one-dimensional numpy array of floating point numbers (test data features). - k: The number of nearest neighbors to consider (default is 3). Returns: - A one-dimensional numpy array of predicted values for the test data. predictions = [] for test_point in x_test: # Compute the distances from the test point to all training data points distances = np.abs(x_train - test_point) # Get the indices of the k closest points nearest_indices = np.argsort(distances)[:k] # Get the corresponding y values of the k closest points nearest_values = y_train[nearest_indices] # Compute the average of these y values prediction = np.mean(nearest_values) # Append the prediction to the results predictions.append(prediction) return np.array(predictions)"},{"question":"# Cumulative Salary Calculator As part of a payroll system, your task is to implement a function that calculates the cumulative salary of an employee over a given period. The cumulative salary is the total of all daily salaries for the given duration. Each salary is stored in a list, where each index represents a day and holds the salary for that specific day. Function Signature ```python def cumulative_salary(salaries: list, start_day: int, end_day: int) -> int: ``` Input * `salaries` - A list of integers where each integer represents the daily salary. * `start_day` - An integer representing the starting day (inclusive) from which the salary calculation should begin. * `end_day` - An integer representing the ending day (inclusive) up to which the salary calculation should be performed. Output * Returns an integer representing the cumulative salary over the specified period. Constraints * The function should handle invalid inputs gracefully (e.g., non-integer days, start_day greater than end_day, days out of range, non-list `salaries` input) by raising appropriate exceptions. * Ensure the function works efficiently for large lists with millions of entries. # Example Scenarios ```python >>> cumulative_salary([100, 200, 150, 300, 250], 1, 3) 650 >>> cumulative_salary([50, 60, 70, 80, 90], 0, 4) 350 >>> cumulative_salary([1000, 2000, 3000], 0, 2) 6000 >>> cumulative_salary([100, 200, 150], \'0\', 2) Traceback (most recent call last): ... TypeError: Day inputs must be integers >>> cumulative_salary([100, 200], 3, 5) Traceback (most recent call last): ... ValueError: Day inputs are out of range ``` # Guidelines 1. Validate the inputs for correct types and logical range correctness. 2. Compute the cumulative salary by summing the values in the `salaries` list from `start_day` to `end_day`. 3. Ensure the implementation runs efficiently, especially for large lists. Happy coding!","solution":"def cumulative_salary(salaries, start_day, end_day): Returns the cumulative salary over the specified period from start_day to end_day inclusive. Parameters: salaries (list): A list of integers where each integer represents the daily salary. start_day (int): The starting day (inclusive) from which to calculate the cumulative salary. end_day (int): The ending day (inclusive) up to which to calculate the cumulative salary. Returns: int: The cumulative salary over the specified period. Raises: TypeError: If the inputs are not of the correct type. ValueError: If the day inputs are out of range or start_day is greater than end_day. if not isinstance(salaries, list): raise TypeError(\\"salaries must be a list.\\") if not all(isinstance(salary, int) for salary in salaries): raise TypeError(\\"All elements in salaries must be integers.\\") if not isinstance(start_day, int) or not isinstance(end_day, int): raise TypeError(\\"Day inputs must be integers.\\") if start_day < 0 or end_day < 0 or start_day >= len(salaries) or end_day >= len(salaries): raise ValueError(\\"Day inputs are out of range.\\") if start_day > end_day: raise ValueError(\\"start_day cannot be greater than end_day.\\") return sum(salaries[start_day:end_day + 1])"},{"question":"# Depth-First Search Implementation Assessment Question Context Depth-First Search (DFS) is a fundamental algorithm in computer science used for traversing or searching tree or graph data structures. Understanding how to implement DFS is essential for various applications, including topological sorting, solving puzzles, and exploring mazes. Task You are required to implement a DFS algorithm for a graph represented as an adjacency list. Your function should return the nodes of the graph in the order they are visited by the DFS starting from a given node. Function Signature ```python def depth_first_search(graph: dict[int, list[int]], start_node: int) -> list[int]: pass ``` # Input 1. **graph**: A dictionary where each key is a node represented by an integer, and the value is a list of integers representing the node\'s neighbors. - (0 leq text{len(graph)} leq 1000) - Each node in the graph (both key and values) lies in the interval ([0, 10^6]) 2. **start_node**: An integer representing the node from which the DFS should start. - (0 leq text{start_node} leq 10^6) # Output A list of integers representing the nodes in the order they are visited by the DFS. # Constraints - Assume there are no duplicate edges or self-loops. - Your DFS should handle cyclic graphs gracefully. - If the start node is not in the graph, return an empty list. Example ```python # Example 1 graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 5], 3: [1], 4: [1], 5: [2] } start_node = 0 print(depth_first_search(graph, start_node)) # Expected Output: [0, 1, 3, 4, 2, 5] # Example 2 graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2] } start_node = 1 print(depth_first_search(graph, start_node)) # Expected Output: [1, 2, 4, 3] # Example 3 graph = {} start_node = 0 print(depth_first_search(graph, start_node)) # Expected Output: [] ``` Notes - Ensure your implementation does not include any forms of infinite loops or errors resulting from cyclic graphs. - The DFS traversal should be performed in a manner consistent with standard implementations, typically using a stack or a recursive function. - Consider using a set to keep track of visited nodes. - You may use helper functions to organize your code if necessary.","solution":"def depth_first_search(graph, start_node): Perform a depth-first search (DFS) on a graph starting from start_node. Parameters: graph (dict[int, list[int]]): The graph represented as an adjacency list. start_node (int): The starting node for the DFS. Returns: list[int]: The nodes in the order they are visited by the DFS. if start_node not in graph: return [] visited = set() result = [] def dfs(node): if node in visited: return visited.add(node) result.append(node) for neighbor in graph[node]: dfs(neighbor) dfs(start_node) return result"},{"question":"# Problem Statement You are given a directed acyclic graph (DAG) representation of tasks, where each task may depend on another task. Your goal is to determine the minimum number of time units required to complete all the tasks given that one time unit is needed to complete any task and multiple tasks can be processed concurrently if their dependencies are met. # Function Signature ```python def min_time_to_complete_tasks(tasks: int, dependencies: list[list[int]]) -> int: pass ``` # Input * `tasks` - an integer representing the number of tasks, labeled from 0 to tasks-1. * `dependencies` - a list of pairs of integers, where the pair [a, b] indicates that task `a` must be completed before task `b` can start. # Output * Return an integer, the minimum number of time units required to complete all tasks. # Constraints * 1 ≤ tasks ≤ 1000 * 0 ≤ len(dependencies) ≤ 5000 * 0 ≤ a, b < tasks * The graph is guaranteed to be a valid DAG # Example ```python tasks = 5 dependencies = [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]] print(min_time_to_complete_tasks(tasks, dependencies)) # Output: 4 ``` # Notes * Task labels are unique and range from 0 to tasks-1. * The minimum number of time units should consider the longest dependency path, as tasks with no dependencies can be completed simultaneously. * Use a topological sort to find the order of completing tasks and accordingly compute the minimum time needed.","solution":"def min_time_to_complete_tasks(tasks: int, dependencies: list[list[int]]) -> int: from collections import deque, defaultdict # Initialize the graph and the indegree count adj_list = defaultdict(list) indegree = [0] * tasks # Build the graph and the indegree array for dep in dependencies: u, v = dep adj_list[u].append(v) indegree[v] += 1 # Initialize the queue with tasks that have no prerequisites queue = deque() for i in range(tasks): if indegree[i] == 0: queue.append(i) time = [0] * tasks while queue: task = queue.popleft() task_time = time[task] + 1 for neighbor in adj_list[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) time[neighbor] = task_time return max(time) + 1"},{"question":"# Question **Substring Checking in a Circular String** You are tasked with implementing a function that checks if one string is a substring of another when the second string is treated as circular (i.e., it wraps around end-to-end). This means you should consider rotations of the second string to determine if the first string can be found within it. Your goal is to write a function: ```python def is_circular_substring(s1: str, s2: str) -> bool: pass ``` # Input * `s1`: A non-empty string that needs to be checked as a substring. * `s2`: A non-empty string that is treated as circular. # Output The function should return `True` if `s1` is a substring of any rotation of `s2`, otherwise `False`. # Constraints * All characters in both strings are ASCII characters. * Length of `s1` will be less than or equal to the length of `s2`. * Both strings contain at least one character. # Examples ```python >>> is_circular_substring(\\"abc\\", \\"cab\\") True >>> is_circular_substring(\\"abcd\\", \\"dabc\\") True >>> is_circular_substring(\\"abcd\\", \\"dcba\\") False >>> is_circular_substring(\\"aaa\\", \\"aaaaa\\") True >>> is_circular_substring(\\"abcd\\", \\"cdaab\\") True >>> is_circular_substring(\\"xyz\\", \\"abcdef\\") False ``` Implement the function `is_circular_substring` to fulfill all the given requirements. Ensure your function passes all the above examples.","solution":"def is_circular_substring(s1: str, s2: str) -> bool: Checks if s1 is a substring of any rotation of s2. if not s1 or not s2 or len(s1) > len(s2): return False # Concatenate s2 with itself to cover all possible rotations s2_doubled = s2 + s2 # Check if s1 is a substring of the concatenated result return s1 in s2_doubled"},{"question":"# Question: You are given a string `s` consisting of lowercase English letters, and you need to determine the minimum number of characters you need to remove from `s` to make it a palindrome. Implement a function `min_chars_to_remove_for_palindrome(s: str) -> int` that returns this minimum number. Input: * `s`: a string consisting of lowercase English letters. Output: * An integer representing the minimum number of deletions required to make the string a palindrome. Constraints: * `1 <= len(s) <= 1000` Example: ```python s = \\"abcda\\" # Removing \'b\' and \'c\' results in \\"adaa\\" which is a palindrome. assert min_chars_to_remove_for_palindrome(s) == 2 s = \\"ab\\" # Removing either \'a\' or \'b\' results in a palindrome. assert min_chars_to_remove_for_palindrome(s) == 1 s = \\"a\\" # The string is already a palindrome. assert min_chars_to_remove_for_palindrome(s) == 0 ``` Notes: * This problem can be approached using Dynamic Programming. * Consider how the problem relates to finding the longest palindromic subsequence of the string. Once you have the length of this subsequence, you can determine the minimum deletions required. * Edge cases include strings that are already palindromes or strings of length 1.","solution":"def min_chars_to_remove_for_palindrome(s: str) -> int: Returns the minimum number of characters to remove to make the string a palindrome. n = len(s) # Create a DP table to store the longest palindromic subsequence lengths dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the DP table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # The length of the longest palindromic subsequence lps_length = dp[0][n - 1] # Minimum deletions required is the difference between string length and LPS length return n - lps_length"},{"question":"# Array Manipulation: Segregate Even and Odd Numbers Problem Statement You are required to implement a function that segregates even and odd numbers in an array. The even numbers should come before the odd numbers while maintaining their relative order. Function Signature ```python def segregate_even_odd(arr: list[int]) -> list[int]: pass ``` Input - A list of integers `arr` (size `n` where `1 <= n <= 10^5`). Output - A new list of integers where all even numbers appear before all odd numbers, maintaining the relative order. Example ```python # Example 1 segregate_even_odd([1, 2, 3, 4, 5]) -> [2, 4, 1, 3, 5] # Example 2 segregate_even_odd([6, 7, 8, 9, 10]) -> [6, 8, 10, 7, 9] # Example 3 segregate_even_odd([1, 3, 5, 7]) -> [1, 3, 5, 7] # Example 4 segregate_even_odd([2, 4, 6, 8]) -> [2, 4, 6, 8] ``` Constraints - The function should perform an in-place modification if possible, attempting to use O(1) extra space. - The relative order of the even and odd numbers should be preserved. Additional Information - Ensure that your implementation handles edge cases such as an array with only even numbers, only odd numbers, or an empty array. - The input list can be assumed to be non-empty within the constraints. Make sure to test your function with various edge cases, including large arrays and arrays with mixed even and odd numbers. Ensure the solution is efficient for larger inputs.","solution":"def segregate_even_odd(arr: list[int]) -> list[int]: Returns a new list where even numbers appear before odd numbers while maintaining their relative order. if not arr: return arr evens = [x for x in arr if x % 2 == 0] odds = [x for x in arr if x % 2 != 0] return evens + odds"},{"question":"# Problem Description A company keeps track of employee data, including employee ID, name, department, and salary. Your task is to create a class called `Employee` and then write a function to filter employees based on their department and find the average salary of the filtered employees. # Class Definition ```python class Employee: def __init__(self, emp_id: int, name: str, department: str, salary: float): self.emp_id = emp_id self.name = name self.department = department self.salary = salary ``` # Function Signature ```python def average_salary_by_department(employees: list[Employee], department: str) -> float: ``` # Parameters - **employees** (list[Employee]): A list of `Employee` objects representing the employees of the company. - **department** (str): The department for which the average salary needs to be calculated. # Returns - Returns the average salary (as a float) of the employees in the given department. If there are no employees in the provided department, return 0.0. # Constraints - The list of employees may contain anywhere from 1 to 1000 `Employee` objects. - The salary of employees is a non-negative float. # Examples ```python # Example usage emp1 = Employee(1, \\"Alice\\", \\"HR\\", 50000.0) emp2 = Employee(2, \\"Bob\\", \\"Engineering\\", 60000.0) emp3 = Employee(3, \\"Charlie\\", \\"HR\\", 55000.0) emp4 = Employee(4, \\"David\\", \\"Marketing\\", 45000.0) employees = [emp1, emp2, emp3, emp4] >>> average_salary_by_department(employees, \'HR\') 52500.0 >>> average_salary_by_department(employees, \'Engineering\') 60000.0 >>> average_salary_by_department(employees, \'Marketing\') 45000.0 >>> average_salary_by_department(employees, \'Sales\') 0.0 ``` # Additional Notes - Ensure that the code handles cases where there are no employees in the given department gracefully by returning 0.0. - Emphasize writing clean, efficient, and maintainable code. - Consider edge cases and test your function thoroughly.","solution":"class Employee: def __init__(self, emp_id: int, name: str, department: str, salary: float): self.emp_id = emp_id self.name = name self.department = department self.salary = salary def average_salary_by_department(employees: list[Employee], department: str) -> float: department_salaries = [employee.salary for employee in employees if employee.department == department] if not department_salaries: return 0.0 return sum(department_salaries) / len(department_salaries)"},{"question":"# Task: Determine the Minimum Number of Swaps to Sort an Array You are tasked with implementing a function to determine the minimum number of swaps required to sort an array of distinct integers in ascending order. Function Signature ```python def min_swaps_to_sort(arr: list) -> int: ``` # Input * `arr`: A list of distinct integers representing the array to be sorted. # Output * An integer representing the minimum number of swaps required to sort the array. # Constraints * The length of the array will be between 1 and 10^5. * Each element in the array will be a distinct integer within the range from 1 to 10^5. # Performance Requirements * Your solution should run in O(n log n) time complexity, where n is the length of the array. * The space complexity should be O(n) for auxiliary data structures. # Example ```python >>> min_swaps_to_sort([4, 3, 1, 2]) 3 >>> min_swaps_to_sort([1, 5, 4, 3, 2]) 2 >>> min_swaps_to_sort([3, 2, 1]) 1 ``` # Notes * The function should efficiently find the minimum number of adjacent swaps required to sort the array. * The approach should ideally involve tracking visited elements and cycles within the permutation induced by the array.","solution":"def min_swaps_to_sort(arr: list) -> int: n = len(arr) arr_pos = [(val, i) for i, val in enumerate(arr)] arr_pos.sort(key=lambda it: it[0]) visited = [False] * n swaps = 0 for i in range(n): if visited[i] or arr_pos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arr_pos[j][1] cycle_size += 1 if cycle_size > 0: swaps += (cycle_size - 1) return swaps"},{"question":"# Problem Description You are given an array `arr` of positive integers. Your task is to find the smallest positive integer that is a multiple of all the numbers in the array. Write a function `find_lcm` that: - Takes `arr` as an input list of positive integers. - Returns the smallest positive integer that is the Least Common Multiple (LCM) of all the elements in the array. # Function Signature ```python def find_lcm(arr: list) -> int: pass ``` # Input - `arr`: A list of positive integers `1 <= arr[i] <= 1000` and `1 <= len(arr) <= 50` # Output - An integer which is the LCM of the array elements. # Example ```python assert find_lcm([1, 2, 3, 4, 5]) == 60 assert find_lcm([2, 7, 3, 9, 4]) == 252 assert find_lcm([5, 10, 20]) == 20 ``` # Constraints - Ensure your solution handles up to the maximum input sizes efficiently. - You may use math library functions to aid in calculations where appropriate.","solution":"import math from functools import reduce def lcm(a, b): Helper function to find the Least Common Multiple (LCM) of two numbers. return abs(a * b) // math.gcd(a, b) def find_lcm(arr): Returns the Least Common Multiple (LCM) of all the numbers in the array. return reduce(lcm, arr)"},{"question":"Coding Assessment Question: Optimizing Memory Management using Linked Lists **Scenario**: You are working as a software engineer focused on improving memory management in a custom operating system. The current system uses a simplistic fixed-size partitioning scheme, leading to inefficient memory usage and frequent internal fragmentation. To address this issue, you are tasked with implementing a dynamic memory management system using linked lists, where memory is allocated and deallocated dynamically. **Objective**: Implement a function `dynamic_memory_allocator` that handles memory allocation and deallocation using linked lists to minimize fragmentation and efficiently utilize available memory. Include helper functions for merging adjacent free blocks and splitting blocks when larger allocations are required. Input: - `operations`: A list of tuples, where each tuple represents either an allocation or deallocation request. - An allocation request is represented as `(\'alloc\', process_id, memory_size)`. - A deallocation request is represented as `(\'release\', process_id)`. - `memory_size`: An integer representing the total size of the memory. The `MemoryBlock` class definition and `LinkedList` class structure are provided. You will be expanding this with your dynamic memory management logic. Output: - A list of integers representing the start addresses for each allocated memory block, in the order they were allocated. - A list of `(start_address, size)` tuples representing the state of free memory blocks after all operations have been processed. ```python class MemoryBlock: def __init__(self, start: int, size: int) -> None: self.start = start self.size = size self.next = None class LinkedList: def __init__(self) -> None: self.head = None def allocate(self, process_id: int, size: int) -> int: Allocate memory block for the process with given size. # Placeholder: Implement the memory allocation logic using linked list here. pass def release(self, process_id: int) -> None: Release memory block allocated to the process. # Placeholder: Implement the memory deallocation logic here. pass def merge_free_blocks(self) -> None: Merge adjacent free memory blocks to reduce fragmentation. # Placeholder: Implement merge logic for adjacent free blocks. pass def get_free_blocks(self) -> list[tuple[int, int]]: Get the list of free memory blocks. # Placeholder: Retrieve the list of free memory blocks. pass def dynamic_memory_allocator(operations: list[tuple[str, int, int]], memory_size: int) -> tuple[list[int], list[tuple[int, int]]]: Core memory management function that processes allocation and deallocation requests dynamically. free_list = LinkedList() free_list.head = MemoryBlock(0, memory_size) # Initialize with the entire memory as a single free block. allocation_addresses = [] for operation in operations: if operation[0] == \'alloc\': _, process_id, size = operation address = free_list.allocate(process_id, size) allocation_addresses.append(address) elif operation[0] == \'release\': _, process_id = operation free_list.release(process_id) free_list.merge_free_blocks() free_blocks = free_list.get_free_blocks() return allocation_addresses, free_blocks # Example usage: if __name__ == \\"__main__\\": operations = [ (\'alloc\', 1, 100), (\'alloc\', 2, 200), (\'release\', 1), (\'alloc\', 3, 50), ] memory_size = 500 allocation_addresses, free_blocks = dynamic_memory_allocator(operations, memory_size) print(f\\"Allocation Addresses: {allocation_addresses}\\") print(f\\"Free Blocks: {free_blocks}\\") ``` Constraints: 1. The allocation size should always be at least 1 and at most the total memory size. 2. Ensure memory management handles both small and large allocation requests appropriately. 3. Deallocation should correctly merge adjacent free blocks to maintain low fragmentation. 4. Processes that request more memory than available should be managed gracefully. Requirements: - Correctly implement the `allocate`, `release`, `merge_free_blocks`, and `get_free_blocks` methods based on the provided scenario and specifications. - Ensure your solution is tested for correctness and edge cases using the class provided. **Note**: This question assesses your understanding of dynamic memory management using linked lists, as well as your ability to implement sophisticated data structures and algorithms.","solution":"class MemoryBlock: def __init__(self, start: int, size: int) -> None: self.start = start self.size = size self.next = None self.process_id = None # Store which process is using this block (None if free) class LinkedList: def __init__(self) -> None: self.head = None def allocate(self, process_id: int, size: int) -> int: # Iterate through the linked list to find the first free block of sufficient size current = self.head prev = None while current: if current.process_id is None and current.size >= size: # Allocate memory block to process alloc_start = current.start if current.size > size: new_block = MemoryBlock(alloc_start + size, current.size - size) new_block.next = current.next current.next = new_block current.size = size current.process_id = process_id return alloc_start prev = current current = current.next # If no suitable block found, allocation fails (We assume allocation will always succeed for simplicity) return -1 def release(self, process_id: int) -> None: current = self.head while current: if current.process_id == process_id: current.process_id = None # Mark the block as free return current = current.next def merge_free_blocks(self) -> None: current = self.head while current and current.next: if current.process_id is None and current.next.process_id is None: # Merge current and next free blocks current.size += current.next.size current.next = current.next.next else: current = current.next def get_free_blocks(self) -> [(int, int)]: free_blocks = [] current = self.head while current: if current.process_id is None: free_blocks.append((current.start, current.size)) current = current.next return free_blocks def dynamic_memory_allocator(operations: [(str, int, int)], memory_size: int) -> ([int], [(int, int)]): free_list = LinkedList() free_list.head = MemoryBlock(0, memory_size) # Initialize with the entire memory as a single free block. allocation_addresses = [] for operation in operations: if operation[0] == \'alloc\': _, process_id, size = operation address = free_list.allocate(process_id, size) allocation_addresses.append(address) elif operation[0] == \'release\': _, process_id = operation free_list.release(process_id) free_list.merge_free_blocks() free_blocks = free_list.get_free_blocks() return allocation_addresses, free_blocks # Example usage: if __name__ == \\"__main__\\": operations = [ (\'alloc\', 1, 100), (\'alloc\', 2, 200), (\'release\', 1), (\'alloc\', 3, 50), ] memory_size = 500 allocation_addresses, free_blocks = dynamic_memory_allocator(operations, memory_size) print(f\\"Allocation Addresses: {allocation_addresses}\\") print(f\\"Free Blocks: {free_blocks}\\")"},{"question":"# Question: Longest Sequence of Consecutive Characters As part of your programming exercises, you\'re tasked with writing a Python function that determines the length of the longest sequence of consecutive, identical characters in a given string. Problem Statement Given a string ( s ), determine the length of the longest contiguous sequence where the same character repeats. Input * A string ( s ) ( (1 leq text{len}(s) leq 10^5) ) consisting of only lowercase English letters. Output * An integer representing the length of the longest sequence of consecutive, identical characters. Example * **Input**: ( s = \\"aaabbccccdd\\" ) * **Output**: 4 Use the following function signature for your solution: ```python def longest_consecutive_sequence(s: str) -> int: pass ``` Constraints * Ensure your solution is optimized for a string length up to ( 10^5 ). * Your implementation should handle edge cases where the string is made up of completely different characters or is entirely comprised of the same character. Additional Notes * Avoid using external libraries for this problem; stick to core Python functionalities. * Consider edge cases in testing, such as strings of minimum length and ones with mixed character sequences. * Efficiently iterate through the string to find the longest contiguous sequence without unnecessary computations. Good Luck!","solution":"def longest_consecutive_sequence(s: str) -> int: if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Problem Statement You are working on an inventory management system for a retail store. Your task is to create a function that determines the minimum number of sales transactions needed to achieve a target revenue. # Requirements Write a function `min_transactions(prices: List[int], target: int) -> int` that takes a list of item prices and a target revenue, and returns the minimum number of sales transactions needed to reach or exceed the target revenue. If it is not possible to achieve the target revenue, return -1. # Input Format - `prices`: A list of integers where each integer ( p_j ) (1 ≤ ( p_j ) ≤ 10,000) represents the price of an item. (1 ≤ length of `prices` ≤ 1,000) - `target`: An integer (1 ≤ `target` ≤ 10,000,000) representing the required revenue. # Output Format - An integer representing the minimum number of transactions required to achieve the target revenue, or -1 if it is not possible. # Constraints - You can sell each item an unlimited number of times. # Example ```python assert min_transactions([1, 2, 3], 7) == 3 # 3 + 3 + 1 assert min_transactions([5, 3, 4], 11) == 3 # 5 + 3 + 3 or 4 + 4 + 3 assert min_transactions([10, 20, 30], 5) == -1 # Not possible assert min_transactions([1, 2, 3], 0) == 0 # No revenue needed ``` # Notes - Carefully handle edge cases such as an empty price list or a target of 0. - Optimize for both time and space complexity as per the provided constraints.","solution":"from typing import List def min_transactions(prices: List[int], target: int) -> int: if target == 0: return 0 # Initialize dp array with a very large number, larger than any possible number of transactions dp = [float(\'inf\')] * (target + 1) dp[0] = 0 for i in range(1, target + 1): for price in prices: if price <= i: dp[i] = min(dp[i], dp[i - price] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"# Maximum Subarray Sum using Divide and Conquer Objective You are given an integer array. Your task is to implement a function that finds the sum of the maximum sum subarray using the divide-and-conquer approach. Function Signature ```python def max_subarray_sum(arr: List[int]) -> int: pass ``` Input - `arr`: A list of integers representing the array. The number of elements is denoted as n (1 ≤ n ≤ 10^5). Output - An integer representing the sum of the maximum sum subarray. Constraints - The elements of the array can be negative or positive integers. - The array is non-empty. Example ```python # Example 1 arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4] assert max_subarray_sum(arr) == 6 # Example 2 arr = [1, 2, 3, 4, 5] assert max_subarray_sum(arr) == 15 # Example 3 arr = [-1, -2, -3, -4] assert max_subarray_sum(arr) == -1 ``` Explanation In the first example, the maximum subarray sum is obtained from the subarray [4, -1, 2, 1], which sums to 6. In the second example, the entire array forms the maximum subarray with a sum of 15. In the third example, the maximum subarray sum is -1 as all elements are negative, so the highest single element is considered. Notes - Adopt the divide-and-conquer strategy to ensure the solution is optimal and efficient. - Ensure to handle edge cases, such as when all elements are negative or when the array contains a single element. - Clear, modular code with appropriate comments is encouraged for better readability.","solution":"from typing import List def max_crossing_sum(arr: List[int], left: int, mid: int, right: int) -> int: left_sum = float(\'-inf\') curr_sum = 0 for i in range(mid, left - 1, -1): curr_sum += arr[i] if curr_sum > left_sum: left_sum = curr_sum right_sum = float(\'-inf\') curr_sum = 0 for i in range(mid + 1, right + 1): curr_sum += arr[i] if curr_sum > right_sum: right_sum = curr_sum return left_sum + right_sum def max_subarray_sum_recursive(arr: List[int], left: int, right: int) -> int: if left == right: return arr[left] mid = (left + right) // 2 left_sum = max_subarray_sum_recursive(arr, left, mid) right_sum = max_subarray_sum_recursive(arr, mid + 1, right) crossing_sum = max_crossing_sum(arr, left, mid, right) return max(left_sum, right_sum, crossing_sum) def max_subarray_sum(arr: List[int]) -> int: return max_subarray_sum_recursive(arr, 0, len(arr) - 1)"},{"question":"**Binary Tree Paths** You are given a binary tree. Your task is to return all root-to-leaf paths in the form of strings. Implement the function `binary_tree_paths(root: Optional[TreeNode]) -> List[str]` to solve this problem. # Function Signature ```python from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: pass ``` # Input - `root`: A `TreeNode` representing the root of the binary tree (1 ≤ number of nodes ≤ 1000). - Each node contains an integer value `val` (-1000 ≤ `val` ≤ 1000). - Leaf nodes are the nodes without any children. # Output - Returns a list of root-to-leaf paths where each path is represented by a string. - Each string path should consist of the node values separated by \\"->\\". # Example ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> binary_tree_paths(root) [\\"1->2->5\\", \\"1->3\\"] >>> root = TreeNode(1) >>> binary_tree_paths(root) [\\"1\\"] ``` # Explanation 1. In the first example, the binary tree can be visualized as: ``` 1 / 2 3 5 ``` - The root-to-leaf paths are \\"1->2->5\\" and \\"1->3\\". 2. In the second example, the binary tree contains only one node which is the root itself. Hence, the only path is \\"1\\". # Constraints - You should not use external libraries for tree traversal. - The solution should efficiently handle trees with up to 1000 nodes.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: Optional[TreeNode]) -> List[str]: def dfs(node, path): if node: path.append(str(node.val)) if not node.left and not node.right: # if leaf node paths.append(\\"->\\".join(path)) else: dfs(node.left, path) dfs(node.right, path) path.pop() paths = [] dfs(root, []) return paths"},{"question":"# Problem: You are given a list of integers representing the heights of buildings along a straight street. Your task is to write a function `count_visible_buildings` that counts how many buildings have an unobstructed view of the sunset, assuming the sunset is on the right side of the street (end of the list). # Requirements: 1. **Input**: A list of integers `heights` where each integer represents the height of a building. 2. **Output**: An integer representing the count of buildings with an unobstructed view of the sunset. 3. **Constraints**: - The list `heights` can have up to (10^5) elements. - Each building height is a positive integer up to (10^6). # Performance: - The solution should have a time complexity of **O(N)** and use **O(1)** additional space. # Example: ```python def count_visible_buildings(heights: list[int]) -> int: # Write your code here pass # Sample Test Cases print(count_visible_buildings([3, 7, 8, 3, 6, 1])) # Expected Output: 3 print(count_visible_buildings([1, 2, 3, 4])) # Expected Output: 1 print(count_visible_buildings([4, 3, 2, 1])) # Expected Output: 4 ``` # Explanation: - In the first example `[3, 7, 8, 3, 6, 1]`, the buildings that can see the sunset are the ones with heights 8, 6, and 1. - In the second example `[1, 2, 3, 4]`, only the last building with height 4 can see the sunset. - In the third example `[4, 3, 2, 1]`, all buildings can see the sunset because each building is taller than the one to its right. # Approach: - Traverse the list from right to left, keeping track of the maximum height seen so far. - Count a building as having an unobstructed view if its height is greater than the maximum height encountered after it.","solution":"def count_visible_buildings(heights): Returns the number of buildings with an unobstructed view of the sunset. The sunset is assumed to be on the right side of the list. :param heights: List of integers representing the heights of buildings. :return: Integer count of buildings with an unobstructed view. if not heights: return 0 max_height = 0 visible_count = 0 for height in reversed(heights): if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"# Sorting Usernames by Length and Alphabetically You are required to write a function that takes a list of usernames and returns the sorted list. The usernames should be sorted first by their length in ascending order, and then alphabetically for usernames of the same length. If the input contains duplicate usernames, they should appear only once in the output. Additionally, the function should handle invalid input gracefully, specifically when the input is not a list or when the list contains elements that are not strings. # Requirements: 1. **Sorting Logic**: - First, sort by length of the usernames in ascending order. - For usernames with the same length, sort alphabetically in ascending order. 2. **Duplicate Removal**: - Ensure that each username appears only once in the output. 3. **Error Handling**: - If the input is not a list, raise a `TypeError` with a message \\"Input must be a list.\\" - If the list contains elements that are not strings, raise a `ValueError` with a message \\"All elements in the input list must be strings.\\" 4. **Function Signature**: - `def sort_usernames(usernames: list) -> list:` 5. **Example**: ```python >>> sort_usernames([\\"amy\\", \\"bob\\", \\"alice\\", \\"bob\\", \\"charlie\\", \\"dan\\", \\"amy\\"]) [\'amy\', \'bob\', \'dan\', \'alice\', \'charlie\'] >>> sort_usernames([\\"xyz\\", \\"abc\\", \\"def\\", \\"ghij\\", \\"ab\\"]) [\'ab\', \'abc\', \'def\', \'xyz\', \'ghij\'] >>> sort_usernames(123) Traceback (most recent call last): ... TypeError: Input must be a list. >>> sort_usernames([\\"hello\\", 123, \\"world\\"]) Traceback (most recent call last): ... ValueError: All elements in the input list must be strings. ``` # Constraints: 1. The function should handle lists with a length of up to 10000 usernames. 2. Each username should be a valid string with a maximum length of 100 characters.","solution":"def sort_usernames(usernames): Returns a list of usernames sorted first by length and then alphabetically. Duplicate usernames are removed, and input contains only strings. if not isinstance(usernames, list): raise TypeError(\\"Input must be a list.\\") for username in usernames: if not isinstance(username, str): raise ValueError(\\"All elements in the input list must be strings.\\") # Remove duplicates by converting to a set and back to a list unique_usernames = list(set(usernames)) # Sort by length first, then alphabetically sorted_usernames = sorted(unique_usernames, key=lambda x: (len(x), x)) return sorted_usernames"},{"question":"# Scenario You are part of a team developing an educational application that includes various tools for math practice. One of the features requested by users is the ability to generate a formatted multiplication table for a given number up to a specified range. # Problem Statement Your task is to implement a new function in the application that generates a multiplication table for a specified number. The table should be well formatted and list the products from 1 up to the given range for the specified number. # Requirements You need to implement the `generate_multiplication_table` function that takes two parameters: 1. `number` (int): The number for which to create the multiplication table. 2. `up_to` (int): The range up to which the multiplication table should be generated. The function should return a string representation of the multiplication table, with each line formatted as follows: ``` <number> x <multiplier> = <product> ``` Ensure that each line is justified so that the equal signs align vertically. # Input - `number`: an integer representing the base number for the multiplication table. - `up_to`: an integer representing the highest multiplier for the multiplication table. # Output - Returns a string representing the formatted multiplication table. # Constraints - `number` will be a positive integer (1 ≤ number ≤ 100). - `up_to` will be a positive integer (1 ≤ up_to ≤ 20). # Example ```python def generate_multiplication_table(number: int, up_to: int) -> str: Generates a multiplication table for the given number up to the specified range. Parameters: number (int): The base number for the multiplication table. up_to (int): The highest multiplier for the multiplication table. Returns: str: The formatted multiplication table as a string. table_lines = [ f\\"{number:3} x {multiplier:2} = {number * multiplier:4}\\" for multiplier in range(1, up_to + 1) ] return \\"n\\".join(table_lines) # Example usage: print(generate_multiplication_table(5, 10)) # Should output: 5 x 1 = 5 5 x 2 = 10 5 x 3 = 15 5 x 4 = 20 5 x 5 = 25 5 x 6 = 30 5 x 7 = 35 5 x 8 = 40 5 x 9 = 45 5 x 10 = 50 print(generate_multiplication_table(12, 12)) # Should output: 12 x 1 = 12 12 x 2 = 24 12 x 3 = 36 12 x 4 = 48 12 x 5 = 60 12 x 6 = 72 12 x 7 = 84 12 x 8 = 96 12 x 9 = 108 12 x 10 = 120 12 x 11 = 132 12 x 12 = 144 ```","solution":"def generate_multiplication_table(number: int, up_to: int) -> str: Generates a multiplication table for the given number up to the specified range. Parameters: number (int): The base number for the multiplication table. up_to (int): The highest multiplier for the multiplication table. Returns: str: The formatted multiplication table as a string. table_lines = [ f\\"{number} x {multiplier} = {number * multiplier}\\" for multiplier in range(1, up_to + 1) ] return \\"n\\".join(table_lines)"},{"question":"# Coding Question: Validate Perfect Square Using Binary Search Objective Write a function that checks if a given positive integer is a perfect square. The function should include thorough validation for input types and adhere to the given constraints. Function Signature ```python def is_perfect_square(number: int) -> bool: Return True if this number is a perfect square or False otherwise. ``` Description **You need to implement a function `is_perfect_square(number)` that returns `True` if the input number is a perfect square, and `False` otherwise.** Input and Output Formats **Input**: * A single integer `number`. **Output**: * A boolean value: `True` if the input integer is a perfect square, `False` otherwise. Constraints 1. The function should raise a `TypeError` if the input is not an integer. 2. The function should raise a `ValueError` if the input is not a positive integer. 3. The function should efficiently determine if the number is a perfect square using binary search. Examples ```python >>> is_perfect_square(1) True >>> is_perfect_square(2) False >>> is_perfect_square(4) True >>> is_perfect_square(10) False >>> is_perfect_square(16) True >>> is_perfect_square(25) True >>> is_perfect_square(-4) Traceback (most recent call last): ... ValueError: number must be positive >>> is_perfect_square(2.5) Traceback (most recent call last): ... TypeError: number must be an integer ``` Implementation Notes * Utilize binary search to find if the integer has an integer square root. * Ensure the function checks for integer type and positive value before processing. * You may use Python\'s built-in exceptions for handling invalid inputs.","solution":"def is_perfect_square(number: int) -> bool: Return True if this number is a perfect square or False otherwise. if not isinstance(number, int): raise TypeError(\\"number must be an integer\\") if number <= 0: raise ValueError(\\"number must be positive\\") left, right = 1, number while left <= right: mid = (left + right) // 2 mid_squared = mid * mid if mid_squared == number: return True elif mid_squared < number: left = mid + 1 else: right = mid - 1 return False"},{"question":"# Problem Statement: Optimized Anagram Grouping Design a function that groups an array of strings into anagram sets. Anagrams are words that contain the same characters in different orders. The function should be optimized for performance to handle large input sizes efficiently. # Requirements: 1. **Function Name**: `group_anagrams(strs: List[str]) -> List[List[str]]` 2. **Input**: List of strings `strs` (1 ≤ len(strs) ≤ 10^5, 1 ≤ len(strs[i]) ≤ 100) 3. **Output**: List of lists of strings, each sublist containing strings that are anagrams of each other. 4. **Constraints**: - All input strings consist of lowercase English letters. # Example: ```python >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> group_anagrams([\\"\\"]) [[\'\']] >>> group_anagrams([\\"a\\"]) [[\'a\']] ``` # Performance Note: - The implementation should leverage hashing and sorting to optimize the grouping of anagrams. # Hints: - Consider using a dictionary where the key is a tuple of sorted characters. - Evaluate different ways to generate the key to balance between sorting and hashing speed.","solution":"from collections import defaultdict from typing import List def group_anagrams(strs: List[str]) -> List[List[str]]: anagrams = defaultdict(list) for s in strs: sorted_s = tuple(sorted(s)) anagrams[sorted_s].append(s) return list(anagrams.values())"},{"question":"# Implement a Function to Reverse a Sublist in a Linked List Given a singly linked list and two integers, `m` and `n`, write a function called `reverse_sublist` that reverses the nodes of the list from position `m` to `n` in one pass. The positions are 1-indexed, and you may not use any extra space apart from a few pointers. # Function Signature ```python def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode: ``` # Parameters and Constraints - `head` is the head node of a singly linked list. - `m` and `n` are integers such that 1 ≤ m ≤ n ≤ length of the list. - You cannot use any extra data structures and should aim for O(1) space complexity. - The function should run in O(n) time where n is the number of nodes in the list. # Example ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next # Helper function to create a linked list from a list and return the head def create_list(lst): dummy = ListNode(0) curr = dummy for val in lst: curr.next = ListNode(val) curr = curr.next return dummy.next # Helper function to convert a linked list to a list def to_list(head): lst = [] while head: lst.append(head.value) head = head.next return lst head = create_list([1, 2, 3, 4, 5]) new_head = reverse_sublist(head, 2, 4) assert to_list(new_head) == [1, 4, 3, 2, 5] ``` # Additional Notes - Ensure your implementation correctly handles edge cases, such as when `m` equals `n` or when `m` or `n` is at the boundaries of the list. - You should validate positions to ensure they adhere to the constraints.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_sublist(head: ListNode, m: int, n: int) -> ListNode: if m == n: # No need to reverse if m == n return head dummy = ListNode(0) dummy.next = head pre = dummy # Move `pre` to point to the node just before the reversal starts for _ in range(m - 1): pre = pre.next # `start` points to the first node of the reversal segment # `then` points to the next node to be reversed start = pre.next then = start.next # Reverse the sublist for _ in range(n - m): start.next = then.next then.next = pre.next pre.next = then then = start.next return dummy.next # Helper function to create a linked list from a list and return the head def create_list(lst): dummy = ListNode(0) curr = dummy for val in lst: curr.next = ListNode(val) curr = curr.next return dummy.next # Helper function to convert a linked list to a list def to_list(head): lst = [] while head: lst.append(head.value) head = head.next return lst"},{"question":"# Coding Assessment Question You are given the following programming problem involving string transformation and optimization: Problem Statement: Given a string `s`, your task is to find the minimum number of modifications needed so that no two adjacent characters are the same. You can perform the following operation: replace any character in the string with any other character. Your Task: Implement the function `min_modifications` to determine the minimum number of modifications required to achieve the desired outcome. **Function Signature**: ```python def min_modifications(s: str) -> int: pass ``` **Constraints**: - ( 1 leq |s| leq 10^5 ) - The string `s` contains only lowercase English letters. **Expected Output**: - The function should return an integer representing the minimum number of modifications needed to ensure no two adjacent characters in the string are the same. Example Usage: ```python print(min_modifications(\\"aab\\")) # Should return 1, as we can change one \'a\' to another character print(min_modifications(\\"aaaa\\")) # Should return 2, as we can alternate characters like \\"abab\\" ``` **Note**: - Consider edge cases where the string is already compliant, or it consists of all identical characters. **Performance Considerations**: - Optimize your solution for linear complexity, given the potentially large size of the input string.","solution":"def min_modifications(s: str) -> int: Function to determine the minimum number of modifications needed so that no two adjacent characters in the string are the same. modifications = 0 # Iterate through the string, starting from the second character for i in range(1, len(s)): if s[i] == s[i - 1]: # Increment the modifications counter when two adjacent characters are the same modifications += 1 # Change the current character to ensure no two adjacent are the same # This change doesn\'t need to be specific, as we\'re just counting modifications # To avoid future conflicts we can set current s[i] to some character different from s[i-1] s = s[:i] + \'*\' + s[i+1:] return modifications"},{"question":"# Coding Assessment Question: Implementing a Custom Sorting Algorithm You are tasked with implementing a custom sorting algorithm that sorts an array of integers based on the frequency of the elements. If two elements have the same frequency, the one which appeared first in the array should come first. This custom sorting algorithm will help optimize certain operations where frequency-based sorting is more effective. **Objective**: Create a function `frequency_sort` that sorts an array according to the above criteria. # Function Signature ```python def frequency_sort(arr: list[int]) -> list[int]: pass ``` # Input - `arr` (list of int): The input list of integers that needs to be sorted. # Output - Returns a list of integers sorted based on frequency in descending order. If two elements have the same frequency, they should appear in the order they first appeared in the original list. # Constraints - The input list `arr` should contain at least one integer. - All integers in the input list are valid. - The length of `arr` will not exceed 10^5. # Requirements - Implement the `frequency_sort` function. - You are allowed to use the collections module in Python for handling frequency calculations. - Ensure the time complexity of your solution is optimized for large inputs. # Example ```python arr = [4, 5, 6, 5, 4, 3] # Performing frequency-based sorting result = frequency_sort(arr) print(\\"Sorted array based on frequency:\\", result) # Expected Output: [4, 4, 5, 5, 6, 3] arr2 = [9, 9, 1, 2, 3, 1, 2, 2] result = frequency_sort(arr2) print(\\"Sorted array based on frequency:\\", result) # Expected Output: [2, 2, 2, 9, 9, 1, 1, 3] ``` # Hints - Make use of Python\'s `collections.Counter` to calculate frequencies efficiently. - Think about how you can maintain the relative order of elements with the same frequency. - Consider using additional data structures like dictionaries paired with lists to keep track of indices or initial positions.","solution":"from collections import Counter def frequency_sort(arr: list[int]) -> list[int]: Sort an array based on the frequency of elements. If two elements have the same frequency, they should appear in the order they first appeared in the original list. # Count the frequency of each element in the array freq = Counter(arr) # Sort the elements first by frequency (in descending order) and then by original index sorted_arr = sorted(arr, key=lambda x: (-freq[x], arr.index(x))) return sorted_arr"},{"question":"# Problem Statement You are given a list of non-negative integers representing the amount of money in each house along a street. You are a professional burglar, but you can’t rob two adjacent houses because it will trigger the alarm system. Your task is to determine the maximum amount of money you can rob tonight without triggering the alarm. # Function Signature ```python def rob(nums: list[int]) -> int: pass ``` **Input Format**: - `nums` (list[int]): A list of non-negative integers representing money in each house. **Output Format**: - Returns an integer representing the maximum amount of money you can rob without triggering the alarm. **Constraints**: - 0 <= len(nums) <= 10^4 - 0 <= nums[i] <= 10^4 # Example Usage ```python houses1 = [1, 2, 3, 1] print(rob(houses1)) # Output: 4 houses2 = [2, 7, 9, 3, 1] print(rob(houses2)) # Output: 12 ``` **Explanation**: - For the first example: You can rob house 1 (money = 1) and then rob house 3 (money = 3), obtaining a total of 1 + 3 = 4. - For the second example: You can rob house 1 (money = 2), then rob house 3 (money = 9), and last rob house 5 (money = 1) obtaining a total of 2 + 9 + 1 = 12. # Evaluation Criteria 1. Correctness: The solution should correctly return the maximum amount of money you can rob without triggering the alarm. 2. Efficiency: The solution should perform within acceptable time limits given the constraints. 3. Edge Handling: Solutions should handle edge cases, such as when there are no houses or when there is only one house. 4. Code Quality: The implementation should be clean, well-documented, and easy to understand.","solution":"def rob(nums: list[int]) -> int: Returns the maximum amount of money that can be robbed without triggering the alarm by robbing two adjacent houses. if not nums: return 0 if len(nums) == 1: return nums[0] dp = [0] * len(nums) dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"# Task: Log Analyzer You are tasked with creating a log analyzer for a web server. The log analyzer should be able to parse the logs, identify the most frequently accessed URLs, and determine the range of dates present in the logs. Part 1: Log Parsing Write a function `parse_logs(logs: List[str]) -> Dict[str, int]` that: - Takes a list of strings `logs` as input where each string represents a log entry in the format: `\\"[timestamp] URL\\"`. - Example log entry: `\\"[2023-10-01 12:00:00] /index.html\\"` - Returns a dictionary with URLs as keys and their access counts as values. Constraints: - The logs will have timestamps formatted as `\\"[YYYY-MM-DD HH:MM:SS]\\"`. - The URLs will always follow the timestamp and a space character. Part 2: Date Range Detection Write a function `date_range(logs: List[str]) -> Tuple[str, str]` that: - Takes a list of strings `logs` as input where each string represents a log entry in the same format. - Returns a tuple with two string elements representing the earliest and latest timestamps found in the logs in the `\\"[YYYY-MM-DD HH:MM:SS]\\"` format. Example ```python >>> logs = [ ... \\"[2023-10-01 12:00:00] /index.html\\", ... \\"[2023-10-02 14:00:00] /about.html\\", ... \\"[2023-10-01 12:00:00] /contact.html\\", ... \\"[2023-10-01 12:00:00] /index.html\\" ... ] >>> parse_logs(logs) {\'/index.html\': 2, \'/about.html\': 1, \'/contact.html\': 1} >>> date_range(logs) (\'[2023-10-01 12:00:00]\', \'[2023-10-02 14:00:00]\') ``` Requirements - Ensure that the log parsing accurately counts the number of times each URL is accessed. - Ensure that the date range detection correctly identifies the earliest and latest timestamps. Implement both the `parse_logs` and `date_range` functions in Python.","solution":"from typing import List, Dict, Tuple def parse_logs(logs: List[str]) -> Dict[str, int]: Parse the logs to count URL access frequency. Args: logs (List[str]): List of log entries in the format \\"[timestamp] URL\\" Returns: Dict[str, int]: Dictionary with URLs as keys and their access counts as values. url_count = {} for log in logs: # Extract the URL from the log entry url = log.split(\'] \')[1] if url in url_count: url_count[url] += 1 else: url_count[url] = 1 return url_count def date_range(logs: List[str]) -> Tuple[str, str]: Determine the range of dates present in the logs. Args: logs (List[str]): List of log entries in the format \\"[YYYY-MM-DD HH:MM:SS] URL\\" Returns: Tuple[str, str]: Earliest and latest timestamps in the log entries. if not logs: return (\\"\\", \\"\\") # Edge case: empty logs timestamps = [log.split(\'] \')[0] + \']\' for log in logs] earliest = min(timestamps) latest = max(timestamps) return (earliest, latest)"},{"question":"# Coding Question: Length of the Longest Substring Without Repeating Characters **Objective**: Write a function that returns the length of the longest substring without repeating characters in a given string. # Problem Statement: Given a string, find the length of the longest substring that does not contain any repeating characters. # Function Signature: ```python def length_of_longest_substring(s: str) -> int: # Your code goes here ``` # Constraints: - **Input**: A single string `s` with length between 0 and 10^4 characters. - **Output**: An integer representing the length of the longest substring without repeating characters. - **Performance Requirement**: Aim for a solution with O(n) time complexity, where n is the length of the string. - **Edge Cases**: - An empty string should return 0. - A string with all identical characters should return 1. # Example: ```python # Example Usage print(length_of_longest_substring(\\"abcabcbb\\")) # Expected Output: 3 (substring is \\"abc\\") print(length_of_longest_substring(\\"bbbbb\\")) # Expected Output: 1 (substring is \\"b\\") print(length_of_longest_substring(\\"pwwkew\\")) # Expected Output: 3 (substring is \\"wke\\") print(length_of_longest_substring(\\"\\")) # Expected Output: 0 (empty string) ``` # Scenario: You are building a text editor with advanced features, including an autocomplete system that relies on the frequency and distribution of substrings. To optimize your autocomplete suggestions, you need to analyze text efficiently, identifying unique sequences of characters. This function will help to determine the length of the longest portion of text without repeating characters. # Additional Notes: You can use a sliding window approach to maintain a window that contains unique characters and expand/shrink this window to find the longest substring without repeating characters. This approach ensures linear time complexity.","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Graph Pathfinding with Dijkstra\'s Algorithm You are given a directed, weighted graph represented as an adjacency list and a source vertex. Your task is to implement Dijkstra\'s algorithm to find the shortest paths from the source vertex to all other vertices in the graph. Function Signature: ```python def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: # graph: A dictionary where keys are vertex identifiers and values are lists of tuples # representing the adjacent vertices and their respective edge weights. # source: The start node for which to find the shortest paths. # Returns a dictionary mapping each vertex to the shortest distance from the source. ``` Input: - `graph`: A dictionary where the keys are integers representing vertices and the values are lists of tuples. Each tuple contains two integers, the first being an adjacent vertex and the second being the weighted edge to that vertex. - `source`: An integer representing the starting vertex. Output: - Returns a dictionary where the keys are vertices and the values are the shortest distances from the source vertex to that vertex. Constraints: - The number of vertices in the graph does not exceed (10^3). - The number of edges in the graph does not exceed (10^4). - Edge weights are non-negative integers. Example: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } source = 0 assert dijkstra(graph, source) == {0: 0, 1: 3, 2: 1, 3: 4} source = 2 assert dijkstra(graph, source) == {0: float(\'inf\'), 1: 2, 2: 0, 3: 3} ```","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], source: int) -> Dict[int, int]: Implements Dijkstra\'s algorithm to find the shortest paths from the source vertex to all other vertices in a directed weighted graph. Parameters: - graph: A dictionary where keys are vertex identifiers and values are lists of tuples representing the adjacent vertices and their respective edge weights. - source: The start node for which to find the shortest paths. Returns: - A dictionary mapping each vertex to the shortest distance from the source. # Initialize distances with infinity and set the source\'s distance to zero distances = {v: float(\'inf\') for v in graph} distances[source] = 0 # Priority queue for the minimum distance priority_queue = [(0, source)] visited = set() while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_vertex in visited: continue visited.add(current_vertex) for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question Problem Statement Write a function `find_articulation_points(graph)` that finds all articulation points in an undirected graph. An articulation point in a graph is a vertex which, when removed along with its associated edges, causes an increase in the number of connected components of the graph. The function should return a list of all articulation points in the graph. Function Signature ```python def find_articulation_points(graph: dict) -> list: pass ``` Input - `graph`: Dictionary where keys are nodes and values are lists of neighbors. E.g., `{0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 4], ...}`. Output - A list of all articulation points in the graph. E.g., `[2, 3]` Constraints - The number of nodes in the graph: (1 leq V leq 1000) - The number of edges in the graph: (0 leq E leq 10000) - Each node is labeled with a unique integer. Example ```python graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3, 4], 3: [2, 4], 4: [2, 3, 5], 5: [4] } print(find_articulation_points(graph)) # Output: [2, 4] ``` Notes - Consider using Depth-First Search (DFS) and keeping track of discovery and low times to identify articulation points. - A node is considered an articulation point if: - It is the root of DFS tree and has two or more children. - It is not the root but has a child node such that no connection from the child or its descendants leads back to an ancestor of the node. - Ensure to efficiently handle the graph traversal and maintain the necessary data structures to keep track of visited nodes and their characteristics.","solution":"def find_articulation_points(graph): def dfs(u, parent, visited, disc, low, ap, time): children = 0 visited[u] = True disc[u] = low[u] = time time += 1 for v in graph[u]: if not visited[v]: children += 1 dfs(v, u, visited, disc, low, ap, time) low[u] = min(low[u], low[v]) if parent is None and children > 1: ap[u] = True if parent is not None and low[v] >= disc[u]: ap[u] = True elif v != parent: low[u] = min(low[u], disc[v]) visited = {u: False for u in graph} disc = {u: float(\\"Inf\\") for u in graph} low = {u: float(\\"Inf\\") for u in graph} ap = {u: False for u in graph} # articulation points time = 0 for u in graph: if not visited[u]: dfs(u, None, visited, disc, low, ap, time) return [u for u in ap if ap[u]]"},{"question":"# Problem Description You are required to implement a function `unique_triplets` that takes a list of integers and returns a list of all unique triplets (three integers) from the input list where the sum of the three integers is zero. The triplets should be returned in ascending order with no duplicates. # Function Signature ```python def unique_triplets(nums: list) -> list: ``` # Input * `nums`: A list of integers (0 ≤ |nums| ≤ 10^3) # Output * Return a list of unique triplets (three integers) where the sum is zero. Each triplet should be sorted in ascending order, and the entire list of triplets should also be sorted. # Constraints 1. The function should handle empty input lists and lists with fewer than three items by returning an empty list. 2. The input list may include negative integers and zero. 3. The list of triplets returned should not contain duplicate triplets. # Example ```python assert unique_triplets([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] assert unique_triplets([0, 1, 1]) == [] assert unique_triplets([0, 0, 0, 0]) == [[0, 0, 0]] assert unique_triplets([1, -1, -1, 0, 2, 1, -1]) == [[-1, -1, 2], [-1, 0, 1]] ``` # Notes * Ensure your function handles edge cases such as lists with duplicate numbers appropriately. * Aim to keep the function clear and efficient within the provided constraints. A time complexity of O(n^2) is acceptable given the input size constraints. * Remember that order matters: the triplets and their contents should be sorted as per the specifications.","solution":"def unique_triplets(nums: list) -> list: Returns a list of all unique triplets in nums where the sum is zero. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # skip duplicates for the first element left, right = nums[i + 1], nums[-1] left_pos, right_pos = i + 1, len(nums) - 1 while left_pos < right_pos: triplet_sum = nums[i] + left + right if triplet_sum == 0: result.append([nums[i], left, right]) while left_pos < right_pos and left == nums[left_pos]: left_pos += 1 # skip duplicates for the second element while left_pos < right_pos and right == nums[right_pos]: right_pos -= 1 # skip duplicates for the third element elif triplet_sum < 0: left_pos += 1 else: right_pos -= 1 left = nums[left_pos] if left_pos < len(nums) else None right = nums[right_pos] if right_pos >= 0 else None return result"},{"question":"# Coding Assessment Question You are provided with an implementation of a basic ticket management system for an event. Your task is to enhance this system to support additional functionalities effectively and efficiently manage ticket sales, reservations, and cancellations. # Requirements 1. Implement a class `TicketManager` with the following methods: - `__init__(self, total_tickets: int)`: Initialize the manager with the total number of tickets available. - `reserve_tickets(self, num_tickets: int) -> bool`: Reserve the specified number of tickets if available. Returns `True` if the reservation is successful, `False` otherwise. - `cancel_tickets(self, num_tickets: int) -> bool`: Cancel the reservation of the specified number of tickets. Returns `True` if the cancellation is successful, `False` otherwise. - `tickets_left(self) -> int`: Return the number of tickets still available for reservation. 2. Ensure that the implementation efficiently manages the state of the ticket inventory and handles edge cases gracefully: - Do not allow reservations or cancellations that would result in a negative number of tickets. - Maintain the integrity of the ticket count throughout all operations. 3. Optimize for performance and clarity in your code. # Example Usage ```python >>> tm = TicketManager(100) >>> tm.tickets_left() 100 >>> tm.reserve_tickets(30) True >>> tm.tickets_left() 70 >>> tm.cancel_tickets(10) True >>> tm.tickets_left() 80 >>> tm.reserve_tickets(90) False >>> tm.tickets_left() 80 >>> tm.cancel_tickets(90) False >>> tm.tickets_left() 80 ``` # Constraints - You may assume `total_tickets` is a non-negative integer. - The number of tickets to reserve or cancel will be within the range of 1 to `total_tickets`. **Note**: Focus on ensuring the correctness and robustness of the ticket management system. Ensure that any invalid operations leave the system\'s state unchanged.","solution":"class TicketManager: def __init__(self, total_tickets: int): Initialize the TicketManager with the total number of tickets available. Args: total_tickets (int): The total number of tickets available for reservation. self.total_tickets = total_tickets self.reserved_tickets = 0 def reserve_tickets(self, num_tickets: int) -> bool: Reserve the specified number of tickets if available. Args: num_tickets (int): The number of tickets to reserve. Returns: bool: True if the reservation is successful, False otherwise. if num_tickets <= 0: return False if self.reserved_tickets + num_tickets <= self.total_tickets: self.reserved_tickets += num_tickets return True return False def cancel_tickets(self, num_tickets: int) -> bool: Cancel the reservation of the specified number of tickets. Args: num_tickets (int): The number of tickets to cancel. Returns: bool: True if the cancellation is successful, False otherwise. if num_tickets <= 0: return False if self.reserved_tickets >= num_tickets: self.reserved_tickets -= num_tickets return True return False def tickets_left(self) -> int: Return the number of tickets still available for reservation. Returns: int: The number of tickets available for reservation. return self.total_tickets - self.reserved_tickets"},{"question":"# Question: Finding the Nearest Smaller Elements You are given an array of integers. For each element in the array, find the nearest smaller element to its left. If no such element exists, return -1 for that position. **Objective:** Write a function `nearest_smaller_elements(arr: List[int]) -> List[int]` that processes the input array and returns a new array where each element is replaced by the nearest smaller element to its left. Requirements: 1. Implement the solution with an efficient approach, ideally using a stack data structure. 2. The expected time complexity should be O(n), where n is the length of the array. Input: 1. `arr`: A list of integers. Output: - A list of integers where each element corresponds to the nearest smaller element to its left in the original array. Constraints: - (1 leq text{length of } arr leq 10^5) - (-10^9 leq arr[i] leq 10^9) Example: ```python >>> nearest_smaller_elements([1, 3, 0, 2, 5]) [-1, 1, -1, 0, 2] >>> nearest_smaller_elements([4, 5, 2, 10, 8]) [-1, 4, -1, 2, 2] >>> nearest_smaller_elements([1, 2, 3, 4, 5]) [-1, 1, 2, 3, 4] >>> nearest_smaller_elements([5, 4, 3, 2, 1]) [-1, -1, -1, -1, -1] ``` # Notes: - Your implementation should efficiently handle the array processing using a stack to keep track of the nearest smaller elements. - Consider edge cases such as strictly increasing or decreasing arrays and arrays with duplicate elements.","solution":"from typing import List def nearest_smaller_elements(arr: List[int]) -> List[int]: Returns a list of nearest smaller elements to the left of each element in the given array. If no such element exists, return -1 for that position. result = [] stack = [] for num in arr: while stack and stack[-1] >= num: stack.pop() if stack: result.append(stack[-1]) else: result.append(-1) stack.append(num) return result"},{"question":"# Efficient Image Rotation with Minimum Memory Usage You are to implement a function to rotate an `n x n` matrix representing an image by 90 degrees clockwise in place, meaning that your algorithm should use only a constant amount of extra space. Specific Requirements 1. **Input**: A 2D list (list of lists in Python) representing an `n x n` matrix. 2. **Output**: The same 2D list after rotating it by 90 degrees clockwise. 3. **Constraints**: * You must rotate the matrix in place, meaning you cannot use another matrix or extra memory proportional to the size of the matrix. * Focus on minimizing the number of operations and memory usage to achieve the rotation. Performance Requirements * The time complexity of the rotation should be O(n^2). * Space complexity should be O(1) excluding the input matrix. Scenario Your application includes functionality to process user-uploaded photos. One of the features allows users to rotate their images. The image data is represented as a 2D list where each element is a pixel value, and you need to perform the rotation efficiently without using significant additional memory. You are tasked with implementing the following function: ```python def rotate_matrix(matrix: list) -> None: Rotate the given n x n matrix by 90 degrees clockwise in place. Parameters: matrix (list of list): n x n matrix to be rotated. Returns: None pass ``` **Example Usage:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) # Output should be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Ensure your solution performs the rotation in place and handles the transformation efficiently.","solution":"def rotate_matrix(matrix: list) -> None: Rotate the given n x n matrix by 90 degrees clockwise in place. Parameters: matrix (list of list): n x n matrix to be rotated. Returns: None n = len(matrix) # First step: transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second step: reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Problem Statement You are given the task of developing a simple file system simulation. This system should support the creation of directories and files, as well as the ability to navigate through and list the contents of the current directory. Additionally, the system should support searching for files by name within the current directory. # Objective Implement a `FileSystem` class with the following functionalities: 1. **Create Directory**: Create a new directory within the current directory. 2. **Create File**: Create a new file within the current directory. 3. **Change Directory**: Change the current directory to a specified subdirectory or parent directory. 4. **List Contents**: List all files and directories in the current directory. 5. **Search File**: Search for a file by name within the current directory. # Specifications 1. **Create Directory**: - Method: `create_directory(self, name: str) -> None` - Input: A string `name` representing the name of the directory to be created. - Output: None - Constraints: Ensure the directory name is unique within the current directory. ```python def create_directory(self, name: str) -> None: pass ``` 2. **Create File**: - Method: `create_file(self, name: str) -> None` - Input: A string `name` representing the name of the file to be created. - Output: None - Constraints: Ensure the file name is unique within the current directory. ```python def create_file(self, name: str) -> None: pass ``` 3. **Change Directory**: - Method: `change_directory(self, path: str) -> None` - Input: A string `path` representing the directory to change to. This can be a subdirectory name or \'..\' for the parent directory. - Output: None - Constraints: Ensure the path exists. ```python def change_directory(self, path: str) -> None: pass ``` 4. **List Contents**: - Method: `list_contents(self) -> List[str]` - Output: A list of strings containing the names of all files and directories in the current directory. ```python def list_contents(self) -> List[str]: pass ``` 5. **Search File**: - Method: `search_file(self, name: str) -> bool` - Input: A string `name` representing the name of the file to search for. - Output: Boolean indicating whether the file exists in the current directory. ```python def search_file(self, name: str) -> bool: pass ``` # Constraints - Each directory or file name can be a maximum of 100 characters. - The directory structure can have a depth up to 10 levels. # Example ```python # Initialize an empty FileSystem fs = FileSystem() # Create directories and files fs.create_directory(\'docs\') fs.create_file(\'readme.txt\') # Change to \'docs\' directory fs.change_directory(\'docs\') # Create files in \'docs\' directory fs.create_file(\'doc1.txt\') fs.create_file(\'doc2.txt\') # Change to parent directory fs.change_directory(\'..\') # List contents of root directory print(fs.list_contents()) # Should print: [\'docs\', \'readme.txt\'] # Search for a file print(fs.search_file(\'readme.txt\')) # Should print: True print(fs.search_file(\'notfound.txt\')) # Should print: False # Change to \'docs\' directory and list its contents fs.change_directory(\'docs\') print(fs.list_contents()) # Should print: [\'doc1.txt\', \'doc2.txt\'] ``` # Notes - Implementations should ensure to handle directory and file naming conflicts gracefully, ensuring unique names within the same directory. - Include appropriate error handling for invalid operations, such as navigating to a non-existent directory.","solution":"class FileSystem: def __init__(self): self.root = {\'type\': \'dir\', \'children\': {}} self.current_dir = self.root self.path_stack = [] def create_directory(self, name: str) -> None: if name in self.current_dir[\'children\']: raise ValueError(\'Directory already exists\') self.current_dir[\'children\'][name] = {\'type\': \'dir\', \'children\': {}} def create_file(self, name: str) -> None: if name in self.current_dir[\'children\']: raise ValueError(\'File already exists\') self.current_dir[\'children\'][name] = {\'type\': \'file\'} def change_directory(self, path: str) -> None: if path == \'..\': if self.path_stack: self.current_dir = self.path_stack.pop() else: raise ValueError(\'Already at root directory\') elif path in self.current_dir[\'children\'] and self.current_dir[\'children\'][path][\'type\'] == \'dir\': self.path_stack.append(self.current_dir) self.current_dir = self.current_dir[\'children\'][path] else: raise ValueError(\'Directory does not exist\') def list_contents(self) -> list: return list(self.current_dir[\'children\'].keys()) def search_file(self, name: str) -> bool: if name in self.current_dir[\'children\'] and self.current_dir[\'children\'][name][\'type\'] == \'file\': return True return False"},{"question":"# Minimum Steps to Reach a Target Number with Two Operations In this task, you are asked to implement a function that calculates the minimum number of steps required to reach a target number starting from zero. You are allowed to either add a given step size ( S ) or subtract it at each step. # Problem Statement Implement a function `minimum_steps_to_target` which takes the following parameters: * `target`: The target number you need to reach (integer, positive). * `step_size`: The size of the step you can add or subtract (integer, positive). It should return the minimum number of steps required to reach the target. # Function Signature ```python def minimum_steps_to_target(target: int, step_size: int) -> int: pass ``` # Input * target: `int` - The target number, positive and non-zero. * step_size: `int` - The step size, positive and non-zero. # Output * `int`: The minimum number of steps to reach the target. # Constraints * (1 leq text{target} leq 10^5) * (1 leq text{step_size} leq 10^3) # Example ```python >>> minimum_steps_to_target(10, 2) 5 >>> minimum_steps_to_target(15, 4) 4 >>> minimum_steps_to_target(20, 7) 3 ``` # Explanation In the first example, the fastest way to reach 10 from 0 with a step size of 2 is to add 2 five times. In the second example, to reach 15 from 0 with a step size of 4, you can follow the sequence: +4, +4, +4, +4, -1. Thus, the minimum steps are 4. In the third example, to reach 20 from 0 with a step size of 7, you can follow the sequence: +7, +7, +7, -1. Thus, the minimum steps are 3. # Notes - Consider both addition and subtraction operations at each step. - Look for the optimal path that minimizes the number of steps. - Ensure to handle edge cases and invalid inputs gracefully.","solution":"def minimum_steps_to_target(target: int, step_size: int) -> int: if target % step_size == 0: return target // step_size else: return (target // step_size) + 1"},{"question":"# Coding Assessment Question Problem Context You are tasked with implementing a function to calculate the product of all the elements in a list, except the element itself, without using division. This type of problem typically requires understanding of array manipulation, efficient computation, and edge case considerations. Task Implement the function `product_except_self` which takes a list of integers `nums` and returns a list such that each element at index `i` of the output list is the product of all the numbers in the input list except the one at `i`. Input * A list of integers `nums` with length ( n ). Output * A list of integers representing the product of all elements except the one at each index. Constraints * The length of the list `n` will be within the range of ( 2 ) to ( 10^5 ). * Each integer in the list will be between ( -1000 ) and ( 1000 ). Performance Requirements * The solution should handle large lists efficiently and should be computed in ( O(n) ) time complexity without using division. Function Signature ```python def product_except_self(nums: list) -> list: ``` Examples ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([5, 6, 2, 3]) == [36, 30, 90, 60] assert product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] ``` Detailed Description * Consider edge cases such as lists containing zero. * Ensure proper handling of negative numbers and the impact on product results. * Utilize auxiliary arrays or other structures to handle the computation efficiently. * Do not use the division operation as it is disallowed in this task.","solution":"def product_except_self(nums): n = len(nums) if n < 2: return [] # Initialize the products list products = [1] * n # Left products - product of numbers to the left of index i left_products = 1 for i in range(n): products[i] = left_products left_products *= nums[i] # Right products - product of numbers to the right of index i right_products = 1 for i in range(n-1, -1, -1): products[i] *= right_products right_products *= nums[i] return products"},{"question":"# Coding Assessment Question Context You\'re designing a system to manage tournament scores for multiple players. Each player has a unique ID and their scores get updated after each round of the tournament. By the end of the tournament, you need to compute the rank of each player based on their total score. Implement a function that provides the ranking of players with tie-breaking based on player IDs in case of equal scores. Task Implement a function `compute_ranking(scores: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that accepts a list of tuples, where each tuple `(player_id, score)` represents the unique ID and the score of a player. The function should return a list of tuples representing the rankings, with each tuple being `(player_id, rank)` where `rank` starts from 1 for the highest score to N for the lowest score. If two players have the same score, they should share the same rank, and the next rank should reflect the number of players above them. Input - `scores`: A list of tuples where each tuple `(player_id, score)` represents the unique ID and the score of a player. Output - A list of tuples `(player_id, rank)` representing the ranking of the players. Constraints - Each `player_id` is a positive integer. - Each `score` is a non-negative integer. - The list will contain at least one element and at most 1000 elements. Example ```python def compute_ranking(scores: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass # Example Usage scores = [(1, 100), (2, 200), (3, 100), (4, 150)] assert compute_ranking(scores) == [(2, 1), (4, 2), (1, 3), (3, 3)] scores = [(1, 100), (2, 100), (3, 100)] assert compute_ranking(scores) == [(1, 1), (2, 1), (3, 1)] ``` Requirements - Your implementation should first sort the players by their scores in descending order. - If two players have the same score, they should be ranked equally, and the next player should have a rank that reflects the count of previous players. - Handle ties appropriately, ensuring stability in rankings with respect to player IDs in case of identical scores. - Ensure the solution is efficient enough to handle up to the maximum number of elements specified in the constraints.","solution":"from typing import List, Tuple def compute_ranking(scores: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Sort scores first by score in descending order, then by player_id in ascending order scores.sort(key=lambda x: (-x[1], x[0])) ranking = [] current_rank = 1 previous_score = None skip_count = 0 for idx, (player_id, score) in enumerate(scores): if score != previous_score: current_rank = idx + 1 - skip_count previous_score = score ranking.append((player_id, current_rank)) if idx < len(scores) - 1 and scores[idx + 1][1] == score: skip_count += 1 else: skip_count = 0 return ranking"},{"question":"# Problem Statement You are designing a route optimization software for a local delivery company. A crucial task is to determine the distance between delivery points on a 2D plane. Each delivery point is represented as a tuple of two integers, `(x, y)`, corresponding to its coordinates. Your task is to implement a function `calculate_distances` that takes in a list of delivery points and returns a matrix of Euclidean distances between each pair of points. The Euclidean distance between two points `(x1, y1)` and `(x2, y2)` is given by the formula `sqrt((x2 - x1)^2 + (y2 - y1)^2)`. # Requirements 1. Implement the `calculate_distances(points: list[tuple[int, int]]) -> list[list[float]]` function. 2. Ensure that your function efficiently calculates the distances even for large input sizes. 3. Return a matrix where each element at position `(i, j)` represents the Euclidean distance between the `i-th` and `j-th` delivery points. # Input Format * A list of tuples where each tuple contains two integers representing the coordinates of a delivery point. # Output Format * A list of lists where each sub-list contains the Euclidean distances to all other points. # Constraints * The number of delivery points will be at most 500. * Each coordinate will be an integer in the range [-1000, 1000]. # Example ```python # Input points = [ (0, 0), (3, 4), (6, 8) ] # Output output_matrix = [ [0.0, 5.0, 10.0], [5.0, 0.0, 5.0], [10.0, 5.0, 0.0] ] ``` Implement the function `calculate_distances` that meets the above requirements.","solution":"import math def calculate_distances(points): Calculates the Euclidean distances between each pair of delivery points. Args: points (list of tuple of int): List of delivery points represented as (x, y) coordinates. Returns: list of list of float: Matrix of Euclidean distances between each pair of points. n = len(points) distance_matrix = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(n): if i != j: x1, y1 = points[i] x2, y2 = points[j] distance = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) distance_matrix[i][j] = distance return distance_matrix"},{"question":"**Scenario:** A social media platform has a growing user base, and they want to identify the most active users based on the frequency of their posts. Each user\'s activity is tracked by appending their user ID to a list every time they make a post. The platform needs a function that finds the top N most active users. **Task:** Implement a function `top_n_users` that takes a list of user IDs representing user activity and an integer N. The function should return a list of tuples with the user IDs and their corresponding post counts, sorted by post count in descending order. If multiple users have the same post count, they should be sorted by their user IDs in ascending order. **Function Signature:** ```python def top_n_users(user_activity: list, N: int) -> list: pass ``` **Input and Output:** - **Input**: - `user_activity` (list): A list of strings where each string is a user ID. - `N` (int): The number of top users to return. - **Output**: - Returns a list of tuples where each tuple contains a user ID (str) and post count (int). **Constraints/Requirements**: - If `user_activity` is empty or `N` is 0, return an empty list. - If `N` is greater than the number of unique users, return all users sorted as described. - User IDs are non-empty strings and can have characters including digits and alphabets. **Example**: ```python print(top_n_users([\'user1\', \'user2\', \'user1\', \'user3\', \'user2\', \'user2\'], 2)) # Expected output: [(\'user2\', 3), (\'user1\', 2)] print(top_n_users([], 3)) # Expected output: [] print(top_n_users([\'a\', \'b\', \'a\', \'c\', \'b\', \'b\', \'a\'], 1)) # Expected output: [(\'a\', 3)] print(top_n_users([\'u1\', \'u2\', \'u1\', \'u3\', \'u2\', \'u2\'], 5)) # Expected output: [(\'u2\', 3), (\'u1\', 2), (\'u3\', 1)] ``` Ensure your solution handles large lists efficiently.","solution":"def top_n_users(user_activity: list, N: int) -> list: Returns the top N most active users based on their post count. Parameters: user_activity (list): A list of strings where each string is a user ID. N (int): The number of top users to return. Returns: list: A list of tuples where each tuple contains a user ID (str) and post count (int). if not user_activity or N == 0: return [] from collections import Counter # Counting the frequency of each user ID in the list user_counts = Counter(user_activity) # Creating a sorted list of tuples (user_id, post_count) sorted_users = sorted(user_counts.items(), key=lambda x: (-x[1], x[0])) # Getting the top N users return sorted_users[:N]"},{"question":"# Generating Fibonacci Sequence using Dynamic Programming Context Suppose you are a software developer for a company that needs to generate the Fibonacci sequence for various financial modeling applications. Due to the high demand and performance constraints, you are required to implement an efficient solution. Your task is to generate the Fibonacci sequence using dynamic programming to ensure that the calculations are performed optimally. Task You need to write a Python function `generate_fibonacci(n: int) -> List[int]` that takes an integer `n` and returns a list containing the first `n` numbers in the Fibonacci sequence. Input and Output Formats * **Input**: A single integer `n` (e.g., `10`) * **Output**: A list of integers representing the first `n` Fibonacci numbers. Examples * **Example 1**: ```python generate_fibonacci(10) ``` *Output*: ``` python [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` * **Example 2**: ```python generate_fibonacci(15) ``` *Output*: ``` python [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377] ``` Constraints * `1 <= n <= 1000` * Use dynamic programming to store intermediate Fibonacci numbers to avoid redundant calculations. * The function should handle large values of `n` efficiently. Performance Requirements * The function should run in O(n) time complexity. Additional Information Dynamic programming allows you to build up the solution by storing the computed values of Fibonacci numbers in a list or an array, which helps in reducing the time complexity compared to naive recursive implementation. Ensure your implementation makes use of this technique to achieve the required efficiency.","solution":"def generate_fibonacci(n): Returns the first n Fibonacci numbers. Parameters: n (int): The number of Fibonacci numbers to generate. Returns: List[int]: A list containing the first n Fibonacci numbers. if n <= 0: return [] fib = [0] * n fib[0] = 0 if n > 1: fib[1] = 1 for i in range(2, n): fib[i] = fib[i - 1] + fib[i - 2] return fib"},{"question":"# Subarray with Maximum Sum You are working as a software engineer for a financial firm. Your team is tasked with analyzing historical price data to determine the best interval to buy and sell assets for maximum profit. To begin with, you decide to solve a simpler problem: finding the subarray with the maximum sum in a given list of integers. Implement the following function: Function: `max_subarray_sum(nums: List[int]) -> int` This function calculates the maximum sum of any contiguous subarray within the given list. * **Input**: * `nums`: A list of integers where each element `nums[i]` represents a daily price change (positive or negative). * **Output**: * An integer representing the maximum sum of any contiguous subarray. * **Constraints**: * 1 <= len(nums) <= 10^5 * -10^4 <= nums[i] <= 10^4 Example ```python # Maximum subarray sum nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4] result = max_subarray_sum(nums) # Expected output: 6 nums = [5, 4, -1, 7, 8] result = max_subarray_sum(nums) # Expected output: 23 nums = [-10, -2, -3, -4, -5, -6] result = max_subarray_sum(nums) # Expected output: -2 ``` Make sure your solution is efficient and considers edge cases such as: - An array with all negative numbers. - An array with all positive numbers. - Diverse combinations of positive and negative numbers. You should also utilize an efficient algorithm (e.g., Kadane’s Algorithm) to ensure the solution handles the given constraints.","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. Utilizes Kadane\'s Algorithm for an efficient solution with O(n) complexity. max_sum = cur_sum = nums[0] for num in nums[1:]: cur_sum = max(num, cur_sum + num) max_sum = max(max_sum, cur_sum) return max_sum"},{"question":"# Question: Determine the Count of Unique Elements after Applying an Operation Problem Statement: You are tasked with determining the count of unique elements in a list after applying a specific operation to each element. The operation involves either incrementing or decrementing each element by 1, but not both on the same element. Requirements: 1. Write a function `unique_count_after_operation(nums: List[int]) -> int` that takes a list of integers and returns the count of unique elements after applying the operation. Input Format: * A list of integers `nums` with size (1 leq len(nums) leq 10^5). Output Format: * An integer denoting the count of unique elements after the operation has been applied. Example: Input: ``` [1, 2, 3, 2] ``` Output: ``` 3 ``` Input: ``` [3, 3, 4, 5, 6] ``` Output: ``` 4 ``` Explanation: - For the first example, the list [1, 2, 3, 2] can lead to [2, 1, 4, 3] or [0, 3, 4, 3], where the unique counts are 3. - For the second example, transforming one of the 3’s to either 2 or 4 will result in a unique set of four numbers. Constraints: * (1 leq nums[i] leq 10^9) Implementation: ```python from typing import List def unique_count_after_operation(nums: List[int]) -> int: unique_elements = set() for num in nums: # attempt to add both num - 1 and num + 1 to the set if (num - 1) not in unique_elements: unique_elements.add(num - 1) elif (num + 1) not in unique_elements: unique_elements.add(num + 1) else: unique_elements.add(num) return len(unique_elements) if __name__ == \\"__main__\\": nums = [int(x) for x in input(\\"Enter list of integers: \\").split()] result = unique_count_after_operation(nums) print(f\\"Unique Count = {result}\\") ```","solution":"from typing import List def unique_count_after_operation(nums: List[int]) -> int: unique_elements = set() for num in nums: # add original number to set unique_elements.add(num) # add both decremented and incremented number to set unique_elements.add(num - 1) unique_elements.add(num + 1) return len(unique_elements)"},{"question":"# Coding Assessment Question Scenario A busy shipping port handles numerous container shipments every day. Each shipment is assigned a unique identifier and a priority level. The priority level signifies the urgency of the shipment\'s processing. Your task is to process a list of shipments in a way that prioritizes higher priority levels using a max-heap. Problem Statement Write a class `ShipmentProcessor` with the following methods: 1. `__init__() -> None`: Initializes an empty ShipmentProcessor. 2. `add_shipment(identifier: str, priority: int) -> None`: Adds a shipment with a given identifier and priority to the processor. 3. `process_shipment() -> str`: Processes the highest priority shipment and returns its identifier. If there are no shipments to process, raise a `ValueError` with the message \\"No shipments to process\\". You should use a heap to efficiently manage the shipment priorities. Input - Identifiers are strings unique across all shipments. - Priorities are integers where higher values indicate higher priority. Output - `process_shipment` should return the identifier of the processed shipment. Constraints - Identifiers are non-empty strings. - Priorities are valid integers (both positive and negative). - There will be at most 10^5 shipments added to the processor. - If `process_shipment` is called without any shipments present, raise a `ValueError` with the message \\"No shipments to process\\". Example ```python import heapq class ShipmentProcessor: def __init__(self) -> None: self.heap = [] def add_shipment(self, identifier: str, priority: int) -> None: heapq.heappush(self.heap, (-priority, identifier)) def process_shipment(self) -> str: if not self.heap: raise ValueError(\\"No shipments to process\\") return heapq.heappop(self.heap)[1] # Example usage and results processor = ShipmentProcessor() processor.add_shipment(\\"ABC123\\", 10) processor.add_shipment(\\"XYZ789\\", 5) processor.add_shipment(\\"LMN456\\", 8) print(processor.process_shipment()) # Output: \\"ABC123\\" (highest priority) print(processor.process_shipment()) # Output: \\"LMN456\\" print(processor.process_shipment()) # Output: \\"XYZ789\\" processor.process_shipment() # Raises ValueError: \\"No shipments to process\\" ``` Note Ensure that your solution is efficient and handles edge cases appropriately within the given constraints.","solution":"import heapq class ShipmentProcessor: def __init__(self) -> None: self.heap = [] def add_shipment(self, identifier: str, priority: int) -> None: heapq.heappush(self.heap, (-priority, identifier)) def process_shipment(self) -> str: if not self.heap: raise ValueError(\\"No shipments to process\\") # We pop the element with the highest priority (negated value) return heapq.heappop(self.heap)[1]"},{"question":"# Problem Statement You are given an unordered list of integers representing a set of weights. Write a function that finds the minimum difference between the sum of elements in any two non-empty subsets of the list. # Function Signature ```python def minimum_subset_difference(weights: List[int]) -> int: ``` # Input - `weights`: A list of integers representing the weights. The list can contain up to 20 elements. # Output - Returns an integer, the minimum difference between the sum of elements in any two non-empty subsets of the list. # Constraints - The list will contain between 2 and 20 integers. - Each integer weight will be between 1 and 1000. # Example ```python weights = [1, 6, 11, 5] print(minimum_subset_difference(weights)) # Expected Output: 1 weights = [3, 1, 4, 2, 2] print(minimum_subset_difference(weights)) # Expected Output: 0 ``` # Instructions 1. Implement the function `minimum_subset_difference(weights: List[int]) -> int`. 2. Your function should explore all potential ways to partition the list into two non-empty subsets and calculate the absolute difference of their sums. 3. Consider efficiency and feasibility, given the constraints. 4. Write clear and readable code, with comments explaining key steps if necessary. # Notes - You do not need to handle input parsing; assume the function will be called with a properly formatted list of weights. - Consider edge cases such as the smallest and largest possible sums based on input constraints.","solution":"from typing import List def minimum_subset_difference(weights: List[int]) -> int: Finds the minimum difference between the sum of elements in any two non-empty subsets. total_weight = sum(weights) n = len(weights) dp = [[False] * (total_weight // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_weight // 2 + 1): if j >= weights[i - 1]: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - weights[i - 1]] else: dp[i][j] = dp[i - 1][j] min_diff = float(\'inf\') for j in range(total_weight // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_weight - 2 * j) return min_diff"},{"question":"Scenario You are asked to help optimize a logistics company\'s route planning system. The system currently uses a basic calculation to determine shipping costs based on the distance traveled and the weight of the package. However, the company now wants to implement a discount strategy where certain weights qualify for a reduced rate. Task Implement a function that calculates the total shipping cost given a list of distances and weights for multiple packages, as well as the discount weight threshold and discount rate. The discount applies to subtotal (distance * weight) for each package that meets or exceeds the threshold weight. Function Signature ```python def calculate_shipping_costs(distances: List[float], weights: List[float], discount_weight: float, discount_rate: float) -> float: ``` Input - `distances` (List[float]): A list of distances traveled for each package. Each distance is a positive float. - `weights` (List[float]): A list of weights for each package. Each weight is a positive float. - `discount_weight` (float): The weight threshold for the discount. Packages with weight greater than or equal to this value get a discount. - `discount_rate` (float): The discount rate, a positive value between 0 and 1 (non-inclusive) that represents the percentage of discount to be applied (e.g., 0.1 for 10% discount). Output - `float`: The total shipping cost after applying the discounts. Constraints - The list of distances and weights will have the same length and contain at least one element and at most (10^5) elements. - All distances and weights will be positive values. - The discount weight threshold will be a positive value. - The discount rate will be between 0 (non-inclusive) and 1 (non-inclusive). Examples ```python >>> calculate_shipping_costs([10, 20, 30], [5, 10, 20], discount_weight=15, discount_rate=0.2) 504.0 >>> calculate_shipping_costs([5, 15, 25], [3, 12, 25], discount_weight=10, discount_rate=0.5) 380.0 >>> calculate_shipping_costs([8, 16, 32], [2, 8, 16], discount_weight=8, discount_rate=0.25) 960.0 ``` Additional Notes - Assume the input lists are always valid and no input validation is required. - The discount applies only to the final cost component of each qualifying package, not before multiplying distance by weight. - Effective use of conditional structures and efficient calculations is recommended to handle large inputs.","solution":"from typing import List def calculate_shipping_costs(distances: List[float], weights: List[float], discount_weight: float, discount_rate: float) -> float: total_cost = 0.0 for distance, weight in zip(distances, weights): cost = distance * weight if weight >= discount_weight: cost *= (1 - discount_rate) total_cost += cost return total_cost"},{"question":"# Assignment: Implement a Basic Multi-threaded Web Server You will be creating a simple multi-threaded web server that can handle multiple client requests concurrently. This will involve setting up a basic server, using threads to manage different client connections, and sending appropriate HTTP responses. # Task: 1. Implement the function `start_server` to set up a server that listens on a specified port and accepts client connections. * Input: * `port` - An integer specifying the port number on which the server will listen. 2. Write the function `handle_client` to manage communication with a connected client. * Input: * `client_socket` - The socket object associated with the connected client. * Output: * None. The function should handle receiving the HTTP request, processing it, and sending back the appropriate response. 3. Implement the function `generate_response` to create a simple HTTP response. * Input: * `request` - The HTTP request received from the client. * Output: * A string representing the HTTP response to be sent back to the client. 4. Use multiple threads to allow `start_server` to handle multiple client connections concurrently. # Constraints: * The server should handle HTTP GET requests and serve basic text responses. * Limit the server to handle up to 5 concurrent client connections. * Ensure that the server responds with appropriate HTTP status codes. * Clean up resources properly by closing client connections after the response is sent. # Example: ```python # Starting the server on port 8080 start_server(8080) # Example HTTP GET request from a client GET / HTTP/1.1 Host: localhost:8080 # Example HTTP response from the server HTTP/1.1 200 OK Content-Type: text/plain Hello, World! ``` # Notes: * Be mindful of possible edge cases such as invalid HTTP requests and handling more than 5 concurrent connections. * Ensure that your server can be shut down gracefully. * Your solution should implement proper error handling and resource management mechanisms. By completing this assignment, you will demonstrate your understanding of network programming, multi-threading, and basic web server protocols.","solution":"import socket import threading def start_server(port): Starts a multi-threaded web server that listens on the specified port. Parameters: port (int): The port number on which the server will listen. Returns: None server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socket.bind((\'0.0.0.0\', port)) server_socket.listen(5) # Limiting the server to handle up to 5 concurrent connections print(f\\"Server started on port {port}\\") try: while True: client_socket, addr = server_socket.accept() print(f\\"Accepted connection from {addr}\\") client_handler = threading.Thread(target=handle_client, args=(client_socket,)) client_handler.start() except KeyboardInterrupt: print(\\"Shutting down the server.\\") finally: server_socket.close() def handle_client(client_socket): Handles communication with a connected client. Parameters: client_socket (socket.socket): The socket object associated with the connected client. Returns: None try: request = client_socket.recv(1024).decode(\'utf-8\') print(f\\"Received request:n{request}\\") response = generate_response(request) client_socket.sendall(response.encode(\'utf-8\')) finally: client_socket.close() def generate_response(request): Generates a simple HTTP response based on the provided request. Parameters: request (str): The HTTP request received from the client. Returns: str: The HTTP response to be sent back to the client. lines = request.split(\'rn\') if len(lines) > 0 and lines[0].startswith(\\"GET\\"): return \\"HTTP/1.1 200 OKrnContent-Type: text/plainrnrnHello, World!\\" else: return \\"HTTP/1.1 400 Bad RequestrnContent-Type: text/plainrnrnBad Request\\""},{"question":"# Coding Assessment Question Scenario In many modern applications, it\'s crucial to manage and manipulate collections of data efficiently. One common requirement is maintaining a dynamic sorted list where elements can be inserted and removed while keeping the list sorted. Task Implement a sorted list data structure in Python. Your implementation should provide efficient insertion, deletion, and retrieval of elements while maintaining order. Requirements 1. Implement a class `SortedList` that: - Uses an appropriate data structure to maintain the ordered list. - Provides methods for inserting and removing elements efficiently. - Provides a method to retrieve the list in its current sorted state. 2. Ensure your implementation handles the following: - Efficiently inserts elements while maintaining order. - Efficiently removes elements by value while maintaining order. - Retrieves the list in sorted order. 3. Demonstrate your implementation with the following cases: - Insert the elements `[3, 1, 4, 1, 5, 9]` and then retrieve the list. - Remove the elements `1` and `5` and then retrieve the list. Function Signature ```python class SortedList: def __init__(self): # Initialize the necessary properties def insert(self, value: int) -> None: # Implement the insertion logic def remove(self, value: int) -> None: # Implement the deletion logic def get_sorted_list(self) -> list: # Retrieve the sorted list # Example usage sorted_list = SortedList() sorted_list.insert(3) sorted_list.insert(1) sorted_list.insert(4) sorted_list.insert(1) sorted_list.insert(5) sorted_list.insert(9) print(sorted_list.get_sorted_list()) # Expected: [1, 1, 3, 4, 5, 9] sorted_list.remove(1) sorted_list.remove(5) print(sorted_list.get_sorted_list()) # Expected: [1, 3, 4, 9] ``` Input Format - Integers for insertion and deletion. - No input required for retrieving the sorted list. Output Format - A list of integers representing the sorted collection after any insertions or deletions. Constraints - You may assume that the list will not contain more than 10,000 elements at any time. - Each value to be inserted or removed will be within the range `-10^6` to `10^6`. Performance Requirements - The implementation should efficiently handle insertions and deletions while keeping the list sorted.","solution":"import bisect class SortedList: def __init__(self): self._list = [] def insert(self, value: int) -> None: Insert a value in the sorted list while maintaining order. bisect.insort(self._list, value) def remove(self, value: int) -> None: Remove a value from the sorted list while maintaining order. index = bisect.bisect_left(self._list, value) if index < len(self._list) and self._list[index] == value: self._list.pop(index) def get_sorted_list(self) -> list: Retrieve the sorted list. return self._list # Example usage sorted_list = SortedList() sorted_list.insert(3) sorted_list.insert(1) sorted_list.insert(4) sorted_list.insert(1) sorted_list.insert(5) sorted_list.insert(9) print(sorted_list.get_sorted_list()) # Expected: [1, 1, 3, 4, 5, 9] sorted_list.remove(1) sorted_list.remove(5) print(sorted_list.get_sorted_list()) # Expected: [1, 3, 4, 9]"},{"question":"# Validating Brackets with Stack Scenario In software development, balanced brackets are crucial for the correctness of expressions in programming languages. An expression is considered valid if all types of brackets (`()`, `{}`, `[]`) are closed and nested in the correct order. Implement a function that verifies the validity of a given expression containing multiple types of brackets using a stack data structure. Function Signature ```python def is_valid_expression(expression: str) -> bool: ``` Input * `expression` (str): A string consisting of characters `(`, `)`, `{`, `}`, `[`, and `]`, with length (n leq 10^5). Output * Returns a boolean indicating whether the input expression has valid and balanced brackets. Constraints * The function should process the input in a single pass through the string. * Only the characters `(`, `)`, `{`, `}`, `[`, and `]` are guaranteed to be in the input string. Example **Input:** ```python expression = \\"{[()()]}\\" ``` **Output:** ```python True ``` **Explanation** * The brackets are opened and closed correctly. **Input:** ```python expression = \\"{[(])}\\" ``` **Output:** ```python False ``` **Explanation** * The brackets are not nested properly. **Input:** ```python expression = \\"([{}])[]\\" ``` **Output:** ```python True ``` **Explanation** * The brackets are balanced and correctly nested. Approach In this task, you need to utilize a stack to keep track of opening brackets and ensure that each closing bracket matches the most recent unclosed opening bracket. Push each opening bracket onto the stack, and for each closing bracket, check if it correctly matches the top of the stack, popping as appropriate. If the stack is empty at the end and all brackets have been correctly matched, the expression is valid.","solution":"def is_valid_expression(expression: str) -> bool: stack = [] bracket_pairs = { \')\': \'(\', \'}\': \'{\', \']\': \'[\' } for char in expression: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack and stack[-1] == bracket_pairs[char]: stack.pop() else: return False return not stack"},{"question":"# Coding Assessment Question Scenario You are working on a simulation of a factory assembly line where each task needs to be executed in the correct sequence, considering its dependencies. The tasks represent various stages of production, and each stage can only start after all its dependent stages have been completed. The sequence can be represented by a Directed Acyclic Graph (DAG) where vertices are tasks and edges denote dependencies. Problem Statement Implement a function `determine_assembly_sequence(tasks_graph: dict[int, list[int]]) -> list[int] | None` that computes the ordering of tasks using topological sorting. Return `None` if it is not possible to determine a valid order due to cyclical dependencies. # Input: * A dictionary `tasks_graph` representing the adjacency list of the graph, where keys are task indices (integers), and values are lists of task indices that are dependent on the key. # Output: * A list of integers representing the topologically sorted order of tasks. * `None` if a valid topological ordering does not exist due to cyclical dependencies. # Constraints: * (1 leq text{number of tasks} leq 10^5) * Each task (vertex) and dependency (edge) is represented using integers. # Example: ```python tasks_graph_1 = {0: [1, 2], 1: [3], 2: [3], 3: [], 4: []} assert determine_assembly_sequence(tasks_graph_1) in [[0, 4, 1, 2, 3], [0, 4, 2, 1, 3]] tasks_graph_2 = {0: [1], 1: [2], 2: [0]} assert determine_assembly_sequence(tasks_graph_2) is None ``` Function Signature ```python def determine_assembly_sequence(tasks_graph: dict[int, list[int]]) -> list[int] | None: pass ``` # Notes: * Ensure to manage the graph traversal efficiently to handle large input sizes and avoid cycles. * Utilize Kahn\'s Algorithm via Breadth-First Search (BFS) for implementing the topological sorting to handle the constraints and complexities appropriately.","solution":"from collections import deque def determine_assembly_sequence(tasks_graph): Computes the topological sort of a DAG or returns None if there is a cycle. in_degree = {u: 0 for u in tasks_graph} # Initialize all in-degrees to 0 # Compute in-degrees of all vertices for u in tasks_graph: for v in tasks_graph[u]: in_degree[v] += 1 # Collect nodes with in-degree of 0 queue = deque([u for u in tasks_graph if in_degree[u] == 0]) topo_sort = [] while queue: u = queue.popleft() topo_sort.append(u) for v in tasks_graph[u]: in_degree[v] -= 1 if in_degree[v] == 0: queue.append(v) # If topo_sort size is not equal to the number of nodes, there is a cycle. if len(topo_sort) != len(tasks_graph): return None return topo_sort"},{"question":"# Code Execution Sequence – Task Dependency Checker Context You are tasked with managing and executing a series of code tasks where certain tasks depend on the completion of others. Your goal is to determine the correct order to execute these tasks to ensure all dependencies are met without causing any execution errors. Problem Statement Implement a function to find an execution sequence for code tasks given their dependencies. # Task Implement a function `find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]` that determines a valid order to execute the given tasks. Parameters: * `num_tasks` (int): The total number of tasks labeled from `0` to `num_tasks - 1`. * `dependencies` (List[Tuple[int, int]]): A list of tuples where each tuple represents a dependency `(a, b)` indicating that task `a` should be executed before task `b`. Expected Output: * A list of integers representing a valid order of task execution. If no valid order exists (i.e., there is a cycle), return an empty list. # Constraints: 1. `1 <= num_tasks <= 1000` 2. Dependencies will form a Directed Acyclic Graph (DAG) or contain no cycles, ensuring at least one valid order exists or confirming no valid order. 3. The number of dependencies will not exceed `5000`. Example Usage ```python num_tasks = 4 dependencies = [(0, 1), (1, 2), (2, 3)] find_task_order(num_tasks, dependencies) # Output: [0, 1, 2, 3] num_tasks = 4 dependencies = [(0, 1), (1, 2), (3, 1)] find_task_order(num_tasks, dependencies) # Output: [0, 3, 1, 2] ``` # Implementation Notes: 1. Use Topological Sorting (Kahn\'s Algorithm or DFS-based) to achieve the task order. 2. Make sure to handle cases where there are no dependencies. 3. Handle scenarios where there might be isolated tasks with no dependencies.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_task_order(num_tasks: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determine a valid order to execute tasks given their dependencies. :param num_tasks: Total number of tasks :param dependencies: List of (a, b) tuples indicating task b depends on task a :return: A list representing a valid order of task execution indegree = [0] * num_tasks adjacency_list = defaultdict(list) # Build the graph for a, b in dependencies: adjacency_list[a].append(b) indegree[b] += 1 # Enqueue nodes with no incoming edges zero_indegree_queue = deque([i for i in range(num_tasks) if indegree[i] == 0]) task_order = [] while zero_indegree_queue: node = zero_indegree_queue.popleft() task_order.append(node) # Decrease the indegree of the neighboring nodes by 1 for neighbor in adjacency_list[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: zero_indegree_queue.append(neighbor) if len(task_order) == num_tasks: return task_order else: return []"},{"question":"# Coding Assessment Question: You are given a string `s` and an integer `k`. Your task is to write a function to rearrange the characters in the string such that no two adjacent characters are the same and the same character repeats at least `k` times apart. If it is not possible to rearrange the string under these conditions, return an empty string. # Function Signature ```python def rearrange_string(s: str, k: int) -> str: Rearrange the characters in the string such that no two adjacent characters are the same and the same character repeats at least k times apart. :param s: Input string to be rearranged. :param k: Minimum distance for the same character to repeat. :return: A rearranged string meeting the criteria or an empty string if not possible. ``` # Example ```python >>> rearrange_string(\\"aabbcc\\", 3) \\"abcabc\\" # Example of one possible valid rearrangement. >>> rearrange_string(\\"aaab\\", 2) \\"\\" # No valid rearrangement is possible to meet the criteria. >>> rearrange_string(\\"a\\", 1) \\"a\\" # The single character string remains the same as it meets the criteria. ``` # Input Constraints * The length of `s` will be between 1 and 10^4. * `s` will consist of lowercase English letters only. * ( k ) will be a positive integer. # Requirements * Your solution should aim for efficiency with a time complexity of O(n log n) and space complexity of O(n), where n is the length of the string. # Edge Cases * Test with the smallest possible string (length 1). * Test with the case where no rearrangement is possible (`k` too large). * Validate that the input string only contains lowercase English letters.","solution":"import heapq from collections import Counter, deque def rearrange_string(s: str, k: int) -> str: if k == 0: return s char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] wait_queue = deque() while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((char, count + 1)) if len(wait_queue) < k: continue next_char, next_count = wait_queue.popleft() if -next_count > 0: heapq.heappush(max_heap, (next_count, next_char)) return \'\'.join(result) if len(result) == len(s) else \\"\\""},{"question":"You are to implement a function that accurately calculates the area under a curve given by a function `fnc` over an interval `[a, b]` using the Simpson\'s rule for numerical integration. To demonstrate your grasp of numerical integration techniques and to handle edge cases effectively, your function should fulfill these requirements: # Function Signature ```python def simpsons_rule( fnc: Callable[[float], float], a: float, b: float, n: int = 100 ) -> float: ``` # Input - `fnc`: A function representing the integrand. - `a`: A float denoting the lower limit of integration. - `b`: A float denoting the upper limit of integration. - `n`: Number of intervals to divide `[a, b]` into (default 100). Note: `n` must be even. # Output - A float representing the approximate area under the curve `fnc` from `a` to `b`. # Constraints - The function assumes `a` is less than `b`. - The function `fnc` should be continuous over `[a, b]`. - Ensure `n` is a positive, even integer for Simpson\'s rule to apply correctly. If `n` is not even, raise a ValueError. # Example ```python import math def g(x): return math.exp(-x ** 2) print(simpsons_rule(g, 0, 1)) ``` Expected output should be a float representing the approximate area under `g(x) = exp(-x^2)` from `0` to `1`. # Note - Implement the Simpson\'s rule formula ensuring accuracy and optimal performance: [ text{Area} = frac{h}{3} left( f(a) + 4 sum_{i=1, 3, 5, ldots, n-1} f(a + i h) + 2 sum_{i=2, 4, 6, ldots, n-2} f(a + i h) + f(b) right) ] where (h = frac{b-a}{n}). - Pay special attention to edge cases and handle them appropriately.","solution":"from typing import Callable def simpsons_rule(fnc: Callable[[float], float], a: float, b: float, n: int = 100) -> float: Calculate the area under the curve given by function `fnc` over the interval [a, b] using Simpson\'s rule with n subdivisions. Args: - fnc (Callable[[float], float]): The integrand function. - a (float): The lower limit of integration. - b (float): The upper limit of integration. - n (int): The number of intervals (must be even). Returns: - float: The approximate area under the curve. Raises: - ValueError: If n is not an even number. if n % 2 != 0: raise ValueError(\\"n must be an even integer\\") h = (b - a) / n sum_odd = sum(fnc(a + i * h) for i in range(1, n, 2)) sum_even = sum(fnc(a + i * h) for i in range(2, n, 2)) area = (h / 3) * (fnc(a) + 4 * sum_odd + 2 * sum_even + fnc(b)) return area"},{"question":"# Problem Statement You are given a list of strings representing a collection of passwords. A password is considered \\"valid\\" if it meets the following criteria: - It is at least 8 characters long. - It contains at least one uppercase letter. - It contains at least one lowercase letter. - It contains at least one digit. - It contains at least one special character (defined as one of the following: `!@#%^&*()-+`). Write a function `validate_passwords(passwords: List[str]) -> List[bool]` that takes a list of strings and returns a list of booleans, where each boolean indicates whether the corresponding password in the input list is valid. # Constraints - Each password string contains between 1 and 100 characters. - The input list contains at most 1000 passwords. # Example ```python >>> validate_passwords([\\"Abc1!\\", \\"password\\", \\"Passw0rd!\\"]) [True, False, True] ``` # Notes - You may use any built-in functions and libraries allowed in a standard Python environment. - Focus on ensuring your function is efficient and handles all given constraints gracefully.","solution":"import re from typing import List def validate_passwords(passwords: List[str]) -> List[bool]: Returns a list of booleans indicating if each password in the given list is valid. A password is considered valid if: - It is at least 8 characters long. - It contains at least one uppercase letter. - It contains at least one lowercase letter. - It contains at least one digit. - It contains at least one special character (one of the following: `!@#%^&*()-+`). special_chars = set(\\"!@#%^&*()-+\\") valid_passwords = [] for password in passwords: if len(password) < 8: valid_passwords.append(False) continue if not any(char.isupper() for char in password): valid_passwords.append(False) continue if not any(char.islower() for char in password): valid_passwords.append(False) continue if not any(char.isdigit() for char in password): valid_passwords.append(False) continue if not any(char in special_chars for char in password): valid_passwords.append(False) continue valid_passwords.append(True) return valid_passwords"},{"question":"# Problem Statement You are given a list of `n` integers where each integer represents the number of candies each student in a line has. Every student must distribute their candies into groups where each group contains at least `k` candies and no extra candies should remain when distributed. Your task is to implement a function that determines the maximum number of students who can distribute all of their candies into groups of exactly `k` candies, without any leftovers. # Input * An integer `k` representing the minimum number of candies per group. * A list `candies` of `n` integers where each integer represents the number of candies a student has. For example: ```python candies = [10, 15, 20, 25] k = 5 ``` # Output * An integer representing the maximum number of students who can distribute all of their candies into groups of exactly `k` with no leftovers. For example: ```python 3 ``` # Constraints * 1 ≤ n ≤ 10,000 (the number of students) * 1 ≤ candies[i] ≤ 10<sup>6</sup> (the number of candies each student has) * 1 ≤ k ≤ 10<sup>6</sup> (the minimum number of candies per group) # Function Signature ```python def max_students_with_exact_groups(candies: list[int], k: int) -> int: ``` # Example Given the input: ```python candies = [10, 15, 20, 25] k = 5 ``` The output should be: ```python 3 ``` # Explanation * Student 1 has 10 candies, can be divided into 2 groups of 5 candies. * Student 2 has 15 candies, can be divided into 3 groups of 5 candies. * Student 3 has 20 candies, can be divided into 4 groups of 5 candies. * Student 4 has 25 candies, can be divided into 5 groups of 5 candies. * All students can distribute their candies into groups of exactly 5 with no leftovers, so the answer is 4. # Notes * Consider edge cases where no students can distribute candies without leftovers. * Aim for an efficient solution with O(n) complexity.","solution":"def max_students_with_exact_groups(candies, k): Returns the maximum number of students who can distribute all of their candies into groups of exactly k. count = 0 for candy in candies: if candy % k == 0: count += 1 return count"},{"question":"# Objective: Create a function to determine the number of distinct substrings of a given string using a Suffix Array-based approach, testing the candidate’s understanding of advanced string algorithms. # Question: Design a function called `count_distinct_substrings(s: str) -> int` that computes the number of distinct substrings of a given string using a Suffix Array-based approach. This method is expected to be efficient for large strings. # Requirements: * **Input**: A string `s` with length 1 ≤ len(s) ≤ 10^5. * **Output**: An integer representing the number of distinct substrings of the input string. # Constraints: * You must use a Suffix Array-based approach to solve this problem. * Consider efficiency in both time and space complexity, ensuring the solution is optimized for large strings. # Example: ```python def count_distinct_substrings(s: str) -> int: # Your code here # Example Usage print(count_distinct_substrings(\\"abc\\")) # Expected: 6 (substrings are a, b, c, ab, bc, abc) print(count_distinct_substrings(\\"banana\\")) # Expected: 15 (substrings are b, a, n, a, n, a, ba, an, na, an, na, ban, ana, nan, ana) ``` # Function Signature: ```python def count_distinct_substrings(s: str) -> int: ``` # Notes: * The function should handle strings containing lowercase English letters only. * Ensure the algorithm is optimized to handle the upper limit of the string length effectively. * Pay special attention to the correct implementation of the Suffix Array and associated operations to achieve the desired complexity. # Example Explanation: For the string \\"abc\\", the distinct substrings are: \\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", and \\"abc\\". Thus, the function should return 6.","solution":"def count_distinct_substrings(s: str) -> int: def build_suffix_array(s): n = len(s) suffixes = sorted((s[i:], i) for i in range(n)) suffix_arr = [suffix[1] for suffix in suffixes] return suffix_arr def build_lcp_array(s, suffix_arr): n = len(s) rank = [0] * n lcp = [0] * (n - 1) for i, suffix_index in enumerate(suffix_arr): rank[suffix_index] = i h = 0 for i in range(n): if rank[i] > 0: j = suffix_arr[rank[i] - 1] while i + h < n and j + h < n and s[i + h] == s[j + h]: h += 1 lcp[rank[i] - 1] = h if h > 0: h -= 1 return lcp n = len(s) suffix_arr = build_suffix_array(s) lcp = build_lcp_array(s, suffix_arr) num_of_distinct_substrings = n * (n + 1) // 2 num_of_lcp_substrings = sum(lcp) return num_of_distinct_substrings - num_of_lcp_substrings # Example usage print(count_distinct_substrings(\\"abc\\")) # Expected: 6 print(count_distinct_substrings(\\"banana\\")) # Expected: 15"},{"question":"# Coding Assessment Question: Implementing a Genetic Algorithm for Function Optimization Context You are working on a project that involves optimizing a mathematical function using evolutionary strategies. To achieve this, you decide to implement a Genetic Algorithm (GA). GA will help in finding the global optimum of complex, multi-dimensional functions by mimicking the process of natural selection. Task Write a function that uses a Genetic Algorithm to find the maximum value of a given function within specified bounds. The function should return the best solution found and its corresponding fitness value after a defined number of generations. Function Signature ```python def genetic_algorithm(func: callable, bounds: list[tuple[int, int]], population_size: int, generations: int, mutation_rate: float) -> tuple[list[float], float]: ``` Input Format * `func`: A callable function that takes a list of floats as input and returns a float. * `bounds`: A list of tuples where each tuple represents the lower and upper bounds for a dimension. * `population_size`: An integer representing the number of individuals in the population. * `generations`: An integer representing the number of iterations over which the population evolves. * `mutation_rate`: A float representing the probability of mutation for each individual. Output Format * The function returns a tuple: * The first element is a list of floats representing the best solution (set of parameters) found. * The second element is a float representing the fitness value of the best solution. Constraints * Each individual in the population is represented as a list of floats within the given bounds. * The number of generations (`generations`) will be a positive integer. * The mutation rate (`mutation_rate`) will be a small positive float (typically between 0.01 and 0.1). Example ```python def example_func(solution): return -sum(x**2 for x in solution) # Simple sphere function bounds = [(-10, 10), (-10, 10), (-10, 10)] population_size = 20 generations = 50 mutation_rate = 0.05 best_solution, best_fitness = genetic_algorithm(example_func, bounds, population_size, generations, mutation_rate) print(f\\"Best solution: {best_solution}\\") print(f\\"Best fitness value: {best_fitness}\\") ``` **Note:** Ensure your implementation includes steps for selection, crossover, and mutation. Handle edge cases such as invalid bounds and ensure convergence towards the optimal solution.","solution":"import random def genetic_algorithm(func, bounds, population_size, generations, mutation_rate): Genetic Algorithm to find the maximum value of a given function within specified bounds. :param func: Callable function to optimize. :param bounds: List of tuples for lower and upper bounds for each dimension. :param population_size: Number of individuals in the population. :param generations: Number of generations. :param mutation_rate: Probability of mutation. :return: Tuple containing the best solution and its fitness value. # Initialize the population with random solutions within the specified bounds population = [[random.uniform(b[0], b[1]) for b in bounds] for _ in range(population_size)] def fitness(individual): return func(individual) # Main loop for generations for _ in range(generations): # Evaluate the fitness of each individual in the population population_fitness = [(individual, fitness(individual)) for individual in population] # Sort the population by fitness (descending order) population_fitness.sort(key=lambda x: x[1], reverse=True) # Select the top individuals to form the next generation next_generation = [individual for individual, fit in population_fitness[:population_size//2]] # Perform crossover to produce offspring while len(next_generation) < population_size: parent1, parent2 = random.sample(next_generation[:population_size//2], 2) crossover_point = random.randint(1, len(bounds) - 1) offspring = parent1[:crossover_point] + parent2[crossover_point:] next_generation.append(offspring) # Apply mutation for individual in next_generation: if random.random() < mutation_rate: mutation_index = random.randint(0, len(bounds) - 1) individual[mutation_index] = random.uniform(bounds[mutation_index][0], bounds[mutation_index][1]) # Update population with the next generation population = next_generation # Final evaluation to get the best individual population_fitness = [(individual, fitness(individual)) for individual in population] best_individual, best_fitness_value = max(population_fitness, key=lambda x: x[1]) return best_individual, best_fitness_value"},{"question":"# Problem Description As a data analyst, you are required to create a utility that converts temperatures between Celsius and Fahrenheit. This will help in analyzing data sets that are in different units of temperature. Objective Write two functions `celsius_to_fahrenheit` and `fahrenheit_to_celsius` that convert temperatures from Celsius to Fahrenheit and vice versa. Function Signatures * `celsius_to_fahrenheit(celsius: float) -> float` * `fahrenheit_to_celsius(fahrenheit: float) -> float` # Function Definitions 1. **celsius_to_fahrenheit** This function converts the temperature from Celsius to Fahrenheit using the formula: [ text{Fahrenheit} = (text{Celsius} times frac{9}{5}) + 32 ] 2. **fahrenheit_to_celsius** This function converts the temperature from Fahrenheit to Celsius using the formula: [ text{Celsius} = (text{Fahrenheit} - 32) times frac{5}{9} ] # Input * `celsius` (float): The temperature in degrees Celsius. (can be any real number) * `fahrenheit` (float): The temperature in degrees Fahrenheit. (can be any real number) # Output * Returns the converted temperature as a float. # Examples ```python # Example for celsius_to_fahrenheit print(celsius_to_fahrenheit(0)) # Expected Output: 32.0 print(celsius_to_fahrenheit(-40)) # Expected Output: -40.0 print(celsius_to_fahrenheit(100)) # Expected Output: 212.0 # Example for fahrenheit_to_celsius print(fahrenheit_to_celsius(32)) # Expected Output: 0.0 print(fahrenheit_to_celsius(-40)) # Expected Output: -40.0 print(fahrenheit_to_celsius(212)) # Expected Output: 100.0 ``` # Instructions 1. Ensure that the mathematical conversions are correctly implemented. 2. Verify results with the examples provided and add additional test cases to ensure accuracy.","solution":"def celsius_to_fahrenheit(celsius: float) -> float: Convert temperature from Celsius to Fahrenheit. Parameters: celsius (float): Temperature in Celsius Returns: float: Temperature in Fahrenheit return (celsius * 9/5) + 32 def fahrenheit_to_celsius(fahrenheit: float) -> float: Convert temperature from Fahrenheit to Celsius. Parameters: fahrenheit (float): Temperature in Fahrenheit Returns: float: Temperature in Celsius return (fahrenheit - 32) * 5/9"},{"question":"# Cell Merge Challenge Given a 2D grid of integers, implement a function that merges all connected cells having the same integer value into larger cells. Each cell can merge with its adjacent cells horizontally or vertically (but not diagonally). # Function Signature ```python def merge_cells(grid: list[list[int]]) -> list[list[int]]: Returns a new 2D grid with merged cells where each group of connected cells with the same integer value is replaced by a single cell with that integer value. ``` # Input * A 2D list of integers `grid` representing the grid. # Output * A 2D list where each group of connected cells with the same integer value is replaced by a single cell with that integer value, and all other cells in the merged group are replaced with 0. # Constraints * The grid will have at least 1 row and at most 100 rows. * The grid will have at least 1 column and at most 100 columns. * Each integer in the grid will be between 0 and 9. # Example ```python >>> grid = [ ... [1, 2, 2], ... [3, 2, 2], ... [3, 3, 4] ... ] >>> merge_cells(grid) [ [1, 2, 0], [3, 0, 0], [0, 0, 4] ] >>> grid = [ ... [5, 5], ... [5, 5] ... ] >>> merge_cells(grid) [ [5, 0], [0, 0] ] ``` # Scenario In a spreadsheet-like application, cells with the same integer value can be merged into larger cells to simplify data presentation. The challenge involves identifying and performing the merging operation in a way that adheres to horizontal and vertical adjacency rules. The result grid should reflect these merges with unique connected values preserved and replaced by a single cell while other redundant positions are filled with zeroes. # Performance Requirements Your solution should efficiently handle the grid size within the constraints, ensuring merges are performed considering all connected groups. The time complexity must account for the potential maximum grid size and the traversal of its cells.","solution":"def merge_cells(grid): def dfs(x, y, value): stack = [(x, y)] while stack: i, j = stack.pop() if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == value: grid[i][j] = 0 cells.add((i, j)) neighbors = [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)] stack.extend(neighbors) for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: value = grid[i][j] cells = set() dfs(i, j, value) min_i = min(cell[0] for cell in cells) min_j = min(cell[1] for cell in cells) grid[min_i][min_j] = value return grid"},{"question":"# Coding Assessment Question Problem Statement You are tasked with parsing log files, extracting specific information, and summarizing the results. Each log entry is a JSON object representing a single event. Write a function that processes these log entries to identify the unique users and count the number of activities they have performed within a specified time range. Function to Implement ```python from typing import List, Dict import json from datetime import datetime def summarize_user_activities(logs: List[str], start_time: str, end_time: str) -> Dict[str, int]: Summarize the user activities within the specified time range. Parameters: - logs (List[str]): A list of JSON strings, each representing a log entry. - start_time (str): The start time in the format \'YYYY-MM-DDTHH:MM:SS\'. - end_time (str): The end time in the format \'YYYY-MM-DDTHH:MM:SS\'. Returns: - Dict[str, int]: A dictionary where keys are user IDs and values are the number of activities performed by the user within the time range. pass ``` Expectations 1. **Functionality**: - The function should parse each log entry and extract the user ID and timestamp. - It should count only the activities that occurred within the given time range (inclusive). - The result should be a dictionary where the keys are user IDs and the values are the counts of their activities within the time range. 2. **Input/Output**: - The function takes three parameters: `logs` (a list of JSON strings), `start_time` (a string), and `end_time` (a string). - It returns a dictionary with user IDs as keys and activity counts as values. 3. **Constraints**: - Assume each log entry is a valid JSON object with \'user_id\' and \'timestamp\' fields. - Ensure the time range strings are in the format \'YYYY-MM-DDTHH:MM:SS\'. - The function should handle edge cases like logs within milliseconds of the start or end times. - Implement the solution efficiently to handle large lists of log entries. Example Usage ```python # Example log entries logs = [ \'{\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-01-01T10:00:00\\", \\"action\\": \\"login\\"}\', \'{\\"user_id\\": \\"user2\\", \\"timestamp\\": \\"2023-01-01T10:05:00\\", \\"action\\": \\"logout\\"}\', \'{\\"user_id\\": \\"user1\\", \\"timestamp\\": \\"2023-01-01T10:10:00\\", \\"action\\": \\"view\\"}\', \'{\\"user_id\\": \\"user3\\", \\"timestamp\\": \\"2023-01-01T10:15:00\\", \\"action\\": \\"click\\"}\' ] start_time = \\"2023-01-01T10:00:00\\" end_time = \\"2023-01-01T10:10:00\\" # Expected output: {\'user1\': 2, \'user2\': 1} print(summarize_user_activities(logs, start_time, end_time)) ``` --- This question aligns with the given sample in terms of style, complexity, and scope, presenting a realistic problem that requires parsing, filtering, and summarizing the data. It is self-contained, adheres to the problem domain, and involves key programming concepts related to JSON parsing, date/time manipulation, and dictionary operations.","solution":"from typing import List, Dict import json from datetime import datetime def summarize_user_activities(logs: List[str], start_time: str, end_time: str) -> Dict[str, int]: Summarize the user activities within the specified time range. Parameters: - logs (List[str]): A list of JSON strings, each representing a log entry. - start_time (str): The start time in the format \'YYYY-MM-DDTHH:MM:SS\'. - end_time (str): The end time in the format \'YYYY-MM-DDTHH:MM:SS\'. Returns: - Dict[str, int]: A dictionary where keys are user IDs and values are the number of activities performed by the user within the time range. start_dt = datetime.strptime(start_time, \'%Y-%m-%dT%H:%M:%S\') end_dt = datetime.strptime(end_time, \'%Y-%m-%dT%H:%M:%S\') activity_count = {} for log in logs: log_entry = json.loads(log) user_id = log_entry[\'user_id\'] timestamp = log_entry[\'timestamp\'] log_dt = datetime.strptime(timestamp, \'%Y-%m-%dT%H:%M:%S\') if start_dt <= log_dt <= end_dt: if user_id not in activity_count: activity_count[user_id] = 0 activity_count[user_id] += 1 return activity_count"},{"question":"# Coding Assessment Question **Array Subset Sum** You are given an array of integers and a target sum. Your task is to determine if there exists a subset of the given array such that the sum of the subset is equal to the target sum. # Function Signature ```python def is_subset_sum(arr: List[int], target: int) -> bool: Determine if there is a subset in the array `arr` with a sum equal to `target`. :param arr: List[int] representing the array of integers. :param target: int representing the target sum. :return: True if a subset with sum equal to `target` exists, False otherwise. ``` # Input and Output - **Input**: - A list of integers `arr` with length `n`. - An integer `target`. - **Output**: A boolean, `True` if a subset with sum equal to `target` exists within `arr`, `False` otherwise. # Example ```python # Example 1 arr = [3, 34, 4, 12, 5, 2] target = 9 assert is_subset_sum(arr, target) == True # Example 2 arr = [1, 2, 3, 7] target = 6 assert is_subset_sum(arr, target) == True # Example 3 arr = [3, 34, 4, 12, 5, 2] target = 30 assert is_subset_sum(arr, target) == False ``` # Constraints - The length of the array `arr` is between 1 and 1000. - Each element in the array `arr` is between -10⁶ and 10⁶. - The target sum can be any valid integer. - Elements in the array can be positive, negative, or zero. # Guidelines - Utilize dynamic programming or recursion to efficiently solve the subset sum problem. - Carefully handle edge cases including: - An array with a single element. - Arrays which include negative numbers. - A target sum of zero. # Performance Requirements - Your solution should be optimized for both time and space, ideally running in O(n * target) time complexity.","solution":"from typing import List def is_subset_sum(arr: List[int], target: int) -> bool: Determine if there is a subset in the array `arr` with a sum equal to `target`. :param arr: List[int] representing the array of integers. :param target: int representing the target sum. :return: True if a subset with sum equal to `target` exists, False otherwise. n = len(arr) dp = [[False] * (target + 1) for _ in range(n + 1)] # When target is 0, subset sum is always True (empty subset) for i in range(n + 1): dp[i][0] = True # Populate the DP table for i in range(1, n + 1): for j in range(1, target + 1): if arr[i-1] > j: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j-arr[i-1]] return dp[n][target]"},{"question":"**Context:** You are developing a text processing module that involves searching and replacing multiple patterns in a large body of text. This could be part of a larger system like a code editor, text formatting tool, or content management system. # Task: Implement a function `multiple_replace` that takes a string and a dictionary. The function should replace all occurrences of each key in the string with its corresponding value from the dictionary. # Specifications: 1. The replacements should be done in a single pass over the string if possible to ensure efficiency. 2. The function should be case-sensitive. 3. Overlapping patterns should be handled correctly, replacing each match independently. # Input: - `text` (string): The input text in which replacements are to be made. - `replacements` (dict): A dictionary where each key is a string to search for, and its value is the string to replace it with. # Output: - A new string with all replacements made. # Constraints: - The length of `text` can be up to 10^6 characters. - `replacements` dictionary can contain up to 10^4 key-value pairs. - Each key in `replacements` can have a length of up to 10^3 characters. - The order of replacements does not affect the final output (no replacements depend on other replacements being performed first). **Example:** ```python def multiple_replace(text: str, replacements: dict) -> str: # Implementation here # Test cases: text = \\"hello world, hello universe\\" replacements = {\\"hello\\": \\"hi\\", \\"world\\": \\"earth\\"} assert multiple_replace(text, replacements) == \\"hi earth, hi universe\\" text = \\"This is a test. Testing is good.\\" replacements = {\\"test\\": \\"exam\\", \\"Testing\\": \\"Examining\\"} assert multiple_replace(text, replacements) == \\"This is a exam. Examining is good.\\" ``` # Notes: - Consider using efficient string processing techniques to handle large text inputs and multiple pattern replacements efficiently. - Ensure that the function maintains the correct order of replacements as specified and handles cases where a key to replace might appear multiple times in the text.","solution":"import re def multiple_replace(text: str, replacements: dict) -> str: Replace all occurrences of each key in the string with its corresponding value from the dictionary. Parameters: text (str): The input text in which replacements are to be made. replacements (dict): A dictionary where each key is a string to search for, and its value is the string to replace it with. Returns: str: A new string with all replacements made. # Create a regular expression pattern that matches any of the keys in the replacements dictionary pattern = re.compile(\\"|\\".join(re.escape(key) for key in replacements.keys())) # Function to be used for re.sub, which will lookup the replacements for the matched text def replacer(match): return replacements[match.group(0)] # Use re.sub with the created pattern and the replacer function for substitution return pattern.sub(replacer, text)"},{"question":"# Question: Nth Triangular Number Finder You are given a positive integer `n` representing the position of a triangular number in the sequence. Your task is to implement a function `find_triangular_number(n: int) -> int` which calculates the nth triangular number using the formula ( T_n = frac{n times (n + 1)}{2} ). Function Signature ```python def find_triangular_number(n: int) -> int: pass ``` Input * A single integer `n` where `1 <= n <= 10^5`. Output * The nth triangular number as an integer. Constraints * The input ( n ) will always be a positive integer within the range specified. * The function should raise a `ValueError` if the input is not a positive integer or raise a `TypeError` if the input is not an integer. Example ```python >>> find_triangular_number(4) 10 >>> find_triangular_number(7) 28 >>> find_triangular_number(10) 55 >>> find_triangular_number(0) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> find_triangular_number(-2) Traceback (most recent call last): ... ValueError: Input must be a positive integer >>> find_triangular_number(8.5) Traceback (most recent call last): ... TypeError: Input value of [number=8.5] must be an integer ``` # Scenario Consider you are developing a learning module for a mathematics course, where students calculate different types of figurate numbers including triangular numbers. By inputting a position `n`, the tool displays the corresponding triangular number. Your task is to implement this function adhering to the constraints, edge cases, and requirements provided to ensure accuracy in the educational tool.","solution":"def find_triangular_number(n: int) -> int: This function returns the nth triangular number. It raises a ValueError if the input is not a positive integer or if the input is less than 1. It raises a TypeError if the input is not an integer. if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") return n * (n + 1) // 2"},{"question":"# Partition Equal Subset Sum Given an array of positive integers, determine if it can be partitioned into two subsets such that the sums of the subsets are equal. # Function Signature ```python def can_partition(nums: List[int]) -> bool: pass ``` # Input - `nums` (List[int]): The list of positive integers (1 ≤ len(nums) ≤ 200, 1 ≤ nums[i] ≤ 100). # Output - Returns `True` if the array can be partitioned into two subsets with equal sum; otherwise, returns `False`. # Constraints - The input array consists of positive integers only. # Example ```python assert can_partition([1, 5, 11, 5]) == True # (Partition into [1, 5, 5] and [11]) assert can_partition([1, 2, 3, 5]) == False # (No such partition exists) assert can_partition([1, 1, 1, 1]) == True # ([1, 1] and [1, 1]) assert can_partition([1]) == False # (Only one element, cannot partition) assert can_partition([2, 2, 3, 5]) == False # ([2, 2, 3] and [5]) assert can_partition([50, 50, 2, 2]) == True # ([50, 2] and [50, 2]) ``` # Requirements 1. Implement the function using a dynamic programming approach. 2. Ensure it operates within O(n * sum(nums) / 2) time complexity. 3. Manage memory efficiently, keeping within O(sum(nums) / 2) space complexity.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, we can\'t split it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Create a dp array of size (target + 1) dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# String Permutation Finder Context: You need to determine if a smaller string is a permutation of a substring within a larger string. A permutation is a rearrangement of letters. Problem Statement: Write a function `is_permutation_in_string` that receives two strings, `s1` and `s2`, and returns `True` if `s1`\'s permutation is a substring of `s2`, and `False` otherwise. Function Signature: ```python def is_permutation_in_string(s1: str, s2: str) -> bool: ``` Input: - `s1`: A string representing the smaller string (1 <= len(s1) <= 100) - `s2`: A string representing the larger string (1 <= len(s2) <= 1000) Output: - `bool`: `True` if any permutation of `s1` is a substring of `s2`, `False` otherwise. Example: ```python >>> is_permutation_in_string(\\"ab\\", \\"eidbaooo\\") True >>> is_permutation_in_string(\\"ab\\", \\"eidboaoo\\") False ``` Notes: - Make sure to handle edge cases where the input strings\' lengths are on their minimum boundaries. - Consider optimizing the solution to avoid checking all possible permutations explicitly, for instance, by using a sliding window approach. # Similarities & Alignment: - The length and complexity of this problem are similar to existing questions, providing a balance of algorithmic thinking and implementation challenge. - This question focuses on string manipulation and permutation checks, aligning with typical coding assessment topics. - Permutations and substring searches are fundamental programming concepts, making the question both relevant and educational.","solution":"from collections import Counter def is_permutation_in_string(s1: str, s2: str) -> bool: Determines whether any permutation of s1 is a substring of s2. len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return False s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) if s1_counter == window_counter: return True for i in range(len_s1, len_s2): start_char = s2[i - len_s1] end_char = s2[i] window_counter[end_char] += 1 window_counter[start_char] -= 1 if window_counter[start_char] == 0: del window_counter[start_char] if window_counter == s1_counter: return True return False"},{"question":"# Coding Problem: Earthquake Magnitude Calculation **Context**: You are working with a seismology research team tasked with calculating the energy released by an earthquake using the Richter scale. The energy release ( E ) is calculated from the magnitude ( M ) of the earthquake. **Task**: Implement a function `earthquake_energy` that calculates the energy released using the formula: [ E = 10^{(4.8 + 1.5 cdot M)} ] Where: * (E) = Energy released by the earthquake in joules * (M) = Magnitude of the earthquake on the Richter scale # Function Signature ```python def earthquake_energy(magnitude: float) -> float: pass ``` # Input format * `magnitude`: A float representing the magnitude of the earthquake on the Richter scale. It should be a non-negative number. # Output format * Return a float representing the energy released by the earthquake in joules. # Constraints * The `magnitude` parameter should be non-negative. * If the `magnitude` parameter is negative, raise a `ValueError` with the message: \\"Magnitude must be non-negative.\\" # Performance Requirements * The function must operate in constant time (O(1)). # Examples ```python assert earthquake_energy(5.0) == 10 ** (4.8 + 1.5 * 5.0) assert earthquake_energy(3.2) == 10 ** (4.8 + 1.5 * 3.2) assert earthquake_energy(0.0) == 10 ** 4.8 ``` # Notes * Use Python\'s exponentiation operator to compute the energy: (10 ** (4.8 + 1.5 cdot M)). * Ensure the result is represented as a float, even for large values.","solution":"def earthquake_energy(magnitude: float) -> float: Calculates the energy released by an earthquake given its magnitude on the Richter scale. Parameters: magnitude (float): The magnitude of the earthquake on the Richter scale. Must be a non-negative number. Returns: float: The energy released by the earthquake in joules. Raises: ValueError: If the magnitude is negative. if magnitude < 0: raise ValueError(\\"Magnitude must be non-negative\\") return 10 ** (4.8 + 1.5 * magnitude)"},{"question":"# Leaky Integrator Design and Implementation Background You are developing a signal processing application that requires efficient methods for smoothing noisy data. One effective approach is to implement a leaky integrator filter. This type of filter is known for its simplicity and effectiveness in gradually smoothing data, making it an ideal candidate for your application. Task Implement the `process` method in the provided `FilterType` interface and use it to apply a leaky integrator filter to a stream of data samples. Your implementation should smooth the input signal based on the specified parameters and enable visualization of the filter\'s step response. Requirements - Implement the `process` method in a class, `LeakyIntegrator`, that conforms to the `FilterType` interface. - The `process` method should implement a leaky integrator filter with a specified leakage factor. - Use the provided `show_step_response` method to visualize the step response of your filter. Filter Description A leaky integrator filter can be described as: [ y[n] = beta y[n-1] + (1 - beta) x[n] ] where: - ( y[n] ) is the output at the ( n )-th sample, - ( x[n] ) is the input at the ( n )-th sample, - ( beta ) is the leakage factor between 0 and 1. Input - A single input sample: `float` - The leakage factor (beta), a float value between 0 and 1. Output - The smoothed sample value: `float` Example Usage ```python class LeakyIntegrator(FilterType): def __init__(self, beta: float): self.beta = beta self.prev_output = 0.0 def process(self, sample: float) -> float: self.prev_output = self.beta * self.prev_output + (1 - self.beta) * sample return self.prev_output # Example: Visualizing the filter\'s step response leak_factor = 0.8 integrator = LeakyIntegrator(beta=leak_factor) show_step_response(integrator) ``` Constraints - Ensure that the filter correctly handles edge cases, such as sudden large variations in input values. - Visualization should be executed within reasonable time and should effectively demonstrate the filter\'s behavior. Good luck!","solution":"class LeakyIntegrator: def __init__(self, beta: float): Initializes the LeakyIntegrator with a specified leakage factor beta. Parameters: beta (float): The leakage factor between 0 and 1. self.beta = beta self.prev_output = 0.0 def process(self, sample: float) -> float: Processes the input sample using the leaky integrator filter. Parameters: sample (float): The input sample to be filtered. Returns: float: The filtered output sample. self.prev_output = self.beta * self.prev_output + (1 - self.beta) * sample return self.prev_output"},{"question":"# Coding Challenge: Warehouse Stock Analysis You are provided with a dataset representing the stock levels of various products in a warehouse. Each product has an identifier and multiple attributes, such as quantity in stock, reorder level, and sales rate. Your task is to write a function that identifies products that are below their reorder levels and returns a list of these products sorted by their reorder urgency. The reorder urgency for a product is calculated as the difference between its reorder level and its current stock level. Products with a higher difference should be considered more urgent and, thus, come first in the output list. Function Signature ```python def identify_reorder_urgency( stock_data: list[list[Union[str, int]]] ) -> list[list[Union[str, int]]]: pass ``` Parameters - `stock_data`: The input data, a list of lists, where each sub-list represents a product with the following elements in order: 1. Product Identifier (a unique string) 2. Current Stock Level (an integer) 3. Reorder Level (an integer) 4. Sales Rate (units sold per day, an integer) Constraints - Each product will have a unique identifier. - The stock levels, reorder levels, and sales rates are non-negative integers. - Assume all input values are valid and properly formatted. Output - A list of lists, where each sub-list consists of the product identifier and its reorder urgency. The list should only include products that are below their reorder level and should be sorted by reorder urgency in descending order. # Example ```python stock_data = [ [\\"A101\\", 50, 100, 5], [\\"B205\\", 20, 30, 10], [\\"C303\\", 5, 20, 2], [\\"D402\\", 80, 100, 15], [\\"E501\\", 60, 50, 7] ] urgent_products = identify_reorder_urgency(stock_data) print(urgent_products) ``` **Output:** ```python [ [\\"C303\\", 15], [\\"B205\\", 10], [\\"A101\\", 50], [\\"D402\\", 20] ] ``` Write the function `identify_reorder_urgency` to solve the problem.","solution":"def identify_reorder_urgency(stock_data): Identifies products that are below their reorder levels and returns a list of these products, sorted by reorder urgency in descending order. Params: stock_data (list of lists): List representing product stock data. Each sublist contains: - Product Identifier (str) - Current Stock Level (int) - Reorder Level (int) - Sales Rate (int) Returns: list: A list of lists where each sublist consists of the product identifier and its reorder urgency. The list includes only products that are below their reorder level and is sorted by reorder urgency in descending order. # List to store products that are below reorder level below_reorder_level = [] for product in stock_data: identifier, current_stock, reorder_level, _ = product if current_stock < reorder_level: reorder_urgency = reorder_level - current_stock below_reorder_level.append([identifier, reorder_urgency]) # Sort the list by reorder urgency in descending order below_reorder_level.sort(key=lambda x: x[1], reverse=True) return below_reorder_level # Example usage stock_data = [ [\\"A101\\", 50, 100, 5], [\\"B205\\", 20, 30, 10], [\\"C303\\", 5, 20, 2], [\\"D402\\", 80, 100, 15], [\\"E501\\", 60, 50, 7] ] print(identify_reorder_urgency(stock_data))"},{"question":"# Problem Statement Write a function in Python to perform a depth-first traversal (DFT) of a binary tree. The function should return two lists: one containing the values of the nodes as visited in the DFT order and the other containing the values of the nodes as visited in the DFT post-order. # Requirements - The binary tree nodes must be represented by a class `TreeNode`, where each node contains a value, a reference to the left child, and a reference to the right child. - The main function `depth_first_traversal(root)` should: - Perform a depth-first in-order traversal of the binary tree, starting from the `root` node. - Perform a depth-first post-order traversal of the binary tree, starting from the `root` node. - Return two lists: the first list should contain node values in the in-order traversal order, and the second list should contain node values in the post-order traversal order. # Input and Output - **depth_first_traversal(root)**: - Input: `root` (TreeNode) - Output: A tuple of two lists: (list of node values in in-order, list of node values in post-order) # Constraints - Assume the `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - The binary tree may contain any number of nodes, including none. - Ensure the function is implemented using a recursive approach. # Example ```python # Constructing a sample binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Performing depth-first traversal in_order, post_order = depth_first_traversal(root) print(in_order) # Output: [4, 2, 5, 1, 3] print(post_order) # Output: [4, 5, 2, 3, 1] ``` # Implementation Please write the function `depth_first_traversal` in Python that meets the requirements mentioned above. Ensure to include proper docstrings and test cases.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_first_traversal(root): Perform a depth-first traversal of a binary tree. Args: root (TreeNode): The root of the binary tree. Returns: Tuple[List[int], List[int]]: A tuple containing two lists: - The first list in in-order traversal order. - The second list in post-order traversal order. in_order_list = [] post_order_list = [] def in_order(node): if node: in_order(node.left) in_order_list.append(node.value) in_order(node.right) def post_order(node): if node: post_order(node.left) post_order(node.right) post_order_list.append(node.value) in_order(root) post_order(root) return in_order_list, post_order_list"},{"question":"# Coding Problem: Detect Cycles in a Directed Graph You are given a directed graph. Your task is to determine if the graph contains any cycles. A cycle in a directed graph is a path that starts and ends at the same vertex, with all edges following the direction of the graph. # Function Signature ```python def has_cycle(graph: Dict[int, List[int]]) -> bool: ``` # Input - `graph`: A dictionary representing a directed graph where the keys are node identifiers (integers) and the values are lists of adjacent nodes (also integers). The graph may have unique node identifiers and the adjacency list strictly follows the direction of edges. # Output - A boolean value `True` if the graph contains a cycle; otherwise, `False`. # Constraints - The number of nodes, `n`, ranges from 1 to 10^5. - The number of edges, `m`, ranges from 0 to 10^6. # Example Input ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [], } ``` Output ```python True ``` Input ```python graph = { 0: [1], 1: [2], 2: [3], 3: [] } ``` Output ```python False ``` # Explanation - In the first example: - The directed graph contains a cycle (0 -> 1 -> 2 -> 0). - In the second example: - The directed graph does not contain any cycles. # Notes - To implement an efficient solution with time complexity O(V + E), consider using depth-first search (DFS) with recursion stack or Kahn\'s algorithm for detecting cycles in a directed graph. - Account for edge cases such as graphs with isolated nodes or graphs with no edges. This problem involves detecting cycles in a directed graph, matching the complexity and domain of graph-related problems while introducing a complementary challenge compared to finding articulation points in an undirected graph.","solution":"def has_cycle(graph): Detect if a directed graph contains a cycle using DFS. visited = set() rec_stack = set() def dfs(v): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Implementing a Custom Matrix Class with Special Operations Scenario: You are required to implement a custom matrix class that supports the following operations: 1. **Matrix Addition**: Add two matrices. 2. **Matrix Subtraction**: Subtract one matrix from another. 3. **Scalar Multiplication**: Multiply a matrix by a scalar value. 4. **Custom Element-wise Function Application**: Apply a user-provided function to each element of the matrix. 5. **Flatten Matrix**: Return the matrix elements as a flattened list. Task: Implement the `Matrix` class with the following methods: ```python class Matrix: def __init__(self, grid: List[List[int]]) -> None: # Initialize the Matrix with a 2D list of integers pass def add(self, other: \'Matrix\') -> \'Matrix\': # Add the current matrix with `other` and return a new Matrix pass def subtract(self, other: \'Matrix\') -> \'Matrix\': # Subtract `other` from the current matrix and return a new Matrix pass def scalar_multiply(self, scalar: int) -> \'Matrix\': # Multiply each element of the current matrix by `scalar` and return a new Matrix pass def apply_function(self, func: Callable[[int], int]) -> \'Matrix\': # Apply a user-provided function `func` to each element of the matrix and return a new Matrix pass def flatten(self) -> List[int]: # Return the matrix elements as a flattened list pass ``` * **Parameters**: - `grid`: A 2D list of integers representing the matrix. * **Methods**: - `add(self, other: \'Matrix\') -> \'Matrix\'`: Adds two matrices. - `subtract(self, other: \'Matrix\') -> \'Matrix\'`: Subtracts one matrix from another. - `scalar_multiply(self, scalar: int) -> \'Matrix\'`: Multiplies the matrix by a scalar. - `apply_function(self, func: Callable[[int], int]) -> \'Matrix\'`: Applies a function to each element. - `flatten(self) -> List[int]`: Flattens the matrix to a list of integers. * **Constraints**: - Matrices to be added or subtracted must be of the same dimensions. - Elements in the grid can be negative or positive integers. - The provided grid can be empty or contain up to (10^4) elements in total. * **Example**: ```python # Example usage: m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[5, 6], [7, 8]]) result_add = m1.add(m2) # Returns: Matrix([[6, 8], [10, 12]]) result_sub = m1.subtract(m2) # Returns: Matrix([[-4, -4], [-4, -4]]) result_scalar_mult = m1.scalar_multiply(2) # Returns: Matrix([[2, 4], [6, 8]]) result_apply_func = m1.apply_function(lambda x: x * x) # Returns: Matrix([[1, 4], [9, 16]]) result_flatten = m1.flatten() # Returns: [1, 2, 3, 4] ``` Note: - Ensure the implementation is robust and validates the dimensions of matrices before performing operations. - Thoroughly test the class methods with various edge cases, such as operations on empty matrices and single-element matrices.","solution":"from typing import List, Callable class Matrix: def __init__(self, grid: List[List[int]]) -> None: self.grid = grid def add(self, other: \'Matrix\') -> \'Matrix\': if len(self.grid) != len(other.grid) or any(len(row) != len(other.grid[i]) for i, row in enumerate(self.grid)): raise ValueError(\\"Matrices must have the same dimensions for addition\\") return Matrix([[self.grid[i][j] + other.grid[i][j] for j in range(len(self.grid[i]))] for i in range(len(self.grid))]) def subtract(self, other: \'Matrix\') -> \'Matrix\': if len(self.grid) != len(other.grid) or any(len(row) != len(other.grid[i]) for i, row in enumerate(self.grid)): raise ValueError(\\"Matrices must have the same dimensions for subtraction\\") return Matrix([[self.grid[i][j] - other.grid[i][j] for j in range(len(self.grid[i]))] for i in range(len(self.grid))]) def scalar_multiply(self, scalar: int) -> \'Matrix\': return Matrix([[scalar * element for element in row] for row in self.grid]) def apply_function(self, func: Callable[[int], int]) -> \'Matrix\': return Matrix([[func(element) for element in row] for row in self.grid]) def flatten(self) -> List[int]: return [element for row in self.grid for element in row]"},{"question":"# Binary Tree Symmetry Checker **Scenario**: You are developing a feature to analyze binary trees for a scientific computing application. Your task is to determine if a given binary tree is symmetric around its center. **Task**: Implement the `SymmetricTree` class with a method to check if the tree is a mirror of itself. **Function Signatures**: ```python class SymmetricTree: @staticmethod def is_symmetric(root: \'TreeNode\') -> bool: pass ``` **Helper Class Definition**: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Requirements**: 1. **Symmetry Check Function (`is_symmetric`)**: - Takes a `root` node of a binary tree as input. - Returns `True` if the tree is symmetric; otherwise, returns `False`. - Ensure the implementation is efficient with a time complexity of O(n), where n is the number of nodes in the tree. - Handle edge cases such as an empty tree (which is considered symmetric). **Constraints**: - The number of nodes in the tree will be between 0 and 10,000. - The node values will be integers between -100 and 100. **Example**: ```python # Example 1 root = TreeNode(val=1, left=TreeNode(2), right=TreeNode(2, TreeNode(3), TreeNode(4))) # Tree structure: # 1 # / # 2 2 # / # 3 4 SymmetricTree().is_symmetric(root) False # Example 2 root = TreeNode(val=1, left=TreeNode(2, TreeNode(3), TreeNode(4)), right=TreeNode(2, TreeNode(4), TreeNode(3))) # Tree structure: # 1 # / # 2 2 # / / # 3 4 4 3 SymmetricTree().is_symmetric(root) True ``` Ensure your implementation thoroughly validates the symmetry of the tree and efficiently handles large datasets. Test your solution with various tree structures to confirm its accuracy and performance.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class SymmetricTree: @staticmethod def is_symmetric(root: TreeNode) -> bool: if not root: return True def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left) return is_mirror(root.left, root.right)"},{"question":"# Question: Generating Unique Hexadecimal Color Codes You are tasked with generating a specified number of unique hexadecimal color codes. Each color code must be a 6-digit hexadecimal number ranging from `#000000` to `#FFFFFF`. Write a function `generate_unique_colors(n: int) -> list[str]` that generates `n` unique color codes. Your implementation must follow these requirements: 1. **Each color code must be unique**: No two color codes in the output list should be the same. 2. **Format**: Each color code should be in the format `#RRGGBB`, where `RR`, `GG`, and `BB` are two-digit hexadecimal representations of the red, green, and blue color components, respectively. # Input - `n` (int): The number of unique color codes to generate (1 ≤ n ≤ 10^5). # Output - A list of `n` unique hexadecimal color codes in `#RRGGBB` format. # Constraints - You must ensure that the returned list contains exactly `n` unique color codes. - The function should be able to handle the upper limit efficiently. # Example ```python n = 3 print(generate_unique_colors(n)) # Expected Output: [\\"#A1B2C3\\", \\"#4F5A6B\\", \\"#FF5733\\"] # Example, actual output will vary n = 5 print(generate_unique_colors(n)) # Expected Output: [\\"#D926A5\\", \\"#2BC9EB\\", \\"#98F210\\", \\"#4B0D77\\", \\"#BF1829\\"] # Example, actual output will vary ``` Ensure to write the function in a clean and efficient manner. Consider edge cases, such as generating the maximum amount of color codes allowed. Your solution should efficiently handle large inputs within reasonable time limits.","solution":"import random def generate_unique_colors(n: int) -> list[str]: Generate a list of `n` unique hexadecimal color codes in the format #RRGGBB. Args: n (int): The number of unique color codes to generate. Returns: list[str]: A list of `n` unique hexadecimal color codes. color_set = set() while len(color_set) < n: color_code = \\"#{:06X}\\".format(random.randint(0, 0xFFFFFF)) color_set.add(color_code) return list(color_set)"},{"question":"# Scenario You are working as a software engineer in a financial technology firm that deals with large volumes of transaction data. To ensure data integrity and efficient processing, the company requires you to implement a data structure that can handle a dynamic stream of transactions by keeping track of their median value in real-time. # Task Implement a class `MedianFinder` which supports the following methods: 1. `add_num(self, num: int) -> None`: * Adds the number `num` to the data stream. 2. `find_median(self) -> float`: * Finds the median of all elements added so far. * Returns the median as a float. # Constraints: - Each element added to the data stream is an integer. - The integer values for `num` will range from `-10^5` to `10^5`. - The total number of elements `n` added to the data stream will not exceed `10^6`. # Requirements: - Ensure that each call to `add_num` and `find_median` operates efficiently. # Example: ```python # Initialize MedianFinder median_finder = MedianFinder() # Add numbers to the data stream median_finder.add_num(1) median_finder.add_num(2) median_finder.add_num(3) # Find median print(median_finder.find_median()) # Output: 2.0 # Add another number median_finder.add_num(4) # Find median print(median_finder.find_median()) # Output: 2.5 # Add more numbers median_finder.add_num(5) # Find median print(median_finder.find_median()) # Output: 3.0 ``` **Note**: You may use additional data structures or helper methods as needed to implement the class efficiently.","solution":"import heapq class MedianFinder: def __init__(self): self.max_heap = [] self.min_heap = [] def add_num(self, num: int) -> None: # Add to max_heap (we invert num to use min-heap as max-heap) heapq.heappush(self.max_heap, -num) # Enforce max_heap property by ensuring max_heap top is <= min_heap top if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Maintain size property if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) elif len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) == len(self.min_heap): return (-self.max_heap[0] + self.min_heap[0]) / 2.0 else: return float(-self.max_heap[0])"},{"question":"Assume you have a list of unique integers representing the weights of items you wish to put in a knapsack. You need to develop a function `max_subset_sum` that calculates the maximum sum of weights that is less than or equal to a given `max_capacity`. Your function should explore all subsets of the list of weights and determine the one with the largest sum that does not exceed `max_capacity`. To ensure your understanding of combinatorial algorithms and efficiency, your function should meet the following requirements: # Function Signature ```python def max_subset_sum(weights: List[int], max_capacity: int) -> int: ``` # Input - `weights`: A list of unique integers representing the weights of the items. - `max_capacity`: An integer representing the maximum capacity of the knapsack. # Output - Returns an integer representing the maximum sum of weights that is less than or equal to `max_capacity`. # Constraints - The list `weights` contains unique integers and its length can be up to 20. - Each weight is a positive integer. - The value of `max_capacity` is a positive integer. # Example ```python weights = [1, 3, 4, 5, 9] max_capacity = 10 print(max_subset_sum(weights, max_capacity)) ``` Expected output would be `10`, which is the sum of the subset `[1, 4, 5]`. **Note**: Ensure proper handling of edge cases such as an empty list of weights or a `max_capacity` that is smaller than the smallest item weight. Additionally, optimize your code for performance while maintaining accuracy.","solution":"from itertools import combinations from typing import List def max_subset_sum(weights: List[int], max_capacity: int) -> int: Determines the maximum sum of weights that is less than or equal to max_capacity. max_sum = 0 n = len(weights) # Generate all subsets and calculate their sums for r in range(n + 1): for subset in combinations(weights, r): current_sum = sum(subset) if current_sum <= max_capacity: max_sum = max(max_sum, current_sum) return max_sum # Example usage weights = [1, 3, 4, 5, 9] max_capacity = 10 print(max_subset_sum(weights, max_capacity)) # Output should be 10"},{"question":"# Coding Assessment Question Context: An anagram is a word formed by rearranging the letters of another, such as `cinema`, formed from `iceman`. Your task is to detect the number of unique anagram groups in a given list of strings. Two strings belong to the same anagram group if and only if they contain the exact same characters with the same frequency. Task: Write a function `count_anagram_groups(words: List[str]) -> int` that determines the number of unique anagram groups from the provided list of words. The function should implement the following steps: 1. Normalize each word by sorting its characters. 2. Use a data structure to track distinct anagram groups. 3. Count and return the number of unique anagram groups. Input: * `words` (1 <= len(words) <= 1000, 1 <= len(words[i]) <= 100): A list of strings. Output: * Integer representing the number of unique anagram groups. Constraints: * The words contain only lowercase English letters (\'a\' - \'z\'). * You may assume the list of words is not empty. Performance Requirements: * The algorithm should efficiently handle the upper limit cases (e.g., maximum word lengths and word count). * Optimize space usage where possible. Example: ```python assert count_anagram_groups([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"goolge\\", \\"cat\\", \\"tac\\", \\"act\\"]) == 3 assert count_anagram_groups([\\"apple\\", \\"papel\\", \\"leapp\\", \\"dog\\", \\"god\\", \\"odg\\"]) == 2 assert count_anagram_groups([\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\", \\"pqr\\", \\"stu\\", \\"vwx\\", \\"yz\\"]) == 9 ``` Good luck! Ensure you handle edge cases and optimize your solution for a large number of words.","solution":"from typing import List def count_anagram_groups(words: List[str]) -> int: Takes a list of words and returns the number of unique anagram groups. # Create a set to store unique anagram signatures unique_anagrams = set() # Normalize each word by sorting its characters and add to the set for word in words: sorted_word = \'\'.join(sorted(word)) unique_anagrams.add(sorted_word) return len(unique_anagrams)"},{"question":"# Question: You are provided with an implementation of the Segment Tree data structure, which allows for efficient range queries and updates on an array. Your task is to extend this data structure by adding a new method to compute the second minimum value in a specified subarray range. **Function Signature**: ```python def second_min_query(node: Node | None, left: int, right: int) -> int: Returns the second minimum value of the numbers in the range [left, right] of the array represented by the Segment Tree. Parameters: - node: The root node of the Segment Tree. - left: Starting index of the range (inclusive). - right: Ending index of the range (inclusive). Returns: - The second minimum value of the numbers in the specified range. - If the range has fewer than two distinct numbers, return -1. ``` # Input: * `node:` The Segment Tree root node built from the given array. * `left (int):` The starting index of the range (0-indexed). * `right (int):` The ending index of the range (0-indexed). # Output: * Return the second minimum value of the numbers in the range `[left, right]` of the array. If the range has fewer than two distinct numbers, return `-1`. # Constraints: * The array contains integers, and its size will not exceed 100,000 elements. * Ensure the function correctly handles arrays with multiple identical elements as well as the edge cases. * The function should be performant and capable of handling the constraints within acceptable time limits. # Example: ```python >>> root = build_segment_tree([7, 3, 1, 5, 9, 0, 2, 4, 6, 8]) >>> second_min_query(root, 0, 5) 1 >>> second_min_query(root, 3, 8) 3 >>> second_min_query(root, 0, 1) 7 >>> second_min_query(root, 4, 4) -1 ``` **Notes**: * The second minimum is defined as the second smallest distinct value in an ordered list. If no such value exists in the range, return `-1`.","solution":"class Node: def __init__(self, start, end, min_val, second_min_val): self.start = start self.end = end self.min_val = min_val self.second_min_val = second_min_val self.left = None self.right = None def build_segment_tree(arr): def build(start, end): if start == end: return Node(start, end, arr[start], float(\'inf\')) mid = (start + end) // 2 left_child = build(start, mid) right_child = build(mid + 1, end) min_val = min(left_child.min_val, right_child.min_val) second_min_candidates = [] for node in [left_child, right_child]: if node.min_val > min_val: second_min_candidates.append(node.min_val) if node.second_min_val != float(\'inf\'): second_min_candidates.append(node.second_min_val) second_min_val = min(second_min_candidates) if second_min_candidates else float(\'inf\') root = Node(start, end, min_val, second_min_val) root.left = left_child root.right = right_child return root return build(0, len(arr) - 1) def second_min_query(node, left, right): if node.start > right or node.end < left: return float(\'inf\'), float(\'inf\') if left <= node.start and node.end <= right: return node.min_val, node.second_min_val left_min, left_second_min = second_min_query(node.left, left, right) right_min, right_second_min = second_min_query(node.right, left, right) min_val = min(left_min, right_min) second_min_candidates = set() for val in [left_min, left_second_min, right_min, right_second_min]: if val > min_val: second_min_candidates.add(val) second_min_val = min(second_min_candidates) if second_min_candidates else float(\'inf\') return min_val, second_min_val def second_min(node, left, right): min_val, second_min_val = second_min_query(node, left, right) return second_min_val if second_min_val != float(\'inf\') else -1"},{"question":"# Longest Consecutive Sequence of Unique Characters Problem Statement You are given a string containing a mix of alphabetic characters. Your task is to write a function that finds the longest substring which contains all unique characters. Write a function `longest_unique_substring_length(s: str) -> int` that takes a string as input and returns the length of the longest substring with all unique characters. Input Format * A single non-null string `s`. Output Format * An integer representing the length of the longest substring with all unique characters. Example Input: ```python s = \\"abcabcbb\\" ``` Output: ```python 3 ``` Explanation: The answer is `\\"abc\\"`, with the length of 3. Additional Example Scenarios Input: ```python s = \\"bbbbb\\" ``` Output: ```python 1 ``` Explanation: The answer is `\\"b\\"`, with the length of 1. Input: ```python s = \\"pwwkew\\" ``` Output: ```python 3 ``` Explanation: The answer is `\\"wke\\"`, with the length of 3. Input: ```python s = \\"\\" ``` Output: ```python 0 ``` Explanation: An empty string has a length of 0. Constraints * The input string can contain both uppercase and lowercase letters, and its length can range from 0 to 10^5. Requirements * Implement the function `longest_unique_substring_length` with the following signature: ```python def longest_unique_substring_length(s: str) -> int: ``` Performance * The implementation should run with a time complexity of O(n), where n is the length of the input string.","solution":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index = {} max_length = 0 start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"Question: Evaluate Expression Tree In computer science, an expression tree is a binary tree used to represent expressions. Each internal node of the tree represents an operator, and each leaf node represents an operand (number). Your task is to write a class `ExpressionTree` that can construct an expression tree from a postfix expression and evaluate the tree to get the result of the expression. # Details: 1. **Postfix Expression**: An expression in which the operator follows its operands. For example, the postfix expression `3 4 +` represents the expression `(3 + 4)`. * Operands are integer values. * Operators are `+`, `-`, `*`, and `/`. 2. **Expression Tree Construction**: * Each operand and operator in the postfix expression corresponds to a node in the tree. * Construct the tree such that the root of the tree is the operator with its operands as child nodes, recursively applying this rule to subexpressions. 3. **Tree Evaluation**: * Evaluate the expression tree by performing the operations represented by the nodes. * Nodes containing operators will combine the values of their children according to the operator. # Class Definition: Implement a class `ExpressionTree` with the following methods: - **`__init__(self, postfix_expr: str) -> None`**: Initializes the expression tree from a postfix expression string. - **`evaluate(self) -> float`**: Evaluates the expression tree and returns the result. # Constraints: - The operators are limited to `+`, `-`, `*`, and `/`. - Postfix expressions will be valid and always result in an integer or float output. # Example: ```python tree = ExpressionTree(\\"3 4 + 2 * 7 /\\") assert tree.evaluate() == 2.0 tree = ExpressionTree(\\"5 1 2 + 4 * + 3 -\\") assert tree.evaluate() == 14 tree = ExpressionTree(\\"2 3 * 5 4 * +\\") assert tree.evaluate() == 26 ``` # Task: Implement the `ExpressionTree` class as described. Ensure your solution passes the above example check scenarios.","solution":"class ExpressionTree: class Node: def __init__(self, value): self.value = value self.left = None self.right = None def __init__(self, postfix_expr: str) -> None: self.root = self.construct_tree(postfix_expr.split()) def construct_tree(self, postfix_expr: list): stack = [] for token in postfix_expr: if token in \\"+-*/\\": node = self.Node(token) node.right = stack.pop() node.left = stack.pop() else: node = self.Node(int(token)) stack.append(node) return stack.pop() def evaluate(self) -> float: return self.evaluate_node(self.root) def evaluate_node(self, node): if isinstance(node.value, int): return node.value left_val = self.evaluate_node(node.left) right_val = self.evaluate_node(node.right) if node.value == \'+\': return left_val + right_val elif node.value == \'-\': return left_val - right_val elif node.value == \'*\': return left_val * right_val elif node.value == \'/\': return left_val / right_val"},{"question":"# Coding Assessment Question: Scenario: As a software developer for a weather forecasting application, you need to process temperature readings efficiently. One essential task is to identify if a given list of daily temperatures contains any immediate temperature inversions, where an inversion is defined as a day with a temperature lower than the previous day. Task: Write a function `has_temperature_inversion(temperatures: List[int]) -> bool` that takes in a list of integers representing daily temperatures and returns `True` if there is at least one inversion in the list, and `False` otherwise. Input: - A list of integers, `temperatures`, where each integer represents the temperature of a day. The list can contain zero or more elements. Output: - A boolean `True` if there is at least one temperature inversion, `False` otherwise. Constraints: - The function should handle lists containing different lengths efficiently. - Focus on performance, particularly ensuring an O(n) time complexity. Examples: ```python has_temperature_inversion([70, 72, 68, 69, 75]) # Returns: True (inversion between 72 and 68) has_temperature_inversion([60, 65, 70, 75, 80]) # Returns: False (no inversions) has_temperature_inversion([30, 25, 20, 15, 10]) # Returns: True (multiple inversions, e.g., 30 to 25) has_temperature_inversion([]) # Returns: False (empty list) has_temperature_inversion([50]) # Returns: False (single element) ``` Any deviation from the above requirements will not be considered.","solution":"def has_temperature_inversion(temperatures): Determines if there\'s any temperature inversion in the list (a day\'s temperature being lower than the previous day\'s temperature). :param temperatures: List[int] - List of daily temperatures :return: boolean - True if there is at least one inversion, False otherwise for i in range(1, len(temperatures)): if temperatures[i] < temperatures[i - 1]: return True return False"},{"question":"# Submatrix Sum Calculation **Objective**: Write a function to calculate the sum of all elements within a given submatrix of a 2D matrix. The function should handle edge cases and validate inputs correctly. Problem Statement: You are provided with a 2D matrix of integers and a set of coordinates representing the top-left and bottom-right corners of a submatrix. Your task is to compute the sum of all elements in the specified submatrix. If the provided coordinates are invalid (e.g., out of bounds or top-left corner is not above and to the left of the bottom-right corner), your function should raise a `ValueError`. Function Signature ```python def submatrix_sum(matrix: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int]) -> int: Calculate the sum of elements in a submatrix. Parameters ---------- matrix : list of lists of int The original 2D matrix of integers. top_left : tuple of int A tuple representing the (row, col) coordinates of the top-left corner of the submatrix. bottom_right : tuple of int A tuple representing the (row, col) coordinates of the bottom-right corner of the submatrix. Returns ------- int The sum of all elements within the specified submatrix. Raises ------ ValueError If the coordinates are out of bounds or invalid. ``` Input: * `matrix`: A list of lists of integers representing the 2D matrix. * `top_left`: A tuple `(row, col)` indicating the top-left corner of the submatrix. * `bottom_right`: A tuple `(row, col)` indicating the bottom-right corner of the submatrix. Output: * An integer representing the sum of elements within the specified submatrix. Constraints: * Values in the matrix can be negative. * Coordinates are zero-based and within the bounds of the matrix. Edge Cases: * If any coordinate is out of bounds, raise a `ValueError` with the message \\"Coordinates out of bounds\\". * If the top-left coordinate is not above and to the left of the bottom-right coordinate, raise a `ValueError` with the message \\"Invalid submatrix coordinates\\". Example: ```python >>> submatrix_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (1, 1)) 12 >>> submatrix_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (1, 1), (2, 2)) 28 >>> submatrix_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], (0, 0), (2, 2)) 45 >>> submatrix_sum([[1, 2], [3, 4]], (1, 0), (5, 5)) Traceback (most recent call last): ... ValueError: Coordinates out of bounds >>> submatrix_sum([[1, 2], [3, 4]], (2, 2), (1, 1)) Traceback (most recent call last): ... ValueError: Invalid submatrix coordinates ``` Additional Information: Ensure that your function is optimized to handle large matrices efficiently and includes input validation to handle common edge cases such as invalid coordinates or non-rectangular submatrices.","solution":"def submatrix_sum(matrix, top_left, bottom_right): Calculate the sum of elements in a submatrix. Parameters ---------- matrix : list of lists of int The original 2D matrix of integers. top_left : tuple of int A tuple representing the (row, col) coordinates of the top-left corner of the submatrix. bottom_right : tuple of int A tuple representing the (row, col) coordinates of the bottom-right corner of the submatrix. Returns ------- int The sum of all elements within the specified submatrix. Raises ------ ValueError If the coordinates are out of bounds or invalid. rows = len(matrix) if not rows: raise ValueError(\\"Matrix is empty\\") cols = len(matrix[0]) # Validate coordinates top_left_row, top_left_col = top_left bottom_right_row, bottom_right_col = bottom_right if (top_left_row < 0 or top_left_row >= rows or top_left_col < 0 or top_left_col >= cols or bottom_right_row < 0 or bottom_right_row >= rows or bottom_right_col < 0 or bottom_right_col >= cols): raise ValueError(\\"Coordinates out of bounds\\") if (top_left_row > bottom_right_row or top_left_col > bottom_right_col): raise ValueError(\\"Invalid submatrix coordinates\\") submatrix_sum = 0 for i in range(top_left_row, bottom_right_row + 1): for j in range(top_left_col, bottom_right_col + 1): submatrix_sum += matrix[i][j] return submatrix_sum"},{"question":"# Multi-threaded Summation Multi-threading is a common technique to optimize performance by allowing concurrent execution of code. Each thread can run a part of the function simultaneously, making efficient use of multi-core processors. **Your task** is to implement multi-threaded functions in Python to compute the sum of the first `n` natural numbers. You should write three functions: `sum_range`, `worker`, and `multi_threaded_sum`. 1. `sum_range(start: int, end: int) -> int`: - This helper function takes a starting integer `start` and an ending integer `end`, and returns the sum of the numbers in this range (start inclusive and end exclusive). 2. `worker(start: int, end: int, result: list, index: int)`: - This helper function is designed to be run by a thread. It computes the sum of a subrange and writes the result to the `result` list at the specified `index`. 3. `multi_threaded_sum(n: int, num_threads: int) -> int`: - This function divides the range `[1, n]` among `num_threads` threads to compute the sum of the first `n` natural numbers efficiently. Requirements: 1. **sum_range(start: int, end: int) -> int** - Compute the sum of the integers in the range `[start, end)`. 2. **worker(start: int, end: int, result: list, index: int)** - Compute the sum for a subrange and store it in the `result` list at the given `index`. 3. **multi_threaded_sum(n: int, num_threads: int) -> int** - Divide the work among the specified number of threads and use them to compute and return the sum of the first `n` natural numbers. Function Definitions and Arguments: - `sum_range(start: int, end: int) -> int`: - `start`: Starting integer of the range (inclusive). - `end`: Ending integer of the range (exclusive). - `worker(start: int, end: int, result: list, index: int)`: - `start`: Starting integer of the subrange (inclusive). - `end`: Ending integer of the subrange (exclusive). - `result`: A list that stores the partial results computed by each thread. - `index`: Index in the `result` list where the sum of this subrange should be stored. - `multi_threaded_sum(n: int, num_threads: int) -> int`: - `n`: The number up to which the sum is to be computed. - `num_threads`: The number of threads to be used for computation. Examples: ```python # Example 1 assert sum_range(1, 101) == 5050 assert multi_threaded_sum(100, 4) == 5050 # Example 2 assert sum_range(1, 11) == 55 assert multi_threaded_sum(10, 2) == 55 ``` **Notes**: - Ensure proper synchronization when accessing shared data structures such as the `result` list. - Consider edge cases such as `n` being very small or equal to 1, and `num_threads` being larger than `n`. - For efficiency, ensure that the range each thread processes is balanced.","solution":"from threading import Thread def sum_range(start: int, end: int) -> int: Compute the sum of the integers in the range [start, end). return sum(range(start, end)) def worker(start: int, end: int, result: list, index: int): Compute the sum for a subrange and store it in the `result` list at the given `index`. result[index] = sum_range(start, end) def multi_threaded_sum(n: int, num_threads: int) -> int: Divide the range [1, n] among `num_threads` threads to compute the sum of the first `n` natural numbers. # Prepare the result list to store results from each thread results = [0] * num_threads threads = [] # Determine the chunk size chunk_size = (n + num_threads - 1) // num_threads # ceiling division # Create threads for i in range(num_threads): start = i * chunk_size + 1 end = min((i + 1) * chunk_size + 1, n + 1) # Ensure we do not exceed n thread = Thread(target=worker, args=(start, end, results, i)) threads.append(thread) thread.start() # Wait for all threads to complete for thread in threads: thread.join() # Return the sum of all partial results return sum(results)"},{"question":"# Task: Implementing a Custom Linked List with Specific Operations You are required to implement a custom singly linked list that supports a specific set of operations. Your implementation should be efficient and handle edge cases gracefully. # Input: 1. **Various method calls on the custom linked list.** Each method will be detailed in the task below. # Output: - **The results of the method calls.** The format of the output will depend on the operations performed, as specified below. # Requirements: Implement the following methods for the custom singly linked list: - **`__init__(self)`:** Initializes an empty linked list. - **`add_at_head(self, value: int) -> None`:** Adds a node with the given value at the head of the list. - **`add_at_tail(self, value: int) -> None`:** Adds a node with the given value at the tail of the list. - **`delete_value(self, value: int) -> bool`:** Deletes the first node with the given value in the list. Returns `True` if a node was deleted, and `False` otherwise. - **`find_middle(self) -> int`:** Returns the value of the middle node in the linked list. If the list is empty, return `-1`. If there are two middle nodes, return the second one. # Constraints: - Values inserted into the list will be integers within the range `-10^6` to `10^6`. - The number of operations will be at most `10^6`. # Example: ```python # Example Usage: linked_list = CustomLinkedList() linked_list.add_at_head(5) linked_list.add_at_head(3) linked_list.add_at_tail(9) assert linked_list.find_middle() == 5 assert linked_list.delete_value(3) is True assert linked_list.find_middle() == 5 assert linked_list.delete_value(7) is False linked_list.add_at_head(3) assert linked_list.find_middle() == 5 ``` # Additional Notes: - Ensure that your implementation of `find_middle` runs in O(n) time complexity, where n is the number of nodes in the list. - Edge cases such as empty list and list with only one element should be handled appropriately. - Efficiently manage memory and handle large numbers of operations within reasonable limits. # Example: ```python # Additional Example: linked_list = CustomLinkedList() linked_list.add_at_head(4) linked_list.add_at_tail(6) assert linked_list.find_middle() == 6 assert linked_list.delete_value(4) is True assert linked_list.find_middle() == 6 ```","solution":"class CustomLinkedList: class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def __init__(self): self.head = None self.size = 0 def add_at_head(self, value: int) -> None: new_node = self.Node(value, self.head) self.head = new_node self.size += 1 def add_at_tail(self, value: int) -> None: new_node = self.Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node self.size += 1 def delete_value(self, value: int) -> bool: current = self.head previous = None while current: if current.value == value: if previous: previous.next = current.next else: self.head = current.next self.size -= 1 return True previous = current current = current.next return False def find_middle(self) -> int: if not self.head: return -1 slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.value"},{"question":"# Hexagonal Tile Generator Your task is to design a Python function that generates a pattern of hexagonal tiles. The pattern should grow recursively based on the specified depth, where each hexagon also contains smaller hexagonal patterns. The goal is to optimize the tiling process through memoization to avoid redundant computations. # Objective Create a function `generate_hexagonal_tiling` that generates the hexagonal tiling pattern efficiently by caching previously computed tiles. # Input and Output * **Inputs**: * `cx: float` - the x-coordinate of the center of the hexagon. * `cy: float` - the y-coordinate of the center of the hexagon. * `size: float` - the side length of the hexagon. * `depth: int` - the depth of the recursion. * `color: str` - the color used for drawing the hexagon (optional, default is \\"green\\"). * **Output**: * Draw the hexagonal tiling pattern on the screen using the optimized approach. # Constraints * `0 <= depth <= 4` * `size > 0` # Guidelines 1. Implement memoization to avoid redundant calculations. 2. Handle edge cases properly, such as depth = 0. # Function Signature ```python def generate_hexagonal_tiling(cx: float, cy: float, size: float, depth: int, color: str = \\"green\\"): # Your code here ``` # Example ```python import turtle def generate_hexagonal_tiling(cx: float, cy: float, size: float, depth: int, color: str = \\"green\\"): # Implementation with memoization here pass def draw_hexagon(cx, cy, size, color): turtle.penup() turtle.goto(cx + size, cy) turtle.pendown() turtle.color(color) for _ in range(6): turtle.forward(size) turtle.left(60) turtle.penup() def main(): turtle.speed(0) generate_hexagonal_tiling(0, 0, 100, 3, \\"green\\") turtle.done() if __name__ == \\"__main__\\": main() ``` # Scenario Imagine you are tasked with creating a visually appealing tile pattern for a floor mosaic in a digital design tool. Optimizing the tiling process through memoization minimizes redundant calculations, making it more efficient to render complex patterns at higher depths. By implementing the optimization, the tiling process can showcase the efficiency advantages of using memoization within recursive algorithms. Describe the impact of optimization on the rendering performance.","solution":"from typing import Tuple, Dict import math def generate_hexagonal_tiling(cx: float, cy: float, size: float, depth: int, color: str = \\"green\\"): memo = {} def draw_hexagon(cx, cy, size, color): # This is a placeholder for actual drawing function # In a graphical implementation, put drawing code here if (cx, cy, size, color) not in memo: memo[(cx, cy, size, color)] = 1 print(f\\"Drawing hexagon at ({cx}, {cy}) with size {size} and color {color}\\") def hexagon_tiling(cx: float, cy: float, size: float, depth: int, color: str): if depth == 0: draw_hexagon(cx, cy, size, color) return if (cx, cy, size, depth, color) in memo: return memo[(cx, cy, size, depth, color)] draw_hexagon(cx, cy, size, color) new_size = size / 2 height = math.sqrt(3) * new_size positions = [ (cx, cy - 2 * height), (cx, cy + 2 * height), (cx - 1.5 * new_size, cy - height), (cx - 1.5 * new_size, cy + height), (cx + 1.5 * new_size, cy - height), (cx + 1.5 * new_size, cy + height), ] for pos in positions: hexagon_tiling(*pos, new_size, depth - 1, color) memo[(cx, cy, size, depth, color)] = True hexagon_tiling(cx, cy, size, depth, color)"},{"question":"# Coding Assessment Question Scenario In many text formatting tasks, it is important to ensure that sentences are properly capitalized. This involves transitioning the first letter of each sentence to uppercase and the rest of the characters to lowercase. You are given the task to implement such a function which manually processes the string to achieve the desired formatting. Problem Statement Write a function `capitalize_sentences(text: str) -> str` that takes a string `text` and returns a new string where the first letter of each sentence is converted to uppercase and all other characters in the sentence are converted to lowercase. Sentences are defined as segments of text ending with a period (`.`), exclamation mark (`!`), or question mark (`?`). Assume that these punctuation marks are followed by a space and the beginning of the next sentence. Input and Output - **Input**: A single string `text` containing ASCII characters and sentences ending with `.` or `!` or `?` followed by a space. (0 ≤ len(text) ≤ 1000) - **Output**: A new string with the first letter of each sentence capitalized and the rest of the sentence in lowercase. Constraints - You are not allowed to use any direct built-in string methods like `str.capitalize()` or `str.title()`. - Sentences always end with `.`, `!`, or `?` followed by a space, except the last sentence which may or may not be followed by a space. - You must handle edge cases such as an empty string and strings with only punctuation marks. Example ```python >>> capitalize_sentences(\\"hello world. this is a test. another Sentence! and one more?\\") \'Hello world. This is a test. Another sentence! And one more?\' >>> capitalize_sentences(\\"SECURITY is important! ACTIVELY WORK on it.\\") \'Security is important! Actively work on it.\' >>> capitalize_sentences(\\"\\") \'\' >>> capitalize_sentences(\\"python is great. let\'s code more.\\") \'Python is great. Let\'s code more.\' ``` Provide the implementation for the `capitalize_sentences` function. Ensure your code passes the given examples and consider any edge cases.","solution":"def capitalize_sentences(text: str) -> str: Capitalizes the first letter of each sentence in the given text, and converts the rest of the characters in the sentence to lowercase. Sentences are defined as segments ending with \'.\', \'!\', or \'?\' followed by a space. if not text: return text result = [] start_new_sentence = True for char in text: if start_new_sentence and char.isalpha(): result.append(char.upper()) start_new_sentence = False else: result.append(char.lower()) if char in \'.!?\': start_new_sentence = True return \\"\\".join(result)"},{"question":"# Problem: Text Editor Undo-Redo System **Context**: You are tasked with implementing a lightweight text editor that supports basic operations such as typing, undoing, and redoing. This editor should maintain a history of operations to efficiently manage the states for Undo and Redo functionalities. Your task is to create a text editor system that can handle the following operations: 1. **Type**: Add a string of characters to the current position. 2. **Undo**: Revert the most recent operation. 3. **Redo**: Reapply an undone operation, if available. # Task: Implement the class `SimpleTextEditor` with the following methods: 1. **__init__()**: Initialize the text editor with an empty string and appropriate data structures for managing history. 2. **type(text: str) -> None**: - Append the given `text` to the current content. - Record this operation in the history for potential undo. 3. **undo() -> None**: - Revert the last operation, if possible. - Record this reverted operation for potential redo. 4. **redo() -> None**: - Reapply the last undone operation, if possible. 5. **get_content() -> str**: - Return the current content of the text editor. # Constraints: - The `text` length (in the `type` operation) will not exceed 1000 characters. - Assume no more than 10^5 operations will be made. # Example: ```python editor = SimpleTextEditor() editor.type(\\"hello\\") assert editor.get_content() == \\"hello\\" editor.type(\\" world\\") assert editor.get_content() == \\"hello world\\" editor.undo() assert editor.get_content() == \\"hello\\" editor.redo() assert editor.get_content() == \\"hello world\\" editor.undo() editor.undo() assert editor.get_content() == \\"\\" editor.redo() assert editor.get_content() == \\"hello\\" ``` *Implement `SimpleTextEditor` below:* ```python class SimpleTextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.future = [] def type(self, text): self.history.append(self.content) self.content += text self.future = [] # clear the future upon new operation def undo(self): if self.history: self.future.append(self.content) self.content = self.history.pop() def redo(self): if self.future: self.history.append(self.content) self.content = self.future.pop() def get_content(self): return self.content # Example usage, such implementations must be tested thoroughly. ```","solution":"class SimpleTextEditor: def __init__(self): self.content = \\"\\" self.history = [] self.future = [] def type(self, text): self.history.append(self.content) self.content += text self.future = [] # clear the future upon new operation def undo(self): if self.history: self.future.append(self.content) self.content = self.history.pop() def redo(self): if self.future: self.history.append(self.content) self.content = self.future.pop() def get_content(self): return self.content"},{"question":"# Subarray Sum Challenge Given an array of integers, your task is to determine if there exists a contiguous subarray that sums to a specified number `k`. Implement an efficient algorithm using a hash map to achieve linear time complexity. Function Signature ```python def subarray_sum(arr: List[int], k: int) -> bool: # Your code here ``` Input - A list of integers `arr` (-10^4 ≤ arr[i] ≤ 10^4, 0 ≤ len(arr) ≤ 10^5). - An integer `k` (-10^9 ≤ k ≤ 10^9). Output - Return `True` if there exists a contiguous subarray of `arr` that sums to `k`; otherwise, return `False`. Constraints - The algorithm should have a time complexity of O(n). - Use a hash map to store the cumulative sum up to each index and check for the required sum to optimize the search. Example ```python assert subarray_sum([1, 2, 3], 5) == True assert subarray_sum([1, 2, 3], 7) == False assert subarray_sum([1, -1, 5, -2, 3], 3) == True assert subarray_sum([-2, -1, 2, 1], 1) == True ``` Create a program that reads a comma-separated list of integers and a target sum `k` from the user, computes whether a contiguous subarray sums to `k` using your `subarray_sum` function, and prints \\"True\\" or \\"False\\" accordingly. - **Input Format**: - A single input string for the array, e.g., \\"1,2,3\\" and an integer `k` on the next line. - **Output Format**: - \\"True\\" if such a subarray exists, otherwise \\"False\\".","solution":"from typing import List def subarray_sum(arr: List[int], k: int) -> bool: Determines if there exists a contiguous subarray that sums to k. Uses a hash map to store the cumulative sum up to each index. cum_sum = 0 cum_sum_map = {0: 1} # initializing with 0:1 to handle case where cum_sum-k == 0 for num in arr: cum_sum += num if cum_sum - k in cum_sum_map: return True if cum_sum in cum_sum_map: cum_sum_map[cum_sum] += 1 else: cum_sum_map[cum_sum] = 1 return False"},{"question":"# Implement a Binary Search Tree and Perform Operations Objective Your task is to implement a basic Binary Search Tree (BST) class with essential operations such as insert, search, and inorder traversal. Problem Statement Design a class `BinarySearchTree` with methods to insert new values, search for values, and perform an inorder traversal of the tree. The tree should maintain the properties of a BST. Class Signature ```python class BinarySearchTree: def __init__(self): Initialize an empty BST. def insert(self, value: int) -> None: Insert a new integer value into the BST. :param value: int, the value to be inserted. def search(self, value: int) -> bool: Search for a specific integer value in the BST. :param value: int, the value to search for. :return: bool, True if the value is found, False otherwise. def inorder(self) -> list: Perform an inorder traversal of the BST. :return: list, elements in inorder. ``` Constraints - Inserted values will be unique integers. - The values to be inserted can be in the range of -10^9 to 10^9. - For simplicity, you may assume that the tree will not exceed 10^6 nodes. Example Usage ```python >>> bst = BinarySearchTree() >>> bst.insert(5) >>> bst.insert(2) >>> bst.insert(8) >>> bst.search(5) True >>> bst.search(10) False >>> bst.inorder() [2, 5, 8] ``` Edge Cases to Consider - Inserting into an initially empty tree. - Searching for values that do not exist in the BST. - Handling large ranges and negative values. - Performing inorder traversal on an empty tree should return an empty list. Testing Your solution should be designed to be testable using standard testing tools for Python, such as `doctest` or `unittest`. --- Ensure you include sufficient comments and documentation within your code to make it understandable and maintainable.","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: Insert a new integer value into the BST. :param value: int, the value to be inserted. new_node = Node(value) if self.root is None: self.root = new_node else: self._insert(self.root, new_node) def _insert(self, root: Node, new_node: Node) -> None: if new_node.value < root.value: if root.left is None: root.left = new_node else: self._insert(root.left, new_node) else: if root.right is None: root.right = new_node else: self._insert(root.right, new_node) def search(self, value: int) -> bool: Search for a specific integer value in the BST. :param value: int, the value to search for. :return: bool, True if the value is found, False otherwise. return self._search(self.root, value) def _search(self, root: Node, value: int) -> bool: if root is None: return False if root.value == value: return True elif value < root.value: return self._search(root.left, value) else: return self._search(root.right, value) def inorder(self) -> list: Perform an inorder traversal of the BST. :return: list, elements in inorder. result = [] self._inorder(self.root, result) return result def _inorder(self, root: Node, result: list) -> None: if root is not None: self._inorder(root.left, result) result.append(root.value) self._inorder(root.right, result)"},{"question":"# Manipulating String Case Write a Python function `swap_case_excluding_numbers(s: str) -> str` that: 1. Takes a string `s` as input. 2. Returns a new string where all alphabetical characters in the original string have their case swapped, while numerical digits and other characters remain unchanged. # Input - A single string `s` containing alphanumeric characters and possibly special characters. # Output - A single string with the case of all alphabetical characters swapped and numeric digits and special characters unchanged. # Example ```python >>> swap_case_excluding_numbers(\\"Hello World 123!\\") \\"hELLO wORLD 123!\\" >>> swap_case_excluding_numbers(\\"Python3.8\\") \\"pYTHON3.8\\" >>> swap_case_excluding_numbers(\\"1234567890\\") \\"1234567890\\" >>> swap_case_excluding_numbers(\\"Test_123\\") \\"tEST_123\\" ``` # Constraints - Length of the string `s` should not exceed 1000 characters.","solution":"def swap_case_excluding_numbers(s: str) -> str: Takes a string `s` as input and returns a new string where all alphabetical characters have their case swapped, while numerical digits and other characters remain unchanged. return \'\'.join( char.swapcase() if char.isalpha() else char for char in s)"},{"question":"# Scenario: You are part of a team that is developing a ridesharing application. Your task is to implement a function that calculates the fare for a ride based on a distance-based fare policy. The policy specifies a base fare and a rate per kilometer. # Task: Implement a function `calculate_fare` that performs the following: 1. Calculate the total fare for each ride based on the given base fare and the rate per kilometer. 2. Print the trip details and the calculated fare in a specified format. # Specifications: 1. `calculate_fare(rides: list[tuple[float, float]], base_fare: float, rate_per_km: float) -> None` - **Parameters**: - `rides (list[tuple[float, float]])`: A list of tuples where each tuple represents a ride with the starting location and ending location in kilometers. - `base_fare (float)`: The base fare for each ride. - `rate_per_km (float)`: The rate per kilometer. - **Returns**: None 2. The function should validate and ensure: - The `rides` list is not empty. - The base fare and rate per kilometer are non-negative. 3. **Output**: - Print trip details in a tabular format: \\"Ride\\", \\"Start (km)\\", \\"End (km)\\", \\"Distance (km)\\", \\"Fare\\". - Print the total and average fare for all rides. # Example: ```python rides = [(0, 10), (5, 15), (8, 25)] base_fare = 2.50 rate_per_km = 1.20 calculate_fare(rides, base_fare, rate_per_km) ``` **Expected Output**: ``` Ride Start (km) End (km) Distance (km) Fare 1 0 10 10 14.50 2 5 15 10 14.50 3 8 25 17 22.90 Total fare = 51.90 Average fare = 17.30 ``` # Constraints: - Assume all distances will be non-negative floats. - Focus on readability, maintainability, and efficiency of the code.","solution":"def calculate_fare(rides, base_fare, rate_per_km): if len(rides) == 0: raise ValueError(\\"The rides list should not be empty.\\") if base_fare < 0 or rate_per_km < 0: raise ValueError(\\"Base fare and rate per kilometer should be non-negative.\\") total_fare = 0.0 print(f\\"{\'Ride\':<8}{\'Start (km)\':<12}{\'End (km)\':<10}{\'Distance (km)\':<15}{\'Fare\':<10}\\") for i, (start, end) in enumerate(rides, start=1): distance = end - start fare = base_fare + distance * rate_per_km total_fare += fare print(f\\"{i:<8}{start:<12}{end:<10}{distance:<15}{fare:<10.2f}\\") average_fare = total_fare / len(rides) print(f\\"Total fare = {total_fare:.2f}\\") print(f\\"Average fare = {average_fare:.2f}\\")"},{"question":"# Longest Consecutive Path in a Binary Tree Problem Statement Your task is to implement a function that finds the length of the longest consecutive path in a binary tree. The path can be either increasing or decreasing, and must be parent-child (directly connected) nodes. Function Signature ```python def longest_consecutive_path(root: Node | None) -> int: pass ``` Input * `root`: The root node of the binary tree (`Node` object). The tree can be empty (None). Output * Returns an integer representing the length of the longest consecutive path. Constraints * The number of nodes (N) in the binary tree can be in the range [0, 10^4]. Example Consider the following binary tree: ``` 2 / 3 1 / / 4 0 2 ``` * Input: ```python root = Node(2, Node(3, Node(4)), Node(1, Node(0), Node(2))) result = longest_consecutive_path(root) ``` * Output: ```python 3 ``` Explanation * The longest consecutive path is [2, 3, 4], which has 3 nodes. Notes * Ensure that any edge cases such as empty trees, single node trees, and skewed trees are correctly handled. * Consider both increasing and decreasing consecutive paths. * The path must follow the parent-child relationship. * Aim to implement the solution with an efficient time complexity to handle large trees.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_consecutive_path(root: Node) -> int: def longest_path(node): if not node: return (0, 0, 0) # (increasing, decreasing, max_length) left_inc, left_dec, left_max = longest_path(node.left) right_inc, right_dec, right_max = longest_path(node.right) inc = dec = 1 if node.left: if node.value + 1 == node.left.value: inc = left_inc + 1 elif node.value == node.left.value + 1: dec = left_dec + 1 if node.right: if node.value + 1 == node.right.value: inc = max(inc, right_inc + 1) elif node.value == node.right.value + 1: dec = max(dec, right_dec + 1) max_length = max(left_max, right_max, inc, dec) return inc, dec, max_length _, _, max_length = longest_path(root) return max_length"},{"question":"# Number Sequence Check Background A number sequence or series is a set of numbers ordered in some fashion. Being able to detect patterns or validate whether a given sequence follows a specific rule is a fundamental skill in solving more complex algorithmic problems. One common sequence type is the arithmetic sequence, where each term after the first is the sum of the previous term and a constant difference. Task Write a function `is_arithmetic_sequence` that checks if the given list of numbers forms an arithmetic sequence. Function Signature ```python def is_arithmetic_sequence(nums: list) -> bool: Determine if the given list of numbers forms an arithmetic sequence. :param nums: List of integers. :return: True if the list forms an arithmetic sequence, False otherwise. ``` Input - `nums`: A list of integers, which may contain at least two elements. Output - Return `True` if `nums` forms an arithmetic sequence, otherwise return `False`. Constraints - The length of the list `nums` is at least 2. - The numbers can be both positive and negative. Example ```python # Example usage print(is_arithmetic_sequence([2, 4, 6, 8])) # Output: True print(is_arithmetic_sequence([3, 6, 9, 12, 17])) # Output: False print(is_arithmetic_sequence([10, 7, 4, 1, -2])) # Output: True ``` Requirements - The function should handle edge cases such as very short or very long lists. - The function should assume that the arithmetic difference is consistent between all terms of the sequence in the list.","solution":"def is_arithmetic_sequence(nums: list) -> bool: Determine if the given list of numbers forms an arithmetic sequence. :param nums: List of integers. :return: True if the list forms an arithmetic sequence, False otherwise. if len(nums) < 2: return False difference = nums[1] - nums[0] for i in range(1, len(nums)): if nums[i] - nums[i - 1] != difference: return False return True"},{"question":"# Predicting Weather Conditions with Machine Learning You are tasked with creating a simple machine learning model to predict the weather condition (e.g., sunny, rainy, cloudy) for a given day based on historical weather data. The objective is to implement the training and prediction procedures using a basic classification algorithm. Specific Requirements 1. **Input**: Historical weather data in the form of a CSV file, and a dictionary with the weather conditions for the next day. 2. **Output**: Predicted weather condition for the given input day. 3. **Constraints**: * The historical weather data CSV file will have columns for date, temperature, humidity, wind speed, and weather condition. * The input dictionary will contain keys: \'temperature\', \'humidity\', and \'wind_speed\'. * Use a simple classification algorithm such as Decision Tree or K-Nearest Neighbors. * The model should be trained on the historical data before making predictions. Performance Requirements * The model should be trained efficiently, and predictions should be made with minimal computation time. * Ensure that the model is evaluated on a separate validation set for accuracy before making real-world predictions. Scenario Your organization needs to predict the weather condition for the next day to optimize outdoor equipment setup for events. The prediction model should be trained on historical weather data and should be able to make accurate predictions based on recent weather attributes. You are tasked with implementing the following function: ```python import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score def train_weather_model(csv_file: str) -> DecisionTreeClassifier: Train a decision tree classifier on the historical weather data. Parameters: csv_file (str): Path to the CSV file containing historical weather data. Returns: DecisionTreeClassifier: Trained Decision Tree model. pass def predict_weather(model: DecisionTreeClassifier, input_data: dict) -> str: Predict the weather condition for the given input data. Parameters: model (DecisionTreeClassifier): Trained Decision Tree model. input_data (dict): Dictionary containing \'temperature\', \'humidity\', and \'wind_speed\'. Returns: str: Predicted weather condition. pass ``` **Example Usage:** ```python model = train_weather_model(\\"historical_weather_data.csv\\") next_day_weather = {\'temperature\': 25, \'humidity\': 60, \'wind_speed\': 15} predicted_condition = predict_weather(model, next_day_weather) print(predicted_condition) # Outputs: \'sunny\' or \'rainy\' or \'cloudy\' ``` Ensure your solution efficiently trains the model and accurately predicts the weather condition for the given input.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score def train_weather_model(csv_file: str) -> DecisionTreeClassifier: Train a decision tree classifier on the historical weather data. Parameters: csv_file (str): Path to the CSV file containing historical weather data. Returns: DecisionTreeClassifier: Trained Decision Tree model. # Load the dataset from the CSV file data = pd.read_csv(csv_file) # Extract features and target variable features = data[[\'temperature\', \'humidity\', \'wind_speed\']] target = data[\'weather_condition\'] # Split the data into training and validation sets X_train, X_val, y_train, y_val = train_test_split(features, target, test_size=0.2, random_state=42) # Initialize the Decision Tree Classifier model = DecisionTreeClassifier(random_state=42) # Train the model model.fit(X_train, y_train) # Validate the model y_pred = model.predict(X_val) accuracy = accuracy_score(y_val, y_pred) print(f\\"Validation Accuracy: {accuracy:.2f}\\") return model def predict_weather(model: DecisionTreeClassifier, input_data: dict) -> str: Predict the weather condition for the given input data. Parameters: model (DecisionTreeClassifier): Trained Decision Tree model. input_data (dict): Dictionary containing \'temperature\', \'humidity\', and \'wind_speed\'. Returns: str: Predicted weather condition. # Convert input data dictionary to DataFrame input_df = pd.DataFrame([input_data]) # Predict the weather condition prediction = model.predict(input_df) return prediction[0]"},{"question":"Question: Anagram Checking with Character Replacements **Context**: Two strings are considered anagrams if they contain the same characters in the same frequency, regardless of order. However, in this problem, we are allowing up to `k` character replacements to make two strings anagrams of each other. # Task: Implement a function `can_become_anagram(s1: str, s2: str, k: int) -> bool` that determines if the two input strings can be made anagrams of each other by replacing at most `k` characters in either string. # Constraints: 1. `1 <= len(s1), len(s2) <= 10^5` 2. `1 <= k <= len(s1)` 3. Both strings contain only lowercase English letters. # Input: - A string `s1` representing the first string. - A string `s2` representing the second string. - An integer `k` representing the maximum number of character replacements allowed. # Output: - A boolean value `True` if the two strings can be made anagrams by at most `k` replacements, `False` otherwise. # Example: ```python def can_become_anagram(s1: str, s2: str, k: int) -> bool: pass # Example cases print(can_become_anagram(\\"anagram\\", \\"mangaar\\", 1)) # should return True print(can_become_anagram(\\"hello\\", \\"billion\\", 2)) # should return False print(can_become_anagram(\\"aabb\\", \\"bbcc\\", 4)) # should return True ``` # Explanation: - For the first example, no replacements are needed as \\"anagram\\" and \\"mangaar\\" are already anagrams. - For the second example, even with 2 replacements, it is not possible to transform \\"hello\\" into \\"billion\\". - For the third example, all characters in both strings can be replaced (`4` replacements) to make them anagrams. # Edge Cases to Consider: - The lengths of `s1` and `s2` are equal but very large (up to 10^5). - Both `s1` and `s2` are already anagrams needing zero replacements (k can be any positive integer). - The number of replacements `k` is minimal (k = 1) or exactly equal to the length of the strings.","solution":"from collections import Counter def can_become_anagram(s1: str, s2: str, k: int) -> bool: if len(s1) != len(s2): return False # Count frequency of characters in both strings counter1 = Counter(s1) counter2 = Counter(s2) # Calculate the number of replacement needed replacements = sum((counter1 - counter2).values()) return replacements <= k"},{"question":"# Coding Assessment Question: Advanced Roman Numeral Converter You are working on software that deals with ancient Roman records, which involve interpreting and converting Roman numerals into modern integer values. While there are basic conversion utilities available, they do not handle some edge cases and complex scenarios effectively. Your task is to implement an advanced version of the Roman numeral to integer converter that addresses the following requirements: 1. The input should be a valid Roman numeral string. 2. If the input string is empty, return `0`. 3. If the input string contains any invalid or non-Roman numeral characters, return `-1`. 4. Optimize the function to process the input string efficiently, with a minimal number of passes over the data. **Function Specification** ```python def roman_to_int(roman: str) -> int: Convert the given Roman numeral string to an integer. Parameters: roman (str): The Roman numeral string to be converted. Returns: int: The integer value of the Roman numeral, or -1 if the string is invalid. ``` # Input * A string `roman` representing the Roman numeral. The string can be any length. # Output * Return the integer value of the Roman numeral. * Return `0` if the given string is empty. * Return `-1` if the given string is invalid due to containing non-Roman numeral characters or other errors. # Constraints * The function will not be provided with Roman numerals representing negative values. * The primary focus should be on correctness and efficiency in parsing the Roman numeral. # Example ```python print(roman_to_int(\\"III\\")) # 3 print(roman_to_int(\\"IX\\")) # 9 print(roman_to_int(\\"MCMXCIV\\")) # 1994 print(roman_to_int(\\"\\")) # 0 print(roman_to_int(\\"IXA\\")) # -1 ``` # Notes - The set of valid Roman numerals consists of the following characters: `I`, `V`, `X`, `L`, `C`, `D`, `M`. - Understand and implement the rules of Roman numeral representation: * Numerals are usually written largest to smallest from left to right. * The numeral for four (`IV`) is not `IIII`; similarly, ninety is `XC` rather than `LXXXX`. - Ensure your function is robust and can handle both valid and invalid inputs gracefully.","solution":"def roman_to_int(roman: str) -> int: Convert the given Roman numeral string to an integer. Parameters: roman (str): The Roman numeral string to be converted. Returns: int: The integer value of the Roman numeral, or -1 if the string is invalid. if not roman: return 0 roman_values = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } if any(char not in roman_values for char in roman): return -1 total = 0 prev_value = 0 for char in reversed(roman): current_value = roman_values[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Pascals Triangle Row Calculation Overview: You are given an integer `n` representing the row index (0-based) of Pascal\'s Triangle. Your task is to implement a function that returns the nth row of Pascal\'s Triangle. Function Signature: ```python def get_pascals_triangle_row(n: int) -> List[int]: ``` Input: - `n`: An integer representing the row index of Pascal\'s Triangle (0-based index). Output: - A list of integers representing the nth row of Pascal\'s Triangle. Constraints: - `0 <= n <= 30` Example: ```python input: 3 output: [1, 3, 3, 1] input: 0 output: [1] input: 5 output: [1, 5, 10, 10, 5, 1] ``` Requirements: 1. Create a function `get_pascals_triangle_row` that calculates the values in the nth row of Pascal\'s Triangle. 2. Pascal’s Triangle is defined such that each number is the sum of the two directly above it. 3. Optimize the function to handle cases up to `n = 30` efficiently. Scenario: A data visualization firm needs to generate specific rows of Pascal\'s Triangle to display combinations and probabilities for a new interactive graph. Your task is to ensure that the solution is both efficient and returns accurate rows quickly, considering higher values of `n` may involve large integer calculations. The firm requires precise and correct rows for dynamic data representation to their clients.","solution":"def get_pascals_triangle_row(n: int) -> list[int]: Calculate the nth row of Pascal\'s Triangle. :param n: Index of the row (0-based) :return: A list of integers representing the nth row of Pascal\'s Triangle row = [1] for k in range(1, n+1): row.append(row[k-1] * (n - k + 1) // k) return row"},{"question":"# Problem Statement You are given a list of integers that represent the denominations of coins available and a target amount. Your task is to determine the number of unique ways to make change for the target amount using the given coin denominations. Each coin denomination can be used unlimited times. Specifications * Write a function `count_ways(coins: List[int], amount: int) -> int` where `coins` is a list of integers representing the coin denominations and `amount` is the target amount for which you need to find the unique ways to make change. Input - A list of integers `coins` where all elements are positive integers. - An integer `amount` where 0 ≤ `amount` ≤ 1000. Output - Return an integer representing the number of unique ways to make change for the target amount using the given coin denominations. Constraints - You need to use dynamic programming for this solution. - Optimize for time and space complexity. Example ```python count_ways([1, 2, 5], 5) # -> 4 count_ways([2], 3) # -> 0 count_ways([10], 10) # -> 1 count_ways([1, 2, 3], 4) # -> 4 count_ways([1, 5, 10, 25], 100) # -> 242 ``` Explanation - For the first example: 5 can be made using the following ways: [1,1,1,1,1], [1,1,1,2], [1,2,2], [5]. - For the second example: 3 cannot be made using only 2s. - For the third example: 10 can be made using [10]. - For the fourth example: 4 can be made using [1,1,1,1], [1,1,2], [2,2], [1,3]. - For the fifth example: There are 242 ways to make change for 100 using the given denominations.","solution":"from typing import List def count_ways(coins: List[int], amount: int) -> int: # Array to store the number of ways to make change of each amount from 0 to amount. dp = [0] * (amount + 1) # There\'s only one way to make 0 amount: use no coins. dp[0] = 1 # Traverse through all coins and update the dp array. for coin in coins: for i in range(coin, amount + 1): dp[i] += dp[i - coin] return dp[amount]"},{"question":"# Real-Time Stock Price Monitoring App You are tasked with creating a real-time stock price monitoring application that connects to a stock price data provider and periodically fetches and displays the latest price of a given stock. The application must also handle network errors gracefully and retry fetching the prices. Function Specification: Implement the function `monitor_stock_price(stock_symbol: str, update_interval: int = 5) -> None`. This function should: 1. Connect to a simulated stock price data provider that provides the latest stock price for the given stock symbol. 2. Fetch the latest stock price for the specified stock symbol at the provided `update_interval` (in seconds) interval. 3. Handle network errors and retry fetching the stock price up to 3 times before giving up and logging an error. 4. Display the latest stock price in the console every `update_interval` seconds. 5. Ensure the application can be terminated gracefully (e.g., using signal handlers for SIGINT). Input: - `stock_symbol` (str): The symbol of the stock to monitor. - `update_interval` (int): The interval (in seconds) at which to fetch and display the latest stock price. Defaults to `5`. Constraints: - The application should handle intermittent network issues and retry fetching data up to 3 times before logging an error. - Use non-blocking operations for network interactions where possible. - Pay attention to performance and error handling. - Ensure the application can be terminated gracefully using a signal handler. Example Usage: ```python if __name__ == \\"__main__\\": monitor_stock_price(\\"AAPL\\", 10) ``` In this example, the application will start and fetch the latest price of the stock symbol `AAPL` every 10 seconds, displaying it in the console. Notes: - You can simulate the stock price data provider by creating a mock server that returns random prices. - Consider using Python\'s `asyncio` module for managing non-blocking I/O operations. - Ensure to log relevant events, such as fetch attempts, errors, and stock price updates.","solution":"import asyncio import signal import random import logging # Setup logging logging.basicConfig(level=logging.INFO) # Simulated stock price data provider async def fetch_stock_price(stock_symbol): Simulates fetching the stock price for a given symbol. Randomly raises ConnectionError to simulate network issues. if random.random() < 0.1: # Simulate a 10% chance of network error. raise ConnectionError(f\\"Failed to fetch price for {stock_symbol}\\") return round(random.uniform(100, 150), 2) async def monitor_stock_price(stock_symbol: str, update_interval: int = 5): Periodically fetches and displays the latest stock price for the given symbol. Retries up to 3 times on network error before logging an error. stop_event = asyncio.Event() def signal_handler(): stop_event.set() signal.signal(signal.SIGINT, lambda s, f: signal_handler()) while not stop_event.is_set(): for attempt in range(3): try: price = await fetch_stock_price(stock_symbol) logging.info(f\\"Latest price for {stock_symbol}: {price}\\") break except ConnectionError as e: if attempt < 2: logging.warning(f\\"Retrying ({attempt+1}/3): {e}\\") else: logging.error(f\\"Failed to fetch price after 3 attempts: {e}\\") try: await asyncio.wait_for(stop_event.wait(), timeout=update_interval) except asyncio.TimeoutError: continue if __name__ == \\"__main__\\": stock_symbol = \\"AAPL\\" update_interval = 10 asyncio.run(monitor_stock_price(stock_symbol, update_interval))"},{"question":"# Coding Assessment Question Scenario You are contributing to a data analytics module for a financial software application. One of the features requested is to automatically smooth out a financial time series by calculating the moving average. To make this versatile, you need to implement it such that it can handle various window sizes efficiently. Task Implement a function `moving_average(time_series: List[int], window_size: int) -> List[float]` following the signature: ```python from typing import List def moving_average(time_series: List[int], window_size: int) -> List[float]: pass ``` Your implementation should calculate the moving average of a given list of integers (`time_series`) over a specified window size (`window_size`). The moving average at position `i` is the average of the `window_size` elements ending at position `i` in the time series. If there are fewer than `window_size` elements prior to position `i`, exclude index `i` from the result. Constraints * The input list `time_series` can have up to `10^5` elements. * Each element in the time series will be an integer between `-10^9` and `10^9`. * The `window_size` will always be a positive integer not greater than the length of the `time_series`. Input/Output Format * **Input**: A list of integers `time_series` and an integer `window_size`. * **Output**: A list of floats representing the moving averages. Performance Requirements * Time complexity should be O(n), where n is the length of the `time_series`. * Space complexity should be O(1) (excluding the input and output lists). Examples ```python moving_average([1, 2, 3, 4, 5], 2) -> [1.5, 2.5, 3.5, 4.5] moving_average([1, 2, 3, 4, 5], 3) -> [2.0, 3.0, 4.0] moving_average([10, 20, 30, 40, 50], 1) -> [10.0, 20.0, 30.0, 40.0, 50.0] moving_average([10, 20, 30, 40, 50], 5) -> [30.0] moving_average([], 3) -> [] moving_average([100,200,300], 4) -> [] ``` Edge Cases to Consider * Empty time series list * `window_size` greater than the length of the time series (this should return an empty list) * The given series and window sizes include large numbers to ensure handling of integer overflow isn\'t required. Implementation Develop an efficient sliding window-based solution that traverses the input list and computes the moving average accordingly, adhering to the provided constraints and performance requirements.","solution":"from typing import List def moving_average(time_series: List[int], window_size: int) -> List[float]: if not time_series or window_size > len(time_series): return [] n = len(time_series) result = [] window_sum = sum(time_series[:window_size-1]) for i in range(window_size-1, n): window_sum += time_series[i] result.append(window_sum / window_size) window_sum -= time_series[i - window_size + 1] return result"},{"question":"# Problem Statement You are asked to implement a function that finds the k-th smallest element in a list of integers. The list may contain duplicate elements, and k is always a valid index (1 ≤ k ≤ len(arr)). # Function Signature ```python def kth_smallest_element(arr: List[int], k: int) -> int: This function finds the k-th smallest element in `arr`. :param arr: A list of integers. :param k: An integer representing the k-th position (1-based index). :returns: The k-th smallest element in the list. ``` # Input - `arr` (List[int]): A list of integers. The length of the list can vary from 1 to 10^5. - `k` (int): A positive integer representing the 1-based index of the smallest element to return. # Output - The function must return an integer representing the k-th smallest element in the list. # Constraints - The algorithm should run in O(n) average time complexity. # Examples ```python assert kth_smallest_element([3, 1, 2, 1, 4, 5, 3], 3) == 2 assert kth_smallest_element([5, 3, 8, 6, 2], 1) == 2 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest_element([7, 7, 7, 7], 2) == 7 assert kth_smallest_element([1], 1) == 1 ``` # Notes - The function should handle cases with duplicate elements correctly. - Ensure that the function works efficiently with large lists. - Consider edge cases such as lists with only one element or where all elements are the same.","solution":"from typing import List def kth_smallest_element(arr: List[int], k: int) -> int: This function finds the k-th smallest element in `arr`. :param arr: A list of integers. :param k: An integer representing the k-th position (1-based index). :returns: The k-th smallest element in the list. def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def select(left, right, k_smallest): if left == right: return arr[left] pivot_index = left + (right - left) // 2 pivot_index = partition(left, right, pivot_index) if k_smallest == pivot_index: return arr[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) return select(0, len(arr) - 1, k - 1)"},{"question":"# Coding Challenge: Longest Path in a Directed Acyclic Graph (DAG) Scenario: You are given a directed acyclic graph (DAG) that represents various tasks and dependencies between them. Each node represents a task, and each directed edge represents a dependency where one task must be completed before another can begin. To optimize the workflow, you need to find the longest path in the DAG, which represents the most extended sequence of tasks that have to be completed sequentially. Task: Implement a function `longest_path` that takes the number of tasks (nodes) and their dependencies (edges) as input and returns the length of the longest path in the graph. Function Signature: ```python def longest_path(n: int, edges: list[tuple[int, int]]) -> int: ``` Input: - `n` (int): The number of tasks (nodes) in the graph. - `edges` (list of tuples of int): Each tuple (u, v) represents a directed edge from task u to task v. Output: - `int`: The length of the longest path in the DAG. Constraints: - `1 <= n <= 10^4` (number of nodes) - `0 <= len(edges) <= 5 * 10^4` (number of edges) - Task IDs (nodes) are numbered from 0 to n-1. Example: ```python n = 6 edges = [(0, 1), (1, 2), (2, 3), (0, 4), (4, 5)] print(longest_path(n, edges)) # Expected Output: 3 # Explanation: The longest path is 0 -> 1 -> 2 -> 3, with a length of 3. ``` Requirements: - Use topological sorting to help identify the longest path in a DAG. - Ensure that your function runs efficiently with the provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like an empty graph (n = 0, edges = []), single node graphs, and multiple disjoint subgraphs. - The graph is given as a DAG, so no need to handle cycles. However, checking for cycles should not be necessary. - The output should be the length of the longest path, not the path itself.","solution":"def longest_path(n, edges): from collections import defaultdict, deque # Create adjacency list and in-degree (number of incoming edges) counter adj_list = defaultdict(list) in_degree = [0] * n # Build the graph for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 # Topological sort using Kahn\'s algorithm queue = deque([i for i in range(n) if in_degree[i] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Calculate the longest path using the topological order dist = [0] * n for node in topological_order: for neighbor in adj_list[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 return max(dist) if n > 0 else 0"},{"question":"# Coding Question: Validate Bracket Sequences Context: Bob is working on a compiler for a new programming language. An essential task for the compiler is to validate curly bracket sequences in the source code. Curly brackets must be properly nested and matched to ensure correct code syntax. Bob needs an efficient way to validate these sequences. Task: Write a function `is_valid_bracket_sequence(sequence: str) -> bool` that checks if a given string containing only curly brackets `{` and `}` is valid. A sequence is considered valid if every opening bracket `{` has a corresponding closing bracket `}`, and the brackets are properly nested. Input and Output Format: * **Input**: A single string `sequence`. * Constraints: * The string length will not exceed 10^6. * The string contains only `{` and `}` characters. * **Output**: A boolean value, `True` if the bracket sequence is valid, `False` otherwise. Example Cases: ```python >>> is_valid_bracket_sequence(\\"{{}}\\") True >>> is_valid_bracket_sequence(\\"{}{}\\") True >>> is_valid_bracket_sequence(\\"{{}\\") False >>> is_valid_bracket_sequence(\\"}{\\") False >>> is_valid_bracket_sequence(\\"\\") True ``` Constraints: * Ensure your function handles edge cases, including empty strings and large inputs efficiently. * The solution should run in linear time, (O(n)), where `n` is the length of the input string. Good luck, and ensure your code passes the provided example cases!","solution":"def is_valid_bracket_sequence(sequence: str) -> bool: Checks if the given string `sequence` containing only \'{\' and \'}\' is a valid bracket sequence. A sequence is valid if every opening bracket has a corresponding closing bracket and they are properly nested. Args: sequence (str): The input string containing only \'{\' and \'}\'. Returns: bool: True if the sequence is valid, False otherwise. stack = [] for char in sequence: if char == \'{\': stack.append(char) elif char == \'}\': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"# Question: Array Reversal for Zero Replacement Context: You need to transform an array such that all zeros in the array are replaced by the previous non-zero element. If a zero is found at the start of the array, it should be replaced by the last element of the array after reversing all the zeros and their replacements. Objective Implement a function `replace_zeros_with_previous` that takes a list of integers and replaces each zero by the previous non-zero integer. If a zero is at the start, consider the last element of the array (post-reversal) as the preceding non-zero element. Function Signature ```python def replace_zeros_with_previous(array: List[int]) -> List[int]: pass ``` Parameters: * `array` (List[int]): A list of integers containing zero or more elements (0 ≤ len(array) ≤ 10^5) where any integer could be zero or non-zero. Returns: * `List[int]`: A list where each zero is replaced with the previous non-zero integer in the array. Example: ```python assert replace_zeros_with_previous([0, 1, 0, 2, 3, 0, 0, 4]) == [4, 1, 1, 2, 3, 3, 3, 4] assert replace_zeros_with_previous([0, 0, 0, 0]) == [0, 0, 0, 0] assert replace_zeros_with_previous([1, 2, 0, 3, 0, 0, 4]) == [1, 2, 2, 3, 3, 3, 4] ``` Constraints: * Keep the solution efficient for large input sizes. * Use appropriate list traversal techniques. * Handle edge cases such as empty arrays and arrays consisting only of zeros or non-zero integers.","solution":"from typing import List def replace_zeros_with_previous(array: List[int]) -> List[int]: if not array: return [] n = len(array) non_zero_elements = [x for x in array if x != 0] if not non_zero_elements: # If the array only contains zeros return array previous_non_zero = non_zero_elements[-1] # The last non-zero element in the array result = [] for num in array: if num == 0: result.append(previous_non_zero) else: previous_non_zero = num result.append(num) return result"},{"question":"# Coding Assessment Question Scenario We are analyzing mathematical properties of sequences and their relationships to common number theory concepts like prime numbers and palindromes. Your task is to solve a problem that blends these concepts. Problem Statement Implement a function `is_prime_palindrome(n: int) -> bool` that determines whether a number (n) is a \\"prime palindrome\\". A \\"prime palindrome\\" is defined as: 1. A number that is a prime number. 2. A number that reads the same backward as forward. Input - An integer `n` where (1 leq n leq 10^6). Output - Returns `True` if (n) is a prime palindrome, else returns `False`. Constraints - Optimize the function to handle checks for primeness and palindromic properties efficiently up to (10^6). - Ensure the function handles all necessary edge cases (e.g., small bounds, typical scenarios). Example ```python assert is_prime_palindrome(131) == True # 131 is prime and palindromic assert is_prime_palindrome(101) == True # 101 is prime and palindromic assert is_prime_palindrome(123) == False # 123 is not palindromic assert is_prime_palindrome(10) == False # 10 is not prime ``` # Solution Implementation ```python def is_prime_palindrome(n: int) -> bool: # Function to check if a number is prime def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Function to check if a number is a palindrome def is_palindrome(num): return str(num) == str(num)[::-1] # Check both conditions return is_prime(n) and is_palindrome(n) ```","solution":"def is_prime_palindrome(n: int) -> bool: # Function to check if a number is prime def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Function to check if a number is a palindrome def is_palindrome(num): return str(num) == str(num)[::-1] # Check both conditions return is_prime(n) and is_palindrome(n)"},{"question":"# Problem Statement **Context**: Your task is to optimize the shipping routes in a logistics company that relies heavily on two-way road networks between major cities. Each road has a distinct travel cost associated with it. The company needs an efficient way to determine the minimum travel cost between two specified cities given the current road network. **Task**: Write a function `find_min_travel_cost` that computes the minimum travel cost between a starting city and a destination city in a two-way road network described by a list of roads. Each road connects two cities and has a defined travel cost. # Function Specification ```python def find_min_travel_cost(n: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Finds the minimum travel cost between the start and end cities in a road network. Args: n (int): Number of cities (nodes). roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two cities and a travel cost (city1, city2, cost). start (int): The starting city. end (int): The destination city. Returns: int: The minimum travel cost from start to end city. If no path exists, return -1. ``` **Input**: - `n` (integer): The number of cities (1 ≤ n ≤ 1000). - `roads` (list of tuples): A list containing tuples of the form (city1, city2, cost) representing two-way roads and their travel costs (0 ≤ cost ≤ 1000). - `start` (integer): The starting city (0 ≤ start < n). - `end` (integer): The destination city (0 ≤ end < n). **Output**: - Returns the minimum travel cost from the start city to the end city. If no path exists, return -1. # Constraints: - There may be multiple roads between two cities. - The cities are numbered from 0 to n-1. # Example Consider the following road network and travel costs: ```python n = 5 roads = [(0, 1, 10), (1, 2, 20), (2, 3, 10), (3, 4, 10), (0, 2, 50)] start = 0 end = 4 assert find_min_travel_cost(n, roads, start, end) == 50 # 0 -> 1 -> 2 -> 3 -> 4, Total Cost = 10 + 20 + 10 + 10 = 50 ``` # Note: Use Dijkstra\'s algorithm or any efficient shortest path finding algorithm to determine the minimum travel costs provided the constraints.","solution":"import heapq from typing import List, Tuple def find_min_travel_cost(n: int, roads: List[Tuple[int, int, int]], start: int, end: int) -> int: Finds the minimum travel cost between the start and end cities in a road network. Args: n (int): Number of cities. roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two cities and a travel cost (city1, city2, cost). start (int): The starting city. end (int): The destination city. Returns: int: The minimum travel cost from start to end city. If no path exists, return -1. # Create the adjacency list for the graph graph = [[] for _ in range(n)] for city1, city2, cost in roads: graph[city1].append((cost, city2)) graph[city2].append((cost, city1)) # Min-heap priority queue to find the shortest path min_heap = [(0, start)] # Dictionary to store the minimum cost to reach each city min_cost = {i: float(\'inf\') for i in range(n)} min_cost[start] = 0 while min_heap: current_cost, current_city = heapq.heappop(min_heap) if current_city == end: return current_cost if current_cost > min_cost[current_city]: continue for cost, neighbor in graph[current_city]: new_cost = current_cost + cost if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(min_heap, (new_cost, neighbor)) return -1"},{"question":"# Problem Statement: You work for an e-commerce platform that needs to analyze product reviews. One of the tasks is to determine whether a review consists entirely of positive words. You are given a list of positive words and a review as input. Your task is to write a function `is_positive_review(review: str, positive_words: List[str]) -> bool` that returns `True` if all words in the review are positive, and `False` otherwise. Function Signature: ```python def is_positive_review(review: str, positive_words: List[str]) -> bool: ``` Input: * A string `review` which contains words delimited by spaces. * A list of strings `positive_words` which contains all the positive words. Output: * Return `True` if every word in the review is found in the list of positive words, `False` otherwise. Constraints: * The input `review` will contain only lowercase alphabetic characters and spaces. * The list `positive_words` will contain only lowercase alphabetic strings. * Each positive word is unique in the list of positive words. * The words in the review are separated by single spaces and the review does not have leading or trailing spaces. Example: ```python assert is_positive_review(\\"excellent amazing superb\\", [\\"excellent\\", \\"amazing\\", \\"superb\\", \\"good\\", \\"great\\"]) == True assert is_positive_review(\\"excellent good bad\\", [\\"excellent\\", \\"amazing\\", \\"superb\\", \\"good\\", \\"great\\"]) == False assert is_positive_review(\\"awesome wonderful\\", [\\"awesome\\", \\"wonderful\\", \\"fantastic\\"]) == True assert is_positive_review(\\"awesome great fantastic\\", [\\"excellent\\", \\"amazing\\", \\"superb\\", \\"good\\", \\"great\\"]) == False ``` Requirements: * **Edge Cases Handling**: Ensure to handle empty reviews and an empty list of positive words. * **Performance**: Efficiently check each word in the review against the list of positive words. Additional Notes: * You may assume the input will only consist of valid reviews and lists as per the constraints. * Focus on optimal performance for checking word membership.","solution":"from typing import List def is_positive_review(review: str, positive_words: List[str]) -> bool: Returns True if every word in the review is found in the list of positive words, False otherwise. positive_word_set = set(positive_words) review_words = review.split() for word in review_words: if word not in positive_word_set: return False return True"},{"question":"Language Translation Processing You are tasked to implement a natural language processing (NLP) function that simulates a basic language translation. The function will translate words from English to a fictional language using a given dictionary. The dictionary provides a one-to-one mapping of English words to words in the fictional language. **Function Signature**: ```python def translate(sentence: str, dictionary: Dict[str, str]) -> str: pass ``` **Parameters**: - **sentence**: A string representing the sentence in English to be translated. - **dictionary**: A dictionary where keys are words in English and values are the corresponding words in the fictional language. **Returns**: - A string representing the translated sentence in the fictional language. # Example ```python sentence = \\"hello world this is a test\\" dictionary = { \\"hello\\": \\"bono\\", \\"world\\": \\"mundo\\", \\"this\\": \\"esto\\", \\"is\\": \\"es\\", \\"a\\": \\"un\\", \\"test\\": \\"prueba\\" } translated_sentence = translate(sentence, dictionary) # Expected translated_sentence is \\"bono mundo esto es un prueba\\" ``` # Constraints - The input sentence will only contain lowercase English alphabets and spaces. - All words in the sentence will exist in the provided dictionary. - The sentence will be non-empty and will not contain leading or trailing spaces, nor multiple spaces between words. # Notes: - Ensure that the words in the returned sentence are in the same order as they appear in the input sentence. - Use the provided dictionary to map each word directly; no additional processing is necessary for word forms.","solution":"def translate(sentence: str, dictionary: dict) -> str: Translates a sentence from English to a fictional language using the provided dictionary. Parameters: sentence (str): The sentence in English to be translated. dictionary (dict): A dictionary where keys are words in English and values are the corresponding words in the fictional language. Returns: str: The translated sentence in the fictional language. words = sentence.split() translated_words = [dictionary[word] for word in words] return \' \'.join(translated_words)"},{"question":"**Binary Search Tree Operations** You are given the root node of a binary search tree (BST). Implement a series of functions to perform various operations on the BST. Implement the functions as described below: Function Definitions: 1. **`bst_insert(root: TreeNode, val: int) -> TreeNode`** - **Input**: root: TreeNode, val: int - **Output**: root of the BST with the new value inserted. 2. **`bst_search(root: TreeNode, val: int) -> Optional[TreeNode]`** - **Input**: root: TreeNode, val: int - **Output**: TreeNode where the val is found, or None if val does not exist in the BST. 3. **`bst_delete(root: TreeNode, val: int) -> TreeNode`** - **Input**: root: TreeNode, val: int - **Output**: root of the BST with the value deleted. 4. **`bst_inorder_traversal(root: TreeNode) -> list[int]`** - **Input**: root: TreeNode - **Output**: list of integers representing the in-order traversal of the BST. Constraints: - The number of nodes in the binary search tree is in the range [0, 2000]. - Each node has a unique integer value. - All `val` inputs for insertion or deletion are guaranteed to fall within the range of the BST node values. Example: Given the binary search tree: ``` 8 / 3 10 / 1 6 14 / / 4 7 13 ``` 1. Insert 2: ``` 8 / 3 10 / 1 6 14 / / / 2 4 7 13 ``` 2. Search 7: Returns the node with value 7. 3. Delete 3: ``` 8 / 4 10 / 1 6 14 / / / 2 7 13` ``` 4. In-order Traversal: [1, 2, 4, 6, 7, 8, 10, 13, 14] Use the provided `TreeNode` class for tree construction: ```python from __future__ import annotations from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right ``` Implement the given functions considering edge cases and optimizing for the constraints provided.","solution":"from __future__ import annotations from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[TreeNode] = None, right: Optional[TreeNode] = None): self.val = val self.left = left self.right = right def bst_insert(root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = bst_insert(root.left, val) else: root.right = bst_insert(root.right, val) return root def bst_search(root: TreeNode, val: int) -> Optional[TreeNode]: if root is None or root.val == val: return root if val < root.val: return bst_search(root.left, val) else: return bst_search(root.right, val) def bst_delete(root: TreeNode, val: int) -> TreeNode: if root is None: return None if val < root.val: root.left = bst_delete(root.left, val) elif val > root.val: root.right = bst_delete(root.right, val) else: # Node to be deleted found if root.left is None: return root.right elif root.right is None: return root.left # Node with two children min_larger_node = get_min(root.right) root.val = min_larger_node.val root.right = bst_delete(root.right, min_larger_node.val) return root def get_min(node: TreeNode) -> TreeNode: current = node while current.left is not None: current = current.left return current def bst_inorder_traversal(root: TreeNode) -> List[int]: result = [] def inorder(node: TreeNode): if node is None: return inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result"},{"question":"# Reversible Rotated Array In this exercise, you will implement the `find_original` function which identifies the original sorted array from a rotated array, where the rotation is unknown. The function takes as input a rotated array and returns the original sorted array. Your implementation should handle various edge cases and ensure efficient performance. Function Signature ```python def find_original(rotated: list[int]) -> list[int]: ``` Input: - `rotated`: A list of integers that represents a rotated sorted array. The array is sorted in ascending order, then rotated at some pivot. Output: - A list of integers representing the original sorted array. Constraints: 1. The input list should contain at least one element and no more than 10,000 elements. 2. The original list has unique elements and the rotation is arbitrary. Performance Requirements: - The solution should run in O(n) time complexity, where n is the number of elements in the list. - It should handle cases where the rotation makes all elements appear shifted. # Example Usage: ```python # Example 1: Simple rotation rotated = [5, 6, 7, 1, 2, 3, 4] print(find_original(rotated)) # Expected output: [1, 2, 3, 4, 5, 6, 7] # Example 2: Rotation at midpoint rotated = [10, 11, 12, 3, 4, 5, 6, 7, 8, 9] print(find_original(rotated)) # Expected output: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12] # Example 3: Rotated at the last element rotated = [20, 1, 2, 3] print(find_original(rotated)) # Expected output: [1, 2, 3, 20] # Example 4: Already sorted array rotated = [1, 2, 3, 4, 5] print(find_original(rotated)) # Expected output: [1, 2, 3, 4, 5] ``` # Implementation Notes: - Your function should identify the pivot point where the rotation occurs. - Reconstruct the original sorted array by splitting and combining the segments of the rotated array. - Ensure to handle different edge cases, such as arrays with minimal rotation or no rotation.","solution":"def find_original(rotated: list[int]) -> list[int]: Identifies the original sorted array from a rotated array. if not rotated: return [] n = len(rotated) # Finding the index of the smallest element low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if rotated[mid] > rotated[high]: low = mid + 1 else: high = mid # The array is rotated around the smallest element pivot = low # Reconstruct the original sorted array return rotated[pivot:] + rotated[:pivot]"},{"question":"# File System Directory Size Calculation **Context**: You are developing a disk management tool, and one of the features it needs is the ability to calculate the total size of a directory including all its subdirectories and files. **Task**: Write a Python function named `directory_size(path: str) -> int:` that performs the following tasks: 1. Access the given directory path. 2. Recursively traverse all subdirectories and sum the sizes of all files encountered. 3. Return the total size in bytes. **Constraints**: - The function should handle large directory trees efficiently. - Consider the possibility of encountering permission errors and handle them gracefully. **Input**: - `path` (str): A string representing the absolute or relative path to the directory whose size is to be calculated. **Output**: - `int`: An integer representing the total size of the directory in bytes. **Example**: Given a directory structure: ``` /example_dir /subdir1 file1.txt (100 bytes) file2.txt (200 bytes) /subdir2 file3.txt (300 bytes) file4.txt (400 bytes) ``` For the path `/example_dir`, the function should return `1000` (100 + 200 + 300 + 400). # Instructions: 1. Use the `os` module to interact with the file system. 2. Implement the function to recursively visit each subdirectory and accumulate the sizes of the files. 3. Handle potential `OSError` exceptions that might occur due to permission issues, and skip such files/directories. 4. Ensure that the function efficiently handles deeply nested directory structures. ```python import os def directory_size(path: str) -> int: total_size = 0 for dirpath, dirnames, filenames in os.walk(path): for f in filenames: fp = os.path.join(dirpath, f) try: total_size += os.path.getsize(fp) except OSError: pass return total_size ```","solution":"import os def directory_size(path: str) -> int: Calculate the total size of a directory including all its subdirectories and files. Args: path (str): A string representing the absolute or relative path to the directory. Returns: int: The total size of the directory in bytes. total_size = 0 for dirpath, dirnames, filenames in os.walk(path): for f in filenames: fp = os.path.join(dirpath, f) try: total_size += os.path.getsize(fp) except OSError: pass # Ignore files that we cannot access return total_size"},{"question":"# Scenario Imagine you are a manager at a busy restaurant. You have a timetable that lists the start and end times of various reservations throughout the day. Your goal is to determine the maximum number of non-overlapping reservations that can be accommodated in the restaurant without any overlaps. # Function Signature ```python def max_reservations(start_times: list, end_times: list) -> int: pass ``` # Input * `start_times`: A list of integers representing the start times of the reservations (in 24-hour format). * `end_times`: A list of integers representing the end times of the reservations (in 24-hour format). # Output * `max_reservations` should return an integer, representing the maximum number of non-overlapping reservations that can be accommodated. # Constraints * The length of `start_times` and `end_times` are the same. * Each start time is less than the corresponding end time. * Times are represented as integers within the 24-hour format (0 to 23). * No reservation lasts longer than 24 hours. # Performance Requirements * Aim for a solution with a time complexity of `O(n log n)` and space complexity of `O(n)`. # Notes 1. Raise an `IndexError` if the lengths of `start_times` and `end_times` do not match. 2. Ensure proper handling of edge cases such as empty lists for start and end times. # Example ```python start_times = [1, 3, 0, 5, 8, 5] end_times = [2, 4, 6, 7, 9, 9] # Expected Output: 4 (The largest set of non-overlapping reservations is [1, 3] [3, 4], [5, 7], [8, 9]) print(max_reservations(start_times, end_times)) # Output: 4 ``` # Edge Cases 1. If `start_times` and `end_times` are both empty, the expected output is 0. 2. If there is only one reservation, the expected output is 1. 3. Handle cases where multiple reservations have the same start or end times correctly. Implement the `max_reservations` function and ensure that your solution passes the provided test cases.","solution":"def max_reservations(start_times, end_times): Returns the maximum number of non-overlapping reservations that can be accommodated. Args: start_times (list of int): List of start times of reservations. end_times (list of int): List of end times of reservations. Returns: int: The maximum number of non-overlapping reservations. Raises: IndexError: If lengths of start_times and end_times do not match. if len(start_times) != len(end_times): raise IndexError(\\"Length of start_times and end_times do not match\\") n = len(start_times) # Combine the times into a list of tuples and sort by end times reservations = list(zip(start_times, end_times)) reservations.sort(key=lambda x: x[1]) # Track the end time of the last added reservation max_non_overlapping = 0 previous_end_time = -1 for start, end in reservations: if start >= previous_end_time: max_non_overlapping += 1 previous_end_time = end return max_non_overlapping"},{"question":"# Binary Search Implementation Problem Statement: You are given a sorted array of integers and a target value. Your task is to implement the binary search algorithm to determine whether the target value exists in the array. If the target exists, return its index. Otherwise, return -1. Function Signature: ```python def binary_search(arr: List[int], target: int) -> int: ``` Input: * **arr**: A list of integers in ascending order. * **target**: An integer value that you need to search in the array. Output: * Returns the index of the **target** in the array if it exists, otherwise returns -1. Constraints: * The array **arr** will have at most (10^5) elements. * All integers in the array are distinct. * The target can be any valid integer. Example: ```python arr = [1, 2, 4, 5, 7, 9, 12, 15] target = 5 expected_output = 3 assert binary_search(arr, target) == expected_output ``` ```python arr = [1, 3, 6, 8, 11, 15, 18, 22] target = 10 expected_output = -1 assert binary_search(arr, target) == expected_output ``` Instructions: 1. **Initialize**: Set two pointers **left** and **right** to the start and end of the array, respectively. 2. **Binary Search Loop**: While **left** pointer is less than or equal to **right** pointer: * Compute the middle index **mid** as: ```python mid = left + (right - left) // 2 ``` * Compare the **target** with the middle element of the array **arr[mid]** * If **arr[mid]** equals **target**, return **mid**. * If **arr[mid]** is less than **target**, move the **left** pointer to **mid + 1**. * If **arr[mid]** is greater than **target**, move the **right** pointer to **mid - 1**. 3. **Return**: If the target is not found in the array, return -1 after the loop ends. Hints: * Remember to handle edge cases, such as an empty array or when the target is not present in the array. * Ensure that the pointers are correctly updated to avoid infinite loops. --- This additional question aligns with the existing questions by covering a fundamental algorithm (Binary Search) and is of comparable length and complexity. The problem constraints and instructions are clear and detailed, similar to the provided question.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform binary search to find the target in a sorted array. Parameters: arr (List[int]): A list of integers sorted in ascending order. target (int): The integer value to search for in the array. Returns: int: The index of the target in the array if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"**Binary Tree Maximum Path Sum** You are tasked to write a function that calculates the maximum path sum in a binary tree. The path can start and end at any node in the tree and must consist of nodes\' values. # Input Format: - A binary tree where each node contains an integer value: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int ``` # Output Format: - An integer representing the maximum path sum in the binary tree. # Constraints: - The number of nodes in the tree is in the range `[1, 3 * 10^4]`. - `-1000 <= Node.val <= 1000` # Example: ```python # Example 1: # Input: [1,2,3] # Output: 6 # Explanation: The path 2 -> 1 -> 3 results in the maximum path sum = 6. # Example 2: # Input: [-10,9,20,None,None,15,7] # Output: 42 # Explanation: The path 15 -> 20 -> 7 results in the maximum path sum = 42. ``` # Performance Requirements: - The function should efficiently handle binary trees within the given constraints. # Scenario Imagine you\'re developing a feature for a computational biology application where you need to analyze the maximum sum of gene pathways represented as binary trees. This requires calculating the highest possible sum pathway for given tree structures, which represent hierarchical gene expressions. Implement the `max_path_sum` function to meet the requirements and satisfy the above test cases. **Tip:** Use depth-first search (DFS) to explore every possible path, and ensure that you keep track of the maximum path sum encountered during the traversal. Handle edge cases gracefully and ensure optimal performance for large trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: def helper(node): nonlocal max_sum if not node: return 0 # Recursively get the maximum path sum for the left and right subtrees left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Calculate the maximum path sum \\"through\\" the current node current_sum = node.val + left_max + right_max # Update the global maximum path sum if the current path sum is greater max_sum = max(max_sum, current_sum) # Return the maximum sum of the path that can be extended to the parent return node.val + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Scenario: You are working on a text processing application that needs to analyze the sentiment of short text messages. To simplify this, you decide to start with a basic function that computes the \\"emotional score\\" of a message. Each word in the message has a pre-defined emotional score, and the overall score is the sum of scores of all individual words. Words not found in the predefined list should be ignored. # Problem Statement: Design a function that calculates the emotional score of a given message based on the provided dictionary of word scores. The function should handle invalid cases gracefully, such as an empty message or a message containing characters other than alphabets and spaces. # Function Signature: ```python def emotional_score(message: str, word_scores: Dict[str, int]) -> int: ``` # Input: * `message`: A string representing the message to be analyzed. It contains words separated by spaces. * `word_scores`: A dictionary where keys are words (strings) and values are their respective emotional scores (integers). # Output: * Returns an integer representing the total emotional score of the message based on the given dictionary. # Constraints: * 0 <= len(message) <= 10^5 * 1 <= len(word_scores) <= 10^4 * Each word in `message` contains only lowercase alphabets. # Example: ```python word_scores = { \\"happy\\": 3, \\"sad\\": -2, \\"joy\\": 5, \\"miserable\\": -3 } assert emotional_score(\\"happy joy\\", word_scores) == 8 assert emotional_score(\\"sad happy sad\\", word_scores) == -1 assert emotional_score(\\"joy miserable joy\\", word_scores) == 7 assert emotional_score(\\"\\", word_scores) == 0 assert emotional_score(\\"unknown word\\", word_scores) == 0 ``` # Additional Instructions: * If the `message` is empty, the function should return 0. * Words in the `message` that are not in the `word_scores` dictionary should be ignored. * Ensure that the function is efficient and performs well even for large inputs.","solution":"def emotional_score(message: str, word_scores: dict) -> int: Calculates the emotional score of a given message based on the provided dictionary of word scores. :param message: A string representing the message to be analyzed. :param word_scores: A dictionary where keys are words and values are their respective emotional scores. :return: Integer representing the total emotional score of the message. if not message: return 0 words = message.split() score = sum(word_scores.get(word, 0) for word in words) return score"},{"question":"# Coding Assessment Question **Objective**: Write a function to rearrange the characters in a string so that no two adjacent characters are the same. If it\'s not possible, return an empty string. **Function Signature**: ```python def rearrange_string(s: str) -> str: pass ``` # Input & Output * **Input Format**: * `s`: A string containing only lowercase English letters. * **Output Format**: * A rearranged string where no two adjacent characters are the same. If not possible, return an empty string. # Constraints * The length of the string `s` does not exceed (10^4). # Performance Requirements * Your implementation should efficiently handle strings up to 10,000 characters long. # Example 1. **Example 1**: * Input: `\\"aabb\\"` * Output: `\\"abab\\"` 2. **Example 2**: * Input: `\\"aaab\\"` * Output: `\\"\\"` 3. **Example 3**: * Input: `\\"aaabbc\\"` * Output: `\\"ababac\\"` 4. **Example 4**: * Input: `\\"abc\\"` * Output: `\\"abc\\"` # Instructions * Implement the `rearrange_string` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * You may assume that the input string `s` contains only lowercase English letters (a-z). * Do not print anything in the function; return the result directly.","solution":"import heapq from collections import Counter def rearrange_string(s: str) -> str: # Count the frequency of each character char_count = Counter(s) # Create a max heap based on the count of characters max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, \'\' while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char result = \'\'.join(result) if len(result) != len(s): return \\"\\" return result"},{"question":"# Dynamic Fibonacci Sequence **Context**: You are tasked with developing an application that requires calculating large Fibonacci numbers quickly. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, typically starting with 0 and 1. Calculating large numbers in this sequence using a naive recursive approach is inefficient due to repeated calculations. **Task**: Implement a function `dynamic_fibonacci` that calculates the `n`-th Fibonacci number using dynamic programming to optimize the process. The function should store the results of previous calculations to avoid redundant computations. **Function Signature**: ```python def dynamic_fibonacci(n: int) -> int: pass ``` **Input**: * `n`: A non-negative integer representing the position in the Fibonacci sequence. **Output**: * The `n`-th Fibonacci number (as an integer). **Constraints**: * `0 <= n <= 10^6` * The function should be efficient and handle very large inputs within a reasonable time frame. **Example**: ```python # Calculating the first few Fibonacci numbers print(dynamic_fibonacci(0)) # Should return 0 print(dynamic_fibonacci(1)) # Should return 1 print(dynamic_fibonacci(10)) # Should return 55 print(dynamic_fibonacci(50)) # Should return 12586269025 # Calculating a large Fibonacci number print(dynamic_fibonacci(100000)) # Output will be a huge number, ensure your function handles this efficiently ``` # Guidelines: 1. Utilize a bottom-up approach to fill the table of Fibonacci numbers up to `n`. 2. Consider the time and space complexity of your implementation to ensure it handles large inputs efficiently. 3. Verify your solution with both small and extremely large values of `n` to ensure its accuracy and efficiency.","solution":"def dynamic_fibonacci(n: int) -> int: Returns the n-th Fibonacci number using dynamic programming. if n == 0: return 0 elif n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"# Problem Statement You are provided with a data processing function that needs to be optimized for performance while maintaining accuracy. The function processes a large list of numerical values and applies a series of transformations to each element. # Requirements 1. Implement a function named `optimized_transform` that takes: * A list of numbers `data` (List of floats or integers). * Four optional transformation functions `transform1`, `transform2`, `transform3`, `transform4` (each a Callable that accepts and returns a float). If any of these is not provided, it should be skipped. * An optional boolean flag `inPlace` (default value = False). 2. The `optimized_transform` function should: * Apply each provided transformation function in sequence to each element in `data`. * Return a new list with the transformed values if `inPlace` is False. * Modify the original `data` list in place if `inPlace` is True. * Handle and raise errors if any transformation function is not applicable to an element in `data`. # Input Format ```python optimized_transform(data: List[Union[float, int]], transform1: Optional[Callable[[float], float]] = None, transform2: Optional[Callable[[float], float]] = None, transform3: Optional[Callable[[float], float]] = None, transform4: Optional[Callable[[float], float]] = None, inPlace: bool = False) -> Optional[List[Union[float, int]]] ``` # Output Format * Returns the new list with transformed values if `inPlace` is False. * Returns None if `inPlace` is True. # Constraints * Each transformation function, if provided, must be a callable that takes a float (or an element convertible to a float) and returns a float. * The `data` list can be large (up to 10^6 elements). * The boolean flag `inPlace` determines if the original list should be modified or if a new list should be created. # Example ```python def scale(x: float) -> float: return x * 2 def shift(x: float) -> float: return x + 3 data = [1, 2, 3, 4, 5] # Applying transformations without modifying the original list new_data = optimized_transform(data, transform1=scale, transform2=shift, inPlace=False) print(f\\"Transformed data: {new_data}\\") # Applying transformations and modifying the original list optimized_transform(data, transform1=scale, transform2=shift, inPlace=True) print(f\\"Original data after transformation: {data}\\") ``` *Expected Output*: ``` Transformed data: [5, 7, 9, 11, 13] Original data after transformation: [5, 7, 9, 11, 13] ``` # Notes * Ensure your implementation is optimized for performance and can handle large datasets efficiently. * Include appropriate error handling for cases where transformation functions are invalid or cannot be applied to elements in `data`.","solution":"from typing import List, Union, Callable, Optional def optimized_transform( data: List[Union[float, int]], transform1: Optional[Callable[[float], float]] = None, transform2: Optional[Callable[[float], float]] = None, transform3: Optional[Callable[[float], float]] = None, transform4: Optional[Callable[[float], float]] = None, inPlace: bool = False ) -> Optional[List[Union[float, int]]]: Applies up to four transformations to the list of numbers. Parameters: - data: List of numbers (floats or integers) - transform1, transform2, transform3, transform4: Optional transformation functions - inPlace: If True, modifies the original list; otherwise, returns a new list Returns: - Transformed list if `inPlace` is False; otherwise, returns None def apply_transforms(value): for transform in (transform1, transform2, transform3, transform4): if transform is not None: value = transform(value) return value if inPlace: for i in range(len(data)): data[i] = apply_transforms(float(data[i])) return None else: return [apply_transforms(float(x)) for x in data]"},{"question":"# Circular Array Rotation Context You are building a feature for a data analysis application that allows users to rotate elements in a circular array. This feature is often used to analyze data with periodic patterns, such as time-series data. Task Implement a function `circular_array_rotation` that rotates an array of integers to the right by a specified number of steps. After performing the rotation, the function should return the array in its new order. Function Signature ```python def circular_array_rotation(arr: list[int], k: int) -> list[int]: ``` Input - `arr` (list of int): A list of integers representing the array elements. - `k` (int): An integer representing the number of steps to rotate the array to the right. Output - The function should return a new list of integers which is the result of the array after the rotation. Constraints - The input array can have up to 10^5 elements. - The elements of the array are integers. - The number of rotation steps `k` is a non-negative integer. Examples 1. `circular_array_rotation([1, 2, 3, 4, 5], 2)` - Returns: `[4, 5, 1, 2, 3]`, after 2 right rotations, the array becomes `[4, 5, 1, 2, 3]`. 2. `circular_array_rotation([1, 2, 3, 4, 5], 5)` - Returns: `[1, 2, 3, 4, 5]`, after 5 right rotations, the array remains the same. 3. `circular_array_rotation([1, 2], 3)` - Returns: `[2, 1]`, after 3 right rotations, the array becomes `[2, 1]`. 4. `circular_array_rotation([], 3)` - Returns: `[]`, an empty array remains unchanged regardless of the number of rotations. 5. `circular_array_rotation([7, -1, 3, 0], 4)` - Returns: `[7, -1, 3, 0]`, after 4 right rotations, the array remains the same since the number of rotations is equal to the array length. Performance Requirement The implementation should be efficient and handle large inputs gracefully. An `O(n)` solution is expected.","solution":"def circular_array_rotation(arr: list[int], k: int) -> list[int]: Rotate the array to the right by k steps. Parameters: arr (list of int): The array to be rotated. k (int): The number of steps to rotate the array to the right. Returns: list of int: The rotated array. if not arr: return arr n = len(arr) k = k % n return arr[-k:] + arr[:-k]"},{"question":"# Histogram Water Trapping You are given a list of non-negative integers representing the heights of bars in a histogram. Each bar\'s width is 1 unit. Implement a function that calculates how much water would be trapped after it rains. # Function Signature ```python def trap_water(heights: list[int]) -> int: pass ``` # Input - `heights`: A list of non-negative integers representing the heights of the bars in the histogram. # Output The amount of water that can be trapped after raining. # Constraints and Notes - The function should run in O(n) time complexity. - The function should use O(1) additional space. - Assume that the dimensions of the histogram are valid and that one unit width corresponds to one unit height. # Example ```python heights = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1] trap_water(heights) # Output: 6 heights = [4, 2, 0, 3, 2, 5] trap_water(heights) # Output: 9 ``` # Requirements - Handle edge cases such as an empty list or a list with only one bar where no water can be trapped. - Implement a solution that efficiently calculates the trapped water using a two-pointer approach or similar. - Ensure that the solution correctly handles varied bar heights and scenarios with multiple trapped areas. - The function\'s output should be tested thoroughly in various scenarios. --- By providing a question that complements the first one, this new question offers a different problem type, testing the candidate\'s understanding of array manipulation and optimization techniques. The complexity, length, and style align well with the original question, ensuring coherence within the assessment set.","solution":"def trap_water(heights: list[int]) -> int: if not heights: return 0 n = len(heights) left, right = 0, n - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"# Coding Question: Matrix Rotation and Pattern Detection Problem Statement Consider a 2D integer matrix where each cell contains a single digit from 0 to 9. Your task is to implement methods that allow rotation of the matrix and check for the existence of a specific integer pattern in the original or rotated matrix. Requirements 1. **Rotate Matrix**: - Implement the `rotate` method which rotates the matrix 90 degrees clockwise. - The method should modify the matrix in place and does not return anything. 2. **Check Pattern Existence**: - Implement the `has_pattern` method which checks if a specific integer pattern exists in the matrix. - The pattern is provided as a list of integers, which the method should search for either horizontally, vertically, or diagonally in any direction (including in the rotated states of the matrix). Method Signatures - `def rotate(self) -> None:` - `def has_pattern(self, pattern: list[int]) -> bool:` Input and Output Formats - **Rotate Method**: - **Input**: None (operates on the matrix attribute of the class). - **Output**: None (modifies the matrix in place). - **Has Pattern Method**: - **Input**: A list of integers representing the pattern. - **Output**: A boolean indicating whether the pattern exists in any of the possible states of the matrix. Constraints - The matrix can have up to 100 rows and 100 columns. - The pattern\'s length will not exceed 10. - The matrix and pattern will only contain digits from 0 to 9. Example Assume the matrix is initialized with the following values: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` - For `matrix.rotate()`, the matrix will be modified to: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` - For `matrix.has_pattern([1, 5, 9])`, the output would be `True`. - For `matrix.has_pattern([3, 6, 9])`, the output would be `True` (after rotation). - For `matrix.has_pattern([2, 5, 8])`, the output would be `True`. Implementation ```python class Matrix: def __init__(self, matrix: list[list[int]]): self.matrix = matrix def rotate(self) -> None: n = len(self.matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = self.matrix[i][j] self.matrix[i][j] = self.matrix[n - 1 - j][i] self.matrix[n - 1 - j][i] = self.matrix[n - 1 - i][n - 1 - j] self.matrix[n - 1 - i][n - 1 - j] = self.matrix[j][n - 1 - i] self.matrix[j][n - 1 - i] = temp def has_pattern(self, pattern: list[int]) -> bool: def check_pattern(matrix, pattern): rows, cols = len(matrix), len(matrix[0]) len_pattern = len(pattern) for i in range(rows): for j in range(cols): if ( j <= cols - len_pattern and all(matrix[i][j + k] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and all(matrix[i + k][j] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and j <= cols - len_pattern and all(matrix[i + k][j + k] == pattern[k] for k in range(len_pattern)) or i >= len_pattern - 1 and j <= cols - len_pattern and all(matrix[i - k][j + k] == pattern[k] for k in range(len_pattern)) ): return True return False for _ in range(4): if check_pattern(self.matrix, pattern): return True self.rotate() return False # Example of how to use: matrix = Matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) print(matrix.has_pattern([1, 5, 9])) # True print(matrix.has_pattern([3, 6, 9])) # True after rotation print(matrix.has_pattern([2, 5, 8])) # True ```","solution":"class Matrix: def __init__(self, matrix: list[list[int]]): self.matrix = matrix def rotate(self) -> None: n = len(self.matrix) m = len(self.matrix[0]) # Create a new matrix to hold rotated values new_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): new_matrix[j][n - 1 - i] = self.matrix[i][j] self.matrix = new_matrix def has_pattern(self, pattern: list[int]) -> bool: def check_pattern(matrix, pattern): rows, cols = len(matrix), len(matrix[0]) len_pattern = len(pattern) for i in range(rows): for j in range(cols): if ( j <= cols - len_pattern and all(matrix[i][j + k] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and all(matrix[i + k][j] == pattern[k] for k in range(len_pattern)) or i <= rows - len_pattern and j <= cols - len_pattern and all(matrix[i + k][j + k] == pattern[k] for k in range(len_pattern)) or i >= len_pattern - 1 and j <= cols - len_pattern and all(matrix[i - k][j + k] == pattern[k] for k in range(len_pattern)) ): return True return False for _ in range(4): if check_pattern(self.matrix, pattern): return True self.rotate() return False"},{"question":"# Coding Question: Unique Letter Combinations from Digit Strings Scenario: You\'re working with a new custom messaging application. One of the features of this app allows users to convert digit strings into all possible combinations of letters based on the standard T9 phone keypad layout. Problem Statement: Write a function `digit_to_letters(digits)` that takes in one parameter: - `digits`: A string consisting of numeric digits. The function should return a list of strings representing all possible letter combinations that the number could represent, based on the T9 phone keypad. If the input string is empty, return an empty list. The mapping of digits to letters is as follows: ``` 2: \\"abc\\", 3: \\"def\\", 4: \\"ghi\\", 5: \\"jkl\\", 6: \\"mno\\", 7: \\"pqrs\\", 8: \\"tuv\\", 9: \\"wxyz\\" ``` Input: - `digits` is a string with `0 <= len(digits) <= 4`, each character `di` where `2 <= di <= 9`. Output: - The function should return a list of all possible letter combinations. Constraints: - You can assume that the digits are valid and correspond to the T9 layout keys. - The order of the combinations in the output list does not matter. Examples: ```python def digit_to_letters(digits): >>> digit_to_letters(\\"23\\") [\'ad\', \'ae\', \'af\', \'bd\', \'be\', \'bf\', \'cd\', \'ce\', \'cf\'] >>> digit_to_letters(\\"\\") [] >>> digit_to_letters(\\"2\\") [\'a\', \'b\', \'c\'] >>> digit_to_letters(\\"79\\") [\'pw\', \'px\', \'py\', \'pz\', \'qw\', \'qx\', \'qy\', \'qz\', \'rw\', \'rx\', \'ry\', \'rz\', \'sw\', \'sx\', \'sy\', \'sz\'] if not digits: return [] digit_to_char = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations ```","solution":"def digit_to_letters(digits): Returns all possible letter combinations that the number could represent based on the T9 phone keypad. if not digits: return [] digit_to_char = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_chars = digit_to_char[digits[index]] for char in possible_chars: path.append(char) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"# Scenario You are designing a system that schedules periodic tasks. Each task must be executed based on its own schedule without interfering with other tasks. You need to implement a function that helps calculate the next execution time for all tasks after a given reference time. # Task Write a function `next_execution_times(reference_time: int, intervals: List[int]) -> List[int]` that takes the current reference time and a list of intervals (in seconds). The function returns the next execution time for each interval, calculated based on the reference time. # Input * **reference_time**: A non-negative integer `0 <= reference_time <= 10^9`, representing the current reference time in seconds. * **intervals**: A list of `m` integers `[t1, t2, ..., tm]` representing the intervals in seconds for each task (`1 <= m <= 10^5` and `1 <= ti <= 10^9`). # Output * Return a list of `m` integers where the ith element represents the next execution time for the task with an interval of `ti` seconds. # Function Signature ```python from typing import List def next_execution_times(reference_time: int, intervals: List[int]) -> List[int]: pass ``` # Examples * `next_execution_times(100, [30, 45, 60])` should return `[120, 135, 120]`. * `next_execution_times(200, [70, 105, 120])` should return `[210, 210, 240]`. # Constraints * Ensure your solution handles large values efficiently in both time and space complexities. * You need to consider both single and multiple intervals for the task execution times. # Notes * You can assume that the intervals are unique for simplification. * The result should correctly compute the smallest next execution time greater than the reference time for each interval.","solution":"from typing import List def next_execution_times(reference_time: int, intervals: List[int]) -> List[int]: result = [] for interval in intervals: # Calculate the number of complete intervals since the start up to the reference time num_intervals = (reference_time // interval) + 1 next_time = num_intervals * interval result.append(next_time) return result"},{"question":"# Fibonacci Sequence Modulo You are tasked with implementing a function that computes the Fibonacci sequence modulo a given number `mod` for the first `n` terms. This function computes the Fibonacci numbers where each number is defined by the recurrence relation: [ F(0) = 0 ] [ F(1) = 1 ] [ F(n) = (F(n-1) + F(n-2)) mod text{mod} ] Your function should return a list of these Fibonacci numbers up to the `n`-th term inclusively. Function Signature ```python def fibonacci_modulo(n: int, mod: int) -> List[int]: ``` Input 1. `n`: An integer representing the number of terms. Example: `n = 10`. 2. `mod`: An integer representing the modulo value. Example: `mod = 100`. Output - Return a list of integers representing the Fibonacci sequence modulo `mod`. Constraints - ( 1 leq n leq 10^6 ) - ( 1 leq text{mod} leq 10^9 ) Example ```python result = fibonacci_modulo(10, 100) print(result) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55] ``` # Notes * The function should be efficient for large values of `n`. * Consider edge cases where `n` is very small or the `mod` value results in repeated patterns. This problem is designed to test your ability to work with recursive sequences, modulo operations, and efficient algorithm implementation.","solution":"from typing import List def fibonacci_modulo(n: int, mod: int) -> List[int]: if n == 0: return [0] if n == 1: return [0, 1] fib = [0, 1] for i in range(2, n + 1): fib.append((fib[-1] + fib[-2]) % mod) return fib"},{"question":"# Question: Implement a Stack Using Queues Scenario Design a stack data structure using only two queues. The stack should support typical stack operations such as push, pop, top, and checking if the stack is empty. Task Implement the `StackUsingQueues` class that simulates the functionality of a stack using only two queues. Do not use any other libraries or data structures. Requirements: - `StackUsingQueues` should have the following methods: * `push(x: int) -> None`: Push element `x` onto the stack. * `pop() -> int`: Removes the element on the top of the stack and returns that element. * `top() -> int`: Gets the top element of the stack. * `empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. Constraints * You may use the built-in `collections.deque` for implementing the queues. * All operations must be implemented to closely match the time complexity (`O(1)` for `push` and `O(n)` for `pop`). Example ```python # Initialize a stack stack = StackUsingQueues() # Push elements stack.push(1) stack.push(2) stack.push(3) # Top element print(stack.top()) # Output: 3 # Pop element print(stack.pop()) # Output: 3 # Top element after pop print(stack.top()) # Output: 2 # Check if the stack is empty print(stack.empty()) # Output: False # Pop remaining elements print(stack.pop()) # Output: 2 print(stack.pop()) # Output: 1 # Check if the stack is empty now print(stack.empty()) # Output: True ``` Edge Cases to Consider * Popping from an empty stack should handle gracefully without errors. * Pushing and immediately popping elements to test stack consistency. * Multiple consecutive `top` calls after single push or pop operation. Notes * Your solution should ensure that `push`, `pop`, and `top` operations are logically consistent and operate as per the stack LIFO (Last-In, First-Out) principle. * Do not use any built-in stack data structures to solve this problem. Implement stack behavior using only queues.","solution":"from collections import deque class StackUsingQueues: def __init__(self): self.q1 = deque() self.q2 = deque() def push(self, x: int) -> None: self.q1.append(x) def pop(self) -> int: while len(self.q1) > 1: self.q2.append(self.q1.popleft()) popped_element = self.q1.popleft() self.q1, self.q2 = self.q2, self.q1 return popped_element def top(self) -> int: while len(self.q1) > 1: self.q2.append(self.q1.popleft()) top_element = self.q1.popleft() self.q2.append(top_element) self.q1, self.q2 = self.q2, self.q1 return top_element def empty(self) -> bool: return not self.q1"},{"question":"# Context You are designing a simple logging system for a web application to record user activities. The log should store the timestamp, user ID, and the action performed. The log should also support querying to retrieve activities based on specific criteria. # Objective Implement the logging system by creating a log manager. The log manager should allow adding new logs, fetching logs based on criteria, and getting a summary of actions performed. # Class Definitions 1. `LogManager`: - Manages the logs and provides interfaces to add and query logs. # Method Definitions 1. `add_log(timestamp: str, user_id: int, action: str)`: - Adds a new log entry with specified timestamp, user ID, and action. 2. `fetch_logs(user_id: int, start_time: str, end_time: str) -> list[tuple[int, str, str]]`: - Retrieves logs for the given user ID within the specified time range. 3. `summary(user_id: int) -> dict[str, int]`: - Returns a summary of actions performed by the user as a dictionary with actions as keys and their counts as values. # Input and Output Formats - **add_log(timestamp: str, user_id: int, action: str)** * `timestamp`: String representing the timestamp in the format `\\"yyyy-mm-dd hh:mm:ss\\"`. * `user_id`: Integer, unique identifier for the user. * `action`: String, action performed by the user. - **fetch_logs(user_id: int, start_time: str, end_time: str) -> list[tuple[int, str, str]]** * `user_id`: Integer, unique identifier for the user. * `start_time`: String, start time in the format `\\"yyyy-mm-dd hh:mm:ss\\"`. * `end_time`: String, end time in the format `\\"yyyy-mm-dd hh:mm:ss\\"`. * Returns: List of tuples, each containing the user ID, timestamp, and action for the logs that match the criteria. - **summary(user_id: int) -> dict[str, int]** * `user_id`: Integer, unique identifier for the user. * Returns: Dictionary with actions as keys and their counts as values. # Constraints - `timestamp` must be a valid date-time string in the format `\\"yyyy-mm-dd hh:mm:ss\\"`. - `user_id` must be a non-negative integer. - `action` must be a non-empty string. - Both `start_time` and `end_time` must be valid date-time strings. # Example Usage ```python # Initialization log_manager = LogManager() # Adding logs log_manager.add_log(\\"2023-01-01 10:00:00\\", 1, \\"login\\") log_manager.add_log(\\"2023-01-01 10:05:00\\", 1, \\"view_page\\") log_manager.add_log(\\"2023-01-01 10:10:00\\", 2, \\"login\\") # Fetching logs for user 1 logs = log_manager.fetch_logs(user_id=1, start_time=\\"2023-01-01 09:00:00\\", end_time=\\"2023-01-01 11:00:00\\") print(logs) # Example output: [(1, \\"2023-01-01 10:00:00\\", \\"login\\"), (1, \\"2023-01-01 10:05:00\\", \\"view_page\\")] # Getting summary for user 1 summary = log_manager.summary(user_id=1) print(summary) # Example output: {\\"login\\": 1, \\"view_page\\": 1} ``` # Task Implement the `LogManager` class with methods `add_log`, `fetch_logs`, and `summary` as specified. Ensure that the methods handle the inputs and outputs correctly as described in the guidelines and constraints.","solution":"from datetime import datetime from collections import defaultdict class LogManager: def __init__(self): self.logs = [] def add_log(self, timestamp: str, user_id: int, action: str): Adds a new log entry with the specified timestamp, user ID, and action. log_entry = (user_id, timestamp, action) self.logs.append(log_entry) def fetch_logs(self, user_id: int, start_time: str, end_time: str) -> list[tuple[int, str, str]]: Retrieves logs for the given user ID within the specified time range. start_dt = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") user_logs = [log for log in self.logs if log[0] == user_id and start_dt <= datetime.strptime(log[1], \\"%Y-%m-%d %H:%M:%S\\") <= end_dt] return user_logs def summary(self, user_id: int) -> dict[str, int]: Returns a summary of actions performed by the user as a dictionary with actions as keys and their counts as values. action_count = defaultdict(int) for log in self.logs: if log[0] == user_id: action_count[log[2]] += 1 return dict(action_count)"},{"question":"# Problem Statement Implement a function `find_kth_largest(nums: List[int], k: int) -> int` that takes a list of integers and a positive integer `k`, and returns the k-th largest element in the list. # Example ```python >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 ``` # Constraints * 1 <= len(nums) <= 10^4 * -10^4 <= nums[i] <= 10^4 * 1 <= k <= len(nums) # Notes * The k-th largest element in the list is the element that would be at index `len(nums) - k` if the list were sorted in ascending order. * You can assume all input values are valid and correctly formatted. * You can implement the function using any algorithm or built-in functionality to achieve the desired result, but it should operate within practical limits for the given constraints. # Task Breakdown 1. Consider sorting the list and accessing the k-th largest element directly. 2. Alternative approaches such as using a heap or a quickselect algorithm can be explored for optimized performance. 3. Ensure the solution handles edge cases such as `k=1` (largest element) or `k=len(nums)` (smallest element in the list).","solution":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the list nums. nums.sort(reverse=True) return nums[k-1]"},{"question":"# Problem: Develop a Memory-Efficient Fibonacci Generator Fibonacci numbers have a wide variety of applications, from mathematics to computer science. The traditional recursive implementation of the Fibonacci sequence, however, can be both time and space inefficient for large indices. Task 1. **Implement a generator function** `fibonacci_generator` that yields elements of the Fibonacci sequence. 2. The generator should be memory efficient, using constant space. Function Signature ```python def fibonacci_generator(n: int) -> Generator[int, None, None]: pass ``` Parameters * `n`: The number of Fibonacci numbers to generate. Requirements * Your generator should efficiently yield `n` Fibonacci numbers starting from `0`. * Use only a constant amount of memory regardless of the value of `n`. * Implement error handling to ensure `n` is a non-negative integer. Constraints * `0 <= n <= 10^6` * Avoid excessive memory usage. Example ```python >>> fib_gen = fibonacci_generator(10) >>> [num for num in fib_gen] [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` Ensure your solution is space-efficient, robust, and well-tested.","solution":"from typing import Generator def fibonacci_generator(n: int) -> Generator[int, None, None]: Generates the first n Fibonacci numbers. Parameters: - n (int): number of Fibonacci numbers to generate Yields: - int: the next Fibonacci number if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") a, b = 0, 1 for _ in range(n): yield a a, b = b, a + b"},{"question":"# Count Connected Components in an Undirected Graph You are given an undirected graph with `n` nodes. Your task is to compute the number of connected components in the graph. A connected component is a set of nodes such that there is a path between any two nodes in the set. # Function Specification ```python def count_connected_components(graph: dict[int, list[int]]) -> int: # Implement your solution here ``` # Input * `graph`: A dictionary where the keys are nodes and the values are lists of neighboring nodes. # Output * An integer representing the number of connected components in the graph. # Constraints * 1 <= number of nodes <= 1000 * There are no self-loops or multiple edges between the same pair of nodes. # Example ```python graph1 = { 0: [1], 1: [0, 2, 3], 2: [1, 3], 3: [1, 2], 4: [5], 5: [4], } assert count_connected_components(graph1) == 2 graph2 = { 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [], } assert count_connected_components(graph2) == 2 graph3 = { 0: [], 1: [], 2: [], 3: [], 4: [], } assert count_connected_components(graph3) == 5 ``` # Explanation 1. In the first example, the graph has 6 nodes and 2 connected components, one consisting of the nodes [0, 1, 2, 3] and the other consisting of the nodes [4, 5]. 2. In the second example, the graph has 4 nodes with 2 connected components, one component containing nodes [0, 1, 2] and the other is a single disconnected node [3]. 3. In the third example, the graph has 5 isolated nodes, resulting in 5 connected components. Each node is its own connected component. Your implementation should traverse the graph and count how many sets of connected nodes there are.","solution":"def count_connected_components(graph: dict[int, list[int]]) -> int: Counts the number of connected components in an undirected graph. :param graph: A dictionary where the keys are nodes and the values are lists of neighboring nodes. :return: An integer representing the number of connected components in the graph. def dfs(node): Depth First Search helper function to traverse the graph. visited.add(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor) visited = set() num_components = 0 for node in graph: if node not in visited: dfs(node) num_components += 1 return num_components"},{"question":"# Binary Search Tree: In-Order Traversal # Scenario You are working with binary search trees (BST), which maintain sorted order and allow efficient searching, insertion, and deletion operations. You need to perform an in-order traversal of a BST, which visits nodes in ascending order. # Task Write a Python function `in_order_traversal` that receives the root of a binary search tree and returns a list of all values in the tree, obtained via an in-order traversal. # Function Signature ```python def in_order_traversal(root: Optional[TreeNode]) -> List[int] ``` # Input 1. `root` (Optional[TreeNode]): The root node of the binary search tree. A `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` # Output * Returns a `List[int]` containing the values of the BST nodes in ascending order. # Constraints 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. `-10^5 <= TreeNode.value <= 10^5` # Performance Requirement * The implemented solution should have a time complexity of (O(n)), where (n) is the number of nodes in the tree. * Space complexity should be (O(n)), accounting for the recursive call stack and the list of node values. # Example ```python # Example of TreeNode class definition class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right # Example Tree: # 4 # / # 2 6 # / / # 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(6, TreeNode(5), TreeNode(7)) # Perform in-order traversal result = in_order_traversal(root) print(result) # Output: [1, 2, 3, 4, 5, 6, 7] ``` # Notes * An in-order traversal visits the left subtree first, the root node second, and the right subtree last. * Ensure the function handles cases of empty trees by returning an empty list.","solution":"from typing import List, Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def in_order_traversal(root: Optional[TreeNode]) -> List[int]: Perform in-order traversal of a binary search tree and return the nodes\' values in ascending order. :param root: The root node of the binary search tree :return: A list of node values in ascending order def traverse(node, output): if node is not None: traverse(node.left, output) output.append(node.value) traverse(node.right, output) result = [] traverse(root, result) return result"},{"question":"# Question: Sort a List of Strings by Anagram Groups In this task, you have to sort a given list of strings in such a way that all anagrams are grouped together and the groups of anagrams themselves are sorted lexicographically. # Requirements: 1. Your function should take a list of strings. 2. Your function should return a list of strings where all anagrams are grouped together and sorted lexicographically. # Input: - A list of strings. # Output: - A list of strings with anagrams grouped together and sorted lexicographically. # Constraints: - All strings in the input list will be in lowercase. - The list will contain at least one string and at most 1000 strings. - Each string will have a maximum length of 100 characters. # Example: ```python def sort_anagram_groups(strings: list[str]) -> list[str]: # Your implementation here pass # Example Usage strings = [\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"] print(sort_anagram_groups(strings)) # Output: [\'bat\', \'bat\', \'tab\', \'eat\', \'tea\', \'nat\', \'tan\'] ``` # Notes: - Two strings are anagrams if they are made of the same characters with the same frequencies. - Ensure that the groups of anagrams are individually sorted and the groups themselves are sorted lexicographically. - The implementation should efficiently handle the given constraints. Implement the `sort_anagram_groups` function to fulfill the above requirements and analyze its performance.","solution":"def sort_anagram_groups(strings): Groups anagrams together and sorts them lexicographically. :param strings: List of strings :return: List of strings with anagrams grouped together and sorted lexicographically from collections import defaultdict # Dictionary to hold groups of anagrams anagram_map = defaultdict(list) for s in strings: # Sort the characters of the string to form the key key = \'\'.join(sorted(s)) anagram_map[key].append(s) # Collect all anagram groups into a list result = [] for key in sorted(anagram_map.keys()): # Sort each group of anagrams and add to the result list result.extend(sorted(anagram_map[key])) return result # Example usage strings = [\\"bat\\", \\"tab\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"nat\\", \\"bat\\"] print(sort_anagram_groups(strings)) # Output: [\'bat\', \'bat\', \'tab\', \'eat\', \'tea\', \'nat\', \'tan\']"},{"question":"# Student Grade Calculation System Objective: Design a Python function to calculate and assign letter grades based on students\' scores from a given list while incorporating core list manipulation and conditional logic skills. Problem Description: You are tasked with writing a function `calculate_grades(scores: list[int]) -> dict[str, int]` that takes a list of integer scores and returns a dictionary where the keys are the letter grades (\'A\', \'B\', \'C\', \'D\', \'F\') and the values are the counts of how many students received each grade. The grading scale is as follows: - \'A\' for scores 90 and above, - \'B\' for scores between 80 and 89, - \'C\' for scores between 70 and 79, - \'D\' for scores between 60 and 69, - \'F\' for scores below 60. Input: - `scores`: a list of integers representing the scores of students. Output: - Dictionary with letter grades as keys and counts as values. Constraints: - Each score is an integer in the range from 0 to 100. - The list of scores could be empty, and the function should handle this gracefully. - The function should correctly categorize duplicates without error. Requirements: 1. The solution should iterate through the list to classify each score. 2. An empty list should return a dictionary with all grade counts as zero. 3. The classification should not assume the scores are sorted. 4. Ensure the function runs efficiently even with a large list of scores. Example Usage: ```python grades = calculate_grades([95, 85, 75, 65, 55, 90, 80, 70, 60, 50]) print(grades) # should output {\'A\': 2, \'B\': 2, \'C\': 2, \'D\': 2, \'F\': 2} ``` Implementation Strategy: 1. Initialize a dictionary with keys \'A\', \'B\', \'C\', \'D\', \'F\' and default values 0. 2. Iterate through the scores list and update the dictionary based on the grading scale. 3. Return the updated dictionary. ```python def calculate_grades(scores: list[int]) -> dict[str, int]: Calculate letter grades from a list of scores and count occurrences of each grade. :param scores: List of integer scores. :return: Dictionary with grade letters as keys and counts as values. # Implementation of the function pass ``` Implement the function ensuring it accurately categorizes and counts the scores into the respective grades. Include handling for edge cases and appropriate documentation.","solution":"def calculate_grades(scores: list[int]) -> dict[str, int]: Calculate letter grades from a list of scores and count occurrences of each grade. :param scores: List of integer scores. :return: Dictionary with grade letters as keys and counts as values. grade_counts = {\'A\': 0, \'B\': 0, \'C\': 0, \'D\': 0, \'F\': 0} for score in scores: if score >= 90: grade_counts[\'A\'] += 1 elif score >= 80: grade_counts[\'B\'] += 1 elif score >= 70: grade_counts[\'C\'] += 1 elif score >= 60: grade_counts[\'D\'] += 1 else: grade_counts[\'F\'] += 1 return grade_counts"},{"question":"# Context You are developing a simple text-based search engine that can find and retrieve documents containing specific keywords. The search engine needs to efficiently index documents and return search results quickly. # Problem Statement Implement a class `SimpleSearchEngine` that indexes a collection of documents and allows for keyword-based searches. # Requirements 1. **Class Definition**: ```python class SimpleSearchEngine: def __init__(self): self.index = {} def add_document(self, doc_id: int, content: str) -> None: pass def search(self, keyword: str) -> list[int]: pass ``` 2. **Methods**: - `__init__`: Initializes an empty index. - `add_document`: Adds a document to the search engine by updating the index. - `doc_id` (int): Unique identifier for the document. - `content` (str): Text content of the document. - `search`: Searches for documents containing the specified keyword. - `keyword` (str): Word to search for. - Returns a list of document IDs that contain the keyword, sorted in ascending order. 3. **Constraints**: - `doc_id` must be a unique identifier for each document. - The `content` of the document will be a non-empty string. - The `keyword` in the search will be a single word (no spaces). 4. **Error Handling**: - Raise `ValueError` with an appropriate message if the `doc_id` is not unique when adding a document. # Examples ```python >>> engine = SimpleSearchEngine() >>> engine.add_document(1, \\"hello world\\") >>> engine.add_document(2, \\"hello\\") >>> engine.add_document(3, \\"world\\") >>> engine.search(\\"hello\\") [1, 2] >>> engine.search(\\"world\\") [1, 3] >>> engine.add_document(1, \\"new document\\") Traceback (most recent call last): ... ValueError: Document ID 1 already exists >>> engine.search(\\"new\\") [] ``` # Notes - Ensure the search engine can handle a large number of documents efficiently. - Consider using appropriate data structures for indexing and searching to optimize performance. - Handle the case-sensitive nature of keywords appropriately, assuming a case-sensitive search.","solution":"class SimpleSearchEngine: def __init__(self): self.index = {} self.documents = {} def add_document(self, doc_id: int, content: str) -> None: if doc_id in self.documents: raise ValueError(f\\"Document ID {doc_id} already exists\\") self.documents[doc_id] = content words = content.split() for word in words: if word in self.index: self.index[word].add(doc_id) else: self.index[word] = {doc_id} def search(self, keyword: str) -> list[int]: if keyword in self.index: return sorted(self.index[keyword]) else: return []"},{"question":"# Coding Assessment Question Context: In the realm of data manipulation, efficiently managing and transforming text data is critical for various applications, such as natural language processing, data cleaning, and automated messaging systems. You are tasked with implementing a system that processes text based on specific tasks, including reversing words, rotating letters, and modifying cases. Problem Statement: Implement two key functions that handle specific text manipulations: `reverse_words` and `rotate_letters`. **Function 1: Reverse Words** Implement a function `reverse_words(sentence: str) -> str` that reverses the order of words in a given sentence. **Function 2: Rotate Letters** Implement a function `rotate_letters(text: str, n: int) -> str` that rotates each letter in a string by `n` positions in the alphabet. Letters should wrap around if they go past \'z\' or \'Z\'. **Constraints and Requirements:** 1. **Reverse Words**: - The input string `sentence` consists of words separated by spaces. - Punctuation marks are part of the words and should not be separated. 2. **Rotate Letters**: - Only alphabets should be rotated; non-alphabet characters remain unchanged. - Rotation should maintain the case of the letters (i.e., uppercase remains uppercase, lowercase remains lowercase). **Expected Input and Output:** 1. `reverse_words(sentence: str) -> str`: - **Input**: A string `sentence`. - **Output**: A string with the words in reversed order. 2. `rotate_letters(text: str, n: int) -> str`: - **Input**: A string `text` and an integer `n`. - **Output**: A string with each letter rotated by `n` positions in the alphabet. **Performance Requirements:** - Ensure efficient handling of long strings for both functions. - Correctly manage edge cases, such as empty strings or strings with only whitespace. **Example Usage:** ```python # Example usage: # Reversing the words in a sentence: print(reverse_words(\\"Hello world, how are you?\\")) # Output: \\"you? are how world, Hello\\" # Rotating letters in a string by 2 positions: print(rotate_letters(\\"Hello, World!\\", 2)) # Output: \\"Jgnnq, Yqtnf!\\" ``` **Function Implementation:** ```python def reverse_words(sentence: str) -> str: # Split the sentence into words and reverse the list of words words = sentence.split() words.reverse() return \' \'.join(words) def rotate_letters(text: str, n: int) -> str: def rotate_char(c, n): # Rotate an individual character c by n places if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + n) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + n) % 26 + ord(\'A\')) else: return c # Apply the rotation to each character in the text return \'\'.join(rotate_char(c, n) for c in text) # Example usage of the implemented functions print(reverse_words(\\"Hello world, how are you?\\")) print(rotate_letters(\\"Hello, World!\\", 2)) ``` Ensure the newly created question aligns with the provided guidelines and seamlessly fits into the original set of questions.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. words = sentence.split() words.reverse() return \' \'.join(words) def rotate_letters(text: str, n: int) -> str: Rotates each letter in a string by n positions in the alphabet. Letters wrap around if they go past \'z\' or \'Z\'. Non-alphabet characters remain unchanged. def rotate_char(c, n): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + n) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + n) % 26 + ord(\'A\')) else: return c return \'\'.join(rotate_char(c, n) for c in text)"},{"question":"# Coding Assessment Question: **Objective**: Write a function that takes an integer and produces a \\"digital root\\" of that number. This will demonstrate your understanding of recursive functions and integer manipulation. # Problem Statement: Implement the function `digital_root(n: int) -> int` that calculates the digital root of a given integer `n`. The digital root is the single-digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration. # Function Signature: ```python def digital_root(n: int) -> int: ``` # Input: - `n` (int): A non-negative integer from which the digital root needs to be derived. # Output: - int: The digital root of the input number. # Constraints: - The input `n` is a non-negative integer. # Examples: - `digital_root(16)` -> 7 (1 + 6 = 7) - `digital_root(942)` -> 6 (9 + 4 + 2 = 15; 1 + 5 = 6) - `digital_root(132189)` -> 6 (1 + 3 + 2 + 1 + 8 + 9 = 24; 2 + 4 = 6) - `digital_root(493193)` -> 2 (4 + 9 + 3 + 1 + 9 + 3 = 29; 2 + 9 = 11; 1 + 1 = 2) - `digital_root(0)` -> 0 # Edge Cases to Consider: - The function should handle the case when `n` is zero. - Ensure the function correctly reduces multi-digit results until a single-digit is obtained. - Avoid infinite recursion or unnecessary loops by ensuring the base case is correctly defined. # Additional Requirement: - The function should be implemented using recursion.","solution":"def digital_root(n: int) -> int: Function to find the digital root of a non-negative integer n. This is done by recursively summing the digits until a single digit is obtained. if n < 10: return n else: next_n = sum(int(digit) for digit in str(n)) return digital_root(next_n)"},{"question":"# Context: You are working on the implementation of a text processing module for a natural language processing (NLP) pipeline. Part of your task is to create a function that can extract and analyze particular text features. # Task: 1. **Implement Custom Text Processing Functions**: - Implement a function `count_words` to count the number of occurrences of each word in a given text. - Implement a function `sentence_length_statistics` to calculate statistical metrics (mean, median, and standard deviation) of sentence lengths in a text. 2. **Improve Performance**: - Optimize your functions to handle large texts efficiently. # Requirements: 1. **Word Counting** (`count_words`): - Input: A string of text. - Output: A dictionary where keys are unique words, and values are their respective counts. 2. **Sentence Length Statistics** (`sentence_length_statistics`): - Input: A string of text. - Output: A dictionary with three keys: `mean`, `median`, and `std`, representing the mean, median, and standard deviation of sentence lengths (measured in words), respectively. # Implementation: - Write the `count_words` function that takes a string of text and returns the word count dictionary. - Write the `sentence_length_statistics` function to calculate the mean, median, and standard deviation of sentence lengths from a given text. - Ensure your implementation performs efficiently even for large input texts. # Input & Output: - **Input**: - A single string of text for both `count_words` and `sentence_length_statistics`. - **Output**: - For `count_words`: A dictionary with words as keys and their count as values. - For `sentence_length_statistics`: A dictionary containing the mean, median, and standard deviation of sentence lengths. # Constraints: - Ignore case sensitivity when counting words (e.g., \\"The\\" and \\"the\\" should be considered the same word). - Use natural sentence delimiters (i.e., periods, exclamation marks, and question marks) to detect sentence boundaries. - Assume the input text is well-formed and does not contain malformed sentences. **Example Code Template**: ```python import re import numpy as np from collections import Counter def count_words(text): # Your code here pass def sentence_length_statistics(text): # Your code here pass def example(): text = \\"Hello world! This is a test. This test is designed to check sentence length statistics. How well does it work?\\" word_counts = count_words(text) print(\\"Word Counts:\\", word_counts) stats = sentence_length_statistics(text) print(\\"Sentence Length Statistics:\\", stats) if __name__ == \\"__main__\\": example() ``` **Notes**: - Ensure the `count_words` function converts all words to lowercase before counting. - Split sentences based on periods, exclamation marks, and question marks, and ensure proper handling of edge cases (e.g., multiple punctuation marks). - Utilize libraries like numpy for statistical calculations in the `sentence_length_statistics` function.","solution":"import re import numpy as np from collections import Counter def count_words(text): Counts the number of occurrences of each word in the given text. :param text: A string of text. :return: A dictionary where keys are unique words, and values are their counts. # Convert text to lowercase lower_text = text.lower() # Use regex to find all words words = re.findall(r\'bw+b\', lower_text) # Use Counter to count occurrences of each word word_counts = Counter(words) return dict(word_counts) def sentence_length_statistics(text): Calculates the mean, median, and standard deviation of sentence lengths in the given text. :param text: A string of text. :return: A dictionary with statistical metrics. # Split text into sentences based on typical sentence-ending punctuation sentences = re.split(r\'[.!?]\', text) # Remove empty sentences and strip whitespace sentences = [sentence.strip() for sentence in sentences if sentence.strip()] # Calculate the number of words in each sentence sentence_lengths = [len(re.findall(r\'bw+b\', sentence)) for sentence in sentences] if len(sentence_lengths) == 0: return {\'mean\': 0, \'median\': 0, \'std\': 0} # Calculate statistics using numpy mean = np.mean(sentence_lengths) median = np.median(sentence_lengths) std = np.std(sentence_lengths, ddof=0) return {\'mean\': mean, \'median\': median, \'std\': std} def example(): text = \\"Hello world! This is a test. This test is designed to check sentence length statistics. How well does it work?\\" word_counts = count_words(text) print(\\"Word Counts:\\", word_counts) stats = sentence_length_statistics(text) print(\\"Sentence Length Statistics:\\", stats) if __name__ == \\"__main__\\": example()"},{"question":"# Coding Assessment Question Implement a text-based Battleship game where a human player competes against a computer opponent. The game is played on a 10x10 grid. Each player has to place a set of ships of varying lengths, and then take turns attempting to hit each other\'s ships. Your goal is to ensure the following functionalities within the game: 1. **Initialization**: Set up the 10x10 grid for both the player and the computer. Prompt the player to place ships of lengths 2, 3, 3, 4, and 5, while the computer places its ships randomly. 2. **Ship Placement**: - Ships can be placed either horizontally or vertically. - Ensure ships do not overlap with each other or go out of the grid bounds. 3. **Gameplay**: - Players take turns to call out a grid coordinate to attack. - Mark hits and misses on both the player\'s and opponent\'s grid. - Inform the player whether the attack resulted in a hit or miss and if a ship is sunk. - Computer should randomly select a valid cell to attack on its turn. 4. **Winning Condition**: The game ends when all of one player\'s ships have been sunk. Display the winner. 5. **Display**: Consistently show the player\'s grid and the opponent’s grid after each turn, with appropriate markings indicating hits, misses, and sunk ships. Function Signature: ```python class BattleshipGame: def __init__(self) -> None: ... def player_place_ships(self) -> None: ... def computer_place_ships(self) -> None: ... def player_turn(self) -> None: ... def computer_turn(self) -> None: ... def display_grids(self) -> None: ... def check_winner(self) -> str: ... def play(self) -> None: ... ``` Your Task: Implement the `BattleshipGame` class and its methods to enable a fully functional text-based Battleship game. Your implementation should ensure the correct placement of ships, proper turn-based gameplay mechanics, and display grid updates consistently. Handle edge cases such as repeated attacks on the same cell and ship placement validation. Constraints: - Grid dimension: 10 x 10. - Ship lengths: [2, 3, 3, 4, 5]. - Ensure random and varied placements and movements for the computer. - Ensure efficient and clear marking of hits, misses, and sunk ships. Given this setup, you can verify correctness by: - Ensuring ships are correctly placed without overlapping or out-of-bounds issues. - Verifying that each turn processes valid hits, misses, and updates the grids accordingly. - Observing the correct ending of the game when all ships of one player are sunk.","solution":"import random SHIP_LENGTHS = [2, 3, 3, 4, 5] GRID_SIZE = 10 def create_grid(): return [[\\"~\\"] * GRID_SIZE for _ in range(GRID_SIZE)] class BattleshipGame: def __init__(self) -> None: self.player_grid = create_grid() self.computer_grid = create_grid() self.player_ships = [] self.computer_ships = [] def place_ship(self, grid, ships, length, vertical, x, y): if vertical: if x + length > GRID_SIZE: return False for i in range(length): if grid[x + i][y] != \\"~\\": return False for i in range(length): grid[x + i][y] = \\"S\\" ships.append((x + i, y, \\"S\\")) else: if y + length > GRID_SIZE: return False for i in range(length): if grid[x][y + i] != \\"~\\": return False for i in range(length): grid[x][y + i] = \\"S\\" ships.append((x, y + i, \\"S\\")) return True def player_place_ships(self) -> None: for length in SHIP_LENGTHS: while True: x = int(input(f\\"Enter the starting row (0-{GRID_SIZE-1}) for ship of length {length}: \\")) y = int(input(f\\"Enter the starting column (0-{GRID_SIZE-1}) for ship of length {length}: \\")) vertical = input(\\"Place vertically? (y/n): \\").lower() == \\"y\\" if self.place_ship(self.player_grid, self.player_ships, length, vertical, x, y): break else: print(\\"Invalid placement. Try again.\\") def computer_place_ships(self) -> None: for length in SHIP_LENGTHS: while True: x = random.randint(0, GRID_SIZE-1) y = random.randint(0, GRID_SIZE-1) vertical = random.choice([True, False]) if self.place_ship(self.computer_grid, self.computer_ships, length, vertical, x, y): break def take_turn(self, grid, ships, x, y): if grid[x][y] == \\"S\\": grid[x][y] = \\"X\\" for ship in ships: if ship[0] == x and ship[1] == y: ships.remove(ship) break if not any(cell for cell in grid[x] if cell == \\"S\\"): return \\"Sunk\\" return \\"Hit\\" grid[x][y] = \\"O\\" return \\"Miss\\" def player_turn(self) -> bool: x = int(input(\\"Enter the row to attack (0-9): \\")) y = int(input(\\"Enter the column to attack (0-9): \\")) result = self.take_turn(self.computer_grid, self.computer_ships, x, y) print(f\\"Player attacked ({x}, {y}): {result}\\") return result == \\"Sunk\\" def computer_turn(self) -> bool: while True: x = random.randint(0, GRID_SIZE-1) y = random.randint(0, GRID_SIZE-1) if self.computer_grid[x][y] not in [\\"X\\", \\"O\\"]: result = self.take_turn(self.player_grid, self.player_ships, x, y) print(f\\"Computer attacked ({x}, {y}): {result}\\") return result == \\"Sunk\\" def display_grids(self) -> None: print(\\"Player\'s grid:\\") for row in self.player_grid: print(\\" \\".join(row)) print(\\"nComputer\'s grid:\\") for row in self.computer_grid: print(\\" \\".join(row)) def check_winner(self) -> str: if not self.computer_ships: return \\"Player\\" if not self.player_ships: return \\"Computer\\" return \\"\\" def play(self) -> None: self.computer_place_ships() # Random for computer, comment in tests self.player_place_ships() # For testing simply place ships while True: self.display_grids() if self.player_turn(): winner = self.check_winner() if winner: print(f\\"{winner} wins!\\") self.display_grids() break if self.computer_turn(): winner = self.check_winner() if winner: print(f\\"{winner} wins!\\") self.display_grids() break"},{"question":"# Background In order to compare the efficiency and performance of various sorting algorithms, you need to write a program that can execute different sorting techniques on a given list of integers. To provide a comprehensive comparison, your task involves implementing specific sorting algorithms with a performance measurement component. # Problem Statement Write a function named `compare_sorting_algorithms` in Python that accomplishes the following: 1. Accepts a list of integers. 2. Implements the following sorting algorithms within the function: - Bubble Sort - Merge Sort - Quick Sort 3. Executes each of these sorting algorithms on the same input list. 4. Measures the time taken to execute each sorting algorithm. 5. Returns a dictionary with the sorting algorithm names as keys and their corresponding execution times (in seconds) as values. # Function Signature ```python import time def compare_sorting_algorithms(arr: list) -> dict: # your code here ``` # Input - `arr` (list): A list of integers to be sorted. # Output - (dict): A dictionary where keys are the names of the sorting algorithms (`\'bubble_sort\'`, `\'merge_sort\'`, `\'quick_sort\'`) and values are the time taken (in seconds) to sort the list using each algorithm. # Constraints - You may assume that the input list will contain at most 1000 integers. - Use the built-in `time` module to measure the execution time of each sorting algorithm. # Example Usage ```python result_times = compare_sorting_algorithms([64, 34, 25, 12, 22, 11, 90]) print(result_times) # Output: {\'bubble_sort\': <time_taken>, \'merge_sort\': <time_taken>, \'quick_sort\': <time_taken>} ``` # Notes - Ensure your implementation of each sorting algorithm is correct and follows conventional approaches. - Consider edge cases such as an empty list or a list with a single element. - Handle exceptions gracefully, ensuring that the timings are returned even if one sorting algorithm fails. # Helper Function (Optional) Implementing the sorting algorithms as separate helper functions within the main function can improve code organization.","solution":"import time def bubble_sort(arr): n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 L = arr[:mid] R = arr[mid:] merge_sort(L) merge_sort(R) i = j = k = 0 while i < len(L) and j < len(R): if L[i] < R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < len(L): arr[k] = L[i] i += 1 k += 1 while j < len(R): arr[k] = R[j] j += 1 k += 1 return arr def quick_sort(arr): if len(arr) <= 1: return arr else: pivot = arr[0] less = [x for x in arr[1:] if x <= pivot] greater = [x for x in arr[1:] if x > pivot] return quick_sort(less) + [pivot] + quick_sort(greater) def compare_sorting_algorithms(arr: list) -> dict: results = {} # Bubble Sort start_time = time.time() bubble_sort(arr.copy()) end_time = time.time() results[\'bubble_sort\'] = end_time - start_time # Merge Sort start_time = time.time() merge_sort(arr.copy()) end_time = time.time() results[\'merge_sort\'] = end_time - start_time # Quick Sort start_time = time.time() quick_sort(arr.copy()) end_time = time.time() results[\'quick_sort\'] = end_time - start_time return results # Example usage: # result_times = compare_sorting_algorithms([64, 34, 25, 12, 22, 11, 90]) # print(result_times) # Output: {\'bubble_sort\': <time_taken>, \'merge_sort\': <time_taken>, \'quick_sort\': <time_taken>}"},{"question":"# Coding Assessment Question **Context**: As part of a data transformation pipeline, you are required to implement a custom normalization function. This function, called `ZScoreNorm`, should standardize the values of a given numpy array such that the resulting distribution has a mean of 0 and a standard deviation of 1. This type of normalization is crucial in various machine learning algorithms to ensure consistency and avoid domination by features with larger scales. **Task**: Write a function `z_score_norm` that applies Z-score normalization to an input numpy array. Function Signature: ```python def z_score_norm(vector: np.ndarray) -> np.ndarray: ``` Parameters: * `vector` (np.ndarray): The input numeric numpy array that needs to be normalized. Returns: * `np.ndarray`: A numpy array where Z-score normalization has been applied. Formula: The Z-score normalization formula: [ Z_i = frac{X_i - mu}{sigma} ] where: * ( X_i ) is the i-th element of the input array, * ( mu ) is the mean of the input array, * ( sigma ) is the standard deviation of the input array. Examples: ```python >>> z_score_norm(np.array([1, 2, 3, 4, 5])) array([-1.41421356, -0.70710678, 0., 0.70710678, 1.41421356]) >>> z_score_norm(np.array([10, 10, 10, 10, 10])) array([0., 0., 0., 0., 0.]) # When all values are the same, standard deviation is zero, normalization results in 0s. ``` # Constraints: * The input array may contain integers or floating-point numbers. * Handle cases where the standard deviation might be zero. * Ensure efficient computation even for large arrays. Additional Information: Z-score normalization is essential for many machine learning models and statistical techniques to ensure that each feature contributes equally to the distance computations.","solution":"import numpy as np def z_score_norm(vector: np.ndarray) -> np.ndarray: Applies Z-score normalization to the input numpy array. Parameters: vector (np.ndarray): The input numeric numpy array that needs to be normalized. Returns: np.ndarray: A numpy array where Z-score normalization has been applied. mean = np.mean(vector) std = np.std(vector) if std == 0: return np.zeros_like(vector) return (vector - mean) / std"},{"question":"# Word Frequency Counter You are required to implement a class called `WordFrequencyCounter` that processes a given list of strings and provides frequency analysis of words. Function Specifications 1. **Initialization**: Define an initializer that accepts a single list of strings. 2. **Frequency Calculation**: Implement a `calculate_frequencies()` method that counts the frequency of each word across all strings and stores these frequencies. 3. **Word Frequency**: Implement a `word_frequency(word)` method to return the frequency of a given word. If the word does not exist, return 0. 4. **Most Frequent Word**: Implement a `most_frequent_word()` method to return the word with the highest frequency. If there are multiple words with the same highest frequency, return any one of them. 5. **Total Unique Words**: Implement a `unique_word_count()` method that returns the total number of unique words present in the list after frequency calculation. Input and Output Specifications **Input**: - `WordFrequencyCounter(str_list)` constructor where `str_list` is the list of strings. - `calculate_frequencies()` method which processes the strings. - `word_frequency(word)` method where `word` is the string to check frequency. - `most_frequent_word()` method with no additional input. - `unique_word_count()` method with no additional input. **Output**: - `calculate_frequencies()` does not return any value but performs the calculation. - `word_frequency(word)` returns an integer representing the frequency. - `most_frequent_word()` returns the word with the highest frequency as a string. - `unique_word_count()` returns an integer representing the number of unique words. # Example Test Cases ```python str_list = [\\"apple orange banana\\", \\"apple apple orange\\", \\"banana orange apple\\"] wf = WordFrequencyCounter(str_list) wf.calculate_frequencies() assert wf.word_frequency(\\"apple\\") == 4 assert wf.word_frequency(\\"banana\\") == 2 assert wf.word_frequency(\\"orange\\") == 3 assert wf.word_frequency(\\"grape\\") == 0 assert wf.most_frequent_word() in [\\"apple\\"] assert wf.unique_word_count() == 3 ``` Implement the `WordFrequencyCounter` class according to these specifications and ensure your implementation passes all the given example test cases.","solution":"from collections import defaultdict class WordFrequencyCounter: def __init__(self, str_list): Initialize the WordFrequencyCounter with a list of strings. self.str_list = str_list self.word_freq = defaultdict(int) def calculate_frequencies(self): Calculate the frequency of each word across all strings. for string in self.str_list: words = string.split() for word in words: self.word_freq[word] += 1 def word_frequency(self, word): Return the frequency of the given word. If the word does not exist, return 0. return self.word_freq.get(word, 0) def most_frequent_word(self): Return the word with the highest frequency. If there are multiple words with the same highest frequency, return any one of them. if not self.word_freq: return None return max(self.word_freq, key=self.word_freq.get) def unique_word_count(self): Return the total number of unique words present. return len(self.word_freq)"},{"question":"# Matrix Transpose Problem **Context:** You are required to implement a function that efficiently computes the transpose of a given matrix. Matrix transposition is a fundamental operation in linear algebra, often used in various scientific and engineering applications. **Problem Statement:** Write a function `transpose_matrix` that takes a 2D list `matrix` as input and returns its transpose. In the transposed matrix, the rows become columns and the columns become rows. ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` **Function Definition:** * **Input**: * `matrix` (list of list of int): The matrix to transpose. It is represented as a list of lists, where each inner list represents a row of the matrix. * **Output**: * Returns list of list of int: The transposed matrix. **Constraints**: 1. The input matrix can be of any dimension (m x n), where m and n are positive integers. 2. Matrix elements are integers. **Edge Cases to Consider**: 1. The matrix is a square matrix (m = n). 2. The matrix is a row vector (1 x n). 3. The matrix is a column vector (m x 1). # Example: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6] ] print(transpose_matrix(matrix)) # Output: [[1, 4], [2, 5], [3, 6]] # Example 2 matrix = [ [1], [2], [3] ] print(transpose_matrix(matrix)) # Output: [[1, 2, 3]] # Example 3 matrix = [ [1, 2, 3] ] print(transpose_matrix(matrix)) # Output: [[1], [2], [3]] ``` **Verification**: Add a unit test class `TestTransposeMatrix` with methods to test the `transpose_matrix` function covering diverse scenarios including square matrices, row and column vectors, and large matrices. ```python import unittest class TestTransposeMatrix(unittest.TestCase): def test_square_matrix(self): matrix = [ [1, 2], [3, 4] ] result = transpose_matrix(matrix) expected = [ [1, 3], [2, 4] ] self.assertEqual(result, expected) def test_row_vector(self): matrix = [ [1, 2, 3] ] result = transpose_matrix(matrix) expected = [ [1], [2], [3] ] self.assertEqual(result, expected) def test_column_vector(self): matrix = [ [1], [2], [3] ] result = transpose_matrix(matrix) expected = [ [1, 2, 3] ] self.assertEqual(result, expected) def test_large_matrix(self): matrix = [ [i for i in range(1000)] for _ in range(1000) ] result = transpose_matrix(matrix) expected = [ [row[i] for row in matrix] for i in range(len(matrix[0])) ] self.assertEqual(result, expected) if __name__ == \'__main__\': unittest.main() ```","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Returns the transpose of the given matrix. Parameters: matrix (list of list of int): The matrix to transpose. Returns: list of list of int: The transposed matrix. return [[row[i] for row in matrix] for i in range(len(matrix[0]))]"},{"question":"**Matrix Spiral Rotation** # Background: Matrix manipulation is a fundamental concept in computer science. One interesting operation on a matrix is rotating its elements in a spiral order. This can be useful for various applications such as image processing, numerical simulations, and more. # Problem Statement: You are required to implement a function that rotates the elements of a given matrix in a clockwise spiral order and returns the rotated matrix. The rotation must be performed in place, meaning you should not create a new matrix for the output. # Function Signature: ```python def rotate_matrix_spiral(matrix: List[List[int]]) -> None: :param matrix: A 2D list of integers representing the input matrix. :return: None. The function modifies the input matrix in place. # Requirements: 1. Implement the `rotate_matrix_spiral` function that: - Takes as input a 2D list representing the matrix. - Rotates the matrix elements in a clockwise spiral order in place. 2. Ensure that your implementation handles matrices of various sizes, including non-square matrices. 3. Do not use additional data structures for storing the matrix’s elements. # Constraints: - The input matrix will have dimensions NxM, where 1 <= N, M <= 100. - Elements of the matrix will be integers. - You must rotate the matrix in place; creating a new matrix is not allowed. # Example: **Example 1:** ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotate_matrix_spiral(matrix) # The matrix should be modified to: # [ # [13, 9, 5, 1], # [14, 10, 6, 2], # [15, 11, 7, 3], # [16, 12, 8, 4] # ] ``` **Example 2:** ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ] rotate_matrix_spiral(matrix) # The matrix should be modified to: # [ # [10, 7, 4, 1], # [11, 8, 5, 2], # [12, 9, 6, 3] # ] ``` # Note: * Ensure that your solution efficiently handles both square and non-square matrices. * Consider edge cases such as very small or singular row/column matrices.","solution":"def rotate_matrix_spiral(matrix): if not matrix or not matrix[0]: return n = len(matrix) m = len(matrix[0]) # Create temporary structure to store the rotated version rotated = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated[j][n - 1 - i] = matrix[i][j] # Replace the original matrix with the rotated structure matrix.clear() matrix.extend(rotated)"},{"question":"# Coding Assessment Question: Detect Cycles in a Directed Graph Scenario You are tasked with implementing a function to determine if a directed graph contains a cycle. Each node in the graph is labeled with a unique integer, and the graph is represented as an adjacency list. Function Signature ```python def has_cycle(graph: Dict[int, List[int]]) -> bool: pass ``` Input - `graph`: A dictionary where keys are node labels (integers) and values are lists of integers representing nodes to which the key node has a directed edge. Output - Returns a boolean value. `True` if the graph contains at least one cycle, `False` otherwise. Constraints - The graph will have at most 1000 vertices. - Vertices are labeled with unique integers from 0 to n-1 (if there are n vertices). Performance Requirements - The solution should efficiently handle graphs with up to 1000 vertices. - Aim for a time complexity of O(V + E) and space complexity of O(V). Example ```python graph1 = { 0: [1], 1: [2], 2: [0], 3: [4], 4: [] } # There is a cycle: 0 -> 1 -> 2 -> 0 assert has_cycle(graph1) == True graph2 = { 0: [1], 1: [2], 2: [3], 3: [] } # There are no cycles assert has_cycle(graph2) == False ``` Detailed Steps 1. Initialize sets to track visited nodes and nodes currently in the recursion stack. 2. Define a helper function to perform Depth-First Search (DFS) to detect cycles: - If a node is not in the visited set, mark it as visited and add it to the recursion stack. - Traverse all adjacent nodes. - If an adjacent node is in the recursion stack, a cycle is detected. - If the adjacent node was not visited, recursively perform DFS on it. - After visiting all adjacent nodes, remove the current node from the recursion stack. 3. Iterate over each node in the graph and apply the DFS-based cycle detection. 4. If no cycles are detected after processing all nodes, return `False`. Edge Cases - Handle graphs with no edges (no cycles possible). - Handle fully connected graphs (possible cycles dependent on the direction of edges). - Make sure to handle isolated nodes appropriately. # Implementation Notes Implement the DFS to detect cycles efficiently by keeping track of nodes in the current recursion stack. Utilize recursive or iterative approaches as needed to ensure all nodes are processed correctly and cycles are accurately identified. Ensure that all nodes are processed exactly once and that the solution can handle large graphs efficiently.","solution":"def has_cycle(graph): This function detects if a directed graph contains a cycle. :param graph: Dictionary representing the directed graph as an adjacency list. :return: Boolean True if the graph contains at least one cycle, False otherwise. visited = set() rec_stack = set() def dfs(node): if node not in visited: visited.add(node) rec_stack.add(node) if node in graph: for neighbor in graph[node]: if neighbor not in visited and dfs(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(node) return False for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"```markdown You are tasked with enhancing the function `delete_key_from_dict` to improve its functionality and safety. The original function attempts to delete a key from a dictionary but lacks comprehensive handling of various edge cases and error conditions. Objective Refactor the function `delete_key_from_dict` to: 1. Handle scenarios where the key might not be present. 2. Ensure the function operates safely without modifying the input dictionary directly. 3. Provide informative feedback about the success or failure of the deletion. Requirements - **Input**: - `source_dict`: The dictionary from which the key should be deleted. - `key_to_delete`: The key that needs to be removed from the dictionary. - **Output**: - A tuple with the first element being a new dictionary with the specified key removed (if it exists) and the second element being a boolean indicating if the key was found and deleted. - **Constraints**: - Ensure the original `source_dict` remains unchanged. - Efficiently handle large dictionaries with potentially thousands of entries. Edge Cases & Error Handling - Handle situations where the `source_dict` is empty. - Manage cases where the `key_to_delete` does not exist in the `source_dict`. - Provide a clear indication of whether the deletion was successful. # Scenario You need a utility function to safely remove keys from a dictionary without altering the provided dictionary directly. This function is part of a larger library that manipulates dictionary data structures and needs to be robust against common issues. Function Signature ```python def delete_key_from_dict(source_dict: dict, key_to_delete: any) -> (dict, bool): # Your improved implementation here ``` Example Consider the dictionary `{\'a\': 1, \'b\': 2, \'c\': 3}` and key `\'b\'`. ```python new_dict, deleted = delete_key_from_dict({\'a\': 1, \'b\': 2, \'c\': 3}, \'b\') ``` The function should return: ```python ({\'a\': 1, \'c\': 3}, True) ``` If the key is not found: ```python new_dict, deleted = delete_key_from_dict({\'a\': 1, \'c\': 3}, \'b\') ``` The function should return: ```python ({\'a\': 1, \'c\': 3}, False) ``` ```","solution":"def delete_key_from_dict(source_dict: dict, key_to_delete: any) -> (dict, bool): Safely removes a key from a dictionary without modifying the original one. Parameters: source_dict (dict): The original dictionary from which the key should be deleted. key_to_delete (any): The key that needs to be removed from the dictionary. Returns: tuple: A new dictionary with the specified key removed (if it exists) and a boolean indicating if the key was found and deleted. if not isinstance(source_dict, dict): raise ValueError(\\"Input source_dict must be a dictionary.\\") new_dict = source_dict.copy() if key_to_delete in new_dict: del new_dict[key_to_delete] return new_dict, True return new_dict, False"},{"question":"# Context Sorting algorithms are fundamental to computer science, frequently used in various applications like organizing data, searching algorithms, and creating efficient structures such as heaps or balanced trees. One simple, yet important, sorting algorithm is the insertion sort. It builds the final sorted array one item at a time, iterating and inserting elements in place. # Problem Statement Write a Python function `insertion_sort(arr)` that takes a list of integers, `arr`, and sorts it in ascending order using the insertion sort algorithm. The function should modify the input list in place and return the sorted list. # Function Signature ```python def insertion_sort(arr: List[int]) -> List[int]: pass ``` # Input and Output * **Input**: - `arr` (List[int]): A list of integers to be sorted. * **Output**: - `List[int]`: The sorted list of integers in ascending order. # Constraints * The list `arr` may contain between 1 and 1000 integers. * The integers in `arr` can be positive, negative, or zero. # Performance Requirements Ensure that the function adheres to a time complexity of O(n^2) in the average and worst-case scenarios, which is inherent to the insertion sort algorithm. # Example ```python arr = [8, 4, 3, 7, 6, 1, 2, 5] sorted_arr = insertion_sort(arr) print(sorted_arr) # Expected output: [1, 2, 3, 4, 5, 6, 7, 8] ``` # Implementation Notes 1. Start with the second element (index 1) and compare it with the elements before it. 2. Swap and insert the element at the correct position within the sorted portion of the list. 3. Repeat this process for all elements in the list. 4. Given the constraints, an optimized and straightforward insertion sort implementation is sufficient.","solution":"from typing import List def insertion_sort(arr: List[int]) -> List[int]: Sorts the given list of integers in ascending order using the insertion sort algorithm. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: The same list of integers sorted in ascending order. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position. while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Prime Number Rearrangement **Objective**: Assess the student\'s ability to work with number theory concepts and practice their sorting and list manipulation skills within a programming context. **Task**: Write a Python function `rearrange_primes` that takes a list of integers, identifies all prime numbers within the list, and rearranges them in descending order while keeping the positions of non-prime numbers unchanged. **Function Signature**: ```python def rearrange_primes(numbers: List[int]) -> List[int]: Parameters: - numbers (List[int]): A list of integers containing both prime and non-prime numbers. Returns: - List[int]: A new list with prime numbers rearranged in descending order while non-prime numbers remain in their original positions. ``` **Input**: - A list of integers `numbers` containing both prime and non-prime values. **Output**: - A list where prime numbers are rearranged in descending order, but non-prime numbers remain in their initial positions. **Example**: ```python numbers = [10, 7, 2, 11, 4, 5, 8, 13] rearrange_primes(numbers) # Expected Output: # [10, 13, 11, 7, 4, 5, 8, 2] ``` **Constraints**: - An integer is considered prime if it is greater than 1 and has no divisors other than 1 and itself. - The list can contain up to 10^5 elements. - The integer values will fit in a typical 32-bit signed integer range. **Notes**: - The function should be optimized for performance given the potential size of the input list. - Implement helper functions where necessary to improve code readability and maintainability. **Testing**: - Include unit tests to cover various cases such as lists containing no primes, all primes, and mixed cases with different lengths and values.","solution":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n == 2: return True # 2 is the only even prime number if n % 2 == 0: return False # No other even number can be a prime for i in range(3, int(n**0.5) + 1, 2): # Odd numbers up to the square root of n if n % i == 0: return False return True def rearrange_primes(numbers: List[int]) -> List[int]: Rearranges primes in a list in descending order while keeping non-primes in the same positions. # Extract primes and their indices primes = [num for num in numbers if is_prime(num)] # Sort primes in descending order primes.sort(reverse=True) # Generate the result list result = [] prime_idx = 0 for num in numbers: if is_prime(num): result.append(primes[prime_idx]) prime_idx += 1 else: result.append(num) return result"},{"question":"# Task: Write a function named `date_difference` that calculates the number of days between two given dates. The function should support dates in the format of \\"YYYY-MM-DD\\". # Requirements: - The function should take two parameters: - `date1` (str): the starting date as a string. - `date2` (str): the ending date as a string. - The function should return the number of days between the two dates as an integer. - If an invalid date format is provided, the function should raise a `ValueError` with a descriptive error message. # Constraints: - Use the standard libraries for date handling to ensure accuracy. - Handle leap years, different month lengths, and other calendar complexities properly. # Examples: ```python >>> date_difference(\'2023-01-01\', \'2023-01-10\') 9 >>> date_difference(\'2020-02-01\', \'2020-03-01\') 29 >>> date_difference(\'2019-12-31\', \'2020-01-01\') 1 >>> date_difference(\'2023/01/01\', \'2023-01-10\') Traceback (most recent call last): ... ValueError: Invalid date format: \'2023/01/01\'. Expected format is \'YYYY-MM-DD\'. ```","solution":"from datetime import datetime def date_difference(date1, date2): Calculate the number of days between two dates. :param date1: Starting date in \'YYYY-MM-DD\' format :param date2: Ending date in \'YYYY-MM-DD\' format :return: Number of days between the two dates try: d1 = datetime.strptime(date1, \\"%Y-%m-%d\\") d2 = datetime.strptime(date2, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Invalid date format. Expected format is \'YYYY-MM-DD\'.\\") return abs((d2 - d1).days)"},{"question":"# Question Objective Create a function `remove_duplicates_preserve_order(input_list: List[Any]) -> List[Any]` that removes duplicate elements from the given list while preserving the order of the first occurrence of each element. Details 1. **Input**: A list of elements, which can be of any data type. 2. **Output**: A list with duplicates removed, retaining the original order of their first occurrence. Constraints * The function should return an empty list if the input list is empty. * The function should handle lists containing elements of mixed data types. Examples ```python >>> remove_duplicates_preserve_order([1, 2, 2, 3, 1, 4, 3]) [1, 2, 3, 4] >>> remove_duplicates_preserve_order([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\"]) [\\"apple\\", \\"banana\\", \\"orange\\"] >>> remove_duplicates_preserve_order([42, \\"hello\\", 42, \\"world\\", \\"hello\\"]) [42, \\"hello\\", \\"world\\"] >>> remove_duplicates_preserve_order([]) [] >>> remove_duplicates_preserve_order([True, False, True, True]) [True, False] ``` Hints - Consider using a data structure that maintains order while checking for duplicates. **Submit your implementation of `remove_duplicates_preserve_order` below:** ```python from typing import List, Any def remove_duplicates_preserve_order(input_list: List[Any]) -> List[Any]: seen = set() result = [] for item in input_list: if item not in seen: result.append(item) seen.add(item) return result ```","solution":"from typing import List, Any def remove_duplicates_preserve_order(input_list: List[Any]) -> List[Any]: Removes duplicate elements from the given list while preserving the order of the first occurrence of each element. Args: input_list (List[Any]): A list of elements which can be of any data type. Returns: List[Any]: A list with duplicates removed, retaining the original order of their first occurrence. seen = set() result = [] for item in input_list: if item not in seen: result.append(item) seen.add(item) return result"},{"question":"# Coding Question Context: You need to create a function that determines the smallest number of characters to be removed from a given string to make it a palindrome. A palindrome is a string that reads the same backward as forward. Function Specification: **Function Name:** `min_removals_to_palindrome` **Input:** - A string ( s ) consisting of lowercase letters. **Output:** - An integer representing the minimum number of characters to be removed from ( s ) to make it a palindrome. Constraints: - ( 1 leq |s| leq 10^4 ) - The input will be a non-empty string consisting only of lowercase letters. Example: ```python assert min_removals_to_palindrome(\\"abca\\") == 1 assert min_removals_to_palindrome(\\"racecar\\") == 0 assert min_removals_to_palindrome(\\"abcdef\\") == 5 assert min_removals_to_palindrome(\\"aabb\\") == 2 ``` Considerations: - Ensure the function handles edge cases such as single-character strings. - Optimize for readability and efficiency, as the length of the string can be up to 10,000 characters. **Special Notes:** - You might consider using dynamic programming to solve this problem efficiently. - Inputs like `min_removals_to_palindrome(\\"\\")` should raise `ValueError` since the function expects a non-empty string.","solution":"def min_removals_to_palindrome(s): Determines the smallest number of removals to make the given string a palindrome. :param s: A string consisting of lowercase letters. :return: An integer representing the minimum number of characters to be removed. if not s: raise ValueError(\\"Input string must be non-empty\\") n = len(s) # dp[i][j] represents the minimum number of removals to make s[i:j+1] a palindrome dp = [[0] * n for _ in range(n)] for length in range(2, n+1): # length ranges from 2 to n for i in range(n-length+1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = 1 + min(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"# Problem Statement You are assigned to extend the functionality of a binary search tree (BST) class implementation. Add a method `get_height` that computes the height of the binary search tree. The height of a tree is the number of edges on the longest downward path between the root and a leaf. # Function Signature ```python def get_height(self) -> int: ``` # Requirements 1. Implement the `get_height` method within the `BinarySearchTree` class. 2. If the tree is empty, the function should return 0. 3. Assume the node values are comparable. # Input/Output Format * **Input**: - No direct input. This function will be called on an instance of the `BinarySearchTree` class. * **Output**: - An integer representing the height of the tree, or 0 if the tree is empty. # Constraints - The function should have an O(n) time complexity, where n is the number of nodes in the tree. - Use recursion or iteration as appropriate. # Example ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) height = bst.get_height() # Output: 2 (The height of the BST is 2) ``` Demonstrate the handling of edge cases such as an empty tree, a tree with a single node, and a balanced vs. unbalanced tree. **Additional Notes**: - You can define any helper methods as needed within the class, as long as the primary method signature remains unchanged. - Ensure the method accurately computes the height for varied distributions of nodes in the tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def get_height(self) -> int: return self._get_height(self.root) def _get_height(self, node): if node is None: return 0 else: left_height = self._get_height(node.left) right_height = self._get_height(node.right) return max(left_height, right_height) + 1"},{"question":"# Coding Challenge # Problem Statement You are given a rectangular grid of integers where each cell contains a positive integer that represents the cost to pass through that cell. Your task is to find the minimum cost path from the top-left corner of the grid to the bottom-right corner. You can only move either down or right at any point in time. # Input - A list of lists representing the grid, where each inner list represents a row in the grid. - Guarantee: The grid will contain between 1 and 100 rows and between 1 and 100 columns. # Output - An integer representing the minimum path cost from the top-left to the bottom-right corner. # Example Input ```python [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` Output ``` 7 ``` # Explanation For the given example, the minimum path cost is 1 -> 3 -> 1 -> 1 -> 1 = 7. # Function Signature ```python def minimum_path_cost(grid: List[List[int]]) -> int: pass ``` # Constraints - 1 ≤ number of rows, number of columns ≤ 100 - All grid values are positive integers between 1 and 1000. # Scenario You are asked to optimize a route through a cost grid for an application that involves pathfinding in resource-limited environments. This task requires you to devise an algorithm that efficiently navigates through the grid while minimizing the cumulative cost. Consider efficiency to ensure performance within acceptable levels.","solution":"def minimum_path_cost(grid): This function calculates the minimum path cost from the top-left corner to the bottom-right corner of the given grid, moving only right or down. rows = len(grid) cols = len(grid[0]) # Initialize the DP table with the same dimensions as the grid dp = [[0 for _ in range(cols)] for _ in range(rows)] # Starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is in the bottom-right corner of the dp table return dp[rows-1][cols-1]"},{"question":"# Binary Search in Sorted Matrix Problem Statement: Write a Python function `search_in_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]` that performs a binary search on a 2D matrix to find the position of a target value. The matrix has the following properties: 1. Each row of the matrix is sorted in ascending order. 2. The first integer of each row is greater than the last integer of the previous row. The function should return the position of the target value as a tuple `(row_index, col_index)` if the target is found in the matrix. If the target is not found, the function should return `(-1, -1)`. Input and Output Format: - **Input**: * A 2D list `matrix` where each sub-list represents a row in a matrix, and all integers in the matrix are sorted as described above. * An integer `target` representing the value to search for in the matrix. - **Output**: * A tuple of two integers representing the row and column indices of the target value if found, or `(-1, -1)` if the target is not found. Constraints: - The matrix is non-empty, and its elements are distinct integers. - The number of rows (m) and the number of columns (n) can be large, making efficiency in time and space crucial. - Example searches: ```python search_in_matrix([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 9) # should return (1, 1) search_in_matrix([[1, 3, 5], [7, 9, 11], [13, 15, 17]], 6) # should return (-1, -1) search_in_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 8) # should return (2, 1) search_in_matrix([[10, 20, 30], [40, 50, 60]], 20) # should return (0, 1) ``` Requirements: 1. Implement the binary search such that the time complexity is O(log(m * n)). 2. Handle both positive and negative integers in the matrix. 3. Ensure the function works efficiently for large input sizes. # Sample Function Signature ```python def search_in_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: pass ```","solution":"def search_in_matrix(matrix, target): if not matrix or not matrix[0]: return -1, -1 m, n = len(matrix), len(matrix[0]) left, right = 0, m * n - 1 while left <= right: mid = (left + right) // 2 mid_value = matrix[mid // n][mid % n] if mid_value == target: return mid // n, mid % n elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1, -1"},{"question":"# Problem Statement You are required to implement a tree traversal algorithm and enhance it with additional functionality. The given task provides the basic structure of a binary search tree (BST) and your role is to extend it with extra methods for in-depth operations. # Requirements 1. Implement a method `inorder_successor` that finds the inorder successor of a given node\'s value in the BST. If the node has no inorder successor, return `None`. 2. Implement a method `path_to_node` that returns a list representing the path from the root to a specified node\'s value in the BST. If the node is not present, return an empty list. 3. Implement a method `is_balanced` that checks if the BST is height-balanced. A tree is height-balanced if, for every node, the height difference of the left and right subtree is no more than 1. 4. Introduce an error handling mechanism in the `delete` method to raise an exception when trying to delete a node that does not exist in the BST. # Provided Code The given implementation includes a `Node` class and a `BST` class with basic methods. You need to add the following methods to the `BST` class accordingly. # Function Signatures ```python def inorder_successor(self, value: int) -> int: pass def path_to_node(self, value: int) -> List[int]: pass def is_balanced(self) -> bool: pass def delete(self, value: int) -> None: pass ``` # Input and Output Formats * **inorder_successor**: - **Input**: One integer input `value`. - **Output**: The value of the inorder successor node, or `None` if not exists. * **path_to_node**: - **Input**: One integer input `value`. - **Output**: A list of integers representing the path to the node. * **is_balanced**: - **Input**: No additional input. - **Output**: Boolean indicating if the tree is height-balanced. * **delete**: - **Input**: One integer input `value`. - **Output**: Raises an exception if the node does not exist, else performs deletion. # Constraints 1. Your solution should efficiently handle large BSTs. 2. Aim to keep methods within their respective time complexities. 3. Ensure methods accurately handle cases with nodes being absent or when the tree structure is empty. 4. The BST should maintain the unique properties of a binary search tree. # Scenario Alice is working with binary search trees and needs to perform various operations for her development work. She seeks ways to find successors, trace paths to nodes, ensure the tree remains balanced, and responsibly handle deletions. Implementing these methods will help Alice streamline her process. # Usage Example ```python bst = BST() values = [20, 10, 30, 5, 15, 25, 35] for v in values: bst.insert(v) print(bst.inorder_successor(15)) # Output: 20 print(bst.path_to_node(25)) # Output: [20, 30, 25] print(bst.is_balanced()) # Output: True bst.delete(5) print(bst.inorder_successor(5)) # Output: 10 try: bst.delete(100) # Raises exception except Exception as e: print(str(e)) ``` To implement the `inorder_successor`, `path_to_node`, `is_balanced`, and error handling in the `delete` method, integrate them into your `BST` class and test with the provided scenarios.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = Node(key) else: self._insert(node.left, key) else: if node.right is None: node.right = Node(key) else: self._insert(node.right, key) def find(self, key): return self._find(self.root, key) def _find(self, node, key): if node is None or node.val == key: return node if key < node.val: return self._find(node.left, key) return self._find(node.right, key) def inorder_successor(self, value): node = self.find(value) if node is None: return None # Case 1: Node has a right child if node.right: return self._min_value_node(node.right).val # Case 2: No right child, find the deepest ancestor for which given node would be in left subtree successor = None ancestor = self.root while ancestor != node: if node.val < ancestor.val: successor = ancestor ancestor = ancestor.left else: ancestor = ancestor.right return successor.val if successor else None def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def path_to_node(self, value): path = [] found = self._path_to_node(self.root, value, path) return path if found else [] def _path_to_node(self, node, value, path): if node is None: return False path.append(node.val) if node.val == value: return True if (node.left and self._path_to_node(node.left, value, path)) or (node.right and self._path_to_node(node.right, value, path)): return True path.pop() return False def is_balanced(self): return self._is_balanced(self.root)[0] def _is_balanced(self, node): if node is None: return (True, 0) left_balanced, left_height = self._is_balanced(node.left) right_balanced, right_height = self._is_balanced(node.right) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return (current_balanced, 1 + max(left_height, right_height)) def delete(self, value): if self.root is None: raise Exception(f\\"Node with value {value} does not exist\\") self.root = self._delete(self.root, value) def _delete(self, root, key): if root is None: raise Exception(f\\"Node with value {key} does not exist\\") if key < root.val: root.left = self._delete(root.left, key) elif key > root.val: root.right = self._delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self._min_value_node(root.right) root.val = temp.val root.right = self._delete(root.right, temp.val) return root"},{"question":"# Coding Challenge: Implementing a Custom Sorting Algorithm Objective Design and implement a custom sorting algorithm called \\"Reverse Selection Sort\\" which sorts a list of integers in ascending order by selecting the largest element and placing it at the end of the list in each iteration. Problem Statement Create a function `reverse_selection_sort(arr: List[int]) -> List[int]` that takes a list of integers and returns a new list sorted in ascending order using the Reverse Selection Sort algorithm. Function Signature ```python from typing import List def reverse_selection_sort(arr: List[int]) -> List[int]: # Your code here ``` Input - `arr`: a list of integers `arr` (0 <= len(arr) <= 10^5) - the list of integers to be sorted. Output - Returns a new list of integers sorted in ascending order. Constraints - The input list can be empty, in which case the function should return an empty list. - The sorting algorithm must be implemented manually; use of Python\'s built-in sorting functions is not allowed. Example ```python >>> reverse_selection_sort([64, 34, 25, 12, 22, 11, 90]) [11, 12, 22, 25, 34, 64, 90] >>> reverse_selection_sort([5, 4, 3, 2, 1]) [1, 2, 3, 4, 5] >>> reverse_selection_sort([]) [] ``` Detailed Instructions 1. Iterate over the list to find the maximum element and place it at the last unsorted position. 2. Repeat the process for the remaining unsorted portion of the list, excluding the last sorted elements. 3. Continue until the entire list is sorted in ascending order. 4. Ensure the function handles an empty list gracefully. Optimization Tips - Keep track of the sorted portion of the list to avoid unnecessary comparisons. - Minimize swaps by only swapping the maximum element with the last unsorted element. Edge Cases to Consider - Handling of an empty list. - Lists with one element. - Lists that are already sorted in ascending or descending order. - Lists with duplicate elements.","solution":"from typing import List def reverse_selection_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n-1, 0, -1): max_index = 0 for j in range(1, i+1): if arr[j] > arr[max_index]: max_index = j arr[i], arr[max_index] = arr[max_index], arr[i] return arr"},{"question":"# Problem Statement Context In a financial application, you need to analyze the trends of stock prices across multiple days to identify local maxima and minima. This information helps in making decisions when to buy or sell stocks. Task Implement a function that identifies all local peaks and valleys in a given list of stock prices. A local peak is defined as a price that is higher than its immediate neighbors, and a local valley is defined as a price that is lower than its immediate neighbors. Function Signature ```python def find_peaks_valleys(prices: list) -> list: pass ``` Input Format - A list `prices` of integers where: * `2 <= len(prices) <= 10^6` * `1 <= prices[i] <= 10^9` Output Format - A list of tuples representing the positions (indices) and values of all identified local peaks and valleys: * If there are no peaks or valleys, return an empty list. Constraints - You should only consider peaks and valleys that are true local extrema (not including boundary elements unless they qualify as extrema). Example ```python assert find_peaks_valleys([100, 200, 150, 250, 150, 300, 100]) == [(1, 200), (2, 150), (3, 250), (4, 150), (5, 300)] assert find_peaks_valleys([1, 2, 3, 4, 5]) == [] assert find_peaks_valleys([5, 4, 3, 2, 1]) == [] assert find_peaks_valleys([3, 2, 3]) == [(0, 3), (1, 2), (2, 3)] ``` Requirements - Ensure your solution is optimized for large input sizes. - Avoid false positives by strictly adhering to the definition of local peaks and valleys. Notes - The input list will always contain at least two elements. - Indices returned should be 0-based, referring to the position in the original list.","solution":"def find_peaks_valleys(prices): Identifies all local peaks and valleys in the given list of stock prices. A local peak is a price higher than its neighbors, and a local valley is a price lower than its neighbors. Returns a list of tuples of the form (index, value). if len(prices) < 2: # If there are less than 2 prices, no peaks or valleys can be found. return [] result = [] for i in range(1, len(prices) - 1): if prices[i-1] < prices[i] > prices[i+1]: result.append((i, prices[i])) elif prices[i-1] > prices[i] < prices[i+1]: result.append((i, prices[i])) return result"},{"question":"# Sorting Large List with Limited Memory You are given a list of integers that might be too large to fit into memory all at once. Your task is to create a function that can sort this list efficiently using limited memory. You will achieve this by splitting the list into manageable chunks, sorting each chunk individually, and then merging the sorted chunks. Problem Requirements: 1. **split_and_sort_chunks**: Split the input list into chunks of a given size, sort each chunk, and save the sorted chunks to disk. 2. **merge_sorted_files**: Merge the sorted chunks from disk back into a single sorted list. # Specification Method Signature ```python def split_and_sort_chunks(input_list: list[int], chunk_size: int) -> list[str] def merge_sorted_files(chunk_files: list[str]) -> list[int] ``` Input - **split_and_sort_chunks**: - `input_list`: The list of integers to be sorted. - `chunk_size`: The maximum size of each chunk. - **merge_sorted_files**: - `chunk_files`: A list of filenames corresponding to sorted chunk files on disk. Output - **split_and_sort_chunks**: - Returns a list of filenames where each file contains a sorted chunk. - **merge_sorted_files**: - Returns a single list of all integers in sorted order, merged from the sorted chunk files. Constraints - The input list may contain up to (10^7) integers. - Each chunk should be sorted using an efficient in-memory sorting algorithm. - The solution should be efficient in terms of both time and space complexity. Example: ```python input_list = [38, 27, 43, 3, 9, 82, 10] chunk_size = 3 # Split and sort the chunks, save to disk chunk_files = split_and_sort_chunks(input_list, chunk_size) # Merge the sorted chunk files sorted_list = merge_sorted_files(chunk_files) assert sorted_list == [3, 9, 10, 27, 38, 43, 82] ``` # Implementation Details 1. **split_and_sort_chunks**: - Split the input list into chunks of size `chunk_size`. - Sort each chunk and write them to separate files. - Return the list of filenames. 2. **merge_sorted_files**: - Open each sorted chunk file and perform a k-way merge to obtain the final sorted list. - Make sure to handle file I/O and efficient merging to keep memory usage minimal. Implement both functions to facilitate sorting large lists efficiently with limited memory.","solution":"import os import heapq def split_and_sort_chunks(input_list, chunk_size): sorted_chunk_files = [] num_chunks = (len(input_list) + chunk_size - 1) // chunk_size # Calculate number of chunks for i in range(num_chunks): chunk = input_list[i * chunk_size:(i + 1) * chunk_size] chunk.sort() # Sort the chunk in memory filename = f\\"chunk_{i}.txt\\" # Write the sorted chunk to a file with open(filename, \\"w\\") as f: for num in chunk: f.write(f\\"{num}n\\") sorted_chunk_files.append(filename) return sorted_chunk_files def merge_sorted_files(chunk_files): min_heap = [] file_handlers = [] sorted_list = [] # Open all files and read the first element, populate the heap for filename in chunk_files: f = open(filename, \\"r\\") file_handlers.append(f) num = int(f.readline().strip()) heapq.heappush(min_heap, (num, f)) # Perform k-way merge while min_heap: num, file_handle = heapq.heappop(min_heap) sorted_list.append(num) line = file_handle.readline() if line: num = int(line.strip()) heapq.heappush(min_heap, (num, file_handle)) # Close all file handlers for f in file_handlers: f.close() return sorted_list # For clean up purposes — remove generated files after usage def clean_up_files(files): for file in files: os.remove(file)"},{"question":"# Sum of Unique Elements **Context**: Working with arrays, it can be useful to identify and sum elements that appear exactly once. This can provide insights into non-repeated values in datasets. # Task: Write a function `sum_of_unique_elements` which takes a list of integers and returns the sum of all unique elements, i.e., elements that appear exactly once in the list. # Requirements: 1. **Input**: A list of integers. (e.g., `[1, 2, 2, 3, 4, 4, 5, 6, 6]`) 2. **Output**: An integer representing the sum of unique elements. 3. **Constraints**: - The input list can contain up to (10^5) elements. - Each element in the list can range from (-10^6) to (10^6). # Examples: 1. **Example 1**: ```python sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5, 6, 6]) ``` **Output**: `9` *(Unique elements are [1, 3, 5], so the sum is 1 + 3 + 5 = 9)*. 2. **Example 2**: ```python sum_of_unique_elements([7, 7, 8, 9, 10, 10, 11]) ``` **Output**: `28` *(Unique elements are [8, 9, 11], so the sum is 8 + 9 + 11 = 28)*. 3. **Example 3**: ```python sum_of_unique_elements([-1, -1, 2, 2, 3, 3, 0]) ``` **Output**: `0` *(Unique element is [0], so the sum is 0)*. ```python def sum_of_unique_elements(nums: list[int]) -> int: Calculates the sum of all unique elements in the input list. :param nums: List of integers. :return: Sum of unique elements in the list. Example: >>> sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5, 6, 6]) 9 >>> sum_of_unique_elements([7, 7, 8, 9, 10, 10, 11]) 28 >>> sum_of_unique_elements([-1, -1, 2, 2, 3, 3, 0]) 0 pass if __name__ == \\"__main__\\": from doctest import testmod testmod() ``` Test your function with provided examples and add more edge cases to ensure robustness.","solution":"def sum_of_unique_elements(nums): Calculates the sum of all unique elements in the input list. :param nums: List of integers. :return: Sum of unique elements in the list. Example: >>> sum_of_unique_elements([1, 2, 2, 3, 4, 4, 5, 6, 6]) 9 >>> sum_of_unique_elements([7, 7, 8, 9, 10, 10, 11]) 28 >>> sum_of_unique_elements([-1, -1, 2, 2, 3, 3, 0]) 0 from collections import Counter # Count the frequency of each element in the list counts = Counter(nums) # Sum elements that appear exactly once return sum(num for num, count in counts.items() if count == 1)"},{"question":"Graph Traversal and Pathfinding # Objective: You are provided with a Python representation of a directed weighted graph using an adjacency list. Your task is to implement functionality for finding the shortest path from a given start node to a target node using Dijkstra\'s Algorithm. # Requirements: 1. **Function Definition**: Create a function `find_shortest_path(graph, start_node, target_node)` that performs Dijkstra\'s Algorithm. 2. **Path Backtracking**: Modify the algorithm to return both the shortest path length and the actual sequence of nodes. 3. **Edge Handling**: Ensure that invalid nodes (nodes not present in the graph) or disjoint graph components (where no path exists) are appropriately handled with error messages. # Input & Output Format: - **Input**: - A graph represented by an adjacency list: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } ``` - Two strings representing the start node and the target node. - **Output**: - If a path exists: - Print the shortest path length and the sequence of nodes. - If no path exists or the nodes are invalid: - Print an appropriate error message. # Examples: ```python # Example Graph graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } # Example Call find_shortest_path(graph, \'A\', \'D\') # Expected Output: # Shortest path from A to D is [\'A\', \'B\', \'C\', \'D\'] with total distance 4 # Invalid Node Example Call find_shortest_path(graph, \'A\', \'E\') # Expected Output: # Error: Target node not found in the graph. # Disjoint Graph Example Call find_shortest_path(graph, \'A\', \'Z\') # Expected Output: # Error: No path exists from A to Z. ``` # Constraints: - The graph will have a maximum of 1000 nodes and 10,000 edges. - All edge weights are positive integers. - Inputs are case-sensitive, with node names being unique strings. # Performance: - The implementation should efficiently handle the constraints and provide results in a reasonable time frame, leveraging the properties of Dijkstra\'s Algorithm. Implement the above requirements to complete the pathfinding functionality in the provided graph and verify your implementation with the provided examples and edge cases.","solution":"import heapq def find_shortest_path(graph, start_node, target_node): Find the shortest path from start_node to target_node using Dijkstra\'s algorithm. Return both the shortest path length and the actual sequence of nodes. if start_node not in graph: return \\"Error: Start node not found in the graph.\\" if target_node not in graph: return \\"Error: Target node not found in the graph.\\" # Priority queue to store (distance, node) queue = [(0, start_node)] distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 previous_nodes = {node: None for node in graph} while queue: current_distance, current_node = heapq.heappop(queue) # If we reach the target node, we can reconstruct the path if current_node == target_node: path = [] while current_node: path.insert(0, current_node) current_node = previous_nodes[current_node] return f\\"Shortest path from {start_node} to {target_node} is {path} with total distance {current_distance}\\" if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) return f\\"Error: No path exists from {start_node} to {target_node}.\\""},{"question":"Question Suppose you are working on a project that involves storing and compressing file metadata. One common compression technique involves using a run-length encoding (RLE) algorithm. Write a function to implement the RLE algorithm which compresses a given string by replacing sequences of the same character with that character followed by the count of repetitions. # Function Signature ```python def run_length_encode(input_string: str) -> str: pass ``` # Input * A single string `input_string` (0 ≤ len(input_string) ≤ 10^5), consisting of printable ASCII characters. # Output * A string representing the run-length encoded version of the input string. # Constraints * The function should handle both upper and lower case letters. * Handle edge cases such as an empty string or where all characters in the string are unique. # Examples ```python >>> run_length_encode(\'aaabbcc\') \'a3b2c2\' >>> run_length_encode(\'abcd\') \'a1b1c1d1\' >>> run_length_encode(\'\') \'\' ``` # Scenario Run-length encoding is particularly effective for compressing data containing many contiguous repeated values. For example, image data, simplified DNA sequences, or even basic text where characters can repeat consecutively. The intention with this function is to provide a simple yet effective way of reducing the size of such data sets before transmission or storage. # Notes Implement the RLE function ensuring it efficiently handles varied input lengths, including extremely large strings. The encoding should be precise and correctly represent consecutive character counts. For instance, the RLE for a string \'aabb\' should be \'a2b2\', adhering to the expected format.<|vq_14882|>","solution":"def run_length_encode(input_string: str) -> str: Compresses the input string using Run Length Encoding algorithm. Parameters: - input_string (str): A string consisting of printable ASCII characters. Returns: - str: The run-length encoded string. if not input_string: return \\"\\" encoded_string = [] count = 1 for i in range(1, len(input_string)): if input_string[i] == input_string[i - 1]: count += 1 else: encoded_string.append(input_string[i - 1] + str(count)) count = 1 encoded_string.append(input_string[-1] + str(count)) return \'\'.join(encoded_string)"},{"question":"# Coding Assessment Question Context: You are required to develop a function that performs matrix multiplication. Multiplying two matrices involves taking the dot product of rows and columns and summing the results. Ensure your solution handles typical edge cases, such as incompatible matrix dimensions for multiplication. Task: Implement the function `matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` which: 1. Accepts two 2D lists of integers representing matrices A and B. 2. Returns a 2D list of integers representing the resultant matrix after multiplying A and B. Input: - `A`: A 2D list of integers of size `m x n` where each element is an integer. - `B`: A 2D list of integers of size `n x p` where each element is an integer. Output: - A 2D list of integers representing the resultant matrix of size `m x p`. Constraints: 1. `1 <= m, n, p <= 50` 2. Each element of the matrices is an integer within the range `-100 <= element <= 100`. 3. The number of columns in matrix A (n) must be equal to the number of rows in matrix B (n). Example: ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiply(A, B) == [ [58, 64], [139, 154] ] ``` Note: Handle errors appropriately for cases where the dimensions of A and B do not allow for matrix multiplication. You may use the following function skeleton: ```python def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ```","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Check if the number of columns in A is equal to the number of rows in B if len(A[0]) != len(B): raise ValueError(\\"Incompatible dimensions for matrix multiplication\\") # Number of rows in A, columns in B, and columns in A (or rows in B) m, n, p = len(A), len(B), len(B[0]) # Create an empty result matrix of dimensions m x p filled with zeroes result = [[0 for _ in range(p)] for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Context You are developing a library function to process and filter network request logs. Each log entry is a string containing information regarding a single request, including the request type, timestamp, and the requested resource. The logs need to be filtered based on a specific request type, and sorted by timestamps before returning a structured format. # Task Your task is to implement a function that takes a list of log entries and a request type, filters the logs by the given request type, sorts the filtered logs by their timestamps, and returns them in a structured format. # Function to Implement ```python def filter_and_sort_logs(logs: list[str], request_type: str) -> list[dict]: Args: logs: A list of strings, where each string is a log entry in the format \\"request_type timestamp resource\\". request_type: A string representing the type of requests to filter (e.g., \\"GET\\", \\"POST\\", \\"PUT\\"). Returns: A list of dictionaries where each dictionary represents a filtered log entry in the format: { \'request_type\': str, \'timestamp\': str, \'resource\': str } The list should be sorted by the \'timestamp\' values. pass ``` # Expected Constraints and Limitations - The timestamp format can be assumed to be consistent and comparable lexicographically (e.g., ISO 8601 format). - The input list `logs` can contain up to 100,000 entries. # Requirements - Filter the log entries based on the provided `request_type`. - Sort the filtered log entries by their timestamps in ascending order. - Return the structured log entries as a list of dictionaries. # Example ```python logs = [ \\"GET 2023-10-01T14:53:00Z /index.html\\", \\"POST 2023-10-01T14:54:00Z /form\\", \\"GET 2023-10-01T14:55:00Z /about.html\\", \\"GET 2023-09-30T10:00:00Z /home\\", \\"POST 2023-09-30T10:01:00Z /submit\\", ] request_type = \\"GET\\" output = filter_and_sort_logs(logs, request_type) print(output) # Expected Output: # [ # {\'request_type\': \'GET\', \'timestamp\': \'2023-09-30T10:00:00Z\', \'resource\': \'/home\'}, # {\'request_type\': \'GET\', \'timestamp\': \'2023-10-01T14:53:00Z\', \'resource\': \'/index.html\'}, # {\'request_type\': \'GET\', \'timestamp\': \'2023-10-01T14:55:00Z\', \'resource\': \'/about.html\'} # ] ```","solution":"def filter_and_sort_logs(logs: list[str], request_type: str) -> list[dict]: Args: logs: A list of strings, where each string is a log entry in the format \\"request_type timestamp resource\\". request_type: A string representing the type of requests to filter (e.g., \\"GET\\", \\"POST\\", \\"PUT\\"). Returns: A list of dictionaries where each dictionary represents a filtered log entry in the format: { \'request_type\': str, \'timestamp\': str, \'resource\': str } The list should be sorted by the \'timestamp\' values. # Filter the logs based on the request_type filtered_logs = [ log for log in logs if log.startswith(request_type) ] # Extract the components for each log and convert them into dictionaries formatted_logs = [ { \'request_type\': log.split()[0], \'timestamp\': log.split()[1], \'resource\': \\" \\".join(log.split()[2:]) } for log in filtered_logs ] # Sort the logs by the timestamp component sorted_logs = sorted(formatted_logs, key=lambda x: x[\'timestamp\']) return sorted_logs"},{"question":"# Assessment Question: Context: You are creating a software for a library system that manages books and their details. One of the functionalities you need to implement is the ability to calculate the similarity between two books based on their titles. The similarity is defined as the length of the longest common subsequence (LCS) between the titles of the two books. Task: Implement a function that calculates the length of the longest common subsequence between two given book titles. # Function Signature: ```python def lcs_length(title1: str, title2: str) -> int: ``` # Input: - `title1`: a string representing the title of the first book. - `title2`: a string representing the title of the second book. # Output: - Return an integer representing the length of the longest common subsequence between the two titles. # Constraints: - The lengths of `title1` and `title2` can range from 1 to 1,000. - The titles will consist of lowercase and uppercase English letters and spaces. # Example: ```python >>> lcs_length(\\"Introduction to Algorithms\\", \\"Algorithmics\\") 10 >>> lcs_length(\\"Data Structures\\", \\"Algorithms\\") 3 ``` # Requirements: - Develop an efficient algorithm to find the longest common subsequence. - Optimize the function to handle the upper limit of input sizes. Notes: - The input and output formats should match the examples. - Ensure your function runs efficiently with the given constraints.","solution":"def lcs_length(title1: str, title2: str) -> int: Calculates the length of the longest common subsequence between two book titles. m, n = len(title1), len(title2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if title1[i - 1] == title2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# String Manipulation and Encoding You are tasked with implementing functions to manipulate and encode strings according to specific rules. The functions should handle various input scenarios and edge cases while maintaining efficiency. Requirements 1. **String Reversal**: - Implement the `reverse_string` function that takes an input string and returns its reversed version. - Handle cases where the input string is empty or very large. 2. **String to ASCII Conversion**: - Implement the `string_to_ascii` function that converts each character in the input string to its corresponding ASCII value and returns a list of these values. - Ensure to handle any non-printable or special characters appropriately. 3. **Base64 Encoding**: - Implement the `base64_encode` function to encode a given input string into its Base64 representation. - Handle inputs with various lengths and ensure the encoded string is properly padded with \'=\' characters. Function Signatures ```python def reverse_string(input_str: str) -> str: pass def string_to_ascii(input_str: str) -> list: pass def base64_encode(input_str: str) -> str: pass ``` Input and Output Formats - **String Reversal**: - **Input**: `input_str` (str) – a string to be reversed - **Output**: `str` – the reversed string - **String to ASCII Conversion**: - **Input**: `input_str` (str) – a string to convert to ASCII values - **Output**: `list` of `int` – list of ASCII values for each character in the input string - **Base64 Encoding**: - **Input**: `input_str` (str) – a string to be encoded in Base64 - **Output**: `str` – the Base64 encoded string Constraints - The input string for all functions should be non-None. - The functions should handle strings of varying lengths efficiently. - The ASCII conversion should ensure it handles non-printable and special characters properly. Performance Requirements All operations should be performed in linear time O(n) with respect to the length of the input string. Example Usage ```python print(reverse_string(\\"hello\\")) # Output: \\"olleh\\" print(string_to_ascii(\\"hello\\")) # Output: [104, 101, 108, 108, 111] print(base64_encode(\\"hello\\")) # Output: \\"aGVsbG8=\\" ``` Implement the given functions based on these details while adhering to the input-output formats, constraints, and performance requirements.","solution":"import base64 def reverse_string(input_str: str) -> str: Returns the reversed version of the input string. return input_str[::-1] def string_to_ascii(input_str: str) -> list: Converts each character in the input string to its corresponding ASCII value. Returns a list of these values. return [ord(char) for char in input_str] def base64_encode(input_str: str) -> str: Encodes the input string into its Base64 representation. encoded_bytes = base64.b64encode(input_str.encode()) return encoded_bytes.decode()"},{"question":"# Scenario You are tasked with developing a feature for a library management system that categorizes books based on their genres for efficient retrieval. Each book in the library can belong to multiple genres, and the system needs to recognize the genres associated with each book and update its catalog accordingly. # Task You need to write two functions, `add_genre` and `get_books_by_genre`, to manage the genres of books in the library. # Details 1. **add_genre(book: str, genre: str) -> None**: * Takes the name of a book and a genre, and associates the book with the given genre. * If the book already has this genre, it should not be duplicated. 2. **get_books_by_genre(genre: str) -> list**: * Takes a genre and returns a list of book names associated with that genre. * If no books are found for the genre, return an empty list. # Input and Output * **Input Format**: * The input for `add_genre` consists of a string `book` and a string `genre`. * The input for `get_books_by_genre` consists of a string `genre`. * **Output Format**: * The `add_genre` function does not return anything. * The `get_books_by_genre` function returns a list of strings. # Constraints * `book` and `genre` are non-empty alphanumeric strings (no special characters other than space). * There can be at most 1000 distinct books and 100 different genres. * Case sensitivity should be considered (e.g., \\"Science\\" and \\"science\\" are different genres). # Examples * Example 1: ```python add_genre(\'The Great Gatsby\', \'Classic\') add_genre(\'The Great Gatsby\', \'Fiction\') get_books_by_genre(\'Classic\') # [\'The Great Gatsby\'] ``` * Example 2: ```python add_genre(\'1984\', \'Dystopian\') add_genre(\'1984\', \'Science Fiction\') add_genre(\'Dune\', \'Science Fiction\') get_books_by_genre(\'Science Fiction\') # [\'1984\', \'Dune\'] ``` # Additional Considerations 1. Ensure your solution handles edge cases correctly, such as adding the same book to multiple genres, retrieving genres with no associated books, or attempting to add a book to a non-existing genre. 2. Implement the functions with the ability to scale, ensuring efficient storage and retrieval of book-genre relationships.","solution":"from collections import defaultdict # Global dictionary to store books by genres genre_catalog = defaultdict(set) def add_genre(book: str, genre: str) -> None: Associates the specified book with the given genre. genre_catalog[genre].add(book) def get_books_by_genre(genre: str) -> list: Returns a list of books associated with the given genre. return list(genre_catalog[genre])"},{"question":"Linked List Cycle Detection and Removal You are given the head node of a singly linked list. Write two functions to detect a cycle in the linked list and to remove the cycle if it exists. Implement the functions as described below: Function Definitions: 1. **`detect_cycle(head: ListNode) -> bool`** - **Input**: head: ListNode - **Output**: boolean value indicating whether the linked list contains a cycle. 2. **`remove_cycle(head: ListNode) -> None`** - **Input**: head: ListNode - **Output**: None. This function modifies the linked list in place to remove the cycle. Constraints: - The number of nodes in the linked list is in the range [0, 1000]. - Each node has a unique integer value. Examples: 1. Given the linked list: ``` 3 -> 2 -> 0 -> -4 ^ | |_________| ``` - **detect_cycle(head)**: should return `True` - **remove_cycle(head)**: should modify the list to `3 -> 2 -> 0 -> -4` without the cycle 2. Given the linked list: ``` 1 -> 2 ^ | |____| ``` - **detect_cycle(head)**: should return `True` - **remove_cycle(head)**: should modify the list to `1 -> 2` without the cycle 3. Given the linked list: ``` 1 -> 2 -> 3 -> 4 ``` - **detect_cycle(head)**: should return `False` - **remove_cycle(head)**: should make no changes to the list Use the provided `ListNode` class for list construction: ```python from __future__ import annotations from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional[ListNode] = None): self.val = val self.next = next ``` Implement the given functions considering edge cases and optimizing for the constraints provided. Ensure that `remove_cycle` modifies the linked list in place and does not create a new linked list.","solution":"from __future__ import annotations from typing import Optional class ListNode: def __init__(self, val: int = 0, next: Optional[ListNode] = None): self.val = val self.next = next def detect_cycle(head: ListNode) -> bool: Detects whether there is a cycle in the linked list. slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(head: ListNode) -> None: Removes the cycle in the linked list if it exists. if not head or not head.next: return slow, fast = head, head # First step: detect the cycle contains_cycle = False while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: contains_cycle = True break if not contains_cycle: return # Second step: find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next # Now both pointers are at the start of the cycle # Third step: find the node just before the start of the cycle and break it ptr = slow while ptr.next != slow: ptr = ptr.next ptr.next = None"},{"question":"**Question 2: Merge Two Sorted Arrays** You are required to implement a function that merges two sorted arrays into a single sorted array. The function should take advantage of the fact that both input arrays are individually sorted and combine them with optimal performance. # Function Signature ```python def merge_sorted_arrays(arr1: list, arr2: list) -> list: Merges two sorted lists into a single sorted list. :param arr1: A sorted list of comparable items. :param arr2: Another sorted list of comparable items. :return: A single sorted list containing all elements from arr1 and arr2. ``` # Requirements 1. Implement the `merge_sorted_arrays` function that merges two input arrays which are already sorted individually. 2. The function should return a new merged list that is sorted in ascending order. 3. Ensure the function handles edge cases such as empty arrays appropriately. 4. The input arrays will always contain comparable items, but may contain different types (e.g., integers, strings, etc.). # Examples ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], [4, 5, 6]) [4, 5, 6] >>> merge_sorted_arrays([\'a\', \'c\', \'e\'], [\'b\', \'d\', \'f\']) [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([1], [1]) [1, 1] ``` # Constraints * Do not use any built-in sorting functions. * The function should have a time complexity of O(n + m), where n and m are the lengths of the input arrays. * The function should use O(n + m) additional space for the merged array. **Scenario/Context**: You are working on an application where merging sorted data from multiple sources is a frequent task. By leveraging the fact that the input data is already sorted, you aim to optimize the merging process to be both time-efficient and straightforward.","solution":"def merge_sorted_arrays(arr1: list, arr2: list) -> list: Merges two sorted lists into a single sorted list. :param arr1: A sorted list of comparable items. :param arr2: Another sorted list of comparable items. :return: A single sorted list containing all elements from arr1 and arr2. merged_array = [] i, j = 0, 0 # Traverse both arrays and insert smaller element from arr1 or arr2 # into the merged_array while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Collect remaining elements of arr1 if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Collect remaining elements of arr2 if any while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Question: Decode Encoded String You are given an encoded string where \\"N[substr]\\" denotes that the substring `substr` should be repeated `N` times. Write a function that takes this encoded string and returns its decoded version. The input string will always be well-formed according to the described format. Function Signature ```python def decode_string(s: str) -> str: ``` Input * `s` : A string representing the encoded message (1 <= len(s) <= 1000). Output * A string, representing the decoded version of the input. Constraints * The nested repetition is well-formed and can be nested up to multiple levels. * The input string only contains digit characters, brackets, and alphabetic characters (both uppercase and lowercase). Example ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" assert decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\" ```","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"# Question: Valid Triangle Checker You need to implement a function to validate whether three given lengths can form a valid triangle. A triangle is valid if the sum of any two sides is greater than the third side. Assume the input lengths are always positive integers. **Function Signature**: ```python def is_valid_triangle(a: int, b: int, c: int) -> bool: ``` **Input**: - `a` (int): The length of the first side. - `b` (int): The length of the second side. - `c` (int): The length of the third side. **Output**: - (bool): `True` if the given sides can form a triangle, otherwise `False`. **Constraints**: - All inputs are guaranteed to be positive integers. - The function should handle edge cases where the three lengths barely meet the criteria for a valid triangle. **Example**: ```python assert is_valid_triangle(3, 4, 5) == True assert is_valid_triangle(1, 1, 1) == True assert is_valid_triangle(1, 2, 3) == False assert is_valid_triangle(5, 5, 10) == False assert is_valid_triangle(5, 10, 12) == True assert is_valid_triangle(7, 10, 5) == True ``` **Explanation**: 1. For a given set of three sides `a`, `b`, and `c`, they can form a triangle if and only if they satisfy the following conditions: - `a + b > c` - `a + c > b` - `b + c > a` 2. The function should return `True` only if all three conditions are met. 3. Ensure simplicity and clarity in the implementation while covering possible edge cases.","solution":"def is_valid_triangle(a: int, b: int, c: int) -> bool: Returns True if the given side lengths can form a valid triangle, otherwise False. A triangle is valid if the sum of any two sides is greater than the third side. return a + b > c and a + c > b and b + c > a"},{"question":"# Question: Document Concordance Generator Context You are developing a text analysis tool that generates a concordance for a given document. A concordance is an alphabetical list of the principal words used in a text, typically with citations of the passages concerned. Task Write a function `generate_concordance` that: 1. Takes a string `document`, representing the entire text of the document. 2. Outputs a dictionary where each key is a unique word from the document (ignoring case), and the value is a list of tuples. Each tuple consists of a line number and the count of occurrences of that word in the respective line. Input - `document`: A string representing the text of the document. The document may contain multiple lines separated by newline characters (`\'n\'`). Output - A dictionary where each key is a word (in lowercase) from the document, and each value is a list of tuples (line_number, count). Performance Requirements - Time Complexity: O(n), where n is the total number of words. - Space Complexity: O(m), where m is the number of unique words. Constraints - Words are separated by spaces and can contain alphabetic characters only. - Words must be considered case-insensitive. Scenarios - For the document \\"The quick brown foxnjumps over the lazy dog.nThe quick brown fox.\\", the expected output dictionary is: ```python { \'the\': [(1, 1), (2, 1), (3, 1)], \'quick\': [(1, 1), (3, 1)], \'brown\': [(1, 1), (3, 1)], \'fox\': [(1, 1), (3, 1)], \'jumps\': [(2, 1)], \'over\': [(2, 1)], \'lazy\': [(2, 1)], \'dog\': [(2, 1)] } ``` - For the document \\"A quick movementnof the enemy willnjeopardize fivenof his gunboats.\\", the expected output dictionary is: ```python { \'a\': [(1, 1)], \'quick\': [(1, 1)], \'movement\': [(1, 1)], \'of\': [(2, 1), (4, 1)], \'the\': [(2, 1)], \'enemy\': [(2, 1)], \'will\': [(2, 1)], \'jeopardize\': [(3, 1)], \'five\': [(3, 1)], \'his\': [(4, 1)], \'gunboats\': [(4, 1)] } ``` Implementation You must define the below function: ```python def generate_concordance(document: str) -> dict: # Your code here ``` # Additional Information: - Ensure proper handling of newline characters. - Consider all words as case-insensitive. - Ignore any punctuation or numeric characters not specified in constraints.","solution":"def generate_concordance(document: str) -> dict: from collections import defaultdict import re # Prepare the final concordance dictionary concordance = defaultdict(list) # Split the document into lines, lower case lines = document.lower().split(\'n\') # Iterate through each line to build the concordance for line_num, line in enumerate(lines, start=1): # Split the line into words using regex to avoid punctuation words = re.findall(r\'b[a-z]+b\', line) word_count = defaultdict(int) # Count occurrences of each word in the current line for word in words: word_count[word] += 1 # Update the concordance dictionary for word, count in word_count.items(): concordance[word].append((line_num, count)) return dict(concordance)"},{"question":"# String Transformation and Validation Your task is to implement methods for transforming and validating strings as part of a text processing module. Specifically, you need to implement a function to reverse all words in a given string and a function to validate if a given string is a palindrome. **Function Signatures**: 1. `reverse_words(sentence: str) -> str` 2. `is_palindrome(word: str) -> bool` **Implementation Details**: 1. **reverse_words(sentence)**: * This function should take a single string `sentence` containing multiple words. * It should return a new string where each word in the original sentence is reversed, but the order of words remains the same. 2. **is_palindrome(word)**: * This function should take a single string `word`. * It should return a boolean value `True` if the word is a palindrome, and `False` otherwise. **Constraints**: * Input strings contain only alphanumeric characters and spaces. * Words within `sentence` are separated by single spaces. * Function `is_palindrome` should be case-insensitive and ignore non-alphanumeric characters. **Example**: ```python # Test reverse_words function sentence = \\"hello world\\" reversed_sentence = reverse_words(sentence) print(reversed_sentence) # Should print \\"olleh dlrow\\" # Test is_palindrome function word1 = \\"racecar\\" word2 = \\"hello\\" word3 = \\"A man, a plan, a canal, Panama\\" print(is_palindrome(word1)) # Should print True print(is_palindrome(word2)) # Should print False print(is_palindrome(word3)) # Should print True ``` # Edge Cases: * The `reverse_words` function should handle cases with only one word. * The `is_palindrome` function should handle empty strings and single-character strings. Implement these functions to extend the capabilities of the provided text processing module.","solution":"def reverse_words(sentence: str) -> str: Reverses each word in the given sentence, while keeping the order of words the same. return \' \'.join(word[::-1] for word in sentence.split()) def is_palindrome(word: str) -> bool: Checks if a given word or sentence is a palindrome, ignoring case and non-alphanumeric characters. import re filtered_word = re.sub(r\'[^a-zA-Z0-9]\', \'\', word).lower() return filtered_word == filtered_word[::-1]"},{"question":"# Problem Statement: You are tasked with implementing a `CountAndSaySequence` class that generates the nth term of the \\"count and say\\" sequence. The sequence is a series of strings where each term is generated by describing the previous term. # Requirements: * Implement the class `CountAndSaySequence` with a method `get_term` that takes an integer n and returns the nth term of the sequence as a string. * Ensure the solution efficiently handles the sequence construction and accurately follows the \\"count and say\\" rules. # Function Signature: ```python class CountAndSaySequence: def get_term(self, n: int) -> str: ``` # Expected Input: * An integer n, e.g., 5. # Expected Output: * A string representing the nth term in the \\"count and say\\" sequence, e.g., \\"111221\\". # Constraints: * 1 <= n <= 30 # Implementation Details: 1. The first term of the sequence is \\"1\\". 2. To generate each subsequent term, read the previous term and count the occurrences of consecutive digits. Then, produce a new term by describing it as the count followed by the digit. 3. Repeat this process iteratively until the nth term is produced. # Example: ```python >>> sequence_generator = CountAndSaySequence() >>> sequence_generator.get_term(1) \\"1\\" >>> sequence_generator.get_term(4) \\"1211\\" ``` # Notes: * Avoid overly complex recursive implementations; strive for an iterative approach. * Be mindful of memory usage, particularly with concatenating strings.","solution":"class CountAndSaySequence: def get_term(self, n: int) -> str: if n == 1: return \\"1\\" term = \\"1\\" for _ in range(2, n + 1): term = self._next_term(term) return term def _next_term(self, term: str) -> str: result = [] count = 1 for i in range(1, len(term)): if term[i] == term[i - 1]: count += 1 else: result.append(str(count) + term[i - 1]) count = 1 result.append(str(count) + term[-1]) # Append the last group return \\"\\".join(result)"},{"question":"# String Manipulation with Rotations Problem Statement You are working on a text processing tool that includes rotating strings as one of its functions. Given a string, you need to implement a function to perform left rotations and another function to perform right rotations. Your task is to implement two functions: `left_rotate` and `right_rotate`. Each function should return the string after performing the respective rotation. Function Specifications 1. **Function 1: `left_rotate(s: str, n: int) -> str`** * **Input**: * `s` - A string representing the text to be rotated. * `n` - An integer indicating the number of positions to rotate the string to the left. * **Output**: A string representing the text after performing the left rotation. 2. **Function 2: `right_rotate(s: str, n: int) -> str`** * **Input**: * `s` - A string representing the text to be rotated. * `n` - An integer indicating the number of positions to rotate the string to the right. * **Output**: A string representing the text after performing the right rotation. Constraints * The input string `s` consists of lowercase letters and/or digits only. * The integer `n` will always be greater than or equal to 0. * The rotations are circular, meaning that rotating a string \\"abc\\" left by 1 yields \\"bca\\" and right by 2 yields \\"cab\\". * The length of the string and the number of rotations are such that the operation can be done within a reasonable amount of time in a typical modern computer. Example ```python # Example 1 s = \\"abcdef\\" n = 2 left_rotated = left_rotate(s, n) # Expected output: \\"cdefab\\" right_rotated = right_rotate(s, n) # Expected output: \\"efabcd\\" # Example 2 s = \\"hello123\\" n = 5 left_rotated = left_rotate(s, n) # Expected output: \\"123hello\\" right_rotated = right_rotate(s, n) # Expected output: \\"o123hell\\" ``` **Note**: Ensure your solution handles edge cases, such as when `n` is 0, when `n` is greater than the length of the string, or when `s` is empty. Implement these functions and validate their correctness with various test cases.","solution":"def left_rotate(s: str, n: int) -> str: Returns the string after rotating it to the left by n positions. if len(s) == 0: return s n = n % len(s) return s[n:] + s[:n] def right_rotate(s: str, n: int) -> str: Returns the string after rotating it to the right by n positions. if len(s) == 0: return s n = n % len(s) return s[-n:] + s[:-n]"},{"question":"# Permutations of a String Coding Challenge Objective You are required to implement a function that generates all unique permutations of a given string. Problem Statement Implement the function `generate_permutations(s: str) -> List[str]` that returns all unique permutations of the input string. Input and Output * **Input**: * `s`: A string of length (n) consisting of lowercase alphabets. * **Output**: * Returns a list containing all unique permutations of the input string. Constraints * The length of the input string (1 leq n leq 8). Performance Requirement The function should generate all permutations in factorial time complexity (O(n!)), which is typical for permutation generation problems. Example ```python >>> generate_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> generate_permutations(\\"aab\\") [\'aab\', \'aba\', \'baa\'] >>> generate_permutations(\\"a\\") [\'a\'] >>> generate_permutations(\\"ab\\") [\'ab\', \'ba\'] ``` Note * Ensure that the output contains unique permutations. * The permutations can be returned in any order. Function Signature ```python from typing import List def generate_permutations(s: str) -> List[str]: # Your implementation here ``` Additional Information * Duplicate characters in the input string should not produce duplicate permutations in the output. * The function should be efficient with respect to memory usage and appropriately handle the given constraints. Implement the function `generate_permutations` to accomplish the task as described above.","solution":"from typing import List from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all unique permutations of a given string. :param s: Input string :return: List of unique permutations of the input string # Use permutations from itertools to generate all permutations perm_set = set(permutations(s)) # Convert each tuple to a string perm_list = [\'\'.join(p) for p in perm_set] return sorted(perm_list)"},{"question":"# Problem Statement You need to implement a text autocompletion feature using a trie (prefix tree) data structure. The algorithm will take a list of words and a prefix and return a list of all words from the given list that start with the specified prefix. Input - A list of strings `words` where each string represents a word. - A string `prefix` representing the prefix for autocompletion. Output - A list of strings containing all words that start with the given prefix. Function Signature ```python def autocomplete(words: List[str], prefix: str) -> List[str]: # Implementation here ``` # Constraints 1. The length of `words` will be between `1` and `10000`. 2. Each word in the list has a length between `1` and `100`. 3. `prefix` has a length between `1` and `100`. # Example Input ```python words = [\\"apple\\", \\"app\\", \\"application\\", \\"ape\\", \\"bat\\", \\"ball\\", \\"banana\\"] prefix = \\"app\\" ``` Output ```python [\\"apple\\", \\"app\\", \\"application\\"] ``` # Additional Information To solve this problem accurately: 1. Implement a `Trie` class to store the words efficiently. 2. Create methods to insert words into the trie and search for all words that start with the given prefix. 3. Ensure that the returned list is sorted in lexicographical order. ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_with_prefix(self, prefix: str) -> List[str]: def dfs(node: TrieNode, path: str, results: List[str]): if node.is_end_of_word: results.append(path) for char in sorted(node.children): dfs(node.children[char], path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results def autocomplete(words: List[str], prefix: str) -> List[str]: trie = Trie() for word in words: trie.insert(word) return trie.search_with_prefix(prefix) ```","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search_with_prefix(self, prefix: str) -> List[str]: def dfs(node: TrieNode, path: str, results: List[str]): if node.is_end_of_word: results.append(path) for char in sorted(node.children): dfs(node.children[char], path + char, results) node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] results = [] dfs(node, prefix, results) return results def autocomplete(words: List[str], prefix: str) -> List[str]: trie = Trie() for word in words: trie.insert(word) return trie.search_with_prefix(prefix)"},{"question":"# Coding Assessment Question Problem Description You are given an array of integers. Your task is to write a function that rearranges the elements of the array such that every element at an even index is greater than the adjacent elements at odd indexes. If the array is sorted, the elements at even indexes should be the largest elements available. Function Signature ```python def rearrange_array(arr: List[int]) -> List[int]: ``` Input - A list of integers `arr` (1 ≤ len(arr) ≤ 10^5) representing the array to be rearranged. Output - A list of integers representing the rearranged array based on the described condition. Example ```python >>> rearrange_array([5, 2, 9, 1, 5, 6]) [9, 2, 6, 1, 5, 5] >>> rearrange_array([4, 3, 2, 1]) [4, 1, 3, 2] ``` Constraints - The function should handle large input sizes efficiently. - Aim for a time complexity of O(n log n) due to sorting and space complexity of O(1). Additional Notes 1. Consider edge cases such as arrays with all similar elements. 2. Ensure your function maintains the order requirements strictly. 3. Optimize for both performance and readability.","solution":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: # First, sort the array to easily select the largest and smallest elements alternately arr.sort() # Create a new array to store the result result = [0] * len(arr) # Pointers to place elements from the end and from the start left = 0 right = len(arr) - 1 # Fill result array ensuring condition: every element at an even index is larger than its adjacent elements for i in range(len(arr)): if i % 2 == 0: result[i] = arr[right] right -= 1 else: result[i] = arr[left] left += 1 return result"},{"question":"# Anagram Checker with Special Characters **Scenario**: As a software developer, you need to create a function that checks if two strings are anagrams of each other. However, the strings may contain special characters, spaces, and numbers. The function should ignore these characters when checking for anagrams and only consider the alphabetical characters. **Task**: Implement a function that checks whether two strings are anagrams of each other, ignoring any non-alphabetical characters. **Function Signature**: ```python def is_anagram(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams, ignoring non-alphabetic characters. Args: str1 (str): the first string. str2 (str): the second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. ``` **Input**: - `str1` and `str2`: two strings of arbitrary length where 0 <= len(str1), len(str2) <= 10^5. **Output**: - The function should return `True` if the alphabetical characters in `str1` and `str2` are anagrams of each other, `False` otherwise. **Constraints**: - Spaces, numbers, and special characters should be ignored. - The function should be case insensitive. - The function should have a time complexity of O(n). **Examples**: ```python # Sample Input/Output 1 >>> is_anagram(\\"Astronomer\\", \\"Moon starer!\\") True # Sample Input/Output 2 >>> is_anagram(\\"The Morse Code\\", \\"Here come dots!\\") True # Sample Input/Output 3 >>> is_anagram(\\"Hello, World!\\", \\"Dell, How rol!\\") True # Sample Input/Output 4 >>> is_anagram(\\"Example\\", \\"Sample\\") False # Sample Input/Output 5 >>> is_anagram(\\"Anagram\\", \\"Nag a ram!\\") True ``` **Requirements**: - The solution should handle edge cases efficiently. - Include test cases for validation.","solution":"def is_anagram(str1: str, str2: str) -> bool: Check if str1 and str2 are anagrams, ignoring non-alphabetic characters. Args: str1 (str): the first string. str2 (str): the second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. import re from collections import Counter def clean_string(s): return re.sub(\'[^a-zA-Z]\', \'\', s).lower() clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) return Counter(clean_str1) == Counter(clean_str2)"},{"question":"# Matrix Reflection: Advanced Assessment Objective Design and implement an advanced function for reflecting a matrix across its main diagonal. This exercise tests your ability to manipulate multidimensional arrays while maintaining the integrity of the data structure. Function Signature ```python def reflect_matrix(matrix: List[List[int]]) -> List[List[int]]: ... ``` Instructions 1. **Functionality**: - Create a function that reflects a square matrix (N x N) across its main diagonal. - The main diagonal runs from the top-left to the bottom-right corner of the matrix. 2. **Input**: - A single parameter, `matrix`: A list of lists where each inner list represents a row of the matrix, and each element is an integer. 3. **Output**: - The function should return a new matrix, which is the reflection of the input matrix across its main diagonal. 4. **Examples**: - ```python reflect_matrix([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` - ```python reflect_matrix([ [1, 7, 9], [2, 6, 4], [3, 5, 8] ]) # Output: # [ # [1, 2, 3], # [7, 6, 5], # [9, 4, 8] # ] ``` 5. **Considerations**: - Ensure the function handles both positive and negative integers. - The function should handle edge cases, such as the smallest possible matrix (1 x 1). 6. **Constraints**: - The matrix will always be square (N x N), where N is in the range of 1 to 100. - All integer values in the matrix will be between -10^6 and 10^6. Notes - Reflecting a matrix involves swapping elements symmetrically about the main diagonal. - Efficiently handle swapping to ensure that larger sized matrices are processed in optimal time.","solution":"from typing import List def reflect_matrix(matrix: List[List[int]]) -> List[List[int]]: Reflects a given square matrix across its main diagonal. Parameters: matrix (List[List[int]]): A 2D list representing the square matrix. Returns: List[List[int]]: A new matrix which is the reflection of the input matrix. # Total rows and columns in the matrix (since it\'s a square matrix) N = len(matrix) # Initializing the reflected_matrix with the appropriate size reflected_matrix = [[0] * N for _ in range(N)] # Reflecting the matrix by swapping elements for i in range(N): for j in range(N): reflected_matrix[j][i] = matrix[i][j] return reflected_matrix"},{"question":"# Problem Statement Write a function `transpose_matrix` that takes a square matrix represented as a list of lists and returns the transpose of the matrix. # Requirements * Your function should expect a square matrix (n x n) as input and validate that it meets this requirement. * The result should be the transpose of the input matrix. # Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` # Input * `matrix` (list of lists): A square matrix of integers. (0 <= len(matrix) <= 10^3) # Output * (list of lists): A list of lists representing the transpose of the input matrix. # Constraints * If the input matrix is empty, the function should return an empty list. * The matrix must be square (length of rows equal). The function should assert this as part of its validation process. * Ensure your implementation handles edge cases and optimizes performance where feasible. # Examples ```python >>> transpose_matrix([[1, 2], [3, 4]]) [[1, 3], [2, 4]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[]]) [] ``` # Notes * Ensure the function raises an error if the input matrix is not square: * Example: `transpose_matrix([[1, 2], [3, 4, 5]])` should raise an assertion error.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transposes an n x n matrix. Args: matrix (list of lists): A square matrix. Returns: list of lists: The transpose of the given matrix. if not matrix: return [] n = len(matrix) assert all(len(row) == n for row in matrix), \\"Matrix must be square\\" transposed = [] for i in range(n): new_row = [] for j in range(n): new_row.append(matrix[j][i]) transposed.append(new_row) return transposed"},{"question":"Quick Sort Implementation Quick Sort is an efficient and widely used sorting algorithm that employs a divide-and-conquer strategy to sort elements in place. This algorithm is particularly effective for large datasets and provides an average case time complexity of O(n log n). # Problem Statement You are required to implement the Quick Sort algorithm to sort a given list of integers in ascending order. # Input * A list `arr` of `n` integers. # Output * Return the sorted list in ascending order. # Constraints * The list `arr` can be of size `0 <= len(arr) <= 10^6`. * The elements in the list can include both positive and negative integers. # Example: ```python >>> quick_sort([4, 5, 6, 7]) [4, 5, 6, 7] >>> quick_sort([7, 4, 5, 6]) [4, 5, 6, 7] >>> quick_sort([]) [] >>> quick_sort([3, -1, 0, 7, 5]) [-1, 0, 3, 5, 7] ``` # Task Implement the `quick_sort` function as described. You may want to create helper functions as needed to complete the implementation.","solution":"def quick_sort(arr): Sorts a list of integers in ascending order using the Quick Sort algorithm. Args: arr (list): A list of integers. Returns: list: The sorted list of integers. if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# Problem Context You are developing a ticket booking system for a movie theater. The system should be able to manage seat reservations, cancellations, and ensure that the seating follows certain constraints to maximize comfort and safety. # Task Implement a Movie Theater class with methods to reserve seats, cancel reservations, and display the current seating arrangement. # Function Signature ```python class MovieTheater: def __init__(self, rows: int, seats_per_row: int): ... def reserve_seat(self, row: int, seat: int) -> bool: ... def cancel_reservation(self, row: int, seat: int) -> bool: ... def display_seating(self) -> str: ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Accepts the number of rows and seats per row to set up the seating arrangement. - Initializes the seating arrangement, with all seats marked as available. 2. **Reserve Seat (`reserve_seat` method)**: - Accepts a row and seat number. - Reserves the specified seat if it is available. - Ensures the reservation follows the constraints for comfort and safety. - Returns `True` if the reservation is successful, `False` otherwise. 3. **Cancel Reservation (`cancel_reservation` method)**: - Accepts a row and seat number. - Cancels the reservation for the specified seat if it is currently reserved. - Returns `True` if the cancellation is successful, `False` otherwise. 4. **Display Seating (`display_seating` method)**: - Provides a string representation of the current seating arrangement. - Shows reserved seats with an \\"X\\" and available seats with an \\"O\\". - Ensures the layout is clear and well-formatted. # Constraints 1. Rows and seats per row are positive integers. 2. Seat numbers start from 1 up to the number of seats per row in each row. 3. Row numbers start from 1 up to the number of rows. # Example Usage ```python if __name__ == \\"__main__\\": theater = MovieTheater(rows=5, seats_per_row=8) print(theater.display_seating()) theater.reserve_seat(1, 3) theater.reserve_seat(2, 4) print(theater.display_seating()) theater.cancel_reservation(1, 3) print(theater.display_seating()) ``` # Input and Output Format * **Input**: Number of rows and seats per row. ```plaintext rows = 5 seats_per_row = 8 ``` * **Output**: - Methods signature implementations. - Output of `display_seating` method shows the layout. ```plaintext OOOOOOOO OOOOOOOO OOOOOOOO OOOOOOOO OOOOOOOO OOXOOOOO OOOOXOOO OOOOOOOO OOOOOOOO OOOOOOOO OOOOOOOO OOOOXOOO OOOOOOOO OOOOOOOO OOOOOOOO ``` # Additional Guidelines 1. **Edge Cases**: - Handle reservations and cancellations for seats outside the specified ranges. - Ensure invalid operations (reserving an already reserved seat, or canceling an unreserved seat) are managed gracefully. 2. **Performance**: - Optimize seating layout display for larger theaters. - Ensure efficient seat reservation and cancellation operations.","solution":"class MovieTheater: def __init__(self, rows: int, seats_per_row: int): self.rows = rows self.seats_per_row = seats_per_row self.seats = [[\\"O\\" for _ in range(seats_per_row)] for _ in range(rows)] def reserve_seat(self, row: int, seat: int) -> bool: if 1 <= row <= self.rows and 1 <= seat <= self.seats_per_row: if self.seats[row - 1][seat - 1] == \\"O\\": self.seats[row - 1][seat - 1] = \\"X\\" return True return False def cancel_reservation(self, row: int, seat: int) -> bool: if 1 <= row <= self.rows and 1 <= seat <= self.seats_per_row: if self.seats[row - 1][seat - 1] == \\"X\\": self.seats[row - 1][seat - 1] = \\"O\\" return True return False def display_seating(self) -> str: return \\"n\\".join(\\"\\".join(row) for row in self.seats)"},{"question":"# Problem Statement: Write a function that computes the largest rectangular area (in terms of the number of unit squares) that can be fitted into a given histogram. Each bar of the histogram has width 1. The heights of the bars are given in an array. Function Signature: ```python def largest_histogram_area(heights: List[int]) -> int: pass ``` Expected Input: * `heights`: A list of integers ( text{heights}[i] ) representing the height of the (i)-th bar in the histogram. ( 1 leq text{len(heights)} leq 10^5 ) and ( 0 leq text{heights}[i] leq 10^5 ). Expected Output: * An integer representing the largest rectangular area that can be fitted into the histogram. Constraints: * The algorithm should efficiently handle histograms with a large number of bars. * Optimize the solution to avoid unnecessary computations and ensure it runs within a reasonable time frame for the upper constraint limits. Examples: ```python largest_histogram_area([2, 1, 5, 6, 2, 3]) # should return 10 largest_histogram_area([2, 4]) # should return 4 largest_histogram_area([6, 2, 5, 4, 5, 1, 6]) # should return 12 ``` # Additional Information: * Make sure your implementation efficiently handles the upper constraint limit (heights array length up to 100,000). * Consider edge cases like empty histograms or histograms with all bars of height zero. * The function should be able to compute the solution even for large and varied height distributions.","solution":"from typing import List def largest_histogram_area(heights: List[int]) -> int: Computes the largest rectangular area that can be fitted into a given histogram. stack = [] # Stack to keep track of indices max_area = 0 # Initialize max area index = 0 # Initialize current index while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar `\'height` area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar as the smallest bar while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Coding Challenge: Sort Log Files Context: You are working on a log management system that needs to sort log entries based on specified criteria. There are two types of log entries: letter-logs and digit-logs. Each log entry consists of an alphanumeric identifier followed by a space and then a string of letters or digits. Task: Implement the function `sort_logs(logs: List[str]) -> List[str]` that: 1. Sorts the log entries such that: * Letter-logs come before digit-logs. * Letter-logs are sorted lexicographically by their contents. If their contents are identical, then sort by their identifiers. * Digit-logs maintain their relative ordering. Implementation Details: * **Input**: * A list of strings `logs` containing log entries. * **Output**: * A list of strings representing the sorted log entries. * **Constraints**: * Each log string is non-empty and no more than 100 characters. * Logs will contain only printable ASCII characters. Examples: ``` python >>> sort_logs([\\"dig1 8 1 5 1\\", \\"let1 art can\\", \\"dig2 3 6\\", \\"let2 own kit dig\\", \\"let3 art zero\\"]) [\'let1 art can\', \'let3 art zero\', \'let2 own kit dig\', \'dig1 8 1 5 1\', \'dig2 3 6\'] >>> sort_logs([\\"let1 abc\\", \\"let2 abc\\", \\"dig1 20 3\\", \\"let3 ab\\"]) [\'let3 ab\', \'let1 abc\', \'let2 abc\', \'dig1 20 3\'] >>> sort_logs([\\"dig1 3 6\\", \\"dig2 4 5\\", \\"let1 art zero\\", \\"let2 art hero\\"]) [\'let2 art hero\', \'let1 art zero\', \'dig1 3 6\', \'dig2 4 5\'] ``` You are required to correctly differentiate between letter-logs and digit-logs, apply the sorting rules, and ensure efficient handling of the input list.","solution":"from typing import List def sort_logs(logs: List[str]) -> List[str]: def get_key(log): identifier, rest = log.split(\\" \\", 1) return (0, rest, identifier) if rest[0].isalpha() else (1, ) return sorted(logs, key=get_key)"},{"question":"# Question Problem Statement You are tasked with creating a function `minimum_bst_height(values)` that calculates the minimum height of a Binary Search Tree (BST) that can be constructed using a given list of unique integer values. The height of a BST is defined as the number of edges on the longest path from the root to a leaf. # Function Signature ```python def minimum_bst_height(values: List[int]) -> int: pass ``` # Input - `values` (1 ≤ len(values) ≤ 1000): A list of unique integers. # Output - Return an integer representing the minimum height of the BST constructed using the given list of values. # Constraints - Assume all values are unique and can fit into the binary search tree rules. - The input list will have at least one element. # Examples Example 1 ```python values = [3, 1, 4, 2] result = minimum_bst_height(values) print(result) # Output: 2 ``` Example 2 ```python values = [15, 10, 20, 8, 12, 18, 25] result = minimum_bst_height(values) print(result) # Output: 2 ``` # Explanation - For `values = [3, 1, 4, 2]`, the minimum height is `2` when the constructed BST has the least number of levels: ``` 3 / 1 4 2 ``` - For `values = [15, 10, 20, 8, 12, 18, 25]`, the minimum height is `2` when the constructed BST is well balanced: ``` 15 / 10 20 / / 8 12 18 25 ``` # Notes - A minimal-height BST is often a balanced BST, which can be achieved by strategically choosing the root (typically the median value in a sorted list) and recursively constructing left and right subtrees. - Efficient tree construction and height calculation are crucial for optimal performance with larger input sizes.","solution":"from typing import List import math def minimum_bst_height(values: List[int]) -> int: def build_min_height_bst(values: List[int]) -> int: if not values: return -1 mid = len(values) // 2 left_height = build_min_height_bst(values[:mid]) right_height = build_min_height_bst(values[mid+1:]) return 1 + max(left_height, right_height) return build_min_height_bst(sorted(values))"},{"question":"# Coding Assessment Question You are tasked with implementing a function that checks if a given integer number is a palindrome in its binary representation. Ensure the function validates the input for any errors before proceeding with the palindrome check. **Function Signature**: ```python def is_binary_palindrome(number: int) -> bool: Check if an integer is a palindrome in its binary representation. Parameters: number (int): An integer number to be checked. Returns: bool: `True` if the binary representation is a palindrome, `False` otherwise. Raises: TypeError: If input is not an integer. ValueError: If the input integer is negative. Sample Input/Output: >>> is_binary_palindrome(9) True # 9 in binary is 1001, which is a palindrome. >>> is_binary_palindrome(10) False # 10 in binary is 1010, which is not a palindrome. >>> is_binary_palindrome(0) True # 0 in binary is 0, which is a palindrome. >>> is_binary_palindrome(\\"1001\\") Traceback (most recent call last): ... TypeError: Expected an integer as input >>> is_binary_palindrome(-5) Traceback (most recent call last): ... ValueError: Negative integers are not allowed ``` **Constraints**: * The function must handle input validation: * Should raise a `TypeError` for non-integer inputs. * Should raise a `ValueError` for negative integers. * The input is guaranteed not to be `None`. **Scenarios**: 1. Mainstream inputs that are valid non-negative integers. 2. Edge cases involving non-integer inputs and negative integers. 3. Palindrome check should be intuitive and efficient, ensuring correctness and clarity. *Assumption*: The binary representation should be considered without leading zeros.","solution":"def is_binary_palindrome(number: int) -> bool: Check if an integer is a palindrome in its binary representation. Parameters: number (int): An integer number to be checked. Returns: bool: `True` if the binary representation is a palindrome, `False` otherwise. Raises: TypeError: If input is not an integer. ValueError: If the input integer is negative. if not isinstance(number, int): raise TypeError(\\"Expected an integer as input\\") if number < 0: raise ValueError(\\"Negative integers are not allowed\\") binary_representation = bin(number)[2:] return binary_representation == binary_representation[::-1]"},{"question":"**Maze Pathfinding with Obstacles** You are tasked with creating a function that finds the shortest path from the top-left corner to the bottom-right corner in a grid representing a maze, where some cells are obstructed. You are only allowed to move up, down, left, or right, and you cannot move through walls. # Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: pass ``` # Input - `grid`: A 2D list of integers where `0` represents an open cell and `1` represents an obstructed cell. # Output - An integer representing the length of the shortest path from the starting point (0, 0) to the destination point (n-1, m-1). - Return `-1` if there is no valid path. # Constraints - The dimensions of the grid are at most `100 x 100`. - There is guarantee that the start and end points are open cells. - There could be multiple paths, you need to find the shortest one. # Example ```python grid = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] # The shortest path from (0, 0) to (2, 2) is 4 (Right -> Down -> Down -> Right) ``` - The function should return `4`. # Performance Requirements - The solution should efficiently handle the grid within the given constraints. - Optimal use of space and time complexity for finding the shortest path in a grid. # Scenario/Context You are developing an application for automated robot navigation in a grid-like environment. Designing an efficient pathfinding algorithm is crucial for ensuring that the robot can navigate through the maze without unnecessary movements or getting stuck. This function will form a core part of the robot\'s navigation system, ensuring quick and effective pathfinding.","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: r, c, dist = queue.popleft() if r == rows-1 and c == cols-1: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"# Kth Smallest Element in Prime Sequence You are given a list of prime numbers ordered increasingly, and an integer `k`. Your task is to find and return the `k`-th smallest element in the prime sequence efficiently. Function Signature ```python def kth_smallest_prime(primes: list[int], k: int) -> int: Parameters: - primes (list[int]): A list of prime numbers in increasing order. - k (int): An integer representing the position (1-based indexing) of the element to find in the prime sequence. Returns: - int: The k-th smallest element in the prime sequence. Constraints: - The input list `primes` is guaranteed to be a strictly increasing list of prime numbers. - `k` is guaranteed to be a valid position within the list `primes`. ``` Input - A list of prime numbers `primes` in increasing order. - An integer `k` representing the k-th position (1-based indexing). Output - An integer representing the k-th smallest prime number in the list. Example ```python >>> primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> k = 5 >>> kth_smallest_prime(primes, k) 11 >>> primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> k = 10 >>> kth_smallest_prime(primes, k) 29 >>> primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> k = 1 >>> kth_smallest_prime(primes, k) 2 ```","solution":"def kth_smallest_prime(primes: list[int], k: int) -> int: Returns the k-th smallest element in the prime sequence. Parameters: - primes (list[int]): A list of prime numbers in increasing order. - k (int): An integer representing the position (1-based indexing) of the element to find in the prime sequence. Returns: - int: The k-th smallest element in the prime sequence. return primes[k-1]"},{"question":"# Question: You are to implement a basic Inventory Management System with a predefined structure using a class. **Objective:** Write a class `Inventory` with the following functionalities: 1. **Initialization:** - Initialize the inventory with a dictionary where the keys are product names and the values are their respective quantities. 2. **Methods:** - `add_product(product: str, quantity: int) -> None`: - Adds the given quantity of the product to the inventory. If the product doesn\'t exist, add it with the given quantity. - `remove_product(product: str, quantity: int) -> bool`: - Removes the given quantity of the product from the inventory. - If the product\'s quantity becomes zero or less, remove the product from the inventory. - Return `True` if the product was successfully removed, or `False` if the product does not exist or does not have enough quantity to remove. - `get_stock(product: str) -> int`: - Returns the current quantity of the given product in the inventory. - If the product does not exist, return 0. - `list_products() -> list`: - Returns a list of all products in the inventory, sorted alphabetically. **Constraints:** - Product names will only contain lowercase alphabetic characters and will be unique. **Input and Output:** - For `add_product`: - **Input**: A product name (string) and a quantity (integer). - **Output**: None. - For `remove_product`: - **Input**: A product name (string) and a quantity (integer). - **Output**: A boolean indicating the success of the removal. - For `get_stock`: - **Input**: A product name (string). - **Output**: An integer representing the quantity of the product. - For `list_products`: - **Input**: None. - **Output**: A list of strings with the names of the products sorted alphabetically. **Examples:** 1. **Example 1:** ```python inventory = Inventory({\'apple\': 10, \'banana\': 5}) inventory.add_product(\'orange\', 3) print(inventory.get_stock(\'orange\')) # Output: 3 ``` 2. **Example 2:** ```python inventory = Inventory({\'apple\': 10, \'banana\': 5}) result = inventory.remove_product(\'apple\', 5) print(result) # Output: True inventory.remove_product(\'apple\', 5) print(inventory.get_stock(\'apple\')) # Output: 0 inventory.add_product(\'grape\', 7) print(inventory.list_products()) # Output: [\'banana\', \'grape\'] ``` **Class Signature:** ```python class Inventory: def __init__(self, initial_stock: dict[str, int]): pass def add_product(self, product: str, quantity: int) -> None: pass def remove_product(self, product: str, quantity: int) -> bool: pass def get_stock(self, product: str) -> int: pass def list_products(self) -> list[str]: pass ``` **Performance Requirements:** - The solution should handle inventories with up to 10^4 products efficiently.","solution":"class Inventory: def __init__(self, initial_stock: dict[str, int]): Initializes the inventory with the given dictionary of products and their quantities. self.stock = initial_stock if initial_stock else {} def add_product(self, product: str, quantity: int) -> None: Adds the given quantity of the product to the inventory. If the product doesn\'t exist, it is added with the given quantity. if product in self.stock: self.stock[product] += quantity else: self.stock[product] = quantity def remove_product(self, product: str, quantity: int) -> bool: Removes the given quantity of the product from the inventory. Returns True if the product quantity was successfully removed, or False if the product does not exist or does not have enough quantity. if product not in self.stock or self.stock[product] < quantity: return False self.stock[product] -= quantity if self.stock[product] <= 0: del self.stock[product] return True def get_stock(self, product: str) -> int: Returns the current quantity of the given product in the inventory. If the product does not exist, returns 0. return self.stock.get(product, 0) def list_products(self) -> list: Returns a list of all products in the inventory sorted alphabetically. return sorted(self.stock.keys())"},{"question":"# Missing Numbers in Range Given an array of unique integers that represent numbers within a given range, write a function to find the numbers that are missing from the array within that range. Requirements 1. Implement `find_missing_numbers(arr: List[int], lower: int, upper: int) -> List[int]` which returns a list of the missing integers. 2. Ensure that the function can handle cases where no numbers are missing efficiently. # Input - A list `arr` of distinct integers. - Two integers, `lower` and `upper`, representing the range bounds, inclusive (`lower ≤ upper`). # Output - A list of integers that are within the range [lower, upper] but not present in `arr`. # Constraints - The length of `arr` will be at most 10^5. - Each element in `arr` and the range bounds `lower` and `upper` will be within the range of [-10^6, 10^6]. - The output list should be sorted in ascending order. Example ```python assert find_missing_numbers([1, 3, 5, 7], 1, 10) == [2, 4, 6, 8, 9, 10] assert find_missing_numbers([-3, -2, 1, 4], -3, 5) == [-1, 0, 2, 3, 5] assert find_missing_numbers([2, 3, 4], 1, 4) == [1] assert find_missing_numbers([10, 12, 15], 10, 15) == [11, 13, 14] assert find_missing_numbers([], 2, 3) == [2, 3] ``` # Explanation In the first example, the missing numbers between 1 and 10 that are not in the array [1, 3, 5, 7] are [2, 4, 6, 8, 9, 10]. In the second example, the missing numbers between -3 and 5 that are not in the array [-3, -2, 1, 4] are [-1, 0, 2, 3, 5].","solution":"from typing import List def find_missing_numbers(arr: List[int], lower: int, upper: int) -> List[int]: Returns a list of integers in the range [lower, upper] that are not present in arr. num_set = set(arr) return [num for num in range(lower, upper + 1) if num not in num_set]"},{"question":"# Scenario You are given an array of integers, and your task is to determine the maximum difference between any two elements such that the larger element comes after the smaller one in the original array. # Problem Statement Implement a function `max_diff(arr: List[int]) -> int` that takes a list of integers and returns the maximum difference between any two elements where the larger element appears after the smaller one. # Input * `arr`: A list of `n` integers `arr[i]` where * `1 <= n <= 10^5` * `-10^9 <= arr[i] <= 10^9` # Output * An integer representing the maximum difference between any two elements in the list where the larger element comes after the smaller one. If no such elements exist, return 0. # Constraints * If the array has less than two elements, return 0. # Example * `max_diff([2, 3, 10, 2, 4, 8, 1])` should return `8` (10 - 2). * `max_diff([7, 9, 5, 6, 3, 2])` should return `2` (9 - 7). * `max_diff([7, 1, 5, 3, 6, 4])` should return `5` (6 - 1). * `max_diff([4, 3, 2, 1])` should return `0`. # Requirements * Your implementation should efficiently handle the input array size within the given constraints, ideally in O(n) time complexity.","solution":"from typing import List def max_diff(arr: List[int]) -> int: if len(arr) < 2: return 0 min_element = arr[0] max_difference = 0 for i in range(1, len(arr)): current_diff = arr[i] - min_element if current_diff > max_difference: max_difference = current_diff if arr[i] < min_element: min_element = arr[i] return max_difference"},{"question":"# Question: Implement an Efficient Version of HeapSort Context HeapSort is a comparison-based sorting algorithm that can be described as an improved selection sort. It creates a heap from the input data and repeatedly extracts the maximum element from the heap. Task You are tasked with implementing an efficient version of the HeapSort algorithm. Specifically, optimize the traditional HeapSort by reducing unnecessary heap adjustments and improving the overall run-time efficiency. Implementation Requirements 1. **Input**: * An unsorted list `lst` containing integers. * The list may contain duplicates. * Assume the list length (`n`) could be large: `1 ≤ n ≤ 10^6`. 2. **Output**: * A sorted list containing all elements from the input list in ascending order. 3. **Constraints**: * You must use HeapSort logic with optimizations for reduced heap adjustments. * Maintain in-place sorting to minimize space complexity. 4. **Performance**: * The solution should handle the worst-case time complexity of O(n log n) efficiently for large inputs. Write a function `efficient_heap_sort(lst)` that implements the required functionality. Example ```python def efficient_heap_sort(lst): # Your efficient implementation here # Example usage: lst = [12, 11, 13, 5, 6, 7] sorted_lst = efficient_heap_sort(lst) print(sorted_lst) # Expected output: [5, 6, 7, 11, 12, 13] ```","solution":"def efficient_heap_sort(lst): def heapify(nums, n, i): largest = i l = 2 * i + 1 r = 2 * i + 2 if l < n and nums[largest] < nums[l]: largest = l if r < n and nums[largest] < nums[r]: largest = r if largest != i: nums[i], nums[largest] = nums[largest], nums[i] heapify(nums, n, largest) n = len(lst) for i in range(n // 2 - 1, -1, -1): heapify(lst, n, i) for i in range(n-1, 0, -1): lst[i], lst[0] = lst[0], lst[i] heapify(lst, i, 0) return lst"},{"question":"# Scenario Online retail websites often need to recommend products based on a user\'s browsing history. Imagine you need to build a utility that suggests a list of product IDs that a user might be interested in, based on the product categories they have recently viewed. The utility should handle data inconsistencies and ensure the recommendations are diverse. # Task Implement a Python function `recommend_products(user_history: List[str], product_db: Dict[str, List[str]]) -> List[str]` that performs the following: 1. Analyzes the provided user history, which is a list of product categories the user has viewed. 2. Uses the product database, which is a dictionary where the keys are product categories and the values are lists of product IDs. 3. Recommends up to 5 unique product IDs that the user has not viewed yet, ensuring that the recommendations are from different categories when possible. # Constraints * Input `user_history` is a non-empty list of valid product categories that the user has viewed. * Input `product_db` is a dictionary with product categories as keys and lists of product IDs as values. * Ensure to handle potential data inconsistencies (e.g., missing categories in the database) gracefully. * The expected output is a list of strings (product IDs), which can be fewer than 5 if not enough recommendations are found. # Function Signature ```python from typing import List, Dict def recommend_products(user_history: List[str], product_db: Dict[str, List[str]]) -> List[str]: pass ``` # Example ```python user_history = [\'electronics\', \'books\', \'clothing\'] product_db = { \'electronics\': [\'e1\', \'e2\', \'e3\'], \'books\': [\'b1\', \'b2\'], \'clothing\': [\'c1\', \'c2\', \'c3\', \'c4\'], \'toys\': [\'t1\', \'t2\'] } result = recommend_products(user_history, product_db) print(result) # Output: [\'e1\', \'b1\', \'c1\', \'t1\'] ``` # Requirements * Ensure recommendations are diverse by suggesting products from different categories when possible. * Handle edge cases such as empty product lists or categories not found in the database. * Provide meaningful messages or fallbacks in cases where recommendations cannot be generated for some categories.","solution":"from typing import List, Dict def recommend_products(user_history: List[str], product_db: Dict[str, List[str]]) -> List[str]: recommended = set() recommendations = [] # Process each category in user history for category in user_history: if category in product_db: for product in product_db[category]: if product not in recommended: recommended.add(product) recommendations.append(product) if len(recommendations) == 5: break if len(recommendations) == 5: break # Fill the remaining recommendations, if needed, from unused categories if len(recommendations) < 5: for category, products in product_db.items(): if category not in user_history: for product in products: if product not in recommended: recommended.add(product) recommendations.append(product) if len(recommendations) == 5: break if len(recommendations) == 5: break return recommendations"},{"question":"You are tasked with writing a function that searches for the smallest factorial number that is also a palindrome. # Task Write a function `find_palindromic_factorial() -> int` that finds the smallest factorial number which is a palindrome. A number is a palindrome if it reads the same backwards as forwards. # Input This function does not require any input parameters. # Output Return the smallest integer which represents a palindromic factorial number. # Constraints - Your implementation should efficiently handle the generation and checking of factorials. - Factorials can grow very large, consider using a data type that can handle large integers. # Example ```python # Example case find_palindromic_factorial() # 1 (1! = 1) ``` # Implementation Notes 1. A number `n!` is `n` factorial, which is the product of all positive integers up to `n`. 2. Loop through factorials starting from `0!` and check if the result is a palindrome. 3. Continue this process until you find the first factorial that is a palindrome.","solution":"def is_palindrome(num): Check if a given number is a palindrome. return str(num) == str(num)[::-1] def factorial(n): Calculate the factorial of a given number n. if n == 0 or n == 1: return 1 result = 1 for i in range(2, n + 1): result *= i return result def find_palindromic_factorial(): Find the smallest factorial number that is also a palindrome. n = 0 while True: fact = factorial(n) if is_palindrome(fact): return fact n += 1"},{"question":"# Customer Order Processing System As a software developer for an online store, you are tasked with creating a system to manage customer orders. You need to implement functionality that processes orders, calculates the total cost including tax, and applies discounts based on certain conditions. Requirements: 1. Process a list of orders, each containing multiple items with their quantities and prices. 2. Apply a discount if the order total exceeds a certain amount. 3. Calculate and add tax to the final total based on a given tax rate. 4. Ensure accurate handling of various edge cases such as empty orders or zero quantities. # Function Specification Implement a function `process_order(order: List[Dict[str, Union[int, float]]], tax_rate: float, discount_threshold: float, discount_rate: float) -> float` that calculates the total amount payable for the order including discounts and tax. Inputs: - `order`: A list of dictionaries, each representing an item with keys `\'quantity\'` (an integer) and `\'price\'` (a float). - `tax_rate`: A float representing the tax rate as a percentage (e.g., 10.0 for 10%). - `discount_threshold`: A float representing the minimum total amount to qualify for a discount. - `discount_rate`: A float representing the discount rate as a percentage (e.g., 5.0 for 5%). Outputs: - A float representing the final total amount payable including tax and any discounts. Constraints: - Each item\'s quantity will be a non-negative integer. - Each item\'s price will be a non-negative float. - `tax_rate`, `discount_threshold`, and `discount_rate` will be non-negative floats. - The function should handle edge cases gracefully, such as an empty order list. Performance Requirements: - Your solution should efficiently handle a list of up to 1000 items. - Ensure calculations are precise and avoid floating-point arithmetic issues. Example Usage: ```python order = [ {\\"quantity\\": 2, \\"price\\": 19.99}, {\\"quantity\\": 3, \\"price\\": 5.49}, {\\"quantity\\": 1, \\"price\\": 15.00} ] tax_rate = 7.25 discount_threshold = 50.00 discount_rate = 10.00 total = process_order(order, tax_rate, discount_threshold, discount_rate) print(total) # Output: Total cost after tax and discount ```","solution":"def process_order(order, tax_rate, discount_threshold, discount_rate): Calculate the total amount payable for the order including discounts and tax. Parameters: - order: List of dictionaries with keys \'quantity\' (int) and \'price\' (float). - tax_rate: Tax rate as a percentage (e.g., 10.0 for 10%). - discount_threshold: Minimum total amount to qualify for a discount. - discount_rate: Discount rate as a percentage (e.g., 5.0 for 5%). Returns: - Float representing the final total amount payable. if not order: return 0.0 subtotal = sum(item[\'quantity\'] * item[\'price\'] for item in order) if subtotal > discount_threshold: discount = subtotal * (discount_rate / 100.0) else: discount = 0.0 subtotal -= discount tax = subtotal * (tax_rate / 100.0) total = subtotal + tax return round(total, 2)"},{"question":"# Merge K Sorted Arrays You are given `k` sorted arrays, each of size `n`. Write a function that merges these `k` arrays into a single sorted array. You should implement an **efficient solution** using a min-heap (priority queue). Function Signature ```python def merge_k_sorted_arrays(arrays: list) -> list: pass ``` Input - `arrays`: A list of `k` lists, where each list contains `n` integers in ascending order (1 ≤ k, n ≤ 500). Output - Return a single list containing all the integers from the `k` lists combined in ascending order. Constraints - Each list individually fits in memory, but the combined size of all lists (`k * n`) may be very large. - Use efficient methods to handle the merging process. Examples ```python # Example 1 arrays = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] # Example 2 arrays = [ [1, 3, 5], [2, 4, 6], [0, 7, 8] ] # Expected Output: [0, 1, 2, 3, 4, 5, 6, 7, 8] ``` Note 1. Efficiently manage memory and runtime using a min-heap to repeatedly extract the smallest element from the front of the `k` lists. 2. Assume all arrays have the same length `n`. 3. Ensure that your implementation handles edge cases and large inputs gracefully.","solution":"import heapq def merge_k_sorted_arrays(arrays): Merges k sorted arrays into a single sorted array using a min-heap. Parameters: arrays (list of list of int): List of k sorted arrays, each of size n. Returns: list: A single sorted list with all elements from the k input arrays. min_heap = [] # Store the iterator for each array iterators = [iter(array) for array in arrays] # Populate the heap with the first element from each array, along with the array index for i, it in enumerate(iterators): element = next(it, None) if element is not None: heapq.heappush(min_heap, (element, i)) result = [] while min_heap: smallest, i = heapq.heappop(min_heap) result.append(smallest) # Get the next element from the iterator corresponding to the array `i` element = next(iterators[i], None) if element is not None: heapq.heappush(min_heap, (element, i)) return result"},{"question":"# Coding Assessment Question Rotate Matrix Elements You are required to write a Python function to solve a problem involving 2D lists (matrices). This will test your understanding of matrix manipulation, traversal, and indexing. Problem Statement Given a 2D list (matrix) of integers, write a function `rotate_matrix_elements` that returns a new matrix with its elements rotated clockwise by one position. Rotation implies moving all elements one step forward in a row-wise manner, where the last element of a row moves to the first position of the next row, and this continues cyclically. Input * `matrix` (List[List[int]]): A non-empty 2D list of integers. The matrix dimensions will be `m x n`, where `1 ≤ m, n ≤ 100`. Output * A 2D list representing the new matrix with elements rotated clockwise by one position. Constraints * Handle edge cases where the number of rows or columns is 1. * Ensure that your solution works for both square and rectangular matrices. Function Signature ```python def rotate_matrix_elements(matrix: List[List[int]]) -> List[List[int]]: ``` Example Input: ``` matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: ``` [ [9, 1, 2], [3, 4, 5], [6, 7, 8] ] ``` Explanation: The matrix elements are rotated clockwise: 1 moves to the second position, 2 to the third position, ..., 9 to the first position in the new matrix. Additional Notes: 1. Make sure to handle all elements correctly without overwriting during rotation. 2. Avoid using extra space proportional to the number of elements; try to use constant extra space. 3. Consider edge cases to ensure correctness, such as single row or single column matrices. Good luck and remember to test your code with various inputs to ensure correctness and efficiency.","solution":"from typing import List def rotate_matrix_elements(matrix: List[List[int]]) -> List[List[int]]: m, n = len(matrix), len(matrix[0]) last_element = matrix[m-1][n-1] # Rotate elements within the matrix by one position in reverse order for i in range(m-1, -1, -1): for j in range(n-1, -1, -1): if j == 0: if i > 0: matrix[i][j] = matrix[i-1][n-1] else: matrix[i][j] = matrix[i][j-1] # Place the last element to the first position matrix[0][0] = last_element return matrix"},{"question":"# Coding Assessment Question Context You work for a tech consultancy that specializes in optimizing network communications. A client has approached you to develop a feature for their internal messaging system to ensure proper capitalization of names. The goal is to format names so that the first letter of each name part is capitalized while the rest are in lowercase, irrespective of the initial format provided. Task Implement a Python function `format_name` that takes a string containing a full name and returns the name with proper capitalization. Function Signature ```python def format_name(full_name: str) -> str: ``` Input * `full_name` (a string): A string containing one or more name parts separated by spaces. Each part can be in any case format. Output * A string where each part of the name is capitalized correctly. Constraints 1. The input `full_name` will contain only alphabetic characters and spaces. 2. The input `full_name` will contain at least one name part and at most `100` characters. 3. There will be no leading or trailing spaces in the input. Example ```python # Example full_name = \\"joHN doE\\" print(format_name(full_name)) # Output: \\"John Doe\\" full_name = \\"alICE jOnes\\" print(format_name(full_name)) # Output: \\"Alice Jones\\" full_name = \\"marY ANN hopkINS\\" print(format_name(full_name)) # Output: \\"Mary Ann Hopkins\\" ``` Notes * You cannot use the `title()` method directly on the string. * Take into account that each name part may be of variable length and can include a mix of lowercase and uppercase letters.","solution":"def format_name(full_name: str) -> str: Takes a full name string and returns it with properly capitalized names. Parameters: - full_name (str): The full name as a string. Returns: - str: The properly capitalized full name. # Split the full name into parts name_parts = full_name.split() # Capitalize each part formatted_parts = [part.capitalize() for part in name_parts] # Join the parts back into a single string formatted_name = \\" \\".join(formatted_parts) return formatted_name"},{"question":"# Problem Statement You have been tasked with creating a function to encode and decode messages using a simple numerical cipher. This cipher shifts the letters in the message by a given number of positions in the alphabet. For example, with a shift of 3, \'a\' would become \'d\', and \'z\' would wrap around to become \'c\'. The function should handle both encoding and decoding of messages using this technique. # Implementation Details **Function 1**: `encode_message(message: str, shift: int) -> str` - **Input**: * `message`: A string containing the message to be encoded. * `shift`: An integer representing the number of positions each letter in the message should be shifted. - **Output**: * Returns the encoded message as a string. - **Constraints**: * The message length will not exceed 10^5 characters. * The message may contain alphabets (both uppercase and lowercase), digits, spaces, and punctuation. * Only alphabet characters (both uppercase and lowercase) should be shifted; all other characters, including spaces and punctuation, should remain unchanged. **Function 2**: `decode_message(encoded_message: str, shift: int) -> str` - **Input**: * `encoded_message`: A string containing the encoded message. * `shift`: An integer representing the number of positions each letter in the encoded message was shifted originally. - **Output**: * Returns the original message as a string by reversing the shift. - **Constraints**: * The message length will not exceed 10^5 characters. * The message may contain alphabets (both uppercase and lowercase), digits, spaces, and punctuation. # Examples 1. **Example 1**: * Encoding: - Input: `\\"Hello World!123\\"`, `shift=3` - Output: `\\"Khoor Zruog!123\\"` * Decoding: - Input: `\\"Khoor Zruog!123\\"`, `shift=3` - Output: `\\"Hello World!123\\"` 2. **Example 2**: * Encoding: - Input: `\\"Python 3.8\\"`, `shift=5` - Output: `\\"Udymts 3.8\\"` * Decoding: - Input: `\\"Udymts 3.8\\"`, `shift=5` - Output: `\\"Python 3.8\\"` # Implementation You should implement the following functions in Python: ```python def encode_message(message: str, shift: int) -> str: def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) return c return \'\'.join(shift_char(c, shift) for c in message) def decode_message(encoded_message: str, shift: int) -> str: return encode_message(encoded_message, -shift) ```","solution":"def encode_message(message: str, shift: int) -> str: Encodes a message by shifting its letters by the specified number of positions in the alphabet. def shift_char(c, shift): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + shift) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + shift) % 26 + ord(\'A\')) return c return \'\'.join(shift_char(c, shift) for c in message) def decode_message(encoded_message: str, shift: int) -> str: Decodes a message that was encoded with a shift cipher by reversing the shift. return encode_message(encoded_message, -shift)"},{"question":"# Objective Your task is to write a function that finds the sum of all prime numbers below a given limit `n`. # Problem Description Write a function `sum_of_primes(n: int) -> int` that: 1. Accepts an integer `n`. 2. Returns the sum of all prime numbers less than `n`. # Constraints * `10 <= n <= 10^6` *Performance Requirement*: Optimize your solution for both time and space complexities. # Function Signature ```python def sum_of_primes(n: int) -> int: pass ``` # Example ```python # Example 1 n = 10 # The prime numbers less than 10 are 2, 3, 5, and 7. Their sum is 17. assert sum_of_primes(n) == 17 # Example 2 n = 30 # The prime numbers less than 30 are 2, 3, 5, 7, 11, 13, 17, 19, 23, and 29. Their sum is 129. assert sum_of_primes(n) == 129 ``` # Scenario Context Imagine you\'re working on an application that performs data analysis of numerical patterns in large datasets. One of the analyses involves identifying and summing prime numbers within a certain range to investigate their properties and distribution. You need to write a function that efficiently calculates this sum for a given upper limit.","solution":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers below n. if n <= 2: return 0 sieve = [True] * n sieve[0] = sieve[1] = False for i in range(2, int(n ** 0.5) + 1): if sieve[i]: for j in range(i * i, n, i): sieve[j] = False return sum(i for i in range(n) if sieve[i])"},{"question":"# Problem Statement Implement two functions: one that converts an integer to its binary representation and another that determines the Hamming weight (number of 1s) of the integer\'s binary representation. These functions are important for applications in error detection and correction, as well as in computer science in general. # Function Definitions 1. `int_to_binary(n: int) -> str` - **Input**: A non-negative integer `n`. - **Output**: A string representation of the binary form of `n`. 2. `hamming_weight(binary_str: str) -> int` - **Input**: A binary string representation of an integer. - **Output**: The Hamming weight, which is the count of \'1\'s in the binary string. # Example ```python assert int_to_binary(9) == \'1001\' assert hamming_weight(\'1001\') == 2 assert int_to_binary(14) == \'1110\' assert hamming_weight(\'1110\') == 3 assert int_to_binary(0) == \'0\' assert hamming_weight(\'0\') == 0 ``` # Constraints 1. For the `int_to_binary` function: - You may assume the input will always be a non-negative integer. - The output should not contain any leading zeroes unless the input itself is zero. 2. For the `hamming_weight` function: - The input will be a valid binary string generated by the `int_to_binary` function. - No need to validate that the string is a proper binary representation as it is assumed to come from `int_to_binary`. # Note - Ensure that your functions handle large integers and their binary representations efficiently. - Consider edge cases such as `0` which should output \'0\' for the binary representation and `0` for the Hamming weight.","solution":"def int_to_binary(n: int) -> str: Converts a non-negative integer to its binary representation. Parameters: n (int): A non-negative integer. Returns: str: The binary representation of the integer. return bin(n)[2:] def hamming_weight(binary_str: str) -> int: Determines the Hamming weight (number of 1s) in a binary string representation of an integer. Parameters: binary_str (str): A binary string representation of an integer. Returns: int: The Hamming weight of the binary string. return binary_str.count(\'1\')"},{"question":"# Question You are asked to implement a function that computes the Short-Time Fourier Transform (STFT) of a given audio signal. Your implementation should efficiently handle various sampling rates and window sizes, ensuring accurate time-frequency representation of the signal. The provided Python function `stft` follows these steps for STFT computation: 1. Split the audio signal into overlapping segments using a window function. 2. Apply the window function to each segment. 3. Compute the Fast Fourier Transform (FFT) for each windowed segment. 4. Assemble the FFT results into a spectrogram. Given an array of audio data, implement the `stft` function by defining the following helper functions: - `windowed_frames` - `apply_window_function` - `compute_fft` Function Signature ```python def windowed_frames(audio: np.ndarray, sample_rate: int, frame_size: int = 1024, hop_length: int = 512) -> np.ndarray: pass def apply_window_function(frames: np.ndarray, window_type: str = \'hann\') -> np.ndarray: pass def compute_fft(windowed_frames: np.ndarray) -> np.ndarray: pass ``` **Constraints**: - The sampling rate of the audio signal is above 8000 Hz. - The audio data is assumed to be a 1D NumPy array of floats. - Frame size defaults to 1024 and can be modified. - The hop length for overlapping frames defaults to 512. - The window function defaults to a Hann window but can be changed. **Example**: ```python import numpy as np sample_rate = 16000 # Sample rate of 16 kHz duration = 3.0 # Duration of 3 seconds t = np.linspace(0, duration, int(sample_rate * duration), endpoint=False) audio = 0.5 * np.sin(2 * np.pi * 220.0 * t) # Generate a 220 Hz sine wave frames = windowed_frames(audio, sample_rate) windowed = apply_window_function(frames) spectrogram = compute_fft(windowed) print(spectrogram.shape) # Expected output: (num_frames, frame_size / 2 + 1) ``` **Explanation**: - The `stft` function takes the audio signal and the sample rate as input. - It splits the signal into frames, applies a window function, computes the FFT for each frame, and assembles these into a spectrogram. - This provides a 2D NumPy array where rows correspond to time frames and columns to frequency bins.","solution":"import numpy as np from scipy.signal import get_window from scipy.fft import rfft def windowed_frames(audio: np.ndarray, sample_rate: int, frame_size: int = 1024, hop_length: int = 512) -> np.ndarray: Splits the audio signal into overlapping frames. :param audio: 1D NumPy array of audio data :param sample_rate: Sampling rate of the audio signal :param frame_size: Size of each frame :param hop_length: Number of samples to hop between frames :return: A 2D NumPy array where each row is a frame num_frames = 1 + (len(audio) - frame_size) // hop_length frames = np.lib.stride_tricks.as_strided( audio, shape=(num_frames, frame_size), strides=(audio.strides[0] * hop_length, audio.strides[0]) ) return frames def apply_window_function(frames: np.ndarray, window_type: str = \'hann\') -> np.ndarray: Applies a window function to each frame. :param frames: 2D NumPy array where each row is a frame :param window_type: Type of window function to apply (e.g., \'hann\', \'hamming\') :return: A 2D NumPy array of windowed frames window = get_window(window_type, frames.shape[1]) windowed_frames = frames * window return windowed_frames def compute_fft(windowed_frames: np.ndarray) -> np.ndarray: Computes the FFT for each windowed frame. :param windowed_frames: 2D NumPy array where each row is a windowed frame :return: A 2D NumPy array of the FFT results (spectrogram) return rfft(windowed_frames, axis=1)"},{"question":"# Problem Statement Create a function that reads a file containing a list of student names and their respective grades, computes the average grade for each student, and identifies the students whose average grade is above a specified threshold. # Functionality Requirements - Implement a function `get_top_students(file_path: str, threshold: float) -> list`. - The input file will have student names and grades in the following format (one student per line): `<student_name>: <grade1>, <grade2>, ..., <gradeN>` - Calculate the average grade for each student. - Return a list of student names whose average grade is above the given threshold. # Constraints - Grades are non-negative integers and can range from 0 to 100. - Each student will have at least one grade. - Handle cases where the file may not exist or is not readable gracefully. - The function should work efficiently even with large files. # Input - `file_path` (str): The path to the file containing student names and grades. - `threshold` (float): The grade threshold to filter top students. # Output - A list of student names whose average grade is above the specified threshold. # Examples Assume `students.txt` contains: ``` Alice: 80, 85, 90 Bob: 70, 75, 65 Charlie: 95, 100, 90 Dave: 60, 55, 65 ``` ```python get_top_students(\'students.txt\', 80) ``` should return: ```python [\'Alice\', \'Charlie\'] ``` # Scenario You are tasked with creating a report for the honor roll in a high school, where only students with an average grade above a certain threshold make it to the list. The system should read from a file containing raw grade data and produce a list of eligible students. # Performance Requirements - Ensure that the solution handles large files efficiently, as a high school could have hundreds or thousands of students. - Handle errors gracefully, ensuring the program does not crash if the file has formatting issues or is inaccessible. # Hints - Consider using the `with open()` statement for reading files to ensure proper resource management. - Use exception handling to manage potential file errors (e.g., FileNotFoundError). - Break down the problem into smaller functions such as reading the file, parsing grades, computing averages, and filtering by threshold.","solution":"def get_top_students(file_path: str, threshold: float) -> list: Reads a file containing student names and their grades, computes the average grade for each student, and returns the list of students whose average grade is above the specified threshold. Args: file_path (str): Path to the file containing student names and grades. threshold (float): The grade threshold to filter top students. Returns: list: List of student names whose average grade is above the threshold. top_students = [] try: with open(file_path, \'r\') as file: for line in file: if line.strip(): name, grades_str = line.split(\':\') grades = list(map(int, grades_str.split(\',\'))) average_grade = sum(grades) / len(grades) if average_grade > threshold: top_students.append(name.strip()) except (FileNotFoundError, IOError) as e: print(f\\"Error reading file: {e}\\") except ValueError as e: print(f\\"Error processing file content: {e}\\") return top_students"},{"question":"# Background Given a string of digits, you need to generate all possible strings by inserting any number of \\"+\\", \\"-\\", or nothing between the digits. Evaluate these expressions to determine which one yields the maximum integer value. # Problem Write a function `max_expression_value` that calculates the maximum possible value obtained by inserting \\"+\\" or \\"-\\" or keeping it as is (concatenating) between the digits of the given string. # Function Signature ```python def max_expression_value(digits: str) -> int: pass ``` # Input * `digits` (str): A string of digits (e.g., `\\"123\\"`). # Output * Returns the maximum integer value that can be obtained by inserting \\"+\\", \\"-\\", or no operation between the digits. # Example ```python max_expression_value(\\"123\\") # Returns 124 (1 + 2 + 3) max_expression_value(\\"105\\") # Returns 105 (1 concatenated with 05) max_expression_value(\\"10\\") # Returns 10 (1 concatenated with 0) ``` # Constraints * The length of `digits` is at least 2 and at most 12. * The input string contains only numeric characters (`0`-`9`). # Additional Notes * Consider all possible insertions of `+`, `-`, and concatenation (i.e., no operator) between the digits. * Evaluate each expression to find the one yielding the maximum value. * Ensure the function efficiently handles the generation and evaluation of expressions for the given constraints.","solution":"from itertools import product def max_expression_value(digits: str) -> int: n = len(digits) max_value = float(\'-inf\') if n == 0: return 0 # Generate all combinations of \'+\' and \'-\' and keep the place with nothing by an empty string operations = [\'+\', \'-\', \'\'] # Generate all possible combinations of operations for comb in product(operations, repeat=n-1): expression = digits[0] for i in range(1, n): expression += comb[i-1] + digits[i] try: value = eval(expression) except Exception: continue if value > max_value: max_value = value return max_value"},{"question":"# Problem Statement A word pyramid is a sequence of words such that each word is strictly longer than the previous word. Each word should only contain lower-case English letters. For example, the sequence `[\\"a\\", \\"at\\", \\"cat\\", \\"scat\\"]` is a word pyramid because each word gets longer step by step. Define `P(n)` to be the number of ways to form a word pyramid of length exactly `n` using the given words list. You can use each word only once in any given sequence. Your task is to write a function `count_word_pyramids(words: List[str], n: int) -> int` that returns the count of word pyramids of length exactly `n` that can be formed using the provided words. Function Signature ```python def count_word_pyramids(words: List[str], n: int) -> int: pass ``` Input - A list of strings `words` (1 ≤ len(words) ≤ 1000) - An integer `n` (1 ≤ n ≤ len(words)) Output - An integer representing the number of word pyramids of length exactly `n`. Constraints - Each word in the `words` list contains only lower-case English letters. - Ensure the function handles up to 1000 words and lengths up to 1000 effectively. Example ```python >>> count_word_pyramids([\\"a\\", \\"at\\", \\"bat\\", \\"cat\\", \\"scat\\", \\"tat\\"], 3) 4 # Possible sequences: [\'a\', \'at\', \'bat\'], [\'a\', \'at\', \'cat\'], [\'a\', \'at\', \'scat\'], [\'a\', \'tat\', \'scat\'] >>> count_word_pyramids([\\"a\\", \\"b\\", \\"c\\"], 2) 0 # No possible sequences since there are no words with increasing length. ``` # Requirements 1. Include a helper function to filter out potential word candidates that are strictly increasing in length. 2. Implement the main `count_word_pyramids` function using dynamic programming or combinatorial techniques to efficiently count valid sequences.","solution":"from typing import List def count_word_pyramids(words: List[str], n: int) -> int: # First, filter out words by their lengths word_by_length = {} for word in words: l = len(word) if l not in word_by_length: word_by_length[l] = [] word_by_length[l].append(word) lengths = sorted(word_by_length.keys()) dp = [[0] * len(lengths) for _ in range(n)] # Initialize dp with the first length counts for index in range(len(lengths)): dp[0][index] = len(word_by_length[lengths[index]]) for i in range(1, n): for j in range(len(lengths)): dp[i][j] = sum(dp[i-1][k] for k in range(j)) return sum(dp[n-1]) # Example usage: # count_word_pyramids([\\"a\\", \\"at\\", \\"bat\\", \\"cat\\", \\"scat\\", \\"tat\\"], 3) # This should output 4 based on the example provided."},{"question":"# Scenario You are tasked with developing a software application that processes customer reviews for a product sold on an e-commerce website. One specific requirement is to identify and remove duplicate reviews. To achieve this, you must implement a function that filters out duplicate reviews based on certain criteria to ensure that the review data is clean and accurate. # Task Implement the function `filter_duplicate_reviews` that follows these steps: 1. Normalize the text of all reviews by converting them to lowercase and removing leading/trailing whitespace. 2. Detect and remove duplicate reviews based on the `normalized_review_text`. A review is considered duplicate if its text matches that of another review after normalization. 3. Return a list of unique reviews, maintaining the original order of their first appearance. # Function Signature ```python def filter_duplicate_reviews(reviews: list) -> list: ``` # Input - `reviews`: A list of strings where each string represents a customer review. # Output - Returns a list of unique reviews as strings, preserving the input order. # Constraints - Each review is a non-empty string containing between 1 and 500 characters. - The list of reviews contains at least one review and up to 1,000 reviews. # Performance - The solution should efficiently handle up to the maximum input size. # Example ```python reviews = [ \\"Great product!\\", \\"Great product! \\", \\"I love it!\\", \\"great product!\\", \\"Would buy again!\\", \\" I love it! \\" ] print(filter_duplicate_reviews(reviews)) # Output should be: # [\\"Great product!\\", \\"I love it!\\", \\"Would buy again!\\"] ``` Use the provided method signatures and implement the logic within the `filter_duplicate_reviews` function to achieve the described functionality.","solution":"def filter_duplicate_reviews(reviews: list) -> list: Removes duplicate reviews from the list based on normalized review text. :param reviews: List of customer reviews :return: List of unique reviews maintaining the original order seen = set() unique_reviews = [] for review in reviews: normalized_review = review.strip().lower() if normalized_review not in seen: seen.add(normalized_review) unique_reviews.append(review) return unique_reviews"},{"question":"# Problem Statement You have been given an array of integers representing scores of a game and a value `K` which represents the top `K` scores that are to be considered. Your task is to implement a function `top_k_average` that computes the average of these top `K` scores. If there are fewer than `K` scores available, the function should return the average of all the scores present. # Function Signature ```python def top_k_average(scores: List[int], K: int) -> float: ``` # Constraints * ( 0 leq text{len(scores)} leq 10^6 ) * ( 1 leq K leq 10^6 ) * Each score in the array is an integer such that ( -10^6 leq text{score} leq 10^6 ). # Example ```python # Example 1 print(top_k_average([5, 3, 8, 6, 2], 3)) # should return 6.3333 (average of 8, 6, 5) # Example 2 print(top_k_average([1, 2, 3], 5)) # should return 2 (average of 1, 2, 3) ``` # Requirements 1. **Sorting**: The function must efficiently handle sorting large arrays to find the top `K` scores. 2. **Handling Edge Cases**: Properly handle scenarios where `K` is larger than the number of scores available in the array. 3. **Performance**: Ensure that the solution can handle the upper limit of constraints effectively, particularly the sorting step.","solution":"from typing import List def top_k_average(scores: List[int], K: int) -> float: Returns the average of the top K scores in the given list. If there are fewer than K scores, return the average of all the scores present. Args: scores (List[int]): List of integer scores. K (int): The number of top scores to consider for the average. Returns: float: The average of the top K scores. if not scores: return 0.0 if K > len(scores): K = len(scores) # Sorting the scores in descending order sorted_scores = sorted(scores, reverse=True) # Taking the top K scores top_k_scores = sorted_scores[:K] # Calculating the average of the top K scores average = sum(top_k_scores) / K return average"},{"question":"# Context Data structures are fundamental in computer science and allow efficient organization and retrieval of data. One commonly used data structure is the linked list. In a linked list, elements are stored in nodes that contain two fields: the data and a reference to the next node in the sequence. You are tasked with implementing a function that checks if two singly linked lists intersect and returns the intersection point, if any. # Objective Write a Python function `find_intersection` that takes the heads of two singly linked lists and determines the first common node at which they intersect. The function should handle various constraints and validate inputs appropriately. # Requirements 1. The function should accept exactly two parameters: `head1` and `head2`, both representing the heads of two singly linked lists. 2. The function should return the data value of the first intersection node if the linked lists intersect. If they do not intersect, the function should return `None`. 3. The function should handle input validation: - If either input is not an instance of the `ListNode` class, raise a `TypeError`. # Implementation Details - Traverse both linked lists to determine if they intersect. - If they intersect, identify and return the data of the intersection node. - Ensure input validation as specified. # Linked List Node Definition ```python class ListNode: def __init__(self, data=0, next_node=None): self.data = data self.next = next_node ``` # Input Format - `head1` (ListNode): The head of the first singly linked list. - `head2` (ListNode): The head of the second singly linked list. # Output Format - The data value of the first intersection node, or `None` if there is no intersection. # Examples 1. Given the linked lists: ``` 1 -> 2 -> 3 6 -> 7 / 4 -> 5 / ``` `find_intersection(head1, head2)` returns `6` 2. Given the linked lists: ``` 1 -> 2 -> 3 4 -> 5 / 6 -> 7 ``` `find_intersection(head1, head2)` returns `None` 3. Given the linked lists: ``` 1 -> 2 -> 3 -> 4 -> 5 6 -> 7 -> 8 -> 5 / 9 -> 10 ``` `find_intersection(head1, head2)` returns `5` 4. Given the linked lists: ``` 1 -> 2 -> 3 -> 4 5 / ``` `find_intersection(head1, head2)` returns `2` 5. `find_intersection(123, \'head\')` raises `TypeError: Inputs must be instances of ListNode` # Constraints - Ensure the function performs efficiently for typical use cases. - Linked lists can contain up to 10^6 nodes.","solution":"class ListNode: def __init__(self, data=0, next_node=None): self.data = data self.next = next_node def find_intersection(head1, head2): Determines the first common node at which two singly linked lists intersect. Parameters: head1 (ListNode): The head of the first singly linked list. head2 (ListNode): The head of the second singly linked list. Returns: int: The data value of the first intersection node, or None if there is no intersection. if not isinstance(head1, ListNode) or not isinstance(head2, ListNode): raise TypeError(\\"Inputs must be instances of ListNode\\") # Use two pointers to traverse both linked lists ptr1, ptr2 = head1, head2 while ptr1 != ptr2: # Move to the next node or switch to the other head ptr1 = ptr1.next if ptr1 else head2 ptr2 = ptr2.next if ptr2 else head1 return ptr1.data if ptr1 else None"},{"question":"# Problem Overview You are working on a text processing tool that removes duplicate words from a given string while maintaining the order of their first appearance. Your task is to write a function that cleans up the input text. # Function Signature ```python def remove_duplicates(text: str) -> str: pass ``` # Input * `text`: A string containing words. Words are separated by any combination of spaces or punctuation marks. Words are case-sensitive. # Output A string representing the cleaned text with duplicates removed. # Constraints 1. The input text length does not exceed 10,000 characters. 2. Words consist of only English letters and are separated by spaces or punctuation. # Examples ```python # Example 1 print(remove_duplicates(\\"Hello, hello world! hello World.\\")) # Expected Output: \\"Hello hello world World\\" # Example 2 print(remove_duplicates(\\"This-is-a test! This, is. a-test; a\\")) # Expected Output: \\"This is a test\\" # Example 3 print(remove_duplicates(\\"No duplicates here. No duplicates here.\\")) # Expected Output: \\"No duplicates here\\" # Example 4 print(remove_duplicates(\\"Python! Python, programming; python programming.\\")) # Expected Output: \\"Python programming python\\" ``` # Notes * The function should be case-sensitive, meaning \\"Hello\\" and \\"hello\\" are considered different words. * Punctuation marks should be treated as word boundaries but should be removed in the output. * Maintain the order of first appearance of each unique word. * Ensure the function handles various forms of punctuation correctly: periods, commas, semicolons, colons, exclamation marks, question marks, hyphens, and spaces.","solution":"import re def remove_duplicates(text: str) -> str: # Use regex to split the text by any non-alphabetic character words = re.split(r\'W+\', text) seen = set() result = [] for word in words: if word and word not in seen: seen.add(word) result.append(word) return \' \'.join(result)"},{"question":"You are asked to implement an encryption and decryption system for a text-based messaging application using the Ceasar Cipher technique. The Caesar Cipher is one of the simplest and most widely known encryption techniques. # Function Specifications **Function 1**: ```python def encrypt(text: str, shift: int) -> str: pass ``` **Function 2**: ```python def decrypt(encrypted_text: str, shift: int) -> str: pass ``` # Input * For `encrypt`: * `text`: A string containing the message to encrypt. * `shift`: An integer representing the number of positions each character in the text should be shifted. * For `decrypt`: * `encrypted_text`: A string containing the encrypted message. * `shift`: An integer representing the number of positions each character in the encrypted message should be shifted back to decode. # Output * For `encrypt`: A string representing the encrypted text. * For `decrypt`: A string representing the decrypted text. # Constraints * 1 ≤ length of text ≤ 1000 * 0 ≤ shift ≤ 25 * The text will consist of only lowercase alphabetic characters (a-z). # Requirements * Both functions should correctly apply and reverse the Caesar Cipher technique. * Ensure the functions handle edge cases, such as the end of the alphabet (\'z\' shifted by 1 should become \'a\'). * The output must be all lowercase and only alphabetic characters should be altered by the shift. # Example ```python # Encryption Example text = \\"hello\\" shift = 3 encrypted_text = encrypt(text, shift) # Encrypted Text Output: \\"khoor\\" # Decryption Example shift = 3 decrypted_text = decrypt(encrypted_text, shift) # Decrypted Text Output: \\"hello\\" ```","solution":"def encrypt(text: str, shift: int) -> str: encrypted_text = [] for char in text: if char.isalpha(): new_char = chr(((ord(char) - ord(\'a\') + shift) % 26) + ord(\'a\')) encrypted_text.append(new_char) else: encrypted_text.append(char) return \'\'.join(encrypted_text) def decrypt(encrypted_text: str, shift: int) -> str: decrypted_text = [] for char in encrypted_text: if char.isalpha(): new_char = chr(((ord(char) - ord(\'a\') - shift + 26) % 26) + ord(\'a\')) decrypted_text.append(new_char) else: decrypted_text.append(char) return \'\'.join(decrypted_text)"},{"question":"# Question: Implement and Test Heap Sort **Context:** Heap Sort is a popular and efficient in-place sorting algorithm that leverages a binary heap data structure. It is particularly renowned for its reliable performance and consistent O(n log n) time complexity. **Objective:** Your task is to implement the Heap Sort algorithm, ensuring the array is correctly sorted in-place. Once implemented, thoroughly validate your Heap Sort function with a series of test cases. **Function Signature:** ```python def heap_sort(array: list) -> list: Sorts the array using Heap Sort algorithm. Args: array (list): A list of elements to be sorted. Returns: list: A list containing the elements sorted in ascending order. pass ``` **Requirements:** * Implement Heap Sort to sort the array in-place. * Ensure the function returns the sorted array maintaining O(n log n) time complexity. **Input:** - A list of comparable elements, e.g., integers, floats. The input list can be of any length, including zero. **Output:** - A list with the elements sorted in ascending order. **Constraints:** - The input list can contain elements in any order, including already sorted or reverse sorted. - Ensure the space complexity of the algorithm remains O(1), apart from the input array itself. **Examples:** ```python >>> heap_sort([4, 3, 2, 1]) [1, 2, 3, 4] >>> heap_sort([-4, 20, 0, -50, 100, -1]) [-50, -4, -1, 0, 20, 100] >>> heap_sort([-.1, -.2, 1.3, -.8]) [-0.8, -0.2, -0.1, 1.3] >>> heap_sort([]) [] ``` **Edge Cases to Consider:** - Empty array `[]` - Arrays with duplicate elements, e.g., `[3, 3, 1, 1]` - Arrays with all identical elements, e.g., `[1, 1, 1, 1]` - Arrays with a single element, e.g., `[5]` **Notes:** - You may consider creating helper functions for heap operations (e.g., `heapify`, `build_heap`) to simplify the main `heap_sort` function. - Ensure that the heap property is maintained during the sorting process.","solution":"def heap_sort(array: list) -> list: Sorts the array using Heap Sort algorithm. Args: array (list): A list of elements to be sorted. Returns: list: A list containing the elements sorted in ascending order. def heapify(arr, n, i): largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[i] < arr[left]: largest = left if right < n and arr[largest] < arr[right]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) n = len(array) for i in range(n // 2 - 1, -1, -1): heapify(array, n, i) for i in range(n - 1, 0, -1): array[i], array[0] = array[0], array[i] heapify(array, i, 0) return array"},{"question":"# Problem Statement: You are assigned the task of balancing the load of several servers by distributing jobs based on their unique IDs in an equitable manner, where jobs with specific characteristics are distributed more efficiently. **Objective:** Write a function `distribute_jobs(jobs: List[int], servers: int) -> List[List[int]]` that takes a list of job IDs and the number of servers, and returns a list of lists where each inner list represents the jobs assigned to one of the servers. Your goal is to distribute the jobs in such a way that the difference between the highest and lowest number of jobs assigned to any server is minimal. **Input:** * A list of integers `jobs`, where each integer represents a job ID. * A single integer `servers` specifying the number of servers. **Output:** * A list of lists, each containing the job IDs assigned to that server. **Constraints:** * `jobs` list will have at least one job and at most 1000 jobs. * The number of `servers` will be a positive integer, and at most equal to the number of jobs. **Example:** ```python assert distribute_jobs([1, 2, 3, 4, 5, 6], 3) == [[1, 4], [2, 5], [3, 6]] assert distribute_jobs([10, 20, 30, 40], 2) == [[10, 30], [20, 40]] assert distribute_jobs([7, 8, 9], 1) == [[7, 8, 9]] ``` **Scenario:** Suppose you are responsible for managing server workloads in a distributed computing environment. To ensure efficient utilization of server resources, you need to assign jobs to servers in a way that balances the load as evenly as possible. Efficient job distribution will help prevent server overloads and ensure timely processing of all tasks.","solution":"from typing import List def distribute_jobs(jobs: List[int], servers: int) -> List[List[int]]: Distributes jobs among servers as evenly as possible. Args: jobs: List[int] - A list of job IDs. servers: int - Number of servers. Returns: List[List[int]] - A list of lists where each inner list represents the jobs assigned to one server. result = [[] for _ in range(servers)] for i, job in enumerate(jobs): result[i % servers].append(job) return result"},{"question":"# Problem Statement Write a function that determines if a string contains any permutation of a shorter substring. That is, given a string `s1` and another string `s2`, check if any permutation of `s2` is a substring of `s1`. # Function Signature ```python def is_permutation_in_string(s1: str, s2: str) -> bool: ``` # Input * **s1** (*str*): The main string in which to search for permutations (1 <= len(s1) <= 10^5). * **s2** (*str*): The substring whose permutations we need to find within `s1` (1 <= len(s2) <= 10^4). # Output * **bool**: True if any permutation of `s2` is a substring of `s1`, otherwise False. # Constraints * The input strings will only consist of lowercase English letters. * Handle edge cases where `s2` is longer than `s1` by returning False. * Ensure the solution is optimal and runs in linear time relative to the length of `s1`. # Example ```python >>> is_permutation_in_string(\\"oidbcaf\\", \\"abc\\") True >>> is_permutation_in_string(\\"oidbcafoo\\", \\"bafo\\") True >>> is_permutation_in_string(\\"oidbcafiaeb\\", \\"abf\\") False >>> is_permutation_in_string(\\"a\\", \\"ab\\") False >>> is_permutation_in_string(\\"abc\\", \\"abc\\") True >>> is_permutation_in_string(\\"abcde\\", \\"edcba\\") True ``` # Requirements * **Performance**: Your solution should run in linear time, making it efficient even for the upper limits of the input size. * **Edge Cases**: Consider cases where `s2` is an empty string, or where `s2` contains the same character repeated. Handle small strings as well as the maximum length constraints proficiently.","solution":"def is_permutation_in_string(s1: str, s2: str) -> bool: from collections import Counter len_s1, len_s2 = len(s1), len(s2) # Edge case where permutation of a longer string cannot fit in a shorter string if len_s2 > len_s1: return False s2_counter = Counter(s2) window_counter = Counter(s1[:len_s2]) if window_counter == s2_counter: return True for i in range(len_s2, len_s1): window_counter[s1[i]] += 1 window_counter[s1[i - len_s2]] -= 1 if window_counter[s1[i - len_s2]] == 0: del window_counter[s1[i - len_s2]] if window_counter == s2_counter: return True return False"},{"question":"# Scenario You are developing a feature for an e-commerce platform to help users find the best deals. One critical component is a system that can efficiently manage and query discounts for various products. You decide to implement a segment tree for this purpose. # Task Implement a Segment Tree class that supports efficient querying of the maximum discount within a given product price range. # Detailed Requirements 1. **Class**: `SegmentTree` 2. **Constructor**: `__init__(self, discounts: List[int])` - Input: A list `discounts` of integers representing discounts for products (length n). - Initializes the segment tree based on the provided discounts. 3. **Method**: `max_discount(self, left: int, right: int) -> int` - Input: Two integers `left` and `right` representing the range within the discounts list (inclusive). - Output: Returns the maximum discount within the specified range. 4. Assume that the discounts are positive integers. # Constraints 1. The length of the discounts list (n) will be `1 <= n <= 10^5`. 2. The values of `left` and `right` will be valid indices within the discounts list, `0 <= left <= right < n`. 3. Minimize the time complexity for both tree construction and range query operations. # Example Usage ```python # Example discounts: [20, 30, 50, 10, 75, 40] seg_tree = SegmentTree([20, 30, 50, 10, 75, 40]) # Maximum discount in the range [1, 4] is 75 assert seg_tree.max_discount(1, 4) == 75 # Maximum discount for the entire range [0, 5] is 75 assert seg_tree.max_discount(0, 5) == 75 # Maximum discount in the range [2, 2] is 50 (single element range) assert seg_tree.max_discount(2, 2) == 50 # Maximum discount in the range [3, 5] is 75 assert seg_tree.max_discount(3, 5) == 75 ``` Provide such a class implementation adhering to the above requirements. Also, include sufficient unit tests to validate the correctness of your implementation.","solution":"class SegmentTree: def __init__(self, discounts): self.n = len(discounts) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(discounts) def build(self, discounts): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = discounts[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def max_discount(self, left, right): left += self.n right += self.n + 1 max_disc = 0 while left < right: if left % 2 == 1: max_disc = max(max_disc, self.tree[left]) left += 1 if right % 2 == 1: right -= 1 max_disc = max(max_disc, self.tree[right]) left //= 2 right //= 2 return max_disc"},{"question":"# Problem Statement You are given two strings, `word1` and `word2`, and your task is to determine whether `word2` can be formed by deleting some characters from `word1` without reordering the remaining characters. If `word2` can be formed from `word1`, return the minimum number of deletions required from `word1` to achieve it. Otherwise, return `-1`. # Function Specifications Function 1: `can_form_by_deletion` - **Input**: - A string `word1`. - A string `word2`. - **Output**: - An integer representing the minimum number of deletions required to form `word2` from `word1` or `-1` if it is not possible. ```python def can_form_by_deletion(word1: str, word2: str) -> int: pass ``` # Constraints - Both input strings will have lengths between 1 and 10^5. - The strings consist of lowercase English letters only. # Example ```python word1 = \\"abcde\\" word2 = \\"ace\\" print(can_form_by_deletion(word1, word2)) # Expected output: 2 word1 = \\"abcde\\" word2 = \\"aec\\" print(can_form_by_deletion(word1, word2)) # Expected output: -1 word1 = \\"abcdefg\\" word2 = \\"bdf\\" print(can_form_by_deletion(word1, word2)) # Expected output: 4 ``` # Notes - If `word2` is an empty string, the output should be the length of `word1`. - Ensure your solution handles edge cases such as very long strings efficiently. - Optimize your solution to handle the largest input sizes within reasonable time limits.","solution":"def can_form_by_deletion(word1: str, word2: str) -> int: Determines whether word2 can be formed by deleting some characters from word1 without reordering the remaining characters. If possible, returns the minimum number of deletions required from word1 to achieve it. Otherwise, returns -1. m, n = len(word1), len(word2) if n == 0: return m # Initialize two pointers i, j = 0, 0 # Traverse through word1 and word2 while i < m and j < n: if word1[i] == word2[j]: j += 1 # Move the pointer of word2 i += 1 # Always move the pointer of word1 # Check if we have traversed through the entire word2 if j == n: return m - n else: return -1"},{"question":"# Problem: Heap-based Task Scheduler Context You are required to design a task scheduler that determines the minimum time required to complete a list of CPU tasks, considering that the same type of tasks must be separated by a cooldown period. Use a heap to manage and schedule tasks efficiently. Question Write a function `schedule_tasks(tasks: List[str], cooldown: int) -> int` that calculates the minimum time needed to execute all tasks in the given `tasks` list, where identical tasks must be separated by at least `cooldown` intervals. Input - A list of characters `tasks`, where each character represents a task. - An integer `cooldown`, specifying the cooldown period between two identical tasks. Output - Return an integer representing the minimum time required to execute all tasks. Algorithm Requirements 1. Use a heap to manage the scheduling of tasks. 2. Track the execution times of tasks considering the cooldown intervals. 3. Ensure efficient time and space complexity in the implementation. Constraints - The length of `tasks` will be in the range [1, 10000]. - `cooldown` will be a non-negative integer. Example ```python def schedule_tasks(tasks: List[str], cooldown: int) -> int: pass # Example usage: print(schedule_tasks([\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"], 2)) # Expected output: 8 ``` Performance Requirements - Ensure the function handles large input sizes effectively, both in terms of time complexity and memory usage. - Optimize the scheduling algorithm to minimize the total execution time required. # Explanation For the input example `[\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"]` with a cooldown of `2`, one optimal schedule would be: - `A -> B -> idle -> A -> B -> idle -> A -> B`. This takes 8 units of time to complete all tasks with the given cooldown constraint.","solution":"from heapq import heappush, heappop from collections import Counter, deque def schedule_tasks(tasks, cooldown): task_counts = Counter(tasks) max_heap = [] for task, count in task_counts.items(): heappush(max_heap, (-count, task)) # Use a max heap (negative counts) time = 0 cooldown_queue = deque() # To track cooldown period of tasks while max_heap or cooldown_queue: time += 1 if max_heap: count, task = heappop(max_heap) count += 1 # Increment because it\'s negative if count != 0: cooldown_queue.append((time + cooldown, count, task)) if cooldown_queue and cooldown_queue[0][0] == time: _, countdown, task = cooldown_queue.popleft() heappush(max_heap, (countdown, task)) return time"},{"question":"# Question Write a Python function `min_contiguous_subarray_sum(nums: List[int]) -> int`. This function should return the sum of the smallest contiguous subarray (minimum sum). # Input - `nums`: A list of integers representing the array (-10^6 ≤ nums[i] ≤ 10^6, 1 ≤ len(nums) ≤ 10^5) # Output - Return an integer representing the sum of the smallest contiguous subarray. # Example ```python >>> min_contiguous_subarray_sum([1, -3, 2, 1, -1]) -3 >>> min_contiguous_subarray_sum([2, -4, 6, 8, -10, 12]) -10 >>> min_contiguous_subarray_sum([-1, -2, -3, -4]) -10 ``` # Explanation 1. For the input `[1, -3, 2, 1, -1]`, the smallest contiguous subarray sum is provided by the subarray `[-3]`. 2. For the input `[2, -4, 6, 8, -10, 12]`, the smallest contiguous subarray sum is provided by the subarray `[-10]`. 3. For the input `[-1, -2, -3, -4]`, the smallest contiguous subarray sum is provided by the subarray `[-1, -2, -3, -4]`. # Constraints 1. The function must handle large input sizes efficiently, ensuring a time complexity of O(n). 2. Use a variation of Kadane\'s algorithm to find the minimum contiguous subarray sum. # Tips - Be cautious with negative numbers and ensure you track the overall minimum sum encountered. - An edge case to consider is when the entire array contains negative numbers. - Ensure your algorithm iterates through the array only once to achieve linear time complexity.","solution":"from typing import List def min_contiguous_subarray_sum(nums: List[int]) -> int: Returns the sum of the smallest contiguous subarray (minimum sum). min_current = min_global = nums[0] for num in nums[1:]: min_current = min(num, min_current + num) if min_current < min_global: min_global = min_current return min_global"},{"question":"# Problem You are given a platform that allows users to post text updates and replies to previously posted updates. Your task is to implement two functions: `post_update` and `post_reply` to handle this functionality. Each post and reply has a unique ID assigned sequentially starting from 1. # Requirements 1. The `post_update` function should create a new post and assign it a unique ID. 2. The `post_reply` function should create a reply to an existing post given its ID. Each reply should also have a unique ID. 3. Maintain a record of all posts and their replies in a dictionary. 4. Write independent tests to verify your implementation. # Constraints * A post or reply is represented as a dictionary with `id`, `content`, and optional `replies`. * The `content` will be a non-empty string with a length of up to 280 characters. * The system should support up to 10,000 posts and replies combined. # Input and Output Format - `post_update(content: str) -> int` - `post_reply(post_id: int, content: str) -> int` Here\'s an example of how these functions should work: ```python post_id = post_update(\'This is my first post!\') assert post_id == 1 reply_id = post_reply(post_id, \'This is a reply to the first post.\') assert reply_id == 2 reply_to_reply_id = post_reply(reply_id, \'This is a reply to the first reply.\') assert reply_to_reply_id == 3 ``` # Additional Information - You should maintain a dictionary `all_posts` where keys are post IDs and values are dictionaries representing the posts or replies. - Consider edge cases such as replying to a non-existent post. # Solution Template ```python class SocialPlatform: def __init__(self): self.all_posts = {} self.next_id = 1 def post_update(self, content: str) -> int: Post a new update to the platform and returns its unique ID. if not content or len(content) > 280: raise ValueError(\\"Content must be a non-empty string of up to 280 characters.\\") post_id = self.next_id self.all_posts[post_id] = {\'id\': post_id, \'content\': content, \'replies\': []} self.next_id += 1 return post_id def post_reply(self, post_id: int, content: str) -> int: Post a reply to an existing update with the given post_id and content, and returns the reply\'s unique ID. if post_id not in self.all_posts: raise ValueError(\\"Post ID does not exist.\\") if not content or len(content) > 280: raise ValueError(\\"Content must be a non-empty string of up to 280 characters.\\") reply_id = self.next_id reply = {\'id\': reply_id, \'content\': content, \'replies\': []} self.all_posts[post_id][\'replies\'].append(reply) self.all_posts[reply_id] = reply self.next_id += 1 return reply_id # Example usage: social_platform = SocialPlatform() post_id = social_platform.post_update(\'This is my first post!\') assert post_id == 1 reply_id = social_platform.post_reply(post_id, \'This is a reply to the first post.\') assert reply_id == 2 reply_to_reply_id = social_platform.post_reply(reply_id, \'This is a reply to the first reply.\') assert reply_to_reply_id == 3 ``` # Testing To test the implementation, consider creating several posts and replies, and verify that the IDs are assigned sequentially and the content is accurately stored and retrieved.","solution":"class SocialPlatform: def __init__(self): self.all_posts = {} self.next_id = 1 def post_update(self, content: str) -> int: Post a new update to the platform and returns its unique ID. if not content or len(content) > 280: raise ValueError(\\"Content must be a non-empty string of up to 280 characters.\\") post_id = self.next_id self.all_posts[post_id] = {\'id\': post_id, \'content\': content, \'replies\': []} self.next_id += 1 return post_id def post_reply(self, post_id: int, content: str) -> int: Post a reply to an existing update with the given post_id and content, and returns the reply\'s unique ID. if post_id not in self.all_posts: raise ValueError(\\"Post ID does not exist.\\") if not content or len(content) > 280: raise ValueError(\\"Content must be a non-empty string of up to 280 characters.\\") reply_id = self.next_id reply = {\'id\': reply_id, \'content\': content, \'replies\': []} self.all_posts[post_id][\'replies\'].append(reply) self.all_posts[reply_id] = reply self.next_id += 1 return reply_id # Example usage: social_platform = SocialPlatform() post_id = social_platform.post_update(\'This is my first post!\') assert post_id == 1 reply_id = social_platform.post_reply(post_id, \'This is a reply to the first post.\') assert reply_id == 2 reply_to_reply_id = social_platform.post_reply(reply_id, \'This is a reply to the first reply.\') assert reply_to_reply_id == 3"},{"question":"# Question: File Mining for Invoice Processing You are tasked with creating a tool that processes a batch of text files containing scanned invoices. Each invoice contains various lines, and you need to extract all lines containing prices, which follow a consistent format: a dollar sign `` followed by digits and optionally decimal places. Instructions 1. Implement a function `extract_prices_from_invoices(filepaths: List[str]) -> Dict[str, List[str]]`: * Takes a list of file paths as input. * Reads each file, extracting lines that contain a price. * Returns a dictionary where each key is the file path and the corresponding value is a list of lines containing prices. 2. Assume the file encoding is UTF-8. 3. You should handle file reading errors gracefully, logging them instead of halting execution. Constraints * There can be up to 1000 files. * Each file can be up to 50KB in size. Example ```python import os from typing import List, Dict def extract_prices_from_invoices(filepaths: List[str]) -> Dict[str, List[str]]: prices_dict = {} for filepath in filepaths: try: with open(filepath, \'r\', encoding=\'utf-8\') as file: lines = file.readlines() prices = [line.strip() for line in lines if \'\' in line and line.strip().startswith(\'\')] prices_dict[filepath] = prices except Exception as e: print(f\\"Error reading {filepath}: {e}\\") return prices_dict filepaths = [ \\"invoice1.txt\\", \\"invoice2.txt\\" ] # Assume the contents of the files are as follows: # invoice1.txt: # # Item A: 35.00 # Shipping: 5.00 # Total: 40.00 # # invoice2.txt: # # Item B: 15.25 # Handling: 1.75 # Total: 17.00 # output = extract_prices_from_invoices(filepaths) print(output) ``` Expected Output: ```python { \\"invoice1.txt\\": [\\"35.00\\", \\"5.00\\", \\"40.00\\"], \\"invoice2.txt\\": [\\"15.25\\", \\"1.75\\", \\"17.00\\"] } ``` Write your solution in Python.","solution":"import os from typing import List, Dict def extract_prices_from_invoices(filepaths: List[str]) -> Dict[str, List[str]]: prices_dict = {} for filepath in filepaths: try: with open(filepath, \'r\', encoding=\'utf-8\') as file: lines = file.readlines() prices = [line.strip() for line in lines if \'\' in line] prices_dict[filepath] = prices except Exception as e: print(f\\"Error reading {filepath}: {e}\\") return prices_dict"},{"question":"# Problem Statement Write a function to determine if a given string has all unique characters. The function should not use any additional data structures. # Function Signature ```python def is_unique(s: str) -> bool: ``` # Input * **s**: A string `s` (0 ≤ |s| ≤ 1000). # Output * A boolean value `True` if all characters in the string are unique, and `False` otherwise. # Constraints * You cannot use any additional data structures, including arrays, lists, or sets. * The solution should work in O(n) time complexity, where n is the length of the string. * Focus on minimizing space complexity. # Example ```python assert is_unique(\\"abcdef\\") == True assert is_unique(\\"aabbcc\\") == False assert is_unique(\\"\\") == True assert is_unique(\\"hello\\") == False assert is_unique(\\"world\\") == True ``` # Notes * Consider edge cases such as an empty string or strings with only one character. * Think about how you can leverage properties of the input characters and their representations to achieve the goal without additional data structures. * Ensure your function efficiently checks for uniqueness, particularly for large strings up to the maximum limit. # Testing Make sure your function passes the provided assertions and add more test cases to cover different scenarios, including large strings and all possible edge cases.","solution":"def is_unique(s: str) -> bool: Determines if a given string has all unique characters. if len(s) > 256: # There are only 256 different ASCII characters return False # Use a single integer (representing bits) to check unique characters checker = 0 for char in s: val = ord(char) if (checker & (1 << val)) > 0: return False checker |= (1 << val) return True"},{"question":"# Problem Statement You need to implement a function that takes in a list of integers and returns a new list containing the running total of the sum of the elements from the original list. The running total at each position in the new list should be the sum of the original list elements up to and including that position. Function Signature ```python def running_total(nums: List[int]) -> List[int]: Calculate the running total of a list of integers. :param nums: A list of integers. :return: A list of integers representing the running total of the input list. ``` Input * A single list of integers `nums` where -10^3 <= nums[i] <= 10^3 and 0 <= len(nums) <= 10^4. Output * A list of integers where each integer at index `i` is the sum of elements from the input list up to and including index `i`. Example ```python print(running_total([1, 2, 3, 4])) # Output: [1, 3, 6, 10] print(running_total([10, -5, 15, 20])) # Output: [10, 5, 20, 40] print(running_total([])) # Output: [] ``` # Requirements 1. Implement the `running_total` function that adheres to the given signature. 2. Ensure the function efficiently calculates the running total for varying input sizes. 3. Handle edge cases, such as an empty input list, gracefully.","solution":"from typing import List def running_total(nums: List[int]) -> List[int]: Calculate the running total of a list of integers. :param nums: A list of integers. :return: A list of integers representing the running total of the input list. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"# Problem Statement You are developing a basic text editor and need to implement a feature that performs find-and-replace operations within a document. Given a list of commands, each specifying either a \\"find\\" or a \\"replace\\" operation, execute these commands in order and return the modified document. # Requirements: Implement a function `execute_document_commands` that takes in: 1. A string `document` representing the initial text of the document. 2. A list of commands, where each command is represented as a tuple. The first element of the tuple is the command type (`\\"find\\"` or `\\"replace\\"`) and the subsequent elements are the parameters for the command. Your function should return the modified document after all commands have been executed. Constraints: * The document string is non-empty. * Commands are non-empty and correctly formatted. * The target and replacement substrings are non-empty. # Function Signature: ```python from typing import List, Tuple def execute_document_commands(document: str, commands: List[Tuple[str, str, str]]) -> str: pass ``` # Example: ```python def execute_document_commands(document: str, commands: List[Tuple[str, str, str]]) -> str: # Your implementation here # Example Usage document = \\"Hello world!\\" commands = [(\\"replace\\", \\"world\\", \\"universe\\"), (\\"find\\", \\"universe\\", \\"UNIVERSE\\")] print(execute_document_commands(document, commands)) # Output: \\"Hello UNIVERSE!\\" commands = [(\\"replace\\", \\"Hello\\", \\"Hi\\"), (\\"replace\\", \\"Hi\\", \\"Hey\\")] print(execute_document_commands(document, commands)) # Output: \\"Hey world!\\" ``` # Additional Examples: ```python document = \\"The quick brown fox jumps over the lazy dog.\\" commands = [(\\"replace\\", \\"quick\\", \\"fast\\"), (\\"replace\\", \\"dog\\", \\"cat\\")] print(execute_document_commands(document, commands)) # Output: \\"The fast brown fox jumps over the lazy cat.\\" document = \\"Sample text for testing.\\" commands = [(\\"find\\", \\"text\\", \\"TEXT\\"), (\\"replace\\", \\"testing\\", \\"example\\")] print(execute_document_commands(document, commands)) # Output: \\"Sample TEXT for example.\\" document = \\"Empty commands test.\\" commands = [] print(execute_document_commands(document, commands)) # Output: \\"Empty commands test.\\" document = \\"Lorem ipsum dolor sit amet.\\" commands = [(\\"replace\\", \\"Lorem\\", \\"LOREM\\"), (\\"replace\\", \\"amet\\", \\"AMET\\")] print(execute_document_commands(document, commands)) # Output: \\"LOREM ipsum dolor sit AMET.\\" ``` # Notes: * \\"find\\" operations only verify the presence of the substring without modifying the document. * If any command is out of the specified constraints, raise a `ValueError` with a suitable message.","solution":"from typing import List, Tuple def execute_document_commands(document: str, commands: List[Tuple[str, str, str]]) -> str: for command in commands: if len(command) != 3: raise ValueError(\\"Each command must be a tuple with three elements.\\") command_type, target, replacement = command if command_type not in (\\"find\\", \\"replace\\"): raise ValueError(\\"Command type must be either \'find\' or \'replace\'.\\") if command_type == \\"replace\\": document = document.replace(target, replacement) # Note: \\"find\\" command was incorrectly described to modify document, but it should not do anything. return document"},{"question":"# Coding Assessment Question Scenario: You are developing a software for a financial institution that needs to normalize transaction records for analysis. Each transaction record contains a sender, a receiver, and an amount. To normalize these records, you need to convert the names to lowercase and round the amounts to two decimal places. Task: Write a Python function `normalize_transactions(transactions: List[Tuple[str, str, float]]) -> List[Tuple[str, str, float]]` that: * Takes a list of tuples where each tuple contains (`str` sender, `str` receiver, `float` amount). * Converts the sender and receiver names to lowercase. * Rounds the transaction amount to two decimal places. * Returns a list of normalized transaction tuples. # Specifications: * **Input**: A list of tuples, where each tuple contains: * `str` sender - non-empty string representing the sender\'s name. * `str` receiver - non-empty string representing the receiver\'s name. * `float` amount - a floating-point number representing the transaction amount. * **Output**: A list of tuples with: * `str` sender (in lowercase). * `str` receiver (in lowercase). * `float` amount rounded to two decimal places. # Constraints: * Each sender and receiver name will be a non-empty string. * Each transaction amount will be a non-negative floating-point number. * If the input list contains invalid data types, your function should raise a `TypeError` with an appropriate error message. * If any sender or receiver name is an empty string, your function should raise a `ValueError`. # Example Inputs and Outputs: 1. `normalize_transactions([(\\"Alice\\", \\"BOB\\", 123.456), (\\"CAROL\\", \\"DAVE\\", 78.910)])` should return `[(\'alice\', \'bob\', 123.46), (\'carol\', \'dave\', 78.91)]` 2. `normalize_transactions([(\\"John\\", \\"JANE\\", 50.004), (\\"MIKE\\", \\"NANCY\\", 100.126)])` should return `[(\'john\', \'jane\', 50.00), (\'mike\', \'nancy\', 100.13)]` # Edge Cases: 1. If the input contains an empty sender or receiver name, your function should raise `ValueError` with the message \\"Sender and receiver names must be non-empty strings\\". 2. If any element of the input list is not a tuple of the specified format, raise `TypeError` with the message \\"Each transaction must be a tuple of (str, str, float)\\". # Example Error Handling: 1. `normalize_transactions([(\\"\\", \\"BOB\\", 100.00)])` should raise `ValueError` with the message \\"Sender and receiver names must be non-empty strings\\". 2. `normalize_transactions([(\\"Alice\\", 123, 123.45)])` should raise `TypeError` with the message \\"Each transaction must be a tuple of (str, str, float)\\". # Note: Ensure error messages are clear and handle all edge cases to maintain the integrity and robustness of the function.","solution":"from typing import List, Tuple def normalize_transactions(transactions: List[Tuple[str, str, float]]) -> List[Tuple[str, str, float]]: normalized_transactions = [] for transaction in transactions: if not isinstance(transaction, tuple) or len(transaction) != 3: raise TypeError(\\"Each transaction must be a tuple of (str, str, float)\\") sender, receiver, amount = transaction if not isinstance(sender, str) or not isinstance(receiver, str) or not isinstance(amount, (int, float)): raise TypeError(\\"Each transaction must be a tuple of (str, str, float)\\") if not sender or not receiver: raise ValueError(\\"Sender and receiver names must be non-empty strings\\") normalized_sender = sender.lower() normalized_receiver = receiver.lower() normalized_amount = round(float(amount), 2) normalized_transactions.append((normalized_sender, normalized_receiver, normalized_amount)) return normalized_transactions"},{"question":"# Coding Assessment Question Scenario Write a function that takes a list of integers and two integer values, `a` and `b`, then partitions the list into three parts: values less than `a`, values between `a` and `b` (inclusive), and values greater than `b`. The order of elements within each partition should maintain their original relative order. Function Signature ```python def partition_list(nums: list, a: int, b: int) -> list: pass ``` Input - `nums` (list): A list of integers which can be positive, negative, or zero. - `a` (int): Lower bound of the middle partition. - `b` (int): Upper bound of the middle partition. Output - (list): A new list where elements are partitioned into three parts as described above. Constraints - The input list `nums` will contain up to 10^6 elements. - The values of `a` and `b` will be such that `a <= b`. Examples ```python # Example 1: # Input: nums = [3, 1, 2, 4, 5], a = 2, b = 4 # Output: [1, 3, 2, 4, 5] # Explanation: Elements less than 2: [1] # Elements between 2 and 4 (inclusive): [3, 2, 4] # Elements greater than 4: [5] # Example 2: # Input: nums = [10, 5, 6, 3, 2, 8], a = 4, b = 7 # Output: [3, 2, 5, 6, 10, 8] # Explanation: Elements less than 4: [3, 2] # Elements between 4 and 7 (inclusive): [5, 6] # Elements greater than 7: [10, 8] # Example 3: # Input: nums = [], a = 1, b = 2 # Output: [] # Explanation: The input list is empty, so the output is also an empty list. # Example 4: # Input: nums = [1, 1, 1, 1], a = 1, b = 1 # Output: [1, 1, 1, 1] # Explanation: All elements are between 1 and 1 (inclusive), so no changes in order are needed. ``` Requirements - Your implementation must handle large input sizes efficiently. - The function should maintain the original relative order of elements within each partition. Guidelines 1. Initialize three different lists to separately store elements less than `a`, between `a` and `b` (inclusive), and greater than `b`. 2. Traverse the input list and append each element to the appropriate list based on its value. 3. Concatenate the three lists to produce the final output. Good luck!","solution":"def partition_list(nums: list, a: int, b: int) -> list: Partitions the list into three parts: values less than `a`, values between `a` and `b` (inclusive), and values greater than `b`. less_than_a = [] between_a_and_b = [] greater_than_b = [] for num in nums: if num < a: less_than_a.append(num) elif a <= num <= b: between_a_and_b.append(num) else: greater_than_b.append(num) return less_than_a + between_a_and_b + greater_than_b"},{"question":"# Problem Statement You have been tasked with developing a queue data structure for a system that processes tasks in a sequential order. Queues must support typical operations and handle error conditions gracefully. **Specifications**: Implement a `Queue` class with the following methods: 1. `enqueue(data: T)`: Add an element `data` to the end of the queue. 2. `dequeue() -> T`: Remove and return the front element of the queue. 3. `front() -> T`: Return (but do not remove) the front element of the queue. 4. `is_empty() -> bool`: Return `True` if the queue is empty, `False` otherwise. 5. `is_full() -> bool`: Return `True` if the queue is full, `False` otherwise. 6. `size() -> int`: Return the number of elements currently in the queue. **Error Handling**: - *QueueOverflowError*: Raised when attempting to enqueue onto a full queue. - *QueueUnderflowError*: Raised when attempting to dequeue from or access the front of an empty queue. **Input/Output**: - Ensure that operations handle edge cases properly. - The queue should be limited by a maximum size constraint upon initialization. # Inputs: - Integer `limit`: Defines the maximum number of elements the queue can hold. - Sequence of operations requests including `enqueue`, `dequeue`, `front`, `is_empty`, `is_full`, `size`. # Outputs: - For `enqueue`: None. - For `dequeue` and `front`: The respective element. - For `is_empty`, `is_full`: Boolean value indicating state of queue. - For `size`: Integer indicating the queue\'s current size. # Example: ```python Q = Queue(3) Q.enqueue(10) Q.enqueue(20) print(Q.dequeue()) # Output: 10 print(Q.front()) # Output: 20 print(Q.is_empty()) # Output: False Q.enqueue(30) print(Q.is_full()) # Output: False Q.enqueue(40) Q.enqueue(50) # Raises QueueOverflowError: Too many elements ``` # Constraints: - Queue size `limit` ranges from 1 to 10^4. - Operations on the queue should be optimized for efficiency. # Task: Implement the `Queue` class described above, ensuring proper function and error handling compliance.","solution":"class QueueOverflowError(Exception): pass class QueueUnderflowError(Exception): pass class Queue: def __init__(self, limit): self.limit = limit self.queue = [] def enqueue(self, data): if self.is_full(): raise QueueOverflowError(\\"Too many elements\\") self.queue.append(data) def dequeue(self): if self.is_empty(): raise QueueUnderflowError(\\"No elements to dequeue\\") return self.queue.pop(0) def front(self): if self.is_empty(): raise QueueUnderflowError(\\"No elements in the queue\\") return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) >= self.limit def size(self): return len(self.queue)"},{"question":"Graph Colorability Check Using DFS # Objective: You\'re tasked with implementing a Python function to determine if a given undirected graph can be colored using two colors such that no two adjacent vertices have the same color. Use Depth-First Search (DFS) to achieve this. # Requirements: 1. **Function Definition**: Implement the function `is_bipartite(graph)` that determines if the graph is bipartite. 2. **DFS Traversal**: Utilize DFS to assign colors to the graph\'s vertices while checking for bipartiteness. 3. **Edge Handling**: Ensure proper handling of cases where the graph has disconnected components. # Input & Output Format: - **Input**: - `graph`: A dictionary representing an undirected graph where keys are node identifiers and values are lists of connected nodes. - **Output**: - Return `True` if the graph is bipartite, otherwise `False`. # Examples: ```python # Example graph 1 (Bipartite) graph1 = { 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] } print(is_bipartite(graph1)) # Output: True # Example graph 2 (Not Bipartite) graph2 = { 0: [1, 2], 1: [0, 2], 2: [0, 1] } print(is_bipartite(graph2)) # Output: False ``` # Constraints: - The input graph is undirected and can have multiple nodes and edges. - Assume the input graph is connected. - Handle cases with single nodes or isolated subgraphs appropriately. # Hint: - Use a color array to keep track of the colors assigned to each vertex. For simplicity, you can use two colors represented by `1` and `-1`. # Performance: - Ensure the function runs efficiently, with the complexity being proportional to the number of vertices and edges, i.e., O(V + E). # Implementation: Define your `is_bipartite` function using the structure and guidelines above to verify graph bipartiteness using DFS.","solution":"def is_bipartite(graph): Determine if the given graph is bipartite using DFS. Parameters: graph (dict): A dictionary representing an undirected graph where keys are node identifiers and values are lists of connected nodes. Returns: bool: True if the graph is bipartite, otherwise False. color = {} def dfs(node, c): if node in color: return color[node] == c color[node] = c return all(dfs(neigh, -c) for neigh in graph[node]) for node in graph: if node not in color and not dfs(node, 1): return False return True"},{"question":"Question: Finding the Second Highest Number in a List Given a list of integers, write a function to find the second highest number. Your function should return the second highest number in the list, ensuring that the list contains at least two distinct elements. If the list fails to meet this condition, the function should return `None`. # Function Signature ```python def find_second_highest(nums: List[int]) -> Union[int, None]: Find the second highest number in a list of integers. :param nums: List[int] - A list of integers. :return: Union[int, None] - The second highest number in the list, or None if the list has fewer than two distinct elements. >>> find_second_highest([4, 1, 5, 2, 3]) 4 >>> find_second_highest([1, 2]) 1 >>> find_second_highest([5, 5, 5]) None >>> find_second_highest([1]) None ``` # Input - `nums`: A list of integers which may contain duplicate values. # Output - The second highest number in the list if there are at least two distinct elements. - `None` if the list has fewer than two distinct elements. # Examples ```python nums = [4, 1, 5, 2, 3] output = find_second_highest(nums) # Expected output: 4 nums = [1, 2] output = find_second_highest(nums) # Expected output: 1 nums = [5, 5, 5] output = find_second_highest(nums) # Expected output: None nums = [1] output = find_second_highest(nums) # Expected output: None ``` # Notes: - The function should handle cases where the list has duplicated values properly. - Ensure the function can handle both small and large lists efficiently. - You can assume that the list contains only integer values. ```python from typing import List, Union def find_second_highest(nums: List[int]) -> Union[int, None]: if len(nums) < 2: return None unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort() return unique_nums[-2] ```","solution":"from typing import List, Union def find_second_highest(nums: List[int]) -> Union[int, None]: if len(nums) < 2: return None unique_nums = list(set(nums)) if len(unique_nums) < 2: return None unique_nums.sort() return unique_nums[-2]"},{"question":"# Coding Question Scenario As a developer, you are often tasked with performing operations on lists of integers. One common requirement is to transform a list such that each element is replaced by the sum of all the previous elements in the list, effectively creating a cumulative sum list. This transformation is useful for computing running totals, which find applications in various financial and data analysis scenarios. Requirements Implement a function `cumulative_sum` that processes a list of integers and replaces each element in the list with the cumulative sum up to that point. Function Signature ```python def cumulative_sum(collection: list[int]) -> list[int]: ``` Input * `collection`: A list of integers. Output * A list of integers where each element is the cumulative sum of the elements up to that point in the input list. Constraints 1. The length of `collection` will not exceed 100 for simplicity. 2. The elements of `collection` can be positive, negative, or zero. Example ```python >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([4, -1, 2, -2]) [4, 3, 5, 3] ``` Edge Cases 1. `collection` is empty. 2. `collection` has one element. 3. `collection` contains a mix of positive and negative numbers. 4. `collection` contains zeros. Note: Handle any edge cases appropriately such that the function remains robust under various input conditions.","solution":"def cumulative_sum(collection: list[int]) -> list[int]: Returns a list where each element is the cumulative sum of the elements up to that point in the input list. if not collection: return [] result = [collection[0]] for i in range(1, len(collection)): result.append(result[-1] + collection[i]) return result"},{"question":"# Duplicate Finder in N-Dimensional Array Problem Statement You are given an n-dimensional list of integers where n can be any positive integer representing the number of dimensions of the array. Write a function to find and return a list of all duplicate integers that appear more than once in this array. Each duplicate integer should appear only once in the returned list. Function Signature ```python def find_duplicates(nd_array: Union[List, int]) -> List[int]: pass ``` Input * `nd_array`: A nested list of arbitrary depth (greater than 0) containing integer elements. The structure could be irregular meaning not all sublists are of the same length. Output * A list of integers representing the duplicate elements found in the input array. Each duplicate should appear only once in the output list. Constraints * All integers in `nd_array` are not guaranteed to be unique. * The integers in `nd_array` range from -10^6 to 10^6. * The length of `nd_array` (considering it as a flat list) is between 1 and 10^6 elements. Example ```python # Example 1 nd_array = [1, [2, 3, [4, [5, 3, 2]]], 4] print(find_duplicates(nd_array)) # Output: [3, 2, 4] # Example 2 nd_array = [[1, 2, [3], [4, 5, 6]], [7, 8, 9], [10, 1, 2]] print(find_duplicates(nd_array)) # Output: [1, 2] ``` # Hint Use a set to keep track of seen elements and another list or set to store duplicates. A recursive function can help traverse the n-dimensional array appropriately.","solution":"from typing import Union, List def find_duplicates(nd_array: Union[List, int]) -> List[int]: def flatten(array): Helper function to flatten n-dimensional list. if isinstance(array, int): return [array] flat_list = [] for item in array: flat_list.extend(flatten(item)) return flat_list # Flatten the n-dimensional list flat_array = flatten(nd_array) # Find duplicates seen = set() duplicates = set() for num in flat_array: if num in seen: duplicates.add(num) else: seen.add(num) return list(duplicates)"},{"question":"# Problem Statement Given a string containing only digits and lowercase letters, write a function that returns the sum of all numerical substrings (i.e., substrings consisting of consecutive digits) found in the string. If there are no such substrings, return 0. **Function Signature**: ```python def sum_of_numerical_substrings(s: str) -> int: ``` # Input Format * `s`: A string containing only digits (0-9) and lowercase letters (a-z). - Example: `\\"a123bc34d8ef34\\"` # Output Format * An integer representing the sum of all numerical substrings in the string. - Example: `199` (The numerical substrings are `123`, `34`, `8`, and `34`, and their sum is `199`) # Constraints * The length of the string `s` should not exceed (10^5). # Performance Requirements * The solution should have a time complexity of O(n) where n is the length of the string. # Example: ```python s = \\"a123bc34d8ef34\\" sum_of_numerical_substrings(s) # Output: 199 ``` If the input string does not contain any numerical substrings, return 0. # Edge Cases * When `s` is an empty string, return 0. * When `s` has no numerical substrings, return 0. # Constraints * String length: (1 leq text{len(s)} leq 100000) Use the given code snippet for reference, but ensure your solution adheres to the constraints and requirements outlined above.","solution":"def sum_of_numerical_substrings(s: str) -> int: Returns the sum of all numerical substrings in the input string. :param s: A string containing only digits and lowercase letters :return: The sum of all numerical substrings current_sum = 0 current_number = \'\' for char in s: if char.isdigit(): current_number += char else: if current_number: current_sum += int(current_number) current_number = \'\' if current_number: current_sum += int(current_number) return current_sum"},{"question":"# Fill Missing Words in Sentences **Context:** You are developing a language-learning application that helps users improve their vocabulary. One of the exercises you want to implement involves filling in missing words in a sentence using a list of provided words. You will write a function to replace placeholders in a sentence with words from the provided list. **Objective:** Write a function `fill_sentence` that takes a sentence with placeholders and a list of words, then returns the sentence with the placeholders replaced by the words. **Function Signature:** ```python def fill_sentence(sentence: str, words: list) -> str: ``` **Inputs:** * `sentence (str)`: A string representing the sentence with placeholders. Placeholders are represented by `{}`. * `words (list)`: A list of strings where each string corresponds to a word that should replace a placeholder in the sentence. **Outputs:** * A `str` that represents the sentence with the placeholders filled. **Constraints:** * The number of placeholders `{}` in the sentence will match the number of words in the list. * Each placeholder `{}` in the sentence must be replaced by a word from the list in the given order. **Example Usage:** ```python sentence = \\"The {} brown {} jumps over the {} dog.\\" words = [\\"quick\\", \\"fox\\", \\"lazy\\"] result = fill_sentence(sentence, words) print(result) # Output: \\"The quick brown fox jumps over the lazy dog.\\" ``` **Notes:** * Ensure that the order of words in the list exactly matches the order of placeholders in the sentence. * Handle possible edge cases such as empty sentences or lists. Your function should efficiently handle typical use cases in the language-learning application, ensuring quick substitution of words even for longer sentences.","solution":"def fill_sentence(sentence: str, words: list) -> str: Fills in the placeholders in a sentence with the corresponding words from the list. Args: sentence (str): The sentence containing placeholders represented by \'{}\'. words (list): A list of words to replace the placeholders. Returns: str: The sentence with the placeholders replaced by the words from the list. for word in words: sentence = sentence.replace(\\"{}\\", word, 1) return sentence"},{"question":"# Problem Scenario Your task is to design a code that assists a library system in managing its inventory of books. Specifically, the system needs a function that can accurately determine the borrowing status of a particular book based on its unique identifier. # Task Implement the `is_book_available` function in Python that will check if a given book is available in the library inventory based on its identifier. # Function Signature ```python def is_book_available(inventory: dict, book_id: str) -> bool: ... ``` # Constraints - Each book in the library inventory is represented by a dictionary where the keys are unique book identifiers (strings) and the values are boolean (True if the book is available, False if it is not). - `inventory` (dict): A dictionary representing the library’s book inventory. - `book_id` (str): A string representing the unique identifier of the book. # Input - `inventory`: A dictionary where the key is a book identifier (string) and the value is a boolean indicating its availability. - `book_id`: A string representing the unique identifier of the book to check. # Output - A boolean value: `True` if the book is available in the inventory (`inventory`), otherwise `False`. # Example ```python library_inventory = { \\"book_1\\": True, \\"book_2\\": False, \\"book_3\\": True, \\"book_4\\": False } print(is_book_available(library_inventory, \\"book_1\\")) # Output: True print(is_book_available(library_inventory, \\"book_4\\")) # Output: False print(is_book_available(library_inventory, \\"book_5\\")) # Output: False ``` # Note - If the specified `book_id` is not present in the `inventory`, the function should return `False`. - Ensure that the function handles all edge cases, including an empty inventory dictionary and invalid `book_id` inputs.","solution":"def is_book_available(inventory: dict, book_id: str) -> bool: This function checks if a given book (identified by its book_id) is available in the library inventory. Parameters: inventory (dict): A dictionary representing the library’s book inventory. book_id (str): A string representing the unique identifier of the book. Returns: bool: True if the book is available in the inventory, otherwise False. return inventory.get(book_id, False)"},{"question":"# Context: You are helping a company organize their product inventory. The company wants to implement a system that can track their products and generate a summary of the total value of all products currently in stock. Each product has a name, a price, and a quantity in stock. # Problem Statement: Implement a class `Product` and another class `Inventory` that allows adding products and calculating the total inventory value. Your implementation should be clear, easy to understand, and efficient. # Class Definitions: Product Class: Create a class `Product` with the following attributes: - `name` (str): The name of the product. - `price` (float): The price of the product. - `quantity` (int): The quantity of the product in stock. Inventory Class: Create a class `Inventory` with the following methods: - `add_product(product: Product) -> None`: Adds a `Product` instance to the inventory. - `total_value() -> float`: Returns the total value of the inventory, which is the sum of the value of all products (price * quantity for each product). # Function Signature: ```python class Product: def __init__(self, name: str, price: float, quantity: int): pass class Inventory: def __init__(self): pass def add_product(self, product: Product) -> None: pass def total_value(self) -> float: pass ``` # Constraints: * The name of the product will be a non-empty string with a maximum length of 100 characters. * The price of the product will be a non-negative float. (0 <= price <= 10^4) * The quantity of the product will be a non-negative integer. (0 <= quantity <= 10^6) # Inputs: * You will receive a series of operations to add products and one operation to calculate the total value of the inventory. # Outputs: * Your methods should not return anything except for `total_value`, which should return a float representing the total value of all products in the inventory. # Example: ```python # Example usage inventory = Inventory() inventory.add_product(Product(\\"Laptop\\", 1000.00, 5)) inventory.add_product(Product(\\"Smartphone\\", 500.00, 10)) inventory.add_product(Product(\\"Tablet\\", 300.00, 7)) assert inventory.total_value() == 1000.00 * 5 + 500.00 * 10 + 300.00 * 7 ``` # Additional Notes: * Ensure your implementation handles floating point arithmetic correctly. * You are encouraged to add any helper methods if necessary to keep your code organized and readable. # Evaluation: Your solution will be evaluated based on: * Correctness * Efficiency * Readability and organization of the code * Handling of edge cases","solution":"class Product: def __init__(self, name: str, price: float, quantity: int): Initializes a new Product instance. self.name = name self.price = price self.quantity = quantity class Inventory: def __init__(self): Initializes a new Inventory instance. self.products = [] def add_product(self, product: Product) -> None: Adds a Product instance to the inventory. self.products.append(product) def total_value(self) -> float: Returns the total value of the inventory. total = 0.0 for product in self.products: total += product.price * product.quantity return total"},{"question":"# Problem Statement As part of a robotics simulation project, you are required to implement a `Robot` class that can move in a 2D grid. The robot should be capable of making basic movements based on a command sequence and report its final position, and you will demonstrate your understanding of object-oriented programming (OOP) principles such as inheritance, encapsulation, and method overriding. # Goal Create a `Robot` class that extends the provided `BaseRobot` class. Your task is to: 1. Implement methods to handle movement in four directions: up, down, left, and right. 2. Create a method to execute a sequence of these movements and report the final coordinates of the robot. # Implementation Robot Class 1. **Movement Methods** * Implement movement methods (`move_up`, `move_down`, `move_left`, `move_right`). * Each method should update the robot\'s position accordingly. 2. **Execute Command Sequence** * Implement the `execute_commands` method that takes in a sequence of commands (e.g., \\"UUDDLRLR\\") and executes the corresponding movement methods. * Commands: - \'U\' for moving up - \'D\' for moving down - \'L\' for moving left - \'R\' for moving right # Input and Output Format ```python class Robot(BaseRobot): def move_up(self): # Implementation for moving up def move_down(self): # Implementation for moving down def move_left(self): # Implementation for moving left def move_right(self): # Implementation for moving right def execute_commands(self, commands): # Implementation for executing command sequence # Expected Input robot = Robot() robot.execute_commands(\\"UUDDLRLR\\") print(robot.get_position()) # Expected Output: The robot\'s final coordinates as a tuple # Constraint # The starting position of the robot is (0, 0). ``` # Constraints and Performance Requirements 1. The robot should start at the position `(0, 0)`. 2. The sequence of commands can be of any length, but each command is always one of \'U\', \'D\', \'L\', \'R\'. 3. Report the final position of the robot after all commands are executed. 4. The robot should handle commands efficiently. # Example Scenario ```python # Create a Robot instance robot = Robot() # Execute a command sequence robot.execute_commands(\\"UUDDLRLR\\") # Get the final position print(robot.get_position()) # Output: (0, 0) ``` # Write your Robot class below: ```python class BaseRobot: def __init__(self): self.x = 0 self.y = 0 def get_position(self): return (self.x, self.y) class Robot(BaseRobot): def move_up(self): self.y += 1 def move_down(self): self.y -= 1 def move_left(self): self.x -= 1 def move_right(self): self.x += 1 def execute_commands(self, commands): for command in commands: if command == \'U\': self.move_up() elif command == \'D\': self.move_down() elif command == \'L\': self.move_left() elif command == \'R\': self.move_right() ```","solution":"class BaseRobot: def __init__(self): self.x = 0 self.y = 0 def get_position(self): return (self.x, self.y) class Robot(BaseRobot): def move_up(self): self.y += 1 def move_down(self): self.y -= 1 def move_left(self): self.x -= 1 def move_right(self): self.x += 1 def execute_commands(self, commands): for command in commands: if command == \'U\': self.move_up() elif command == \'D\': self.move_down() elif command == \'L\': self.move_left() elif command == \'R\': self.move_right()"},{"question":"Question: In this task, you are required to implement a function that determines if a given string is a palindrome. A palindrome is a string that reads the same backwards as forwards, ignoring non-alphanumeric characters and case sensitivity. This exercise is intended to evaluate your string manipulation and comparison skills. # Requirements: 1. **Function**: `def is_palindrome(s: str) -> bool:` 2. **Input**: * A string `s`, e.g., `\\"A man, a plan, a canal: Panama\\"`. 3. **Output**: * A boolean value `True` if the string is a palindrome, `False` otherwise. 4. **Constraints**: * The input string can be empty or contain up to `10,000` characters. 5. **Performance**: * Target O(n) time complexity. * O(1) additional space—use only fixed-size buffers if needed. # Scenario: Your cousin, a literature enthusiast, has a collection of sentences and phrases. They want to find out which ones are palindromes to include them in their new book of quirky facts. They ask for your help to automate this task for consistency and efficiency. # Example: Input: `\\"A man, a plan, a canal: Panama\\"` Output: `True` Input: `\\"race a car\\"` Output: `False` # Edge Cases to Consider: * The algorithm should handle empty strings gracefully by returning `True` because an empty string can be considered a trivial palindrome. * It should accurately identify palindromic strings regardless of case and ignore non-alphanumeric characters. * Consider cases where the input string contains a mix of letters, numbers, and special characters. # Additional Tests: Make sure your implementation passes the expected outputs for the following scenarios: 1. Input: `\\" \\"` Output: `True` 2. Input: `\\"No lemon, no melon\\"` Output: `True` 3. Input: `\\"Was it a car or a cat I saw?\\"` Output: `True` 4. Input: `\\"hello\\"` Output: `False` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness.","solution":"def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome, ignoring non-alphanumeric characters and case. Parameters: s (str): The input string to check. Returns: bool: True if the string is a palindrome, False otherwise. # Use two pointers to check characters from both ends left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 # Compare characters if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# Question: Compare Strings Based on Custom Dictionary Order Context You are tasked with comparing two strings based on a custom dictionary order provided as a string of unique characters. This custom order defines the hierarchy of characters rather than the usual alphabetical order. Your implementation should be able to compare any two strings and determine their relative ordering according to this custom dictionary. Task 1. Implement the `compare_strings` function that compares two given strings based on a custom dictionary order. 2. Your implementation should use the provided custom dictionary order to determine which string comes first. Function Signature ```python def compare_strings(s1: str, s2: str, custom_order: str) -> int: pass ``` Input * `s1`: First string to be compared. * `s2`: Second string to be compared. * `custom_order`: A string representing the custom dictionary order. Output * An integer: * `-1` if `s1` is less than `s2` based on the custom order. * `1` if `s1` is greater than `s2` based on the custom order. * `0` if `s1` is equal to `s2` based on the custom order. Constraints * 1 <= len(s1), len(s2) <= 100 * len(custom_order) == 26 (It contains every letter of the alphabet exactly once) * Both `s1` and `s2` consist only of lowercase English letters. Example ```python >>> compare_strings(\\"apple\\", \\"banana\\", \\"zyxwvutsrqponmlkjihgfedcba\\") 1 >>> compare_strings(\\"cat\\", \\"car\\", \\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> compare_strings(\\"dog\\", \\"dog\\", \\"abcdefghijklmnopqrstuvwxyz\\") 0 ``` Notes * Ensure you handle edge cases such as strings with different lengths. * Consider performance bottlenecks and optimize accordingly. * Include comprehensive tests to validate your `compare_strings` implementation.","solution":"def compare_strings(s1: str, s2: str, custom_order: str) -> int: # Create a dictionary to store the custom order custom_index = {char: index for index, char in enumerate(custom_order)} # Get the length of the shorter string to avoid IndexError min_len = min(len(s1), len(s2)) # Compare character by character using the custom order for i in range(min_len): if s1[i] != s2[i]: if custom_index[s1[i]] < custom_index[s2[i]]: return -1 else: return 1 # If all characters matched so far, then the shorter string is less if len(s1) < len(s2): return -1 elif len(s1) > len(s2): return 1 else: return 0"},{"question":"Coding Question: Longest Increasing Subsequence with Duplicate Elements # Context: The Longest Increasing Subsequence (LIS) problem is a classic algorithmic challenge in computer science. When considering sequences with duplicate elements, it’s critical to correctly identify and count the LIS while taking duplicates into account. # Problem Statement: Implement a function `longest_increasing_subsequence(arr: List[int]) -> int` that returns the length of the longest strictly increasing subsequence in the given array `arr`. Input: - `arr`: A list of integers that may contain duplicate values. Output: - Returns an integer representing the length of the longest strictly increasing subsequence. # Constraints: - The input list can have up to 1000 elements. - The elements of the list are in the range of -1000 to 1000. # Examples: Example 1: ```python arr = [1, 2, 2, 3] assert longest_increasing_subsequence(arr) == 3 # LIS = [1, 2, 3] ``` Example 2: ```python arr = [4, 10, 4, 3, 8, 9] assert longest_increasing_subsequence(arr) == 3 # LIS = [4, 8, 9] or [3, 8, 9] ``` Example 3: ```python arr = [10, 9, 2, 5, 3, 7, 101, 18] assert longest_increasing_subsequence(arr) == 4 # LIS = [2, 3, 7, 101] ``` # Notes: 1. The solution should handle edge cases such as empty array and single-element array. 2. Optimizations using dynamic programming or binary search are advisable for larger inputs. ```python def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 dp = [] for num in arr: index = bisect_left(dp, num) if index == len(dp): dp.append(num) else: dp[index] = num return len(dp) ```","solution":"from typing import List from bisect import bisect_left def longest_increasing_subsequence(arr: List[int]) -> int: Function to find the length of the longest strictly increasing subsequence in the given array. if not arr: return 0 dp = [] # This will store the smallest tail of all increasing subsequences of given lengths for num in arr: # Find the index where this num can be placed in the dp list index = bisect_left(dp, num) # If index is equal to the length of dp array, append num if index == len(dp): dp.append(num) else: # Otherwise, replace the existing value with num to maintain minimum tail value dp[index] = num return len(dp)"},{"question":"# Code Challenge - Find the Missing Number in a Range You are to solve the following problem by implementing a function `find_missing_number`: Problem Description Given an array containing n distinct numbers taken from the range 0 to n, find the one number that is missing from the range. Function Signature ```python def find_missing_number(arr: list) -> int: ``` Input - `arr`: List of integers of size n containing distinct numbers from the range 0 to n, except for one missing number. Output - Return the single integer from the range 0 to n that is missing from the array. Performance Constraints - The solution should have a time complexity of O(n) and a space complexity of O(1), not including the input list. Example ```python def find_missing_number(arr: list) -> int: # Implement your solution here pass if __name__ == \\"__main__\\": print(find_missing_number([3, 0, 1])) # Expected Output: 2 print(find_missing_number([0, 1])) # Expected Output: 2 print(find_missing_number([9,6,4,2,3,5,7,0,1])) # Expected Output: 8 ``` **Note**: - You must not use extra list or dictionary-based data structures to achieve O(1) space usage. - The input array will always have exactly one missing number from the range. **Considerations**: - Consider the properties of arithmetic progressions and summation formulas to help simplify your implementation. - Ensure that your function works efficiently even for the largest values of n.","solution":"def find_missing_number(arr: list) -> int: Returns the missing number from the range 0 to n in the input array. n = len(arr) total_sum = n * (n + 1) / 2 array_sum = sum(arr) return int(total_sum - array_sum)"},{"question":"# Scenario You are part of an AI development team, and your current task is to implement some foundational algorithms for natural language processing. One common problem is to check if a word can be constructed by rearranging the letters of another word, which is fundamental in tasks such as spell-checking and text analysis. # Task Write a function to determine if one word is an anagram of another. # Function: `is_anagram` Input - Two strings `word1` and `word2` representing the words to compare. Output - A boolean `True` if `word1` is an anagram of `word2`, and `False` otherwise. Example ```python assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"triangle\\", \\"integral\\") == True assert is_anagram(\\"apple\\", \\"pale\\") == False assert is_anagram(\\"anagram\\", \\"nagaram\\") == True ``` Constraints - Consider case insensitivity (e.g., \\"Listen\\" and \\"silent\\" should be considered anagrams). - Ignore spaces and punctuation (e.g., \\"a gentleman\\" and \\"elegant man\\" should be considered anagrams). # Notes - Avoid using sorting to achieve the goal as it may be inefficient for long strings. - Ensure the solution processes inputs in a time-efficient manner. - Implement error handling for invalid inputs (e.g., non-string inputs).","solution":"import string def is_anagram(word1, word2): Determines if word1 is an anagram of word2. Parameters: - word1: First word to compare (string). - word2: Second word to compare (string). Returns: - True if word1 is an anagram of word2, False otherwise. if not isinstance(word1, str) or not isinstance(word2, str): raise ValueError(\\"Both inputs must be strings.\\") # Normalize inputs by converting to lowercase and removing non-alphabetic characters translater = str.maketrans(\\"\\", \\"\\", string.punctuation + \\" \\") word1 = word1.lower().translate(translater) word2 = word2.lower().translate(translater) # Use a frequency dictionary to count occurrences of each character def char_frequency(word): freq = {} for char in word: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq return char_frequency(word1) == char_frequency(word2)"},{"question":"# Question You are asked to implement a min-heap data structure in Python with efficient insertion and deletion operations. This data structure must support dynamic resizing and be implemented using an array (list in Python). Ensure your implementation maintains the heap property and allows for efficient retrieval of the minimum element. Specific Requirements: 1. **Class Name**: MinHeap 2. **Methods to Implement**: * `__init__(self)`: Initialize an empty heap. * `insert(self, item: int) -> None`: Insert a new integer into the heap. * `extract_min(self) -> int`: Remove and return the smallest element from the heap. * `peek_min(self) -> int`: Return the smallest element without removing it. Raise `IndexError` if the heap is empty. * `is_empty(self) -> bool`: Return True if the heap is empty, else False. * `clear(self) -> None`: Clear the heap. 3. **Input**: Variably through method calls. 4. **Output**: Variably through method returns. Constraints: * Your implementation must handle dynamic resizing of the underlying array. * If attempting to extract or peek at the minimum element from an empty heap, raise an `IndexError`. Performance Requirements: * **Time Complexity**: * Insertion must be O(log n). * Extracting the minimum element must be O(log n). * Peeking at the minimum element must be O(1). # Example Usage: ```python heap = MinHeap() print(heap.is_empty()) # True heap.insert(10) heap.insert(4) heap.insert(15) heap.insert(1) print(heap.peek_min()) # 1 print(heap.extract_min()) # 1 print(heap.extract_min()) # 4 heap.clear() print(heap.is_empty()) # True try: heap.peek_min() # Raises IndexError except IndexError as e: print(e) # Heap is empty. ```","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, item: int) -> None: self.heap.append(item) self._sift_up(len(self.heap) - 1) def extract_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty.\\") if len(self.heap) == 1: return self.heap.pop() min_item = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return min_item def peek_min(self) -> int: if self.is_empty(): raise IndexError(\\"Heap is empty.\\") return self.heap[0] def is_empty(self) -> bool: return len(self.heap) == 0 def clear(self) -> None: self.heap = [] def _sift_up(self, index: int) -> None: parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._sift_up(parent_index) def _sift_down(self, index: int) -> None: smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._sift_down(smallest)"},{"question":"# Context As a software developer, you are often required to manipulate and process data stored in various formats. One common task is handling CSV (Comma-Separated Values) data. To test your skills in data parsing and manipulation, you need to write a function that processes CSV data to extract useful information based on specified criteria. # Task Implement a function that takes a string formatted as CSV data and returns a list of rows where the value in a specified column matches a given search string. The first row of the CSV data contains the column headers. # Function Signature ```python def filter_csv(data: str, column_name: str, search_value: str) -> List[List[str]]: ``` # Input - `data` (string): Input string formatted as CSV data. - `column_name` (string): The name of the column to search. - `search_value` (string): The value to search for in the specified column. # Output - Returns a list of lists, where each inner list represents a row from the CSV data where the value in the specified column matches the search string. # Examples ```python data = name,age,city Alice,30,New York Bob,25,Los Angeles Chloe,35,New York David,40,Chicago assert filter_csv(data, \'city\', \'New York\') == [[\'Alice\', \'30\', \'New York\'], [\'Chloe\', \'35\', \'New York\']] assert filter_csv(data, \'age\', \'25\') == [[\'Bob\', \'25\', \'Los Angeles\']] assert filter_csv(data, \'name\', \'David\') == [[\'David\', \'40\', \'Chicago\']] ``` # Constraints 1. The input string will be a well-formed CSV string with columns separated by commas and rows separated by newlines. 2. The input string will have at least one row of data and one column header. 3. The `column_name` will always match one of the headers in the CSV data. 4. The `search_value` will only search for exact matches in the specified column. # Edge Cases 1. If there are no rows where the specified column matches the `search_value`, the function should return an empty list. 2. The function should handle CSV data with various data types (e.g., strings, integers) seamlessly. 3. Ensure the function processes CSV data efficiently, even for moderately large datasets (up to thousands of rows and dozens of columns).","solution":"from typing import List def filter_csv(data: str, column_name: str, search_value: str) -> List[List[str]]: # Split the data into rows rows = data.split(\'n\') # Separate the header and the rest of the data header = rows[0].split(\',\') data_rows = rows[1:] # Find the index of the specified column if column_name not in header: raise ValueError(\\"Column name not found in the CSV headers\\") column_index = header.index(column_name) # Filter rows based on the search value in the specified column filtered_rows = [] for row in data_rows: cells = row.split(\',\') if cells[column_index] == search_value: filtered_rows.append(cells) return filtered_rows"},{"question":"# Coding Assessment Question You are tasked with developing a tool to transform data for a machine learning preprocessing step. Specifically, you need to normalize a list of numerical values. Normalization involves scaling the data to a specific range, typically between 0 and 1. **Task**: Implement a function `normalize_data` that takes a list of numerical values and normalizes them to the range ([0, 1]). Function Signature ```python def normalize_data(data: List[float]) -> List[float]: pass ``` Input * `data` (List[float]): A list of numerical values that need to be normalized. The list contains at least two elements. Output * Returns a list of normalized values, with each element transformed to the range ([0, 1]). Constraints * `2 <= len(data) <= 10^6` * (-10^9 leq data[i] leq 10^9) for each element in `data`. Performance Requirements * The function should have a linear time complexity relative to the size of the input list. # Example Example Input ```python data = [100, 200, 300, 400, 500] ``` Example Output ```python [0.0, 0.25, 0.5, 0.75, 1.0] ``` **Explanation**: The input data is scaled such that the minimum value (100) maps to 0.0 and the maximum value (500) maps to 1.0, with all other values scaled accordingly. Your task is to implement the function considering various edge cases, performance constraints, and efficient handling of large input sizes.","solution":"from typing import List def normalize_data(data: List[float]) -> List[float]: min_val = min(data) max_val = max(data) if min_val == max_val: # If all values in the data are the same, return 0 for each. return [0.0] * len(data) normalized_data = [(x - min_val) / (max_val - min_val) for x in data] return normalized_data"},{"question":"# Problem Statement Implement a function that takes a string and determines if it is possible to re-arrange the characters to form a palindrome. If it\'s possible, your function should return one of the possible palindromic strings. If it is not possible, return an empty string. # Function Signature ```python def palindrome_permutation(s: str) -> str: pass ``` # Input Format * A string `s`, containing only lowercase alphabetic characters (a-z). # Output Format * One of the possible palindromic strings if it can be rearranged to form a palindrome. * An empty string if no such arrangement exists. # Constraints * The length of the string `s` will be between 1 and 1000 characters. # Example `palindrome_permutation(\\"aabb\\")` should return `\\"abba\\"`, `\\"baab\\"`, or any other valid palindrome. `palindrome_permutation(\\"abc\\")` should return `\\"\\"` as it cannot be rearranged into a palindrome. # Notes * A palindromic string reads the same forward and backward. * Pay attention to the output format ensuring the function correctly returns a valid palindrome or an empty string.","solution":"def palindrome_permutation(s: str) -> str: from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # A string can form a palindrome if at most one character has an odd count odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: return \\"\\" first_half = [] middle = [] for char, count in char_count.items(): if count % 2 != 0: middle = [char] first_half.extend([char] * (count // 2)) # Create the first half and mirror it to form the second half first_half_str = \'\'.join(first_half) second_half_str = first_half_str[::-1] return first_half_str + \'\'.join(middle) + second_half_str"},{"question":"# Coding Challenge: Median Filtering of a Signal Context You are asked to implement a median filter, a non-linear digital filtering technique, often used to remove noise from signals. It involves sliding a window across the signal, sorting the values within the window, and replacing the central value with the median of those values. Problem Statement Write a Python function `median_filter(signal: List[int], k: int) -> List[int]` that applies a median filter to the input signal. The window size `k` determines the number of elements in the current window being analyzed. Function Signature ```python def median_filter(signal: List[int], k: int) -> List[int]: pass ``` Parameters * `signal`: A list of integers representing the signal to be filtered. * `k`: An odd integer representing the size of the window to apply median filtering. Returns * A list of integers representing the filtered signal. Constraints 1. The window size `k` must be a positive odd integer; otherwise, raise a `ValueError`. 2. The length of the input signal must be at least as large as the window size `k`. 3. Implement the function efficiently to handle large signals. Examples ```python # Example 1 result = median_filter([1, 2, 3, 4, 5], 3) # Window 1: [1, 2, 3] => median is 2 # Window 2: [2, 3, 4] => median is 3 # Window 3: [3, 4, 5] => median is 4 assert result == [2, 3, 4] # Example 2 result = median_filter([4, 1, 7, 8, 2, 5], 3) # Window 1: [4, 1, 7] => median is 4 # Window 2: [1, 7, 8] => median is 7 # Window 3: [7, 8, 2] => median is 7 # Window 4: [8, 2, 5] => median is 5 assert result == [4, 7, 7, 5] # Example 3 try: result = median_filter([1, 2, 3, 4, 5], 2) except ValueError as e: assert str(e) == \\"Window size k must be a positive odd integer\\" # Example 4 try: result = median_filter([1, 2, 3], 5) except ValueError as e: assert str(e) == \\"Signal length must be at least as large as the window size k\\" ```","solution":"def median_filter(signal, k): Applies a median filter to the input signal. Parameters: signal (list): A list of integers representing the signal to be filtered. k (int): An odd integer representing the size of the window to apply median filtering. Returns: list: A list of integers representing the filtered signal. Raises: ValueError: If k is not a positive odd integer or if the length of the signal is less than the window size k. if k <= 0 or k % 2 == 0: raise ValueError(\\"Window size k must be a positive odd integer\\") if len(signal) < k: raise ValueError(\\"Signal length must be at least as large as the window size k\\") half_k = k // 2 filtered_signal = [] for i in range(len(signal) - k + 1): window = signal[i:i+k] median = sorted(window)[half_k] filtered_signal.append(median) return filtered_signal"},{"question":"# Coding Assessment Question: Merge Two Sorted Lists into One Without Duplicates You have been provided with two non-decreasingly sorted lists of integers `list1` and `list2`. Write a function `merge_unique_sorted(list1: list[int], list2: list[int]) -> list[int]` that merges these two lists into a single sorted list without any duplicates. Input: * Two lists of integers `list1` and `list2`, each being non-decreasingly sorted and containing only unique elements. Output: * A single list of integers that contains all the elements from `list1` and `list2` merged into a non-decreasingly sorted list without any duplicates. Example: ```python >>> merge_unique_sorted([1, 3, 5], [2, 3, 6]) [1, 2, 3, 5, 6] >>> merge_unique_sorted([-5, -3, 0], [-4, -3, 0, 2]) [-5, -4, -3, 0, 2] >>> merge_unique_sorted([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_unique_sorted([], [1, 2, 3]) [1, 2, 3] >>> merge_unique_sorted([1, 2, 3], []) [1, 2, 3] >>> merge_unique_sorted([], []) [] ``` Constraints: * Both input lists `list1` and `list2` can be empty. * All integers in `list1` and `list2` lie within a reasonably small range to avoid overflow. * There are no duplicate elements within each individual list. Performance Requirements: * Your solution should run in O(n + m) time complexity, where `n` and `m` are the lengths of `list1` and `list2`, respectively. * Your solution should use O(1) extra space beyond the input lists and the output list. Notes: * Make sure to handle edge cases such as one or both lists being empty. * The output list must maintain the non-decreasing order without duplicates. Implement the `merge_unique_sorted` function based on the guidelines provided above: ```python def merge_unique_sorted(list1: list[int], list2: list[int]) -> list[int]: # Your implementation here pass ```","solution":"def merge_unique_sorted(list1: list[int], list2: list[int]) -> list[int]: # Initialize pointers for list1 and list2 i, j = 0, 0 merged_list = [] # Traverse both lists and merge them into a single sorted list while i < len(list1) and j < len(list2): if list1[i] < list2[j]: if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 elif list1[i] > list2[j]: if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 else: # list1[i] == list2[j] if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 j += 1 # Append remaining elements from list1 while i < len(list1): if not merged_list or merged_list[-1] != list1[i]: merged_list.append(list1[i]) i += 1 # Append remaining elements from list2 while j < len(list2): if not merged_list or merged_list[-1] != list2[j]: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Robot Path Planning You are required to develop a path planning algorithm for a robot in a grid. The robot starts at the top-left corner of a grid and aims to reach the bottom-right corner. Some cells in the grid may be blocked, which means the robot cannot move through them. The robot can move up, down, left, or right. Your task is to find one valid path from the start to the goal if it exists. # Requirements 1. **Function to Find Path**: Write a function `find_path` that returns a path from the start to the goal. - **Input**: - `grid`: a 2D list representing the grid, where `0` indicates a free cell and `1` indicates a blocked cell. - **Output**: - A list of tuples indicating the path coordinates from start to goal if a path exists, otherwise `None`. # Constraints - The grid dimensions (n x m) will be positive integers within the range [2, 100]. - The grid will always have a free cell at the start `(0, 0)` and at the goal `(n-1, m-1)` positions. - The robot cannot move diagonally. # Example ```python grid = [ [0, 0, 1, 0], [0, 0, 0, 0], [1, 0, 1, 1], [0, 0, 0, 0] ] find_path(grid) ``` This should return one valid path from `(0, 0)` to `(3, 3)` such as: ```python [(0, 0), (0, 1), (1, 1), (1, 2), (1, 3), (2, 3), (3, 3)] ``` or another valid path if multiple solutions exist. If there is no valid path, it should return `None`. # Notes - You can utilize algorithms like BFS (Breadth-First Search) or DFS (Depth-First Search) to find the path. - Ensure that your solution efficiently handles edge cases and large grids. - Avoid using external libraries for pathfinding algorithms.","solution":"def find_path(grid): from collections import deque def is_valid_move(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, [(0, 0)])]) visited = set((0, 0)) while queue: x, y, path = queue.popleft() if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return path for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, path + [(nx, ny)])) return None"},{"question":"# Coding Assessment Question You are tasked with implementing a function that processes a stream of log entries and identifies suspicious login attempts. This will test your understanding of regular expressions, data handling, and stream processing. # Question **Problem Statement:** Write a function `detect_suspicious_logins(log_entries: List[str]) -> List[str]` that processes a list of log entries and identifies any suspicious login attempts based on predefined criteria. Each log entry is a string in the format: `\\"[timestamp] USER <username> <operation> from IP <ip_address>\\"` # Criteria for Suspicious Activity: 1. More than 3 login attempts from the same IP address within a 5-minute window. 2. Log entries include the exact time in the format `YYYY-MM-DD HH:MM:SS`. **Input:** - `log_entries` (List[str]): A list of log entry strings. **Output:** - A list of IP addresses that have suspicious login attempts. # Constraints: - Assume the list of log entries is in chronological order. - Log time precision is to the second. - Handle log entries with invalid formats gracefully by ignoring them. - Optimize the function to handle large logs efficiently. # Example ```python def detect_suspicious_logins(log_entries: List[str]) -> List[str]: pass # Your implementation here # Example log entries: logs = [ \\"[2023-07-19 10:20:01] USER john LOGIN from IP 192.168.1.1\\", \\"[2023-07-19 10:21:15] USER jane LOGIN from IP 192.168.1.1\\", \\"[2023-07-19 10:22:30] USER mike LOGIN from IP 192.168.1.1\\", \\"[2023-07-19 10:23:45] USER john LOGIN from IP 192.168.1.1\\", \\"[2023-07-19 10:24:30] USER jane LOGIN from IP 192.168.2.1\\", \\"[2023-07-19 10:25:20] USER mike LOGIN from IP 192.168.1.1\\", ] # Call the function: suspicious_ips = detect_suspicious_logins(logs) # Expected output: print(suspicious_ips) # Output: [\'192.168.1.1\'] ``` Provide well-documented code, handle errors appropriately, and ensure performance is adequate for large datasets. Use appropriate libraries to manage dates and times if necessary.","solution":"import re from collections import defaultdict from datetime import datetime, timedelta def detect_suspicious_logins(log_entries): Processes a list of log entries and identifies any suspicious login attempts based on predefined criteria. :param log_entries: List of log entry strings :return: List of IP addresses with suspicious login attempts # Regular expression to match the log entries log_pattern = re.compile(r\'[(.*?)] USER S+ LOGIN from IP (S+)\') login_attempts = defaultdict(list) suspicious_ips = set() for entry in log_entries: match = log_pattern.match(entry) if match: timestamp_str, ip_address = match.groups() timestamp = datetime.strptime(timestamp_str, \'%Y-%m-%d %H:%M:%S\') login_attempts[ip_address].append(timestamp) # Remove timestamps older than 5 minutes from the current timestamp login_attempts[ip_address] = [t for t in login_attempts[ip_address] if timestamp - timedelta(minutes=5) <= t <= timestamp] # Check if there are more than 3 login attempts in the last 5 minutes if len(login_attempts[ip_address]) > 3: suspicious_ips.add(ip_address) return list(suspicious_ips)"},{"question":"# Context You are developing a small command-line utility to analyze text files. The utility needs to provide various insights about the contents of the file, such as word frequencies and the number of unique words. # Problem Statement Write a function `analyze_text(file_path: str) -> dict` that reads a text file from the given file path and returns a dictionary with the following information: - `total_words` (int): The total number of words in the file. - `unique_words` (int): The number of unique words in the file. - `word_frequencies` (dict): A dictionary where the keys are words and the values are the number of times each word appears in the file. Function Signature ```python def analyze_text(file_path: str) -> dict: pass ``` Input - `file_path` (str): The path to the text file to be analyzed. Output - (dict): A dictionary containing the analysis results as described above. # Requirements 1. Words should be considered case-insensitive (e.g., \\"Word\\" and \\"word\\" should be the same). 2. The function should handle punctuation correctly, ensuring that words do not include trailing or leading punctuation. 3. Provide meaningful error messages if a problem occurs (e.g., file not found, invalid file format). 4. Handle large files efficiently without loading the entire file into memory at once. Example Assume the file at `sample.txt` contains the following text: ``` Hello world! Hello Python programmers. Welcome to the world of Python. ``` The output of the function should be: ```python { \\"total_words\\": 9, \\"unique_words\\": 6, \\"word_frequencies\\": { \\"hello\\": 2, \\"world\\": 2, \\"python\\": 2, \\"programmers\\": 1, \\"welcome\\": 1, \\"to\\": 1, \\"the\\": 1, \\"of\\": 1 } } ``` # Constraints - The maximum file size is 10MB. - The function should not use any external libraries beyond Python\'s standard library. # Notes 1. Consider using a generator to process the file line by line. 2. Ensure the code is modular and easy to test with unit tests. You may need to split the functionality into smaller helper functions. 3. Remember to strip punctuation from words and convert them to lowercase for accurate word frequency counts.","solution":"import re from collections import defaultdict def analyze_text(file_path: str) -> dict: Analyzes the text file at the given file path. Args: file_path (str): The path to the text file. Returns: dict: A dictionary containing total words, unique words, and word frequencies. word_count = 0 word_frequencies = defaultdict(int) word_pattern = re.compile(r\'bw+b\') try: with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = word_pattern.findall(line.lower()) word_count += len(words) for word in words: word_frequencies[word] += 1 except FileNotFoundError: raise FileNotFoundError(f\\"The file at path {file_path} does not exist.\\") except Exception as e: raise Exception(f\\"An error occurred while reading the file: {e}\\") unique_words = len(word_frequencies) return { \\"total_words\\": word_count, \\"unique_words\\": unique_words, \\"word_frequencies\\": dict(word_frequencies) }"},{"question":"# Connected Islands In a small archipelago, there are several islands connected by bridges. The islands and the bridges connecting them form a graph. Each island is represented by a node, and each bridge is represented by an edge with a unique positive integer weight that denotes the distance between the islands. You are asked to find the shortest path to travel from one specific island to another. Implement the Dijkstra\'s algorithm to calculate the shortest path. Task You are required to implement a function `shortest_path` that takes the number of islands, a list of bridges, a start island, and an end island, and returns the shortest distance between the start and end islands. If there\'s no path between them, return -1. Function Signature ```python def shortest_path(num_islands: int, bridges: List[Tuple[int, int, int]], start: int, end: int) -> int: pass ``` Input * `num_islands` (int): The number of islands. * `bridges` (List[Tuple[int, int, int]]): A list of tuples representing the bridges where each tuple `(a, b, c)` denotes a bridge between island `a` and island `b` with a distance `c`. * `start` (int): The starting island. * `end` (int): The destination island. Output * Returns the shortest distance between the start and end islands. If no path exists, return -1. Constraints * `2 <= num_islands <= 1000` * `1 <= len(bridges) <= 10000` * `1 <= a, b <= num_islands` * `1 <= c <= 1000` * There are no duplicate bridges, and no bridge connects an island to itself. Examples * Example 1: - Input: `num_islands = 5`, `bridges = [(1, 2, 2), (1, 3, 4), (3, 4, 1), (2, 4, 7)]`, `start = 1`, `end = 4` - Output: `5` * Example 2: - Input: `num_islands = 3`, `bridges = [(1, 2, 1), (2, 3, 2)]`, `start = 1`, `end = 3` - Output: `3` * Example 3: - Input: `num_islands = 4`, `bridges = [(1, 2, 5), (2, 3, 10)]`, `start = 1`, `end = 4` - Output: `-1` Requirements * Use Dijkstra\'s algorithm to find the shortest path. * Ensure the algorithm efficiently handles the constraints. * Handle the case where no path exists gracefully.","solution":"import heapq from typing import List, Tuple def shortest_path(num_islands: int, bridges: List[Tuple[int, int, int]], start: int, end: int) -> int: # Create adjacency list for the graph graph = {i: [] for i in range(1, num_islands + 1)} for a, b, c in bridges: graph[a].append((b, c)) graph[b].append((a, c)) # Dijkstra\'s algorithm initialization distance = {i: float(\'inf\') for i in range(1, num_islands + 1)} distance[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If we reached the end node, return the shortest distance if current_node == end: return current_distance # If we found a shorter path to the current node, process it if current_distance <= distance[current_node]: for neighbor, weight in graph[current_node]: distance_through_current = current_distance + weight # Only consider this new path if it\'s better if distance_through_current < distance[neighbor]: distance[neighbor] = distance_through_current heapq.heappush(priority_queue, (distance_through_current, neighbor)) # If the end node is unreachable return -1 if distance[end] == float(\'inf\') else distance[end]"},{"question":"# Problem Statement Implement a function that generates all possible unique subsets (the power set) of a given set of integers. The input is a list of distinct integers with a length up to 20. The output should be a list of lists, containing all unique subsets in any order. Function Signature ```python def generate_subsets(nums: List[int]) -> List[List[int]]: ``` Input * `nums` (List[int]): A list of distinct integers. (1 <= len(nums) <= 20) Output * `List[List[int]]`: A list of lists representing all possible unique subsets of the input list. Constraints 1. The input list consists of distinct integers only. 2. The subsets can be returned in any order. 3. The subsets within the result do not need to be sorted. # Example ```python # Example 1 nums = [1, 2, 3] assert sorted(generate_subsets(nums)) == sorted([[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]) # Example 2 nums = [0] assert sorted(generate_subsets(nums)) == sorted([[], [0]]) # Example 3 nums = [] assert sorted(generate_subsets(nums)) == sorted([[]]) ``` Additional Notes * You can implement this function using a recursive approach or an iterative approach. * Consider the combinatorial nature of the problem where for a set of `n` elements, there are `2^n` possible subsets. * Properly handle the edge cases such as the empty input list which should return a list containing one empty list.","solution":"from typing import List def generate_subsets(nums: List[int]) -> List[List[int]]: Generates all possible unique subsets (the power set) of a given set of integers. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i+1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"# Coding Assessment Question You are given a function `matrix_rotation` that rotates a 2D matrix 90 degrees either clockwise or counterclockwise. This function adheres to typical array manipulations for matrix rotations and ensures the matrix is a square matrix (i.e., the number of rows equals the number of columns). Write a function named `extended_matrix_rotation` that extends the `matrix_rotation` function to handle multiple, arbitrary angles (not just 90 degrees) of rotation and non-square matrices (rectangular matrices). The function should be able to rotate the given matrix by any provided angle in degrees. The rotation should be performed in a clockwise direction only. Your function should return the rotated matrix. Function Signature: ```python def extended_matrix_rotation(matrix: list[list[int]], angle: int) -> list[list[int]]: pass ``` # Requirements - **Parameters**: - `matrix`: A 2D list of integers representing the matrix. - `angle`: An integer value representing the angle in degrees by which the matrix needs to be rotated. Valid angles are 90, 180, 270, and 360. - **Returns**: - A 2D list of integers representing the rotated matrix. - **Constraints**: - The 2D matrix can be rectangular (number of rows may not equal number of columns). - The provided angle will always be one among 90, 180, 270, and 360 degrees. - The matrix will have at least one row and one column. # Examples 1. ```python extended_matrix_rotation([[1, 2], [3, 4], [5, 6]], 90) ``` Should rotate the matrix by 90 degrees clockwise, resulting in: ``` [[5, 3, 1], [6, 4, 2]] ``` 2. ```python extended_matrix_rotation([[1, 2], [3, 4], [5, 6]], 180) ``` Should rotate the matrix by 180 degrees, resulting in: ``` [[6, 5], [4, 3], [2, 1]] ```","solution":"def extended_matrix_rotation(matrix: list[list[int]], angle: int) -> list[list[int]]: Rotates the given matrix by the specified angle in degrees clockwise. def rotate_90(mat): return [list(row) for row in zip(*mat[::-1])] rotations = (angle // 90) % 4 for _ in range(rotations): matrix = rotate_90(matrix) return matrix"},{"question":"# Coding Assessment Question You are given a binary tree and need to implement additional operations to manage and manipulate the tree structure efficiently. Specifically, implement the following methods in the `BinaryTree` class: 1. `find_max_depth()` - Calculates the maximum depth (or height) of the binary tree. 2. `is_symmetric()` - Checks whether the tree is symmetric around its center. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class BinaryTree: ... def find_max_depth(self) -> int: Calculates the maximum depth (or height) of the binary tree. >>> tree = BinaryTree() >>> tree.insert_node(3) >>> tree.insert_node(9) >>> tree.insert_node(20) >>> tree.insert_node(15) >>> tree.insert_node(7) >>> tree.find_max_depth() 3 def is_symmetric(self) -> bool: Checks whether the tree is symmetric around its center. >>> tree = BinaryTree() >>> tree.insert_node(1) >>> tree.insert_node(2) >>> tree.insert_node(2) >>> tree.insert_node(3) >>> tree.insert_node(4) >>> tree.insert_node(4) >>> tree.insert_node(3) >>> tree.is_symmetric() True >>> ``` Constraints: - The methods should handle corner cases such as an empty tree or a tree with a single node. - The `find_max_depth` method should operate with a time complexity of O(N), where N is the number of nodes in the tree. - The `is_symmetric` method should operate with a time complexity of O(N), where N is the number of nodes in the tree. - Assume that the `insert_node` method and the `BinaryTree` class structure already exist. **Scenario/Context**: You are maintaining a hierarchical data structure represented as a binary tree. Determining the depth of the tree and verifying its symmetry are crucial for various structural analysis tasks. Implement these methods to efficiently support these operations.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self): self.root = None def insert_node(self, value): Inserts a node into the binary tree using level order traversal. if not self.root: self.root = TreeNode(value) return queue = [self.root] while queue: node = queue.pop(0) if not node.left: node.left = TreeNode(value) break else: queue.append(node.left) if not node.right: node.right = TreeNode(value) break else: queue.append(node.right) def find_max_depth(self): Calculates the maximum depth (or height) of the binary tree. def max_depth_helper(node): if not node: return 0 left_depth = max_depth_helper(node.left) right_depth = max_depth_helper(node.right) return max(left_depth, right_depth) + 1 return max_depth_helper(self.root) def is_symmetric(self): Checks whether the tree is symmetric around its center. def is_mirror(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.value == tree2.value and is_mirror(tree1.left, tree2.right) and is_mirror(tree1.right, tree2.left)) return is_mirror(self.root, self.root)"},{"question":"# Coding Question: Efficient Path Finder in a Grid **Background**: Finding the shortest path in a grid is a common problem in computer science, often associated with various algorithms including Breadth-First Search (BFS). It is especially useful in scenarios where we need to navigate through a maze or game level grid. The travel cost within the grid can vary, making the problem more challenging. **Task**: Implement a function that finds the shortest path in a grid from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1). The path can only be formed by moving right or down and each cell contains an integer representing the cost to travel through that cell. **Function Signature**: ```python def shortest_path(grid: list) -> int: Finds the minimum cost path in a given grid from the top-left corner to the bottom-right corner. :param grid: A 2D list of integers representing the cost grid. :return: The minimum cost of the path. Example: >>> shortest_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 pass ``` **Instructions**: 1. Implement the function `shortest_path(grid)` which calculates the minimum cost path from the top-left corner to the bottom-right corner. 2. You can only move right or down within the grid. 3. Ensure your solution handles edge cases such as: - If the grid is empty - If the grid has only one row or one column 4. The function should return the minimum cost of the path from the start to the end of the grid. **Constraints**: - The number of rows (`m`) and columns (`n`) in the grid will be within the range [1, 200]. - The cost values in each cell of the grid will be non-negative integers within the range [0, 1000]. **Example**: ```python >>> shortest_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> shortest_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> shortest_path([[0]]) 0 >>> shortest_path([[1, 2], [1, 1]]) 3 ```","solution":"def shortest_path(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize a dp array to store the minimum cost to reach each cell dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The minimum cost to reach the bottom-right corner return dp[m-1][n-1]"},{"question":"Your task is to implement a function that normalizes the values of a list within a specified range. This function is crucial for preparing data before training machine learning models. # Function Definition Implement the function `normalize_values(values, min_value, max_value)` that takes in: - `values`: A list of numerical values. - `min_value`: The minimum value of the target range. - `max_value`: The maximum value of the target range. # Return Format The function should return a new list where all values from the `values` list are scaled to the range `[min_value, max_value]` using min-max normalization. # Constraints - The length of the `values` list will always be a minimum of one element and a maximum of 10^6 elements. - Values in `values` are floats or integers. - The `min_value` and `max_value` are floats or integers. - `min_value` will always be less than `max_value`. - The list `values` will contain at least two distinct values. # Example ```python values = [2, 8, 5] min_value = 0 max_value = 1 result = normalize_values(values, min_value, max_value) # Expected Output: # [0.0, 1.0, 0.5] ``` # Additional Information - Min-max normalization formula: `normalized_value = (value - min_original) / (max_original - min_original) * (max_value - min_value) + min_value` - Ensure that the function handles edge cases such as negative values and large ranges.","solution":"def normalize_values(values, min_value, max_value): Normalize the values within the specified min_value and max_value range. Parameters: values (list): A list of numerical values to normalize. min_value (float/int): The minimum value of the target range. max_value (float/int): The maximum value of the target range. Returns: list: A list of normalized values. original_min = min(values) original_max = max(values) if original_min == original_max: raise ValueError(\\"The input list should have at least two distinct values.\\") normalized_values = [] range_original = original_max - original_min range_new = max_value - min_value for value in values: normalized_value = ((value - original_min) / range_original) * range_new + min_value normalized_values.append(normalized_value) return normalized_values"},{"question":"# Coding Question: Implementing a Simple Calculator Background A simple calculator can perform basic mathematical operations: addition, subtraction, multiplication, and division. This tool is fundamental in learning computational logic and programming. Objective You need to implement a function that takes a string input representing a mathematical expression containing two operands (integers) and one operator (from \\"+\\", \\"-\\", \\"*\\", \\"/\\") and returns the result of the computation. Ensure to handle potential errors such as division by zero. Function Signature ```python def simple_calculator(expression: str) -> float: ``` Input 1. **expression**: A string representing a mathematical calculation. * Constraints: The string will always be in the format \\"a op b\\" where: * `a` and `b` are integers. * `op` is one of the operators \\"+\\", \\"-\\", \\"*\\", \\"/\\". * a and b are in the range [-1000, 1000]. Output Return a float result of the computation. Examples ```python >>> simple_calculator(\\"3 + 5\\") 8.0 >>> simple_calculator(\\"10 - 7\\") 3.0 >>> simple_calculator(\\"6 * 4\\") 24.0 >>> simple_calculator(\\"8 / 2\\") 4.0 >>> simple_calculator(\\"10 / 0\\") Traceback (most recent call last): ... ZeroDivisionError: division by zero ``` Note * You must handle division by zero and raise a ZeroDivisionError in such cases. * The result should always be returned as a float. # Instructions - Parse the input string to extract the operands and the operator. - Implement the four basic operations: addition, subtraction, multiplication, and division. - Handle any possible errors appropriately. - Ensure your implementation is efficient and follows good coding standards. Implement the function as described and test it with multiple scenarios to ensure correctness.","solution":"def simple_calculator(expression: str) -> float: Evaluates a simple mathematical expression containing two operands and one operator. Args: expression (str): A string in the format \\"a op b\\" where `a` and `b` are integers and `op` is an operator (\\"+\\", \\"-\\", \\"*\\", \\"/\\"). Returns: float: The result of the computation. Raises: ZeroDivisionError: If there is an attempt to divide by zero. # Split the expression into parts parts = expression.split() if len(parts) != 3: raise ValueError(\\"Expression must be in the format \'a op b\'.\\") # Parse the operands and operator a = int(parts[0]) op = parts[1] b = int(parts[2]) # Perform the calculation based on the operator if op == \'+\': return float(a + b) elif op == \'-\': return float(a - b) elif op == \'*\': return float(a * b) elif op == \'/\': if b == 0: raise ZeroDivisionError(\\"division by zero\\") return float(a / b) else: raise ValueError(f\\"Unknown operator {op}\\")"},{"question":"# Array Rotation **Context**: You are developing a utility for manipulating arrays in various ways. One common operation is rotating an array, which involves shifting its elements either to the left or right by a certain number of positions. Your goal is to implement a function that performs this rotation efficiently. **Task**: Implement the `rotate_array` function that takes an array of integers and a non-negative integer `k`, and returns a new array where the elements have been rotated to the right by `k` positions. # Function Signature: ```python def rotate_array(arr: List[int], k: int) -> List[int]: arr: List[int] - A list of integers to be rotated k: int - The number of positions to rotate the array to the right returns: A new list of integers rotated by k positions ``` # Constraints: 1. The input array can be empty. 2. `k` will be a non-negative integer (0 ≤ k ≤ 10^9). 3. The function should handle cases where `k` is larger than the length of the array. 4. The function should have a time complexity of O(n) where n is the length of the array. # Expected Input/Output: - **Input**: A list of integers and an integer `k`. - **Output**: A new list of integers rotated by `k` positions to the right. **Example**: ```python # Example 1 arr = [1, 2, 3, 4, 5] k = 2 # Applying rotate_array rotated_arr = rotate_array(arr, k) # Output: [4, 5, 1, 2, 3] # Example 2 arr = [1, 2, 3] k = 4 # Applying rotate_array rotated_arr = rotate_array(arr, k) # Output: [3, 1, 2] ``` # Additional Notes: - If `k` is greater than the length of the array, the function should still correctly rotate the array by effectively using the modulus operation (`k % len(arr)`). - Ensure that your solution is efficient and can handle large input sizes gracefully. - Consider edge cases such as empty arrays, arrays with a single element, and cases where `k` is a multiple of the array\'s length.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotate the array to the right by k positions. arr: List[int] - A list of integers to be rotated k: int - The number of positions to rotate the array to the right returns: A new list of integers rotated by k positions if not arr: return [] n = len(arr) k = k % n # Use modulus to handle cases where k > len(arr) return arr[-k:] + arr[:-k]"},{"question":"# Problem Statement Imagine you are analyzing a massive dataset with data points representing various events in time. You need to find the maximum number of events overlapping at any given point in time. Your task is to implement an algorithm to calculate this. # Function Signature ```python def max_events_overlap(events: list[tuple[int, int]]) -> int: pass ``` # Input * `events`: A list of tuples, where each tuple represents an event with a `start` and an `end` time. - Constraints: (1 leq text{len}(events) leq 10^5) - Each event\'s `start` and `end` times are integers, satisfying (0 leq text{start} < text{end} leq 10^9) # Output * Returns an integer indicating the maximum number of overlapping events at any point in time. # Examples 1. `max_events_overlap([(1, 4), (2, 3), (5, 8), (6, 10)])` should return `2`. 2. `max_events_overlap([(1, 5), (2, 6), (4, 8), (3, 5), (7, 9)])` should return `4`. 3. `max_events_overlap([(10, 15), (20, 25), (12, 18), (22, 28)])` should return `2`. 4. `max_events_overlap([(5, 10), (10, 15)])` should return `1`. 5. `max_events_overlap([(1, 4), (5, 8), (9, 12)])` should return `1`. # Edge Cases Consider the following edge cases: 1. A case with only one event should return `1`. 2. Non-overlapping events should correctly calculate the count without errors. 3. Multiple events starting and ending at the same time in various scenarios should be correctly handled. 4. Events that span the entire range should be considered in capacity calculations. # Constraints - You should not use any built-in overlapping calculation functions provided by Python. - The solution should strive for an optimal time complexity, ideally O(n log n), due to the constraint on event count.","solution":"def max_events_overlap(events): Calculate the maximum number of overlapping events at any point in time. if not events: return 0 # Create a list of all possible time points with their type (start or end) times = [] for start, end in events: times.append((start, \'start\')) times.append((end, \'end\')) # Sort the list of times. If time is the same, \'end\' should come before \'start\' times.sort(key=lambda x: (x[0], x[1] == \'start\')) max_overlap = 0 overlap = 0 # Iterate over the sorted times for time, t_type in times: if t_type == \'start\': overlap += 1 max_overlap = max(max_overlap, overlap) else: overlap -= 1 return max_overlap"},{"question":"# Question: Unique Elements Sum Given an array of integers, write a function that returns the sum of all unique elements. Unique elements are those that appear exactly once in the array. Your task is to write a function `unique_elements_sum(data: list) -> int` in Python, which takes a list of integers and returns the sum of unique elements. # Input: * A list of integers `data`, where (1 leq text{len(data)} leq 10^5) and (-10^6 leq text{data}[i] leq 10^6). # Output: * An integer representing the sum of the unique elements in the list. # Examples: Example 1: ```python data = [1, 2, 2, 3, 4, 4, 5] print(unique_elements_sum(data)) # Output: 9 # (1 + 3 + 5) ``` Example 2: ```python data = [10, 10, 20, 30, 40, 50, 50] print(unique_elements_sum(data)) # Output: 90 # (20 + 30 + 40) ``` Example 3: ```python data = [5, 5, 5] print(unique_elements_sum(data)) # Output: 0 # No unique elements ``` # Hints: * Utilize a dictionary or set to keep track of the frequency of each element. * Iterate through the list to sum up the elements that appear exactly once.","solution":"def unique_elements_sum(data): Returns the sum of unique elements in the list. Unique elements are those that appear exactly once. from collections import Counter counts = Counter(data) # Filter and sum up the unique elements unique_sum = sum(key for key, count in counts.items() if count == 1) return unique_sum"},{"question":"# Balanced Parentheses with Limited Replacements You are tasked with developing a function that checks if a given string of parentheses can be balanced by performing at most a set number of replacements. A balanced string is defined as one where each opening parenthesis \'(\' has a corresponding closing parenthesis \')\', and no closing parenthesis \')\' appears before its matching opening parenthesis \'(\'. The function should return a boolean indicating whether the string can be balanced with the allowed number of replacements. # Instructions 1. **Function Signature**: ```python def can_balance_parentheses(s: str, k: int) -> bool: ``` 2. **Inputs**: * `s`: A string consisting of only the characters \'(\' and \')\'. * `k`: An integer representing the maximum allowed replacements. 3. **Output**: * A boolean value indicating whether the string can be balanced with at most `k` replacements. 4. **Constraints**: * The length of `s` will be between 1 and 10^5. * `k` will be a non-negative integer. 5. **Example**: ```python s = \\"())(\\" k = 1 result = can_balance_parentheses(s, k) print(result) # True ``` 6. **Explanation**: In the example above, one replacement can be used to replace one of the \')\' with \'(\', resulting in a balanced string \\"(())\\". Implement the function `can_balance_parentheses` ensuring it correctly evaluates whether the given string can be balanced with the allowed number of replacements.","solution":"def can_balance_parentheses(s: str, k: int) -> bool: Checks if the given string of parentheses can be balanced by performing at most k replacements. Args: s (str): The string consisting of \'(\' and \')\' characters. k (int): The maximum number of replacements allowed. Returns: bool: True if the string can be balanced with at most k replacements, False otherwise. unbalanced_left = unbalanced_right = 0 # Check how many unmatched \'(\' and \')\' we have for char in s: if char == \'(\': unbalanced_left += 1 elif char == \')\': if unbalanced_left > 0: unbalanced_left -= 1 else: unbalanced_right += 1 # To balance the string, the total replacements needed is the maximum of unbalanced_left and unbalanced_right return max(unbalanced_left, unbalanced_right) <= k"},{"question":"# Problem Statement: You are tasked with implementing a `FractionRationalizer` class that reduces a given fraction to its simplest form. Your implementation should involve finding the greatest common divisor (GCD) to simplify the fraction. # Requirements: * Implement the class `FractionRationalizer` with a method `simplify` to take a fraction as a numerator and denominator and return it in the simplest form. * Ensure the fraction is simplified by dividing both the numerator and the denominator by their GCD. * Consider edge cases such as negative numbers and zero. # Function Signature: ```python class FractionRationalizer: def simplify(self, numerator: int, denominator: int) -> tuple[int, int]: ``` # Expected Input: * Two integers representing the numerator and denominator of a fraction, e.g., (4, 8). # Expected Output: * A tuple of two integers representing the simplified fraction, e.g., (1, 2). # Constraints: * -10000 <= numerator, denominator <= 10000 * The denominator must not be zero. # Implementation Details: 1. Implement a helper method `gcd` within the class using the Euclidean algorithm to find the greatest common divisor of two integers. 2. Use the `gcd` to simplify the fraction by dividing both the numerator and the denominator by their GCD. 3. Ensure that the denominator is always positive in the final fraction. # Example: ```python >>> rationalizer = FractionRationalizer() >>> rationalizer.simplify(4, 8) (1, 2) >>> rationalizer.simplify(-4, 8) (-1, 2) >>> rationalizer.simplify(21, -28) (-3, 4) ``` # Notes: * Handle cases where the fraction involves negative numbers to ensure the numerator carries the negative sign if any. * Avoid division by zero errors by checking the denominator input.","solution":"class FractionRationalizer: def _gcd(self, a: int, b: int) -> int: while b != 0: a, b = b, a % b return abs(a) def simplify(self, numerator: int, denominator: int) -> tuple[int, int]: if denominator == 0: raise ValueError(\\"Denominator cannot be zero.\\") gcd = self._gcd(numerator, denominator) numerator //= gcd denominator //= gcd # Ensure the denominator is positive if denominator < 0: numerator = -numerator denominator = -denominator return (numerator, denominator)"},{"question":"# Problem Statement You are tasked with creating a function that processes a list of integers and returns the second highest unique number in the list. If there are not enough unique numbers to determine the second highest, the function should return `None`. # Implementation Details Implement the following function: ```python def second_highest(numbers: list) -> int: Find the second highest unique number in the given list of integers. Args: numbers (list): A list of integers. Returns: int: The second highest unique number, or None if not applicable. Examples: >>> second_highest([10, 20, 20, 8, 7]) 10 >>> second_highest([5, 5, 5]) None >>> second_highest([2]) None >>> second_highest([4, 1, 6, 3, 4, 7]) 6 pass ``` Input * `numbers`: A list of integers, with lengths between 0 and 10,000. Output * An integer representing the second highest unique number, or `None` if there are fewer than two unique numbers. Constraints * The list can contain both positive and negative numbers and may also include duplicate values. # Points to Consider * Handle cases where all numbers are the same. * Ensure the function efficiently determines the second highest unique number for large inputs. Performance Requirements * The function should complete in a reasonable time for the input size within constraints.","solution":"def second_highest(numbers: list) -> int: Find the second highest unique number in the given list of integers. Args: numbers (list): A list of integers. Returns: int: The second highest unique number, or None if not applicable. unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"# Scenario You are optimizing a function for image processing software where pixel values need to be manipulated quickly. The software frequently requires the inversion of colors in images. Each pixel\'s color is represented by an 8-bit unsigned integer, and the inversion is computed using bitwise operations. # Problem Statement Implement a function `invert_color(pixel: int) -> int` that takes in a single integer `pixel` representing an 8-bit unsigned integer. The function should return the color inversion of the given pixel. The inversion of a color can be calculated by flipping all the bits of the pixel value. # Input and Output Formats * The function will receive one integer as an input parameter. * The function will return an integer as output. # Constraints * The input integer can range from 0 to 255. # Performance Requirements * The implementation should have constant time complexity (O(1)). * The solution should only use bitwise operations, without any loops or conditionals. # Example Cases ```python >>> invert_color(0) 255 >>> invert_color(255) 0 >>> invert_color(170) 85 >>> invert_color(85) 170 >>> invert_color(128) 127 ``` # Additional Notes * Ensure the function is efficient and does not use any additional space apart from fixed size variables. * Consider edge cases like input values 0 and 255, which represent black and white respectively.","solution":"def invert_color(pixel: int) -> int: Return the color inversion of the given pixel. The inversion of a color is calculated by flipping all the bits of the pixel value. :param pixel: an integer representing an 8-bit unsigned integer (0 <= pixel <= 255) :return: an integer which is the bitwise inversion of the input pixel return pixel ^ 0xFF # Invert all bits by XORing with 0xFF (which is 255 in decimal)"},{"question":"# Problem Statement You are required to implement a function that accepts a list of integers and returns the maximum possible sum of non-adjacent elements. The function should work efficiently for a large number of elements. # Input Format - A list of integers `nums` (0 ≤ length of `nums` ≤ 10^6, -10^6 ≤ nums[i] ≤ 10^6) # Output Format - An integer representing the maximum possible sum of non-adjacent elements from the list. # Constraints - Your implementation should be optimized to handle lists of up to 1 million elements efficiently. - If the list is empty, return 0. # Function Signature ```python def max_non_adjacent_sum(nums: List[int]) -> int: pass ``` # Example Input ```python nums = [3, 2, 5, 10, 7] ``` Output 12 Explanation - The maximum possible sum of non-adjacent elements is achieved by selecting 3, 10, and 2 (3 + 10 = 13), or by selecting 5 and 7 (5 + 7 = 12). The best outcome is 12. # Notes - Ensure your solution efficiently handles the sum computation even for large input sizes. - The elements of the list can be negative, so consider edge cases where excluding negative numbers can be beneficial. - You may assume that the elements of the list are stored in adjacent memory locations, meaning accessing elements has O(1) complexity in average cases.","solution":"from typing import List def max_non_adjacent_sum(nums: List[int]) -> int: if not nums: return 0 if len(nums) == 1: return max(0, nums[0]) include = 0 # To store the sum including the current element exclude = 0 # To store the sum excluding the current element for num in nums: # Current max excluding the current element new_exclude = max(include, exclude) # Current max including the current element include = exclude + num exclude = new_exclude # Return maximum of include and exclude return max(include, exclude)"},{"question":"# Coding Question: Implement and Optimize LRU Cache An LRU (Least Recently Used) cache is designed to store a limited number of values. When the cache reaches its limits, the oldest accessed value is removed to make space for the new one. Your task is to create an LRU Cache class with optimized performance using a combination of a hash map and a doubly-linked list. **Instructions**: 1. Implement the class `LRUCache` with the following methods: - `__init__(self, capacity: int)`: Initializes the cache with a fixed capacity. - `get(self, key: int) -> int`: Retrieves the value associated with the key if it exists, otherwise returns `-1`. - `put(self, key: int, value: int) -> None`: Inserts or updates the value associated with the key. If the cache exceeds its capacity, remove the least recently used item. 2. Ensure the class adheres to the principles and optimizes performance in both space and time. 3. Write appropriate test cases that cover: - Standard operations such as inserting a new element, retrieving elements, and updating existing elements. - Handling the removal of the least recently used elements when the capacity is reached. - Edge cases, such as querying non-existent keys or updating the capacity. ```python class LRUCache: def __init__(self, capacity: int): # Your implementation goes here pass def get(self, key: int) -> int: # Your implementation goes here pass def put(self, key: int, value: int) -> None: # Your implementation goes here pass def test_lru_cache() -> None: # Test cases are provided to validate the implementation pass # Example of running tests if __name__ == \\"__main__\\": test_lru_cache() ``` **Class Specification**: - **Input** (for methods): - `capacity (int)`: The maximum number of items the cache can hold. - `key (int)`: The key associated with the value to be accessed or inserted. - `value (int)`: The value to be inserted or updated in the cache. - **Output** (for methods): - `int`: The value associated with the key if it exists, otherwise `-1`. **Constraints**: - The maximum number of items (capacity) the cache can hold is between `1` and `10^5`. - The key and value are integers. **Performance Requirements**: - The LRU Cache operations should have an average time complexity of `O(1)`. - Appropriate handling of edge cases to ensure correct insertion, deletion, and retrieval operations. Develop your solution iteratively and test thoroughly. Best of luck!","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node: Node): prev_node = self.tail.prev prev_node.next = node node.prev = prev_node node.next = self.tail self.tail.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru_node = self.head.next self._remove(lru_node) del self.cache[lru_node.key]"},{"question":"Longest Consecutive Sequence in Array Objective Write a function to find the length of the longest consecutive elements sequence in an unsorted array of integers. The consecutive sequence refers to a sequence where each element is exactly 1 apart from the next element. Input * A list of integers `arr` where `1 <= len(arr) <= 10^5`. Output * An integer representing the length of the longest consecutive elements sequence. Constraints * The elements can be in any order and can include both positive and negative integers. * The algorithm should be efficient, ideally with linear time complexity. Example ```python assert longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4 # The sequence is [1, 2, 3, 4] assert longest_consecutive_sequence([0, -1, 1, 2, -2, -3, 3, 4]) == 8 # The sequence is [-3, -2, -1, 0, 1, 2, 3, 4] assert longest_consecutive_sequence([9, 1, -4, 7, 5, -6, 6, 2, -3, 2, 3, 4]) == 12 # The sequence is [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] assert longest_consecutive_sequence([]) == 0 # An empty list should return 0 ``` Implementation details 1. Use a set to help with fast look-up times of the elements. 2. Iterate through the array and check for the start of a sequence by ensuring the previous number is not present. 3. When the start of a sequence is found, count forward until the end of the sequence. 4. Keep track of the maximum length of any sequence found during the process.","solution":"def longest_consecutive_sequence(arr): if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem Statement Write a function that simulates a simple text editor capable of recognizing and performing text deletion and undo operations. The text editor should only support two operations: \\"add\\" to add a string of text at the end, and \\"undo\\" to undo the last operation performed. **Function Signature:** ```python def text_editor(operations: List[Tuple[str, str]]) -> str: pass ``` # Input * A list of `n` operations where each operation is a tuple. The first element of the tuple is a string indicating the operation type (\\"add\\" or \\"undo\\"), and the second element is a string representing the text to be added (empty string for \\"undo\\" operations). * ( 1 leq n leq 10^5 ) * Any single text addition can be up to 100 characters long. * Each type of operation can appear at most ( 10^5 ) times. # Output * A single string representing the final state of the text after all operations have been processed. # Constraints * Ensure your solution efficiently handles the operations and large input sizes. # Example ```python def text_editor(operations: List[Tuple[str, str]]) -> str: Simulates a simple text editor supporting \\"add\\" and \\"undo\\" operations. Parameters: operations (List[Tuple[str, str]]): List of operations (either \\"add\\" or \\"undo\\"). Returns: str: Final state of the text after all operations. stack = [] result = [] for op, value in operations: if op == \\"add\\": stack.append(value) result.append(value) elif op == \\"undo\\" and stack: to_remove = stack.pop() result = result[:-len(to_remove)] return \'\'.join(result) # Example 1 operations = [(\\"add\\", \\"hello\\"), (\\"add\\", \\" world\\"), (\\"undo\\", \\"\\"), (\\"add\\", \\" there\\")] print(text_editor(operations)) # Expected Output: \\"hello there\\" # Example 2 operations = [(\\"add\\", \\"a\\"), (\\"add\\", \\"bc\\"), (\\"add\\", \\"def\\"), (\\"undo\\", \\"\\"), (\\"undo\\", \\"\\"), (\\"add\\", \\"ghi\\")] print(text_editor(operations)) # Expected Output: \\"aghi\\" # Example 3 operations = [(\\"add\\", \\"foo\\"), (\\"add\\", \\"bar\\"), (\\"undo\\", \\"\\"), (\\"undo\\", \\"\\"), (\\"undo\\", \\"\\")] print(text_editor(operations)) # Expected Output: \\"\\" ``` # Notes * Make sure the text editor efficiently processes a large number of operations. * The \\"undo\\" operation should only affect the most recent \\"add\\" operation. * Handle cases where multiple \\"undo\\" operations are performed successively.","solution":"from typing import List, Tuple def text_editor(operations: List[Tuple[str, str]]) -> str: Simulates a simple text editor supporting \\"add\\" and \\"undo\\" operations. Parameters: operations (List[Tuple[str, str]]): List of operations (either \\"add\\" or \\"undo\\"). Returns: str: Final state of the text after all operations. stack = [] for op, value in operations: if op == \\"add\\": stack.append(value) elif op == \\"undo\\" and stack: stack.pop() return \'\'.join(stack)"},{"question":"# Pathfinding on Grid: Shortest Path Scenario You are given a 2D grid representing a maze, where \'0\' represents an open cell, and \'1\' represents a blocked cell. You need to find the shortest path from the top-left corner of the grid (starting at cell [0][0]) to the bottom-right corner of the grid (ending at cell [n-1][m-1]). You can move up, down, left, or right. If there is no valid path, return -1. Input and Output * Input: * A 2D list `grid` where each element is either \'0\' (open) or \'1\' (blocked). * Output: * An integer representing the length of the shortest path from the top-left to the bottom-right corner. Return -1 if no valid path exists. Constraints * The grid will have dimensions `n x m` where `1 ≤ n, m ≤ 100`. * The grid is guaranteed to be non-empty. * The starting and ending cells are always open (i.e., `grid[0][0] = \'0\'` and `grid[n-1][m-1] = \'0\'`). Performance Requirement * The function should complete within 1 second for the largest grid size (100 x 100). Function Definition ```python def shortest_path(grid: list[list[str]]) -> int: Finds the shortest path in a grid from top-left to bottom-right. Args: grid (list[list[str]]): 2D grid representing the maze. Returns: int: The length of the shortest path, or -1 if no path exists. # Implementation goes here ``` Algorithm Tips * Consider using the Breadth-First Search (BFS) algorithm as it naturally finds the shortest path in an unweighted grid. * Use a queue to keep track of current paths being evaluated. * Keep track of visited cells to avoid processing the same cell multiple times. Example ```python # Example 1: grid = [ [\\"0\\", \\"0\\", \\"1\\", \\"0\\"], [\\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\"] ] print(shortest_path(grid)) # Output: 6 # Example 2: grid = [ [\\"0\\", \\"1\\"], [\\"1\\", \\"0\\"] ] print(shortest_path(grid)) # Output: -1 ```","solution":"from collections import deque def shortest_path(grid): Finds the shortest path in a grid from top-left to bottom-right. Args: grid (list[list[str]]): 2D grid representing the maze. Returns: int: The length of the shortest path, or -1 if no path exists. if not grid or grid[0][0] == \'1\' or grid[-1][-1] == \'1\': return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n - 1 and y == m - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == \'0\' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"# Description: You are provided with a function, `is_prime`, that checks if a given number is prime. However, this function can become slow for large numbers. Your task is to implement a more efficient function using the Akazaki prime-number determination method. # Task: Implement a function `optimized_is_prime(n: int) -> bool` that: 1. Efficiently determines whether the given integer `n` is a prime number. 2. Uses a hybrid approach which combines a simple iteration for small numbers and the Akazaki method for larger numbers. # Constraints: - The input number `n` is a non-negative integer. - For `n <= 20`, use a simple function to determine if `n` is prime. - For `n > 20`, use the Akazaki method to determine if `n` is prime. # Inputs: - `n` (Integer): The number to check for primality. # Output: - Returns `True` if `n` is prime, otherwise `False`. # Example Usage: ```python >>> optimized_is_prime(2) True >>> optimized_is_prime(4) False >>> optimized_is_prime(17) True >>> optimized_is_prime(25) False >>> optimized_is_prime(101) True ``` # Note: - Assume the Akazaki method is efficiently handling numbers at least up to 10^6. - The Akazaki method involves advanced modular arithmetic and factor sieve techniques. ```python def optimized_is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False def simple_is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def akazaki_is_prime(n: int) -> bool: # Placeholder for the Akazaki method if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True if n <= 20: return simple_is_prime(n) else: return akazaki_is_prime(n) ```","solution":"def optimized_is_prime(n: int) -> bool: if n <= 1: return False def simple_is_prime(k: int) -> bool: if k <= 1: return False if k <= 3: return True if k % 2 == 0 or k % 3 == 0: return False i = 5 while i * i <= k: if k % i == 0 or k % (i + 2) == 0: return False i += 6 return True def akazaki_is_prime(k: int) -> bool: if k % 2 == 0 or k % 3 == 0: return False # This uses a 6k +/- 1 optimization which is more efficient i = 5 while i * i <= k: if k % i == 0 or k % (i + 2) == 0: return False i += 6 return True if n <= 20: return simple_is_prime(n) else: return akazaki_is_prime(n)"},{"question":"# Problem Statement You are tasked to implement a function to calculate the product of all integers in a specified range, inclusive. The function should handle given `start` and `end` values, and return the product of all integers from `start` to `end`. If `start` is greater than `end`, the function should return `1` as a convention. Implement the following function: * `range_product(start: int, end: int) -> int` Function Definition * **Input**: * `start` (int): The starting integer of the range. * `end` (int): The ending integer of the range. * **Output**: * `int`: The product of all integers from `start` to `end`, inclusive. Constraints * `start` and `end` will be integers. * Handle cases where `start` might be greater than `end` by returning `1`. * Consider the performance implications and avoid unnecessary computations, especially for large ranges. Error Handling * If `start` or `end` is not an integer, raise a `ValueError` with the message: `\\"range_product() requires both start and end to be integers\\"`. Examples * `range_product(1, 4)` should return `24`. (since 1 * 2 * 3 * 4 = 24) * `range_product(3, 3)` should return `3`. (since there is only one number in the range) * `range_product(5, 2)` should return `1`. (since start > end) * `range_product(2, 5)` should return `120`. (since 2 * 3 * 4 * 5 = 120)","solution":"def range_product(start, end): Return the product of all integers from start to end, inclusive. If start > end, return 1. If start or end is not an integer, raise a ValueError. if not isinstance(start, int) or not isinstance(end, int): raise ValueError(\\"range_product() requires both start and end to be integers\\") if start > end: return 1 product = 1 for num in range(start, end + 1): product *= num return product"},{"question":"# Coding Assessment Question Binary Search Algorithm with Rotated Array You are given a sorted array that has been rotated at some unknown pivot. You need to implement a method that efficiently searches for a target value within this rotated array. Task 1. Implement a method `search` that uses a modified binary search algorithm to find the target value in the rotated array. 2. The method should return the index of the target value if found, or -1 if the target is not in the array. Additional Guidelines - The rotated array maintains a sorted order, but it may have been rotated such that the smallest value could be somewhere in the middle. - The time complexity of the search algorithm should remain O(log n). Function Signature and Expected Behavioral Outline ```python class RotatedArraySearch: def __init__(self, rotated_array): self.array = rotated_array def search(self, target): # Implement the binary search logic to find the target in rotated_array pass ``` Input Examples and Output Expectations ```python # Sample rotated array rotated_array = [15, 18, 2, 3, 6, 12] target = 3 # Initialize RotatedArraySearch class with rotated array search_instance = RotatedArraySearch(rotated_array) # Search for the target value index = search_instance.search(target) print(index) # Expected output: 3 # Searching for a value not in the array target_not_in_array = 5 index_not_found = search_instance.search(target_not_in_array) print(index_not_found) # Expected output: -1 ``` - **Constraints**: - The input `rotated_array` must contain unique integers. - The `rotated_array` will have a length between 1 and 10^4. - The `target` will be an integer within the range of values in the `rotated_array`. - **Performance Requirements**: - The solution must efficiently handle the upper limit of input size (i.e., 10^4 elements). - Ensure the implementation uses a logarithmic approach to maintain optimal performance. By following these guidelines and implementing the `search` method, the algorithm should be able to detect the target value\'s index within the rotated array efficiently.","solution":"class RotatedArraySearch: def __init__(self, rotated_array): self.array = rotated_array def search(self, target): left, right = 0, len(self.array) - 1 while left <= right: mid = (left + right) // 2 if self.array[mid] == target: return mid # Determine the sorted half if self.array[left] <= self.array[mid]: if self.array[left] <= target < self.array[mid]: right = mid - 1 else: left = mid + 1 else: if self.array[mid] < target <= self.array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Challenge: Implementing Additional Graph Traversal Techniques Context You have been provided with a `Graph` class that uses an adjacency list representation to store a directed graph. Currently, the class supports basic operations like adding vertices and edges, as well as performing a depth-first search (DFS) and breadth-first search (BFS). Task Expand the `Graph` class to include two additional traversal methods: 1. **Topological Sort**: This traversal should return an ordering of vertices in a Directed Acyclic Graph (DAG). 2. **Detect Cycle**: This traversal should check whether there is any cycle in the directed graph. Specifications **Operation 1: Topological Sort** - **Function Signature**: `def topological_sort(self):` - **Output**: Returns a list of vertices in topologically sorted order. **Constraints**: - The graph must be a DAG (Directed Acyclic Graph). **Operation 2: Detect Cycle** - **Function Signature**: `def detect_cycle(self):` - **Output**: Returns `True` if there is a cycle in the graph, `False` otherwise. # Example Usage ```python # Initialize a directed graph graph = Graph() # Add vertices for i in range(5): graph.add_vertex(i) # Add edges (forming a DAG) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 3) graph.add_edge(2, 3) graph.add_edge(3, 4) # Perform topological sort print(graph.topological_sort()) # Should print a topologically sorted order, like [0, 2, 1, 3, 4] # Detect cycle (should return False for the above graph) print(graph.detect_cycle()) # Should print False # Adding an edge to form a cycle graph.add_edge(4, 0) # Detect cycle again (should return True now) print(graph.detect_cycle()) # Should print True ``` # Constraints - Assume that the number of vertices and edges fit within the permissible limits of a typical graph problem. - Handle cases where the graph is not a DAG gracefully for `topological_sort`. - Performance of the detection algorithm should be efficient and adhere to the standard complexities of graph traversal algorithms. **Nota Bene**: Modify the `Graph` class as necessary to implement these new functionalities.","solution":"class Graph: def __init__(self): self.graph = {} def add_vertex(self, v): if v not in self.graph: self.graph[v] = [] def add_edge(self, u, v): if u not in self.graph: self.add_vertex(u) if v not in self.graph: self.add_vertex(v) self.graph[u].append(v) def topological_sort_util(self, v, visited, stack): visited[v] = True for neighbor in self.graph.get(v, []): if not visited[neighbor]: self.topological_sort_util(neighbor, visited, stack) stack.insert(0, v) def topological_sort(self): visited = {v: False for v in self.graph} stack = [] for v in self.graph: if not visited[v]: self.topological_sort_util(v, visited, stack) return stack def detect_cycle_util(self, v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbor in self.graph.get(v, []): if not visited[neighbor]: if self.detect_cycle_util(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False def detect_cycle(self): visited = {v: False for v in self.graph} rec_stack = {v: False for v in self.graph} for v in self.graph: if not visited[v]: if self.detect_cycle_util(v, visited, rec_stack): return True return False"},{"question":"# Air Quality Index Prediction with Linear Regression Context You are a data analyst working for an environmental organization. Your task is to predict the Air Quality Index (AQI) based on various air pollutant levels. You choose to use Linear Regression for this purpose. Objective Implement a Linear Regression model from scratch to predict the AQI using the given air pollutant levels. Additionally, include functionality for adding polynomial features to the dataset for capturing non-linear relationships. Input Format 1. A matrix `X` of shape (n, d) representing n samples and d air pollutant features. 2. A vector `y` of shape (n,) representing the AQI for each sample. 3. Learning rate `alpha` (float). 4. Number of iterations `iterations` (integer). 5. An integer `degree` for the polynomial degree of features. Output Format 1. A vector `theta` of shape (p,) representing the weights of the Linear Regression model (where p is determined by the polynomial degree d). Constraints 1. Number of features `d` should be ≥ 1 and ≤ 20. 2. Number of samples `n` should be ≥ 50 and ≤ 5000. 3. The ranges for `alpha`, `iterations`, and `degree` will be supplied to ensure meaningful computations. # Function Signature ```python def linear_regression_polynomial(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int, degree: int) -> np.ndarray: pass ``` # Example ```python X = np.array([[1, 2], [2, 3], [4, 5], [7, 8], [10, 11]]) y = np.array([100, 200, 300, 400, 500]) alpha = 0.01 iterations = 1000 degree = 2 theta = linear_regression_polynomial(X, y, alpha, iterations, degree) print(\\"Final weights:\\", theta) ``` In this example, the function `linear_regression_polynomial` should output weights learned from the given features and AQI values, incorporating polynomial features up to the specified degree. # Requirements Implement the following steps: 1. Expand the features to include polynomial terms up to the specified degree. 2. Normalize features for efficient gradient descent. 3. Define the cost function for Linear Regression. 4. Use gradient descent to iteratively update weights. 5. Return the weights after training. Good luck!","solution":"import numpy as np def expand_polynomial_features(X, degree): Expand the input features X to include polynomial features up to the specified degree. from sklearn.preprocessing import PolynomialFeatures poly = PolynomialFeatures(degree) return poly.fit_transform(X) def normalize_features(X): Normalize the features in X to have mean 0 and variance 1. mean = np.mean(X, axis=0) std = np.std(X, axis=0) X_norm = (X - mean) / std return X_norm, mean, std def compute_cost(X, y, theta): Compute the cost for given hypothesis, data and parameters. m = len(y) predictions = X.dot(theta) cost = (1 / (2 * m)) * np.sum((predictions - y)**2) return cost def gradient_descent(X, y, theta, alpha, iterations): Perform gradient descent to learn theta. m = len(y) cost_history = np.zeros(iterations) for i in range(iterations): predictions = X.dot(theta) errors = predictions - y descent = alpha * (1/m) * X.T.dot(errors) theta = theta - descent cost_history[i] = compute_cost(X, y, theta) return theta, cost_history def linear_regression_polynomial(X: np.ndarray, y: np.ndarray, alpha: float, iterations: int, degree: int) -> np.ndarray: Perform Linear Regression with Polynomial Features and return the weights. X_poly = expand_polynomial_features(X, degree) X_poly, mean, std = normalize_features(X_poly) X_poly = np.insert(X_poly, 0, 1, axis=1) # Add intercept term theta = np.zeros(X_poly.shape[1]) theta, cost_history = gradient_descent(X_poly, y, theta, alpha, iterations) return theta"},{"question":"# Efficient Integer Partition Calculation Context You are developing a feature for an educational platform that deals with combinatorial mathematics. One common problem in this domain is the integer partition problem, where the goal is to find the number of ways to split a positive integer `n` into a set of positive integers. Given the extensive use of this problem in mathematical proofs and applications, you need an efficient method to compute the number of partitions for large values of `n`. Task Write a function `integer_partition` that computes the number of ways to partition the integer `n`. Utilize dynamic programming to ensure your solution is efficient even for large values of `n`. **Function Signature**: ```python def integer_partition(n: int) -> int: pass ``` Input - `n` (int): An integer where 1 ≤ n ≤ 2,000 represents the number to be partitioned. Output - (int): The number of distinct partitions of the integer `n`. Constraints - Use dynamic programming to achieve an efficient solution. - Handle trivial cases like n=1, n=2, etc., gracefully. - Ensure the function runs efficiently for the upper limit of n. - Use modulo `10^9 + 7` to keep numbers manageable and prevent overflow: `(result % MODULO)`. Examples 1. **Input**: `n = 5` **Output**: `7` (partitions are [5], [4, 1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1], [1, 1, 1, 1, 1]) 2. **Input**: `n = 10` **Output**: `42` (there are 42 distinct partitions of 10) 3. **Input**: `n = 1` **Output**: `1` (only partition is [1]) Use the provided function header to complete the `integer_partition` function that meets the requirements outlined. Ensure it passes all provided test cases and edge cases effectively.","solution":"def integer_partition(n: int) -> int: MODULO = 10**9 + 7 # Initialize a list to store the partition counts dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): for j in range(i, n + 1): dp[j] = (dp[j] + dp[j - i]) % MODULO return dp[n]"},{"question":"**Coding Problem: Connected Components in Graph** # Problem Statement You are tasked with finding all the connected components in an undirected graph. Each connected component is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. You must implement the `connected_components(graph)` function. The `graph` is represented as an adjacency list where each key `graph[node]` contains a list of its neighboring nodes. The `connected_components` function should return a list of sets, each set containing the nodes that form a connected component. # Input - `graph`: A dictionary representing the graph, where keys are node names and values are lists of neighboring nodes. Example: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\'], \'D\': [\'B\'], \'E\': [\'F\'], \'F\': [\'E\'] } ``` # Output - A list of sets. Each set contains nodes that form a connected component. # Constraints - Assume all node names are unique strings. - The graph can be disconnected, meaning there could be multiple connected components. - The graph contains no self-loops or multiple edges between two nodes. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\'], \'C\': [\'A\'], \'D\': [\'B\'], \'E\': [\'F\'], \'F\': [\'E\'] } print(connected_components(graph)) # Output: [{\'A\', \'B\', \'C\', \'D\'}, {\'E\', \'F\'}] ``` # Implementation Details 1. Initialize an empty list to store the connected components. 2. Maintain a set to keep track of visited nodes to avoid cycles and redundant work. 3. Use a Depth-First Search (DFS) or Breadth-First Search (BFS) starting from each unvisited node to explore all nodes in the same connected component. 4. Collect nodes encountered during the search into a set and add it to the list of connected components. 5. Repeat until all nodes have been visited.","solution":"def connected_components(graph): def dfs(node, visited, component): stack = [node] while stack: n = stack.pop() if n not in visited: visited.add(n) component.add(n) for neighbor in graph[n]: if neighbor not in visited: stack.append(neighbor) components = [] visited = set() for node in graph: if node not in visited: component = set() dfs(node, visited, component) components.append(component) return components"},{"question":"# Problem Statement You need to implement a function `first_unique_char` that finds the first non-repeating character in a given string and returns its index. If it does not exist, return -1. # Function Signature ```python def first_unique_char(s: str) -> int: ``` # Input - **s (str)**: A string that consists of lower-case English letters (1 ≤ len(s) ≤ 10^5). # Output - **int**: The index of the first non-repeating character in the string, or -1 if no such character exists. # Constraints 1. The input string will only contain lower-case English letters. 2. Optimize for both time and space complexity. # Example ```python >>> first_unique_char(\\"leetcode\\") 0 >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabb\\") -1 ``` # Explanation of Examples - In the string `\\"leetcode\\"`, the first unique character is `\'l\'` at index 0. - In the string `\\"loveleetcode\\"`, the first unique character is `\'v\'` at index 2. - In the string `\\"aabb\\"`, there are no unique characters, thus the return value is -1. # Edge Cases to Consider - Strings where all characters are repeating. - Strings with only one character. - Longer strings with a single unique character amidst repeating characters. # Implementation Notes Make use of appropriate data structures to achieve the optimal time complexity. Iterate over the string to collect frequency counts, then iterate again to identify the first unique character based on these counts.","solution":"def first_unique_char(s: str) -> int: Finds the first non-repeating character in the string `s` and returns its index. If it does not exist, returns -1. # Dictionary to store the frequency of each character frequency = {} # Populate the frequency dictionary for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 # Find the first character with a frequency of 1 for index, char in enumerate(s): if frequency[char] == 1: return index # No unique character found return -1"},{"question":"# Sort Colors in Place Scenario You are given an array containing 0s, 1s, and 2s (similar to the sorting challenge in the Dutch national flag problem). Your task is to sort these integers in-place so that all 0s come first, followed by all 1s, and then all 2s. Objective Implement the `sortColors` function which sorts the array in a single pass with a constant amount of extra space. Requirements 1. **Input**: - An array `colors` of integers where each integer is either 0, 1, or 2. 2. **Output**: - The same array `colors`, but sorted in non-decreasing order. 3. **Constraints**: - The length of `colors` will be in the range `1 <= len(colors) <= 300`. - The array will only contain the integers 0, 1, and 2. 4. **Performance**: - The solution must operate in O(n) time complexity. - The space complexity should be O(1), meaning the sorting should be done in-place. Function Signature ```python def sortColors(colors: list[int]) -> None: # code to sort the array in-place ``` Hints - Consider using the two-pointer technique to maintain the position of the 0s and 2s. - Iterate through the array only once, swapping elements to place them in the correct positions. Example ```python colors = [2, 0, 2, 1, 1, 0] sortColors(colors) print(colors) # Expected output: [0, 0, 1, 1, 2, 2] colors = [2, 2, 2, 0, 0, 1] sortColors(colors) print(colors) # Expected output: [0, 0, 1, 2, 2, 2] ``` - The function should modify the input list `colors` directly and ensure that the integers are sorted in non-decreasing order.","solution":"def sortColors(colors: list[int]) -> None: Sorts the array in-place so that all 0s come first, followed by all 1s, and then all 2s. low, mid, high = 0, 0, len(colors) - 1 while mid <= high: if colors[mid] == 0: colors[low], colors[mid] = colors[mid], colors[low] low += 1 mid += 1 elif colors[mid] == 1: mid += 1 else: colors[mid], colors[high] = colors[high], colors[mid] high -= 1"},{"question":"# Coding Assessment Question Context You\'re developing a logistics planning tool for a delivery service company. The company needs to efficiently schedule deliveries each day based on the provided delivery windows and the distances between delivery points. The aim is to minimize total travel distance while ensuring each delivery happens within its specified time window. Implement an algorithm to schedule these deliveries. Task Write a function `schedule_deliveries` that, given several delivery points with associated delivery windows, optimizes the order of deliveries to minimize total travel distance while respecting the delivery windows. # Function Signature ```python from typing import List, Tuple def schedule_deliveries( delivery_points: List[Tuple[float, float]], delivery_windows: List[Tuple[int, int]], start_point: Tuple[float, float] ) -> List[int]: Schedules the deliveries for a given set of delivery points and their time windows. Args: delivery_points: A list of tuples representing the coordinates (x, y) of each delivery point. delivery_windows: A list of tuples representing the delivery window (start_time, end_time) for each delivery point. start_point: A tuple representing the starting point (x, y) for the deliveries. Returns: A list of integers representing the indices of the delivery points in the optimized order of visits. ``` # Input and Output Format - **Input**: - `delivery_points`: A list of tuples of shape `(k,)` where `k` is the number of delivery points and each tuple contains two floats representing the `(x, y)` coordinates of a delivery point. - `delivery_windows`: A list of tuples of shape `(k,)` where each tuple contains two integers representing the `(start_time, end_time)` denoting the delivery window for the corresponding delivery point. - `start_point`: A tuple of two floats representing the `(x, y)` coordinates of the starting point. - **Output**: A list of integers representing the indices of the delivery points in the order they should be visited to minimize total travel distance while respecting the delivery windows. # Constraints - Assume `1 <= k <= 10^3`. - Coordinates and times are non-negative. - Delivery windows are such that it is possible to create a valid schedule adhering to all delivery windows. - The starting point\'s delivery window can be considered as always open (i.e., no delivery window constraints apply to the starting point). # Example ```python delivery_points = [ (2.3, 3.5), (3.1, 4.2), (4.0, 5.1), (4.5, 5.8) ] delivery_windows = [ (8, 10), (9, 12), (11, 15), (13, 16) ] start_point = (1.0, 1.0) order = schedule_deliveries(delivery_points, delivery_windows, start_point) print(order) # Expected output: A list representing the optimized order of visits, e.g., [0, 1, 2, 3] ``` # Notes - You may use any suitable optimization technique, such as dynamic programming, greedy algorithms, or even metaheuristic approaches like genetic algorithms if necessary. - Ensure your implementation handles edge cases such as overlapping delivery windows and distant delivery points efficiently. - Consider using libraries such as NumPy for efficient numerical calculations and `scipy.optimize` if helpful for complex optimization problems. Hints 1. Implement a distance calculation function to compute travel distances between points. 2. Consider sorting the delivery points based on their delivery windows as a potential heuristic. 3. Verify the feasibility of the generated schedule in terms of delivery windows.","solution":"from typing import List, Tuple import math def distance(point1: Tuple[float, float], point2: Tuple[float, float]) -> float: Calculate the Euclidean distance between two points. return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def schedule_deliveries( delivery_points: List[Tuple[float, float]], delivery_windows: List[Tuple[int, int]], start_point: Tuple[float, float] ) -> List[int]: Schedules the deliveries for a given set of delivery points and their time windows. Args: delivery_points: A list of tuples representing the coordinates (x, y) of each delivery point. delivery_windows: A list of tuples representing the delivery window (start_time, end_time) for each delivery point. start_point: A tuple representing the starting point (x, y) for the deliveries. Returns: A list of integers representing the indices of the delivery points in the optimized order of visits. # Number of delivery points k = len(delivery_points) # Initially each delivery is not visited visited = [False] * k # List to store the order of visits order = [] # Current position starts at start_point current_position = start_point current_time = 0 while len(order) < k: best_next_index = -1 best_distance = float(\'inf\') for i in range(k): if not visited[i]: dist = distance(current_position, delivery_points[i]) if current_time + dist <= delivery_windows[i][1]: # Ensure we can reach within the delivery window if dist < best_distance: best_distance = dist best_next_index = i if best_next_index == -1: raise ValueError(\\"Cannot find a valid next delivery point within remaining time windows\\") order.append(best_next_index) visited[best_next_index] = True current_position = delivery_points[best_next_index] current_time += best_distance return order"},{"question":"# Coding Assessment Question: Nested Array Maximum Depth Calculation **Background**: You have been tasked with analyzing the structure of nested arrays to determine their depth. Understanding the maximum depth of an array can be useful for various computational tasks. **Objective**: Implement a function `max_depth` that calculates the maximum depth of a given special array. Your function should correctly handle nested arrays, accounting for their levels of nesting. **Function Signature**: ```python def max_depth(arr: list) -> int: pass ``` **Inputs and Outputs**: * **Input**: A single list `arr` containing integers or nested lists of integers. * **Output**: An integer representing the maximum depth of the nested array. **Constraints**: * The depth of an empty list is 0. * The depth of a top-level list without any nested lists is 1. * Sub-array elements increase depth by 1 for each level of nesting. * The input list can contain up to (10^5) elements in total, including nested elements. * The depth level of nesting will not exceed 100 for practical purposes. **Example**: 1. **Input**: `[5, 2, [-7, 1], 3, [6, [-13, 8], 4]]` **Output**: `3` 2. **Input**: `[1, [2, [3, 4]]]` **Output**: `3` 3. **Input**: `[1, 2, 3]` **Output**: `1` 4. **Input**: `[1, [2, [3, [4]]]]` **Output**: `4` **Hint**: Use a recursive approach to calculate the maximum depth, but ensure to handle significant depth levels efficiently. **Edge Cases to Consider**: * Empty list `[]` * Lists containing negative numbers, e.g., `[1, [-2, 3]]` * Very deeply nested lists **Starter Template**: ```python def max_depth(arr: list) -> int: def helper(sub_arr: list, current_depth: int) -> int: if not isinstance(sub_arr, list) or not sub_arr: return current_depth return max(helper(ele, current_depth + 1) if isinstance(ele, list) else current_depth + 1 for ele in sub_arr) return helper(arr, 0) ``` Output one new question only.","solution":"def max_depth(arr: list) -> int: def helper(sub_arr: list, current_depth: int) -> int: if not isinstance(sub_arr, list) or not sub_arr: return current_depth return max(helper(ele, current_depth + 1) if isinstance(ele, list) else current_depth for ele in sub_arr) return helper(arr, 1) # start with depth 1 for top-level list"},{"question":"# Problem Statement: Design and implement a class called `Rectangle` in a programming language of your choice that encapsulates the properties and behaviors of a rectangle. Your class should provide methods to calculate the perimeter and area of the rectangle, as well as methods to scale the rectangle by a given factor. # Requirements: 1. Implement the `Rectangle` class with the following methods: - `__init__(self, length: float, width: float)`: Constructor that accepts the length and width of the rectangle. Raise a `ValueError` if either length or width is non-positive with the message \\"Dimensions must be positive.\\" - `perimeter(self) -> float`: Method that calculates and returns the perimeter of the rectangle. - `area(self) -> float`: Method that calculates and returns the area of the rectangle. - `scale(self, factor: float) -> None`: Method that scales the dimensions of the rectangle by a given factor. Raise a `ValueError` if the factor is non-positive with the message \\"Scaling factor must be positive.\\" # Input: - The length and width of the rectangle as float values during the instantiation of the `Rectangle` class. - A float value representing the scaling factor for the `scale` method. # Output: - For `perimeter()`: A float representing the perimeter of the rectangle. - For `area()`: A float representing the area of the rectangle. - For `scale()`: The dimensions of the rectangle should be updated. # Constraints: - Length and width should be positive float values. - The scaling factor should be a positive float. # Example: ```plaintext rect = Rectangle(4.0, 3.0) rect.perimeter() Expected Output: 14.0 rect.area() Expected Output: 12.0 rect.scale(2.0) rect.perimeter() Expected Output: 28.0 rect.area() Expected Output: 48.0 rect = Rectangle(-2.0, 3.0) Expected Output: Raises ValueError with message \\"Dimensions must be positive.\\" rect.scale(0) Expected Output: Raises ValueError with message \\"Scaling factor must be positive.\\" ``` # Notes: - Ensure that your class methods are well-documented and include error-handling as specified. - The perimeter of a rectangle is calculated as `2 * (length + width)`. - The area of a rectangle is calculated as `length * width`. - The `scale` method should update both length and width by multiplying them with the given scaling factor.","solution":"class Rectangle: def __init__(self, length: float, width: float): Initializes the Rectangle with the given length and width. Raises a ValueError if either length or width is non-positive. if length <= 0 or width <= 0: raise ValueError(\\"Dimensions must be positive.\\") self.length = length self.width = width def perimeter(self) -> float: Calculates and returns the perimeter of the rectangle. return 2 * (self.length + self.width) def area(self) -> float: Calculates and returns the area of the rectangle. return self.length * self.width def scale(self, factor: float) -> None: Scales the dimensions of the rectangle by the given factor. Raises a ValueError if the factor is non-positive. if factor <= 0: raise ValueError(\\"Scaling factor must be positive.\\") self.length *= factor self.width *= factor"},{"question":"Develop a simplified banking system that handles customer accounts, transactions, and basic Auditing operations. Implement the required functionality to manage account creation, deposit, withdrawal operations, and provide an audit log for every operation performed. # Objectives: 1. Implement the `create_account` function to initialize a new account with a given initial balance. 2. Implement the `deposit` function to add an amount to a specific account. 3. Implement the `withdraw` function to subtract an amount from a specific account. 4. Create a `audit_log` function to generate a log of all transactions for a specific account. # Function Definitions: - `create_account(account_id: str, initial_balance: float) -> None` - **Input**: - account_id: A unique identifier for the account. - initial_balance: A floating point number representing the initial balance. - **Output**: None - `deposit(account_id: str, amount: float) -> None` - **Input**: - account_id: The unique identifier of the account. - amount: A floating point number representing the amount to be deposited. - **Output**: None - `withdraw(account_id: str, amount: float) -> bool` - **Input**: - account_id: The unique identifier of the account. - amount: A floating point number representing the amount to be withdrawn. - **Output**: A boolean indicating if the withdrawal was successful (True) or not (False). - `audit_log(account_id: str) -> List[str]` - **Input**: - account_id: The unique identifier of the account. - **Output**: A list of strings, each representing a transaction log entry in the format: \\"Operation: DEPOSIT/WITHDRAW, Amount: amount, Balance: current_balance\\". # Constraints: - `account_id` will be a non-empty string. - `initial_balance` and `amount` will always be non-negative. - A `withdraw` operation should fail if the amount is greater than the current balance and should not alter the balance. - Transactions should be recorded in the audit log in the same order they are performed. # Example Usage: ```python # Creating account with initial balance create_account(\\"123ABC\\", 1000.0) # Making a deposit deposit(\\"123ABC\\", 250.0) # Making a withdrawal success = withdraw(\\"123ABC\\", 200.0) print(success) # Output: True # Making a failed withdrawal success = withdraw(\\"123ABC\\", 2000.0) print(success) # Output: False # Getting the audit log log = audit_log(\\"123ABC\\") for entry in log: print(entry) # Example output of audit_log: # Operation: DEPOSIT, Amount: 250.0, Balance: 1250.0 # Operation: WITHDRAW, Amount: 200.0, Balance: 1050.0 # Operation: WITHDRAW, Amount: 2000.0, Balance: 1050.0 ``` Implement these functions in Python ensuring proper management of account balances, deposit/withdrawal operations, and generation of comprehensive audit logs for given accounts.","solution":"accounts = {} audit_logs = {} def create_account(account_id: str, initial_balance: float) -> None: accounts[account_id] = initial_balance audit_logs[account_id] = [] audit_logs[account_id].append(f\\"Operation: CREATE_ACCOUNT, Amount: {initial_balance}, Balance: {initial_balance}\\") def deposit(account_id: str, amount: float) -> None: if account_id in accounts: accounts[account_id] += amount audit_logs[account_id].append(f\\"Operation: DEPOSIT, Amount: {amount}, Balance: {accounts[account_id]}\\") def withdraw(account_id: str, amount: float) -> bool: if account_id in accounts and accounts[account_id] >= amount: accounts[account_id] -= amount audit_logs[account_id].append(f\\"Operation: WITHDRAW, Amount: {amount}, Balance: {accounts[account_id]}\\") return True elif account_id in accounts: audit_logs[account_id].append(f\\"Operation: WITHDRAW, Amount: {amount}, Balance: {accounts[account_id]} (Failed)\\") return False def audit_log(account_id: str) -> list: return audit_logs.get(account_id, [])"},{"question":"# Calculate the Minimum Path Sum in a Grid You have been tasked with developing an algorithm that calculates the minimum path sum from the top-left to the bottom-right of a 2D grid. Each cell in the grid contains a non-negative integer representing the cost to traverse over it. You can only move either down or right at any point in time. Context Consider a grid where each entry `grid[i][j]` represents the cost at the cell (i, j). The goal is to find the minimum sum of a path from the top-left corner to the bottom-right corner, moving only down or right at each step. Input - A list of lists `grid` where `grid[i][j]` is a non-negative integer representing the cost at cell (i, j). Output - A single integer representing the minimum path sum from the top-left corner to the bottom-right corner. Constraints - The dimensions of the grid will be at least 1x1 and at most 200x200. - The values inside the grid will be at least 0 and at most 1000. Performance Requirement - The solution must run in O(m * n) time complexity, where m is the number of rows and n is the number of columns in the grid. Example Function Calls ```python grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(grid1)) # Output: 7 grid2 = [ [1, 2, 3], [4, 5, 6] ] print(min_path_sum(grid2)) # Output: 12 ``` Implement the `min_path_sum` function following the input and output specifications.","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left to the bottom-right of a 2D grid. :param grid: List of lists of non-negative integers where grid[i][j] represents the cost at cell (i, j). :return: Minimum path sum from the top-left to the bottom-right corner. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row. for col in range(1, cols): grid[0][col] += grid[0][col - 1] # Initialize the first column. for row in range(1, rows): grid[row][0] += grid[row - 1][0] # Populate the rest of the grid. for row in range(1, rows): for col in range(1, cols): grid[row][col] += min(grid[row - 1][col], grid[row][col - 1]) return grid[rows - 1][cols - 1]"},{"question":"# Circular Buffer with Overwriting Capability Implement a class `CircularBuffer` that simulates a fixed-size circular buffer with the ability to overwrite the oldest data when the buffer is full. This buffer should be efficient in terms of both space and time complexity for common operations like read and write. Class Definition Your task is to implement the `CircularBuffer` class with the following methods: - `__init__(capacity: int)`: Initializes a buffer with a given capacity. - `write(data: int) -> None`: Writes an integer to the buffer. If the buffer is full, the oldest data should be overwritten with new data. - `read() -> int`: Reads and removes the oldest element from the buffer. If the buffer is empty, raise an `UnderFlowError`. - `__str__() -> str`: Returns a string representation of the current buffer contents in order from the oldest to the newest. Requirements: 1. The buffer should support any size from 1 to 1000. 2. Writing to a full buffer should overwrite the oldest element. 3. Reading from an empty buffer should raise an `UnderFlowError`. 4. The class should ensure efficient reads and writes. Constraints: - Only integer data should be written to and read from the buffer. - Maintain the order of data based on the time they were written. ```python class UnderFlowError(Exception): pass class CircularBuffer: def __init__(self, capacity: int): assert capacity > 0, \\"Buffer capacity must be greater than zero.\\" self._capacity = capacity self._buffer = [None] * capacity self._start = 0 self._end = 0 self._size = 0 def write(self, data: int) -> None: self._buffer[self._end] = data self._end = (self._end + 1) % self._capacity if self._size < self._capacity: self._size += 1 else: self._start = (self._start + 1) % self._capacity def read(self) -> int: if self._size == 0: raise UnderFlowError(\\"Buffer is empty\\") data = self._buffer[self._start] self._buffer[self._start] = None self._start = (self._start + 1) % self._capacity self._size -= 1 return data def __str__(self) -> str: if self._size == 0: return \\"Buffer is empty\\" result = [] idx = self._start for _ in range(self._size): result.append(self._buffer[idx]) idx = (idx + 1) % self._capacity return str(result) # Example usage: # cb = CircularBuffer(3) # cb.write(1) # cb.write(2) # print(cb) # Output: [1, 2] # cb.write(3) # cb.write(4) # Overwrites 1 since the buffer is full. # print(cb) # Output: [2, 3, 4] # assert cb.read() == 2 # assert cb.read() == 3 # print(cb) # Output: [4] # cb.write(5) # cb.write(6) # print(cb) # Output: [4, 5, 6] # try: # cb.read() # cb.read() # cb.read() # cb.read() # This should raise an UnderFlowError # except UnderFlowError: # print(\\"Buffer is empty\\") ``` The above class definition includes the core structure. Implement the methods to fulfill the described functionality, ensuring proper handling of edge cases and maintaining the efficiency of operations.","solution":"class UnderFlowError(Exception): pass class CircularBuffer: def __init__(self, capacity: int): assert capacity > 0, \\"Buffer capacity must be greater than zero.\\" self._capacity = capacity self._buffer = [None] * capacity self._start = 0 self._end = 0 self._size = 0 def write(self, data: int) -> None: self._buffer[self._end] = data self._end = (self._end + 1) % self._capacity if self._size < self._capacity: self._size += 1 else: self._start = (self._start + 1) % self._capacity def read(self) -> int: if self._size == 0: raise UnderFlowError(\\"Buffer is empty\\") data = self._buffer[self._start] self._buffer[self._start] = None self._start = (self._start + 1) % self._capacity self._size -= 1 return data def __str__(self) -> str: if self._size == 0: return \\"Buffer is empty\\" result = [] idx = self._start for _ in range(self._size): result.append(self._buffer[idx]) idx = (idx + 1) % self._capacity return str(result)"},{"question":"# Problem Statement You are required to create a function that identifies and returns all the unique words from a given list of words that are anagrams of each other. Two words are anagrams if they can be formed by rearranging the letters of each other, using all the original letters exactly once. Write a function `find_anagrams` that accepts a list of strings and returns a list of lists, each containing the group of anagram words. # Input and Output Format * **Input**: A list `words` of strings where each string contains only lowercase alphabets. * **Output**: A list of lists, where each list contains strings that are anagrams of each other. # Constraints - The length of the list is such that `1 <= len(words) <= 10^3`. - Each word has a length in the range `[1, 100]`. - All words consist of lowercase English letters only. # Example ```python # Example input words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"cat\\", \\"tac\\", \\"act\\"] # Example output anagrams = [ [\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"rat\\", \\"tar\\", \\"art\\"], [\\"cat\\", \\"tac\\", \\"act\\"] ] ``` # Task Implement the function `find_anagrams(words: List[str]) -> List[List[str]]` to group anagram words together. ```python from typing import List from collections import defaultdict def find_anagrams(words: List[str]) -> List[List[str]]: anagram_dict = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) return list(anagram_dict.values()) # Example usage words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"rat\\", \\"tar\\", \\"art\\", \\"cat\\", \\"tac\\", \\"act\\"] print(find_anagrams(words)) # Output should be # [[\\"listen\\", \\"silent\\", \\"enlist\\"], # [\\"rat\\", \\"tar\\", \\"art\\"], # [\\"cat\\", \\"tac\\", \\"act\\"]] ```","solution":"from typing import List from collections import defaultdict def find_anagrams(words: List[str]) -> List[List[str]]: Groups words that are anagrams of each other. Args: words: List of strings to group by anagram. Returns: List of lists, each containing words that are anagrams. anagram_dict = defaultdict(list) for word in words: # Sort the word to get the anagram key sorted_word = \'\'.join(sorted(word)) anagram_dict[sorted_word].append(word) # Return the list of anagram groups return list(anagram_dict.values())"},{"question":"# Question Create a function that identifies the most common word in a given string and returns it in lowercase. If there is a tie, return the word that appears first in the string. The function should ignore punctuation and be case-insensitive. Implement the function `most_common_word(text: str) -> str` that adheres to the following requirements: * **Input**: A string `text` which: * May contain punctuation, which should be ignored (e.g., \'.\', \'!\', \'?\', \',\', \';\', \':\', etc.). * May contain both uppercase and lowercase letters. * Words are separated by spaces. * **Output**: A single lowercase string representing the most common word in the input text. * If there is a tie, return the earliest word in the input string that has the highest frequency. * **Constraints**: * Ignore all punctuation marks. * The function should be case-insensitive. * If the input string is empty or contains only punctuation, return an empty string. * **Examples**: ```python >>> most_common_word(\\"Hello, hello, hello! How many times do I have to say Hello?\\") \'hello\' >>> most_common_word(\\"This is a test. This test is only a test.\\") \'test\' >>> most_common_word(\\"A tie means the first word wins. A tie!\\") \'a\' >>> most_common_word(\\"...!!!,,\\") \'\' >>> most_common_word(\\"\\") \'\' ``` * **Performance**: * The algorithm should have a linear time complexity O(n), where n is the length of the input string. * Space complexity should be proportional to the number of unique words in the text. **Definition**: ```python def most_common_word(text: str) -> str: ```","solution":"import re from collections import Counter def most_common_word(text: str) -> str: Returns the most common word in the input text, ignoring punctuation and case. If there\'s a tie, returns the earliest one in the text. # Remove punctuation and convert to lowercase words = re.findall(r\'bw+b\', text.lower()) # Return empty string if there are no words if not words: return \'\' # Count the occurrences of each word word_counts = Counter(words) # Find the most common word, considering ties by order of appearance most_common, _ = max(word_counts.items(), key=lambda item: (item[1], -words.index(item[0]))) return most_common"},{"question":"# Problem: Efficient Stock Span Calculation The stock span problem is a financial problem where we need to calculate the span of stocks\' price for all N days. The span Si of the stock\'s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the prices of the stock were less than or equal to the price on the given day i. # Task Implement the function `calculate_stock_span(prices: List[int]) -> List[int]` which: - Takes a list of integers `prices` representing the stock prices over N days as input. - Returns a list of integers where each value at index `i` represents the span of stock prices on day `i`. # Input - `prices` (1 ≤ N ≤ 10^5): A list of integers representing the prices of the stock over N days, where each price is a positive integer. # Output - A list of integers representing the stock span on each given day. # Constraints - The function should have a time complexity of O(N) for efficient processing of large inputs. # Examples - `calculate_stock_span([100, 80, 60, 70, 60, 75, 85])` should return `[1, 1, 1, 2, 1, 4, 6]`. - `calculate_stock_span([10, 4, 5, 90, 120, 80])` should return `[1, 1, 2, 4, 5, 1]`. # Example Explanation - On day 0, the price is 100, and there are no previous days to compare, so the span is 1. - On day 1, the price is 80, and there\'s no previous day with price less than or equal to 80, so the span is 1. - On day 2, the price is 60, and no previous day with price less than or equal to 60, so the span is 1. - On day 3, the price is 70, and the price on day 2 (60) is less than 70, so the span is 2. - And so on... # Hints - Utilize a stack to maintain a history of days and their prices to efficiently compute the span for each day in a single pass. - For each day, pop elements from the stack while the stack is not empty and the price of the current day is greater than the price represented by the elements in the stack. # Notes - Ensure the solution handles edge cases and large inputs efficiently. - Test the implementation against different scenarios to validate correctness and performance.","solution":"from typing import List def calculate_stock_span(prices: List[int]) -> List[int]: n = len(prices) spans = [0] * n stack = [] # this will hold indexes of prices list for i in range(n): # Pop elements from stack while stack is not empty # and the current price is greater than the price at index stored at the top of the stack while stack and prices[stack[-1]] <= prices[i]: stack.pop() # If the stack becomes empty, it means all previous prices are less than the current price if not stack: spans[i] = i + 1 # all days up to current day have lower price else: spans[i] = i - stack[-1] # difference between current day and a day with higher price than current # Push this element to stack stack.append(i) return spans"},{"question":"# Problem Statement You are given an integer array `nums` and an integer `k`. Your task is to implement a function to find the k-th smallest element in the array using the Quickselect algorithm. The Quickselect algorithm is an efficient selection algorithm based on the partitioning logic used in QuickSort. # Input and Output - **Input**: - An integer array `nums` of size n. - An integer `k` where `1 <= k <= n`. - **Output**: - An integer representing the k-th smallest element in the given array. # Constraints - The size of the array `nums` is between 1 and 10^5. - Each element in `nums` is an integer between -10^9 and 10^9. - `k` is a valid index such that `1 <= k <= len(nums)`. # Function Signature ```python def find_kth_smallest(nums: List[int], k: int) -> int: pass ``` # Example ```python # Example 1 nums = [3, 2, 1, 5, 6, 4] k = 2 print(find_kth_smallest(nums, k)) # Output should be 2 # Example 2 nums = [7, 10, 4, 3, 20, 15] k = 3 print(find_kth_smallest(nums, k)) # Output should be 7 # Example 3 nums = [3, 2, 3, 1, 2, 4, 5, 5, 6] k = 4 print(find_kth_smallest(nums, k)) # Output should be 3 # Example 4 nums = [1, 2] k = 2 print(find_kth_smallest(nums, k)) # Output should be 2 ``` # Requirements 1. Implement the function using the Quickselect algorithm. 2. Ensure the function is optimized in terms of time complexity, particularly for large input sizes. 3. Handle edge cases such as arrays with duplicate elements and minimum/maximum sizes.","solution":"from typing import List def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = partition(arr, low, high) if pivot_index == k: return arr[pivot_index] elif pivot_index < k: return quickselect(arr, pivot_index + 1, high, k) else: return quickselect(arr, low, pivot_index - 1, k) def find_kth_smallest(nums: List[int], k: int) -> int: return quickselect(nums, 0, len(nums) - 1, k - 1)"},{"question":"# Scenario You are tasked with finding the shortest path for a robot to clean a grid. The robot starts at the top-left corner of the grid and must clean all dirty cells marked as \'1\'. The robot can move up, down, left, or right. Implement a function to determine the minimum number of steps the robot needs to clean all the dirty cells and return to its starting point. # Requirements 1. Implement a function `min_cleaning_steps` that takes in a 2D list `grid` representing the grid where each cell is either \'0\' (clean) or \'1\' (dirty). 2. The function should return an integer representing the minimum number of steps required for the robot to clean all dirty cells and return to its starting point. # Input - `grid: List[List[int]]` - 2D list representing the grid with clean and dirty cells. # Output - `int` - Minimum number of steps required to clean all dirty cells and return to the starting point. # Constraints - `1 <= len(grid), len(grid[0]) <= 10` - Each cell in `grid` is either 0 or 1. - The robot starts at the top-left corner of the grid (i.e., `grid[0][0]`). # Performance - The solution should handle the provided grid size constraints efficiently. # Function Signature ```python def min_cleaning_steps(grid: List[List[int]]) -> int: pass ``` # Example ```python grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert min_cleaning_steps(grid) == 8 ``` Explanation: 1. The robot starts at `grid[0][0]`. 2. One possible minimal path for cleaning all the dirty cells (1s) and returning to the start might be: - Down to `grid[1][0]` -> left to `grid[1][1]` -> down to `grid[2][1]` -> left to `grid[2][2]` - Up to `grid[1][2]` -> up to `grid[0][1]` -> left to `grid[0][0]` Thus covering all dirty cells in 8 steps.","solution":"from collections import deque def min_cleaning_steps(grid): Returns the minimum number of steps required to clean all dirty cells and return to the starting point. rows, cols = len(grid), len(grid[0]) dirty_cells = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 1] if not dirty_cells: return 0 def bfs(start): visited = set() queue = deque([(start[0], start[1], 0)]) distances = {} while queue: x, y, d = queue.popleft() if (x, y) in visited: continue visited.add((x, y)) distances[(x, y)] = d for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: queue.append((nx, ny, d + 1)) return distances start = (0, 0) all_cells = [start] + dirty_cells all_distances = {cell: bfs(cell) for cell in all_cells} def find_min_path(current, remaining, path_length): if not remaining: return path_length + all_distances[current][start] min_length = float(\'inf\') for next_cell in remaining: next_path_length = path_length + all_distances[current][next_cell] remaining_next = remaining - {next_cell} min_length = min(min_length, find_min_path(next_cell, remaining_next, next_path_length)) return min_length dirty_set = set(dirty_cells) return find_min_path(start, dirty_set, 0)"},{"question":"# Remove Duplicates from a Sorted Array in-place You are given a sorted array in non-decreasing order and your task is to remove the duplicate elements in-place, such that each element appears only once. Return the new length of the array after removing the duplicates. Do not use extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. **Function Signature:** ```python def remove_duplicates(nums: List[int]) -> int: pass ``` **Input and Output Formats:** - **Input**: - `nums` (List[int]): A sorted list of integers. - **Output**: - int: New length of the array after duplicates have been removed. - The first part of the array up to the returned length should contain no duplicates and the rest of the array does not matter. **Constraints**: - `0 <= len(nums) <= 10^4` - `-10^4 <= nums[i] <= 10^4` **Performance Requirements**: - The function should run in linear time with respect to the length of the input array. - Only O(1) extra memory usage is allowed. # Example: ```python # Example 1: nums = [1, 1, 2] new_length = remove_duplicates(nums) print(new_length) # Output: 2 print(nums[:new_length]) # Output: [1, 2] # Example 2: nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] new_length = remove_duplicates(nums) print(new_length) # Output: 5 print(nums[:new_length]) # Output: [0, 1, 2, 3, 4] ``` Expected behavior is that after calling `remove_duplicates`, the array `nums` should contain each element at most once up to the returned `new_length`, with any remaining elements beyond the new length being irrelevant.","solution":"def remove_duplicates(nums): if not nums: return 0 write_index = 1 # index to write the next unique element for i in range(1, len(nums)): if nums[i] != nums[write_index - 1]: nums[write_index] = nums[i] write_index += 1 return write_index"},{"question":"**Context**: Imagine you are maintaining an e-commerce website. One recurrent request is to allow users to track their order history. Each order can belong to multiple users (e.g., in case of shared family accounts), and each user can have multiple orders. **Objective**: Write a function to fetch and display all unique order IDs for a given user. **Requirements**: 1. **Function Signature**: ```python def fetch_user_orders(user_id: int, orders_data: List[Dict[str, Any]]) -> List[int]: ... ``` 2. **Functionality**: * Filter orders based on the given user ID. * Return a list of unique order IDs that the user has placed. 3. **Implementation Details**: * `orders_data` is a list of dictionaries, where each dictionary represents an order and includes an order ID and a list of user IDs associated with that order. * The function should return a list of unique order IDs sorted in ascending order. # Input and Output Formats * **Input**: * `user_id` (int): The ID of the user whose orders need to be fetched. * `orders_data` (List[Dict[str, Any]]): A list of dictionaries where each dictionary contains the details of an order: * `\'order_id\'` (int): The ID of the order. * `\'user_ids\'` (List[int]): A list of user IDs associated with the order. * **Output**: * A list of unique order IDs (List[int]) sorted in ascending order. # Constraints 1. Assume inputs are valid, i.e., `user_id` is a positive integer and `orders_data` is a properly structured list. 2. Each order in `orders_data` contains at least one user ID. # Example 1. Fetch unique order IDs for a given user: ```python orders_data = [ {\'order_id\': 101, \'user_ids\': [1, 2, 3]}, {\'order_id\': 102, \'user_ids\': [2, 4, 5]}, {\'order_id\': 103, \'user_ids\': [1, 6]}, {\'order_id\': 104, \'user_ids\': [5, 6]}, {\'order_id\': 105, \'user_ids\': [1, 2]}, ] user_id = 1 print(fetch_user_orders(user_id, orders_data)) # Expected: [101, 103, 105] ```","solution":"from typing import List, Dict, Any def fetch_user_orders(user_id: int, orders_data: List[Dict[str, Any]]) -> List[int]: Fetch and return unique order IDs for a given user, sorted in ascending order. :param user_id: The ID of the user whose orders need to be fetched. :param orders_data: A list of dictionaries containing order details. :return: A list of unique order IDs sorted in ascending order. user_orders = {order[\'order_id\'] for order in orders_data if user_id in order[\'user_ids\']} return sorted(user_orders)"},{"question":"# Problem Statement: You need to implement a library management system that keeps track of book borrowing activities. Extend the provided `Library` class to support adding new books, borrowing books, returning books, and viewing the current borrow status of all books. # Class Signature: ```python class Library: def __init__(self): pass def add_book(self, book_id: str, title: str, author: str) -> None: pass def borrow_book(self, book_id: str, user: str) -> None: pass def return_book(self, book_id: str, user: str) -> None: pass def view_status(self) -> List[Dict[str, str]]: pass ``` # Requirements: 1. **Methods**: - `add_book(book_id: str, title: str, author: str) -> None`: Adds a new book to the library with the provided `book_id`, `title`, and `author`. - `borrow_book(book_id: str, user: str) -> None`: Marks the book with `book_id` as borrowed by the specified `user`. Raise an exception if the book is already borrowed. - `return_book(book_id: str, user: str) -> None`: Marks the book with `book_id` as returned by the specified `user`. Raise an exception if the book is not currently borrowed by that user. - `view_status() -> List[Dict[str, str]]`: Returns a list of dictionaries representing all books and their current status (either \\"available\\" or borrowed by a specific user). 2. **Constraints**: - `book_id` is a unique identifier for each book. - Each book can only be borrowed by one user at a time. - Handle cases where `borrow_book` or `return_book` might be called with invalid operations (e.g., borrowing an already borrowed book or returning a book not borrowed by the user). 3. **Output**: - No return value for methods `add_book`, `borrow_book`, and `return_book`. - The `view_status` method should return a list of dictionaries. # Example: ```python library = Library() library.add_book(\\"001\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\") library.add_book(\\"002\\", \\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.borrow_book(\\"001\\", \\"user1\\") print(library.view_status()) # Output: [{\'book_id\': \'001\', \'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'status\': \'borrowed by user1\'}, {\'book_id\': \'002\', \'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'status\': \'available\'}] library.return_book(\\"001\\", \\"user1\\") print(library.view_status()) # Output: [{\'book_id\': \'001\', \'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'status\': \'available\'}, {\'book_id\': \'002\', \'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'status\': \'available\'}] ``` **Note**: - Ensure proper error handling where applicable. - Maintain the integrity of the library system throughout concurrent borrow and return operations.","solution":"from typing import List, Dict class Library: def __init__(self): self.books = {} # Dictionary to store book details self.borrowed_books = {} # Dictionary to track borrowed books def add_book(self, book_id: str, title: str, author: str) -> None: if book_id in self.books: raise ValueError(f\\"Book with id {book_id} already exists.\\") self.books[book_id] = { \'book_id\': book_id, \'title\': title, \'author\': author, \'status\': \'available\' } def borrow_book(self, book_id: str, user: str) -> None: if book_id not in self.books: raise ValueError(f\\"Book with id {book_id} does not exist.\\") if self.books[book_id][\'status\'] != \'available\': raise ValueError(f\\"Book with id {book_id} is already borrowed by {self.books[book_id][\'status\']}.\\") self.books[book_id][\'status\'] = f\'borrowed by {user}\' self.borrowed_books[book_id] = user def return_book(self, book_id: str, user: str) -> None: if book_id not in self.borrowed_books: raise ValueError(f\\"Book with id {book_id} is not borrowed.\\") if self.borrowed_books[book_id] != user: raise ValueError(f\\"Book with id {book_id} is not borrowed by {user}.\\") self.books[book_id][\'status\'] = \'available\' del self.borrowed_books[book_id] def view_status(self) -> List[Dict[str, str]]: return list(self.books.values())"},{"question":"Task Question Creation for Coding Assessment **Objective** Analyze the provided sample question and create an additional question that aligns with the existing set in terms of style, complexity, and scope. **Guidelines** # Question Style - Carefully examine the format and presentation of the given questions. - Maintain a consistent tone and language used in the original set. # Question Length - Ensure your new question is of comparable length to the existing one. # Difficulty Level - Assess the cognitive and technical challenges presented in the sample question. - Match the complexity of concepts, algorithms, or programming techniques required. # Topic Alignment - Identify the core programming concepts or domains covered in the existing question. - Create a question that explores a related or complementary area within the same general topic. # Question Uniqueness - While maintaining similarity, ensure your new question is not a mere rephrasing of the existing one. - Introduce a novel problem or scenario that tests the same skills in a different context. **Output** Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines. Your new question should appear as if it were part of the original examination and indistinguishable in quality. Output one new question only. --- *Given Question Example*: # Minimum Spanning Tree Construction Context: You have been asked to design a network with minimum cost. Given the number of nodes and the edges with their respective weights, use Kruskal’s algorithm to find the minimum spanning tree (MST). Task: Write a function `kruskal(num_nodes, edges)` that takes the number of nodes and a list of edges. Each edge is represented as a list [u, v, w] where u and v are the nodes connected by this edge, and w is the weight. Input: * An integer `num_nodes` (2 <= num_nodes <= 1000) representing the number of nodes. * A list `edges` (1 <= len(edges) <= 10000) where each element is a list [u, v, w] representing an edge between nodes u and v with weight w. Output: * A list of edges that form the minimum spanning tree represented similarly as the input edges. Constraints: * The given graph is undirected and may be disconnected. * Assume all inputs are valid as per the problem statement. Example: ```python num_nodes = 5 edges = [ [0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4] ] result = kruskal(num_nodes, edges) expected = [ [2, 3, 4], [0, 3, 5], [0, 1, 10] ] ``` # Notes: * You can use any helper functions or data structures you see fit to implement Kruskal’s algorithm efficiently. * Ensure your implementation can handle large inputs within reasonable time and space limits. --- *New Question:*: # Shortest Path in Weighted Graph Context: You are developing a navigation system that finds the shortest path from a starting point to an ending point in a city represented as a graph. Each intersection is a node, and each road is an edge with a given travel time. Implement Dijkstra\'s algorithm to find the shortest path. Task: Write a function `dijkstra(num_nodes, edges, start, end)` that takes the number of nodes, a list of edges, a starting node, and an ending node. Each edge is represented as a list `[u, v, w]` where `u` and `v` are the nodes connected by this edge, and `w` is the weight. Input: * An integer `num_nodes` (2 <= num_nodes <= 1000) representing the number of nodes. * A list `edges` (1 <= len(edges) <= 10000) where each element is a list `[u, v, w]` representing an edge between nodes `u` and `v` with weight `w`. * An integer `start` (0 <= start < num_nodes) representing the starting node. * An integer `end` (0 <= end < num_nodes) representing the ending node. Output: * A list of nodes that form the shortest path from the starting node to the ending node. If no such path exists, return an empty list. Constraints: * The given graph is undirected. * Assume all inputs are valid as per the problem statement. Example: ```python num_nodes = 5 edges = [ [0, 1, 10], [0, 2, 3], [1, 2, 1], [1, 3, 2], [2, 3, 8], [3, 4, 7] ] start = 0 end = 4 result = dijkstra(num_nodes, edges, start, end) expected = [0, 2, 1, 3, 4] ``` # Notes: * You can use any helper functions or data structures you see fit to implement Dijkstra\'s algorithm efficiently. * Ensure your implementation can handle large inputs within reasonable time and space limits.","solution":"import heapq def dijkstra(num_nodes, edges, start, end): Returns the shortest path from start to end node using Dijkstra\'s algorithm. If no path exists, returns an empty list. if start == end: return [start] # Create adjacency list adj = {i: [] for i in range(num_nodes)} for u, v, w in edges: adj[u].append((v, w)) adj[v].append((u, w)) # Min-heap to store the next node to visit heap = [(0, start, [])] # (distance, node, path) visited = set() while heap: current_dist, node, path = heapq.heappop(heap) if node in visited: continue visited.add(node) path = path + [node] if node == end: return path for neighbor, weight in adj[node]: if neighbor not in visited: heapq.heappush(heap, (current_dist + weight, neighbor, path)) return []"},{"question":"# Data Transformation and Analysis You are working on a data analysis project and need to preprocess a dataset stored as a list of dictionaries. Each dictionary represents a record with various attributes. Your task is to implement a function that normalizes the numerical values and categorizes text fields according to predefined rules. Requirements: 1. Normalize numerical values to a range of 0 to 1. 2. Categorize text fields based on a given set of rules. 3. Ensure the transformation does not alter the original data structure other than the specified fields. # Function Specification Implement a function `transform_dataset(data: List[Dict[str, Any]], transformations: Dict[str, Callable[[Any], Any]]) -> List[Dict[str, Any]]` that preprocesses the dataset according to the given transformations. Inputs: - `data`: A list of dictionaries where each dictionary represents a record in the dataset. - `transformations`: A dictionary where keys are the field names, and values are functions that take a value and return a transformed value. Outputs: - A list of dictionaries representing the transformed dataset. Constraints: - `data` will contain at least one record. - Numerical values should be normalized to the range [0, 1] using min-max normalization. - Text fields should be categorized based on custom transformation functions provided for each field. Performance Requirements: - Your solution should efficiently process the entire dataset, handling up to 10,000 records efficiently. Example Usage: ```python data = [ {\'name\': \'Alice\', \'age\': 25, \'income\': 50000}, {\'name\': \'Bob\', \'age\': 30, \'income\': 60000}, {\'name\': \'Charlie\', \'age\': 35, \'income\': 70000} ] def normalize_age(value): min_age, max_age = 20, 40 return (value - min_age) / (max_age - min_age) def categorize_name(value): return value[0].upper() transformations = { \'age\': normalize_age, \'name\': categorize_name } transformed_data = transform_dataset(data, transformations) print(transformed_data) # Output: [{\'name\': \'A\', \'age\': 0.25, \'income\': 50000}, {\'name\': \'B\', \'age\': 0.5, \'income\': 60000}, {\'name\': \'C\', \'age\': 0.75, \'income\': 70000}] ``` Ensure the implementation retains the original structure of each record, transforming only the specified fields according to the given functions.","solution":"from typing import List, Dict, Any, Callable def transform_dataset(data: List[Dict[str, Any]], transformations: Dict[str, Callable[[Any], Any]]) -> List[Dict[str, Any]]: transformed_data = [] for record in data: transformed_record = record.copy() for field, transform in transformations.items(): if field in record: transformed_record[field] = transform(record[field]) transformed_data.append(transformed_record) return transformed_data"},{"question":"# Problem: Kebab-case to camelCase Conversion Task Write a function `kebab_to_camel_case(input_str: str) -> str` that transforms a given string from kebab-case (words separated by hyphens) to camelCase. The function should handle various edge cases including sequences of non-alphanumeric characters, ensuring the first word is lowercase and subsequent words are capitalized. Input - `input_str` (str): A string in kebab-case format. The input can contain alphanumeric characters and hyphens only. Output - Returns a string which is the camelCase version of the input. Constraints - The input string will have a maximum length of (10^5). - The input must be a string. If not, raise a `ValueError` with a message indicating the type of the input found. Function Signature ```python def kebab_to_camel_case(input_str: str) -> str: pass ``` Examples ```python >>> kebab_to_camel_case(\\"kebab-case-example\\") \'kebabCaseExample\' >>> kebab_to_camel_case(\\"another-thing-to-test\\") \'anotherThingToTest\' >>> kebab_to_camel_case(\\"some-random-string-here\\") \'someRandomStringHere\' >>> kebab_to_camel_case(\\"400-kebab-case\\") \'400KebabCase\' ``` **Note**: Ensure your function efficiently handles strings up to the specified length and performs necessary checks for correct input type.","solution":"def kebab_to_camel_case(input_str: str) -> str: Converts a kebab-case string to camelCase. Parameters: input_str (str): The input string in kebab-case. Returns: str: The converted string in camelCase. Raises: ValueError: If the input is not a string. if not isinstance(input_str, str): raise ValueError(f\\"Expected a string, but got {type(input_str).__name__}\\") words = input_str.split(\'-\') camel_case_list = [words[0].lower()] + [word.capitalize() for word in words[1:]] return \'\'.join(camel_case_list)"},{"question":"# Problem Statement You are implementing a simplified version of the Knuth-Morris-Pratt (KMP) string matching algorithm which searches for occurrences of a \\"word\\" pattern within a main \\"text\\". Your task is to create a function that returns all the start indices of the pattern in the text. # Requirements Implement the function `kmp_search(text: str, pattern: str) -> list[int]` to perform the following steps: 1. **Compute the Longest Prefix Suffix (LPS) array** for the given pattern. 2. **Use the LPS array to perform the KMP search algorithm** on the given text and pattern. 3. **Return a list of all start indices** where the pattern is found within the text. # Components - **LPS Array Computation**: Compute the LPS array to store the longest suffix which is also a prefix for the pattern string. - **KMP Search**: Use the precomputed LPS array to find all occurrences of the pattern in the text. # Input Constraints: - `text`: A non-empty string with up to 10^6 characters (a million characters). - `pattern`: A non-empty string with up to 10^5 characters (a hundred thousand characters). # Expected Output: The function should return a list of integers which are the start indices of the found pattern within the text. # Example: ```python # Example usage text = \\"ababcabcabababd\\" pattern = \\"ababd\\" result = kmp_search(text, pattern) print(result) # Output: [10] (since pattern \\"ababd\\" starts at index 10 in the text) ``` # Notes: 1. Ensure the solution is optimized for performance, particularly in handling large strings efficiently. 2. Handle edge cases such as when the pattern is longer than the text, or when the pattern does not exist in the text. 3. Your implementation should be free of external libraries to compute the LPS array or perform the search, ensuring the algorithm’s workings are explicitly demonstrated. ```python def kmp_search(text: str, pattern: str) -> list[int]: def compute_lps(pattern: str) -> list[int]: lps = [0] * len(pattern) length = 0 # length of previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) i, j = 0, 0 # indexes for text and pattern result = [] while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result # Example usage text = \\"ababcabcabababd\\" pattern = \\"ababd\\" result = kmp_search(text, pattern) print(result) # Output: [10] ``` Ensure your function is thoroughly tested to handle various cases and constraints as described above.","solution":"def kmp_search(text: str, pattern: str) -> list[int]: Knuth-Morris-Pratt (KMP) string matching algorithm to find all occurrences of a pattern in a text. :param text: The main text string where pattern search is performed. :param pattern: The pattern string to be searched in the text. :return: A list of starting indices where pattern is found in the text. if not text or not pattern or len(pattern) > len(text): return [] def compute_lps(pattern: str) -> list[int]: Function to compute the Longest Prefix Suffix (LPS) array. :param pattern: The pattern string for which LPS array is computed. :return: LPS array. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 # The loop calculates lps[i] for i = 1 to len(pattern)-1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"# Context A social media platform needs to create a feature for tracking and managing user posts efficiently. Posts can receive reactions (likes, comments), and the platform needs to keep track of these reactions in forms of reaction counts. Additionally, finding the most reacted post efficiently is a priority. # Task Implement the following functions in a class named `PostManager`, which internally uses a data structure to manage posts and their reactions efficiently: 1. `add_post(self, post_id: int) -> None`: Adds a new post with the given post ID. 2. `remove_post(self, post_id: int) -> None`: Removes the post with the given post ID. Raise a `ValueError` if the post is not found. 3. `add_reaction(self, post_id: int, count: int) -> None`: Adds reactions to the post identified by `post_id`. Raise a `ValueError` if the post is not found. 4. `remove_reaction(self, post_id: int, count: int) -> None`: Removes a specified number of reactions from the post. If the reaction count to remove exceeds the existing reactions, set reactions to 0. Raise a `ValueError` if the post is not found. 5. `get_reactions(self, post_id: int) -> int`: Returns the current reaction count for the given post. Raise a `ValueError` if the post is not found. 6. `get_most_reacted_post(self) -> int`: Returns the post ID with the highest reaction count. In case of a tie, return the post with the smallest post ID. Raise an `IndexError` if there are no posts. # Constraints * Posts IDs are distinct integers. * Reaction counts and post IDs are non-negative integers. * Operations should be efficient, aiming for O(log n) time complexity for searches and updates where n is the number of posts. # Performance Requirements Ensure all functions have efficient time complexity, with operations on the posts and reactions remaining performant under large input sizes. # Class signature ```python class PostManager: def __init__(self) -> None: pass def add_post(self, post_id: int) -> None: pass def remove_post(self, post_id: int) -> None: pass def add_reaction(self, post_id: int, count: int) -> None: pass def remove_reaction(self, post_id: int, count: int) -> None: pass def get_reactions(self, post_id: int) -> int: pass def get_most_reacted_post(self) -> int: pass ``` # Example Usage ```python pm = PostManager() pm.add_post(101) pm.add_post(102) pm.add_reaction(101, 5) pm.add_reaction(102, 3) pm.add_reaction(101, 2) print(pm.get_reactions(101)) # 7 print(pm.get_reactions(102)) # 3 pm.remove_reaction(101, 4) print(pm.get_reactions(101)) # 3 print(pm.get_most_reacted_post()) # 101 pm.remove_post(101) print(pm.get_most_reacted_post()) # 102 ```","solution":"class PostManager: def __init__(self) -> None: self.posts = {} self.reactions = {} def add_post(self, post_id: int) -> None: if post_id in self.posts: raise ValueError(f\\"Post with id {post_id} already exists.\\") self.posts[post_id] = 0 def remove_post(self, post_id: int) -> None: if post_id not in self.posts: raise ValueError(f\\"Post with id {post_id} not found.\\") del self.posts[post_id] def add_reaction(self, post_id: int, count: int) -> None: if post_id not in self.posts: raise ValueError(f\\"Post with id {post_id} not found.\\") self.posts[post_id] += count def remove_reaction(self, post_id: int, count: int) -> None: if post_id not in self.posts: raise ValueError(f\\"Post with id {post_id} not found.\\") self.posts[post_id] = max(self.posts[post_id] - count, 0) def get_reactions(self, post_id: int) -> int: if post_id not in self.posts: raise ValueError(f\\"Post with id {post_id} not found.\\") return self.posts[post_id] def get_most_reacted_post(self) -> int: if not self.posts: raise IndexError(\\"No posts available.\\") max_reactions = max(self.posts.values()) most_reacted_posts = [pid for pid, reactions in self.posts.items() if reactions == max_reactions] return min(most_reacted_posts)"},{"question":"# Coding Assessment Question: Implement a Simple Cache System Context You are given a cache system class to manage a fixed-size cache using the Least Recently Used (LRU) policy. The system should be able to efficiently store, retrieve, and update values for given keys, maintaining the most recently accessed items while removing the least recently accessed ones when the cache reaches its maximum capacity. Task 1. **Initialization**: Implement the constructor to initialize the cache with a fixed size. 2. **Get Method**: Implement a method `get(key)` that retrieves the value associated with the key from the cache. If the key is not in the cache, return `-1`. 3. **Put Method**: Implement a method `put(key, value)` that inserts or updates the value for the key in the cache. If the cache exceeds its capacity, evict the least recently used item. 4. **Current Size Method**: Implement a method `current_size()` that returns the current number of items in the cache. Implementation ```python class LRUCache: def __init__(self, capacity: int): self.cache = {} self.order = [] self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.order.remove(key) self.order.append(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key) def current_size(self) -> int: return len(self.cache) ``` Input Format - The constructor takes a single integer parameter `capacity` which is the maximum size of the cache. - Method `get` takes a single integer `key`. - Method `put` takes two integers `key` and `value`. Output Format - Method `get` returns the value associated with the key, or `-1` if the key is not found. - Method `put` does not return a value. - Method `current_size` returns the number of items currently in the cache. Constraints - `1 <= capacity <= 1000` - `-1000000 <= key, value <= 1000000` - Calls to `get` and `put` will not exceed 10000. You should write your implementation within the given `LRUCache` class template.","solution":"class LRUCache: def __init__(self, capacity: int): self.cache = {} self.order = [] self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 self.order.remove(key) self.order.append(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.order.remove(key) elif len(self.cache) >= self.capacity: oldest = self.order.pop(0) del self.cache[oldest] self.cache[key] = value self.order.append(key) def current_size(self) -> int: return len(self.cache)"},{"question":"# Objective Implement a more advanced version of the `number_to_words` function to handle a wider range of numbers and edge cases. # Question Write a Python function `number_to_words` that converts a given integer into its English words representation. The enhanced version should: * Convert small integers between 0 and 999 inclusive. * Handle edge cases like negative numbers and return \'Minus\' followed by the English words representation of the absolute value. * Handle input values of None or non-integer types gracefully and return an appropriate error message. * Handle the number zero correctly by returning the word \'Zero\'. **Function Signature:** ```python def number_to_words(num: int) -> str: pass ``` # Input * A single integer `num`, ranging from -999 to 999 (both inclusive). # Output * A string representing the English words conversion of the input number. # Constraints * The number will be an integer within the range, or it will be None. * The number will not contain decimal points. # Example ```python assert number_to_words(123) == \\"One Hundred Twenty-Three\\" assert number_to_words(-45) == \\"Minus Forty-Five\\" assert number_to_words(0) == \\"Zero\\" assert number_to_words(999) == \\"Nine Hundred Ninety-Nine\\" assert number_to_words(None) == \\"Invalid input, please enter an integer.\\" ``` # Notes * Handle error scenarios like invalid input types by returning appropriate error messages. * Ensure the correct conversion of numbers, including handling special cases like teens and tens. * Words should be properly capitalized and spelled out (e.g., \'One Hundred Twenty-Three\').","solution":"def number_to_words(num): if num is None or not isinstance(num, int): return \\"Invalid input, please enter an integer.\\" def translate_hundreds(n): ones = (\\"Zero\\", \\"One\\", \\"Two\\", \\"Three\\", \\"Four\\", \\"Five\\", \\"Six\\", \\"Seven\\", \\"Eight\\", \\"Nine\\", \\"Ten\\", \\"Eleven\\", \\"Twelve\\", \\"Thirteen\\", \\"Fourteen\\", \\"Fifteen\\", \\"Sixteen\\", \\"Seventeen\\", \\"Eighteen\\", \\"Nineteen\\") tens = (\\"\\", \\"\\", \\"Twenty\\", \\"Thirty\\", \\"Forty\\", \\"Fifty\\", \\"Sixty\\", \\"Seventy\\", \\"Eighty\\", \\"Ninety\\") if n < 20: return ones[n] elif n < 100: return tens[n // 10] + (\\"\\" if n % 10 == 0 else \\"-\\" + ones[n % 10]) else: return ones[n // 100] + \\" Hundred\\" + (\\"\\" if n % 100 == 0 else \\" \\" + translate_hundreds(n % 100)) if num == 0: return \\"Zero\\" if num < 0: return \\"Minus \\" + translate_hundreds(-num) return translate_hundreds(num)"},{"question":"# Problem Statement You are tasked with creating a file system simulation. The file system consists of directories and files. Each directory can contain multiple subdirectories and files, while each file is stored with a specific size. You need to implement the functionality to add directories, add files, and calculate the total size of a directory, including all its subdirectories and files. # Implementation Details 1. **Class Definition**: Implement a class `FileSystem` with the following methods: - `add_directory(path: str) -> None`: Adds a directory at the given path. The path will be in the format `/dir1/dir2/.../dirN`. It is guaranteed that parent directories will already exist when adding a subdirectory. - `add_file(path: str, size: int) -> None`: Adds a file at the given path with the specified size. The path will include the file name and extension, in the format `/dir1/dir2/.../file.txt`. It is guaranteed that the containing directory exists prior to adding the file. - `get_directory_size(path: str) -> int`: Returns the total size of the directory at the given path, including all its subdirectories and files. 2. **Class Constraints**: - Directory and file names contain only alphanumeric characters and `/`. - File sizes are positive integers. - The path will not end with a slash `/` unless it refers to a directory. - Directory and files are added sequentially, so dependencies are always met. # Example ```python fs = FileSystem() # Adding directories fs.add_directory(\\"/documents\\") fs.add_directory(\\"/documents/projects\\") fs.add_directory(\\"/pictures\\") # Adding files fs.add_file(\\"/documents/projects/report.txt\\", 120) fs.add_file(\\"/documents/projects/design.pdf\\", 200) fs.add_file(\\"/pictures/photo.jpg\\", 250) # Calculating directory sizes assert fs.get_directory_size(\\"/documents/projects\\") == 320 assert fs.get_directory_size(\\"/documents\\") == 320 assert fs.get_directory_size(\\"/pictures\\") == 250 assert fs.get_directory_size(\\"/\\") == 570 ``` # Additional Notes - Consider using a tree-like structure to store directories and files. - Ensure to handle nested directories properly. - The solution should efficiently compute the total size even for deeply nested directories and files.","solution":"class FileSystem: def __init__(self): self.structure = {\'/\': {\'directories\': {}, \'files\': {}}} def add_directory(self, path: str) -> None: current = self.structure[\'/\'] for part in path.strip(\'/\').split(\'/\'): if part not in current[\'directories\']: current[\'directories\'][part] = {\'directories\': {}, \'files\': {}} current = current[\'directories\'][part] def add_file(self, path: str, size: int) -> None: *directories, filename = path.strip(\'/\').split(\'/\') current = self.structure[\'/\'] for part in directories: current = current[\'directories\'][part] current[\'files\'][filename] = size def _get_size(self, current: dict) -> int: total_size = sum(current[\'files\'].values()) for subdir in current[\'directories\'].values(): total_size += self._get_size(subdir) return total_size def get_directory_size(self, path: str) -> int: current = self.structure[\'/\'] for part in path.strip(\'/\').split(\'/\'): if part: current = current[\'directories\'][part] return self._get_size(current)"},{"question":"# Sorting an Array Using Merge Sort You are tasked with implementing the merge sort algorithm to sort an array of integers. # Problem Statement Write a function `merge_sort(arr: list[int]) -> list[int]` that: - **Input**: - `arr`: A list of integers which needs to be sorted. - **Output**: - Returns a sorted list of integers in ascending order. # Constraints - The length of `arr` does not exceed 1000. - Array elements are integers and can be both positive and negative. - The algorithm should be implemented with a time complexity of (O(n log n)). # Performance Requirements - Ensure the solution properly handles edge cases including small arrays, arrays with duplicate values, and already sorted arrays. - Implement the merge sort algorithm using a recursive approach. # Example ```python # Example 1 arr = [38, 27, 43, 3, 9, 82, 10] sorted_arr = merge_sort(arr) print(sorted_arr) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2 arr = [5, 2, 9, 1, 5, 6] sorted_arr = merge_sort(arr) print(sorted_arr) # Output: [1, 2, 5, 5, 6, 9] # Example 3 arr = [0, -1, 5, 3, 3, 2] sorted_arr = merge_sort(arr) print(sorted_arr) # Output: [-1, 0, 2, 3, 3, 5] ``` # Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: pass ``` # Additional Notes: - You may implement any helper functions needed for merging the sorted halves. - Ensure the main function `merge_sort` initiates the sorting by dividing the array and recursively sorting each half before merging them.","solution":"def merge_sort(arr: list[int]) -> list[int]: if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: list[int], right: list[int]) -> list[int]: sorted_list = [] left_index = 0 right_index = 0 # Merge the two lists into sorted_list while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Append any remaining elements from left or right sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"# Question: Optimal Delivery Route Calculation You are assigned the task to design a class `DeliveryRoute` that determines the optimal route for delivering packages in a city grid. The city is represented as a grid of intersecting streets with blocks of varying distances. Each block’s distance between intersections is given in a two-dimensional array. Your task: Implement the `DeliveryRoute` class with the following functionalities: 1. **Initialization**: - Initialize the class with a 2D list representing the city grid distances and the starting point (intersection coordinates). 2. **Calculate Shortest Route**: - `shortest_route(self, destination: Tuple[int, int]) -> List[Tuple[int, int]]`: Calculate and return the shortest route from the starting point to the destination using the Dijkstra’s algorithm. 3. **Calculate Total Distance**: - `total_distance(self, route: List[Tuple[int, int]]) -> float`: Calculate and return the total distance of the given route. Requirements: * Initialization should check if the input grid is valid (e.g., non-negative distances). * Ensure that the starting point and destination are within the grid bounds. * For the shortest route: * Use Dijkstra\'s algorithm to calculate the shortest route. * Return the route as a list of coordinates (tuples) representing the path from the starting point to the destination. Example Scenarios & Edge Cases: 1. **Example Grid**: ``` grid = [ [1, 2, 3], [4, 8, 2], [1, 5, 3] ] ``` 2. **Example Usage**: ```python route = DeliveryRoute(grid, (0, 0)) destination = (2, 2) shortest_path = route.shortest_route(destination) print(shortest_path) # Expected: [(0, 0), (0, 1), (1, 2), (2, 2)] total_distance = route.total_distance(shortest_path) print(total_distance) # Expected: 8.0 ``` 3. **Edge Cases**: * Handling grids where all blocks have the same distance. * Destination that is on the boundary of the grid. * Grids with multiple optimal paths yielding the same shortest distance. Implement the class with all necessary methods and ensure it handles various grid complexities and edge cases efficiently. Example Test Case: ```python # Example Test Case grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] route = DeliveryRoute(grid, (0, 0)) destination = (2, 2) shortest_path = route.shortest_route(destination) assert shortest_path == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)], f\\"Failed: {shortest_path}\\" total_distance = route.total_distance(shortest_path) assert total_distance == 7, f\\"Failed: {total_distance}\\" ```","solution":"import heapq from typing import List, Tuple class DeliveryRoute: def __init__(self, grid: List[List[int]], start: Tuple[int, int]): self.grid = grid self.start = start self.rows = len(grid) self.cols = len(grid[0]) self.validate_grid() def validate_grid(self): if not all(len(row) == self.cols for row in self.grid): raise ValueError(\\"The grid should be a rectangle (all rows must have equal length)\\") if any(cell < 0 for row in self.grid for cell in row): raise ValueError(\\"The grid distances should not contain negative values\\") if not (0 <= self.start[0] < self.rows and 0 <= self.start[1] < self.cols): raise ValueError(\\"The starting point must be within the grid bounds\\") def shortest_route(self, destination: Tuple[int, int]) -> List[Tuple[int, int]]: if not (0 <= destination[0] < self.rows and 0 <= destination[1] < self.cols): raise ValueError(\\"The destination point must be within the grid bounds\\") directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] heap = [(0, self.start)] # (total cost, (x, y)) distances = {self.start: 0} previous = {self.start: None} while heap: current_distance, current_position = heapq.heappop(heap) if current_position == destination: break for direction in directions: neighbor = (current_position[0] + direction[0], current_position[1] + direction[1]) if 0 <= neighbor[0] < self.rows and 0 <= neighbor[1] < self.cols: distance = self.grid[neighbor[0]][neighbor[1]] new_distance = current_distance + distance if neighbor not in distances or new_distance < distances[neighbor]: distances[neighbor] = new_distance previous[neighbor] = current_position heapq.heappush(heap, (new_distance, neighbor)) path = [] step = destination while step: path.append(step) step = previous[step] return path[::-1] def total_distance(self, route: List[Tuple[int, int]]) -> float: total = 0 for i in range(1, len(route)): total += self.grid[route[i][0]][route[i][1]] return total"},{"question":"# Adding With Carrying Problem Statement: Write a function `add_with_carrying(num1: str, num2: str) -> str` that takes two non-negative integer numbers represented as strings `num1` and `num2`, adds them together digit by digit from right to left, and returns the sum as a new string. Input - Two non-negative integers represented as strings, `num1` and `num2` (1 ≤ len(num1), len(num2) ≤ 10^5). Output - A string representing the sum of the two numbers. Constraints - You must handle the addition explicitly without using big integer libraries. - The solution must efficiently handle the length of the strings. Example ```python >>> add_with_carrying(\\"123\\", \\"456\\") \'579\' >>> add_with_carrying(\\"99\\", \\"1\\") \'100\' >>> add_with_carrying(\\"1\\", \\"999\\") \'1000\' ``` Explanation For `num1 = \\"123\\"` and `num2 = \\"456\\"`, the sum is `123 + 456 = 579`. For `num1 = \\"99\\"` and `num2 = \\"1\\"`, the sum is `99 + 1 = 100`. For `num1 = \\"1\\"` and `num2 = \\"999\\"`, the sum is `1 + 999 = 1000`.","solution":"def add_with_carrying(num1: str, num2: str) -> str: Adds two non-negative numbers represented as strings and returns their sum as a string. max_len = max(len(num1), len(num2)) # Pad shorter string with leading zeros num1 = num1.zfill(max_len) num2 = num2.zfill(max_len) carry = 0 result = [] # Start adding from the least significant digit for i in range(max_len-1, -1, -1): n1 = int(num1[i]) n2 = int(num2[i]) total = n1 + n2 + carry carry = total // 10 result.append(str(total % 10)) # If there\'s remaining carry, add it to the result if carry: result.append(str(carry)) # The result array is in reverse order, reverse it back result.reverse() return \'\'.join(result)"},{"question":"# Coding Question: Simple Cipher Encoder **Context**: You are tasked with creating a simple cipher encoder for a communication app. The encoding process involves shifting letters in the alphabet by a specific number of positions. This technique is known as the Caesar Cipher. For this task, you will only handle lowercase alphabetic characters and maintain non-alphabetic characters unchanged. **Task**: Implement a function: 1. `caesar_cipher(text: str, shift: int) -> str` This function should: - Validate the input parameters. - Shift each letter in the `text` by `shift` positions to the right in the alphabet. - Wrap around to the start of the alphabet if the shift exceeds \'z\'. - Retain all non-alphabetic characters in their original position. **Constraints**: - `text` is a string containing at least one character and no more than 1000 characters. - `shift` must be an integer between 0 and 25 inclusive. - Assume the input string will only contain lowercase alphabetic characters and punctuation marks, spaces, or digits. **Formula**: - For a character `c` in the string: [ text{shifted_char} = text{chr}((text{ord}(c) - 97 + shift) % 26 + 97) ] Here, `ord(c)` gives the ASCII value of the character, and `chr()` converts back the ASCII value to a character. **Input/Output**: - **Input**: A string `text` and an integer `shift`. - **Output**: A string with each alphabetic character shifted by `shift` positions. **Examples**: ```python assert caesar_cipher(\\"hello, world!\\", 3) == \\"khoor, zruog!\\" assert caesar_cipher(\\"abcxyz\\", 2) == \\"cdezab\\" assert caesar_cipher(\\"python123\\", 5) == \\"udymts123\\" assert caesar_cipher(\\"simple cipher\\", 1) == \\"tjnqmf djqifs\\" ``` Write the function based on the provided formula and constraints, ensuring to handle invalid inputs appropriately.","solution":"def caesar_cipher(text: str, shift: int) -> str: Applies the Caesar Cipher to a given text by shifting each letter to the right by the given shift amount. Parameters: text (str): The input text to be encoded. shift (int): The number of positions each letter in the text should be shifted. Returns: str: The encoded text with the Caesar Cipher applied. # Check for valid shift value if not (0 <= shift <= 25): raise ValueError(\\"Shift must be between 0 and 25 inclusive.\\") encoded_chars = [] for char in text: # Process only lowercase alphabetic characters if \'a\' <= char <= \'z\': new_char = chr(((ord(char) - ord(\'a\') + shift) % 26) + ord(\'a\')) encoded_chars.append(new_char) else: # Keep non-alphabetic characters unchanged encoded_chars.append(char) return \'\'.join(encoded_chars)"},{"question":"Bank Transaction Fraud Detection You are tasked with implementing a simplified version of a fraud detection system for bank transactions. The goal is to demonstrate your understanding of data preprocessing, feature engineering, classification algorithms, and performance evaluation. # Functional Requirements: 1. **Data Preprocessing**: Load and preprocess transaction data from a CSV file. 2. **Feature Engineering**: Create additional features to improve model accuracy. 3. **Model Training**: Train a classification model to detect fraudulent transactions. 4. **Model Evaluation**: Evaluate the model\'s performance using appropriate metrics. # Input and Output Formats: - **Input**: 1. A CSV file containing transaction data with features such as transaction amount, transaction date, transaction type, and a label indicating whether the transaction is fraudulent or not. 2. The path to the CSV file. 3. An optional parameter to adjust the train-test split ratio. - **Output**: A function returning a trained model and the evaluation metrics including precision, recall, and F1-score. # Constraints: 1. Handle missing values appropriately. 2. Apply necessary data scaling. 3. Implement a feature selection method to improve the model. 4. Ensure reproducibility by setting a random seed for splitting the data. 5. The dataset should be split into training and testing subsets. # Performance Requirements: 1. Efficient loading and preprocessing of the transaction data. 2. Optimized feature selection and model training. 3. Clear presentation of evaluation metrics. # Implementation Scenario: You are required to implement the function `fraud_detection(csv_path: str, test_split_ratio: float = 0.2, random_seed: int = 42)`: ```python import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import precision_score, recall_score, f1_score def fraud_detection(csv_path: str, test_split_ratio: float = 0.2, random_seed: int = 42): # Implement function following the outlined requirements # 1. Data preprocessing: Load and clean the dataset. # 2. Feature engineering: Create and select relevant features. # 3. Model training: Train a classification model on the training data. # 4. Model evaluation: Evaluate the model on the test data using precision, recall, and F1-score. # 1. Data preprocessing data = pd.read_csv(csv_path) # Handle missing values data.fillna(method=\'ffill\', inplace=True) # 2. Feature engineering # Assuming some basic feature engineering for simplicity data[\'transaction_date\'] = pd.to_datetime(data[\'transaction_date\']) data[\'day_of_week\'] = data[\'transaction_date\'].dt.dayofweek data[\'hour\'] = data[\'transaction_date\'].dt.hour features = [\'transaction_amount\', \'day_of_week\', \'hour\'] X = data[features] y = data[\'fraudulent\'] # Data scaling scaler = StandardScaler() X = scaler.fit_transform(X) # Train-test split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_split_ratio, random_state=random_seed) # 3. Model training model = RandomForestClassifier(random_state=random_seed) model.fit(X_train, y_train) # 4. Model evaluation y_pred = model.predict(X_test) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) metrics = {\'precision\': precision, \'recall\': recall, \'f1_score\': f1} return model, metrics ``` *Note*: The function should include internal documentation, as well as potential improvements and enhancements for feature engineering and model tuning.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import precision_score, recall_score, f1_score def fraud_detection(csv_path: str, test_split_ratio: float = 0.2, random_seed: int = 42): Detect fraudulent transactions in a bank dataset. Parameters: csv_path (str): Path to the CSV file containing transaction data. test_split_ratio (float, optional): Proportion of the dataset to include in the test split. random_seed (int, optional): Seed used by the random number generator. Returns: model: The trained classification model. metrics (dict): Dictionary containing precision, recall, and F1-score. # 1. Data preprocessing: Load and clean the dataset. data = pd.read_csv(csv_path) # Handle missing values data = data.fillna(method=\'ffill\').fillna(method=\'bfill\') # 2. Feature engineering data[\'transaction_date\'] = pd.to_datetime(data[\'transaction_date\']) data[\'day_of_week\'] = data[\'transaction_date\'].dt.dayofweek data[\'hour\'] = data[\'transaction_date\'].dt.hour # Features selected for training features = [\'transaction_amount\', \'day_of_week\', \'hour\'] X = data[features] y = data[\'fraudulent\'] # Data scaling scaler = StandardScaler() X = scaler.fit_transform(X) # Train-test split X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_split_ratio, random_state=random_seed) # 3. Model training model = RandomForestClassifier(random_state=random_seed) model.fit(X_train, y_train) # 4. Model evaluation y_pred = model.predict(X_test) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) metrics = {\'precision\': precision, \'recall\': recall, \'f1_score\': f1} return model, metrics"},{"question":"# Question You are developing a system that processes customer orders for an e-commerce platform. Part of the processing requires validating the format and structure of incoming order data against expected requirements. To ensure your validation functionality is robust and correctly implemented, you should write unit tests to simulate various scenarios. # Task Write a Python function, `test_validate_order_data`, to mock different inputs and verify that your validation function behaves as expected when faced with valid and invalid data. Requirements: - Create a dummy validation function `validate_order_data` that simulates validation rules for order data. For instance, the order data must include keys \'order_id\', \'customer_id\', and \'items\'. - Items should be a list of dictionaries, each containing at least \'item_id\' and \'quantity\' fields. - Write test cases using the `pytest` framework, one for each of the following scenarios: - Valid order data. - Missing \'order_id\' key. - \'items\' is not a list. - An item within the \'items\' list missing the \'item_id\' key. - Use the `pytest.raises` context to check for exceptions raised for invalid data. - Ensure that no network calls are made; the tests should only verify the validation logic. Input and Output: - The function `validate_order_data` should take a dictionary as input and raise a `ValueError` with an appropriate message if the data is invalid. - If the order data is valid, the function should return `True`. Constraints: - You don’t need to handle actual database operations or further order processing steps, just the validation part. - Assume the function `validate_order_data` is defined separately and you need to write tests for it. # Example: ```python def validate_order_data(order_data): if \'order_id\' not in order_data: raise ValueError(\\"Missing order_id\\") if \'customer_id\' not in order_data: raise ValueError(\\"Missing customer_id\\") if \'items\' not in order_data or not isinstance(order_data[\'items\'], list): raise ValueError(\\"Invalid items format\\") for item in order_data[\'items\']: if \'item_id\' not in item: raise ValueError(\\"Missing item_id in an item\\") return True def test_validate_order_data(): # Write your test cases here pass ``` Create the mock unit test function `test_validate_order_data` with appropriate scenarios.","solution":"def validate_order_data(order_data): Validates the structure and format of the order data. Parameters: order_data (dict): The order data to be validated. Returns: True: If order data is valid. Raises: ValueError: If the order data is invalid. if \'order_id\' not in order_data: raise ValueError(\\"Missing order_id\\") if \'customer_id\' not in order_data: raise ValueError(\\"Missing customer_id\\") if \'items\' not in order_data or not isinstance(order_data[\'items\'], list): raise ValueError(\\"Invalid items format\\") for item in order_data[\'items\']: if \'item_id\' not in item: raise ValueError(\\"Missing item_id in an item\\") return True"},{"question":"**Floyd-Warshall Algorithm Path Retrieval** **Objective**: Implement the Floyd-Warshall algorithm to compute the shortest paths between all pairs of vertices in a directed graph with positive or negative edge weights (but no negative cycles). Additionally, enhance your implementation to retrieve the path between any two vertices. **Problem Statement**: Write a function `floyd_warshall_with_path(n: int, edges: list, queries: list) -> list` that performs the following tasks: 1. Computes the shortest paths between all pairs of vertices using the Floyd-Warshall algorithm. 2. Handles a list of queries, where each query is a tuple `(u, v)` representing a request for the shortest path between vertices `u` and `v`. **Function Signature**: ```python def floyd_warshall_with_path(n: int, edges: list, queries: list) -> list: pass ``` **Input**: * `n` (integer, 1 ≤ n ≤ 200): The number of vertices in the graph. * `edges` (list of tuples, 0 ≤ len(edges) ≤ 10^4): A list where each element is a tuple `(u, v, w)` representing an edge from vertex `u` to vertex `v` with weight `w`. * `queries` (list of tuples, 1 ≤ len(queries) ≤ 10^3): List of tuples where each tuple `(u, v)` requires the shortest path from vertex `u` to vertex `v`. **Output**: * List of lists where the `i-th` element is the shortest path from `queries[i][0]` to `queries[i][1]`. Each path is represented as a list of vertices traversed from the source to the destination. **Example**: ```python n = 4 edges = [(1, 2, 3), (2, 3, 4), (3, 4, 2), (1, 3, 10)] queries = [(1, 3), (1, 4), (2, 1)] result = floyd_warshall_with_path(n, edges, queries) print(result) # Result should be [[1, 2, 3], [1, 2, 3, 4], []] ``` **Explanation**: For the graph: ``` 1---(3)--->2---(4)--->3---(2)--->4 | / |(10)------| ``` Shortest paths are: * From vertex 1 to vertex 3: `[1, 2, 3]` * From vertex 1 to vertex 4: `[1, 2, 3, 4]` * There is no path from vertex 2 to vertex 1: `[]` These paths should be returned in the matching order within the query list.","solution":"def floyd_warshall_with_path(n: int, edges: list, queries: list) -> list: # Initialize the distance matrix with infinite values and 0 for diagonal dist = [[float(\'inf\')] * n for _ in range(n)] next_node = [[-1] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 # Fill in the distances based on direct edges for u, v, w in edges: dist[u-1][v-1] = w next_node[u-1][v-1] = v-1 # Floyd-Warshall algorithm implementation for k in range(n): for i in range(n): for j in range(n): if dist[i][k] + dist[k][j] < dist[i][j]: dist[i][j] = dist[i][k] + dist[k][j] next_node[i][j] = next_node[i][k] def retrieve_path(u, v): if next_node[u][v] == -1: return [] path = [u] while u != v: u = next_node[u][v] path.append(u) return path result = [] for u, v in queries: path = retrieve_path(u-1, v-1) if path: result.append([p+1 for p in path]) else: result.append([]) return result"},{"question":"# Question: Implement a Multi-Line Grid Path Finder Context: You need to write a function that finds the shortest path from the top-left corner to the bottom-right corner of a grid. The grid contains weights that represent the cost of entering each cell, and you can only move right or down. Requirements: 1. **Function Signature**: - `def find_min_path(grid: List[List[int]]) -> int` 2. **Input and Output Formats**: - The function accepts one parameter: a two-dimensional list `grid` representing the cost grid. - The function returns an integer which is the minimum cost to reach the bottom-right corner from the top-left corner. 3. **Constraints**: - `1 <= len(grid), len(grid[0]) <= 100` - Each cell in `grid` contains a non-negative integer cost. - You can only move right or down at any point in time. - Handle edge cases where the grid size is 1x1. 4. **Performance Requirements**: - Your solution should run efficiently with a time complexity of O(m*n), where m and n are the dimensions of the grid. - Optimize for space by using dynamic programming with an in-place update to minimize additional memory usage. Example Usage: ```python assert find_min_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 assert find_min_path([[1, 2], [1, 1]]) == 3 assert find_min_path([[1]]) == 1 assert find_min_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 21 ``` Instructions: 1. Write the `find_min_path` function to compute the minimum path cost as described. 2. Implement the function using dynamic programming with in-place updates to ensure optimal memory usage. 3. Test your function with the provided assertions to verify its correctness. 4. Handle edge cases such as a single-cell grid gracefully.","solution":"from typing import List def find_min_path(grid: List[List[int]]) -> int: Finds the minimum path sum from top-left to bottom-right in a grid. # Get the dimensions of the grid m, n = len(grid), len(grid[0]) # Dynamic programming to update the grid with minimum path sums for i in range(m): for j in range(n): if i == 0 and j == 0: continue # Skip the starting cell elif i == 0: grid[i][j] += grid[i][j - 1] # First row can only come from the left elif j == 0: grid[i][j] += grid[i - 1][j] # First column can only come from above else: grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]) # Minimum of coming from above or left # The bottom-right cell contains the minimum path sum return grid[m - 1][n - 1]"},{"question":"# Problem Statement **Game of Sequences** is a game where players take turns constructing a sequence of numbers based on a specific rule. The rule is to add the number of divisors of each element to the sequence as its next element. Initially, the sequence starts with a given integer `a1`. For example, if the sequence starts with `a1 = 7`, the next element is `2` (since 7 has two divisors, 1 and 7). If the sequence starts with `a1 = 6`, the next element is `4` (since 6 has four divisors: 1, 2, 3, 6). The game continues until the sequence reaches a specified length `n`. # Task Write a function `game_of_sequences(a1: int, n: int) -> List[int]` that generates the sequence up to its nth element based on the rules of the game. Your function should return a list representing the sequence. # Input * `a1 (int: 1 <= a1 <= 1000)`: The initial integer of the sequence. * `n (int: 1 <= n <= 100)`: The length of the sequence. # Output * Return a list of integers representing the sequence generated according to the game rules. # Example Consider the following examples to gain clarity: ```python >>> game_of_sequences(6, 5) [6, 4, 3, 2, 2] >>> game_of_sequences(7, 4) [7, 2, 2, 2] ``` # Constraints 1. The input values `a1` will be between `1` and `1000`. 2. The input value `n` will be between `1` and `100`. 3. Ensure all calculations are performed efficiently due to potential large values. # Performance Requirements Ensure your solution efficiently calculates the number of divisors and generates the sequence within acceptable time limits for the maximum values of `a1` and `n`.","solution":"from typing import List def number_of_divisors(x: int) -> int: Helper function to return the number of divisors of x. count = 0 for i in range(1, int(x**0.5) + 1): if x % i == 0: count += 1 if i != x // i: # To account for both divisors when i is not the square root of x count += 1 return count def game_of_sequences(a1: int, n: int) -> List[int]: Generates a sequence of numbers based on the rule provided. :param a1: The initial element of the sequence. :param n: The length of the sequence. :return: A list representing the sequence. sequence = [a1] current_value = a1 for _ in range(n - 1): next_value = number_of_divisors(current_value) sequence.append(next_value) current_value = next_value return sequence"},{"question":"# Linear Regression Classification Question You are given a dataset containing various attributes of individuals, and each individual is labeled as either having a disease or not. Your task is to implement a function using `Logistic Regression` that trains on these attributes to classify whether an individual has the disease. Ensure to follow these specific steps for implementation: **Function Implementation:** 1. **Function Signature**: `def logistic_regression_classifier(data: dict) -> dict:` 2. **Input**: The input will be a dictionary with two keys, - `data`: A list of lists where each inner list represents the attributes of an individual. - `target`: A list of binary labels (0 or 1) corresponding to whether each individual has the disease (1) or not (0). 3. **Process**: * Split the dataset into training and testing sets using a 70-30 ratio for training and testing respectively. * Train the Logistic Regression classifier using the training dataset. * Predict the labels for the test dataset. 4. **Output**: A dictionary containing two keys: - `predictions`: A list of predicted labels (0 or 1) for the test dataset. - `evaluation`: Another dictionary with keys `accuracy` and `f1_score` representing the classifier\'s performance on the test dataset. **Constraints**: * Ensure that all necessary preprocessing of the data is performed within the function. * Use appropriate Logistic Regression hyperparameters to avoid overfitting. * Evaluate the model performance using the accuracy and F1 score. **Example**: ```python >>> data = { ... \\"data\\": [ ... [45, 85, 1, 65, 0], # Attributes of first individual ... [50, 90, 0, 70, 1], # Attributes of second individual ... # Add more attribute sets ... ], ... \\"target\\": [1, 0, # Add more labels ... ] ... } >>> logistic_regression_classifier(data) { \\"predictions\\": [1, 0], # Example output representing predicted labels (not actual) \\"evaluation\\": { \\"accuracy\\": 0.95, # Example accuracy \\"f1_score\\": 0.94 # Example F1 score } } ``` **Note**: The example provided in the main function of the code snippet is based on synthetic data for illustrative purposes. Refer to this example for guidance on processing and feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.metrics import accuracy_score, f1_score def logistic_regression_classifier(data: dict) -> dict: Trains a logistic regression classifier on the given dataset and evaluates its performance. Args: data (dict): A dictionary with \'data\' and \'target\' keys where: - \'data\' (list of lists): Attributes of individuals. - \'target\' (list): Binary labels (0 or 1) indicating disease presence. Returns: dict: A dictionary with \'predictions\' and \'evaluation\' keys where: - \'predictions\' (list): Predicted labels for the test set. - \'evaluation\' (dict): Contains \'accuracy\' and \'f1_score\' of the model on the test set. X = data[\'data\'] y = data[\'target\'] # Split the data into training and testing sets (70% training, 30% testing) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) # Initialize and train the logistic regression model model = LogisticRegression(solver=\'liblinear\') model.fit(X_train, y_train) # Predict on the test set y_pred = model.predict(X_test) # Evaluate the model accuracy = accuracy_score(y_test, y_pred) f1 = f1_score(y_test, y_pred) # Return predictions and evaluation metrics return { \\"predictions\\": y_pred.tolist(), \\"evaluation\\": { \\"accuracy\\": accuracy, \\"f1_score\\": f1 } }"},{"question":"# Question: Find the Missing Number in a Consecutive Integer Sequence Background: You are given a list of integers where each integer is between 1 and n, inclusive. The list has a length of n-1, indicating that exactly one integer from this range is missing. Your task is to find and return the missing integer. This is useful in systems where maintaining a complete series of identifiers is crucial, such as database primary keys, event sequences, or version control. Problem Statement: Write a function `find_missing_number` which takes a list of integers and returns the missing number in the sequence. Function Signature: ```python def find_missing_number(numbers: list[int]) -> int: pass ``` Input: * A list `numbers` containing `n - 1` unique integers where each integer is between 1 and `n` (inclusive). Output: * An integer representing the missing number in the sequence. Constraints: * The input list will be of length `n - 1` where `1 ≤ n ≤ 10^6`. Performance Requirements: * The function should be efficient, ideally operating in O(n) time complexity. Example: ```python assert find_missing_number([1, 2, 4, 5]) == 3 assert find_missing_number([2, 3, 1, 5]) == 4 assert find_missing_number([6, 2, 3, 4, 1]) == 5 assert find_missing_number([1]) == 2 assert find_missing_number([3, 4, 2]) == 1 ``` Edge Cases: 1. **Single Element**: `find_missing_number([1])` should return `2`, handling the smallest sequence case properly. 2. **Missing First or Last Number**: Ensure correct handling when the missing number is the first (`[2, 3, 4]` should return `1`) or last number (`[1, 2, 3]` returns `4`). Additional Notes: 1. If the input is not a list, handle it appropriately by raising a `TypeError` with the message \\"Input value must be a \'list\' type\\". 2. If the list contains invalid or duplicate elements, raise a `ValueError` with the message \\"List must contain unique integers from 1 to n\\". Write comprehensive test cases to validate your implementation.","solution":"def find_missing_number(numbers: list[int]) -> int: Finds the missing number in the consecutive integer sequence. :param numbers: A list of n-1 unique integers, where each integer is between 1 and n. :return: The missing integer. if not isinstance(numbers, list): raise TypeError(\\"Input value must be a \'list\' type\\") expected_length = len(numbers) + 1 actual_sum = sum(numbers) expected_sum = expected_length * (expected_length + 1) // 2 return expected_sum - actual_sum"},{"question":"# Coding Question Task: You are given a problem where you need to generate a list of the first `n` prime numbers. Your goal is to write a function that returns this list. Function Signature: ```python def generate_primes(n: int) -> List[int]: pass ``` Input: * `n` (int): The count of prime numbers to generate. (1 <= n <= 100) Output: * The function should return a list of the first `n` prime numbers. Constraints: * The list should start with the first prime number, 2. * `n` will be a positive integer greater than or equal to 1 and less than or equal to 100. Example: ```python print(generate_primes(10)) ``` Expected Output: ``` [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` Performance Requirements: The solution should be efficient and not involve unnecessary computations. Implementations can use the sieve of Eratosthenes or direct checking methods, with optimizations to limit re-checking of non-primes.","solution":"from typing import List def generate_primes(n: int) -> List[int]: Returns a list of the first n prime numbers. if n < 1: return [] primes = [] num = 2 # Start checking for primes from 2 while len(primes) < n: is_prime = True for i in range(2, int(num ** 0.5) + 1): if num % i == 0: is_prime = False break if is_prime: primes.append(num) num += 1 return primes"},{"question":"# Scenario: You are part of a development team working on a digital library management system. One of the requirements is to maintain a log of book borrowings so that the most frequently borrowed books can be promoted or restocked. For this purpose, you decide to implement a data structure that efficiently handles the tracking of the borrow counts for different books. # Task: Implement a class `BorrowTracker` that keeps track of the borrow counts for books and allows for efficient retrieval of the most frequently borrowed book. Your class should provide functionality to perform the following operations: 1. **Record a borrow**: Increments the borrow count for a given book. 2. **Get the most frequently borrowed book**: Returns the book with the highest borrow count. 3. **Remove the most frequently borrowed book**: Removes the book with the highest borrow count from the tracker. 4. **Update the borrow count**: Updates the borrow count for a book to a specified new value. # Requirements: - You should use an appropriate data structure to efficiently manage and query the borrow counts. - Assume that book identifiers are integers. # Function Specifications: 1. **record_borrow(book_id: int) -> None**: Increments the borrow count of the book with the specified `book_id`. 2. **get_most_frequent_book() -> tuple | None**: Returns a tuple `(book_id, count)` of the book with the highest borrow count if present, else `None`. 3. **remove_most_frequent_book() -> tuple | None**: Removes and returns the tuple `(book_id, count)` of the book with the highest borrow count if present, else `None`. 4. **update_borrow_count(book_id: int, new_count: int) -> None**: Updates the borrow count of the book with `book_id` to `new_count`. # Constraints: - `1 <= book_id, count <= 10^5` - The number of book borrow logs will not exceed 10^5. # Example: ```python tracker = BorrowTracker() tracker.record_borrow(101) tracker.record_borrow(102) tracker.record_borrow(101) tracker.record_borrow(103) tracker.record_borrow(101) print(tracker.get_most_frequent_book()) # Output: (101, 3) tracker.update_borrow_count(101, 1) print(tracker.get_most_frequent_book()) # Output: (103, 1) print(tracker.remove_most_frequent_book()) # Output: (103, 1) print(tracker.get_most_frequent_book()) # Output: (101, 1) ``` # Note: - Choose an efficient data structure to handle the dynamic nature of the borrow logs. - Consider edge cases such as queries on an empty tracker and updates leading to priority changes among books.","solution":"import heapq from collections import defaultdict class BorrowTracker: def __init__(self): self.borrow_counts = defaultdict(int) self.max_heap = [] self.book_positions = {} self.entry_finder = {} self.REMOVED = \'<removed-book>\' self.counter = 0 def record_borrow(self, book_id: int) -> None: if book_id in self.entry_finder: self.remove_book(book_id) self.borrow_counts[book_id] += 1 self._add_book(book_id, self.borrow_counts[book_id]) def _add_book(self, book_id: int, count: int): entry = [-count, self.counter, book_id] self.entry_finder[book_id] = entry heapq.heappush(self.max_heap, entry) self.counter += 1 def remove_book(self, book_id: int): entry = self.entry_finder.pop(book_id) entry[-1] = self.REMOVED def get_most_frequent_book(self) -> tuple | None: while self.max_heap and self.max_heap[0][-1] == self.REMOVED: heapq.heappop(self.max_heap) if not self.max_heap: return None count, _, book_id = self.max_heap[0] return (book_id, -count) def remove_most_frequent_book(self) -> tuple | None: while self.max_heap and self.max_heap[0][-1] == self.REMOVED: heapq.heappop(self.max_heap) if not self.max_heap: return None count, _, book_id = heapq.heappop(self.max_heap) self.entry_finder.pop(book_id, None) return (book_id, -count) def update_borrow_count(self, book_id: int, new_count: int) -> None: if book_id in self.entry_finder: self.remove_book(book_id) self.borrow_counts[book_id] = new_count self._add_book(book_id, new_count)"},{"question":"# Coding Question: Calculate and Format Average Grades Context: As a software developer for an educational platform, you need to write a utility that processes students\' grades. The system receives lists of grades for different students and should calculate the average grade for each student. Additionally, you are required to format the average grades in a specific way for reporting purposes. Objective: - Write a function `calculate_and_format_averages(students_grades: Dict[str, List[int]]) -> Dict[str, str>` that: - Calculates the average grade for each student. - Formats the average grade as a string with exactly two decimal places. - Returns a dictionary with student names as keys and their formatted average grades as values. Input and Output: - **Input**: A dictionary `students_grades` where keys are student names (strings) and values are lists of integers representing their grades (e.g., `{\\"Alice\\": [90, 95, 88], \\"Bob\\": [70, 80, 100]}`). - **Output**: A dictionary where the keys are student names and the values are their average grades formatted as strings with two decimal places. Constraints and Limitations: - Grades will be non-negative integers between 0 and 100 inclusive. - Each list of grades will contain at least one grade. - Ensure no division by zero occurs as each student has at least one grade. Examples: ```python >>> calculate_and_format_averages({\\"Alice\\": [90, 95, 88], \\"Bob\\": [70, 80, 100]}) {\'Alice\': \'91.00\', \'Bob\': \'83.33\'} >>> calculate_and_format_averages({\\"Carla\\": [100, 80], \\"Daniel\\": [55, 70, 80, 90]}) {\'Carla\': \'90.00\', \'Daniel\': \'73.75\'} >>> calculate_and_format_averages({\\"Eve\\": [60], \\"Frank\\": [70, 80]}) {\'Eve\': \'60.00\', \'Frank\': \'75.00\'} ``` Function Signature: ```python def calculate_and_format_averages(students_grades: Dict[str, List[int]]) -> Dict[str, str]: pass ```","solution":"def calculate_and_format_averages(students_grades): Calculate the average grades for each student and format the result as a dictionary with student names as keys and their average grades formatted as strings with two decimal places as values. Parameters: students_grades (dict): A dictionary where keys are student names (str) and values are lists of grades (list[int]). Returns: dict: A dictionary with student names as keys and their average grades as formatted strings (two decimal places). formatted_averages = {} for student, grades in students_grades.items(): average = sum(grades) / len(grades) formatted_averages[student] = f\\"{average:.2f}\\" return formatted_averages"},{"question":"# Decode Message **Problem Statement:** You are given a message that was encoded using an arbitrary secret alphabet known only to the sender. The encoded message is represented as a string of numbers where each number corresponds to a specific letter in the secret alphabet. The secret alphabet consists of lowercase English letters (\'a\' to \'z\'), and their respective numerical values are assigned as follows: \'a\' -> 1, \'b\' -> 2, ..., \'z\' -> 26 The encoded message can be formed by combining two-digit numbers as well, where \'10\' represents \'j\', \'11\' represents \'k\', etc. Each letter in the message can only be decoded using single or double digits at a time. Your task is to determine how many different ways the given message can be decoded. **Objective:** Write a function `num_decodings(s: str) -> int` that returns the number of valid ways to decode an encoded message `s`. **Function Signature:** ```python def num_decodings(s: str) -> int: pass ``` **Input:** - `s`: A string representing the encoded message. (`1 <= len(s) <= 100`) **Output:** - An integer representing the number of ways to decode the given message. **Constraints:** - The encoded message contains only digits and is guaranteed to be a non-empty string. - You may assume that the message does not contain any leading zeros. - The message is always a valid string that can be decoded. **Performance Requirements:** - Aim to use a dynamic programming approach for efficient computation. Example: ```python >>> num_decodings(\\"12\\") 2 # \\"AB\\" (1 2) or \\"L\\" (12) >>> num_decodings(\\"226\\") 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6) ``` **Notes:** - You need to handle the combination of decoding single and double digits appropriately. - Leverage techniques like dynamic programming to ensure that your solution can handle the upper limits efficiently.","solution":"def num_decodings(s: str) -> int: # Edge case: empty string if not s: return 0 # dp array where dp[i] will store the number of ways to decode s[:i] dp = [0] * (len(s) + 1) # Base cases dp[0] = 1 # An empty string has one way to be decoded (doing nothing) dp[1] = 1 if s[0] != \'0\' else 0 # A single character string can be decoded if it\'s not \'0\' for i in range(2, len(s) + 1): # One step back if s[i - 1] != \'0\': dp[i] += dp[i - 1] # Two steps back two_digit = int(s[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[len(s)]"},{"question":"# Scenario A local library needs a way to organize their books based on their titles to help librarians and users locate books quickly. They have a cataloging system that can download a list of book titles, but the titles need to be sorted alphabetically. Your task is to implement a bubble sort algorithm to order the titles alphabetically. # Problem Statement Implement a function `library_bubble_sort` that sorts a list of book titles alphabetically using the bubble sort algorithm. Ensure the function handles varying lengths and edge cases appropriately. # Function Signature ```python def library_bubble_sort(titles: List[str]) -> List[str]: ``` # Input * A list (`titles`) of strings, where each string represents a book title. # Output * The same list of titles, but sorted alphabetically in ascending order. # Constraints * Assume the input list can contain at most 10^3 book titles. * Each book title is a non-empty string consisting of only alphabetic characters and spaces. # Requirements * The solution must achieve a stable sort. * The sort should be case insensitive. # Examples ```python assert library_bubble_sort([\'The Great Gatsby\', \'1984\', \'To Kill a Mockingbird\', \'Animal Farm\']) == [\'1984\', \'Animal Farm\', \'The Great Gatsby\', \'To Kill a Mockingbird\'] assert library_bubble_sort([]) == [] assert library_bubble_sort([\'A Tale of Two Cities\', \'Pride and Prejudice\', \'Moby Dick\']) == [\'A Tale of Two Cities\', \'Moby Dick\', \'Pride and Prejudice\'] assert library_bubble_sort([\'apple\', \'Apple\', \'Banana\', \'banana\']) == [\'apple\', \'Apple\', \'Banana\', \'banana\'] assert library_bubble_sort([\'C\', \'B\', \'a\']) == [\'a\', \'B\', \'C\'] ``` # Performance * The function should efficiently sort the book titles and handle edge cases without errors. Write your implementation below:","solution":"from typing import List def library_bubble_sort(titles: List[str]) -> List[str]: Sorts a list of book titles alphabetically using the bubble sort algorithm. The sort is case insensitive. n = len(titles) for i in range(n): for j in range(0, n-i-1): if titles[j].lower() > titles[j+1].lower(): titles[j], titles[j+1] = titles[j+1], titles[j] return titles"},{"question":"# Problem Statement: You are given a list of words. Two words are defined as being \\"neighboring\\" if they share at least one initial letter when both are converted to lowercase. Your task is to group the words into clusters, where every word in a cluster is a neighbor to at least one other word in that cluster. # Function Signature: ```python def group_words(words: list[str]) -> list[list[str]]: Args: words (list[str]): A list of strings representing words. Returns: list[list[str]]: A list of lists, where each sublist represents a cluster of neighboring words. ``` # Input/Output Format: - **Input**: * words: A list of strings where each string is a word. - **Output**: * A list of lists of strings, where each list contains words that are neighbors. # Constraints: - 1 <= len(words) <= 10^4 - 1 <= len(words[i]) <= 100 - words[i] contains only alphabetical characters (both uppercase and lowercase). # Examples: Example 1: ```python words = [\\"apple\\", \\"ape\\", \\"banana\\", \\"book\\", \\"cat\\", \\"cab\\"] print(group_words(words)) # Output: [[\\"apple\\", \\"ape\\"], [\\"banana\\", \\"book\\"], [\\"cat\\", \\"cab\\"]] ``` Example 2: ```python words = [\\"Zoo\\", \\"zebra\\", \\"alligator\\", \\"Antelope\\", \\"Buffalo\\"] print(group_words(words)) # Output: [[\\"Zoo\\", \\"zebra\\"], [\\"alligator\\", \\"Antelope\\"], [\\"Buffalo\\"]] ``` # Notes: 1. Words are case insensitive, so \\"Apple\\" and \\"apple\\" should be considered neighbors. 2. The order of clusters and words within each cluster is not important. Any valid output that meets the problem\'s conditions will be accepted. 3. The solution should be efficient to handle large inputs, so consider using appropriate data structures for grouping the words.","solution":"def group_words(words): from collections import defaultdict # Create a dictionary to hold groups of words clusters = defaultdict(list) # Process each word and group them by their initial letter for word in words: # Convert word to lowercase lower_word = word.lower() # Use the first letter as the key initial_letter = lower_word[0] clusters[initial_letter].append(word) # Convert dictionary values to a list return list(clusters.values())"},{"question":"# Coding Challenge: Palindromic Permutations Scenario Your company is developing a feature that helps users generate interesting trivia. One of the challenges involves determining whether a given string\'s characters can be rearranged to form a palindrome. A palindrome reads the same forwards and backwards (like \\"racecar\\" or \\"level\\"). A string can be rearranged to form a palindrome if, at most, one character has an odd count while all other characters have even counts. Question Write a Python function to determine if any permutation of the input string is a palindrome. Function Signature ```python def can_form_palindrome(input_string: str) -> bool: Determines if any permutation of the input string can form a palindrome. Parameters: input_string (str): The input string to check. Returns: bool: True if any permutation can form a palindrome, False otherwise. ``` Input/Output * **Input Format**: A single string containing only lowercase alphabetical characters. * **Output Format**: A boolean indicating whether any permutation can form a palindrome. Constraints 1. The input string will have at least one and up to 10^5 characters. 2. The input string contains only lowercase English letters (a-z). Example ```python print(can_form_palindrome(\\"civic\\")) # Expected output: True print(can_form_palindrome(\\"ivicc\\")) # Expected output: True print(can_form_palindrome(\\"hello\\")) # Expected output: False print(can_form_palindrome(\\"aab\\")) # Expected output: True ``` Your function should efficiently handle large input strings by utilizing optimal data structures for counting and validating characters.","solution":"def can_form_palindrome(input_string: str) -> bool: Determines if any permutation of the input string can form a palindrome. Parameters: input_string (str): The input string to check. Returns: bool: True if any permutation can form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character char_count = Counter(input_string) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return odd_count <= 1"},{"question":"Railroad Station Map Parsing You are tasked with implementing a system to parse and interpret a railroad station map. **Context:** The railway system is represented by nodes (stations) and edges (railway tracks between those stations). Each railway track has a length that represents the distance between the two stations. The goal is to build a parser that takes a textual description of the railway system and enables various operations to analyze the railway map. # Your Task: **Function 1: `parse_railroad_map(railroad_map: str) -> dict`** * **Input**: - `railroad_map` (str): A string representation of the railway system. Each entry consists of three parts formatted as \\"StationA-StationB-Distance\\", where Distance is a positive integer. * **Output**: - `map_dict` (dict): A dictionary where keys are station names and values are dictionaries. The nested dictionaries map connected stations to their respective distances. **Function 2: `shortest_path(map_dict: dict, start: str, end: str) -> int`** * **Input**: - `map_dict` (dict): The dictionary representation of the railroad map as parsed by `parse_railroad_map`. - `start` (str): The starting station. - `end` (str): The destination station. * **Output**: - `shortest_distance` (int): The shortest distance from `start` to `end`. # Constraints: * The `railroad_map` input string may contain multiple entries separated by commas. * The text representation of stations will be uppercase alphabetical characters. * Ensure the functions handle maps with up to 1000 stations and 5000 connections efficiently. * If there is no available path from `start` to `end`, return -1 for the `shortest_distance`. # Examples: ```python def test_railroad_station_map_parsing(): railroad_map = \\"A-B-5,B-C-10,C-D-15,A-D-20\\" map_dict = parse_railroad_map(railroad_map) # Expected map_dict expected_map_dict = { \\"A\\": {\\"B\\": 5, \\"D\\": 20}, \\"B\\": {\\"A\\": 5, \\"C\\": 10}, \\"C\\": {\\"B\\": 10, \\"D\\": 15}, \\"D\\": {\\"C\\": 15, \\"A\\": 20} } assert map_dict == expected_map_dict # Example 1: Shortest path from A to D assert shortest_path(map_dict, \\"A\\", \\"D\\") == 20 # Example 2: Shortest path from A to C (A->B->C) assert shortest_path(map_dict, \\"A\\", \\"C\\") == 15 # Example 3: Shortest path from D to B (D->C->B) assert shortest_path(map_dict, \\"D\\", \\"B\\") == 25 # Example 4: No path exists from A to E assert shortest_path(map_dict, \\"A\\", \\"E\\") == -1 ``` # Implementation Tips: * Use Dijkstra\'s algorithm or another suitable shortest path algorithm to determine the shortest distance between stations. * Ensure the `parse_railroad_map` function constructs the dictionary representation accurately, ensuring bidirectional connectivity between stations. * Handle edge cases such as disconnected stations and non-existent paths appropriately in the `shortest_path` function.","solution":"def parse_railroad_map(railroad_map: str) -> dict: Parses the railroad map string and returns a dictionary representation. map_dict = {} connections = railroad_map.split(\',\') for connection in connections: stationA, stationB, distance = connection.split(\'-\') distance = int(distance) if stationA not in map_dict: map_dict[stationA] = {} if stationB not in map_dict: map_dict[stationB] = {} map_dict[stationA][stationB] = distance map_dict[stationB][stationA] = distance return map_dict def shortest_path(map_dict: dict, start: str, end: str) -> int: Finds the shortest path between start and end stations. Returns the shortest distance or -1 if no path exists. import heapq if start not in map_dict or end not in map_dict: return -1 distances = {station: float(\'infinity\') for station in map_dict} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_station = heapq.heappop(priority_queue) if current_distance > distances[current_station]: continue for neighbor, weight in map_dict[current_station].items(): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end] if distances[end] != float(\'infinity\') else -1"},{"question":"Shortest Path with Dijkstra\'s Algorithm # Context You are given a set of cities connected by roads, each with an associated travel time. Your task is to determine the shortest travel time from a specified start city to a specified destination city using Dijkstra\'s algorithm. # Task Write a function that reads the road network from a file in the form of an edge list and calculates the minimum travel time between two given cities. # Function Signature ```python def find_shortest_travel_time(filename: str, start_city: str, destination_city: str) -> int: ``` # Input - **`filename` (str)**: A string representing the path to a file containing the network\'s edge list. - **`start_city` (str)**: The name of the starting city. - **`destination_city` (str)**: The name of the destination city. # Output - **`int`**: The minimum travel time between the start city and the destination city. # Constraints - The file contains lines in the format: `\\"CityA CityB travel_time\\"`. - All cities are represented as strings with no embedded whitespace, and travel_time is a non-negative integer. - Cities are uniquely named, and the network is guaranteed to have at least one valid path between any two cities. # Examples Given the content of \\"cities.txt\\" as follows: ``` A B 4 A C 2 B C 5 B D 10 C D 3 ``` ```python >>> find_shortest_travel_time(\\"cities.txt\\", \\"A\\", \\"D\\") 9 ``` # Algorithm 1. Parse the file to construct the graph as an adjacency list. 2. Implement Dijkstra\'s algorithm to find the shortest path from the start city to the destination city. 3. Return the minimum travel time as the result. # Explanation In the given example: - From A to D, the paths are: - (A rightarrow B rightarrow D) with a travel time of (4 + 10 = 14) - (A rightarrow C rightarrow D) with a travel time of (2 + 3 = 5) - The minimum travel time is (5), so the answer is (9).","solution":"import heapq def find_shortest_travel_time(filename: str, start_city: str, destination_city: str) -> int: graph = {} # Read the file and construct the graph as an adjacency list with open(filename, \'r\') as file: for line in file: city_a, city_b, travel_time = line.split() travel_time = int(travel_time) if city_a not in graph: graph[city_a] = [] if city_b not in graph: graph[city_b] = [] graph[city_a].append((travel_time, city_b)) graph[city_b].append((travel_time, city_a)) # Dijkstra\'s algorithm priority_queue = [(0, start_city)] shortest_paths = {start_city: 0} while priority_queue: current_travel_time, current_city = heapq.heappop(priority_queue) if current_city == destination_city: return current_travel_time for connected_travel_time, connected_city in graph[current_city]: travel_time = current_travel_time + connected_travel_time if connected_city not in shortest_paths or travel_time < shortest_paths[connected_city]: shortest_paths[connected_city] = travel_time heapq.heappush(priority_queue, (travel_time, connected_city)) return float(\'inf\') # Return a large number if no path is found (should not happen according to constraints) # Example file creation for illustration with open(\\"cities.txt\\", \\"w\\") as file: file.write(\\"A B 4n\\") file.write(\\"A C 2n\\") file.write(\\"B C 5n\\") file.write(\\"B D 10n\\") file.write(\\"C D 3n\\")"},{"question":"# Description: Create a class `Distance` that supports basic arithmetic operations for distances represented in kilometers and meters. The class should handle operations such as addition, subtraction, multiplication, and division. Additionally, the class should be able to convert distances into meters and vice versa. # Task: Implement a class `Distance` with the following functionalities: 1. Initialization that accepts kilometers and meters. 2. Methods for addition, subtraction, multiplication, and division. 3. Support for conversion between kilometers and meters. 4. String representation of the distance in the format \\"X km Y m\\". # Constraints: - Positive and negative values must be handled. - The division should raise a `ValueError` when attempting to divide by zero. - Ensure consistency in units during operations and conversions. # Input: - Two integers or floats representing kilometers and meters. # Output: - Distances as an instance of the Distance class after the performed arithmetic operations. # Example Usage: ```python >>> d1 = Distance(2, 500) # 2 km 500 m >>> d2 = Distance(1, 750) # 1 km 750 m >>> d3 = d1 + d2 >>> print(d3) 4 km 250 m >>> d4 = d1 - d2 >>> print(d4) 0 km 750 m >>> d5 = d1 * 3 >>> print(d5) 7 km 500 m >>> d6 = d1 / 2 >>> print(d6) 1 km 250 m >>> d2.to_kilometers() 1.75 >>> d2.to_meters() 1750 ``` # Note: - Kilometers and meters should be normalized after each arithmetic operation (i.e., meters should always be less than 1000). - Customize the representation to display meaningful and accurate results for combined distances. ```python class Distance: def __init__(self, kilometers: int | float, meters: int | float): self.kilometers = kilometers self.meters = meters self.normalize() def normalize(self): if self.meters >= 1000: self.kilometers += self.meters // 1000 self.meters %= 1000 elif self.meters < 0: reduce_km = (-self.meters) // 1000 + 1 self.kilometers -= reduce_km self.meters += reduce_km * 1000 def __str__(self): return f\\"{self.kilometers} km {self.meters} m\\" def __add__(self, other): km = self.kilometers + other.kilometers m = self.meters + other.meters return Distance(km, m) def __sub__(self, other): km = self.kilometers - other.kilometers m = self.meters - other.meters return Distance(km, m) def __mul__(self, factor): km = self.kilometers * factor m = self.meters * factor return Distance(km, m) def __truediv__(self, divisor): if divisor == 0: raise ValueError(\\"Cannot divide by zero\\") total_meters = (self.kilometers * 1000 + self.meters) / divisor km = total_meters // 1000 m = total_meters % 1000 return Distance(km, m) def to_kilometers(self): return self.kilometers + self.meters / 1000 def to_meters(self): return self.kilometers * 1000 + self.meters ```","solution":"class Distance: def __init__(self, kilometers: int | float, meters: int | float): Initializes the Distance object and normalizes the values. self.kilometers = kilometers self.meters = meters self.normalize() def normalize(self): Converts meters to kilometers if meters >= 1000 or meters < 0. if self.meters >= 1000: self.kilometers += self.meters // 1000 self.meters %= 1000 elif self.meters < 0: reduce_km = (-self.meters) // 1000 + 1 self.kilometers -= reduce_km self.meters += reduce_km * 1000 def __str__(self): Returns the string representation of the Distance object. return f\\"{int(self.kilometers)} km {int(self.meters)} m\\" def __add__(self, other): Adds two Distance objects. km = self.kilometers + other.kilometers m = self.meters + other.meters return Distance(km, m) def __sub__(self, other): Subtracts one Distance object from another. km = self.kilometers - other.kilometers m = self.meters - other.meters return Distance(km, m) def __mul__(self, factor): Multiplies the Distance object by a factor. total_meters = (self.kilometers * 1000 + self.meters) * factor km = total_meters // 1000 m = total_meters % 1000 return Distance(km, m) def __truediv__(self, divisor): Divides the Distance object by a divisor. Raises ValueError if divisor is zero. if divisor == 0: raise ValueError(\\"Cannot divide by zero\\") total_meters = (self.kilometers * 1000 + self.meters) / divisor km = total_meters // 1000 m = total_meters % 1000 return Distance(km, m) def to_kilometers(self): Converts the Distance object to kilometers. return self.kilometers + self.meters / 1000 def to_meters(self): Converts the Distance object to meters. return self.kilometers * 1000 + self.meters"},{"question":"# Longest Common Substring Using Suffix Array and LCP Array Background Scenario Finding the longest common substring between two strings efficiently is a common problem in bioinformatics and text processing. One method to solve this involves using suffix arrays and longest common prefix (LCP) arrays. You are tasked with implementing functions to construct these arrays and then find the longest common substring. Function Description Implement three functions: 1. `construct_suffix_array(text: str) -> List[int]`: This function takes a text input and constructs the suffix array. 2. `construct_lcp_array(text: str, suffix_array: List[int]) -> List[int]`: This function takes the text and its suffix array to construct the LCP array. 3. `find_longest_common_substring(text1: str, text2: str) -> str`: This function takes two texts and finds the longest common substring using the suffix and LCP arrays. Expected Input and Output: 1. `construct_suffix_array(text: str) -> List[int]` * **Input**: A string `text` of length `n`. * **Output**: A list of integers representing the suffix array. 2. `construct_lcp_array(text: str, suffix_array: List[int]) -> List[int]` * **Input**: A string `text` and its suffix array. * **Output**: A list of integers representing the LCP array. 3. `find_longest_common_substring(text1: str, text2: str) -> str` * **Input**: Two strings `text1` and `text2`. * **Output**: A string representing the longest common substring. Constraints: 1. Text length `n` and `m` are between 1 and 10^5. 2. Texts consist of lowercase English alphabets only. 3. The time complexity for constructing the suffix array should be O(n log n). 4. The time complexity for constructing the LCP array should be O(n). 5. The time complexity for finding the longest common substring should aim for O(n + m). Specification: ```python def construct_suffix_array(text: str) -> List[int]: Constructs a suffix array for the given text. Parameters: text (str): The text for which to construct the suffix array. Returns: List[int]: The constructed suffix array. # Task implementation here pass def construct_lcp_array(text: str, suffix_array: List[int]) -> List[int]: Constructs the LCP array for the given text using its suffix array. Parameters: text (str): The text for which to construct the LCP array. suffix_array (List[int]): The suffix array of the text. Returns: List[int]: The constructed LCP array. # Task implementation here pass def find_longest_common_substring(text1: str, text2: str) -> str: Finds the longest common substring between two texts using suffix and LCP arrays. Parameters: text1 (str): The first text. text2 (str): The second text. Returns: str: The longest common substring. # Task implementation here pass ``` Example: ```python text1 = \\"banana\\" text2 = \\"ananas\\" print(find_longest_common_substring(text1, text2)) # Output: \\"anana\\" text1 = \\"abcde\\" text2 = \\"fghij\\" print(find_longest_common_substring(text1, text2)) # Output: \\"\\" ```","solution":"from typing import List, Tuple def construct_suffix_array(text: str) -> List[int]: Constructs a suffix array for the given text. Parameters: text (str): The text for which to construct the suffix array. Returns: List[int]: The constructed suffix array. suffixes = [(text[i:], i) for i in range(len(text))] suffixes.sort() suffix_array = [suffix[1] for suffix in suffixes] return suffix_array def construct_lcp_array(text: str, suffix_array: List[int]) -> List[int]: Constructs the LCP array for the given text using its suffix array. Parameters: text (str): The text for which to construct the LCP array. suffix_array (List[int]): The suffix array of the text. Returns: List[int]: The constructed LCP array. n = len(text) rank = [0] * n lcp = [0] * n # Build rank array for i, suffix in enumerate(suffix_array): rank[suffix] = i # Build LCP array using Kasai\'s algorithm h = 0 for i in range(n): if rank[i] > 0: j = suffix_array[rank[i] - 1] while (i + h < n) and (j + h < n) and text[i + h] == text[j + h]: h += 1 lcp[rank[i]] = h if h > 0: h -= 1 return lcp def find_longest_common_substring(text1: str, text2: str) -> str: Finds the longest common substring between two texts using suffix and LCP arrays. Parameters: text1 (str): The first text. text2 (str): The second text. Returns: str: The longest common substring. combined_text = text1 + \'#\' + text2 + \'\' suffix_array = construct_suffix_array(combined_text) lcp = construct_lcp_array(combined_text, suffix_array) max_len = 0 start_index = 0 for i in range(1, len(suffix_array)): if (suffix_array[i] < len(text1)) != (suffix_array[i - 1] < len(text1)): if lcp[i] > max_len: max_len = lcp[i] start_index = suffix_array[i] return combined_text[start_index: start_index + max_len]"},{"question":"# Matrix Path Finder Challenge Overview You are developing a feature for a navigation system that calculates the shortest path in a grid-based map. The map is represented as a 2D grid where certain cells are marked as obstacles, and you need to find the shortest path from the starting point to the destination. Problem Statement Implement a function `shortest_path(grid: list[list[int]], start: tuple, destination: tuple) -> int` that calculates the shortest path from the start position to the destination in a 2D grid. Each cell in the grid can either be walkable (represented by 0) or an obstacle (represented by 1). You can move up, down, left, or right from a cell. If there is no valid path from the start to the destination, return -1. Input - `grid`: A list of lists where each inner list represents a row in the 2D grid. Each value in the inner lists is either 0 (walkable) or 1 (obstacle). - `start`: A tuple `(x, y)` representing the starting coordinates in the grid. - `destination`: A tuple `(x, y)` representing the destination coordinates in the grid. Output - An integer representing the length of the shortest path from the start to the destination. Return -1 if there is no valid path. Constraints - The grid can be of any size, but it will always be a valid rectangular grid. - The start and destination coordinates will always be within the grid boundaries. - There will be no obstacles at the start and destination positions. - The grid will have at least 1 row and 1 column. Example ```python grid = [ [0, 0, 0, 1], [0, 1, 0, 0], [0, 0, 0, 0], [1, 0, 1, 0] ] start = (0, 0) destination = (3, 3) output = 6 assert shortest_path(grid, start, destination) == 6 ``` ```python grid = [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 0, 0, 1], [1, 0, 1, 0] ] start = (0, 0) destination = (3, 3) output = -1 assert shortest_path(grid, start, destination) == -1 ``` Notes - Ensure your solution is efficient and can handle larger grids in a reasonable time frame. - Avoid redundant paths and loops to minimize the computational complexity.","solution":"from collections import deque def shortest_path(grid, start, destination): Finds the shortest path from start to destination in a grid. :param grid: List of lists representing the 2D grid. 0 represents walkable cell, 1 represents obstacle. :param start: Tuple (x, y) representing the starting coordinates. :param destination: Tuple (x, y) representing the destination coordinates. :returns: Integer representing the length of the shortest path, or -1 if no valid path exists. if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) start_x, start_y = start dest_x, dest_y = destination def is_valid_move(x, y): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) while queue: x, y, dist = queue.popleft() if (x, y) == (dest_x, dest_y): return dist for dx, dy in directions: new_x, new_y = x + dx, y + dy if is_valid_move(new_x, new_y) and (new_x, new_y) not in visited: visited.add((new_x, new_y)) queue.append((new_x, new_y, dist + 1)) return -1"},{"question":"You are required to write a function that evaluates the postfix (Reverse Polish Notation) expression and returns the result. The function should support the four basic arithmetic operators (\'+\', \'-\', \'*\', \'/\'). # Function Signature ```python def evaluate_postfix(expression: List[str]) -> int: pass ``` # Input * **expression**: A list of strings, each string being either an operand (whole number) or an operator (\'+\', \'-\', \'*\', \'/\'). The list represents a valid postfix expression. # Output * **Return**: An integer representing the result of evaluating the postfix expression. # Constraints * Every operand in the expression is a whole number. * The expression is guaranteed to be valid. * The result will be an integer after evaluating the expression. * Division should truncate towards zero. # Performance Requirement * Your algorithm should efficiently evaluate the postfix expression using an appropriate data structure. # Scenario A computer scientist is implementing a calculator app that needs to support postfix expressions. This task will help in evaluating the given postfix expressions accurately and efficiently, ensuring correct calculations in the app. # Examples ```python assert evaluate_postfix([\'2\', \'1\', \'+\', \'3\', \'*\']) == 9 assert evaluate_postfix([\'4\', \'13\', \'5\', \'/\', \'+\']) == 6 assert evaluate_postfix([\'10\', \'6\', \'9\', \'3\', \'+\', \'-11\', \'*\', \'/\', \'*\', \'17\', \'+\', \'5\', \'+\']) == 22 ``` Explanation: * In the first example, the expression evaluates to 3 * (2 + 1) = 9. * In the second example, the expression evaluates to 4 + (13 / 5) = 6. * In the third example, the complex expression evaluates to 22 following the postfix notation rules. This additional question maintains the same style, length, complexity, and scope as the provided question, but explores a different yet related concept within the realm of algorithmic challenges.","solution":"from typing import List def evaluate_postfix(expression: List[str]) -> int: stack = [] for token in expression: if token.isdigit() or (token[0] == \'-\' and token[1:].isdigit()): # handling negative numbers stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(int(a / b)) # truncate towards zero return stack[0]"},{"question":"# Coding Assessment Question You are required to design a function that takes a list of numbers and returns a new list containing only the prime numbers from the original list. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Function Signature `def filter_primes(numbers: list) -> list:` Input * `numbers`: A list of integers. Output * Returns a list of integers containing only the prime numbers present in the input list. Constraints * The input list can contain both positive and negative integers but the function should only consider the positive integers for prime checking. * The returned list should maintain the order of primes as they appeared in the original list. * If there are no prime numbers in the list, return an empty list. * Handle large inputs efficiently. Examples ```python >>> filter_primes([2, 3, 4, 5, 6, 7, 8, 9, 10]) [2, 3, 5, 7] >>> filter_primes([-1, 0, 1, 13, 17, -19, 23]) [13, 17, 23] >>> filter_primes([15, 21, 24, 28]) [] >>> filter_primes([29, 31, 37, 41]) [29, 31, 37, 41] ``` # Your Implementation ```python def filter_primes(numbers: list) -> list: def is_prime(n): if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True return [num for num in numbers if is_prime(num)] ``` Notes Make sure to: - Consider edge cases like empty input lists or lists with no positive integers. - Optimize the prime checking function for efficiency, particularly with large numbers. - Validate against the provided examples to ensure correctness.","solution":"def filter_primes(numbers: list) -> list: def is_prime(n): if n < 2: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True return [num for num in numbers if is_prime(num)]"},{"question":"Problem Statement You are provided with the `height_balanced_tree()` function, which constructs a height-balanced binary search tree from a sorted list of integers. Height-balanced trees are widely used in computer science due to their efficient insertion, deletion, and lookup times. Your task is to create and verify this functionality by implementing the `height_balanced_tree()` function. # Function Signature ```python def height_balanced_tree(arr: list[int]) -> TreeNode: ``` # Input - `arr`: A list of integers in non-decreasing order where (1 leq text{len(arr)} leq 10^4). # Output - A `TreeNode` object representing the root of the height-balanced binary search tree. # TreeNode Class Definition You can assume the following `TreeNode` class is available for representing tree nodes: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Example ```python # Example usage arr = [-10, -3, 0, 5, 9] root = height_balanced_tree(arr) ``` For the input sorted list `[-10, -3, 0, 5, 9]`, a possible output binary tree could be: ```plaintext 0 / -10 5 -3 9 ``` # Explanation - The first call to `height_balanced_tree([-10, -3, 0, 5, 9])` chooses the middle element `0` as the root. - The left subtree is constructed by recursively applying the function to `[-10, -3]`, and the right subtree is constructed by applying the function to `[5, 9]`. # Constraints - The input list `arr` is guaranteed to be sorted in non-decreasing order. - The height-balanced property implies that the depths of the two subtrees of any node never differ by more than 1. # Note - Aim for a solution with O(n) time complexity where n is the length of `arr`. - Ensure the function correctly handles cases where the sorted list has even and odd lengths.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def height_balanced_tree(arr): Constructs a height-balanced binary search tree from a sorted list of integers. :param arr: List[int] - Sorted list of integers :return: TreeNode - The root of the height-balanced binary search tree if not arr: return None mid = len(arr) // 2 root = TreeNode(val=arr[mid]) root.left = height_balanced_tree(arr[:mid]) root.right = height_balanced_tree(arr[mid+1:]) return root"},{"question":"# Problem Description Given a series of points in 2D space, your task is to implement a function that determines the minimum bounding rectangle (MBR) that can encompass all the given points. The MBR is defined by its bottom-left and top-right corner points. # Input A function `min_bounding_rectangle(points: list[tuple[int, int]]) -> tuple[tuple[int, int], tuple[int, int]]` that takes a list of tuples, where each tuple consists of two integers representing the x and y coordinates of a point in 2D space. # Output The function should return a tuple of two tuples. The first tuple represents the bottom-left corner and the second tuple represents the top-right corner of the MBR. # Constraints * `0 <= len(points) <= 10^5` * `-10^9 <= x, y <= 10^9` for each point. # Example ```python assert min_bounding_rectangle([(1, 2), (4, 6), (2, 3), (5, 8)]) == ((1, 2), (5, 8)) assert min_bounding_rectangle([(-5, -3), (0, 0), (10, 2)]) == ((-5, -3), (10, 2)) assert min_bounding_rectangle([(3, 3)]) == ((3, 3), (3, 3)) ``` # Explanation 1. **Input**: `[(1, 2), (4, 6), (2, 3), (5, 8)]` **Output**: `((1, 2), (5, 8))` **Explanation**: The minimum bounding rectangle covering all the points has bottom-left corner at (1, 2) and top-right corner at (5, 8). 2. **Input**: `[(-5, -3), (0, 0), (10, 2)]` **Output**: `((+5, -3), (10, 2))` **Explanation**: The minimum bounding rectangle covering all the points has bottom-left corner at (-5, -3) and top-right corner at (10, 2). 3. **Input**: `[(3, 3)]` **Output**: `((3, 3), (3, 3))` **Explanation**: The minimum bounding rectangle containing just a single point (3, 3) coincides with that point.","solution":"def min_bounding_rectangle(points): Determines the minimum bounding rectangle (MBR) that encompasses all given points. Parameters: points (list[tuple[int, int]]): A list of tuples where each tuple represents a point (x, y) in 2D space. Returns: tuple[tuple[int, int], tuple[int, int]]: The bottom-left and top-right corners of the MBR. if not points: return None # Return None if points list is empty min_x = min(point[0] for point in points) max_x = max(point[0] for point in points) min_y = min(point[1] for point in points) max_y = max(point[1] for point in points) return (min_x, min_y), (max_x, max_y)"},{"question":"# Graph Traversal Problem – Shortest Path in Unweighted Graph In this task, you are required to implement solutions to find the shortest path between nodes in an unweighted graph. Part 1: Breadth-First Search (BFS) You are to implement a function `shortest_path_bfs` that finds the shortest path in terms of the number of edges between two nodes in an unweighted graph using BFS. The function should return the path as a list of nodes. Part 2: Depth-First Search (DFS) Implement a function `path_exists_dfs` that checks if there is a path between two nodes in an unweighted graph using DFS. The function should return `True` if a path exists, otherwise `False`. Function Signatures ```python def shortest_path_bfs(graph: Dict[int, List[int]], start: int, goal: int) -> List[int]: Finds the shortest path in terms of the number of edges between two nodes in an unweighted graph using BFS. Parameters: graph (Dict[int, List[int]]): The adjacency list representation of the graph where each node has a list of connected nodes. start (int): The starting node. goal (int): The goal node. Returns: List[int]: The shortest path from start to goal as a list of nodes, or an empty list if no path exists. pass def path_exists_dfs(graph: Dict[int, List[int]], start: int, goal: int) -> bool: Checks if there is a path between two nodes in an unweighted graph using DFS. Parameters: graph (Dict[int, List[int]]): The adjacency list representation of the graph where each node has a list of connected nodes. start (int): The starting node. goal (int): The goal node. Returns: bool: True if a path exists, otherwise False. pass ``` # Constraints * The graph is undirected and may be disconnected. * `graph` will have at most 10,000 nodes and 100,000 edges. * The nodes are represented as integers. * `start` and `goal` are guaranteed to be nodes present in the graph. # Example ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2] } print(shortest_path_bfs(graph, 0, 3)) # Output: [0, 1, 3] print(path_exists_dfs(graph, 0, 3)) # Output: True print(shortest_path_bfs(graph, 0, 5)) # Output: [] print(path_exists_dfs(graph, 0, 5)) # Output: False ``` # Requirements 1. Use queue and visited set appropriately for BFS. 2. Use stack and visited set appropriately for DFS. 3. Ensure to handle graphs with cycles. 4. Optimize for performance, avoiding excessive recursion in DFS to prevent stack overflow.","solution":"from collections import deque def shortest_path_bfs(graph, start, goal): Finds the shortest path in terms of the number of edges between two nodes in an unweighted graph using BFS. Parameters: graph (Dict[int, List[int]]): The adjacency list representation of the graph where each node has a list of connected nodes. start (int): The starting node. goal (int): The goal node. Returns: List[int]: The shortest path from start to goal as a list of nodes, or an empty list if no path exists. if start == goal: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == goal: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] def path_exists_dfs(graph, start, goal): Checks if there is a path between two nodes in an unweighted graph using DFS. Parameters: graph (Dict[int, List[int]]): The adjacency list representation of the graph where each node has a list of connected nodes. start (int): The starting node. goal (int): The goal node. Returns: bool: True if a path exists, otherwise False. stack = [(start, [start])] visited = set() while stack: current_node, path = stack.pop() if current_node in visited: continue if current_node == goal: return True visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: stack.append((neighbor, path + [neighbor])) return False"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the product of all elements except the one at the current index in an integer array. The product should be computed without using division. Return the resultant array of products. # Function Signature ```python def products_except_current(nums: list) -> list: Calculates the product of all elements except the one at the current index. Args: nums (list of int): An array of integers. Returns: list: An array where each element is the product of all the elements in the input array except the one at the current index. ``` # Input Constraints - `nums` is a list of integers. - The length of `nums` is between 1 and 10^5. - The values of integers in `nums` are between -10^3 and 10^3. # Output Format - Return a list where each element is the product of all elements in `nums` except the one at that index. # Example ```python nums = [1, 2, 3, 4] print(products_except_current(nums)) # Output: [24, 12, 8, 6] nums = [-1, 1, 0, -3, 3] print(products_except_current(nums)) # Output: [0, 0, 9, 0, 0] ``` # Evaluation Criteria - Correctness: The function should return accurate products for all test cases. - Efficiency: The function should run within acceptable time limits for large inputs. - Edge Cases: The function should handle edge cases such as arrays with zero, negative numbers, and the smallest/largest values effectively.","solution":"def products_except_current(nums): Calculates the product of all elements except the one at the current index. Args: nums (list of int): An array of integers. Returns: list: An array where each element is the product of all the elements in the input array except the one at the current index. length = len(nums) if length == 0: return [] # Initialize the result array with 1s result = [1] * length # First pass: Calculate products of all elements before each index left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] # Second pass: Calculate products of all elements after each index right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"# File Management System You are tasked with creating a file management system that supports creating, reading, updating, and deleting files. Additionally, you need to track the creation and modification times of each file. Problem Statement Implement the following functions for the file management system: 1. `create_file(file_name: str, content: str) -> str`: Creates a new file with the given content. If the file already exists, it will overwrite the content. 2. `read_file(file_name: str) -> str`: Reads the content of the specified file. 3. `update_file(file_name: str, content: str) -> str`: Updates the content of an existing file. 4. `delete_file(file_name: str) -> str`: Deletes the specified file. 5. `file_info(file_name: str) -> dict`: Returns a dictionary with the \'created\' and \'modified\' times of the specified file in ISO format. Each function should raise appropriate exceptions if the file operations fail (e.g., file not found when reading, updating, or deleting). Input and Output Formats * **Inputs**: * `file_name` (string): The name of the file to operate on. * `content` (string): The content to write to the file (for create and update operations). * **Outputs**: * For `create_file`, `update_file`, and `delete_file`, return a string confirming the operation (e.g., \\"File created\\", \\"File updated\\", \\"File deleted\\"). * For `read_file`, return the content of the file as a string. * For `file_info`, return a dictionary with \'created\' and \'modified\' times in ISO format. Constraints: * If any file operations fail (file not found, access permissions, etc.), raise an appropriate exception with a message describing the issue. * Ensure file operations are atomic to avoid concurrent access issues. Example ```python # Example usage print(create_file(\\"example.txt\\", \\"Hello, world!\\")) # Output: \\"File created\\" print(read_file(\\"example.txt\\")) # Output: \\"Hello, world!\\" print(update_file(\\"example.txt\\", \\"Updated content\\")) # Output: \\"File updated\\" print(delete_file(\\"example.txt\\")) # Output: \\"File deleted\\" print(file_info(\\"example.txt\\")) # Output: {\'created\': \'2023-10-21T14:56:20\', \'modified\': \'2023-10-21T15:00:00\'} ```","solution":"import os import time from datetime import datetime def create_file(file_name, content): with open(file_name, \'w\') as f: f.write(content) times = { \'created\': datetime.fromtimestamp(os.path.getctime(file_name)).isoformat(), \'modified\': datetime.fromtimestamp(os.path.getmtime(file_name)).isoformat() } return \\"File created\\", times def read_file(file_name): if not os.path.exists(file_name): raise FileNotFoundError(f\\"File {file_name} not found.\\") with open(file_name, \'r\') as f: return f.read() def update_file(file_name, content): if not os.path.exists(file_name): raise FileNotFoundError(f\\"File {file_name} not found.\\") with open(file_name, \'w\') as f: f.write(content) times = { \'created\': datetime.fromtimestamp(os.path.getctime(file_name)).isoformat(), \'modified\': datetime.fromtimestamp(os.path.getmtime(file_name)).isoformat() } return \\"File updated\\", times def delete_file(file_name): if not os.path.exists(file_name): raise FileNotFoundError(f\\"File {file_name} not found.\\") os.remove(file_name) return \\"File deleted\\" def file_info(file_name): if not os.path.exists(file_name): raise FileNotFoundError(f\\"File {file_name} not found.\\") times = { \'created\': datetime.fromtimestamp(os.path.getctime(file_name)).isoformat(), \'modified\': datetime.fromtimestamp(os.path.getmtime(file_name)).isoformat() } return times"},{"question":"# Coding Assessment Question You are given the code snippet for a doubly linked list and its algorithm to append and prepend elements. Enhance the `DoublyLinkedList` class by adding two new operations: 1. `find_kth_from_end(k: int) -> int` - Finds the k-th element from the end of the doubly linked list. Returns `-1` if `k` is greater than the length of the list. 2. `delete_node(node_value: int) -> bool` - Deletes the first node with the given value from the doubly linked list. Returns `True` if the node was successfully deleted, otherwise returns `False`. Implement the following methods with the exact signatures and constraints as shown. Expected Input and Output Formats: ```python class DoublyLinkedList: ... def find_kth_from_end(self, k: int) -> int: Finds the k-th element from the end of the doubly linked list. Args: k (int): The position from the end (1-based index). Returns: int: The value of the k-th node from the end, or -1 if k is invalid. >>> dll = DoublyLinkedList() >>> dll.append(1) >>> dll.append(2) >>> dll.append(3) >>> dll.append(4) >>> dll.append(5) >>> dll.find_kth_from_end(2) 4 >>> dll.find_kth_from_end(6) -1 >>> def delete_node(self, node_value: int) -> bool: Deletes the first node with the specified value from the doubly linked list. Args: node_value (int): The value of the node to be deleted. Returns: bool: True if the node was deleted, False otherwise. >>> dll = DoublyLinkedList() >>> dll.append(1) >>> dll.append(2) >>> dll.append(3) >>> dll.append(4) >>> dll.append(5) >>> dll.delete_node(3) True >>> dll.find_kth_from_end(3) 2 >>> dll.delete_node(10) False >>> ``` Constraints: - Memory usage should be kept minimal. - The operations should be performed in place. - The methods should handle edge cases gracefully (e.g., empty list, single node list). - Performance targets: - Finding the k-th element from the end in O(N) time complexity. - Deleting a node in O(N) time complexity. **Scenario/Context**: You are working on a software component that manipulates a doubly linked list to manage a sequence of actions history. You often need to find recent actions (k-th from the end) and remove specific actions from the history. Implement these functionalities efficiently to ensure reliable and quick data management operations.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node def find_kth_from_end(self, k: int) -> int: if self.head is None or k <= 0: return -1 slow = fast = self.head for _ in range(k): if fast is None: return -1 fast = fast.next while fast is not None: slow = slow.next fast = fast.next return slow.value def delete_node(self, node_value: int) -> bool: current = self.head while current: if current.value == node_value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return True current = current.next return False"},{"question":"# Problem Statement Write a function that transforms a given string by reversing each word in the string while preserving the word order and the original positions of the whitespace characters. # Function Signature ```python def reverse_each_word(string: str) -> str: Reverses each word in the input string while maintaining the original whitespace positions. :param string: The input string composed of words and whitespace characters. :return: A new string with each word reversed but whitespace positions unchanged. ``` # Input Format * The `string` parameter is a non-empty string of ASCII characters, including spaces. # Output Format * A string with each word reversed but the original whitespace preserved. # Constraints * The input string will have a length of (1 leq |text{string}| leq 10^5). * Words are defined as sequences of non-space characters. * Whitespaces can appear at any position in the string. # Example ```python >>> reverse_each_word(\\"hello world\\") \\"olleh dlrow\\" >>> reverse_each_word(\\" code challenge \\") \\" edoc egnellahc \\" >>> reverse_each_word(\\"Programming is fun\\") \\"gnimmargorP si nuf\\" >>> reverse_each_word(\\"reverse this string\\") \\"esrever siht gnirts\\" ``` # Explanation In the example `reverse_each_word(\\"hello world\\")`, the function should reverse each individual word while maintaining the original positions of the spaces, resulting in the string `\\"olleh dlrow\\"`. # Additional Notes Consider edge cases such as: * Multiple spaces between words. * Leading or trailing spaces should be preserved in the final result. * Handle strings that consist entirely of spaces, or strings with no spaces gracefully.","solution":"def reverse_each_word(string: str) -> str: Reverses each word in the input string while maintaining the original whitespace positions. :param string: The input string composed of words and whitespace characters. :return: A new string with each word reversed but whitespace positions unchanged. words = string.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Coding Question Create a function to determine whether a given string `s` is a valid palindrome, considering only alphanumeric characters and ignoring cases. Additionally, implement an iterative function to reverse the string and compare it with the original for validation. Function Signatures 1. `is_palindrome_check(s: str) -> bool` 2. `reverse_and_compare(s: str) -> bool` Input - `s`: A string consisting of any characters. Output - `True` if the string is a valid palindrome; otherwise, `False`. Constraints - The string may be empty. - The string may contain non-alphanumeric characters which should be ignored during the palindrome check. Example ```python s = \\"A man, a plan, a canal: Panama\\" print(is_palindrome_check(s)) # Output: True print(reverse_and_compare(s)) # Output: True s = \\"race a car\\" print(is_palindrome_check(s)) # Output: False print(reverse_and_compare(s)) # Output: False s = \\"\\" print(is_palindrome_check(s)) # Output: True print(reverse_and_compare(s)) # Output: True ``` Notes - The `is_palindrome_check` function should use a two-pointer technique to check for palindromes by ignoring non-alphanumeric characters and case differences. - The `reverse_and_compare` function should reverse the string (considering only alphanumeric characters) iteratively and compare it ignoring cases. - Both functions should handle empty strings gracefully.","solution":"def is_palindrome_check(s: str) -> bool: Returns True if the given string is a palindrome, ignoring non-alphanumeric characters and case differences. def is_alphanumeric(c): return c.isalnum() left, right = 0, len(s) - 1 while left < right: while left < right and not is_alphanumeric(s[left]): left += 1 while left < right and not is_alphanumeric(s[right]): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True def reverse_and_compare(s: str) -> bool: Returns True if the given string is a palindrome by reversing the string and comparing it to the original, ignoring non-alphanumeric characters and case differences. filtered_chars = [c.lower() for c in s if c.isalnum()] reversed_chars = filtered_chars[::-1] return filtered_chars == reversed_chars"},{"question":"# Problem Statement: You need to write a function that takes an encoded message string and decodes it based on a specific compression algorithm. The algorithm encodes the message by grouping consecutive identical characters and replacing them with the character followed by the number of occurrences in that group. Your task is to reverse this process and decode the message back to its original form. **Function Specifications**: 1. **decode_message**: - **Input**: `encoded: str` - An encoded string using the specified compression algorithm. - **Output**: `str` - The original decoded message. **Details**: The compression algorithm works as follows: - `\\"aaabbcddd\\"` becomes `\\"a3b2c1d3\\"`. - Each character is followed by an integer indicating the number of times it appears consecutively. To decode: - Read each character and the following number, then expand the character according to the number. **Constraints**: - The input string `encoded` will always be valid as per the encoding rules. - Characters are limited to lowercase alphabetic letters. **Example**: ```python # Example usage: print(decode_message(\\"a3b2c1d3\\")) # Expected Output: \\"aaabbcddd\\" print(decode_message(\\"x1y2z3\\")) # Expected Output: \\"xyyzzz\\" ``` # Implementation You need to implement the following function: ```python def decode_message(encoded: str) -> str: # Implement the decoding algorithm pass ``` # Notes - Ensure to handle multiple characters and longer sequences properly. - Consider edge cases such as single characters, long sequences, and mixed lengths. Example Input and Output ```python # Example 1 print(decode_message(\\"p5q2r1\\")) # Expected Output: \\"pppppqqr\\" # Example 2 print(decode_message(\\"m1n3o4\\")) # Expected Output: \\"mnnnoooo\\" # Example 3 print(decode_message(\\"a1b10\\")) # Expected Output: \\"abbbbbbbbbb\\" ``` The function should correctly decode the given encoded string back to its original form by expanding each character as specified by the accompanying number.","solution":"def decode_message(encoded: str) -> str: Decodes the given encoded string back to its original form. :param encoded: A string encoded using the specified compression algorithm. :return: The original decoded message. decoded = [] i = 0 while i < len(encoded): char = encoded[i] i += 1 num_str = \\"\\" while i < len(encoded) and encoded[i].isdigit(): num_str += encoded[i] i += 1 num = int(num_str) decoded.append(char * num) return \'\'.join(decoded)"},{"question":"# Matrix Rotation **Context**: Given a two-dimensional square matrix, you are required to rotate the matrix elements 90 degrees in the clockwise direction. Rotating the matrix involves transforming the matrix such that the first row becomes the last column, the second row becomes the second-to-last column, etc. **Function Specification**: Write a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes as input a square matrix (a list of lists of integers) and returns a new matrix that represents the original matrix rotated 90 degrees clockwise. **Input**: - A 2D list of integers representing the matrix, ( matrix ) (1 <= len(matrix) <= 100, 1 <= len(matrix[0]) <= 100) - It\'s guaranteed that the matrix will be square (i.e., number of rows is equal to the number of columns). **Output**: - A 2D list of integers representing the matrix rotated 90 degrees clockwise. **Constraints**: - Ensure the rotation is performed in-place (without using additional 2D arrays for storage). **Sample Input and Output**: ```python matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert rotate_matrix(matrix_1) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix_2 = [ [5, 1, 9], [2, 4, 8], [13, 3, 7] ] assert rotate_matrix(matrix_2) == [ [13, 2, 5], [3, 4, 1], [7, 8, 9] ] ```","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the given square matrix 90 degrees clockwise. n = len(matrix) # Create a new matrix to store the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Problem Statement You need to implement a function `is_perfect_square` that checks whether a given non-negative integer is a perfect square. A perfect square is an integer that is the square of some other integer. # Function Signature ```python def is_perfect_square(num: int) -> bool: ``` # Input - **num (int)**: A non-negative integer to be checked (0 ≤ num ≤ 10^6) # Output - **bool**: Returns `True` if the input number is a perfect square; otherwise, returns `False`. # Constraints 1. The input num will always be a non-negative integer. 2. Optimize for both time and space complexity. 3. The function should only deal with integer numbers, not floats or other types. # Example ```python >>> is_perfect_square(4) True >>> is_perfect_square(15) False >>> is_perfect_square(16) True >>> is_perfect_square(0) True >>> is_perfect_square(1) True >>> is_perfect_square(123456) False ``` # Explanation of Examples - `4` is a perfect square because it is equal to `2^2`. - `15` is not a perfect square because there is no integer whose square is `15`. - `16` is a perfect square because it is equal to `4^2`. - `0` is a perfect square because it is equal to `0^2`. - `1` is a perfect square because it is equal to `1^2`. - `123456` is not a perfect square as there is no integer whose square equals `123456`. # Edge Cases to Consider - The smallest number (0). - Typical use cases for small and large non-negative integers. - Limits of input size (up to 10^6) to evaluate performance.","solution":"def is_perfect_square(num: int) -> bool: Checks whether the given non-negative integer is a perfect square. Parameters: num (int): A non-negative integer to check. Returns: bool: True if the number is a perfect square, False otherwise. if num < 0: return False # As per constraint, but just to be safe. # We can use the integer square root function from the math library root = int(num**0.5) return root * root == num"},{"question":"# Scenario: You work for a company managing a logistics network where delivery trucks follow the shortest path between warehouses. They need a software solution to compute the shortest delivery routes efficiently, specifically applying Dijkstra\'s algorithm. # Task: Implement a class that constructs a weighted, directed graph to represent the warehouse network and uses Dijkstra\'s algorithm to find the shortest path between two warehouses. # Requirements: 1. **Initialization**: Initialize the graph with a list of edges, where each edge is a tuple (source, destination, weight). 2. **Methods**: * `add_edge(source, destination, weight)`: Adds an edge to the graph. * `shortest_path(source, destination)`: Finds the shortest path from the `source` node to the `destination` node using Dijkstra\'s algorithm. 3. **Constraints**: * Assume `source` and `destination` are valid nodes in the graph. * Edge weights are positive integers. * If there\'s no path between `source` and `destination`, return `None`. # Input Format: - Initialization parameters: * `edges`: List of tuples, where each tuple is `(source, destination, weight)`. - For `shortest_path` method: * `source`: Integer denoting the source node. * `destination`: Integer denoting the destination node. - For `add_edge` method: * `source`: Integer denoting the starting node of the edge. * `destination`: Integer denoting the ending node of the edge. * `weight`: Positive integer denoting the weight of the edge. # Output Format: - `shortest_path`: Float representing the shortest path distance, or `None` if no path exists. - `add_edge`: No return value. # Example: ```python # Initializing the graph with given edges edges = [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3)] graph = LogisticsGraph(edges) # Adding an edge graph.add_edge(4, 5, 11) # Finding the shortest path from node 1 to node 4 print(graph.shortest_path(1, 4)) # Expected output: shortest path distance between 1 and 4 ``` Implement the `LogisticsGraph` class in Python with the above specifications.","solution":"import heapq from collections import defaultdict, deque class LogisticsGraph: def __init__(self, edges): Initializes the graph. edges: List of tuples, where each tuple is (source, destination, weight). self.graph = defaultdict(list) for source, destination, weight in edges: self.add_edge(source, destination, weight) def add_edge(self, source, destination, weight): Adds an edge to the graph. source: Integer denoting the starting node of the edge. destination: Integer denoting the ending node of the edge. weight: Positive integer denoting the weight of the edge. self.graph[source].append((destination, weight)) self.graph[destination].append((source, weight)) # Assuming undirected graph def shortest_path(self, source, destination): Finds the shortest path from the source node to the destination node using Dijkstra\'s algorithm. source: Integer denoting the source node. destination: Integer denoting the destination node. Returns: Float representing the shortest path distance, or None if no path exists. heap = [(0, source)] distances = {source: 0} visited = set() while heap: current_dist, current_node = heapq.heappop(heap) if current_node in visited: continue visited.add(current_node) if current_node == destination: return current_dist for neighbor, weight in self.graph[current_node]: if neighbor in visited: continue new_dist = current_dist + weight if new_dist < distances.get(neighbor, float(\'inf\')): distances[neighbor] = new_dist heapq.heappush(heap, (new_dist, neighbor)) return None"},{"question":"# Scenario: You are tasked with implementing a system to manage a library’s collection of books. The system should support efficient insertion of new books, querying a book by its title, and retrieving a list of books by a specific author. # Requirements: 1. **Insert operation** should add a new book to the collection. 2. **Query-by-title operation** should retrieve the book details given its title. 3. **List-by-author operation** should retrieve all books by a specific author. # Function Specification: 1. **Insert Function**: ```python def insert(self, title: str, author: str, year: int) -> None: Inserts a new book into the library collection. Parameters: title (str): The title of the book. author (str): The author of the book. year (int): The publication year of the book. # Your implementation here ``` 2. **Query-by-title Function**: ```python def query_by_title(self, title: str) -> dict: Retrieves the book details for a given title. Parameters: title (str): The title of the book to retrieve. Returns: dict: A dictionary containing the book\'s title, author, and year. Returns an empty dictionary if the book is not found. # Your implementation here ``` 3. **List-by-author Function**: ```python def list_by_author(self, author: str) -> list: Retrieves all books by a specific author. Parameters: author (str): The author to list books for. Returns: list: A list of dictionaries, each containing the book\'s title, author, and year. Returns an empty list if no books by the author are found. # Your implementation here ``` # Constraints: - **Library Size**: 1 <= number of books in the library <= 10^5 - **Book Titles and Authors**: Title and author strings will have a length of <= 50 characters. - **Publication Year**: The year will be a positive integer. # Performance Requirements: - The insert and query operations should have average case time complexities that can handle collections of up to 100,000 books efficiently. # Example Usage: ```python # Initialize the library system library = Library() # Insert books into the library library.insert(\'The Great Gatsby\', \'F. Scott Fitzgerald\', 1925) library.insert(\'1984\', \'George Orwell\', 1949) library.insert(\'To Kill a Mockingbird\', \'Harper Lee\', 1960) # Query a book by its title book_details = library.query_by_title(\'1984\') # Should return {\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949} # List all books by a specific author books_by_orwell = library.list_by_author(\'George Orwell\') # Should return [{\'title\': \'1984\', \'author\': \'George Orwell\', \'year\': 1949}] ``` Ensure that all operations insert, query_by_title, and list_by_author follow the constraints and perform efficiently.","solution":"class Library: def __init__(self): self.books_by_title = {} self.books_by_author = {} def insert(self, title: str, author: str, year: int) -> None: self.books_by_title[title] = { \'title\': title, \'author\': author, \'year\': year } if author not in self.books_by_author: self.books_by_author[author] = [] self.books_by_author[author].append({ \'title\': title, \'author\': author, \'year\': year }) def query_by_title(self, title: str) -> dict: return self.books_by_title.get(title, {}) def list_by_author(self, author: str) -> list: return self.books_by_author.get(author, [])"},{"question":"# Question **Context**: You are a software engineer working on a project requiring quick access and manipulation of specific elements within a large dataset. A common data structure used for such purposes is a binary search tree (BST). Your task is to implement a function that will efficiently delete nodes from a BST while maintaining its properties. **Task**: Implement a function that deletes a given node from a binary search tree (BST) and returns the root of the updated tree. **Function Signature**: ```python class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None def delete_node(root: TreeNode, key: int) -> TreeNode: Args: - root: The root node of the binary search tree (BST), or None if the tree is empty. - key: An integer representing the key of the node to delete. Returns: - The root node of the updated BST after deleting the specified node. The function must maintain the properties of the binary search tree after deleting the node. ``` **Requirements**: 1. Implement the function `delete_node` which takes in: * `root`: The root node of the BST. * `key`: An integer representing the key of the node to delete. 2. The function should return the root node of the BST after the specified node has been deleted. 3. The BST must maintain its properties after the node is deleted. This means: * Every node\'s left subtree must contain only nodes with keys less than the node\'s key. * Every node\'s right subtree must contain only nodes with keys greater than the node\'s key. 4. If the node to be deleted does not exist in the tree, the function should return the original tree unchanged. **Examples**: ```python >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(7) >>> new_root = delete_node(root, 3) >>> # Expected new tree structure: >>> # 5 >>> # / >>> # 4 6 >>> # / >>> # 2 7 >>> new_root = delete_node(root, 5) >>> # Expected new tree structure: >>> # 6 >>> # / >>> # 3 7 >>> # / >>> # 2 4 >>> new_root = delete_node(root, 10) >>> # No change to the tree because 10 is not in the tree. ``` **Constraints**: * The number of nodes in the BST can be up to (10^5). * Each node\'s key is unique. * Each node contains an integer key (the value of the node). Good luck, and happy coding!","solution":"class TreeNode: def __init__(self, key: int): self.key = key self.left = None self.right = None def delete_node(root: TreeNode, key: int) -> TreeNode: if not root: return root if key < root.key: root.left = delete_node(root.left, key) elif key > root.key: root.right = delete_node(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = find_min(root.right) root.key = temp.key root.right = delete_node(root.right, temp.key) return root def find_min(node): current = node while current.left is not None: current = current.left return current"},{"question":"# Coding Question: Implement a basic Genetic Algorithm for Function Optimization **Objective**: Create a genetic algorithm to find the maximum value of a simple mathematical function within a specified range. You need to implement mechanisms for selection, crossover, mutation, and evolution of the population. Task Description: You need to implement a `GeneticAlgorithm` class with: 1. **Initialization**: Set up the population with random values within the defined range. 2. **Fitness Function**: - Evaluate the population by computing the function value. 3. **Selection Method**: - Select individuals based on their fitness (higher fitness means higher probability of selection). 4. **Crossover Method**: - Combine two parent solutions to produce offspring. 5. **Mutation Method**: - Introduce mutations in the offspring with a certain probability. 6. **Evolve Method**: - Perform selection, crossover, and mutation iteratively to evolve the population. 7. **Run Method**: - Execute the genetic algorithm for a specified number of generations or until convergence to a suitable solution. 8. **Best Solution Method**: - Return the best solution found. Implementation: ```python import numpy as np class GeneticAlgorithm: def __init__(self, population_size: int, mutation_rate: float, generations: int, bounds: tuple) -> None: self.population_size = population_size self.mutation_rate = mutation_rate self.generations = generations self.bounds = bounds self.population = self.initialize_population() def initialize_population(self) -> np.ndarray: return np.random.uniform(self.bounds[0], self.bounds[1], self.population_size) def fitness(self, individual: float) -> float: # Example function f(x) = x * sin(10 * π * x) + 1.0 return individual * np.sin(10 * np.pi * individual) + 1.0 def selection(self, population: np.ndarray) -> np.ndarray: fitness_values = np.array([self.fitness(ind) for ind in population]) probabilities = fitness_values / np.sum(fitness_values) return population[np.random.choice(np.arange(population.size), size=population.size, p=probabilities)] def crossover(self, parent1: float, parent2: float) -> float: return (parent1 + parent2) / 2 def mutation(self, individual: float) -> float: if np.random.rand() < self.mutation_rate: return individual + np.random.uniform(-0.1, 0.1) return individual def evolve(self) -> None: for _ in range(self.generations): selected_population = self.selection(self.population) new_population = [] for i in range(0, self.population_size, 2): parent1, parent2 = selected_population[i], selected_population[i+1] offspring1 = self.crossover(parent1, parent2) offspring2 = self.crossover(parent2, parent1) new_population.append(self.mutation(offspring1)) new_population.append(self.mutation(offspring2)) self.population = np.array(new_population) def best_solution(self) -> float: fitness_values = np.array([self.fitness(ind) for ind in self.population]) max_fitness_idx = np.argmax(fitness_values) return self.population[max_fitness_idx] def run(self) -> float: self.evolve() return self.best_solution() # Example Usage: if __name__ == \\"__main__\\": ga = GeneticAlgorithm(population_size=100, mutation_rate=0.01, generations=100, bounds=(0, 2)) best_solution = ga.run() print(f\\"Best solution: {best_solution}\\") ``` **Constraints**: - Ensure the population size, mutation rate, and the number of generations are optimal for the function optimization task. - Avoid using external libraries explicitly designed for genetic algorithms. **Performance Consideration**: - Aim for a runtime below a few minutes for the evolution process. - Ensure the genetic algorithm converges to an optimal or near-optimal solution within the specified number of generations.","solution":"import numpy as np class GeneticAlgorithm: def __init__(self, population_size: int, mutation_rate: float, generations: int, bounds: tuple) -> None: self.population_size = population_size self.mutation_rate = mutation_rate self.generations = generations self.bounds = bounds self.population = self.initialize_population() def initialize_population(self) -> np.ndarray: return np.random.uniform(self.bounds[0], self.bounds[1], self.population_size) def fitness(self, individual: float) -> float: # Example function f(x) = x * sin(10 * π * x) + 1.0 return individual * np.sin(10 * np.pi * individual) + 1.0 def selection(self, population: np.ndarray) -> np.ndarray: fitness_values = np.array([self.fitness(ind) for ind in population]) probabilities = fitness_values / np.sum(fitness_values) return population[np.random.choice(np.arange(population.size), size=population.size, p=probabilities)] def crossover(self, parent1: float, parent2: float) -> float: return (parent1 + parent2) / 2 def mutation(self, individual: float) -> float: if np.random.rand() < self.mutation_rate: return individual + np.random.uniform(-0.1, 0.1) return individual def evolve(self) -> None: for _ in range(self.generations): selected_population = self.selection(self.population) new_population = [] for i in range(0, self.population_size, 2): parent1, parent2 = selected_population[i], selected_population[i+1] offspring1 = self.crossover(parent1, parent2) offspring2 = self.crossover(parent2, parent1) new_population.append(self.mutation(offspring1)) new_population.append(self.mutation(offspring2)) self.population = np.array(new_population) def best_solution(self) -> float: fitness_values = np.array([self.fitness(ind) for ind in self.population]) max_fitness_idx = np.argmax(fitness_values) return self.population[max_fitness_idx] def run(self) -> float: self.evolve() return self.best_solution() # Example Usage: if __name__ == \\"__main__\\": ga = GeneticAlgorithm(population_size=100, mutation_rate=0.01, generations=100, bounds=(0, 2)) best_solution = ga.run() print(f\\"Best solution: {best_solution}\\")"},{"question":"# Scenario: You are a developer responsible for implementing a feature in a social media application that aggregates and returns trending hashtags. A hashtag is trending if it appears at least a specified number of times in a given list of hashtags. Your task is to implement a function that processes a list of hashtags and identifies the trending ones based on the given threshold. # Task: Implement a function `trending_hashtags` that performs the following: 1. Identifies hashtags that appear at least a given number of times. 2. Returns the list of trending hashtags in descending order of their frequency. If two hashtags have the same frequency, they should be returned in alphabetical order. # Specifications: 1. `trending_hashtags(hashtags: list[str], threshold: int) -> list[str]` - **Parameters**: - `hashtags (list[str])`: A list of hashtags (strings) used in posts. - `threshold (int)`: The minimum frequency a hashtag must have to be considered trending. - **Returns**: A list of trending hashtags sorted in the required order. 2. The function should validate and ensure: - The list of hashtags is not empty. - The threshold is a positive integer. # Example: ```python hashtags = [\\"#fun\\", \\"#meme\\", \\"#fun\\", \\"#travel\\", \\"#meme\\", \\"#fun\\", \\"#sunset\\", \\"#travel\\", \\"#fun\\"] threshold = 3 print(trending_hashtags(hashtags, threshold)) ``` **Expected Output**: ``` [\'#fun\', \'#meme\'] ``` # Constraints: - Hashtags are non-empty strings that start with the \'#\' character. - Focus on readability, maintainability, and efficiency of the code.","solution":"def trending_hashtags(hashtags, threshold): Identifies hashtags that appear at least a given number of times and returns them in descending order of their frequency. If two hashtags have the same frequency, they are returned in alphabetical order. from collections import Counter # Validate inputs if not hashtags or threshold <= 0: raise ValueError(\\"Hashtags list should not be empty and threshold should be a positive integer.\\") # Count the occurrences of each hashtag hashtag_counts = Counter(hashtags) # Filter hashtags that meet the threshold trending = [hashtag for hashtag, count in hashtag_counts.items() if count >= threshold] # Sort hashtags by frequency (descending), then alphabetically (ascending) trending.sort(key=lambda x: (-hashtag_counts[x], x)) return trending"},{"question":"# Problem Statement You are tasked with writing a function that determines whether a given list contains two numbers that add up to a specific target sum. Write a function `has_pair_with_sum(numbers: list, target_sum: int) -> bool` that takes a list of integers and a target sum as arguments, and returns `True` if there are any two distinct numbers in the list whose sum equals the target sum. Otherwise, it should return `False`. # Function Signature ```python def has_pair_with_sum(numbers: list, target_sum: int) -> bool: ``` # Input * A list `numbers` of integers. * An integer `target_sum` representing the target sum. # Output * A boolean value `True` or `False`. # Constraints * The elements of `numbers` are integers and can be positive or negative. * The length of the `numbers` list is between 0 and 10^6. * The function should have an average time complexity of O(n). # Example ```python numbers = [10, 15, 3, 7] target_sum = 17 assert has_pair_with_sum(numbers, target_sum) == True # Because 10 + 7 = 17 numbers = [1, 2, 3, 9] target_sum = 8 assert has_pair_with_sum(numbers, target_sum) == False # There are no two numbers that add up to 8 numbers = [] target_sum = 5 assert has_pair_with_sum(numbers, target_sum) == False # An empty list cannot have pairs numbers = [4] target_sum = 4 assert has_pair_with_sum(numbers, target_sum) == False # A single element list cannot have pairs numbers = [1, -2, 3, 8, -6, 4] target_sum = 2 assert has_pair_with_sum(numbers, target_sum) == True # Because -2 + 4 = 2 ``` # Explanation - Implement the `has_pair_with_sum` function aiming for an O(n) solution.","solution":"def has_pair_with_sum(numbers: list, target_sum: int) -> bool: Determine if there are two distinct numbers in the list that add up to the target_sum. :param numbers: List of integers :param target_sum: Integer representing the target sum :return: True if a pair is found, otherwise False seen = set() for num in numbers: if (target_sum - num) in seen: return True seen.add(num) return False"},{"question":"# Anagram Checker and Palindrome Constructor Context You are given two tasks involving string manipulation. The first task is to check if two strings are anagrams of each other. The second task is to construct the shortest possible palindrome by adding characters to the end of one of these strings. Task 1. Implement a function, `are_anagrams(str1: str, str2: str) -> bool` that checks if two input strings are anagrams of each other. 2. Implement a function, `shortest_palindrome(str1: str) -> str` that constructs the shortest possible palindrome by adding characters to the end of the input string. Specifications 1. You have two functions to implement: ```python def are_anagrams(str1: str, str2: str) -> bool: Determine if the two provided strings are anagrams of each other. Args: str1: A string str2: A string Returns: bool: True if the strings are anagrams, False otherwise def shortest_palindrome(str1: str) -> str: Construct the shortest possible palindrome by adding characters to the end of the input string. Args: str1: A string Returns: str: The shortest palindrome that can be constructed ``` Input and Output Formats * **Input**: * `str1` and `str2` for `are_anagrams` - two non-empty strings consisting of lowercase alphabetic characters. * `str1` for `shortest_palindrome` - a non-empty string consisting of lowercase alphabetic characters. * **Output**: * For `are_anagrams`: Return `True` if the strings are anagrams, otherwise `False`. * For `shortest_palindrome`: Return the shortest possible palindrome as a string. Constraints * The strings for both functions should contain only lowercase alphabetic characters and be non-empty. Examples ```python # Anagram examples assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"hello\\", \\"jello\\") == False # Palindrome examples assert shortest_palindrome(\\"race\\") == \\"racecar\\" assert shortest_palindrome(\\"abcd\\") == \\"abcdcba\\" ```","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determine if the two provided strings are anagrams of each other. Args: str1: A string str2: A string Returns: bool: True if the strings are anagrams, False otherwise # Check if sorted versions of the strings are identical return sorted(str1) == sorted(str2) def shortest_palindrome(str1: str) -> str: Construct the shortest possible palindrome by adding characters to the end of the input string. Args: str1: A string Returns: str: The shortest palindrome that can be constructed # Helper function to check if a string is a palindrome def is_palindrome(s): return s == s[::-1] # The original string is already a palindrome if is_palindrome(str1): return str1 # Create a palindrome by adding minimum characters from the beginning and checking for i in range(len(str1)): if is_palindrome(str1[i:]): return str1 + str1[:i][::-1] # Example usage print(are_anagrams(\\"listen\\", \\"silent\\")) # True print(are_anagrams(\\"hello\\", \\"jello\\")) # False print(shortest_palindrome(\\"race\\")) # racecar print(shortest_palindrome(\\"abcd\\")) # abcdcba"},{"question":"# Question: Implement a Custom Priority Queue Context A priority queue is an abstract data type similar to a regular queue but where each element is associated with a \\"priority.\\" Elements with higher priorities are dequeued before elements with lower priorities. Task You are tasked with implementing a custom priority queue using a heap-based data structure. Specifically, you need to create a min-heap where the element with the smallest priority is always at the front of the queue. You will also provide functions to insert elements with priorities and to extract the element with the highest priority (i.e., the smallest element). Implementation Requirements 1. **Class**: * Create a class `PriorityQueue` that will manage the priority queue. 2. **Methods**: * The class should have the following methods: * `insert(element, priority)` - Inserts an element with a given priority. * `extract_min()` - Removes and returns the element with the smallest priority. * `is_empty()` - Returns `True` if the queue is empty, `False` otherwise. 3. **Input**: * Operations to insert elements and to extract elements from the priority queue. 4. **Output**: * The method `extract_min()` should return the element with the smallest priority or `None` if the queue is empty. 5. **Constraints**: * The solution should handle a large number of operations efficiently. * Assume priorities can be any comparable data type (e.g., integers, floats). * Handle duplicate priorities gracefully during insertion. Write the class `PriorityQueue` with the specified methods. Example ```python class PriorityQueue: def __init__(self): # Your implementation here def insert(self, element, priority): # Your implementation here def extract_min(self): # Your implementation here def is_empty(self): # Your implementation here # Example usage: pq = PriorityQueue() pq.insert(\'task1\', 2) pq.insert(\'task2\', 1) pq.insert(\'task3\', 3) print(pq.extract_min()) # Expected output: \'task2\' print(pq.extract_min()) # Expected output: \'task1\' print(pq.is_empty()) # Expected output: False print(pq.extract_min()) # Expected output: \'task3\' print(pq.is_empty()) # Expected output: True ```","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, element, priority): heapq.heappush(self.heap, (priority, element)) def extract_min(self): if not self.is_empty(): return heapq.heappop(self.heap)[1] return None def is_empty(self): return len(self.heap) == 0"},{"question":"# Question: Implement a Merge Sort Function You are required to implement the merge sort algorithm due to its importance in reducing time complexity for sorting huge datasets. This algorithm uses the divide and conquer method to recursively sort and merge elements. Task Implement the function `merge_sort(arr: List[int]) -> List[int]` that sorts a given list of integers using the merge sort algorithm. Function Signature ```python from typing import List def merge_sort(arr: List[int]) -> List[int]: pass ``` Input * `arr`: a list of integers that need to be sorted. - Constraints: (1 leq len(arr) leq 10^6) - Values of the integers within the list are in the range (-10^9 leq arr[i] leq 10^9). Output * Returns a list of integers sorted in ascending order. Constraints 1. Implement the merge sort algorithm without using any built-in sorting functions. 2. Ensure your solution handles lists of varying lengths efficiently, including large datasets. Example ```python print(merge_sort([3, 7, 1, 5])) # Expected output: [1, 3, 5, 7] print(merge_sort([9, 8, 7, 6])) # Expected output: [6, 7, 8, 9] print(merge_sort([0, -10, 5, 5, 1000000])) # Expected output: [-10, 0, 5, 5, 1000000] print(merge_sort([1])) # Expected output: [1] ``` Additional Requirements 1. **Performance**: Ensure the function is efficiently implemented to handle up to (10^6) elements. 2. **Correctness**: Verify the function successfully sorts arrays with a wide range of values, including edge cases such as already sorted lists, reverse sorted lists, and lists with duplicate values.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers using merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i, j = 0, 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # If there are remaining elements in left or right, add them sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"# Question You are tasked with implementing a function `tree_diameter` that computes the diameter of a binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. The function signature should be: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def tree_diameter(root: TreeNode) -> int: pass ``` # Input - `root`: The root node of a binary tree. # Output - Returns an integer representing the diameter of the tree. # Constraints - The number of nodes in the tree is in the range `[1, 10^4]`. - The value of each node is an integer. # Requirements - The function should efficiently compute the diameter of the binary tree. - Consider using a depth-first search (DFS) strategy to explore the tree and calculate dimensions. # Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) diameter = tree_diameter(root) # diameter should return 3, as the longest path is [4, 2, 5] or [4, 2, 1, 3], both having length 3 ``` **Hint**: As you traverse the tree, keep track of the depth of each subtree and use this information to compute the maximum possible diameter at each node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def tree_diameter(root): Computes the diameter of a binary tree. The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. def height_and_diameter(node): nonlocal max_diameter if not node: return 0 left_height = height_and_diameter(node.left) right_height = height_and_diameter(node.right) # Update max_diameter with the longest path through current node max_diameter = max(max_diameter, left_height + right_height) return 1 + max(left_height, right_height) max_diameter = 0 height_and_diameter(root) return max_diameter"},{"question":"# Coding Assessment Question Scenario: You are building a feature for a mapping application that provides real-time route recommendations to users. To deliver accurate and efficient routes, you must implement a priority queue that can dynamically update the path priorities based on real-time traffic data. Task: Implement a priority queue using a binary heap to manage the routes. You need to support operations for inserting a new route, updating the priority of an existing route, and extracting the route with the highest priority based on the latest traffic data. Function: ```python class PriorityQueue: def __init__(self): Initialize an empty priority queue. pass def insert(self, route: str, priority: int): Insert a new route with a given priority into the priority queue. Args: route (str): The name of the route. priority (int): The priority of the route; lower values indicate higher priority. pass def update_priority(self, route: str, new_priority: int): Update the priority of an existing route. If the route does not exist, it should be added. Args: route (str): The name of the route. new_priority (int): The new priority of the route. pass def extract_min(self) -> str: Extract and return the route with the highest priority (lowest priority value). Returns: str: The name of the route with the highest priority. pass ``` Input Methods: * `insert(route: str, priority: int)`: Adds a new route with the specified priority to the priority queue. * `update_priority(route: str, new_priority: int)`: Updates the priority of the given route. If the route does not exist, it is added with the new priority. * `extract_min()`: Extracts and returns the name of the route with the highest priority. Output: * The extracted route name when `extract_min` is called. Constraints: * Route names are unique strings. * Priorities are non-negative integers. * The priority queue must support efficient operations (e.g., insert, update, extract) using a binary heap. Example: ```python # Create a priority queue pq = PriorityQueue() # Insert routes with their priorities pq.insert(\\"RouteA\\", 5) pq.insert(\\"RouteB\\", 3) pq.insert(\\"RouteC\\", 4) # Update the priority of an existing route pq.update_priority(\\"RouteA\\", 2) # Extract the route with the highest priority print(pq.extract_min()) # Output: \\"RouteA\\" # Extract the next route with the highest priority print(pq.extract_min()) # Output: \\"RouteB\\" ``` In this example, the priority queue first receives three routes with different priorities. After updating the priority of \\"RouteA\\" to 2, it becomes the highest priority route, and subsequent `extract_min` calls extract routes based on their updated priorities.","solution":"import heapq class PriorityQueue: def __init__(self): Initialize an empty priority queue. self.heap = [] self.route_map = {} def insert(self, route: str, priority: int): Insert a new route with a given priority into the priority queue. Args: route (str): The name of the route. priority (int): The priority of the route; lower values indicate higher priority. heapq.heappush(self.heap, (priority, route)) self.route_map[route] = priority def update_priority(self, route: str, new_priority: int): Update the priority of an existing route. If the route does not exist, it should be added. Args: route (str): The name of the route. new_priority (int): The new priority of the route. if route in self.route_map: self.route_map[route] = new_priority heapq.heappush(self.heap, (new_priority, route)) else: self.insert(route, new_priority) def extract_min(self) -> str: Extract and return the route with the highest priority (lowest priority value). Returns: str: The name of the route with the highest priority. while self.heap: priority, route = heapq.heappop(self.heap) if self.route_map.get(route) == priority: del self.route_map[route] return route return None # If the heap is empty"},{"question":"# Question You are given an implementation of a matrix multiplication function in the `multiply_matrices` function. Your task is to write a function `matrix_multiplication_selector` that chooses an optimized matrix multiplication method based on the size of the matrices. Specifically: - If the number of rows in the first matrix or the number of columns in the second matrix is less than or equal to a given threshold, use the standard matrix multiplication approach. - If both matrices are large (i.e., the number of rows in the first matrix and the number of columns in the second matrix are both greater than the threshold), use the Strassen\'s algorithm for matrix multiplication. # Function Signature ```python def matrix_multiplication_selector(A: list[list[int]], B: list[list[int]], threshold: int) -> list[list[int]]: pass ``` # Input - `A` (list[list[int]]): A 2D list representing the first matrix to be multiplied. - `B` (list[list[int]]): A 2D list representing the second matrix to be multiplied. - `threshold` (int): The threshold value for selecting between the standard and Strassen\'s algorithm. # Output - `list[list[int]]`: The resulting matrix after multiplying `A` and `B`. # Constraints - You must use the provided `standard_matrix_multiplication` and `strassens_matrix_multiplication` functions. - `A` and `B` will be valid matrices such that the number of columns in `A` equals the number of rows in `B`. - The threshold will be a non-negative integer. # Examples ```python >>> matrix_multiplication_selector([[1, 2], [3, 4]], [[5, 6], [7, 8]], 2) [[19, 22], [43, 50]] >>> matrix_multiplication_selector([[1, 2], [3, 4], [5, 6]], [[1, 2], [3, 4]], 2) [[7, 10], [15, 22], [23, 34]] >>> matrix_multiplication_selector([[1]], [[2]], 1) [[2]] >>> matrix_multiplication_selector([[2, 4], [1, 3]], [[3, 1], [2, 2]], 1) [[14, 10], [9, 7]] ``` # Requirements - Optimize for both performance and readability. - Handle edge cases effectively. # Testing Ensure your function passes the provided examples as well as edge cases like single element matrices and very large matrices. Validate the correctness of the multiplication results.","solution":"def standard_matrix_multiplication(A, B): Returns the product of matrices A and B using standard matrix multiplication. n, m, p = len(A), len(B), len(B[0]) C = [[0] * p for _ in range(n)] for i in range(n): for j in range(p): for k in range(m): C[i][j] += A[i][k] * B[k][j] return C def strassens_matrix_multiplication(A, B): A simplistic implementation of Strassen\'s algorithm for matrix multiplication. Note: This implementation works specifically for power of 2 sized matrices. n = len(A) # Base case for 1x1 matrix if n == 1: return [[A[0][0] * B[0][0]]] # Split matrices A and B mid = n // 2 A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) # Compute the products P1 = strassens_matrix_multiplication(add_matrices(A11, A22), add_matrices(B11, B22)) P2 = strassens_matrix_multiplication(add_matrices(A21, A22), B11) P3 = strassens_matrix_multiplication(A11, subtract_matrices(B12, B22)) P4 = strassens_matrix_multiplication(A22, subtract_matrices(B21, B11)) P5 = strassens_matrix_multiplication(add_matrices(A11, A12), B22) P6 = strassens_matrix_multiplication(subtract_matrices(A21, A11), add_matrices(B11, B12)) P7 = strassens_matrix_multiplication(subtract_matrices(A12, A22), add_matrices(B21, B22)) C11 = add_matrices(subtract_matrices(add_matrices(P1, P4), P5), P7) C12 = add_matrices(P3, P5) C21 = add_matrices(P2, P4) C22 = add_matrices(subtract_matrices(add_matrices(P1, P3), P2), P6) # Combine the 4 matrices into a single result matrix return combine_matrices(C11, C12, C21, C22) def split_matrix(A): Splits an nxn matrix into four (n/2)x(n/2) submatrices. mid = len(A) // 2 A11 = [row[:mid] for row in A[:mid]] A12 = [row[mid:] for row in A[:mid]] A21 = [row[:mid] for row in A[mid:]] A22 = [row[mid:] for row in A[mid:]] return A11, A12, A21, A22 def add_matrices(A, B): Adds two matrices A and B. return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))] def subtract_matrices(A, B): Subtracts matrix B from matrix A. return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))] def combine_matrices(A11, A12, A21, A22): Combines four submatrices into a single matrix. n = len(A11) * 2 A = [[0] * n for _ in range(n)] mid = n // 2 for i in range(mid): for j in range(mid): A[i][j] = A11[i][j] A[i][j+mid] = A12[i][j] A[i+mid][j] = A21[i][j] A[i+mid][j+mid] = A22[i][j] return A def matrix_multiplication_selector(A, B, threshold): num_rows_A = len(A) num_cols_B = len(B[0]) if num_rows_A <= threshold or num_cols_B <= threshold: return standard_matrix_multiplication(A, B) else: return strassens_matrix_multiplication(A, B)"},{"question":"**Context**: Sorting algorithms are fundamental in computer science, with numerous applications in data processing and optimization. One interesting variation on sorting is checking if a list can be made to become sorted with a limited number of adjacent swaps. Given a list of integers, determine the minimum number of adjacent swaps required to transform the list into a sorted order. **Problem Statement**: You are given a list `nums` of `n` integers. Your task is to implement the function `min_adjacent_swaps_to_sort(nums: List[int]) -> int` which returns the minimum number of adjacent swaps needed to sort the list in non-decreasing order. # Function Signature: ```python def min_adjacent_swaps_to_sort(nums: List[int]) -> int: pass ``` # Input: - a list of integers `nums` (0 ≤ len(nums) ≤ 1000, -10^6 ≤ nums[i] ≤ 10^6) # Output: - an integer representing the minimum number of adjacent swaps required to sort the list. # Constraints: - The input list can contain duplicate elements. - Optimize the function to handle the maximum list length efficiently within the given constraints. # Example: ```python assert min_adjacent_swaps_to_sort([3, 1, 2]) == 2 assert min_adjacent_swaps_to_sort([5, 3, 1, 4, 2]) == 7 assert min_adjacent_swaps_to_sort([1, 2, 3, 4, 5]) == 0 ``` # Note: - Use an efficient algorithm to determine the minimum number of adjacent swaps, such as converting the problem to counting the number of inversions in the list. - Edge cases may include an already sorted list or a list with multiple identical elements.","solution":"def min_adjacent_swaps_to_sort(nums): Returns the minimum number of adjacent swaps needed to sort the list in non-decreasing order. def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn\'t exceed mid and j doesn\'t exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count # Create a temporary array temp_arr = [0]*len(nums) return merge_sort_and_count(nums, temp_arr, 0, len(nums)-1)"},{"question":"# Problem Description You are given an unsorted list of `n` integers `arr`. Your task is to implement the Radix Sort algorithm to sort the list in ascending order. # Implementation Details 1. **Function Signature**: ```python def radix_sort(arr: List[int]) -> List[int]: ``` 2. **Input**: - `arr`: A list of integers with length `n` where `0 <= n <= 10^5` 3. **Output**: - Returns a list of integers sorted in ascending order. # Constraints - The function must run in O(d * (n + b)) time complexity where `d` is the number of digits in the largest number and `b` is the base (usually 10). # Example ```python assert radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert radix_sort([3, 10, 2, 8, 6, 7, 5]) == [2, 3, 5, 6, 7, 8, 10] assert radix_sort([5]) == [5] assert radix_sort([]) == [] assert radix_sort([11, 2, 20, 55]) == [2, 11, 20, 55] ``` # Additional Notes 1. Implement a helper function to perform counting sort on each digit place. 2. Handle edge cases such as empty arrays and arrays with one element. 3. The input list may contain positive and negative integers, ensure your algorithm accounts for this accordingly. Good luck and happy coding!","solution":"from typing import List def counting_sort(arr: List[int], exp: int) -> List[int]: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = abs(arr[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] for i in range(n-1, -1, -1): index = abs(arr[i]) // exp output[count[index % 10] - 1] = arr[i] count[index % 10] -= 1 return output def radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] max_num = max(arr, key=abs) exp = 1 while abs(max_num) // exp > 0: arr = counting_sort(arr, exp) exp *= 10 negatives = [num for num in arr if num < 0] positives = [num for num in arr if num >= 0] return negatives[::-1] + positives"},{"question":"# Question: Implement a Simple HTTP Server Background HTTP servers are the backbone of the web, handling requests and serving content to users. Understanding how to build a simple HTTP server can be a valuable skill for understanding web technologies and handling server-side operations. Task Your task is to implement a basic but functional HTTP server in Python using the `http.server` module. This server should: 1. Serve static HTML files from a specified directory. 2. Log incoming requests to the console. # Function Specifications `run_server(directory: str, port: int)` - **Input**: `directory` (str) - The directory from which to serve static files, `port` (int) - The port number to listen to for incoming requests. - **Output**: Starts the HTTP server and logs incoming requests. - **Constraints**: - `port` should be a valid port number (1-65535). - `directory` must be a valid path to a directory containing static files (HTML, CSS, JS, etc.). # Example Usage ```python run_server(\'./static\', 8080) ``` When this function is called: 1. The server should start listening on the specified port. 2. Requests for files should be served from the specified directory. 3. Each incoming request should be logged to the console in the format: `\\"{method} {path} {protocol}\\"`. # Notes 1. Handle common error scenarios such as invalid port numbers and non-existent directories by raising appropriate exceptions. 2. Ensure the server runs until manually stopped (e.g., via a keyboard interrupt). # Example Implementation Below is a sample implementation outline to get you started: ```python from http.server import SimpleHTTPRequestHandler, HTTPServer import os class CustomHandler(SimpleHTTPRequestHandler): def log_message(self, format, *args): print(\\"%s - - [%s] %sn\\" % (self.address_string(), self.log_date_time_string(), format % args)) def run_server(directory, port): os.chdir(directory) handler = CustomHandler httpd = HTTPServer((\\"\\", port), handler) print(f\\"Serving HTTP on port {port} from {directory}...\\") httpd.serve_forever() ``` # Example Usage in the Console ```bash # Assuming the command is executed from the directory containing the script python script_name.py Serving HTTP on port 8080 from ./static... ``` # Additional Requirements 1. Validate that `directory` exists and contains valid static files. 2. Ensure valid port numbers and proper error handling for invalid inputs.","solution":"import http.server import os import socketserver from http.server import SimpleHTTPRequestHandler def run_server(directory, port): Runs a simple HTTP server that serves files from the specified directory. Args: - directory (str): The directory to serve the static files from. - port (int): The port number on which the server will listen for incoming requests. if not isinstance(port, int) or port < 1 or port > 65535: raise ValueError(\\"Port number must be an integer between 1 and 65535.\\") if not os.path.isdir(directory): raise FileNotFoundError(f\\"The directory \'{directory}\' does not exist or is not a directory.\\") os.chdir(directory) handler = SimpleHTTPRequestHandler with socketserver.TCPServer((\\"\\", port), handler) as httpd: print(f\\"Serving HTTP on port {port} from {directory}...\\") httpd.serve_forever()"},{"question":"**Problem Statement:** As a software engineer, you are tasked with optimizing a given neural network\'s performance by enhancing its weight initialization process. The goal is to implement the Xavier Glorot initialization method, which is particularly useful for neural networks with sigmoid or hyperbolic tangent activation functions. Your task is to create a function that initializes the weights of a given layer in a neural network using this method. **Function Signature:** ```python def xavier_initialization(input_dim: int, output_dim: int) -> list[list[float]]: ``` **Input:** - `input_dim` (int): The number of input neurons in the layer. - `output_dim` (int): The number of output neurons in the layer. **Output:** - A 2D list of floats where each sub-list represents the initialized weights for the connections from each input neuron to all output neurons. **Constraints:** - `input_dim` and `output_dim` will be positive integers greater than 0. - The weight values should be initialized using the Xavier Glorot method: `W_i,j = random.normal(0, sqrt(2 / (input_dim + output_dim)))`. **Performance Requirement:** - Ensure efficient initialization with a time complexity of O(input_dim * output_dim) and space complexity of O(input_dim * output_dim). **Additional Information:** - Use the `random.gauss` function from the `random` module to generate normally distributed values. - The function should handle both small and large values of `input_dim` and `output_dim` gracefully. **Example:** ```python weights = xavier_initialization(3, 2) print(weights) # Output: [[w11, w12], [w21, w22], [w31, w32]] ``` **Explanation:** The function initializes the weights for a neural network layer using the Xavier Glorot method, generating weights that follow a normal distribution with mean 0 and standard deviation `sqrt(2 / (input_dim + output_dim))`. **Note:** You are not allowed to use any external libraries beyond Python\'s standard library.","solution":"import random import math def xavier_initialization(input_dim: int, output_dim: int) -> list[list[float]]: Initializes the weights of a given layer in a neural network using the Xavier Glorot method. Args: input_dim (int): The number of input neurons in the layer. output_dim (int): The number of output neurons in the layer. Returns: list[list[float]]: A 2D list of floats where each sub-list represents the initialized weights for the connections from each input neuron to all output neurons. stddev = math.sqrt(2 / (input_dim + output_dim)) weights = [[random.gauss(0, stddev) for _ in range(output_dim)] for _ in range(input_dim)] return weights"},{"question":"# Problem Statement Given an array of integers representing the even distribution of cargo weights on a ship\'s containers, implement a function to modify the array so that it represents a state where the ship is balanced. Balance is achieved when the absolute difference between the sum of the weights of containers on the left half and the right half is minimal. If there are an odd number of containers, consider the middle container part of the left half. Specifically, you will need to implement the following function: 1. `balance_ship_containers(containers)` The function should rearrange the input array `containers` to achieve the balance, and return the minimum possible absolute difference. # Input - The function takes a single argument: * `containers`: A list of integers where each integer represents the weight of a container # Output - The function should return a single integer: * The minimum possible absolute difference between the sums of the weights of the left half and the right half of the balanced array. # Constraints - The number of containers is in the range [1, 1000]. - Container weights are in the range [1, 10000]. # Examples ```python # Example 1 containers = [10, 20, 30, 40, 50] assert balance_ship_containers(containers) == 10 # Possible balanced configuration: [10, 20, 50, 40, 30] # Left half: [10, 20, 50] -> sum = 80 # Right half: [40, 30] -> sum = 70 # Example 2 containers = [15, 25, 35, 45] assert balance_ship_containers(containers) == 0 # Possible balanced configuration: [25, 15, 35, 45] # Left half: [25, 15] -> sum = 40 # Right half: [35, 45] -> sum = 80 # Possible balanced configuration: [25, 35, 15, 45] # Left half: [25, 35] -> sum = 60 # Right half: [15, 45] -> sum = 60 # Minimum difference is 0 # Example 3 containers = [5, 5, 5, 5, 5, 5] assert balance_ship_containers(containers) == 0 # Array is already balanced, so the minimum difference is 0 ``` # Detailed Requirements 1. **Container arrangement**: Implement `balance_ship_containers(containers)` to modify the array `containers` such that the absolute difference between the left and right half is minimized. * Hint: Consider using a sorting approach or dynamic programming to find the optimal transfer of containers between halves. 2. **Edge Cases**: Ensure to handle all edge cases, such as a single container, which should result in returning the weight of that container considering it as the left half. # Note: - Pay attention to edge cases including very small arrays or arrays with all containers of the same weight. - Strive to achieve a time-efficient solution for larger arrays within the given constraints.","solution":"def balance_ship_containers(containers): Rearrange the containers to minimize the absolute difference between the sum of the weights of the left half and right half of the balanced array. Args: containers: List[int] - List of integers where each integer represents the weight of a container. Returns: int - The minimum possible absolute difference between the sums of the weights of the left half and right half. # Calculate the total sum of weights total_sum = sum(containers) # Length of the array n = len(containers) # To find the partition there is no need to consider a weight more than half the total sum half_sum = total_sum // 2 # Create a dynamic programming table, dp[i] represents whether a sum of \'i\' is achievable dp = [0] * (half_sum + 1) dp[0] = 1 # A sum of 0 is always achievable with an empty set # Populate the dp table for weight in containers: for j in range(half_sum, weight - 1, -1): if dp[j - weight]: dp[j] = 1 # Find the largest sum which is achievable and is <= half_sum for i in range(half_sum, -1, -1): if dp[i]: return total_sum - 2 * i return total_sum"},{"question":"# Maximum Subarray Sum Finder Context: You are working on an algorithm related to financial data analysis, specifically to determine the best period to invest for maximum returns. This involves finding a subarray within an array of daily returns that has the greatest sum. This problem is commonly known as the \\"Maximum Subarray Problem\\" and is key in fields like quantitative finance and algorithm design. Problem Statement: Write a function `max_subarray_sum(arr: List[int]) -> int` that returns the sum of the subarray with the maximum sum within the given list of integers `arr`. Input: - A list `arr` consisting of integers which can be both positive and negative, as well as zero. Output: - An integer representing the sum of the subarray with the maximum sum. Constraints: - The function should execute in O(n) time complexity and use O(1) additional space. Examples: ``` >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5, -4, -2, 6, -1]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([0, 0, -1, 0, -2, 0]) 0 ``` Performance Requirements: - Make sure your solution is efficient in terms of both time and space complexity. Implementation Challenge: Implement the `max_subarray_sum` function using the Kadane’s Algorithm, which is known for its efficiency in solving the Maximum Subarray Problem within linear time complexity. Be sure to handle edge cases such as all negative numbers or a single element array.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray within a given array of integers. Implements Kadane\'s Algorithm to achieve this. if not arr: return 0 max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Question: Find Intersection of Two Arrays Context: You are given two integer arrays. Your task is to find the intersection of these two arrays, which means finding all elements that are present in both arrays. The result array should contain unique elements only and should be sorted in ascending order. Function Description: Implement the function `find_intersection` which takes two integer arrays as input and returns a sorted array containing the intersection of the two input arrays. Input: - `arr1` (List[int]): The first integer array. - `arr2` (List[int]): The second integer array. Output: - List[int]: A sorted list containing the intersection of `arr1` and `arr2`. Constraints: - The elements in each input array are integers. - The elements of the result list should be unique and sorted in ascending order. - The input arrays can be of different lengths and may contain duplicates. Example: ```python from typing import List def find_intersection(arr1: List[int], arr2: List[int]) -> List[int]: # Your code goes here # Test case example arr1 = [1, 2, 2, 3, 4] arr2 = [2, 2, 4, 4, 6] print(find_intersection(arr1, arr2)) # Output: [2, 4] ``` # Requirements: * The function should efficiently determine the intersection of the two arrays. * The output list must be sorted in ascending order. * Handle edge cases such as empty input arrays appropriately. * Avoid using built-in functions that directly solve the problem, such as set operations, to mimic typical coding assessment limitations.","solution":"from typing import List def find_intersection(arr1: List[int], arr2: List[int]) -> List[int]: Finds the intersection of two integer arrays, returning a sorted list containing unique elements. # Convert arrays to sets to remove duplicates and then find the intersection set1 = set(arr1) set2 = set(arr2) # Find the intersection of both sets intersection = set1.intersection(set2) # Convert the set back to a list and sort it result = list(intersection) result.sort() return result"},{"question":"# Binary Search Tree (BST) Insertion and Traversal **Scenario**: You are an intern at a tech company, and your team is working on a project that involves managing a large set of ordered data. To efficiently manage and retrieve this data, your team has decided to use a Binary Search Tree (BST) data structure. # Problem Statement 1. Write a class `BSTNode` that represents a node in a BST. 2. Write a class `BinarySearchTree` that: - Can insert values following the BST properties. - Can traverse the tree using in-order, pre-order, and post-order traversal methods. 3. Additionally, provide a method to check if the BST is balanced. **Class Signatures** ```python class BSTNode: def __init__(self, value: int): pass class BinarySearchTree: def __init__(self): pass def insert(self, value: int): pass def in_order_traversal(self) -> list[int]: pass def pre_order_traversal(self) -> list[int]: pass def post_order_traversal(self) -> list[int]: pass def is_balanced(self) -> bool: pass ``` **Input/Output Format** * **Input**: - For the insertion method, an integer `value` to be inserted into the BST. - For the traversal methods, no input is required. - For the `is_balanced` method, no input is required. * **Output**: - For the insertion method, no output is required. - For the traversal methods, a list of integers representing the traversal order. - For the `is_balanced` method, a boolean indicating if the tree is balanced. **Constraints** * The values inserted into the BST will be unique integers. * Each integer will be between -10^6 and 10^6. # Constraints/Edge Cases to Consider 1. Inserting into an empty tree. 2. Traversing an empty tree. 3. Checking if a single-node tree is balanced. 4. Handling large tree structures to ensure the `is_balanced` method efficiently checks the balance condition. # Requirements Explain how the `is_balanced` method works and discuss its time complexity. Provide examples where the tree is balanced and where it is not. Discuss the traversal orders and their respective uses in different scenarios.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = BSTNode(value) else: self._insert_recursive(node.right, value) def in_order_traversal(self) -> list[int]: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node, result): if node is not None: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result) def pre_order_traversal(self) -> list[int]: result = [] self._pre_order_recursive(self.root, result) return result def _pre_order_recursive(self, node, result): if node is not None: result.append(node.value) self._pre_order_recursive(node.left, result) self._pre_order_recursive(node.right, result) def post_order_traversal(self) -> list[int]: result = [] self._post_order_recursive(self.root, result) return result def _post_order_recursive(self, node, result): if node is not None: self._post_order_recursive(node.left, result) self._post_order_recursive(node.right, result) result.append(node.value) def is_balanced(self) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return max(left_height, right_height) + 1, balanced _, balanced = check_balance(self.root) return balanced"},{"question":"# Problem Statement You are given a grid of characters and a target word. Your task is to find all starting positions (row and column indices) in the grid where the target word appears horizontally (from left to right). Write a function `find_horizontal_word_positions()` that efficiently finds these starting positions and returns them as a list of tuples. Each tuple should be of the form (row_index, column_index). # Function Specification **Function Name**: `find_horizontal_word_positions` **Input**: * `grid` (List[List[str]]): A 2D list of characters representing the grid. * `word` (str): The target word to search for in the grid. **Output**: * Returns a list of tuples. Each tuple contains the row and column index of the start position where the word is found horizontally. # Example ```python def find_horizontal_word_positions(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: # Implementation goes here # Example usage: grid = [ [\'h\', \'e\', \'l\', \'l\', \'o\'], [\'w\', \'o\', \'r\', \'l\', \'d\'], [\'h\', \'e\', \'l\', \'l\', \'o\'], [\'r\', \'o\', \'w\', \'i\', \'n\'] ] word = \\"hello\\" print(find_horizontal_word_positions(grid, word)) # Output: [(0, 0), (2, 0)] grid = [ [\'c\', \'o\', \'d\', \'e\'], [\'j\', \'a\', \'v\', \'a\'], [\'p\', \'y\', \'t\', \'h\', \'o\', \'n\'] ] word = \\"code\\" print(find_horizontal_word_positions(grid, word)) # Output: [(0, 0)] ``` # Constraints 1. The grid will have at least 1 row and 1 column. 2. The length of each row in the grid will be between 1 and 10^3. 3. The total number of characters in the grid will not exceed 10^6. 4. The target word will only contain alphabetical characters (a-z, A-Z). 5. The target word can have a length between 1 and the length of the longest row in the grid. # Requirements * The solution must efficiently handle searching for the word within the grid. # Performance Your solution should aim for optimal time complexity considering the constraints.","solution":"from typing import List, Tuple def find_horizontal_word_positions(grid: List[List[str]], word: str) -> List[Tuple[int, int]]: positions = [] word_length = len(word) for row_index, row in enumerate(grid): row_str = \'\'.join(row) start = 0 while True: start = row_str.find(word, start) if start == -1: break positions.append((row_index, start)) start += 1 # Move start index one character to the right to find subsequent matches return positions"},{"question":"# Circular Dependency Detection in Directed Graph Given a directed graph, your task is to detect if there is a circular dependency (cycle) present in the graph. You are required to implement the detection algorithm using Depth-First Search (DFS). **Task**: 1. Implement a class to represent the directed graph. 2. Implement a method to add edges to the graph. 3. Implement a method to detect if the graph contains any cycles using DFS. **Function Signatures**: 1. `class DirectedGraph:` 2. `def __init__(self): -> None` 3. `def add_edge(self, from_vertex: int, to_vertex: int): -> None` 4. `def has_cycle(self): -> bool` **Input Format**: - The graph is initialized without any edges. - `add_edge(from_vertex, to_vertex)` is called to create the directed graph. - `has_cycle()` checks the graph for a cycle and returns True if a cycle is found, else returns False. **Output Format**: - A boolean value indicating whether there is a cycle in the graph or not. **Constraints**: - The number of vertices `V` and edges `E` where `1 <= V, E <= 1000`. - Vertices are represented as integers starting from 0. **Performance Requirement**: - The algorithm should efficiently handle the graph within the constrained limits. **Example**: ```python # Initialize Graph graph = DirectedGraph() # Add Edges graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 0) # Check for Cycle result = graph.has_cycle() # Output: True # Initialize Another Graph graph2 = DirectedGraph() graph2.add_edge(0, 1) graph2.add_edge(1, 2) graph2.add_edge(2, 3) # Check for Cycle result2 = graph2.has_cycle() # Output: False ``` **Explanation**: In the first example, there is a cycle (0 -> 1 -> 2 -> 0), so `has_cycle()` returns True. In the second example, there are no cycles in the graph, so `has_cycle()` returns False. This problem tests the ability to implement and apply graph traversal techniques and cycle detection algorithms effectively.","solution":"class DirectedGraph: def __init__(self): self.graph = {} def add_edge(self, from_vertex, to_vertex): if from_vertex not in self.graph: self.graph[from_vertex] = [] self.graph[from_vertex].append(to_vertex) def has_cycle(self): visited = set() rec_stack = set() def dfs(v): if v not in visited: visited.add(v) rec_stack.add(v) if v in self.graph: for neighbour in self.graph[v]: if neighbour not in visited and dfs(neighbour): return True elif neighbour in rec_stack: return True rec_stack.remove(v) return False for vertex in self.graph: if dfs(vertex): return True return False"},{"question":"Problem Statement You have been given a string `s` containing only digits (\'0\'-\'9\'). Your task is to find the length of the longest substring of `s` such that the digits in the substring are in non-decreasing order. A non-decreasing order means that every digit is less than or equal to the digit following it. Write a function `longest_non_decreasing_substring(s: str) -> int` that takes a single parameter: - `s` (a string): The input string containing the digits. The function should return an integer representing the length of the longest substring with digits in non-decreasing order. # Constraints 1. The input string will have at most length `10^4`. 2. The input string will only contain the characters \'0\'-\'9\'. # Example ```python def longest_non_decreasing_substring(s: str) -> int: # TODO: Write your implementation here ``` Input: ```python longest_non_decreasing_substring(\\"123451234\\") ``` Output: ```python 5 ``` Input: ```python longest_non_decreasing_substring(\\"54321\\") ``` Output: ```python 1 ``` Input: ```python longest_non_decreasing_substring(\\"111222333\\") ``` Output: ```python 9 ``` # Notes - Ensure your solution is efficient with a time complexity of O(n) where n is the length of the input string. - Pay careful attention to edge cases, such as strings with only one character, or strings that are in strictly increasing or decreasing order.","solution":"def longest_non_decreasing_substring(s: str) -> int: if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Question: Analyzing a Special Drop Number Sequence Introduction In mathematics, a special drop number sequence is defined such that each number in the sequence follows specific rules based on simple operations using its digits. For the purpose of this problem, a number `N` in the special drop number sequence is generated as follows: - If the number is even, the next number is obtained by dividing the number by 2. - If the number is odd, the next number is obtained by multiplying the number by 3 and then adding 1. The sequence always ends when the number reaches 1. For example, starting with the number 6, the sequence would be: 6 → 3 → 10 → 5 → 16 → 8 → 4 → 2 → 1. Task Write a function `drop_number_sequence_length` that computes the length of the special drop number sequence starting from a given number `m`. Function Signature ```python def drop_number_sequence_length(m: int) -> int: Computes the length of the special drop number sequence starting from m. Parameters: m (int): The starting number of the sequence. Returns: int: The length of the sequence from m to 1. ``` Input Format * A single integer `m (1 <= m <= 10^5)` specifying the starting number of the sequence. Output Format * Return a single integer, representing the number of steps in the sequence from `m` until it reaches 1. Example ```python print(drop_number_sequence_length(6)) # Output: 9 ``` # Constraints * The function should efficiently handle the sequence computation to avoid excessive computational time for large values of `m`. # Performance Requirements Solution must calculate the sequence steps efficiently without unnecessary computational redundancy, ensuring that it works in a practical time frame for `m` up to 100000.","solution":"def drop_number_sequence_length(m: int) -> int: Computes the length of the special drop number sequence starting from m. Parameters: m (int): The starting number of the sequence. Returns: int: The length of the sequence from m to 1. length = 1 # Start counting with the initial number m while m != 1: if m % 2 == 0: m = m // 2 else: m = 3 * m + 1 length += 1 return length"},{"question":"# Binary Tree Operations A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. Your task is to implement several functions that provide fundamental operations on a binary tree. Objective: Write a class `BinaryTree` with the following functionalities: 1. **Insert a value into the Binary Tree.** 2. **Search for a value in the Binary Tree.** 3. **Delete a value from the Binary Tree.** 4. **Perform an in-order traversal of the Binary Tree.** Class Definition: ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): Initialize the Binary Tree with a root node set to None. self.root = None def insert(self, value: int) -> None: Inserts a value into the Binary Tree. :param value: The value to be inserted. pass def search(self, value: int) -> bool: Searches for a value in the Binary Tree. :param value: The value to search for. :return: True if the value exists in the Binary Tree, False otherwise. pass def delete(self, value: int) -> None: Deletes a value from the Binary Tree. :param value: The value to delete. pass def in_order_traversal(self) -> list: Performs an in-order traversal of the Binary Tree. :return: A list of values representing the in-order traversal. pass ``` Input: - Each function takes in a value (`int`). Output: - `insert`: None - `search`: `True` if the value exists, `False` otherwise. - `delete`: None - `in_order_traversal`: List of values (`list[int]`) in in-order traversal order. Constraints: - The values inserted into the binary tree are unique integers. - The operations on the binary tree (insert, search, delete) will be called at most 10^4 times in combination. Example: ```python # Example sequence of operations: binary_tree = BinaryTree() binary_tree.insert(5) binary_tree.insert(3) binary_tree.insert(7) assert binary_tree.search(5) == True assert binary_tree.search(4) == False binary_tree.insert(4) assert binary_tree.search(4) == True binary_tree.delete(3) assert binary_tree.search(3) == False assert binary_tree.in_order_traversal() == [4, 5, 7] ```","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = TreeNode(value) def search(self, value: int) -> bool: return self._search_recursive(self.root, value) def _search_recursive(self, node: TreeNode, value: int) -> bool: if not node: return False if node.value == value: return True elif value < node.value: return self._search_recursive(node.left, value) else: return self._search_recursive(node.right, value) def delete(self, value: int) -> None: self.root = self._delete_recursive(self.root, value) def _delete_recursive(self, node: TreeNode, value: int) -> TreeNode: if not node: return node if value < node.value: node.left = self._delete_recursive(node.left, value) elif value > node.value: node.right = self._delete_recursive(node.right, value) else: if not node.left: return node.right elif not node.right: return node.left min_larger_node = self._get_min_node(node.right) node.value = min_larger_node.value node.right = self._delete_recursive(node.right, min_larger_node.value) return node def _get_min_node(self, node: TreeNode) -> TreeNode: current = node while current.left: current = current.left return current def in_order_traversal(self) -> list: result = [] self._in_order_recursive(self.root, result) return result def _in_order_recursive(self, node: TreeNode, result: list) -> None: if node: self._in_order_recursive(node.left, result) result.append(node.value) self._in_order_recursive(node.right, result)"},{"question":"# Problem: K-Subarray Maximum Sum You are given an array of integers and a positive integer `K`. Your task is to find the maximum possible sum of any contiguous subarray of length `K`. # Function Signature ```python def max_subarray_sum(nums: List[int], K: int) -> int: # Your code here ``` # Input * `nums`: a list of integers (`1 <= len(nums) <= 10^5` and `-10^4 <= nums[i] <= 10^4`). * `K`: a positive integer (`1 <= K <= len(nums)`). # Output * An integer representing the maximum sum of any contiguous subarray of length `K`. # Constraints * The input array can contain both negative and positive integers. * The length of the subarray `K` will be at least 1 and at most the length of the given array. # Example Example 1 ```python nums = [2, 1, 5, 1, 3, 2] K = 3 assert max_subarray_sum(nums, K) == 9 # Explanation: The subarray [5, 1, 3] has the maximum sum of 9. ``` Example 2 ```python nums = [1, -1, 5, 1, -3, 2, 3] K = 4 assert max_subarray_sum(nums, K) == 6 # Explanation: The subarray [1, -1, 5, 1] has the maximum sum of 6. ``` # Notes * The solution should aim to be efficient to handle large inputs up to the upper constraint. * Ensure that your implementation handles edge cases, such as when the array contains all negative numbers.","solution":"from typing import List def max_subarray_sum(nums: List[int], K: int) -> int: # Initialize the maximum sum and the current window sum max_sum = float(\'-inf\') current_sum = 0 # Loop through the array for i in range(len(nums)): current_sum += nums[i] # When the window hits size K if i >= K - 1: # Update the maximum sum if necessary max_sum = max(max_sum, current_sum) # Remove the element going out of the window current_sum -= nums[i - (K - 1)] return max_sum"},{"question":"# Word Frequency Counter In this question, you are tasked with writing a Python program that analyzes the frequency of each word in a given text. Your program should be capable of identifying and counting the occurrences of each unique word, and then outputting the word frequencies in descending order. Input - A single string `text` representing a block of text, where words are separated by spaces. Punctuation marks, such as periods, commas, etc., should be removed from the analysis. - The string may include upper- and lower-case letters, punctuation, and numerals. Output - The program should output a list of tuples, each tuple containing a word and its frequency. The list should be sorted in descending order based on the frequency of the words. If two words have the same frequency, they should be sorted in ascending alphabetical order. Constraints - The input text will contain at most 10,000 characters. - Words are case-insensitive, i.e., \\"Hello\\" and \\"hello\\" should be considered the same word. - Consider only alphabetical characters and numerals as part of words; punctuation and special characters should be ignored. Example ```python def word_frequency(text: str) -> list: # Your code goes here # Sample input text = \\"Hello world! This is a test. Hello again. Testing, one, two, three.\\" # Sample output print(word_frequency(text)) # Output: [(\'hello\', 2), (\'again\', 1), (\'is\', 1), (\'one\', 1), (\'test\', 1), (\'testing\', 1), (\'this\', 1), (\'three\', 1), (\'two\', 1), (\'world\', 1)] ``` Implement the function `word_frequency` to correctly analyze and output the word frequencies as specified.","solution":"import re from collections import Counter def word_frequency(text: str) -> list: Analyzes the frequency of each word in a given text and outputs the word frequencies in descending order. - Words are case-insensitive - Punctuation marks are removed # Convert to lowercase to ensure case insensitivity text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Split text into words words = text.split() # Count the frequency of each word word_count = Counter(words) # Sort by frequency in descending order, then by word in ascending order sorted_word_count = sorted(word_count.items(), key=lambda item: (-item[1], item[0])) return sorted_word_count"},{"question":"# Depth-First Search (DFS) for Cycle Detection Objective Implement the following function to detect if a given undirected graph contains a cycle using Depth-First Search (DFS): ```python from typing import List def has_cycle(graph: List[List[int]]) -> bool: Determines if an undirected graph contains a cycle using DFS. Parameters: graph (List[List[int]]): An adjacency list representing the graph. Returns: bool: True if there is a cycle in the graph, otherwise False. pass ``` Input Format * A list of lists where each sublist represents the adjacency list of a vertex in the graph. Output Format * A boolean value `True` if the graph has a cycle, and `False` otherwise. Constraints * The input graph is a valid adjacency list. * Each node may have zero or more edges, and the graph may be disconnected. * There are no self-loops in the graph. Example ```python graph = [ [1, 2], [0, 2], [0, 1, 3], [2] ] print(has_cycle(graph)) # Expected output: True graph = [ [1], [0, 2], [1, 3], [2] ] print(has_cycle(graph)) # Expected output: False ``` Notes * Consider both connected and disconnected graphs. * Ensure your implementation is efficient and handles edge cases, like empty graphs or single-node graphs, correctly. * You may use helper functions to manage the DFS traversal and visitation status of nodes.","solution":"from typing import List def has_cycle(graph: List[List[int]]) -> bool: Determines if an undirected graph contains a cycle using DFS. Parameters: graph (List[List[int]]): An adjacency list representing the graph. Returns: bool: True if there is a cycle in the graph, otherwise False. def dfs(v, parent, visited): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v, visited): return True elif neighbor != parent: return True return False visited = [False] * len(graph) for i in range(len(graph)): if not visited[i]: if dfs(i, -1, visited): return True return False"},{"question":"# Problem Statement Design a function that calculates the nth Fibonacci number using a bottom-up dynamic programming approach. The Fibonacci sequence is defined as: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) for n >= 2 Your task is to compute and return the nth Fibonacci number, where the input `n` is a non-negative integer. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Input * `n (int)`: The position in the Fibonacci sequence to compute (0 <= n <= 50) # Output * Returns the nth Fibonacci number. # Constraints * Use a bottom-up dynamic programming approach to compute the result. * Consider space optimization techniques to reduce the extra space used during computation. # Example ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(25) == 75025 assert fibonacci(50) == 12586269025 ``` # Explanation Write a function `fibonacci` that takes an integer `n` and returns the nth Fibonacci number using a bottom-up dynamic programming approach. Ensure to optimize for space to handle large inputs efficiently.","solution":"def fibonacci(n: int) -> int: Returns the nth Fibonacci number using a bottom-up dynamic programming approach. if n == 0: return 0 elif n == 1: return 1 # Initialize the first two Fibonacci numbers a, b = 0, 1 # Use a loop to calculate the nth Fibonacci number for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Flood Fill Algorithm **Context:** You are given a 2D image represented by an `m x n` grid of integers where each integer represents the color of a pixel. You are also provided with a starting pixel `(sr, sc)` and a new color. Your task is to perform a \\"flood fill\\" on the image starting from the given pixel. **Function Signature:** ```python def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: ``` **Input:** * `image`: A list of lists of integers representing the 2D image (1 <= m, n <= 100). * `sr`: An integer representing the starting row index. * `sc`: An integer representing the starting column index. * `new_color`: An integer representing the new color. **Output:** * A list of lists of integers representing the modified image after performing the flood fill. **Constraints:** * 0 <= image[i][j], new_color < 10^5 * The starting pixel’s color and new color are not equal. **Performance Requirements:** * The solution should efficiently handle the maximum constraints with optimal use of time and space. **Example:** ```python # Example 1 image = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] sr = 1 sc = 1 new_color = 2 flood_fill(image, sr, sc, new_color) # Output: [ # [2, 2, 2], # [2, 2, 0], # [2, 0, 1] # ] # Example 2 image = [ [0, 0, 0], [0, 1, 1] ] sr = 1 sc = 1 new_color = 1 flood_fill(image, sr, sc, new_color) # Output: [ # [0, 0, 0], # [0, 1, 1] # ] ``` **Assignment:** Implement the `flood_fill` function to simulate the flood fill algorithm starting from the specified pixel and updating the image accordingly. **Evaluation Criteria:** * Correctness of the solution. * Efficiency in terms of time and space complexity. * Clear and concise implementation.","solution":"from typing import List def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: original_color = image[sr][sc] if original_color == new_color: return image def dfs(x, y): if x < 0 or x >= len(image) or y < 0 or y >= len(image[0]): return if image[x][y] != original_color: return image[x][y] = new_color # recursive calls for 4 adjacent pixels dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) dfs(sr, sc) return image"},{"question":"# Question: Duplicate Subtree Finder You are given the root of a binary tree. Write a function to find all duplicate subtrees in the binary tree. Two subtrees are considered duplicates if they have the same structure and node values. Function Signature ```python def find_duplicate_subtrees(root: Optional[Node]) -> List[Optional[Node]]: ... ``` Input - `root` (Optional[Node]): The root node of the binary tree. Output - `List[Optional[Node]]`: A list of root nodes of the duplicate subtrees. Constraints - The number of nodes in the tree is in the range [0, 500]. - -200 <= Node.data <= 200 Example ```python # Example tree: # 1 # / # 2 3 # / / # 4 2 4 # / # 4 # # The tree has two duplicate subtrees: # Subtree rooted at Node with value 4: # 4 # # Subtree rooted at Node with value 2: # 2 # / # 4 root = Node(1) root.left = Node(2, left=Node(4)) root.right = Node(3, left=Node(2, left=Node(4)), right=Node(4)) duplicates = find_duplicate_subtrees(root) assert len(duplicates) == 2 assert duplicates[0].data == 4 assert duplicates[1].data == 2 ``` Explanation The function `find_duplicate_subtrees` should identify all subtrees that appear more than once in the given binary tree. Note that each subtree must be structurally identical and have the same node values to be considered a duplicate. You may assume the provided `Node` class definition as follows: ```python from typing import Optional, List class Node: def __init__(self, data: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.data = data self.left = left self.right = right ``` Make sure to handle cases with no duplicate subtrees or cases where the tree is empty (returns an empty list). Carefully consider time and space complexities while designing your function.","solution":"from typing import Optional, List, Tuple from collections import defaultdict class Node: def __init__(self, data: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.data = data self.left = left self.right = right def find_duplicate_subtrees(root: Optional[Node]) -> List[Optional[Node]]: def traverse(node: Optional[Node]): if not node: return \\"#\\" left_serial = traverse(node.left) right_serial = traverse(node.right) serial = f\\"{node.data},{left_serial},{right_serial}\\" trees[serial].append(node) return serial trees = defaultdict(list) traverse(root) return [nodes[0] for nodes in trees.values() if len(nodes) > 1]"},{"question":"# Coding Assessment Question Problem Statement: You are given a list of integers representing the lengths of different ropes. Your task is to combine the ropes into one single rope with minimal cost. The cost to combine two ropes is equal to the sum of their lengths. You need to minimize this total cost. Write a function `minimize_cost_to_combine_ropes(ropes)` that returns the minimum cost to combine all the given ropes into a single rope. Function Signature: ```python def minimize_cost_to_combine_ropes(ropes: [int]) -> int: ``` Parameters: - `ropes` (list of int): A list of integers representing the lengths of the ropes. Returns: - `int`: The minimum cost to combine all the given ropes into one rope. Example: ```python assert minimize_cost_to_combine_ropes([4, 3, 2, 6]) == 29 ``` Constraints: - The number of ropes will be between 1 and 1000. - The length of each rope will be a positive integer up to 1000. Performance Requirements: - Your solution should have a time complexity of O(n log n), where `n` is the number of ropes. Scenario: Imagine you are a craftsman working with ropes to create various designs. You have several pieces of ropes of different lengths, and you need to combine them into one long rope. The cost of combining any two pieces of rope is equal to the sum of their lengths. Your goal is to minimize the total cost of combining all the ropes into one continuous piece.","solution":"import heapq def minimize_cost_to_combine_ropes(ropes): Minimizes the total cost to combine all the given ropes into one rope. Parameters: ropes (list of int): A list of integers representing the lengths of the ropes. Returns: int: The minimum cost to combine all the given ropes into one rope. if not ropes: return 0 # Create a min heap from the list of ropes heapq.heapify(ropes) total_cost = 0 # Continue combining ropes until only one rope is left while len(ropes) > 1: # Pop the two smallest ropes first = heapq.heappop(ropes) second = heapq.heappop(ropes) # The cost to combine them is their sum cost = first + second total_cost += cost # Push the combined rope back into the heap heapq.heappush(ropes, cost) return total_cost"},{"question":"# Array Slicing and Data Transformation Context: Manipulating and transforming data in arrays is a fundamental skill in programming. This often involves tasks such as slicing sections of arrays, performing operations on the slices, and combining the results in meaningful ways. In this assessment, your task is to perform specific transformations on a given array based on the instructions provided. Task: You need to write a function `transform_array(data: list, instructions: dict) -> list` that transforms the given list of numbers based on a set of instructions. Requirements: 1. The function should accept a list of integers or floats `data` and a dictionary `instructions` outlining the transformation steps. 2. The dictionary `instructions` will have the following keys: - `\\"action\\"`: A string that specifies the transformation action to perform (either `\\"slice\\"` or `\\"reverse\\"`). - `\\"start\\"` (optional): An integer indicating the starting index for the slice. Defaults to the beginning of the array if not provided (applicable only when `\\"action\\"` is `\\"slice\\"`). - `\\"end\\"` (optional): An integer indicating the ending index for the slice. Defaults to the end of the array if not provided (applicable only when `\\"action\\"` is `\\"slice\\"`). Input: * A list of integers or floats `data` which can contain any numerical value. * A dictionary `instructions` with keys as described. Output: * A transformed list based on the provided instructions. Constraints: * Ensure the function handles cases where the indices might be out of bounds gracefully. * If an unsupported action is provided, raise a `ValueError` with the message `\\"Unsupported action\\"`. Examples: ```python transform_array([10, 20, 30, 40, 50], {\\"action\\": \\"slice\\", \\"start\\": 1, \\"end\\": 4}) # Output: [20, 30, 40] transform_array([10, 20, 30, 40, 50], {\\"action\\": \\"slice\\", \\"start\\": 2}) # Output: [30, 40, 50] transform_array([10, 20, 30, 40, 50], {\\"action\\": \\"reverse\\"}) # Output: [50, 40, 30, 20, 10] transform_array([10, 20, 30, 40, 50], {\\"action\\": \\"slice\\"}) # Output: [10, 20, 30, 40, 50] transform_array([10, 20, 30, 40, 50], {\\"action\\": \\"rotate\\"}) # Raises: ValueError: Unsupported action ```","solution":"def transform_array(data: list, instructions: dict) -> list: Transforms the given list of numbers based on the instructions provided. :param data: List of integers or floats :param instructions: Dictionary with transformation instructions :return: Transformed list action = instructions.get(\\"action\\") if action == \\"slice\\": start = instructions.get(\\"start\\", 0) end = instructions.get(\\"end\\", len(data)) return data[start:end] elif action == \\"reverse\\": return data[::-1] else: raise ValueError(\\"Unsupported action\\")"},{"question":"# Coding Challenge: Reverse Only Alphabet Characters in a String Write a function that reverses only the alphabet characters in a given string, while leaving all other characters in their original positions. This will test your understanding of string manipulation and handling of special character positions. Problem Description Implement a function named `reverse_only_alphabets` that takes a single string as input and returns a new string with only the alphabetic characters reversed, without affecting the positions of non-alphabetic characters. Function Signature: ```python def reverse_only_alphabets(s: str) -> str: ``` Input: * `s`: A string that may contain letters (both uppercase and lowercase), digits, and special characters. Output: * Returns a string with only the alphabetic characters reversed. Example: ```python assert reverse_only_alphabets(\\"ab-cd\\") == \\"dc-ba\\" assert reverse_only_alphabets(\\"a-bC-dEf-ghIj\\") == \\"j-Ih-gfE-dCba\\" assert reverse_only_alphabets(\\"Test1ng-Leet=code-Q!\\") == \\"Qedo1ct-eeLg=ntse-T!\\" ``` Constraints: * You must handle both uppercase and lowercase alphabetic characters. * Non-alphabetic characters (digits, symbols, spaces) should remain in their original positions. * The solution should be efficient and handle strings of varying lengths, including empty strings. Additional Considerations: Make sure to preserve the case of the characters and the original positions of non-alphabet characters. Consider edge cases with all non-alphabet characters or a mix of alphabetic and non-alphabetic characters.","solution":"def reverse_only_alphabets(s: str) -> str: Returns the input string with only the alphabetic characters reversed, while leaving all other characters in their original positions. # Extract alphabetic characters and reverse them alphabets = [char for char in s if char.isalpha()] reversed_alphabets = alphabets[::-1] # Result list to construct the final string result = [] alpha_index = 0 # Reconstruct the string with reversed alphabets in place of original ones for char in s: if char.isalpha(): result.append(reversed_alphabets[alpha_index]) alpha_index += 1 else: result.append(char) return \'\'.join(result)"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},L={class:"card-container"},N={key:0,class:"empty-state"},z=["disabled"],R={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,w(a.displayedPoems,(o,f)=>(n(),v(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",N,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",R,"See more"))],8,z)):u("",!0)])}const Y=c(F,[["render",P],["__scopeId","data-v-acc57e27"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/49.md","filePath":"quotes/49.md"}'),j={name:"quotes/49.md"},H=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,H as default};
