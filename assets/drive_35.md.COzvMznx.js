import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const C=c(k,[["render",A],["__scopeId","data-v-994c4990"]]),S=JSON.parse('[{"question":"# Maze Pathfinding You are tasked with navigating a maze represented by a 2D grid to reach a designated destination from a starting point. The grid cells may contain blocks, restricting movement, and movement is only allowed vertically or horizontally. Your objective is to find the shortest path from the start to the destination. **Function Signature**: ```python def shortest_path(grid: list, start: tuple, end: tuple) -> int: pass ``` **Expected Input and Output**: * **Input**: * `grid` - A 2D list of integers, where 0 represents an empty cell and 1 represents a block. * `start` - A tuple of two integers representing the starting cell\'s coordinates (row, column). * `end` - A tuple of two integers representing the destination cell\'s coordinates (row, column). * **Output**: * Return an integer representing the length of the shortest path from `start` to `end`. If no path is found, return -1. **Constraints**: * The grid will have at least one row and one column and at most 500 rows and 500 columns. * The grid contains only 0s and 1s. * The start and end points will always be valid and non-blocked cells. * The start and end points can be the same. **Example**: ```python >>> shortest_path([[0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0]], (0, 0), (4, 4)) 8 >>> shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1)) -1 ``` **Instructions**: 1. Validate the input data to ensure the dimensions of the grid are non-empty and contain only 0s and 1s. 2. Use a breadth-first search (BFS) algorithm to find the shortest path from the start cell to the end cell. 3. Keep track of visited cells to avoid cycles. 4. If the destination is not reachable, return -1. 5. Implement edge case handling such as the grid being completely blocked or no possible path. **Note**: The solution must be efficient to handle the maximum constraints.","solution":"from collections import deque def shortest_path(grid, start, end): # Check if the start and end points are the same if start == end: return 0 # Directions array for moving in 4 possible directions directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Get the dimensions of the grid rows, cols = len(grid), len(grid[0]) # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: current_row, current_col, dist = queue.popleft() # Explore all possible 4 directions for dr, dc in directions: new_row, new_col = current_row + dr, current_col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: if (new_row, new_col) == end: return dist + 1 queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"# Problem Statement You need to implement a text editor feature that finds and replaces all occurrences of a word in a given text. This involves searching the target word, replacing it with the provided replacement, and ensuring that the function operates efficiently even for large volumes of text. # Function Signatures - Implement the function `find_and_replace(text: str, target: str, replacement: str) -> str`. This function will: - Take three strings: `text`, `target`, and `replacement`. - Return a new string where all occurrences of `target` in `text` are replaced with `replacement`. ```python def find_and_replace(text: str, target: str, replacement: str) -> str: pass ``` # Input and Output Input 1. `text` (str): The original text. Constraints: `1 ≤ len(text) ≤ 5000`. 2. `target` (str): The word to search for in the text. Constraints: `1 ≤ len(target) ≤ 100`. 3. `replacement` (str): The word to replace the target with. Constraints: `0 ≤ len(replacement) ≤ 100`. Output 1. Returns a new string where every occurrence of `target` in `text` has been replaced with `replacement`. # Example 1. `find_and_replace(\\"hello world, hello universe\\", \\"hello\\", \\"hi\\")` - Returns: `\\"hi world, hi universe\\"` 2. `find_and_replace(\\"abc abc abc\\", \\"abc\\", \\"xyz\\")` - Returns: `\\"xyz xyz xyz\\"` 3. `find_and_replace(\\"hello\\", \\"world\\", \\"hi\\")` - Returns: `\\"hello\\"` 4. `find_and_replace(\\"hello world\\", \\"world\\", \\"\\")` - Returns: `\\"hello \\"` # Constraints - You must handle edge cases where `target` is not found in `text`. - Ensure the function efficiently processes the text, even if the `target` and `replacement` strings significantly differ in length. - Handle cases where `replacement` is an empty string appropriately. # Notes - Utilize built-in string functions for efficient manipulation. - Consider special cases such as overlapping targets or targets at the boundaries of the text.","solution":"def find_and_replace(text: str, target: str, replacement: str) -> str: Replaces all occurrences of target with replacement in the given text. if target == \\"\\": # If target is empty string, replacing it would cause infinite loop raise ValueError(\\"Target string must not be empty\\") return text.replace(target, replacement)"},{"question":"# Scenario You need to implement a cache system for frequently accessed data in a web application. The cache should follow the Least Recently Used (LRU) eviction policy to ensure that the most frequently accessed items are quickly available, while less frequently accessed items are evicted when the cache size limit is reached. # Task Write a Python class `LRUCache` that implements an LRU cache using a combination of a doubly-linked list and a hash map. # Class Structure ```python class LRUCache: def __init__(self, capacity: int) -> None: Initialize the LRUCache with a given capacity. pass def get(self, key: int) -> int: Return the value of the key if it exists, otherwise return -1. pass def put(self, key: int, value: int) -> None: Insert a key-value pair into the cache. If the cache exceeds its capacity, evict the least recently used item. pass ``` # Constraints and Requirements * The cache should operate in O(1) time complexity for both `get` and `put` operations. * Expected input format: * `capacity` is an integer representing the maximum size of the cache. * `key` is an integer representing the key to be accessed/inserted. * `value` is an integer representing the value associated with the key. * Expected output: * For the `get` method, an integer representing the value associated with the key if it exists, otherwise -1. * The `put` method does not return anything. # Example ```python # Example usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Expected Output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Expected Output: -1 cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Expected Output: -1 print(cache.get(3)) # Expected Output: 3 print(cache.get(4)) # Expected Output: 4 ``` # Important Note Ensure that the doubly-linked list and hash map are correctly synchronized to maintain the LRU order and handle edge cases such as cache underflow and overflow.","solution":"class Node: def __init__(self, key: int = 0, value: int = 0): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = {} self.head = Node() self.tail = Node() self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node: Node) -> None: node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.tail.prev self._remove(lru) del self.cache[lru.key]"},{"question":"# Coding Assessment: Optimize Recursive Fibonacci Function Context The Fibonacci sequence is used in various algorithmic problems and optimization tasks. A common implementation of the Fibonacci sequence uses recursion, which can be inefficient for larger input values due to repeated calculations. Your task is to optimize the recursive Fibonacci function to improve its efficiency. Problem Statement Optimize the function `fib_recursive` to memoize previously computed values, thus reducing redundant calculations and improving performance. Function to Be Optimized ```python def fib_recursive(n: int) -> int: Calculate the nth Fibonacci number recursively. The Fibonacci sequence is defined as: F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 >>> fib_recursive(0) 0 >>> fib_recursive(1) 1 >>> fib_recursive(10) 55 if n <= 0: return 0 elif n == 1: return 1 else: return fib_recursive(n - 1) + fib_recursive(n - 2) ``` Requirements 1. **Optimization**: - Implement caching to store already computed values. - Use a suitable Python feature for memoization. 2. **Input Validation**: - Ensure the input `n` is a non-negative integer. - Raise a `ValueError` with an appropriate message for invalid inputs. Input/Output Format * **Input**: - `n`: An integer representing the position in the Fibonacci sequence (must be a non-negative integer). * **Output**: - An integer value representing the nth Fibonacci number. Constraints 1. The input value `n` must be a non-negative integer. Example ```python try: print(fib_recursive(10)) # Outputs: 55 print(fib_recursive(20)) # Outputs: 6765 print(fib_recursive(-5)) # Raises ValueError except ValueError as ve: print(f\\"ValueError: {ve}\\") ``` Optimized Function Template ```python from functools import lru_cache @lru_cache(None) def fib_recursive(n: int) -> int: Calculate the nth Fibonacci number recursively with memoization. The Fibonacci sequence is defined as: F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 >>> fib_recursive(0) 0 >>> fib_recursive(1) 1 >>> fib_recursive(10) 55 if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n - 1) + fib_recursive(n - 2) ```","solution":"from functools import lru_cache @lru_cache(None) def fib_recursive(n: int) -> int: Calculate the nth Fibonacci number recursively with memoization. The Fibonacci sequence is defined as: F(0) = 0, F(1) = 1 F(n) = F(n-1) + F(n-2) for n >= 2 if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") elif n == 0: return 0 elif n == 1: return 1 else: return fib_recursive(n - 1) + fib_recursive(n - 2)"},{"question":"Task: Compose one additional question for a coding assessment that seamlessly integrates with the given set. Existing Question Examples # Question 1 # Banker\'s Algorithm Implementation and Enhancement Objective: You\'re given the Python implementation of the Banker\'s Algorithm used for resource allocation and deadlock avoidance. Demonstrate your understanding of this algorithm by enhancing its functionality to handle dynamic changes in resource availability and process requests. Requirements: 1. **Function Addition**: Add functionality to handle dynamic requests for resources by providing a new method `request_resources(self, process_id, request_vector)`. 2. **Safety Verification**: Ensure that each dynamic request leverages the existing safety check mechanism to validate the system\'s state post request. 3. **Edge Handling**: Implement error handling for edge cases where resource requests exceed available or maximum claimed resources. Input & Output Format: - **Input**: - An instance method `request_resources` that accepts: - `process_id`: ID of the process making the request. - `request_vector`: A list depicting the number of each type of resource requested. - **Output**: - Print the result of the request - whether it\'s granted or denied based on safety checks. - Print updated resource allocation and available resource states. Examples: ```python # Initialize Banker\'s Algorithm with given tables bankers = BankersAlgorithm(test_claim_vector, test_allocated_res_table, test_maximum_claim_table) # Request resources for process 0 and print results bankers.request_resources(0, [1, 0, 1, 1]) # Expected Output: # Process 1 request [1, 0, 1, 1] is being processed. # Updated available resource stack for processes: [0, 2, 1, 1] # Process 1 request is granted. System remains in safe state. ``` Constraints: - The system cannot deny requests if it leaves the system in an unsafe state. - Resources requested must not exceed the total available resources. - Error messages should be clear for any invalid request cases. Performance: - The complexity should remain within reasonable limits, ensuring responsive behavior for resource requests in small to medium system scales. Implement the above requirements to complete the Banker\'s Algorithm and verify your enhancements with the provided example and edge cases. # New Question Proposal # Question 2 # Data Stream Median Maintenance Objective: Implement a class to maintain the median of a stream of integers. You will be required to handle dynamic insertion of integers while retrieving the current median in a time-efficient manner. Requirements: 1. **Class Implementation**: Create a class `MedianStream` with the following methods: - `add_number(self, num: int)`: Adds an integer to the data stream. - `find_median(self) -> float`: Returns the current median of the stream. 2. **Data Structures**: Utilize appropriate data structures (such as heaps) to ensure efficient insertion and retrieval operations. 3. **Edge Handling**: Implement error handling for scenarios where no elements are present when retrieving the median. Input & Output Format: - **Input**: - Instance method `add_number` which accepts: - `num`: An integer to be added to the stream. - Instance method `find_median` which returns: - The current median of the stream as a float. - **Output**: - Each integer is added in constant or logarithmic time. - Median retrieval is efficient and correctly reflects the stream’s current state. Examples: ```python # Initialize the MedianStream class median_stream = MedianStream() # Add numbers and print medians median_stream.add_number(1) print(median_stream.find_median()) # Expected Output: 1.0 median_stream.add_number(5) print(median_stream.find_median()) # Expected Output: 3.0 median_stream.add_number(2) print(median_stream.find_median()) # Expected Output: 2.0 median_stream.add_number(10) print(median_stream.find_median()) # Expected Output: 3.5 ``` Constraints: - Ensure that adding a number and finding the median are optimized for performance. - Handle data streams with varying sizes efficiently. Performance: - The solution should support real-time data streams, guaranteeing quick updates and queries for the current median. Implement the `MedianStream` class following the requirements and demonstrate its functionality using the provided examples and edge cases.","solution":"import heapq class MedianStream: def __init__(self): # Max heap for the lower half of the numbers self.low = [] # Min heap for the upper half of the numbers self.high = [] def add_number(self, num: int): # Always add to the max heap (inverted min heap) heapq.heappush(self.low, -num) # Balance the heaps by moving the largest element in low to high if self.low and self.high and (-self.low[0]) > self.high[0]: heapq.heappush(self.high, -heapq.heappop(self.low)) # Ensure size property: (len(low) >= len(high)) if len(self.low) > len(self.high) + 1: heapq.heappush(self.high, -heapq.heappop(self.low)) if len(self.high) > len(self.low): heapq.heappush(self.low, -heapq.heappop(self.high)) def find_median(self) -> float: if len(self.low) > len(self.high): return float(-self.low[0]) return (-self.low[0] + self.high[0]) / 2"},{"question":"# Mandelbrot Set Visualization You are required to implement a Python function that visualizes the Mandelbrot set, a famous fractal. Your task is to enhance the provided algorithm by introducing parallel processing to speed up the calculation. # Objective Write a function `plot_mandelbrot_parallel` that improves the performance of plotting the Mandelbrot set by utilizing parallel processing. # Input and Output * **Inputs**: * `width: int` - the width of the generated image in pixels. * `height: int` - the height of the generated image in pixels. * `max_iter: int` - the maximum number of iterations to determine the level of divergence. * `x_min: float` - the minimum x-coordinate (real) of the plot area. * `x_max: float` - the maximum x-coordinate (real) of the plot area. * `y_min: float` - the minimum y-coordinate (imaginary) of the plot area. * `y_max: float` - the maximum y-coordinate (imaginary) of the plot area. * **Output**: * Display the Mandelbrot set as an image. # Constraints * `width > 0` * `height > 0` * `max_iter > 0` * `x_min < x_max` * `y_min < y_max` # Guidelines 1. Use Python\'s multiprocessing library to enhance the computation speed. 2. Ensure that your function handles the edge cases, such as where the input values do not form a valid viewing window. # Function Signature ```python def plot_mandelbrot_parallel(width: int, height: int, max_iter: int, x_min: float, x_max: float, y_min: float, y_max: float): # Your code here ``` # Example ```python import numpy as np from PIL import Image import multiprocessing def mandelbrot(c, max_iter): z = c for n in range(max_iter): if abs(z) > 2: return n z = z*z + c return max_iter def calculate_mandelbrot(pixel_data): x, y, width, height, max_iter, x_min, x_max, y_min, y_max = pixel_data c = complex(x_min + (x / width) * (x_max - x_min), y_min + (y / height) * (y_max - y_min)) return mandelbrot(c, max_iter) def plot_mandelbrot_parallel(width: int, height: int, max_iter: int, x_min: float, x_max: float, y_min: float, y_max: float): pixels = [(x, y, width, height, max_iter, x_min, x_max, y_min, y_max) for x in range(width) for y in range(height)] with multiprocessing.Pool() as pool: results = pool.map(calculate_mandelbrot, pixels) img = Image.new(\'RGB\', (width, height)) img.putdata([(int(r * 255 / max_iter), int(r * 255 / max_iter), int(r * 255 / max_iter)) for r in results]) img.show() def main(): plot_mandelbrot_parallel(800, 600, 1000, -2.0, 1.0, -1.5, 1.5) if __name__ == \\"__main__\\": main() ``` # Scenario Suppose you are optimizing a fractal viewer application to visualize the Mandelbrot set. By leveraging parallel processing, the application can handle larger images and higher iteration counts more efficiently, providing a smoother user experience. Implement the parallelization and describe its impact on the rendering performance.","solution":"import numpy as np from PIL import Image import multiprocessing def mandelbrot(c, max_iter): z = c for n in range(max_iter): if abs(z) > 2: return n z = z*z + c return max_iter def calculate_mandelbrot(pixel_data): x, y, width, height, max_iter, x_min, x_max, y_min, y_max = pixel_data c = complex(x_min + (x / width) * (x_max - x_min), y_min + (y / height) * (y_max - y_min)) return (x, y, mandelbrot(c, max_iter)) def plot_mandelbrot_parallel(width: int, height: int, max_iter: int, x_min: float, x_max: float, y_min: float, y_max: float): pixels = [(x, y, width, height, max_iter, x_min, x_max, y_min, y_max) for x in range(width) for y in range(height)] with multiprocessing.Pool() as pool: results = pool.map(calculate_mandelbrot, pixels) img = Image.new(\'RGB\', (width, height)) img_pixels = img.load() for (x, y, value) in results: color = 255 - int(value * 255 / max_iter) img_pixels[x, y] = (color, color, color) img.show() def main(): plot_mandelbrot_parallel(800, 600, 1000, -2.0, 1.0, -1.5, 1.5) if __name__ == \\"__main__\\": main()"},{"question":"# Matrix Rotation Challenge Background You are working on a graphics rendering application that frequently requires rotating images represented as 2D matrices. Rotation operations are computationally intensive and must be optimized to handle high-resolution images efficiently. Problem Statement Write a function `rotate_matrix` that rotates a given N x N matrix 90 degrees clockwise. The rotation should be done in-place, meaning you should not use any extra space for another matrix. ```python def rotate_matrix(matrix: list) -> None: Rotates the given N x N matrix 90 degrees clockwise in-place. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4]] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [[1]] >>> rotate_matrix(matrix) >>> matrix [[1]] pass ``` # Input - `matrix` (list of list of ints): An N x N matrix represented as a list of N lists, each containing N integers. # Output - The function modifies the input matrix in place and does not return any value. # Constraints - The matrix is guaranteed to be non-empty and NxN (the number of rows and columns are the same). - N is an integer such that 1 ≤ N ≤ 1000. - The elements of the matrix are integers within the range -10^6 to 10^6. # Requirements - The function should run efficiently, with a time complexity of O(N^2) and a space complexity of O(1) (in-place rotation). - Handle small edge cases, such as a 1x1 matrix, gracefully. # Testing You may assume the presence of a testing framework similar to `doctest`. Comprehensive tests covering various matrix sizes and values will be appreciated. Good luck, and happy coding!","solution":"def rotate_matrix(matrix: list) -> None: Rotates the given N x N matrix 90 degrees clockwise in-place. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9]] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4]] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [[1]] >>> rotate_matrix(matrix) >>> matrix [[1]] n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first top = matrix[first][i] # save top # left -> top matrix[first][i] = matrix[last-offset][first] # bottom -> left matrix[last-offset][first] = matrix[last][last-offset] # right -> bottom matrix[last][last-offset] = matrix[i][last] # top -> right matrix[i][last] = top"},{"question":"# Coding Assessment Question Context: You have been working with search algorithms and their various implementations. Now, you\'ll be tasked with implementing an efficient search algorithm for a sorted dataset and comparing its performance with a linear search. Task: Implement the Binary Search algorithm. Given a sorted list of integers and a target integer, your function should return the index of the target within the list using Binary Search. Compare its efficiency on the same dataset with Linear Search. Function Signature: ```python def binary_search(arr: List[int], target: int) -> int: pass ``` Input & Output: - **Input**: A sorted list of integers `arr` (0 <= len(arr) <= 1000) and an integer `target`. - **Output**: The index of the target integer within the list if found, otherwise -1. Constraints: - The input list can be empty. - All integers are within the range [-10^6, 10^6]. - You should not use any in-built search functions. - You must implement the search logic. Performance Requirements: - Time Complexity: O(log n) for Binary Search. - Space Complexity: O(1). Examples: ```python assert binary_search([1, 2, 3, 4, 5, 6], 4) == 3 assert binary_search([1, 2, 3, 4, 5, 6], 6) == 5 assert binary_search([1, 2, 3, 4, 5, 6], 1) == 0 assert binary_search([1, 2, 3, 4, 5, 6], 7) == -1 assert binary_search([], 1) == -1 ``` Additional Challenge: Create a performance comparison by implementing a test that searches for an element in a sorted list of 1000 integers using both your `binary_search` and a simple linear search. Document the time taken for both search operations.","solution":"from typing import List def binary_search(arr: List[int], target: int) -> int: Perform a binary search to find the index of the target in the sorted list. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1 def linear_search(arr: List[int], target: int) -> int: Perform a linear search to find the index of the target in the list. Args: arr (List[int]): The list of integers. target (int): The integer to find in the array. Returns: int: The index of the target in the array if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1 import time def compare_search_performance(arr: List[int], target: int): Compare the performance of binary search and linear search. Args: arr (List[int]): The sorted list of integers. target (int): The integer to find in the array. start_time = time.time() binary_search_result = binary_search(arr, target) binary_search_time = time.time() - start_time start_time = time.time() linear_search_result = linear_search(arr, target) linear_search_time = time.time() - start_time print(f\\"Binary Search Result: {binary_search_result}, Time: {binary_search_time}\\") print(f\\"Linear Search Result: {linear_search_result}, Time: {linear_search_time}\\")"},{"question":"# Advanced Inventory Management System Objective Create a comprehensive `InventorySystem` class that efficiently manages a collection of products, tracks stock levels, and handles sales and restocking operations. The system should ensure integrity and validation of product data throughout all transactions. Instructions 1. **Class Definition**: Write a class `InventorySystem` that: - Maintains an inventory of products where each product has a name, SKU (Stock Keeping Unit), price, and quantity. - Provides methods for adding new products, selling products, restocking inventory, and generating sales reports. 2. **Class Methods**: - `add_product(name: str, sku: str, price: float, quantity: int) -> None`: Adds a new product to the inventory. - `sell_product(sku: str, quantity: int) -> float`: Sells the specified quantity of a product if available and returns the total price of the sale. Reduces the product quantity in the inventory. - `restock_product(sku: str, quantity: int) -> None`: Restocks the specified quantity of a product. - `get_stock_level(sku: str) -> int`: Returns the current stock level of the specified product. - `generate_sales_report() -> dict`: Returns a dictionary summarizing the total sales for each product along with the total revenue. 3. **Validation**: - Ensure that the price of products and quantities cannot be negative. - SKU values should be unique across the inventory. - Ensure that the requested quantity for sales does not exceed the available stock. Example Here\'s an example of how your `InventorySystem` can be used: ```python inventory = InventorySystem() inventory.add_product(\'Laptop\', \'SKU123\', 999.99, 10) inventory.add_product(\'Smartphone\', \'SKU124\', 499.99, 20) print(\\"Stock Level for SKU123:\\", inventory.get_stock_level(\'SKU123\')) revenue = inventory.sell_product(\'SKU123\', 2) print(\\"Revenue from selling 2 Laptops:\\", revenue) inventory.restock_product(\'SKU123\', 5) print(\\"Stock Level for SKU123 after restocking:\\", inventory.get_stock_level(\'SKU123\')) print(\\"Sales Report:\\", inventory.generate_sales_report()) ``` Constraints - Assume no product can have a price or quantity less than or equal to zero. - Maximum price for any product is 10000 units. - Maximum quantity for any product is 1000 units. - SKU must be a unique string identifier for each product.","solution":"class InventorySystem: def __init__(self): self.inventory = {} self.sales = {} def add_product(self, name: str, sku: str, price: float, quantity: int) -> None: if price <= 0 or quantity <= 0: raise ValueError(\\"Price and quantity must be positive.\\") if sku in self.inventory: raise ValueError(\\"SKU must be unique.\\") self.inventory[sku] = {\'name\': name, \'price\': price, \'quantity\': quantity} self.sales[sku] = {\'name\': name, \'total_sold\': 0, \'total_revenue\': 0.0} def sell_product(self, sku: str, quantity: int) -> float: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if self.inventory[sku][\'quantity\'] < quantity: raise ValueError(\\"Insufficient stock to complete the sale.\\") self.inventory[sku][\'quantity\'] -= quantity total_price = self.inventory[sku][\'price\'] * quantity self.sales[sku][\'total_sold\'] += quantity self.sales[sku][\'total_revenue\'] += total_price return total_price def restock_product(self, sku: str, quantity: int) -> None: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") self.inventory[sku][\'quantity\'] += quantity def get_stock_level(self, sku: str) -> int: if sku not in self.inventory: raise ValueError(\\"Product not found.\\") return self.inventory[sku][\'quantity\'] def generate_sales_report(self) -> dict: report = {} for sku, data in self.sales.items(): report[sku] = { \'name\': data[\'name\'], \'total_sold\': data[\'total_sold\'], \'total_revenue\': data[\'total_revenue\'] } return report"},{"question":"# Graph Traversal with Depth-First Search You are asked to implement a directed graph and perform Depth-First Search (DFS) on it. Your implementation should allow adding vertices and edges, as well as performing DFS to visit all nodes from a given starting vertex. # Function Requirements 1. `add_vertex(self, vertex)`: Add a new vertex to the graph. 2. `add_edge(self, start, end)`: Add a directed edge from vertex `start` to vertex `end`. 3. `dfs(self, start)`: Perform DFS starting from the vertex `start` and return the order of visited vertices. # Input and Output - `add_vertex(self, vertex)` - **Input**: A string `vertex` representing the vertex name. - **Output**: None. - `add_edge(self, start, end)` - **Input**: Two strings `start` and `end` representing the vertices to connect. - **Output**: None. - `dfs(self, start)` - **Input**: A string `start` representing the starting vertex for DFS traversal. - **Output**: A list of strings representing the order in which vertices are visited. # Constraints - Assume all vertex names are unique strings. - The graph can have up to 1,000 vertices. - You can assume that the graph is always connected, and there will always be a path from `start` to all other vertices. # Example ```python # Create graph object g = Graph() # Add vertices g.add_vertex(\\"A\\") g.add_vertex(\\"B\\") g.add_vertex(\\"C\\") g.add_vertex(\\"D\\") g.add_vertex(\\"E\\") # Add edges g.add_edge(\\"A\\", \\"B\\") g.add_edge(\\"A\\", \\"C\\") g.add_edge(\\"B\\", \\"D\\") g.add_edge(\\"C\\", \\"D\\") g.add_edge(\\"D\\", \\"E\\") # Perform DFS starting from vertex \'A\' print(g.dfs(\\"A\\")) # => [\'A\', \'B\', \'D\', \'E\', \'C\'] ``` # Implementation Implement the necessary methods to complete the `Graph` class and perform the DFS traversal as specified. Use an appropriate data structure to keep track of the vertices and the edges between them.","solution":"class Graph: def __init__(self): self.adjacency_list = {} def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, start, end): if start in self.adjacency_list and end in self.adjacency_list: self.adjacency_list[start].append(end) def dfs(self, start): visited = set() traversal = [] self._dfs_helper(start, visited, traversal) return traversal def _dfs_helper(self, current_vertex, visited, traversal): if current_vertex not in visited: visited.add(current_vertex) traversal.append(current_vertex) for neighbor in self.adjacency_list[current_vertex]: self._dfs_helper(neighbor, visited, traversal)"},{"question":"# Traveling Salesman Problem - Approximation Using Nearest Neighbor Heuristic Background: The Traveling Salesman Problem (TSP) is a classic algorithmic problem in the fields of computer science and operations research. Given a list of cities and the distances between each pair of cities, the task is to find the shortest possible route that visits each city exactly once and returns to the origin city. This problem is known to be NP-hard. Therefore, for large lists of cities, heuristic or approximate solutions are often used. Task: 1. **Implement Nearest Neighbor Heuristic for TSP**: Write a function to solve the TSP using the Nearest Neighbor heuristic. Start from an arbitrary city, repeatedly move to the nearest unvisited city until all cities have been visited, then return to the starting city. Function Signature: 1. `nearest_neighbor_tsp(distances: list[list[float]], start_city: int = 0) -> list[int]` * **Input**: * `distances` - A 2D list representing the distance matrix where `distances[i][j]` is the distance between city `i` and city `j`. * `start_city` - The index of the city to start and end the tour. * **Output**: * A list of city indices representing the order in which the cities are visited in the approximate shortest tour, starting and ending at `start_city`. Constraints: * The number of cities `n` is relatively small (e.g., n ≤ 100). * The distance matrix is symmetric and satisfies the triangle inequality (i.e., `distances[i][j]` = `distances[j][i]` and `distances[i][k]` ≤ `distances[i][j] + distances[j][k]` for all `i, j, k`). Example: ```python # Example distance matrix (symmetric) distances = [ [0, 29, 20, 21], [29, 0, 15, 17], [20, 15, 0, 28], [21, 17, 28, 0] ] start_city = 0 tour = nearest_neighbor_tsp(distances, start_city) print(tour) # Output could be something like [0, 2, 1, 3, 0] based on nearest neighbor heuristic ``` Notes: * Ensure your solution handles edge cases such as when the distance matrix contains zero distances for the same city. * The function should return the tour starting and ending at the given `start_city`. * While ties in distances can happen, you may return any one of the nearest unvisited cities in such cases.","solution":"def nearest_neighbor_tsp(distances, start_city=0): Solves the Traveling Salesman Problem using the Nearest Neighbor heuristic. Parameters: distances (list[list[float]]): A 2D list representing the distance matrix where distances[i][j] is the distance between city i and city j. start_city (int): The index of the city to start and end the tour. Returns: list[int]: A list of city indices representing the order in which the cities are visited in the approximate shortest tour, starting and ending at start_city. n = len(distances) visited = [False] * n tour = [start_city] visited[start_city] = True current_city = start_city for _ in range(n - 1): nearest_distance = float(\'inf\') nearest_city = None for j in range(n): if not visited[j] and distances[current_city][j] < nearest_distance: nearest_distance = distances[current_city][j] nearest_city = j tour.append(nearest_city) visited[nearest_city] = True current_city = nearest_city # Return to the starting city tour.append(start_city) return tour"},{"question":"# Array Pair Sum Challenge # Problem Description: You are given a list of integers and a target integer `k`. Write a function that determines whether any two distinct elements from the list sum up to `k`. The solution should be efficient to handle larger input sizes. # Requirements: 1. Implement a function `has_pair_with_sum(numbers: List[int], k: int) -> bool` that returns a boolean indicating whether there are two distinct integers in the list that add up to `k`. 2. Optimize your solution to have linear time complexity, utilizing appropriate data structures. Input: * `numbers` (list of integers): A non-empty list of integers where each integer can be positive, negative, or zero. * `k` (integer): The target sum integer. Output: * Return `True` if there exist two distinct integers within the list that sum up to `k`. Otherwise, return `False`. Constraints: * Each integer in the list and `k` will be within the range of [-1,000,000, 1,000,000]. * The length of the list `numbers` will be within the range of [2, 1,000,000]. # Example: ```python # Example 1 assert has_pair_with_sum([10, 15, 3, 7], 17) == True # 10 + 7 = 17 # Example 2 assert has_pair_with_sum([1, 2, 3, 9], 8) == False # No two integers sum up to 8 # Example 3 assert has_pair_with_sum([5, -2, 6, -1, 4], 3) == True # 5 + (-2) = 3 ``` # Performance: - Your implementation should aim for an optimal time complexity of O(n) where `n` is the number of elements in the list `numbers`. # Tips: 1. Consider using a set data structure to keep track of the complements needed to reach the target sum. 2. Make sure to handle both positive and negative integers within the list appropriately. 3. Pay attention to edge cases such as lists with length 2 or with all elements being the same. # Implementation: Your task is to fill in the implementation of the following function: ```python from typing import List def has_pair_with_sum(numbers: List[int], k: int) -> bool: # Your implementation here pass ``` Ensure to test your function thoroughly using the provided examples and additional edge cases you can think of.","solution":"from typing import List def has_pair_with_sum(numbers: List[int], k: int) -> bool: complements = set() for number in numbers: if k - number in complements: return True complements.add(number) return False"},{"question":"Log Parser for Security Events In this task, you need to implement a log parser that extracts and classifies security events from a given log file. The security events have a specific format, and your implementation should accurately identify and categorize them based on predefined types. **Function Signatures**: - Implement the function `def extract_security_events(log: str) -> List[dict]:` # Requirements: 1. **extract_security_events(log: str) -> List[dict]**: - Accepts a single string representing the log data. - Returns a list of dictionaries, each representing a recognized security event. - Each dictionary should have the following keys: - `timestamp` (string): The timestamp of the event in \\"YYYY-MM-DD HH:MM:SS\\" format. - `event_type` (string): The type/category of the security event. Possible values: `LOGIN_FAILURE`, `DENIED_ACCESS`, `MALWARE_DETECTED`. - `description` (string): A brief description of the event. 2. **Log Format**: - Each log entry is a single line. - Security events are embedded within the log entries. - Only the lines matching the security event patterns should be extracted and parsed. 3. **Event Patterns**: - `LOGIN_FAILURE`: Occurs when there is a failed login attempt. - Example: `\\"2023-10-01 13:45:30: LOGIN_FAILURE from user \'admin\' at IP 192.168.1.10\\"` - `DENIED_ACCESS`: When access to a resource is denied. - Example: `\\"2023-10-01 14:12:47: DENIED_ACCESS to endpoint \'/admin\' by user \'guest\'\\"` - `MALWARE_DETECTED`: When malware is detected in the system. - Example: `\\"2023-10-01 19:22:59: MALWARE_DETECTED: virus \'Trojan.XYZ\' found on device \'Device123\'\\"` # Constraints: - The input log string length can be up to 10^6 characters. - Each log line will not exceed 300 characters in length. - The logs are well-formed and follow a consistent pattern. # Example: ```python # Example extract_security_events usage log_data = 2023-10-01 13:45:30: LOGIN_FAILURE from user \'admin\' at IP 192.168.1.10 2023-10-01 13:50:00: SYSTEM_EVENT: Routine maintenance completed. 2023-10-01 14:12:47: DENIED_ACCESS to endpoint \'/admin\' by user \'guest\' 2023-10-01 19:22:59: MALWARE_DETECTED: virus \'Trojan.XYZ\' found on device \'Device123\' events = extract_security_events(log_data) assert events == [ { \\"timestamp\\": \\"2023-10-01 13:45:30\\", \\"event_type\\": \\"LOGIN_FAILURE\\", \\"description\\": \\"from user \'admin\' at IP 192.168.1.10\\" }, { \\"timestamp\\": \\"2023-10-01 14:12:47\\", \\"event_type\\": \\"DENIED_ACCESS\\", \\"description\\": \\"to endpoint \'/admin\' by user \'guest\'\\" }, { \\"timestamp\\": \\"2023-10-01 19:22:59\\", \\"event_type\\": \\"MALWARE_DETECTED\\", \\"description\\": \\"virus \'Trojan.XYZ\' found on device \'Device123\'\\" } ] ``` # Tests: Your implementation will be tested on various cases, including but not limited to: - Logs containing a mix of security and non-security events. - Edge cases such as empty logs and logs with only non-security events. - Logs containing different types of security events interspersed with other log entries. Make sure to cover these tests comprehensively to validate the robustness of your function.","solution":"import re from typing import List, Dict def extract_security_events(log: str) -> List[Dict[str, str]]: event_patterns = { \'LOGIN_FAILURE\': re.compile(r\\"(d{4}-d{2}-d{2} d{2}:d{2}:d{2}): LOGIN_FAILURE (.*)\\"), \'DENIED_ACCESS\': re.compile(r\\"(d{4}-d{2}-d{2} d{2}:d{2}:d{2}): DENIED_ACCESS (.*)\\"), \'MALWARE_DETECTED\': re.compile(r\\"(d{4}-d{2}-d{2} d{2}:d{2}:d{2}): MALWARE_DETECTED: (.*)\\") } events = [] for line in log.split(\'n\'): line = line.strip() for event_type, pattern in event_patterns.items(): match = pattern.match(line) if match: events.append({ \'timestamp\': match.group(1), \'event_type\': event_type, \'description\': match.group(2) }) break return events"},{"question":"# Scenario You oversee the development of a logistics management system for a large-scale transportation company. One critical component of this system involves calculating the optimal route between multiple delivery points to minimize travel time and distance. To accomplish this, you need to solve the Traveling Salesman Problem (TSP) for a given set of locations. # Task Write a Python function that accepts a list of tuples representing Cartesian coordinates of various delivery points. The function should compute and return the minimal possible route that visits each point exactly once and returns to the starting point. Implement the nearest-neighbor heuristic for simplicity. # Function Signature ```python def find_optimal_route(locations: list[tuple[float, float]]) -> list[tuple[float, float]]: ``` # Input & Output Requirements * **Input**: * `locations` (list of tuples): Each tuple contains two floating-point numbers representing the x and y coordinates of a delivery point. The list will contain at least two points and at most 100 points. * **Output**: * A list of tuples representing the sequence of delivery points in the order they are visited to achieve the minimal travel distance. The list should start and end at the same point. # Constraints: 1. The `locations` list will have at least two points. 2. Coordinates can be negative or positive. 3. The function should ensure the sum of Euclidean distances between consecutive points is minimized. # Example Scenarios: 1. **Input**: ```python find_optimal_route([(0, 0), (2, 2), (2, 0), (0, 2)]) ``` **Output**: ```python [(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)] ``` 2. **Input**: ```python find_optimal_route([(1, 1), (4, 4), (4, 1), (1, 4)]) ``` **Output**: ```python [(1, 1), (4, 1), (4, 4), (1, 4), (1, 1)] ``` 3. **Input**: ```python find_optimal_route([(5, 5), (10, 10), (5, 10), (10, 5)]) ``` **Output**: ```python [(5, 5), (10, 5), (10, 10), (5, 10), (5, 5)] ``` Formulate your function using the nearest-neighbor heuristic and test it exhaustively to ensure accurate and optimal results.","solution":"import math def find_optimal_route(locations): def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) if not locations: return [] n = len(locations) visited = [False] * n route = [] current_index = 0 route.append(locations[current_index]) visited[current_index] = True while len(route) < n: min_distance = float(\'inf\') next_index = None for i in range(n): if not visited[i]: distance = euclidean_distance(locations[current_index], locations[i]) if distance < min_distance: min_distance = distance next_index = i if next_index is not None: visited[next_index] = True route.append(locations[next_index]) current_index = next_index route.append(route[0]) # Return to starting point return route"},{"question":"# Question: Write a Python function that performs matrix multiplication without using any external libraries like NumPy. The function should take two matrices as input and return the resulting matrix after multiplication. # Objective: Implement the `matrix_multiply` function to perform matrix multiplication manually, ensuring proper handling of matrix dimensions. # Requirements: 1. **Input**: Two 2D lists representing matrices. * `A`: An `m x n` 2D list where `m` is the number of rows and `n` the number of columns. * `B`: An `n x p` 2D list where `n` is the number of rows and `p` the number of columns. 2. **Output**: A 2D list representing the product of the matrices `A` and `B`. 3. **Constraints**: * The function should raise a `ValueError` with a clear message if the matrices cannot be multiplied due to incompatible dimensions. # Example: ```python def matrix_multiply(A: list, B: list) -> list: Perform matrix multiplication manually. Args: - A: First matrix as a 2D list. - B: Second matrix as a 2D list. Returns: - A 2D list representing the product of matrices A and B. Raises: - ValueError: If the matrices have incompatible dimensions. Example: >>> A = [[1, 2, 3], [4, 5, 6]] >>> B = [[7, 8], [9, 10], [11, 12]] >>> matrix_multiply(A, B) [[58, 64], [139, 154]] >>> C = [[1, 2], [3, 4]] >>> D = [[5, 6, 7]] >>> matrix_multiply(C, D) ValueError: Matrices have incompatible dimensions (2x2) and (1x3). >>> E = [[1]] >>> F = [[2]] >>> matrix_multiply(E, F) [[2]] # Validate dimensions if len(A[0]) != len(B): raise ValueError(f\\"Matrices have incompatible dimensions ({len(A)}x{len(A[0])}) and ({len(B)}x{len(B[0])}).\\") # Initialize the resulting matrix with zeros result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))] # Compute each element in the resulting matrix for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result ```","solution":"def matrix_multiply(A: list, B: list) -> list: Perform matrix multiplication manually. Args: - A: First matrix as a 2D list. - B: Second matrix as a 2D list. Returns: - A 2D list representing the product of matrices A and B. Raises: - ValueError: If the matrices have incompatible dimensions. Example: >>> A = [[1, 2, 3], [4, 5, 6]] >>> B = [[7, 8], [9, 10], [11, 12]] >>> matrix_multiply(A, B) [[58, 64], [139, 154]] >>> C = [[1, 2], [3, 4]] >>> D = [[5, 6, 7]] >>> matrix_multiply(C, D) ValueError: Matrices have incompatible dimensions (2x2) and (1x3). >>> E = [[1]] >>> F = [[2]] >>> matrix_multiply(E, F) [[2]] # Validate dimensions if len(A[0]) != len(B): raise ValueError(f\\"Matrices have incompatible dimensions ({len(A)}x{len(A[0])}) and ({len(B)}x{len(B[0])}).\\") # Initialize the resulting matrix with zeros result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))] # Compute each element in the resulting matrix for i in range(len(A)): for j in range(len(B[0])): for k in range(len(B)): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"Problem Statement # Context Your team is working on analyzing large datasets containing user information. One common task is to identify and extract information on potential duplicate entries based on user names and email addresses. This helps in cleansing the data and maintaining data integrity. # Task Write a function `find_potential_duplicates` that takes a list of dictionaries, each representing a user\'s details, and identifies potential duplicates based on the `name` and `email` fields. Two entries are considered potential duplicates if they have the same `name` or the same `email`. # Requirements 1. The function should be named `find_potential_duplicates`. 2. The function should take one parameter: - `users` (list of dict): A list where each dict contains keys `id`, `name`, and `email`. 3. The function should return a list of tuples, where each tuple contains two user IDs that are considered potential duplicates. 4. The returned list should not contain duplicate tuples, and tuples should be ordered such that the smaller ID comes first. # Function Signature ```python def find_potential_duplicates(users: list[dict]) -> list[tuple[int, int]]: pass ``` # Constraints * The list `users` will contain between 1 and 10^5 entries. * Each user dictionary will contain three keys: - `id`: an integer uniquely identifying the user. - `name`: a string containing the user\'s name. - `email`: a string containing the user\'s email address. * Names and emails will be non-empty strings with a maximum length of 256 characters. # Example ```python users = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"email\\": \\"alice@example.com\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"email\\": \\"bob@example.com\\"}, {\\"id\\": 3, \\"name\\": \\"Alice\\", \\"email\\": \\"alice123@example.com\\"}, {\\"id\\": 4, \\"name\\": \\"Charlie\\", \\"email\\": \\"charlie@example.com\\"}, {\\"id\\": 5, \\"name\\": \\"Dave\\", \\"email\\": \\"dave@example.com\\"}, {\\"id\\": 6, \\"name\\": \\"Bob\\", \\"email\\": \\"bob@example.com\\"}, ] assert find_potential_duplicates(users) == [(1, 3), (2, 6)] ``` # Notes - Your function should efficiently handle large lists of users. - Ensure that the returned list is sorted in ascending order of user IDs in each tuple. - Each tuple in the returned list should be unique.","solution":"def find_potential_duplicates(users): name_dict = {} email_dict = {} duplicates = set() for user in users: user_id = user[\'id\'] name = user[\'name\'] email = user[\'email\'] if name in name_dict: for duplicate_id in name_dict[name]: duplicates.add((min(user_id, duplicate_id), max(user_id, duplicate_id))) name_dict[name].append(user_id) else: name_dict[name] = [user_id] if email in email_dict: for duplicate_id in email_dict[email]: duplicates.add((min(user_id, duplicate_id), max(user_id, duplicate_id))) email_dict[email].append(user_id) else: email_dict[email] = [user_id] return sorted(list(duplicates))"},{"question":"# Question Context You are developing a library for handling operations on matrices. One common operation in linear algebra and machine learning involves multiplying two matrices together. Given two matrices, you need to implement a function to perform this multiplication and return the resulting matrix. Task Implement a function `matrix_multiplication` that takes two matrices and returns their product. The matrices will be represented as lists of lists, where each inner list represents a row of the matrix. Function Signature ```python def matrix_multiplication(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: ``` - **Input**: * matrix_a: A list of lists of integers representing the first matrix. * matrix_b: A list of lists of integers representing the second matrix. - **Output**: * A list of lists of integers representing the product matrix. - **Constraints**: * The number of columns in `matrix_a` is equal to the number of rows in `matrix_b`. * The elements of the matrices are integers. * The maximum number of rows and columns in any matrix is 1000. - **Performance Requirements**: * The solution should have a time complexity of (O(N^3)), where (N) is the dimension of the matrix. Example ```python matrix_a = [ [1, 2, 3], [4, 5, 6] ] matrix_b = [ [7, 8], [9, 10], [11, 12] ] assert matrix_multiplication(matrix_a, matrix_b) == [ [58, 64], [139, 154] ] ``` Explanation In the given example, the product of matrix_a and matrix_b is calculated as follows: 1. The element at (0, 0) in the result is calculated as (1 * 7) + (2 * 9) + (3 * 11) = 58. 2. The element at (0, 1) in the result is calculated as (1 * 8) + (2 * 10) + (3 * 12) = 64. 3. The element at (1, 0) in the result is calculated as (4 * 7) + (5 * 9) + (6 * 11) = 139. 4. The element at (1, 1) in the result is calculated as (4 * 8) + (5 * 10) + (6 * 12) = 154. Make sure your function correctly multiplies any two matrices given the constraints.","solution":"def matrix_multiplication(matrix_a, matrix_b): Returns the product of two matrices matrix_a and matrix_b. The number of columns in matrix_a must be equal to the number of rows in matrix_b. # Number of rows in matrix_a rows_a = len(matrix_a) # Number of columns in matrix_a (which must be equal to number of rows in matrix_b) cols_a = len(matrix_a[0]) # Number of columns in matrix_b cols_b = len(matrix_b[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] # Perform the matrix multiplication for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += matrix_a[i][k] * matrix_b[k][j] return result"},{"question":"# String Compression Problem Write a Python function `compress_string(chars: List[str]) -> int` that compresses a list of characters in-place to represent the same input string but in a compressed format. The compressed string should be returned as a length of the modified list. The compression format should count the consecutive repeated characters in the form of the character followed by its count. If the length after compression is not shorter than the original string, the original string should remain. Function Signature: ```python def compress_string(chars: List[str]) -> int: ``` Input Parameters: - `chars` (List[str]): A list of characters representing the input string. Output: - An integer representing the length of the new compressed list. Constraints: 1. `1 <= len(chars) <= 1000` 2. Each character in the `chars` list is a lowercase English letter. # Example: ```python assert compress_string([\\"a\\",\\"a\\",\\"b\\",\\"b\\",\\"c\\",\\"c\\",\\"c\\"]) == 6 # After calling the function, chars should be [\\"a\\",\\"2\\",\\"b\\",\\"2\\",\\"c\\",\\"3\\"] assert compress_string([\\"a\\"]) == 1 # After calling the function, chars should be [\\"a\\"] assert compress_string([\\"a\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\",\\"b\\"]) == 4 # After calling the function, chars should be [\\"a\\",\\"b\\",\\"1\\",\\"2\\"] ``` # Guidelines: - You must modify the list `chars` in-place. - The length returned should be the new length of the modified list after compression. - Ensure to handle edge cases like a single character input or already compressed strings. - The function should aim to achieve optimal time complexity.","solution":"from typing import List def compress_string(chars: List[str]) -> int: write = 0 # Position to write the compressed characters read = 0 # Position to read the original characters while read < len(chars): char = chars[read] count = 0 # Count occurrences of the current character while read < len(chars) and chars[read] == char: read += 1 count += 1 # Write the character chars[write] = char write += 1 # Write the count if greater than 1 if count > 1: for c in str(count): chars[write] = c write += 1 return write"},{"question":"# Coding Question - Dynamic Programming on Strings **Context**: You are given two strings, `str1` and `str2`. Your task is to determine the length of the longest subsequence common to both strings. A subsequence is a sequence derived by deleting some or no characters from the original string(s), without changing the order of the remaining characters. **Task**: Write a function named `longest_common_subsequence` that returns the length of the longest common subsequence between the two given strings. **Requirements**: 1. Implement the `longest_common_subsequence` method: ```python def longest_common_subsequence(str1: str, str2: str) -> int: # code to find the length of the longest common subsequence ``` 2. Utilize dynamic programming to solve the problem efficiently. 3. Avoid redundant computations by storing intermediate results in a 2D array (dp table). **Function Signature**: ```python def longest_common_subsequence(str1: str, str2: str) -> int: pass ``` **Example**: ```python str1 = \\"ABCDGH\\" str2 = \\"AEDFHR\\" result = longest_common_subsequence(str1, str2) # The result should be 3 ``` **Input/Output**: * Input: Two strings `str1` (e.g., \\"ABCDGH\\") and `str2` (e.g., \\"AEDFHR\\"). * Output: The length of the longest common subsequence (e.g., 3 in this case for the subsequence \\"ADH\\"). *Example Execution*: ```python str1 = \\"ABC\\" str2 = \\"AC\\" result = longest_common_subsequence(str1, str2) # Expected output: 2 (subsequence: \\"AC\\") str1 = \\"abcdef\\" str2 = \\"acf\\" result = longest_common_subsequence(str1, str2) # Expected output: 3 (subsequence: \\"acf\\") ``` **Constraints**: * The length of both strings will not exceed 1000. * The characters in the string are all ASCII characters. Implement your solution ensuring that it efficiently computes the length of the longest common subsequence using a dynamic programming approach. ```python def longest_common_subsequence(str1: str, str2: str) -> int: m = len(str1) n = len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # Example usage: str1 = \\"ABCDGH\\" str2 = \\"AEDFHR\\" print(longest_common_subsequence(str1, str2)) # Output: 3 ``` End of Question 2.","solution":"def longest_common_subsequence(str1: str, str2: str) -> int: Returns the length of the longest common subsequence between str1 and str2. m = len(str1) n = len(str2) # Create a 2D DP array with all zeroes dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The last cell of dp will have the length of the longest common subsequence return dp[m][n]"},{"question":"# Problem Statement You are given a list of integers. Implement a function `count_inversions(arr)` that returns the number of inversions required to sort the list in non-decreasing order. An inversion is a pair of indices `(i, j)` such that `i < j` and `arr[i] > arr[j]`. Function Signature ```python def count_inversions(arr: list[int]) -> int: pass ``` Input Parameters * `arr` (list[int]): A list of integers. Output * Returns an integer representing the number of inversions required to sort the list. # Constraints * The length of `arr` is between 0 and 10^5. * The elements of `arr` are within the range of [-10^9, 10^9]. # Examples ```python assert count_inversions([1, 3, 2, 3, 1]) == 4 assert count_inversions([2, 4, 1, 3, 5]) == 3 assert count_inversions([5, 4, 3, 2, 1]) == 10 assert count_inversions([1, 2, 3, 4, 5]) == 0 assert count_inversions([]) == 0 ``` # Notes * Consider an efficient approach such as merge sort to handle input size up to 10^5 elements and ensure performance within reasonable time limits. * An inversion indicates how far the list is from being sorted. For example, the list `[2, 1]` has one inversion because `2` precedes `1`.","solution":"def count_inversions(arr: list[int]) -> int: if not arr: return 0 def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right) // 2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*len(arr) return merge_sort_and_count(arr, temp_arr, 0, len(arr)-1)"},{"question":"# Coding Challenge Scenario You are developing software for a robotic vacuum cleaner operating within a confined rectangular grid. For efficient path planning, you need to calculate the area of the smallest rectangular region that contains all the dirty spots marked on the grid. Task Implement the function `min_rectangle_area(grid: List[List[int]]) -> int` which computes the area of the smallest rectangle that can enclose all the dirty spots. A dirty spot is represented by a `1` in the grid, while a clean spot is represented by a `0`. # Input and Output - **Input**: A 2D list `grid` of integers where `grid[i][j]` can be either `0` or `1`. - **Output**: An integer representing the area of the smallest rectangle that can enclose all the dirty spots. # Constraints - The dimensions of the grid should be at least (1 times 1). - The grid can contain up to (10^4) elements. # Performance Requirements - Your solution should aim for (O(n times m)) time complexity, where (n) and (m) are the dimensions of the grid, and (O(1)) additional space complexity. # Error Handling - Raise `ValueError` if the grid is empty or contains no dirty spots. - Raise `TypeError` if the grid is not a 2D list of integers. # Examples - Given `grid = [[0, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]`, `min_rectangle_area(grid)` should return `4`. - Given `grid = [[1, 0, 0], [0, 0, 0], [0, 0, 1]]`, `min_rectangle_area(grid)` should return `6`. - Given `grid = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]`, `min_rectangle_area(grid)` should raise `ValueError: No dirty spots in the grid`. # Additional Notes - The grid can contain varying numbers of rows and columns. - Ensure your implementation handles various grid configurations and edge cases effectively.","solution":"from typing import List def min_rectangle_area(grid: List[List[int]]) -> int: Returns the area of the smallest rectangle that contains all the \'1\'s in the grid. if not grid or not all(isinstance(row, list) for row in grid): raise TypeError(\\"The grid should be a 2D list.\\") rows = len(grid) cols = len(grid[0]) for row in grid: if len(row) != cols or not all(isinstance(val, int) for val in row): raise TypeError(\\"The grid should be a 2D list of integers with consistent row lengths.\\") min_row, max_row = rows, -1 min_col, max_col = cols, -1 dirty_spots_found = False for r in range(rows): for c in range(cols): if grid[r][c] == 1: dirty_spots_found = True if r < min_row: min_row = r if r > max_row: max_row = r if c < min_col: min_col = c if c > max_col: max_col = c if not dirty_spots_found: raise ValueError(\\"No dirty spots in the grid.\\") height = max_row - min_row + 1 width = max_col - min_col + 1 return height * width"},{"question":"# Subject: Tree Traversal Algorithms You are tasked with implementing an algorithm to traverse a binary tree and capture its nodes\' values in a specific format. # Description Given a binary tree, you need to traverse the tree and find the sum of values for nodes at each level. The result should be a list where each element represents the sum of the node values at that level. # Binary Tree Node Definition Define a binary tree node class as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Implementation Functions 1. **`level_sum(root: TreeNode) -> List[int]`**: - **Input**: The root node of a binary tree. - **Output**: A list of integers representing the sum of node values at each level of the binary tree. # Function Definition ```python def level_sum(root: TreeNode) -> List[int]: Calculate the sum of values for nodes at each level of the binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: List[int]: A list of sums of node values at each level. pass ``` # Requirements - Implement your solution using Python. - Do not use any external libraries except for the standard `collections` module for managing queues. - Ensure your code handles edge cases, such as an empty tree (where root is None). # Examples ```python # Example 1: Simple binary tree # 1 # / # 2 3 # / / # 4 5 6 # Creating the tree nodes root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.right.left = TreeNode(5) root.right.right = TreeNode(6) print(level_sum(root)) # Should return [1, 5, 15] # Example 2: Binary tree with single node # 7 # Single node tree root = TreeNode(7) print(level_sum(root)) # Should return [7] # Example 3: Empty tree print(level_sum(None)) # Should return [] ``` # Constraints - The number of nodes in the binary tree could be up to 10,000. - Node value ranges from -1000 to 1000. Develop an efficient and clear solution that can handle large trees and various edge cases.","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_sum(root: TreeNode) -> List[int]: if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum) return result"},{"question":"# Array Rotation Write a function `rotate_array` that rotates the elements of an array to the right by a given number of steps. When rotating the array, elements that are shifted beyond the last position should wrap around to the start of the array. Input * A list of integers `arr` representing the array to be rotated. * An integer `steps` which indicates the number of steps to rotate the array. Output * A list of integers representing the rotated array. Constraints - (0 leq text{len(arr)} leq 10^5) - (0 leq text{steps} leq 10^5) # Example ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([], 3) [] >>> rotate_array([10, 20], 1) [20, 10] ``` # Notes - If the number of steps is greater than the length of the array, the function should handle it appropriately (e.g., rotating by 7 steps in an array of length 5 is equivalent to rotating by 2 steps).","solution":"def rotate_array(arr, steps): Rotates the elements of an array to the right by a given number of steps. if not arr: return arr n = len(arr) steps = steps % n # Reduce the steps to a value within the array length return arr[-steps:] + arr[:-steps]"},{"question":"# Context You are working on a file system utility tool that needs to provide information about the directory structure. The tool is supposed to list all the files in a given directory and its subdirectories, recursively. Additionally, it should compute the total number of files and the combined size of all these files. This utility will help in analyzing disk usage and managing storage space efficiently. # Task Write a Python function that takes the path to a directory and returns the following details: 1. A list of all file paths within the given directory and its subdirectories. 2. The total number of files. 3. The combined size of all the files (in bytes). # Function Signature ```python def analyze_directory(path: str) -> dict[str, list | int]: pass ``` # Input - `path` (str): The file path to the target directory. # Output A dictionary with the following keys and values: - `\\"files\\"` (list of str): List of file paths found within the directory and its subdirectories. - `\\"total_files\\"` (int): Total number of files discovered. - `\\"total_size\\"` (int): Combined size of all the files in bytes. # Constraints - The input `path` will be a valid directory path. - The directory may contain a large number of files and subdirectories, so the function should handle this efficiently. # Example ```python path = \\"/example_directory\\" # Assuming the example_directory contains the following structure: # /example_directory # ├── file1.txt (size: 100 bytes) # └── subdir # ├── file2.txt (size: 200 bytes) # └── file3.txt (size: 300 bytes) expected_output = { \\"files\\": [\\"/example_directory/file1.txt\\", \\"/example_directory/subdir/file2.txt\\", \\"/example_directory/subdir/file3.txt\\"], \\"total_files\\": 3, \\"total_size\\": 600 } assert analyze_directory(path) == expected_output ```","solution":"import os def analyze_directory(path: str) -> dict[str, list | int]: Analyzes the directory structure and returns the list of file paths, total number of files, and the combined size of all files in the directory and its subdirectories. Parameters: - path (str): The file path to the target directory. Returns: dict[str, list | int]: A dictionary containing: - \\"files\\" (list of str): List of file paths found within the directory and its subdirectories. - \\"total_files\\" (int): Total number of files discovered. - \\"total_size\\" (int): Combined size of all the files in bytes. all_files = [] total_size = 0 for root, dirs, files in os.walk(path): for file in files: file_path = os.path.join(root, file) all_files.append(file_path) total_size += os.path.getsize(file_path) return { \\"files\\": all_files, \\"total_files\\": len(all_files), \\"total_size\\": total_size }"},{"question":"**Problem Statement**: You are tasked with implementing a simple mathematical expression evaluator that supports basic arithmetic operations and maintains a history of all evaluated expressions. This evaluator should be able to handle integers and basic binary operations: addition, subtraction, multiplication, and division. # Features to Implement: 1. **Evaluate Expression**: - Method: `evaluate(expression: str) -> int` - Description: Evaluates the given arithmetic expression string and returns the result as an integer. The expression may contain positive and negative integers, and the operators `+`, `-`, `*`, and `/`. Division should be integer division. Raise a `ValueError` if the expression is invalid. 2. **Get History**: - Method: `get_history() -> List[str]` - Description: Returns a list of all evaluated expressions in the order they were evaluated, each expression formatted as \\"`expression = result`\\". 3. **Clear History**: - Method: `clear_history() -> None` - Description: Clears the evaluation history. # Constraints: - The input expression will be a properly formatted string without any spaces. - Division by zero should raise a `ZeroDivisionError`. - The expression will not contain parentheses and should be evaluated using the standard operator precedence. # Example: ```python # Example Usage evaluator = ExpressionEvaluator() assert evaluator.evaluate(\\"3+5*6-4/2\\") == 31 assert evaluator.evaluate(\\"10-3*2\\") == 4 evaluator.evaluate(\\"-7+8/4\\") # Raises ValueError for invalid input assert evaluator.get_history() == [\\"3+5*6-4/2 = 31\\", \\"10-3*2 = 4\\"] evaluator.clear_history() assert evaluator.get_history() == [] ``` Implement the `ExpressionEvaluator` class, ensuring it correctly evaluates expressions, maintains a history, and handles all specified edge cases.","solution":"import re from typing import List class ExpressionEvaluator: def __init__(self): self.history = [] def evaluate(self, expression: str) -> int: # Check for invalid characters in the expression if not re.match(r\'^[0-9+-*/]+\', expression): raise ValueError(\\"Invalid expression\\") try: # Evaluate the expression using Python\'s eval with integer division result = eval(expression.replace(\\"/\\", \\"//\\")) except ZeroDivisionError: raise ZeroDivisionError(\\"Division by zero\\") except SyntaxError: raise ValueError(\\"Invalid expression\\") # Append to history self.history.append(f\\"{expression} = {result}\\") return result def get_history(self) -> List[str]: return self.history def clear_history(self) -> None: self.history = []"},{"question":"# Optimal Delivery Routes You are given a list of delivery locations represented as coordinates in a 2D plane. The delivery driver starts at the origin (0, 0) and must deliver packages to all the given locations, one package per location. Your goal is to find an optimal route such that the driver makes the minimum total distance traveled visiting each location exactly once. Function Signature ```python def find_optimal_route(locations: list[tuple[int, int]]) -> list[tuple[int, int]]: ``` Input: - `locations`: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a delivery location. Output: - A list of tuples representing the optimal order of locations to visit. Constraints: - `1 <= len(locations) <= 10^4` - `-10^6 <= x, y <= 10^6` Performance Requirements: Your implementation should aim to provide a good, although not necessarily optimal, solution in a reasonable time for the input size. Example: ```python >>> locations = [(1, 2), (4, 6), (3, 1), (6, 5)] >>> find_optimal_route(locations) [(1, 2), (3, 1), (4, 6), (6, 5)] >>> locations = [(2, 3), (-1, -5), (7, 8), (3, 3)] >>> find_optimal_route(locations) [(2, 3), (3, 3), (7, 8), (-1, -5)] ``` Explanation: For the first example: - The provided locations are [(1, 2), (4, 6), (3, 1), (6, 5)]. A possible optimal route that minimizes the total travel distance could be [(1, 2), (3, 1), (4, 6), (6, 5)], assuming the driver starts at the origin (0, 0). For the second example: - The provided locations are [(2, 3), (-1, -5), (7, 8), (3, 3)]. A possible optimal route that minimizes the total travel distance could be [(2, 3), (3, 3), (7, 8), (-1, -5)], assuming the driver starts at the origin (0, 0). Note: The function should attempt to implement a heuristic approach to find a reasonably short route, such as the nearest neighbor algorithm or a greedy approach.","solution":"def find_optimal_route(locations): Returns the approximate optimal route for the given locations using a heuristic approach like the nearest neighbor. import math def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) if not locations: return [] # Start from the origin current_location = (0, 0) unvisited_locations = set(locations) route = [] while unvisited_locations: next_location = min(unvisited_locations, key=lambda loc: distance(current_location, loc)) route.append(next_location) unvisited_locations.remove(next_location) current_location = next_location return route"},{"question":"# Meeting Scheduler with Constraints Scenario You are to implement a meeting scheduler for a team of employees. Each employee has a list of available time slots for a given day. Your task is to find a common time slot of a specified duration where all employees are available. Objective Implement the `MeetingScheduler` class with a function to find a common time slot for a meeting. Requirements 1. **Input**: - A dictionary `availability` where each key is an employee ID (an integer) and its value is a list of tuples representing available time slots (start time, end time) in 24-hour format. - An integer `duration` representing the desired duration of the meeting in minutes. 2. **Output**: - A tuple representing the start and end time of the common available slot in 24-hour format, or `None` if no common slot exists. 3. **Constraints**: - The time slots will be within a single day, denoted in 24-hour format (e.g., `9:00` is `9` and `14:30` is `14.5`). - The duration will not exceed the length of any available slot for any employee. - The total number of employees ranges from `2` to `100`. 4. **Performance**: - The solution should efficiently handle cases with a large number of employees and multiple available time slots for each of them. Function Signature ```python class MeetingScheduler: def __init__(self, availability: dict[int, list[tuple[float, float]]], duration: int): # initialization code def find_common_slot(self) -> tuple[float, float] | None: # code to find common available slot ``` Hints - Convert time into a continuous scale (e.g., decimal hours) for easy comparison. - Consider sorting the time slots and using a two-pointer technique or merging intervals for efficiency. - Ensure that overlapping time slots among employees are properly handled. Example ```python availability = { 1: [(9, 12), (13, 17)], 2: [(10, 11), (13, 16)], 3: [(11, 14), (15, 18)] } duration = 60 scheduler = MeetingScheduler(availability, duration) common_slot = scheduler.find_common_slot() print(common_slot) # Expected output: (13.0, 14.0) if a common slot exists ``` --- Compose the solution to match the structure, tone, and complexity of the original question, aligning with the given guidelines.","solution":"class MeetingScheduler: def __init__(self, availability: dict[int, list[tuple[float, float]]], duration: int): self.availability = availability self.duration = duration def find_common_slot(self) -> tuple[float, float] | None: # Helper function to check if two intervals overlap def does_overlap(interval1, interval2): return max(interval1[0], interval2[0]) < min(interval1[1], interval2[1]) # Helper function to find the intersection of two intervals def intersection(interval1, interval2): if does_overlap(interval1, interval2): return (max(interval1[0], interval2[0]), min(interval1[1], interval2[1])) return None # Start with the time slots of the first employee common_slots = self.availability[next(iter(self.availability))] # Intersect with the time slots of each subsequent employee for employee_id, slots in self.availability.items(): new_common_slots = [] for common_slot in common_slots: for slot in slots: intersected = intersection(common_slot, slot) if intersected and (intersected[1] - intersected[0]) >= self.duration / 60.0: new_common_slots.append(intersected) common_slots = new_common_slots if not common_slots: return None # Return the first common slot that satisfies the duration requirement for slot in common_slots: if (slot[1] - slot[0]) >= self.duration / 60.0: return (slot[0], slot[0] + self.duration / 60.0) return None"},{"question":"Problem Statement You are given a list of integers. Your task is to implement a function that finds the missing number in the list. The list contains integers from 1 to `n` without any repetition, but one number within this range is missing. Determine that missing number. # Function Signature ```python def find_missing_number(nums: List[int]) -> int: ``` # Input - `nums` (1 ≤ len(nums) ≤ 10^5): A list of integers containing unique elements from 1 to `n` except one missing number. # Output - An integer representing the missing number in the range from 1 to `n`. # Constraints - The elements of `nums` are distinct integers in the range from 1 to `n`. - The list is missing exactly one number in this range. # Performance Requirements - The function should complete within a reasonable time frame, even for the upper limit of the list length. # Example ```python find_missing_number(nums=[1, 2, 4, 6, 3, 7, 8]) # Expected output: 5, since the complete list from 1 to 8 should be [1, 2, 3, 4, 5, 6, 7, 8] and 5 is missing. find_missing_number(nums=[1, 2, 3, 5]) # Expected output: 4, as the complete list from 1 to 5 should be [1, 2, 3, 4, 5] and 4 is missing. ``` Implement the function `find_missing_number` to accurately determine the missing integer in the given list.","solution":"from typing import List def find_missing_number(nums: List[int]) -> int: Finds the missing number in the list of integers from 1 to n. :param nums: List of integers containing unique elements from 1 to n except one missing number. :return: The missing number in the range from 1 to n. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"# Coding Challenge: Balanced Parentheses Conversion Problem Statement You are given a text file containing a list of strings, where each string consists solely of parentheses `(` and `)`. Your task is to determine how many operations are required to convert each string into a balanced parentheses string. Each operation can either be: - Insert a parenthesis at any position. - Delete a parenthesis at any position. - Replace a parenthesis at any position with the other type (i.e., `(` becomes `)`, or `)` becomes `(`). Write a function `minimum_operations_to_balance(s: str) -> int` that computes the minimum number of operations required to make a string of parentheses balanced. Use this function within a main function `compute_total_operations(filename: str) -> int` that reads the strings from a file and returns the sum of the minimum operations required for each string to become balanced. Specifications - **Input**: A string `filename`, which is the path to the file containing strings of parentheses (one per line). - **Output**: An integer representing the total number of operations needed to balance all strings in the file. Constraints - The length of each string will not exceed 1000 characters. - An empty string is considered balanced and requires 0 operations. Example Consider a file named `parentheses.txt` with the following contents: ``` ())))( ()()( ((()) ) ``` Calling `compute_total_operations(\'parentheses.txt\')` should return `6`, since: - `())))` requires 2 insert operations to become balanced. - `()()(` requires 1 insert operation to become balanced. - `((())` requires 1 insert operation to become balanced. - `)` requires 2 insert operations to become balanced. Total operations = 2 + 1 + 1 + 2 = 6. Function Signatures ```python def minimum_operations_to_balance(s: str) -> int: pass def compute_total_operations(filename: str) -> int: pass ``` **Note**: Ensure your solution handles all edge cases and optimizes for performance where possible.","solution":"def minimum_operations_to_balance(s: str) -> int: open_count = 0 close_count = 0 for char in s: if char == \'(\': open_count += 1 elif char == \')\': if open_count > 0: open_count -= 1 else: close_count += 1 return open_count + close_count def compute_total_operations(filename: str) -> int: total_operations = 0 with open(filename, \'r\') as file: for line in file: line = line.strip() total_operations += minimum_operations_to_balance(line) return total_operations"},{"question":"# Student Grade Calculator **Context**: As a teacher, you need to calculate the final grades for your students based on their scores across different subjects. Each student has scores for multiple subjects, and you need to compute their average score and assign a corresponding grade based on the average. **Task**: Write a Python function named `calculate_grades(students: dict) -> dict:` that performs the following tasks: 1. Accepts a dictionary where each key is a student\'s name and the value is another dictionary of subject-score pairs. 2. Computes the average score for each student. 3. Assigns a grade based on the average score using the following criteria: - 90 <= average <= 100: Grade \\"A\\" - 80 <= average < 90: Grade \\"B\\" - 70 <= average < 80: Grade \\"C\\" - 60 <= average < 70: Grade \\"D\\" - average < 60: Grade \\"F\\" 4. Returns a dictionary with the students\' names as keys and their final grades as values. **Constraints**: - Assume each student has at least one subject score. - All scores are between 0 and 100. - Handle the case where the dictionary is empty gracefully. **Input**: - `students` (dict): A dictionary containing students\' names and their subject-score pairs. ```python { \\"Alice\\": {\\"Math\\": 85, \\"English\\": 78, \\"Science\\": 92}, \\"Bob\\": {\\"Math\\": 75, \\"English\\": 68, \\"History\\": 80}, ... } ``` **Output**: - `dict`: A dictionary containing students\' names and their corresponding grades. ```python { \\"Alice\\": \\"B\\", \\"Bob\\": \\"C\\", ... } ``` **Example**: Given the following input: ```python students = { \\"Alice\\": {\\"Math\\": 85, \\"English\\": 78, \\"Science\\": 92}, \\"Bob\\": {\\"Math\\": 75, \\"English\\": 68, \\"History\\": 80} } ``` The function should return: ```python { \\"Alice\\": \\"B\\", \\"Bob\\": \\"C\\" } ``` # Instructions: 1. Iterate over each student in the input dictionary. 2. Compute the average score for each student based on their scores across all subjects. 3. Determine the grade based on the computed average using the predefined criteria. 4. Return the final grades in a dictionary format as specified.","solution":"def calculate_grades(students: dict) -> dict: def get_grade(average): if 90 <= average <= 100: return \\"A\\" elif 80 <= average < 90: return \\"B\\" elif 70 <= average < 80: return \\"C\\" elif 60 <= average < 70: return \\"D\\" else: return \\"F\\" final_grades = {} for student, subjects in students.items(): if subjects: average = sum(subjects.values()) / len(subjects) final_grades[student] = get_grade(average) return final_grades"},{"question":"# Coding Assessment Question Problem Statement Given an integer `n`, your task is to implement a function `generate_factors(n: int) -> List[int]` that returns a list of all unique positive factors of `n` (excluding `1` and `n` itself). A **factor** of a number `n` is an integer `m` such that `n % m == 0`. Your solution should handle edge cases appropriately and return an empty list if no factors are found excluding `1` and `n`. Requirements 1. Adhere to the input-output format described. 2. Consider the performance of your solution. Aim for a solution with time complexity O(sqrt(n)). 3. Handle edge cases like when `n` is zero or a prime number. 4. Ensure the list of factors is sorted in ascending order. Constraints * `n` is an integer and satisfies (-10^9 le n le 10^9). * Exclude `1` and `n` as factors. Input * An integer `n`. Output * A list of integers representing the factors of `n`, sorted in ascending order. # Examples ```python >>> generate_factors(-1) [] >>> generate_factors(0) [] >>> generate_factors(1) [] >>> generate_factors(10) [2, 5] >>> generate_factors(28) [2, 4, 7, 14] >>> generate_factors(13) [] >>> generate_factors(50) [2, 5, 10, 25] >>> generate_factors(100) [2, 4, 5, 10, 20, 25, 50] ``` Implementation Template ```python def generate_factors(n: int) -> List[int]]: pass # You can add additional functions if required. if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import List def generate_factors(n: int) -> List[int]: if n == 0: return [] n = abs(n) factors = [] for i in range(2, int(n**0.5) + 1): if n % i == 0: factors.append(i) if i != n // i: # Avoid adding the square root twice in case of perfect squares factors.append(n // i) return sorted(factors)"},{"question":"# Coding Question: Efficient Cargo Container Loading Algorithm **Context**: Bob is working on a logistics management system that optimizes the loading of cargo containers onto ships. Each container has a specified weight, and the ship has a maximum weight capacity it can hold. Bob needs an algorithm that determines the maximum weight that can be achieved without exceeding the ship\'s capacity. **Objective**: Your task is to implement the `CargoLoader` class that accurately finds the maximum weight that can be loaded onto the ship using a dynamic programming approach. **Function to Implement**: You need to implement the `CargoLoader` class with the following method: ```python class CargoLoader: def __init__(self, container_weights: list[int], capacity: int): # Initialize method with the list of container weights and the ship\'s capacity. pass def max_loading_weight(self) -> int: # Method to find the maximum weight that can be loaded onto the ship without exceeding its capacity. pass ``` **Input Format**: - The constructor `__init__` receives two parameters: - A list of integers `container_weights` representing the weights of the containers. - An integer `capacity` representing the maximum weight capacity of the ship. - Example: `container_weights = [2, 5, 3, 8, 4]` and `capacity = 10` - The `max_loading_weight` method does not receive any parameters. **Output Format**: - The `max_loading_weight` method should return an integer, the maximum weight that can be loaded onto the ship. - Example: `9` **Constraints**: - The number of containers can be up to 1000. - The weight of each container will be a non-negative integer. - The ship\'s capacity will be a non-negative integer. - Assume all weights and capacities are integers. **Performance Requirements**: - The solution must efficiently handle large inputs, optimizing both time and space complexity. **Example**: Given the following: ```python container_weights = [2, 5, 3, 8, 4] capacity = 10 ``` Output: - The maximum weight that can be loaded without exceeding the ship\'s capacity is: `9` Write your implementation in the class provided to correctly determine the maximum loading weight using dynamic programming.","solution":"class CargoLoader: def __init__(self, container_weights: list[int], capacity: int): self.container_weights = container_weights self.capacity = capacity def max_loading_weight(self) -> int: # Initialize a list to store maximum weight attainable for each capacity from 0 to self.capacity dp = [0] * (self.capacity + 1) # Iterate over each container weight for weight in self.container_weights: # Traverse dp array from back to front for c in range(self.capacity, weight - 1, -1): dp[c] = max(dp[c], dp[c - weight] + weight) return dp[self.capacity]"},{"question":"# Coding Assessment Question Context: Sorting algorithms are fundamental to computer science and programming. One interesting challenge involves sorting matrix rows based on the sum of their elements. This type of sorting can be useful in data processing, image manipulation, and various other applications. Problem Statement: Given an ( M times N ) matrix, sort the rows of the matrix in ascending order based on the sum of their elements. If two rows have the same sum, maintain their original relative order. Guidelines: 1. Write a function `sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]` that takes a matrix as input and returns a new matrix with rows sorted by the sum of their elements. 2. Ensure the original relative order of rows with the same sum is preserved (i.e., this is a stable sort). 3. Do not modify the input matrix. 4. Handle edge cases such as an empty matrix or matrix with rows of varying lengths. Input Format: - A list of lists where each inner list represents a row in the matrix. - The matrix will have at least 1 row and each row will have at least 1 element. Output Format: - A new list of lists representing the sorted matrix. Example: Input: ```python matrix = [ [3, 1, 2], [1, 2, 3], [3, 3, 3], [1, 1, 1] ] ``` Output: ```python [ [1, 1, 1], [3, 1, 2], [1, 2, 3], [3, 3, 3] ] ``` Constraints: - The matrix will have ( 1 leq M leq 1000 ) rows. - Each row will have ( 1 leq N leq 1000 ) elements. - All elements are integers in the range (-10^6) to (10^6). Function Signature: ```python from typing import List def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: pass ``` Performance Requirements: - The solution should handle the sorting operation efficiently, even for the largest possible matrices.","solution":"from typing import List def sort_matrix_rows(matrix: List[List[int]]) -> List[List[int]]: Sort the rows of the matrix in ascending order based on the sum of their elements. return sorted(matrix, key=sum)"},{"question":"# Coding Assessment Question Context In this exercise, you will work with strings and text processing to find patterns and perform transformations. This type of problem is common in tasks involving text parsing, pattern matching, and data extraction. Problem Statement Write a function `compress_repeating_chars(s: str) -> str` that takes a string `s` and returns a new string where consecutive repeating characters are compressed into a single character followed by the count of its repetitions. If a character does not repeat, it should appear in the result as it is. Constraints * The input string `s` will contain only alphanumeric characters and be non-empty. * The maximum length of `s` will be 10,000 characters. Input * A single string `s`. Output * A compressed string according to the described rules. Examples * `compress_repeating_chars(\\"aaabccdddd\\")` should return `\\"a3bc2d4\\"`. * `compress_repeating_chars(\\"abcd\\")` should return `\\"abcd\\"`. * `compress_repeating_chars(\\"zzzzyy\\")` should return `\\"z4y2\\"`. Function Signature ```python def compress_repeating_chars(s: str) -> str: pass ``` Requirements * Ensure efficient processing, even for strings of the maximum length. * Handle edge cases, such as strings with no repeating characters, strings with all repeating characters, and strings with mixed patterns of repetitions. * Include appropriate test cases to verify the correctness of your implementation.","solution":"def compress_repeating_chars(s: str) -> str: Compresses consecutive repeating characters in the string `s`. Parameters: s (str): Input string containing alphanumeric characters. Returns: str: A new string with consecutive repeating characters replaced by the single character followed by the count of repetitions. if not s: return \\"\\" compressed_string = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed_string.append(s[i - 1]) if count > 1: compressed_string.append(str(count)) count = 1 # Handle the last group of characters compressed_string.append(s[-1]) if count > 1: compressed_string.append(str(count)) return \\"\\".join(compressed_string)"},{"question":"# Data Preprocessing for Stock Price Prediction Description You are building a machine learning model to predict stock prices, and you need to preprocess the data for training. The preprocessing steps involve handling missing values, scaling features, and generating sequences of time-series data for model input. Task Implement the `preprocess_stock_data` function to handle the preprocessing tasks described. The input data contains timestamps, stock prices, and additional features. Your function should: 1. Fill in any missing values using forward fill. 2. Scale the prices and features to fit within a specific range using Min-Max scaling. 3. Generate sequences of input data for the model to use, consisting of a specified number of past time steps for prediction. Function Signature ```python def preprocess_stock_data( data: pd.DataFrame, n_steps: int, feature_range: tuple[float, float] = (0, 1) ) -> tuple[np.ndarray, np.ndarray]: pass ``` Input - `data (pd.DataFrame)`: A DataFrame containing timestamped stock prices and other features. The first column is the \'Date\', containing timestamps. The second column is \'Price\', and the subsequent columns are additional features. - `n_steps (int)`: The number of past time steps to include in each input sequence for the model. - `feature_range (tuple[float, float])`: A tuple specifying the desired range for scaling features. Output - `tuple[np.ndarray, np.ndarray]`: A tuple containing two numpy arrays: - `X`: The preprocessed input sequences with shape (num_samples, n_steps, num_features). - `y`: The target prices corresponding to each input sequence with shape (num_samples,). Constraints - Ensure that missing values in the data are filled using the forward fill method. - Apply Min-Max scaling to normalize the prices and features to the specified feature range. - Generate sequences of historical data points for input into the model, based on the specified number of past time steps. Example ```python import pandas as pd import numpy as np data_dict = { \\"Date\\": [\\"2023-01-01\\", \\"2023-01-02\\", \\"2023-01-03\\", \\"2023-01-04\\", \\"2023-01-05\\"], \\"Price\\": [100.0, 101.5, np.nan, 103.0, 104.5], \\"Feature1\\": [1.2, 1.3, 1.4, 1.5, 1.6], \\"Feature2\\": [0.9, 0.8, 0.7, 0.6, 0.5] } data = pd.DataFrame(data_dict) n_steps = 3 feature_range = (0, 1) # Call the function X, y = preprocess_stock_data(data, n_steps, feature_range) # X will be the input sequences with shape (num_samples, n_steps, num_features) # y will be the target prices corresponding to each input sequence with shape (num_samples,) ``` Implement the logic to handle missing values, scale the data, and generate sequences for model training. Ensure the returned sequences and target values are correctly aligned. Write the `preprocess_stock_data` function to achieve the above task.","solution":"import pandas as pd import numpy as np from sklearn.preprocessing import MinMaxScaler def preprocess_stock_data(data: pd.DataFrame, n_steps: int, feature_range: tuple[float, float] = (0, 1)) -> tuple[np.ndarray, np.ndarray]: Preprocess stock data for machine learning models. Parameters: data (pd.DataFrame): A DataFrame containing timestamped stock prices and other features. n_steps (int): The number of past time steps to include in each input sequence for the model. feature_range (tuple[float, float]): A tuple specifying the desired range for scaling features. Returns: tuple[np.ndarray, np.ndarray]: A tuple containing the preprocessed input sequences and target prices. # Fill missing values using forward fill data = data.ffill() # Separate features and target features = data.iloc[:, 1:] # Apply Min-Max scaling scaler = MinMaxScaler(feature_range=feature_range) scaled_features = scaler.fit_transform(features) # Generate sequences of data for model input X, y = [], [] for i in range(len(scaled_features) - n_steps): X.append(scaled_features[i:i + n_steps]) y.append(scaled_features[i + n_steps - 1, 0]) # Target is the price at the end of the sequence # Convert lists to numpy arrays X = np.array(X) y = np.array(y) return X, y"},{"question":"# Max Profit with Cooldown **Problem Statement**: You are asked to implement a function that calculates the maximum profit you can achieve from buying and selling stocks over multiple days, given the constraint that after selling a stock, you must wait for one day before buying again. Your task is to write a function `max_profit_with_cooldown` that takes a list of prices and returns the maximum profit. **Function Signature**: ```python def max_profit_with_cooldown(prices: List[int]) -> int: pass ``` **Requirements**: 1. The function should handle the transaction with a cooldown period of one day between a sell and a new buy. 2. You can determine the best strategy to buy and sell to maximize the profit, keeping the cooldown constraint in mind. 3. If the list is empty, the function should return 0. **Input**: * `prices` (List[int]): A list of integers representing the stock prices on different days. **Output**: * `int`: The maximum profit that can be obtained with the cooldown rule. **Constraints**: * The length of the list `prices` can be up to 5000. * Each price will be a positive integer. **Examples**: ```python >>> max_profit_with_cooldown([1, 2, 3, 0, 2]) 3 # Buy on day 0, sell on day 2, cooldown on day 3, buy on day 4, sell on day 5, profit = 3 >>> max_profit_with_cooldown([1, 2, 4]) 3 # Buy on day 0, sell on day 2, profit = 3 >>> max_profit_with_cooldown([]) 0 # No transactions, profit = 0 >>> max_profit_with_cooldown([1]) 0 # Only one day, no transactions possible, profit = 0 ``` **Note**: - The optimal strategy must consider not only when to buy and sell but also the required cooldown period after a sale.","solution":"def max_profit_with_cooldown(prices): Returns the maximum profit that can be achieved by buying and selling stocks with a cooldown period of one day. if not prices: return 0 n = len(prices) if n == 1: return 0 # Define the dp arrays sell = [0] * n buy = [0] * n cooldown = [0] * n # Initialize the first day values buy[0] = -prices[0] sell[0] = 0 cooldown[0] = 0 for i in range(1, n): buy[i] = max(buy[i-1], cooldown[i-1] - prices[i]) sell[i] = max(sell[i-1], buy[i-1] + prices[i]) cooldown[i] = max(cooldown[i-1], sell[i-1]) return max(sell[n-1], cooldown[n-1])"},{"question":"# Problem Statement You have been tasked with developing a Python function for an inventory management system used in a warehouse. One of the critical functions of this system is to update the inventory quantities whenever a shipment is received or dispatched. Each operation can either add to the existing inventory or subtract from it. Your task is to implement a function that takes in a list of operations and their corresponding quantities and updates the inventory accordingly. Each operation can either be \\"add\\" or \\"remove\\", and the quantities will be positive integers. The function should take a list of operations where each operation is represented as a tuple containing a string (\\"add\\" or \\"remove\\") and an integer (the quantity). The function should return the final state of the inventory after applying all the operations. Function Signature ```python def update_inventory(operations: list[tuple[str, int]]) -> int: Update the inventory based on the given operations. Args: operations (list): A list of operations, where each operation is a tuple containing a string (either \\"add\\" or \\"remove\\") and a positive integer (quantity). Returns: int: The final state of the inventory after applying all operations. Example: >>> update_inventory([(\\"add\\", 10), (\\"remove\\", 3), (\\"add\\", 5)]) 12 pass ``` # Constraints: * The operations list will contain at least one operation. * Each operation in the list is a tuple with the first element being either \\"add\\" or \\"remove\\". * The integer in each tuple is a positive integer. # Requirements: * The function should correctly update the inventory based on the operations. * If a \\"remove\\" operation results in negative inventory, set the inventory to zero instead. * Consider edge cases, such as multiple consecutive \\"add\\" or \\"remove\\" operations. # Example: ```python >>> update_inventory([(\\"add\\", 10), (\\"remove\\", 3), (\\"add\\", 5)]) 12 >>> update_inventory([(\\"add\\", 5), (\\"remove\\", 10)]) 0 ``` # Performance: * Aim for a concise and efficient solution capable of handling a moderately large list of operations.","solution":"def update_inventory(operations: list[tuple[str, int]]) -> int: Update the inventory based on the given operations. Args: operations (list): A list of operations, where each operation is a tuple containing a string (either \\"add\\" or \\"remove\\") and a positive integer (quantity). Returns: int: The final state of the inventory after applying all operations. inventory = 0 for operation, quantity in operations: if operation == \\"add\\": inventory += quantity elif operation == \\"remove\\": inventory -= quantity if inventory < 0: inventory = 0 return inventory"},{"question":"# Question: You are given a series of daily stock prices followed by an interval `k`, which represents the number of days an investor is willing to hold the stock. The objective is to determine the maximum profit that can be achieved by buying on one day and selling within the next `k` days. If no profit can be made, return 0. The function should handle large inputs efficiently. **Function Signature**: ```python def max_profit_within_k_days(prices: List[int], k: int) -> int: Calculates the maximum possible profit by buying and selling the stock within the given `k` days. :param prices: A list of integers representing daily stock prices. :param k: An integer representing the number of days you are willing to hold the stock. :return: An integer representing the maximum profit that can be achieved. Example: >>> prices = [5, 11, 3, 50, 60, 90] >>> k = 3 >>> max_profit_within_k_days(prices, k) 57 Constraints: - 1 <= len(prices) <= 10^5 - 1 <= prices[i] <= 10^6 for any valid index i. - 1 <= k <= len(prices) ``` **Requirements**: 1. Utilize an efficient algorithm to handle large input sizes (up to a maximum of 100,000 prices). 2. The function should handle edge cases (e.g., very small `k`, prices in descending order). 3. Aim for an overall time complexity of O(n), where n is the number of days (length of the prices list). **Example**: ```python >>> prices = [2, 4, 1, 7, 5, 9, 3] >>> k = 2 >>> print(max_profit_within_k_days(prices, k)) 6 >>> prices = [10, 7, 5, 8, 11, 9] >>> k = 3 >>> print(max_profit_within_k_days(prices, k)) 6 ```","solution":"from typing import List from collections import deque def max_profit_within_k_days(prices: List[int], k: int) -> int: Calculates the maximum possible profit by buying and selling the stock within the given `k` days. :param prices: A list of integers representing daily stock prices. :param k: An integer representing the number of days you are willing to hold the stock. :return: An integer representing the maximum profit that can be achieved. if not prices or k <= 0: return 0 max_profit = 0 min_deque = deque() for i in range(len(prices)): # Remove indices that are out of the current window of size k if min_deque and min_deque[0] < i - k: min_deque.popleft() # Maintain min_deque such that it stores the indices of the increasing order of prices while min_deque and prices[min_deque[-1]] >= prices[i]: min_deque.pop() min_deque.append(i) if i >= k: max_profit = max(max_profit, prices[i] - prices[min_deque[0]]) return max_profit"},{"question":"# Task Implement a function `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]` to merge two already sorted arrays into a single sorted array. # Input - Two lists of integers `arr1` and `arr2`, each already sorted in non-decreasing order. - The combined number of elements in the two arrays will not exceed 10^6. # Output - Return a list of integers representing the merged sorted array. # Constraints - The function should be efficient with O(n + m) time complexity, where n and m are the lengths of `arr1` and `arr2`, respectively. - The function should use O(1) additional space, aside from the output list. # Example ```python >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([0, 1, 2], [3, 4, 5]) [0, 1, 2, 3, 4, 5] >>> merge_sorted_arrays([5, 6, 7], [1, 2, 3]) [1, 2, 3, 5, 6, 7] >>> merge_sorted_arrays([], [1, 2, 3, 4]) [1, 2, 3, 4] >>> merge_sorted_arrays([1, 2, 3, 4], []) [1, 2, 3, 4] ``` # Notes - You should avoid using any built-in sorting functions for merging. - Consider edge cases where one or both input arrays might be empty. - Ensure the merged array maintains the non-decreasing order from the input arrays.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array in non-decreasing order. :param arr1: List[int] - First sorted list of integers. :param arr2: List[int] - Second sorted list of integers. :return: List[int] - Merged sorted list of integers. i, j = 0, 0 merged_array = [] # Iterate over both arrays and merge while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # If there are remaining elements in arr1, add them to the merged array while i < len(arr1): merged_array.append(arr1[i]) i += 1 # If there are remaining elements in arr2, add them to the merged array while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Problem Statement Create a software to solve a classic problem in image processing called the \\"Flood Fill\\" or \\"Paint Fill\\" problem. This problem involves filling a connected region of a 2D array with a single color. # Requirements Implement a Python function `flood_fill` that takes three parameters: 1. `image: List[List[int]]` representing a 2D array where each element is an integer representing a pixel color. 2. `sr: int` representing the starting row index. 3. `sc: int` representing the starting column index. 4. `new_color: int` representing the new color to be applied. The function should: 1. Replace the color of the starting pixel and all connected pixels of the same color as the starting pixel with the `new_color`. 2. Return the modified `image`. # Constraints * The dimensions of the image are as follows: * 1 ≤ len(image), len(image[0]) ≤ 50 * Each color is represented by an integer between 0 and 255. * `0 ≤ sr < len(image)`, `0 ≤ sc < len(image[0])` * The starting pixel\'s original color should not be the same as the `new_color` to avoid infinite loops. # Input and Output Formats * **Input**: * `image: List[List[int]]`: A 2D list of integers representing the pixel values. * `sr: int`: Starting row index. * `sc: int`: Starting column index. * `new_color: int`: The new color to apply to the specified region. * **Output**: * `List[List[int]]`: The modified 2D list after performing the flood fill. # Example ```python def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: # Your implementation here # Example usage image = [ [1, 1, 1], [1, 1, 0], [1, 0, 1] ] sr = 1 sc = 1 new_color = 2 result = flood_fill(image, sr, sc, new_color) print(result) # Output should be: # [ # [2, 2, 2], # [2, 2, 0], # [2, 0, 1] # ] ``` # Notes * Use recursive or iterative approaches to traverse neighbor pixels. * Ensure efficient handling of the image to avoid unnecessary performance issues. * Handle edge cases such as border pixels and large regions effectively.","solution":"from typing import List def flood_fill(image: List[List[int]], sr: int, sc: int, new_color: int) -> List[List[int]]: rows, cols = len(image), len(image[0]) original_color = image[sr][sc] if original_color == new_color: return image def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or image[r][c] != original_color: return image[r][c] = new_color dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) dfs(sr, sc) return image"},{"question":"# Problem Statement You are given a string containing numeric digits and possibly some non-numeric characters. Your task is to write a function `sum_of_digits` that calculates the sum of all numeric digits present in the string. If the string does not contain any numeric digits, the function should return 0. # Function Signature ```python def sum_of_digits(s: str) -> int: ``` # Input - `s`: A string containing characters. The length of the string will be between 0 and 10^5 inclusive. # Output - Returns an integer representing the sum of all numeric digits in the string. # Examples ```python assert sum_of_digits(\\"abc123def\\") == 6 assert sum_of_digits(\\"123abc456\\") == 21 assert sum_of_digits(\\"a1b2c3\\") == 6 assert sum_of_digits(\\"abcdef\\") == 0 assert sum_of_digits(\\"\\") == 0 ``` # Constraints & Notes - If the string is empty or does not contain any numeric digits, the result should be 0. - Ensure that the function handles a large string efficiently. - Numeric digits are considered to be characters between \'0\' and \'9\' inclusive.","solution":"def sum_of_digits(s: str) -> int: Returns the sum of all numeric digits in the given string. If there are no numeric digits, returns 0. return sum(int(char) for char in s if char.isdigit())"},{"question":"# Task: File Synchronizer You are developing a utility to synchronize files between two directories. The utility should be capable of identifying newly added, updated, and deleted files and syncing the target directory accordingly. Part 1: File Metadata Create a class `FileMetadata` that: - Represents metadata about a file including: - `filename`: The name of the file (string). - `modified_time`: The last modified time of the file (float, representing Unix timestamp). - `size`: The size of the file in bytes (int). Part 2: Get Directory Snapshot Write a function `get_directory_snapshot(directory_path: str) -> List[FileMetadata]` that: - Takes a string `directory_path` as input, representing the path to the directory. - Returns a list of `FileMetadata` objects representing the files in the specified directory. Part 3: Synchronize Directories Write a function `synchronize_directories(source_snapshot: List[FileMetadata], target_snapshot: List[FileMetadata], source_directory: str, target_directory: str) -> None` that: - Takes two lists of `FileMetadata` (`source_snapshot` and `target_snapshot`) representing the source and target directory snapshots. - Takes two strings representing the paths to the source and target directories. - Synchronizes files from the source directory to the target directory by performing the following actions: - Copy files from the source to the target if they are new or updated. - Delete files from the target that are missing in the source. Constraints: - Assume file copying and deletion can be performed using appropriate library functions. - Both directories are on the same filesystem. - Filenames in both directories are unique. Example Usage ```python # Assuming the following files and their respective metadata # Source Directory (source_directory): # - file1.txt (modified_time: 1625079600.0, size: 100) # - file2.txt (modified_time: 1625166000.0, size: 200) # - file3.txt (modified_time: 1625252400.0, size: 300) # Target Directory (target_directory): # - file1.txt (modified_time: 1625079500.0, size: 100) # older version # - file4.txt (modified_time: 1625338800.0, size: 400) source_snapshot = [ FileMetadata(\'file1.txt\', 1625079600.0, 100), FileMetadata(\'file2.txt\', 1625166000.0, 200), FileMetadata(\'file3.txt\', 1625252400.0, 300), ] target_snapshot = [ FileMetadata(\'file1.txt\', 1625079500.0, 100), FileMetadata(\'file4.txt\', 1625338800.0, 400), ] synchronize_directories(source_snapshot, target_snapshot, \'source_directory\', \'target_directory\') # After synchronization, Target Directory should be: # - file1.txt (copied from source, updated version) # - file2.txt (copied from source) # - file3.txt (copied from source) # - file4.txt (deleted) ``` Requirements - Ensure all files are copied, updated, or deleted as specified. - Handle potential errors related to file operations gracefully. - Maintain the efficiency of synchronization operations. Implement the `FileMetadata` class and the `get_directory_snapshot` and `synchronize_directories` functions in Python.","solution":"import os from typing import List import shutil class FileMetadata: def __init__(self, filename: str, modified_time: float, size: int): self.filename = filename self.modified_time = modified_time self.size = size def get_directory_snapshot(directory_path: str) -> List[FileMetadata]: Returns a snapshot of the given directory in the form of a list of FileMetadata objects. snapshot = [] with os.scandir(directory_path) as entries: for entry in entries: if entry.is_file(): metadata = FileMetadata( filename=entry.name, modified_time=entry.stat().st_mtime, size=entry.stat().st_size ) snapshot.append(metadata) return snapshot def synchronize_directories(source_snapshot: List[FileMetadata], target_snapshot: List[FileMetadata], source_directory: str, target_directory: str) -> None: Synchronizes files from the source directory to the target directory. source_files = {file_meta.filename: file_meta for file_meta in source_snapshot} target_files = {file_meta.filename: file_meta for file_meta in target_snapshot} # Update or add files from source to target for filename, source_meta in source_files.items(): target_meta = target_files.get(filename) if not target_meta or source_meta.modified_time > target_meta.modified_time: # Copy the file from source to target source_path = os.path.join(source_directory, filename) target_path = os.path.join(target_directory, filename) shutil.copy2(source_path, target_path) # Remove files that are in the target but not in the source for filename in target_files: if filename not in source_files: target_path = os.path.join(target_directory, filename) os.remove(target_path)"},{"question":"# Question Context A logistics company uses a simplified navigation system for plotting routes based on a grid. To ensure efficient delivery, a utility function is required to determine the shortest path (in terms of distance) between two points on the grid. Task Write a function `shortest_distance` that computes the shortest distance between two points on a Cartesian coordinate system. Function Signature ```python def shortest_distance(x1: int, y1: int, x2: int, y2: int) -> float: ``` Input * `x1` (int): The x-coordinate of the starting point. (-1000 <= x1 <= 1000) * `y1` (int): The y-coordinate of the starting point. (-1000 <= y1 <= 1000) * `x2` (int): The x-coordinate of the ending point. (-1000 <= x2 <= 1000) * `y2` (int): The y-coordinate of the ending point. (-1000 <= y2 <= 1000) Output * (float): The shortest distance between the two points with high precision (e.g., 7.0710678118654755). Example ```python >>> shortest_distance(0, 0, 3, 4) 5.0 >>> shortest_distance(-1, -1, 2, 3) 5.0 >>> shortest_distance(0, 0, 0, 0) 0.0 ``` Constraints * All input coordinates should be validated to ensure: * `-1000 <= x1, y1, x2, y2 <= 1000` * Assumed that inputs are valid integers. * Implement function calculations with high precision. Edge Cases * When the starting and ending points are the same, the distance should be 0. * When the points form a standard 3-4-5 triangle, the distance should explicitly validate this with a 5.0 output.","solution":"import math def shortest_distance(x1: int, y1: int, x2: int, y2: int) -> float: Computes the shortest distance between two points (x1, y1) and (x2, y2) on a Cartesian coordinate system. Parameters: x1 (int): The x-coordinate of the starting point. y1 (int): The y-coordinate of the starting point. x2 (int): The x-coordinate of the ending point. y2 (int): The y-coordinate of the ending point. Returns: float: The shortest distance between the two points. return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)"},{"question":"# Coding Assessment Question You are tasked with writing a function that processes logs from a system and filters out error messages. The goal is to handle various log formats and ensure the function correctly identifies and filters error-related log entries. You will also need to write unit test cases to ensure the function behaves correctly under different scenarios. Scenario Your task is to write a function `extract_error_logs` which takes a list of log entries and returns a list of error messages. Additionally, you need to write test cases to verify the function works correctly. Implementation Details **Function: extract_error_logs(log_entries: list) -> list** * **Inputs**: - `log_entries` (list): A list of log entries, where each entry is a string. * **Outputs**: - A list of strings, where each string is an error message extracted from the log entries. **Unit Testing** * Write a function `test_extract_error_logs` that uses various scenarios to test `extract_error_logs`. Example: ```python def extract_error_logs(log_entries: list) -> list: error_logs = [] for entry in log_entries: if \\"[ERROR]\\" in entry: error_logs.append(entry) return error_logs def test_extract_error_logs(): # Test case 1: Logs with mixed entries logs = [ \\"[INFO] System started\\", \\"[WARNING] Low disk space\\", \\"[ERROR] Failed to connect to database\\", \\"[INFO] User login successful\\", \\"[ERROR] Unexpected end of file\\" ] result = extract_error_logs(logs) assert result == [ \\"[ERROR] Failed to connect to database\\", \\"[ERROR] Unexpected end of file\\" ] # Test case 2: Logs with no error entries logs = [ \\"[INFO] System started\\", \\"[INFO] User login successful\\" ] result = extract_error_logs(logs) assert result == [] # Test case 3: Logs with only error entries logs = [ \\"[ERROR] Connection timeout\\", \\"[ERROR] Disk failure\\" ] result = extract_error_logs(logs) assert result == [ \\"[ERROR] Connection timeout\\", \\"[ERROR] Disk failure\\" ] # Test case 4: Empty log entries logs = [] result = extract_error_logs(logs) assert result == [] # Test case 5: Logs with error keyword in the message but not as an error log logs = [ \\"[INFO] This is an error message but not tagged as error.\\", \\"[ERROR] Genuine error log\\" ] result = extract_error_logs(logs) assert result == [ \\"[ERROR] Genuine error log\\" ] if __name__ == \\"__main__\\": test_extract_error_logs() print(\\"All tests passed!\\") ``` In the above example, you need to ensure the correctness of the `extract_error_logs` function by developing tests that handle various scenarios. **Constraints**: * The log entries will contain strings of varying lengths. * Log entries can include error codes or descriptions within error messages. * Assume the log entries are well-formed and tagged appropriately.","solution":"def extract_error_logs(log_entries: list) -> list: Extracts error messages from a list of log entries. Parameters: log_entries (list): A list of log entries, where each entry is a string. Returns: list: A list of strings, where each string is an error message extracted from the log entries. error_logs = [] for entry in log_entries: if \\"[ERROR]\\" in entry: error_logs.append(entry) return error_logs"},{"question":"# Advanced Coding Assessment Question Context In some situations, especially in fields like gaming or robotics, we often need to simulate movements on a grid in multiple dimensions. Such scenarios require tracking and efficiently updating the position of an object as it moves based on various commands. Problem Statement Implement a class `GridNavigator` which will navigate a 2D grid based on a given set of commands. The navigator starts at a specified initial position on the grid and accepts commands to move in four orthogonal directions (`UP`, `DOWN`, `LEFT`, `RIGHT`). 1. Initialize the class `GridNavigator` with the following properties: - The current position on the grid. - A history of all positions visited. 2. Implement the following methods in `GridNavigator`: - `move(direction: str) -> None`: Moves the navigator in the specified direction and updates the current position and history. - `current_position() -> tuple[int, int]`: Returns the current position as a tuple `(x, y)`. - `visited_positions() -> list[tuple[int, int]]`: Returns the list of all visited positions in order. 3. Handle edge cases: - Provide meaningful error messages or handle cases where the direction is invalid. - Avoid duplication of positions in the history if revisiting the same position. Constraints * Commands are guaranteed to be valid string instructions, i.e., `UP`, `DOWN`, `LEFT`, `RIGHT`. * There are no bounds on the grid\'s size; it can be considered infinite. Function Signatures * `class GridNavigator` - `__init__(self, start_x: int, start_y: int) -> None` - `move(self, direction: str) -> None` - `current_position(self) -> tuple[int, int]` - `visited_positions(self) -> list[tuple[int, int]]` Example Usage ```python navigator = GridNavigator(0, 0) navigator.move(\\"UP\\") print(navigator.current_position()) # Outputs: (0, 1) print(navigator.visited_positions()) # Outputs: [(0, 0), (0, 1)] navigator.move(\\"RIGHT\\") print(navigator.current_position()) # Outputs: (1, 1) print(navigator.visited_positions()) # Outputs: [(0, 0), (0, 1), (1, 1)] navigator.move(\\"DOWN\\") print(navigator.current_position()) # Outputs: (1, 0) print(navigator.visited_positions()) # Outputs: [(0, 0), (0, 1), (1, 1), (1, 0)] navigator.move(\\"LEFT\\") print(navigator.current_position()) # Outputs: (0, 0) print(navigator.visited_positions()) # Outputs: [(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)] ``` Note: Ensure to handle invalid commands gracefully and maintain the history integrity by avoiding duplicate entries if the navigator revisits a position.","solution":"class GridNavigator: def __init__(self, start_x: int, start_y: int) -> None: self.current_pos = (start_x, start_y) self.history = [self.current_pos] def move(self, direction: str) -> None: x, y = self.current_pos if direction == \\"UP\\": y += 1 elif direction == \\"DOWN\\": y -= 1 elif direction == \\"LEFT\\": x -= 1 elif direction == \\"RIGHT\\": x += 1 else: raise ValueError(\\"Invalid direction\\") self.current_pos = (x, y) self.history.append(self.current_pos) def current_position(self) -> tuple[int, int]: return self.current_pos def visited_positions(self) -> list[tuple[int, int]]: return self.history"},{"question":"# Question **Context**: A self-dividing number is a number that is divisible by every digit it contains without leaving a remainder. For instance, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. However, 26 is not a self-dividing number because 26 % 6 != 0. **Task**: You need to write a function that finds all self-dividing numbers in a given range. **Function Signature**: ```python def self_dividing_numbers(left: int, right: int) -> List[int]: pass ``` **Input**: * Two integers `left` and `right` such that ( 1 leq left leq right leq 10000 ). **Output**: * A list of integers representing all the self-dividing numbers within the given range [left, right]. **Constraints**: 1. ( 1 leq left leq right leq 10000 ). **Requirements**: 1. Your solution should handle edge cases gracefully. 2. Optimize the function to handle the largest ranges efficiently. **Example**: ```python >>> self_dividing_numbers(1, 22) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22] >>> self_dividing_numbers(123, 130) [124, 126, 128] >>> self_dividing_numbers(10, 15) [11, 12, 15] ``` Explanation: 1. Numbers like 1, 2, and 3 are self-dividing by definition as they are single-digit and divide by themselves. 2. For a number like 12, both 12 % 1 == 0 and 12 % 2 == 0, so it is self-dividing. 3. The number 26 is not self-dividing since 26 % 6 ≠ 0. **Edge cases to consider**: * Including the smallest and largest bounds in the range. * Handling cases where no valid self-dividing numbers exist in the given range. **Hints**: - Consider iterating through each number within the given range and checking if it is self-dividing. - Ensure to check every digit within the number for the self-dividing property.","solution":"from typing import List def is_self_dividing(n: int) -> bool: Helper function to determine if a number is self-dividing original = n while n > 0: digit = n % 10 if digit == 0 or original % digit != 0: return False n = n // 10 return True def self_dividing_numbers(left: int, right: int) -> List[int]: Returns a list of all self-dividing numbers in the range [left, right] result = [] for num in range(left, right + 1): if is_self_dividing(num): result.append(num) return result"},{"question":"# Matrix Manipulation: Rotate and Sum **Context**: In this task, you will work on manipulating a matrix. You must write functions to rotate the matrix by 90 degrees and to compute the sum of the border elements of the matrix. **Objective**: Implement functions to rotate a matrix clockwise by 90 degrees and to sum the border elements of a matrix. **Function Specifications**: 1. **rotate_matrix(matrix: List[List[int]]) -> List[List[int]]** - Input: * `matrix`: A list of lists (2D matrix) of integers with dimensions `n x n`. - Output: * A new matrix representing the 90-degree rotated version of the input matrix. 2. **sum_border_elements(matrix: List[List[int]]) -> int** - Input: * `matrix`: A list of lists (2D matrix) of integers with dimensions `n x n`. - Output: * An integer representing the sum of the border elements of the matrix. **Requirements**: - You can assume the input matrix will always be a square matrix (`n x n` where `n >= 2`). - Rotation should be done in-place if possible, or you may return a new matrix. - Border elements include the first and last rows, and the first and last columns, excluding any duplicates from the corners. **Examples**: ```python # Example 1: matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) print(f\\"Rotated Matrix = {rotated_matrix}\\") # Expected Output: # Rotated Matrix = [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] border_sum = sum_border_elements(matrix) print(f\\"Sum of Border Elements = {border_sum}\\") # Expected Output: # Sum of Border Elements = 40 # Example 2: matrix = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotated_matrix = rotate_matrix(matrix) print(f\\"Rotated Matrix = {rotated_matrix}\\") # Expected Output: # Rotated Matrix = [ # [15, 13, 2, 5], # [14, 3, 4, 1], # [12, 6, 8, 9], # [16, 7, 10, 11] # ] border_sum = sum_border_elements(matrix) print(f\\"Sum of Border Elements = {border_sum}\\") # Expected Output: # Sum of Border Elements = 112 ``` **Note**: - Ensure the matrix rotations and sum computations handle various edge cases such as the smallest `2x2` matrix and larger matrices. - Pay attention to matrix indexing when performing rotations and summing border elements.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates the input matrix by 90 degrees clockwise. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def sum_border_elements(matrix: List[List[int]]) -> int: Computes the sum of the border elements of the input matrix. n = len(matrix) border_sum = 0 for i in range(n): border_sum += matrix[0][i] # Top row border_sum += matrix[n - 1][i] # Bottom row for i in range(1, n - 1): border_sum += matrix[i][0] # Left column (excluding corners) border_sum += matrix[i][n - 1] # Right column (excluding corners) return border_sum"},{"question":"# Question You are given three different implementations for calculating the factorial of an integer: - An iterative approach (`factorial_iter`). - A recursive approach (`factorial_recur`). - A compact approach using Python\'s built-in `math.factorial` function (`factorial_builtin`). Your task is to write a function `factorial_factory` that returns the factorial of a given integer based on the size of the integer and a provided threshold. Specifically: - If the input integer is less than or equal to the given threshold, use the recursive approach. - If the input integer is greater than the threshold, use the iterative approach. - If the input integer is zero or negative, return 1 (as the factorial of zero is 1 by definition, and factorial of negative numbers is not defined in this context). # Function Signature ```python def factorial_factory(n: int, threshold: int) -> int: pass ``` # Input - `n` (int): The integer whose factorial is to be calculated. - `threshold` (int): The threshold value to choose between the recursive and iterative approach. # Output - `int`: The factorial of the given integer `n`. # Constraints - You must use the provided `factorial_iter` and `factorial_recur` functions. - The input `n` can be any integer (positive, negative, or zero). - The threshold will be a non-negative integer. # Examples ```python >>> factorial_factory(5, 3) 120 >>> factorial_factory(3, 4) 6 >>> factorial_factory(0, 2) 1 >>> factorial_factory(-4, 2) 1 >>> factorial_factory(10, 5) 3628800 ``` # Requirements - Ensure your function handles both small and large integers efficiently. - Handle edge cases like zero and negative integers appropriately. # Testing Ensure your function passes the provided examples and edge cases involving zero, negative numbers, and large integers.","solution":"def factorial_recur(n): Returns the factorial of n using recursion. if n <= 1: return 1 else: return n * factorial_recur(n - 1) def factorial_iter(n): Returns the factorial of n using iteration. result = 1 for i in range(2, n + 1): result *= i return result def factorial_factory(n: int, threshold: int) -> int: if n <= 0: return 1 elif n <= threshold: return factorial_recur(n) else: return factorial_iter(n)"},{"question":"# Coding Question: Convert Roman Numerals to Integers Context In various applications, historical data is often represented in Roman numerals. Your task is to create a function that converts Roman numerals into their corresponding integer values. This can be particularly useful in software dealing with historical texts or any system that integrates ancient numeral systems. Task Write a function `roman_to_int(roman: str) -> int` that takes a string representing a Roman numeral as input and returns its integer equivalent. Expected Input and Output * **Input**: A single string parameter `roman`. * **Output**: An integer value representing the Roman numeral. Constraints 1. The function should handle uppercase Roman numeral strings. 2. The function should raise a `ValueError` if the input string is not a valid Roman numeral. 3. The function should correctly interpret subtractive combinations (e.g., \\"IV\\" means 4, \\"IX\\" means 9). Performance Requirements * The solution must operate in linear time O(n), where n is the length of the input string. * The solution should use constant space O(1). Examples ```python >>> roman_to_int(\\"I\\") 1 >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994 >>> roman_to_int(\\"MMXX\\") 2020 >>> roman_to_int(\\"IM\\") Traceback (most recent call last): ... ValueError: invalid Roman numeral >>> roman_to_int(123) Traceback (most recent call last): ... TypeError: input must be a string ``` - **Invalid Roman Numeral Example**: `roman_to_int(\\"IIII\\")` should raise `ValueError`. - **Non-string Input Example**: `roman_to_int(2020)` should raise `TypeError`. # Edge Cases and Performance Expectations Consider and handle edge cases such as: * Handling invalid Roman numeral sequences (e.g., \\"IIII\\" or \\"VV\\"). * Large valid Roman numerals up to 3999 (the maximum value representable by standard Roman numerals). * Incorrect input types (e.g., integers, lists). Your solution should account for these scenarios and operate efficiently while adhering to the constraints.","solution":"def roman_to_int(roman: str) -> int: Converts a Roman numeral string to an integer. :param roman: A string representing a Roman numeral. :return: An integer equivalent of the Roman numeral. if not isinstance(roman, str): raise TypeError(\\"input must be a string\\") roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } int_value = 0 prev_value = 0 for char in reversed(roman): if char not in roman_to_int_map: raise ValueError(\\"invalid Roman numeral\\") value = roman_to_int_map[char] if value < prev_value: int_value -= value else: int_value += value prev_value = value # Validation: convert the integer back to Roman and check if it matches the original input if int_to_roman(int_value) != roman: raise ValueError(\\"invalid Roman numeral\\") return int_value def int_to_roman(num: int) -> str: Converts an integer to a Roman numeral string. Used for validation. :param num: An integer. :return: A string representing the Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): count = num // val[i] roman_numeral += syms[i] * count num -= val[i] * count return roman_numeral"},{"question":"# Coding Assessment Question Context: Searching algorithms are crucial for efficiently retrieving data from a collection. The Binary Search algorithm is especially useful for searching in a sorted list due to its logarithmic time complexity. Mastering Binary Search, including its recursive and iterative implementations, is fundamental for problem-solving in competitive programming and software development. Task: Implement a function `binary_search_recursive(arr: list, x: int, left: int, right: int) -> int` which performs a Binary Search to find the index of a given element `x` in a sorted list of integers using a recursive approach. Refer to provided details for expected behavior and handling edge cases. Function Signature: ```python def binary_search_recursive(arr: list, x: int, left: int, right: int) -> int: pass ``` Input: - `arr` (list): A sorted list of integers. - `x` (int): The target integer to be searched in the list. - `left` (int): Left index for the current subarray being searched. - `right` (int): Right index for the current subarray being searched. Output: - The function should return the index of `x` if it is present in the list; otherwise, return -1. Constraints: - The list is guaranteed to be sorted in ascending order. - You must not use any built-in `search` functions. Examples: ```python >>> sorted_list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> binary_search_recursive(sorted_list1, 5, 0, len(sorted_list1) - 1) 4 >>> sorted_list2 = [2, 3, 5, 7, 11, 13, 17, 19, 23] >>> binary_search_recursive(sorted_list2, 13, 0, len(sorted_list2) - 1) 5 >>> sorted_list3 = [8, 16, 24, 32, 40] >>> binary_search_recursive(sorted_list3, 10, 0, len(sorted_list3) - 1) -1 ``` Notes: - Return the index of the first occurrence if the element appears more than once. - Consider base cases for recursion: i.e., if the element is not found, and when the search range is invalid. Hint: * In each recursive call, reduce the search range by half by comparing the target element with the middle element of the current subarray.","solution":"def binary_search_recursive(arr, x, left, right): if left > right: return -1 mid = (left + right) // 2 if arr[mid] == x: return mid elif arr[mid] > x: return binary_search_recursive(arr, x, left, mid - 1) else: return binary_search_recursive(arr, x, mid + 1, right)"},{"question":"# Coding Assessment Question Context You are implementing a simple dictionary-based auto-suggestion feature for a text editor. The editor should provide suggestions based on the prefix of the word being typed by the user. The suggestions should be words from the given dictionary that start with the same prefix. Task Implement a function `auto_suggest(dictionary: list, prefix: str) -> list` that takes a dictionary of words and a prefix string. The function should return a list of all words from the dictionary that start with the given prefix, sorted in ascending order. Implementation * Your function should: - Ensure `dictionary` is a list of strings. - Ensure `prefix` is a string. - Return a list of words from the `dictionary` that start with the `prefix`, sorted in ascending order. Constraints - `1 <= len(dictionary) <= 10^5` - `1 <= len(dictionary[i]) <= 100` for every valid `i` - `1 <= len(prefix) <= 100` - The words in `dictionary` and `prefix` consist of only lowercase English letters. Input/Output Format - Input: - A list of strings `dictionary` - A string `prefix` - Output: A list of strings representing the words from the dictionary that start with the prefix, sorted in ascending order. Example ```python def auto_suggest(dictionary: list, prefix: str) -> list: # Your implementation here # Example usage: dictionary = [\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"date\\", \\"fig\\", \\"grape\\"] prefix = \\"ap\\" print(auto_suggest(dictionary, prefix)) # Output: [\'apple\', \'apricot\'] prefix = \\"bl\\" print(auto_suggest(dictionary, prefix)) # Output: [\'blueberry\'] prefix = \\"ch\\" print(auto_suggest(dictionary, prefix)) # Output: [\'cherry\'] prefix = \\"x\\" print(auto_suggest(dictionary, prefix)) # Output: [] ``` The submitted code will be evaluated for correctness, efficiency, and adherence to the problem constraints.","solution":"def auto_suggest(dictionary: list, prefix: str) -> list: Returns a list of words from the dictionary that start with the given prefix, sorted in ascending order. suggestions = [word for word in dictionary if word.startswith(prefix)] suggestions.sort() return suggestions"},{"question":"# Array Rotation and Query You are tasked with implementing an array rotation function and a querying function to evaluate the array after performing the specified rotations. This is useful in database management systems and data processing pipelines where rotational transformations and data retrieval are frequent tasks. Requirements: 1. **Rotation Function**: Implement a function to rotate an array to the right by a specified number of positions. 2. **Querying Function**: Implement a function to return the element at a specific index after the rotation process. # Input Specifications: 1. `rotate_array(arr: list, k: int) -> list`: This function rotates the array `arr` to the right by `k` positions. 2. `query_element(arr: list, k: int, idx: int) -> int`: This function returns the element at index `idx` after rotating the array `arr` to the right by `k` positions. # Output Specifications: 1. `rotate_array` should return the resultant rotated array. 2. `query_element` should return the queried element at the specified index. # Constraints: 1. 1 ≤ len(arr) ≤ 1000 2. 0 ≤ k < 1000 3. 0 ≤ idx < len(arr) # Scenarios and Examples: 1. **Rotating Array**: - `rotate_array([1, 2, 3, 4, 5], 2)` should return `[4, 5, 1, 2, 3]`. - `rotate_array([1, 2, 3, 4, 5], 0)` should return `[1, 2, 3, 4, 5]`. 2. **Querying Element**: - `query_element([1, 2, 3, 4, 5], 2, 1)` should return `5`. - `query_element([1, 2, 3, 4, 5], 0, 3)` should return `4`. # Boilerplate Code ```python def rotate_array(arr: list, k: int) -> list: n = len(arr) k %= n # To handle cases where k >= n return arr[-k:] + arr[:-k] def query_element(arr: list, k: int, idx: int) -> int: rotated = rotate_array(arr, k) return rotated[idx] # Example usage if __name__ == \\"__main__\\": import doctest def _test(): >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> query_element([1, 2, 3, 4, 5], 2, 1) 5 >>> query_element([1, 2, 3, 4, 5], 0, 3) 4 doctest.run_docstring_examples(_test, globals()) _test() ```","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k positions. Args: arr (list): The input array to rotate. k (int): The number of positions to rotate the array. Returns: list: The rotated array. n = len(arr) k %= n # To handle cases where k >= n return arr[-k:] + arr[:-k] def query_element(arr: list, k: int, idx: int) -> int: Returns the element at the specified index after rotating the array. Args: arr (list): The input array to rotate. k (int): The number of positions to rotate the array. idx (int): The index to query after rotation. Returns: int: The element at the specified index after rotation. rotated = rotate_array(arr, k) return rotated[idx]"},{"question":"# XOR Gate Implementation and Boolean Expression Evaluation You are given a function that emulates the behavior of a simple XOR logic gate. Your task is to write a Python function that will evaluate a boolean expression consisting of a series of XOR operations between multiple boolean values. The expression will be given as an array of integers, where each integer is either 0 or 1, representing False or True respectively. Your function should evaluate the entire expression from left to right using the XOR logic gate and return the final result. Function Signature ```python def evaluate_xor_expression(expression: List[int]) -> int: ``` Input - `expression`: A list of integers containing `0` and `1`. Length of the list will be between 2 and 100, inclusive. Output - Return an integer, which is either `0` or `1`, representing the result of the XOR operation performed on the entire expression. Constraints - The expression array will always contain at least two elements. - Every element in the expression array is guaranteed to be either `0` or `1`. Example ```python >>> evaluate_xor_expression([1, 0, 0, 1]) 0 >>> evaluate_xor_expression([1, 1, 1, 1]) 0 >>> evaluate_xor_expression([0, 1, 1, 1]) 1 >>> evaluate_xor_expression([1, 0]) 1 ``` Explanation - In the first example, the expression evaluates as follows: 1 XOR 0 XOR 0 XOR 1 = 0 - In the second example: 1 XOR 1 XOR 1 XOR 1 = 0 - In the third example: 0 XOR 1 XOR 1 XOR 1 = 1 - In the fourth example: 1 XOR 0 = 1 You can make use of the provided `xor_gate` function inside your implementation.","solution":"from typing import List def evaluate_xor_expression(expression: List[int]) -> int: Evaluates a boolean expression of XOR operations. Parameters: expression (List[int]): A list of integers (0s and 1s) to be evaluated. Returns: int: The result of evaluating the expression with XOR operations. result = expression[0] for value in expression[1:]: result ^= value return result"},{"question":"# Problem Description You are given a string consisting of lowercase English letters. Your task is to detect if the string contains any duplicate characters. If duplicates are found, return `True`, otherwise return `False`. You should aim to accomplish this with optimized time and space complexity. # Function Signature ```python def has_duplicates(s: str) -> bool: Checks if a string contains any duplicate characters. :param s: A string consisting of lowercase English letters. :return: A boolean indicating whether the string contains duplicate characters. Examples: >>> has_duplicates(\\"hello\\") True >>> has_duplicates(\\"world\\") False >>> has_duplicates(\\"a\\") False ``` # Input - A string `s` consisting of lowercase English letters. # Output - A boolean `True` if the string contains duplicate characters, otherwise `False`. # Constraints - The length of the input string can range from 1 to 10**5. - All characters in the string are lowercase English letters (from \'a\' to \'z\'). # Performance Requirements - Aim for an optimal time complexity (one linear pass) and efficient space usage. - Your solution should handle large strings efficiently. # Example ```python assert has_duplicates(\\"hello\\") == True assert has_duplicates(\\"world\\") == False assert has_duplicates(\\"a\\") == False ```","solution":"def has_duplicates(s: str) -> bool: Checks if a string contains any duplicate characters. :param s: A string consisting of lowercase English letters. :return: A boolean indicating whether the string contains duplicate characters. seen_characters = set() for char in s: if char in seen_characters: return True seen_characters.add(char) return False"},{"question":"# Coding Assessment Question **Problem Statement**: You are working with a filesystem-like structure where directories can contain both files and other directories. Your task is to implement an algorithm to determine the total size of all files within a given directory, including those in its subdirectories. Each file or directory is represented as a nested dictionary. A directory contains keys which are either sub-directories or files. If the key is a file, its value is an integer representing the file\'s size. If the key is a directory, its value is another dictionary which follows the same structure. **Function Signature**: ```python def compute_directory_size(directory: Dict[str, Any]) -> int: ``` **Input**: - `directory`: A dictionary representing the root directory. The keys are strings representing file or directory names. The values are either: - Integers (if the key is a file and the value is its size) - Dictionaries (if the key is a sub-directory) **Output**: - Returns an integer representing the total size of all files within the input directory and its subdirectories. **Example**: ```python directory = { \\"file1.txt\\": 100, \\"folder1\\": { \\"file2.txt\\": 200, \\"folder2\\": { \\"file3.txt\\": 300 }, }, \\"file4.txt\\": 400 } Output: 1000 ``` **Constraints**: - The size of the file is guaranteed to be a non-negative integer. - The nesting of directories can be arbitrary but within a practical depth for recursion in programming environments. **Hints**: 1. Use a recursive approach to navigate through nested dictionaries. 2. Accumulate the sizes of all files encountered during the traversal. **Performance Requirements**: - The solution should be efficient in terms of both time and space complexity, ideally proportional to the size of the input directory structure. - Ensure proper handling of deeply nested directories without exceeding recursion limits. Write the function `compute_directory_size` that should correctly traverse the nested dictionary and compute the total file size.","solution":"def compute_directory_size(directory): Computes the total size of all files within the input directory and its subdirectories. :param directory: Dictionary representing the root directory. :return: Integer representing the total size of all files. total_size = 0 for key, value in directory.items(): if isinstance(value, dict): total_size += compute_directory_size(value) elif isinstance(value, int): total_size += value return total_size"},{"question":"# Question Write a function that implements a basic K-Means clustering algorithm from scratch. This function should group a set of 2D points into k clusters based on their Euclidean distances. Additionally, visualize the clustered points after the algorithm has converged. # Requirements: - Do not use any clustering-related functions from libraries such as scikit-learn. - Implement the K-Means algorithm to: - Initialize the centroids randomly. - Iterate to update the cluster centroids and assign points to the nearest cluster. - Stop when the centroids do not change significantly between iterations. - Plot the final clusters using different colors for different clusters. # Input: - `points`: a list of tuples, where each tuple represents the coordinates of a 2D point. - `k`: an integer representing the number of clusters. # Output: - A list of k clusters, where each cluster is represented by a list of points. - A visual plot displaying the clustered points. # Constraints: - The number of clusters k must be less than the number of points. - The algorithm should handle edge cases, such as points located at the exact same coordinate. - The algorithm converges when the maximum change in any centroid is below a small threshold (e.g., 1e-4). # Performance Requirements: - Aim for the algorithm to converge in a reasonable number of iterations (e.g., less than 300). # Scenario: Consider you have been given a set of 2D points that you need to cluster into k groups. Implement the `k_means_clustering` function and visualize the clusters. The following helper functions provided will assist in loading the dataset and visualizing the results. ```python import numpy as np import random from matplotlib import pyplot as plt def load_2d_points() -> list: Generate a random set of 2D points for clustering np.random.seed(42) points = np.random.randn(100, 2) return [tuple(point) for point in points] def plot_clusters(clusters: list, centroids: list) -> None: Plot the clustered points along with their centroids colors = [\'r\', \'g\', \'b\', \'y\', \'c\', \'m\'] for i, cluster in enumerate(clusters): cluster_points = np.array(cluster) plt.scatter(cluster_points[:, 0], cluster_points[:, 1], c=colors[i % len(colors)], label=f\'Cluster {i + 1}\') centroid_points = np.array(centroids) plt.scatter(centroid_points[:, 0], centroid_points[:, 1], c=\'k\', marker=\'x\', label=\'Centroids\') plt.legend() plt.show() def euclidean_distance(point1: tuple, point2: tuple) -> float: Calculate the Euclidean distance between two 2D points return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def k_means_clustering(points: list, k: int) -> list: Implement K-Means clustering algorithm # Initialize centroids randomly centroids = random.sample(points, k) prev_centroids = [(0, 0)] * k # Define threshold for convergence threshold = 1e-4 while True: # Assign points to the nearest centroid clusters = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) # Update centroids new_centroids = [] for cluster in clusters: if cluster: new_centroids.append((np.mean([point[0] for point in cluster]), np.mean([point[1] for point in cluster]))) else: new_centroids.append(random.choice(points)) # Check for convergence if max(euclidean_distance(prev_centroids[i], new_centroids[i]) for i in range(k)) < threshold: break prev_centroids = centroids centroids = new_centroids return clusters, centroids def main() -> None: # Load 2D points dataset points = load_2d_points() # Define the number of clusters k = 3 # Perform K-Means clustering clusters, centroids = k_means_clustering(points, k) # Visualize the result plot_clusters(clusters, centroids) if __name__ == \\"__main__\\": main() ``` **Note**: Ensure to install the required libraries using `pip install numpy matplotlib` before running your script.","solution":"import numpy as np import random from matplotlib import pyplot as plt def euclidean_distance(point1: tuple, point2: tuple) -> float: Calculate the Euclidean distance between two 2D points. return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def k_means_clustering(points: list, k: int) -> list: Implement K-Means clustering algorithm. # Ensure k is less than the number of points if k >= len(points): raise ValueError(\\"Number of clusters must be less than the number of points\\") # Initialize centroids randomly centroids = random.sample(points, k) prev_centroids = [(0, 0)] * k # Define threshold for convergence threshold = 1e-4 while True: # Assign points to the nearest centroid clusters = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_index = distances.index(min(distances)) clusters[closest_centroid_index].append(point) # Update centroids new_centroids = [] for cluster in clusters: if cluster: new_centroids.append((np.mean([point[0] for point in cluster]), np.mean([point[1] for point in cluster]))) else: # Handle empty cluster: reinitialize with a random point new_centroids.append(random.choice(points)) # Check for convergence if max(euclidean_distance(prev_centroids[i], new_centroids[i]) for i in range(k)) < threshold: break prev_centroids = centroids centroids = new_centroids return clusters, centroids def plot_clusters(clusters: list, centroids: list) -> None: Plot the clustered points along with their centroids. colors = [\'r\', \'g\', \'b\', \'y\', \'c\', \'m\'] for i, cluster in enumerate(clusters): cluster_points = np.array(cluster) if len(cluster_points) > 0: plt.scatter(cluster_points[:, 0], cluster_points[:, 1], c=colors[i % len(colors)], label=f\'Cluster {i + 1}\') centroid_points = np.array(centroids) plt.scatter(centroid_points[:, 0], centroid_points[:, 1], c=\'k\', marker=\'x\', label=\'Centroids\') plt.legend() plt.show()"},{"question":"# Library Management System You are tasked with implementing a basic library management system that allows tracking of books and their availability status. The system should support adding new books, checking out books to users, and returning books. # Detailed Requirements 1. **Class Implementation**: * Implement a `Library` class to manage the library system. * Implement a `Book` class to represent individual books. 2. **Library Class**: * Define the `Library` class with the following methods: * `add_book(book: Book) -> None`: Add a new book to the library. * `checkout_book(title: str, user: str) -> str`: Check out a book to a user. Return a message indicating success or if the book is unavailable. * `return_book(title: str) -> str`: Return a checked-out book to the library. Return a message indicating success or if the book was not checked out. 3. **Book Class**: * Define the `Book` class with the following attributes: * `title` (str): The title of the book. * `author` (str): The author of the book. * `available` (bool): Status of the book\'s availability. 4. **Additional Details**: * During checkout, if a book with the given title is not available or doesn\'t exist, return a suitable message. * During return, if the book was not checked out or doesn\'t exist, return a suitable message. * Ensure that the system can handle multiple checkouts and returns gracefully. # Function Signatures ```python class Book: def __init__(self, title: str, author: str): pass class Library: def add_book(self, book: Book) -> None: pass def checkout_book(self, title: str, user: str) -> str: pass def return_book(self, title: str) -> str: pass ``` # Input * `title` (str): The title of the book. * `author` (str): The author of the book. * `user` (str): The user checking out the book. # Output * For `add_book`: None. * For `checkout_book` and `return_book`: Return a message indicating the action\'s result. # Constraints * Each book\'s title will be unique in the library. * The system should handle up to 1000 books without significant performance degradation. # Example ```python library = Library() book1 = Book(\\"1984\\", \\"George Orwell\\") book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\") library.add_book(book1) library.add_book(book2) print(library.checkout_book(\\"1984\\", \\"Alice\\")) # Output: \\"Book \'1984\' checked out to Alice.\\" print(library.checkout_book(\\"1984\\", \\"Bob\\")) # Output: \\"Book \'1984\' is not available.\\" print(library.return_book(\\"1984\\")) # Output: \\"Book \'1984\' successfully returned.\\" print(library.return_book(\\"1984\\")) # Output: \\"Book \'1984\' was not checked out.\\" ``` Example Output (Structure): ```python library.add_book(book1) library.add_book(book2) print(library.checkout_book(\\"1984\\", \\"Alice\\")) # \\"Book \'1984\' checked out to Alice.\\" print(library.checkout_book(\\"1984\\", \\"Bob\\")) # \\"Book \'1984\' is not available.\\" print(library.return_book(\\"1984\\")) # \\"Book \'1984\' successfully returned.\\" print(library.return_book(\\"1984\\")) # \\"Book \'1984\' was not checked out.\\" ``` The `Library` class and `Book` class should interact to manage the books\' statuses appropriately. The system should handle the basic operations of adding, checking out, and returning books efficiently.","solution":"class Book: def __init__(self, title: str, author: str): self.title = title self.author = author self.available = True class Library: def __init__(self): self.books = {} def add_book(self, book: Book) -> None: self.books[book.title] = book def checkout_book(self, title: str, user: str) -> str: if title in self.books: book = self.books[title] if book.available: book.available = False return f\\"Book \'{title}\' checked out to {user}.\\" else: return f\\"Book \'{title}\' is not available.\\" else: return f\\"Book \'{title}\' does not exist in the library.\\" def return_book(self, title: str) -> str: if title in self.books: book = self.books[title] if not book.available: book.available = True return f\\"Book \'{title}\' successfully returned.\\" else: return f\\"Book \'{title}\' was not checked out.\\" else: return f\\"Book \'{title}\' does not exist in the library.\\""},{"question":"# Context You\'re developing a simplified version of an inventory management system for a small retail store. The system keeps track of the products and their quantities. # Task Implement a class `Inventory` that allows for adding, updating, retrieving, and deleting products and their quantities. Ensure the class accommodates edge cases like adding an already existing product or deleting a non-existent product. # Requirements 1. **Constructor**: `Inventory()` initializes an empty inventory. 2. **Methods**: * `add_product(self, product_name, quantity)`: Adds the product with the given quantity to the inventory. If the product already exists, updates the quantity. * `get_quantity(self, product_name)`: Returns the quantity of the given product. If the product does not exist, returns 0. * `delete_product(self, product_name)`: Deletes the product from the inventory. If the product does not exist, does nothing. * `total_items(self)`: Returns the total number of unique items in the inventory. * `all_products(self)`: Returns a list of tuples containing all product names and their quantities. # Example ```python # Example with basic operations inventory = Inventory() inventory.add_product(\'apple\', 10) inventory.add_product(\'banana\', 5) assert inventory.get_quantity(\'apple\') == 10 assert inventory.get_quantity(\'banana\') == 5 # Adding more to existing product inventory.add_product(\'apple\', 5) assert inventory.get_quantity(\'apple\') == 15 # Deleting a product inventory.delete_product(\'banana\') assert inventory.total_items() == 1 assert inventory.all_products() == [(\'apple\', 15)] ```","solution":"class Inventory: def __init__(self): self.inventory = {} def add_product(self, product_name, quantity): if product_name in self.inventory: self.inventory[product_name] += quantity else: self.inventory[product_name] = quantity def get_quantity(self, product_name): return self.inventory.get(product_name, 0) def delete_product(self, product_name): if product_name in self.inventory: del self.inventory[product_name] def total_items(self): return len(self.inventory) def all_products(self): return list(self.inventory.items())"},{"question":"# Anagram Verification **Objective**: Implement a function to verify if two given strings are anagrams of each other. **Function Signature**: `def are_anagrams(word1: str, word2: str) -> bool:` # Input: - `word1` (str): The first string to be compared. - `word2` (str): The second string to be compared. # Output: - Returns a Boolean value (True or False) indicating whether the two words are anagrams of each other. # Constraints: - The strings must only consist of printable ASCII characters. - The function should handle case insensitivity (e.g., \'Listen\' and \'Silent\' should be considered anagrams). # Examples: 1. `are_anagrams(\\"Listen\\", \\"Silent\\")` should return `True`. 2. `are_anagrams(\\"Triangle\\", \\"Integral\\")` should return `True`. 3. `are_anagrams(\\"Apple\\", \\"Pine\\")` should return `False`. 4. `are_anagrams(\\"Schoolmaster\\", \\"The Classroom\\")` should return `True`. 5. `are_anagrams(\\"Astronomer\\", \\"Moon starer\\")` should return `True`. # Notes: - Ignore spaces and characters should be treated in a case-insensitive manner while determining if the words are anagrams. - Consider edge cases like empty strings. - Avoid using built-in sort methods for solving this problem to enforce more manual manipulation of the strings. # Hints: - Use the `collections.Counter` class from the `collections` module to count the frequency of each character in both strings. - Ensure that the function accounts for spaces and mixed casing appropriately.","solution":"from collections import Counter def are_anagrams(word1: str, word2: str) -> bool: Verifies if two given strings are anagrams of each other. Ignores spaces and is case insensitive. # Remove spaces and convert to lowercase word1_cleaned = word1.replace(\\" \\", \\"\\").lower() word2_cleaned = word2.replace(\\" \\", \\"\\").lower() # Compare the character counts of both cleaned words return Counter(word1_cleaned) == Counter(word2_cleaned)"},{"question":"# Reverse a Subarray in a List # Problem Statement You are given a list of integers and two indices representing the start and end of a subarray. Implement an algorithm to reverse the elements within the specified subarray. For this task, implement the `ListManipulator` class with the following methods: - `__init__(self, nums: List[int])`: Initializes the instance with the given list of integers. - `reverse_subarray(self, start_index: int, end_index: int)`: Reverses the elements in the subarray from `start_index` to `end_index` (inclusive). Raises a `ValueError` if the indices are out of range or if the start index is greater than the end index. - `get_list(self) -> List[int]`: Returns the current state of the list. Input - A list of integers `nums`. - Two integers `start_index` and `end_index` which specify the starting and ending indices of the subarray to be reversed. Output - `reverse_subarray`: Returns `None`, but modifies the list in place. - `get_list`: Returns the current state of the list after any modifications. # Example ```python lm = ListManipulator([1, 2, 3, 4, 5]) lm.reverse_subarray(1, 3) assert lm.get_list() == [1, 4, 3, 2, 5] lm.reverse_subarray(0, 4) assert lm.get_list() == [5, 2, 3, 4, 1] try: lm.reverse_subarray(3, 1) except ValueError as e: assert str(e) == \\"Invalid indices: start_index must be <= end_index and both should be within the list bounds.\\" try: lm.reverse_subarray(0, 5) except ValueError as e: assert str(e) == \\"Invalid indices: Out of range.\\" ``` You need to complete the class `ListManipulator` as per the specified requirements: ```python class ListManipulator: def __init__(self, nums: List[int]): # Initialize your data structures here pass def reverse_subarray(self, start_index: int, end_index: int): # Implement the logic to reverse the specified subarray pass def get_list(self) -> List[int]: # Return the current state of the list pass ``` # Constraints - `1 <= len(nums) <= 10^5` - `0 <= start_index, end_index < len(nums)` # Notes - Ensure your solution handles invalid indices properly by raising appropriate exceptions. - Optimize for both time and space, adhering to the constraints and expected computational complexity.","solution":"class ListManipulator: def __init__(self, nums): Initializes the instance with the given list of integers. self.nums = nums def reverse_subarray(self, start_index, end_index): Reverses the elements in the subarray from start_index to end_index (inclusive). Raises a ValueError if the indices are out of range or if the start index is greater than the end index. if start_index < 0 or end_index >= len(self.nums): raise ValueError(\\"Invalid indices: Out of range.\\") if start_index > end_index: raise ValueError(\\"Invalid indices: start_index must be <= end_index and both should be within the list bounds.\\") while start_index < end_index: self.nums[start_index], self.nums[end_index] = self.nums[end_index], self.nums[start_index] start_index += 1 end_index -= 1 def get_list(self): Returns the current state of the list. return self.nums"},{"question":"# Problem Context You are developing a library for basic geometric transformations that can be applied to 2D shapes. One of the functionalities required is to perform transformations like translation, scaling, and rotation on polygons represented by their vertices. # Task Implement the `Polygon` class with methods to accurately perform geometric transformations on the vertices of the polygon. # Function Signature ```python class Polygon: def __init__(self, vertices: list[tuple[float, float]]): ... def translate(self, dx: float, dy: float): ... def scale(self, sx: float, sy: float): ... def rotate(self, angle: float): ... def get_vertices(self) -> list[tuple[float, float]]: ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Accepts a list of vertices and stores it. - Vertices are tuples of XY coordinates. - Checks that there are at least three vertices (to form a polygon). 2. **Translation (`translate` method)**: - Accepts translation distances `dx` and `dy`. - Applies translation to all vertices and updates them. 3. **Scaling (`scale` method)**: - Accepts scale factors `sx` and `sy`. - Scales the vertices relative to the origin (0,0) and updates them. 4. **Rotation (`rotate` method)**: - Accepts an angle in degrees. - Rotates the vertices around the origin (0,0) by the specified angle and updates them. 5. **Get Vertices (`get_vertices` method)**: - Returns the current list of vertices. # Input and Output Format * **Input**: List of vertices, translation distances, scale factors, and rotation angle. ```plaintext Vertices: [(1, 1), (2, 2), (3, 1)] Translation: (dx=1, dy=1) Scale: (sx=2, sy=2) Rotation: (angle=90) ``` * **Output**: Transformed list of vertices. # Example Usage ```python if __name__ == \\"__main__\\": polygon = Polygon([(1, 1), (2, 2), (3, 1)]) polygon.translate(1, 1) print(polygon.get_vertices()) # Output after translation polygon.scale(2, 2) print(polygon.get_vertices()) # Output after scaling polygon.rotate(90) print(polygon.get_vertices()) # Output after rotation ``` # Additional Guidelines 1. **Edge Cases**: - Ensure at least three vertices are provided during initialization. - Handle translations, scalings, and rotations that result in vertices going to negative coordinates. - Properly handle cases where scaling factors are zero or negative. 2. **Coordinate Transformations**: - Use standard 2D transformation formulas: - Translation: ( (x\', y\') = (x + dx, y + dy) ) - Scaling: ( (x\', y\') = (x cdot sx, y cdot sy) ) - Rotation: ( (x\', y\') = (x cdot cos(theta) - y cdot sin(theta), x cdot sin(theta) + y cdot cos(theta)) ) 3. **Performance**: - Efficiently apply transformations without unnecessary recalculations.","solution":"import math class Polygon: def __init__(self, vertices: list[tuple[float, float]]): if len(vertices) < 3: raise ValueError(\\"A polygon must have at least three vertices.\\") self.vertices = vertices def translate(self, dx: float, dy: float): self.vertices = [(x + dx, y + dy) for x, y in self.vertices] def scale(self, sx: float, sy: float): self.vertices = [(x * sx, y * sy) for x, y in self.vertices] def rotate(self, angle: float): radians = math.radians(angle) cos_angle = math.cos(radians) sin_angle = math.sin(radians) self.vertices = [ ( x * cos_angle - y * sin_angle, x * sin_angle + y * cos_angle ) for x, y in self.vertices ] def get_vertices(self) -> list[tuple[float, float]]: return self.vertices"},{"question":"# Problem Statement Design a function `rotate_image` that takes a 2D list representing an NxN image and rotates the image 90 degrees clockwise. The function should modify the input list in-place. # Function Signature ```python def rotate_image(matrix: list) -> None: ``` # Input * A 2D list `matrix` where (1 leq text{len(matrix)} leq 1000) representing an NxN image. # Output * The input list `matrix` should be modified in-place to reflect the 90-degree clockwise rotation. # Constraints * The function should not return any value. * The function should handle matrix sizes efficiently within the given constraints. * The solution should utilize an in-place algorithm to minimize additional space usage. # Performance Requirements * Time complexity: O(N^2) * Space complexity: O(1) (excluding input parameters) # Edge Cases & Error Handling * If the input `matrix` is not a square matrix or is empty, raise a `ValueError`. * Handle cases where the input dimensions are minimal (i.e., 1x1 matrix). # Example 1. Example 1: ```python image = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_image(image) ``` Expected Output: ```python image == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. Edge Case 1: ```python rotate_image([]) ``` Expected Output: ```python ValueError: Input is not a square matrix ``` 3. Edge Case 2: ```python rotate_image([[5]]) ``` Expected Output: ```python image == [[5]] ``` Write the `rotate_image` function to solve the above problem statement.","solution":"def rotate_image(matrix: list) -> None: Rotates the given NxN 2D matrix 90 degrees clockwise in-place. :param matrix: 2D list representation of an NxN image. :raises ValueError: if the input matrix is not square or is empty. if not matrix or len(matrix) != len(matrix[0]): raise ValueError(\\"Input is not a square matrix\\") n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"Code Review and Refactoring Task You have been provided with a legacy Python script that processes user data and generates a user report. As part of a code review, your task is to identify any inefficiencies or potential errors in the script and refactor it to improve performance, readability, and maintainability. Task: 1. Refactor the function `process_user_data` to: - Optimize data processing by minimizing redundancy and improving the efficiency of loops. - Ensure the code follows the best practices of Python coding conventions (PEP 8). - Include error handling to manage potential failures, such as missing user attributes or malformed input data. 2. Modify the `generate_user_report` function to: - Take advantage of Python\'s in-built functionalities to streamline the report generation. - Add input validation to ensure the provided user data is in the correct format. - Return a well-structured summary report containing user statistics. Initial Implementation: ```python def process_user_data(raw_data): users = [] for user in raw_data: user_info = {} user_info[\'name\'] = user[0] + \\" \\" + user[1] user_info[\'email\'] = user[2] user_info[\'age\'] = user[3] users.append(user_info) return users def generate_user_report(users): total_age = 0 count = 0 for user in users: total_age += user[\'age\'] count += 1 average_age = total_age / count if count > 0 else 0 report = { \'total_users\': count, \'average_age\': average_age, \'users\': users } return report ``` Refactored Code: ```python def process_user_data(raw_data): Processes raw user data into a list of dictionaries, each containing user information. :param raw_data: List of tuples, with each tuple containing (first_name, last_name, email, age). :return: List of dictionaries with keys: \'name\', \'email\', \'age\'. users = [] for user in raw_data: try: user_info = { \'name\': f\\"{user[0]} {user[1]}\\", \'email\': user[2], \'age\': int(user[3]) # Ensure age is an integer } users.append(user_info) except IndexError as e: print(f\\"Missing information in user data: {user}, error: {e}\\") except ValueError as e: print(f\\"Invalid age value for user: {user}, error: {e}\\") return users def generate_user_report(users): Generates a report with total users count, average age, and a list of users. :param users: List of dictionaries with user information. :return: Dictionary containing report summary. if not users: return {\'error\': \'No user data available to generate report.\'} total_age = sum(user.get(\'age\', 0) for user in users) valid_users_count = len([user for user in users if \'age\' in user]) average_age = total_age / valid_users_count if valid_users_count else 0 report = { \'total_users\': valid_users_count, \'average_age\': average_age, \'users\': users } return report ``` Expected Input and Output: * `process_user_data(raw_data)`: - **Input**: List of tuples, e.g., `[(\\"Jane\\", \\"Doe\\", \\"jane.doe@example.com\\", \\"28\\"), (\\"John\\", \\"Smith\\", \\"john.smith@example.com\\", \\"35\\")]`. - **Output**: List of dictionaries, e.g., `[{\\"name\\": \\"Jane Doe\\", \\"email\\": \\"jane.doe@example.com\\", \\"age\\": 28}, {\\"name\\": \\"John Smith\\", \\"email\\": \\"john.smith@example.com\\", \\"age\\": 35}]`. * `generate_user_report(users)`: - **Input**: List of dictionaries with user information. - **Output**: Dictionary summarizing user statistics, e.g., `{\\"total_users\\": 2, \\"average_age\\": 31.5, \\"users\\": [{\\"name\\": \\"Jane Doe\\", \\"email\\": \\"jane.doe@example.com\\", \\"age\\": 28}, {\\"name\\": \\"John Smith\\", \\"email\\": \\"john.smith@example.com\\", \\"age\\": 35}]}`. Constraints: - The `raw_data` will be a properly formatted list of tuples as stated. - All ages provided in the `raw_data` will be valid numerical strings. - The `raw_data` list will contain at least one user record. Performance Requirements: - Ensure the refactored code is efficient, concise, and follows Python best practices. - Include appropriate error handling to manage any potential data inconsistencies. Implement the following: ```python def process_user_data(raw_data): # Implement the refactored code here def generate_user_report(users): # Implement the refactored code here ```","solution":"def process_user_data(raw_data): Processes raw user data into a list of dictionaries, each containing user information. :param raw_data: List of tuples, with each tuple containing (first_name, last_name, email, age). :return: List of dictionaries with keys: \'name\', \'email\', \'age\'. users = [] for user in raw_data: try: user_info = { \'name\': f\\"{user[0]} {user[1]}\\", \'email\': user[2], \'age\': int(user[3]) # Ensure age is an integer } users.append(user_info) except IndexError as e: print(f\\"Missing information in user data: {user}, error: {e}\\") except ValueError as e: print(f\\"Invalid age value for user: {user}, error: {e}\\") return users def generate_user_report(users): Generates a report with total users count, average age, and a list of users. :param users: List of dictionaries with user information. :return: Dictionary containing report summary. if not users: return {\'error\': \'No user data available to generate report.\'} total_age = sum(user.get(\'age\', 0) for user in users) valid_users_count = len([user for user in users if \'age\' in user]) average_age = total_age / valid_users_count if valid_users_count else 0 report = { \'total_users\': valid_users_count, \'average_age\': average_age, \'users\': users } return report"},{"question":"# Coding Question: Partition Array into Disjoint Intervals You are given an array of unique integers. Your task is to write a function to partition the array into two contiguous subarrays such that every element in the left subarray is less than or equal to every element in the right subarray. The left subarray should be the smallest possible but non-empty. Return the length of the left subarray after the partition. # Function Signature ```python def partition_disjoint(nums: list[int]) -> int: Given a list of unique integers `nums`, returns the length of the smallest left subarray in a partition where each element in the left is less than or equal to every element in the right. Parameters: nums (list): A list of unique integers. Returns: int: Length of the left subarray. Example: >>> nums = [5, 0, 3, 8, 6] >>> partition_disjoint(nums) 3 # Input * A list of unique integers `nums` with length `n`. # Output * An integer representing the length of the left subarray after partitioning. # Constraints * `2 <= n <= 10^5` * `0 <= nums[i] <= 10^6` * All elements in `nums` are unique. # Example ```python # Example 1: nums = [5, 0, 3, 8, 6] print(partition_disjoint(nums)) # Output: 3 # Example 2: nums = [1, 1, 1, 0, 6, 12] print(partition_disjoint(nums)) # Output: 4 ``` # Explanation In the first example, left subarray [5, 0, 3] and right subarray [8, 6] satisfy the condition where every element in the left subarray is less than or equal to every element in the right subarray. The length of the left subarray after partitioning is 3.","solution":"def partition_disjoint(nums: list[int]) -> int: n = len(nums) max_left = [0] * n min_right = [0] * n max_left[0] = nums[0] for i in range(1, n): max_left[i] = max(max_left[i-1], nums[i]) min_right[-1] = nums[-1] for i in range(n-2, -1, -1): min_right[i] = min(min_right[i+1], nums[i]) for i in range(1, n): if max_left[i-1] <= min_right[i]: return i"},{"question":"**Scenario**: You are developing a library that needs functionality for producing concise, human-readable summaries of lists containing both numerical and string elements. This library will handle dynamic datasets where data representation is key to user engagement and quick understanding. # Task 1. **Function to Concatenate Strings**: - Implement a function `concatenate_strings` that accepts a list of strings and concatenates them into a single string, separated by a comma and a space (`, `). 2. **Function to Calculate Numerical Summaries**: - Implement a function `calculate_summary_statistics` that accepts a list of numbers and returns a dictionary with the following statistical values: - `mean`: the average of the list. - `median`: the median value of the list. - `variance`: the variance of the list. - `standard_deviation`: the standard deviation of the list. - Use standard statistical formulas to compute these values. 3. **Function to Produce Summary**: - Implement a function `produce_summary` that accepts a list which can contain both strings and numerical values. The function should: - Separate the strings and numerical values into two different lists. - Use `concatenate_strings` to concatenate the strings. - Use `calculate_summary_statistics` to compute the summary statistics for the numerical values. - Return a dictionary with the following keys: - `concatenated_strings`: the concatenated string. - `summary_statistics`: the dictionary of summary statistics. # Input and Output Format - **Input**: - For `concatenate_strings`: a list of strings. - For `calculate_summary_statistics`: a list of numbers. - For `produce_summary`: a list containing strings and/or numbers. - **Output**: - For `concatenate_strings`: a single concatenated string. - For `calculate_summary_statistics`: a dictionary with the statistical values. - For `produce_summary`: a dictionary with the concatenated string and summary statistics. # Constraints - You may assume that the list passed to `produce_summary` contains only strings and numbers. - The list of numbers passed to `calculate_summary_statistics` will contain at least one element. # Example ```python # Function to Concatenate Strings concatenated_result = concatenate_strings([\\"apple\\", \\"banana\\", \\"cherry\\"]) # returns \'apple, banana, cherry\' # Function to Calculate Numerical Summaries summary = calculate_summary_statistics([1, 2, 3, 4, 5]) # returns {\'mean\': 3, \'median\': 3, \'variance\': 2.5, \'standard_deviation\': 1.58} # Function to Produce Summary summary_result = produce_summary([\\"apple\\", \\"banana\\", 1, 2, 3, 4, 5, \\"cherry\\"]) # returns { # \'concatenated_strings\': \'apple, banana, cherry\', # \'summary_statistics\': {\'mean\': 3, \'median\': 3, \'variance\': 2.5, \'standard_deviation\': 1.58} # } ```","solution":"def concatenate_strings(string_list): Concatenates a list of strings into a single string, separated by a comma and a space. Args: string_list (list): List of strings to concatenate. Returns: str: Concatenated string. return \', \'.join(string_list) def calculate_summary_statistics(num_list): Calculates summary statistics for a list of numbers. Args: num_list (list): List of numerical values. Returns: dict: Dictionary containing mean, median, variance and standard deviation. import statistics mean_val = statistics.mean(num_list) median_val = statistics.median(num_list) variance_val = statistics.variance(num_list) std_dev_val = statistics.stdev(num_list) return { \'mean\': mean_val, \'median\': median_val, \'variance\': variance_val, \'standard_deviation\': std_dev_val } def produce_summary(mixed_list): Produces a summary from a list containing both strings and numbers. Args: mixed_list (list): List containing strings and numerical values. Returns: dict: Dictionary containing concatenated string and summary statistics. strings = [x for x in mixed_list if isinstance(x, str)] numbers = [x for x in mixed_list if isinstance(x, (int, float))] concatenated_strings = concatenate_strings(strings) summary_statistics = calculate_summary_statistics(numbers) return { \'concatenated_strings\': concatenated_strings, \'summary_statistics\': summary_statistics }"},{"question":"# Coding Assessment Question Context Your task is to implement a program that helps with inventory management in a warehouse. Each item in the inventory has a unique identifier, and certain operations need to be performed on the inventory data. Task Write a function `update_inventory(operations: list[tuple[str, int, int]]) -> dict[int, int]` that processes a list of operations to update the inventory. The operations can be `(\\"add\\", item_id, quantity)` to add a certain quantity of an item, and `(\\"remove\\", item_id, quantity)` to remove a certain quantity of an item. If an attempt is made to remove more than the available quantity of an item, set the quantity to zero. Input - `operations`: A list of tuples where each tuple represents an operation in the form `(operation, item_id, quantity)`. `operation` is a string that can either be \\"add\\" or \\"remove\\", `item_id` is an integer representing the unique identifier of the item, and `quantity` is an integer representing the number of items to add or remove. Output - A dictionary where the keys are the item IDs (integers) and the values are the quantities of the items (integers) in the inventory after all operations have been applied. Constraints - `operation` will be either \\"add\\" or \\"remove\\". - `item_id` will always be a positive integer. - `quantity` will always be a non-negative integer. - Assume well-formed input data. - The number of `operations` will not exceed 10⁴. Performance Requirements - Ensure the function efficiently processes up to 10⁴ operations. Example ```python operations = [(\\"add\\", 1, 5), (\\"add\\", 2, 3), (\\"remove\\", 1, 2), (\\"remove\\", 2, 4)] result = update_inventory(operations) print(result) # Expected output: {1: 3, 2: 0} ``` In this example, item 1 had 5 units added, then 2 units removed, leaving 3 units. Item 2 had 3 units added, then 4 units removed, but since only 3 units were available, it results in 0 units remaining.","solution":"def update_inventory(operations): inventory = {} for operation, item_id, quantity in operations: if operation == \\"add\\": if item_id in inventory: inventory[item_id] += quantity else: inventory[item_id] = quantity elif operation == \\"remove\\": if item_id in inventory: inventory[item_id] = max(0, inventory[item_id] - quantity) else: inventory[item_id] = 0 return inventory"},{"question":"# Problem Statement: Prime Factorization and Greatest Common Divisor You are required to write a library that assists in computing prime factorizations of integers and using those factorizations to determine the greatest common divisor (GCD) of two numbers. **Context and Functions:** Prime factorization involves breaking down a number into a product of prime numbers. The GCD of two numbers is the largest number that divides both of them without leaving a remainder. For example, the prime factorization of 18 is (2^1 times 3^2), and that of 24 is (2^3 times 3^1). The GCD of 18 and 24, based on their factorizations, is (2^1 times 3^1 = 6). **Tasks**: 1. **Implement the function `prime_factorization(n: int) -> Dict[int, int]`.** * The function should compute and return the prime factorization of the given integer (n) as a dictionary where keys are prime numbers and values are their respective exponents. * Ensure that it raises a `ValueError` if (n) is not a positive integer greater than 1. **Example**: ```python >>> prime_factorization(18) {2: 1, 3: 2} >>> prime_factorization(29) {29: 1} >>> prime_factorization(-5) Traceback (most recent call last): ... ValueError: Input must be a positive integer greater than 1 ``` 2. **Implement the function `gcd(a: int, b: int) -> int`.** * The function should compute and return the greatest common divisor of the two given integers (a) and (b) using their prime factorizations. * Ensure that it raises a `ValueError` if (a) or (b) is not a positive integer greater than 1. **Example**: ```python >>> gcd(18, 24) 6 >>> gcd(29, 13) 1 >>> gcd(12, -15) Traceback (most recent call last): ... ValueError: Both inputs must be positive integers greater than 1 ``` **Input Constraints**: - (2 leq n, a, b leq 10^6) **Assumptions**: - The provided integers are within the constraint limits and are valid for prime factorization. Your implementation should be efficient and handle edge cases such as very large numbers appropriately.","solution":"from typing import Dict import math def prime_factorization(n: int) -> Dict[int, int]: if n <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") factors = {} # Check for number of twos in n and divide by two while n % 2 == 0: factors[2] = factors.get(2, 0) + 1 n //= 2 # Check for odd factors from 3 to sqrt(n) for i in range(3, int(math.sqrt(n)) + 1, 2): while n % i == 0: factors[i] = factors.get(i, 0) + 1 n //= i # If n is still a prime number and greater than 2 if n > 2: factors[n] = 1 return factors def gcd(a: int, b: int) -> int: if a <= 1 or b <= 1: raise ValueError(\\"Both inputs must be positive integers greater than 1\\") factors_a = prime_factorization(a) factors_b = prime_factorization(b) common_factors = {} for prime in factors_a: if prime in factors_b: common_factors[prime] = min(factors_a[prime], factors_b[prime]) gcd_value = 1 for prime, exponent in common_factors.items(): gcd_value *= prime ** exponent return gcd_value"},{"question":"# Problem Description: You are given a class `Node` that represents a node in a singly linked list, and another class `LinkedList` that manages the linked list operations. Extend the functionality of the `LinkedList` class by implementing the following additional method: **Task**: Implement a method `reverse_k_group` which reverses every `k` nodes in the linked list. # Definition ```python class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, new_data): new_node = Node(new_data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def reverse_k_group(self, k: int) -> None: Reverses every `k` nodes in the linked list. Time complexity: O(n) @param k: The number of nodes in each group to reverse. @returns: None. self.head = self._reverse_k_group(self.head, k) def _reverse_k_group(self, head: Node, k: int) -> Node: if head is None: return None current = head count = 0 # Check the count of nodes in linked list while (current is not None and count < k): current = current.next count += 1 if count == k: current = head next = None prev = None count = 0 while (current is not None and count < k): next = current.next current.next = prev prev = current current = next count += 1 if next is not None: head.next = self._reverse_k_group(next, k) return prev return head def print_list(self): result = [] temp = self.head while temp: result.append(temp.data) temp = temp.next return result ``` **Input**: - An integer `k` representing the number of nodes in each group to be reversed. **Output**: - The linked list reversed in groups of size `k`. # Constraints: - All nodes of the linked list must be properly managed and linked. - The method should handle edge cases (e.g., size of linked list smaller than `k` or `k` equals 1). # Example Consider a sample usage below: ```python # LinkedList initialization ll = LinkedList() for i in range(1, 8): ll.append(i) # Before reversing print(ll.print_list()) # Output: [1, 2, 3, 4, 5, 6, 7] # Reversing in groups of 3 ll.reverse_k_group(3) print(ll.print_list()) # Output: [3, 2, 1, 6, 5, 4, 7] # Reversing in groups of 2 ll.reverse_k_group(2) print(ll.print_list()) # Output: [2, 3, 5, 6, 4, 1, 7] ``` **Notes**: - Ensure proper handling of different sizes of `k` relative to the length of the linked list. - Maintain the integrity of the linked list structure after each operation. - Test for various starting conditions, including edge cases like a very small or empty list.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def append(self, new_data): new_node = Node(new_data) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def reverse_k_group(self, k: int) -> None: Reverses every `k` nodes in the linked list. Time complexity: O(n) @param k: The number of nodes in each group to reverse. @returns: None. self.head = self._reverse_k_group(self.head, k) def _reverse_k_group(self, head: Node, k: int) -> Node: if head is None: return None current = head count = 0 # Check the count of nodes in linked list while (current is not None and count < k): current = current.next count += 1 if count == k: current = head next = None prev = None count = 0 while (current is not None and count < k): next = current.next current.next = prev prev = current current = next count += 1 if next is not None: head.next = self._reverse_k_group(next, k) return prev return head def print_list(self): result = [] temp = self.head while temp: result.append(temp.data) temp = temp.next return result"},{"question":"# Implement a Multi-threaded Downloader Your task is to create a multi-threaded file downloader. Given a URL to a file, your implementation should divide the download task into multiple parts, download these parts concurrently using threads, and combine the parts to reconstruct the original file. Input Format: 1. A single string representing the URL of the file to be downloaded. 2. An integer specifying the number of threads to use for downloading. Output Format: - The output should be the downloaded file saved in the local directory with the same name as specified in the URL. Constraints: - Ensure that the threads do not interfere with each other. - The downloaded parts should be reassembled correctly to form the complete file. - Handle exceptions such as network failures or invalid URLs gracefully, ensuring any partially downloaded files are cleaned up. - Your solution should achieve a significant speed-up compared to single-threaded downloading. Example Assume you need to download a file from `http://example.com/file.zip` using 4 threads: ```python download_file(\\"http://example.com/file.zip\\", 4) ``` This should start 4 threads to download different parts of the file concurrently and then combine them to produce `file.zip` in the current directory. **Function Signature:** ```python def download_file(url: str, num_threads: int) -> None: pass ```","solution":"import os import requests from threading import Thread def download_part(url, start, end, part_num): headers = {\'Range\': f\'bytes={start}-{end}\'} response = requests.get(url, headers=headers, stream=True) with open(f\'part_{part_num}\', \'wb\') as file_part: file_part.write(response.content) def download_file(url: str, num_threads: int) -> None: response = requests.head(url) file_name = url.split(\'/\')[-1] file_size = int(response.headers[\'Content-Length\']) part_size = file_size // num_threads threads = [] # Download file by parts using threads for i in range(num_threads): start = i * part_size # If last part, it should go up to the end of the file. end = (i + 1) * part_size - 1 if i != num_threads - 1 else file_size - 1 thread = Thread(target=download_part, args=(url, start, end, i)) threads.append(thread) thread.start() for thread in threads: thread.join() # Combine parts into a single file with open(file_name, \'wb\') as final_file: for i in range(num_threads): with open(f\'part_{i}\', \'rb\') as file_part: final_file.write(file_part.read()) os.remove(f\'part_{i}\')"},{"question":"# String Compression Algorithm Implementation You are given a string `s` consisting of lowercase alphabetical characters. Your task is to implement a function `compress_string` that compresses the string using the following basic run-length encoding technique: for a sequence of repeated characters, replace it by the character followed by its count. If the compressed string is not shorter than the original string, return the original string. Input * A single string `s` where: * `s` consists only of lowercase alphabetical characters. * The length of `s` is between 1 and 1000. Output * A string that represents the run-length encoded version of the input string. If the encoded string is not shorter than the original string, return the original string instead. Constraints * You may assume that the string contains only lowercase alphabetical characters. * The function should handle both short and long sequences efficiently. Requirements * Your code should be designed to handle edge cases effectively. * Ensure that the compression maintains the original order of characters. # Example ```python def compress_string(s: str) -> str: # Your implementation goes here # Example usage: # compress_string(\\"aabcccccaaa\\") # Output: \\"a2b1c5a3\\" # compress_string(\\"abc\\") # Output: \\"abc\\" ``` # Performance Considerations While implementing `compress_string`, consider: * Ensuring that the function runs efficiently even for the longest permissible string. * Handling cases where the compressed string might not be shorter than the original string. Your function will be evaluated based on correctness, efficiency, and code clarity.","solution":"def compress_string(s: str) -> str: Compresses a string using a basic run-length encoding technique. For a sequence of repeated characters, it replaces the sequence with the character followed by its count. If the compressed string is not shorter than the original string, it returns the original string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Add the last character group compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question **Context:** In many financial applications, tracking running medians is important for analyzing changes in data over time efficiently. The median is the middle value in a list when sorted, or the average of the two middle values if the list has an even number of elements. **Problem Statement:** Write a function `running_median(data: List[int]) -> List[float]` that takes in a list of integers `data` and returns a list of running medians. The running median is updated as each new element is added. **Input:** - A list `data` of integers where `1 ≤ len(data) ≤ 10^5` and each element is between `-10^9` and `10^9`. **Output:** - A list of floating point numbers representing the running median after each new element in the input list is added. **Constraints:** - The input list will always contain at least one element. - The function should run efficiently to handle the upper constraints. # Function Signature ```python def running_median(data: List[int]) -> List[float]: pass ``` # Examples ```python # Example 1: print(running_median([1, 2, 3, 4, 5])) # Output: [1.0, 1.5, 2.0, 2.5, 3.0] # Example 2: print(running_median([2, 1, 5, 7, 2, 0, 5])) # Output: [2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0] ```","solution":"import heapq def running_median(data): Returns a list of running medians of the input data. lower_half = [] # max-heap to store the lower half of the elements upper_half = [] # min-heap to store the upper half of the elements medians = [] for number in data: if not lower_half or number <= -lower_half[0]: heapq.heappush(lower_half, -number) else: heapq.heappush(upper_half, number) # Rebalance the heaps if len(lower_half) > len(upper_half) + 1: heapq.heappush(upper_half, -heapq.heappop(lower_half)) elif len(upper_half) > len(lower_half): heapq.heappush(lower_half, -heapq.heappop(upper_half)) # Calculate the median if len(lower_half) == len(upper_half): median = (-lower_half[0] + upper_half[0]) / 2.0 else: median = float(-lower_half[0]) medians.append(median) return medians"},{"question":"# Question: Find the Largest Connected Component in a Graph Background: You are required to write a function that finds the largest connected component in an undirected graph. In graph theory, a connected component (or just component) of an undirected graph is a subgraph in which any two vertices are connected to each other by paths, and which is connected to no additional vertices in the supergraph. Requirements: 1. Implement a function `largest_connected_component(graph: Dict[int, List[int]]) -> int` that returns the size of the largest connected component in the given undirected graph. 2. The graph is represented as an adjacency list where keys are node identifiers and values are lists of adjacent nodes. Input: - A dictionary `graph` representing an adjacency list of an undirected graph. Each key-value pair represents a node and its neighbors. Output: - Return the size (number of nodes) of the largest connected component in the graph. Constraints: - The graph will contain between 1 and 1000 nodes. - The node identifiers will be non-negative integers. - The adjacency list will not contain duplicate edges, and there will be no self-loops. Examples: ```python assert largest_connected_component({ 0: [1, 2], 1: [0], 2: [0], 3: [4], 4: [3] }) == 3 assert largest_connected_component({ 0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4, 5], 4: [3, 5], 5: [3, 4], 6: [] }) == 3 assert largest_connected_component({ 0: [1], 1: [0], 2: [3], 3: [2], 4: [5, 6], 5: [4, 6], 6: [4, 5], 7: [], 8: [] }) == 3 assert largest_connected_component({ 0: [], 1: [2], 2: [1] }) == 2 assert largest_connected_component({ 0: [1, 3], 1: [0, 2], 2: [1, 3], 3: [0, 2] }) == 4 ``` Hints: - Use Depth First Search (DFS) or Breadth First Search (BFS) to explore the graph and identify connected components. - Track visited nodes to avoid revisiting and recounting nodes in already discovered components. - Initialize a max_size variable to keep track of the largest component size encountered during the traversal.","solution":"def largest_connected_component(graph): def dfs(node): stack = [node] size = 0 while stack: current = stack.pop() if current not in visited: visited.add(current) size += 1 stack.extend(graph.get(current, [])) return size visited = set() max_size = 0 for node in graph: if node not in visited: component_size = dfs(node) max_size = max(max_size, component_size) return max_size"},{"question":"# Weather Data Analysis using Linear Regression Given a dataset containing historical weather data, implement a Linear Regression algorithm to predict future temperatures. The dataset includes features like day of the year, average humidity, average wind speed, and temperature. **Input**: * A `train_data` list of lists, each containing three numeric values representing the features (day of the year, average humidity, average wind speed) for training samples. * A `train_target` list of floats representing the average temperatures of training samples. * A `test_data` list of lists, each containing three numeric values for the test features. **Output**: * A list of predicted temperatures for each test sample. **Function Signature**: ```python def linear_regression_predict(train_data: list[list[float]], train_target: list[float], test_data: list[list[float]]) -> list[float]: # Function implementation ``` **Constraints**: * Features will always be valid numerical values. * Temperatures are real numbers and can be negative or positive. **Example**: ```python # Training Data train_data = [ [120, 65, 5.7], [200, 70, 4.5], [300, 75, 6.1], [150, 68, 5.0], [250, 72, 5.5] ] train_target = [22.5, 25.0, 30.0, 23.0, 27.5] # Test Data test_data = [ [170, 67, 5.2], [220, 73, 4.8] ] # Expected Output # Predicted temperatures for the given test data print(linear_regression_predict(train_data, train_target, test_data)) # Output: [24.0, 26.5] (Example values, actual implementation needed) ``` Ensure to consider the edge cases and normalize the features appropriately in your implementation.","solution":"from sklearn.linear_model import LinearRegression def linear_regression_predict(train_data: list[list[float]], train_target: list[float], test_data: list[list[float]]) -> list[float]: Predicts temperature using linear regression based on training data. Parameters: train_data: A list of lists containing the training features. train_target: A list of training target values. test_data: A list of lists containing the test features. Returns: A list of predicted temperatures for the test data. # Create the linear regression model model = LinearRegression() # Fit the model on the training data model.fit(train_data, train_target) # Predict using the model on the test data predictions = model.predict(test_data) return predictions.tolist()"},{"question":"# Problem Statement You are required to design a class `Matrix2D` that represents a 2D matrix and provides basic matrix operations. The class should support the following functionalities: 1. **Initialization**: Initialize the matrix with a nested list of numbers. 2. **Addition**: Implement a method to add two matrices, if they have the same dimensions. 3. **Multiplication**: Implement a method to multiply two matrices, ensuring the dimensions are compatible for multiplication. 4. **Transposition**: Implement a method to transpose the matrix. # Implementation Details - Create the `Matrix2D` class that: - Initializes a 2D matrix represented internally as a list of lists. - Has methods to add, multiply, and transpose matrices. # Input & Output Formats - **Input**: The matrix will be initialized with a nested list of numbers. - `Matrix2D([[a, b], [c, d]])` - **Output**: - `add(matrix2)` method should return a new `Matrix2D` object representing the sum of the two matrices. - `multiply(matrix2)` method should return a new `Matrix2D` object representing the product of the two matrices. - `transpose()` method should return a new `Matrix2D` object representing the transposed matrix. # Constraints - Elements of the matrix must be numeric values (integers or floats). - Ensure that matrix addition and multiplication handle dimensional compatibility, raising appropriate errors if the dimensions are not compatible. # Example ```python # Assume necessary dependencies are implemented as defined in the provided snippet. m1 = Matrix2D([[1, 2], [3, 4]]) m2 = Matrix2D([[5, 6], [7, 8]]) print(m1.add(m2).matrix) # Expected output: [[6, 8], [10, 12]] print(m1.multiply(m2).matrix) # Expected output: [[19, 22], [43, 50]] print(m1.transpose().matrix) # Expected output: [[1, 3], [2, 4]] invalid_add = Matrix2D([[1, 2], [3, 4], [5, 6]]) m1.add(invalid_add) # Should raise ValueError: Matrices do not have the same dimensions for addition. ``` # Performance Requirements - Ensure the implementation efficiently handles matrix operations, especially with larger dimensions. - Raise appropriate errors for invalid input or incompatible dimensions.","solution":"class Matrix2D: def __init__(self, matrix): self.matrix = matrix def add(self, other): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices do not have the same dimensions for addition.\\") result = [ [self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return Matrix2D(result) def multiply(self, other): if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Matrices are not compatible for multiplication.\\") result = [ [ sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(other.matrix))) for j in range(len(other.matrix[0])) ] for i in range(len(self.matrix)) ] return Matrix2D(result) def transpose(self): result = [ [self.matrix[j][i] for j in range(len(self.matrix))] for i in range(len(self.matrix[0])) ] return Matrix2D(result)"},{"question":"# Coding Question: Implement a Custom Sorting Function for a Given Data Structure **Objective**: Develop a custom sorting function for a specific data structure - a `LinkedList`. The objective is to sort the elements of the linked list using Merge Sort algorithm, which is known for its efficiency and stable sorting mechanism. Task Description: You need to implement a `LinkedList` class with a custom sorting function as described below: 1. **Node Class**: - A nested class within `LinkedList` called `Node` to represent the linked list nodes. 2. **LinkedList Initialization**: - Initialize an empty linked list. 3. **Insertion Method**: - Method to append elements to the linked list. 4. **Merge Sort Helper Methods**: - Implement helper methods to find the middle of the linked list, merge two sorted linked lists, and perform the merge sort recursively. 5. **Sort Method**: - A method to sort the linked list using the merge sort algorithm. 6. **Traversal Method**: - Traverse the linked list and print its elements. Implementation: ```python class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self) -> None: self.head = None def append(self, value) -> None: new_node = self.Node(value) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def _merge_sort(self, head): if not head or not head.next: return head middle = self._get_middle(head) next_to_middle = middle.next middle.next = None left = self._merge_sort(head) right = self._merge_sort(next_to_middle) sorted_list = self._sorted_merge(left, right) return sorted_list def _get_middle(self, head): if not head: return head slow, fast = head, head.next while fast and fast.next: slow, fast = slow.next, fast.next.next return slow def _sorted_merge(self, left, right): if not left: return right if not right: return left if left.value <= right.value: result = left result.next = self._sorted_merge(left.next, right) else: result = right result.next = self._sorted_merge(left, left) return result def sort(self) -> None: self.head = self._merge_sort(self.head) def print_list(self) -> None: current = self.head while current: print(current.value, end=\\" -> \\") current = current.next print(\\"None\\") # Example Usage: if __name__ == \\"__main__\\": ll = LinkedList() ll.append(4) ll.append(2) ll.append(5) ll.append(1) ll.append(3) print(\\"Linked List before sorting:\\") ll.print_list() ll.sort() print(\\"Linked List after sorting:\\") ll.print_list() ``` **Constraints**: - The linked list should only contain integer values. - Avoid using Python\'s standard libraries for sorting (e.g., `list.sort()` or `sorted()`). **Performance Consideration**: - Ensure the sorting function is efficient with a time complexity of O(n log n). - The method `sort()` should work seamlessly for linked lists up to 10,000 elements.","solution":"class LinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self) -> None: self.head = None def append(self, value) -> None: new_node = self.Node(value) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def _merge_sort(self, head): if not head or not head.next: return head middle = self._get_middle(head) next_to_middle = middle.next middle.next = None left = self._merge_sort(head) right = self._merge_sort(next_to_middle) sorted_list = self._sorted_merge(left, right) return sorted_list def _get_middle(self, head): if not head: return head slow, fast = head, head.next while fast and fast.next: slow, fast = slow.next, fast.next.next return slow def _sorted_merge(self, left, right): if not left: return right if not right: return left if left.value <= right.value: result = left result.next = self._sorted_merge(left.next, right) else: result = right result.next = self._sorted_merge(left, right.next) return result def sort(self) -> None: self.head = self._merge_sort(self.head) def to_list(self) -> list: result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Problem Statement You are required to design a class `WordDictionary` to manage a collection of words and support efficient word search operations with support for regular expressions. The `WordDictionary` should support the following functionalities: 1. **Initialization**: Construct the dictionary. 2. **Add Word**: Add a word to the dictionary. 3. **Search Word**: Search whether a word with a regular expression exists in the dictionary. Your implementation should consider the efficient management and search of words using tries or any other efficient data structure to handle regular expressions. # Function Signatures ```python class WordDictionary: def __init__(self) -> None: Initializes the data structure. def add_word(self, word: str) -> None: Adds a word to the dictionary. def search(self, word: str) -> bool: Returns True if there exists any word in the dictionary that matches the given word with wildcards, False otherwise. The word can contain the dot character \'.\' to represent any one letter. ``` # Input Constraints - The words added to the dictionary have a length of up to `500` characters. - The characters in the words will be lowercase English letters (\'a\' - \'z\'). - The search words will also have a length of up to `500` characters and may contain the dot character `.` which represents any one letter. - Operations on the dictionary (initialize, add word, search word) may be called multiple times. # Example Usage ```python # Initialize the dictionary wd = WordDictionary() # Add words to the dictionary wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") # Search for words print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` # Constraints - You must handle edge cases such as empty word inputs and wildcards in different positions. - Aim to optimize the performance of the search to handle frequent operations efficiently.","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # End of word marker def search(self, word: str) -> bool: def dfs(node, word): for i, char in enumerate(word): if char == \'.\': for key in node: if key != \'#\' and dfs(node[key], word[i+1:]): return True return False if char not in node: return False node = node[char] return \'#\' in node return dfs(self.trie, word)"},{"question":"# Problem Statement You have been assigned to design a function called `summarize_transactions` to process a list of financial transactions and summarize the total income and expenses. Transactions are represented as a list of tuples, where each tuple contains the transaction type (`\\"income\\"` or `\\"expense\\"`) and the amount (a positive float). You must return a dictionary with two keys: `\\"total_income\\"` and `\\"total_expense\\"` displaying the summed amounts for each type of transaction, rounded to 2 decimal places. # Input - **transactions**: A list of tuples, where each tuple contains a transaction type (`\\"income\\"` or `\\"expense\\"`) and a positive float representing the amount. # Output - A dictionary with two keys: `\\"total_income\\"` and `\\"total_expense\\"`, each mapped to a float rounded to 2 decimal places. # Constraints - Each transaction type will always be either `\\"income\\"` or `\\"expense\\"`. - Each amount in the transaction tuple will always be a positive float. - The transactions list will always have at least one transaction. # Examples ```python >>> summarize_transactions([(\\"income\\", 100.0), (\\"expense\\", 50.0), (\\"income\\", 200.0)]) {\'total_income\': 300.0, \'total_expense\': 50.00} >>> summarize_transactions([(\\"expense\\", 30.5), (\\"expense\\", 70.0), (\\"income\\", 100.0), (\\"income\\", 50.50)]) {\'total_income\': 150.5, \'total_expense\': 100.5} >>> summarize_transactions([(\\"income\\", 500.0)]) {\'total_income\': 500.0, \'total_expense\': 0.0} >>> summarize_transactions([(\\"expense\\", 50.75), (\\"expense\\", 25.25)]) {\'total_income\': 0.0, \'total_expense\': 76.0} ``` # Function Signature ```python def summarize_transactions(transactions: list) -> dict: pass ``` # Context Consider you are developing a small-scale personal finance application. This function is crucial in providing users with a clear summary of their financial activities, enabling them to understand their overall financial health at a glance.","solution":"def summarize_transactions(transactions): Summarizes the total income and expenses from a list of transactions. :param transactions: List of tuples, where each tuple contains the transaction type and the amount. :returns: Dictionary with \'total_income\' and \'total_expense\'. total_income = 0.0 total_expense = 0.0 for transaction in transactions: type_, amount = transaction if type_ == \\"income\\": total_income += amount elif type_ == \\"expense\\": total_expense += amount return { \\"total_income\\": round(total_income, 2), \\"total_expense\\": round(total_expense, 2) }"},{"question":"# Context You are working on a feature for an e-commerce platform that involves calculating the total price of items in a shopping cart. Each item in the cart has a unit price and a quantity, and you also need to account for a sales tax that varies by location. # Task Write a Python function that calculates the total price of all items in the cart, including tax. The function should handle edge cases like empty carts or zero quantities gracefully. # Function Signature ```python def calculate_total(cart: list, location: str) -> float: ``` # Requirements - The `cart` parameter is a list of dictionaries, where each dictionary represents an item in the cart and has two keys: `\\"unit_price\\"` and `\\"quantity\\"`. - `\\"unit_price\\"`: A float representing the price per single unit of the item. - `\\"quantity\\"`: An integer representing how many units of the item are being purchased. - The `location` parameter is a string that indicates the location for the sales tax. - The function should return the total price as a float, rounded to 2 decimal places. - The sales tax rates are as follows: - `\'NY\'`: 8.875% - `\'CA\'`: 7.25% - Other locations: 5.0% - If the cart is empty, the function should return 0. - If any item has a quantity of 0, it should be ignored in the total price calculation. # Constraints - Ensure the function handles invalid input gracefully, such as negative prices or quantities, by ignoring such items. - Use the built-in `round()` function to ensure the total price is rounded to 2 decimal places. # Example Usage ```python cart = [ {\\"unit_price\\": 19.99, \\"quantity\\": 2}, {\\"unit_price\\": 5.49, \\"quantity\\": 3}, {\\"unit_price\\": 7.99, \\"quantity\\": 1} ] total_price = calculate_total(cart, \'NY\') print(total_price) # Example output: 66.25 ``` # Notes - Use a loop to iterate over the items in the cart for the total calculation. - Ensure that any invalid input is handled appropriately, with such items being ignored in the calculation. - Consider edge cases such as empty carts and zero quantities while calculating the total price.","solution":"def calculate_total(cart: list, location: str) -> float: Calculates the total price of items in a shopping cart, including tax based on location. # Define the sales tax rates tax_rates = { \'NY\': 0.08875, \'CA\': 0.0725, \'default\': 0.05 } # Determine the applicable tax rate based on location sales_tax_rate = tax_rates.get(location, tax_rates[\'default\']) # Initialize total price total_price = 0.0 for item in cart: # Extract unit price and quantity, ignoring invalid entries unit_price = item.get(\\"unit_price\\", -1) quantity = item.get(\\"quantity\\", -1) if unit_price < 0 or quantity <= 0: continue # Calculate the subtotal price for the current item subtotal = unit_price * quantity total_price += subtotal # Apply sales tax to the total price total_with_tax = total_price * (1 + sales_tax_rate) # Return the total price rounded to 2 decimal places return round(total_with_tax, 2)"},{"question":"# Problem Description: You are given a list of strings where each string represents a word. Your task is to find all pairs of indices `(i, j)` such that the concatenation of the words at these indices results in a palindrome. # Function Signature: ```python def find_palindrome_pairs(words: List[str]) -> List[Tuple[int, int]]: pass ``` # Input: - `words`: A list of strings `words` where each `word` consists of lowercase English letters. # Output: - A list of tuples `(i, j)` where the concatenation of `words[i] + words[j]` is a palindrome. # Constraints: - (1 leq len(words) leq 5000) - (1 leq len(words[i]) leq 300) # Example: ```python # Example Usage words = [\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"] print(find_palindrome_pairs(words)) # Output: [(0, 1), (1, 0), (3, 2), (2, 4)] ``` # Explanation: In the given example, the following pairs of indices form palindromes when concatenated: - \\"abcd\\" + \\"dcba\\" -> \\"abcddcba\\" (palindrome) - \\"dcba\\" + \\"abcd\\" -> \\"dcbabcd\\" (palindrome) - \\"s\\" + \\"lls\\" -> \\"slls\\" (palindrome) - \\"lls\\" + \\"sssll\\" -> \\"llssssll\\" (palindrome) # Notes: - Palindromes are strings that read the same backward as forwards. - Ensure the function efficiently handles large inputs considering the constraints. - Consider using a hashmap or trie to optimize lookup times for potential palindromic pairs. # Edge Cases: - Handle cases where no pairs form a palindrome. - Consider words with varying lengths, including single-character words. - Ensure efficient processing time by avoiding redundant checks and using appropriate data structures for fast lookups.","solution":"def find_palindrome_pairs(words): def is_palindrome(word): return word == word[::-1] word_dict = {word: i for i, word in enumerate(words)} palindrome_pairs = [] for i, word in enumerate(words): n = len(word) for j in range(n + 1): prefix = word[:j] suffix = word[j:] if is_palindrome(prefix): rev_suffix = suffix[::-1] if rev_suffix in word_dict and word_dict[rev_suffix] != i: palindrome_pairs.append((word_dict[rev_suffix], i)) if j != n and is_palindrome(suffix): rev_prefix = prefix[::-1] if rev_prefix in word_dict and word_dict[rev_prefix] != i: palindrome_pairs.append((i, word_dict[rev_prefix])) return palindrome_pairs"},{"question":"Problem: Array Rotation Check You are tasked with checking if a given array is a rotation of another array. Two arrays are considered a rotation of one another if one of them can be obtained by cyclically rotating the other. Implement a function `is_rotation` which checks whether one array is a rotation of another. # Input: - Two lists of integers `arr1` and `arr2` where ( 0 leq text{len}(arr1), text{len}(arr2) leq 10^6 ) and each integer ( 1 leq text{abs(arr1[i])}, text{abs(arr2[i])} leq 10^6 ). # Output: - A boolean indicating whether `arr2` is a rotation of `arr1`. # Function Signature: ```python def is_rotation(arr1: List[int], arr2: List[int]) -> bool: ``` # Constraints: - Optimize for time and space complexity due to large possible input size. - Consider edge cases such as empty arrays, arrays of different lengths, etc. # Example: ```python >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> >>> is_rotation([1, 2, 3, 4, 5], [4, 5, 1, 3, 2]) False ``` # Explanation: - For the first example, the second array `[3, 4, 5, 1, 2]` is a rotation of the first array `[1, 2, 3, 4, 5]` by 2 positions. - For the second example, the second array `[4, 5, 1, 3, 2]` cannot be obtained by any cyclic rotation of the first array `[1, 2, 3, 4, 5]`; hence, the function returns `False`. # Notes: - Ensure to check for cases where the arrays have different lengths, as they cannot be rotations of one another. - Consider efficient string manipulation techniques to handle large arrays.","solution":"from typing import List def is_rotation(arr1: List[int], arr2: List[int]) -> bool: Checks whether arr2 is a rotation of arr1. if len(arr1) != len(arr2): return False if not arr1 and not arr2: # Case when both are empty lists return True # Concatenate arr1 to itself and check if arr2 is a substring of it concatenated = arr1 + arr1 return \' \'.join(map(str, arr2)) in \' \'.join(map(str, concatenated))"},{"question":"# Coding Assessment Question **Context**: You are growing a collection of utility functions to manipulate strings and need to handle specific pattern requirements efficiently. **Problem Statement**: Implement a function that checks if a string can be formed by repeating a substring for a given number of times. If it can, return the smallest such substring; otherwise, return an empty string. # Function Signature: ```python def find_repeating_pattern(s: str, k: int) -> str: pass ``` # Input: 1. **s (str)**: The input string you need to examine. 2. **k (int)**: The number of times the substring should repeat to form the string. # Output: Return the smallest substring that can be repeated `k` times to form the string `s`. If no such substring exists, return an empty string. # Constraints: 1. `1 <= len(s) <= 10^5` 2. `1 <= k <= len(s)` # Example: ```python assert find_repeating_pattern(\\"ababab\\", 3) == \\"ab\\" assert find_repeating_pattern(\\"abcd\\", 2) == \\"\\" assert find_repeating_pattern(\\"aaaa\\", 4) == \\"a\\" assert find_repeating_pattern(\\"xyzxyzxyz\\", 3) == \\"xyz\\" ``` # Explanation: 1. For the first input, \\"ababab\\" can be formed by repeating \\"ab\\" 3 times. 2. For the second input, \\"abcd\\" cannot be formed by repeating any substring 2 times, hence return an empty string. 3. For the third input, \\"aaaa\\" can be formed by repeating \\"a\\" 4 times. 4. For the fourth input, \\"xyzxyzxyz\\" can be formed by repeating \\"xyz\\" 3 times. # Notes: - Ensure to optimize for performance given the input size constraints. - Valid substring length for repeating pattern should be len(s) // k.","solution":"def find_repeating_pattern(s: str, k: int) -> str: if len(s) % k != 0: return \\"\\" # The length of the potential repeating substring repeat_len = len(s) // k # Candidate substring candidate = s[:repeat_len] # Check if repeating the candidate k times equals s if candidate * k == s: return candidate else: return \\"\\""},{"question":"Coding Assessment Question # Context: A wizard is organizing their book collection and wants to categorize the books based on their respective genres. The wizard has compiled a list of books, each with a title and genre. Help the wizard develop a program to create a categorized dictionary of books by genre. # Problem: Given a list of books, where each book is represented as a tuple (title, genre), write a function that returns a dictionary where the keys are the genres and the values are lists of titles belonging to each genre. # Function Signature: ```python def categorize_books(books: List[Tuple[str, str]]) -> Dict[str, List[str]]: ``` Input: - **books**: A list of tuples, where each tuple contains two strings: - **title**: The title of the book. - **genre**: The genre of the book. Output: - A dictionary where the keys are genres and the values are lists of titles of books in that genre, sorted alphabetically. Constraints: - `1 ≤ len(books) ≤ 1000` - Each tuple contains two non-empty strings where: - `1 ≤ len(title) ≤ 100` - `1 ≤ len(genre) ≤ 50` # Example: ```python # Input books = [ (\\"The Hobbit\\", \\"Fantasy\\"), (\\"1984\\", \\"Dystopian\\"), (\\"Brave New World\\", \\"Dystopian\\"), (\\"Harry Potter\\", \\"Fantasy\\"), (\\"The Road\\", \\"Post-apocalyptic\\"), (\\"The Fellowship of the Ring\\", \\"Fantasy\\") ] # Output { \\"Dystopian\\": [\\"1984\\", \\"Brave New World\\"], \\"Fantasy\\": [\\"Harry Potter\\", \\"The Fellowship of the Ring\\", \\"The Hobbit\\"], \\"Post-apocalyptic\\": [\\"The Road\\"] } ``` # Guidelines: - Ensure that the resulting dictionary has genres as keys and lists of book titles as values, each list sorted alphabetically. - Handle edge cases such as: - Books belonging to genres with only one book. - Multiple books with the same title under different genres. - Books with titles that include special characters or spaces. # Note: Make sure the function is efficient and processes the inputs correctly, creating a coherent and organized dictionary of books sorted by genre.","solution":"from typing import List, Tuple, Dict def categorize_books(books: List[Tuple[str, str]]) -> Dict[str, List[str]]: category_dict = {} for title, genre in books: if genre not in category_dict: category_dict[genre] = [] category_dict[genre].append(title) for genre in category_dict: category_dict[genre].sort() return category_dict"},{"question":"# Frequency of Elements in a List **Background**: You are required to design a program that analyzes the frequency of elements in a list. Given a list of integers, count the number of times each unique element appears and return a dictionary where the keys are the unique elements, and the values are their respective counts. **Function Specification**: Implement the function `element_frequency(sequence)` that counts the frequencies of all elements in the input list. **Input**: - `sequence`: A list of integers. **Output**: - A dictionary where keys are the unique elements from the list, and values are the frequencies of the elements in the list. **Constraints**: - The input list can have up to 10^5 elements. - The elements in the list can be any integer. **Performance Requirements**: - The solution should efficiently handle lists with a large number of elements. **Example**: ```python def element_frequency(sequence): # Your code here # Examples print(element_frequency([1, 2, 2, 3, 3, 3, 4])) # {1: 1, 2: 2, 3: 3, 4: 1} print(element_frequency([10, 20, 10, 30, 20])) # {10: 2, 20: 2, 30: 1} print(element_frequency([1])) # {1: 1} print(element_frequency([])) # {} print(element_frequency([5, 5, 5, 5, 5])) # {5: 5} ``` Implement the function to demonstrate your ability to analyze and count the frequency of elements effectively, ensuring that the solution handles both small and large input sizes efficiently.","solution":"def element_frequency(sequence): Counts the frequencies of all unique elements in the input list. Args: sequence: A list of integers. Returns: A dictionary with unique elements as keys and their frequencies as values. frequency_dict = {} for element in sequence: if element in frequency_dict: frequency_dict[element] += 1 else: frequency_dict[element] = 1 return frequency_dict"},{"question":"# Coding Assessment Question Scenario You\'re developing a module for a content management system (CMS) that requires dynamic alteration of HTML attributes based on user interactions. One of the prime requirements is managing and updating the `class` attributes of HTML elements efficiently. Task Write a Python function `toggle_class` that can toggle the presence of a CSS class within the `class` attribute of an HTML element represented as a string. If the CSS class is already present in the element\'s classes, it should be removed; if it is not present, it should be added. Function Signature ```python def toggle_class(html_element: str, css_class: str) -> str: pass ``` Input * `html_element` (str): A string representing an HTML element with its classes, e.g., `<div class=\\"blue large\\"></div>`. * `css_class` (str): A string representing the CSS class to toggle, e.g., `large`. Output * A string representing the updated HTML element with the toggled class. Constraints * Ignore leading and trailing whitespaces in the input HTML element string. * The function should handle empty `class` attributes appropriately. * Take care to preserve other attributes of the HTML element. * The input HTML element will always be properly formatted without nested elements. Example ```python >>> toggle_class(\'<div class=\\"blue large\\"></div>\', \'large\') \'<div class=\\"blue\\"></div>\' >>> toggle_class(\'<div class=\\"blue large\\"></div>\', \'red\') \'<div class=\\"blue large red\\"></div>\' >>> toggle_class(\'<div class=\\"blue\\"></div>\', \'blue\') \'<div></div>\' >>> toggle_class(\'<div class=\\"blue\\"></div>\', \'large\') \'<div class=\\"blue large\\"></div>\' >>> toggle_class(\'<p class=\\"text\\"></p>\', \'text\') \'<p></p>\' ``` Performance Requirements Ensure that the function handles typical length HTML elements efficiently and maintains readability and maintainability.","solution":"def toggle_class(html_element: str, css_class: str) -> str: Toggles the presence of a CSS class within the class attribute of an HTML element. Parameters: - html_element (str): A string representing an HTML element. - css_class (str): The CSS class to toggle. Returns: - str: The updated HTML element with the toggled class. tag_start = html_element.find(\'<\') tag_end = html_element.find(\'>\') tag_name = html_element[tag_start + 1: html_element.find(\' \', tag_start + 1)] class_pos_start = html_element.find(\'class=\\"\') if class_pos_start == -1: # If there\'s no class attribute and css_class needs to be added new_element = f\'{html_element[:tag_end]} class=\\"{css_class}\\"{html_element[tag_end:]}\' return new_element class_pos_end = html_element.find(\'\\"\', class_pos_start + 7) classes = html_element[class_pos_start + 7: class_pos_end].split() if css_class in classes: classes.remove(css_class) else: classes.append(css_class) new_classes_str = \' \'.join(classes) new_element = f\'{html_element[:class_pos_start + 7]}{new_classes_str}{html_element[class_pos_end:]}\' # Remove empty class attribute if new_classes_str == \'\': new_element = new_element.replace(\' class=\\"\\"\', \'\') return new_element.strip()"},{"question":"# Coding Assessment Question Scenario You are provided with a string that contains mixed letters and digits. Your task is to reformat the string such that the letters and digits alternate, beginning with a letter. If the transformation is not possible, return an empty string. Task Implement a function `reformat_string` that transforms the given string so that letters and digits alternate. If it\'s not possible to do so, return an empty string. Function Signature ```python def reformat_string(s: str) -> str: Transforms a string so that letters and digits alternate, starting with a letter. Returns an empty string if the transformation is not possible. :param s: The string to reformat. :return: The reformatted string or an empty string if not possible. ``` Input - A string `s`, where: * `1 <= len(s) <= 10^5` * `s` contains only alphanumeric characters Output - A string representing the reformatted string that alternates letters and digits, starting with a letter, or an empty string if the transformation is not possible. Examples - Example 1: ```python s = \\"a0b1c2\\" return = \\"a0b1c2\\" ``` - Example 2: ```python s = \\"123abc\\" return = \\"a1b2c3\\" ``` - Example 3: ```python s = \\"ab12\\" return = \\"a1b2\\" ``` - Example 4: ```python s = \\"abcd1234\\" return = \\"a1b2c3d4\\" ``` - Example 5: ```python s = \\"a1b3C\\" return = \\"a1b3C\\" ``` - Example 6: ```python s = \\"aaa\\" return = \\"\\" ``` Notes - The function should handle cases where there are more letters than digits or vice versa. - If the difference in count between letters and digits is more than 1, it is not possible to create such a string, and the function should return an empty string. Explanation: 1. Separate the input string into letters and digits. 2. If the difference in the number of letters and digits is more than one, return an empty string. 3. Otherwise, interleave the letters and digits starting with a letter. 4. Return the reformatted string. # Solution: ```python def reformat_string(s: str) -> str: letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" if len(letters) < len(digits): letters, digits = digits, letters result = [] for i in range(len(s)): if i % 2 == 0: result.append(letters.pop()) else: result.append(digits.pop()) return \\"\\".join(result) ``` This provided solution ensures the string is properly alternated between letters and digits and handles the cases where the transformation is not possible.","solution":"def reformat_string(s: str) -> str: letters = [ch for ch in s if ch.isalpha()] digits = [ch for ch in s if ch.isdigit()] if abs(len(letters) - len(digits)) > 1: return \\"\\" if len(letters) < len(digits): letters, digits = digits, letters result = [] for i in range(len(s)): if i % 2 == 0: result.append(letters.pop(0)) else: result.append(digits.pop(0)) return \\"\\".join(result)"},{"question":"# Product of Array Except Self Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`. Key Constraints - You must write an algorithm that runs in `O(n)` time. - Do not use division and achieve the output array with `O(1)` space complexity (excluding the space for the output array). # Function Signature ```python def product_except_self(nums: List[int]) -> List[int]: pass ``` Input Constraints - `2 <= len(nums) <= 10^5` - `-30 <= nums[i] <= 30` - The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer. # Expected Output - A list of integers where the value at each index is the product of all the numbers in the input array except for the number at that index. Example ```python >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0] ``` Steps 1. Initialize a list `answer` of length `n` (where `n` is the length of `nums`) and set all elements to 1. 2. Use a variable `left_product` to represent the product of all elements to the left of `i`. 3. Traverse the array from left to right to populate `answer[]` with the product of elements to the left of each element. 4. Use a variable `right_product` to represent the product of all elements to the right of `i`. 5. Traverse the array from right to left to multiply each element in `answer[]` by the corresponding `right_product`. Implement the `product_except_self` function that satisfies the above requirements.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) answer = [1] * n left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"# Objective Implement a function to validate and extract useful information from email addresses. The function should handle various edge cases, such as invalid email formats and domain-specific rules. # Task Write a Python function `extract_email_info(email: str) -> dict` that takes an email address as input and returns a dictionary with the extracted information. The function should handle the following: - Validate the email format. - Extract the username and domain part of the email. - Identify and handle common free email providers (e.g., Gmail, Yahoo, Outlook) with a specific flag in the output. - Ensure the function is robust and handles invalid email formats gracefully. # Input - `email` (string): The email address to validate and extract information from. # Output - A dictionary with the following keys: - `is_valid` (bool): Indicates whether the email format is valid. - `username` (string): The username part of the email. - `domain` (string): The domain part of the email. - `is_free_provider` (bool): Indicates whether the domain is a common free email provider. # Constraints - Consider only the common TLDs (e.g., .com, .net, .org, .edu, .gov) for validation. - Implement your own validation logic without relying on external libraries. # Example Usage ```python email_info = extract_email_info(\\"john.doe@gmail.com\\") print(email_info) # Output: # { # \\"is_valid\\": True, # \\"username\\": \\"john.doe\\", # \\"domain\\": \\"gmail.com\\", # \\"is_free_provider\\": True # } ``` # Notes - If the email format is invalid, `is_valid` should be False, and other keys can have empty string or False as appropriate. - Examples of common free email providers to check for: `gmail.com`, `yahoo.com`, `outlook.com`. - Ensure that your function adheres to best practices for validation and string handling. ```python def extract_email_info(email: str) -> dict: import re result = { \\"is_valid\\": False, \\"username\\": \\"\\", \\"domain\\": \\"\\", \\"is_free_provider\\": False } free_providers = {\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"} email_regex = re.compile( r\\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+)\\" ) if email_regex.match(email): result[\\"is_valid\\"] = True username, domain = email.split(\'@\') result[\\"username\\"] = username result[\\"domain\\"] = domain if domain in free_providers: result[\\"is_free_provider\\"] = True return result # Example usage email_info = extract_email_info(\\"john.doe@gmail.com\\") print(email_info) ```","solution":"def extract_email_info(email: str) -> dict: import re # Initialize the output dictionary with default values result = { \\"is_valid\\": False, \\"username\\": \\"\\", \\"domain\\": \\"\\", \\"is_free_provider\\": False } # The set of common free email providers free_providers = {\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"} # Regular expression for validating email email_regex = re.compile( r\\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+)\\" ) if email_regex.match(email): result[\\"is_valid\\"] = True username, domain = email.split(\'@\') result[\\"username\\"] = username result[\\"domain\\"] = domain if domain in free_providers: result[\\"is_free_provider\\"] = True return result # Example usage email_info = extract_email_info(\\"john.doe@gmail.com\\") print(email_info)"},{"question":"# Coding Assessment Question Context As part of a larger software system dealing with dates and times, you are tasked with writing a function to determine if a specific year is a leap year. Leap years are important for accurate date calculations, including determining the correct number of days in a year. Problem Description Write a function `is_leap_year` that takes a single integer parameter `year` and returns a boolean indicating whether the specified year is a leap year. A leap year is exactly divisible by 4, except for years that are exactly divisible by 100, but these centurial years are leap years if they are exactly divisible by 400. Input and Output - **Input**: - `year` (int): The year to check (must be a positive integer). - **Output**: - Returns `True` if `year` is a leap year, and `False` otherwise. - Raises a `ValueError` if `year` is less than 1. - Raises a `TypeError` if `year` cannot be cast to an integer. Constraints - You are only allowed to use standard Python libraries. - The function should handle years within typical use case ranges (e.g., year 1 through year 9999). Examples ``` >>> is_leap_year(2020) True >>> is_leap_year(1900) False >>> is_leap_year(2000) True >>> is_leap_year(2019) False >>> is_leap_year(-5) Traceback (most recent call last): ... ValueError: The input must be a positive integer. >>> is_leap_year(\\"two thousand twenty\\") Traceback (most recent call last): ... TypeError: The input must be an integer or castable to an integer. ``` Performance Requirement Your solution should efficiently handle years within the range of 1 and 9999, ensuring both correctness and performance. Hints - Review the rules for determining if a year is a leap year. - Use conditional statements to implement the logic for leap years. - Consider input validation to handle edge cases and incorrect input types.","solution":"def is_leap_year(year): Determines if a given year is a leap year. Parameters: year (int): The year to check (must be a positive integer). Returns: bool: True if `year` is a leap year, and False otherwise. Raises: ValueError: If `year` is less than 1. TypeError: If `year` cannot be cast to an integer. if not isinstance(year, int): raise TypeError(\\"The input must be an integer or castable to an integer.\\") if year < 1: raise ValueError(\\"The input must be a positive integer.\\") if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return True else: return False"},{"question":"# Scenario You are currently developing a file management system and need to ensure that the system can handle a variety of file paths efficiently. One of the tasks required is to normalize file paths, simplifying them by resolving any redundant components such as `.` (current directory) or `..` (parent directory). Implementing a robust path normalization function that can handle both absolute and relative paths is essential to maintain the integrity of file references in the system. # Problem Statement **Task**: Implement a function to normalize a given Unix-like file path to its simplest form. # Input & Output **Function Name**: `normalize_path` **Input**: - `path`: A string, representing the Unix-like file path to be normalized. **Output**: - A string, representing the normalized file path. # Constraints - The input path will only contain valid characters for Unix-like file paths. - The input path may begin with `/`, indicating an absolute path. - The normalized path must not end with a slash (`/`), except when it represents the root directory (`/`). - Handle any redundant slashes (`//`), current directory indicators (`./`), and parent directory indicators (`..`). # Examples ```python path1 = \\"/home/./user/../documents//file.txt\\" assert normalize_path(path1) == \\"/home/documents/file.txt\\" path2 = \\"user/../user2/./documents/file.txt\\" assert normalize_path(path2) == \\"user2/documents/file.txt\\" path3 = \\"/var//log/././../tmp/\\" assert normalize_path(path3) == \\"/var/tmp\\" path4 = \\"images/cat/../../videos/dog\\" assert normalize_path(path4) == \\"videos/dog\\" ``` # Performance Requirements - The solution should have a time complexity of O(N), where N is the length of the input path. - The space complexity should also be O(N). ```python def normalize_path(path: str) -> str: Normalize the given Unix-like file path. if not path: return \\"\\" parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"..\\": if stack and stack[-1] != \\"\\": stack.pop() elif part == \\".\\" or part == \\"\\": continue else: stack.append(part) normalized_path = \\"/\\" + \\"/\\".join(stack) if path.startswith(\\"/\\") else \\"/\\".join(stack) return \\"/\\" if normalized_path == \\"\\" else normalized_path # Testing the function with provided examples assert normalize_path(\\"/home/./user/../documents//file.txt\\") == \\"/home/documents/file.txt\\" assert normalize_path(\\"user/../user2/./documents/file.txt\\") == \\"user2/documents/file.txt\\" assert normalize_path(\\"/var//log/././../tmp/\\") == \\"/var/tmp\\" assert normalize_path(\\"images/cat/../../videos/dog\\") == \\"videos/dog\\" ```","solution":"def normalize_path(path: str) -> str: Normalize the given Unix-like file path. if not path: return \\"\\" parts = path.split(\\"/\\") stack = [] for part in parts: if part == \\"..\\": if stack and stack[-1] != \\"\\": stack.pop() elif part == \\".\\" or part == \\"\\": continue else: stack.append(part) normalized_path = \\"/\\" + \\"/\\".join(stack) if path.startswith(\\"/\\") else \\"/\\".join(stack) return \\"/\\" if normalized_path == \\"\\" else normalized_path"},{"question":"# Decision Tree Classifier Coding Question You are given a dataset containing various features of patients and their corresponding diagnosis labels. Your task is to implement a function using a `DecisionTreeClassifier` that trains on these features to predict the diagnosis. Follow these steps for implementation: **Function Implementation:** 1. **Function Signature**: `def decision_tree_predict(data: dict) -> np.ndarray:` 2. **Input**: The input will be a dictionary with two keys, - `features`: A list of lists where each inner list represents the features of a patient. - `labels`: A list of diagnosis labels (\'M\' for malignant, \'B\' for benign) corresponding to each list of features in `features`. 3. **Process**: * Split the dataset into training and testing sets using a 70-30 ratio for training and testing respectively. * Train a `DecisionTreeClassifier` using the training dataset. * Predict the diagnosis labels for the test dataset. 4. **Output**: A numpy array containing the predicted diagnosis labels for the test dataset. **Constraints**: * Ensure that all necessary preprocessing of the data is performed within the function. * Use appropriate Decision Tree hyperparameters to avoid overfitting and ensure efficient performance. * Evaluate the model performance using accuracy. **Example**: ```python >>> data = { ... \\"features\\": [ ... [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 1.0, 1.0, 2.0, 3.0], ... [10.0, 10.0, 10.0, 10.0, 7.0, 6.0, 4.0, 10.0, 4.0, 1.0], ... # Add more feature sets ... ], ... \\"labels\\": [\'B\', \'M\', # Add more diagnosis labels ... ] ... } >>> decision_tree_predict(data) array([\'B\', \'M\']) # Example output representing predicted diagnosis labels (not actual) ``` **Note**: The example provided in the main function of the code snippet is representative of a typical binary classification problem such as the Breast Cancer Wisconsin dataset. Refer to this example for guidance on processing and feature extraction. Good luck, and ensure your solution is well-tested across multiple scenarios to validate its robustness!","solution":"import numpy as np from sklearn.tree import DecisionTreeClassifier from sklearn.model_selection import train_test_split from sklearn.preprocessing import LabelEncoder def decision_tree_predict(data: dict) -> np.ndarray: Trains a DecisionTreeClassifier on the given dataset and predicts diagnosis labels on the test set. Parameters: - data: A dictionary containing \'features\' and \'labels\' Returns: - np.ndarray: Predicted diagnosis labels for the test set # Extract features and labels features = np.array(data[\'features\']) labels = np.array(data[\'labels\']) # Encode labels to numerical values label_encoder = LabelEncoder() encoded_labels = label_encoder.fit_transform(labels) # Split the dataset into training and testing sets X_train, X_test, y_train, y_test = train_test_split(features, encoded_labels, test_size=0.3, random_state=42) # Initialize and train the DecisionTreeClassifier clf = DecisionTreeClassifier(random_state=42) clf.fit(X_train, y_train) # Predict on the test set predictions = clf.predict(X_test) # Decode predicted labels back to original string values predicted_labels = label_encoder.inverse_transform(predictions) return predicted_labels"},{"question":"# Maze Solver with Depth-First Search Scenario You are tasked with programming a maze solver for an autonomous drone. The drone needs to find a path from its starting position to a target location within a maze-like environment, represented as a grid with walls and open spaces. Objective Implement the `DepthFirstMazeSolver` class to find a path from the start position to the target using Depth-First Search (DFS). Your solution should showcase your understanding of graph traversal algorithms. Requirements 1. **Input**: - A grid represented as a 2D list of integers, where `0` denotes open space and `1` denotes walls. - A tuple `start` representing the starting coordinates `(row, col)`. - A tuple `goal` representing the target coordinates `(row, col)`. 2. **Output**: - A list of coordinates (tuples) forming the path from `start` to `goal`, or `None` if no path exists. 3. **Constraints**: - The grid will have dimensions `m x n`, where `1 <= m, n <= 500`. - The start and goal coordinates will always be valid and within bounds. 4. **Performance**: - The solution should handle grids up to the maximum size of `500x500` efficiently. Function Signature ```python class DepthFirstMazeSolver: def __init__(self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]): # initialization code def search(self) -> list[tuple[int, int]] | None: # code to perform search and return the path ``` Hints - Consider using a stack to manage the nodes to visit. - Implement a method to detect cycles and avoid revisiting nodes. - Handle possible edge cases such as running into walls or reaching grid boundaries. Example ```python grid = [ [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 1], [0, 0, 0, 0, 0], ] dfs = DepthFirstMazeSolver(grid, (0, 0), (4, 4)) path = dfs.search() print(path) # Expected output: [(0, 0), (1, 0), (2, 0), ..., (4, 4)] if a path exists ``` This additional question maintains consistency with the provided sample in terms of style, complexity, and length. It offers a different problem within the pathfinding domain by focusing on Depth-First Search, complementing the Greedy Best-First Search question.","solution":"class DepthFirstMazeSolver: def __init__(self, grid, start, goal): self.grid = grid self.start = start self.goal = goal self.m = len(grid) self.n = len(grid[0]) self.visited = set() def search(self): stack = [(self.start, [self.start])] self.visited.add(self.start) while stack: (current, path) = stack.pop() if current == self.goal: return path for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]: neighbor = (current[0] + direction[0], current[1] + direction[1]) if (0 <= neighbor[0] < self.m and 0 <= neighbor[1] < self.n and neighbor not in self.visited and self.grid[neighbor[0]][neighbor[1]] == 0): self.visited.add(neighbor) stack.append((neighbor, path + [neighbor])) return None"},{"question":"# Duplicate Elements in a Subarray Problem Statement Your task is to implement a function that returns a boolean indicating whether any duplicate element exists within a specific subarray of a given array. The subarray is defined by a specified sliding window size. Function Signature ```python def has_duplicate_within_window(arr: list[int], window_size: int) -> bool: pass ``` Input * `arr`: A list of integers representing the array. * `window_size`: An integer representing the size of the sliding window (1 ≤ window_size ≤ len(arr)). Output * Returns `True` if any duplicate elements exist within any subarray of the specified window size; otherwise, returns `False`. Constraints * The length of the array (N) can be in the range [1, 10^4]. Example Consider the following array and window size: * Input: ```python arr = [1, 3, 2, 1, 4, 5, 2, 6] window_size = 4 result = has_duplicate_within_window(arr, window_size) ``` * Output: ```python True ``` Explanation * Subarray [1, 3, 2, 1] contains duplicates within the specified window size (4) => True * Other sliding subarrays of size 4 like [3, 2, 1, 4], [2, 1, 4, 5], [1, 4, 5, 2], and [4, 5, 2, 6] do not contain duplicates. Notes * Ensure that any edge cases such as very small or large window sizes, arrays with unique elements, and arrays with all identical elements are correctly handled. * Aim to implement the solution with an efficient time complexity suitable for large arrays.","solution":"def has_duplicate_within_window(arr: list[int], window_size: int) -> bool: Returns True if there are any duplicate elements within any subarray of the specified window size in the given array. if window_size == 1: return False # No possibility of duplicates within a subarray of size 1. # Use a set to track elements within the current window. current_window_elements = set() for i in range(len(arr)): # Add the current element to the set. if arr[i] in current_window_elements: return True current_window_elements.add(arr[i]) # If the window size is exceeded, remove the element that\'s sliding out of the window. if i >= window_size - 1: current_window_elements.remove(arr[i - window_size + 1]) return False"},{"question":"# Problem Description You are tasked with implementing a function that finds the kth smallest element in an unsorted list of integers. The function should use an efficiency-oriented algorithm that guarantees good average-case performance. # Function Signature ```python def kth_smallest_element(data: list, k: int) -> int: pass ``` # Input * A list of integers `data` which can be empty or contain up to 10^5 elements. * An integer `k` where 1 ≤ k ≤ len(data). # Output * Returns the kth smallest element in the list `data`. # Constraints * The solution must have an expected time complexity of O(N), where N is the number of elements in `data`. * The function should handle edge cases such as an empty list gracefully by assuming the input constraints are always met (i.e., there is at least one element and valid k). * Implement an efficient selection algorithm, such as the Quickselect algorithm, to solve the problem. # Examples ```python assert kth_smallest_element([3, 1, 5, 4, 2], 3) == 3 assert kth_smallest_element([10, 4, 5, 8, 6, 11, 26], 5) == 10 assert kth_smallest_element([2, 1, 3, 4], 2) == 2 assert kth_smallest_element([7, 2, 1, 8, 6, 11, 3], 1) == 1 assert kth_smallest_element([13, 2, 1, 5, 7, 3, 4], 6) == 7 ``` # Notes * Consider using the Quickselect algorithm for its average case O(N) time complexity. * Ensure that you handle the in-place partitioning efficiently to minimize space complexity. * If there are multiple elements with the same value and they are positioned at the kth index, any one of them is an acceptable return.","solution":"def kth_smallest_element(data: list, k: int) -> int: Returns the kth smallest element in the list `data`. Uses the Quickselect algorithm. def partition(left, right, pivot_index): pivot_value = data[pivot_index] # Move pivot to end data[pivot_index], data[right] = data[right], data[pivot_index] store_index = left # Move all smaller elements to the left for i in range(left, right): if data[i] < pivot_value: data[store_index], data[i] = data[i], data[store_index] store_index += 1 # Move pivot to its final place data[right], data[store_index] = data[store_index], data[right] return store_index def quickselect(left, right, k_smallest): Return the k-th smallest element of list within left..right if left == right: return data[left] # Select a random pivot_index pivot_index = left + (right - left) // 2 # Find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return data[k_smallest] # go left elif k_smallest < pivot_index: return quickselect(left, pivot_index - 1, k_smallest) # go right else: return quickselect(pivot_index + 1, right, k_smallest) return quickselect(0, len(data) - 1, k - 1)"},{"question":"# Problem Statement You are developing a tool to analyze text files and extract useful metrics. One of the functionalities required is to compute the word frequency distribution of a given text. Write a function that takes a text string as input and returns a sorted list of tuples, where each tuple consists of a word and its frequency, ordered by frequency in descending order. Words should be treated case-insensitively and punctuation marks should be ignored. # Requirements Implement a function `word_frequency` that computes and returns the word frequency distribution of a given text. Function Signature: ```python def word_frequency(text: str) -> List[Tuple[str, int]]: pass ``` Input: * `text` (str): A string containing the input text. Output: * `frequencies` (List[Tuple[str, int]]): A list of tuples where each tuple contains a word and its frequency, sorted by frequency in descending order. In case of ties, words are sorted alphabetically. # Constraints: * The input text will contain only printable ASCII characters. * The length of the input text will not exceed 10^6 characters. * Words are defined as contiguous sequences of alphabetic characters separated by non-alphabetic characters. # Examples: ```python >>> word_frequency(\\"Hello, world! Hello!\\") [(\'hello\', 2), (\'world\', 1)] >>> word_frequency(\\"A quick brown fox jumps over the lazy dog.\\") [(\'a\', 1), (\'brown\', 1), (\'dog\', 1), (\'fox\', 1), (\'jumps\', 1), (\'lazy\', 1), (\'over\', 1), (\'quick\', 1), (\'the\', 1)] ``` # Hints: 1. Consider using regular expressions to handle punctuation and non-alphabetic characters. 2. Use Python\'s built-in functionalities to count and sort the words efficiently.","solution":"import re from collections import Counter from typing import List, Tuple def word_frequency(text: str) -> List[Tuple[str, int]]: Computes and returns the word frequency distribution of a given text. Words are treated case-insensitively and punctuation marks are ignored. # Convert to lower case and use regex to find all words words = re.findall(r\'bw+b\', text.lower()) # Use Counter to count the frequencies of each word word_counts = Counter(words) # Sort the word counts by frequency (descending) and then alphabetically for ties sorted_word_counts = sorted(word_counts.items(), key=lambda kv: (-kv[1], kv[0])) return sorted_word_counts"},{"question":"Prime Factorization Problem Write a Python function that computes the prime factorization of a given number. Each prime factor should be raised to its respective power. If the input number is less than or equal to 1, the function should raise a `ValueError` with an appropriate message. # Function Signature ```python def prime_factorization(n: int) -> List[Tuple[int, int]]: pass ``` # Input: * `n`: A positive integer greater than 1. # Output: * The function should return a list of tuples, where each tuple contains a prime factor and its corresponding power. The prime factors should be listed in ascending order. # Constraints: * `2 <= n <= 10^18` # Requirements: 1. Handle large prime factors efficiently. 2. Raise a `ValueError` if the input is less than or equal to 1 with an appropriate message. 3. Return the prime factors in ascending order. # Examples: ```python assert prime_factorization(2) == [(2, 1)] assert prime_factorization(3) == [(3, 1)] assert prime_factorization(4) == [(2, 2)] assert prime_factorization(18) == [(2, 1), (3, 2)] assert prime_factorization(100) == [(2, 2), (5, 2)] assert prime_factorization(999983) == [(999983, 1)] assert prime_factorization(1234567890) == [(2, 1), (3, 2), (5, 1), (3607, 1), (3803, 1)] ``` Implement the function `prime_factorization` in Python and test it extensively to ensure it handles the examples and edge cases properly. # Solution ```python from typing import List, Tuple def prime_factorization(n: int) -> List[Tuple[int, int]]: if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] count = 0 # Check for number of 2s that divide `n` while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # `n` must be odd at this point, # so a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): count = 0 while (n % i == 0): n = n // i count += 1 if count > 0: factors.append((i, count)) # This condition is to check if `n` is a prime number # greater than 2 if n > 2: factors.append((n, 1)) return factors ``` Test the `prime_factorization` function with various inputs to ensure its correctness and efficiency.","solution":"from typing import List, Tuple def prime_factorization(n: int) -> List[Tuple[int, int]]: if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] count = 0 # Check for number of 2s that divide `n` while n % 2 == 0: n = n // 2 count += 1 if count > 0: factors.append((2, count)) # `n` must be odd at this point, # so a skip of 2 (i.e., i = i + 2) can be used for i in range(3, int(n**0.5) + 1, 2): count = 0 while (n % i == 0): n = n // i count += 1 if count > 0: factors.append((i, count)) # This condition is to check if `n` is a prime number # greater than 2 if n > 2: factors.append((n, 1)) return factors"},{"question":"# Problem Statement: Product of Absolute Value Pairs You are required to implement a function `product_of_abs_pairs` that calculates the product of pairs of absolute values from two given lists of integers. The function should handle cases where the lists have different lengths by pairing elements until one list is exhausted. If one or both lists are empty, the function should return `None`. The function signature is as follows: ```python def product_of_abs_pairs(list1: list[int], list2: list[int]) -> list[int]: pass ``` # Function Signature: ```python def product_of_abs_pairs(list1: list[int], list2: list[int]) -> list[int]: Calculates the product of pairs of absolute values from two given lists of integers. Parameters: list1 (list[int]): The first input list of integers. list2 (list[int]): The second input list of integers. Returns: list[int]: A list containing the products of the absolute values of the pairs. If one or both lists are empty, returns None. pass ``` # Input: - Two lists of integers, `list1` and `list2`. # Output: - A list of integers containing the products of the absolute values of pairs formed from `list1` and `list2`. - If either `list1` or `list2` is empty, return `None`. # Constraints: - The lists may contain negative numbers. - The lists do not necessarily have the same length. # Examples: ```python >>> product_of_abs_pairs([2, -3, 4], [1, -5, -2]) [2, 15, 8] >>> product_of_abs_pairs([2, -3], [4]) [8] >>> product_of_abs_pairs([], [1, 2, 3]) None >>> product_of_abs_pairs([1, 2, 3], []) None >>> product_of_abs_pairs([-1, -2, -3], [-5, 6]) [5, 12] ``` # Additional Notes: - Ensure the solution handles edge cases such as empty lists. - Use the absolute value of the integers before computing the product. - Only pairs up to the length of the shorter list should be considered.","solution":"def product_of_abs_pairs(list1, list2): Calculates the product of pairs of absolute values from two given lists of integers. Parameters: list1 (list[int]): The first input list of integers. list2 (list[int]): The second input list of integers. Returns: list[int]: A list containing the products of the absolute values of the pairs. If one or both lists are empty, returns None. if not list1 or not list2: return None length = min(len(list1), len(list2)) result = [] for i in range(length): result.append(abs(list1[i]) * abs(list2[i])) return result"},{"question":"# Linked List Middle Node Context: You are given a singly linked list and your task is to find the middle node. If the linked list has an even number of nodes, return the second of the two middle nodes. The goal is to accomplish this in linear time, O(n), and using O(1) space. Task: Write a function `find_middle` that returns the value of the middle node in the linked list. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_middle(head: ListNode) -> int: pass ``` Input: * A singly linked list defined by the `ListNode` class. The head node of the list (`head`) is given. The list can be empty. Output: * The value of the middle node in the linked list. If the list is empty, return `None`. Constraints: * The number of nodes in the linked list may be up to 10^5. * The nodes\' values are integers. Performance Requirements: * The function should complete in O(n) time complexity with O(1) space complexity. Example: ```python # Example 1: # Input: head = [1, 2, 3, 4, 5] # Output: 3 # Example 2: # Input: head = [1, 2, 3, 4, 5, 6] # Output: 4 # Example 3: # Input: head = [] # Output: None node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node6 = ListNode(6) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 node5.next = node6 assert find_middle(node1) == 4 node1 = ListNode(1) node2 = ListNode(2) node3 = ListNode(3) node4 = ListNode(4) node5 = ListNode(5) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node5 assert find_middle(node1) == 3 assert find_middle(None) == None ``` Note: Ensure that your implementation handles edge cases gracefully.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_middle(head: ListNode) -> int: if head is None: return None slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next return slow.val"},{"question":"# Coding Question **Problem Statement**: You are given an array of integers and a target sum. Your task is to determine if there exist three elements in the array whose sum is equal to the given target sum. **Objective**: Write a function `three_sum_exists(arr: List[int], target: int) -> bool` that returns `True` if there are three elements in `arr` whose sum is equal to `target`, and `False` otherwise. # Function Signature ```python def three_sum_exists(arr: List[int], target: int) -> bool: ``` # Input * An array of integers `arr` (1 <= len(arr) <= 300, -10^3 <= arr[i] <= 10^3) * An integer `target` representing the target sum (-10^4 <= target <= 10^4) # Output * Return a boolean value (`True` or `False`). # Example ```python >>> three_sum_exists([1, 2, 3, 4, 5], 9) True >>> three_sum_exists([1, 2, 3, 4, 5], 100) False >>> three_sum_exists([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum_exists([], 0) False >>> three_sum_exists([0, 0, 0], 0) True ``` # Constraints * The array `arr` can contain both positive and negative integers. * Ensure that your solution has an efficient time complexity (aim for O(n^2)). # Scenario A software development company is implementing a financial analysis tool that needs to verify if three distinct transaction amounts can sum up to a specific target. Your function will help efficiently determine the feasibility of this condition given the transaction records. # Performance Tips * Utilize sorting and the two-pointer technique to optimize the performance. * Avoid checking the same triplet multiple times by leveraging the sorted order of the array.","solution":"from typing import List def three_sum_exists(arr: List[int], target: int) -> bool: arr.sort() # Sort the array to use the two-pointer technique n = len(arr) for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue # Skip duplicates left, right = i + 1, n - 1 while left < right: three_sum = arr[i] + arr[left] + arr[right] if three_sum == target: return True elif three_sum < target: left += 1 # Move the left pointer to the right else: right -= 1 # Move the right pointer to the left return False"},{"question":"# Coding Challenge: Kth Largest Element in a Stream Context In data streams, identifying the kth largest element in real-time is a common problem. Maintaining the current state efficiently as new elements are added to the stream poses significant challenges. Utilizing a min-heap data structure is a typical approach to solve this problem with optimal time complexity. Task Write a class `KthLargest` that finds the kth largest element in a stream. Implement the following methods: - `__init__(self, k: int, nums: list[int])`: Initializes the object with the integer `k` and the integer stream `nums`. - `add(self, val: int) -> int`: Appends the integer `val` to the stream and returns the kth largest element. Input - An integer `k`, representing the position of the kth largest element desired. - A list `nums` of integers representing the initial elements of the stream. Output - The `add` method returns an integer, which is the current kth largest element in the stream after adding the new element `val`. Constraints - `1 <= k <= len(nums) + 10^4` - `-10^4 <= nums[i] <= 10^4` - The total number of add operations will not exceed 10^4. Performance Requirement Your solution should efficiently handle real-time addition of elements, ensuring an optimal approach in terms of time and space complexity. Example ```python # Initialize the object with k and the initial stream >>> kth_largest = KthLargest(3, [4, 5, 8, 2]) # K is 3, nums = [4, 5, 8, 2] >>> kth_largest.add(3) # Returns 4 4 # After adding 3, the stream is: [4, 5, 8, 2, 3] - 3rd largest is 4 >>> kth_largest.add(5) # Returns 5 5 # After adding 5, the stream is: [4, 5, 8, 2, 3, 5] - 3rd largest is 5 >>> kth_largest.add(10) # Returns 5 5 # After adding 10, the stream is: [4, 5, 8, 2, 3, 5, 10] - 3rd largest is 5 >>> kth_largest.add(9) # Returns 8 8 # After adding 9, the stream is: [4, 5, 8, 2, 3, 5, 10, 9] - 3rd largest is 8 >>> kth_largest.add(4) # Returns 8 8 # After adding 4, the stream is: [4, 5, 8, 2, 3, 5, 10, 9, 4] - 3rd largest is 8 ``` Implementation Tips 1. Use a min-heap of size k to keep track of the kth largest element. 2. When adding a new element, ensure the size of the heap remains k by evicting smaller elements if necessary. 3. Initially populate the heap with the given stream elements while adhering to the size restriction. Good luck and ensure your implementation remains efficient while handling the real-time constraints!","solution":"import heapq class KthLargest: def __init__(self, k: int, nums: list[int]): Initialize KthLargest with an integer k and a list of integers nums. self.k = k self.min_heap = nums[:] heapq.heapify(self.min_heap) # Maintain only the k largest elements in the heap while len(self.min_heap) > k: heapq.heappop(self.min_heap) def add(self, val: int) -> int: Add the value to the stream and return the kth largest element. heapq.heappush(self.min_heap, val) # If the heap exceeds k, remove the smallest element if len(self.min_heap) > self.k: heapq.heappop(self.min_heap) # The root of the heap is the kth largest element return self.min_heap[0]"},{"question":"# Inversion Count in an Array using Merge Sort Context: You have been given an array of integers representing the sequence of daily temperatures recorded over a month. An inversion in the array is a pair of indices (i, j) such that i < j and array[i] > array[j]. Your task is to determine the total number of such inversions, efficiently. Task: Implement the merge sort algorithm to count the number of inversions in the array. Requirements: 1. **Function 1**: `merge_sort_and_count(arr: list[int]) -> tuple[list[int], int]` - Input: A list of integers `arr` representing the daily temperatures. - Output: A tuple where the first element is the sorted list and the second element is the total number of inversions. - Constraints: The input list will have at least one element. - Performance: Ensure that the solution works in O(n log n) time. Example: ```python temperatures = [30, 20, 40, 50, 10] sorted_temps, inv_count = merge_sort_and_count(temperatures) assert sorted_temps == [10, 20, 30, 40, 50] assert inv_count == 5 temperatures = [5, 4, 3, 2, 1] sorted_temps, inv_count = merge_sort_and_count(temperatures) assert sorted_temps == [1, 2, 3, 4, 5] assert inv_count == 10 ```","solution":"def merge_sort_and_count(arr): Function to use merge sort to sort an array and count inversions. Parameters: arr (list): list of integers to be sorted Returns: tuple: (sorted array, number of inversions) def merge_and_count(left, right): i = j = 0 merged = [] inversions = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) inversions += len(left) - i j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged, inversions if len(arr) <= 1: return arr, 0 mid = len(arr) // 2 left, left_inv = merge_sort_and_count(arr[:mid]) right, right_inv = merge_sort_and_count(arr[mid:]) merged, split_inv = merge_and_count(left, right) return merged, left_inv + right_inv + split_inv"},{"question":"Context: You have been given a task to enhance the functionality of a **Binary Search Tree (BST)** class. This will evaluate your proficiency with tree data structures, particularly BSTs, and your ability to implement common operations efficiently. # Task: 1. Implement a method `find_min(self) -> Any` that returns the minimum value stored in the BST. 2. Implement a method `find_max(self) -> Any` that returns the maximum value stored in the BST. 3. Implement a method `is_balanced(self) -> bool` that checks whether the BST is height-balanced according to the definition: * A binary tree is considered height-balanced if the heights of the two child subtrees of any node never differ by more than one. # Function Signature: ```python def find_min(self) -> Any: Returns the minimum value in the BST. def find_max(self) -> Any: Returns the maximum value in the BST. def is_balanced(self) -> bool: Checks if the BST is height-balanced. ``` # Input & Output Formats: * The `find_min` method takes no arguments and returns the minimum value in the BST. * The `find_max` method takes no arguments and returns the maximum value in the BST. * The `is_balanced` method takes no arguments and returns a boolean indicating whether the BST is balanced. # Constraints: * The `find_min` and `find_max` methods should traverse the tree only once. * The `is_balanced` method should be efficient and avoid unnecessary recalculations. * If the BST is empty, `find_min` and `find_max` methods should return `None`. # Performance Requirements: * Traversal methods should perform in O(h) time, where h is the height of the tree. * Calculations for checking balance should ideally function within O(n), where n is the number of nodes. # Example: ```python # Initialize BST and insert elements bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) bst.insert(12) bst.insert(20) # Find minimum value print(bst.find_min()) # Expected Output: 2 # Find maximum value print(bst.find_max()) # Expected Output: 20 # Check if BST is balanced print(bst.is_balanced()) # Expected Output: True # Insert additional elements to unbalance the tree bst.insert(1) bst.insert(0) # Check if BST is still balanced print(bst.is_balanced()) # Expected Output: False ```","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.key: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_min(self): if self.root is None: return None current = self.root while current.left is not None: current = current.left return current.key def find_max(self): if self.root is None: return None current = self.root while current.right is not None: current = current.right return current.key def is_balanced(self): def check_balance(node): if node is None: return (True, 0) left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return (balanced, max(left_height, right_height) + 1) return check_balance(self.root)[0]"},{"question":"# Question: Implement a Trie Data Structure with Word Frequency Count Background A trie (or prefix tree) is a tree data structure used to efficiently store a dynamic set of strings where the keys are usually strings. Tries are commonly used for autocomplete systems and dictionaries. In this task, you will implement a trie that not only supports insertion and search but also keeps track of the frequency of each word inserted. Task Implement a `Trie` class that supports the following methods: 1. `insert(word: str) -> None`: Inserts the word into the trie and updates its frequency count. 2. `search(word: str) -> bool`: Returns `True` if the word is in the trie, otherwise `False`. 3. `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise `False`. 4. `word_frequency(word: str) -> int`: Returns the frequency count of the given word. If the word is not in the trie, return 0. Function Signatures ```python class Trie: def __init__(self): pass def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass def word_frequency(self, word: str) -> int: pass ``` Constraints - All inputs are non-empty strings and consist of lowercase English letters only (`\'a\'` to `\'z\'`). - Words are case-sensitive. Example 1. **Input**: ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"apple\\") trie.insert(\\"app\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: True print(trie.starts_with(\\"app\\")) # Output: True print(trie.word_frequency(\\"apple\\")) # Output: 2 print(trie.word_frequency(\\"app\\")) # Output: 1 print(trie.word_frequency(\\"banana\\")) # Output: 0 ``` 2. **Output**: ```python True True True 2 1 0 ``` Notes - The `insert` method should handle duplicate entries by increasing the frequency count each time the same word is inserted. - The `search` method should return `True` only for exact matches. - The `starts_with` method should return `True` if any word in the trie starts with the given prefix. - The `word_frequency` method should efficiently return the frequency count of a given word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False self.frequency = 0 class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True node.frequency += 1 def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def word_frequency(self, word: str) -> int: node = self.root for char in word: if char not in node.children: return 0 node = node.children[char] return node.frequency if node.is_end_of_word else 0"},{"question":"# Coffee Shop Simulator You are tasked with writing a function to simulate the order processing in a coffee shop. The coffee shop sells three types of coffee: \\"Espresso\\", \\"Americano\\", and \\"Latte\\". Each type of coffee has a different preparation time: - \\"Espresso\\" takes 3 minutes to prepare. - \\"Americano\\" takes 5 minutes to prepare. - \\"Latte\\" takes 7 minutes to prepare. The shop can only process one coffee order at a time. Given a list of incoming orders and their timestamps in minutes since the shop opened, your task is to calculate the finish time for each order. Each order is represented as a tuple with the first element being the type of coffee and the second element being the timestamp when the order was placed. # Function Signature ```python def process_coffee_orders(orders: List[Tuple[str, int]]) -> List[int]: pass ``` # Input - `orders` (List[Tuple[str, int]]): A list of tuples where each tuple contains the coffee type (string) and the timestamp (int). # Output - Returns a list of integers representing the finish time for each order. # Constraints - Assume there will be no invalid coffee types in the orders. - The timestamps in the orders list are non-decreasing (orders are given in the order they are placed). # Example Input: ```python orders = [(\\"Espresso\\", 1), (\\"Americano\\", 2), (\\"Latte\\", 3), (\\"Espresso\\", 8)] ``` Output: ```python [4, 9, 16, 19] ``` # Explanation - The first order (\\"Espresso\\" at 1) will finish at 1 + 3 = 4. - The second order (\\"Americano\\" at 2) will start at 4 and finish at 4 + 5 = 9. - The third order (\\"Latte\\" at 3) will start at 9 and finish at 9 + 7 = 16. - The fourth order (\\"Espresso\\" at 8) will start at 16 (as the previous order finished at 16) and finish at 16 + 3 = 19. By processing each order in sequence and determining the finish times based on the order\'s placement timestamp and the preparation time, we can compute the total processing times for all orders. # Notes - Handle edge cases such as having no orders or having several orders with the same timestamp. - Make sure the function efficiently computes the finish times for a potentially large list of orders.","solution":"from typing import List, Tuple def process_coffee_orders(orders: List[Tuple[str, int]]) -> List[int]: # Preparation times for different coffee types prep_times = { \\"Espresso\\": 3, \\"Americano\\": 5, \\"Latte\\": 7 } finish_times = [] current_time = 0 # Time when the last coffee order was processed for coffee_type, order_time in orders: prep_time = prep_times[coffee_type] # The coffee can start preparing either when it is ordered or when the previous coffee finishes, whichever is later start_time = max(current_time, order_time) finish_time = start_time + prep_time finish_times.append(finish_time) # Update the current time to the time when this coffee finishes current_time = finish_time return finish_times"},{"question":"# Problem Statement: Anagrammatic Palindrome Checker You are developing a contribution for a text analysis toolkit that includes functionalities for checking various properties of strings. One of the features required is to determine if a given string can be rearranged to form a palindrome. # Function Signature ```python def is_anagrammatic_palindrome(s: str) -> bool: pass ``` # Input - A single string `s` of length between 1 and 1000 containing only lowercase alphabetical characters. # Output - A boolean value: - `True` if the string can be rearranged to form a palindrome, - `False` otherwise. # Constraints - The input string will only contain lowercase alphabetical characters. # Example ```python # Examples of strings that can be rearranged to form palindromes is_anagrammatic_palindrome(\\"civic\\") # Expected output: True (\\"civic\\" is already a palindrome) is_anagrammatic_palindrome(\\"ivicc\\") # Expected output: True (\\"ivicc\\" can be rearranged to \\"civic\\") is_anagrammatic_palindrome(\\"aabb\\") # Expected output: True (\\"aabb\\" can be rearranged to \\"abba\\") # Examples of strings that cannot be rearranged to form palindromes is_anagrammatic_palindrome(\\"hello\\") # Expected output: False (\\"hello\\" cannot be rearranged to form a palindrome) is_anagrammatic_palindrome(\\"world\\") # Expected output: False (\\"world\\" cannot be rearranged to form a palindrome) is_anagrammatic_palindrome(\\"abc\\") # Expected output: False (\\"abc\\" cannot be rearranged to form a palindrome) ``` # Instructions 1. You must implement the `is_anagrammatic_palindrome` function to determine if a string can be rearranged to form a palindrome. 2. A string can be rearranged to form a palindrome if at most one character in the string has an odd frequency count. 3. Use data structures such as dictionaries or arrays to count character frequencies and apply the palindrome logic. 4. Provide an efficient implementation keeping the time complexity in mind, considering the length constraint.","solution":"def is_anagrammatic_palindrome(s: str) -> bool: Determines if the given string can be rearranged to form a palindrome. :param s: Input string of lowercase alphabetical characters :return: True if the string can be rearranged to form a palindrome, False otherwise from collections import Counter # Count the frequency of each character freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # For a string to be rearranged into a palindrome, there must be at most one character with an odd frequency return odd_count <= 1"},{"question":"**Find Common Elements in Two Sorted Lists** **Problem Statement**: You are given two lists of integers that are each individually sorted in non-decreasing order. Implement a function that finds the common elements between these two lists. The function should return a new list of the common elements, also sorted in non-decreasing order. **Function Signature**: ```python def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: ``` **Input**: - Two lists of integers, `list1` and `list2`, each sorted in non-decreasing order. **Output**: - A list of integers representing the common elements between `list1` and `list2`, sorted in non-decreasing order. **Constraints**: - The function should handle lists with up to 10^5 elements each. - Both lists are already sorted in non-decreasing order. **Examples**: ```python assert find_common_elements([2, 4, 5, 6, 9], [1, 2, 4, 7, 9]) == [2, 4, 9] assert find_common_elements([1, 1, 1, 1], [1, 1, 1, 1]) == [1, 1, 1, 1] assert find_common_elements([1, 3, 5], [2, 4, 6]) == [] assert find_common_elements([], [2, 4, 6]) == [] assert find_common_elements([1, 2, 3], []) == [] ``` **Edge Cases**: - If either list is empty, the output should be an empty list. - Lists containing duplicates should correctly identify and include the appropriate number of common elements. **Hint**: Use a two-pointer technique to traverse both lists simultaneously. Compare elements from both lists and move the pointers accordingly to find and collect common elements.","solution":"from typing import List def find_common_elements(list1: List[int], list2: List[int]) -> List[int]: common_elements = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] == list2[j]: common_elements.append(list1[i]) i += 1 j += 1 elif list1[i] < list2[j]: i += 1 else: j += 1 return common_elements"},{"question":"# Find First and Last Position of an Element in a Sorted Array Implement a function that finds the starting and ending position of a given target value in a sorted array of integers. If the target is not found in the array, return `[-1, -1]`. You must write an algorithm with `O(log n)` runtime complexity to handle large arrays efficiently. Detailed Requirements: 1. **Function Signature**: `def search_range(nums: List[int], target: int) -> List[int]:` 2. **Input**: - `nums`: A list of integers sorted in ascending order. - `target`: An integer representing the value to search for. 3. **Output**: A list of two integers representing the starting and ending positions of the `target` value in the array. If the target is not found, return `[-1, -1]`. Constraints: - The input list can be of any length, including empty. - The function should be optimized for performance with a logarithmic time complexity. Examples: ```python assert search_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] assert search_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] assert search_range([], 0) == [-1, -1] assert search_range([2, 2], 2) == [0, 1] assert search_range([1, 3, 5, 7, 9, 11], 4) == [-1, -1] ``` Performance Requirements: - The solution must achieve `O(log n)` runtime complexity using an efficient search approach, likely involving binary search.","solution":"from typing import List def search_range(nums: List[int], target: int) -> List[int]: def find_start(nums: List[int], target: int) -> int: left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] >= target: right = mid - 1 else: left = mid + 1 return left def find_end(nums: List[int], target: int) -> int: left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right start = find_start(nums, target) end = find_end(nums, target) if start <= end and start < len(nums) and nums[start] == target: return [start, end] else: return [-1, -1]"},{"question":"# Problem You are given a list of strings representing different types of items. Your task is to create a function that returns the top `k` most frequently occurring items in the list. If there is a tie in frequency, the items should be returned in lexicographical order. # Function Signature ```python def top_k_frequent_items(items: List[str], k: int) -> List[str]: Returns the top k most frequently occurring items in the list. :param items: List of strings representing the items. :type items: List[str] :param k: Number of top frequent items to return. :type k: int :return: List of top k frequent items sorted based on the criteria. :rtype: List[str] ``` # Input * `items`: List of strings where each string represents an item. (1 <= len(items) <= 10^5) * `k`: An integer representing the number of top frequent items to return. (1 <= k <= min(len(items), 100)) # Output * A list of strings representing the top k frequent items sorted first by frequency and then by lexicographical order. # Example ```python # Example 1: print(top_k_frequent_items([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\", \\"grape\\", \\"orange\\", \\"apple\\"], 2)) # Output: [\\"apple\\", \\"banana\\"] # Example 2: print(top_k_frequent_items([\\"car\\", \\"truck\\", \\"car\\", \\"bike\\", \\"truck\\", \\"car\\", \\"bike\\", \\"plane\\"], 3)) # Output: [\\"car\\", \\"bike\\", \\"truck\\"] ``` # Constraints * The function should efficiently handle large lists of items. * Items are to be compared in a case-sensitive manner. # Implementation Implement the function `top_k_frequent_items(items, k)` that follows the provided constraints and solves the described problem efficiently.","solution":"from typing import List from collections import Counter def top_k_frequent_items(items: List[str], k: int) -> List[str]: Returns the top k most frequently occurring items in the list. :param items: List of strings representing the items. :type items: List[str] :param k: Number of top frequent items to return. :type k: int :return: List of top k frequent items sorted based on the criteria. :rtype: List[str] # Count the frequency of each item item_counts = Counter(items) # Get the items sorted by frequency and lexicographical order sorted_items = sorted(item_counts.keys(), key=lambda x: (-item_counts[x], x)) # Get the top k items return sorted_items[:k]"},{"question":"# Question: Write a function `find_subsets_backtrack` that generates all possible subsets of a given list of unique integers using backtracking. The subsets should be returned as a list of lists, with each subset in non-descending order, and the list of subsets in lexicographic order. # Objective: Implement the `find_subsets_backtrack` function to generate all subsets of a list and test the function with different input scenarios to ensure correctness. # Requirements: 1. **Input**: A list of unique integers. * `nums`: A list of unique integers where `len(nums) <= 16`. 2. **Output**: A list of lists, where each inner list is a subset of the input list and sorted in non-descending order. 3. **Constraints**: * Subsets should be returned in lexicographic order. * The function should handle edge cases, such as an empty list. # Example: ```python def find_subsets_backtrack(nums): Generate all subsets of a list of unique integers using backtracking. Args: - nums: List of unique integers. Returns: - A list of lists representing all subsets, sorted in lexicographic order. Example: >>> find_subsets_backtrack([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> find_subsets_backtrack([]) [[]] pass # Your code here ``` # Instructions: 1. Implement the `find_subsets_backtrack` function using a backtracking algorithm. 2. Ensure the subsets generated are in non-descending order and the overall list is in lexicographic order. 3. Test the function with different examples, including an empty list, a list with one element, and a list with distinct integers, to verify the correctness of the implementation. # Implementation Details: To create a backtracking solution, consider the following approach: 1. Sort the input list `nums` to handle the order of subsets inherently. 2. Use a helper function to recursively build subsets, starting from an empty list. 3. At each recursion level, include the current element in the subset or skip it, thereby generating all possible combinations. 4. Collect the completed subsets into the result list and ensure they are in the expected order. Make sure your implementation is efficient and handles the constraints appropriately without unnecessary computations.","solution":"def find_subsets_backtrack(nums): Generate all subsets of a list of unique integers using backtracking. Args: - nums: List of unique integers. Returns: - A list of lists representing all subsets, sorted in lexicographic order. def backtrack(start, path): # Add the current subset to the result result.append(path[:]) # Generate all possible subsets starting with the current element for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() # Sort the list to make sure the subsets are in non-descending order nums.sort() result = [] backtrack(0, []) return result"},{"question":"# Coding Assessment Question Context Develop a function that models a common inventory management scenario in a retail environment. The function must adjust the quantity of items based on new shipments and sales data. Task Write a function `update_inventory` that takes two dictionaries: `current_inventory` and `transactions`, and returns a new dictionary representing the updated inventory. * **Input**: * `current_inventory` (dict): A dictionary where keys are item names (strings) and values are quantities (integers) of these items currently in stock. * `transactions` (dict): A dictionary where keys are item names (strings) and values are changes in quantities (integers). Positive values represent new shipments or added stock, and negative values represent sales or subtractions from the stock. * **Output**: * A dictionary representing the updated inventory after applying all transactions. For example: ```python >>> current_inventory = {\'apples\': 10, \'bananas\': 20} >>> transactions = {\'apples\': 5, \'bananas\': -7, \'oranges\': 10} >>> update_inventory(current_inventory, transactions) {\'apples\': 15, \'bananas\': 13, \'oranges\': 10} ``` Constraints * The input dictionaries will have string keys and integer values. * The resulting inventory values should not be negative. If a transaction causes a quantity to fall below zero, set the quantity to zero instead. Requirements * Your function should handle large dictionaries efficiently. * Ensure type and value checks are appropriately designed to handle erroneous input gracefully. * Aim for linear time complexity. Performance Your solution should process each dictionary entry in `O(n)` time complexity, where `n` is the number of unique items between both dictionaries. Edge Cases: * Handle cases where there are items in `transactions` that do not exist in `current_inventory` and vice versa. * Transactions that result in zero or negative inventory should still be correctly reflected in the result. # Example The following illustrates the expected result: ```python >>> update_inventory({\'apples\': 15}, {\'apples\': -20}) {\'apples\': 0} >>> update_inventory({}, {\'oranges\': 10}) {\'oranges\': 10} ``` # Implement the function below: ```python def update_inventory(current_inventory, transactions): # Your code here pass ```","solution":"def update_inventory(current_inventory, transactions): Updates the quantities of items in the current inventory based on the transactions. Parameters: current_inventory (dict): A dictionary of current inventory with item names as keys and quantities as values. transactions (dict): A dictionary of transactions with item names as keys and changes in quantities as values. Returns: dict: Updated inventory after applying the transactions. # Create a copy of the current inventory to avoid modifying the input dictionary updated_inventory = current_inventory.copy() for item, change in transactions.items(): if item in updated_inventory: updated_inventory[item] += change else: updated_inventory[item] = change # Ensure no item quantity goes below zero if updated_inventory[item] < 0: updated_inventory[item] = 0 return updated_inventory"},{"question":"# Find Missing Number in Array **Objective**: Write a function to find the missing number in an array containing `n` distinct numbers taken from the 0, 1, 2, ..., n set. One number from this set will be missing from the array, and your task is to identify and return that missing number. Function to Implement ```python def find_missing_number(arr: List[int]) -> int: Returns the missing number from the array containing distinct numbers from the 0, 1, 2, ..., n set. Parameters: arr (List[int]): The list containing n distinct numbers from the set. Returns: int: The missing number from the array. Raises: ValueError: If the input array does not meet the requirements. TypeError: If the input is not a list. Examples: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8 pass ``` Input - `arr` (List[int]): An array of `n` distinct numbers, which are part of the 0, 1, 2, ..., n set. Output - Returns the missing number from the array. Constraints - 1 ≤ `len(arr)` ≤ 10^4 - The elements of `arr` will be unique and in the range from 0 to `len(arr)`. Special Considerations - Ensure the function handles different array lengths and edge cases appropriately. - Optimize the solution to handle the largest possible input size efficiently. Example Usage ```python print(find_missing_number([3, 7, 1, 2, 8, 4, 5])) # Output: 6 print(find_missing_number([0, 1, 2, 4, 5, 6])) # Output: 3 ```","solution":"from typing import List def find_missing_number(arr: List[int]) -> int: Returns the missing number from the array containing distinct numbers from the 0, 1, 2, ..., n set. Parameters: arr (List[int]): The list containing n distinct numbers from the set. Returns: int: The missing number from the array. n = len(arr) expected_sum = n * (n + 1) // 2 actual_sum = sum(arr) return expected_sum - actual_sum"},{"question":"# Coding Assessment: Matrix Transpose Context Transposing a matrix involves swapping its rows with its columns, resulting in a new matrix where the original\'s rows and columns have been switched. Problem Description Implement the function `transpose_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes a two-dimensional list (matrix) as input and returns its transpose. Input A two-dimensional list `matrix` where: - Each sublist represents a row of the matrix. - The matrix is guaranteed to have at least one row and one column, and each row will have the same number of columns. Output A new two-dimensional list representing the transpose of the input matrix. Constraints - The columns of the input matrix will contain at least one element. - Handle matrices that are not square (i.e., the number of rows is not equal to the number of columns). Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3, 4], [5, 6, 7, 8]]) [[1, 5], [2, 6], [3, 7], [4, 8]] ```","solution":"def transpose_matrix(matrix): Returns the transpose of the given 2D matrix. Args: - matrix: A list of lists where each sublist represents a row of the matrix. Returns: - A new matrix that is the transpose of the input matrix. # Use zip(*matrix) to transpose rows and columns transposed = [list(row) for row in zip(*matrix)] return transposed"},{"question":"# Question You are given a string representing a sequence of operations to be performed on a string. The operations include: - `add <character>`: Add the given character to the end of the string. - `remove`: Remove the last character from the string. - `reverse`: Reverse the current string. - `print`: Print the current string. Write a function `perform_operations` that takes in a list of operations and returns a list of strings that were printed during the execution of these operations. Input - A list of strings, `operations`, where each string represents one of the described operations. The length of `operations` will be between 1 and 10^4. - Each `add <character>` operation will be a string of length 5 (e.g. \\"add a\\"). - The `remove`, `reverse`, and `print` operations will be exactly those strings. Output - A list of strings that were printed during the execution of the operations, in the order they were printed. Function Signature ```python def perform_operations(operations: list[str]) -> list[str]: pass ``` Examples ```python assert perform_operations([\\"add a\\", \\"add b\\", \\"print\\", \\"reverse\\", \\"print\\", \\"remove\\", \\"print\\"]) == [\\"ab\\", \\"ba\\", \\"b\\"] assert perform_operations([\\"add x\\", \\"add y\\", \\"remove\\", \\"print\\", \\"add z\\", \\"print\\"]) == [\\"x\\", \\"xz\\"] assert perform_operations([\\"print\\", \\"reverse\\", \\"add p\\", \\"print\\"]) == [\\"\\", \\"p\\"] assert perform_operations([\\"remove\\", \\"reverse\\", \\"print\\", \\"add q\\", \\"reverse\\", \\"print\\"]) == [\\"\\", \\"q\\"] assert perform_operations([\\"print\\"]) == [\\"\\"] ``` Constraints - Ensure your solution is efficient regarding both time and space complexity. - Handle edge cases, such as attempting to remove or reverse an empty string, gracefully without causing errors.","solution":"def perform_operations(operations): result = [] current_string = [] for operation in operations: if operation.startswith(\\"add \\"): current_string.append(operation.split()[1]) elif operation == \\"remove\\" and current_string: current_string.pop() elif operation == \\"reverse\\": current_string.reverse() elif operation == \\"print\\": result.append(\'\'.join(current_string)) return result"},{"question":"# Question Develop a program that simulates a simple scheduling system for a clinic\'s appointments. The system should manage patient bookings and cancellations while ensuring no time conflicts. Task Description 1. **Appointment Booking:** Allow patients to book an appointment by providing their name and desired time. Each appointment is 30 minutes long, and bookings can be made between 9:00 AM and 5:00 PM on weekdays. 2. **Appointment Cancellation:** Allow patients to cancel their appointments by providing their name and the time of the booked appointment. 3. **View Appointments:** Enable the receptionist to view all booked appointments for a given day, sorted by time. Constraints - Appointment times are on the hour and half-hour (e.g., 9:00 AM, 9:30 AM). - No double booking is allowed. - Only working hours (9:00 AM to 5:00 PM) and weekdays should be considered. Requirements - Implement a class `ClinicScheduler`. - Implement methods for booking (`book_appointment`), cancellation (`cancel_appointment`), and viewing appointments (`view_appointments`). # Example ```python # Example usage of ClinicScheduler scheduler = ClinicScheduler() # Book an appointment scheduler.book_appointment(\\"John Doe\\", \\"10:00 AM\\") scheduler.book_appointment(\\"Jane Smith\\", \\"10:30 AM\\") # Cancel an appointment scheduler.cancel_appointment(\\"John Doe\\", \\"10:00 AM\\") # View appointments appointments = scheduler.view_appointments() print(appointments) # Output: [\\"Jane Smith - 10:30 AM\\"] # Scheduling attempts scheduler.book_appointment(\\"Patient A\\", \\"9:00 AM\\") scheduler.book_appointment(\\"Patient B\\", \\"9:00 AM\\") # This should raise an error due to double booking ``` # Implementation Define the class and methods as follows: ```python class ClinicScheduler: def __init__(self): self.appointments = {} # Dictionary to store appointments def time_slot_valid(self, time): hours, minutes = map(int, time[:-2].split(\':\')) period = time[-2:] if period not in [\\"AM\\", \\"PM\\"]: return False if period == \\"AM\\": if hours < 9 or hours >= 12 or (hours == 12 and minutes > 0): return False else: # PM period if hours < 1 or hours > 4 or (hours == 5 and minutes > 0): return False return True def book_appointment(self, patient_name, time): if not self.time_slot_valid(time): raise ValueError(\\"Invalid appointment time.\\") if time in self.appointments: raise ValueError(\\"Time slot already booked.\\") self.appointments[time] = patient_name print(f\\"Appointment booked for {patient_name} at {time}.\\") def cancel_appointment(self, patient_name, time): if time in self.appointments and self.appointments[time] == patient_name: del self.appointments[time] print(f\\"Appointment for {patient_name} at {time} canceled.\\") else: raise ValueError(\\"No such appointment to cancel.\\") def view_appointments(self): sorted_appointments = sorted(self.appointments.items(), key=lambda x: x[0]) return [f\\"{v} - {k}\\" for k, v in sorted_appointments] # Example Usage scheduler = ClinicScheduler() scheduler.book_appointment(\\"John Doe\\", \\"10:00 AM\\") scheduler.book_appointment(\\"Jane Smith\\", \\"10:30 AM\\") scheduler.cancel_appointment(\\"John Doe\\", \\"10:00 AM\\") print(scheduler.view_appointments()) ``` # Additional Notes - Ensure the system prevents double bookings by raising appropriate errors. - Consider extending functionality with features like recurring appointments or notifications based on real-world requirements.","solution":"class ClinicScheduler: def __init__(self): self.appointments = {} # Dictionary to store appointments def time_slot_valid(self, time): hours, minutes = map(int, time[:-2].split(\':\')) period = time[-2:] if period == \\"AM\\": if hours >= 9 and hours <= 11: # 9:00 AM - 11:30 AM if minutes in [0, 30]: return True elif period == \\"PM\\": if hours == 12 and minutes in [0, 30]: # 12:00 PM - 12:30 PM return True if hours >= 1 and ((hours < 5 and minutes in [0, 30]) or (hours == 5 and minutes == 0)): # 1:00 PM - 5:00 PM return True return False def book_appointment(self, patient_name, time): if not self.time_slot_valid(time): raise ValueError(\\"Invalid appointment time.\\") if time in self.appointments: raise ValueError(\\"Time slot already booked.\\") self.appointments[time] = patient_name print(f\\"Appointment booked for {patient_name} at {time}.\\") def cancel_appointment(self, patient_name, time): if time in self.appointments and self.appointments[time] == patient_name: del self.appointments[time] print(f\\"Appointment for {patient_name} at {time} canceled.\\") else: raise ValueError(\\"No such appointment to cancel.\\") def view_appointments(self): sorted_appointments = sorted(self.appointments.items(), key=lambda x: x[0]) return [f\\"{v} - {k}\\" for k, v in sorted_appointments]"},{"question":"# Sum of Odd Fibonacci Numbers Objective Write a Python function that computes the sum of all odd Fibonacci numbers less than a given positive integer `n`. The function should handle invalid inputs properly and should be efficient enough for larger values of `n`. Input - A positive integer `n` (1 ≤ n ≤ 10^9). Output - An integer representing the sum of all odd Fibonacci numbers less than `n`. Function Signature ```python def sum_of_odd_fibonacci(n: int) -> int: pass ``` Constraints - Input must be a positive integer. - The function should raise a ValueError if the input is less than 1. - The function should raise a TypeError if the input is not an integer. - The function should handle inputs up to `10^9` efficiently. Examples ```python >>> sum_of_odd_fibonacci(10) 10 # 1 + 1 + 3 + 5 >>> sum_of_odd_fibonacci(18) 23 # 1 + 1 + 3 + 5 + 13 >>> sum_of_odd_fibonacci(1) 0 # There are no odd Fibonacci numbers less than 1 ``` Notes Your implementation should aim for efficiency within the provided input constraints. Consider edge cases, and ensure proper error handling.","solution":"def sum_of_odd_fibonacci(n: int) -> int: if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 1: raise ValueError(\\"Input must be a positive integer greater than or equal to 1\\") a, b = 1, 1 sum_odd_fib = 0 while a < n: if a % 2 != 0: sum_odd_fib += a a, b = b, a + b return sum_odd_fib"},{"question":"# Summation of Two Sparse Matrices Write a function `sparse_matrix_addition` that takes two sparse matrices represented as dictionaries and returns their sum, also represented as a dictionary. Both matrices have the same dimensions. In the dictionary representation of a sparse matrix, only non-zero elements are stored with their keys being a tuple of their row and column indices. # Function Signature ```python def sparse_matrix_addition( mat1: Dict[Tuple[int, int], int], mat2: Dict[Tuple[int, int], int] ) -> Dict[Tuple[int, int], int]: pass ``` # Input 1. `mat1`: A dictionary representing the first sparse matrix, where keys are tuples `(row, column)` and values are non-zero integers. 2. `mat2`: A dictionary representing the second sparse matrix in the same format as `mat1`. # Output * Return a dictionary representing the sum of the two sparse matrices. The output dictionary should only contain non-zero elements. # Constraints * Keys in both dictionaries will be valid indices for matrices of the same fixed dimension. * All integer values in the input dictionaries are non-zero. # Example ```python mat1 = {(0, 1): 3, (1, 0): 2} mat2 = {(0, 1): 4, (1, 0): 3, (1, 1): 5} result = sparse_matrix_addition(mat1, mat2) print(result) # Output should be {(0, 1): 7, (1, 0): 5, (1, 1): 5} ``` # Note 1. Ensure that the resulting dictionary contains only non-zero elements. 2. If a position `(i, j)` appears in both `mat1` and `mat2`, their values should be added. Only the positions with non-zero resultant sums should appear in the output dictionary. 3. If a position appears in only one of the matrices, it should appear in the result as is.","solution":"def sparse_matrix_addition( mat1: dict[tuple[int, int], int], mat2: dict[tuple[int, int], int] ) -> dict[tuple[int, int], int]: result = {} for key in set(mat1.keys()).union(set(mat2.keys())): value = mat1.get(key, 0) + mat2.get(key, 0) if value != 0: result[key] = value return result"},{"question":"# **Implementing a Simple Text-Based Search Algorithm** **Scenario**: You are tasked with developing a simple text-based search function to find the first occurrence of a substring (needle) in a longer string (haystack). This could be useful in various applications like text editors or search engines where users need to locate specific information quickly. **Function to Implement**: ```python def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of the substring needle in the string haystack. If needle is not a substring of haystack, returns -1. Args: haystack (str): The string in which to search for the substring. needle (str): The substring to be found in the haystack. Returns: int: The index of the first occurrence of the substring needle in haystack, or -1 if not found. pass ``` **Requirements**: 1. Implement the `find_substring` function. 2. Do not use built-in string functions like `str.find` or `str.index` to solve this problem. 3. Your function should operate in linear time complexity relative to the length of `haystack`. **Input**: - `haystack` (str): The string within which to search. It can be up to 10^5 characters long. - `needle` (str): The substring to search for. The length of `needle` should be less than or equal to the length of `haystack`. **Output**: - Returns an integer representing the first index where `needle` starts within `haystack`. - If `needle` is not found, return -1. **Constraints**: - The length of `needle` will always be less than or equal to the length of `haystack`. - The length of `haystack` will be at least 1. **Performance**: - Ensure the function handles large inputs efficiently. **Hints**: 1. Consider implementing the Knuth-Morris-Pratt (KMP) pattern matching algorithm to achieve linear time complexity. 2. Be mindful of edge cases such as when `needle` is an empty string or when `haystack` and `needle` are identical. You can test your implementation with various lengths of `haystack` and `needle` to ensure correctness and efficiency.","solution":"def find_substring(haystack: str, needle: str) -> int: Returns the index of the first occurrence of the substring needle in the string haystack. If needle is not a substring of haystack, returns -1. Args: haystack (str): The string in which to search for the substring. needle (str): The substring to be found in the haystack. Returns: int: The index of the first occurrence of the substring needle in haystack, or -1 if not found. # KMP algorithm if not needle: return 0 lsp = [0] * len(needle) # Longest suffix-prefix table j = 0 # partial match length in the LSP table # Fill the LSP table for i in range(1, len(needle)): while j > 0 and needle[i] != needle[j]: j = lsp[j - 1] if needle[i] == needle[j]: j += 1 lsp[i] = j else: lsp[i] = 0 j = 0 # index for needle # Traverse the haystack using the LSP table for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = lsp[j - 1] if haystack[i] == needle[j]: j += 1 if j == len(needle): return i - j + 1 return -1"},{"question":"# [Problem Statement] You are developing a software that simulates an online meeting room where participants can join and leave the meeting at any time. One of the essential functionalities needed is to create a log of the participants\' arrival and departure times. Tasks 1. **Implement \'log_entry\' function** Create a class `MeetingRoom` with a method `log_entry(name: str, action: str, timestamp: str) -> None`. This method should log the participant\'s name, their action (`\\"enter\\"` or `\\"leave\\"`), and the timestamp of the action. 2. **Implement \'get_log\' function** Add a method `get_log() -> list` to the `MeetingRoom` class. This method should return the log of all participants\' actions in the order they occurred. Each log entry should be a dictionary containing `name`, `action`, and `timestamp`. # Constraints - The `log_entry` method should ensure that any participant who logs a `\\"leave\\"` action must have previously logged an `\\"enter\\"` action. - The `get_log` method should return entries in the order they occurred. - Utilize O(n) space complexity, where \'n\' is the number of log entries. # Function Signatures ```python class MeetingRoom: def __init__(self): pass def log_entry(self, name: str, action: str, timestamp: str) -> None: pass def get_log(self) -> list: pass ``` # Example ```python # Example usage meeting_room = MeetingRoom() meeting_room.log_entry(\\"Alice\\", \\"enter\\", \\"10:00\\") meeting_room.log_entry(\\"Bob\\", \\"enter\\", \\"10:05\\") meeting_room.log_entry(\\"Alice\\", \\"leave\\", \\"10:30\\") print(meeting_room.get_log()) # Output should be: # [ # {\\"name\\": \\"Alice\\", \\"action\\": \\"enter\\", \\"timestamp\\": \\"10:00\\"}, # {\\"name\\": \\"Bob\\", \\"action\\": \\"enter\\", \\"timestamp\\": \\"10:05\\"}, # {\\"name\\": \\"Alice\\", \\"action\\": \\"leave\\", \\"timestamp\\": \\"10:30\\"} # ] ``` **Note**: Ensure that your implementation handles cases where participants try to leave without entering.","solution":"class MeetingRoom: def __init__(self): self.log = [] self.participants = set() def log_entry(self, name: str, action: str, timestamp: str) -> None: if action == \\"enter\\": self.participants.add(name) self.log.append({\\"name\\": name, \\"action\\": action, \\"timestamp\\": timestamp}) elif action == \\"leave\\": if name in self.participants: self.log.append({\\"name\\": name, \\"action\\": action, \\"timestamp\\": timestamp}) self.participants.remove(name) else: raise ValueError(f\\"Participant \'{name}\' cannot leave without entering first.\\") else: raise ValueError(f\\"Invalid action \'{action}\'. Use \'enter\' or \'leave\'.\\") def get_log(self) -> list: return self.log # Example usage # meeting_room = MeetingRoom() # meeting_room.log_entry(\\"Alice\\", \\"enter\\", \\"10:00\\") # meeting_room.log_entry(\\"Bob\\", \\"enter\\", \\"10:05\\") # meeting_room.log_entry(\\"Alice\\", \\"leave\\", \\"10:30\\") # print(meeting_room.get_log()) # Output should be: # [ # {\\"name\\": \\"Alice\\", \\"action\\": \\"enter\\", \\"timestamp\\": \\"10:00\\"}, # {\\"name\\": \\"Bob\\", \\"action\\": \\"enter\\", \\"timestamp\\": \\"10:05\\"}, # {\\"name\\": \\"Alice\\", \\"action\\": \\"leave\\", \\"timestamp\\": \\"10:30\\"} # ]"},{"question":"# Scenario: You are developing a software task scheduler that assigns priority tasks to available processors. Each task has an associated importance level, and each processor can handle only one task at any given time. The scheduler aims to maximize the total importance level of the assigned tasks. # Task: Write a Python function that assigns tasks to processors in a way that maximizes the total importance level. The function should receive a list of tasks, each represented by its importance level, and the number of available processors. # Function Signature: ```python def maximize_task_importance(tasks: List[int], processors: int) -> int: pass ``` # Input: - `tasks` (List[int]): A list of integers representing the importance levels of the tasks. - `processors` (int): An integer representing the number of available processors. # Output: - Returns an integer representing the maximum total importance level achievable with the given processors. # Constraints: - 1 ≤ len(tasks) ≤ 1000 - 1 ≤ importance level of each task ≤ 10000 - 1 ≤ processors ≤ 100 # Example: ```python >>> maximize_task_importance([7, 4, 8, 6], 2) 15 >>> maximize_task_importance([1, 2, 3, 4, 5], 3) 12 ``` # Requirements: - Implement the solution by considering the most important tasks first. - Ensure the function efficiently allocates tasks to the available processors. - Handle edge cases where the number of tasks is less than or equal to the number of processors.","solution":"from typing import List def maximize_task_importance(tasks: List[int], processors: int) -> int: Assigns tasks to processors to maximize the total importance level. Args: tasks (List[int]): A list of integers representing the importance levels of the tasks. processors (int): An integer representing the number of available processors. Returns: int: The maximum total importance level achievable with the given processors. # Sort tasks in descending order of importance tasks.sort(reverse=True) # Assign the most important tasks to the processors return sum(tasks[:processors])"},{"question":"# Problem Statement You are given an array of integers where every element appears twice except for one. Write a function `find_single_number(nums: List[int]) -> int` that finds and returns the single element that appears only once. # Input Format - The function will accept a single parameter: a list of integers `nums` where every integer except one appears exactly twice. # Output Format - The function should return an integer which is the single number. # Examples ```python assert find_single_number([2, 2, 1]) == 1 assert find_single_number([4, 1, 2, 1, 2]) == 4 assert find_single_number([1]) == 1 ``` # Constraints - The length of the list `nums` will be in the range [1, 10^5]. - All elements of `nums` are integers in the range `[-3 * 10^4, 3 * 10^4]`. # Requirements 1. Implement an efficient solution to handle the given constraints. 2. Optimize for O(n) time complexity and O(1) space complexity using bitwise operations if possible.","solution":"from typing import List def find_single_number(nums: List[int]) -> int: Returns the single number in the list where every other number appears twice. result = 0 for num in nums: result ^= num return result"},{"question":"# Question You need to implement a function that flattens a nested list structure. A nested list is a list that can contain integers or other lists recursively. The function should take such a nested list as input and return a single list of integers in the same order as they appear in the nested structure. # Function Signature ```python def flatten_nested_list(nested_list: list) -> list: ``` # Input * `nested_list: list` - A list that can contain integers or other lists, which can themselves contain integers or other lists, and so on. # Output * `list` - A \\"flattened\\" list containing all the integers from the input list and its nested sublists, in the order they appear. # Constraints * The length of `nested_list` can be up to 10^4. * The depth of the nested lists is guaranteed to be at most 100. * All integers in the list are between -10^6 and 10^6 inclusive. # Examples ```python assert flatten_nested_list([1, [2, 3], [[4, 5], 6], 7, [8, [9, [10]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert flatten_nested_list([]) == [] assert flatten_nested_list([1, [2, [3, [4, [5]]]]]) == [1, 2, 3, 4, 5] assert flatten_nested_list([[1, 2], [[3, 4], 5]]) == [1, 2, 3, 4, 5] assert flatten_nested_list([[[[[[-1]]]]], 0]) == [-1, 0] ``` # Implementation Guide 1. **Initialize Result List**: Create an empty list to hold the flattened result. 2. **Iterate Through Input**: Use a helper function or recursive logic to process each element in the nested list. 3. **Recursion/Stack for Nested Lists**: If the element is an integer, add it to the result list. If it is a list, recursively flatten that list and extend it to the result list. 4. **Return Result**: After processing all elements, return the result list. # Notes - Ensure you handle deeply nested structures efficiently. - Use recursion or an explicit stack to manage the nested levels properly.","solution":"def flatten_nested_list(nested_list): Flattens a nested list of integers. Parameters: nested_list (list): A list which can contain integers or other lists. Returns: list: A flattened list containing all integers from the input list and its nested sublists. flat_list = [] def flatten(sublist): for ele in sublist: if isinstance(ele, list): flatten(ele) else: flat_list.append(ele) flatten(nested_list) return flat_list"},{"question":"# Problem Statement You are working on a social media platform that lets users create posts containing text and hashtags. The platform needs a feature to categorize posts based on the hashtags they contain. Given a list of posts, where each post is represented as a string, your task is to classify the posts into different groups based on the unique hashtags they contain. Two posts belong to the same group if they share at least one hashtag. Your goal is to implement a function that returns the number of different groups of posts. # Input ```txt The function should accept a list of strings `posts`, where each string represents a post containing text and hashtags. ``` # Output ```txt The function should return an integer representing the number of unique groups of posts. ``` # Constraints * Each post contains alphanumeric characters and hashtags prefixed by `#`. * Each post will contain at least one hashtag. * Hashtags are case-sensitive. # Example Input ```python posts = [ \\"Looking forward to the weekend! #fun #relax\\", \\"Workout time! #fitness #health\\", \\"New blog post on data science #datascience #python\\", \\"Had a great time at the beach #fun #sun\\", \\"Just finished a 5k run #fitness #run\\", \\"Exploring the city #adventure\\", \\"Enjoying a sunny day #sun #relax\\", \\"Learning new coding skills #python #coding\\" ] ``` Expected Output ```python 5 ``` # Explanation There are 5 unique groups of posts based on the hashtags they share: 1. [\\"Looking forward to the weekend! #fun #relax\\", \\"Had a great time at the beach #fun #sun\\", \\"Enjoying a sunny day #sun #relax\\"] 2. [\\"Workout time! #fitness #health\\", \\"Just finished a 5k run #fitness #run\\"] 3. [\\"New blog post on data science #datascience #python\\", \\"Learning new coding skills #python #coding\\"] 4. [\\"Exploring the city #adventure\\"] 5. [\\"Enjoying a sunny day #sun #relax\\"] # Implementation Implement the function `count_hashtag_groups` which takes a list of posts and returns the number of unique groups: ```python def count_hashtag_groups(posts: list[str]) -> int: # implementation details pass ```","solution":"def count_hashtag_groups(posts): from collections import defaultdict def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: parent[rootX] = rootY hashtag_to_posts = defaultdict(list) index = 0 for post in posts: hashtags = set(word for word in post.split() if word.startswith(\\"#\\")) for hashtag in hashtags: hashtag_to_posts[hashtag].append(index) index += 1 parent = list(range(len(posts))) for hashtag, indices in hashtag_to_posts.items(): for i in range(1, len(indices)): union(parent, indices[i - 1], indices[i]) return len(set(find(parent, i) for i in range(len(posts)))) # Example usage posts = [ \\"Looking forward to the weekend! #fun #relax\\", \\"Workout time! #fitness #health\\", \\"New blog post on data science #datascience #python\\", \\"Had a great time at the beach #fun #sun\\", \\"Just finished a 5k run #fitness #run\\", \\"Exploring the city #adventure\\", \\"Enjoying a sunny day #sun #relax\\", \\"Learning new coding skills #python #coding\\" ] print(count_hashtag_groups(posts)) # Output should be 5"},{"question":"# Array Manipulation: Find the Maximum Value Difference Problem Statement You are tasked to implement a function that finds the maximum absolute difference between any two elements in an unsorted array of integers. The array can contain positive, negative, and zero values. Function Signature ```python def max_value_difference(arr: List[int]) -> int: pass ``` Input - A list of integers `arr` that contains at least two elements. Output - An integer representing the maximum absolute difference between any two elements in the array. Example ```python # Example 1 max_value_difference([1, 2, 3, 4, 5]) -> 4 # Example 2 max_value_difference([-10, -5, 0, 5, 10]) -> 20 # Example 3 max_value_difference([1, -1, 2, -2, 3, -3]) -> 6 # Example 4 max_value_difference([100]) -> None # Less than two elements, so invalid input. ``` Constraints - The function should handle input arrays that include both large and small integers efficiently. - The time complexity of your solution should be O(n), where n is the number of elements in the array. - The function should return `None` if the input array has fewer than two elements. Additional Information - You may assume that the integers are within the range of -2^31 to 2^31-1. - Be sure to test your function with various edge cases, including arrays with large positive and negative values, duplicates, and the smallest and largest possible integers.","solution":"from typing import List, Optional def max_value_difference(arr: List[int]) -> Optional[int]: if len(arr) < 2: return None min_val = min(arr) max_val = max(arr) return abs(max_val - min_val)"},{"question":"# Coding Assessment Question You are tasked with implementing a function to perform a Left Rotation on an array. Given an integer array and a number of rotations, the function should return the array after the specified number of left rotations. **Function Signature**: ```python def left_rotate(arr: list[int], rotations: int) -> list[int]: ``` **Input**: - `arr`: A non-empty list of integers. - `rotations`: An integer representing the number of left rotations to apply. The number of rotations will always be a non-negative integer. **Output**: - A list of integers representing the array after the specified number of left rotations. **Constraints**: - `1 <= len(arr) <= 10^5` - `0 <= rotations <= 10^5` - `-10^9 <= arr[i] <= 10^9` for 0 <= i < len(arr) **Examples**: 1. `left_rotate([1, 2, 3, 4, 5], 2)` should return `[3, 4, 5, 1, 2]`. 2. `left_rotate([1, 2, 3, 4, 5], 7)` should return `[3, 4, 5, 1, 2]` (since 7 rotations are equivalent to 2 rotations). 3. `left_rotate([1], 3)` should return `[1]` (since rotating a single-element array has no effect). **Edge Cases**: 1. Rotating zero times should return the original array. 2. Rotating a single-element array should return the same array. 3. Rotating an array as many times as its length or a multiple of its length should return the original array. # Testing: 1. Write tests to ensure the function handles arrays of varying lengths, including the edge cases. 2. Check if the function performs efficiently for large inputs. **Tasks**: 1. Write the function `left_rotate` based on the provided signature. 2. Ensure your function is optimized for performance, especially for large input sizes.","solution":"def left_rotate(arr: list[int], rotations: int) -> list[int]: Performs left rotation on an array `arr` by `rotations` times. :param arr: List of integers to be rotated :param rotations: Number of left rotations to apply :return: Rotated list of integers n = len(arr) if n == 0: return arr rotations = rotations % n # Adjust rotations if they exceed the length of the array return arr[rotations:] + arr[:rotations]"},{"question":"**Matrix Rotation Algorithm** Rotate a given N x N matrix 90 degrees clockwise. This coding problem will assess your understanding of matrix manipulation, indexing, and efficient in-place transformations. Problem Statement: Write a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes an N x N matrix and returns the matrix rotated 90 degrees clockwise. Input: - A list of lists `matrix`, where each inner list represents a row of the matrix with integer values. - N x N matrix, where 1 ≤ N ≤ 500. Output: - The input matrix rotated 90 degrees clockwise. Function Signature: ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` Constraints: - The elements of the matrix will be integers between (-1000) and (1000). - The matrix will always be square (same number of rows and columns). Performance Requirements: - Aim for O(N^2) time complexity. - Ideally, perform the rotation in place without using extra space for another matrix. Example: ```python # Example 1 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Expected Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Example 2 matrix = [ [1, 2], [3, 4] ] # Expected Output: # [ # [3, 1], # [4, 2] # ] assert rotate_matrix(matrix) == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Another test case to ensure correctness assert rotate_matrix([ [1, 2], [3, 4] ]) == [ [3, 1], [4, 2] ] # Edge case: Single element assert rotate_matrix([ [5] ]) == [ [5] ] # Edge case: Large matrix (5x5) assert rotate_matrix([ [ 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ]) == [ [21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5] ] ``` Implementation Details: 1. **In-place Rotation**: - Use layer-by-layer rotation to perform the transformation without additional space for another matrix. 2. **Matrix Indexing**: - Understand and apply correct indexing for the 90-degree rotation within each layer. Note: Ensure your solution caters to edge cases such as single-element matrices and large matrices up to 500 x 500 in size.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates a given NxN matrix 90 degrees clockwise. :param matrix: List of lists where each inner list is a row of the matrix. :return: The rotated matrix. N = len(matrix) # Perform the rotation layer by layer for layer in range(N // 2): first = layer last = N - layer - 1 for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Left -> Top matrix[first][i] = matrix[last - offset][first] # Bottom -> Left matrix[last - offset][first] = matrix[last][last - offset] # Right -> Bottom matrix[last][last - offset] = matrix[i][last] # Top -> Right matrix[i][last] = top return matrix"},{"question":"# Coding Question: Median of Two Sorted Arrays Context: Finding the median of two sorted arrays is a frequent problem in data analysis, optimization, and various algorithm challenges. You are tasked with implementing an efficient solution to solve this problem that respects time complexity constraints. Task: Write a Python function `find_median_sorted_arrays(nums1: Sequence[int], nums2: Sequence[int]) -> float` that finds the median of the two sorted arrays. The overall run time complexity should be O(log(min(n, m))), where n and m are the lengths of the two arrays. Input Format: * `nums1`: A list of integers sorted in non-decreasing order. * `nums2`: A list of integers sorted in non-decreasing order. Output Format: Return a single floating-point number representing the median of the input arrays. If both arrays are empty, return `None`. Constraints: 1. The first array can be empty. 2. The second array can be empty. 3. Each array is individually sorted in non-decreasing order. 4. Both arrays together can have up to 10^6 elements. Example: ```plaintext Input: [1, 3], [2] Output: 2.0 Input: [1, 2], [3, 4] Output: 2.5 Input: [0, 0], [0, 0] Output: 0.0 Input: [], [1] Output: 1.0 Input: [2], [] Output: 2.0 Input: [], [] Output: None ``` Notes: * This problem tests your skills in binary search, handling edge cases, and merging ordered sequences. * Ensure the solution is efficient and takes advantage of the sorted properties of the input arrays. * Consider edge cases like unevenly sized arrays and arrays with overlapping or identical elements.","solution":"from typing import Sequence, Optional def find_median_sorted_arrays(nums1: Sequence[int], nums2: Sequence[int]) -> Optional[float]: if not nums1 and not nums2: return None if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 x, y = len(nums1), len(nums2) low, high = 0, x while low <= high: partitionX = (low + high) // 2 partitionY = (x + y + 1) // 2 - partitionX maxX = float(\'-inf\') if partitionX == 0 else nums1[partitionX - 1] minX = float(\'inf\') if partitionX == x else nums1[partitionX] maxY = float(\'-inf\') if partitionY == 0 else nums2[partitionY - 1] minY = float(\'inf\') if partitionY == y else nums2[partitionY] if maxX <= minY and maxY <= minX: if (x + y) % 2 == 0: return (max(maxX, maxY) + min(minX, minY)) / 2 else: return max(maxX, maxY) elif maxX > minY: high = partitionX - 1 else: low = partitionX + 1 raise ValueError(\\"Input arrays are not sorted\\")"},{"question":"# Question: Implementing a Stack with Minimum Retrieval You are asked to implement a stack data structure which, in addition to the usual stack operations, supports retrieving the minimum element in constant time. Your task is to write a class that provides these operations and a function to validate their correctness. Class Definition ```python class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def get_min(self) -> int: pass ``` Function Signature for Testing ```python def validate_min_stack_operations(operations: list[str], values: list[list[int]]) -> list[int]: ``` Input * `operations`: A list of strings where each string is one of `\\"MinStack\\", \\"push\\", \\"pop\\", \\"top\\", \\"get_min\\"`. * `values`: A list of lists where each sublist corresponds to the parameters for the operations listed in the same order. Empty sublists indicate no parameters for operations like `\\"MinStack\\"`, `\\"pop\\"`, `\\"top\\"`, and `\\"get_min\\"`. Output * Returns a list of results from top and get_min operations in the order they were called. Constraints * All operations (`push`, `pop`, `top`, `get_min`) are valid and will be called in an appropriate sequence consistent with stack operations. * Values for `push` will be integer values within the valid range of Python integers. Example ```python operations = [\\"MinStack\\", \\"push\\", \\"push\\", \\"push\\", \\"get_min\\", \\"pop\\", \\"top\\", \\"get_min\\"] values = [[], [1], [2], [-1], [], [], [], []] # Expected outputs for top and get_min operations # 1. Initialize MinStack # 2. Push 1 # 3. Push 2 # 4. Push -1 # 5. Get min -> -1 # 6. Pop (current top -1 is removed) # 7. Get top -> 2 # 8. Get min -> 1 # Expected output list -> [-1, 2, 1] print(validate_min_stack_operations(operations, values)) ``` Additional Notes * You need to handle edge cases such as popping from an empty stack and calling `top` or `get_min` on an empty stack. * Ensure that all operations execute in constant time.","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int) -> None: self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self) -> None: if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None # Assuming None for top on an empty stack for this example def get_min(self) -> int: if self.min_stack: return self.min_stack[-1] return None # Assuming None for get_min on an empty stack for this example def validate_min_stack_operations(operations: list[str], values: list[list[int]]) -> list[int]: results = [] min_stack = None for operation, value in zip(operations, values): if operation == \\"MinStack\\": min_stack = MinStack() elif operation == \\"push\\": min_stack.push(value[0]) elif operation == \\"pop\\": min_stack.pop() elif operation == \\"top\\": results.append(min_stack.top()) elif operation == \\"get_min\\": results.append(min_stack.get_min()) return results"},{"question":"# Question: Implementing Efficient String Rotations Check You are tasked with implementing a function that determines if one string is a rotation of another string. A string rotation is derived by taking a string and moving some of its leading characters to the end. For example, the rotations of the string `abcde` are `bcdea`, `cdeab`, `deabc`, and `eabcd`. Given two strings, your function should efficiently check if one string is a rotation of the other. # Input and Output Formats Function Signature ```python def are_rotations(str1: str, str2: str) -> bool: pass ``` Inputs: - `str1` (str): The first string. - `str2` (str): The second string. Outputs: - Returns `True` if `str1` is a rotation of `str2` or vice versa. - Returns `False` otherwise. Constraints: - The input strings will contain only printable ASCII characters. - The lengths of the input strings will be between 1 and 100,000 inclusive. Performance Requirements: - The function should be efficient to handle the input size constraints, preferably with a time complexity of O(n), where n is the length of the strings. Examples: ```python >>> are_rotations(\\"waterbottle\\", \\"erbottlewat\\") True >>> are_rotations(\\"hello\\", \\"elloh\\") True >>> are_rotations(\\"rotation\\", \\"tationro\\") True >>> are_rotations(\\"abcd\\", \\"dabc\\") True >>> are_rotations(\\"abcde\\", \\"abced\\") False >>> are_rotations(\\"apple\\", \\"ppale\\") False ``` # Scenario String rotations are a common concept in string manipulation problems. This task is useful in various applications like text processing or pattern recognition. Your task is to create an efficient solution to the problem of determining if one string can be rotated to become another, taking care to handle large strings within acceptable time limits.","solution":"def are_rotations(str1: str, str2: str) -> bool: Returns True if str1 is a rotation of str2 or vice versa. Returns False otherwise. if len(str1) != len(str2): return False if str1 == str2 == \\"\\": return True return str2 in str1 + str1"},{"question":"# Subset Sum Problem Implement a function to determine if there exists a subset of the given list of integers that sums up to a target number. This classic problem can be approached using dynamic programming. # Function Signature ```python def subset_sum(nums: list[int], target: int) -> bool: pass ``` # Input - A list of integers `nums`, where each integer can be both positive and negative. - An integer `target` representing the desired sum. # Output - A boolean value `True` if there exists a subset of `nums` that sums to `target`, otherwise `False`. # Constraints - The list `nums` can contain up to `1000` integers. - Each integer in `nums` is between `-1000` and `1000`. # Example ```python nums = [3, 34, 4, 12, 5, 2] target = 9 print(subset_sum(nums, target)) # Output: # True # Explanation: # There exists a subset [4, 5] that sums to 9. nums = [3, 34, 4, 12, 5, 2] target = 30 print(subset_sum(nums, target)) # Output: # False # Explanation: # No subset sums to 30. ``` # Notes - Since the problem includes negative integers, ensure your algorithm accounts for this during subset generation. - Consider using a dynamic programming approach to solve this problem efficiently. - Handle edge cases such as an empty list or very large numbers in the list. - Test your solution with various inputs to ensure accuracy and efficiency. Good luck, and make sure to validate your function with a range of tests!","solution":"def subset_sum(nums: list[int], target: int) -> bool: Determines if there exists a subset of the given list of integers that sums up to the target. Uses dynamic programming to solve the problem efficiently. n = len(nums) if n == 0: return target == 0 # Create a dictionary to store the sums we have seen so far dp = {0} for num in nums: new_dp = dp.copy() for t in dp: new_sum = t + num new_dp.add(new_sum) dp = new_dp return target in dp"},{"question":"# Coding Assessment Question Context: You\'re tasked with designing a system that processes logs of user activities and identifies the top K most frequently performing actions. This will help in analyzing trends and understanding user behavior patterns. Task: Write a Python function `top_k_actions(logs: List[str], k: int) -> List[str]` that processes a list of user activity logs and identifies the top K most frequent actions. Each log entry in the list is a string in the format `\\"USER_ID ACTION_NAME\\"`. Implementation Steps: 1. Parse the logs to build a frequency table for actions. 2. Sort the actions based on their frequency, and then by the action name alphabetically for actions with the same frequency. 3. Return the top K most frequently occurring actions. Input Format: - `logs`: A list of strings representing user activity logs, where each string is in the format `\\"USER_ID ACTION_NAME\\"`. - `k`: An integer representing the number of top actions to return. Output Format: - Return a list of the top K action names sorted by their frequency in descending order. If multiple actions have the same frequency, sort those actions alphabetically. Constraints: - Each `USER_ID` and `ACTION_NAME` will be an alphanumeric string. - 1 <= len(logs) <= 10000. - 1 <= k <= the number of unique actions in the logs. Performance Requirements: - The solution should have a time complexity of O(n log n) and space complexity of O(n), where n is the number of log entries in the list. Example: Suppose the input is: ```python logs = [ \\"u1 login\\", \\"u2 login\\", \\"u1 logout\\", \\"u3 login\\", \\"u1 login\\", \\"u2 logout\\", \\"u3 logout\\" ] ``` Calling `top_k_actions(logs, 2)` should return: ```python [\'login\', \'logout\'] ``` (Note: The actual order of actions with the same frequency will be alphabetical.) Note: - Handle edge cases where fewer than k unique actions are present in the logs. - Ensure the function is efficient and scales well with the input size.","solution":"from typing import List from collections import Counter def top_k_actions(logs: List[str], k: int) -> List[str]: Identify the top K most frequent actions from the log entries. Args: logs: List of log entries in format \\"USER_ID ACTION_NAME\\". k: Number of top actions to return. Returns: List of top K action names sorted by their frequency in descending order (alphabetically for ties). # Extract action names from logs actions = [log.split()[1] for log in logs] # Count the frequency of each action action_counts = Counter(actions) # Sort actions by frequency (descending) and then alphabetically sorted_actions = sorted(action_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top K actions top_k = [action for action, count in sorted_actions[:k]] return top_k"},{"question":"# Student Grades Processing Overview You are tasked with developing a system that processes students\' grades and calculates specific statistics based on the input data. Each student has multiple grades across different subjects, and you need to compute the average grade per student, the highest average grade among all students, and the overall average grade across all subjects. Problem Statement Write a function `process_grades(students: list[dict]) -> dict` that takes a list of dictionaries representing the students and their grades, and returns a dictionary containing the average grade for each student, the name of the student with the highest average grade, and the overall average grade across all subjects. Input - `students`: A list of dictionaries with the following structure: - `name`: A string representing the student\'s name. - `grades`: A list of floating-point numbers representing the student\'s grades. Output - A dictionary with the following structure: - `student_averages`: A dictionary with student names as keys and their average grades as values. - `highest_average`: A string representing the name of the student with the highest average grade. - `overall_average`: A floating-point number representing the overall average grade across all subjects. Constraints - Each student will have at least one grade. - Grades are floating-point numbers between 0.0 and 100.0. - No two students will have the same name. Example ```python from typing import List, Dict def process_grades(students: List[Dict[str, List[float]]]) -> Dict[str, any]: student_averages = {} total_sum = 0 total_count = 0 for student in students: average = sum(student[\'grades\']) / len(student[\'grades\']) student_averages[student[\'name\']] = average total_sum += sum(student[\'grades\']) total_count += len(student[\'grades\']) highest_average_student = max(student_averages, key=student_averages.get) overall_average = total_sum / total_count return { \'student_averages\': student_averages, \'highest_average\': highest_average_student, \'overall_average\': overall_average } # Example Test Case students = [ {\'name\': \'Alice\', \'grades\': [90.0, 85.5, 82.0]}, {\'name\': \'Bob\', \'grades\': [75.0, 88.5, 91.0]}, {\'name\': \'Charlie\', \'grades\': [95.0, 92.0, 89.0]} ] result = process_grades(students) assert result == { \'student_averages\': {\'Alice\': 85.83333333333333, \'Bob\': 84.83333333333333, \'Charlie\': 92.0}, \'highest_average\': \'Charlie\', \'overall_average\': 87.55555555555556 } ``` Implement the function to ensure that the test case passes and your code correctly computes the required statistics for the students\' grades.","solution":"from typing import List, Dict def process_grades(students: List[Dict[str, List[float]]]) -> Dict[str, any]: student_averages = {} total_sum = 0 total_count = 0 for student in students: average = sum(student[\'grades\']) / len(student[\'grades\']) student_averages[student[\'name\']] = average total_sum += sum(student[\'grades\']) total_count += len(student[\'grades\']) highest_average_student = max(student_averages, key=student_averages.get) overall_average = total_sum / total_count return { \'student_averages\': student_averages, \'highest_average\': highest_average_student, \'overall_average\': overall_average }"},{"question":"# Binary Tree Depth Counter Problem Statement Given a binary tree, define a function to count the depth of the tree. The depth of a binary tree is the number of edges from the root node to the deepest leaf node. A tree with only a root node has a depth of 0. Task Write a function `get_tree_depth(root: TreeNode) -> int` that takes the root of a binary tree and returns the depth of the tree. Input - `root`: a `TreeNode` object representing the root of the binary tree. Output - An integer representing the depth of the tree. Examples ```python # Define the binary tree nodes and structure class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example binary tree # 1 # / # 2 3 # / # 4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) get_tree_depth(root) # 2 # Example binary tree # 1 root = TreeNode(1) get_tree_depth(root) # 0 ``` Constraints 1. The number of nodes in the tree will be between 0 and 1000. 2. Node values will be integers and unique. 3. TreeNode class is pre-defined for this problem: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` Notes - You can assume the tree is well-formed and does not contain cycles. - Utilize depth-first search (DFS) or breadth-first search (BFS) to calculate the depth efficiently. - Consider edge cases like empty trees or trees with uneven depths in branches.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def get_tree_depth(root: TreeNode) -> int: def depth(node: TreeNode) -> int: if not node: return -1 left_depth = depth(node.left) right_depth = depth(node.right) return max(left_depth, right_depth) + 1 return depth(root)"},{"question":"# Merge Sorted Arrays Efficiently Write a function that merges two sorted arrays into one sorted array. The function should accommodate both arrays of varying lengths and ensure the resulting array maintains the sorted order. # Requirements 1. Implement the function `merge_sorted_arrays` that takes two sorted lists of integers `arr1` and `arr2` as inputs and returns a single sorted list containing all the elements from both input lists. 2. Optimize the solution for time complexity, aiming for a linear runtime relative to the combined length of both input lists. 3. Preserve the sorted order without using additional sorting methods post-merge. # Input and Output Specifications * **Input**: - `arr1`: A sorted list of `m` integers (`m >= 0`). - `arr2`: A sorted list of `n` integers (`n >= 0`). * **Output**: A single sorted list containing all elements from `arr1` and `arr2`. # Function Signature ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: ``` # Constraints * The input lists are already sorted in non-decreasing order. * Both input lists can be empty. * The elements in the lists can be negative or positive integers, and duplicates are allowed. # Examples 1. `merge_sorted_arrays([1, 3, 5], [2, 4, 6])` - Expected Output: `[1, 2, 3, 4, 5, 6]` 2. `merge_sorted_arrays([], [2, 4, 6])` - Expected Output: `[2, 4, 6]` 3. `merge_sorted_arrays([-5, -3, 0], [-4, -2, 1])` - Expected Output: `[-5, -4, -3, -2, 0, 1]` 4. `merge_sorted_arrays([1, 2, 2, 3], [2, 2, 4])` - Expected Output: `[1, 2, 2, 2, 2, 3, 4]` 5. `merge_sorted_arrays([], [])` - Expected Output: `[]` # Instructions 1. Implement the function `merge_sorted_arrays` as specified. 2. Ensure the function handles the provided examples and additional edge cases correctly and efficiently. 3. Aim for a time complexity of O(m + n) where `m` and `n` are the lengths of `arr1` and `arr2` respectively.","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. Parameters: arr1 (list of int): The first sorted list. arr2 (list of int): The second sorted list. Returns: list of int: The merged sorted list containing all elements from both input lists. merged = [] i, j = 0, 0 # Iterate through both arrays until one is exhausted while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 # Append remaining elements (if any) from arr1 or arr2 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 return merged"},{"question":"# Course Prerequisite Checker You are tasked with determining whether a student can complete all courses given the prerequisite relationships between the courses. Each course is a unique integer. A course must be taken after all its prerequisites have been completed. Your task is to write a function `can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool` that returns `True` if it is possible for the student to finish all courses, otherwise returns `False`. Input Format The function receives two parameters: - `num_courses` (an integer): the total number of courses. - `prerequisites` (a list of lists): each inner list contains two integers `[a, b]` where course `a` is a prerequisite of course `b`. Output Format A boolean value, `True` if all courses can be finished, otherwise `False`. Constraints - `1 <= num_courses <= 5000` - `0 <= len(prerequisites) <= 5000` - Prerequisites relationships will not contain duplicates. Example ``` 1. Example: num_courses = 2 prerequisites = [[1, 0]] Output: True Explanation: The student can complete course 0 before course 1. 2. Example: num_courses = 2 prerequisites = [[1, 0], [0, 1]] Output: False Explanation: There is a cycle in the prerequisite relationships, making it impossible to complete all courses. 3. Example: num_courses = 3 prerequisites = [[0, 2], [1, 2], [2, 0]] Output: False Explanation: There is a cycle among the courses (0 -> 2 -> 0), preventing completion of all courses. 4. Example: num_courses = 3 prerequisites = [[0, 1], [0, 2], [1, 2]] Output: True Explanation: The student can take course 2 first, then courses 1, and finally course 0. ``` Performance Requirements * The solution should aim for an efficient approach, ideally O(|V| + |E|) where |V| is the number of courses and |E| is the number of prerequisites.","solution":"from collections import defaultdict, deque from typing import List def can_finish(num_courses: int, prerequisites: List[List[int]]) -> bool: # Create graph and in-degree count graph = defaultdict(list) in_degree = [0] * num_courses # Build the graph and fill in-degrees for dest, src in prerequisites: graph[src].append(dest) in_degree[dest] += 1 # Queue for courses with no prerequisites queue = deque([course for course in range(num_courses) if in_degree[course] == 0]) visited = 0 while queue: course = queue.popleft() visited += 1 for neighbor in graph[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return visited == num_courses"},{"question":"# Background In computer science, string manipulation is a fundamental skill. One common task is to determine whether a given password is secure based on certain criteria. The criteria might include the presence of uppercase letters, lowercase letters, digits, and special characters, as well as minimum and maximum length constraints. # Task You are provided with a string representing a password. Your task is to write a function that checks if the password meets the following criteria: 1. The length of the password should be at least 8 characters and at most 20 characters. 2. The password must contain at least one uppercase letter, one lowercase letter, one digit, and one special character (any character that is not a letter or digit). # Function Signature ```python def is_secure_password(password: str) -> bool: ``` # Input * `password`: A string representing the password. # Output * Returns `True` if the password meets the criteria mentioned above, otherwise returns `False`. # Constraints * The password string will consist of printable ASCII characters only. # Example ```python # Example 1 password1 = \\"A1b!5678\\" print(is_secure_password(password1)) # Output: True # Example 2 password2 = \\"ABC123abc\\" print(is_secure_password(password2)) # Output: False # Example 3 password3 = \\"@bcDEfgh123\\" print(is_secure_password(password3)) # Output: True # Example 4 password4 = \\"Short1!\\" print(is_secure_password(password4)) # Output: False ``` # Notes * You may use Python\'s string library methods to check for the presence of different types of characters. * Consider edge cases such as very short or very long passwords that do not meet the length requirements.","solution":"def is_secure_password(password: str) -> bool: if not (8 <= len(password) <= 20): return False has_upper = any(c.isupper() for c in password) has_lower = any(c.islower() for c in password) has_digit = any(c.isdigit() for c in password) has_special = any(not c.isalnum() for c in password) return has_upper and has_lower and has_digit and has_special"},{"question":"# Problem Statement You are tasked with finding the minimum number of operations required to transform one binary string into another of the same length using specific operations. The allowed operations are: 1. Flip a single bit (changing `0` to `1` or `1` to `0`). 2. Swap the same position bit in both strings simultaneously (swapping the bit at index `i` in the first string with the bit at index `i` in the second string). # Function: min_operations_to_transform Write a function `min_operations_to_transform(str1: str, str2: str) -> int` that calculates the minimum number of operations required to transform the string `str1` into the string `str2`. Input - `str1`: A binary string (each element is either `0` or `1`) with length ( n ) (1 ≤ ( n ) ≤ ( 10^6 )). - `str2`: A binary string (each element is either `0` or `1`) with length ( n ) (1 ≤ ( n ) ≤ ( 10^6 )). Output - An integer representing the minimum number of operations required to transform `str1` into `str2`. Example ```python >>> min_operations_to_transform(\'1101\', \'1011\') 2 >>> min_operations_to_transform(\'1000\', \'0111\') 3 ``` Constraints - Both `str1` and `str2` will have the same length. - The allowed operations are as described: flipping a single bit or simultaneous bit swapping at the same positions in both strings. # Additional Notes 1. Efficiently identify and group mismatches between the strings. 2. Consider edge cases where strings are already the same or where all bits differ. 3. Analyze the potential swaps that reduce the number of required flips.","solution":"def min_operations_to_transform(str1: str, str2: str) -> int: flips = 0 for i in range(len(str1)): if str1[i] != str2[i]: flips += 1 return flips"},{"question":"# Question You are given an array of integers and you need to determine if there is a subarray (continuous sequence) that sums up to a given target integer. Your task is to write a function that finds such a subarray if it exists. # Function Signature ```python def subarray_sum(nums: list[int], target: int) -> bool: ``` # Input - `nums`: a list of integers. - `target`: an integer representing the target sum. # Output - A boolean value: `True` if such a subarray exists, `False` otherwise. # Constraints - Each input may or may not have a solution. - The input size constraint: 1 ≤ len(nums) ≤ 10^5. - Integer values will be within the range of -10^9 to 10^9. # Examples ```python >>> subarray_sum([1, 2, 3, 4, 5], 9) True >>> subarray_sum([1, 2, 3, 4, 5], 15) True >>> subarray_sum([1, 2, 3, 4, 5], 20) False >>> subarray_sum([-1, 2, 3, -4, 5], 0) True ``` # Explanation - In the first example, a subarray that sums up to 9 is [2, 3, 4]. - In the second example, the entire array sums up to 15, so the function returns `True`. - In the third example, no subarray sums up to 20, hence the function returns `False`. - In the fourth example, a subarray that sums up to 0 is [-1, 2, 3, -4]. Implement your function in Python: ```python def subarray_sum(nums: list[int], target: int) -> bool: # Your code here # ```","solution":"def subarray_sum(nums: list[int], target: int) -> bool: Returns True if there is a subarray (continuous sequence) that sums up to the given target integer, otherwise returns False. current_sum = 0 hash_map = {} for num in nums: current_sum += num if current_sum == target: return True if (current_sum - target) in hash_map: return True hash_map[current_sum] = True return False"},{"question":"# Unique Subsets Objective Write a function to generate all unique subsets of a given list of integers. Ensure the subsets are returned in lexicographical order without any duplicates. Description You need to implement a function that finds all possible unique subsets of the given list of integers and returns them in sorted order. Each subset should be sorted internally. Additionally, the list of subsets should be sorted and contain no duplicate subsets. # Function Signature ```python def unique_subsets(nums: List[int]) -> List[List[int]]: pass ``` Input - `nums`: A list of integers. # Constraints - The length of `nums` will not exceed 10. - The integers in `nums` will be in the range -10 to 10. Output - Return a list of lists, where each list is a unique subset of `nums`, sorted in lexicographical order. Examples 1. Given: - `nums = [1, 2, 2]` - Output: `[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]` 2. Given: - `nums = [-1, 0, 1]` - Output: `[[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]]` 3. Given: - `nums = [4, 4, 4, 1, 4]` - Output: `[[], [1], [1, 4], [1, 4, 4], [1, 4, 4, 4], [1, 4, 4, 4, 4], [4], [4, 4], [4, 4, 4], [4, 4, 4, 4]]` Detailed Requirements 1. Implement the `unique_subsets` function considering the requirement to generate all unique subsets and sort them. 2. Use a suitable algorithmic approach that can handle duplicates within the input list to avoid duplicate subsets. 3. Ensure each subset within the result is represented as a sorted list, and the overall result is sorted as well. 4. Validate your implementation with various edge cases, including the presence of negative numbers, duplicated elements, and different list sizes. Notes - Consider leveraging backtracking or other combinatorial generation techniques to efficiently produce the required subsets. - Pay careful attention to handle and eliminate duplicates in the input list during subset generation.","solution":"from typing import List def unique_subsets(nums: List[int]) -> List[List[int]]: Given a list of integers, return all possible unique subsets in lexicographical order. Each subset should be sorted internally. nums.sort() result = [] subset = [] def backtrack(start): result.append(subset[:]) # Add a copy of subset to result for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue # skip duplicates subset.append(nums[i]) backtrack(i + 1) subset.pop() # remove last element for backtracking backtrack(0) return result"},{"question":"# Scenario You are developing a simplified database management system (DBMS) that needs to keep track of student grades. The system should support creating and updating records, as well as querying specific information. To manage this, you will write a `GradeBook` class that stores student names and their corresponding grades, and provides various functionalities. # Task Implement the `GradeBook` class which supports the following operations: 1. **add_record(name: str, grade: float) -> None**: Adds a new student record. If the student already exists, their grade should be updated. 2. **remove_record(name: str) -> None**: Removes a student record. 3. **get_average_grade() -> float**: Returns the average grade of all students. 4. **get_student_grade(name: str) -> Optional[float]**: Returns the grade of the specified student. If the student does not exist, return `None`. 5. **get_top_student() -> Optional[str]**: Returns the name of the student with the highest grade. If there are no students, return `None`. # Input - `name`: A string representing the student\'s name (`1 <= len(name) <= 100`). - `grade`: A float representing the student\'s grade (`0.0 <= grade <= 100.0`). # Output - Returns `None` for all methods except `get_average_grade`, `get_student_grade`, and `get_top_student`. # Constraints - Assume there are no duplicate names. - Handle cases where there are no student records gracefully. # Example ```python gradebook = GradeBook() gradebook.add_record(\\"Alice\\", 91.5) gradebook.add_record(\\"Bob\\", 85.0) gradebook.add_record(\\"Alice\\", 95.0) # Update Alice\'s grade print(gradebook.get_student_grade(\\"Alice\\")) # Expected output: 95.0 print(gradebook.get_student_grade(\\"Charlie\\")) # Expected output: None print(gradebook.get_average_grade()) # Expected output: 90.0 print(gradebook.get_top_student()) # Expected output: \\"Alice\\" gradebook.remove_record(\\"Alice\\") print(gradebook.get_top_student()) # Expected output: \\"Bob\\" ``` # Notes 1. Ensure efficient handling of data structures to manage operations on potentially large datasets. 2. Provide comprehensive error checking/messages for invalid input types where applicable.","solution":"from typing import Optional class GradeBook: def __init__(self): self.records = {} def add_record(self, name: str, grade: float) -> None: self.records[name] = grade def remove_record(self, name: str) -> None: if name in self.records: del self.records[name] def get_average_grade(self) -> float: if not self.records: return 0.0 return sum(self.records.values()) / len(self.records) def get_student_grade(self, name: str) -> Optional[float]: return self.records.get(name) def get_top_student(self) -> Optional[str]: if not self.records: return None return max(self.records, key=self.records.get)"},{"question":"# Problem Statement You need to implement a function that accepts a list of integers and returns the indices of the two numbers in the list that add up to a specific target. This problem is known as the \\"Two Sum\\" problem, which tests basic understanding and application of hash tables or dictionaries. # Function Signature ```python def two_sum(nums: list[int], target: int) -> list[int]: pass ``` # Input and Output * **Input**: * `nums` (list[int]): A list of integers. * `target` (int): The target sum. * **Output**: * Returns a list of two integers, representing the indices of the two numbers that add up to the target sum. # Constraints * Each input list will have exactly one solution. * You may not use the same element twice. * Indices in the return list must be in ascending order. # Example ```python >>> two_sum([2, 7, 11, 15], 9) [0, 1] # nums[0] + nums[1] = 2 + 7 = 9 >>> two_sum([3, 2, 4], 6) [1, 2] # nums[1] + nums[2] = 2 + 4 = 6 >>> two_sum([3, 3], 6) [0, 1] # nums[0] + nums[1] = 3 + 3 = 6 ``` # Performance Requirements * Your solution should run in O(n) time to be considered optimal. # Context Solving the \\"Two Sum\\" problem evaluates your ability to implement and leverage efficient search techniques such as hash tables or dictionaries. This is foundational in understanding time complexity reduction and optimizing space usage in algorithms. --- By creating this problem, the aim is to test the candidate’s understanding of basic algorithm design and efficient use of data structures in Python. It also encourages thinking about edge cases and performance implications, making it aligned with the previous question\'s complexity and topic.","solution":"def two_sum(nums: list[int], target: int) -> list[int]: Find two indices such that the numbers at those indices add up to the target value. Args: nums (list[int]): List of integers. target (int): The target sum. Returns: list[int]: A list of two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"# Task Implement Dijkstra\'s algorithm to find the shortest path in a weighted graph from a given source node to all other nodes. # Function Signature ```python def dijkstra(graph: dict[int, dict[int, int]], source: int) -> dict[int, int]: ``` # Input - `graph`: A dictionary where keys are node values and values are dictionaries mapping neighboring nodes to edge weights between them. - `source`: An integer representing the starting node for the shortest path calculation. # Output - Returns a dictionary where keys are node values and values are the shortest distance from the source node to that node. # Constraints - The graph can contain up to 100 nodes. - Nodes are represented by integers. - Edge weights are positive integers. - Assume all nodes are reachable from the source node. # Requirements - Use Dijkstra\'s algorithm to calculate the shortest path from the source node to all other nodes. - Utilize a priority queue (or min-heap) to efficiently retrieve the next node with the shortest known distance. - Handle cases where multiple edges connect the same nodes by considering the edge with the smallest weight. # Example ```python graph = { 1: {2: 2, 5: 9, 6: 14}, 2: {1: 2, 3: 6, 4: 7}, 3: {2: 6, 4: 8}, 4: {2: 7, 3: 8, 5: 10}, 5: {1: 9, 4: 10, 6: 2}, 6: {1: 14, 5: 2} } print(dijkstra(graph, 1)) # Expected Output: {1: 0, 2: 2, 3: 8, 4: 9, 5: 9, 6: 11} graph_with_self_loop = { 1: {1: 0, 2: 1}, 2: {1: 1, 3: 3}, 3: {2: 3} } print(dijkstra(graph_with_self_loop, 1)) # Expected Output: {1: 0, 2: 1, 3: 4} ``` # Notes - Ensure to handle self-loops by confirming shortest paths do not incorrectly route through such edges. - Validate correctness by testing the function with different graph structures and source nodes.","solution":"import heapq def dijkstra(graph, source): Implements Dijkstra\'s algorithm to find the shortest path from the source node to all other nodes in a weighted graph. Parameters: graph (dict): A dictionary where keys are node values and values are dictionaries mapping neighboring nodes to edge weights. source (int): The starting node for the shortest path calculation. Returns: dict: A dictionary where keys are node values and values are the shortest distance from the source node to that node. # Initialize the shortest path dictionary with infinity for all nodes except the source shortest_paths = {node: float(\'inf\') for node in graph} shortest_paths[source] = 0 # Initialize the priority queue with the source node priority_queue = [(0, source)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node has a greater distance than the recorded shortest distance, skip it if current_distance > shortest_paths[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s shorter if distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_paths"},{"question":"# Scenario You are developing a program for a popular online bookstore to help them keep track of inventory. The bookstore offers a wide selection of books, but needs to ensure that customers are only able to purchase books that are currently in stock. You will write a function to search for a specific book by its name and determine if it is available for purchase. # Problem Statement Write a function `is_book_available(book_name: str, inventory: Dict[str, int]) -> bool` that takes a string `book_name` representing the name of the book and a dictionary `inventory` where keys are book names and values are the quantities of each book in stock. The function should return `True` if the book is available (i.e., its quantity is greater than zero) and `False` if it is not available or not found in the inventory. # Input/Output Format * **Input**: * A string `book_name` representing the name of the book. * A dictionary `inventory` with keys as book names (strings) and values as quantities (integers) representing the number of copies in stock. * **Output**: * A boolean indicating the availability of the book. # Constraints * The function should handle case sensitivity for book names appropriately. * Ensure the function is efficient and can handle reasonably large inventories. # Example ```python >>> inventory = { ... \\"The Great Gatsby\\": 3, ... \\"1984\\": 0, ... \\"To Kill a Mockingbird\\": 5, ... \\"Moby Dick\\": 2, ... } >>> is_book_available(\\"The Great Gatsby\\", inventory) True >>> is_book_available(\\"1984\\", inventory) False >>> is_book_available(\\"To Kill a Mockingbird\\", inventory) True >>> is_book_available(\\"The Catcher in the Rye\\", inventory) False ``` # Guidance Consider edge cases where the book name may not be found in the inventory, and ensure that case differences in book names are handled appropriately. The solution should efficiently manage lookups in the dictionary to check for book availability.","solution":"def is_book_available(book_name: str, inventory: dict) -> bool: Checks if the specified book is available in the inventory. Parameters: book_name: str - The name of the book to check availability for. inventory: dict - The inventory dictionary with book names as keys and quantities as values. Returns: bool - True if the book is available (quantity > 0), False otherwise. return inventory.get(book_name, 0) > 0"},{"question":"# Mimicking the Sample Questions Context In finance, the moving average is a widely used indicator that helps smooth out price data by creating a constantly updated average price. It can be useful to identify the trend direction of a stock price. Your task is to implement a function that calculates the simple moving average of stock prices over a specified window. Task Write a function `moving_average(prices: List[float], window: int) -> List[float]` that returns a list representing the simple moving average of the stock prices. Input - `prices`: A list of float numbers, representing the stock prices in chronological order. - `window`: An integer, representing the number of periods over which to calculate the moving average. Output - A list of float numbers, where each element is the average of the previous `window` prices. The first `window-1` elements should be `None`, as there aren\'t enough prices to compute the average. Constraints - (1 leq window leq text{len}(prices)) - The elements of the `prices` list will be in the range [0, 10000]. - The length of the `prices` list will not exceed 10^5. Example ```python >>> moving_average([10, 20, 30, 40, 50, 60], 3) [None, None, 20.0, 30.0, 40.0, 50.0] >>> moving_average([5, 10, 15, 20, 25], 2) [None, 7.5, 12.5, 17.5, 22.5] ``` Instructions 1. Implement the function `moving_average(prices: List[float], window: int) -> List[float]`. 2. Use efficient list operations to ensure the function can handle large inputs within the provided constraints. 3. Ensure the function correctly handles cases where prices contain values at the edge of the expected range or where the window is at its minimum or maximum allowable value.","solution":"from typing import List def moving_average(prices: List[float], window: int) -> List[float]: Returns a list representing the simple moving average of the stock prices over the specified window. The first `window-1` elements should be None, as there aren\'t enough prices to compute the average. if not prices or window <= 0: return [] averages = [None] * (window - 1) current_sum = sum(prices[:window]) averages.append(current_sum / window) for i in range(window, len(prices)): current_sum += prices[i] - prices[i - window] averages.append(current_sum / window) return averages"},{"question":"# Scrabble Word Score Calculation Objective: Create a function to calculate the scrabble score of a given word based on the letter values provided in the English Scrabble game. Problem Statement: Write a function `scrabble_score(word: str) -> int` that takes a string `word` and calculates its Scrabble word score based on the following letter values: | Letter: | A, E, I, O, U, L, N, S, T, R | D, G | B, C, M, P | F, H, V, W, Y | K | J, X | Q, Z | |---------------|------------------------------|------|------------|---------------|----|-------|-------| | Value: | 1 | 2 | 3 | 4 | 5 | 8 | 10 | Your function should return the calculated score as an integer. Input: - A string `word` containing uppercase and/or lowercase letters. Output: - An integer score representing the Scrabble score of the word. Constraints: - The length of `word` is between 1 and 15. - The `word` contains only alphabetic characters. - The function should be case-insensitive. Example: ```python scrabble_score(\\"Python\\") # Output: 14 scrabble_score(\\"QUIZ\\") # Output: 22 scrabble_score(\\"Scrabble\\") # Output: 14 scrabble_score(\\"a\\") # Output: 1 ``` Hints: 1. Consider creating a dictionary to map each letter to its corresponding score. 2. Remember to handle both uppercase and lowercase letters by converting the word to a single case (e.g., all uppercase). 3. Iterate through each letter of the word and sum their respective scores to get the total score.","solution":"def scrabble_score(word: str) -> int: Returns the scrabble score of the given word based on Scrabble letter values. scores = { 1: \\"AEIOULNRST\\", 2: \\"DG\\", 3: \\"BCMP\\", 4: \\"FHVWY\\", 5: \\"K\\", 8: \\"JX\\", 10: \\"QZ\\" } score_map = {letter: score for score, letters in scores.items() for letter in letters} total_score = sum(score_map[letter.upper()] for letter in word) return total_score"},{"question":"# Weather Data Aggregator **Objective**: Implement a function to interact with a weather API to retrieve and aggregate weather data into a user-friendly format. **Scenario**: In an application where users want to check the latest weather forecast for a given city, fetch data from a weather API and format it in a structured output. Ensure the solution is resilient to common potential issues such as network failures and invalid responses. **Requirements**: - Define a function `get_weather_forecast(city: str, api_key: str) -> dict` that: - Takes a city name (string) and the weather API key (string). - Returns a dictionary with two keys: `\\"success\\"` (boolean) and `\\"data\\"` (a dictionary containing the weather details on success or an error message on failure). - Handle empty or invalid city names by returning an appropriate error message. - Gracefully handle network errors or invalid API responses. - The weather data dictionary should include the city name, temperature, weather description, and humidity. **Function Signature**: ```python def get_weather_forecast(city: str, api_key: str) -> dict: pass ``` **Constraints**: - The API key provided is valid. - The input city is a non-empty string of maximum length 100. **Examples**: 1. `get_weather_forecast(\\"New York\\", \\"YOUR API KEY\\")` - Might return: ```python { \\"success\\": True, \\"data\\": { \\"city\\": \\"New York\\", \\"temperature\\": \\"15°C\\", \\"description\\": \\"Light rain\\", \\"humidity\\": \\"73%\\" } } ``` 2. `get_weather_forecast(\\"\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"Invalid city name.\\" } ``` 3. `get_weather_forecast(\\"NonexistentCity\\", \\"YOUR API KEY\\")` - Should return: ```python { \\"success\\": False, \\"data\\": \\"City not found.\\" } ``` 4. On network failure: - Should return: ```python { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather data.\\" } ```","solution":"import requests def get_weather_forecast(city: str, api_key: str) -> dict: Fetches and aggregates weather data for a given city. Parameters: - city (str): The name of the city to fetch weather data for. - api_key (str): The API key for accessing the weather service. Returns: - dict: A dictionary containing either the weather data or an error message. if not city or len(city) > 100: return { \\"success\\": False, \\"data\\": \\"Invalid city name.\\" } try: response = requests.get(f\\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\\") response.raise_for_status() # This will raise an HTTPError if the status is 4xx, 5xx data = response.json() if data[\'cod\'] != 200: return { \\"success\\": False, \\"data\\": \\"City not found.\\" } weather_details = { \\"city\\": city, \\"temperature\\": f\\"{data[\'main\'][\'temp\']}°C\\", \\"description\\": data[\'weather\'][0][\'description\'].capitalize(), \\"humidity\\": f\\"{data[\'main\'][\'humidity\']}%\\" } return { \\"success\\": True, \\"data\\": weather_details } except requests.exceptions.RequestException: return { \\"success\\": False, \\"data\\": \\"Network error occurred while fetching weather data.\\" }"},{"question":"# Problem Statement You are required to implement a class that manages a robot\'s movement on a 2D grid. The robot needs to navigate the grid and follow specific commands to move up, down, left, and right. Each command will instruct the robot to move in the given direction a certain number of steps. Your task is to track the robot\'s position and implement a method to determine if the robot can reach a specified target location starting from the origin (0, 0) with the given movement commands. Implement the `Robot` class with the following methods: 1. **`__init__`**: - Initialize the robot\'s starting position at the origin (0, 0). 2. **`move`**: - Given a direction (`\'U\'`, `\'D\'`, `\'L\'`, or `\'R\'`) and a number of steps, update the robot\'s position accordingly. 3. **`can_reach`**: - Given a target location (x, y), determine if the robot can reach the target location from its current position with the provided sequence of movement commands. # Requirements - Write thorough unittests for each method to confirm correctness, including edge cases. - Ensure the robot\'s movements and position updates are accurate as per the command instructions. - The `can_reach` method should efficiently determine reachability within the constraints of the commands. # Example Usage ```python robot = Robot() robot.move(\'U\', 5) # Moves to (0, 5) robot.move(\'R\', 3) # Moves to (3, 5) assert robot.can_reach(3, 5) == True assert robot.can_reach(0, 0) == False robot.move(\'D\', 2) # Moves to (3, 3) assert robot.can_reach(3, 3) == True ``` # Notes - Ensure that the movement commands only include valid directions. - The robot\'s position should be accurately updated for each valid command. - Consider the edge cases where the robot might be instructed to move such that it reaches or exceeds the grid boundaries (negative coordinates or very large values).","solution":"class Robot: def __init__(self): self.x = 0 self.y = 0 def move(self, direction, steps): if direction == \'U\': self.y += steps elif direction == \'D\': self.y -= steps elif direction == \'L\': self.x -= steps elif direction == \'R\': self.x += steps def can_reach(self, target_x, target_y): return self.x == target_x and self.y == target_y"},{"question":"# Matrix Rotation by 90 Degrees Problem Statement Given an `n x n` matrix `mat`, rotate the matrix by 90 degrees in a clockwise direction. You are required to perform this operation in-place. Function Signature ```python def rotate_matrix(mat: List[List[int]]) -> None: pass ``` Input - `mat` (List[List[int]]): A 2D list representing an `n x n` matrix, where (1 leq n leq 1000). Output - Modifies the input matrix `mat` such that it is rotated by 90 degrees in place. Does not return any value. Constraints - The matrix contains integer values. - The matrix is square (i.e., it has the same number of rows and columns). Examples ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(mat) assert mat == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] mat = [ [1, 2], [3, 4] ] rotate_matrix(mat) assert mat == [ [3, 1], [4, 2] ] ``` Solution Hints - Start by transposing the matrix (swap rows with columns). - Then, reverse each row to complete the 90-degree rotation. - Ensure all operations are performed in-place. Good luck!","solution":"from typing import List def rotate_matrix(mat: List[List[int]]) -> None: Rotates the given n x n matrix mat by 90 degrees clockwise in-place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Coding Question: You are given a list of transactions each represented as a tuple `(transaction_id, user_id, amount)`, where: * `transaction_id` (int): A unique identifier for the transaction. * `user_id` (int): The identifier for the user performing the transaction. * `amount` (float): The transaction amount. Amount can be positive (credit) or negative (debit). Your task is to write a function `calculate_user_balances` that calculates and returns the balance for each user after processing all transactions. Input: * A list of tuples, where each tuple represents a transaction. Output: * A dictionary where the keys are `user_id` and the values are the respective balances rounded to two decimal places. Constraints: * If no transactions are provided, return an empty dictionary. **Examples:** ```python >>> calculate_user_balances([(1, 101, 50.75), (2, 102, 20.25), (3, 101, -15.00), (4, 103, 100.0), (5, 102, -5.25)]) {101: 35.75, 102: 15.0, 103: 100.0} >>> calculate_user_balances([(1, 201, -20.50), (2, 201, 50.00), (3, 202, 30.00), (4, 203, -10.0)]) {201: 29.5, 202: 30.0, 203: -10.0} >>> calculate_user_balances([]) {} ``` Write the implementation of the function `calculate_user_balances(transactions: list[tuple[int, int, float]]) -> dict[int, float]` below.","solution":"def calculate_user_balances(transactions): Calculates and returns the balance for each user after processing all transactions. Args: transactions (list of tuples): A list of tuples where each tuple represents a transaction. Each tuple contains (transaction_id, user_id, amount). Returns: dict: A dictionary where the keys are user_id and the values are the respective balances rounded to two decimal places. user_balances = {} for transaction in transactions: _, user_id, amount = transaction if user_id not in user_balances: user_balances[user_id] = 0.0 user_balances[user_id] += amount # Round balances to two decimal places for user_id in user_balances: user_balances[user_id] = round(user_balances[user_id], 2) return user_balances"},{"question":"# Question: Implement and Test Enhanced Data Stream Aggregator Context: You are required to design a software module that processes a continuous data stream of integers and computes the running median in real-time. The running median is the median of all the numbers seen so far. Requirements: 1. **Real-Time Processing**: Handle a continuous stream of integers and update the running median efficiently with each new integer. 2. **Data Structure Optimization**: Use appropriate data structures to ensure efficient insertion and median retrieval operations. 3. **Scalability**: The solution should handle large streams of data. Main Function Specification: ```python class RunningMedian: def __init__(self): Initialize your data structure here. pass def add_number(self, number: int) -> None: Adds a new number to the data structure. Parameters: number (int): The new number to be added to the stream. pass def get_median(self) -> float: Retrieves the current median of the numbers. Returns: float: The median of the numbers seen so far. pass ``` * **Input**: A stream of integers added one by one using the `add_number` method. * **Output**: The current median calculated using the `get_median` method after each addition. Constraints: - The add operation should be efficient enough to handle large numbers of incoming integers quickly. - The median should be retrieved efficiently without re-sorting the entire data set each time. - Use appropriate data structures like heaps to optimize the addition and median retrieval processes. * **Example**: ```python rm = RunningMedian() rm.add_number(1) assert rm.get_median() == 1.0 rm.add_number(2) assert rm.get_median() == 1.5 rm.add_number(3) assert rm.get_median() == 2.0 rm.add_number(4) assert rm.get_median() == 2.5 rm.add_number(5) assert rm.get_median() == 3.0 ``` Performance Requirements: - Ensure the `add_number` and `get_median` operations are optimized for performance given the continuous nature of the data stream. Note: Provide a well-documented and tested solution showcasing your understanding of data structures, particularly heaps, and your ability to handle real-time data processing in Python.","solution":"import heapq class RunningMedian: def __init__(self): Initialize two heaps: max_heap for the lower half of the numbers and min_heap for the upper half of the numbers. self.max_heap = [] # Max-heap (inverted as a min-heap using negated values) self.min_heap = [] # Min-heap def add_number(self, number: int) -> None: Adds a new number to the data structure. Parameters: number (int): The new number to be added to the stream. # Add to max heap (invert the value to use as max-heap) heapq.heappush(self.max_heap, -number) # Balancing step to ensure the largest number in max_heap is smaller than the smallest in min_heap if (self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0])): val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) # Ensuring the size property: max-heap can at most have one more element than min-heap if len(self.max_heap) > len(self.min_heap) + 1: val = -heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, val) elif len(self.min_heap) > len(self.max_heap): val = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -val) def get_median(self) -> float: Retrieves the current median of the numbers. Returns: float: The median of the numbers seen so far. # Depending on the size of the heaps, the median is either the top element of max-heap # or the average of the tops of both heaps in case they have equal size. if len(self.max_heap) > len(self.min_heap): return -self.max_heap[0] return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"# Image Resizing with Bounding Box Annotation Update Context You are enhancing a machine learning dataset preparation pipeline with a function to resize images to a specified dimension. Additionally, you must correctly update the associated bounding box annotations for each image after resizing. The annotations follow the format [class, x_center, y_center, width, height] where coordinates are normalized to the range [0, 1]. Task Write a function that reads a list of image paths and corresponding annotation lists, resizes each image to the specified width and height while updating the annotations accordingly, and saves the resized images and annotations in an output directory. Function Signature ```python def resize_images_with_annotations( img_paths: list, annos: list, target_width: int, target_height: int, output_dir: str ) -> None: ... ``` Input - `img_paths` (list of str): List of paths to input images. - `annos` (list of list): List of annotation lists, where each annotation list corresponds to an image and contains multiple annotations [class, x_center, y_center, width, height]. - `target_width` (int): Desired width of the output images. - `target_height` (int): Desired height of the output images. - `output_dir` (str): Directory path to save the resized images and annotations. Output - The function should not return any value. - Resized images should be saved in the output directory with filenames including a unique string identifier. - Resized annotation files should be saved with the same unique string identifier in text format. Constraints - The output directory exists and is writable. - All images are in .jpg format. Example ```python img_paths = [\\"image1.jpg\\", \\"image2.jpg\\"] annos = [ [[0, 0.5, 0.5, 0.2, 0.2]], [[1, 0.3, 0.3, 0.1, 0.1], [2, 0.6, 0.6, 0.2, 0.2]] ] target_width = 800 target_height = 600 output_dir = \\"./resized_images\\" resize_images_with_annotations(img_paths, annos, target_width, target_height, output_dir) ``` In the output directory, you should find resized images and their corresponding annotation files for both `image1.jpg` and `image2.jpg` with unique identifiers.","solution":"import os from PIL import Image def resize_images_with_annotations(img_paths, annos, target_width, target_height, output_dir): for img_path, annotations in zip(img_paths, annos): # Load the image image = Image.open(img_path) # Get original dimensions original_width, original_height = image.size # Resize the image resized_image = image.resize((target_width, target_height)) # Save the resized image image_name = os.path.basename(img_path) name, ext = os.path.splitext(image_name) resized_image_name = f\\"{name}_resized{ext}\\" resized_image_path = os.path.join(output_dir, resized_image_name) resized_image.save(resized_image_path) # Update the annotations updated_annotations = [] for anno in annotations: cls, x_center, y_center, width, height = anno new_x_center = x_center * target_width / original_width new_y_center = y_center * target_height / original_height new_width = width * target_width / original_width new_height = height * target_height / original_height updated_annotations.append([cls, new_x_center, new_y_center, new_width, new_height]) # Save the annotations annotation_name = f\\"{name}_resized.txt\\" annotation_path = os.path.join(output_dir, annotation_name) with open(annotation_path, \'w\') as f: for anno in updated_annotations: f.write(\' \'.join(map(str, anno)) + \'n\')"},{"question":"# Coding Assessment Question: Evaluate Arithmetic Expression **Background**: You are tasked with creating a function that evaluates a given arithmetic expression represented as a string. The expression can contain positive integers, the operators `+`, `-`, `*`, `/`, and parentheses `(`, `)`. The challenge is to correctly compute the value of the given expression, respecting the order of operations and handling nested parentheses. **Function Description**: Write a function `evaluate_expression(expression: str) -> int` that calculates and returns the value of the arithmetic expression. The function must accommodate integer division. Input: * `expression`: a string representing the arithmetic expression. The string will be non-empty and can contain whitespace characters, which should be ignored. The string length will not exceed 1000 characters. Output: * An integer representing the result of the arithmetic expression. Constraints: * Ensure that the function handles incorrect input appropriately by raising a `ValueError` for invalid characters. * The function should correctly follow the order of operations (parentheses, multiplication and division, addition and subtraction). Example: ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13 assert evaluate_expression(\\"(4 + 6) * 3\\") == 30 assert evaluate_expression(\\"7 - (3 * (2 + 1))\\") == -2 assert evaluate_expression(\\"10 / 2 + 5 * (2 + 3)\\") == 30 ``` Additional Context: 1. The expression `3 + 5 * 2` should evaluate to `3 + (5 * 2) = 3 + 10 = 13`. 2. Expressions can contain nested parentheses which should be evaluated from the innermost to the outermost.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string and returns the result as an integer. Parameters: expression (str): The arithmetic expression to be evaluated. Returns: int: The result of the arithmetic expression. Raises: ValueError: If the expression contains invalid characters or is improperly formed. def operate(a, b, op): if op == \'+\': return a + b if op == \'-\': return a - b if op == \'*\': return a * b if op == \'/\': return int(a / b) def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 def apply_operation(nums, ops): op = ops.pop() b = nums.pop() a = nums.pop() nums.append(operate(a, b, op)) def evaluate(expression): i = 0 nums = [] ops = [] while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': ops.append(expression[i]) elif expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 nums.append(num) i -= 1 elif expression[i] == \')\': while ops and ops[-1] != \'(\': apply_operation(nums, ops) ops.pop() else: while ops and precedence(ops[-1]) >= precedence(expression[i]): apply_operation(nums, ops) ops.append(expression[i]) i += 1 while ops: apply_operation(nums, ops) return nums[0] if not all(c.isdigit() or c in \'()+-*/ \' for c in expression): raise ValueError(\\"Invalid characters in the expression\\") return evaluate(expression)"},{"question":"# Question: Implementing and Optimizing a Custom Sparse Matrix Implement a custom sparse matrix class optimized for memory efficiency and typical sparse matrix operations. # Task: 1. **Implement the SparseMatrix Class**: - Create a class `SparseMatrix` to handle large sparse matrices efficiently, using a dictionary to store non-zero values. - Implement methods to: - Set and get elements. - Add and multiply sparse matrices. - Transpose the matrix. 2. **Optimize and Analyze**: - Optimize the data structure for typical operations on sparse matrices. - Analyze the efficiency of your implementation, focusing on time and space complexity. - Write appropriate unittests to ensure correctness. # Specifications: - **`SparseMatrix` Class**: - `__init__(self, rows: int, cols: int)`: Initialize the sparse matrix with specified dimensions. - `set_element(self, i: int, j: int, value: float) -> None`: Set the element at position `(i, j)` to `value`. - `get_element(self, i: int, j: int) -> float`: Get the element at position `(i, j)`. - `__add__(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: Add two sparse matrices. - `__mul__(self, other: \'SparseMatrix\') -> \'SparseMatrix\'`: Multiply two sparse matrices. - `transpose(self) -> \'SparseMatrix\'`: Return the transpose of the matrix. - `__str__(self) -> str`: Return a string representation of the matrix. # Input and Output: - **Input**: - For initialization: Dimensions of the matrix (`rows` and `cols`). - For setting an element: Indices `(i, j)` and the value to set. - For getting an element: Indices `(i, j)`. - For addition and multiplication: Another sparse matrix. - **Output**: - For getting an element: The value at the specified indices. - For addition and multiplication: A new sparse matrix resulting from the operation. - For transpose: A new sparse matrix which is the transpose of the original. - For string representation: A string showing the non-zero elements in a readable format. # Constraints: - The dimensions of the matrices will be positive integers within reasonable limits for typical sparse matrices. - Sparse matrices will primarily contain zeros, with non-zero elements stored in the dictionary format. # Example: ```python # Initialize matrix 3x3 matrix1 = SparseMatrix(3, 3) matrix1.set_element(0, 0, 1.0) matrix1.set_element(1, 1, 2.0) matrix1.set_element(2, 2, 3.0) matrix2 = SparseMatrix(3, 3) matrix2.set_element(0, 2, 4.0) matrix2.set_element(1, 1, 5.0) matrix2.set_element(2, 0, 6.0) # Add matrices matrix3 = matrix1 + matrix2 print(matrix3) # Output should show the sum of the two matrices # Multiply matrices matrix4 = matrix1 * matrix2 print(matrix4) # Output should show the product of the two matrices # Transpose matrix1 matrix5 = matrix1.transpose() print(matrix5) # Output should show the transpose of matrix1 ``` # Deliverables: - Complete implementation of the `SparseMatrix` class. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate the correct operation of the sparse matrix for edge cases and general cases.","solution":"class SparseMatrix: def __init__(self, rows, cols): self.rows = rows self.cols = cols self.data = {} def set_element(self, i, j, value): if value != 0: self.data[(i, j)] = value elif (i, j) in self.data: del self.data[(i, j)] def get_element(self, i, j): return self.data.get((i, j), 0) def __add__(self, other): if self.rows != other.rows or self.cols != other.cols: raise ValueError(\\"Matrix dimensions must be the same for addition.\\") result = SparseMatrix(self.rows, self.cols) for key in self.data: result.set_element(*key, self.data[key]) for key in other.data: result.set_element(key[0], key[1], result.get_element(*key) + other.data[key]) return result def __mul__(self, other): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions are not suitable for multiplication.\\") result = SparseMatrix(self.rows, other.cols) for (i, k) in self.data: for j in range(other.cols): result.set_element(i, j, result.get_element(i, j) + self.data[(i, k)] * other.get_element(k, j)) return result def transpose(self): result = SparseMatrix(self.cols, self.rows) for (i, j) in self.data: result.set_element(j, i, self.data[(i, j)]) return result def __str__(self): # Custom string representation result = [] for key, value in self.data.items(): result.append(f\\"({key[0]}, {key[1]}): {value}\\") return \\"n\\".join(result)"},{"question":"# Median of Three Numbers **Problem Statement**: In statistics and programming, finding the median of a given set of numbers is a common task. The median is the middle value in a sorted, ascending or descending list of numbers and can be more descriptive of that data set than the average. Specifically, for a list with an odd number of elements, the median is the middle element. For an even number of elements, it is the average of the two middle elements. You are given a function `median_of_three` that computes the median of three numbers. Your task is to: 1. Implement the `median_of_three` function. 2. Ensure that your function handles both positive and negative numbers correctly. 3. Do not use any in-built functions like `sorted` or `median`. Function Signature ```python def median_of_three(a: int, b: int, c: int) -> int: pass ``` Input - `a`: An integer. - `b`: An integer. - `c`: An integer. Output - Returns an integer representing the median of the input values. Constraints - The inputs `a`, `b`, and `c` will always be integers. Example ```python >>> median_of_three(3, 1, 2) 2 >>> median_of_three(10, -5, 5) 5 >>> median_of_three(-1, -2, -3) -2 ``` Additional Requirements - Do not use any in-built sorting functions. - The function should correctly compute the median without converting the numbers to a list or any other data structure.","solution":"def median_of_three(a: int, b: int, c: int) -> int: Returns the median of three integers. if (a > b) != (a > c): return a elif (b > a) != (b > c): return b else: return c"},{"question":"# Coding Question: **Binary Tree Vertical Order Traversal** Consider a binary tree. Write a function to return the vertical order traversal of the binary tree. In vertical order traversal, nodes at the same horizontal distance are grouped together and the order of nodes in each vertical traversal should be from top to bottom. Task: Write a function `vertical_order_traversal(root: TreeNode) -> List[List[int]]` that returns the vertical order traversal of the binary tree rooted at `root`. Function Signature: ```python def vertical_order_traversal(root: TreeNode) -> List[List[int]]: ``` Input: - `root` (TreeNode): The root node of the binary tree, where TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - A list of lists of integers representing the vertical order traversal. Each sublist contains nodes at the same horizontal distance from the root. Constraints: - The number of nodes in the tree will be in the range [1, 1000]. - Each node\'s value will be in the range [-1000, 1000]. - Assume the TreeNode class is already implemented. Example: ```python # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert vertical_order_traversal(root) == [[4], [2], [1, 5, 6], [3], [7]] # Example 2 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) assert vertical_order_traversal(root) == [[2], [1, 4], [3], [5]] ``` Hints: - Use a breadth-first search (BFS) strategy to traverse the tree. - Maintain a data structure to track the horizontal distance of each node from the root. - Group nodes by horizontal distance and sort them properly to generate the vertical order traversal.","solution":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def vertical_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] # Dictionary to hold the nodes at each horizontal distance node_map = defaultdict(list) # Queue to perform BFS; holds pairs of nodes and their horizontal distance from the root queue = deque([(root, 0)]) while queue: node, hd = queue.popleft() node_map[hd].append(node.val) if node.left: queue.append((node.left, hd - 1)) if node.right: queue.append((node.right, hd + 1)) # Sorting the keys (horizontal distances) and returning the corresponding nodes return [node_map[hd] for hd in sorted(node_map.keys())]"},{"question":"# Question: Calculate Fibonacci Sequence Implement a function that calculates the first `n` numbers in the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. # Function Signature ```python def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate (1 ≤ n ≤ 50). Returns: list: A list containing the first n numbers in the Fibonacci sequence. ``` # Input - An integer `n` representing the number of Fibonacci numbers to generate (1 ≤ n ≤ 50). # Output - A list containing the first `n` numbers in the Fibonacci sequence. # Example ```python # Input n = 10 # Output [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Notes - The sequence starts with `0` and `1`. - Ensure your implementation handles the constraints efficiently and correctly generates the sequence up to the specified length.","solution":"def generate_fibonacci_sequence(n: int) -> list: Generates the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to generate (1 ≤ n ≤ 50). Returns: list: A list containing the first n numbers in the Fibonacci sequence. if n == 1: return [0] elif n == 2: return [0, 1] else: fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Context You are given a collection of documents with each document represented as a list of words. Your task is to build an inverted index that maps each unique word to the list of document IDs where it appears. An inverted index is a commonly used data structure that enables fast full-text searches. Additionally, implement a function to search for documents containing specific words using the inverted index. # Task You need to implement two functions: 1. `build_inverted_index` to build the inverted index from the list of documents. 2. `search_inverted_index` to search for documents containing all specified search words using the inverted index. # Function Signatures ```python def build_inverted_index(documents: list[list[str]]) -> dict: Builds an inverted index from the given documents. Args: documents (list[list[str]]): The list of documents, where each document is a list of words. Returns: dict: An inverted index mapping each word to the list of document IDs it appears in. def search_inverted_index(inverted_index: dict, words: list[str]) -> list[int]: Searches for documents containing all specified words using the inverted index. Args: inverted_index (dict): An inverted index mapping each word to the list of document IDs it appears in. words (list[str]): The list of words to search for. Returns: list[int]: The list of document IDs containing all the specified words. ``` # Input - For `build_inverted_index`: - `documents`: A list of lists, where each inner list represents a document and contains strings representing words. - For `search_inverted_index`: - `inverted_index`: A dictionary mapping each word to the list of document IDs it appears in. - `words`: A list of strings representing the words to search for. # Output - For `build_inverted_index`, returns a dictionary where keys are words (as strings) and values are lists of integers (representing document IDs). - For `search_inverted_index`, returns a list of integers representing the document IDs that contain all the specified words. # Constraints - Assume the document IDs are the index positions of documents in the input list. - All words are provided in lowercase without punctuation. - The list of documents is non-empty, and each document contains at least one word. - The list of search words is non-empty. # Examples ```python documents = [ [\'the\', \'quick\', \'brown\', \'fox\'], [\'jumps\', \'over\', \'the\', \'lazy\', \'dog\'], [\'the\', \'lazy\', \'dog\'], [\'the\', \'fox\', \'is\', \'quick\'], ] inverted_index = build_inverted_index(documents) expected_index = { \'the\': [0, 1, 2, 3], \'quick\': [0, 3], \'brown\': [0], \'fox\': [0, 3], \'jumps\': [1], \'over\': [1], \'lazy\': [1, 2], \'dog\': [1, 2], \'is\': [3], } assert inverted_index == expected_index search_result = search_inverted_index(inverted_index, [\'quick\', \'fox\']) expected_result = [0, 3] assert search_result == expected_result ``` # Notes - Focus on implementing an efficient and accurate inverted index building process. - Ensure the search function can handle cases where none of the documents contain the specified words, returning an empty list in such scenarios. - Consider edge cases such as documents with repeated words or search words that are not present in any document.","solution":"def build_inverted_index(documents): Builds an inverted index from the given documents. Args: documents (list[list[str]]): The list of documents, where each document is a list of words. Returns: dict: An inverted index mapping each word to the list of document IDs it appears in. inverted_index = {} for doc_id, document in enumerate(documents): for word in document: if word not in inverted_index: inverted_index[word] = [] if doc_id not in inverted_index[word]: inverted_index[word].append(doc_id) return inverted_index def search_inverted_index(inverted_index, words): Searches for documents containing all specified words using the inverted index. Args: inverted_index (dict): An inverted index mapping each word to the list of document IDs it appears in. words (list[str]): The list of words to search for. Returns: list[int]: The list of document IDs containing all the specified words. if not words: return [] # Get the list of documents containing the first search word result_docs = set(inverted_index.get(words[0], [])) # Intersect with lists of documents containing other search words for word in words[1:]: result_docs &= set(inverted_index.get(word, [])) return sorted(result_docs)"},{"question":"# N-dimensional Identity Matrix Generator You are provided with a function `identity_matrix(n)` that generates an n x n identity matrix. # Problem Statement Given a positive integer `n`, your task is to implement the function `identity_matrix(n)` that returns an n x n identity matrix. An identity matrix is a square matrix with ones on the main diagonal and zeros elsewhere. # Implementation Details * **Function Signature**: ```python def identity_matrix(n: int) -> list[list[int]]: ``` * **Input**: - `n` (int): A positive integer indicating the dimensions of the identity matrix. * **Output**: - A 2D list of integers representing the n x n identity matrix. * **Constraints**: - The input `n` will be a positive integer. - You should raise a `ValueError` if `n` is not a positive integer. # Example 1. **Input**: 3 **Output**: ```python [ [1, 0, 0], [0, 1, 0], [0, 0, 1] ] ``` 2. **Input**: 4 **Output**: ```python [ [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ] ``` # Additional Notes - Ensure your code follows the specified function signature. - Consider edge cases such as when the input is not a positive integer and handle them appropriately by raising the specified error.","solution":"def identity_matrix(n: int) -> list[list[int]]: Generates an n x n identity matrix. Parameters: n (int): The size of the identity matrix to generate. Returns: list[list[int]]: The n x n identity matrix. Raises: ValueError: If n is not a positive integer. if not isinstance(n, int) or n <= 0: raise ValueError(\\"n must be a positive integer\\") # Creating an n x n identity matrix identity = [[1 if i == j else 0 for j in range(n)] for i in range(n)] return identity"},{"question":"# Question Objective Write a function `find_missing_numbers` to find the missing numbers in a sorted array of integers. In a sorted array, the numbers can be missing anywhere in the sequence, and your task is to identify all such missing numbers. Algorithm Explanation The function should: 1. Take a sorted list of integers as input. 2. Determine the range from the minimum to the maximum value in the list. 3. Identify any numbers within this range that are not present in the list. Input and Output * **Input**: A sorted list of integers `sequence`. * **Output**: A list of integers representing the missing numbers in the sequence. Constraints * The input list will always be sorted in non-decreasing order. * The input list can be empty. * Aim for a time complexity of O(n) and space complexity of O(m), where n is the length of the input list and m is the number of missing numbers. * The function signature should be: `def find_missing_numbers(sequence: list) -> list`. Scenario Consider an exam where students\' scores are listed in sorted order. If a score is missing, a detailed analysis needs to be done to determine which scores were not included. This is essential for validating the completeness of the score sheet. Example ```python >>> sequence = [1, 2, 4, 6, 7, 10] >>> find_missing_numbers(sequence) >>> [3, 5, 8, 9] >>> sequence = [1, 2, 3, 4, 5] >>> find_missing_numbers(sequence) >>> [] >>> sequence = [] >>> find_missing_numbers(sequence) >>> [] >>> sequence = [2, 3, 5, 9] >>> find_missing_numbers(sequence) >>> [4, 6, 7, 8] ``` Develop the `find_missing_numbers` function to correctly identify missing numbers from the given sorted sequences.","solution":"def find_missing_numbers(sequence): Finds all missing numbers in a sorted list of integers. :param sequence: List of sorted integers :return: List of missing numbers in the sequence if not sequence: return [] min_val = sequence[0] max_val = sequence[-1] complete_set = set(range(min_val, max_val + 1)) given_set = set(sequence) return sorted(list(complete_set - given_set))"},{"question":"# Problem Statement Implement a text editor buffer that efficiently supports the following operations: 1. **Insert Text**: - Insert a string at any position in the buffer. 2. **Delete Text**: - Delete a substring from a specified start and end position. 3. **Replace Text**: - Replace a specified substring with another string. 4. **Get Text**: - Retrieve the current text in the buffer. # Method Signatures ```python class TextBuffer: def __init__(self): Initialize an empty buffer. pass def insert(self, text: str, position: int) -> None: Insert the given text at the specified position in the buffer. Args: - text (str): The text to insert. - position (int): The position at which to insert the text. pass def delete(self, start: int, end: int) -> None: Delete the substring from start to end in the buffer. Args: - start (int): The starting position of the substring to delete. - end (int): The ending position of the substring to delete. pass def replace(self, start: int, end: int, replacement: str) -> None: Replace the substring from start to end with the replacement text. Args: - start (int): The starting position of the substring to replace. - end (int): The ending position of the substring to replace. - replacement (str): The text to replace the substring with. pass def get_text(self) -> str: Retrieve the current text in the buffer. Returns: - str: The current text in the buffer. pass ``` # Constraints - Positions (start and end) are zero-indexed and inclusive of the start position but exclusive of the end position. - The buffer should efficiently handle multiple operations without degrading in performance significantly. # Example Usage ```python buffer = TextBuffer() # Insert text at position 0 buffer.insert(\\"Hello\\", 0) assert buffer.get_text() == \\"Hello\\" # Insert text at position 5 buffer.insert(\\" World\\", 5) assert buffer.get_text() == \\"Hello World\\" # Replace text from position 6 to 11 with \\"Everyone\\" buffer.replace(6, 11, \\"Everyone\\") assert buffer.get_text() == \\"Hello Everyone\\" # Delete text from position 5 to 13 buffer.delete(5, 13) assert buffer.get_text() == \\"Hello\\" ``` **Your task is to complete the implementation of the `TextBuffer` class as specified above. Ensure the buffer efficiently handles insert, delete, replace, and get operations.**","solution":"class TextBuffer: def __init__(self): Initialize an empty buffer. self.buffer = [] def insert(self, text: str, position: int) -> None: Insert the given text at the specified position in the buffer. Args: - text (str): The text to insert. - position (int): The position at which to insert the text. if position < 0 or position > len(self.buffer): raise ValueError(\\"Position out of range\\") self.buffer = self.buffer[:position] + list(text) + self.buffer[position:] def delete(self, start: int, end: int) -> None: Delete the substring from start to end in the buffer. Args: - start (int): The starting position of the substring to delete. - end (int): The ending position of the substring to delete. if start < 0 or end > len(self.buffer) or start > end: raise ValueError(\\"Invalid start or end position\\") self.buffer = self.buffer[:start] + self.buffer[end:] def replace(self, start: int, end: int, replacement: str) -> None: Replace the substring from start to end with the replacement text. Args: - start (int): The starting position of the substring to replace. - end (int): The ending position of the substring to replace. - replacement (str): The text to replace the substring with. if start < 0 or end > len(self.buffer) or start > end: raise ValueError(\\"Invalid start or end position\\") self.buffer = self.buffer[:start] + list(replacement) + self.buffer[end:] def get_text(self) -> str: Retrieve the current text in the buffer. Returns: - str: The current text in the buffer. return \'\'.join(self.buffer)"},{"question":"# Generate All Possible Subsets of a Set You are tasked with implementing a function to generate all possible subsets of a given set of integers. This problem can also be referred to as finding the power set of the given set. # Problem Statement Write a function `generate_subsets(nums: list[int]) -> list[list[int]]` that: - **Input**: - `nums`: A list of integers representing the original set. - **Output**: - Returns a list of lists, where each inner list represents a subset of the original set. # Constraints - The length of `nums` does not exceed 20. - The elements in `nums` are unique. - `nums` can contain negative, zero, and positive integers. # Performance Requirements - Aim to implement the algorithm with a time complexity of (O(2^n)) where (n) is the length of `nums`. - Ensure the solution remains efficient and comprehensive given the constraints. # Example ```python # Example 1 nums = [1, 2, 3] subsets = generate_subsets(nums) print(subsets) # Output Example: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] # Example 2 nums = [0, 1] subsets = generate_subsets(nums) print(subsets) # Output Example: [[], [0], [1], [0, 1]] ``` # Function Signature ```python def generate_subsets(nums: list[int]) -> list[list[int]]: pass ``` # Additional Notes: - The order of subsets in the output list does not matter. - You are encouraged to iterate over different methods for generating subsets (e.g., using recursion, bit manipulation, or iterative approaches). - Edge cases to consider include an empty input list, a list with one element, and a list of entirely negative/positive numbers.","solution":"def generate_subsets(nums: list[int]) -> list[list[int]]: Generates all possible subsets of a given set of integers. :param nums: List of unique integers :return: List containing lists, each representing a subset of nums result = [[]] for num in nums: result += [curr + [num] for curr in result] return result # Example usage: # nums = [1, 2, 3] # print(generate_subsets(nums)) # Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]"},{"question":"# File Processing and Data Analysis Create a function `extract_high_salary` that processes a CSV file containing employee data and returns a list of employee names who earn above a specified salary threshold. # Data Details: - The CSV file consists of the following columns: - `EmployeeID` (`int`): Unique identifier for the employee. - `Name` (`str`): Name of the employee. - `Department` (`str`): Department where the employee works. - `Salary` (`float`): Salary of the employee. # Requirements: 1. Implement the function `extract_high_salary(filename: str, salary_threshold: float) -> list` to read the CSV file, process the data, and return a list of names of employees earning above the specified salary threshold. 2. Handle cases where the CSV file might be missing or formatted incorrectly. 3. Ensure that the function efficiently handles large files. # Function Signature: ```python def extract_high_salary(filename: str, salary_threshold: float) -> list: ``` # Inputs: - `filename` (`str`): The name of the CSV file containing the employee data. - `salary_threshold` (`float`): The salary threshold for filtering employees. # Output: - `list`: A list of names of employees whose salary is above the specified threshold. # Constraints: - Assume the CSV file will have at least `EmployeeID`, `Name`, `Department`, and `Salary` columns. - Handle file-related errors gracefully. - The names should be returned in the order they appear in the file. # Example Usage: ```python # Given a CSV file \\"employees.csv\\" with content: # EmployeeID,Name,Department,Salary # 1,John Doe,Engineering,80000 # 2,Jane Smith,Marketing,95000 # 3,Jim Brown,Sales,45000 # 4,Ella Lopez,Engineering,120000 result = extract_high_salary(\\"employees.csv\\", 90000) print(result) # Expected output: [\'Jane Smith\', \'Ella Lopez\'] ``` Implement `extract_high_salary` to correctly read from a CSV file, handle unexpected file errors, and efficiently process to return the correct list of employee names based on the salary threshold.","solution":"import csv from typing import List def extract_high_salary(filename: str, salary_threshold: float) -> List[str]: Extracts the names of employees earning above a specified salary threshold from a CSV file. Parameters: - filename (str): The name of the CSV file containing the employee data. - salary_threshold (float): The salary threshold for filtering employees. Returns: - List[str]: A list of names of employees whose salary is above the specified threshold. high_salary_employees = [] try: with open(filename, newline=\'\', encoding=\'utf-8\') as csvfile: reader = csv.DictReader(csvfile) for row in reader: try: salary = float(row[\'Salary\']) if salary > salary_threshold: high_salary_employees.append(row[\'Name\']) except ValueError: # If the salary is not a valid float, skip this row continue except FileNotFoundError: print(f\\"File {filename} not found.\\") except csv.Error: print(\\"Error reading the CSV file.\\") return high_salary_employees"},{"question":"# Balanced Binary Search Tree (BST) Validation **Context**: You are developing a component for a data management system that requires validating whether a given binary tree is a balanced Binary Search Tree (BST). A balanced BST not only adheres to the properties of a standard BST but also ensures that the height of the two subtrees of every node differ by no more than 1. **Task**: Implement a function to verify if a given binary tree is a balanced BST. **Instructions**: 1. Complete the `is_balanced_bst` method for the `BinaryTree` class. 2. Your method should first ensure the tree adheres to BST properties, then check if it is balanced. 3. Assume the tree nodes contain integer values. **Input Format**: - A root node of the binary tree. **Output Format**: - A boolean value: `True` if the tree is a balanced BST, `False` otherwise. **Constraints**: - Do not use additional libraries for tree handling; build upon the provided class interface. - Assume the input binary tree will not contain duplicate values. ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def is_balanced_bst(self, node=None): Check if the binary tree is a balanced Binary Search Tree (BST). :param node: The current node in the binary tree. :return: Boolean indicating whether the tree is a balanced BST. if node is None: node = self.root def check(node): Helper function to check the BST properties and balance of the tree. :param node: The current node. :return: A tuple (is_bst, is_balanced, height) if node is None: return (True, True, 0) left_bst, left_balanced, left_height = check(node.left) right_bst, right_balanced, right_height = check(node.right) # Check if current node respects BST properties is_bst = left_bst and right_bst and (node.left is None or node.left.value < node.value) and (node.right is None or node.right.value > node.value) # Check if current node is balanced is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 # Height of current node height = 1 + max(left_height, right_height) return (is_bst, is_balanced, height) return check(node)[0] and check(node)[1] # Example root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(15) root.left.left = TreeNode(2) root.left.right = TreeNode(7) root.right.right = TreeNode(20) tree = BinaryTree(root) print(tree.is_balanced_bst()) ``` **Example**: Input: ``` 10 / 5 15 / 2 7 20 ``` Output: ``` True ``` Input: ``` 10 / 15 5 / 2 ``` Output: ``` False ```","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def is_balanced_bst(self, node=None): Check if the binary tree is a balanced Binary Search Tree (BST). :param node: The current node in the binary tree. :return: Boolean indicating whether the tree is a balanced BST. if node is None: node = self.root def check(node): Helper function to check the BST properties and balance of the tree. :param node: The current node. :return: A tuple (is_bst, is_balanced, height) if node is None: return (True, True, 0) left_bst, left_balanced, left_height = check(node.left) right_bst, right_balanced, right_height = check(node.right) # Check if current node respects BST properties is_bst = left_bst and right_bst and (node.left is None or node.left.value < node.value) and (node.right is None or node.right.value > node.value) # Check if current node is balanced is_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 # Height of current node height = 1 + max(left_height, right_height) return (is_bst, is_balanced, height) # Run the check on the subtree is_bst, is_balanced, _ = check(node) return is_bst and is_balanced"},{"question":"# Problem Statement You are given an undirected graph with ( n ) nodes and ( m ) edges. Write a Python function `is_cyclic_graph(n: int, edges: List[Tuple[int, int]]) -> bool` that detects if there is a cycle in the graph. # Input * An integer ( n ) representing the number of nodes where ( 1 leq n leq 10^5 ). * A list of ( m ) tuples, where each tuple contains two integers ( (u, v) ) indicating an edge between node ( u ) and node ( v ), and ( 0 leq m leq 10^5 ). # Output * Return `True` if there is at least one cycle in the graph, otherwise return `False`. # Constraints * The graph does not contain any self-loops or multiple edges between the same pair of nodes. * Your solution should ideally utilize a Union-Find (Disjoint Set Union) structure or Depth-First Search (DFS) for cycle detection, running efficiently within the given constraints. # Examples ```python def is_cyclic_graph(n: int, edges: List[Tuple[int, int]]) -> bool: # Your implementation here # Example 1 print(is_cyclic_graph(5, [(1, 2), (1, 3), (2, 4), (2, 5)])) # Output: False # Example 2 print(is_cyclic_graph(4, [(1, 2), (2, 3), (3, 4), (4, 2)])) # Output: True # Example 3 print(is_cyclic_graph(3, [(1, 2), (2, 3), (3, 1)])) # Output: True # Example 4 print(is_cyclic_graph(6, [(1, 2), (1, 3), (2, 4), (2, 5), (5, 6)])) # Output: False ``` # Explanation - In the first example, there is no cycle in the graph. - In the second example, the graph has a cycle among nodes 2, 3, and 4. - In the third example, the graph forms a cycle among nodes 1, 2, and 3. - In the fourth example, the graph does not contain any cycles. # Notes * Implementing an efficient cycle detection algorithm is crucial for large inputs. * Consider corner cases like very sparse graphs (graphs with almost no edges) and dense graphs with multiple nodes having higher connectivity.","solution":"from typing import List, Tuple def is_cyclic_graph(n: int, edges: List[Tuple[int, int]]) -> bool: parent = [-1] * n def find_parent(v): if parent[v] == -1: return v return find_parent(parent[v]) def union(u, v): parent_u = find_parent(u) parent_v = find_parent(v) if parent_u != parent_v: parent[parent_u] = parent_v for u, v in edges: u -= 1 v -= 1 parent_u = find_parent(u) parent_v = find_parent(v) if parent_u == parent_v: return True union(u, v) return False"},{"question":"**Dynamic Programming (DP) for Subset Sum** # Background: The subset sum problem is a well-known problem in computer science, particularly in the field of combinatorial optimization. It involves determining whether there exists a subset of a given set of integers that sums up to a specified target value. This problem has applications in various fields, including cryptography, computational biology, and finance. # Problem Statement: You are required to implement a function that uses dynamic programming to determine if there exists a subset of a given list of integers that sums up to a specified target value. # Function Signature: ```python def subset_sum(arr: list, target: int) -> bool: :param arr: List of integers. :param target: The target sum value. :return: True if there exists a subset of the list that sums up to the target, False otherwise. # Requirements: 1. Implement the `subset_sum` function using dynamic programming. 2. Initialize a boolean DP array of size `(target + 1)` where `dp[i]` will be True if a subset with sum `i` can be achieved; otherwise False. 3. Populate the DP array based on the input list `arr`. 4. Return the value of `dp[target]` which indicates whether a subset with the target sum exists. # Constraints: - The list `arr` will contain integers with possible negative values. - The list `arr` will have a length in the range [1, 1000]. - The target value `target` will be an integer in the range [-10,000, 10,000]. # Example: ```python # Example 1 arr = [3, 34, 4, 12, 5, 2] target = 9 result = subset_sum(arr, target) # Output: True (because the subset [4, 5] sums up to 9) # Example 2 arr = [3, 34, 4, 12, 5, 2] target = 30 result = subset_sum(arr, target) # Output: False (because no subset sums up to 30) ``` This function should determine and return whether a subset of `arr` exists that sums up to the given `target` value. # Note: * Ensure that your solution is efficient and handles large lists and target values appropriately. * Consider edge cases such as the target being zero, negative values in `arr`, or very large/small target values.","solution":"def subset_sum(arr, target): Returns True if there exists a subset of the list that sums up to the target, False otherwise. n = len(arr) # Using a set to store possible sums to handle negative values dp = {0} for num in arr: new_dp = dp.copy() for t in dp: new_dp.add(t + num) dp = new_dp return target in dp"},{"question":"# Code Exercise: Write a function to compute the maximum depth of nested parenthesis within a given string. The maximum depth of nested parenthesis refers to the maximum number of valid parentheses pairs you can find nested inside each other in the string. # Function Signature ```python def max_parenthesis_depth(s: str) -> int: ``` # Input - A string `s` consisting of characters `(`, `)`, and lowercase alphabets. # Output - An integer representing the maximum depth of nested parenthesis in the string. # Constraints - The length of string `s` will be between 1 and 100,000. # Scenario Consider you are working on a syntax checker for a new programming language, and your task is to determine the nesting level of parenthesis to ensure they are balanced and to help optimize the way code blocks are handled internally. # Example ```python # Example usage: print(max_parenthesis_depth(\\"(a(b)c(d(e)f)g)\\")) # Output: 3 print(max_parenthesis_depth(\\"a(b)c(d)\\")) # Output: 1 print(max_parenthesis_depth(\\"x + (y * (z + (w - u)))\\")) # Output: 3 print(max_parenthesis_depth(\\"no(parenthesis)\\")) # Output: 0 ```","solution":"def max_parenthesis_depth(s: str) -> int: Compute the maximum depth of nested parenthesis within a given string. Args: s (str): The input string containing characters \'(\', \')\', and lowercase alphabets. Returns: int: The maximum depth of nested parenthesis in the string. max_depth = 0 current_depth = 0 for char in s: if char == \'(\': current_depth += 1 max_depth = max(max_depth, current_depth) elif char == \')\': if current_depth > 0: current_depth -= 1 return max_depth"},{"question":"# Problem Statement You are tasked with implementing a rudimentary version of a Tic-Tac-Toe game. The game should allow two players to play against each other on a 3x3 board. Specifically, you will: 1. Implement methods for initializing the board, making a move, checking for a win, and displaying the board. 2. Ensure the game correctly handles turns and enforces the rules of Tic-Tac-Toe. # Requirements - Create a `TicTacToe` class to manage the state of the game. - Implement the following methods to the class: * `__init__` to initialize the board. * `make_move` to make a move for a player. * `check_winner` to check if there is a winner. * `display_board` to print the current state of the board. # Function Implementation Method Header 1. **Initialization**: ```python def __init__(self) -> None: ``` - Initializes an empty 3x3 board. 2. **Making a move**: ```python def make_move(self, row: int, col: int, player: str) -> bool: ``` - **row**: The row index where the player wants to place their mark (0, 1, or 2). - **col**: The column index where the player wants to place their mark (0, 1, or 2). - **player**: A string representing the player (\'X\' or \'O\'). - **returns**: A boolean indicating if the move was successful. 3. **Checking for a winner**: ```python def check_winner(self) -> Union[str, None]: ``` - **returns**: \'X\' if player X wins, \'O\' if player O wins, or `None` if there is no winner yet. 4. **Displaying the board**: ```python def display_board(self) -> None: ``` - Prints the current state of the board in a readable format. # Input and Output Formats - The board will be a 3x3 grid represented by a 2D list. - Player marks will be strings \'X\' or \'O\'. - The methods will return appropriate types as described above. # Constraints - Moves must be within the bounds of the 3x3 board. - A cell can only be marked once. - The game should alternate between players \'X\' and \'O\'. # Example ```python # Example usage of the TicTacToe class game = TicTacToe() game.make_move(0, 0, \'X\') game.display_board() # Output: # X _ _ # _ _ _ # _ _ _ game.make_move(1, 1, \'O\') game.display_board() # Output: # X _ _ # _ O _ # _ _ _ game.make_move(0, 1, \'X\') game.display_board() # Output: # X X _ # _ O _ # _ _ _ game.make_move(2, 1, \'O\') game.display_board() # Output: # X X _ # _ O _ # _ O _ game.make_move(0, 2, \'X\') game.display_board() print(game.check_winner()) # Expected Output: X # Output: # X X X # _ O _ # _ O _ ``` # Notes - Ensure proper handling of invalid moves, such as placing a mark on an already occupied cell or playing out of turn. - The board display should be user-friendly, displaying the current state clearly.","solution":"class TicTacToe: def __init__(self): Initializes an empty 3x3 board. self.board = [[\'_\' for _ in range(3)] for _ in range(3)] self.current_turn = \'X\' def make_move(self, row, col, player): Makes a move for the player at the specified row and column. :param row: int - Row index where the player wants to place their mark (0, 1, or 2). :param col: int - Column index where the player wants to place their mark (0, 1, or 2). :param player: str - The player making the move (\'X\' or \'O\'). :return: bool - True if the move is successful, False otherwise. if self.board[row][col] != \'_\' or player != self.current_turn: return False self.board[row][col] = player self.current_turn = \'O\' if self.current_turn == \'X\' else \'X\' return True def check_winner(self): Checks if there is a winner. :return: str or None - Returns \'X\' if player X wins, \'O\' if player O wins, None otherwise. # Check rows and columns for a winner for i in range(3): if self.board[i][0] == self.board[i][1] == self.board[i][2] != \'_\': return self.board[i][0] if self.board[0][i] == self.board[1][i] == self.board[2][i] != \'_\': return self.board[0][i] # Check diagonals for a winner if self.board[0][0] == self.board[1][1] == self.board[2][2] != \'_\': return self.board[0][0] if self.board[0][2] == self.board[1][1] == self.board[2][0] != \'_\': return self.board[0][2] return None def display_board(self): Displays the current state of the board. for row in self.board: print(\' \'.join(row))"},{"question":"# Problem Statement: You are given a function that calculates the reverse of a string. Your task is to implement a new function named `reverse_words_in_string(s: str) -> str` that reverses the order of words in a given string while keeping the relative order of spaces intact. # Requirements: 1. If the input string is empty, return an empty string. 2. Handle multiple spaces between words and leading/trailing spaces. 3. Ensure the function maintains O(n) complexity, where n is the length of the string. # Function Signature: ```python def reverse_words_in_string(s: str) -> str: pass ``` # Input Format: * `s`: A string containing words separated by spaces. # Output Format: * A string with the words in reversed order, preserving the original spacing. # Example: ```python # Example 1 s = \\" hi there \\" # Words reversed with preserved spaces: \\" there hi \\" print(reverse_words_in_string(s)) # Example 2 s = \\"hello world\\" # Words reversed with preserved spaces: \\"world hello\\" print(reverse_words_in_string(s)) # Example 3 s = \\"a b c\\" # Words reversed with preserved spaces: \\"c b a\\" print(reverse_words_in_string(s)) ``` # Constraints: * The given string can contain any printable ASCII characters and have a maximum length of 1000 characters.","solution":"def reverse_words_in_string(s: str) -> str: Reverses the order of words in the given string while preserving the relative order of spaces. # Splitting the string into words and preserving spaces parts = s.split(\' \') words = [part for part in parts if part != \'\'] spaces = [len(part) for part in parts if part == \'\'] # Output the string by processing words in reverse order result = [] word_index = len(words) - 1 for part in parts: if part == \'\': # Preserve spaces result.append(\'\') else: # Append words in reverse order if word_index >= 0: result.append(words[word_index]) word_index -= 1 return \' \'.join(result)"},{"question":"# Context: A string is considered \\"balanced\\" if for every character in the string, there is an equal number of occurrences of each character paired with its \\"opposite\\". In this exercise, you will implement a function to determine if the given string meets the balanced criteria. # Task: Write a function `is_balanced(s, pairs)` that takes a string `s` and a list of character pairs, and returns `True` if the string is balanced according to the given pairs, and `False` otherwise. # Input: - `s`: a string consisting of lowercase alphabetical characters. - `pairs`: a list of tuples, where each tuple consists of two characters that are considered opposites. # Output: - A boolean value `True` if the string meets the balanced criteria for the provided pairs, and `False` otherwise. # Constraints: - The length of `s` will not exceed 1,000,000 characters. - The length of `pairs` will not exceed 10. - Each character in the pair will be a single lowercase alphabetical character. - Characters in the string and pairs are case insensitive, treat pairs like (\'a\', \'A\') as (\'a\', \'A\'). # Example: ```python s = \\"aabbcc\\" pairs = [(\'a\', \'b\'), (\'c\', \'d\')] assert is_balanced(s, pairs) == False s = \\"abccab\\" pairs = [(\'a\', \'c\'), (\'b\', \'d\')] assert is_balanced(s, pairs) == True ``` # Performance Requirements: - The function should efficiently handle the input constraints without excessive memory usage or time delays.","solution":"def is_balanced(s, pairs): Check if the string s is balanced according to the given pairs. Args: s (str): The input string. pairs (list of tuples): List of character pairs. Returns: bool: True if the string meets the balanced criteria, False otherwise. balance_dict = {} # Initialize the balance dictionary for pair in pairs: balance_dict[pair[0]] = 0 balance_dict[pair[1]] = 0 # Count occurrences of each character in the string for char in s: if char in balance_dict: balance_dict[char] += 1 # Check if the occurrences are balanced for pair in pairs: if balance_dict[pair[0]] != balance_dict[pair[1]]: return False return True"},{"question":"# Question: Fibonacci Sequence with Memoization and Iterative Approach You are tasked with implementing a function to generate the nth Fibonacci number using both memoization and iterative approaches. This function should also handle edge cases and input validation appropriately. A Fibonacci number is defined as: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for `n > 1` Your function should raise an appropriate error for invalid inputs. **Function Signature**: ```python def fibonacci_memoization(n: int) -> int: pass def fibonacci_iterative(n: int) -> int: pass ``` # Input - `n` (integer): A non-negative integer representing the position in the Fibonacci sequence. # Output - Returns the Fibonacci number at position `n` as an integer. # Constraints - The function should only accept non-negative integer inputs. - Should handle edge cases, such as non-integer and negative integer inputs by raising `ValueError`. - Use appropriate error messages as mentioned in the given examples. # Examples ```python assert fibonacci_memoization(0) == 0 assert fibonacci_memoization(1) == 1 assert fibonacci_memoization(5) == 5 assert fibonacci_memoization(10) == 55 assert fibonacci_iterative(0) == 0 assert fibonacci_iterative(1) == 1 assert fibonacci_iterative(5) == 5 assert fibonacci_iterative(10) == 55 try: fibonacci_memoization(-1) except ValueError as e: assert str(e) == \\"fibonacci_memoization() not defined for negative values\\" try: fibonacci_iterative(-1) except ValueError as e: assert str(e) == \\"fibonacci_iterative() not defined for negative values\\" try: fibonacci_memoization(0.5) except ValueError as e: assert str(e) == \\"fibonacci_memoization() only accepts integral values\\" try: fibonacci_iterative(0.5) except ValueError as e: assert str(e) == \\"fibonacci_iterative() only accepts integral values\\" ```","solution":"def fibonacci_memoization(n: int) -> int: if not isinstance(n, int): raise ValueError(\\"fibonacci_memoization() only accepts integral values\\") if n < 0: raise ValueError(\\"fibonacci_memoization() not defined for negative values\\") memo = {0: 0, 1: 1} def fib_memo(n, memo): if n in memo: return memo[n] memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo) return memo[n] return fib_memo(n, memo) def fibonacci_iterative(n: int) -> int: if not isinstance(n, int): raise ValueError(\\"fibonacci_iterative() only accepts integral values\\") if n < 0: raise ValueError(\\"fibonacci_iterative() not defined for negative values\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"**Product of Array Except Self** # Problem Statement Given an array of integers `nums`, create a program that returns an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. # Input - An integer array `nums` of length `n` (1 <= n <= 10^5), where each element `nums[i]` (1 <= nums[i] <= 100). # Output - An integer array `output` of length `n` where each `output[i]` represents the product of all elements of `nums` except `nums[i]`. # Constraints - You must solve it without using division and in O(n) time complexity. # Example ``` Input: [1, 2, 3, 4] Output: [24, 12, 8, 6] Input: [2, 3, 4] Output: [12, 8, 6] Input: [5, 6] Output: [6, 5] Input: [10] Output: [1] ``` # Instructions Implement the function `product_except_self(nums: List[int]) -> List[int]` which takes an array of integers `nums` and returns an array `output` such that `output[i]` is the product of all elements in `nums` except `nums[i]`. # Example Function Signature ```python from typing import List def product_except_self(nums: List[int]) -> List[int]: # Your code here ``` # Implementation Considerations - Ensure that your solution efficiently handles the entire range of input sizes. - Avoid using the division operation to create the solution. # Performance Requirement - Your code should have a time complexity of O(n) to handle the upper limit constraints effectively.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) output = [1] * n left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"# Image Edge Detection **Context**: You are developing an image processing tool that supports various image manipulation features, including edge detection to highlight edges within images. One of the fundamental techniques to perform edge detection is using the Sobel operator. You are required to implement a function to apply the Sobel filter on a given grayscale image to detect edges. **Task**: Implement the `sobel_edge_detection` function that takes a grayscale PIL image object and returns a new image highlighting the edges based on the Sobel operator. # Function Signature: ```python def sobel_edge_detection(image: Image) -> Image: image: is a grayscale PIL image object returns: a new grayscale PIL image object with edges highlighted using the Sobel operator. ``` # Constraints: 1. The input image is guaranteed to be non-empty and in grayscale. 2. You should implement the Sobel filter using convolution manually instead of using pre-built libraries. 3. Ensure proper handling of image boundaries while applying the filter. # Expected Input/Output: - **Input**: A grayscale PIL image object. - **Output**: A new grayscale PIL image object highlighting the edges. **Example**: ```python from PIL import Image import numpy as np # Creating a mock grayscale image using numpy image_data = np.random.randint(0, 256, (10, 10), dtype=np.uint8) image = Image.fromarray(image_data, \'L\') # Applying Sobel edge detection output_image = sobel_edge_detection(image) # Output image will have edges highlighted ``` # Additional Notes: - The Sobel operator consists of two kernels, one for detecting horizontal changes and another for vertical changes: - Gx = [[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]] - Gy = [[-1, -2, -1], [0, 0, 0], [+1, +2, +1]] - The magnitude of the gradient can be calculated as: `sqrt(Gx^2 + Gy^2)`. - Ensure the final pixel values are clamped between 0 and 255. # Example Implementation: ```python from PIL import Image import numpy as np def sobel_edge_detection(image: Image) -> Image: # Convert image to numpy array to perform computations image_array = np.array(image, dtype=float) # Sobel kernels Gx = np.array([[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]]) Gy = np.array([[-1, -2, -1], [0, 0, 0], [+1, +2, +1]]) # Get image dimensions rows, cols = image_array.shape # Apply Sobel filter sobel_image = np.zeros_like(image_array) for i in range(1, rows-1): for j in range(1, cols-1): Sx = np.sum(Gx * image_array[i-1:i+2, j-1:j+2]) Sy = np.sum(Gy * image_array[i-1:i+2, j-1:j+2]) sobel_image[i, j] = np.sqrt(Sx**2 + Sy**2) # Clamp values to the valid range and convert back to uint8 sobel_image = np.clip(sobel_image, 0, 255).astype(np.uint8) # Convert back to PIL Image return Image.fromarray(sobel_image, \'L\') ```","solution":"from PIL import Image import numpy as np def sobel_edge_detection(image: Image) -> Image: Takes in a grayscale PIL image object and returns a new image highlighting the edges using the Sobel operator. # Convert image to numpy array for processing image_array = np.array(image, dtype=float) # Sobel kernels Gx = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=float) Gy = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]], dtype=float) # Get image dimensions rows, cols = image_array.shape # Prepare an array to store the output edges edge_image = np.zeros_like(image_array) # Convolution and edge detection for i in range(1, rows-1): for j in range(1, cols-1): region = image_array[i-1:i+2, j-1:j+2] Sx = np.sum(Gx * region) Sy = np.sum(Gy * region) edge_magnitude = np.sqrt(Sx**2 + Sy**2) edge_image[i, j] = edge_magnitude # Clamp the values to the valid range (0 to 255) and convert to uint8 edge_image = np.clip(edge_image, 0, 255).astype(np.uint8) # Convert back to PIL image return Image.fromarray(edge_image, \'L\')"},{"question":"# Problem Statement You\'ve been tasked with analyzing a sequence of integers to find the first pair of duplicate elements within the list. The duplicates can appear consecutively or with other elements in between. Your solution needs to be efficient, ideally working within linear time complexity. # Task **Implement a function `first_duplicate(nums)` to determine the first pair of duplicated elements in the given list.** **Specifications**: 1. The function should return the first duplicated element it encounters. 2. If no duplicates are found, return `None`. 3. Ensure the function handles lists of varying lengths, including empty lists. 4. Optimize the function to operate within O(n) time complexity. **Input Format**: - A list of integers `nums`. **Output Format**: - An integer indicating the first duplicate element found in the list, or `None` if no duplicates exist. **Examples**: ```python >>> first_duplicate([1, 2, 3, 1]) 1 >>> first_duplicate([1, 2, 3, 4, 5]) None >>> first_duplicate([5, 1, 5, 1, 7, 8]) 5 >>> first_duplicate([]) None >>> first_duplicate([2, 4, 2, 4]) 2 ``` # Constraints: - The function should have a linear time complexity O(n). - Aim to use only a constant amount of extra space, O(1) (excluding the input list itself).","solution":"def first_duplicate(nums): This function returns the first duplicated element it encounters in the list of integers nums. If no duplicates are found, it returns None. seen = set() for num in nums: if num in seen: return num seen.add(num) return None"},{"question":"# Coding Assessment Question **Non-Repeating Element Finder** You are to write a program that finds the first non-repeating element in a list of integers. The function should return the first integer that does not repeat. If no such element exists, return `None`. Function Signature ```python def first_non_repeating_element(elements: List[int]) -> Union[int, None]: Returns the first non-repeating element in the list. :param elements: A list of integers where 1 <= len(elements) <= 10^5. :return: The first non-repeating element or None if all elements repeat. ``` Input * `elements` - a list of integers `[a1, a2, ..., an]` where the length of the list is between 1 and 100,000. Output * The function should return a single integer, the first non-repeating element in the list. If no such element is found, return `None`. Example ```python print(first_non_repeating_element([2, 3, 4, 2, 3, 4, 5])) # Output: 5 print(first_non_repeating_element([1, 2, 1, 3, 2, 5])) # Output: 3 print(first_non_repeating_element([7, 8, 7, 10, 8, 11, 10])) # Output: 11 print(first_non_repeating_element([1, 1, 1, 1])) # Output: None ``` Constraints * Elements may include both positive and negative integers. * You must ensure that the function performs efficiently even for larger lists. Performance Requirements * The implementation should complete within a reasonable time frame for the upper limit value of list length (10^5). Context A non-repeating element is an element in the list that appears exactly once. Your task is to efficiently identify and return the first such element that appears when traversing the list from left to right. If no element appears only once, the function should return `None`.","solution":"from typing import List, Union def first_non_repeating_element(elements: List[int]) -> Union[int, None]: Returns the first non-repeating element in the list. :param elements: A list of integers where 1 <= len(elements) <= 10^5. :return: The first non-repeating element or None if all elements repeat. element_count = {} # First pass: count the occurrence of each element for element in elements: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 # Second pass: find the first element with a count of 1 for element in elements: if element_count[element] == 1: return element # If no non-repeating element is found return None"},{"question":"# Coding Assessment Question You are developing a simple content-based recommendation system for a book library. Implement a `ContentBasedRecommender` class that recommends books based on their descriptions using cosine similarity. **Requirements**: 1. Implement the `ContentBasedRecommender` class constructor to initialize the book descriptions and titles. 2. Implement the `_cosine_similarity` method to calculate the cosine similarity between two vectors. 3. Implement the `recommend` method: - Recommend the top N books based on the similarity of their descriptions to a given input description. - If N exceeds the number of available books, return all books sorted by similarity score. **Function Signatures**: ```python from typing import List, Tuple class ContentBasedRecommender: def __init__(self, descriptions: List[str], titles: List[str]) -> None: Init method to store book descriptions and titles. @staticmethod def _cosine_similarity(a: List[float], b: List[float]) -> float: Compute the cosine similarity between two vectors. def recommend(self, input_description: str, N: int = 5) -> List[Tuple[str, float]]: Recommend the top N books based on the input description. ``` **Input**: * **descriptions**: A list of strings, where each string represents the description of a book. * **titles**: A list of strings, where each string represents the title of a book. * **input_description**: A string representing the description of a book to compare against the library. * **N**: An integer representing the number of top recommendations to return (default is 5). **Output**: * **recommend**: Returns a list of tuples where each tuple contains a book title and its cosine similarity score to the `input_description`, sorted by similarity from highest to lowest. **Example**: ```python descriptions = [ \\"This is a science fiction book with adventures and space travel.\\", \\"A historical novel set in medieval times with knights and epic battles.\\", \\"A thrilling mystery novel with unexpected twists and a gripping plot.\\", \\"An educational book on programming in Python with practical examples.\\", \\"A romance novel with heartwarming and emotional storylines.\\" ] titles = [ \\"Galactic Adventures\\", \\"Medieval Epics\\", \\"Mystery Unveiled\\", \\"Learn Python\\", \\"Heartfelt Stories\\" ] recommender = ContentBasedRecommender(descriptions, titles) input_desc = \\"A book on programming tips and Python examples.\\" print(recommender.recommend(input_desc, N=3)) # Output: [(\'Learn Python\', similarity_score), ...] ``` **Constraints**: * The number of books (length of `descriptions` and `titles`) can be up to (10^3). * The descriptions and input descriptions may contain up to 500 words. * N is a positive integer within (1) to (10^3). # Note To compute cosine similarity between text descriptions, consider using TF-IDF vectors or other suitable vector representations.","solution":"from typing import List, Tuple from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.metrics.pairwise import cosine_similarity import numpy as np class ContentBasedRecommender: def __init__(self, descriptions: List[str], titles: List[str]) -> None: Init method to store book descriptions and titles. self.descriptions = descriptions self.titles = titles self.vectorizer = TfidfVectorizer() self.tfidf_matrix = self.vectorizer.fit_transform(self.descriptions) @staticmethod def _cosine_similarity(a: np.ndarray, b: np.ndarray) -> float: Compute the cosine similarity between two vectors. dot_product = np.dot(a, b) norm_a = np.linalg.norm(a) norm_b = np.linalg.norm(b) return dot_product / (norm_a * norm_b) def recommend(self, input_description: str, N: int = 5) -> List[Tuple[str, float]]: Recommend the top N books based on the input description. input_vec = self.vectorizer.transform([input_description]) similarities = cosine_similarity(input_vec, self.tfidf_matrix).flatten() indices = similarities.argsort()[-N:][::-1] recommendations = [(self.titles[idx], similarities[idx]) for idx in indices] return recommendations"},{"question":"# Scenario An e-commerce platform wants to offer discount prices and calculate totals for orders placed by customers. The discount rules can be configured for different product categories. # Task 1. **Function Requirement: `calculate_discount`** - **Purpose**: Create a function to calculate the discount on a product based on its category and price. - **Input**: - `category: str`: The category of the product (e.g., \'electronics\', \'clothing\', \'books\'). - `price: float`: The original price of the product. - **Output**: - Returns the discounted price as a float. 2. **Function Requirement: `calculate_order_total`** - **Purpose**: Create a function to calculate the total price for an order, including discounts and an optional shipping fee. - **Input**: - `products: list`: A list of tuples, each containing the product category (str) and the original price (float). - `shipping_fee: float`: (default 0.0) The shipping fee for the order. - **Output**: - Returns the total price for the order after applying discounts and adding the shipping fee. # Constraints: - The discount rates are as follows: - \'electronics\': 10% - \'clothing\': 20% - \'books\': 5% - All other categories: 0% - Ensure the discounted price and total price are rounded to two decimal places. - Handle edge cases like empty product lists and invalid categories gracefully. - Must raise custom exceptions with meaningful messages for critical errors, such as invalid price values (negative or zero). # Example ```python # Example Usage # 1. Calculate discounted price discounted_price = calculate_discount(\'electronics\', 100.00) print(discounted_price) # Expected output: 90.00 # 2. Calculate order total order_total = calculate_order_total([ (\'electronics\', 100.00), (\'clothing\', 50.00), (\'books\', 20.00) ], shipping_fee=10.00) print(order_total) # Expected output: 150.00 ``` This new question aligns with the existing set by focusing on practical programming tasks pertinent to real-world scenarios. It maintains the complexity and scope, requiring both individual computations and aggregated results.","solution":"class InvalidPriceError(Exception): Custom exception for invalid price values. pass def calculate_discount(category, price): Returns the discounted price based on the category and original price. if price <= 0: raise InvalidPriceError(\\"Invalid price value. Price must be greater than zero.\\") discounts = { \'electronics\': 0.10, \'clothing\': 0.20, \'books\': 0.05 } discount_rate = discounts.get(category, 0) discounted_price = price * (1 - discount_rate) return round(discounted_price, 2) def calculate_order_total(products, shipping_fee=0.0): Returns the total price for an order after applying discounts and adding the shipping fee. if any(price <= 0 for category, price in products): raise InvalidPriceError(\\"Invalid price value. All prices must be greater than zero.\\") total = 0.0 for category, price in products: total += calculate_discount(category, price) total += shipping_fee return round(total, 2)"},{"question":"# Coding Assessment Question: Background The Fibonacci sequence is a series of numbers where the next number in the sequence is the sum of the previous two numbers. The sequence starts as follows: 0, 1, 1, 2, 3, 5, 8, ... A common problem is to find the nth number in the Fibonacci sequence. However, we are interested in finding the index of the first Fibonacci number that contains a specific number of digits. Task Implement a function `find_fibonacci_index_by_length(d)` that meets the following requirements: - **Input**: A single integer `d` (1 ≤ d ≤ 1000). - **Output**: Return the index of the first Fibonacci number that contains exactly `d` digits. - **Constraints**: If the input is not a positive integer or exceeds the limit, raise an appropriate error. - **Performance**: Optimize your implementation to handle large values of `d` efficiently. Function Signature ```python def find_fibonacci_index_by_length(d: int) -> int: pass ``` Examples ```python assert find_fibonacci_index_by_length(2) == 7 assert find_fibonacci_index_by_length(3) == 12 assert find_fibonacci_index_by_length(1) == 1 ``` Additional Notes - Assume `d` is a positive integer within the given constraints. - Raise a `ValueError` for invalid input values and a `TypeError` for non-integer inputs. **Hint**: - You might find it useful to use an iterative approach to generate Fibonacci numbers until the desired length is found. - Keep track of the length of the numbers to efficiently find the first one with the desired digit length.","solution":"def find_fibonacci_index_by_length(d: int) -> int: Find the index of the first Fibonacci number that contains exactly d digits. Parameters: d (int): The number of digits to find in a Fibonacci number. Returns: int: The index of the first Fibonacci number with at least d digits. Raises: ValueError: If d is not a positive integer or exceeds the limit. if not isinstance(d, int): raise TypeError(\\"Input must be an integer\\") if d < 1 or d > 1000: raise ValueError(\\"Input must be between 1 and 1000 inclusive\\") a, b = 0, 1 index = 1 while len(str(b)) < d: a, b = b, a + b index += 1 return index"},{"question":"# Fibonacci Sequence Implementation Challenge Objective You are tasked to implement a function to compute Fibonacci numbers using both iterative and recursive approaches. Scenario Consider a program that needs to compute the Fibonacci sequence for a series of integers as part of its calculations. The Fibonacci function must be reliable and handle edge cases appropriately. Function Specifications: * **Function Name**: `fibonacci_iterative` * **Input**: An integer `n` (0 ≤ n ≤ 100) * **Output**: Returns the `n`th Fibonacci number. * **Constraints**: - The function should raise a `ValueError` with the message \\"fibonacci() not defined for negative values\\" if `n` is negative. - The function should raise a `ValueError` with the message \\"fibonacci() only accepts integral values\\" if `n` is not an integer. * **Performance Requirements**: Use an iterative approach that utilizes less than O(n) auxiliary space. * **Function Name**: `fibonacci_recursive` * **Input**: An integer `n` (0 ≤ n ≤ 100) * **Output**: Returns the `n`th Fibonacci number. * **Constraints**: - Same as above with respect to `ValueError` raising. * **Performance Requirements**: Use a recursive approach. Example Usage ```python # Iterative implementation examples assert fibonacci_iterative(5) == 5 assert fibonacci_iterative(0) == 0 assert fibonacci_iterative(1) == 1 try: fibonacci_iterative(-1) except ValueError as e: assert str(e) == \\"fibonacci() not defined for negative values\\" try: fibonacci_iterative(1.5) except ValueError as e: assert str(e) == \\"fibonacci() only accepts integral values\\" # Recursive implementation examples assert fibonacci_recursive(5) == 5 assert fibonacci_recursive(0) == 0 assert fibonacci_recursive(1) == 1 try: fibonacci_recursive(-1) except ValueError as e: assert str(e) == \\"fibonacci() not defined for negative values\\" try: fibonacci_recursive(1.5) except ValueError as e: assert str(e) == \\"fibonacci() only accepts integral values\\" ```","solution":"def fibonacci_iterative(n): if not isinstance(n, int): raise ValueError(\\"fibonacci() only accepts integral values\\") if n < 0: raise ValueError(\\"fibonacci() not defined for negative values\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b def fibonacci_recursive(n): if not isinstance(n, int): raise ValueError(\\"fibonacci() only accepts integral values\\") if n < 0: raise ValueError(\\"fibonacci() not defined for negative values\\") if n == 0: return 0 elif n == 1: return 1 return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)"},{"question":"# Simple Text Editor Objective: Implement a simple text editor with the following functionalities: append some text, delete some text, and undo the last edit. The function should simulate the operations and return the final content of the text editor after performing all operations. Function Signature: ```python def simple_text_editor(operations: list[tuple]) -> str: ``` Input: - `operations`: A list of tuples where each tuple contains an operation to be performed. The operations can be: - `(\\"append\\", string_to_append)`: Append `string_to_append` to the current content. - `(\\"delete\\", k)`: Delete the last `k` characters from the current content. - `(\\"undo\\",)`: Undo the last operation (either \\"append\\" or \\"delete\\"). Output: - A string representing the final content of the text editor after all operations have been performed. Constraints: - The length of the content (`S`) can range from `0` to `10^6`. - Each `string_to_append` is a non-empty string with at most `10^6` characters. - The value of `k` for the delete operation will be a positive integer such that `k` does not exceed the current length of the content. - The number of operations will not exceed `10^5`. Example: ```python operations = [ (\\"append\\", \\"abc\\"), (\\"append\\", \\"def\\"), (\\"delete\\", 3), (\\"undo\\",), (\\"undo\\",) ] assert simple_text_editor(operations) == \\"abc\\" ``` Details: - You need to maintain a history of operations for the undo functionality. - Optimize the implementation to handle up to 10^5 operations efficiently. - Consider edge cases like multiple consecutive undo operations or an empty initial content. Implement the function and test it against the provided example and additional cases to ensure its correctness and efficiency.","solution":"def simple_text_editor(operations: list[tuple]) -> str: content = [] history = [] for operation in operations: if operation[0] == \\"append\\": history.append((\'deleted\', len(operation[1]))) content.append(operation[1]) elif operation[0] == \\"delete\\": k = operation[1] deleted_text = content[-1][-k:] history.append((\'appended\', deleted_text)) content[-1] = content[-1][:-k] elif operation[0] == \\"undo\\": last_op = history.pop() if last_op[0] == \\"appended\\": content[-1] += last_op[1] elif last_op[0] == \\"deleted\\": content[-1] = content[-1][:-last_op[1]] return \'\'.join(content)"},{"question":"# Matching Word Pairs You are developing a component of a word game that checks if two words are anagrams of each other. Two words are considered anagrams if they contain the same characters in the same frequencies but may be arranged differently. Task Implement a function `are_anagrams` to determine if two given words are anagrams of each other. Function Signature ```python def are_anagrams(word1: str, word2: str) -> bool: ``` Input - `word1` (string): The first word. - `word2` (string): The second word. Output - Returns a boolean value `True` if `word1` and `word2` are anagrams, otherwise `False`. Constraints - The length of `word1` and `word2` will not exceed 1000. - All characters in `word1` and `word2` are lowercase English letters. Example ```python assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"triangle\\", \\"integral\\") == True assert are_anagrams(\\"apple\\", \\"pale\\") == False ``` Explanation of Example - For `are_anagrams(\\"listen\\", \\"silent\\") == True`: * Both words use the same characters: \'l\', \'i\', \'s\', \'t\', \'e\', \'n\'. - For `are_anagrams(\\"triangle\\", \\"integral\\") == True`: * Both words use the same characters: \'t\', \'r\', \'i\', \'a\', \'n\', \'g\', \'l\', \'e\'. - For `are_anagrams(\\"apple\\", \\"pale\\") == False`: * \'apple\' has characters \'a\', \'p\', \'p\', \'l\', \'e\' while \'pale\' has \'p\', \'a\', \'l\', \'e\'; \'pale\' lacks an extra \'p\'. Performance Requirements - Aim to achieve a time complexity of (O(n)), where (n) is the maximum length of `word1` or `word2`. - Use a data structure that allows for efficient comparison of character frequencies.","solution":"def are_anagrams(word1: str, word2: str) -> bool: Returns True if word1 and word2 are anagrams, otherwise False. # If lengths of the words are different, they cannot be anagrams if len(word1) != len(word2): return False # Create dictionaries to count the frequency of each character from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"New Question Suggestion You are implementing a simplified ride-sharing application where drivers have a list of pending ride requests sorted by their arrival times. Each request is represented by a tuple containing the driver\'s ID, the pickup time of the ride (in HH:MM), and the drop-off time (in HH:MM). Your task is to assign rides to the drivers based on availability and without overlapping any of the rides. **Task**: 1. **Parse Input**: Implement functionality to parse a list of ride requests and sort them based on their pickup times. 2. **Schedule Rides**: For each driver, maintain a schedule and assign rides such that no rides overlap for any driver. 3. **Output Results**: Ensure the resulting schedule for each driver is saved in a file where each line represents a ride request assigned to that driver in the format: `DriverID PickupTime DropoffTime`. **Constraints**: * Each ride request assures the pickup time is always earlier than the drop-off time. * Input format assures all times are given in 24-hour format as HH:MM. * No two requests for the same driver will have the same pickup time. **Function Specifications**: ```python def parse_ride_requests(ride_requests: list) -> dict: - ride_requests <type: list>: List of ride request tuples (DriverID, PickupTime, DropoffTime) Returns <type: dict>: - Dictionary where keys are driver IDs and values are lists of ride request tuples sorted by PickupTime def assign_rides(parsed_requests: dict) -> dict: - parsed_requests <type: dict>: Dictionary with driver IDs as keys and sorted list of ride requests as values Returns <type: dict>: - Dictionary where keys are driver IDs and values are lists of non-overlapping ride assignments def save_schedule(schedule: dict, output_dir: str) -> None: - schedule <type: dict>: Dictionary with driver IDs as keys and list of assigned ride tuples (PickupTime, DropoffTime) as values - output_dir <type: str>: Directory to save the schedule files for each driver def main() -> None: - Parse the list of ride requests - Schedule rides for each driver to ensure no overlaps - Save the schedule in the specified output directory if __name__ == \\"__main__\\": main() ``` **Input Format**: * A list of ride request tuples where each tuple is in the format `(DriverID, PickupTime, DropoffTime)`. * Output directory path. **Output Format**: * Schedule files are saved in the specified output directory, one file per driver. Each file contains the assigned ride requests in the format `PickupTime DropoffTime` on each line. # Example Input ```python ride_requests = [ (\'D1\', \'08:00\', \'09:00\'), (\'D2\', \'08:30\', \'09:30\'), (\'D1\', \'09:30\', \'10:30\'), (\'D2\', \'10:00\', \'11:00\'), (\'D1\', \'10:00\', \'11:00\') ] output_dir = \'output_schedule\' ``` # Example Output Files saved to the `output_schedule` directory: `D1.txt` ``` 08:00 09:00 09:30 10:30 ``` `D2.txt` ``` 08:30 09:30 10:00 11:00 ```","solution":"from collections import defaultdict from typing import List, Tuple, Dict import os def parse_ride_requests(ride_requests: List[Tuple[str, str, str]]) -> Dict[str, List[Tuple[str, str]]]: Parse and sort the list of ride requests by pickup time for each driver. - ride_requests <type: list>: List of ride request tuples (DriverID, PickupTime, DropoffTime). Returns <type: dict>: Dictionary where keys are driver IDs and values are lists of ride request tuples sorted by PickupTime. request_dict = defaultdict(list) for req in ride_requests: driver_id, pickup_time, dropoff_time = req request_dict[driver_id].append((pickup_time, dropoff_time)) for driver_id in request_dict: request_dict[driver_id].sort(key=lambda x: x[0]) # Sort by pickup time return request_dict def assign_rides(parsed_requests: Dict[str, List[Tuple[str, str]]]) -> Dict[str, List[Tuple[str, str]]]: Assign rides to ensure no overlap for each driver. - parsed_requests <type: dict>: Dictionary with driver IDs as keys and sorted list of ride requests as values. Returns <type: dict>: Dictionary where keys are driver IDs and values are lists of non-overlapping ride assignments. assigned_rides = {} for driver_id, rides in parsed_requests.items(): scheduled = [] last_dropoff = \\"\\" for ride in rides: pickup_time, dropoff_time = ride if not scheduled or pickup_time >= last_dropoff: scheduled.append(ride) last_dropoff = dropoff_time assigned_rides[driver_id] = scheduled return assigned_rides def save_schedule(schedule: Dict[str, List[Tuple[str, str]]], output_dir: str) -> None: Save the schedule in the specified output directory. - schedule <type: dict>: Dictionary with driver IDs as keys and list of assigned ride tuples (PickupTime, DropoffTime) as values. - output_dir <type: str>: Directory to save the schedule files for each driver. if not os.path.exists(output_dir): os.makedirs(output_dir) for driver_id, rides in schedule.items(): with open(os.path.join(output_dir, f\\"{driver_id}.txt\\"), \'w\') as f: for pickup_time, dropoff_time in rides: f.write(f\\"{pickup_time} {dropoff_time}n\\") def main(): ride_requests = [ (\'D1\', \'08:00\', \'09:00\'), (\'D2\', \'08:30\', \'09:30\'), (\'D1\', \'09:30\', \'10:30\'), (\'D2\', \'10:00\', \'11:00\'), (\'D1\', \'10:00\', \'11:00\') ] output_dir = \'output_schedule\' parsed_requests = parse_ride_requests(ride_requests) assigned_rides = assign_rides(parsed_requests) save_schedule(assigned_rides, output_dir) if __name__ == \\"__main__\\": main()"},{"question":"# Problem Statement Create a function that generates all valid combinations of `k` numbers out of the range `[1, n]` (both inclusive). Each combination must be returned as a list of integers. The combinations should be lexicographically sorted in ascending order. # Function Signature ```python def combine(n: int, k: int) -> list[list[int]]: ``` # Input 1. `n` (int): An integer representing the upper limit of the range (1 ≤ n ≤ 20). 2. `k` (int): An integer representing the number of elements to combine (1 ≤ k ≤ n). # Output * `list[list[int]]`: A list of lists, each containing a valid combination of `k` numbers out of the range `[1, n]`. # Constraints * The function should be efficient in terms of both time and space complexity. * The order of the combinations in the output list must be sorted lexicographically. # Example ```python assert combine(4, 2) == [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]] assert combine(5, 3) == [[1, 2, 3], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3, 5], [1, 4, 5], [2, 3, 4], [2, 3, 5], [2, 4, 5], [3, 4, 5]] assert combine(1, 1) == [[1]] ``` Consider the combination selection process and ensure that an appropriate algorithm (like backtracking) is employed to generate the combinations efficiently. # Hints * Use a recursive backtracking approach to explore all the valid combinations. * Ensure that elements in each combination are ordered in ascending order to guarantee lexicographic sorting. * Think about how to curtail the recursion early when generating combinations to avoid unnecessary calculations.","solution":"def combine(n: int, k: int) -> list[list[int]]: def backtrack(start, path): # If the combination is complete if len(path) == k: result.append(path[:]) return # Explore further combinations for i in range(start, n + 1): path.append(i) backtrack(i + 1, path) path.pop() result = [] backtrack(1, []) return result"},{"question":"# Problem Statement You are required to implement two utility functions: `bin_encode` and `bin_decode`. These functions will perform encoding of bytes data into binary (base2) format and decoding of such binary strings back into bytes data correspondingly. **Function 1: `bin_encode`** - **Input**: A `bytes` object `data`. - **Output**: A `str` object representing the corresponding binary (base2) encoding of the input data. - **Constraints**: - The output binary string must group bits in 8-bit chunks, separated by spaces. - The input `data` can be an empty byte string. **Function 2: `bin_decode`** - **Input**: A `str` object `data` representing binary (base2) encoded data. - **Output**: A `bytes` object which is the decoded representation of the input data. - **Constraints**: - The input `data` must consist of 8-bit chunks of binary digits (i.e., groups of 8 bits separated by spaces). - If the input data is invalid, the function should raise a `ValueError` with a descriptive message. # Example ```python def bin_encode(data: bytes) -> str: \'\'\' This function encodes the input bytes into a binary encoding string in 8-bit chunks separated by spaces. \'\'\' pass # TODO: Write the implementation here def bin_decode(data: str) -> bytes: \'\'\' This function decodes the input binary encoded string back into bytes. \'\'\' pass # TODO: Write the implementation here # Test Cases assert bin_encode(b\'Hello World!\') == \'01001000 01100101 01101100 01101100 01101111 00100000 01010111 01101111 01110010 01101100 01100100 00100001\' assert bin_encode(b\'HELLO WORLD!\') == \'01001000 01000101 01001100 01001100 01001111 00100000 01010111 01001111 01010010 01001100 01000100 00100001\' assert bin_encode(b\'\') == \'\' assert bin_decode(\'01001000 01100101 01101100 01101100 01101111 00100000 01010111 01101111 01110010 01101100 01100100 00100001\') == b\'Hello World!\' assert bin_decode(\'01001000 01000101 01001100 01001100 01001111 00100000 01010111 01001111 01010010 01001100 01000100 00100001\') == b\'HELLO WORLD!\' assert bin_decode(\'\') == b\'\' try: bin_decode(\'01001000 01100101 01101100 1\') except ValueError as e: assert str(e) == \'Binary encoded data is invalid: Each byte must consist of exactly 8 bits.\' try: bin_decode(\'01001000 01100101 01101100 01101100 2\') except ValueError as e: assert str(e) == \'Binary encoded data is invalid: Data contains characters other than 0 and 1.\' try: bin_decode(\'This is not binary data.\') except ValueError as e: assert str(e) == \'Binary encoded data is invalid: Data contains characters other than 0 and 1 or spaces.\' ``` **Additional Note**: - Ensure your code handles edge cases and invalid inputs appropriately, raising exceptions with meaningful messages. - The implementation should be efficient and correctly handle very large input data within the constraints.","solution":"def bin_encode(data: bytes) -> str: \'\'\' This function encodes the input bytes into a binary encoding string in 8-bit chunks separated by spaces. \'\'\' return \' \'.join(f\'{byte:08b}\' for byte in data) def bin_decode(data: str) -> bytes: \'\'\' This function decodes the input binary encoded string back into bytes. \'\'\' # Check if the input string is correctly formatted if not all(part.isdigit() and len(part) == 8 and set(part).issubset({\'0\', \'1\'}) for part in data.split()): raise ValueError(\'Binary encoded data is invalid: Each byte must consist of exactly 8 bits and contain only 0s and 1s.\') # Convert each 8-bit chunk of binary to the corresponding byte byte_list = [int(byte, 2) for byte in data.split()] return bytes(byte_list)"},{"question":"# Captcha Code Verification You are tasked to create a simple validation system for an online form. The form captures a piece of text and a captcha code, generated as a random mix of 5 alphanumeric characters. You need to implement a function to verify if the entered captcha matches the generated captcha. # Problem Statement Create a function that verifies if the entered captcha code matches the generated captcha code. Function Signature ```python def verify_captcha(generated_captcha, entered_captcha): # your code here ``` Input - `generated_captcha:` the captcha code generated by the system, represented as a string of 5 alphanumeric characters (both uppercase and lowercase are possible). - `entered_captcha:` the captcha code entered by the user, represented as a string. Output - Boolean value: `True` if the entered captcha matches the generated captcha exactly, otherwise `False`. # Examples ```python # Example 1 generated_captcha = \\"aB3kL\\" entered_captcha = \\"aB3kL\\" print(verify_captcha(generated_captcha, entered_captcha)) # Expected Output: True # Example 2 generated_captcha = \\"XyZ12\\" entered_captcha = \\"xyz12\\" print(verify_captcha(generated_captcha, entered_captcha)) # Expected Output: False # Example 3 generated_captcha = \\"G7d2Q\\" entered_captcha = \\"G7d2o\\" print(verify_captcha(generated_captcha, entered_captcha)) # Expected Output: False ``` # Requirements 1. Ensure that the function is case-sensitive (i.e., \'a\' != \'A\'). 2. Consider only exact matches as valid captcha entries. 3. Focus on handling simple comparison; it does not have to handle leading/trailing spaces as inputs are assumed to be properly formatted.","solution":"def verify_captcha(generated_captcha, entered_captcha): Verifies if the entered captcha matches the generated captcha. Parameters: generated_captcha (str): The captcha code generated by the system. entered_captcha (str): The captcha code entered by the user. Returns: bool: True if the entered captcha matches the generated captcha, otherwise False. return generated_captcha == entered_captcha"},{"question":"# Coding Challenge # Problem Statement You are given a string representation of a series of integers that form a sequence. Your task is to find and return the maximum length of a sequence of consecutive integers (i.e., any order of consecutive integer occurrence). # Input - A string containing space-separated integers. - Guarantee: The sequence will contain between 1 and 10,000 integers. # Output - An integer representing the maximum length of a consecutive integer sequence. # Example Input ``` 100 4 200 1 3 2 ``` Output ``` 4 ``` # Explanation For the given example, the longest sequence of consecutive integers is 1, 2, 3, 4. # Function Signature ```python def longest_consecutive_sequence(nums_str: str) -> int: pass ``` # Constraints - 1 ≤ length of the sequence ≤ 10,000 - All sequence values are integers between -10^6 and 10^6. # Scenario This problem tests your ability to handle large inputs efficiently and requires the use of data structures to track sequences and determine the maximum length of consecutive subsequences. Analyze the string input, convert it into a manageable format, and ensure your solution adheres to optimal performance requirements.","solution":"def longest_consecutive_sequence(nums_str: str) -> int: nums = list(map(int, nums_str.split())) nums_set = set(nums) max_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"# Coding Question: Merge Two Sorted Linked Lists **Scenario**: You are developing a feature for a financial application that requires merging stock price lists from two different sources. Each source delivers the stock prices as a sorted linked list. Your task is to merge these two sorted linked lists into one sorted linked list. **Problem Statement**: Implement a method `merge_sorted_lists` that merges two sorted singly linked lists into a single sorted linked list. # Requirements: - **Input**: - Two singly linked lists represented by their respective head nodes of type `Node`. - **Output**: - A head node of the resulting merged and sorted singly linked list. # Constraints: 1. Each node contains an integer and a reference to the next node. 2. The input lists are sorted in non-decreasing order. 3. The resulting list must also be sorted in non-decreasing order. 4. Optimize for time complexity. # Function Signature: ```python class Node: def merge_sorted_lists(self, list1, list2): pass ``` # Implementation Details: Your implementation should handle various cases robustly, including: - Both input lists are empty. - One input list is empty. - Both input lists are non-empty but of different lengths. # Examples: 1. **Example 1**: ```python list1 = Node(1) list1.next_node = Node(3) list1.next_node.next_node = Node(5) list2 = Node(2) list2.next_node = Node(4) list2.next_node.next_node = Node(6) merged_list = Node() result = merged_list.merge_sorted_lists(list1, list2) # The resulting sorted list should be: 1 -> 2 -> 3 -> 4 -> 5 -> 6 ``` 2. **Example 2**: ```python list1 = Node(2) list1.next_node = Node(4) list2 = Node(1) list2.next_node = Node(3) list2.next_node.next_node = Node(5) merged_list = Node() result = merged_list.merge_sorted_lists(list1, list2) # The resulting sorted list should be: 1 -> 2 -> 3 -> 4 -> 5 ``` **Note**: Consider implementing this function iteratively for simplicity and manageable space complexity.","solution":"class Node: def __init__(self, data=0, next_node=None): self.data = data self.next_node = next_node def merge_sorted_lists(self, list1, list2): # Dummy node to serve as the starting point of the merged list dummy = Node() current = dummy while list1 and list2: if list1.data < list2.data: current.next_node = list1 list1 = list1.next_node else: current.next_node = list2 list2 = list2.next_node current = current.next_node if list1: current.next_node = list1 if list2: current.next_node = list2 return dummy.next_node # Helper function to convert linked list to a python list for easy comparison in tests def linked_list_to_list(head: Node): result = [] current = head while current: result.append(current.data) current = current.next_node return result"},{"question":"# Coding Assessment Question: Longest Increasing Path in a Matrix Problem Statement You are given a 2D matrix of integers and are tasked with finding the length of the longest increasing path in the matrix. From each cell, you can move in one of four directions: left, right, up, or down. You may not move diagonally or move outside the boundary of the matrix, and you can only move to a cell with a strictly greater value than the current one. Write a class `MatrixPathFinder` that includes the following methods: 1. `__init__()`: Initialization method. 2. `longest_increasing_path(self, matrix: List[List[int]]) -> int`: This method calculates the length of the longest increasing path in the given matrix. Requirements: - **Input Format**: - `matrix`: A 2D list of integers (`List[List[int]]`). - **Output Format**: - An integer representing the length of the longest increasing path (`int`). Constraints: - The matrix dimensions are `m x n` where `1 <= m, n <= 200`. - The values in the matrix are between `-2^31` and `2^31 - 1`. # Scenario Consider the following example to ensure clarity of the problem: You are given the following matrix: ``` [ [9, 9, 4], [6, 6, 8], [2, 1, 1] ] ``` Your function should return `4` for the longest increasing path, which is `[1, 2, 6, 9]`. # Example Use Case ```python from typing import List class MatrixPathFinder: def __init__(self): pass def longest_increasing_path(self, matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) memo = [[0] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x: int, y: int) -> int: if memo[x][y] != 0: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) memo[x][y] = max_length return max_length return max(dfs(x, y) for x in range(m) for y in range(n)) ``` Explanation - We initialize a memo table to cache the results of each cell\'s longest path to optimize for repeated calculations. - The `dfs` function performs a depth-first search to compute the longest path starting from a particular cell, checking all four possible directions. - The main function iterates through each cell and computes the longest path using the `dfs` function. This solution ensures that performance concerns are optimized by employing memoization and a helper function to avoid redundant computations.","solution":"from typing import List class MatrixPathFinder: def __init__(self): pass def longest_increasing_path(self, matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) memo = [[0] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x: int, y: int) -> int: if memo[x][y] != 0: return memo[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and matrix[nx][ny] > matrix[x][y]: length = 1 + dfs(nx, ny) max_length = max(max_length, length) memo[x][y] = max_length return max_length return max(dfs(x, y) for x in range(m) for y in range(n))"},{"question":"# AVL Tree Implementation and Enhancement As a programming task, you need to implement and enhance an AVL Tree data structure to handle integer keys. An AVL Tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. 1. **Insertion with Balancing**: Implement the insertion method that ensures the AVL Tree remains balanced after each insertion. This involves updating the height and performing rotations (left, right, left-right, right-left) as needed to maintain the AVL property. 2. **Deletion with Balancing**: Implement the deletion method that handles removing a node while maintaining the AVL Tree property. Ensure the tree rebalances itself after each deletion. 3. **Tree Height Calculation**: Provide a method to calculate the height of the AVL Tree at any given point. # Input and Output Format * Implement three distinct methods in the AVLTree class: * `insert_node(key: int) -> None`: Handles inserting a new key while maintaining the AVL balance. * `delete_node(key: int) -> None`: Manages deletion of a node and rebalancing the tree. * `tree_height() -> int`: Calculates and returns the height of the AVL Tree. # Constraints * The functionality should support only integer keys. * The tree should be dynamically adjusted to maintain balance after each insertion and deletion. # Examples ```python # Example usage: avl = AVLTree() # Insert elements and maintain AVL property avl.insert_node(10) avl.insert_node(20) avl.insert_node(30) avl.insert_node(40) avl.insert_node(50) print(avl.tree_height()) # Should reflect a balanced height # Deletion with balancing avl.delete_node(20) print(avl.tree_height()) # Should reflect the AVLTree height after rebalancing # Maintain balance after multiple operations avl.insert_node(25) avl.delete_node(10) print(avl.tree_height()) # Should maintain AVL Tree property ``` Implement the AVLTree class with the methods described to meet the above requirements.","solution":"class AVLTree: class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 def __init__(self): self.root = None def insert_node(self, key): self.root = self._insert_node(self.root, key) def _insert_node(self, node, key): if not node: return self.Node(key) if key < node.key: node.left = self._insert_node(node.left, key) else: node.right = self._insert_node(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def delete_node(self, key): self.root = self._delete_node(self.root, key) def _delete_node(self, node, key): if not node: return node if key < node.key: node.left = self._delete_node(node.left, key) elif key > node.key: node.right = self._delete_node(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete_node(node.right, temp.key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._balance(node) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _balance(self, node): balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def tree_height(self): return self._get_height(self.root)"},{"question":"# Problem Statement You have been given a collection of n integers that may or may not be sorted. Your task is to find the kth smallest element in this collection efficiently. Implement a function `quickselect` that uses the Quickselect algorithm, an efficient selection algorithm to solve this problem in O(n) average time complexity. The Quickselect algorithm is related to the Quicksort sorting algorithm. Instead of fully sorting the array, it only partially sorts the array so that the kth smallest element is in its correct position and all elements smaller than it are to the left, while all elements greater than it are to the right. # Input: - A list of integers `data`, where `1 <= len(data) <= 10^6` - An integer `k`, where `1 <= k <= len(data)` # Output: - The kth smallest integer in the list. # Constraints: - The list contains integers and may contain duplicates. # Example: ```python # Example 1 data = [3, 2, 1, 5, 4] k = 2 print(quickselect(data, k)) # Output: 2 (The 2nd smallest element) # Example 2 data = [7, 10, 4, 3, 20, 15] k = 4 print(quickselect(data, k)) # Output: 10 (The 4th smallest element) ``` # Requirements: - Implement the Quickselect algorithm efficiently. - Ensure the solution works in O(n) average time complexity. - The solution should handle large inputs efficiently. - Avoid using additional space beyond the input and a few variables for the algorithm. # Notes: - The list may contain repeated elements; the kth smallest element is counted by value rather than uniqueness. - Ensure a robust testing across a variety of test cases, including edge cases.","solution":"import random def quickselect(data, k): Finds the kth smallest element in an unsorted list using the Quickselect algorithm. Parameters: data (list of int): The list of integers k (int): The kth position (1-based) smallest element to find Returns: int: The kth smallest element in the list def partition(left, right, pivot_index): pivot_value = data[pivot_index] # Move pivot to end data[pivot_index], data[right] = data[right], data[pivot_index] store_index = left for i in range(left, right): if data[i] < pivot_value: data[store_index], data[i] = data[i], data[store_index] store_index += 1 # Move pivot to its final place data[right], data[store_index] = data[store_index], data[right] return store_index def select(left, right, k_smallest): if left == right: # If the list contains only one element return data[left] # Select a random pivot_index pivot_index = random.randint(left, right) # Find the pivot position in a sorted list pivot_index = partition(left, right, pivot_index) # The pivot is in its final sorted position if k_smallest == pivot_index: return data[k_smallest] elif k_smallest < pivot_index: return select(left, pivot_index - 1, k_smallest) else: return select(pivot_index + 1, right, k_smallest) # k is 1-based index, so we convert it to 0-based by subtracting 1 return select(0, len(data) - 1, k - 1)"},{"question":"# Question: Linked List Cycle Detection and Removal You need to extend the `LinkedList` class with functionality to both detect if a cycle exists in the linked list and to remove the cycle if one is found. **Requirements**: - Implement a method `has_cycle` that returns `True` if a cycle exists in the linked list, otherwise `False`. - Implement a method `remove_cycle` which removes the cycle if it exists. # Function Signature ```python class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def has_cycle(self) -> bool: pass def remove_cycle(self) -> None: pass ``` # Input Format - No direct input. The sequence of operations is performed via the class methods. # Output Format - `has_cycle` should return a boolean indicating the presence of a cycle. - `remove_cycle` should modify the linked list by removing any existing cycle but returns nothing. # Constraints - Assume the linked list contains only integer values. - If there is no cycle, the `remove_cycle` method should not alter the list. - The solution should handle edge cases such as an empty list or a list with a single node. # Example ```python # Initializing nodes and forming a linked list with a cycle node1 = Node(1) node2 = Node(2) node3 = Node(3) node4 = Node(4) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node2 # Cycle here # Create a LinkedList and set its head ll = LinkedList() ll.head = node1 # Detect cycle print(ll.has_cycle()) # Output: True # Remove cycle ll.remove_cycle() # Verify cycle removal print(ll.has_cycle()) # Output: False ``` **Hint**: To detect a cycle, consider using Floyd’s Cycle-Finding Algorithm (the Tortoise and the Hare). To remove the cycle, once the cycle is detected, identify the cycle\'s entry point and break the link.","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def has_cycle(self) -> bool: Detects if a cycle exists in the linked list using Floyd’s Cycle-Finding Algorithm. Returns True if a cycle is found, otherwise False. slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def remove_cycle(self) -> None: Removes the cycle in the linked list if one exists. Modifies the linked list in place and returns nothing. if self.head is None: return slow = self.head fast = self.head # Detect if a cycle exists using Floyd’s Cycle-Finding Algorithm. while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: # No cycle detected return # Find the start of the cycle slow = self.head while slow != fast: slow = slow.next fast = fast.next # To remove the cycle, find the last node in the cycle while fast.next != slow: fast = fast.next # Break the cycle fast.next = None"},{"question":"# Merge Sorted Lists **Scenario**: You are working as a software developer in a data-intensive environment where you often need to merge data from multiple sources. One common task is to combine sorted lists of integers into a single sorted list. To achieve this efficiently, you decide to implement a function that leverages the properties of the already sorted input lists. **Task**: Write a function `merge_sorted_lists` that merges multiple sorted lists of integers into one sorted list in ascending order. You should ensure your implementation is efficient, particularly for handling multiple lists with large numbers of elements. # Function Signature ```python def merge_sorted_lists(lists: list[list[int]]) -> list[int]: pass ``` # Input - `lists`: A list of `k` sorted lists of integers. Each sorted list may contain between `0` and `10^6` elements, and there can be up to `10^3` such lists. # Output - A single sorted list of integers containing all the elements from the `k` input lists. # Constraints 1. Each input list is independently sorted in ascending order. 2. The function should handle empty lists gracefully. 3. The total number of integers across all input lists can be very large (up to `10^6 * 10^3` elements in the worst case). # Example ```python print(merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]])) # Output: [1, 1, 2, 3, 4, 4, 5, 6] print(merge_sorted_lists([[], [], []])) # Output: [] print(merge_sorted_lists([[1], [2], [3]])) # Output: [1, 2, 3] ``` # Evaluation Criteria 1. **Accuracy**: The merged list should be correctly sorted in ascending order. 2. **Efficiency**: The solution should efficiently handle merging large numbers of elements from multiple lists. 3. **Robustness**: The code should handle various edge cases, including empty lists and lists with duplicate values. 4. **Clarity**: The implementation should be clear, well-documented, and maintainable. **Note**: For the purpose of this task, you can assume that Python\'s built-in libraries for handling sorted data structures are available for use, but it may be beneficial to also comment on possible improvements or optimizations.","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into one sorted list. Parameters: lists (List[List[int]]): A list of k sorted lists of integers. Returns: List[int]: A single sorted list containing all the elements from the k input lists. merged_list = [] heap = [] # Populate heap with the first element from each list along with the list index and element index for list_index, sorted_list in enumerate(lists): if sorted_list: heapq.heappush(heap, (sorted_list[0], list_index, 0)) # Extract the smallest element from the heap and add the next element from the same list to the heap while heap: value, list_index, element_index = heapq.heappop(heap) merged_list.append(value) # If there is another element in the same list, add it to the heap if element_index + 1 < len(lists[list_index]): next_value = lists[list_index][element_index + 1] heapq.heappush(heap, (next_value, list_index, element_index + 1)) return merged_list"},{"question":"# File Comparison Tool Your task is to create a script that compares the contents of two text files and identifies the differences line by line, reporting the output in a clear and structured format. # Requirements: 1. **Input**: Two strings representing the file paths of the two text files to be compared. 2. **Output**: A list of tuples, where each tuple contains the line number (1-based), the content of the line from the first file, and the content of the corresponding line from the second file. If a line exists in one file and not the other, the missing content should be represented as `None`. 3. **Function Implementation**: Write a function `compare_files(file1_path: str, file2_path: str) -> list[tuple[int, str, Optional[str]]]`. # Constraints: 1. Ensure the function handles different file lengths gracefully. 2. Handle large files efficiently, without consuming excessive memory. 3. Provide meaningful error messages for missing or unreadable files. # Example: ```python def compare_files(file1_path: str, file2_path: str) -> list[tuple[int, str, Optional[str]]]: # Your implementation # Test case differences = compare_files(\\"file1.txt\\", \\"file2.txt\\") for diff in differences: print(f\\"Line {diff[0]}: File1 -> \'{diff[1]}\' | File2 -> \'{diff[2]}\'\\") ``` # Scenario: Imagine you are working on a project where you need to track changes between two versions of a document or configuration file. Your task is to implement a tool that can quickly highlight the differences between these files, facilitating version control and collaborative work. # Notes: - Consider line-ending differences between operating systems (e.g., `n` vs `rn`). - Implement robust error handling for scenarios such as file not found or permission issues. - Optimize for performance to handle potentially large files without significant slowdown. - Support text files encoded in common formats such as UTF-8.","solution":"from typing import List, Tuple, Optional def compare_files(file1_path: str, file2_path: str) -> List[Tuple[int, str, Optional[str]]]: Compares two text files line by line and returns differences. Args: file1_path (str): Path to the first file. file2_path (str): Path to the second file. Returns: List[Tuple[int, str, Optional[str]]]: List containing tuples with line number, line content from the first file, and line content from the second file. differences = [] try: with open(file1_path, \'r\', encoding=\'utf-8\') as f1, open(file2_path, \'r\', encoding=\'utf-8\') as f2: file1_lines = f1.readlines() file2_lines = f2.readlines() longest_file_length = max(len(file1_lines), len(file2_lines)) for i in range(longest_file_length): file1_line = file1_lines[i].rstrip(\'n\') if i < len(file1_lines) else None file2_line = file2_lines[i].rstrip(\'n\') if i < len(file2_lines) else None if file1_line != file2_line: differences.append((i + 1, file1_line, file2_line)) except FileNotFoundError as e: raise FileNotFoundError(f\\"File not found: {e.filename}\\") except OSError as e: raise OSError(f\\"Error reading files: {e}\\") return differences"},{"question":"# Problem Statement **Task**: Write a function called `find_minimum_subarray` that finds the contiguous subarray within a one-dimensional numeric array that has the minimum sum. Core Functions Your `find_minimum_subarray` function should: - Iterate through the input array to determine the contiguous subarray which gives the minimum sum. - Handle both positive and negative numbers efficiently. - Return the minimum sum found in any possible subarray. Function Signature ```python def find_minimum_subarray(nums: Union[np.ndarray, List[float], Tuple[float, ...]]) -> float: Finds the contiguous subarray with the minimum sum. Parameters: nums (np.ndarray, list, or tuple): Input array of real values. Returns: float: Minimum sum found in any possible contiguous subarray. ``` Inputs - **nums**: An array-like structure (`np.ndarray`, list, or tuple) containing real numbers. The array will have at least one element. Output - A `float` representing the minimum sum of any contiguous subarray within the given array. Constraints - The input array length can be large, so consider efficient algorithms for the solution. - Enforce the solution’s complexity remains O(n) for time and O(1) for space. # Example ```python >>> find_minimum_subarray([1, -3, 2, 1, -4]) -4 >>> find_minimum_subarray([2, -1, 2, 3, -4, 5]) -4 ``` # Note Employ the Kadane\'s algorithm variation for finding the minimum sum subarray to ensure optimal performance. ___","solution":"from typing import Union, List, Tuple import numpy as np def find_minimum_subarray(nums: Union[np.ndarray, List[float], Tuple[float, ...]]) -> float: Finds the contiguous subarray with the minimum sum. Parameters: nums (np.ndarray, list, or tuple): Input array of real values. Returns: float: Minimum sum found in any possible contiguous subarray. if not nums: raise ValueError(\\"Input array must contain at least one element.\\") min_sum = float(\'inf\') current_sum = 0 for num in nums: if current_sum > 0: current_sum = num else: current_sum += num min_sum = min(min_sum, current_sum) return min_sum"},{"question":"# Coding Assessment Question Context In many scenarios, such as computing moving averages or finding specific entries in sorted arrays, efficient algorithms for windowed computations are essential. One such problem is finding the maximum value in a sliding window across an array. Task Implement the `max_sliding_window` function that finds the maximum value in each sliding window of size `k` across a given list of integers. The function should handle edge cases appropriately by raising errors for invalid inputs. Function Signature ```python def max_sliding_window(nums: list[int], k: int) -> list[int]: Finds the maximum value in each sliding window of size k across an array. @param nums: a list of integers. @param k: the size of the sliding window. @return: a list of the maximum values from each sliding window. If the window size k is invalid, raise a ValueError. ``` Input and Output - **Input**: - `nums`: A list of integers which could be positive or negative. - `k`: An integer representing the size of the sliding window. - **Output**: A list of integers which are the maximum values in each sliding window of size `k`. Constraints - The input list `nums` should not be empty. - The window size `k` should be a positive integer and should not be larger than the length of the list `nums`. Performance - The function should aim for an optimized solution with respect to time and space complexity, ideally O(n) with n being the length of the list `nums`. Example Use Cases ```python print(max_sliding_window([1,3,-1,-3,5,3,6,7], 3)) # Output: [3,3,5,5,6,7] print(max_sliding_window([9,11], 2)) # Output: [11] print(max_sliding_window([4,3,2,1], 1)) # Output: [4,3,2,1] print(max_sliding_window([1,2,3,4,5], 2)) # Output: [2,3,4,5] ``` Error Handling - If `nums` is empty, raise a `ValueError` with the message \\"Input list must not be empty\\". - If `k` is not a positive integer, raise a `ValueError` with the message \\"Window size must be a positive integer\\". - If `k` is greater than the length of `nums`, raise a `ValueError` with the message \\"Window size must not exceed the length of the input list\\".","solution":"from collections import deque def max_sliding_window(nums: list[int], k: int) -> list[int]: Finds the maximum value in each sliding window of size k across an array. @param nums: a list of integers. @param k: the size of the sliding window. @return: a list of the maximum values from each sliding window. If the window size k is invalid, raise a ValueError. if not nums: raise ValueError(\\"Input list must not be empty\\") if k <= 0: raise ValueError(\\"Window size must be a positive integer\\") if k > len(nums): raise ValueError(\\"Window size must not exceed the length of the input list\\") deq = deque() max_values = [] for i, num in enumerate(nums): while deq and deq[0] <= i - k: deq.popleft() while deq and nums[deq[-1]] < num: deq.pop() deq.append(i) if i >= k - 1: max_values.append(nums[deq[0]]) return max_values"},{"question":"# Sorting a List of Dictionaries by a Specific Key You are asked to implement a function that sorts a list of dictionaries based on the values of a specific key. Each dictionary in the list represents a student, with keys \'name\' and \'age\'. Your function should return a list of dictionaries sorted by the \'age\' key in ascending order. # Input - A list of dictionaries, where each dictionary contains \'name\' (a string) and \'age\' (an integer). # Output - A list of dictionaries sorted by the \'age\' key in ascending order. # Constraints - The list contains at least one dictionary. - Each dictionary will have the \'name\' key with string values and the \'age\' key with integer values. - Dictionary keys \'name\' and \'age\' will always be present in each dictionary. # Example ```python def sort_students_by_age(students: list) -> list: Sorts a list of student dictionaries by age :param students: List[Dict[str, Union[str, int]]] :return: List[Dict[str, Union[str, int]]] >>> sort_students_by_age([{\'name\': \'Alice\', \'age\': 25}, {\'name\': \'Bob\', \'age\': 20}, {\'name\': \'Charlie\', \'age\': 23}]) [{\'name\': \'Bob\', \'age\': 20}, {\'name\': \'Charlie\', \'age\': 23}, {\'name\': \'Alice\', \'age\': 25}] >>> sort_students_by_age([{\'name\': \'David\', \'age\': 22}]) [{\'name\': \'David\', \'age\': 22}] return sorted(students, key=lambda student: student[\'age\']) if __name__ == \\"__main__\\": students_list = [{\'name\': \'Alice\', \'age\': 25}, {\'name\': \'Bob\', \'age\': 20}, {\'name\': \'Charlie\', \'age\': 23}] print(sort_students_by_age(students_list)) ``` # Task: Implement the `sort_students_by_age` function that sorts and returns the list of student dictionaries by their \'age\' in ascending order. Ensure your implementation passes the provided test cases.","solution":"def sort_students_by_age(students: list) -> list: Sorts a list of student dictionaries by age. :param students: List[Dict[str, Union[str, int]]] :return: List[Dict[str, Union[str, int]]] return sorted(students, key=lambda student: student[\'age\'])"},{"question":"# Question: Unique Substring Finder Scenario: Finding the longest substring without any repeated characters is a common problem in various string manipulation tasks, such as text analysis, pattern matching, and data compression. Task: Write a function `longest_unique_substring(s: str) -> str` that finds and returns the longest substring without repeating characters from a given string `s`. If there are multiple such substrings with the same length, return the one that appears first. Implement a helper function `substring_details(substring: str) -> str` to format the details of the longest unique substring. Function Specifications: 1. `longest_unique_substring(s: str) -> str` - **Input**: A string `s` containing only ASCII characters. - **Output**: The longest substring without repeated characters. 2. `substring_details(substring: str) -> str` - **Input**: A string representing the longest unique substring. - **Output**: A formatted string showing the length of the substring and the substring itself. Examples: ```python >>> print(substring_details(longest_unique_substring(\\"abcabcbb\\"))) Longest unique substring length: 3, Substring: \\"abc\\" >>> print(substring_details(longest_unique_substring(\\"bbbbb\\"))) Longest unique substring length: 1, Substring: \\"b\\" >>> print(substring_details(longest_unique_substring(\\"pwwkew\\"))) Longest unique substring length: 3, Substring: \\"wke\\" >>> print(substring_details(longest_unique_substring(\\"abcdef\\"))) Longest unique substring length: 6, Substring: \\"abcdef\\" >>> print(substring_details(longest_unique_substring(\\"aab\\"))) Longest unique substring length: 2, Substring: \\"ab\\" >>> print(substring_details(longest_unique_substring(\\"dvdf\\"))) Longest unique substring length: 3, Substring: \\"vdf\\" ``` Constraints: - The input string will have a length between 0 and 10^5. - Use only standard library functions and data structures. Performance Requirements: - The solution must run in linear time O(n) and use linear space O(n) where n is the length of the input string `s`.","solution":"def longest_unique_substring(s: str) -> str: Finds the longest substring without repeating characters. start = 0 max_length = 0 max_substring = \'\' used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: current_length = i - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:i+1] used_chars[char] = i return max_substring def substring_details(substring: str) -> str: Formats the details of the longest unique substring. return f\'Longest unique substring length: {len(substring)}, Substring: \\"{substring}\\"\'"},{"question":"# Context In a common task of text processing, one might need to count the number of words present in a given string. Words are typically separated by spaces, and the string may contain leading, trailing, or multiple spaces between words. Your aim is to implement a function that accurately counts the number of words in a given string. # Task Write a function that takes a string as input and returns the number of words in the string. A word is defined as a sequence of non-space characters separated by spaces. Ensure that your function handles multiple spaces correctly. # Input and Output * **Input**: A string `text` (0 ≤ len(text) ≤ 10^5), which may contain alphabetic characters, numbers, and spaces. * **Output**: An integer representing the number of words in the given string. # Constraints * The input string may contain leading, trailing, and multiple spaces between words. * The length of the input string will be between 0 and 100,000 characters. # Examples ```python >>> count_words(\\"Hello world\\") 2 >>> count_words(\\" The quick brown fox jumps over the lazy dog \\") 9 >>> count_words(\\"\\") 0 >>> count_words(\\" \\") 0 ``` # Implementation Requirements * Your solution should be efficient in terms of time and space complexity. * Make sure to handle edge cases, such as strings with only spaces or empty strings. # Hints * Using Python\'s string split() method might simplify the task. * Consider how to handle various cases of spaces in the input string.","solution":"def count_words(text): Returns the number of words in the input string. Words are defined as sequences of non-space characters separated by spaces. # Split the string by spaces and filter out empty strings words = [word for word in text.split(\' \') if word] return len(words)"},{"question":"# Coding Assessment Question Scenario As a software developer, you have been tasked with refining the search functionality within an e-commerce platform. To enhance the performance of the search operation, your job is to implement the Boyer-Moore string matching algorithm to efficiently locate a substring within a larger corpus of text. Function to Implement Implement the function `boyer_moore(text: str, pattern: str) -> int` which searches for the first occurrence of the specified pattern within the text using the Boyer-Moore algorithm. Input 1. `text`: A string representing the text corpus where the search is performed. 2. `pattern`: A string representing the substring you want to locate within the text. Output The function should return an integer representing the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. Constraints 1. The length of the text is between 1 and 100,000 characters. 2. The length of the pattern is between 1 and 1,000 characters. 3. Both text and pattern consist of ASCII characters. Performance Requirements - The function should be efficient and have a time complexity in the average case of O(n + m), where n is the length of the text and m is the length of the pattern. Example ```python text = \\"Here is a simple example to demonstrate the Boyer-Moore string matching algorithm.\\" pattern = \\"example\\" assert boyer_moore(text, pattern) == 17 ``` **Note**: Consider edge cases such as an empty pattern or text, and ensure the handling of overlapping patterns efficiently within the given constraints.","solution":"def boyer_moore(text: str, pattern: str) -> int: Implements the Boyer-Moore string matching algorithm to find the first occurrence of the pattern in the text. def get_bad_char_table(pattern: str): Constructs the bad character table. bad_char_table = [-1] * 256 # Considering ASCII characters for i, char in enumerate(pattern): bad_char_table[ord(char)] = i return bad_char_table def get_good_suffix_table(pattern: str): Constructs the good suffix table. m = len(pattern) good_suffix_table = [0] * m z = [0] * m left, right = 0, 0 for i in range(m - 1, -1, -1): if i > right: left, right = i, i while left >= 0 and pattern[left] == pattern[m - 1 - (right - left)]: left -= 1 z[i] = right - left right += 1 else: k = i - left if z[k] < right - i + 1: z[i] = z[k] else: left = i while left >= 0 and pattern[left] == pattern[m - 1 - (right - left)]: left -= 1 z[i] = right - left right += 1 for i in range(m - 1): good_suffix_table[m - z[i] - 1] = i + 1 return good_suffix_table n = len(text) m = len(pattern) if m == 0: return 0 bad_char_table = get_bad_char_table(pattern) good_suffix_table = get_good_suffix_table(pattern) s = 0 # s is the shift of the pattern with respect to text while s <= n - m: j = m - 1 while j >= 0 and pattern[j] == text[s + j]: j -= 1 if j < 0: return s else: skip_bad_char = j - bad_char_table[ord(text[s + j])] skip_good_suffix = good_suffix_table[j] if j < m - 1 else 1 s += max(skip_bad_char, skip_good_suffix) return -1"},{"question":"# Scenario You are developing a command-line tool that interacts with a weather API to fetch and display the current weather for a given location. Your objective is to implement a function that makes a request to the API and retrieves the weather information, and then write corresponding unit tests ensuring the reliability of your function using mocking. # Task 1. Implement a function `get_current_weather` that takes a location name as an argument and returns a dictionary with the weather description and temperature. 2. Write unit tests for your function using the mocking technique to simulate the API\'s behavior. # Requirements **Function Signature**: ```python def get_current_weather(location: str) -> dict: # Your implementation here ``` # Example ```python # Example of return value get_current_weather(\\"London\\") # Expected output: {\\"description\\": \\"clear sky\\", \\"temperature\\": 15.5} ``` # Constraints - Assume `WEATHER_API_ENDPOINT = \\"https://api.weather.com/v1/current\\"` - The function should raise an exception if the response does not contain `description` or `temperature`. # Testing - Use the `monkeypatch` utility from the `pytest` library to mock the `requests.get` method. - Verify that the function correctly processes valid and invalid location names. # Additional Information - You can use `assert` statements to ensure that the mocked responses are correctly used. - Handle edge cases such as invalid location names, network issues, or unexpected response formats gracefully.","solution":"import requests WEATHER_API_ENDPOINT = \\"https://api.weather.com/v1/current\\" def get_current_weather(location: str) -> dict: Fetches the current weather for the given location from the weather API. :param location: The name of the location to fetch the weather for. :return: A dictionary containing the weather description and temperature. :raises Exception: If the API response does not contain the required fields. response = requests.get(f\\"{WEATHER_API_ENDPOINT}?location={location}\\") response.raise_for_status() # Raise an exception for HTTP errors data = response.json() if \'description\' not in data or \'temperature\' not in data: raise Exception(\\"API response does not contain required weather information\\") return { \\"description\\": data[\'description\'], \\"temperature\\": data[\'temperature\'] }"},{"question":"# Question: Implement the Intersection of Multiple Linked Lists **Context**: You are required to implement a function to find the intersection node(s) of multiple singly linked lists. An intersection in this context refers to the first common node at which the linked lists converge. If no intersection exists, the function should return `None`. **Function to Implement**: Implement the following function: ```python def find_intersection(lists): Find the intersection node of multiple linked lists. Parameters: lists : List[ListNode] A list of head nodes representing the singly linked lists. Returns: ListNode or None The first intersection node of the linked lists, or None if no intersection exists. ``` **Input/Output**: - **Input**: - `lists`: A list of `ListNode` instances, with each representing the head node of a singly linked list. - **Output**: - The function should return a `ListNode` instance that is the intersection node or return `None` if no intersection exists. **Constraints**: - The number of linked lists does not exceed 10. - The length of each linked list does not exceed 1000 nodes. - Nodes in the input linked lists will be distinct instances with integer values. **Additional Details**: 1. The ListNode class is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` 2. You are expected to come up with an efficient way to find the intersection that minimizes both time and space complexity. **Example**: ```python # Assuming we have the following linked lists sharing some common nodes: # List1: 1 -> 2 -> 3 -> 4 -> 5 # List2: 6 -> 4 -> 5 # List3: 7 -> 8 -> 4 -> 5 # The intersection point is at node with value 4. head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) head2 = ListNode(6, ListNode(4, ListNode(5))) head3 = ListNode(7, ListNode(8, ListNode(4, ListNode(5)))) lists = [head1, head2, head3] # The function should return the node with value 4. intersection_node = find_intersection(lists) ``` **Performance Considerations**: - Aim for a solution with a time complexity of O(N) where N is the combined length of all linked lists. - Space complexity should be O(1) if possible, excluding the space required for input storage.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_intersection(lists): Find the intersection node of multiple linked lists. Parameters: lists : list of ListNode A list of head nodes representing the singly linked lists. Returns: ListNode or None The first intersection node of the linked lists, or None if no intersection exists. if not lists: return None if len(lists) < 2: return lists[0] if lists[0] else None def get_length(head): length = 0 while head: length += 1 head = head.next return length def get_intersection_node(head1, head2): len1, len2 = get_length(head1), get_length(head2) if len1 > len2: for _ in range(len1 - len2): head1 = head1.next else: for _ in range(len2 - len1): head2 = head2.next while head1 and head2: if head1 == head2: return head1 head1 = head1.next head2 = head2.next return None intersection = lists[0] for i in range(1, len(lists)): intersection = get_intersection_node(intersection, lists[i]) if not intersection: return None return intersection"},{"question":"# Scenario You are assisting in the development of a robotic system for an automated warehouse. The system uses a grid-based map where each cell can either be open or blocked. The robot can only move up, down, left, or right. You need to determine if there is a valid path from the top-left corner to the bottom-right corner, given that the robot cannot move through blocked cells. # Task Write a function `has_path(grid)` that: 1. Returns a boolean value indicating whether there is a path from the top-left corner to the bottom-right corner. 2. Utilizes breadth-first search (BFS) for finding the path. 3. Does not modify the input grid. # Input and Output Formats Input * `grid` (list[list[int]]): A 2D matrix of integers where 0 represents an open cell and 1 represents a blocked cell. Output * `bool`: True if there is a path from the top-left corner to the bottom-right corner, False otherwise. # Function Signature ```python def has_path(grid: list[list[int]]) -> bool: ``` # Example ```python # Example 1 # Path exists. print(has_path([[0, 0, 1], [0, 1, 0], [0, 0, 0]])) # Output: True # Example 2 # No path exists. print(has_path([[0, 1, 1], [1, 1, 0], [0, 0, 0]])) # Output: False # Example 3 # Single cell grid. print(has_path([[0]])) # Output: True # Example 4 # Blocked starting cell. print(has_path([[1, 0], [0, 0]])) # Output: False ``` # Constraints * The grid is always a rectangular matrix with dimensions `m x n` where `1 <= m, n <= 1000`. * The top-left cell and the bottom-right cell are always open (i.e., `grid[0][0] == 0` and `grid[m-1][n-1] == 0`). # Notes * Ensure your solution is optimized for larger grids. * You can use helper functions if necessary to aid readability and code organization. **Complete the implementation in Python.**","solution":"from collections import deque def has_path(grid): Determines if there is a valid path from the top-left corner to the bottom-right corner of the grid using breadth-first search (BFS). Args: grid (list[list[int]]): 2D matrix representing the grid where 0 is an open cell and 1 is blocked. Returns: bool: True if there is a path from the top-left corner to the bottom-right corner, False otherwise. if not grid or not grid[0]: return False rows, cols = len(grid), len(grid[0]) # Early exit if the start or end points are blocked if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (rows-1, cols-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) return False"},{"question":"# Coding Question: Identify the Minimum Missing Positive Integer Context: Bob is working on a data analysis project and he needs to find the smallest missing positive integer in an unsorted list of integers. This problem arises frequently in data cleanup tasks, ensuring that sequences of integers are complete. Task: Write a function `find_minimum_missing_positive(nums: List[int]) -> int` that returns the smallest positive integer that does not appear in the given list of integers. Assume the list can contain both positive and negative integers, and may be unsorted. Input and Output Format: * **Input**: A list of integers `nums`. * Constraints: * The length of the list is between 1 and (10^5). * Each integer in the list is between (-10^6) and (10^6). * **Output**: The smallest positive integer not present in the list. Example Cases: ```python >>> find_minimum_missing_positive([3, 4, -1, 1]) 2 >>> find_minimum_missing_positive([1, 2, 0]) 3 >>> find_minimum_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_minimum_missing_positive([1, 1, 1, 1]) 2 >>> find_minimum_missing_positive([-1, -2, -3]) 1 ``` Constraints: * The function must run in O(n) time complexity. * The function should use O(1) additional space complexity (i.e., apart from the input, it should use constant extra space). Performance Requirements: * Your solution should efficiently handle lists with up to (10^5) elements. * Handle edge cases, such as lists with all negative numbers or lists where all integers in a certain range are present. Good luck and make sure your code handles large inputs efficiently!","solution":"def find_minimum_missing_positive(nums): Returns the smallest missing positive integer in the unsorted list of integers. n = len(nums) # Move each positive int to the position idx=int-1 for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Find the first position not having the right int => that int is missing for i in range(n): if nums[i] != i + 1: return i + 1 # All positions are filled correctly with 1 to n, hence the missing int is n+1 return n + 1"},{"question":"# Genetic Algorithm for Function Optimization Objective You are required to develop a genetic algorithm to find the minimum value of a specified mathematical function. The function to be optimized is given as a Python callable, and the range within which the solution should be searched will also be specified. Problem Statement Implement a genetic algorithm that optimizes the function `f(x)` within the interval `[a, b]`. The algorithm should: 1. Generate an initial population of random solutions within the range. 2. Use selection, crossover, and mutation to evolve the population toward better solutions. 3. Terminate the algorithm when either a specified number of generations has been reached or the fitness improvement is negligible. Input/Output Format * **Input**: * A callable `func` representing the function to be optimized. * Two floats `a` and `b` representing the range `[a, b]` in which to search for the minimum value. * Optional parameters `population_size`, `generations`, `crossover_rate`, `mutation_rate`, and `tolerance` with default values of 100, 200, 0.7, 0.01, and 1e-4 respectively. * **Output**: * A float representing the approximate minimum of the function within the specified range. Constraints * Function `func` must be a continuous and differentiable function in the interval `[a, b]`. * Limit the dimensionality to a 1D optimization problem. Code Requirements 1. Implement the genetic algorithm with the ability to configure population size, number of generations, crossover rate, and mutation rate. 2. Ensure the algorithm terminates early if the change in the best fitness value is less than the specified tolerance over a set number of generations. Template ```python import numpy as np def genetic_algorithm_optimization(func, a, b, population_size=100, generations=200, crossover_rate=0.7, mutation_rate=0.01, tolerance=1e-4): Optimizes the function `func` within the range `[a, b]` using a genetic algorithm. Parameters: func (callable): The objective function to be minimized. a (float): Lower bound of the search interval. b (float): Upper bound of the search interval. population_size (int): Number of individuals in the population. generations (int): Maximum number of generations to run the algorithm. crossover_rate (float): Probability of crossover. mutation_rate (float): Probability of mutation. tolerance (float): Minimum change in fitness value to continue iterations. # Utility to generate an initial population within the range def generate_population(size, lower_bound, upper_bound): return np.random.uniform(lower_bound, upper_bound, size) # Fitness function to evaluate population def evaluate_population(population): return np.array([func(indiv) for indiv in population]) # Main genetic algorithm loop pop = generate_population(population_size, a, b) best_fitness = float(\'inf\') best_solution = None for gen in range(generations): fitness_vals = evaluate_population(pop) if np.min(fitness_vals) < best_fitness: best_fitness = np.min(fitness_vals) best_solution = pop[np.argmin(fitness_vals)] # Selection (using tournament selection) selected_parents = np.random.choice(population_size, size=population_size, replace=True) # Crossover new_pop = [] for i in range(0, population_size, 2): parent1, parent2 = pop[selected_parents[i]], pop[selected_parents[i+1]] if np.random.rand() < crossover_rate: crossover_point = np.random.uniform(0, 1) child1 = crossover_point * parent1 + (1 - crossover_point) * parent2 child2 = crossover_point * parent2 + (1 - crossover_point) * parent1 new_pop.extend([child1, child2]) else: new_pop.extend([parent1, parent2]) # Mutation new_pop = np.array(new_pop) mutations = np.random.rand(population_size) < mutation_rate new_pop[mutations] += np.random.uniform(-0.1, 0.1, size=np.count_nonzero(mutations)) # Replace population pop = np.clip(new_pop, a, b) # Check for convergence if np.abs(best_fitness - np.min(fitness_vals)) < tolerance: break return best_solution # Example usage def example_func(x): return x**2 + 4*x + 6 a, b = -10, 10 minimum = genetic_algorithm_optimization(example_func, a, b) print(\\"Approximate minimum:\\", minimum) ```","solution":"import numpy as np def genetic_algorithm_optimization(func, a, b, population_size=100, generations=200, crossover_rate=0.7, mutation_rate=0.01, tolerance=1e-4): Optimizes the function `func` within the range `[a, b]` using a genetic algorithm. Parameters: func (callable): The objective function to be minimized. a (float): Lower bound of the search interval. b (float): Upper bound of the search interval. population_size (int): Number of individuals in the population. generations (int): Maximum number of generations to run the algorithm. crossover_rate (float): Probability of crossover. mutation_rate (float): Probability of mutation. tolerance (float): Minimum change in fitness value to continue iterations. # Utility to generate an initial population within the range def generate_population(size, lower_bound, upper_bound): return np.random.uniform(lower_bound, upper_bound, size) # Fitness function to evaluate population def evaluate_population(population): return np.array([func(indiv) for indiv in population]) # Main genetic algorithm loop pop = generate_population(population_size, a, b) best_fitness = float(\'inf\') best_solution = None for gen in range(generations): fitness_vals = evaluate_population(pop) if np.min(fitness_vals) < best_fitness: best_fitness = np.min(fitness_vals) best_solution = pop[np.argmin(fitness_vals)] # Selection (using tournament selection) selected_indices = np.random.choice(population_size, size=population_size, replace=True) # Crossover new_pop = [] for i in range(0, population_size, 2): parent1, parent2 = pop[selected_indices[i]], pop[selected_indices[i+1]] if np.random.rand() < crossover_rate: crossover_point = np.random.uniform(0, 1) child1 = crossover_point * parent1 + (1 - crossover_point) * parent2 child2 = crossover_point * parent2 + (1 - crossover_point) * parent1 new_pop.extend([child1, child2]) else: new_pop.extend([parent1, parent2]) # Mutation new_pop = np.array(new_pop) mutations = np.random.rand(population_size) < mutation_rate new_pop[mutations] += np.random.uniform(-0.1, 0.1, size=np.count_nonzero(mutations)) # Replace population pop = np.clip(new_pop, a, b) # Check for convergence if np.abs(best_fitness - np.min(fitness_vals)) < tolerance: break return best_solution # Example usage def example_func(x): return x**2 + 4*x + 6 a, b = -10, 10 minimum = genetic_algorithm_optimization(example_func, a, b) print(\\"Approximate minimum:\\", minimum)"},{"question":"# Problem Statement You are to implement a function to calculate the **Matrix Product** using the Strassen Algorithm, which is more efficient than the standard matrix multiplication approach for larger matrices. # Requirements Write a function `strassen_matrix_mult` that takes in two square matrices `A` and `B`, and returns their product using the Strassen algorithm. Function Signature ```python def strassen_matrix_mult(A, B): pass ``` Expected Input and Output - **Input**: - `A`: A square matrix of size `2^n x 2^n` represented as a list of lists. - `B`: Another square matrix of size `2^n x 2^n` represented as a list of lists. - **Output**: - Returns the resulting matrix product of `A` and `B` as a list of lists, also of size `2^n x 2^n`. Example ```python A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] result = strassen_matrix_mult(A, B) print(result) # Output should be [[19, 22], [43, 50]] C = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] D = [ [16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1] ] result = strassen_matrix_mult(C, D) print(result) # Output should be [[80, 70, 60, 50], [240, 214, 188, 162], [400, 358, 316, 274], [560, 502, 444, 386]] ``` Constraints 1. Both matrices `A` and `B` are guaranteed to be square and of size `2^n x 2^n` where ( n geq 1 ). 2. Ensure your implementation follows the divide-and-conquer approach of the Strassen algorithm. 3. Consider edge cases such as small matrices or where `n` is 1 (resulting in 2x2 matrices). 4. Validate the inputs to ensure they are lists of lists and conform to the expected dimensions. # Notes - Use the efficiency of the Strassen algorithm to handle larger matrices compared to the traditional matrix multiplication approach. - Optimize your recursive calls to minimize the overhead and ensure correct allocation of memory for sub-matrices. - Ensure that the multiplication function handles matrices correctly for the base case and recursively for larger matrices with proper combination of results from sub-matrices.","solution":"import numpy as np def add_matrix(A, B): Adds two matrices A and B. return [[A[i][j] + B[i][j] for j in range(len(A[0]))] for i in range(len(A))] def subtract_matrix(A, B): Subtracts matrix B from matrix A. return [[A[i][j] - B[i][j] for j in range(len(A[0]))] for i in range(len(A))] def split_matrix(M): Splits a given matrix into four sub-matrices. mid = len(M) // 2 A = [[M[i][j] for j in range(mid)] for i in range(mid)] B = [[M[i][j] for j in range(mid, len(M))] for i in range(mid)] C = [[M[i][j] for j in range(mid)] for i in range(mid, len(M))] D = [[M[i][j] for j in range(mid, len(M))] for i in range(mid, len(M))] return A, B, C, D def strassen_matrix_mult(A, B): Performs matrix multiplication using the Strassen algorithm. n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] A11, A12, A21, A22 = split_matrix(A) B11, B12, B21, B22 = split_matrix(B) M1 = strassen_matrix_mult(add_matrix(A11, A22), add_matrix(B11, B22)) M2 = strassen_matrix_mult(add_matrix(A21, A22), B11) M3 = strassen_matrix_mult(A11, subtract_matrix(B12, B22)) M4 = strassen_matrix_mult(A22, subtract_matrix(B21, B11)) M5 = strassen_matrix_mult(add_matrix(A11, A12), B22) M6 = strassen_matrix_mult(subtract_matrix(A21, A11), add_matrix(B11, B12)) M7 = strassen_matrix_mult(subtract_matrix(A12, A22), add_matrix(B21, B22)) C11 = add_matrix(subtract_matrix(add_matrix(M1, M4), M5), M7) C12 = add_matrix(M3, M5) C21 = add_matrix(M2, M4) C22 = add_matrix(subtract_matrix(add_matrix(M1, M3), M2), M6) C = [] for i in range(len(C11)): C.append(C11[i] + C12[i]) for i in range(len(C21)): C.append(C21[i] + C22[i]) return C"},{"question":"# Question: Matrix Determinant Calculation You are given a function `determinant(matrix)` that calculates the determinant of a 2x2 matrix. Your task is to implement an enhanced function `determinant_calculator` that reads a matrix input string, parses it into a 2x2 list structure, and computes its determinant. # Function Signature: ```python def determinant_calculator(input_str: str) -> int: pass ``` # Input Format * A string representing a 2x2 matrix where elements are separated by commas and rows are separated by semicolons. The format is: `\\"a11,a12;a21,a22\\"`. # Output Format * An integer representing the determinant of the matrix. # Constraints * All matrix elements are integers within the range of -10,000 to 10,000. * The matrix will always be 2x2. # Example ```python >>> determinant_calculator(\\"1,2;3,4\\") -2 >>> determinant_calculator(\\"5,6;7,8\\") -2 >>> determinant_calculator(\\"0,1;-1,0\\") 1 ``` # Notes Your implementation needs to correctly handle any valid 2x2 matrix provided in the specified format. Ensure you account for all possible integer values within the given range.","solution":"def determinant(matrix): Calculates the determinant of a 2x2 matrix. The matrix is expected to be a list of lists in the form: [[a11, a12], [a21, a22]] [[a11, a12], [a21, a22]] = matrix return a11 * a22 - a12 * a21 def determinant_calculator(input_str: str) -> int: Parses a matrix represented as a string and calculates its determinant. :param input_str: A string representing a 2x2 matrix, formatted as \'a11,a12;a21,a22\' :return: The determinant of the matrix as an integer rows = input_str.split(\';\') matrix = [] for row in rows: matrix.append([int(x) for x in row.split(\',\')]) return determinant(matrix)"},{"question":"# Introduction Binary numbers can be converted into their decimal form and vice versa. This process involves understanding and applying the base-2 and base-10 numerical systems. # Task Write a function named `convert_binary_to_decimal(binary_str: str) -> int` that converts a binary string into its decimal integer equivalent. # Requirements * **Function Signature**: `def convert_binary_to_decimal(binary_str: str) -> int` * **Input**: A single string `binary_str` containing a binary number (i.e., a sequence of \'0\' and \'1\' characters). The input string can contain leading or trailing spaces. * **Output**: A single integer representing the decimal equivalent of the binary number. # Constraints 1. Leading or trailing spaces should be ignored. 2. Return -1 if the input string is empty or contains only spaces. 3. The conversion should be case-insensitive, but since binary numbers involve only \'0\' and \'1\', this is more about handling any potential input irregularities. 4. If the initial string is `None`, return -1. 5. Consider only valid binary inputs (i.e., strings containing only \'0\' and \'1\' characters). 6. Do not use any external libraries for the conversion, except for basic string manipulation functions. # Examples ```python >>> convert_binary_to_decimal(\\"101\\") 5 >>> convert_binary_to_decimal(\\"1101\\") 13 >>> convert_binary_to_decimal(\\" 1110 \\") 14 >>> convert_binary_to_decimal(\\" 1001 \\") 9 >>> convert_binary_to_decimal(\\" \\") -1 >>> convert_binary_to_decimal(None) -1 ``` # Additional Notes * Test your function thoroughly with various test cases, including edge cases for a robust solution. * You can assume the input will be a valid binary string so there is no need for extensive validation beyond handling the described edge cases.","solution":"def convert_binary_to_decimal(binary_str: str) -> int: Converts a binary string into its decimal integer equivalent. Parameters: binary_str (str): The binary string to convert. Returns: int: The decimal equivalent of the binary number or -1 for invalid input. if binary_str is None: return -1 # Strip leading or trailing spaces from the string binary_str = binary_str.strip() # Return -1 if the string is empty after stripping spaces if binary_str == \\"\\": return -1 # Check if the string contains only \'0\' and \'1\' characters if not all(char in \'01\' for char in binary_str): return -1 # Convert the binary string to a decimal integer decimal_value = 0 for i, char in enumerate(reversed(binary_str)): if char == \'1\': decimal_value += 2 ** i return decimal_value"},{"question":"# Context: You are developing a text editor that supports various string manipulation features. One useful feature is checking if the text follows the rules of a specific pattern. In this task, you need to implement a function that checks whether a given string conforms to the pattern of a palindrome. # Problem Statement: Write a function `is_palindrome(text: str) -> bool` that takes a string as input and returns `True` if the string is a palindrome (reads the same forwards and backwards, ignoring spaces, punctuation, and case), and `False` otherwise. Your function should validate the input and raise a `ValueError` if the input is not a string. Input and Output Formats: * **Input**: A single argument `text` which is a string. * **Output**: A boolean value: `True` if the text is a palindrome, `False` otherwise. Constraints and Limitations: * The input is guaranteed to be a non-empty string. * You should ignore spaces, punctuation, and case when determining if the string is a palindrome. * You should consider edge cases and validate the input. Example: ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") True >>> is_palindrome(\\"racecar\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"Hello, World!\\") False >>> is_palindrome(12345) Traceback (most recent call last): ... ValueError: Input must be a string >>> is_palindrome(\\"\\") Traceback (most recent call last): ... ValueError: Input must be a non-empty string ``` # Performance Requirements: * Your solution should ideally handle strings of various lengths efficiently. * Consider using string manipulation and filtering techniques to preprocess the input.","solution":"import re def is_palindrome(text: str) -> bool: Checks if the given text is a palindrome, ignoring spaces, capitalization, and punctuation. Raises a ValueError if the input is not a string or is an empty string. :param text: The input string to check. :return: True if the text is a palindrome, False otherwise. if not isinstance(text, str): raise ValueError(\\"Input must be a string\\") if text.strip() == \\"\\": raise ValueError(\\"Input must be a non-empty string\\") # Remove non-alphanumeric characters and convert to lowercase cleaned_text = re.sub(r\'[^a-zA-Z0-9]\', \'\', text).lower() # Check if the cleaned text is a palindrome return cleaned_text == cleaned_text[::-1]"},{"question":"# Sum of Multiples Problem Statement Write a function that calculates the sum of all multiples of a given set of numbers up to a specified limit. The function should be able to handle scenarios where no multiples are found and should work efficiently for a large range of inputs. Requirements * Input: A list of integers and a single integer limit. * Output: An integer representing the sum of all multiples of the provided integers up to but not including the specified limit. Constraints 1. The list of integers will only contain non-negative integers. 2. The limit will be a non-negative integer. 3. If the list of integers is empty, the sum is 0. 4. If no multiples are found up to the limit, the sum is 0. 5. The input integers and the limit are small enough to avoid integer overflow but large enough to require efficient computation. Example ```python def sum_of_multiples(numbers: list, limit: int) -> int: pass # Example test cases print(sum_of_multiples([3, 5], 10)) # Output: 23 (3 + 5 + 6 + 9) print(sum_of_multiples([7, 3], 20)) # Output: 84 (3 + 6 + 7 + 9 + 12 + 14 + 18) print(sum_of_multiples([1], 5)) # Output: 10 (0 + 1 + 2 + 3 + 4) print(sum_of_multiples([], 100)) # Output: 0 print(sum_of_multiples([5], 5)) # Output: 0 ``` # Additional Notes - Ensure your function is efficient, particularly for cases with a high limit. - You may use mathematical formulas to optimize the computation rather than brute-forcing through all numbers up to the limit. - Include handling of edge cases such as empty lists and very small limits.","solution":"def sum_of_multiples(numbers, limit): Calculate the sum of all multiples of given numbers up to the specified limit. if not numbers: return 0 multiples = set() for number in numbers: if number <= 0: continue for multiple in range(number, limit, number): multiples.add(multiple) return sum(multiples)"},{"question":"# Question: Calculate the Maximum Water Stored Between Buildings Given an array of non-negative integers representing the heights of buildings, you are tasked with finding out how much water can be trapped between the buildings after it rains. The water trapped is defined as the amount of water that resides between the buildings due to their differing heights. Task Write a function `calculate_water_trapped(heights: List[int]) -> int` that computes the total amount of water that can be trapped between the buildings. Function Signature ```python def calculate_water_trapped(heights: List[int]) -> int: ``` Input - `heights` (List[int]): An array of non-negative integers where each integer represents the height of a building. Output - `int`: The total amount of water trapped between the buildings. Constraints - `0 <= len(heights) <= 10^5` - `0 <= heights[i] <= 10^4` Example # Example 1: ```python calculate_water_trapped([0,1,0,2,1,0,1,3,2,1,2,1]) # Output: 6 # Explanation: Across index 1 and 5, 1 unit of water; # Across index 2 and 6, 1 unit; across index 3 and 7, 2 units; # across index 5 and 8, 1 unit; across index 6 and 9, 1 unit. # Total: 1 + 1 + 2 + 1 + 1 = 6 ``` # Example 2: ```python calculate_water_trapped([4,2,0,3,2,5]) # Output: 9 # Explanation: Across index 1 and 5, 3 units of water; # Across index 2 and 6, 3 units; across index 4 and 6, 2 units. # Total: 3 + 3 + 2 + 1 = 9 ``` Performance Requirements Your implementation should be efficient enough to handle the maximum input size, with a time complexity around O(n) being acceptable. Note - Consider using two-pointer techniques to achieve an optimal solution.","solution":"from typing import List def calculate_water_trapped(heights: List[int]) -> int: if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] water_trapped = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) water_trapped += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) water_trapped += right_max - heights[right] return water_trapped"},{"question":"# Question: Maximal Bipartite Matching You are given a bipartite graph with `N` nodes labeled from `1` to `N` on one side and `M` nodes labeled from `1` to `M` on the other side. The graph is represented by a list of edges where each edge connects a node from the first set to a node in the second set. Your task is to implement a function that computes the maximum number of matching pairs (i.e., edges) that can be formed such that no two edges share the same node. # Functions to Implement: 1. `maximal_bipartite_matching(N: int, M: int, edges: list[tuple[int, int]]) -> int`: - **Input**: - `N`: Number of nodes in the first set. - `M`: Number of nodes in the second set. - `edges`: List of tuples where each tuple `(u, v)` represents an edge connecting node `u` from the first set to node `v` from the second set. - **Output**: The maximum number of matching pairs. # Constraints: - `1 <= N, M <= 1000` - `0 <= len(edges) <= N * M` - Each node in the first set is only connected to nodes in the second set and vice versa. - The function should have a time complexity of O(N * M). # Example: Given the bipartite graph represented as follows: ``` Nodes in Set 1: [1, 2, 3] Nodes in Set 2: [1, 2, 3] Edges: [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)] ``` ```python maximal_bipartite_matching(3, 3, [(1, 1), (1, 2), (2, 2), (2, 3), (3, 3)]) # Outputs: 3 ``` Explanation: - The matching pairs can be (1, 1), (2, 2), and (3, 3). - One possible maximum matching is all nodes in the first set being matched with a unique node in the second set.","solution":"def maximal_bipartite_matching(N: int, M: int, edges: list[tuple[int, int]]) -> int: from collections import deque, defaultdict def bpm(u, matchR, seen): for v in adj[u]: if not seen[v]: seen[v] = True if matchR[v] == -1 or bpm(matchR[v], matchR, seen): matchR[v] = u return True return False adj = defaultdict(list) for u, v in edges: adj[u].append(v) matchR = [-1] * (M + 1) result = 0 for u in range(1, N + 1): seen = [False] * (M + 1) if bpm(u, matchR, seen): result += 1 return result"},{"question":"# Problem Statement You are tasked with creating a scheduling system that checks for conflicts in a list of events and suggests optimal event slots based on given constraints. Each event has a start time, end time, and a unique identifier. Function Descriptions 1. **parse_time(time_str: str) -> Tuple[int, int]** - Input: A string representing time in the format \\"HH:MM\\". - Output: A tuple of two integers representing hours and minutes. - Example: ```python parse_time(\\"14:30\\") # returns (14, 30) ``` 2. **event_conflict(event1: Tuple[str, str, str], event2: Tuple[str, str, str]) -> bool** - Input: Two events in the form of tuples (id: str, start_time: str, end_time: str). - Output: A boolean indicating whether the two events conflict. - Example: ```python event1 = (\\"1\\", \\"09:00\\", \\"11:00\\") event2 = (\\"2\\", \\"10:30\\", \\"12:00\\") event_conflict(event1, event2) # returns True ``` 3. **find_conflicts(events: List[Tuple[str, str, str]]) -> List[Tuple[str, str]]** - Input: A list of events, where each event is a tuple (id: str, start_time: str, end_time: str). - Output: A list of tuples, where each tuple contains the ids of conflicting events. - Example: ```python events = [(\\"1\\", \\"09:00\\", \\"11:00\\"), (\\"2\\", \\"10:30\\", \\"12:00\\"), (\\"3\\", \\"11:00\\", \\"13:00\\")] find_conflicts(events) # returns [(\\"1\\", \\"2\\"), (\\"2\\", \\"3\\")] ``` 4. **suggest_time_slot(events: List[Tuple[str, str, str]], event_duration: int) -> str** - Input: A list of events and the duration of the new event in minutes. - Output: A suggested time slot for the new event in the format \\"HH:MM\\". - Example: ```python events = [(\\"1\\", \\"09:00\\", \\"11:00\\"), (\\"2\\", \\"13:30\\", \\"15:00\\")] suggest_time_slot(events, 60) # returns \'12:00\' ``` # Constraints: - The input times will follow the \\"HH:MM\\" format. - The time is based on a 24-hour clock. - The event duration will be a positive integer representing minutes. - Assume there are no events spanning midnight. - A time slot suggestion should fit within a working day (e.g., 08:00 to 18:00). # Implementation Implement the following functions: ```python from typing import List, Tuple def parse_time(time_str: str) -> Tuple[int, int]: # Your implementation here pass def event_conflict(event1: Tuple[str, str, str], event2: Tuple[str, str, str]) -> bool: # Your implementation here pass def find_conflicts(events: List[Tuple[str, str, str]]) -> List[Tuple[str, str]]: # Your implementation here pass def suggest_time_slot(events: List[Tuple[str, str, str]], event_duration: int) -> str: # Your implementation here pass ```","solution":"from typing import List, Tuple def parse_time(time_str: str) -> Tuple[int, int]: hours, minutes = map(int, time_str.split(\':\')) return (hours, minutes) def event_conflict(event1: Tuple[str, str, str], event2: Tuple[str, str, str]) -> bool: _, start1, end1 = event1 _, start2, end2 = event2 start1_h, start1_m = parse_time(start1) end1_h, end1_m = parse_time(end1) start2_h, start2_m = parse_time(start2) end2_h, end2_m = parse_time(end2) start1_total = start1_h * 60 + start1_m end1_total = end1_h * 60 + end1_m start2_total = start2_h * 60 + start2_m end2_total = end2_h * 60 + end2_m return not (end1_total <= start2_total or end2_total <= start1_total) def find_conflicts(events: List[Tuple[str, str, str]]) -> List[Tuple[str, str]]: conflicts = [] for i in range(len(events)): for j in range(i + 1, len(events)): if event_conflict(events[i], events[j]): conflicts.append((events[i][0], events[j][0])) return conflicts def suggest_time_slot(events: List[Tuple[str, str, str]], event_duration: int) -> str: WORK_START = 8 * 60 # 08:00 in minutes WORK_END = 18 * 60 # 18:00 in minutes occupied = [(parse_time(event[1])[0] * 60 + parse_time(event[1])[1], parse_time(event[2])[0] * 60 + parse_time(event[2])[1]) for event in events] occupied.sort() if len(occupied) == 0: return f\\"{WORK_START // 60:02}:{WORK_START % 60:02}\\" current_time = WORK_START for start, end in occupied: if start - current_time >= event_duration: return f\\"{current_time // 60:02}:{current_time % 60:02}\\" current_time = max(current_time, end) if WORK_END - current_time >= event_duration: return f\\"{current_time // 60:02}:{current_time % 60:02}\\" return \\"No available slot\\""},{"question":"# Problem Statement Context You are managing a file storage system, where read and write operations are frequent. To optimize data retrieval, you need to implement a least-recently-used (LRU) cache that maximizes the efficiency of accessing frequently used files while adhering to the system\'s capacity constraints. Task Implement an LRU cache with a fixed capacity. The LRU cache should support two operations: `get` and `put`. When the cache reaches its capacity, it should evict the least recently used item before inserting a new item. Function Signature ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` Input Format - The constructor of the class will take an integer `capacity` where: * `1 <= capacity <= 10^4` - `get` method will take an integer `key` and return the value associated with the key in the cache, or `-1` if the key does not exist. - `put` method will take an integer `key` and an integer `value`, adding the key-value pair to the cache. Output Format - `get` method should return the value associated with the key or `-1` if the key does not exist. - `put` method does not return anything; it adds the key-value pair to the cache. Constraints - The time complexity for both `get` and `put` should be O(1). Example ```python # Example usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 ``` Requirements - Ensure the cache evicts the least recently used item when it reaches its maximum capacity. - Maintain O(1) time complexity for the `get` and `put` operations by using appropriate data structures like HashMap and Doubly Linked List. - Properly handle edge cases such as accessing a key that does not exist and adding new key-value pairs when the cache is full. Notes - You can use Python\'s built-in `collections` module to maintain the order of elements used in the cache.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Minimum Steps in a Grid with Obstacles Given a grid where some cells are empty and others contain obstacles, write a function to compute the minimum number of steps required to move from the top-left corner (0, 0) to the bottom-right corner (n-1, m-1), navigating around obstacles. You can only move up, down, left, or right. Your task is to implement the function `min_steps(grid)` which takes a 2D list (list of lists) representing the grid and returns the minimum number of steps. If it is impossible to reach the destination, return -1. Parameters: - The input `grid` is a 2D list (list of lists) where each cell can be: - `0` representing an empty cell, - `1` representing an obstacle. Output: - The function should return the minimum number of steps to reach the destination, or -1 if it is not possible. Constraints: - The dimensions of the grid `n` by `m` are such that `1 <= n, m <= 1000`. - There should always be a starting point at (0, 0) and a destination at (n-1, m-1). - `grid[0][0]` and `grid[n-1][m-1]` will always be `0`. Example: ```python # Example grid with obstacles grid = [ [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1], [1, 0, 0, 0] ] # Expected output: Minimum steps is 5 min_steps(grid) ``` * The function should return `5`.","solution":"from collections import deque def min_steps(grid): Computes the minimum number of steps to move from the top-left corner to the bottom-right corner of a grid with obstacles. if not grid: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, step count) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if (r, c) == (n - 1, m - 1): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 0 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"# Problem: Pairwise Product Sum You are given a list of non-negative integers and your task is to find the sum of products of all unique pairs of elements in the list. More specifically, for a list `A` of `n` integers, you need to find the sum of (A[i] times A[j]) for all pairs `(i, j)` where `0 ≤ i < j < n`. Input: - A list of non-negative integers `A` with 2 ≤ len(A) ≤ 1000. Output: - An integer representing the pairwise product sum. Example: Input: ``` [1, 2, 3, 4] ``` Output: ``` 20 ``` Explanation: ``` The unique pairs and their products are: (1, 2) -> 1×2 = 2 (1, 3) -> 1×3 = 3 (1, 4) -> 1×4 = 4 (2, 3) -> 2×3 = 6 (2, 4) -> 2×4 = 8 (3, 4) -> 3×4 = 12 Sum = 2 + 3 + 4 + 6 + 8 + 12 = 35 ``` The program should handle edge cases with minimum and maximum list sizes effectively. Write a function `pairwise_product_sum` that solves the problem. ```python def pairwise_product_sum(A: list) -> int: This function calculates the sum of products of all unique pairs in the given list of non-negative integers. Args: A (list): A list of non-negative integers. Returns: int: The sum of the products of all unique pairs in the list. total_sum = 0 n = len(A) for i in range(n): for j in range(i + 1, n): total_sum += A[i] * A[j] return total_sum # Example of usage if __name__ == \\"__main__\\": print(pairwise_product_sum([1, 2, 3, 4])) # Output should be 35 ``` # Constraints: - The input list will contain only non-negative integers. - The length of the list will be between 2 and 1000, inclusive. - The function should handle lists with large numbers efficiently.","solution":"def pairwise_product_sum(A: list) -> int: This function calculates the sum of products of all unique pairs in the given list of non-negative integers. Args: A (list): A list of non-negative integers. Returns: int: The sum of the products of all unique pairs in the list. total_sum = 0 n = len(A) for i in range(n): for j in range(i + 1, n): total_sum += A[i] * A[j] return total_sum"},{"question":"# Coding Assessment Question **Context**: You are tasked with developing part of an analytics dashboard for an e-commerce website. One of the features is to display a summary of user reviews for products. Reviews are provided and stored as a list of dictionaries, where each dictionary contains information about the review. # Task Write a function `average_rating_by_category` that calculates the average rating for each product category based on user reviews. The product category and rating are included in each review dictionary. # Function Signature ```python def average_rating_by_category(reviews: List[Dict[str, Union[str, int]]]) -> Dict[str, float]: ``` # Input - `reviews` (List[Dict[str, Union[str, int]]]): A list of dictionaries, where each dictionary contains two keys: - \'category\' (str): The category of the product. - \'rating\' (int): The rating given by the user (an integer from 1 to 5). # Output - Returns a dictionary where the keys are product categories (str) and the values are the average ratings (float) for those categories, rounded to two decimal places. # Constraints - The input list `reviews` can contain between 0 and 10,000 review entries. - Each review dictionary will always contain \'category\' and \'rating\' keys. - Ensure the function handles cases with no reviews by returning an empty dictionary. # Example ```python reviews = [ {\'category\': \'electronics\', \'rating\': 4}, {\'category\': \'electronics\', \'rating\': 5}, {\'category\': \'books\', \'rating\': 3}, {\'category\': \'books\', \'rating\': 4}, {\'category\': \'clothing\', \'rating\': 2} ] print(average_rating_by_category(reviews)) ``` Expected Output: ``` { \'electronics\': 4.50, \'books\': 3.50, \'clothing\': 2.00 } ``` # Additional Information 1. Handle cases where all reviews in the input list correspond to a single category or to different categories. 2. Include robust error handling for cases where the rating is not an integer between 1 and 5, although such cases should not occur with the given constraints. --- By creating this question, we are testing the candidate\'s ability to work with lists of dictionaries, calculating averages, and handling possible edge cases such as empty inputs and malformed data. This problem addresses data processing, dictionary manipulation, and basic error handling, aligning with the complexity and scope of the sample question provided.","solution":"from typing import List, Dict, Union import collections def average_rating_by_category(reviews: List[Dict[str, Union[str, int]]]) -> Dict[str, float]: if not reviews: return {} category_totals = collections.defaultdict(int) category_counts = collections.defaultdict(int) for review in reviews: category = review[\'category\'] rating = review[\'rating\'] category_totals[category] += rating category_counts[category] += 1 average_ratings = {category: round(category_totals[category] / category_counts[category], 2) for category in category_totals} return average_ratings"},{"question":"# Problem Statement You are tasked with creating an efficient spell-checking function that can identify misspelled words in a given text. The function should take in a list of valid words and a target text, then return a list of words from the target text that are not found in the list of valid words. Focus on creating an optimized solution that handles large inputs effectively. # Objectives 1. Implement a method that efficiently checks each word in the target text against the list of valid words. 2. Ensure the solution is capable of handling a large number of words in both the valid word list and the target text. 3. Maintain low time complexity, particularly for large datasets. # Function Signature ```python from typing import List def spell_checker(valid_words: List[str], text: str) -> List[str]: pass ``` # Input * `valid_words` (List[str]): A list of non-empty strings containing the valid words. Each word only contains lowercase English letters and has a maximum length of 20. There will be up to (10^6) words in this list. * `text` (str): A string representing the target text. Each word in the text is separated by space and has a maximum length of 20. The total length of the text is up to (10^6) characters. # Output * Returns a list of words (List[str]) that are in the `text` but not in the `valid_words`. # Constraints * The words will only contain lowercase English letters. * Handle edge cases such as an empty `text` correctly. # Example ```python >>> valid_words = [\\"apple\\", \\"banana\\", \\"grape\\", \\"orange\\"] >>> text = \\"I have an apple and a banana but no grapes\\" >>> spell_checker(valid_words, text) [\'I\', \'have\', \'an\', \'and\', \'a\', \'but\', \'no\', \'grapes\'] >>> valid_words = [\\"cat\\", \\"dog\\", \\"fish\\"] >>> text = \\"the cat and the dog are friends with the fish\\" >>> spell_checker(valid_words, text) [\'the\', \'and\', \'the\', \'are\', \'friends\', \'with\', \'the\'] ``` # Notes * It is recommended to use data structures that support fast membership testing, such as sets, to optimize the checking process. * Explain your approach and the optimizations made in the comments within your code.","solution":"from typing import List def spell_checker(valid_words: List[str], text: str) -> List[str]: Identifies misspelled words in the target text compared to a list of valid words. Parameters: valid_words (List[str]): A list of non-empty strings containing the valid words. text (str): A string representing the target text. Returns: List[str]: A list of words from the target text that are not found in the valid words. # Convert the list of valid words to a set for O(1) average time complexity lookups valid_word_set = set(valid_words) # Split the text into words words_in_text = text.split() # List to hold misspelled words misspelled_words = [] # Check every word in the text against the valid words set for word in words_in_text: if word not in valid_word_set: misspelled_words.append(word) return misspelled_words"},{"question":"# Problem: String Transformation with Vowel Removal Given a need to reformat strings by removing certain characters and maintaining order, your task is to modify the provided `transform_str` function to handle specific transformation rules. Implement it such that: 1. All vowel characters (both uppercase and lowercase) are removed from the input string. 2. The relative order of the remaining characters is preserved. 3. Ensure that non-alphabetic characters are unaffected and retain their positions in the string. # Task Write a function `transform_str(input_str: str) -> str` which removes all vowel characters from the input string while preserving the order and position of remaining characters. # Input * `input_str` (str): A string that can contain letters, digits, punctuation, and whitespaces. # Output * (str): A string with all vowel characters removed. # Constraints * The input string\'s length will not exceed 1000 characters. * You may assume all characters in the string are ASCII. # Example ```python def transform_str(input_str: str) -> str: # Implement this function pass # Example Usage print(transform_str(\\"hello world!\\")) # Output: \\"hll wrld!\\" print(transform_str(\\"There are 3 apples!\\")) # Output: \\"Thr r 3 ppls!\\" print(transform_str(\\"AEIOU aeioU\\")) # Output: \\" \\" print(transform_str(\\"\\")); # Output: \\"\\" ``` # Additional Information 1. You must consider vowels as the characters \'a\', \'e\', \'i\', \'o\', \'u\' and their uppercase counterparts \'A\', \'E\', \'I\', \'O\', \'U\'. 2. Handle empty strings gracefully, returning an empty string. 3. Ensure that punctuation, digits, and whitespace characters remain unaffected in their original positions.","solution":"def transform_str(input_str: str) -> str: Removes all vowels from the input string. Args: input_str (str): The input string. Returns: str: The string with all vowel characters removed. vowels = \\"aeiouAEIOU\\" return \'\'.join([char for char in input_str if char not in vowels])"},{"question":"# Question: Valid Anagram Given two strings `s` and `t`, write a function to determine if `t` is an anagram of `s`. An anagram is a word formed by rearranging the letters of another, such as `fluster` and `restful`, using all the original letters exactly once. Function Signature ```python def is_anagram(s: str, t: str) -> bool: @input: s, t (Two strings comprised of lowercase English letters) @return: A boolean indicating whether t is an anagram of s # Input * `s`: A string of length `n` composed of lowercase English letters. * `t`: A string of length `n` composed of lowercase English letters. # Output * A boolean `True` if t is an anagram of s, and `False` otherwise. # Example ```python >>> s = \\"anagram\\" >>> t = \\"nagaram\\" >>> is_anagram(s, t) True ``` ```python >>> s = \\"rat\\" >>> t = \\"car\\" >>> is_anagram(s, t) False ``` # Constraints * The length of the strings `s` and `t` does not exceed 10^5 characters. * Both strings are guaranteed to have the same length. # Notes * Consider efficient ways to count character occurrences. * Focus on performance and correctness. * Handle edge cases such as empty strings appropriately. # Hints * Using data structures like hash maps or arrays could be beneficial to track character counts. * Ensure your solution checks all possible input scenarios effectively.","solution":"def is_anagram(s: str, t: str) -> bool: Determine if t is an anagram of s. :param s: First string :param t: Second string :return: True if t is an anagram of s, False otherwise if len(s) != len(t): return False # Utilize a counter to count occurrences of each character from collections import Counter # Compare character counts of both strings return Counter(s) == Counter(t)"},{"question":"# Coding Challenge: Calculate Minimum Cost of Travel Scenario: Allroads Travel Agency prepares trips for tourists by connecting various cities in their itinerary. Each connection between two cities has a specific travel cost. The goal for the agency is to minimize the total travel cost for a given list of cities to be visited, ensuring that the cities form a continuous route. You are given a list of cities and the travel costs between each pair of cities. Develop a solution to find the minimum cost to travel through all the given cities. The solution should use an optimal route and include every city at least once. Task: Implement a function `min_travel_cost` that takes the number of cities, the list of connections between cities, and the associated travel costs as inputs. The function should return the minimum travel cost to visit all the cities. Function Signature: ```python def min_travel_cost(n: int, connections: list[tuple[int, int, int]]) -> int: ``` Input: - `n` (int): The number of cities. - `connections` (list of tuples of int): Each tuple (i, j, cost) represents a travel cost `cost` between city `i` and city `j`. Output: - `int`: The minimum travel cost to visit all the given cities. Constraints: - `2 <= n <= 1000` (number of cities) - `1 <= len(connections) <= 10000` (number of connections) - `1 <= cost <= 10000` (travel cost between cities) - City IDs (nodes) are numbered from 0 to n-1. Example: ```python n = 5 connections = [(0, 1, 4), (0, 2, 7), (1, 2, 1), (1, 3, 5), (2, 3, 2), (3, 4, 3)] print(min_travel_cost(n, connections)) # Expected Output: 10 ``` Requirements: - Use Prim\'s or Kruskal\'s algorithm to determine the minimum cost spanning tree which ensures minimal travel cost. - Ensure that your function runs efficiently with the provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like a sparse graph with the minimum number of connections, and ensure all given cities are visited in the cheapest possible manner. - You can assume that the graph is connected, and there is at least one way to travel between all cities.","solution":"def min_travel_cost(n: int, connections: list[tuple[int, int, int]]) -> int: Return the minimum travel cost to visit all the given cities. Args: n (int): Number of cities. connections (list of tuples of int): Each tuple (i, j, cost) represents a travel cost `cost` between city `i` and city `j`. Returns: int: Minimum travel cost to visit all the given cities. from heapq import heappop, heappush # Build the graph graph = {i: [] for i in range(n)} for u, v, cost in connections: graph[u].append((cost, v)) graph[v].append((cost, u)) # Prim\'s Algorithm total_cost = 0 visited = set() min_heap = [(0, 0)] # Start with node 0, cost 0 while len(visited) < n: cost, u = heappop(min_heap) if u in visited: continue total_cost += cost visited.add(u) for edge_cost, v in graph[u]: if v not in visited: heappush(min_heap, (edge_cost, v)) return total_cost"},{"question":"# Balanced Binary Tree Check A binary tree is balanced if the depth of the two subtrees of every node never differs by more than 1. You are tasked with implementing a function that determines if a given binary tree is balanced. Function Signature ```python def is_balanced(root: \'TreeNode\') -> bool: pass ``` Class Definition for Tree Node ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` Input * `root` (TreeNode): The root node of the binary tree. Output * `result` (bool): A boolean value indicating whether the binary tree is balanced (`True`) or not (`False`). Constraints * The number of nodes in the tree will be in the range `[0, 10^4]`. * The depth of nodes\' values are of type `int`. Performance Requirements * The time complexity should be O(n) where n is the number of nodes. * The space complexity should be O(h), where h is the height of the tree due to the recursive call stack. Example ```python # Example 1: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.right = TreeNode(6) root.left.left.left = TreeNode(7) print(is_balanced(root)) # Output: False (since one subtree has height 4 and another has height 2) # Example 2: root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) print(is_balanced(root)) # Output: True (since every subtree heights differ by at most 1) ``` # Prompt Write a Python function `is_balanced(root: \'TreeNode\') -> bool` that checks if a given binary tree is balanced. Utilize a depth-first search approach and ensure the function adheres to the performance requirements. Include robust error handling and an efficient implementation to meet the given constraints.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: def check_balance(node: TreeNode): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balanced _, is_tree_balanced = check_balance(root) return is_tree_balanced"},{"question":"# Problem Statement You are given a list of strings and an integer `k`. Your task is to implement a function that returns the `k` most frequent strings in the list. The returned result should be a list of the `k` most frequent strings sorted in descending order of their frequency. In case of a tie in frequency, the order should be based on lexicographical (dictionary) order. # Implementation Details * Function Name: `top_k_frequent_strings` * Input: A list of strings `words` (e.g., `[\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"]`) and an integer `k` (e.g., `2`) * Output: A list of strings containing the `k` most frequent strings (e.g., `[\\"i\\", \\"love\\"]`) # Constraints 1. Assume the list of strings can have up to 10^4 elements. 2. The strings will consist of lowercase English letters only. 3. The integer `k` will be between 1 and the number of unique strings in the input list. # Example ```python def top_k_frequent_strings(words: list[str], k: int) -> list[str]: # Your implementation here # Test Cases print(top_k_frequent_strings([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2)) # Expected: [\\"i\\", \\"love\\"] print(top_k_frequent_strings([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 3)) # Expected: [\\"the\\", \\"is\\", \\"sunny\\"] print(top_k_frequent_strings([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"a\\"], 1)) # Expected: [\\"a\\"] print(top_k_frequent_strings([\\"x\\", \\"y\\", \\"z\\", \\"y\\", \\"z\\", \\"x\\", \\"z\\"], 2)) # Expected: [\\"z\\", \\"y\\"] ``` **Restrictions**: * Aim for a time complexity close to O(N log N). * Avoid using libraries that directly solve the problem. # Notes 1. Consider using a dictionary to track the frequency of each string. 2. Use sorting or a heap to get the top `k` frequent strings efficiently. 3. Carefully handle cases with ties in frequency to ensure the correct order based on lexicographical comparison.","solution":"from collections import Counter import heapq def top_k_frequent_strings(words, k): Returns the k most frequent strings in the given list. In case of a tie, strings are ordered lexicographically. # Count the frequency of each word frequency = Counter(words) # Create a heap of the frequency counted words heap = [(-count, word) for word, count in frequency.items()] # Convert list to a heap heapq.heapify(heap) # Extract the k most frequent words from the heap top_k_words = [heapq.heappop(heap)[1] for _ in range(k)] return top_k_words"},{"question":"# Count Distinct Elements in Every Window You are given an array `arr` of integers and an integer `k`. Write a function `count_distinct_elements` that returns a list containing the count of distinct elements in every window of size `k` in the given array. Input * `arr`: A list of integers where `1 <= len(arr) <= 10^5` and `1 <= arr[i] <= 10^5` * `k`: An integer where `1 <= k <= len(arr)` Output * A list of integers, where each integer represents the count of distinct elements in each window of size `k`. Constraints * Aim to achieve an efficient time complexity, ideally O(n). Example ```python >>> count_distinct_elements([1, 2, 1, 3, 4, 2, 3], 4) [3, 4, 4, 3] >>> count_distinct_elements([1, 2, 4, 4], 2) [2, 2, 1] >>> count_distinct_elements([1, 1, 1, 1], 1) [1, 1, 1, 1] ``` Implementation Note Ensure that your solution handles edge cases appropriately, such as arrays where all elements are the same or `k` equals the length of `arr`.","solution":"def count_distinct_elements(arr, k): Returns a list containing the count of distinct elements in every window of size k in the given array. from collections import defaultdict n = len(arr) if k > n or k == 0: return [] distinct_count = [] freq_map = defaultdict(int) distinct_elements = 0 for i in range(k): if freq_map[arr[i]] == 0: distinct_elements += 1 freq_map[arr[i]] += 1 distinct_count.append(distinct_elements) for i in range(k, n): if freq_map[arr[i - k]] == 1: distinct_elements -= 1 freq_map[arr[i - k]] -= 1 if freq_map[arr[i]] == 0: distinct_elements += 1 freq_map[arr[i]] += 1 distinct_count.append(distinct_elements) return distinct_count"},{"question":"# Anagram Grouping Problem Statement An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Given a list of strings, group the anagrams together and return them as a list of lists. Each list within the list contains anagrams. # Input * A list of strings ( text{words} ) where each string length is between ( 1 ) and ( 100 ), and the number of strings in the list is between ( 1 ) and ( 1000 ). # Output * Return a list of lists where each sublist contains strings that are anagrams of each other. # Constraints * All strings are composed of lowercase English letters. * The solution must run efficiently for all inputs within the constraints. # Examples ```python # Example 1 Input: [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] Output: [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] Explanation: \\"eat\\", \\"tea\\", and \\"ate\\" are anagrams, so they are grouped together. \\"tan\\" and \\"nat\\" are anagrams, and \\"bat\\" stands alone. # Example 2 Input: [\\"\\"] Output: [[\\"\\"]] Explanation: The input contains only one empty string, so it forms a group by itself. # Example 3 Input: [\\"a\\"] Output: [[\\"a\\"]] Explanation: The input contains only one string \\"a\\", so it forms a group by itself. ``` # Task Write a function `group_anagrams(words: List[str]) -> List[List[str]]` that implements the above requirements. # Implementation ```python from collections import defaultdict def group_anagrams(words: List[str]) -> List[List[str]]: anagram_map = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values()) ```","solution":"from collections import defaultdict from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Group strings into lists of anagrams. Parameters: words (List[str]): List of strings to be grouped. Returns: List[List[str]]: A list of lists containing anagrams. anagram_map = defaultdict(list) for word in words: sorted_word = \'\'.join(sorted(word)) anagram_map[sorted_word].append(word) return list(anagram_map.values())"},{"question":"# Problem Statement You are tasked with developing a basic encryption and decryption system using a simple substitution cipher. Each letter in the plaintext is \'shifted\' a certain number of places down (or up) the alphabet. This is a variation of the Caesar cipher that needs to handle both uppercase and lowercase letters while leaving non-alphabetic characters unchanged. # Requirements 1. Implement two functions: `encrypt` and `decrypt`. * `encrypt` should take a string `text` and an integer `shift` and return the encrypted text. * `decrypt` should take an encrypted string `text` and an integer `shift` and return the original plaintext. 2. Both functions should: * Maintain the case of the alphabetic characters. * Ignore and leave unchanged any non-alphabetic characters. * Be able to handle negative shifts (shifting leftwards in the alphabet). * Use the Latin alphabet (A-Z, a-z) without wrapping to other character sets. # Input Format ```python encrypt(text: str, shift: int) -> str decrypt(text: str, shift: int) -> str ``` # Output Format * Both functions should return strings. # Constraints * Only valid characters in `text` are printable ASCII characters. * `shift` can be any integer (positive or negative). # Example ```python encrypted_message = encrypt(\\"Hello, World!\\", 3) print(encrypted_message) decrypted_message = decrypt(encrypted_message, 3) print(decrypted_message) ``` *Expected Output*: ``` Khoor, Zruog! Hello, World! ``` # Notes * Ensure that punctuation marks, spaces, and any special characters in the input string remain unchanged in the output. * Remember to handle both uppercase and lowercase letters separately to maintain their cases.","solution":"def encrypt(text, shift): Encrypts the text by shifting alphabetical characters by a given shift amount. result = [] for char in text: if char.isalpha(): if char.islower(): result.append(chr((ord(char) - ord(\'a\') + shift) % 26 + ord(\'a\'))) elif char.isupper(): result.append(chr((ord(char) - ord(\'A\') + shift) % 26 + ord(\'A\'))) else: result.append(char) return \'\'.join(result) def decrypt(text, shift): Decrypts the text by reversing the shift alphabetical characters by a given shift amount. return encrypt(text, -shift)"},{"question":"# String Compression Context You are implementing a basic string compression algorithm where consecutive repeated characters are replaced with the character followed by the number of repetitions. This kind of algorithm can help reduce the storage space or transmission size in data processing applications. However, if the compressed string is not smaller than the original string, the original string is returned. # Task Write a function `compress_string(data: str) -> str` that compresses the given string using the described algorithm. # Input & Output * **Input**: `data` - a string of length `1 <= len(data) <= 1000`, consisting of lowercase alphabetical characters. * **Output**: A compressed string if it results in a smaller output, otherwise the original string. # Constraints * The input will always be a non-empty string. * Case sensitivity does not matter as the input consists only of lowercase letters. # Example ```python >>> compress_string(\'aabcccccaaa\') \'a2b1c5a3\' >>> compress_string(\'abcdef\') \'abcdef\' >>> compress_string(\'zzz\') \'z3\' ``` # Requirements 1. Traverse the string and count the occurrences of each character consecutively. 2. Build the compressed string as you process the character counts. 3. Compare the length of the compressed string with the original and return the one that is shorter. 4. Ensure to handle edge cases like a single character and repeated characters correctly. # Notes 1. Carefully handle the transition from one character to another and ensure that counts are reset appropriately. 2. Optimize the function to ensure it runs efficiently for longer strings up to the maximum length.","solution":"def compress_string(data: str) -> str: Compresses the given string using the described algorithm where consecutive repeated characters are replaced with the character followed by the number of repetitions. Returns the original string if the compressed version is not smaller. if not data: return data compressed = [] count = 1 for i in range(1, len(data)): if data[i] == data[i-1]: count += 1 else: compressed.append(f\\"{data[i-1]}{count}\\") count = 1 compressed.append(f\\"{data[-1]}{count}\\") compressed_str = \\"\\".join(compressed) return compressed_str if len(compressed_str) < len(data) else data"},{"question":"# Graph Traversal Implementations Your task is to implement a set of fundamental graph traversal methods as functions within a Python class. The traversals to be implemented include Depth-First Search (DFS), Breadth-First Search (BFS), and detection of cyclic graphs. Ensure that your implementation handles edge cases, validates input types, and raises appropriate errors when constraints are violated. # Specifications: * **Class Name**: `GraphTraversal` * **Methods**: - `dfs(graph, start)`: Traverses the graph using Depth-First Search starting from the specified vertex. - `bfs(graph, start)`: Traverses the graph using Breadth-First Search starting from the specified vertex. - `is_cyclic(graph)`: Determines if the graph contains any cycles. # Constraints: * The input graph will be provided as an adjacency list in the form of a dictionary where keys are vertex identifiers and values are lists of adjacent vertices. * The graph can be either directed or undirected. * Methods should raise appropriate Python exceptions for invalid inputs: - `TypeError` if inputs are not in the correct format or if vertices in the adjacency list are not hashable. - `ValueError` if the start vertex for DFS or BFS does not exist in the graph. # Example Usage: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } traversals = GraphTraversal() # Depth-First Search dfs_result = traversals.dfs(graph, \'A\') print(dfs_result) # Output: [\'A\', \'B\', \'D\', \'E\', \'F\', \'C\'] # Breadth-First Search bfs_result = traversals.bfs(graph, \'A\') print(bfs_result) # Output: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] # Cycle Detection cycle_result = traversals.is_cyclic(graph) print(cycle_result) # Output: False ``` # Performance Requirements: * Operations should be optimal for graphs containing up to 10,000 vertices and 100,000 edges. * Ensure the implementation uses an efficient approach to manage space and time complexity, especially for cyclic detection which should ideally run in linear time with respect to the number of vertices and edges. # Implementation: Implement the `GraphTraversal` class with the specified methods. Ensure each method validates its inputs and performs the required operations accurately. Include robust error handling, and validate edge cases such as disconnected graphs or graphs with no vertices.","solution":"class GraphTraversal: def dfs(self, graph, start): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") if start not in graph: raise ValueError(\\"The start vertex does not exist in the graph.\\") visited = set() result = [] def _dfs(v): if v not in visited: visited.add(v) result.append(v) for neighbor in graph.get(v, []): _dfs(neighbor) _dfs(start) return result def bfs(self, graph, start): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") if start not in graph: raise ValueError(\\"The start vertex does not exist in the graph.\\") visited = set() queue = [start] result = [] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend([neighbor for neighbor in graph.get(vertex, []) if neighbor not in visited]) return result def is_cyclic(self, graph): if not isinstance(graph, dict): raise TypeError(\\"Graph should be a dictionary.\\") visited = set() rec_stack = set() def _is_cyclic(v): visited.add(v) rec_stack.add(v) for neighbor in graph.get(v, []): if neighbor not in visited and _is_cyclic(neighbor): return True elif neighbor in rec_stack: return True rec_stack.remove(v) return False for vertex in graph: if vertex not in visited: if _is_cyclic(vertex): return True return False"},{"question":"# Circular List Node Sum You are given a circular linked list where each node contains an integer value. Write a function to calculate the sum of all the node values in the circular linked list. A circular linked list is similar to a regular linked list except the last node\'s next pointer points back to the first node, forming a loop. Function Specification Implement the function: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def circular_list_sum(head: ListNode) -> int: Given the head of a circular linked list, this function calculates the sum of all the node values. Parameters: head (ListNode): The starting node of the circular linked list. Returns: int: The sum of all node values in the circular linked list. Raises: ValueError: If the input list is empty. ``` Input - `head`: The starting node of a non-empty circular linked list. Output - An integer representing the sum of all node values in the circular linked list. Constraints - The list is guaranteed to be circular and will contain at least one node. - The node values are integers. - Nodes may contain negative values. Examples ```python # Example 1: # List: 3 -> 5 -> 2 -> 7 -> 3 (circular) node1 = ListNode(3) node2 = ListNode(5) node3 = ListNode(2) node4 = ListNode(7) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node1 circular_list_sum(node1) # returns 17 # Example 2: # List: -1 -> 4 -> -3 -> 8 -> -1 (circular) node1 = ListNode(-1) node2 = ListNode(4) node3 = ListNode(-3) node4 = ListNode(8) node1.next = node2 node2.next = node3 node3.next = node4 node4.next = node1 circular_list_sum(node1) # returns 8 ``` # Performance Requirements The function should complete its task with a linear time complexity, O(n), where n is the number of nodes in the circular linked list. - Ensure that you account for edge cases, such as handling a list with a single node. Also, appropriate error handling should be implemented, raising a `ValueError` if the input list is unexpectedly invalid.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def circular_list_sum(head: ListNode) -> int: if not head: raise ValueError(\\"The input list cannot be empty.\\") total_sum = 0 current = head while True: total_sum += current.val current = current.next if current == head: break return total_sum"},{"question":"# Problem Statement You are required to implement a function that checks if a given string is a valid Roman numeral and converts it into an integer. # Function Signature ```python def roman_to_int(input_str: str) -> int: pass ``` # Input - `input_str` (str): The string representing the Roman numeral to be converted. # Output - `int`: Return the integer representation of the Roman numeral if it is valid, or raise an appropriate exception otherwise. # Constraints 1. `input_str` length is between 1 and 15 characters. 2. A valid Roman numeral must: - Only contain the characters: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. - Follow the rules of Roman numeral notation without any invalid sequences. # Requirements - Your function should return an integer equivalent of the Roman numeral. - Handle invalid input types or formats by raising appropriate exceptions. - Ensure that the execution time is efficient, ideally linear with respect to the input length. # Examples ```python # Valid Roman numeral print(roman_to_int(\\"XIV\\")) # Output: 14 # Another valid Roman numeral print(roman_to_int(\\"MCMXCIV\\")) # Output: 1994 # Invalid Roman numeral with incorrect sequence try: roman_to_int(\\"IIII\\") except ValueError as e: print(e) # Output: \\"Invalid Roman numeral format\\" # Invalid input format try: roman_to_int(123) except ValueError as e: print(e) # Output: \\"Expected str as input, found <class \'int\'>\\" # Non-Roman numeral string input try: roman_to_int(\\"ABCD\\") except ValueError as e: print(e) # Output: \\"Invalid Roman numeral format\\" ``` # Evaluation Criteria - Correctness: The function should correctly convert Roman numerals into their integer equivalents. - Efficiency: The function should run efficiently, ideally in linear time relative to the input length. - Robustness: The function must handle various invalid inputs gracefully by raising appropriate exceptions.","solution":"def roman_to_int(input_str: str) -> int: if not isinstance(input_str, str): raise ValueError(f\\"Expected str as input, found {type(input_str)}\\") roman_numerals = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Validating input for char in input_str: if char not in roman_numerals: raise ValueError(\\"Invalid Roman numeral format\\") previous_value = 0 total = 0 for char in reversed(input_str): current_value = roman_numerals[char] if current_value < previous_value: total -= current_value else: total += current_value previous_value = current_value return total"},{"question":"# Letter Frequency Counter Text analysis is a common task in natural language processing and data science. One of the most basic forms of text analysis is counting the frequency of each letter in a given string. Your task is to implement a function that computes the frequency of each letter in a given text and returns a dictionary with letters as keys and their corresponding frequencies as values. Function Signature ```python def letter_frequency(text: str) -> dict: pass ``` Input - **text**: A string containing the text to be analyzed. The text may contain letters, digits, punctuation, and whitespace. Output - A dictionary where the keys are letters (lowercase) and the values are the corresponding frequencies of those letters in the input text. Constraints - The input string text will have a maximum length of 10,000 characters. - Only alphabetic characters should be counted (ignore case and other characters). - The function should be case-insensitive (i.e., \'a\' and \'A\' should be considered the same letter). # Sample Input ```python text = \\"Hello World!\\" ``` # Sample Output ```python { \'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1 } ``` # Additional Information * Make sure to ignore non-alphabetic characters. * The function should efficiently handle the input string and produce the result with optimal performance. * The result should be returned in a case-insensitive manner; both \'a\' and \'A\' count towards the same letter frequency. * The order of the dictionary keys does not matter. With this question, you can test the candidate\'s understanding of basic string processing and dictionary data structures in Python, while ensuring alignment with the style, complexity, and scope of the original question set.","solution":"def letter_frequency(text: str) -> dict: This function takes a text and returns a dictionary with the frequency of each letter in the text. Non-alphabetic characters are ignored, and the counting is case-insensitive. Args: text (str): The input text. Returns: dict: A dictionary with letters as keys and their corresponding frequencies as values. frequency_dict = {} for char in text.lower(): if char.isalpha(): if char in frequency_dict: frequency_dict[char] += 1 else: frequency_dict[char] = 1 return frequency_dict"},{"question":"# Binary Search with Error Handling You are given a SortedList class which is designed to store a sorted list of integers and provide various methods for list manipulation. However, the current implementation of the binary search method in the SortedList class is incomplete and does not handle certain error cases properly. Your task is to complete and improve the SortedList class to: 1. Ensure binary search is implemented correctly and efficient. 2. Handle cases where the list is empty. 3. Return appropriate messages or values when the searched element is not found. Below is the modified SortedList class and the key areas you need to work on: ```python class SortedList: def __init__(self): self.list = [] def add_element(self, element: int) -> None: self.list.append(element) self.list.sort() def binary_search(self, element: int) -> str: if not self.list: return \\"Error: List is empty\\" left, right = 0, len(self.list) - 1 while left <= right: mid = (left + right) // 2 if self.list[mid] == element: return f\\"Element {element} found at index {mid}\\" elif self.list[mid] < element: left = mid + 1 else: right = mid - 1 return f\\"Element {element} not found\\" if __name__ == \\"__main__\\": s_list = SortedList() s_list.add_element(10) s_list.add_element(20) s_list.add_element(5) s_list.add_element(7) print(s_list.list) print(s_list.binary_search(7)) print(s_list.binary_search(15)) print(s_list.binary_search(10)) empty_list = SortedList() print(empty_list.binary_search(7)) ``` # Implementation Requirements: 1. **Binary Search Implementation**: Implement the `binary_search` method using an iterative approach. 2. **Handle Empty List**: Modify the `binary_search` method to handle cases when the list is empty and return a meaningful error message. 3. **Element Not Found**: Ensure the binary search returns an appropriate message when the element is not found in the list. # Input: - Elements are added to the list using the `add_element` method. - The `binary_search` method will be called with an integer to search for in the list. # Output: - A string indicating the index of the found element, or an error message if the element is not found or if the list is empty. # Constraints: - The number of elements in the list may range from 0 to 1000. - Elements in the list will be integers ranging from -10^6 to 10^6. - The `add_element` method ensures that the list is sorted after each addition. # Example Input: ```python s_list = SortedList() s_list.add_element(10) s_list.add_element(20) s_list.add_element(5) s_list.add_element(7) print(s_list.list) print(s_list.binary_search(7)) print(s_list.binary_search(15)) print(s_list.binary_search(10)) empty_list = SortedList() print(empty_list.binary_search(7)) ``` Output: ``` [5, 7, 10, 20] Element 7 found at index 1 Element 15 not found Element 10 found at index 2 Error: List is empty ``` # Explanation: - The output demonstrates that the list is kept sorted and the binary search method is capable of finding elements or providing error messages appropriately.","solution":"class SortedList: def __init__(self): self.list = [] def add_element(self, element: int) -> None: self.list.append(element) self.list.sort() def binary_search(self, element: int) -> str: if not self.list: return \\"Error: List is empty\\" left, right = 0, len(self.list) - 1 while left <= right: mid = (left + right) // 2 if self.list[mid] == element: return f\\"Element {element} found at index {mid}\\" elif self.list[mid] < element: left = mid + 1 else: right = mid - 1 return f\\"Element {element} not found\\" if __name__ == \\"__main__\\": s_list = SortedList() s_list.add_element(10) s_list.add_element(20) s_list.add_element(5) s_list.add_element(7) print(s_list.list) print(s_list.binary_search(7)) print(s_list.binary_search(15)) print(s_list.binary_search(10)) empty_list = SortedList() print(empty_list.binary_search(7))"},{"question":"# Question Implement a function `validate_expression` that checks if a mathematical expression containing parenthesis is valid. The expression contains only digits, basic arithmetic operators (`+`, `-`, `*`, `/`) and parentheses (`(`, `)`). The expression is valid if every opening parenthesis has a corresponding closing parenthesis and the operators are used correctly. The function signature should be: ```python def validate_expression(expression: str) -> bool: pass ``` # Input - `expression`: A string representing a mathematical expression containing digits, basic arithmetic operators, and parentheses. # Output - Returns `True` if the expression is valid, and `False` otherwise. # Constraints - The length of the input string will be `1 <= len(expression) <= 10^5`. # Requirements - The function must run efficiently within the constraints. - Operators must be placed correctly (e.g., not consecutive operators, no operator at the start or end unless it\'s preceeded by a valid operand or parenthesis). # Example ```python expression = \\"(1+2)*(3/4)-(5*(6))\\" print(validate_expression(expression)) # Output: True expression = \\"((1+2*3\\" print(validate_expression(expression)) # Output: False expression = \\"1++2\\" print(validate_expression(expression)) # Output: False expression = \\"10/2+5*(4-3)\\" print(validate_expression(expression)) # Output: True ``` **Hint**: Use a stack to keep track of parentheses and ensure operators are used properly within the expression.","solution":"def validate_expression(expression: str) -> bool: Validates if the given expression containing digits, basic arithmetic operators, and parentheses is valid. Returns True if the expression is valid, and False otherwise. stack = [] valid_chars = set(\'0123456789+-*/()\') operators = set(\'+-*/\') last_char = None for char in expression: if char not in valid_chars: return False if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() if char in operators: if last_char in operators or last_char is None: return False last_char = char if stack: return False if last_char in operators: return False return True"},{"question":"# Question: Implement a Graph Traversal Algorithm Context Graph traversal algorithms are fundamental in computer science for exploring graph structures. One of the popular algorithms is Depth-First Search (DFS), which traverses the graph in depthwards motion, utilizing a stack-based approach. You are required to implement a DFS traversal to explore all reachable nodes from a given starting node. Problem Description Write a function `depth_first_search(graph: dict[int, list[int]], start_node: int) -> list[int]` that performs a Depth-First Search on the input graph starting from the `start_node`. # Input: - `graph`: A dictionary where keys are integers representing nodes, and values are lists of integers representing adjacent nodes. - `start_node`: An integer representing the starting node for the DFS traversal. # Output: - A list of integers representing the nodes in the order they were visited during the DFS traversal. # Constraints: 1. The graph is represented as an adjacency list. 2. The `start_node` is guaranteed to be valid and exists within the graph. 3. The graph may include cycles. 4. The DFS traversal must visit each node exactly once. Example Usage ```python >>> graph = { ... 0: [1, 2], ... 1: [0, 3, 4], ... 2: [0], ... 3: [1], ... 4: [1, 5], ... 5: [4] ... } >>> depth_first_search(graph, 0) [0, 1, 3, 4, 5, 2] >>> depth_first_search(graph, 3) [3, 1, 0, 2, 4, 5] >>> depth_first_search(graph, 5) [5, 4, 1, 0, 2, 3] ``` Implementation Guidelines - Use either an iterative approach with a stack or a recursive approach for DFS. - Ensure every node is visited exactly once. - The order of traversal in the adjacency list should be preserved. - Handle cycles in the graph without entering into infinite loops.","solution":"def depth_first_search(graph, start_node): Perform a DFS traversal starting from start_node. :param graph: dict - An adjacency list representing the graph :param start_node: int - The starting node for DFS :return: list[int] - List of nodes in the order they were visited visited = set() result = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.add(node) result.append(node) # Reverse to maintain the order of traversal as per adjacency list stack.extend(reversed(graph[node])) return result"},{"question":"# Simple Text Compression You are tasked with implementing a simple text compression method using a Run-Length Encoding (RLE) algorithm. This algorithm compresses a string by replacing sequences of the same character appearing consecutively by that character followed by the length of the sequence. Problem Statement Implement two functions `compress` and `decompress` to compress and decompress strings using the Run-Length Encoding technique. 1. **compress(message: str) -> str**: - **Input**: - `message`: A string containing the input message. - **Output**: Returns the compressed message as a string. 2. **decompress(message: str) -> str**: - **Input**: - `message`: A string containing the compressed message. - **Output**: Returns the original message as a string. Constraints * The input strings can contain uppercase and lowercase English letters and digits. * The input string for compression may not necessarily include any characters that appear more than once consecutively. Example ```python assert compress(\'aaabbc\') == \'a3b2c1\' assert decompress(\'a3b2c1\') == \'aaabbc\' assert compress(\'a\') == \'a1\' assert decompress(\'a1\') == \'a\' ``` Function Definitions ```python def compress(message: str) -> str: pass def decompress(message: str) -> str: pass ``` # Requirements - Use an appropriate algorithm to implement both functions. - Ensure your functions handle edge cases as specified in the analysis. - Efficiency is important; aim for O(n) time complexity for both functions.","solution":"def compress(message: str) -> str: Compresses the input message using Run-Length Encoding (RLE). Args: message (str): The input message to compress. Returns: str: The compressed message. if not message: return \\"\\" compressed = [] count = 1 for i in range(1, len(message)): if message[i] == message[i-1]: count += 1 else: compressed.append(message[i-1] + str(count)) count = 1 compressed.append(message[-1] + str(count)) return \'\'.join(compressed) def decompress(message: str) -> str: Decompresses the input message that was compressed using Run-Length Encoding (RLE). Args: message (str): The compressed message to decompress. Returns: str: The original (decompressed) message. if not message: return \\"\\" decompressed = [] i = 0 while i < len(message): char = message[i] count = [] i += 1 while i < len(message) and message[i].isdigit(): count.append(message[i]) i += 1 decompressed.append(char * int(\'\'.join(count))) return \'\'.join(decompressed)"},{"question":"# Coding Assessment Question Context You are developing a data visualization library that allows users to generate various statistical plots. One of the features is to create histograms for different types of data. Histograms are graphical representations of data distribution, typically showing the frequency of data points within certain ranges or bins. To simplify user interaction, you plan to create a function that takes a list of numerical data and returns the frequencies of data points within a specified number of bins. Task Implement a function that takes a list of numerical data and the number of bins and returns the frequency of data points in each bin. The formulas required are: * **Bin Width (W)**: ( W = frac{text{max}(data) - text{min}(data)}{text{num_bins}} ) * **Bin index for a data point x (i)**: ( i = leftlfloor frac{x - text{min}(data)}{W} rightrfloor ) Requirements * **Function Name**: - `compute_histogram(data: list, num_bins: int) -> list` * **Input**: - `data`: A list of floats/numbers. - `num_bins`: An integer representing the number of bins. * **Output**: - A list of integers representing the counts of data points in each bin. * **Constraints**: - `num_bins` must be a positive integer greater than 0. - `data` must contain at least one number; raise a `ValueError` if not. - The bin edges should be inclusive for the lower bin edges and exclusive for the upper bin edges, except for the last bin. * **Performance**: - The implementation should be efficient, with a time complexity of ( O(n) ), where ( n ) is the number of data points. * **Tests**: - Include tests to validate your solution. For example: ```python >>> compute_histogram([1, 2, 3, 4, 5], 2) [2, 3] >>> compute_histogram([1, 2.5, 3, 4.7, 2.8, 5], 3) [1, 3, 2] >>> compute_histogram([7, 8, 9], 0) Traceback (most recent call last): ... ValueError: Number of bins must be a positive integer. >>> compute_histogram([], 5) Traceback (most recent call last): ... ValueError: Data list must contain at least one number. ``` Bonus Extend your solution to include a function `describe_bins(data: list, num_bins: int) -> dict`, which returns a dictionary containing the bin edges and counts in each bin.","solution":"import math def compute_histogram(data, num_bins): Computes the histogram of the given data. Args: data (list of float/integers): List of numerical data points. num_bins (int): Number of bins. Returns: list of int: Counts of data points in each bin. if num_bins <= 0: raise ValueError(\\"Number of bins must be a positive integer.\\") if not data: raise ValueError(\\"Data list must contain at least one number.\\") min_val = min(data) max_val = max(data) bin_width = (max_val - min_val) / num_bins if bin_width == 0: # If all data points are the same, they fall into one bin return [len(data)] + [0] * (num_bins - 1) bins = [0] * num_bins for x in data: # Compute the bin index bin_index = math.floor((x - min_val) / bin_width) # Adjust last bin index to be inclusive if bin_index == num_bins: bin_index -= 1 bins[bin_index] += 1 return bins"},{"question":"# Coding Assessment Question **Scenario**: You are working on a data processing application that requires efficient handling of JSON-like structures. One of the tasks involves searching deeply nested dictionaries to find the value associated with a given key. **Task**: Write a function to search for a given key in a deeply nested dictionary. The function should return the value associated with the key if it exists, and `None` if the key is not found. Ensure that your implementation handles large nested structures without causing stack overflow or excessive memory usage. **Function Signature**: ```python def find_nested_key(data: dict, key: str) -> any: Search for a specific key in a deeply nested dictionary and return its value. :param data: dict - Input nested dictionary. :param key: str - Key to search for. :return: any - Value associated with the key, or None if the key is not found. ``` **Input**: - A dictionary `data` containing nested dictionaries, lists, and primitive data types (0 <= size of data <= 10^6). - A string `key` representing the key to search for. **Output**: - The value associated with the key if it exists, otherwise `None`. **Constraints**: - The function should correctly handle empty dictionaries. - Implement an efficient search algorithm that can handle deeply nested dictionaries. **Example**: ```python input_data = { \\"a\\": 1, \\"b\\": { \\"c\\": 2, \\"d\\": { \\"e\\": 3 } } } assert find_nested_key(input_data, \'e\') == 3 assert find_nested_key(input_data, \'c\') == 2 assert find_nested_key(input_data, \'f\') == None input_data_2 = { \\"x\\": { \\"y\\": { \\"z\\": { \\"target\\": 42 } }, \\"w\\": 7 } } assert find_nested_key(input_data_2, \'target\') == 42 assert find_nested_key(input_data_2, \'w\') == 7 assert find_nested_key(input_data_2, \'nonexistent\') == None ```","solution":"def find_nested_key(data, key): Search for a specific key in a deeply nested dictionary and return its value. :param data: dict - Input nested dictionary. :param key: str - Key to search for. :return: any - Value associated with the key, or None if the key is not found. stack = [data] while stack: current = stack.pop() if isinstance(current, dict): for k, v in current.items(): if k == key: return v if isinstance(v, dict) or isinstance(v, list): stack.append(v) elif isinstance(current, list): for item in current: stack.append(item) return None"},{"question":"# Problem Statement **Context:** You are required to implement a simplified version of the Dijkstra\'s shortest path algorithm. The algorithm should find the shortest paths from a given source vertex to all other vertices in a weighted, directed graph. Handle various edge cases like unreachable nodes and disconnected graphs. # Task: Implement the `dijkstra` function using the following definition: ```python def dijkstra( graph: dict, start_node: str ) -> dict: ``` # Input: * `graph` (dict): A dictionary where the keys are node names (strings) and the values are dictionaries. The nested dictionaries represent the neighbors and their respective edge weights. * `start_node` (str): The starting node for Dijkstra\'s algorithm. # Output: * A dictionary where the keys are node names and the values are the shortest distance from `start_node` to that node. If a node is not reachable from `start_node`, its value should be `float(\'inf\')`. # Constraints: * Node names will be non-empty strings. * Edge weights will be positive integers. * The graph will have at least one node. * The `start_node` will always be a valid node within the graph. # Example: ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } start_node = \'A\' print(dijkstra(graph, start_node)) # Output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` # Requirements: * Handle edge cases such as unreachable nodes. * Optimize for clarity, efficiency, and correctness. * Include comments and docstrings to explain the logic where necessary. # Notes: * You may re-use and modify any helper functions provided in the initial code snippets for validation purposes. * Ensure all inputs are validated before processing the algorithm to adhere to constraints. **Good luck!**","solution":"import heapq def dijkstra(graph, start_node): Finds the shortest distances from the start_node to all other nodes in the graph. Parameters: graph (dict): A dictionary where keys are node names and values are dictionaries representing neighboring nodes and their respective edge weights. start_node (str): The starting node for the Dijkstra\'s algorithm. Returns: dict: A dictionary where keys are node names and values are the shortest distance from the start_node to that node. If a node is not reachable, its value is float(\'inf\'). # Initialize the distance dictionary with infinity for all nodes except the start node. distances = {node: float(\'inf\') for node in graph} distances[start_node] = 0 # Priority queue to store (distance, node) tuples. priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node has a greater distance than the recorded distance, skip it. if current_distance > distances[current_node]: continue # Check neighbors and update their distances. for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s shorter. if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Task Graphs are a vital data structure in computer science and are used to solve numerous real-world problems. In this task, we will work with directed graphs, where edges have a direction, indicating a one-way relationship between nodes. You are required to implement a function `has_cycle` that determines if a given directed graph contains a cycle. A cycle in a directed graph is a path that starts and ends at the same node, following the direction of the edges. Function Signature ```python def has_cycle(graph: dict) -> bool: ``` # Input * `graph` - A dictionary where the keys are node identifiers (integers or strings) and the values are lists of nodes representing the outgoing edges from the key node. # Output * A boolean value: `True` if the graph contains a cycle, and `False` otherwise. # Constraints * The graph\'s nodes are labeled with integers or strings. * The graph can have up to 100 nodes. * Each node can have 0 or more outgoing edges. * Graph edges and nodes are directed and can form complex structures. # Examples ```python graph1 = {1: [2], 2: [3], 3: [1]} has_cycle(graph1) # Output: True graph2 = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': []} has_cycle(graph2) # Output: False graph3 = {1: [2, 3], 2: [3], 3: []} has_cycle(graph3) # Output: False graph4 = {\'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\']} has_cycle(graph4) # Output: True ``` # Explanation * For `graph1`, there is a cycle: 1 -> 2 -> 3 -> 1. * For `graph2`, there are no cycles as there are no paths that start and end at the same node. * For `graph3`, although there are multiple paths, none of them form a cycle. * For `graph4`, there is a cycle: \'A\' -> \'B\' -> \'C\' -> \'A\'. # Performance Requirements * The solution should efficiently handle graphs of up to 100 nodes, as we expect it to run in reasonable time for medium-sized graphs. Implement the function `has_cycle` as per the above specifications.","solution":"def has_cycle(graph): def visit(node): if node in visited: return visited[node] visited[node] = True # Mark node as being visited for neighbour in graph.get(node, []): if visit(neighbour): return True visited[node] = False # Mark node as fully processed return False visited = {} for node in graph: if visit(node): return True return False"},{"question":"# Question: Reverse Words in a String Context: You are given a string consisting of words separated by spaces. Your task is to write a Python function that reverses the order of words in the string while maintaining the original spacing between the words. Consecutive spaces should be treated as a single space when reversing the order. Problem Statement: Write a function `reverse_words(s: str) -> str` that reverses the order of words in the input string `s` and returns the resulting string. Input: * `s` (str): The input string containing words separated by spaces. Output: * `str`: The string with the order of words reversed. Constraints: * The input string `s` will have a length between 1 and 1000. * The words in the string will consist only of alphabetic characters and spaces. * There will not be leading or trailing spaces, and there will be at least one word in the input. Example: ```python assert reverse_words(\\"the sky is blue\\") == \\"blue is sky the\\" assert reverse_words(\\"hello world\\") == \\"world hello\\" assert reverse_words(\\"sphinx of black quartz judge my vow\\") == \\"vow my judge quartz black of sphinx\\" ``` Requirements: * You should split the input string by spaces, reverse the resulting list of words, and join them back together with a single space between each word. * The algorithm should ensure that words are split and joined correctly, maintaining the original meaning of the input string. * Optimize for readability and clarity in the implemented solution.","solution":"def reverse_words(s: str) -> str: This function takes a string `s` as input and returns a new string with the order of words reversed while maintaining a single space between the words. words = s.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"**Question: Implement a Basic Text-Based Tic-Tac-Toe Game** You are tasked with writing a simple text-based implementation of the Tic-Tac-Toe game where two players can play against each other in turns. Your implementation should handle the following: 1. **Game Board Display**: Implement a function to print the current state of the game board. 2. **Player Moves**: Implement a function to allow players to make their moves by specifying the board position. 3. **Win Check**: Implement a function to check if there is a winner after each move. 4. **Draw Check**: Implement a function to determine if the game is a draw. 5. **Game Loop**: Implement the main game loop that alternates between player moves until there is a win or a draw. **Function Specification**: * `print_board(board: list) -> None`: Prints the current game board. * `make_move(board: list, player: str, position: int) -> bool`: Makes a move for the player on the board at the specified position. Returns `True` if the move is valid, otherwise `False`. * `check_winner(board: list, player: str) -> bool`: Checks if the specified player has won the game. Returns `True` if the player has won, otherwise `False`. * `is_draw(board: list) -> bool`: Checks if the game is a draw. Returns `True` if the game is a draw, otherwise `False`. * `play_game() -> None`: The main function to play the game. **Input:** * The `print_board` function accepts a list representing the game board. * The `make_move` function accepts a game board list, a player symbol (\'X\' or \'O\'), and a board position (1 to 9). * The `check_winner` function accepts a game board list and a player symbol to check for a win. * The `is_draw` function accepts a game board list. * The `play_game` function initiates the game loop and handles player inputs. **Output:** * The `print_board` function prints the game board. * The `make_move` function returns `True` or `False` based on the move\'s validity. * The `check_winner` function returns `True` or `False` based on win condition. * The `is_draw` function returns `True` or `False` based on draw condition. * The `play_game` function manages the game interactions and prints game status updates. **Example Usage:** ```python def print_board(board): print(f\\"{board[0]} | {board[1]} | {board[2]}\\") print(\\"--+---+--\\") print(f\\"{board[3]} | {board[4]} | {board[5]}\\") print(\\"--+---+--\\") print(f\\"{board[6]} | {board[7]} | {board[8]}\\") def make_move(board, player, position): if board[position-1] == \' \': board[position-1] = player return True return False def check_winner(board, player): win_conditions = [(0,1,2), (3,4,5), (6,7,8), (0,3,6), (1,4,7), (2,5,8), (0,4,8), (2,4,6)] return any(board[a] == board[b] == board[c] == player for a, b, c in win_conditions) def is_draw(board): return all(cell != \' \' for cell in board) def play_game(): board = [\' \'] * 9 current_player = \'X\' while True: print_board(board) position = int(input(f\\"Player {current_player}, choose your position (1-9): \\")) if make_move(board, current_player, position): if check_winner(board, current_player): print_board(board) print(f\\"Player {current_player} wins!\\") break if is_draw(board): print_board(board) print(\\"The game is a draw!\\") break current_player = \'O\' if current_player == \'X\' else \'X\' else: print(\\"Invalid move, try again.\\") play_game() ``` **Explanation:** 1. `print_board` displays the current game board. 2. `make_move` updates the board with the player\'s move. 3. `check_winner` checks if a player has won based on predefined winning conditions. 4. `is_draw` checks if all the positions on the board are filled and there is no winner. 5. `play_game` handles the main game loop, managing player turns, displaying updates, and declaring the result.","solution":"def print_board(board): Prints the current game board. Arguments: board -- list of 9 elements representing the tic-tac-toe board print(f\\"{board[0]} | {board[1]} | {board[2]}\\") print(\\"--+---+--\\") print(f\\"{board[3]} | {board[4]} | {board[5]}\\") print(\\"--+---+--\\") print(f\\"{board[6]} | {board[7]} | {board[8]}\\") def make_move(board, player, position): Makes a move for the player on the board at the specified position. Arguments: board -- list of 9 elements representing the tic-tac-toe board player -- \'X\' or \'O\' representing player symbol position -- integer from 1 to 9 representing board position Returns: True if the move is valid, False otherwise if 1 <= position <= 9 and board[position - 1] == \' \': board[position - 1] = player return True return False def check_winner(board, player): Checks if the specified player has won the game. Arguments: board -- list of 9 elements representing the tic-tac-toe board player -- \'X\' or \'O\' representing player symbol Returns: True if the player has won, False otherwise win_conditions = [ (0, 1, 2), (3, 4, 5), (6, 7, 8), # rows (0, 3, 6), (1, 4, 7), (2, 5, 8), # columns (0, 4, 8), (2, 4, 6) # diagonals ] return any(board[a] == board[b] == board[c] == player for (a, b, c) in win_conditions) def is_draw(board): Checks if the game is a draw. Arguments: board -- list of 9 elements representing the tic-tac-toe board Returns: True if the game is a draw, False otherwise return all(cell != \' \' for cell in board) def play_game(): Manages the main game loop, managing player turns, displaying updates, and declaring the result. board = [\' \'] * 9 current_player = \'X\' while True: print_board(board) try: position = int(input(f\\"Player {current_player}, choose your position (1-9): \\")) if make_move(board, current_player, position): if check_winner(board, current_player): print_board(board) print(f\\"Player {current_player} wins!\\") break if is_draw(board): print_board(board) print(\\"The game is a draw!\\") break current_player = \'O\' if current_player == \'X\' else \'X\' else: print(\\"Invalid move, try again.\\") except ValueError: print(\\"Please enter a valid position.\\")"},{"question":"# Problem Statement Write a function `rotate_list` that takes a list of integers and an integer `k` and rotates the list to the right by `k` places. Rotating the list means that elements are shifted to the right, and elements that fall off are moved to the beginning of the list. # Input * A list of integers, e.g., `[1, 2, 3, 4, 5]`. * An integer `k` representing the number of places to rotate the list to the right. # Output * A list of integers representing the rotated list, e.g., `[4, 5, 1, 2, 3]`. # Constraints 1. The input list will have at most `10^5` elements. 2. The integer `k` will be non-negative and will not exceed `10^5`. 3. The integer values in the list will be within the range of typical 32-bit integers. # Examples ```python >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([0, 1, 2], 4) [2, 0, 1] >>> rotate_list([-1, -100, 3, 99], 2) [3, 99, -1, -100] ``` # Notes - The output list should retain the order of the elements after rotation. - If `k` is greater than the length of the list, consider `k % len(lst)` rotations instead. # Instructions Implement the function `rotate_list` to solve the specified problem: ```python def rotate_list(lst: list, k: int) -> list: Given a list of integers and an integer k, rotate the list to the right by k places. if not lst: return lst k = k % len(lst) return lst[-k:] + lst[:-k] ```","solution":"def rotate_list(lst: list, k: int) -> list: Given a list of integers and an integer k, rotate the list to the right by k places. if not lst: return lst k = k % len(lst) return lst[-k:] + lst[:-k]"},{"question":"# Spiral Matrix Traversal with Obstacles # Problem Statement: You are tasked with implementing a function that traverses a given matrix in a spiral order, skipping any cells that contain obstacles. The traversal should start from the top-left corner of the matrix and move to the right initially. Obstacles are represented by the integer `-1`, and they are to be bypassed during the traversal without disrupting the overall spiral pattern. # Traversal Rules: 1. Start from the top-left cell `(0, 0)` and initially move to the right. 2. When a cell containing `-1` is encountered, skip it and continue the traversal in the current direction if possible. 3. If moving in the current direction is not possible (either due to boundaries or encountering an obstacle), change direction in the following order: right -> down -> left -> up. 4. Continue the traversal until all traversable cells have been visited. # Function Signature: ```python def spiral_traverse_with_obstacles(matrix: list[list[int]]) -> list[int]: Traverses a given matrix in spiral order, skipping cells containing obstacles. :param matrix: 2D list of integers representing the matrix, where obstacles are indicated by -1. :return: A list of integers representing the values of the traversable cells in spiral order. ``` # Constraints: * The input matrix can have dimensions ranging from `1x1` up to `100x100`. * The matrix will contain only integers, with obstacles indicated by `-1`. # Input/Output Examples: ```python matrix = [ [1, 2, 3], [4, -1, 5], [6, 7, 8] ] print(spiral_traverse_with_obstacles(matrix)) # Expected Output: [1, 2, 3, 5, 8, 7, 6, 4] matrix = [ [1, -1], [-1, 2] ] print(spiral_traverse_with_obstacles(matrix)) # Expected Output: [1, 2] matrix = [ [-1, -1], [-1, -1] ] print(spiral_traverse_with_obstacles(matrix)) # Expected Output: [] ``` Implement the function `spiral_traverse_with_obstacles` to achieve the spiral traversal of the matrix while skipping the obstacles as defined.","solution":"def spiral_traverse_with_obstacles(matrix): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up direction_index = 0 # start with \'right\' direction rows, cols = len(matrix), len(matrix[0]) visited = [[False] * cols for _ in range(rows)] result = [] row, col = 0, 0 for _ in range(rows * cols): if matrix[row][col] != -1: result.append(matrix[row][col]) visited[row][col] = True next_row = row + directions[direction_index][0] next_col = col + directions[direction_index][1] if 0 <= next_row < rows and 0 <= next_col < cols and not visited[next_row][next_col]: row, col = next_row, next_col else: direction_index = (direction_index + 1) % 4 row += directions[direction_index][0] col += directions[direction_index][1] # Filter out all visited which had obstacles(-1) return [x for x in result if x != -1]"},{"question":"# Problem Statement You need to create a function that determines the format type of a given text as an \\"ASCII\\", \\"UNICODE\\", or \\"BINARY\\" string. The function should correctly identify the format and return the corresponding format type string. # Requirements: 1. The function should accept a text string and analyze its content to determine the format. 2. If the text only contains ASCII characters (0 to 127 in decimal), it should return \\"ASCII\\". 3. If the text contains any character outside the ASCII range but within the Unicode range, it should return \\"UNICODE\\". 4. If the text only contains \'0\' and \'1\' characters, it should return \\"BINARY\\". 5. If the text is an empty string, it should raise a `ValueError`. # Implementation Details: * **Input Format**: A string which needs to be analyzed. * **Output Format**: A string representing the determined format type: \\"ASCII\\", \\"UNICODE\\", or \\"BINARY\\". # Constraints: - The input string can have a maximum length of 10000 characters. - The input string will only contain printable characters within the Unicode standard and binary digits. # Examples: ```python def determine_format(text: str) -> str: Determines the format type of the given text. Args: text: str - Input text string Returns: str - The format type of the text (\\"ASCII\\", \\"UNICODE\\", or \\"BINARY\\") Raises: ValueError - If the input is an empty string Examples: >>> determine_format(\'Hello, World!\') \'ASCII\' >>> determine_format(\'こんにちは\') \'UNICODE\' >>> determine_format(\'1010101011101\') \'BINARY\' >>> determine_format(\'\') Traceback (most recent call last): ... ValueError: Empty string was passed to the function # Your code here # Example usage text_input = \'Hello, World!\' print(determine_format(text_input)) # Should return \'ASCII\' ``` Write the `determine_format` function according to the outlined requirements and ensure it passes all provided examples and edge cases.","solution":"def determine_format(text: str) -> str: Determines the format type of the given text. Args: text: str - Input text string Returns: str - The format type of the text (\\"ASCII\\", \\"UNICODE\\", or \\"BINARY\\") Raises: ValueError - If the input is an empty string if not text: raise ValueError(\\"Empty string was passed to the function\\") is_binary = all(c in \'01\' for c in text) if is_binary: return \\"BINARY\\" is_ascii = all(ord(c) <= 127 for c in text) if is_ascii: return \\"ASCII\\" return \\"UNICODE\\" # Example usage text_input = \'Hello, World!\' print(determine_format(text_input)) # Should return \'ASCII\'"},{"question":"# Coding Question **Context**: Liam is working on data analysis projects and often finds himself needing to filter out unnecessary data from a collection. He wants an efficient way to filter elements based on dynamically specified criteria. **Task**: Write a Python function `filter_elements` that: 1. Takes a list of elements and a filtering function as inputs. 2. Returns a new list of elements that satisfy the filtering criteria defined by the provided function. **Function Signature**: ```python def filter_elements(elements: list, filter_fn: callable) -> list: Filters the elements based on the provided filtering function. :param elements: list - the list of elements to be filtered :param filter_fn: callable - a function that takes an element and returns True if it should be included in the output list and False if it should be excluded :return: list - a new list containing elements that satisfy the filtering criteria Example filter_fn usage: - For numeric elements: lambda x: x > 10 - For string elements: lambda x: \\"apple\\" in x pass ``` **Constraints**: * The function should handle different data types within the list (e.g., integers, strings). * The filtering function should be versatile enough to handle custom logic specified by the user. * Ensure the implementation is efficient even with large lists of elements. * The function should raise appropriate exceptions if inputs are invalid (e.g., elements is not a list, filter_fn is not callable). **Example**: When calling `filter_elements([1, 2, 3, 4, 5, 6], lambda x: x % 2 == 0)`: ```python [2, 4, 6] ``` When calling `filter_elements([\\"apple pie\\", \\"cherry tart\\", \\"banana bread\\"], lambda x: \\"apple\\" in x)`: ```python [\\"apple pie\\"] ``` When calling `filter_elements([10, 20, 30, 40, 50], lambda x: x > 25)`: ```python [30, 40, 50] ``` Ensure your implementation handles various scenarios and custom filtering logic effectively, taking into account potential performance considerations with large datasets.","solution":"def filter_elements(elements: list, filter_fn: callable) -> list: Filters the elements based on the provided filtering function. :param elements: list - the list of elements to be filtered :param filter_fn: callable - a function that takes an element and returns True if it should be included in the output list and False if it should be excluded :return: list - a new list containing elements that satisfy the filtering criteria if not isinstance(elements, list): raise ValueError(\'The first argument must be a list.\') if not callable(filter_fn): raise ValueError(\'The second argument must be callable.\') return [element for element in elements if filter_fn(element)]"},{"question":"Image Rotation by 90 Degrees You are required to implement a function to rotate a given NxN matrix by 90 degrees clockwise. This is a common task in image processing, particularly in the manipulation of bitmap images. # Function Specification **Function**: `rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]` Input - `matrix` (List[List[int]]): A 2D list representing an NxN matrix of integers. Output - `List[List[int]]`: A new NxN matrix representing the input matrix rotated 90 degrees clockwise. Constraints - The input matrix will always be non-empty and will have dimensions NxN where 1 ≤ N ≤ 1000. # Example ```python # Input matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Output # Result after rotating the matrix 90 degrees clockwise output = rotate_matrix_90(matrix) print(output) # Expected: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` # Notes: - Ensure the function handles edge cases gracefully, including the smallest possible matrix. - Do not use any built-in functions that directly perform matrix rotations; implement the logic manually. - Pay attention to the time and space complexity of your solution. **Good luck!**","solution":"from typing import List def rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]: Rotates the given NxN matrix by 90 degrees clockwise. Args: matrix (List[List[int]]): A 2D list representing an NxN matrix of integers. Returns: List[List[int]]: A new NxN matrix representing the input matrix rotated 90 degrees clockwise. N = len(matrix) # Initialize the result matrix with 0s result = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): # Assign the value of matrix[i][j] to its new position after rotation result[j][N - 1 - i] = matrix[i][j] return result"},{"question":"# Coding Challenge Context You are tasked with developing an efficient algorithm for manipulating strings based on given rules. The challenge requires you to determine if a string can be constructed by repeating a smaller substring multiple times. Task Implement a function: ```python def repeated_substring_pattern(s: str) -> bool: pass ``` Function Signature ```python def repeated_substring_pattern(s: str) -> bool: ``` Input * A string ( s ) where ( 1 leq text{len}(s) leq 10^4 ). ( s ) consists of lowercase English letters. Output * A boolean, which is True if the string can be constructed by repeating a smaller substring multiple times, and False otherwise. Examples ```python >>> repeated_substring_pattern(\\"abab\\") True >>> repeated_substring_pattern(\\"aba\\") False >>> repeated_substring_pattern(\\"abcabcabcabc\\") True ``` Constraints * You must ensure your solution runs efficiently within the provided constraints. * Handle edge cases such as the smallest and largest inputs appropriately.","solution":"def repeated_substring_pattern(s: str) -> bool: Returns True if the string can be constructed by repeating a smaller substring multiple times, otherwise returns False. n = len(s) for i in range(1, n // 2 + 1): # Only need to check up to half the length of the string if n % i == 0: # Ensure the length of the candidate substring divides s evenly if s[:i] * (n // i) == s: return True return False"},{"question":"# Problem Statement Implement a Simulation of the Dining Philosophers Problem. The Dining Philosophers problem is a classic synchronization problem described by Dijkstra. Five philosophers sit around a circular table with a bowl of spaghetti in the middle. There are five forks placed between each pair of adjacent philosophers. A philosopher can only eat if they have both the left and right forks. They must pick up the forks one at a time, and they must put down both forks when they finish eating. Philosophers alternate between thinking and eating. Your task is to implement this scenario using threads and synchronization tools provided by the `threading` library in Python. Each philosopher should be represented by a separate thread. # Method Signatures ```python import threading import time from typing import List class DiningPhilosophers: def __init__(self): Initialize the DiningPhilosophers class and synchronize necessary tools. pass def wants_to_eat(self, philosopher: int): This method will be called by each philosopher thread when they want to eat. The philosopher will pick up the left and right forks in sequence, eat, and then put both forks down. Args: - philosopher (int): The ID of the philosopher (0 through 4). pass def philosopher_thread(self, philosopher: int): Simulate the behavior of a single philosopher. A philosopher alternates between thinking and eating. Args: - philosopher (int): The ID of the philosopher (0 through 4). pass def start_dining(self, duration: int): Start the dining philosophers simulation for a given duration. Args: - duration (int): The duration (in seconds) for which the simulation will run. pass ``` # Constraints - Each philosopher thread should attempt to eat multiple times within the provided simulation duration. - You must ensure that no two philosophers can pick up the same fork at the same time. - Prevent deadlocks and ensure that every philosopher gets a chance to eat. - Use the `threading` library for managing threads and synchronization. # Example Usage ```python import time # Initialize the DiningPhilosophers class dining_philosophers = DiningPhilosophers() # Start the dining simulation for 10 seconds dining_philosophers.start_dining(10) ``` **Your task is to complete the implementation of the `DiningPhilosophers` class, ensuring proper synchronization among philosopher threads while they attempt to pick up forks and eat.**","solution":"import threading import time from typing import List class DiningPhilosophers: def __init__(self): Initialize the DiningPhilosophers class and synchronize necessary tools. self.forks = [threading.Lock() for _ in range(5)] self.philosopher_states = [0] * 5 # 0: thinking, 1: hungry, 2: eating self.conditions = [threading.Condition() for _ in range(5)] def wants_to_eat(self, philosopher: int): This method will be called by each philosopher thread when they want to eat. The philosopher will pick up the left and right forks in sequence, eat, and then put both forks down. Args: - philosopher (int): The ID of the philosopher (0 through 4). left = philosopher right = (philosopher + 1) % 5 # Acquire the condition for the philosopher to guarantee proper synchronization with self.conditions[philosopher]: self.philosopher_states[philosopher] = 1 # hungry # Check if philosopher can pick up the forks self._pick_up_forks(philosopher, left, right) # Philosopher can eat self.philosopher_states[philosopher] = 2 # eating self._eat(philosopher) # Philosopher is done eating self._put_down_forks(philosopher, left, right) self.philosopher_states[philosopher] = 0 # thinking def _pick_up_forks(self, philosopher, left, right): Try to pick up the left and right forks for the philosopher. with self.conditions[left], self.conditions[right]: while not (self.philosopher_states[left] != 2 and self.philosopher_states[right] != 2): self.conditions[philosopher].wait() self.forks[left].acquire() self.forks[right].acquire() def _put_down_forks(self, philosopher, left, right): Put down the forks and notify any waiting philosophers. self.forks[left].release() self.forks[right].release() # Notifying the philosophers on the left and right with self.conditions[left]: self.conditions[left].notify_all() with self.conditions[right]: self.conditions[right].notify_all() def _eat(self, philosopher): Simulate eating print(f\\"Philosopher {philosopher} starts eating.\\") time.sleep(0.1) print(f\\"Philosopher {philosopher} finishes eating.\\") def philosopher_thread(self, philosopher: int): Simulate the behavior of a single philosopher. A philosopher alternates between thinking and eating. Args: - philosopher (int): The ID of the philosopher (0 through 4). while True: print(f\\"Philosopher {philosopher} is thinking.\\") time.sleep(0.2) self.wants_to_eat(philosopher) def start_dining(self, duration: int): Start the dining philosophers simulation for a given duration. Args: - duration (int): The duration (in seconds) for which the simulation will run. threads = [] for i in range(5): t = threading.Thread(target=self.philosopher_thread, args=(i,)) t.daemon = True # Make sure threads do not prevent program exit threads.append(t) t.start() time.sleep(duration)"},{"question":"# Context You are tasked with developing a frequency counter for a stream of integers. This counter will allow efficient queries for the frequency of any integer received so far. # Task Refactor the provided `FrequencyCounter` class to support both insertion of new numbers and efficient frequency queries. # Requirements 1. Implement the methods – `insert(num)` and `get_frequency(num)` to maintain and query the frequency of integers efficiently. 2. The `insert(num)` method should add a new integer to the stream in O(1) time complexity. 3. The `get_frequency(num)` method should return the frequency of the given integer in O(1) time complexity. # Input/Output - The `insert(num)` method takes an integer `num` and inserts it into the stream. - The `get_frequency(num)` method takes an integer `num` and returns the frequency of `num` in the stream. If `num` has not been inserted, it should return 0. # Example ```python fc = FrequencyCounter() fc.insert(1) fc.insert(2) fc.insert(1) print(fc.get_frequency(1)) # Output: 2 print(fc.get_frequency(3)) # Output: 0 fc.insert(3) print(fc.get_frequency(2)) # Output: 1 ``` # Notes * Use a dictionary to maintain the frequency of each integer. * Ensure that both operations are highly efficient to handle a large stream of integers.","solution":"class FrequencyCounter: def __init__(self): # Initialize a dictionary to store frequencies of numbers self.frequency_dict = {} def insert(self, num): Inserts an integer into the stream. :param num: int if num in self.frequency_dict: self.frequency_dict[num] += 1 else: self.frequency_dict[num] = 1 def get_frequency(self, num): Returns the frequency of the integer in the stream. :param num: int :return: int return self.frequency_dict.get(num, 0)"},{"question":"# Question You are given an array of integers `arr` and an integer `k`. Your task is to write a function `rotate_array(arr: list[int], k: int) -> list[int]` that rotates the array `k` steps to the right. Constraints: - The rotation should be performed in-place with O(1) extra space. - Negative values for `k` should be treated as rotating to the left. - The function should return the rotated array. Example: ```python >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5, 6, 7], -2) [3, 4, 5, 6, 7, 1, 2] >>> rotate_array([10, 20, 30, 40, 50], 10) [10, 20, 30, 40, 50] >>> rotate_array([2, 4, 6, 8, 10], -10) [2, 4, 6, 8, 10] >>> rotate_array([5], 3) [5] >>> rotate_array([], 5) [] ``` Notes: - You should first normalize `k` with respect to the length of the array. - Consider edge cases such as when the `arr` list is empty or contains only one element. - Ensure the performance is optimal for large input sizes. Write the function `rotate_array` to solve the above problem.","solution":"def rotate_array(arr, k): Rotates the array arr k steps to the right. For negative k, rotates to the left. n = len(arr) if n == 0: return arr k = k % n # Normalize k arr[:] = arr[-k:] + arr[:-k] # Rotate the array in-place return arr"},{"question":"# Scenario You are working as a software developer at a company that provides streaming platforms for various content. To enhance the user experience, the company aims to implement a recommendation system for suggesting the top N most frequently watched movies. # Task Implement a function that extracts the top N most frequently watched movies from a given list of movie watches. The function should return the titles of the movies sorted by their frequency in descending order. If multiple movies have the same frequency, sort them lexicographically by their title. # Function Signature ```python def top_n_movies(watches, N): ``` # Inputs - `watches` (List[str]): A list of strings where each string represents a movie title that has been watched. - `N` (int): The number of top movies to return. # Outputs - A list of strings `result` (List[str]): The titles of the top N most frequently watched movies, sorted by frequency in descending order and lexicographically if frequencies are the same. # Constraints - `1 <= len(watches) <= 10^5` - `1 <= len(watches[i]) <= 100` - `1 <= N <= len(watches)` # Example Given the list of movie watches: ``` watches = [ \\"Inception\\", \\"The Dark Knight\\", \\"Inception\\", \\"Interstellar\\", \\"The Dark Knight\\", \\"The Prestige\\", \\"Inception\\", \\"Dunkirk\\", \\"Interstellar\\", \\"The Dark Knight\\" ] N = 3 ``` The function should output: ``` [\\"Inception\\", \\"The Dark Knight\\", \\"Interstellar\\"] ``` # Remarks - Ensure to count the frequency of each movie efficiently. - Remember to handle the sorting requirements as specified. - Aim for a solution that is performant given the constraints.","solution":"from collections import Counter def top_n_movies(watches, N): Returns the top N most frequently watched movies. # Count the frequency of each movie movie_count = Counter(watches) # Create a list of movies sorted by frequency and then lexicographically sorted_movies = sorted(movie_count.keys(), key=lambda x: (-movie_count[x], x)) return sorted_movies[:N]"},{"question":"# Distance Between Points in N-Dimensional Space Background In mathematics, the distance between two points in an n-dimensional space can be calculated using the Euclidean distance formula. This distance is the length of the straight line segment connecting the points. The formula to calculate the Euclidean distance between two points, ( A ) and ( B ), in ( n )-dimensional space is given by: [ d(A, B) = sqrt{ sum_{i=1}^n (b_i - a_i)^2 } ] You are given a task to implement a function that computes the Euclidean distance between two points in ( n )-dimensional space. Requirements - Write a function `euclidean_distance(a: List[float], b: List[float]) -> float` that takes two lists of floats `a` and `b`, representing the coordinates of two points in ( n )-dimensional space, and returns the Euclidean distance between them. - The function should raise a `ValueError` if the length of `a` and `b` are not equal. - The function should raise a `TypeError` if `a` or `b` contain non-float elements. Function Signature ```python def euclidean_distance(a: List[float], b: List[float]) -> float: pass ``` Input - Two lists of floats, `a` and `b`, each of length ( n ). Output - Returns a float which is the Euclidean distance between points `a` and `b`. Constraints - The arrays can have up to 10^6 elements. - Ensure the function operates efficiently for large inputs. Example ```python print(euclidean_distance([1.0, 2.0, 3.0], [4.0, 5.0, 6.0])) # Output: 5.196152422706632 print(euclidean_distance([1.0, 2.0], [1.0, 2.0])) # Output: 0.0 print(euclidean_distance([0.0, 0.0, 0.0, 0.0], [1.0, 1.0, 1.0, 1.0])) # Output: 2.0 ``` Notes - Carefully handle type checking and ensure to only process valid inputs. - Provide suitable test cases when submitting your solution.","solution":"from typing import List import math def euclidean_distance(a: List[float], b: List[float]) -> float: Computes the Euclidean distance between two points in n-dimensional space. Args: a : List[float] - The coordinates of the first point. b : List[float] - The coordinates of the second point. Returns: float - The Euclidean distance between points a and b. Raises: ValueError - If the lengths of the input lists are not equal. TypeError - If the input lists contain non-float elements. if len(a) != len(b): raise ValueError(\\"Both lists must have the same number of elements.\\") if not all(isinstance(x, (float, int)) for x in a + b): raise TypeError(\\"All elements in both lists must be floats or integers.\\") distance = math.sqrt(sum((ai - bi)**2 for ai, bi in zip(a, b))) return distance"},{"question":"# Coding Challenge Scenario You are developing an application that needs to perform efficient matrix operations for image processing tasks. One common operation is to rotate an image represented by an `n x n` matrix 90 degrees clockwise. Implement a function to achieve this rotation in-place with ( O(1) ) extra space. Task Implement the function `rotate_matrix(matrix: List[List[int]]) -> None` which takes an `n x n` matrix of integers and rotates it 90 degrees clockwise in-place. # Input and Output - **Input**: A single `n x n` matrix `matrix` where `n` is the number of rows/columns. - **Output**: None. The function should modify the matrix in-place. # Constraints - The input matrix will have dimensions `n x n` where `1 <= n <= 1000`. # Performance Requirements - Your solution should aim for ( O(n^2) ) time complexity and ( O(1) ) space complexity (in-place rotation). # Example - Given the matrix ``` [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` After calling `rotate_matrix(matrix)`, the matrix should be modified to: ``` [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` # Additional Notes - Make sure your implementation handles edge cases, such as a 1x1 matrix or when `n` is very large. - You can assume that the matrix contains valid integer values.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the input n x n matrix 90 degrees clockwise in-place. n = len(matrix) # First, transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Then, reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Scenario A financial analyst needs to predict future stock prices based on historical data. They decide to use a simple moving average (SMA) approach to smooth out short-term fluctuations and identify longer-term trends. A moving average is calculated by taking the average of the last ( n ) data points in the time series. # Problem Statement You are tasked with implementing a function that computes the simple moving average (SMA) for a list of stock prices over a specified window size. Given a list of stock prices (represented as integers) and an integer window size ( k ), the function should return a list of SMA values. Each SMA value is the average of the last ( k ) stock prices up to and including the current price. # Function Signature ```python def calculate_sma(prices: List[int], k: int) -> List[float]: ``` # Input - **prices**: A list of integers representing the stock prices at different points in time. - **k**: An integer representing the window size for calculating the SMA. # Output - Returns a list of floating-point numbers representing the SMA values. The first ( k - 1 ) values in the output list should be `None` since there aren\'t enough data points to compute the SMA for these indices. # Constraints - (1 leq text{len(prices)} leq 10^5) - (1 leq prices[i] leq 10^4) - (1 leq k leq text{len(prices)}) # Example ```python prices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 3 print(calculate_sma(prices, k)) # Expected Output: [None, None, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] ``` # Explanation - For the first ( k - 1 ) indices, the SMA cannot be computed and should be `None`. - For index ( k ), the SMA is the average of the first ( k ) prices: (1 + 2 + 3) / 3 = 2.0. - For index ( k + 1 ), the SMA is the average of prices from index 1 to ( k ): (2 + 3 + 4) / 3 = 3.0. - And so on until the end of the list. # Constraints and Performance Notes - Ensure your solution is efficient and can handle the upper constraint on the length of the stock prices list. - Consider using a sliding window approach to keep the time complexity optimal at (O(n)).","solution":"from typing import List def calculate_sma(prices: List[int], k: int) -> List[float]: if k <= 0: raise ValueError(\\"Window size k must be greater than 0.\\") n = len(prices) if n < k: raise ValueError(\\"The length of prices must be greater or equal to the window size k.\\") sma_values = [None] * (k - 1) window_sum = sum(prices[:k]) sma_values.append(window_sum / k) for i in range(k, n): window_sum = window_sum - prices[i - k] + prices[i] sma_values.append(window_sum / k) return sma_values"},{"question":"# Problem Description You are given a problem where you need to determine the minimum distance between two points in a 2-dimensional plane avoiding obstacles. The points and the obstacles are provided in the grid format, where 1 denotes an obstacle, and 0 denotes a free space. Implement the Breadth-First Search (BFS) algorithm to find the shortest path from the start point to the end point, avoiding obstacles. # Input A function `shortest_path_in_grid(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int` that takes: * `grid` (a list of lists of integers): a 2D grid. * `start` (a tuple of two integers): the starting point `(row, col)`. * `end` (a tuple of two integers): the ending point `(row, col)`. # Output The function should return an integer representing the minimum distance between the start and end points. If there is no valid path, return -1. # Constraints * The grid dimensions are `m x n` where `1 <= m, n <= 1000` * Each cell in the grid is either 0 (free space) or 1 (obstacle). * The start and end points are guaranteed to be valid points within the grid boundaries and are always free spaces (0). # Example ```python grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ] start = (0, 0) end = (3, 3) assert shortest_path_in_grid(grid, start, end) == 6 grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) assert shortest_path_in_grid(grid, start, end) == -1 ``` # Explanation 1. **Input**: ```python grid = [ [0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ] start = (0, 0) end = (3, 3) ``` **Output**: `6` **Explanation**: The shortest path from (0, 0) to (3, 3) avoids obstacles and has a length of 6. 2. **Input**: ```python grid = [ [0, 1], [1, 0] ] start = (0, 0) end = (1, 1) ``` **Output**: `-1` **Explanation**: There is no valid path from the start point (0, 0) to the end point (1, 1) because of obstacles. In your implementation, ensure to handle edge cases such as an entirely blocked grid and grids with the start and end points being the same.","solution":"from collections import deque def shortest_path_in_grid(grid, start, end): Returns the minimum distance between start and end points in a 2D grid avoiding obstacles. Uses Breadth-First Search (BFS) algorithm. rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Initialize the queue with the start point and distance 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: (current_row, current_col), current_distance = queue.popleft() # If we have reached the end point, return the distance if (current_row, current_col) == end: return current_distance # Explore neighbors for dr, dc in directions: next_row, next_col = current_row + dr, current_col + dc if 0 <= next_row < rows and 0 <= next_col < cols and grid[next_row][next_col] == 0: if (next_row, next_col) not in visited: visited.add((next_row, next_col)) queue.append(((next_row, next_col), current_distance + 1)) # If the end point is not reachable, return -1 return -1"},{"question":"# Coding Question: Generate All Subsets As an aspiring software developer, you are tasked with solving a problem involving the generation of all possible subsets of a given set of distinct integers. Your goal is to write a function that returns all possible subsets (the power set) of the given list of integers. Function Signature: Implement the function `generate_subsets`: ```python def generate_subsets(nums: list[int]) -> list[list[int]]: pass ``` Input: * `nums`: List of `n` distinct integers. Output: * Returns a list of lists, where each sublist is a subset of the input `nums` list. Constraints: * The input list `nums` will have at least 1 element and at most 10 elements. Examples: ```python >>> generate_subsets([1, 2, 3]) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_subsets([0]) [[], [0]] >>> generate_subsets([2, 4, 6]) [[], [2], [4], [6], [2, 4], [2, 6], [4, 6], [2, 4, 6]] ``` Explanation: 1. The array `[1, 2, 3]` has 8 possible subsets, including the empty set. 2. The array `[0]` has 2 possible subsets, the empty set and the set containing `[0]` itself. 3. The array `[2, 4, 6]` has 8 possible subsets, including the empty set. Hint: Consider using a backtracking or iterative approach to generate all subsets, exploring each element\'s inclusion/exclusion in the subset.","solution":"def generate_subsets(nums: list[int]) -> list[list[int]]: Generates all possible subsets (the power set) of the given list of integers. def backtrack(start, path): # Add the current subset path to the result result.append(path[:]) for i in range(start, len(nums)): # Include nums[i] in the subset path.append(nums[i]) # Continue to generate subsets with nums[i] included backtrack(i + 1, path) # Backtrack and remove nums[i] from the subset path.pop() result = [] backtrack(0, []) return result"},{"question":"# Substring Matching in a Grid Problem Statement Implement a function to check if a given pattern exists as a substring in a 2D grid of characters. The pattern can appear horizontally or vertically in the grid. Function Signature ```python def pattern_exists_in_grid(grid: list[list[str]], pattern: str) -> bool: pass ``` Input - **grid**: A 2D list of single-character strings representing the grid. - **pattern**: A string representing the pattern to search for in the grid. Output - A boolean value indicating whether the pattern exists in the grid. Constraints - The number of rows (m) in the grid will not exceed 100. - The number of columns (n) in the grid will not exceed 100. - The length of the pattern will not exceed the greater of m or n. - The grid and pattern consist of uppercase English letters. Example ```python # Example 1 grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] pattern = \\"SEE\\" # The pattern \\"SEE\\" appears horizontally in the last row. # Example 2 grid = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] pattern = \\"ABCCED\\" # The pattern \\"ABCCED\\" appears in a zig-zag fashion in the grid. output = pattern_exists_in_grid(grid, pattern) print(output) # Example 1: True, Example 2: False ``` Notes - The function should account for patterns that span multiple rows or columns. - Avoid moving diagonally or reusing the same character cell in the grid. - Focus on efficient searching algorithms to handle larger grid sizes while maintaining performance.","solution":"def pattern_exists_in_grid(grid, pattern): if not grid or not pattern: return False rows = len(grid) cols = len(grid[0]) pat_len = len(pattern) def search_horizontal(r, c): if c + pat_len > cols: return False for i in range(pat_len): if grid[r][c + i] != pattern[i]: return False return True def search_vertical(r, c): if r + pat_len > rows: return False for i in range(pat_len): if grid[r + i][c] != pattern[i]: return False return True for r in range(rows): for c in range(cols): if search_horizontal(r, c) or search_vertical(r, c): return True return False"},{"question":"# Problem Statement You are asked to implement a function to perform integer division without using the division, multiplication, or modulus operators. The function should be able to handle negative numbers and perform division using only addition, subtraction, and bit manipulation techniques. # Function Signature ```python def integer_division(dividend: int, divisor: int) -> int: Performs integer division of two numbers without using division, multiplication, or modulus operators. Args: - dividend (int): The number to be divided. - divisor (int): The number by which to divide the dividend. Returns: - int: The quotient of the division. ``` # Input - An integer `dividend` representing the number to be divided. - An integer `divisor` representing the number by which the dividend is divided. # Output - An integer representing the quotient of the division. # Constraints - The `dividend` and `divisor` will be within the range `[-2^31, 2^31 - 1]`. - The divisor will not be zero. # Example ```python dividend = 10 divisor = 3 assert integer_division(dividend, divisor) == 3 dividend = 7 divisor = -3 assert integer_division(dividend, divisor) == -2 dividend = 0 divisor = 1 assert integer_division(dividend, divisor) == 0 dividend = -7 divisor = -3 assert integer_division(dividend, divisor) == 2 ``` # Requirements 1. You must implement the `integer_division` function. 2. Ensure the function handles both positive and negative inputs. 3. Do not use division, multiplication, or modulus operators in your implementation. Use addition, subtraction, and bit manipulation to achieve the result. 4. Handle edge cases according to the constraints provided.","solution":"def integer_division(dividend: int, divisor: int) -> int: # Handle edge cases if dividend == 0: return 0 if divisor == 1: return dividend if divisor == -1: return -dividend if dividend != -2**31 else 2**31 - 1 # Get sign of result negative = (dividend < 0) != (divisor < 0) # Convert both numbers to positive for easier calculation dividend, divisor = abs(dividend), abs(divisor) # Initialize the quotient quotient = 0 # Subtract the divisor from the dividend until what\'s left is less than the divisor while dividend >= divisor: current_divisor, num_divisors = divisor, 1 while dividend >= (current_divisor << 1): current_divisor <<= 1 num_divisors <<= 1 dividend -= current_divisor quotient += num_divisors if negative: quotient = -quotient # Clamp the result to the range [-2**31, 2**31 - 1] return min(max(quotient, -2**31), 2**31 - 1)"},{"question":"# Context: Temperature and precipitation patterns significantly influence various aspects of daily life, agriculture, ecosystems, and climate science. It is essential to analyze and process temperature data accurately for various meteorological predictions and analysis. # Task: Implement a function called `average_temperature` that calculates the average temperature across a given list of daily temperatures recorded over a month. Additionally, the function should identify the highest and lowest temperatures in the list. # Input: 1. `temperatures` (List[float]): A list of floating-point numbers representing daily temperatures for a month. # Output: - A tuple containing three elements: 1. A float representing the average temperature. 2. A float representing the highest temperature. 3. A float representing the lowest temperature. # Constraints: - The list `temperatures` will contain at least one temperature value. - You may assume that the temperatures are provided in degrees Celsius and can be positive, negative, or zero. # Examples: ```python def average_temperature(temperatures: List[float]) -> Tuple[float, float, float]: Calculates the average temperature, the highest temperature, and the lowest temperature. Parameters: - temperatures : List[float] : List of daily temperatures. Returns: - Tuple[float, float, float] : (average temperature, highest temperature, lowest temperature) average_temp = sum(temperatures) / len(temperatures) highest_temp = max(temperatures) lowest_temp = min(temperatures) return average_temp, highest_temp, lowest_temp # Example Usage temperatures = [23.4, 21.0, 22.1, 19.5, 25.3, 24.8, 20.0, 22.9, 21.9, 23.1] print(average_temperature(temperatures)) # (22.40, 25.3, 19.5) temperatures = [-5.0, -3.2, 0.0, 1.4, -2.0] print(average_temperature(temperatures)) # (-1.76, 1.4, -5.0) ``` # Requirements: Implement the function as described, ensuring it handles edge cases such as negative temperatures and non-integer values correctly. Verify the calculations using sample values provided in the question.","solution":"from typing import List, Tuple def average_temperature(temperatures: List[float]) -> Tuple[float, float, float]: Calculates the average temperature, the highest temperature, and the lowest temperature. Parameters: - temperatures : List[float] : List of daily temperatures. Returns: - Tuple[float, float, float] : (average temperature, highest temperature, lowest temperature) average_temp = sum(temperatures) / len(temperatures) highest_temp = max(temperatures) lowest_temp = min(temperatures) return round(average_temp, 2), highest_temp, lowest_temp"},{"question":"# Question: Sentence Reverser You are required to write a function that takes a sentence as input and reverses the order of the words in that sentence. The sentence will be provided as a string containing words separated by whitespace characters. The function should preserve all leading and trailing whitespaces as well as any multiple spaces between words. Constraints 1. The input is provided as a single string. 2. The input string can contain varying amounts of whitespace characters. 3. The function should handle both empty strings and strings containing only whitespaces. Input and Output Format * **Input**: A string representing a sentence. - Example: `\\"Hello World\\"`, `\\" This is a test \\"` * **Output**: A string where the order of words is reversed, preserving all whitespaces. - Example: `\\"World Hello\\"`, `\\" test a is This \\"` Function Signature ```python def reverse_sentence(sentence: str) -> str: ``` Implementation Details 1. Split the sentence into words while preserving whitespace. 2. Reverse the order of the words. 3. Join the reversed words back into a string while maintaining the original whitespace. Examples ```python >>> reverse_sentence(\\"Hello World\\") \'World Hello\' >>> reverse_sentence(\\" This is a test \\") \' test a is This \' >>> reverse_sentence(\\"single\\") \'single\' >>> reverse_sentence(\\"\\") \'\' >>> reverse_sentence(\\" \\") \' \' ``` Notes * Consider how to handle multiple consecutive whitespace characters. * The function should preserve all leading, trailing, and internal whitespace exactly as in the original sentence.","solution":"def reverse_sentence(sentence: str) -> str: Reverses the order of words in a given sentence while preserving all leading, trailing, and multiple spaces between words. words = sentence.split(\' \') reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Problem Statement You\'ve joined a team that works on a custom data compression library. One of the features of this library involves compressing strings by counting consecutive duplicate characters. Tasks 1. **Implement \'compress_string\' function** Implement a function `compress_string(input_str: str) -> str` that compresses a string using the run-length encoding (RLE) technique. The RLE compresses by replacing consecutive duplicate characters with a single character followed by the number of duplicates. If the compressed string is not shorter than the original string, return the original string. 2. **Implement \'decompress_string\' function** Implement a function `decompress_string(compressed_str: str) -> str` which takes a string compressed with the `compress_string` function and returns the original string. # Constraints - The input string for `compress_string` will consist of only lowercase alphabets. - Run-length encoded strings will include counts only if they are greater than 1. - Handle edge cases like empty strings appropriately in both functions. # Function Signatures ```python def compress_string(input_str: str) -> str: pass def decompress_string(compressed_str: str) -> str: pass ``` # Examples - **Compress String** ```python input_str = \\"aaabbcddd\\" print(compress_string(input_str)) # Output: \\"a3b2cd3\\" ``` - **Compress String (no compression)** ```python input_str = \\"abcdef\\" print(compress_string(input_str)) # Output: \\"abcdef\\" (since compression does not reduce the size) ``` - **Decompress String** ```python compressed_str = \\"a3b2cd3\\" print(decompress_string(compressed_str)) # Output: \\"aaabbcddd\\" ``` **Note**: Assume input strings to be valid and consistent with the constraints described.","solution":"def compress_string(input_str: str) -> str: if not input_str: return \\"\\" compressed = [] count = 1 for i in range(1, len(input_str)): if input_str[i] == input_str[i - 1]: count += 1 else: compressed.append(input_str[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(input_str[-1]) if count > 1: compressed.append(str(count)) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(input_str) else input_str def decompress_string(compressed_str: str) -> str: if not compressed_str: return \\"\\" decompressed = [] i = 0 while i < len(compressed_str): char = compressed_str[i] count = 1 if i + 1 < len(compressed_str) and compressed_str[i + 1].isdigit(): j = i + 1 num_str = [] while j < len(compressed_str) and compressed_str[j].isdigit(): num_str.append(compressed_str[j]) j += 1 count = int(\'\'.join(num_str)) i = j - 1 decompressed.append(char * count) i += 1 return \'\'.join(decompressed)"},{"question":"# Problem Statement You are responsible for optimizing a music playlist that allows efficient song management. The playlist supports adding songs, removing songs, and shuffling the current order of songs. Your goal is to enhance the current `Playlist` class by adding two new methods: `get_most_frequent` and `shuffle_playlist`. The `Playlist` class uses a doubly linked list to maintain the order of songs with each node representing a song. Tasks 1. **Implement \'get_most_frequent\' function** Enhance the `Playlist` class by adding a method `get_most_frequent() -> str`. This function should return the title of the most frequently added song. If there are multiple songs with the same highest frequency, return any one of them. 2. **Implement \'shuffle_playlist\' function** Add a method `shuffle_playlist() -> None` to the `Playlist` class. This function should randomize the order of the songs in the playlist while maintaining the `DoublyLinkedList` structure. # Constraints - The `get_most_frequent` method should have O(n) time complexity, where n is the number of songs in the playlist. - Implement shuffling such that it is done fairly and all permutations are possible. - You may assume that the playlist has at least one song when calling these methods. # Function Signatures ```python def get_most_frequent(self) -> str: pass def shuffle_playlist(self) -> None: pass ``` # Example - **Adding songs to the playlist** ```python pl = Playlist() pl.add_song(\'SongA\') pl.add_song(\'SongB\') pl.add_song(\'SongA\') pl.add_song(\'SongC\') pl.add_song(\'SongA\') ``` - **Getting the most frequently added song** ```python print(pl.get_most_frequent()) # Output should be \'SongA\' ``` - **Shuffling playlist** ```python pl.shuffle_playlist() print(pl.list_songs()) # Output should be a shuffled order of [\'SongA\', \'SongB\', \'SongA\', \'SongC\', \'SongA\'] ``` **Note**: Prior songs\' order is valid before shuffled, and the provided `Playlist` and `DoublyLinkedList` classes shall be used and modified according to the task requirements.","solution":"from collections import defaultdict import random class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def append(self, value): new_node = self.Node(value) if self.tail is None: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def to_list(self): result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def from_list(self, values): self.head = self.tail = None for value in values: self.append(value) class Playlist: def __init__(self): self.songs = DoublyLinkedList() self.frequency = defaultdict(int) def add_song(self, song): self.songs.append(song) self.frequency[song] += 1 def get_most_frequent(self) -> str: return max(self.frequency, key=self.frequency.get) def shuffle_playlist(self) -> None: songs_list = self.songs.to_list() random.shuffle(songs_list) self.songs.from_list(songs_list) def list_songs(self): return self.songs.to_list()"},{"question":"# Context Sorting algorithms are fundamental to computer science, and understanding how they work can elucidate deeper algorithmic concepts. Merge Sort is a classic divide-and-conquer algorithm that you are required to implement. Demonstrating your grasp of this algorithm will show your proficiency in recursion and sorting. # Objective Write a Python function `merge_sort(arr: list[int]) -> list[int]` to implement the Merge Sort algorithm. The provided code snippets serve as reference implementations for various parts of this algorithm. # Requirements 1. **Input Format**: * `arr`: A list of integers that needs to be sorted. 2. **Output Format**: * A list of integers sorted in non-decreasing order. 3. **Constraints**: * The elements of `arr` are in the range `-10^5 <= element <= 10^5` * The length of `arr` is `1 <= len(arr) <= 10^4` # Performance Your implementation should have an expected time complexity of O(n log n) and should handle edge cases such as empty inputs or single-element lists gracefully. # Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: ``` # Example ```python merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) # Should return [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] ``` # Notes * Focus on clear and well-commented code. * Include both the merging and recursive splitting steps in your implementation. * Ensure your solution is both efficient and easy to understand through modularization of different parts of the algorithm.","solution":"def merge_sort(arr): Implements the Merge Sort algorithm to sort a list of integers in non-decreasing order. Parameters: arr (list of int): List of integers to be sorted. Returns: list of int: Sorted list of integers. if len(arr) <= 1: return arr # Finding the midpoint of the array mid = len(arr) // 2 # Recursively splitting and sorting the left half left_half = merge_sort(arr[:mid]) # Recursively splitting and sorting the right half right_half = merge_sort(arr[mid:]) # Merging the sorted halves return merge(left_half, right_half) def merge(left, right): Merges two sorted lists into a single sorted list. Parameters: left (list of int): The first sorted list. right (list of int): The second sorted list. Returns: list of int: Merged and sorted list. sorted_arr = [] i = j = 0 # Merging the two sorted lists while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # Collecting the remaining elements if any sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr"},{"question":"Binary Tree Zigzag Level Order Traversal Background A binary tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. Zigzag level order traversal of a binary tree is a variant of the standard level order traversal where the nodes\' values at each level alternate between left-to-right and right-to-left order. Task Given the `Node` class for a binary tree, implement the function `zigzag_level_order` to perform a zigzag level order traversal. Requirements - The function should return a list of lists, each inner list containing the node values of the tree at that level, following the zigzag order. - Implement the `Node` class with the initializer and any required methods for creating and manipulating the tree. # Function Specifications `Node` - **Attributes**: - `val` (int): The value of the node. - `left` (`Node`): The left child node. - `right` (`Node`): The right child node. - **Methods**: - `__init__(self, val:int=0, left:\'Node\'=None, right:\'Node\'=None)`: Initializes a node with value, left child, and right child. `zigzag_level_order(root: Node) -> List[List[int]]` - **Input**: `root` (`Node` object) - The root node of the binary tree. - **Output**: A list of lists, where each inner list contains the node values at that level following zigzag order. - **Constraints**: - The number of nodes in the tree is in the range [0, 1000]. - Node values are in the range [-1000, 1000]. # Example Usage ```python # Tree structure: # 3 # / # 9 20 # / # 15 7 root = Node(3) root.left = Node(9) root.right = Node(20, Node(15), Node(7)) print(zigzag_level_order(root)) # Output: [[3], [20, 9], [15, 7]] ``` # Notes 1. The input could be an empty tree (i.e., root is null), in which case return an empty list. 2. Optimize the solution to manage space and time complexity efficiently given the constraints.","solution":"from typing import List, Optional import collections class Node: def __init__(self, val: int = 0, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def zigzag_level_order(root: Optional[Node]) -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) left_to_right = True while queue: level_size = len(queue) level_nodes = collections.deque() for _ in range(level_size): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.appendleft(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(list(level_nodes)) left_to_right = not left_to_right return result"},{"question":"# Maximum Subarray Sum Challenge You are required to implement a function that finds the largest sum of a contiguous subarray within a given one-dimensional array containing at least one integer. Implement the following function: 1. `max_subarray_sum(arr: List[int]) -> int`: Finds the maximum sum of a contiguous subarray. # Expected Input and Output - The function takes a single list of integers, `arr`, as input. - The function should return an integer representing the maximum subarray sum. - **Input constraint**: The array can have up to 10,000 elements, with each element being an integer between -10,000 and 10,000. # Example Suppose you have the following array: ``` arr = [-2,1,-3,4,-1,2,1,-5,4] ``` The largest sum subarray is `[4, -1, 2, 1]` which sums up to 6. Expected Output: ``` 6 ``` # Constraints: - The solution must run in O(n) time complexity. - Avoid using excessive additional space. - Consider edge cases where the array might have all negative values or all positive values. Implement the function ensuring it adheres to the above specifications and handles the given constraints effectively.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Finds the largest sum of a contiguous subarray within a given one-dimensional array containing at least one integer. if not arr: return 0 # Assuming an empty array should return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Coding Assessment Question Context You are given the heights of buildings in a city represented by a list, where each element represents the height of a building at that position. The goal is to calculate how much water can be trapped between the buildings after a rain. Write a function to determine the total amount of trapped water. Objective Implement the function `trap_water(heights: list[int]) -> int` that returns the total amount of water that can be trapped. Input/Output Format - **Input**: A list of integers, `heights`, where each integer represents the height of a building. - **Output**: An integer representing the total amount of trapped water. Constraints - `0 <= len(heights) <= 10^4` - `0 <= heights[i] <= 10^5` Example ```python >>> trap_water([0,1,0,2,1,0,1,3,2,1,2,1]) 6 # 6 units of water can be trapped >>> trap_water([4,2,0,3,2,5]) 9 # 9 units of water can be trapped >>> trap_water([]) 0 # no water can be trapped >>> trap_water([1]) 0 # no water can be trapped with one building >>> trap_water([1,2,1,2]) 1 # 1 unit of water can be trapped ``` Requirements 1. Ensure the function handles edge cases such as an empty list, a single building, and sequences with no trapped water. 2. The solution must run in linear time O(n) and use O(n) extra space.","solution":"def trap_water(heights): Return the total amount of water that can be trapped between the buildings. heights: list of integers representing the height of buildings. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"# Merge Sort for a List of Integers Problem Statement You are required to implement a function named `merge_sort` that performs the merge sort algorithm on a given list of integers. The function should sort the list in ascending order. Input * A list of integers `list_data` which needs to be sorted. Output * The function should return a new list of integers which is the sorted version of `list_data`. Function Signature ```python def merge_sort(list_data: list) -> list: pass ``` Constraints * The list can contain integers in any order. * The function should handle lists of length 0 up to 10^4. # Example ```python >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> merge_sort([]) [] >>> merge_sort([5]) [5] >>> merge_sort([10, -10, 0]) [-10, 0, 10] ``` Notes * The implementation should not use any built-in sorting functions such as `sorted()` or similar. * Ensure to handle all edge cases such as an empty list or a list with a single element. * Aim to write a clear and efficient implementation of the merge sort algorithm that works within the constraints.","solution":"def merge_sort(list_data): Sorts the list_data using the merge sort algorithm. Parameters: list_data (list): The list of integers to be sorted. Returns: list: A new sorted list. if len(list_data) <= 1: return list_data def merge(left, right): Merges two sorted lists into one sorted list. Parameters: left (list): The first sorted list. right (list): The second sorted list. Returns: list: The merged and sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(list_data) // 2 left_half = merge_sort(list_data[:mid]) right_half = merge_sort(list_data[mid:]) return merge(left_half, right_half)"},{"question":"# Problem Statement You are tasked with implementing a depth-first search (DFS) algorithm for a graph and extending it to find the shortest path in an unweighted graph using DFS in conjunction with backtracking. Specifically, you will create a class that manages the graph, the DFS algorithm, and the shortest path finder. # Requirements 1. **Input**: - An undirected graph represented as an adjacency list. The keys are the nodes, and the values are lists of neighboring nodes. - Two nodes, `start` and `end`, representing the nodes between which the shortest path is to be found. 2. **Output**: - The `dfs` method returns a list containing the nodes visited during the DFS traversal starting from the `start` node. - The `find_shortest_path` method returns a list representing the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints - The graph contains at least one node and at most 1,000 nodes. - There can be at most 10,000 edges in the graph. - The nodes are identified by unique integers. - The `start` and `end` nodes are valid nodes of the graph. # Example ```python # Sample inputs graph = { 0: [1, 2], 1: [0, 3], 2: [0, 3], 3: [1, 2, 4], 4: [3] } start = 0 end = 4 # Creating the graph object graph_obj = GraphTraversal(graph) # Performing DFS dfs_result = graph_obj.dfs(start) print(f\\"DFS traversal from node {start}: {dfs_result}\\") # Finding shortest path shortest_path = graph_obj.find_shortest_path(start, end) print(f\\"Shortest path from {start} to {end}: {shortest_path}\\") ``` # Instructions: 1. Implement the class `GraphTraversal` with methods: - `__init__(self, adjacency_list)`: Initialize the graph using the given adjacency list. - `dfs(self, node)`: Perform DFS traversal starting from the given node and return the list of nodes visited. - `find_shortest_path(self, start, end)`: Use DFS and backtracking to find the shortest path between `start` and `end`. 2. Ensure the DFS algorithm avoids revisiting nodes. 3. Ensure the `find_shortest_path` method efficiently finds the shortest path, if one exists, using backtracking. This new question integrates seamlessly with the existing set, maintaining the same level of complexity and addressing a related topic in graph traversal and pathfinding, presenting a novel problem scenario.","solution":"class GraphTraversal: def __init__(self, adjacency_list): Initialize the graph using the given adjacency list. adjacency_list: Dictionary where keys are node values and values are lists of connected nodes. self.graph = adjacency_list def dfs(self, node): Perform DFS traversal starting from the given node and return the list of nodes visited. visited = set() result = [] def dfs_recursive(n): if n in visited: return visited.add(n) result.append(n) for neighbor in self.graph.get(n, []): dfs_recursive(neighbor) dfs_recursive(node) return result def find_shortest_path(self, start, end): Use DFS and backtracking to find the shortest path between start and end nodes. shortest_path = [] visited = set() def dfs_recursive(path): nonlocal shortest_path current_node = path[-1] if current_node == end: if not shortest_path or len(path) < len(shortest_path): shortest_path = list(path) return for neighbor in self.graph.get(current_node, []): if neighbor not in visited: visited.add(neighbor) dfs_recursive(path + [neighbor]) visited.remove(neighbor) visited.add(start) dfs_recursive([start]) return shortest_path"},{"question":"# Coding Assessment Question Context In the realm of string manipulation algorithms, a common challenge is to determine whether a given string is a permutation of another string (i.e., can one string be rearranged to form the other). This concept is widely used in various applications including anagrams and password validation. Task Implement the `are_permutations` function that checks if two given strings are permutations of each other. The function should handle edge cases appropriately by raising errors for invalid inputs. Function Signature ```python def are_permutations(s1: str, s2: str) -> bool: Checks if the two strings are permutations of each other. @param s1: the first string @param s2: the second string @return: True if s1 and s2 are permutations of each other, False otherwise. Raises a ValueError for non-string inputs. ``` Input and Output - **Input**: Two strings, `s1` and `s2`. - **Output**: A boolean value - `True` if the strings are permutations of each other, `False` otherwise. Constraints - The inputs should be strings. - The function should be case sensitive (i.e., \'a\' and \'A\' are considered different characters). Performance - The function should aim to be efficient in terms of both time and space complexities while ensuring clarity. Example Use Cases ```python print(are_permutations(\\"abcd\\", \\"dcba\\")) # Output: True print(are_permutations(\\"hello\\", \\"bello\\")) # Output: False print(are_permutations(\\"12345\\", \\"54321\\")) # Output: True print(are_permutations(\\"apple\\", \\"appe\\")) # Output: False print(are_permutations(\\"apple\\", \\"Apple\\")) # Output: False ``` Error Handling - If any of the inputs is not a string, raise a `ValueError` with the message \\"Both inputs must be strings\\".","solution":"def are_permutations(s1: str, s2: str) -> bool: Checks if the two strings are permutations of each other. @param s1: the first string @param s2: the second string @return: True if s1 and s2 are permutations of each other, False otherwise. Raises a ValueError for non-string inputs. if not isinstance(s1, str) or not isinstance(s2, str): raise ValueError(\\"Both inputs must be strings\\") # Permutations must be of the same length if len(s1) != len(s2): return False # Check if both strings have the same characters with the same frequencies return sorted(s1) == sorted(s2)"},{"question":"# Problem Statement You are given a task to write a function that takes a list of integers and returns a new list containing the squares of all the negative numbers in the original list. The positive numbers and zeros should be left unchanged. # Function Signature ```python def process_numbers(numbers: List[int]) -> List[int]: ``` # Input - `numbers` (list of ints): A list of integers which may include positive numbers, negative numbers, and zeros. # Output - Returns a list of integers where all the negative numbers from the input list are replaced by their squares, and the positive numbers and zeros remain the same. # Constraints - The length of the list can vary from 0 to 10^5. - Each integer in the list will be between -10^3 and 10^3. # Performance Requirements - The function should execute in linear time, O(n), where n is the number of elements in the input list. # Examples 1. `process_numbers([1, -2, 3, -4, 0])` should return `[1, 4, 3, 16, 0]` 2. `process_numbers([-1, -3, 9, -2])` should return `[1, 9, 9, 4]` 3. `process_numbers([0, 0, -7])` should return `[0, 0, 49]` 4. `process_numbers([5, 2, 8])` should return `[5, 2, 8]` 5. `process_numbers([-5, -5, -5])` should return `[25, 25, 25]` 6. `process_numbers([])` should return `[]` # Implementation Notes - Traverse through the list and use a list comprehension or a similar construct to perform the operation in a single pass. - Ensure that the solution maintains the order of the original list. - Handle edge cases such as an empty list and lists with no negative numbers. Implement the function `process_numbers` adhering to the specifications provided.","solution":"from typing import List def process_numbers(numbers: List[int]) -> List[int]: Returns a new list where all negative numbers are replaced by their squares, and the positive numbers and zeros remain the same. return [x**2 if x < 0 else x for x in numbers]"},{"question":"# Problem Statement: You are assigned a task to identify the next largest prime within a certain range after a given number. **Objective:** Write a function `next_largest_prime(n: int, upper_bound: int) -> int` that returns the smallest prime number greater than `n` and less than or equal to `upper_bound`. **Input:** * A single integer `n` representing the starting point. * A single integer `upper_bound` representing the exclusive upper limit for the search. **Output:** * The smallest prime number greater than `n` and less than or equal to `upper_bound`. If no such prime number exists, return `-1`. **Constraints:** * Both `n` and `upper_bound` will be positive integers. * `upper_bound` will always be greater than `n`. **Example:** ```python assert next_largest_prime(10, 20) == 11 assert next_largest_prime(14, 30) == 17 assert next_largest_prime(30, 35) == 31 assert next_largest_prime(13, 13) == -1 ``` **Scenario:** Imagine you are developing a feature for a security application that needs to find the next viable prime after a given checkpoint to generate a secure key. Implementing the function to find this prime efficiently will be crucial for the security of the application.","solution":"def is_prime(num): Helper function to check if a number is prime if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_largest_prime(n, upper_bound): Finds the smallest prime number greater than n and less than or equal to upper_bound. for num in range(n + 1, upper_bound + 1): if is_prime(num): return num return -1"},{"question":"# **Matrix Row and Column Swapping** Write a function `swap_matrix_elements(matrix: list[list[int]], row1: int, col1: int, row2: int, col2: int) -> list[list[int]]` that swaps two elements in a given matrix. For this task: 1. **Input:** - `matrix`: A list of lists, where each inner list represents a row in the matrix and contains integers. - `row1`: The row index of the first element to be swapped. - `col1`: The column index of the first element to be swapped. - `row2`: The row index of the second element to be swapped. - `col2`: The column index of the second element to be swapped. 2. **Output:** - A new matrix with the specified elements swapped. 3. **Constraints:** - `matrix` is at least a 1x1 matrix. - The provided indices for rows and columns are within the bounds of the matrix. 4. **Handling Errors:** - If any provided index is out of bounds for the matrix dimensions, raise an `IndexError` with the message `\\"Row or column index out of bounds\\"`. # Example Usage ```python >>> swap_matrix_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0, 0, 2, 2) [[9, 2, 3], [4, 5, 6], [7, 8, 1]] >>> swap_matrix_elements([[1]], 0, 0, 0, 0) [[1]] >>> swap_matrix_elements([[1, 2], [3, 4]], 0, 1, 1, 0) [[1, 3], [2, 4]] >>> swap_matrix_elements([[1, 2], [3, 4]], 0, 0, 2, 2) Traceback (most recent call last): ... IndexError: Row or column index out of bounds >>> swap_matrix_elements([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 1, 1, 2, 2) [[10, 20, 30], [40, 90, 60], [70, 80, 50]] >>> swap_matrix_elements([[15]], 0, 0, 0, 1) Traceback (most recent call last): ... IndexError: Row or column index out of bounds ``` # Requirements * Ensure the function handles invalid index input gracefully by raising exceptions where necessary. * Create a deep copy of the input matrix to avoid mutating the original matrix in-place.","solution":"def swap_matrix_elements(matrix, row1, col1, row2, col2): Swaps the elements at the given row and column positions in the matrix. :param matrix: List of lists representing the matrix. :param row1: The row index of the first element to be swapped. :param col1: The column index of the first element to be swapped. :param row2: The row index of the second element to be swapped. :param col2: The column index of the second element to be swapped. :return: A new matrix with the specified elements swapped. :raises IndexError: If any of the specified indices are out of bounds. # Verify that the provided indices are within the bounds of the matrix. if row1 < 0 or row1 >= len(matrix) or row2 < 0 or row2 >= len(matrix): raise IndexError(\\"Row or column index out of bounds\\") if col1 < 0 or col1 >= len(matrix[0]) or col2 < 0 or col2 >= len(matrix[0]): raise IndexError(\\"Row or column index out of bounds\\") # Create a deep copy of the matrix to avoid modifying the original matrix. new_matrix = [row[:] for row in matrix] # Swap the elements. new_matrix[row1][col1], new_matrix[row2][col2] = new_matrix[row2][col2], new_matrix[row1][col1] return new_matrix"},{"question":"# Problem You are tasked with implementing a function that simulates an infection spread through a grid. Your job is to create a simulation where each cell in a 2D grid can be healthy, infected, or recovered. Healthy cells can get infected by adjacent infected cells, and infected cells recover after a certain number of iterations. # Function Signature ```python def simulate_infection( width: int, height: int, initial_infected: list, infection_probability: float, infection_duration: int, max_iterations: int ) -> dict: pass ``` # Parameters - **width, height** `(int)`: Dimensions of the grid (1 ≤ width, height ≤ 100). - **initial_infected** `(list of tuple)`: List of coordinates indicating initially infected cells. - **infection_probability** `(float)`: The probability (0.0 ≤ infection_probability ≤ 1.0) that a healthy cell adjacent to an infected cell will get infected in a given iteration. - **infection_duration** `(int)`: The number of iterations an infected cell stays infected before recovering (1 ≤ infection_duration ≤ 50). - **max_iterations** `(int)`: Maximum number of iterations to run the simulation (1 ≤ max_iterations ≤ 1000). # Returns - **result** `(dict)`: A dictionary with the final counts of healthy, infected, and recovered cells. - `{\\"healthy\\": <final healthy count>, \\"infected\\": <final infected count>, \\"recovered\\": <final recovered count>}` # Detailed Requirements 1. **Initialization**: - Populate the grid with healthy cells. - Set the initially infected cells as given in `initial_infected`. 2. **Simulation Loop**: - For each iteration, update the state of the grid by: - Having infected cells potentially infecting adjacent healthy cells with a given probability. - Decreasing the infection duration timer for each infected cell. - Transforming infected cells to recovered cells once their infection duration timer reaches zero. 3. **Cell State Transitions**: - **Healthy Cell**: A healthy cell can become infected if it has at least one adjacent infected cell. The chance of getting infected is determined by the `infection_probability`. - **Infected Cell**: An infected cell will stay infected for `infection_duration` iterations and then recover. - **Recovered Cell**: A recovered cell remains recovered and cannot be infected again. 4. **Return Final Counts**: - After running `max_iterations`, return the counts of healthy, infected, and recovered cells. # Example ```python width = 20 height = 20 initial_infected = [(10, 10), (15, 15)] infection_probability = 0.3 infection_duration = 5 max_iterations = 50 result = simulate_infection( width, height, initial_infected, infection_probability, infection_duration, max_iterations ) print(result) # Output: {\'healthy\': A, \'infected\': B, \'recovered\': C} ``` In this example, replace `A`, `B`, and `C` with the resulting counts of healthy, infected, and recovered cells after the simulation runs for `max_iterations` iterations.","solution":"import random def simulate_infection( width: int, height: int, initial_infected: list, infection_probability: float, infection_duration: int, max_iterations: int ) -> dict: # Initialize the grid with healthy cells grid = [[\'H\' for _ in range(width)] for _ in range(height)] # Dictionary to store infection duration for each infected cell infection_timers = {} # Set initial infected cells for (x, y) in initial_infected: grid[y][x] = \'I\' infection_timers[(x, y)] = infection_duration # Directions for adjacent cells (left, right, up, down) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for _ in range(max_iterations): # Collect cells to infect and cells to recover in this iteration new_infections = [] recoveries = [] for y in range(height): for x in range(width): if grid[y][x] == \'I\': # Check adjacent cells for potential infection for dx, dy in directions: nx, ny = x + dx, y + dy # Make sure the adjacent cell is within bounds and healthy if 0 <= nx < width and 0 <= ny < height and grid[ny][nx] == \'H\': if random.random() < infection_probability: new_infections.append((nx, ny)) # Decrease infection timer infection_timers[(x, y)] -= 1 if infection_timers[(x, y)] == 0: recoveries.append((x, y)) # Infect new cells for (x, y) in new_infections: grid[y][x] = \'I\' infection_timers[(x, y)] = infection_duration # Recover cells for (x, y) in recoveries: grid[y][x] = \'R\' del infection_timers[(x, y)] # Count the final states healthy_count = sum(row.count(\'H\') for row in grid) infected_count = sum(row.count(\'I\') for row in grid) recovered_count = sum(row.count(\'R\') for row in grid) return { \'healthy\': healthy_count, \'infected\': infected_count, \'recovered\': recovered_count }"},{"question":"# Scenario You are working for a company that develops container orchestration systems. Part of your job involves ensuring efficient resource allocation within a distributed network. You\'ve been tasked with implementing an algorithm that calculates the maximum number of non-overlapping intervals from a list of intervals where each interval represents a job with a start and end time. # Problem Statement Given a list of intervals where each interval is represented as a tuple (start, end), write a function `max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int` that returns the maximum number of non-overlapping intervals that can be selected. # Input * `intervals` (List[Tuple[int, int]]): a list of intervals where each interval is represented as a tuple (start, end). (1 ≤ len(intervals) ≤ 10^5) # Output * Return the maximum number of non-overlapping intervals as an integer. # Example ```python >>> max_non_overlapping_intervals([(1, 2), (2, 4), (3, 5), (5, 6)]) 3 >>> max_non_overlapping_intervals([(1, 3), (2, 6), (4, 5), (7, 8)]) 3 ``` # Constraints * Each interval is represented by two integers `start` and `end` (0 ≤ start < end ≤ 10^9). * Aim for an optimal solution to ensure efficient handling of large input sizes. # Note Consider using a greedy algorithm to solve this problem efficiently. The greedy choice involves always selecting the next interval whose end time is the earliest among the remaining intervals that do not overlap with the intervals selected so far.","solution":"from typing import List, Tuple def max_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping intervals. # Sort intervals by their end time intervals.sort(key=lambda x: x[1]) count = 0 current_end = float(\'-inf\') for start, end in intervals: if start >= current_end: count += 1 current_end = end return count"},{"question":"# Question: Create a function that processes a string containing variables enclosed in curly braces `{}` and replaces them with their corresponding values from a given dictionary. Ensure that the function robustly handles various edge cases, such as missing keys in the dictionary and nested curly braces, by ignoring them safely. Function Signature ```python def replace_variables(text: str, variables: dict) -> str: pass ``` Input - `text` (str): A string containing variables enclosed in curly braces `{}`. - `variables` (dict): A dictionary where keys are variable names, mapped to their corresponding replacement values. Output - `str`: The resulting string after replacing all valid variable placeholders with their corresponding values from the dictionary. Constraints - The input string `text` can be up to 10^5 characters long. - Variable names and values contained in the dictionary will be alphabetic strings. - The dictionary can have up to 10^3 entries. Example Input: ```python text = \\"Hello, {name}! You have {count} new messages.\\" variables = {\\"name\\": \\"Alice\\", \\"count\\": \\"5\\"} ``` Output: ```python \\"Hello, Alice! You have 5 new messages.\\" ``` Input: ```python text = \\"Your balance is {balance} USD. {missing_var}.\\" variables = {\\"balance\\": \\"500\\"} ``` Output: ```python \\"Your balance is 500 USD. {missing_var}.\\" ``` Notes - If a variable in the text does not have a corresponding key in the `variables` dictionary, it should remain unchanged. - Nested curly braces are considered invalid input; resulting behavior should be to leave them as-is in the original text.","solution":"def replace_variables(text: str, variables: dict) -> str: Replace variables enclosed in curly braces with their corresponding values from the given dictionary. Leave variables that are not found in the dictionary or are invalid (like nested braces) as they are. import re def replacer(match): variable_name = match.group(1) return variables.get(variable_name, match.group(0)) pattern = re.compile(r\'{([^{}]+)}\') result = pattern.sub(replacer, text) return result"},{"question":"# Coding Question: Connect Four Board Evaluation Given a Connect Four board, write a function that evaluates the board and determines the winner, if any. Connect Four is played on a 6x7 board, and players take turns dropping discs into columns. The first player to align four of their discs either horizontally, vertically, or diagonally wins. Function Signature ```python def connect_four_winner(board: list[list[str]]) -> str: pass ``` Input Parameters * `board` (list of list of str): A 6x7 grid representing the Connect Four board. Each element is either \'R\' (Red), \'Y\' (Yellow), or \'.\' (empty). Output * A string indicating the winner (\'R\' or \'Y\') based on the current state of the board. If there is no winner, return \'None\'. Constraints * The input `board` will always be a 6x7 grid. * There will be at most one winner. * The input will be a valid Connect Four board (no invalid states like discs floating above empty spaces). Examples ```python >>> connect_four_winner([[\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'R\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'Y\', \'R\', \'.\', \'.\', \'.\'], [\'.\', \'Y\', \'Y\', \'R\', \'.\', \'.\', \'.\'], [\'R\', \'R\', \'R\', \'R\', \'.\', \'.\', \'.\']]) \'R\' >>> connect_four_winner([[\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'R\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'R\', \'Y\'], [\'.\', \'.\', \'.\', \'.\', \'R\', \'Y\', \'Y\']]) \'None\' >>> connect_four_winner([[\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'Y\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'Y\', \'R\', \'.\', \'.\'], [\'.\', \'.\', \'Y\', \'R\', \'Y\', \'.\', \'.\'], [\'.\', \'Y\', \'R\', \'Y\', \'R\', \'R\', \'.\']]) \'Y\' ``` Ensure your implementation checks vertical, horizontal, and diagonal alignments to determine the winner.","solution":"def connect_four_winner(board): rows = len(board) columns = len(board[0]) def check_winner(player): # Check horizontal for r in range(rows): for c in range(columns - 3): if all(board[r][c + i] == player for i in range(4)): return True # Check vertical for r in range(rows - 3): for c in range(columns): if all(board[r + i][c] == player for i in range(4)): return True # Check diagonal (bottom-left to top-right) for r in range(rows - 3): for c in range(columns - 3): if all(board[r + i][c + i] == player for i in range(4)): return True # Check diagonal (top-left to bottom-right) for r in range(3, rows): for c in range(columns - 3): if all(board[r - i][c + i] == player for i in range(4)): return True return False for player in [\'R\', \'Y\']: if check_winner(player): return player return \'None\'"},{"question":"# Matrix Row and Column Swap **Context**: Matrix manipulations are a fundamental part of many numerical and data processing algorithms. One of the simpler manipulations involves swapping rows and columns, which can be useful in a variety of applications, including matrix factorization, searching, and optimization problems. **Problem Statement**: Implement a function `swap_rows_and_columns` that swaps the given rows and columns of a square matrix. The function should return a new matrix with the specified swaps applied, without modifying the original matrix. # Function Signature ```python def swap_rows_and_columns(matrix: np.ndarray, row1: int, row2: int, col1: int, col2: int) -> np.ndarray: pass ``` # Input - **matrix (np.ndarray)**: A square matrix of dimensions (n, n). - **row1 (int)**: The index of the first row to swap. - **row2 (int)**: The index of the second row to swap. - **col1 (int)**: The index of the first column to swap. - **col2 (int)**: The index of the second column to swap. # Output - **np.ndarray**: A new matrix with the specified rows and columns swapped. # Constraints 1. The input matrix will always be square (n x n). 2. Indices for rows and columns (row1, row2, col1, col2) are guaranteed to be within the valid range [0, n-1]. # Examples ```python import numpy as np matrix = np.array([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) row1, row2 = 1, 3 col1, col2 = 0, 2 print(swap_rows_and_columns(matrix, row1, row2, col1, col2)) # Output: # array([ # [ 3, 2, 1, 4], # [15, 14, 13, 16], # [11, 10, 9, 12], # [ 7, 6, 5, 8] # ]) ``` # Notes * Your function should not modify the original matrix; instead, it should return a new matrix with the swaps applied. * Ensure that swapping operations are correctly done simultaneously to avoid intermediate modifications affecting subsequent swaps. * Handle edge cases, such as the same row and column indices being provided for the swap (`row1 == row2` or `col1 == col2`), without raising an error. **Testing**: Besides the provided example, create additional test cases to validate your implementation, including edge cases such as: 1. Swapping the same index for rows and columns. 2. Applying swaps on small (e.g., 2x2) and larger matrices. 3. Ensuring that the original matrix remains unmodified after the function execution. --- This new question is consistent with the previously provided question in terms of style, complexity, scope, and length. It addresses fundamental matrix operations, combining practical numerical processes with programming skills, which aligns well with the original problem set.","solution":"import numpy as np def swap_rows_and_columns(matrix: np.ndarray, row1: int, row2: int, col1: int, col2: int) -> np.ndarray: n = matrix.shape[0] new_matrix = matrix.copy() # Swap rows new_matrix[[row1, row2], :] = new_matrix[[row2, row1], :] # Swap columns new_matrix[:, [col1, col2]] = new_matrix[:, [col2, col1]] return new_matrix"},{"question":"# Question: Implementing a File-based Key-Value Store in Python You are tasked with developing a simple file-based key-value store in Python that supports basic CRUD (Create, Read, Update, Delete) operations. The key-value store should persist data to a file on the disk, allowing the data to survive sessions. # Task: 1. **Implement the Key-Value Store**: - Create a class `FileKeyValueStore` with methods to: - Initialize the store with a given file path. - Add or update a key-value pair. - Retrieve a value by its key. - Delete a key-value pair. - Persist the store to a file. - Load the store from a file. 2. **Analyze and Test**: - Analyze the efficiency of your algorithm in terms of time and space complexity. - Write appropriate unittests to ensure that the implementation handles edge cases and performs correctly. # Specifications: - **`FileKeyValueStore` Class**: - `__init__(self, file_path: str)`: Initialize the store object and load data from the specified file. - `put(self, key: str, value: str) -> None`: Add or update a key-value pair in the store. - `get(self, key: str) -> str | None`: Retrieve the value associated with the specified key. - `delete(self, key: str) -> bool`: Remove the key-value pair associated with the specified key. - `save(self) -> None`: Persist the current state of the store to the file. - `load(self) -> None`: Load the state of the store from the file. # Input and Output - **Input**: - A string file path for initializing the store. - String keys and values for CRUD operations. - **Output**: - For `get` method: the value associated with the key or `None` if the key does not exist. - For `delete` method: a boolean indicating success or failure of the deletion. # Constraints: - Keys and values will only comprise ASCII letters and digits. - The file path must be a valid path on the filesystem. - Concurrent access to the file is not required to be handled. # Example: ```python # Initialize key-value store with file path \'store.txt\' kv_store = FileKeyValueStore(\'store.txt\') # Add or update key-value pairs kv_store.put(\'name\', \'John Doe\') kv_store.put(\'age\', \'30\') # Retrieve the value for a given key name = kv_store.get(\'name\') print(name) # Output: \\"John Doe\\" # Delete a key-value pair success = kv_store.delete(\'age\') print(success) # Output: True # Save the store to the file kv_store.save() # Load the store from the file (initialization will also load automatically) kv_store.load() # Check that the changes persist name = kv_store.get(\'name\') print(name) # Output: \\"John Doe\\" ``` # Deliverables: - The complete implementation of `FileKeyValueStore`. - Analysis of the implemented code regarding its time and space complexity. - Unittests to validate correct operation of the key-value store for edge cases and general cases.","solution":"import json import os class FileKeyValueStore: def __init__(self, file_path: str): self.file_path = file_path self.store = {} self.load() def put(self, key: str, value: str) -> None: self.store[key] = value def get(self, key: str) -> str | None: return self.store.get(key) def delete(self, key: str) -> bool: if key in self.store: del self.store[key] return True return False def save(self) -> None: with open(self.file_path, \'w\') as f: json.dump(self.store, f) def load(self) -> None: if os.path.exists(self.file_path): with open(self.file_path, \'r\') as f: self.store = json.load(f)"},{"question":"# Problem Statement Implement a function `knight_moves` that calculates the minimum number of moves required for a knight to travel from a starting position to a target position on an 8x8 chessboard. The function should take two tuples as input: the starting position and the target position, each represented by a pair of integers (row, column). # Requirements * The coordinates for both positions will be given as 0-indexed integers (0 <= row, col <= 7). * The start and target positions are guaranteed to be valid within the 8x8 board. * The function must return an integer representing the minimum number of moves required for the knight to reach the target position from the start position. # Input * Two tuples, `start` and `target`, each consisting of two integers. # Output * An integer representing the minimum number of moves required for the knight to travel from the start to the target position. # Function Signature ```python def knight_moves(start: tuple[int, int], target: tuple[int, int]) -> int: pass ``` # Example ```python >>> knight_moves((0, 0), (7, 7)) 6 >>> knight_moves((0, 0), (2, 1)) 1 >>> knight_moves((3, 3), (4, 3)) 3 >>> knight_moves((0, 0), (0, 0)) 0 ``` # Constraints * The chessboard is always 8x8. * The start and target positions are valid within the range (0-7) for both row and column.","solution":"from collections import deque def knight_moves(start: tuple[int, int], target: tuple[int, int]) -> int: if start == target: return 0 def in_bounds(x, y): return 0 <= x < 8 and 0 <= y < 8 moves = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] visited = [[False]*8 for _ in range(8)] queue = deque([(start[0], start[1], 0)]) while queue: x, y, d = queue.popleft() for dx, dy in moves: nx, ny = x + dx, y + dy if (nx, ny) == target: return d + 1 if in_bounds(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, d + 1)) return -1 # Should never reach here if inputs are valid"},{"question":"# Coding Question: Minimum Steps to Reach Target in a Knight\'s Move Background You are given a square chessboard of `N x N` dimensions and a knight that moves with standard chess rules (in an L-shape: two squares in a horizontal or vertical direction and then one square perpendicular). The task is to determine the minimum number of moves required for the knight to reach from a starting position to a target position on the chessboard. If the target position is not reachable, return -1. Task Write a function `min_knight_moves(N: int, start: tuple[int, int], target: tuple[int, int]) -> int` that returns the minimum number of moves required for the knight to reach the target position from the start position. Constraints * 1 <= N <= 1000 * `start` and `target` are tuples (x, y) representing coordinates on the chessboard (0-indexed). Input Format * `N`: An integer representing the dimensions of the chessboard. * `start`: A tuple (x, y) representing the starting position of the knight. * `target`: A tuple (x, y) representing the target position the knight must reach. Output Format * Return an integer representing the minimum number of moves, or -1 if the target is unreachable. Example ```python N = 8 start = (0, 0) target = (7, 7) min_knight_moves(N, start, target) # Output: 6 N = 8 start = (0, 0) target = (3, 3) min_knight_moves(N, start, target) # Output: 2 N = 8 start = (0, 0) target = (7, 6) min_knight_moves(N, start, target) # Output: 5 ``` Explanation - In the first example, the knight needs 6 moves to reach from (0, 0) to (7, 7). - In the second example, the knight needs 2 moves to reach from (0, 0) to (3, 3). - In the third example, the knight needs 5 moves to reach from (0, 0) to (7, 6). Hint A Breadth-First Search (BFS) algorithm is often useful for finding the shortest path in unweighted grids or graphs.","solution":"from collections import deque def min_knight_moves(N: int, start: tuple[int, int], target: tuple[int, int]) -> int: # Directions a knight can move in (8 possible directions) directions = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)] # Check if the start and target positions are valid def is_valid(x, y): return 0 <= x < N and 0 <= y < N # Initialize the queue with the starting position queue = deque([(start[0], start[1], 0)]) # (x, y, steps) visited = set((start[0], start[1])) while queue: x, y, steps = queue.popleft() # If we reached the target, return the number of steps if (x, y) == target: return steps # Explore all possible moves for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) # If the target position is not reachable return -1"},{"question":"# Coding Assessment Question: Imagine you are tasked with analyzing strings for symmetry and transformation patterns. **Problem Statement:** You are given a collection of strings. Your assignment is to identify all possible palindromic substrings within each string without transforming the string. After identifying the palindromic substrings, you will then determine the longest palindromic substring for each string and return a list of these substrings. If a string does not contain any palindromic substrings, return an empty string for that string. **Requirements:** 1. **is_palindrome(s: str) -> bool**: Given a substring, determine if it is a palindrome. - Input: A string, `s`. - Output: `True` if `s` is a palindrome, else `False`. 2. **find_longest_palindromes(strings: list[str]) -> list[str]**: Finds the longest palindromic substring for each string in the input list. - Input: A list of strings, `strings`. - Output: A list of strings representing the longest palindromic substring from each input string. **Input/Output Format:** - The `find_longest_palindromes` function should take a list of strings and return a list where each element is either the longest palindromic substring from the corresponding input string or an empty string if no palindrome is found. - The `is_palindrome` function should take a single string and return a boolean indicating whether the string is a palindrome. **Example:** ```python def is_palindrome(s): # Your palindrome checking logic here def find_longest_palindromes(strings): # Your implementation here # Example use case strings = [\\"babad\\", \\"cbbd\\", \\"a\\", \\"racecar\\", \\"noon\\", \\"hello\\"] assert find_longest_palindromes(strings) == [\\"bab\\", \\"bb\\", \\"a\\", \\"racecar\\", \\"noon\\", \\"\\"] ``` **Constraints/Limitations:** - For `is_palindrome`: The string input will always be non-empty. - For `find_longest_palindromes`: The input list will contain at least one string and each string will have a length between 1 and 1000 characters.","solution":"def is_palindrome(s: str) -> bool: Determines if the given string is a palindrome. Parameters: s (str): Input string to check for palindrome. Returns: bool: True if the input string is a palindrome, False otherwise. return s == s[::-1] def find_longest_palindromes(strings: list[str]) -> list[str]: Finds the longest palindromic substring for each string in the input list. Parameters: strings (list[str]): List of input strings. Returns: list[str]: List of longest palindromic substrings for each input string. def longest_palindrome(s: str) -> str: n = len(s) if n == 0: return \\"\\" longest = \\"\\" for i in range(n): for j in range(i, n): substring = s[i:j+1] if is_palindrome(substring) and len(substring) > len(longest): longest = substring return longest return [longest_palindrome(s) for s in strings]"},{"question":"# Problem Statement Scenario: As a part of a database migration project, you are required to write a utility function that verifies the integrity of numeric data entries. One of the primary integrity check scenarios is to validate that a given list of integers is sorted in non-decreasing order. Additionally, the function should be able to handle large datasets efficiently and handle any edge cases appropriately. Task: You need to implement a function that checks if a given list of integers is sorted in non-decreasing order. This function must be robust and efficient, addressing various input scenarios, including large lists and edge cases. # Function Signature: ```python def is_sorted_non_decreasing(nums: List[int]) -> bool: ``` Input: - `nums`: A list of integers (`0 ≤ len(nums) ≤ 10^6`). Output: - Returns `True` if the list is sorted in non-decreasing order, `False` otherwise. Constraints: - Optimize for both time and space complexity. - The function should handle very large lists efficiently. Example: ```python is_sorted_non_decreasing([1, 2, 2, 3, 4, 5, 5]) # Expected Output: True is_sorted_non_decreasing([5, 3, 4, 2, 1]) # Expected Output: False is_sorted_non_decreasing([10, 20, 20, 20, 30]) # Expected Output: True is_sorted_non_decreasing([1000]) # Expected Output: True ``` # Note: 1. Ensure that the function works efficiently even with very large lists. 2. Edge cases to consider include empty lists and lists with all elements being the same.","solution":"from typing import List def is_sorted_non_decreasing(nums: List[int]) -> bool: This function checks if the given list of integers is sorted in non-decreasing order. for i in range(1, len(nums)): if nums[i] < nums[i - 1]: return False return True"},{"question":"# Employee Salary Calculator You are asked to develop an employee salary calculator system that determines the monthly salary of employees based on their hourly rate and hours worked. The system should also compute overtime pay for hours worked beyond a specified threshold. **Objectives**: 1. **Salary Calculation**: - Calculate the regular salary based on the hourly rate and regular hours worked. - Calculate the overtime pay for hours worked beyond the regular hours threshold. Overtime rate is 1.5 times the hourly rate. - Calculate the total monthly salary for each employee including overtime pay if any. 2. **Function Definitions**: - **`calculate_regular_salary(hours_worked: float, hourly_rate: float) -> float`**: Calculate the regular salary based on hourly rate and hours worked. - **`calculate_overtime_salary(hours_worked: float, hourly_rate: float, regular_hours: float) -> float`**: Calculate the overtime salary for hours worked beyond the regular hours. - **`calculate_total_salary(hours_worked: float, hourly_rate: float, regular_hours: float) -> float`**: Calculate the total monthly salary. **Input/Output Specifications**: - **`calculate_regular_salary`**: - **Input**: - `hours_worked` (float): The number of regular hours worked in a month. - `hourly_rate` (float): The employee\'s hourly pay rate. - **Output**: - (float): The calculated regular salary. - **Constraints**: - `hours_worked` should be non-negative. - `hourly_rate` should be positive. - **`calculate_overtime_salary`**: - **Input**: - `hours_worked` (float): The total hours worked in a month. - `hourly_rate` (float): The employee\'s hourly pay rate. - `regular_hours` (float): The threshold of regular hours before overtime kicks in. - **Output**: - (float): The calculated overtime salary. - **Constraints**: - `hours_worked`, `hourly_rate`, and `regular_hours` should be non-negative. - Overtime hours are calculated as the difference between `hours_worked` and `regular_hours`. - **`calculate_total_salary`**: - **Input**: - `hours_worked` (float): The total hours worked in a month. - `hourly_rate` (float): The employee\'s hourly pay rate. - `regular_hours` (float): The threshold of regular hours before overtime kicks in. - **Output**: - (float): The total calculated salary for the month including regular and overtime pay. - **Constraints**: - The inputs should meet the constraints of the previous functions. **Example**: Given the following inputs: - For `calculate_regular_salary`: ```python calculate_regular_salary(160, 20) ``` Output: ```python 3200.0 ``` - For `calculate_overtime_salary`: ```python calculate_overtime_salary(180, 20, 160) ``` Output: ```python 600.0 ``` - For `calculate_total_salary`: ```python calculate_total_salary(180, 20, 160) ``` Output: ```python 3800.0 ``` **Constraints**: - Handle invalid inputs appropriately. - Use constants for regular hours threshold and overtime rate multiplier if necessary. - Ensure the calculations are performed accurately. Implement the salary calculator in Python to compute employee salaries based on the provided specifications.","solution":"def calculate_regular_salary(hours_worked: float, hourly_rate: float) -> float: Calculate the regular salary based on hourly rate and hours worked. if hours_worked < 0 or hourly_rate < 0: raise ValueError(\\"hours_worked and hourly_rate must be non-negative\\") return hours_worked * hourly_rate def calculate_overtime_salary(hours_worked: float, hourly_rate: float, regular_hours: float) -> float: Calculate the overtime salary for hours worked beyond the regular hours. if hours_worked < 0 or hourly_rate < 0 or regular_hours < 0: raise ValueError(\\"hours_worked, hourly_rate, and regular_hours must be non-negative\\") overtime_hours = max(0, hours_worked - regular_hours) overtime_rate = hourly_rate * 1.5 return overtime_hours * overtime_rate def calculate_total_salary(hours_worked: float, hourly_rate: float, regular_hours: float) -> float: Calculate the total monthly salary including regular and overtime pay. regular_salary = calculate_regular_salary(min(hours_worked, regular_hours), hourly_rate) overtime_salary = calculate_overtime_salary(hours_worked, hourly_rate, regular_hours) return regular_salary + overtime_salary"},{"question":"# Coding Question Context: You are tasked with creating a system that handles text analysis. Specifically, you need to develop a function to identify the longest substring in a given string consisting of unique characters. Prompt: Given a string, implement a function `longest_unique_substring(s: str) -> str` that returns the longest substring containing all unique characters. If there are multiple substrings with the same maximum length, return the one that appears first. Input: * A string `s` consisting of lower and upper case English letters. Output: * The longest substring of `s` which contains all unique characters. Constraints: * ( 1 leq text{len}(s) leq 10^5 ) Example: ```python def longest_unique_substring(s: str) -> str: pass # Example usage: print(longest_unique_substring(\\"abcabcbb\\")) # Output: \\"abc\\" print(longest_unique_substring(\\"bbbbb\\")) # Output: \\"b\\" print(longest_unique_substring(\\"pwwkew\\")) # Output: \\"wke\\" ``` Performance: * Optimize your solution for performance to handle strings up to the maximum constraints efficiently.","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring with all unique characters. If there are multiple substrings with the same length, returns the first one. n = len(s) if n == 0: return \\"\\" char_index_map = {} start = 0 max_len = 0 longest_substr_start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end if end - start + 1 > max_len: max_len = end - start + 1 longest_substr_start = start return s[longest_substr_start:longest_substr_start + max_len]"},{"question":"# Scenario You are working as a software developer for a company that designs algorithms for analyzing social networks. Your task is to implement a recommendation system that suggests new friends to users based on shared connections. # Task Create a Python function that suggests new friends for a given user by identifying users who share the most common friends with them. Use an adjacency list to represent the friendships in the network. # Function Signature ```python def suggest_friends(user, friendships): ``` # Inputs - `user` (int): The ID of the user for whom you want to recommend new friends. - `friendships` (Dict[int, List[int]]): A dictionary where the keys are user IDs and the values are lists of IDs representing the friends of each user. # Output - A list of `suggestions` (List[Tuple[int, int]]): A list of tuples where each tuple (friend_id, shared_friends_count) represents a user ID of a suggested friend and the count of shared friends with the given user. The list should be sorted by `shared_friends_count` in descending order. If the shared friends count is the same, sort by `friend_id` in ascending order. # Constraints - Assume the friendships are bidirectional (if user `A` is a friend of user `B`, then `B` is also a friend of `A`). - A user cannot be friends with themselves. - User IDs are unique positive integers. # Example Given the friendships: ```python friendships = { 1: [2, 3, 4], 2: [1, 3], 3: [1, 2, 5], 4: [1], 5: [3] } ``` Calling the function with: ```python user = 1 suggest_friends(user, friendships) ``` The function should output: ``` [(5, 1)] ``` # Remarks - Exclude users who are already friends with the given user from the suggestions. - Make sure to handle cases where no new friends can be suggested. - Consider users who share at least one friend with the given user for potential recommendations.","solution":"from collections import defaultdict from typing import Dict, List, Tuple def suggest_friends(user: int, friendships: Dict[int, List[int]]) -> List[Tuple[int, int]]: shared_friends_count = defaultdict(int) user_friends = set(friendships.get(user, [])) for friend in user_friends: for potential_friend in friendships.get(friend, []): if potential_friend != user and potential_friend not in user_friends: shared_friends_count[potential_friend] += 1 suggestions = sorted(shared_friends_count.items(), key=lambda x: (-x[1], x[0])) return suggestions"},{"question":"# Binary Search Tree Validation You are given a Binary Search Tree (BST) class implemented in Python with basic functionalities such as insert and search. Your task is to enhance this BST implementation with the following additional features while adhering to the given constraints: 1. **Height Calculation (`get_height`)**: Add a method to calculate and return the height of the BST. 2. **Find K-th Smallest Element (`find_kth_smallest`)**: Add a method to find and return the k-th smallest element in the BST. 3. **Validate BST (`is_valid_bst`)**: Add a method to validate if the current tree still adheres to the BST properties. Constraints * The methods should handle edge cases effectively. For example, `get_height` should return -1 for an empty tree. * You must ensure that each method operates efficiently, utilizing the properties of the BST. * The `find_kth_smallest` method should run in O(h + k) time where h is the height of the tree. Function Signatures ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): # Implementation for inserting value into the BST def search(self, value): # Implementation for searching a value in the BST def get_height(self, node: TreeNode = None) -> int: # Implement get_height here def find_kth_smallest(self, k: int) -> int: # Implement find_kth_smallest here def is_valid_bst(self, node: TreeNode = None) -> bool: # Implement is_valid_bst here ``` Example Usage ```python # Example usage bst = BinarySearchTree() bst.insert(10).insert(5).insert(15).insert(3).insert(7).insert(12).insert(17) print(bst.get_height()) # Output: 2 (since the tree height is 2) print(bst.find_kth_smallest(3)) # Output: 7 (3rd smallest element in the BST) print(bst.is_valid_bst()) # Output: True (the tree is a valid BST) ``` Expand upon the original Binary Search Tree implementation by completing these features. Ensure that you include tests to verify the correctness of your implementations.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert(self.root, value) return self def _insert(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert(node.right, value) def search(self, value): return self._search(self.root, value) def _search(self, node, value): if node is None or node.value == value: return node if value < node.value: return self._search(node.left, value) return self._search(node.right, value) def get_height(self, node=None): if node is None: node = self.root if node is None: return -1 return self._get_height(node) def _get_height(self, node): if node is None: return -1 left_height = self._get_height(node.left) right_height = self._get_height(node.right) return 1 + max(left_height, right_height) def find_kth_smallest(self, k): if self.root is None: return None return self._find_kth_smallest(self.root, k)[1] def _find_kth_smallest(self, node, k): stack = [] current = node count = 0 while stack or current: if current: stack.append(current) current = current.left else: current = stack.pop() count += 1 if count == k: return (True, current.value) current = current.right return (False, None) def is_valid_bst(self, node=None): if node is None: node = self.root return self._is_valid_bst(node, float(\'-inf\'), float(\'inf\')) def _is_valid_bst(self, node, low, high): if node is None: return True if not (low < node.value < high): return False return self._is_valid_bst(node.left, low, node.value) and self._is_valid_bst(node.right, node.value, high)"},{"question":"# Coding Question: Maximum Binary Substring Length **Scenario**: You work as a software developer for a cybersecurity firm. One common operation in cybersecurity is analyzing sequences of binary data. You are tasked with developing a solution that can process binary strings to detect and analyze critical patterns. Specifically, you need to identify the length of the longest contiguous substring composed solely of `1`s. **Problem**: Implement a function `max_binary_substring_length` which takes a binary string as input and returns the length of the longest contiguous substring of `1`s. # Function Signature: ```python def max_binary_substring_length(binary_string: str) -> int: Find the length of the longest contiguous substring of \'1\'s in a binary string. Args: binary_string (str): A string consisting of \'0\'s and \'1\'s Returns: int: The length of the longest contiguous substring of \'1\'s Examples: >>> max_binary_substring_length(\\"11011101111\\") 4 >>> max_binary_substring_length(\\"00001\\") 1 >>> max_binary_substring_length(\\"000\\") 0 ``` # Constraints: - The input string contains only the characters \'0\' and \'1\'. - The input string is non-empty. - The length of the string does not exceed (10^5) characters. # Examples: 1. **Input**: `\\"11011101111\\"` **Output**: `4` -> The longest contiguous substring of `1`s is `\\"1111\\"`. 2. **Input**: `\\"00001\\"` **Output**: `1` -> The longest contiguous substring of `1`s is `\\"1\\"`. 3. **Input**: `\\"000\\"` **Output**: `0` -> There are no `1`s in the string. ```python def max_binary_substring_length(binary_string: str) -> int: max_len = 0 current_len = 0 for char in binary_string: if char == \'1\': current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len ```","solution":"def max_binary_substring_length(binary_string: str) -> int: max_len = 0 current_len = 0 for char in binary_string: if char == \'1\': current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 0 return max_len"},{"question":"# Coding Problem: Balanced Subarray with Zero Sum You are given an integer array. Your task is to find the length of the longest subarray with a sum of zero. If there is no such subarray, return 0. **Function Signature**: ```python def longest_zero_sum_subarray(array: list) -> int: ``` **Input**: * `array` (list of int): A list containing n integer elements, where n >= 0. **Output**: * (int): The length of the longest subarray with a sum of zero. If no such subarray exists, return 0. **Constraints**: * The elements of the array can be positive, negative, or zero. * The function should maintain O(n) time complexity and O(n) space complexity. **Examples**: ```python assert longest_zero_sum_subarray([]) == 0 assert longest_zero_sum_subarray([4, 2, -3, 1, 6]) == 3 # The subarray [4, 2, -3] sums to zero. assert longest_zero_sum_subarray([1, 2, 3]) == 0 # No subarray sums to zero. assert longest_zero_sum_subarray([1, -1, 3, -3, 4]) == 4 # The subarray [1, -1, 3, -3] sums to zero. assert longest_zero_sum_subarray([-1, 1, 1, -1, -1, 1]) == 6 # The entire array sums to zero. ``` **Hint**: * Utilize a hashmap to store the cumulative sum and its corresponding index. If the same cumulative sum reappears, it indicates the elements between the previous index and the current index sum to zero.","solution":"def longest_zero_sum_subarray(array: list) -> int: prefix_sum = 0 sum_indices = {0: -1} max_len = 0 for idx, value in enumerate(array): prefix_sum += value if prefix_sum in sum_indices: max_len = max(max_len, idx - sum_indices[prefix_sum]) else: sum_indices[prefix_sum] = idx return max_len"},{"question":"# Problem Statement You are tasked with implementing a function `generate_prime_factors` that takes an integer `n` and returns a list of its prime factors in ascending order. Prime factors are the prime numbers that divide the number exactly, without leaving a remainder. # Input Format - An integer `n` where `2 <= n <= 10^6`. # Output Format - A list of prime factors of `n` in ascending order. # Function Signature ```python def generate_prime_factors(n: int) -> list[int]: pass ``` # Constraints - The input number `n` will be at least 2 and at most 10^6. # Example ```python assert generate_prime_factors(28) == [2, 2, 7] # 28 = 2 * 2 * 7 assert generate_prime_factors(29) == [29] # 29 is a prime number ``` # Approach: 1. Begin by dividing `n` by the smallest prime number `2` and keep a count of how many times you can divide `n` by `2` without leaving a remainder. 2. Move to the next potential factor `3` and continue dividing `n` similarly. 3. Repeat this process up to the square root of `n`. If `n` is still greater than 1 after the loop, then `n` is prime and should be added to the list of prime factors. 4. Return the list of prime factors. # Performance Requirements - Time Complexity: O(sqrt(n)) for factorization. - Space Complexity: O(log n) for storing the list of factors.","solution":"def generate_prime_factors(n: int) -> list[int]: Returns the prime factors of the given integer n in ascending order. prime_factors = [] # Step 1: Account for 2\'s while n % 2 == 0: prime_factors.append(2) n //= 2 # Step 2: Account for odd factors from 3 onwards factor = 3 while factor * factor <= n: while n % factor == 0: prime_factors.append(factor) n //= factor factor += 2 # Step 3: If n is still greater than 1, then it is prime if n > 1: prime_factors.append(n) return prime_factors"},{"question":"**Question 2: Coding Challenge: Finding Kth Smallest Element in a Matrix** Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, write a function to find the k-th smallest element in the matrix. # Function Signature ```python def kth_smallest(matrix: list[list[int]], k: int) -> int: pass ``` # Input - `matrix`: A list of lists of integers, where each inner list is sorted in ascending order, representing an `n x n` matrix. - `k`: An integer (1 <= k <= n^2): the position of the smallest element to find. # Output - An integer representing the k-th smallest element in the matrix. # Constraints - The matrix will always be a square matrix (i.e., `n x n` where 1 <= n <= 300). - Each row and column of the matrix is sorted in non-decreasing order. # Example ```python assert kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) == 13 assert kth_smallest([[1, 2], [1, 3]], 2) == 1 ``` # Performance Your solution should efficiently handle matrices up to the size 300x300, ensuring that the algorithm\'s time complexity is within acceptable limits for such input sizes.","solution":"import heapq def kth_smallest(matrix, k): Find the k-th smallest element in the given n x n matrix where rows and columns are sorted in ascending order. Args: matrix (list[list[int]]): A square matrix with sorted rows and columns. k (int): The position of the smallest element to find. Returns: int: The k-th smallest element in the matrix. # Min-heap to keep track of smallest elements n = len(matrix) min_heap = [] # Insert the first element of each row in the heap for row in range(min(n, k)): # We don\'t need to go beyond row count or k rows heapq.heappush(min_heap, (matrix[row][0], row, 0)) # Extract-min k-1 times count = 0 while min_heap: element, row, col = heapq.heappop(min_heap) count += 1 if count == k: return element if col + 1 < n: heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1)) # Example usage #print(kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)) #print(kth_smallest([[1, 2], [1, 3]], 2))"},{"question":"# Question: Rotate Matrix Elements Clockwise You are required to implement a function that rotates the elements of a given square matrix (NxN) in a clockwise direction by one step. Each rotation moves the elements that are closer to the center of the matrix. Specifications: - **Function Name**: `rotate_matrix_clockwise` - **Input**: - `matrix` (List[List[int]]): A square matrix of integers where `matrix` is NxN. - **Output**: - List[List[int]] representing the rotated matrix. Example: ```python >>> rotate_matrix_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[4, 1, 2], [7, 5, 3], [8, 9, 6]] >>> rotate_matrix_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] ``` Instructions: 1. Analyze how a matrix can be rotated clockwise by one step. 2. Implement the `rotate_matrix_clockwise` function based on the given specification. 3. Ensure the function accurately computes and returns the rotated matrix for various test cases. Take care of edge cases, such as the matrix being of minimal size (1x1), and ensure that the solution works within acceptable time for large matrices.","solution":"def rotate_matrix_clockwise(matrix): Rotates the elements of a given NxN matrix in a clockwise direction by one step. Parameters: - matrix : List[List[int]] : A square matrix of integers Returns: - List[List[int]] : Matrix after rotating clockwise by one step n = len(matrix) if n <= 1: return matrix # Create a new matrix to store the rotated result rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Question You are tasked with developing a text file analysis tool to process large text files efficiently. Your tool should provide options to perform different types of text analysis such as word frequency analysis, finding the most common words, and identifying unique words. # Function Specification **Task**: * Write a function `text_analysis` that reads a large text file and performs the following analyses: * Calculate the frequency of every word in the text. * Identify and return the `k` most common words. * Return the list of unique words not repeated in the text. **Functions to Implement**: ```python def text_analysis(file_path: str, analysis_type: str, k: int = 10) -> dict: pass ``` **Parameters**: * `file_path` (str): The path to the input text file. * `analysis_type` (str): The type of analysis to perform. It can be one of the following: * \'word_frequency\' - To get the frequency of each word in the text. * \'most_common\' - To get the k most common words in the text. * \'unique_words\' - To get the list of unique words in the text. * `k` (int): The number of most common words to return. This parameter is only relevant if `analysis_type` is set to \'most_common\'. Default value is 10. **Returns**: * A dictionary containing the results of the analysis: * For `word_frequency`: `{\'word_frequencies\': {\'word1\': freq1, \'word2\': freq2, ...}}` * For `most_common`: `{\'most_common_words\': [(\'word1\', freq1), (\'word2\', freq2), ...]}` * For `unique_words`: `{\'unique_words\': [word1, word2, ...]}` # Constraints: * The function should be optimized to handle very large text files efficiently. * Assume the file path is always valid and the file is a plain text file. * Handle case insensitivity by treating \'Word\' and \'word\' as the same. * Ignore punctuation and special characters when considering words. # Examples: Assuming `file_path` is the path to \\"large_text.txt\\", ```python # Word frequency analysis result = text_analysis(\\"large_text.txt\\", \\"word_frequency\\") # Most common words analysis result = text_analysis(\\"large_text.txt\\", \\"most_common\\", k=5) # Unique words analysis result = text_analysis(\\"large_text.txt\\", \\"unique_words\\") ``` # Implementation Notes: * Consider using Python\'s collections like Counter to efficiently count word frequencies. * Use regular expressions to handle punctuation and special characters. * Ensure the implementation uses memory efficiently, possibly using lazy reading techniques for large files. # Performance Considerations: * Optimize read operations to handle very large files without loading the entire file into memory. * Use efficient data structures and algorithms to minimize the time complexity of text processing functions.","solution":"import re from collections import Counter def text_analysis(file_path: str, analysis_type: str, k: int = 10): def clean_word(word): # Remove punctuation and convert to lower case return re.sub(r\'W+\', \'\', word).lower() word_counter = Counter() with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = line.split() cleaned_words = [clean_word(word) for word in words if clean_word(word)] word_counter.update(cleaned_words) if analysis_type == \'word_frequency\': return {\'word_frequencies\': dict(word_counter)} elif analysis_type == \'most_common\': return {\'most_common_words\': word_counter.most_common(k)} elif analysis_type == \'unique_words\': unique_words = [word for word, count in word_counter.items() if count == 1] return {\'unique_words\': unique_words} else: raise ValueError(\\"Invalid analysis_type. Choose from \'word_frequency\', \'most_common\', \'unique_words\'.\\")"},{"question":"**Question**: Robot Pathfinding in a Grid You are given a `m x n` grid representing a map, where each cell in the grid can be one of three types: - An empty cell (denoted by `0`) - An obstacle (denoted by `1`) - The robot (denoted by `R`) starting point The robot can move up, down, left, or right, but cannot move into cells with obstacles. Your task is to write a function to determine if there exists a path that the robot can take to reach from its starting point to the target cell given by coordinates `(tx, ty)`. If such a path exists, return the length of the shortest path; otherwise, return -1. # Function Signature ```python def shortest_path(grid: List[List[int]], tx: int, ty: int) -> int: pass ``` # Input The function should take in: 1. `grid: List[List[int]]`: A 2D list representing the map. The list will contain integers `0`, `1`, and one `R`. 2. `tx (int)`: The x-coordinate of the target cell. 3. `ty (int)`: The y-coordinate of the target cell. # Output The function should return: - The length of the shortest path from the robot\'s starting point to the target cell if a path exists. - `-1` if no such path exists. # Constraints - `2 ≤ m, n ≤ 100` - `0 ≤ tx < m` - `0 ≤ ty < n` - The robot\'s starting point is a unique `R` in the grid. # Examples ```python >>> grid = [ ... [0, 0, 1, 0], ... [0, 1, 0, 0], ... [R, 0, 0, 0] ... ] >>> shortest_path(grid, 2, 3) 3 >>> grid = [ ... [R, 0, 1], ... [1, 0, 1], ... [0, 0, 0] ... ] >>> shortest_path(grid, 2, 2) 4 >>> grid = [ ... [R, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> shortest_path(grid, 2, 2) -1 ``` # Performance Requirement - The function should efficiently handle different grid sizes up to the maximum constraints. # Additional Context (if needed) Imagine the grid as a warehouse layout, where `R` is a worker robot that needs to navigate from its starting point to pick up items placed in the target cell `(tx, ty)`, maneuvering around obstacles.","solution":"from collections import deque from typing import List, Tuple def shortest_path(grid: List[List[int]], tx: int, ty: int) -> int: # Find the starting position of the robot m, n = len(grid), len(grid[0]) start_x, start_y = -1, -1 for i in range(m): for j in range(n): if grid[i][j] == \'R\': start_x, start_y = i, j break if start_x != -1: break # Directions for movement directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start_x, start_y, 0)]) # (x, y, distance) visited = set((start_x, start_y)) # BFS for shortest path while queue: x, y, dist = queue.popleft() # Check if we reached the target if x == tx and y == ty: return dist # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] != 1: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"# Scenario You are tasked with developing an algorithm to manage a library\'s book borrowing system. The library needs a function to keep track of borrowed books and their return status. Each book has a unique identifier and can be borrowed multiple times. To simplify the task, you need to create a function that: - Records when books are borrowed. - Marks books as returned. - Determines how many books are currently borrowed. # Task Write a class `Library` which provides the following methods: - `borrow_book(book_id: int) -> None`: Registers a book as borrowed. - `return_book(book_id: int) -> None`: Registers a book as returned if it is currently borrowed. - `current_borrowed() -> int`: Returns the count of books that are currently borrowed. # Input/Output - **Input**: Methods receive integer inputs corresponding to book IDs. - **Output**: `current_borrowed` method returns an integer count of books currently borrowed. # Constraints - Book IDs are positive integers. - A book with the given ID can be borrowed and returned multiple times. - Unreturned books should only be counted once even if borrowed multiple times without being returned in between. # Function Signature ```python class Library: def __init__(self): pass def borrow_book(self, book_id: int) -> None: pass def return_book(self, book_id: int) -> None: pass def current_borrowed(self) -> int: pass ``` # Example ```python # Example Usage library = Library() library.borrow_book(1) library.borrow_book(2) library.borrow_book(3) print(library.current_borrowed()) # Output: 3 library.return_book(2) print(library.current_borrowed()) # Output: 2 library.borrow_book(1) library.borrow_book(4) print(library.current_borrowed()) # Output: 3 ``` # Notes Ensure that the `Library` class can handle multiple borrow and return events efficiently, and the `current_borrowed` method reflects the current state of borrowed books accurately.","solution":"class Library: def __init__(self): self.borrowed_books = set() def borrow_book(self, book_id: int) -> None: self.borrowed_books.add(book_id) def return_book(self, book_id: int) -> None: self.borrowed_books.discard(book_id) def current_borrowed(self) -> int: return len(self.borrowed_books)"},{"question":"Coding Assessment: Enhance String Manipulation Class Context You are working on a text processing tool that performs various string manipulation tasks. One of your tasks involves improving an existing function in the `TextProcessor` class to handle edge cases and improve its robustness. Problem Statement Enhance the method `count_words` in the `TextProcessor` class to handle edge cases and provide input validation to ensure it runs correctly under all realistic scenarios. Class and Method to Be Enhanced ```python class TextProcessor: @staticmethod def count_words(text: str) -> int: Count the number of words in the provided text. A word is defined as a sequence of characters separated by whitespace. >>> TextProcessor.count_words(\\"Hello world\\") 2 >>> TextProcessor.count_words(\\"The quick brown fox jumps over the lazy dog\\") 9 return len(text.split()) ``` Requirements 1. **Input Validation**: - Ensure `text` is a string. - Raise a `TypeError` with an appropriate message for invalid inputs. 2. **Edge Case Handling**: - Handle the case where `text` is an empty string or consists of only whitespace characters. 3. **Improved Clarity**: - Provide clear and concise docstrings. Input/Output Format * **Input**: - `text`: A string representing the input text to be processed. * **Output**: - An integer representing the count of words in the input text. Constraints 1. The input must be a string. 2. Words are sequences of characters separated by whitespace. Example ```python try: print(TextProcessor.count_words(\\"Hello world\\")) # Outputs: 2 print(TextProcessor.count_words(\\"The quick brown fox\\")) # Outputs: 4 print(TextProcessor.count_words(\\" \\")) # Outputs: 0 print(TextProcessor.count_words(\\"\\")) # Outputs: 0 print(TextProcessor.count_words(12345)) # Raises TypeError except TypeError as te: print(f\\"TypeError: {te}\\") ``` Complete the method `count_words` in the `TextProcessor` class to handle the specified requirements and constraints.","solution":"class TextProcessor: @staticmethod def count_words(text: str) -> int: Count the number of words in the provided text. A word is defined as a sequence of characters separated by whitespace. Parameters: text (str): The input text to process. Returns: int: The number of words in the input text. Raises: TypeError: If \'text\' is not a string. Examples: >>> TextProcessor.count_words(\\"Hello world\\") 2 >>> TextProcessor.count_words(\\"The quick brown fox jumps over the lazy dog\\") 9 if not isinstance(text, str): raise TypeError(\\"Input must be a string\\") return len(text.split())"},{"question":"# Problem Description You are given a list of strings containing both lowercase and uppercase alphabetical characters. Your task is to reorder the list such that all strings starting with uppercase letters come before those starting with lowercase letters, while maintaining the relative order of the strings within each group. # Task Write a function `reorder_strings` that takes a list of strings as input and returns a reordered list where strings starting with uppercase letters come first. # Input * `input_list` (List of strings): The list of strings to be reordered. # Output * (List of strings): A reordered list where all strings starting with uppercase letters precede those starting with lowercase letters, preserving their relative order. # Constraints * Each string in the list consists of only alphabetical characters. * The input list can be empty. * The length of each string will be at most 100 characters. * The number of strings in the list will be at most 1000. # Performance Requirements * The solution should have a linear time complexity, i.e., O(n), where n is the length of the list. # Example ```python def reorder_strings(input_list: list) -> list: pass # Example usage: print(reorder_strings([\\"apple\\", \\"Banana\\", \\"cherry\\", \\"Apricot\\", \\"blueberry\\"])) # Output: [\'Banana\', \'Apricot\', \'apple\', \'cherry\', \'blueberry\'] print(reorder_strings([\\"dog\\", \\"Elephant\\", \\"ant\\", \\"Bear\\", \\"cat\\"])) # Output: [\'Elephant\', \'Bear\', \'dog\', \'ant\', \'cat\'] print(reorder_strings([\\"Xenon\\", \\"xylophone\\", \\"Yacht\\", \\"zebra\\"])) # Output: [\'Xenon\', \'Yacht\', \'xylophone\', \'zebra\'] print(reorder_strings([\\"apple\\", \\"banana\\", \\"cherry\\"])) # Output: [\'apple\', \'banana\', \'cherry\'] ```","solution":"def reorder_strings(input_list): uppercase_strings = [] lowercase_strings = [] for string in input_list: if string[0].isupper(): uppercase_strings.append(string) else: lowercase_strings.append(string) return uppercase_strings + lowercase_strings"},{"question":"# Sliding Window Maximum You are tasked with implementing a function that calculates the maximum value in each sliding window of a specified size over a given list of integers. The sliding window moves one element at a time from the start to the end of the list. # Requirements 1. Provide a method `sliding_window_maximum(nums: list[int], k: int) -> list[int]` that calculates the maximum values. 2. `nums`: A list of integers representing the input data. 3. `k`: An integer representing the size of the sliding window. 4. The function should return a list of integers where each integer is the maximum value of the corresponding sliding window. # Constraints 1. The length of `nums` will always be greater than or equal to `k`. 2. `k` will be greater than 0 and less than or equal to the length of `nums`. 3. The integers in `nums` can be positive, negative, or zero. # Example ```python nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 print(sliding_window_maximum(nums, k)) # Example Output: [3, 3, 5, 5, 6, 7] ``` **Hint**: Utilize a deque (double-ended queue) to keep track of the indices of the elements in the current window, which could help in efficiently finding the maximum of the current window.","solution":"from collections import deque def sliding_window_maximum(nums, k): Returns the maximum value in each sliding window of size k for the given list of integers. if not nums or k == 0: return [] result = [] window = deque() for i, num in enumerate(nums): # Remove indices that are out of the current window while window and window[0] <= i - k: window.popleft() # Remove elements that are less than the current element nums[i] while window and nums[window[-1]] < num: window.pop() window.append(i) # The first index in the deque is the max of the current window if i >= k - 1: result.append(nums[window[0]]) return result"},{"question":"# Coding Assessment Question You are working with a large dataset that requires frequent statistical analysis. To expedite your computations, you need to create a utility function that computes the median of a list of numbers efficiently. **Task**: Implement a function `find_median` to calculate the median of a given list of integers, ensuring it performs well even with large datasets. Function Signature ```python def find_median(nums: List[int]) -> float: pass ``` Input * `nums` (List[int]): A list of integers whose median you need to determine. Output * Returns the median of the list as a float. Constraints * `1 <= len(nums) <= 10^6` * `-10^6 <= nums[i] <= 10^6` * The list may contain duplicate values. Performance Requirements * The function should use efficient sorting or selection techniques to handle large lists within a reasonable time frame. # Example Example Input ```python nums = [7, 3, 5, 6, 1] ``` Example Output ```python 5.0 ``` Example Input ```python nums = [2, 4, 1, 3] ``` Example Output ```python 2.5 ``` **Note**: - For lists with an odd number of elements, the median is the middle element after sorting the list. - For lists with an even number of elements, the median is the average of the two middle elements after sorting. Your task is to implement the function while considering the efficiency requirements and correctly handling the median calculation for both odd and even length lists.","solution":"from typing import List def find_median(nums: List[int]) -> float: nums.sort() n = len(nums) if n % 2 == 1: # Odd number of elements, return the middle one return float(nums[n // 2]) else: # Even number of elements, return the average of the two middle ones mid1, mid2 = nums[n // 2 - 1], nums[n // 2] return (mid1 + mid2) / 2"},{"question":"**Problem Statement: Water Boiling Point Adjustment** You are required to write a function that calculates the boiling point of water at different altitudes. The boiling point of water decreases as the altitude increases due to the decrease in atmospheric pressure. This can be approximated using the empirical formula: [ T_b(h) = 100 - frac{h}{300} ] - ( T_b(h) ) is the boiling point of water in degrees Celsius at altitude ( h ). - ( h ) is the altitude in meters above sea level. # Function Signature ```python def boiling_point_adjustment(altitude: float) -> float: pass ``` # Input: - `altitude` (float): The altitude in meters above sea level. Must be non-negative. # Output: - A float value representing the boiling point of water in degrees Celsius. # Constraints: - Altitude must be greater than or equal to 0 meters. # Example: ```python >>> boiling_point_adjustment(0) 100.0 >>> boiling_point_adjustment(1500) 95.0 ``` # Performance Requirements: - The function should operate in constant time, O(1). # Edge Cases: - Handle cases where the altitude is 0 meters. - Handle cases where the altitude is a very large value. # Implementation: 1. Validate the inputs. 2. Compute the boiling point using the formula. 3. Return the computed boiling point. Implement the function `boiling_point_adjustment` accordingly.","solution":"def boiling_point_adjustment(altitude: float) -> float: Calculate the boiling point of water at a given altitude. Parameters: - altitude (float): The altitude in meters above sea level. Must be non-negative. Returns: - float: The boiling point of water in degrees Celsius at the given altitude. if altitude < 0: raise ValueError(\\"Altitude must be a non-negative value.\\") boiling_point = 100 - (altitude / 300) return boiling_point"},{"question":"# Problem: Advanced String Manipulation Utility Develop a comprehensive string manipulation library in Python, which includes various functionalities to handle different string operations. The goal is to implement functions that modify and retrieve specific information from the given strings, ensuring efficient processing and clear error handling. Task Requirements: 1. **Function Signature**: - Implement the following functions: * `reverse_string` * `is_palindrome` * `count_vowels` * `find_longest_word` * `capitalize_words` * `remove_duplicates` 2. **Input and Output**: - Each function should accept a single string argument unless specifically noted. - Outputs should vary according to the function’s purpose, as specified below. - In cases of invalid input (e.g., non-string input), the function should raise a `TypeError` with an appropriate message. 3. **Constraints**: - The input string will always consist of printable characters. - Implementations should aim to handle the operations in linear time O(n) when applicable. Function Details and Examples: 1. **Reverse String** ```python def reverse_string(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"reverse_string() only accepts strings\\") return s[::-1] ``` 2. **Check Palindrome** ```python def is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"is_palindrome() only accepts strings\\") cleaned_s = \'\'.join(filter(str.isalnum, s)).lower() return cleaned_s == cleaned_s[::-1] ``` - `is_palindrome(\\"A man, a plan, a canal, Panama!\\")` should return `True`. 3. **Count Vowels** ```python def count_vowels(s: str) -> int: if not isinstance(s, str): raise TypeError(\\"count_vowels() only accepts strings\\") return sum(1 for char in s if char.lower() in \\"aeiou\\") ``` - `count_vowels(\\"hello world\\")` should return `3`. 4. **Find Longest Word** ```python def find_longest_word(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"find_longest_word() only accepts strings\\") words = s.split() longest = max(words, key=len, default=\\"\\") return longest ``` - `find_longest_word(\\"This is a simple test string\\")` should return `\\"simple\\"`. 5. **Capitalize Words** ```python def capitalize_words(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"capitalize_words() only accepts strings\\") return \' \'.join(word.capitalize() for word in s.split()) ``` - `capitalize_words(\\"hello world\\")` should return `\\"Hello World\\"`. 6. **Remove Duplicates** ```python def remove_duplicates(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"remove_duplicates() only accepts strings\\") seen = set() return \'\'.join(seen.add(char) or char for char in s if char not in seen) ``` - `remove_duplicates(\\"hello world\\")` should return `\\"helo wrd\\"`. Test Your Functions: Ensure to cover the following cases in your tests: - Typical valid inputs showing expected string manipulations. - Boundary cases like empty strings. - Invalid inputs raising appropriate errors. Provide at least one test example for each utility function in the form of `assert` statements to validate their behavior.","solution":"def reverse_string(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"reverse_string() only accepts strings\\") return s[::-1] def is_palindrome(s: str) -> bool: if not isinstance(s, str): raise TypeError(\\"is_palindrome() only accepts strings\\") cleaned_s = \'\'.join(filter(str.isalnum, s)).lower() return cleaned_s == cleaned_s[::-1] def count_vowels(s: str) -> int: if not isinstance(s, str): raise TypeError(\\"count_vowels() only accepts strings\\") return sum(1 for char in s if char.lower() in \\"aeiou\\") def find_longest_word(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"find_longest_word() only accepts strings\\") words = s.split() longest = max(words, key=len, default=\\"\\") return longest def capitalize_words(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"capitalize_words() only accepts strings\\") return \' \'.join(word.capitalize() for word in s.split()) def remove_duplicates(s: str) -> str: if not isinstance(s, str): raise TypeError(\\"remove_duplicates() only accepts strings\\") seen = set() return \'\'.join(seen.add(char) or char for char in s if char not in seen)"},{"question":"**Symmetric Subarray Sum** Given an array of integers, we want to determine whether there is a subarray within it that contains the same elements in the same order when read from left to right and from right to left (i.e., a subarray that is a palindrome). # Scenario You must write a function that receives an array of integers and returns `True` if there exists a symmetric (palindromic) subarray within it, and `False` otherwise. # Task Write a function that: 1. Iterates over all possible subarrays to check if they are symmetric. 2. Ensures efficient checking to match the complexity expected in competitive programming. # Function Signature ```python def has_symmetric_subarray(arr: List[int]) -> bool: pass ``` # Input - `arr` (List[int]): An array of integers (1 <= len(arr) <= 10^3, -10^6 <= arr[i] <= 10^6). # Output - Returns `True` if there is a symmetric subarray, `False` otherwise. # Constraints - Your algorithm should have a time complexity efficient enough for the given input size constraints. - Handle arrays with a length of up to 1000 elements properly. # Example ```python >>> has_symmetric_subarray([1, 2, 3, 2, 1]) True >>> has_symmetric_subarray([1, 2, 3, 4, 5]) False >>> has_symmetric_subarray([1, 2, 3, 3, 2, 1]) True >>> has_symmetric_subarray([7, 1, 3, 6, 3, 1, 7]) True >>> has_symmetric_subarray([1, 2]) False ``` # Notes - The function should be able to handle the edge cases such as: - An array with a single element, which is trivially symmetric. - Arrays with no symmetric subarray at all. - Arrays where the entire array is a symmetric subarray. - Ensure proper handling of cases where the symmetric subarray is in the middle or at the ends of the array.","solution":"from typing import List def has_symmetric_subarray(arr: List[int]) -> bool: Determines if there is a symmetric subarray within the given array. A symmetric subarray reads the same from left to right and from right to left. Parameters: arr (List[int]): The input array of integers. Returns: bool: True if there exists a symmetric subarray, False otherwise. n = len(arr) # Check all subarrays of length more than 1 for symmetry for start in range(n): for end in range(start + 1, n): subarray = arr[start:end + 1] if subarray == subarray[::-1]: return True return False"},{"question":"# Coding Task Graph traversal is a fundamental concept in computer science, particularly for searching and navigating data structures. A graph is typically represented as an adjacency matrix or adjacency list. In this task, you\'ll implement depth-first search (DFS) and breadth-first search (BFS) to traverse a graph. You are required to implement two functions `dfs_traversal` and `bfs_traversal` that take in an adjacency list representing the graph and a starting vertex, and return a list of vertices in the order they are visited. Function Signatures ```python def dfs_traversal(graph: dict, start: int) -> list[int]: def bfs_traversal(graph: dict, start: int) -> list[int]: ``` # Input * `graph` - A dictionary where keys represent vertices and values are lists of vertices directly connected to the key vertex. * `start` - The starting vertex for the traversal. # Output * A list of vertices in the order they are visited during the traversal. # Constraints * The graph is represented as a dictionary where keys and values are integers. * There are no isolated vertices. * The number of vertices in the graph will not exceed 1000. * The start vertex will always exist in the graph. # Examples ```python graph = { 0: [1, 2], 1: [0, 3, 4], 2: [0, 4], 3: [1], 4: [1, 2] } dfs_traversal(graph, 0) # Output: [0, 1, 3, 4, 2] bfs_traversal(graph, 0) # Output: [0, 1, 2, 3, 4] ``` # Explanation In a DFS traversal starting from vertex 0, the recursive exploration visits 0, then 1, moves deeper to 3, backtracks to 1, then to 4, and finally to 2. In a BFS traversal, starting from vertex 0, it visits 0 first, then its direct neighbors 1 and 2, followed by the neighbors\' neighbors, ensuring all nodes at the present depth level are visited before moving on to nodes at the next depth. # Performance Requirements * The solution should handle large graphs efficiently. * Make use of appropriate data structures to manage the traversal process. Implement the functions `dfs_traversal` and `bfs_traversal` as per the above specifications.","solution":"def dfs_traversal(graph: dict, start: int) -> list[int]: Depth-first search traversal of a graph. Parameters: graph (dict): Adjacency list of the graph. start (int): Starting vertex for the traversal. Returns: list[int]: List of vertices in the order they are visited. visited = set() result = [] def dfs(vertex): visited.add(vertex) result.append(vertex) for neighbor in graph[vertex]: if neighbor not in visited: dfs(neighbor) dfs(start) return result def bfs_traversal(graph: dict, start: int) -> list[int]: Breadth-first search traversal of a graph. Parameters: graph (dict): Adjacency list of the graph. start (int): Starting vertex for the traversal. Returns: list[int]: List of vertices in the order they are visited. visited = set() queue = [start] result = [] while queue: vertex = queue.pop(0) if vertex not in visited: visited.add(vertex) result.append(vertex) queue.extend([neighbor for neighbor in graph[vertex] if neighbor not in visited]) return result"},{"question":"# Determine Temperature based on Pressure using the Ideal Gas Law Problem Description: Given the pressure, calculate the corresponding temperature using the Ideal Gas Law for a fixed volume and number of moles of gas. Formula: [ T = frac{P cdot V}{n cdot R} ] Where: * ( T ) = temperature (K) * ( P ) = pressure (Pa) * ( V ) = volume (m³) * ( n ) = number of moles (mol) * ( R ) = ideal gas constant (8.314 J/(mol·K)) Provided Constants: [ V = 1.0 , m³ ] [ n = 1.0 , mol ] Function Signature: ```python def get_temperature_from_pressure(pressure: float) -> float: pass ``` Input: * A single float ( pressure ) representing the pressure in Pascals. (0 < pressure <= 101325) Output: * A float representing the calculated temperature in Kelvin. Constraints: * The pressure must be a positive value and less than or equal to 101325 Pascals. Examples: * **Example 1**: ```python get_temperature_from_pressure(pressure=101325) ``` **Output**: ```python 12180.23 ``` * **Example 2**: ```python get_temperature_from_pressure(pressure=50000) ``` **Output**: ```python 6011.94 ``` * **Example 3**: ```python get_temperature_from_pressure(pressure=1000) ``` **Output**: ```python 120.48 ``` * **Example 4**: ```python get_temperature_from_pressure(pressure=25000) ``` **Output**: ```python 3005.97 ``` Notes: * Use the provided constants when implementing the formula. * The function should raise a `ValueError` for pressures outside the specified range. Implement the `get_temperature_from_pressure` function to determine the temperature from the pressure using the provided formula.","solution":"def get_temperature_from_pressure(pressure: float) -> float: Calculate the temperature using the Ideal Gas Law given the pressure. Parameters: pressure (float): The pressure in Pascals. Returns: float: The temperature in Kelvin. Raises: ValueError: If the pressure is not within the valid range. if pressure <= 0 or pressure > 101325: raise ValueError(\\"Pressure must be in the range (0, 101325] Pascals\\") V = 1.0 # volume in cubic meters n = 1.0 # number of moles R = 8.314 # ideal gas constant in J/(mol·K) # Ideal Gas Law: T = (P * V) / (n * R) T = (pressure * V) / (n * R) return T"},{"question":"Write a function `find_central_substring(s: str) -> str` that returns the central substring of given input string ( s ). The central substring is defined as: - If the length of the string is odd, the central substring is the middle character. - If the length of the string is even, the central substring consists of the two middle characters. # Input: * A single string ( s ) with length ( 1 leq |s| leq 10^5 ). # Output: * Single string representing the central substring. # Function Signature: ```python def find_central_substring(s: str) -> str: pass ``` # Example: ```python >>> find_central_substring(\\"abcdef\\") \\"cd\\" >>> find_central_substring(\\"abcde\\") \\"c\\" >>> find_central_substring(\\"a\\") \\"a\\" >>> find_central_substring(\\"ab\\") \\"ab\\" ``` # Note: * For ( s = \\"abcdef\\" ), the length is 6 (even), so the result is the middle two characters \\"cd\\". * For ( s = \\"abcde\\" ), the length is 5 (odd), so the result is the middle character \\"c\\". * For ( s = \\"a\\" ), the length is 1, so the result is the character itself \\"a\\". * For ( s = \\"ab\\" ), the length is 2 (even), so the result is the two characters \\"ab\\".","solution":"def find_central_substring(s: str) -> str: Returns the central substring of a given string s. If the string length is odd, returns the middle character. If the string length is even, returns the two middle characters. length = len(s) mid = length // 2 if length % 2 == 0: return s[mid-1:mid+1] else: return s[mid]"},{"question":"**Problem Statement**: You are given a list of integers where each element represents a building\'s height. Your task is to compute the largest rectangular area that can be formed within these buildings when visualized as adjacent bars of width 1. **Function Signature**: ```python def largest_rectangle_area(heights: list[int]) -> int: ``` **Inputs**: - `heights`: A list of non-negative integers representing the heights of the buildings. Each element in the list is the height of a building. The length of the list is between 0 and 10^5. **Outputs**: - Return an integer representing the maximum area of the rectangle that can be formed within the given heights. **Constraints**: - You must handle edge cases with an empty input list. - Ensure all heights in the input are non-negative. - Aim for an O(n) time complexity with an efficient space complexity. **Scenario**: Imagine you have a skyline of buildings and you need to determine the maximum area of a solid rectangle that can be formed within this skyline. This will help in planning the architecture efficiently to maximize utilization of space. **Examples**: ```python >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([1, 2, 3, 4, -1]) Traceback (most recent call last): ... ValueError: No height can be negative ``` **Requirements**: - Raise a `ValueError` if any of the heights are negative. - Optimize for both time and space complexity wherever possible.","solution":"def largest_rectangle_area(heights: list[int]) -> int: Calculates the largest rectangular area that can be formed within the given heights of buildings. :param heights: List[int] - A list of non-negative integers representing the heights of the buildings. :return: int - The maximum rectangular area formed within these buildings. :raises: ValueError if any height is negative. if any(height < 0 for height in heights): raise ValueError(\\"No height can be negative\\") stack = [] max_area = 0 for i, height in enumerate(heights): # Ensure we handle the stack for the taller height being ended while stack and heights[stack[-1]] > height: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) # Clear the stack for remaining bars while stack: h = heights[stack.pop()] w = len(heights) if not stack else len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area"},{"question":"Maze Solver with Depth-First Search Scenario: As a developer for a gaming company, you are tasked with implementing the core algorithm for a maze-solving game. The maze is presented as a 2D grid where each cell can either be an open path or a wall. The objective is to navigate from the start to the goal using the Depth-First Search (DFS) algorithm. Task: Your task is to implement a function to determine if there is a path from the start to the goal. # Function to Implement: 1. **`maze_solver(maze, start, goal)`**: * **Input**: * `maze` (List[List[int]]): A 2D list representing the maze grid. A value of `1` represents an open path, and `0` represents a wall. * `start` (Tuple[int, int]): A tuple representing the starting cell coordinate. * `goal` (Tuple[int, int]): A tuple representing the goal cell coordinate. * **Output**: * A boolean value indicating whether a path exists (True) or not (False). # Constraints: * The `maze` grid will have dimensions at most `100x100`. * The `start` and `goal` coordinates will always be within maze boundaries. * You may assume that `start` and `goal` are open paths (`1`). # Example: ```python # Example usage and expected outputs maze = [ [1, 0, 1, 1, 1], [1, 1, 0, 0, 1], [0, 1, 1, 0, 1], [1, 0, 1, 1, 1], [1, 1, 1, 0, 1] ] start = (0, 0) goal = (4, 4) path_exists = maze_solver(maze, start, goal) print(path_exists) # Output: True or False depending on the maze structure ``` Your implementation should efficiently explore the maze using the DFS algorithm, handle different maze structures, and provide the correct boolean output to indicate the existence of a path from the start to the goal.","solution":"def maze_solver(maze, start, goal): Determines if there is a path from start to goal using Depth-First Search (DFS). :param maze: List[List[int]], a 2D list representing the maze grid. :param start: Tuple[int, int], starting cell coordinate. :param goal: Tuple[int, int], goal cell coordinate. :return: bool, True if a path exists, False otherwise. def is_valid_move(maze, visited, x, y): if 0 <= x < len(maze) and 0 <= y < len(maze[0]) and maze[x][y] == 1 and not visited[x][y]: return True return False def dfs(maze, visited, x, y, goal): if (x, y) == goal: return True visited[x][y] = True # Directions: Down, Up, Right, Left directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for dir_x, dir_y in directions: new_x, new_y = x + dir_x, y + dir_y if is_valid_move(maze, visited, new_x, new_y): if dfs(maze, visited, new_x, new_y, goal): return True return False visited = [[False for _ in range(len(maze[0]))] for _ in range(len(maze))] return dfs(maze, visited, start[0], start[1], goal)"},{"question":"# Problem Statement: You are tasked with implementing a range-sum query class for a one-dimensional list of integers. This class should support the initialization of the list, updating a value at a specific index, and efficiently querying the sum of elements within a specified range. # Requirements: 1. Implement a class `RangeSumQuery` with the following methods: - `__init__(self, nums: List[int])`: Initializes the object with a list of integers. - `void update(int index, int value)`: Updates the element at the specified `index` with the given `value`. - `int sumRange(int left, int right)`: Returns the sum of the elements between indices `left` and `right` (inclusive). 2. The `update` method should allow modification of the list elements, and the `sumRange` method should efficiently return the sum within the specified range. 3. Utilize appropriate data structures to ensure that the sumRange method operates efficiently, even after multiple updates. # Constraints: - The list `nums` contains n elements where 1 <= n <= 10^4. - The element values are within the range -10^5 <= nums[i] <= 10^5. - 0 <= `index` < n. - 0 <= `left` <= `right` < n. - Queries and updates are called multiple times, so aim for optimizing time complexity. # Example: ```python class RangeSumQuery: def __init__(self, nums: List[int]): pass # Include your initialization code here def update(self, index: int, value: int) -> None: pass # Include your update method implementation here def sumRange(self, left: int, right: int) -> int: pass # Include your sumRange method implementation here # Example usage: nums = [1, 3, 5, 7, 9, 11] obj = RangeSumQuery(nums) print(obj.sumRange(1, 3)) # Expected output: 15 (3 + 5 + 7) obj.update(1, 10) print(obj.sumRange(1, 3)) # Expected output: 22 (10 + 5 + 7) ``` Complete the class `RangeSumQuery` based on the provided requirements and examples.","solution":"from typing import List class RangeSumQuery: def __init__(self, nums: List[int]): self.n = len(nums) self.nums = nums[:] self.segment_tree = [0] * (4 * self.n) self._build_segment_tree(0, 0, self.n - 1) def _build_segment_tree(self, node, start, end): if start == end: self.segment_tree[node] = self.nums[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build_segment_tree(left_child, start, mid) self._build_segment_tree(right_child, mid + 1, end) self.segment_tree[node] = self.segment_tree[left_child] + self.segment_tree[right_child] def _update_segment_tree(self, node, start, end, idx, value): if start == end: self.nums[idx] = value self.segment_tree[node] = value else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= idx <= mid: self._update_segment_tree(left_child, start, mid, idx, value) else: self._update_segment_tree(right_child, mid + 1, end, idx, value) self.segment_tree[node] = self.segment_tree[left_child] + self.segment_tree[right_child] def _sum_range_query(self, node, start, end, L, R): if R < start or end < L: return 0 if L <= start and end <= R: return self.segment_tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_sum = self._sum_range_query(left_child, start, mid, L, R) right_sum = self._sum_range_query(right_child, mid + 1, end, L, R) return left_sum + right_sum def update(self, index: int, value: int) -> None: self._update_segment_tree(0, 0, self.n - 1, index, value) def sumRange(self, left: int, right: int) -> int: return self._sum_range_query(0, 0, self.n - 1, left, right)"},{"question":"# Content Rebalancing and Sharding (Database Scaling) The following set of functions implements a basic sharding mechanism for distributing and rebalancing data across multiple database shards. The specific focus is on distributing user data uniformly using consistent hashing. You are required to implement the `rebalance` function to complement the existing sharding functionality. The `rebalance` function should: 1. Take a list of user data entries and a target number of shards. 2. Redistribute the user data across the new shard configuration using consistent hashing. 3. Ensure uniform distribution and minimal data movement between shards. **Function Signature:** ```python def rebalance(user_data: List[Tuple[str, Any]], num_shards: int) -> List[Dict[str, Any]]: pass ``` **Input and Output Formats:** - **Input**: - `user_data` (List[Tuple[str, Any]]): List of tuples where each tuple contains a user ID (string) and their corresponding data (any type). - `num_shards` (int): Desired number of shards after rebalancing. - **Output**: - List[Dict[str, Any]]: List of dictionaries where each dictionary represents a shard containing user data. **Constraints**: - Assume `user_data` contains at least as many entries as `num_shards`. - All user IDs are unique. - `num_shards` is a positive integer. **Performance Requirements**: - The rebalancing function should run efficiently with respect to the size of `user_data`. - Minimize data movement to achieve a balanced distribution. # Example: Given user data and a `num_shards` value, you should be able to redistribute the data: ```python user_data = [ (\\"user1\\", {\\"data\\": \\"value1\\"}), (\\"user2\\", {\\"data\\": \\"value2\\"}), (\\"user3\\", {\\"data\\": \\"value3\\"}), (\\"user4\\", {\\"data\\": \\"value4\\"}) ] # Rebalance data for 2 shards sharded_data = rebalance(user_data, 2) # Output: List of two dictionaries, each containing approximately half of the user data # Example: # [ # {\\"user1\\": {\\"data\\": \\"value1\\"}, \\"user3\\": {\\"data\\": \\"value3\\"}}, # {\\"user2\\": {\\"data\\": \\"value2\\"}, \\"user4\\": {\\"data\\": \\"value4\\"}} # ] ```","solution":"import hashlib from typing import List, Tuple, Any, Dict def consistent_hash(key: str, num_shards: int) -> int: Consistently hash a given key to one of the available shards. return int(hashlib.md5(key.encode()).hexdigest(), 16) % num_shards def rebalance(user_data: List[Tuple[str, Any]], num_shards: int) -> List[Dict[str, Any]]: Rebalances the user data across the specified number of shards using consistent hashing. # Initialize empty shards shards = [{} for _ in range(num_shards)] # Distribute the data using consistent hashing for user_id, data in user_data: shard_index = consistent_hash(user_id, num_shards) shards[shard_index][user_id] = data return shards"},{"question":"# Problem Statement You are given a `Trie` class that helps store strings and supports insertions and basic prefix searches. Your task is to enhance this `Trie` class by implementing functionalities to find all words stored in the trie that match a given wildcard pattern. # Task Write a method `search_with_wildcard(pattern: str) -> List[str]` in the `Trie` class that takes a wildcard pattern as input and returns a list of all words in the trie matching this pattern. The pattern may include the \'.\' character as a wildcard, which can match any single letter. # Trie Class Definition The `Trie` class has the following structure: ```python class Trie: def __init__(self): self.root = {} self.end_of_word = \\"#\\" def insert(self, word: str) -> None: node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node[self.end_of_word] = self.end_of_word def search_with_wildcard(self, pattern: str) -> List[str]: # Implement this method pass ``` # Input * `pattern`: A string containing letters and the \'.\' wildcard character. # Output * A list of strings representing all words in the trie that match the wildcard pattern, ordered lexicographically. # Constraints * All characters in `pattern` are lowercase English letters or the \'.\' character. * The length of `pattern` and each word in the trie is between 1 and 100 (inclusive). * The number of words inserted into the trie is at most 1000. # Example ```python trie = Trie() trie.insert(\\"dog\\") trie.insert(\\"cat\\") trie.insert(\\"car\\") trie.insert(\\"dag\\") trie.insert(\\"cog\\") # sample pattern with wildcards pattern = \\"c.t\\" result = trie.search_with_wildcard(pattern) print(result) # Output should be [\'cat\'] pattern = \\"d.g\\" result = trie.search_with_wildcard(pattern) print(result) # Output should be [\'dag\', \'dog\'] ``` # Notes * The `search_with_wildcard` method should handle patterns of any valid length and return results efficiently. * Ensure your implementation considers all edge cases such as no matching words or patterns with multiple wildcards. * Pay attention to the efficiency of your search algorithm.","solution":"class Trie: def __init__(self): self.root = {} self.end_of_word = \\"#\\" def insert(self, word: str) -> None: node = self.root for char in word: if char not in node: node[char] = {} node = node[char] node[self.end_of_word] = self.end_of_word def search_with_wildcard(self, pattern: str) -> list: def search(node, pattern): if not pattern: return [\\"\\" if self.end_of_word in node else None] char = pattern[0] if char == \'.\': results = [] for child_char in node: if child_char != self.end_of_word: child_results = search(node[child_char], pattern[1:]) for child_result in child_results: if child_result is not None: results.append(child_char + child_result) return results elif char in node: child_results = search(node[char], pattern[1:]) return [char + child_result for child_result in child_results if child_result is not None] else: return [] results = search(self.root, pattern) results = [result for result in results if result is not None] return sorted(results)"},{"question":"# Problem Statement Develop a `MovieDatabase` class that models a simple database of movies, allowing users to add movies, rate them, and retrieve movies based on certain criteria. This class should store information about each movie, including the title, release year, and a list of ratings. The class should also provide methods to add a movie, add a rating to a movie, retrieve the average rating of a movie, and get a list of movies released within a specified year range. # Requirements - Implement the `MovieDatabase` class with methods to add and manage movies and their ratings. - The class should contain: - Method to add a movie with its title and release year. - Method to add a rating to an existing movie. - Method to retrieve the average rating of a specific movie. - Method to get all movies released within a specified range of years. # Function Implementation Method Header 1. **Adding a movie to the database**: ```python def add_movie(self, title: str, year: int) -> None: ``` - **title**: The title of the movie. - **year**: The release year of the movie. 2. **Adding a rating to a movie**: ```python def add_rating(self, title: str, rating: float) -> None: ``` - **title**: The title of the movie. - **rating**: The rating to be added, which should be a float between 0 and 10. 3. **Retrieving the average rating of a movie**: ```python def get_average_rating(self, title: str) -> float: ``` - **title**: The title of the movie. - **returns**: The average rating of the specified movie. If the movie has no ratings, returns 0.0. 4. **Getting movies within a specified range of years**: ```python def get_movies_by_year_range(self, start_year: int, end_year: int) -> List[str]: ``` - **start_year**: The beginning of the year range (inclusive). - **end_year**: The end of the year range (inclusive). - **returns**: A list of movie titles released within the specified year range, sorted by release year. # Input and Output Formats - Movie titles are unique within the database. - Ratings are floats between 0.0 and 10.0 inclusive. # Constraints - Ratings must be added only to movies already in the database. - The year range method should handle cases where no movies are within the specified range gracefully. # Example ```python # Example usage of the MovieDatabase class db = MovieDatabase() db.add_movie(\\"Inception\\", 2010) db.add_movie(\\"The Matrix\\", 1999) db.add_movie(\\"Interstellar\\", 2014) db.add_rating(\\"Inception\\", 9.0) db.add_rating(\\"Inception\\", 8.5) db.add_rating(\\"The Matrix\\", 9.5) db.add_rating(\\"Interstellar\\", 8.0) print(db.get_average_rating(\\"Inception\\")) # Expected Output: 8.75 print(db.get_movies_by_year_range(1990, 2010)) # Expected Output: [\\"The Matrix\\", \\"Inception\\"] ``` # Notes - Ensure that the `get_average_rating` method handles movies with no ratings by returning 0.0. - Handle cases where movies are not found when trying to add ratings or retrieve average ratings gracefully. - Validate that the provided ratings are within the acceptable range (0.0 to 10.0).","solution":"class MovieDatabase: def __init__(self): self.movies = {} def add_movie(self, title: str, year: int) -> None: self.movies[title] = {\'year\': year, \'ratings\': []} def add_rating(self, title: str, rating: float) -> None: if title in self.movies and 0.0 <= rating <= 10.0: self.movies[title][\'ratings\'].append(rating) def get_average_rating(self, title: str) -> float: if title in self.movies and self.movies[title][\'ratings\']: ratings = self.movies[title][\'ratings\'] return sum(ratings) / len(ratings) return 0.0 def get_movies_by_year_range(self, start_year: int, end_year: int): result = [title for title, info in self.movies.items() if start_year <= info[\'year\'] <= end_year] result.sort(key=lambda title: self.movies[title][\'year\']) return result"},{"question":"# URL Shortener Objective: You need to write a function that simulates the basic operation of a URL shortener by generating a shorter alias for a given URL. Your function should ensure that the aliases are unique and consistent for the same input URL. You should also handle collisions efficiently. Function Signature: ```python def shorten_url(url: str) -> str: ... ``` Inputs: * `url` (str): A string representing the original URL to be shortened. Constraints: It can be any valid URL. Output: * `str`: Returns a shortened, unique alias for the input URL as a string prefixed with \\"http://short.url/\\". Examples: ```python shorten_url(\\"https://example.com/some-long-url\\") # returns \\"http://short.url/abc123\\" shorten_url(\\"https://example.com/another-long-url\\") # returns \\"http://short.url/xyz789\\" shorten_url(\\"https://example.com/some-long-url\\") # returns \\"http://short.url/abc123\\" shorten_url(\\"https://different.com/different-long-url\\") # returns \\"http://short.url/jkl456\\" ``` Edge Cases to Consider: 1. Ensure the alias is unique. 2. Multiple calls with the same URL should returning the same shortened URL. 3. Different URLs generate different aliases, handling potential collisions. 4. Properly handle URLs that include edge case characters (e.g., trailing slashes, query parameters). Performance Requirements: - The function should handle up to ( 10^6 ) unique URL shorten requests efficiently without significant time delay. - Ensure the generated aliases are reasonably short and fit typical URL length constraints.","solution":"import hashlib url_map = {} def shorten_url(url: str) -> str: Generates a shortened unique alias for the given URL. Args: - url (str): The original URL to be shortened. Returns: - str: A shortened URL prefixed with \\"http://short.url/\\". # Use SHA-256 hash function to ensure the uniqueness hash_object = hashlib.sha256(url.encode()) # Use the first 8 characters of the hexadecimal digest as the unique identifier short_hash = hash_object.hexdigest()[:8] short_url = f\\"http://short.url/{short_hash}\\" # Store in url_map to ensure consistent return if url not in url_map: url_map[url] = short_url return url_map[url]"},{"question":"# Context You are tasked with creating a basic text editor application that supports undo functionality. This editor should allow users to type and delete characters, while also toggling between typing and deletion modes. Additionally, it should maintain a history of all operations to support undoing the most recent action. # Task Implement the `TextEditor` class to support the following methods: 1. `write(character)`: Adds the specified character to the text at the current cursor position. Should work in typing mode. 2. `delete()`: Deletes the character to the left of the cursor under typing mode or deletes the entire word to the left of the cursor under deletion mode. 3. `toggle_mode()`: Switches the editor between typing and deletion modes. 4. `undo()`: Reverts the most recent operation (either a write or delete) and restores the previous text state. # Requirements 1. The `write(character)` method should run in O(1) time complexity. 2. The `delete()` method should run in O(1) time complexity under typing mode and in O(w) time complexity, where `w` is the length of the word, under deletion mode. 3. The `toggle_mode()` method should run in O(1) time complexity. 4. The `undo()` method should run in O(1) time complexity. # Input/Output - The `write(character)` method takes a single character and adds it to the text editor. - The `delete()` method removes characters as specified above. - The `toggle_mode()` method changes the mode from typing to deletion or vice versa. - The `undo()` method reverts the most recent modification(s). # Example ```python editor = TextEditor() editor.write(\'h\') editor.write(\'e\') editor.write(\'l\') editor.write(\'l\') editor.write(\'o\') print(editor.text) # Output: \'hello\' editor.delete() # In typing mode, deletes \'o\' print(editor.text) # Output: \'hell\' editor.toggle_mode() editor.delete() # In deletion mode, deletes \'hell\' print(editor.text) # Output: \'\' editor.undo() # Restores previous state before deletion print(editor.text) # Output: \'hell\' editor.undo() # Restores previous state before \'hell\' was deleted to \'\' print(editor.text) # Output: \'hello\' ``` # Notes * Focus on minimizing state re-computations. * Maintain the mode state (typing or deletion) using a boolean flag. * Use appropriate data structures to support efficient undo operations while managing text editing tasks.","solution":"class TextEditor: def __init__(self): self.text = [] self.mode = \\"typing\\" self.history = [] def write(self, character): # If the mode is not typing, do nothing for write if self.mode != \\"typing\\": return # Save current text for undo self.history.append((\'write\', character)) # Add character to text self.text.append(character) def delete(self): if not self.text: return if self.mode == \\"typing\\": # Save the current state to history for undo deleted_char = self.text.pop() # remove last character self.history.append((\'delete\', deleted_char)) elif self.mode == \\"deletion\\": # Delete word to the left of the cursor import re joined_text = \'\'.join(self.text) if not joined_text.strip(): return words = re.findall(r\'bw+b\', joined_text) if not words: return last_word = words[-1] index = joined_text.rfind(last_word) self.history.append((\'delete_word\', joined_text[index:])) self.text = list(joined_text[:index]) def toggle_mode(self): self.mode = \\"deletion\\" if self.mode == \\"typing\\" else \\"typing\\" def undo(self): if not self.history: return last_operation = self.history.pop() operation = last_operation[0] if operation == \'write\': # It was a write operation, so we pop the last character self.text.pop() elif operation == \'delete\': # It was a delete operation, so we add the character back self.text.append(last_operation[1]) elif operation == \'delete_word\': deleted_word = last_operation[1] self.text.extend(list(deleted_word))"},{"question":"# Generate Book Recommendations Based on User Preferences **Background:** You are developing a book recommendation engine and need to create a functionality that fetches book recommendations based on user preferences. The user will provide their preferred genres and authors. Your task is to recommend books that match these preferences by querying an external books API. **Task:** 1. Write a function named `recommend_books` that accepts two arguments: a list of preferred genres and a list of preferred authors. 2. The function should query an external books API to fetch books matching the provided genres and authors. 3. Implement error handling to manage scenarios such as: - Invalid API key. - Network errors and timeouts. - Invalid response formats. - No books found matching the criteria. 4. On encountering any error, the function should return appropriate error messages instead of failing silently or crashing. **Parameters:** - `preferred_genres` (List[str]): A list of genres that the user is interested in. - `preferred_authors` (List[str]): A list of authors that the user prefers. **Output:** - Return a list of book titles matching the user\'s preferences. - Return appropriate error messages in case of any failures. **Constraints:** - Use standard libraries only. - Handle network errors and timeouts appropriately. - Ensure your solution is robust and can handle different types of errors gracefully. **Example:** ```python def recommend_books(preferred_genres: List[str], preferred_authors: List[str]) -> List[str]: pass # Example of expected function call recommend_books([\\"Fiction\\", \\"Science Fiction\\"], [\\"Isaac Asimov\\", \\"Arthur C. Clarke\\"]) ``` In this function, you should fetch books that match the user\'s preferences based on genres and authors. Ensure that you handle errors such as invalid API keys or poor network connections gracefully by returning appropriate error messages.","solution":"import requests def recommend_books(preferred_genres, preferred_authors): Fetch books from an external API based on user\'s preferred genres and authors. Args: preferred_genres (List[str]): List of preferred genres. preferred_authors (List[str]): List of preferred authors. Returns: List[str]: List of book titles matching the criteria, or error message. # Placeholder URL, an actual API endpoint is needed: API_URL = \\"https://example-books-api.com/recommendations\\" API_KEY = \\"your_api_key_here\\" # API key placeholder, an actual key is needed. headers = { \'Authorization\': f\'Bearer {API_KEY}\' } params = { \'genres\': \',\'.join(preferred_genres), \'authors\': \',\'.join(preferred_authors) } try: response = requests.get(API_URL, headers=headers, params=params, timeout=10) response.raise_for_status() except requests.exceptions.HTTPError as e: # Handle specific HTTP errors if response.status_code == 401: return \\"Invalid API key.\\" else: return f\\"HTTP error occurred: {e}\\" except requests.exceptions.RequestException as e: # Handle other request errors such as connection errors, timeouts, etc return f\\"Request error occurred: {e}\\" try: data = response.json() except ValueError: return \\"Invalid response format.\\" # Check if the expected data format is present in the response if \'books\' not in data or not isinstance(data[\'books\'], list): return \\"No books found matching the criteria.\\" # Extract book titles from the response data book_titles = [book[\'title\'] for book in data[\'books\']] return book_titles"},{"question":"You are tasked with implementing a function that computes the number of distinct subsequences of a given string `s` that equal another string `t`. A subsequence of a string is derived by deleting some or no characters without changing the order of the remaining characters. # Function Signature ```python def num_distinct_subsequences(s: str, t: str) -> int: pass ``` # Input * Two strings `s` and `t`, both consisting of lowercase alphabets. # Output * Return an integer representing the number of distinct subsequences of `s` that are equal to `t`. # Constraints * 1 <= len(s), len(t) <= 1000 # Examples ```python >>> num_distinct_subsequences(\\"rabbbit\\", \\"rabbit\\") 3 >>> num_distinct_subsequences(\\"babgbag\\", \\"bag\\") 5 >>> num_distinct_subsequences(\\"abcde\\", \\"ace\\") 1 ``` # Explanation To solve this problem: 1. Utilize dynamic programming where `dp[i][j]` represents the number of ways to form the subsequence `t[0...j-1]` from `s[0...i-1]`. 2. If `s[i-1] != t[j-1]`, then `dp[i][j] = dp[i-1][j]`. 3. If `s[i-1] == t[j-1]`, then `dp[i][j] = dp[i-1][j] + dp[i-1][j-1]`. 4. Initialize `dp[0][0] = 1` since an empty string is a subsequence of another empty string. 5. Iterate and fill the DP table according to the above rules to get the result in `dp[len(s)][len(t)]`.","solution":"def num_distinct_subsequences(s: str, t: str) -> int: m, n = len(s), len(t) if n == 0: return 1 if m == 0: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): dp[i][0] = 1 # An empty string t can be formed from any string s by deleting all characters for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] else: dp[i][j] = dp[i - 1][j] return dp[m][n]"},{"question":"# Palindrome Permutation Coding Challenge You are tasked with implementing a function to determine if a given string can be rearranged to form a palindrome. A palindrome is a word, phrase, number, or other sequences of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Function Signature: ```python def can_form_palindrome(s: str) -> bool: pass ``` # Input - `s`: A string consisting of ASCII characters. # Output - Returns `True` if any permutation of the string can form a palindrome, otherwise `False`. # Constraints - The length of `s` will be in the range [1, 1000]. - The string can contain spaces, punctuation, and uppercase and lowercase letters. # Scenario Given a string, you must determine if its characters can be rearranged to form a palindrome. This will involve counting the occurrences of each character and determining if a palindrome can be constructed from these counts. # Example ```python input_str = \\"Tact Coa\\" print(can_form_palindrome(input_str)) # Expected output: True (Permutations: \\"taco cat\\", \\"atco cta\\", etc.) input_str2 = \\"python\\" print(can_form_palindrome(input_str2)) # Expected output: False ``` # Considerations * Ignore spaces and punctuation while determining the permutation, but maintain the respective counts of letters. * The function should be case-insensitive, treating \'A\' and \'a\' as the same character. * Optimize your solution to handle the input lengths effectively up to the maximum constraint. By ensuring the count of each character and processing the permutations accordingly, your function should accurately determine if a palindrome is possible.","solution":"from collections import Counter import string def can_form_palindrome(s: str) -> bool: Determine if any permutation of the string can form a palindrome. Params: s: str - The input string containing ASCII characters which can include spaces, punctuation, etc. Returns: bool - True if any permutation of the string can form a palindrome, otherwise False. # Normalize input: remove spaces and punctuation, convert to lowercase s = \'\'.join(char.lower() for char in s if char in string.ascii_letters) # Count the frequency of each character char_count = Counter(s) # At most one character can have an odd count for the string to be able to form a palindrome odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1"},{"question":"# Sum of Divisors Context You are given an integer `n`, and you need to calculate the sum of all its divisors. A divisor of an integer ( k ) is any integer ( d ) such that the remainder when ( k ) is divided by ( d ) is zero. For example, the divisors of 6 are 1, 2, 3, and 6. Task Write a function `sum_of_divisors(n: int) -> int` that returns the sum of all divisors of `n`. Example ``` Input: 6 Output: 12 Explanation: The divisors of 6 are 1, 2, 3, and 6. The sum of these divisors is 1 + 2 + 3 + 6 = 12. Input: 28 Output: 56 Explanation: The divisors of 28 are 1, 2, 4, 7, 14, and 28. The sum of these divisors is 1 + 2 + 4 + 7 + 14 + 28 = 56. ``` # Constraints - Input `n` is an integer such that ( 1 leq n leq 10^4 ).","solution":"def sum_of_divisors(n): Returns the sum of all divisors of n. # Initialize the sum of divisors to 0 total = 0 # Loop through all integers from 1 to n for i in range(1, n + 1): if n % i == 0: total += i return total"},{"question":"**Scenario**: You are responsible for developing a system that organizes a collection of books in a library. The system should be able to search for books based on different criteria, including the book title, author, and genre. Your task is to implement a search function that can filter the collection based on specified criteria. **Task**: Create a function `search_books` that filters a list of books based on the given criteria. Each book is represented as a dictionary with keys `title`, `author`, and `genre`. The function should allow for an exact match search on any combination of these criteria and should return a list of books that match all provided conditions. # Input Format: - `books` (list of dict): List of books, where each book is a dictionary with keys `title`, `author`, and `genre`. - `title` (str, optional): The title of the book to search for. If not provided, title is ignored in the search. - `author` (str, optional): The author of the book to search for. If not provided, author is ignored in the search. - `genre` (str, optional): The genre of the book to search for. If not provided, genre is ignored in the search. # Output Format: - Return a list of dictionaries representing books that match all specified criteria. # Example: ```python def search_books(books: list, title: str = None, author: str = None, genre: str = None) -> list: Search a list of books based on the given criteria. >>> books = [ ... {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"genre\\": \\"Fiction\\"}, ... {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"genre\\": \\"Dystopian\\"}, ... {\\"title\\": \\"A Brief History of Time\\", \\"author\\": \\"Stephen Hawking\\", \\"genre\\": \\"Science\\"} ... ] >>> search_books(books, author=\\"George Orwell\\") [{\'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\'}] >>> search_books(books, genre=\\"Fiction\\") [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\'}, {\'title\': \'To Kill a Mockingbird\', \'author\': \'Harper Lee\', \'genre\': \'Fiction\'}] >>> search_books(books, title=\\"The Great Gatsby\\", author=\\"F. Scott Fitzgerald\\") [{\'title\': \'The Great Gatsby\', \'author\': \'F. Scott Fitzgerald\', \'genre\': \'Fiction\'}] >>> search_books(books, author=\\"J.K. Rowling\\") [] result = [] for book in books: if title and book[\\"title\\"] != title: continue if author and book[\\"author\\"] != author: continue if genre and book[\\"genre\\"] != genre: continue result.append(book) return result if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Constraints: - The title, author, and genre fields are case-sensitive and should match exactly what is provided in the book dictionary. - Your function should handle an empty list of books without errors and return an empty list if no books match the criteria. - Utilize the default parameters correctly to handle cases where some search criteria may not be provided. **Notes**: - Ensure the function can handle reasonably large lists of books efficiently. - Consider edge cases such as partial matches not being used, empty criteria, and mixed availability of the criteria.","solution":"def search_books(books: list, title: str = None, author: str = None, genre: str = None) -> list: Search a list of books based on the given criteria. Args: books (list of dict): List of books, where each book is a dictionary with keys \'title\', \'author\', and \'genre\'. title (str, optional): The title of the book to search for. If not provided, title is ignored in the search. author (str, optional): The author of the book to search for. If not provided, author is ignored in the search. genre (str, optional): The genre of the book to search for. If not provided, genre is ignored in the search. Returns: list of dict: A list of dictionaries representing books that match all specified criteria. result = [] for book in books: if title and book[\\"title\\"] != title: continue if author and book[\\"author\\"] != author: continue if genre and book[\\"genre\\"] != genre: continue result.append(book) return result"},{"question":"# Problem Statement Consider the following sequence where each term is calculated based on the sum of the previous terms: [ a_1 = 1 ] [ a_2 = 1 ] [ a_n = a_{n-1} + a_{n-2} + dots + a_1 ] Given this recurrence relation, compute the nth term of the sequence. Your task is to write a function `sequence_nth_term` that calculates the nth term of this sequence. # Input - An integer `n` where 1 ≤ n ≤ 1000, representing the position of the term to find in the sequence. # Output - An integer representing the nth term of the sequence described. # Constraints - 1 ≤ n ≤ 1000 # Example ```python def test_sequence_nth_term(): assert sequence_nth_term(1) == 1 # First term is 1 assert sequence_nth_term(2) == 1 # Second term is 1 assert sequence_nth_term(3) == 2 # Third term is 1 + 1 = 2 assert sequence_nth_term(4) == 4 # Fourth term is 1 + 1 + 2 = 4 assert sequence_nth_term(5) == 8 # Fifth term is 1 + 1 + 2 + 4 = 8 ``` Implement the function `sequence_nth_term` such that it passes the above test cases. # Additional Notes - Pay attention to efficient computation and avoid direct summing for large `n`. - Consider using dynamic programming or memoization to optimize performance for large `n`.","solution":"def sequence_nth_term(n): Calculate the nth term of the sequence where each term is the sum of all previous terms. if n == 1 or n == 2: return 1 terms = [0] * (n+1) terms[1] = 1 terms[2] = 1 for i in range(3, n+1): terms[i] = sum(terms[1:i]) return terms[n]"},{"question":"# Problem Statement You are required to implement a MaxHeap class with the following functionalities: insertion, extraction of the maximum, getting the current maximum, and heapifying an arbitrary list. The goal is to practice the Max Heap data structure, commonly used in priority queues. Implement methods in the MaxHeap class to handle: 1. Inserting a value. 2. Extracting the maximum value. 3. Getting the current maximum value without removing it. 4. Converting an arbitrary list into a MaxHeap. # Function Specifications 1. **Insert Function** ```python def insert(self, value: int) -> None: ``` - **Input**: An integer value to be added to the heap. - **Output**: None. - **Constraints**: Values could be any integer. 2. **Extract Maximum Function** ```python def extract_max(self) -> int: ``` - **Input**: None. - **Output**: The maximum value in the heap. - **Constraints**: Raises IndexError if heap is empty. 3. **Get Maximum Function** ```python def get_max(self) -> int: ``` - **Input**: None. - **Output**: The maximum value in the heap without removing it. - **Constraints**: Raises IndexError if heap is empty. 4. **Heapify Function** ```python def heapify(self, array: List[int]) -> None: ``` - **Input**: A list of integers. - **Output**: The heap created from the list. - **Constraints**: The list can contain any integers. # Examples ```python h = MaxHeap() h.insert(10) h.insert(4) h.insert(15) h.insert(7) assert h.get_max() == 15 assert h.extract_max() == 15 assert h.get_max() == 10 h.heapify([3, 5, 1, 10, 2]) assert h.get_max() == 10 ```","solution":"import heapq class MaxHeap: def __init__(self): self.heap = [] def insert(self, value: int) -> None: heapq.heappush(self.heap, -value) def extract_max(self) -> int: if not self.heap: raise IndexError(\\"extract_max() from empty heap\\") return -heapq.heappop(self.heap) def get_max(self) -> int: if not self.heap: raise IndexError(\\"get_max() from empty heap\\") return -self.heap[0] def heapify(self, array: list[int]) -> None: self.heap = [-x for x in array] heapq.heapify(self.heap)"},{"question":"# File Processing for Large Text Files You are tasked with creating a script to efficiently process and analyze a large text file containing log data. Problem Statement Implement the function `analyze_log_file(file_path: str) -> dict` which will: 1. Read a large text log file line by line to avoid loading the entire file into memory. 2. Count the occurrences of each unique IP address found in the log file. 3. Implement error handling to manage file-related issues, such as a file not found or permission errors, and log appropriate messages. 4. Return a dictionary where the keys are the unique IP addresses and the values are their respective counts. Input and Output Formats * **Input**: * `file_path` (string): Path to the log file that needs to be analyzed. * **Output**: * A dictionary with IP addresses as keys and their count of occurrences as values. Constraints: * The log file might be too large to fit into memory, so it must be processed line by line. * The function should handle common file I/O errors and raise an exception with a message \\"File read error\\" for unresolved issues. * IP addresses in the log file are in standard dotted-decimal notation. Example ```python # Example usage # Assuming the log file contains the following lines: # 192.168.0.1 - - [01/Oct/2023:10:00:00] \\"GET / HTTP/1.1\\" 200 1234 # 192.168.0.2 - - [01/Oct/2023:10:05:00] \\"GET / HTTP/1.1\\" 200 1234 # 192.168.0.1 - - [01/Oct/2023:10:10:00] \\"GET / HTTP/1.1\\" 200 1234 result = analyze_log_file(\\"/path/to/logfile.txt\\") print(result) # Output: # { # \\"192.168.0.1\\": 2, # \\"192.168.0.2\\": 1 # } ```","solution":"import re def analyze_log_file(file_path: str) -> dict: Analyze a log file to count occurrences of each unique IP address. Parameters: - file_path (str): Path to the log file Returns: - dict: A dictionary with IP addresses as keys and their count of occurrences as values ip_counts = {} try: with open(file_path, \'r\') as file: for line in file: match = re.match(r\'(d+.d+.d+.d+)\', line) if match: ip_address = match.group(1) if ip_address in ip_counts: ip_counts[ip_address] += 1 else: ip_counts[ip_address] = 1 except (FileNotFoundError, PermissionError) as e: print(f\\"Error: {str(e)}\\") raise Exception(\\"File read error\\") from e return ip_counts"},{"question":"# Coding Assessment Question Scenario: You are working on a network application that requires efficient handling of internet packet transmission. Each packet has a sequence number, and it is crucial to detect and handle any out-of-sequence packets to ensure data integrity and correct order of delivery. Your task is to implement a function that can validate the order of incoming packets and reorder them if needed. Task: Implement a function `validate_and_reorder_packets` that takes a list of packet sequence numbers and ensures that the packets are received in sequence. The function should return a list of reordered packet sequence numbers and identify any missing packets. Function: ```python def validate_and_reorder_packets(sequence_numbers: List[int]) -> Tuple[List[int], List[int]]: Ensures packets are in sequence and identifies missing packets. Args: sequence_numbers (List[int]): A list of packet sequence numbers. Returns: Tuple[List[int], List[int]]: A tuple containing: - A list of reordered packet sequence numbers. - A list of missing packet sequence numbers. ``` Input: * `sequence_numbers` (List[int]): A list of integers representing packet sequence numbers, potentially out of order and with missing packets. Output: * A tuple containing: - A list of reordered packet sequence numbers. - A list of missing packet sequence numbers. Constraints: * The list of sequence numbers will have at least one packet. * Sequence numbers are non-negative integers. Example: ```python # Example input with out-of-order and missing packets packets = [3, 1, 4, 5, 8, 2] # Function call to reorder and identify missing packets reordered, missing = validate_and_reorder_packets(packets) # Expected output: # reordered = [1, 2, 3, 4, 5, 8] # missing = [6, 7] print(\\"Reordered packets:\\", reordered) print(\\"Missing packets:\\", missing) ``` The function should correctly reorder the packets in ascending sequence and provide a list of sequence numbers for any packets that are missing from the input list.","solution":"from typing import List, Tuple def validate_and_reorder_packets(sequence_numbers: List[int]) -> Tuple[List[int], List[int]]: Ensures packets are in sequence and identifies missing packets. Args: sequence_numbers (List[int]): A list of packet sequence numbers. Returns: Tuple[List[int], List[int]]: A tuple containing: - A list of reordered packet sequence numbers. - A list of missing packet sequence numbers. if not sequence_numbers: return [], [] sorted_packets = sorted(sequence_numbers) min_packet = sorted_packets[0] max_packet = sorted_packets[-1] full_set = set(range(min_packet, max_packet + 1)) received_set = set(sequence_numbers) missing_packets = sorted(full_set - received_set) return sorted_packets, missing_packets"},{"question":"# Task: Implement a Function to Calculate the Median of a List with Enhanced Features Given a basic requirement to compute the median of a list of numbers, your task is to enhance this implementation with additional features and error handling. Specifically: 1. **Empty List Handling**: If the input list is empty, raise a ValueError with the message \\"Input list cannot be empty\\". 2. **Non-Numeric Values**: Ensure that all elements in the list are numbers (integers or floats). In case of any non-numeric value, raise a ValueError with the message \\"All elements in the list must be numbers\\". 3. **Median Calculation**: Compute the median of the list. If the list has an odd number of elements, return the middle element. If the list has an even number of elements, return the average of the two middle elements. # Function Signature ```python def enhanced_median(numbers): Calculate the median of a list of numbers, with enhanced features and error handling. :param numbers: list of int or float :return: float: Median of the list >>> enhanced_median([1, 2, 3]) 2.0 >>> enhanced_median([1, 2, 3, 4]) 2.5 >>> enhanced_median([]) Traceback (most recent call last): ... ValueError: Input list cannot be empty >>> enhanced_median([1, 2, \'a\']) Traceback (most recent call last): ... ValueError: All elements in the list must be numbers # Your implementation here ``` # Constraints 1. The input must be a list of numeric values (integers or floats). 2. If the input list is empty, raise a `ValueError`. 3. If any element in the list is not numeric, raise a `ValueError`. # Example Usages - `enhanced_median([1, 2, 3])` should return `2.0`. - `enhanced_median([1, 2, 3, 4])` should return `2.5`. - `enhanced_median([])` should raise `ValueError: Input list cannot be empty`. - `enhanced_median([1, 2, \'a\'])` should raise `ValueError: All elements in the list must be numbers`.","solution":"def enhanced_median(numbers): Calculate the median of a list of numbers, with enhanced features and error handling. :param numbers: list of int or float :return: float: Median of the list if not numbers: raise ValueError(\\"Input list cannot be empty\\") if not all(isinstance(num, (int, float)) for num in numbers): raise ValueError(\\"All elements in the list must be numbers\\") numbers.sort() n = len(numbers) mid = n // 2 if n % 2 == 1: return float(numbers[mid]) else: return (numbers[mid - 1] + numbers[mid]) / 2.0"},{"question":"# Matrix Transposition and Sum of Diagonals You are tasked to implement two primary functions for working with matrices. This task will assess your understanding of matrix manipulation, handling edge cases, and writing algorithms efficiently. Function 1: Matrix Transposition Write a function `transpose_matrix` that transposes a given matrix. The function should adhere to the following constraints: - **Input**: A list of n lists (each with a length of m), representing an n x m matrix. - **Output**: A list of m lists (each with a length of n), representing the transposed m x n matrix. Function 2: Sum of Diagonals Write a function `sum_diagonals` that calculates the sum of the main diagonal and the anti-diagonal of a given square matrix. The function should adhere to the following constraints: - **Input**: A list of n lists (each with a length of n), representing an n x n square matrix. - **Output**: An integer which is the sum of the main diagonal and the anti-diagonal elements. Note that if the matrix has an odd dimension and the center element is shared by both diagonals, it should only be counted once. # Expected Function Signatures ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass def sum_diagonals(matrix: list[list[int]]) -> int: pass ``` # Example Scenarios & Expected Outputs * `transpose_matrix([[1, 2, 3], [4, 5, 6]])` should return `[[1, 4], [2, 5], [3, 6]]` * `transpose_matrix([[1, 2], [3, 4], [5, 6]])` should return `[[1, 3, 5], [2, 4, 6]]` * `sum_diagonals([[1, 2, 3], [4, 5, 6], [7, 8, 9]])` should return `1 + 5 + 9 + 3 + 5 + 7 - 5` = `25` (center element counted once) * `sum_diagonals([[2, 1], [1, 2]])` should return `2 + 2 + 1 + 1` = `6` # Constraints & Conditions - Ensure the matrix input is a valid list of lists with consistent row lengths. - Handle potential edge cases such as empty matrices and single-element matrices. - You may assume all matrix elements are integers. - Your solution should not rely on any external libraries for matrix operations. Implement these functions and provide thorough test cases to demonstrate their correctness. Consider edge cases and explore the effectiveness of your implementation thoroughly.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: if not matrix or not matrix[0]: return [] return [list(row) for row in zip(*matrix)] def sum_diagonals(matrix: list[list[int]]) -> int: n = len(matrix) if n == 0: return 0 sum_diag = 0 for i in range(n): sum_diag += matrix[i][i] # Main diagonal sum_diag += matrix[i][n - 1 - i] # Anti-diagonal # Adjust for the center element if n is odd if n % 2 == 1: center = n // 2 sum_diag -= matrix[center][center] return sum_diag"},{"question":"# Multi-Threaded Matrix Multiplication Matrix multiplication is a fundamental operation in many areas of computer science. Your task is to implement a function that performs matrix multiplication using multiple threads to improve performance. Task Requirements 1. **Function Implementation**: - Implement a multi-threaded matrix multiplication function. - Make sure to handle edge cases such as incompatible matrices for multiplication. 2. **Thread Management**: - Use appropriate threading techniques to distribute the workload across multiple threads. - Ensure proper synchronization to avoid race conditions. 3. **Testing**: - Write comprehensive test cases for your function, ensuring all edge cases are covered. Function Signature ```python def threaded_matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Parameters ---------- A : list[list[int]] First matrix to multiply. B : list[list[int]] Second matrix to multiply. Returns ------- list[list[int]] Resultant matrix after multiplying A and B. ``` Input and Output Formats - **Input**: - Two matrices `A` and `B`, where each matrix is a list of lists of integers. The number of columns in `A` should be equal to the number of rows in `B` for multiplication to be possible. - **Output**: - A matrix represented as a list of lists of integers, which is the product of `A` and `B`. Constraints - Do not use any libraries that handle the entire multiplication process for you (e.g., `numpy`). - Use Python\'s `threading` library to manage threads. Example ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] # Result of multiplying A and B result = [ [58, 64], [139, 154] ] assert threaded_matrix_multiplication(A, B) == result A = [[2, 4], [3, 4]] B = [[1, 2, 3], [2, 3, 4]] # Result of multiplying A and B result = [ [10, 16, 22], [11, 18, 25] ] assert threaded_matrix_multiplication(A, B) == result ``` **Note:** If the dimensions of the input matrices `A` and `B` are incompatible for multiplication, your function should raise a `ValueError` with a descriptive error message.","solution":"import threading def threaded_matrix_multiplication(A, B): Multiplies two matrices A and B using multiple threads. Parameters ---------- A : list[list[int]] First matrix to multiply. B : list[list[int]] Second matrix to multiply. Returns ------- list[list[int]] Resultant matrix after multiplying A and B. # Number of rows in A and B num_rows_A, num_cols_A = len(A), len(A[0]) num_rows_B, num_cols_B = len(B), len(B[0]) # Check if the matrices can be multiplied if num_cols_A != num_rows_B: raise ValueError(\\"Number of columns in A must be equal to the number of rows in B\\") # Resultant matrix initialized to zero result = [[0] * num_cols_B for _ in range(num_rows_A)] def compute_element(i, j): result[i][j] = sum(A[i][k] * B[k][j] for k in range(num_cols_A)) threads = [] for i in range(num_rows_A): for j in range(num_cols_B): thread = threading.Thread(target=compute_element, args=(i, j)) threads.append(thread) thread.start() # Wait for all threads to complete for thread in threads: thread.join() return result"},{"question":"# Context: You have been hired to optimize a function that calculates the strongly connected components (SCC) in a directed graph. This algorithm is crucial for applications such as web crawling, circuit optimization, and social media analysis where discovering interconnected clusters is essential. # Problem Statement: Implement an optimized version of the function `find_scc`. The new function should maximize efficiency in calculating the strongly connected components in large graphs. # Function Signature: ```python def find_scc(graph: dict[int, list[int]]) -> list[set[int]]: # Your implementation here ``` # Input: - A dictionary `graph` where the keys are node identifiers (integers) and the values are lists of integers representing directed edges from the key node. # Output: - A list of sets, where each set contains the node identifiers that form a strongly connected component. # Constraints: 1. The graph can be very large (up to 10^5 nodes and edges). 2. Node identifiers are unique and consecutively numbered from 0 to N-1. 3. Aim for an O(V + E) time complexity (V is the number of vertices and E is the number of edges) using algorithms like Tarjan\'s or Kosaraju\'s. # Examples: ```python graph1 = { 0: [1], 1: [2, 3], 2: [0], 3: [4], 4: [5], 5: [3] } graph2 = { 0: [1], 1: [2], 2: [0], 3: [4, 5], 4: [5], 5: [] } assert find_scc(graph1) == [{0, 1, 2}, {3, 4, 5}] assert find_scc(graph2) == [{0, 1, 2}, {3}, {4}, {5}] assert find_scc({}) == [] ``` # Guidelines: - Leverage efficient graph traversal techniques such as Depth-First Search (DFS). - Use stack and low-link values to identify SCCs. - Ensure the solution can handle graphs with a large number of nodes and edges without excessive memory usage or runtime delays. - Document your code with comments that explain the core logic and any assumptions made.","solution":"def find_scc(graph): Find strongly connected components in the given directed graph using Tarjan\'s algorithm. Parameters: graph (dict[int, list[int]]): A dictionary representing the directed graph where the keys are node identifiers and the values are lists of integers representing directed edges from the key node. Returns: list[set[int]]: A list of sets, each containing the node identifiers that form a strongly connected component. index = [0] # Single item list to act as a static variable stack = [] indices = {} lowlinks = {} on_stack = set() sccs = [] def strongconnect(node): indices[node] = index[0] lowlinks[node] = index[0] index[0] += 1 stack.append(node) on_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif neighbor in on_stack: lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = set() while True: current = stack.pop() on_stack.remove(current) scc.add(current) if current == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"# Coding Assessment Question: **Objective**: Write a function that replicates the Fibonacci sequence using an iterative approach. This will show your understanding of control structures in Python and efficient computation with minimal memory overhead. # Problem Statement: Implement the function `generate_fibonacci_sequence(n: int) -> List[int]` which returns the first `n` elements of the Fibonacci sequence. The sequence starts with 0 and 1, and each subsequent number is the sum of the previous two numbers. # Function Signature: ```python def generate_fibonacci_sequence(n: int) -> List[int]: ``` # Input: - `n` (int): The number of elements from the Fibonacci sequence to generate. `n` will be a non-negative integer. # Output: - List[int]: A list containing the first `n` elements of the Fibonacci sequence. # Constraints: - The input `n` is a non-negative integer (0 ≤ `n` ≤ 30). # Examples: - `generate_fibonacci_sequence(0)` -> [] - `generate_fibonacci_sequence(1)` -> [0] - `generate_fibonacci_sequence(2)` -> [0, 1] - `generate_fibonacci_sequence(5)` -> [0, 1, 1, 2, 3] - `generate_fibonacci_sequence(10)` -> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] # Edge Cases to Consider: - The function should handle cases when `n` is 0 or 1. - Ensure efficient memory usage by avoiding recursion for this problem due to stack space limitations. # Additional Requirement: - Do not use any form of recursion—only iterative control structures are allowed.","solution":"from typing import List def generate_fibonacci_sequence(n: int) -> List[int]: Generates the first n elements of the Fibonacci sequence using an iterative approach. Args: n (int): The number of elements to generate. Returns: List[int]: A list containing the first n elements of the Fibonacci sequence. if n <= 0: return [] elif n == 1: return [0] result = [0, 1] while len(result) < n: next_value = result[-1] + result[-2] result.append(next_value) return result"},{"question":"# Merge Intervals Question: Implement Advanced Interval Management Operations Background In computational problems, intervals are commonly used to represent ranges of numbers. Merging overlapping intervals is a frequent task that ensures intervals are non-overlapping and as consolidated as possible. You are given a simple merge function. Your task is to implement advanced operations that efficiently manage and manipulate intervals while considering edge cases and performance constraints. # Task 1. **Advanced Interval Merging**: - Modify the `merge_intervals` function to accept an additional parameter `new_interval`, which represents a single interval to be inserted into a list of existing intervals and merged accordingly. - Ensure that the function correctly handles overlapping intervals and edge cases. 2. **Interval Coverage Calculation**: - Implement a function `coverage` that takes a list of intervals and returns the total length of the covered range after merging the intervals. - Ensure the function handles non-overlapping and overlapping intervals effectively. Function Signatures * `def merge_intervals(intervals: List[Tuple[int, int]], new_interval: Tuple[int, int]) -> List[Tuple[int, int]]` * `def coverage(intervals: List[Tuple[int, int]]) -> int` # Constraints * The `intervals` list will contain tuples of two integers representing the start and end of the interval, where the start is always less than or equal to the end. * Intervals can have negative and positive integer values. * The intervals list and new_interval are assumed to be sorted and non-decreasing based on the starting values. # Examples ```python print(merge_intervals([(1, 3), (5, 7)], (4, 6))) # -> [(1, 3), (4, 7)] print(coverage([(1, 3), (2, 4), (5, 7)])) # -> 5 ``` # Notes * Ensure your code handles invalid input and edge cases appropriately. * Optimize the performance of the functions where feasible. * Provide clear and concise docstrings and comments in your code.","solution":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[int, int]], new_interval: Tuple[int, int]) -> List[Tuple[int, int]]: Merge a new interval into a list of existing intervals, ensuring no overlapping intervals in the result. Args: intervals: List of existing intervals (sorted). new_interval: A single interval to insert and merge with the existing intervals. Returns: A list of merged intervals. result = [] i = 0 n = len(intervals) # Add all intervals before the new_interval starts while i < n and intervals[i][1] < new_interval[0]: result.append(intervals[i]) i += 1 # Merge overlapping intervals while i < n and intervals[i][0] <= new_interval[1]: new_interval = (min(new_interval[0], intervals[i][0]), max(new_interval[1], intervals[i][1])) i += 1 # Add the merged new_interval result.append(new_interval) # Add the remaining intervals after the merged interval while i < n: result.append(intervals[i]) i += 1 return result def coverage(intervals: List[Tuple[int, int]]) -> int: Calculate the total length of the covered range after merging the intervals. Args: intervals: List of intervals to be merged and calculated for coverage. Returns: The total length of the covered range after merging intervals. if not intervals: return 0 # First, sort intervals if not already sorted intervals.sort() merged_intervals = [intervals[0]] for current in intervals[1:]: last = merged_intervals[-1] if current[0] <= last[1]: # There is an overlap merged_intervals[-1] = (last[0], max(last[1], current[1])) # Merge else: merged_intervals.append(current) # Calculate the total coverage length total_length = sum(interval[1] - interval[0] for interval in merged_intervals) return total_length"},{"question":"# Prime Factorization with Large Input Handling You are given a `PrimeFactorization` class with methods to handle finding and printing the prime factors of a given number. However, the current implementation is naive and needs improvements to handle larger inputs efficiently. Your task is to complete the `PrimeFactorization` class to: 1. Efficiently compute the prime factors of a given integer. 2. Optimize the factorization for very large inputs. 3. Handle edge cases appropriately (e.g., small numbers, prime numbers). Below is the modified `PrimeFactorization` class and the key areas you need to work on: ```python class PrimeFactorization: def __init__(self): pass def prime_factors(self, n: int) -> list: factors = [] # You need to implement this method efficiently for very large n. return factors if __name__ == \\"__main__\\": pf = PrimeFactorization() number = 100 factors = pf.prime_factors(number) print(f\\"Prime factors of {number} are: {\' \'.join(map(str, factors))}\\") ``` # Implementation Requirements: 1. **Efficient Prime Factorization**: Implement the `prime_factors` method to find and return the prime factors of `n` using an optimized algorithm. 2. **Handle Large Inputs**: Ensure the solution can handle large input values (up to (10^{12})) within a reasonable time frame. 3. **Output Format**: The output should list the prime factors in ascending order. # Input: - The integer `n` for which prime factors need to be found. # Output: - A list of prime factors of `n` in ascending order. # Constraints: - (2 leq n leq 10^{12}) # Example Input: ```python pf = PrimeFactorization() number = 100 factors = pf.prime_factors(number) print(f\\"Prime factors of {number} are: {\' \'.join(map(str, factors))}\\") ``` Output: ``` Prime factors of 100 are: 2 2 5 5 ``` Input: ```python pf = PrimeFactorization() number = 53 factors = pf.prime_factors(number) print(f\\"Prime factors of {number} are: {\' \'.join(map(str, factors))}\\") ``` Output: ``` Prime factors of 53 are: 53 ``` # Explanation: - The outputs show the prime factors of the input numbers in ascending order, handling both composite and prime numbers efficiently.","solution":"class PrimeFactorization: def __init__(self): pass def prime_factors(self, n: int) -> list: factors = [] # Deal with 2 separately to allow incrementing by 2 later while n % 2 == 0: factors.append(2) n //= 2 # Check odd factors from 3 onward factor = 3 max_factor = int(n**0.5) + 1 while factor <= max_factor: while n % factor == 0: factors.append(factor) n //= factor factor += 2 # Only test odd numbers max_factor = int(n**0.5) + 1 if n > 1: # If n is still a prime number greater than 2 factors.append(n) return factors if __name__ == \\"__main__\\": pf = PrimeFactorization() number = 100 factors = pf.prime_factors(number) print(f\\"Prime factors of {number} are: {\' \'.join(map(str, factors))}\\")"},{"question":"# Matrix Zeros Problem You are given an ( m times n ) matrix filled with integers. Write a function to set the entire row and column to zero if an element is zero. Your solution should have space complexity of ( O(1) ). # Function Signature ```python def set_zeroes(matrix: List[List[int]]) -> None: Sets the entire row and column of matrix to zero if an element is zero. :param matrix: 2D list of integers representing the matrix. :return: None. The function modifies the matrix in-place. ``` # Input * A 2D list of integers ( matrix ) with ( m ) rows and ( n ) columns (1 ≤ ( m, n ) ≤ 200). # Output * None. The function modifies the input matrix in-place. # Constraints * You must update the matrix in-place without using additional space for another matrix. # Example ```python >>> matrix = [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> set_zeroes(matrix) >>> matrix [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] >>> matrix = [ ... [0, 1, 2, 0], ... [3, 4, 5, 2], ... [1, 3, 1, 5] ... ] >>> set_zeroes(matrix) >>> matrix [ [0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0] ] ``` # Notes * Make use of the first row and first column of the matrix to mark zeros without extra space. * Be mindful of the matrix dimensions and handle edge cases accordingly. * Ensure that your solution is optimized for both time and space complexity. # Hints * Iterate through the matrix to mark which rows and columns should be zeroed. * Use the first row and first column as a replacement for additional storage to mark zeros. * Handle the zeroing of the first row and column after processing the entire matrix to avoid early modification errors.","solution":"from typing import List def set_zeroes(matrix: List[List[int]]) -> None: m, n = len(matrix), len(matrix[0]) first_row_has_zero = any(matrix[0][j] == 0 for j in range(n)) first_col_has_zero = any(matrix[i][0] == 0 for i in range(m)) # Use first row and column to mark zeros for i in range(1, m): for j in range(1, n): if matrix[i][j] == 0: matrix[i][0] = 0 matrix[0][j] = 0 # Zero out cells based on marks in the first row and column for i in range(1, m): if matrix[i][0] == 0: for j in range(1, n): matrix[i][j] = 0 for j in range(1, n): if matrix[0][j] == 0: for i in range(1, m): matrix[i][j] = 0 # Finally, zero out the first row and column if needed if first_row_has_zero: for j in range(n): matrix[0][j] = 0 if first_col_has_zero: for i in range(m): matrix[i][0] = 0"},{"question":"# Problem Statement: You are developing an optimized solution for a warehouse management system. The warehouse consists of several storage units, each of which can store a certain quantity of a single type of product. Your task is to determine the optimal way to allocate products to the storage units such that the total quantity of stored products is maximized. You are given two lists: one representing the available capacities of the storage units and another representing the quantities of different types of products. You need to write a function `max_product_storage(capacities: list[int], quantities: list[int]) -> int` to determine the maximum quantity of products that can be stored in the units. # Function Signature: ```python def max_product_storage(capacities: list[int], quantities: list[int]) -> int: ``` # Input Format: * `capacities`: A list of positive integers where `capacities[i]` represents the capacity of the i-th storage unit. * `quantities`: A list of positive integers where `quantities[i]` represents the quantity of the i-th type of product. # Output Format: * Return an integer representing the maximum quantity of products that can be stored. # Constraints: * 1 ≤ len(capacities), len(quantities) ≤ 1000 * 1 ≤ capacities[i], quantities[i] ≤ 1000 # Performance Requirements: * The solution should have a time complexity of (O(n log n + m log m)), where `n` is the number of storage units and `m` is the number of product types, because sorting is involved. # Example: ```python >>> capacities = [10, 20, 30] >>> quantities = [15, 25, 35] >>> max_product_storage(capacities, quantities) 60 ``` # Explanation: In this example, the optimal strategy is to allocate the following way: - The first storage unit (capacity 10) can store a portion of the first product (quantity 15), storing 10 out of 15. - The second storage unit (capacity 20) can store the remaining 5 of the first product plus 15 from the second product, making the total stored 20. - The third storage unit (capacity 30) can store the remaining 10 of the second product plus 20 from the third product, making the total stored 30. Total products stored: 10 + 20 + 30 = 60. This example showcases how products can optimally be allocated to maximize the total stored quantity.","solution":"def max_product_storage(capacities, quantities): # Sort both capacities and quantities in descending order capacities.sort(reverse=True) quantities.sort(reverse=True) total_stored = 0 i, j = 0, 0 while i < len(capacities) and j < len(quantities): if capacities[i] > quantities[j]: total_stored += quantities[j] capacities[i] -= quantities[j] j += 1 else: total_stored += capacities[i] quantities[j] -= capacities[i] i += 1 return total_stored"},{"question":"Coding Assessment Question # Context: In a land far away, an ancient tree produces magical fruits that people use to cure various illnesses. Each type of fruit has a specific healing power and ripens only on certain days of the year. You are tasked with helping a healer pick the most powerful combination of fruits available over a given period. # Problem: The healer has a list of fruits, each with a healing power and ripening day. Your goal is to maximize the total healing power of the fruits picked within a specified range of days. # Function Signature: ```python def max_healing_power(fruits: List[Tuple[str, int, int]], start_day: int, end_day: int) -> Tuple[List[str], int]: ``` Input: - **fruits**: A list of tuples, where each tuple contains three elements: - A string representing the name of a fruit. - An integer representing the healing power of the fruit. - An integer representing the day of the year the fruit ripens (1 ≤ day ≤ 365). - **start_day**: An integer representing the starting day of the period (1 ≤ start_day ≤ 365). - **end_day**: An integer representing the ending day of the period (start_day ≤ end_day ≤ 365). Output: - A tuple with two elements: - **List of strings**: The names of the fruits picked that provide the maximum healing power within the specified period. - **Integer**: The total healing power of the picked fruits. Constraints: - `1 ≤ len(fruits) ≤ 1000` - `1 ≤ healing power ≤ 10^4` # Example: ```python # Input fruits = [(\\"Apple\\", 100, 10), (\\"Banana\\", 200, 15), (\\"Cherry\\", 150, 13), (\\"Dragonfruit\\", 300, 20), (\\"Elderberry\\", 180, 17)] start_day = 10 end_day = 15 # Output ([\\"Banana\\", \\"Cherry\\", \\"Apple\\"], 450) ``` # Guidelines: * Ensure the implementation efficiently selects the fruits within the specified period and maximizes the healing power. * Handle different edge cases, such as periods with no available fruits, fruits with the same ripening days, and large periods. # Note: Sort the fruits by healing power to prioritize picking the most beneficial fruits. Consider various scenarios where the start and end days encompass a range with multiple fruits ripening on the same or different days.","solution":"from typing import List, Tuple def max_healing_power(fruits: List[Tuple[str, int, int]], start_day: int, end_day: int) -> Tuple[List[str], int]: # Filter fruits that ripen within the specified period valid_fruits = [fruit for fruit in fruits if start_day <= fruit[2] <= end_day] # Sort the valid fruits by healing power in descending order valid_fruits.sort(key=lambda fruit: fruit[1], reverse=True) # Collect names and total healing power selected_fruits = [fruit[0] for fruit in valid_fruits] total_healing_power = sum(fruit[1] for fruit in valid_fruits) return selected_fruits, total_healing_power"},{"question":"# Scenario You are developing a feature for a calendar application, which involves determining the day of the week for a given date. This feature should help users quickly identify the day of the week for any date they enter. # Task Write a function `get_day_of_week(date: str) -> str` that takes a string `date` in the format \\"YYYY-MM-DD\\" and returns the day of the week for that date (e.g., \\"Sunday\\", \\"Monday\\", etc.). # Function Signature ```python def get_day_of_week(date: str) -> str: ``` # Expected Input and Output - **Input**: A string `date` representing a date in the format \\"YYYY-MM-DD\\". - **Output**: A string representing the day of the week for the input date. # Constraints - The input string `date` will be a valid date between \\"1900-01-01\\" and \\"2100-12-31\\". - Consider using Python\'s built-in libraries for handling dates to simplify the problem. # Performance Requirements - The function should compute the day of the week in constant time, `O(1)`, relative to the length of the date string. - The space complexity should be `O(1)`. # Examples ```python assert get_day_of_week(\\"2023-10-07\\") == \\"Saturday\\" assert get_day_of_week(\\"1987-01-01\\") == \\"Thursday\\" assert get_day_of_week(\\"2000-02-29\\") == \\"Tuesday\\" assert get_day_of_week(\\"1900-12-31\\") == \\"Monday\\" assert get_day_of_week(\\"2100-01-01\\") == \\"Friday\\" ``` # Notes - Utilize Python\'s `datetime` module to handle date conversion and calculation. - Ensure the function correctly handles edge cases such as leap years and century years.","solution":"from datetime import datetime def get_day_of_week(date: str) -> str: Given a date string in the format \\"YYYY-MM-DD\\", return the day of the week. date_object = datetime.strptime(date, \\"%Y-%m-%d\\") return date_object.strftime(\\"%A\\")"},{"question":"# Unique Elements Extractor You are given a list of integers. Your task is to write a program in Python that extracts all unique elements from the list and returns them in a sorted order. **Function 1: extract_unique_elements** - **Input:** A list of integers. - **Output:** A sorted list of integers containing only the unique elements from the input list. # Constraints: 1. The input list may contain both positive and negative integers. 2. The input list may contain duplicates. 3. The output list should be sorted in ascending order. # Example Cases: Input/Output: **Example 1:** ```python extract_unique_elements([4, 5, 6, 4, 7, 6, -1]) -> [-1, 4, 5, 6, 7] ``` **Example 2:** ```python extract_unique_elements([10, 9, 8, 7, 7, 8, 10]) -> [7, 8, 9, 10] ```","solution":"def extract_unique_elements(lst): Returns a sorted list of unique elements from the given list of integers. unique_elements = sorted(set(lst)) return unique_elements"},{"question":"# Question: You are tasked with developing a simple command-line application to manage a collection of books in a library. The application must support adding books, searching for books by title, and listing all books by a specific author. Task: 1. **Function 1: `add_book(library: dict, title: str, author: str, year: int) -> None`** - Input: - `library`: A dictionary where keys are book titles and values are tuples containing the author and year of publication. - `title`: A string representing the title of the book. - `author`: A string representing the author of the book. - `year`: An integer representing the year of publication. - Output: - The function should modify the `library` dictionary in place by adding the new book. - Implementation details: - Ensure that the title is not already in the library. If it is, overwrite the existing entry. 2. **Function 2: `search_by_title(library: dict, title: str) -> str`** - Input: - `library`: A dictionary where keys are book titles and values are tuples containing the author and year of publication. - `title`: A string representing the title of the book to search for. - Output: - A string detailing the author and year of the book if found, or an appropriate message if the book is not found. - Implementation details: - Perform a case-insensitive search for the book title. 3. **Function 3: `list_books_by_author(library: dict, author: str) -> list`** - Input: - `library`: A dictionary where keys are book titles and values are tuples containing the author and year of publication. - `author`: A string representing the author whose books are to be listed. - Output: - A list of strings, each string representing a book title by the given author. - Implementation details: - Perform a case-insensitive match of the author\'s name. Examples: ```python library = {} add_book(library, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 1960) add_book(library, \\"1984\\", \\"George Orwell\\", 1949) add_book(library, \\"Animal Farm\\", \\"George Orwell\\", 1945) search_by_title(library, \\"1984\\") # Output: \'George Orwell, 1949\' search_by_title(library, \\"Moby Dick\\") # Output: \'Book not found.\' list_books_by_author(library, \\"George Orwell\\") # Output: [\'1984\', \'Animal Farm\'] list_books_by_author(library, \\"J.K. Rowling\\") # Output: [] ``` Ensure your solution is efficient, correctly handles edge cases, and provides accurate and user-friendly output.","solution":"def add_book(library: dict, title: str, author: str, year: int) -> None: Adds a book to the library. If the title already exists in the library, it updates the existing entry. library[title.lower()] = (author, year) def search_by_title(library: dict, title: str) -> str: Searches for a book by its title and returns a string detailing the author and year of the book. If the book is not found, returns \'Book not found.\' title_lower = title.lower() if title_lower in library: author, year = library[title_lower] return f\'{author}, {year}\' else: return \'Book not found.\' def list_books_by_author(library: dict, author: str) -> list: Lists all books by a specific author. Performs a case-insensitive match of the author\'s name. books = [] for title, details in library.items(): if details[0].lower() == author.lower(): books.append(title) return books"},{"question":"# Coding Challenge: Circular Array Rotation # Context: A circular array rotation operation shifts each element of the array to its right by a given number of steps. This task will help you understand array manipulation and modular arithmetic. # Task: Your task is to implement a function that performs circular rotations on an array, shifting its elements to the right by a specified number of steps. After performing the rotations, return the updated array. # Requirements: 1. Implement a function that takes an array and the number of rotation steps as input. 2. Ensure your function can handle various data types within the array (integers, floats, strings, etc.). 3. Consider edge cases, such as an empty array and a single-element array. 4. Optimize your implementation to achieve a time complexity of O(n). # Input: - A list of elements `collection` where elements can be of any data type. - An integer `steps` representing the number of steps to rotate the array. # Output: - A new list with the elements shifted to the right by the given number of steps. # Constraints: - Do not use any built-in rotation functions or external libraries. - The function should handle negative rotation steps as well, where a negative step value indicates a left rotation. # Function Signature: ```python from typing import List, Any def circular_array_rotation(collection: List[Any], steps: int) -> List[Any]: pass ``` # Examples: ```python >>> circular_array_rotation([0, 1, 2, 3, 4], 2) [3, 4, 0, 1, 2] >>> circular_array_rotation([1, 2, 3], -1) [2, 3, 1] >>> circular_array_rotation([], 3) [] >>> circular_array_rotation([\'a\', \'b\', \'c\', \'d\'], 1) [\'d\', \'a\', \'b\', \'c\'] >>> circular_array_rotation([1.1, 2.2, 3.3], 4) [3.3, 1.1, 2.2] ``` **Note**: You are encouraged to write additional test cases to further validate your implementation. # Evaluation Criteria: - Correctness: Your code should accurately rotate the array by the specified steps. - Efficiency: Your code should handle large arrays and large step values efficiently. - Robustness: Your code should handle various data types and edge cases correctly. - Clarity: Your code should be clear, readable, and well-documented.","solution":"from typing import List, Any def circular_array_rotation(collection: List[Any], steps: int) -> List[Any]: Rotates the elements of the collection to the right by a given number of steps. Handles negative steps (left rotation). if not collection: return collection n = len(collection) steps = steps % n return collection[-steps:] + collection[:-steps]"},{"question":"# Problem Statement Write a function that takes an integer array and a target sum as input and returns the indices of the two numbers that add up to the target sum. Assume each input will have exactly one solution, and you may not use the same element twice. # Input - A list of integers `nums` representing the array. - An integer `target` representing the target sum. # Output - A tuple containing two integers representing the indices of the two numbers that add up to the target sum. # Constraints - 2 <= length of `nums` <= 10^4 - -10^9 <= `nums[i]` <= 10^9 - -10^9 <= `target` <= 10^9 # Example ```python find_two_sum_indices([2, 7, 11, 15], 9) ``` Expected Output: ```python (0, 1) ``` # Implementation ```python from typing import List, Tuple def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i # Example usage print(find_two_sum_indices([2, 7, 11, 15], 9)) # Output: (0, 1) ``` # Note - Ensure the function finds and returns the correct indices. - The expected solution has a time complexity of O(n).","solution":"from typing import List, Tuple def find_two_sum_indices(nums: List[int], target: int) -> Tuple[int, int]: Finds two indices in the list such that the numbers at those indices add up to the target sum. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: Tuple[int, int]: Tuple of two indices. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i"},{"question":"# Scenario You are a software engineer at a logistics company that tracks the movement of delivery trucks. Your task is to write a function that calculates the shortest path a truck needs to travel visiting all given delivery points and returning to the starting point using the Traveling Salesman Problem (TSP) with nearest neighbor approximation. # Function Details Implement a function `calculate_shortest_path` that takes one parameter: - `points` (List of tuples): A list of tuples representing the coordinates (x, y) of delivery points, including the starting point. The starting point is always the first point in the list. The function should apply the nearest neighbor algorithm to approximate the shortest path starting from the initial point, visiting all other points, and returning to the starting point. # Requirements - The function should handle cases where the number of points is at least 2. - The result should be a list of points (tuples) representing the path taken. - If the input list has less than 2 points, raise a `ValueError`. # Input and Output - **Input**: - `points` (List of tuples): Coordinates of the delivery points including the starting point. - **Output**: - Return a list of points (tuples) representing the path taken. # Constraints - The list of points will have at most 100 points. - The coordinates ( x ) and ( y ) are integers within the range (-1000 leq x, y leq 1000). # Example ```python # Example of a function call path = calculate_shortest_path([(0, 0), (2, 3), (5, 4), (1, 1)]) print(path) # Expected output: [(0, 0), (1, 1), (2, 3), (5, 4), (0, 0)] path = calculate_shortest_path([(0, 0), (10, 10), (15, 1), (5, 5), (-1, -2)]) print(path) # Expected output: [(0, 0), (-1, -2), (5, 5), (10, 10), (15, 1), (0, 0)] ``` # Notes Handle edge cases such as when two points have the same coordinates or when all points form a straight line. The function should aim for efficiency and accuracy typical of nearest neighbor approximations.","solution":"import math def calculate_shortest_path(points): Calculates the shortest path using the nearest neighbor algorithm. Parameters: points (List of tuples): A list of tuples representing the coordinates (x, y) of delivery points Returns: List of tuples: The shortest path visiting all points and returning to the start. Raises: ValueError: If points has less than 2 elements. if len(points) < 2: raise ValueError(\\"There should be at least 2 points to calculate a path.\\") def distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) # Initialize path = [points[0]] unvisited = points[1:] current_point = points[0] while unvisited: # Find nearest neighbor next_point = min(unvisited, key=lambda p: distance(current_point, p)) path.append(next_point) unvisited.remove(next_point) current_point = next_point # Return to the starting point path.append(points[0]) return path"},{"question":"# Problem Statement You need to implement a function that takes a positive integer and returns a list of all its prime factors including their multiplicity. Prime factorization breaks down a number into a product of prime numbers. The prime factors of a number are the prime numbers that divide the number exactly, without leaving a remainder. # Function Specification Implement the following function: ```python def prime_factors(n: int) -> list: This function returns a list of prime factors of a given integer n including their multiplicity. Args: n (int): The positive integer to factorize. Returns: list: A list containing the prime factors of the number n. ``` # Input - A positive integer `n` where `2 <= n <= 1000`. # Output - A list of integers representing the prime factors of the input integer in non-decreasing order. # Examples ```python >>> prime_factors(18) [2, 3, 3] >>> prime_factors(100) [2, 2, 5, 5] >>> prime_factors(7) [7] >>> prime_factors(60) [2, 2, 3, 5] ``` # Constraints - The input integer `n` will always be between `2` and `1000` inclusive. # Requirements - The implementation should be efficient enough to handle the upper constraint. - The function should accurately identify and list all prime factors in non-decreasing order with their multiplicity. - Consider the smallest input and very large inputs within the constraints to ensure the function behaves correctly.","solution":"def prime_factors(n: int) -> list: This function returns a list of prime factors of a given integer n including their multiplicity. Args: n (int): The positive integer to factorize. Returns: list: A list containing the prime factors of the number n. factors = [] divisor = 2 while n >= 2: if n % divisor == 0: factors.append(divisor) n //= divisor else: divisor += 1 return factors"},{"question":"# Library Book Management Background A library system requires a software solution to manage its collection of books. One of the key operations in this software is determining overdue fines. The fine is based on how many days a book is overdue and whether the user is a student or a faculty member: - Students: 0.50 per day - Faculty: 1.00 per day - Maximum fine: 50.00 Task Write a Python function `calculate_fine(days_overdue: int, user_type: str) -> float` that calculates and returns the overdue fine for a book. The function must follow these rules: 1. `user_type` must be one of two strings: \\"student\\" or \\"faculty\\". 2. The fine is calculated based on the rates provided above. 3. The fine amount cannot exceed 50.00. Input * Two parameters: * `days_overdue` (int): The number of days the book is overdue. * `user_type` (str): The type of user (\\"student\\" or \\"faculty\\"). Output * A float indicating the fine amount. Examples ```python >>> calculate_fine(days_overdue=5, user_type=\'student\') 2.5 >>> calculate_fine(days_overdue=30, user_type=\'faculty\') 30.0 >>> calculate_fine(days_overdue=60, user_type=\'student\') 30.0 >>> calculate_fine(days_overdue=120, user_type=\'faculty\') 50.0 >>> calculate_fine(days_overdue=15, user_type=\'admin\') Traceback (most recent call last): ... ValueError: User type must be \'student\' or \'faculty\' >>> calculate_fine(days_overdue=-5, user_type=\'student\') Traceback (most recent call last): ... ValueError: Days overdue cannot be negative ```","solution":"def calculate_fine(days_overdue: int, user_type: str) -> float: Calculate the overdue fine for a book based on user type and days overdue. Args: days_overdue (int): The number of days the book is overdue. user_type (str): The type of user (\\"student\\" or \\"faculty\\"). Returns: float: The overdue fine. Raises: ValueError: If an invalid user type is provided or days_overdue is negative. if days_overdue < 0: raise ValueError(\\"Days overdue cannot be negative\\") if user_type not in [\\"student\\", \\"faculty\\"]: raise ValueError(\\"User type must be \'student\' or \'faculty\'\\") if user_type == \\"student\\": fine_rate = 0.50 else: fine_rate = 1.00 fine = days_overdue * fine_rate return min(fine, 50.00)"},{"question":"# Coding Assessment Question: Expression Validator Context You are given a string representing a mathematical expression that includes various types of brackets, such as parentheses `()`, square brackets `[]`, and curly braces `{}`. To ensure that the expression is valid, all brackets must be correctly matched and properly nested. Task Implement a function to determine if the given string containing brackets is a valid expression. A valid expression has matching and properly nested brackets. Function Signature ```python def is_valid_expression(expression: str) -> bool: Determines if the given expression is valid in terms of bracket matching and nesting. Parameters: expression (str): The string containing the mathematical expression with various brackets. Returns: bool: True if the expression is valid, False otherwise. ``` Input - A string `expression` containing characters `(`, `)`, `[`, `]`, `{`, and `}`. - The length of `expression` will be between 0 and 1000 characters. Output - The function should return `True` if the expression is valid, `False` otherwise. Constraints - Only bracket characters mentioned above will need to be checked for validity. - Consider edge cases such as empty strings or strings with only one type of bracket. Example ```python # Example 1 expression1 = \\"([{}])\\" print(is_valid_expression(expression1)) # Expected output: True # Example 2 expression2 = \\"([)]\\" print(is_valid_expression(expression2)) # Expected output: False # Example 3 expression3 = \\"[({})]\\" print(is_valid_expression(expression3)) # Expected output: True # Example 4 expression4 = \\"(((\\" print(is_valid_expression(expression4)) # Expected output: False # Example 5 expression5 = \\"\\" print(is_valid_expression(expression5)) # Expected output: True ``` Additional Notes - A stack data structure is commonly used to solve this type of problem efficiently. - Ensure your solution handles both the inclusion of various brackets and their respective nesting levels.","solution":"def is_valid_expression(expression: str) -> bool: Determines if the given expression is valid in terms of bracket matching and nesting. Parameters: expression (str): The string containing the mathematical expression with various brackets. Returns: bool: True if the expression is valid, False otherwise. stack = [] bracket_pairs = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in bracket_pairs.values(): stack.append(char) elif char in bracket_pairs.keys(): if stack == [] or bracket_pairs[char] != stack.pop(): return False return stack == []"},{"question":"# Binary Search Tree - Level Order Traversal Scenario Alice is building a complex search feature for her application, which necessitates traversing a Binary Search Tree (BST) in level order. This traversal method is beneficial in handling data hierarchically and is useful for features like auto-completion and prefix matching. Objective Using the provided Binary Search Tree implementation as a base, add a method to output the nodes of a BST in level order. Implement the following additional operation: 1. `level_order_traversal(self) -> List[int]`: Returns the elements of the BST in level order traversal (breadth-first). Requirements * **Function Specifications**: * Perform breadth-first traversal on the BST. * Validate the structure of the tree and handle different tree configurations (empty tree, full tree, etc.). * **Constraints**: * Ensure the traversal process does not affect the structure of the tree. * The tree can store any number of elements up to system limits, but efficiency is key. * **Performance**: * Achieve O(n) time complexity with an appropriate algorithm. * Optimize space usage for maintaining the queue during traversal. Implementation Given the following class template: ```python class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = TreeNode(value) def level_order_traversal(self) -> List[int]: Returns a list of values representing the level order traversal (breadth-first traversal) of the BST. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(6) >>> bst.insert(15) >>> bst.insert(3) >>> bst.insert(8) >>> bst.insert(20) >>> bst.level_order_traversal() [10, 6, 15, 3, 8, 20] # Your implementation here ``` Complete the implementation of the `level_order_traversal` method. Ensure that the traversal correctly uses a queue to handle node visits in level order, reflecting the hierarchical structure efficiently.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int): if value < node.value: if node.left: self._insert_recursive(node.left, value) else: node.left = TreeNode(value) else: if node.right: self._insert_recursive(node.right, value) else: node.right = TreeNode(value) def level_order_traversal(self): Returns a list of values representing the level order traversal (breadth-first traversal) of the BST. >>> bst = BinarySearchTree() >>> bst.insert(10) >>> bst.insert(6) >>> bst.insert(15) >>> bst.insert(3) >>> bst.insert(8) >>> bst.insert(20) >>> bst.level_order_traversal() [10, 6, 15, 3, 8, 20] if not self.root: return [] queue = [self.root] result = [] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"# Dijkstra\'s Algorithm with Priority Queues In this task, you need to implement Dijkstra\'s algorithm using priority queues to efficiently find the shortest path from a given source vertex to all other vertices in a weighted graph with no negative weights. Your Task Write a function `dijkstra_shortest_path` that implements Dijkstra\'s algorithm as follows: * **Input**: - `graph`: Dictionary where keys are vertex indices and values are lists of tuples, each representing a neighboring vertex and the weight of the edge connecting to it. - `vertex_count`: Integer denoting the number of vertices. - `src`: Integer denoting the source vertex. * **Output**: - Return a list `shortest_distances` where the value at index `i` is the shortest distance from the source vertex to vertex `i`. Constraints * (1 leq text{vertex_count} leq 500) * Vertices indices range from (0) to (vertex_count - 1). * All edge weights are non-negative. Example ```python graph = { 0: [(1, 4), (2, 1)], 1: [(2, 2), (3, 5)], 2: [(3, 1)], 3: [] } vertex_count = 4 src = 0 shortest_distances = dijkstra_shortest_path(graph, vertex_count, src) print(\\"Shortest distances:\\", shortest_distances) ``` Expectations: 1. **Correctness**: Correctly compute the shortest paths from the source vertex to all other vertices using Dijkstra\'s algorithm. 2. **Efficiency**: Properly use a priority queue to ensure optimal performance. 3. **Edge Cases**: Handle scenarios where some vertices may not be reachable from the source and appropriately handle graphs with different structures. Provide the implementation for `dijkstra_shortest_path` function following the described requirements and constraints.","solution":"import heapq def dijkstra_shortest_path(graph, vertex_count, src): Implements Dijkstra\'s algorithm to find the shortest path from source to all other vertices. :param graph: Dictionary where keys are vertex indices and values are lists of (neighbor, weight) tuples. :param vertex_count: Integer denoting the number of vertices. :param src: Integer denoting the source vertex. :return: List of shortest distances from source to each vertex. # Initialize the shortest path distances with infinity shortest_distances = [float(\'inf\')] * vertex_count # Distance to the source itself is always 0 shortest_distances[src] = 0 # Priority queue to hold (distance, vertex) tuples priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the current distance is greater than already found shortest distance, continue if current_distance > shortest_distances[current_vertex]: continue # Explore the neighbors for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight # If found shorter path to the neighbor, update it if distance < shortest_distances[neighbor]: shortest_distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return shortest_distances"},{"question":"# Efficient Network Synchronization In a distributed system, multiple nodes communicate with each other to achieve synchronization. Each node can send messages to other nodes, but communication is bidirectional and has a cost associated with it. The goal is to minimize the total communication cost required to synchronize all nodes so that every node can communicate directly or indirectly with every other node. You are given a list of bidirectional communication paths between nodes, where each path has an associated cost. Your task is to determine the minimum cost required to ensure that all nodes are synchronized. **Function Signature**: ```python def minimum_synchronization_cost(n: int, connections: List[Tuple[int, int, int]]) -> int: ``` Input/Output Specification: - **Input**: - `n` (int): The number of nodes in the network, where `1 <= n <= 1000`. - `connections` (List[Tuple[int, int, int]]): A list of tuples representing the communication paths between nodes. Each tuple `(u, v, cost)` indicates a bidirectional path between node `u` and node `v` with a communication cost `cost`. - **Output**: An integer representing the minimum cost needed to achieve full network synchronization or `-1` if it is not possible to synchronize all nodes. Constraints/Key Points: - Nodes are labeled from 1 to n. - There will not be more than 10000 communication paths. - Synchronization requires all nodes to be connected through some series of paths with the minimum possible cost. - If there is no way to connect all nodes, return `-1`. Example: ```python assert minimum_synchronization_cost(4, [(1, 2, 1), (2, 3, 2), (3, 4, 4), (1, 4, 3)]) == 6 assert minimum_synchronization_cost(4, [(1, 2, 5), (2, 3, 6)]) == -1 assert minimum_synchronization_cost(3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)]) == 3 ``` **Scenario/Context**: Consider a network topology where multiple servers or devices need to communicate in a cost-effective manner. Each communication link between devices has a cost, and the goal is to ensure that all devices can eventually communicate with each other, either directly or indirectly, while minimizing the expenditure on communication infrastructure. This problem is crucial for designing efficient communication networks and ensuring reliable interconnectivity.","solution":"from typing import List, Tuple def minimum_synchronization_cost(n: int, connections: List[Tuple[int, int, int]]) -> int: def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal\'s algorithm to find the Minimum Spanning Tree (MST) connections.sort(key=lambda x: x[2]) # Sort edges based on cost parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_cost = 0 edges_used = 0 for u, v, cost in connections: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += cost edges_used += 1 if edges_used == n - 1: break return mst_cost if edges_used == n - 1 else -1"},{"question":"# Sorting Complex Tuples You are required to write a function that sorts a list of tuples based on multiple criteria. Each tuple contains three elements: an integer, a string, and a floating-point number. The sorting should be prioritized as follows: 1. Sort by the integer in ascending order. 2. If two tuples have the same integer, sort by the string in alphabetical order. 3. If two tuples have the same integer and string, sort by the floating-point number in descending order. Function Signature ```python def sort_complex_tuples(data: List[Tuple[int, str, float]]) -> List[Tuple[int, str, float]]: ``` Input: - `data` (List[Tuple[int, str, float]]): A list of tuples, where each tuple contains: - (int): an integer - (str): a string - (float): a floating-point number Output: - Returns a new list with the tuples sorted based on the described criteria. Constraints: - The length of the input list `data` will be between 1 and 1000. - The integer values will be in the range [-10^6, 10^6]. - The string values are case-sensitive and will contain only alphabetical characters. - The floating-point numbers will be in the range [0.0, 100.0]. Example: ```python sort_complex_tuples([(3, \'apple\', 5.0), (1, \'apple\', 10.0), (1, \'banana\', 1.0), (3, \'apple\', 15.0)]) ``` This should return: ```python [(1, \'apple\', 10.0), (1, \'banana\', 1.0), (3, \'apple\', 15.0), (3, \'apple\', 5.0)] ``` Notes: - Make sure to test your function with different combinations of integers, strings, and floating-point numbers to ensure the correct sorting order.","solution":"from typing import List, Tuple def sort_complex_tuples(data: List[Tuple[int, str, float]]) -> List[Tuple[int, str, float]]: Sorts a list of tuples based on the following criteria: 1. By the integer in ascending order. 2. By the string in alphabetical order if the integers are the same. 3. By the floating-point number in descending order if both the integer and string are the same. Parameters: data (List[Tuple[int, str, float]]): A list of tuples to be sorted. Returns: List[Tuple[int, str, float]]: The sorted list of tuples. return sorted(data, key=lambda x: (x[0], x[1], -x[2]))"},{"question":"# Tic-Tac-Toe AI You are tasked with developing an intelligent Tic-Tac-Toe player that can never lose. Implement a class `TicTacToeAI` that can play a perfect game of Tic-Tac-Toe against a human player or another AI. ```python class TicTacToeAI: def __init__(self): Initialize the Tic-Tac-Toe AI. Initialize the game board as a 3x3 matrix filled with empty strings. self.board = [[\\"\\" for _ in range(3)] for _ in range(3)] def make_move(self, player: str) -> tuple: Make the optimal move for the given player and update the board. :param player: \'X\' or \'O\', representing the player making the move :return: a tuple (row, col) representing the position of the move made pass def is_winner(self, player: str) -> bool: Check if the given player has won the game. :param player: \'X\' or \'O\' :return: True if the player has won, False otherwise pass def is_draw(self) -> bool: Check if the game is a draw (no empty spots left on the board). :return: True if the game is a draw, False otherwise pass def reset_board(self): Reset the game board to its initial empty state. self.board = [[\\"\\" for _ in range(3)] for _ in range(3)] ``` Requirements: * Implement the `make_move` method using the minimax algorithm with alpha-beta pruning to ensure optimal play. * The AI should never lose; it should aim to win or draw at worst. * The `is_winner` and `is_draw` methods should accurately determine the game state. * Write additional helper functions as needed to maintain a clean and modular codebase. Additional Considerations: Consider the efficiency of your AI, particularly for the minimax implementation, and how you can optimize it to ensure quick move decisions. A strong solution will include thoughtful consideration of edge cases, such as checking the board state after each move to determine if someone has won or if there are any ties. Demonstrate your AI\'s capabilities by playing it against itself and output the game board after each move until the game concludes with a win or a draw. Summarize the results and explain your algorithm\'s efficiency, decision-making processes, and how it handles various game scenarios.","solution":"class TicTacToeAI: def __init__(self): Initialize the Tic-Tac-Toe AI. Initialize the game board as a 3x3 matrix filled with empty strings. self.board = [[\\"\\" for _ in range(3)] for _ in range(3)] def make_move(self, player: str) -> tuple: Make the optimal move for the given player and update the board. :param player: \'X\' or \'O\', representing the player making the move :return: a tuple (row, col) representing the position of the move made if player == \'X\': opponent = \'O\' else: opponent = \'X\' best_score = -float(\'inf\') best_move = None for i in range(3): for j in range(3): if self.board[i][j] == \\"\\": self.board[i][j] = player score = self.minimax(0, False, player, opponent) self.board[i][j] = \\"\\" if score > best_score: best_score = score best_move = (i, j) self.board[best_move[0]][best_move[1]] = player return best_move def minimax(self, depth, is_maximizing, player, opponent): if self.is_winner(player): return 1 if self.is_winner(opponent): return -1 if self.is_draw(): return 0 if is_maximizing: best_score = -float(\'inf\') for i in range(3): for j in range(3): if self.board[i][j] == \\"\\": self.board[i][j] = player score = self.minimax(depth + 1, False, player, opponent) self.board[i][j] = \\"\\" best_score = max(best_score, score) return best_score else: best_score = float(\'inf\') for i in range(3): for j in range(3): if self.board[i][j] == \\"\\": self.board[i][j] = opponent score = self.minimax(depth + 1, True, player, opponent) self.board[i][j] = \\"\\" best_score = min(best_score, score) return best_score def is_winner(self, player: str) -> bool: Check if the given player has won the game. :param player: \'X\' or \'O\' :return: True if the player has won, False otherwise for row in self.board: if row == [player, player, player]: return True for col in range(3): if [self.board[0][col], self.board[1][col], self.board[2][col]] == [player, player, player]: return True if [self.board[0][0], self.board[1][1], self.board[2][2]] == [player, player, player]: return True if [self.board[0][2], self.board[1][1], self.board[2][0]] == [player, player, player]: return True return False def is_draw(self) -> bool: Check if the game is a draw (no empty spots left on the board). :return: True if the game is a draw, False otherwise for row in self.board: if \\"\\" in row: return False return not (self.is_winner(\'X\') or self.is_winner(\'O\')) def reset_board(self): Reset the game board to its initial empty state. self.board = [[\\"\\" for _ in range(3)] for _ in range(3)]"},{"question":"# Sorting Large Files You are required to implement a system for efficiently sorting extremely large text files. Each line in the file contains a single word. # Task: 1. Write a function `external_sort` that sorts a large file on disk without loading the entire file into memory. * Input: * `input_file` - The name of the input file that contains an unsorted list of words. * `output_file` - The name of the output file where the sorted list of words should be saved. * Output: * A sorted file saved as `output_file`. # Requirements: - The input file could be very large (several gigabytes), so your algorithm must handle it efficiently. - You should implement a sorting method that uses temporary auxiliary files to manage the sorting process. - You should ensure that your implementation handles possible edge cases, such as empty input files or files with a large number of duplicate words. # Example: Suppose you have an input file `unsorted_words.txt` with the following content: ``` banana apple cherry banana grape apple elderberry fig date ``` After running the `external_sort` function, the output file `sorted_words.txt` should contain: ``` apple apple banana banana cherry date elderberry fig grape ``` # Solution Hints: - Consider implementing a variation of the external merge sort algorithm, which involves splitting the input file into smaller chunks, sorting each chunk in memory, and then merging the sorted chunks. - Utilize efficient file I/O operations and ensure minimal usage of memory. # Constraints: - You can assume the length of each word does not exceed 255 characters. - The total content of the file may exceed the available system memory. # Additional Notes: - Your solution should aim for clarity and efficiency. - Provide comments in your code to explain the key steps and logical decisions. **Example Python Implementation:** ```python def external_sort(input_file, output_file, chunk_size=1000): def merge(files): import heapq min_heap = [] for i, f in enumerate(files): first_line = f.readline().strip() if first_line: heapq.heappush(min_heap, (first_line, i)) sorted_result = [] while min_heap: min_word, file_index = heapq.heappop(min_heap) sorted_result.append(min_word) next_line = files[file_index].readline().strip() if next_line: heapq.heappush(min_heap, (next_line, file_index)) return sorted_result import os temp_dir = \'temp_chunks\' os.makedirs(temp_dir, exist_ok=True) temp_files = [] with open(input_file, \'r\') as infile: while True: lines = infile.readlines(chunk_size) if not lines: break sorted_lines = sorted(line.strip() for line in lines) temp_file_path = os.path.join(temp_dir, f\'temp_chunk_{len(temp_files)}.txt\') with open(temp_file_path, \'w\') as temp_file: temp_file.write(\'n\'.join(sorted_lines) + \'n\') temp_files.append(open(temp_file_path, \'r\')) sorted_result = merge(temp_files) with open(output_file, \'w\') as outfile: outfile.write(\'n\'.join(sorted_result)) for temp_file in temp_files: temp_file.close() for temp_file in os.scandir(temp_dir): os.remove(temp_file.path) os.rmdir(temp_dir) # Example usage: external_sort(\'unsorted_words.txt\', \'sorted_words.txt\', chunk_size=1024) ```","solution":"import os import heapq def external_sort(input_file, output_file, chunk_size=1000): def merge(files): min_heap = [] for i, f in enumerate(files): first_line = f.readline().strip() if first_line: heapq.heappush(min_heap, (first_line, i)) with open(output_file, \'w\') as outfile: while min_heap: min_word, file_index = heapq.heappop(min_heap) outfile.write(min_word + \\"n\\") next_line = files[file_index].readline().strip() if next_line: heapq.heappush(min_heap, (next_line, file_index)) temp_dir = \'temp_chunks\' os.makedirs(temp_dir, exist_ok=True) temp_files = [] try: with open(input_file, \'r\') as infile: while True: lines = infile.readlines(chunk_size) if not lines: break sorted_lines = sorted(line.strip() for line in lines) temp_file_path = os.path.join(temp_dir, f\'temp_chunk_{len(temp_files)}.txt\') with open(temp_file_path, \'w\') as temp_file: temp_file.write(\'n\'.join(sorted_lines) + \'n\') temp_files.append(open(temp_file_path, \'r\')) merge(temp_files) finally: for temp_file in temp_files: temp_file.close() for temp_file in os.scandir(temp_dir): os.remove(temp_file.path) os.rmdir(temp_dir)"},{"question":"# Flatten Dictionary Objective Write a function that takes a nested dictionary and flattens it by concatenating the keys. Function Signature ```python def flatten_dict(input_dict: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: ``` Parameters * `input_dict` (dict): The nested dictionary to be flattened. * `parent_key` (str): The base key to use for the top-level dictionary. Defaults to an empty string. * `sep` (str): The separator used to concatenate keys. Defaults to period (`.`). Returns * `dict`: The flattened dictionary with concatenated keys. Constraints 1. `input_dict` is guaranteed to be a valid dictionary of arbitrary depth. 2. All keys are strings and all values are either dictionaries or scalars (e.g., int, float, str). Examples ```python >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}}) {\'a\': 1, \'b.c\': 2, \'b.d.e\': 3} >>> flatten_dict({\\"a\\": {\\"b\\": {\\"c\\": 1}}, \\"d\\": {\\"e\\": 2}}) {\'a.b.c\': 1, \'d.e\': 2} >>> flatten_dict({\\"x\\": 1, \\"y\\": {\\"z\\": {\\"w\\": 2}}, \\"v\\": 3}, sep=\\"_\\") {\'x\': 1, \'y_z_w\': 2, \'v\': 3} >>> flatten_dict({}) {} ``` Edge Cases * Empty dictionary `{}` * Nested dictionaries of varying depths Instructions 1. Implement `flatten_dict` adhering to the function signature above. 2. Ensure to handle type errors: - Raise `ValueError` with an appropriate message if `input_dict` is not a dictionary. - Raise `ValueError` with an appropriate message if `parent_key` or `sep` is not a string. 3. Use a recursive approach to flatten nested dictionaries. Testing Use the provided examples and edge cases to validate your implementation.","solution":"def flatten_dict(input_dict: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: Flattens a nested dictionary by concatenating keys. Parameters: - input_dict: The nested dictionary to be flattened. - parent_key: The base key to use for the top-level dictionary. - sep: The separator used to concatenate keys. Returns: - The flattened dictionary with concatenated keys. if not isinstance(input_dict, dict): raise ValueError(\\"input_dict must be a dictionary.\\") if not isinstance(parent_key, str): raise ValueError(\\"parent_key must be a string.\\") if not isinstance(sep, str): raise ValueError(\\"sep must be a string.\\") items = [] for k, v in input_dict.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Question You are tasked with developing a Python function that evaluates the performance metrics of a machine learning model. The function `evaluate_model_performance` should compute the model\'s accuracy, precision, recall, and F1 score based on the provided true labels and predicted labels. **Function Signature:** ```python def evaluate_model_performance(true_labels: list[int], predicted_labels: list[int]) -> dict: pass ``` # Input: - `true_labels`: A list of integers where each integer represents the true class label of a data point. - `predicted_labels`: A list of integers where each integer represents the predicted class label of a data point produced by the model. # Output: - Returns a dictionary with the following keys: `accuracy`, `precision`, `recall`, and `f1_score`. The values should be computed as follows: - `accuracy`: The fraction of correct predictions over the total number of predictions. - `precision`: The fraction of relevant instances among the retrieved instances. - `recall`: The fraction of relevant instances that have been retrieved over the total amount of relevant instances. - `f1_score`: The harmonic mean of precision and recall. # Constraints: - The lists `true_labels` and `predicted_labels` are both non-empty and of the same length. - Class labels are binary (0 or 1). # Example: ```python # Example Usage: true_labels = [1, 0, 1, 1, 0, 1, 0] predicted_labels = [1, 0, 0, 1, 0, 1, 1] metrics = evaluate_model_performance(true_labels, predicted_labels) print(metrics) # Output: # { # \\"accuracy\\": 0.7142857142857143, # \\"precision\\": 0.75, # \\"recall\\": 0.75, # \\"f1_score\\": 0.75 # } ``` # Note: - The accuracy is calculated as ((text{{number of correct predictions}}) / (text{{total number of predictions}})). - The precision is calculated as ((text{{true positives}}) / (text{{true positives}} + text{{false positives}})). - The recall is calculated as ((text{{true positives}}) / (text{{true positives}} + text{{false negatives}})). - The F1 score is calculated as (2 times (text{{precision}} times text{{recall}}) / (text{{precision}} + text{{recall}})).","solution":"def evaluate_model_performance(true_labels, predicted_labels): Compute accuracy, precision, recall, and F1 score for binary classification. Args: true_labels (list of int): True class labels. predicted_labels (list of int): Predicted class labels. Returns: dict: Dictionary with keys \'accuracy\', \'precision\', \'recall\', \'f1_score\'. # Ensure both lists are of the same length assert len(true_labels) == len(predicted_labels), \\"Both lists should be of the same length\\" # Initialize counts tp = 0 # True positives tn = 0 # True negatives fp = 0 # False positives fn = 0 # False negatives # Calculate tp, tn, fp, and fn for true, pred in zip(true_labels, predicted_labels): if true == 1 and pred == 1: tp += 1 elif true == 0 and pred == 0: tn += 1 elif true == 0 and pred == 1: fp += 1 elif true == 1 and pred == 0: fn += 1 # Calculate metrics accuracy = (tp + tn) / len(true_labels) precision = tp / (tp + fp) if (tp + fp) > 0 else 0 recall = tp / (tp + fn) if (tp + fn) > 0 else 0 f1_score = 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0 return { \'accuracy\': accuracy, \'precision\': precision, \'recall\': recall, \'f1_score\': f1_score }"},{"question":"# Scenario You are tasked with developing a function to analyze list elements and identify whether a particular element exists within a nested structure of lists. The structure can be arbitrarily deep with lists containing other lists or single elements. # Problem Statement Implement the `element_in_nested_list` function to determine if a specific element exists within a given nested list structure. The function should be able to handle complex nested structures and return a boolean indicating the presence of the element. # Function Signature ```python def element_in_nested_list(nested_list: list, element: any) -> bool: ``` # Input * `nested_list` (list): The nested list structure containing sub-lists and/or elements. * `element` (any): The element you are searching for within the nested list. # Output * Returns a boolean `True` if the element is found in the nested list, otherwise `False`. # Exception Handling * Handle cases where `nested_list` might contain types other than lists or permissible elements appropriately. # Constraints * The nested structure can be deeply nested and might include various data types. * This function should be efficient enough to handle large and deeply nested structures. # Example ```python # Example usage of element_in_nested_list nested_list = [3, [7, [9, [10, [13, 17]]]], 20] print(element_in_nested_list(nested_list, 17)) # True print(element_in_nested_list(nested_list, 8)) # False ``` # Test Cases Ensure your function passes the following test cases: 1. `element_in_nested_list([1, [2, [3, [4, 5]]]], 5)` should return `True` 2. `element_in_nested_list([[\'a\', \'b\'], [\'c\', [\'d\', \'e\']], \'f\'], \'g\')` should return `False` 3. `element_in_nested_list([], 1)` should return `False` (Your function should be able to handle similar complexities and edge cases like the provided examples and test cases.)","solution":"def element_in_nested_list(nested_list, element): Determines if a specific element exists within a given nested list structure. Parameters: nested_list (list): The nested list structure containing sub-lists and/or elements. element (any): The element to search for within the nested list. Returns: bool: True if the element is found in the nested list, otherwise False. # Base case: if the element is directly in the list for item in nested_list: if isinstance(item, list): # Recursive case: if the item is a list, recurse if element_in_nested_list(item, element): return True elif item == element: return True return False"},{"question":"# Task: Implement a File System Hierarchy Background You are tasked with implementing a basic file system hierarchy in memory. This file system allows for the creation and manipulation of directories and files. Requirements 1. **Operations**: * `mkdir(path: str) -> None` - Creates a new directory at the specified path. If the directory already exists, do nothing. * `addFile(path: str, content: str) -> None` - Creates a new file at the specified path and adds content to it. If the file already exists, append the content to the existing file. * `ls(path: str) -> List[str]` - Lists the contents of the specified directory or file. For a directory, return the names of the subdirectories and files within it (both directories and files should be sorted lexicographically). For a file, return just the file name. * `readFile(path: str) -> str` - Reads the content of the specified file. 2. **Input/Output**: * All paths are absolute starting from the root (`\\"/\\"`). Paths and content are strings. * The structure should initially only contain the root directory (`\\"/\\"`). * File names and directory names are case-sensitive and contain no spaces. 3. **Constraints**: * The length of the path will not exceed 1000 characters. * The length of the file content will not exceed 5000 characters. Function Signatures ```python class FileSystem: def mkdir(self, path: str) -> None: pass def addFile(self, path: str, content: str) -> None: pass def ls(self, path: str) -> list[str]: pass def readFile(self, path: str) -> str: pass ``` # Example Usage ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello\\") fs.addFile(\\"/a/b/c/d.txt\\", \\" World\\") assert fs.ls(\\"/a/b/c\\") == [\\"d.txt\\"] assert fs.readFile(\\"/a/b/c/d.txt\\") == \\"Hello World\\" assert fs.ls(\\"/\\") == [\\"a\\"] ``` This question asks you to build and manipulate a simple in-memory file system, enhancing your understanding of tree structures, string manipulation, and object-oriented design.","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: dirs = path.strip(\'/\').split(\'/\') current = self.root for dir in dirs: if dir not in current: current[dir] = {} current = current[dir] def addFile(self, path: str, content: str) -> None: dirs = path.strip(\'/\').split(\'/\') file_name = dirs.pop() current = self.root for dir in dirs: if dir not in current: current[dir] = {} current = current[dir] if file_name not in current: current[file_name] = \\"\\" current[file_name] += content def ls(self, path: str) -> list: if path == \\"/\\": return sorted(self.root.keys()) dirs = path.strip(\'/\').split(\'/\') current = self.root for dir in dirs: current = current[dir] if isinstance(current, str): return [dirs[-1]] return sorted(current.keys()) def readFile(self, path: str) -> str: dirs = path.strip(\'/\').split(\'/\') file_name = dirs.pop() current = self.root for dir in dirs: current = current[dir] return current[file_name]"},{"question":"# Path Finder: Can You Reach the End? Problem Statement You are given a 2D grid `grid`, where each cell represents either a passable path (represented by `1`) or an impassable obstacle (represented by `0`). Your task is to determine if there exists a path from the top-left corner cell (0, 0) to the bottom-right corner cell (n-1, n-1), moving only up, down, left, or right. Write a function `can_reach_end(grid: List[List[int]]) -> bool` to determine if such a path exists. Input * `grid` (List[List[int]]): A two-dimensional list representing the grid. Contains only `1`s (passable path) and `0`s (impassable obstacle). * It is guaranteed that both the top-left and bottom-right corners of the grid are passable (`1`). Output * Return `True` if there exists a path from cell (0, 0) to cell (n-1, n-1). * Otherwise, return `False`. Constraints * The size of the grid (n x n) will be between `2` and `1000`. Examples ```python can_reach_end([[1, 0, 1, 1], [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 1]]) -> True # Explanation: A possible path is [(0,0), (1,0), (1,1), (2,1), (2,2), (3,2), (3,3)] can_reach_end([[1, 0], [0, 1]]) -> False # Explanation: There is no way to proceed from (0,0) to (1,1). ``` Additional Information Consider using breadth-first search (BFS) or depth-first search (DFS) to explore the grid systematically. Ensure you manage space and time complexities well, given the constraints of the grid size.","solution":"from typing import List from collections import deque def can_reach_end(grid: List[List[int]]) -> bool: if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return False n = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(n)] queue = deque([(0, 0)]) visited[0][0] = True while queue: x, y = queue.popleft() if x == n - 1 and y == n - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1: queue.append((nx, ny)) visited[nx][ny] = True return False"},{"question":"# Problem Statement You are assigned to implement a function that computes the gravitational potential energy of an object. The potential energy is determined using the mass of the object, the height of the object above ground, and the gravitational acceleration constant. Ensure your implementation handles invalid input appropriately. # Function Signature ```python def potential_energy(mass: float, height: float, gravity: float = 9.80665) -> float: pass ``` # Input - `mass`: A positive float representing the mass of the object in kilograms. - `height`: A positive float representing the height of the object in meters. - `gravity`: An optional positive float representing the gravitational acceleration in meters per second squared, defaulting to 9.80665. # Output - A float representing the gravitational potential energy of the object in joules. # Constraints - All input parameters (`mass`, `height`, `gravity`) must be positive values. # Requirement - If any input parameter is not positive, raise a `ValueError` with the message `\\"mass, height, and gravity all need to be positive\\"`. # Examples 1. `potential_energy(10, 5)` returns `490.3325` 2. `potential_energy(2.5, 3.8)` returns `93.34735` 3. `potential_energy(5, 10, 9.8)` returns `490.0` 4. `potential_energy(-5, 10)` raises `ValueError` 5. `potential_energy(3, -2)` raises `ValueError` # Context This problem helps in understanding and applying fundamental principles of physics in computational programming. It assesses your ability to handle numerical calculations, input validation, and exceptions in Python. # Detailed Instructions 1. Validate the input parameters to ensure they are all positive. 2. Apply the gravitational potential energy formula to compute and return the result. 3. Handle invalid input appropriately by raising a `ValueError` with the specified message. ```python def potential_energy(mass: float, height: float, gravity: float = 9.80665) -> float: if mass <= 0 or height <= 0 or gravity <= 0: raise ValueError(\\"mass, height, and gravity all need to be positive\\") return mass * height * gravity ```","solution":"def potential_energy(mass: float, height: float, gravity: float = 9.80665) -> float: Calculates the gravitational potential energy of an object. Parameters: mass (float): Mass of the object in kilograms. height (float): Height of the object in meters. gravity (float, optional): Gravitational acceleration in meters per second squared. Defaults to 9.80665. Returns: float: The gravitational potential energy in joules. Raises: ValueError: If mass, height, or gravity are not positive values. if mass <= 0 or height <= 0 or gravity <= 0: raise ValueError(\\"mass, height, and gravity all need to be positive\\") return mass * height * gravity"},{"question":"# Problem Statement Create a function that takes a list of integers and returns the length of the longest subsequence where the difference between consecutive elements is consistent. This subsequence does not need to be contiguous but must maintain the order of the original list. # Function Signature ```python def longest_arithmetic_subsequence(arr: list[int]) -> int: `arr`: A list of integers. Returns the length of the longest arithmetic subsequence. Constraints: * The input list can have up to 10^6 elements. * Each element in the list is an integer within the range -10^9 to 10^9. Example: >>> longest_arithmetic_subsequence([1, 7, 10, 15, 27, 29]) 3 >>> longest_arithmetic_subsequence([1, 3, 5, 7, 9]) 5 pass ``` # Guidelines 1. **Subsequence Definition**: The subsequence must maintain the order of the original list, but elements do not need to be contiguous. 2. **Difference Consistency**: The difference between consecutive elements in the subsequence must be the same throughout. 3. **Optimal Performance**: Ensure the solution performs efficiently for large lists. # Input and Output Format ```text longest_arithmetic_subsequence([1, 7, 10, 15, 27, 29]) => 3 longest_arithmetic_subsequence([1, 3, 5, 7, 9]) => 5 ``` # Constraints * The input list can have up to 10^6 elements. * Each element in the list is an integer within the range -10^9 to 10^9. Notes - This problem requires an algorithm that can handle large input sizes efficiently. - Consider edge cases such as very short lists or lists with identical elements.","solution":"def longest_arithmetic_subsequence(arr: list[int]) -> int: if not arr: return 0 from collections import defaultdict # dp will store the length of subsequences for each difference found dp = [defaultdict(int) for _ in range(len(arr))] max_length = 1 for i in range(1, len(arr)): for j in range(i): diff = arr[i] - arr[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"# Problem Statement You are tasked with implementing a function that determines whether a given integer is a \\"Keith number\\". A Keith number is a special number in recreational mathematics. To determine if a number is a Keith number, you start with its digits as the initial terms of a sequence (e.g., for 197, the sequence starts with 1, 9, 7). Subsequent terms in the sequence are generated by summing the previous terms. If the original number reappears in the sequence, it is a Keith number. Create a function `is_keith_number` that accepts an integer `num` and determines whether it is a Keith number or not. # Function Signature ```python def is_keith_number(num: int) -> bool: pass ``` # Input - `num`: A positive integer (10 ≤ num ≤ 10^6) # Output - A boolean indicating whether the given number is a Keith number. # Constraints - If the input `num` is less than 10, raise a ValueError with the message: `\\"num must be greater than or equal to 10\\"`. # Example ```python >>> is_keith_number(197) True >>> is_keith_number(19) True >>> is_keith_number(20) False >>> is_keith_number(999) False >>> is_keith_number(14) Traceback (most recent call last): ... ValueError: num must be greater than or equal to 10 ``` # Implementation Considerations - Ensure your solution is efficient and can handle the upper limit of the constraint. - Make sure to correctly validate the input and raise appropriate errors when necessary.","solution":"def is_keith_number(num): Determines if a given number is a Keith number. if num < 10: raise ValueError(\\"num must be greater than or equal to 10\\") # Convert the number to its individual digits digits = [int(digit) for digit in str(num)] # Use the length of the digits length = len(digits) # Initialize the sequence with the digits sequence = digits[:] # Generate the sequence until the number is reached or surpassed while True: next_term = sum(sequence[-length:]) if next_term == num: return True if next_term > num: return False sequence.append(next_term)"},{"question":"# Problem Statement: You are provided with a function template to implement a basic matrix manipulation. Your task is to complete the function to perform a series of transformations on the given matrix according to specified operations. # Requirements: 1. Implement a method `transform_matrix` that takes in the following parameters: - `matrix`: A list of lists representing a 2D matrix of integers. - `operations`: A list of operation strings where each string can be: - `\'rotate_clockwise\'`: Rotate the matrix 90 degrees clockwise. - `\'rotate_counterclockwise\'`: Rotate the matrix 90 degrees counterclockwise. - `\'reverse_rows\'`: Reverse the order of elements in each row. - `\'reverse_columns\'`: Reverse the order of elements in each column. 2. The `transform_matrix` function should apply the transformations in the order they are given in the `operations` list. 3. Validate the input and handle invalid operations by raising appropriate exceptions. The matrix should be a non-empty list of non-empty lists with equal lengths, representing a valid 2D matrix, and operations should be from the specified set only. # Constraints: - **Input validation**: Must handle invalid input cases by raising exceptions. - **Performance**: The function should apply the transformations efficiently and handle typical cases within reasonable limits. # Function Signature: ```python def transform_matrix( matrix: list[list[int]], operations: list[str] ) -> list[list[int]]: pass ``` # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] operations = [\'rotate_clockwise\', \'reverse_rows\'] result = transform_matrix(matrix, operations) print(result) # Output should be: # [[7, 4, 1], # [8, 5, 2], # [9, 6, 3]] ``` # Note: - You should handle edge cases such as an empty matrix, rows of different lengths, and invalid operation strings gracefully by raising appropriate exceptions. - The operations should be performed in sequence as provided in the `operations` list. ---","solution":"def transform_matrix(matrix, operations): def rotate_clockwise(mat): return [list(x) for x in zip(*mat[::-1])] def rotate_counterclockwise(mat): return [list(x) for x in zip(*mat)][::-1] def reverse_rows(mat): return [row[::-1] for row in mat] def reverse_columns(mat): return mat[::-1] # Validate matrix if not matrix or not isinstance(matrix, list) or not all(isinstance(row, list) and row for row in matrix): raise ValueError(\\"Invalid matrix: must be a non-empty list of non-empty lists\\") row_length = len(matrix[0]) if any(len(row) != row_length for row in matrix): raise ValueError(\\"Invalid matrix: all rows must have the same length\\") # Validate operations valid_operations = {\'rotate_clockwise\', \'rotate_counterclockwise\', \'reverse_rows\', \'reverse_columns\'} for op in operations: if op not in valid_operations: raise ValueError(f\\"Invalid operation: {op}\\") # Apply operations for operation in operations: if operation == \'rotate_clockwise\': matrix = rotate_clockwise(matrix) elif operation == \'rotate_counterclockwise\': matrix = rotate_counterclockwise(matrix) elif operation == \'reverse_rows\': matrix = reverse_rows(matrix) elif operation == \'reverse_columns\': matrix = reverse_columns(matrix) return matrix"},{"question":"# Context You are working on enhancing a spell-checking software by implementing a feature for suggesting corrections to misspelled words. The software needs to generate suggestions based on the edit distance, which measures the number of operations (insertions, deletions, or substitutions) required to transform one word into another. # Objective Develop a function that takes a misspelled word and a list of correctly spelled words, then returns the best suggestion based on the smallest edit distance. # Function Definitions Implement the following function: 1. `suggest_correction(misspelled: str, dictionary: list[str]) -> str`: - Takes a misspelled word and a dictionary of correctly spelled words. - Returns the word from the dictionary with the smallest edit distance to the misspelled word. # Input and Output Formats - **suggest_correction(misspelled: str, dictionary: list[str]) -> str** * `misspelled`: String, the misspelled word. * `dictionary`: List of strings, the correctly spelled words. * Returns: String, the best suggestion from the dictionary based on the smallest edit distance. # Constraints - `1 <= len(misspelled) <= 100` - `1 <= len(dictionary) <= 1000` - Each word in the dictionary should have a length between 1 and 100. - Dictionary words and the misspelled word consist of lowercase alphabetic characters only. # Example Usage ```python # Example inputs misspelled = \\"speling\\" dictionary = [\\"spelling\\", \\"sphere\\", \\"selling\\", \\"spilling\\"] # Function call print(suggest_correction(misspelled, dictionary)) # Expected output: \\"spelling\\" ``` # Task Implement the function `suggest_correction` following the guidelines and constraints provided. Ensure your implementation efficiently computes the edit distance between the misspelled word and each word in the dictionary.","solution":"def edit_distance(word1, word2): Compute the edit distance between two words. dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)] for i in range(len(word1) + 1): for j in range(len(word2) + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[len(word1)][len(word2)] def suggest_correction(misspelled, dictionary): Suggest the best correction for a misspelled word from a dictionary. best_suggestion = \\"\\" smallest_distance = float(\'inf\') for word in dictionary: distance = edit_distance(misspelled, word) if distance < smallest_distance: smallest_distance = distance best_suggestion = word return best_suggestion"},{"question":"# Coding Question: Stock Price Tracking System Context You\'re required to create a program that fetches real-time stock prices for a set of given company tickers from a financial data API and monitors: 1. The current stock price. 2. The highest price for the last 24 hours. 3. The lowest price for the last 24 hours. Task Implement a class `StockTracker` with the following methods: 1. `__init__(self, tickers: list[str]) -> None`: Initializes the tracker with a list of company tickers. 2. `update_price(self) -> None`: Fetches the latest price for each ticker and updates the highest and lowest prices for the last 24 hours. 3. `get_current_price(self, ticker: str) -> float`: Returns the current price of the specified ticker. 4. `get_highest_price(self, ticker: str) -> float`: Returns the highest price of the specified ticker in the last 24 hours. 5. `get_lowest_price(self, ticker: str) -> float`: Returns the lowest price of the specified ticker in the last 24 hours. You should ensure your implementation handles potential errors and edge cases robustly, ensuring accurate tracking and updates of stock information. Input * `tickers` - A list of strings where each string represents a company ticker (e.g., `[\\"AAPL\\", \\"GOOGL\\", \\"AMZN\\"]`). Output * Ensure the methods above return the expected data for each ticker. Constraints * Handle potential API errors gracefully with appropriate error messages. * Ensure that the data parsing handles edge cases where certain elements might be missing. * Suppose the hypothetical API endpoint is `\\"https://api.finance.com/stock?ticker=\\"`. Performance Requirements * Optimize for time by minimizing API calls and parsing time. * Ensure your solution does not significantly exceed O(n) time and space complexity for fetching and parsing the data (where n is the number of tickers). Example Usage ```python # Example of using the StockTracker class tracker = StockTracker([\\"AAPL\\", \\"GOOGL\\", \\"AMZN\\"]) tracker.update_price() print(tracker.get_current_price(\\"AAPL\\")) # Outputs the current price of AAPL print(tracker.get_highest_price(\\"GOOGL\\")) # Outputs the highest price of GOOGL in the last 24 hours print(tracker.get_lowest_price(\\"AMZN\\")) # Outputs the lowest price of AMZN in the last 24 hours ``` Additional Information * You can use third-party libraries such as `requests` which are already imported in the provided code snippet. * Add necessary error handling for unpredictable scenarios such as connection issues or changes in API response structure. * If the financial data API has rate limits, implement appropriate handling to conform to those limits.","solution":"import requests from datetime import datetime, timedelta class StockTracker: def __init__(self, tickers): self.tickers = tickers self.stock_data = {} for ticker in tickers: self.stock_data[ticker] = { \\"current_price\\": None, \\"high_24h\\": float(\'-inf\'), \\"low_24h\\": float(\'inf\'), \\"history\\": [] } def update_price(self): for ticker in self.tickers: try: response = requests.get(f\\"https://api.finance.com/stock?ticker={ticker}\\") response.raise_for_status() data = response.json() current_price = data[\'price\'] timestamp = datetime.utcnow() self.stock_data[ticker][\'current_price\'] = current_price self.stock_data[ticker][\'history\'].append((timestamp, current_price)) # Clean up history to only keep entries from the past 24 hours cutoff = timestamp - timedelta(hours=24) self.stock_data[ticker][\'history\'] = [(time, price) for (time, price) in self.stock_data[ticker][\'history\'] if time > cutoff] # Update high and low prices over the last 24 hours prices_last_24h = [price for time, price in self.stock_data[ticker][\'history\']] if prices_last_24h: self.stock_data[ticker][\'high_24h\'] = max(prices_last_24h) self.stock_data[ticker][\'low_24h\'] = min(prices_last_24h) except requests.RequestException as e: print(f\\"Error fetching data for {ticker}: {e}\\") def get_current_price(self, ticker): return self.stock_data[ticker][\'current_price\'] if ticker in self.stock_data else None def get_highest_price(self, ticker): return self.stock_data[ticker][\'high_24h\'] if ticker in self.stock_data else None def get_lowest_price(self, ticker): return self.stock_data[ticker][\'low_24h\'] if ticker in self.stock_data else None"},{"question":"# Coding Assessment Question Implement a function `remove_duplicates` that removes duplicate elements from a sorted list in-place, ensuring every element appears only once. The function should return the length of the modified list. This will help you practice in-place list manipulation and handling of sorted collections. Function Signature ```python def remove_duplicates(nums: list) -> int: pass ``` Input - `nums` (list of ints): A sorted list of integers, which may contain duplicates. Output - Returns an integer which is the length of the list after removing duplicates. - The list `nums` is modified in-place such that the first `k` elements (where `k` is the returned length) hold the non-duplicate elements. Constraints - List may contain up to `10^4` elements. - Elements can be negative or positive integers. - The list is guaranteed to be sorted. Performance Requirements - Expected time complexity: O(n). Example ```python nums = [1, 1, 2] length = remove_duplicates(nums) print(length) # Output: 2 print(nums[:length]) # Output: [1, 2] nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4] length = remove_duplicates(nums) print(length) # Output: 5 print(nums[:length]) # Output: [0, 1, 2, 3, 4] nums = [1, 2, 3] length = remove_duplicates(nums) print(length) # Output: 3 print(nums[:length]) # Output: [1, 2, 3] ``` Scenarios to Validate - Removing duplicates from an empty list. - Removing duplicates from a single-element list. - Removing duplicates from a list with only duplicate elements. - Handling cases where no duplicates are present.","solution":"def remove_duplicates(nums): Removes duplicate elements from a sorted list in-place. Returns the length of the modified list. if not nums: return 0 # Initialize the index for the next unique element unique_index = 0 for i in range(1, len(nums)): if nums[i] != nums[unique_index]: unique_index += 1 nums[unique_index] = nums[i] return unique_index + 1"},{"question":"# Problem Statement You have been given a `Graph` class that supports operations like adding vertices, adding edges, breadth-first search (BFS), depth-first search (DFS), and finding the shortest path using Dijkstra\'s algorithm. Enhance this class by adding a new functionality that identifies all the articulation points in an undirected graph. An articulation point (or cut vertex) is a vertex which, when removed, increases the number of connected components in the graph. # Requirements 1. **Function to Implement**: `find_articulation_points()` method inside the `Graph` class. 2. **Input**: The `Graph` object itself with (n) vertices and (m) edges where (n geq 2) and (m geq 1). 3. **Output**: A list of vertices that are articulation points. 4. **Performance**: Aim for (O(n + m)) time complexity. 5. **Constraints**: Ensure that the graph is connected, otherwise, raise an appropriate exception. # Example ```python g = Graph() g.add_vertex(0) g.add_vertex(1) g.add_vertex(2) g.add_vertex(3) g.add_vertex(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) print(g.find_articulation_points()) # Output: [1, 3] ``` # Notes - Implement the function using Depth First Search (DFS) approach for finding articulation points. - Utilize Tarjan\'s algorithm which uses DFS to efficiently find articulation points. - Maintain arrays for `discovery time` and `low value` of each vertex. - Ensure to handle edge cases where there might be no articulation points. - Make sure to validate the graph connectivity before proceeding with the algorithm.","solution":"class Graph: def __init__(self): self.graph = {} self.time = 0 def add_vertex(self, v): if v not in self.graph: self.graph[v] = [] def add_edge(self, v, w): if v in self.graph and w in self.graph: self.graph[v].append(w) self.graph[w].append(v) def _dfs(self, u, visited, parent, low, disc, articulation_points): children = 0 visited[u] = True disc[u] = self.time low[u] = self.time self.time += 1 for v in self.graph[u]: if not visited[v]: parent[v] = u children += 1 self._dfs(v, visited, parent, low, disc, articulation_points) low[u] = min(low[u], low[v]) if parent[u] is None and children > 1: articulation_points.add(u) if parent[u] is not None and low[v] >= disc[u]: articulation_points.add(u) elif v != parent[u]: low[u] = min(low[u], disc[v]) def find_articulation_points(self): n = len(self.graph) if n == 0: return [] if not self.is_connected(): raise ValueError(\\"Graph is not connected\\") visited = {v: False for v in self.graph} disc = {v: float(\'inf\') for v in self.graph} low = {v: float(\'inf\') for v in self.graph} parent = {v: None for v in self.graph} articulation_points = set() for v in self.graph: if not visited[v]: self._dfs(v, visited, parent, low, disc, articulation_points) return list(articulation_points) def is_connected(self): visited = {v: False for v in self.graph} def dfs(v): visited[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: dfs(neighbor) start_vertex = next(iter(self.graph)) dfs(start_vertex) return all(visited.values())"},{"question":"# Student Score and Grade Calculation Context: You are responsible for managing student scores and determining their corresponding grades. Your task involves calculating the total score for each student based on their individual assignment scores, and then assigning a grade based on their total score. Requirements: 1. **Function 1**: Implement a function `calculate_total_score(scores: dict) -> int` that computes the total score for a student. The function should: * Take a dictionary `scores` where keys are the names of assignment categories (e.g., \'homework\', \'exam\') and values are lists of integer scores. * Calculate the total score by summing all the individual scores across all categories. * Handle edge cases like empty lists or missing categories by assuming a score of 0 for those cases. 2. **Function 2**: Implement a function `determine_grade(total_score: int) -> str` that assigns a grade based on the total score. The function should: * Take the total score as an integer. * Return a grade as a string according to the following scale: - \'A\' for scores 90 and above - \'B\' for scores between 80 and 89 - \'C\' for scores between 70 and 79 - \'D\' for scores between 60 and 69 - \'F\' for scores below 60 * Ensure the input is a non-negative integer. Constraints: * Ensure both functions handle invalid inputs gracefully and provide meaningful error messages. * Aim to handle cases where score lists or categories might be missing without crashing. Input: - `calculate_total_score` function: * A dictionary `scores` with assignment categories as keys and lists of integers as values. - `determine_grade` function: * A non-negative integer `total_score`. Output: - `calculate_total_score` function: * Returns an integer representing the total score. - `determine_grade` function: * Returns a string indicating the grade corresponding to the input score. Example Usage: ```python >>> calculate_total_score({\\"homework\\": [90, 85, 80], \\"exam\\": [88], \\"project\\": [92]}) 435 >>> determine_grade(435) \'A\' >>> calculate_total_score({\\"homework\\": [], \\"exam\\": []}) 0 >>> determine_grade(0) \'F\' >>> determine_grade(-5) Traceback (most recent call last): ... ValueError: Total score must be a non-negative integer. ```","solution":"def calculate_total_score(scores): Calculate the total score for a student based on their assignment scores. :param scores: dict where keys are assignment categories and values are lists of integer scores :return: int total score total_score = 0 for category, score_list in scores.items(): if score_list: # If the list is not empty total_score += sum(score_list) return total_score def determine_grade(total_score): Determine the grade for a student based on the total score. :param total_score: int representing the total score :return: str grade corresponding to the total score if not isinstance(total_score, int) or total_score < 0: raise ValueError(\\"Total score must be a non-negative integer.\\") if total_score >= 90: return \'A\' elif total_score >= 80: return \'B\' elif total_score >= 70: return \'C\' elif total_score >= 60: return \'D\' else: return \'F\'"},{"question":"# Coding Assessment Question **Context**: You are required to implement a modified version of the classic Fibonacci sequence generator. In this alternate version, the sequence\'s terms are produced by summing the previous three terms instead of the traditional two. The sequence starts with the first three terms as `0, 1, 1`. **Objective**: Write a function `modified_fibonacci(n: int) -> List[int]` that generates the first `n` terms of this sequence. **Function Signature**: ```python def modified_fibonacci(n: int) -> List[int]: pass ``` **Input**: - `n`: An integer representing the number of terms to generate in the sequence. **Output**: - A list of integers containing the first `n` terms of the modified Fibonacci sequence. **Constraints**: - The input integer `n` is non-negative (i.e., `0 ≤ n ≤ 100`). - The function should handle cases where `n` is very small (such as `n = 0` or `n = 1`). **Example**: ```python >>> modified_fibonacci(0) [] >>> modified_fibonacci(1) [0] >>> modified_fibonacci(5) [0, 1, 1, 2, 4] >>> modified_fibonacci(10) [0, 1, 1, 2, 4, 7, 13, 24, 44, 81] ``` **Performance Requirements**: - Ensure the implementation efficiently handles the generation of the sequence, especially for maximum values of `n`. **Additional Notes**: - Pay special attention to edge cases, such as very small or large values of `n`. - The initial terms of the sequence are always `0, 1, 1`, which directly influence subsequent terms.","solution":"from typing import List def modified_fibonacci(n: int) -> List[int]: if n == 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] elif n == 3: return [0, 1, 1] seq = [0, 1, 1] for i in range(3, n): next_term = seq[-1] + seq[-2] + seq[-3] seq.append(next_term) return seq"},{"question":"# Coding Assessment Question: Context: Binary search trees (BST) are a fundamental data structure in computer science used for efficient searching, insertion, and deletion operations. They maintain a sorted order of elements, ensuring that the left child of any node has a value less than its parent node, and the right child has a value greater than its parent node. Given their importance, your task is to implement functions that handle BST operations and count the number of nodes within a specified range. Problem Statement: Write a Python function that, given a binary search tree and a range [low, high], returns the number of nodes that have values within the given range, inclusive. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_nodes_in_range(root: TreeNode, low: int, high: int) -> int: Count the number of nodes in the BST with values in the range [low, high]. Args: root (TreeNode): The root of the binary search tree. low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The count of nodes within the specified range. Examples: >>> root = TreeNode(10, TreeNode(5), TreeNode(15, None, TreeNode(20))) >>> count_nodes_in_range(root, 5, 15) 3 >>> root = TreeNode(12, TreeNode(7, TreeNode(5), TreeNode(9)), TreeNode(15, None, TreeNode(18))) >>> count_nodes_in_range(root, 6, 10) 2 >>> root = None >>> count_nodes_in_range(root, 1, 10) 0 # Implement your code here... ``` Constraints: - The binary search tree nodes consist of integer values. - The `TreeNode` class is already defined with `val`, `left`, and `right` attributes. - The BST will not contain duplicate values. - `low` and `high` are inclusive and have valid integer values where `low <= high`. Expected output: - The solution must return the count of nodes whose values fall within the range [low, high]. Example: For the given tree: ``` 10 / 5 15 20 ``` - If `low = 5` and `high = 15`, the count is `3` (nodes with values 5, 10, and 15). - If `low = 15` and `high = 20`, the count is `2` (nodes with values 15 and 20). Evaluation Criteria: Your solution will be evaluated based on: 1. Correctness: The function should accurately count the nodes in the specified range. 2. Efficiency: The function should handle large BSTs efficiently, adhering to the BST property. 3. Coding Style: Use clear and descriptive variable names, and ensure the code is readable and well-documented.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_nodes_in_range(root: TreeNode, low: int, high: int) -> int: Count the number of nodes in the BST with values in the range [low, high]. Args: root (TreeNode): The root of the binary search tree. low (int): The lower bound of the range. high (int): The upper bound of the range. Returns: int: The count of nodes within the specified range. if root is None: return 0 count = 0 if low <= root.val <= high: count += 1 if root.val > low: count += count_nodes_in_range(root.left, low, high) if root.val < high: count += count_nodes_in_range(root.right, low, high) return count"},{"question":"# Coding Assessment Question Scenario: Multi-threaded Matrix Multiplication You are developing a system for scientific computing that requires the efficient multiplication of large matrices. To optimize performance, you decide to implement a multi-threaded approach to matrix multiplication. Task Implement a function `multi_threaded_matrix_multiplication(A, B)` that multiplies two matrices A and B using multiple threads for parallel computation. Each thread should be responsible for computing specific elements of the resulting matrix. Function Signature ```python def multi_threaded_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Multiplies two matrices using multi-threading. Parameters: A (List[List[int]]): The first matrix, where each sublist is a row. B (List[List[int]]): The second matrix, where each sublist is a row. It is guaranteed that the number of columns in A equals the number of rows in B. Returns: List[List[int]]: The resulting matrix product. ``` Input - `A`: A list of lists representing matrix A of size MxK (1 <= M, K <= 500). - `B`: A list of lists representing matrix B of size KxN (1 <= K, N <= 500). Output - A list of lists representing the resulting matrix C of size MxN. Constraints - You must use multi-threading to achieve parallel computation. - Ensure proper synchronization between threads to avoid data races. - Consider edge cases such as matrices with a single row or column, and identities where appropriate. - A and B will always be valid matrices such that they can be multiplied as per matrix multiplication rules. Example ```python from typing import List # Example function call A = [ [1, 2], [3, 4] ] B = [ [5, 6], [7, 8] ] C = multi_threaded_matrix_multiplication(A, B) print(C) # Output: [[19, 22], [43, 50]] ``` Guidelines - Utilize Python\'s `threading` module to create and manage threads. - Each thread should be responsible for computing an individual element or a subset of elements in the resultant matrix. - Optimize thread workload distribution to minimize idle threads and enhance performance. - Ensure that your implementation is robust and can gracefully handle potential errors or exceptions. By following these guidelines and constraints, the multi-threaded approach should significantly enhance the matrix multiplication performance for large data sets.","solution":"from typing import List import threading def worker(A, B, result, row, col): result[row][col] = sum(A[row][k] * B[k][col] for k in range(len(A[row]))) def multi_threaded_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: M = len(A) K = len(A[0]) N = len(B[0]) result = [[0] * N for _ in range(M)] threads = [] for i in range(M): for j in range(N): thread = threading.Thread(target=worker, args=(A, B, result, i, j)) threads.append(thread) thread.start() for thread in threads: thread.join() return result"},{"question":"# Question: You are provided with a function `is_possible` that determines if it is possible to transform one string into another using a series of operations. Each operation can be one of the following: - Insert a character at any position in the string. - Delete a character from any position in the string. - Replace a character at any position in the string. Despite having this function, its efficiency is not suitable for large inputs due to its high time complexity. Your task is twofold: 1. **Analyze the given `is_possible` function** to identify its computational inefficiencies in terms of time and space. 2. **Develop an optimized solution** that can efficiently determine the minimum number of operations required to transform one string into another, and utilize this to improve the given function. # Requirements: - Write a function `min_operations(str1: str, str2: str) -> int` that computes the minimum number of operations required to transform `str1` into `str2`. - Use this function to optimize the `is_possible(str1: str, str2: str) -> bool` function, which returns whether the transformation is achievable in a specified number of operations `k`. # Constraints: - Both input strings will have lengths between 0 and 1000 characters. - The maximum number of operations `k` will be a non-negative integer. # Input Example: ```python str1 = \\"intention\\" str2 = \\"execution\\" k = 5 ``` # Expected Output: ```python False ``` # Notes: - The minimum number of operations to transform \\"intention\\" into \\"execution\\" is 5 replacements and 3 insertions/deletions, which totals 8 operations. Hence, for k = 5, the transformation is not possible. # Implementation: Implement the functions `min_operations` and `is_possible` ensuring that their time complexity is O(|str1| * |str2|). ```python def min_operations(str1: str, str2: str) -> int: m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # str1 is empty, insert all characters of str2 elif j == 0: dp[i][j] = i # str2 is empty, remove all characters of str1 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # characters match, no operation needed else: dp[i][j] = min(dp[i-1][j], # delete dp[i][j-1], # insert dp[i-1][j-1]) + 1 # replace return dp[m][n] def is_possible(str1: str, str2: str, k: int) -> bool: operations_needed = min_operations(str1, str2) return operations_needed <= k ```","solution":"def min_operations(str1: str, str2: str) -> int: m, n = len(str1), len(str2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # str1 is empty, insert all characters of str2 elif j == 0: dp[i][j] = i # str2 is empty, remove all characters of str1 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] # characters match, no operation needed else: dp[i][j] = min(dp[i-1][j], # delete dp[i][j-1], # insert dp[i-1][j-1]) + 1 # replace return dp[m][n] def is_possible(str1: str, str2: str, k: int) -> bool: operations_needed = min_operations(str1, str2) return operations_needed <= k"},{"question":"# Problem Statement You are required to implement a function that calculates the minimum number of coins needed to make up a given amount using an unlimited supply of coins of given denominations. If that amount of money cannot be made up by any combination of the coins, return -1. # Function Signature ```python def coinChange(coins: List[int], amount: int) -> int: pass ``` # Input - `coins` (List[int]): A list of integers representing the denominations of the available coins. Constraints: 1 <= len(coins) <= 12, 1 <= coins[i] <= 10000 - `amount` (int): An integer representing the amount of money. Constraints: 0 <= amount <= 10000. # Output - Returns an integer representing the minimum number of coins needed to make up the given amount, or -1 if it is not possible. # Example ```python assert coinChange([1, 2, 5], 11) == 3 # 11 = 5 + 5 + 1 assert coinChange([2], 3) == -1 # It\'s not possible to make up the amount assert coinChange([1], 0) == 0 # No coins are needed to make up amount 0 assert coinChange([1], 1) == 1 # 1 = 1 assert coinChange([1], 2) == 2 # 2 = 1 + 1 ``` # Constraints - Utilize a dynamic programming approach to ensure efficient computation given the constraints. - Ensure edge cases are handled, such as minimal or zero amount, and when only one type of coin is provided. # Performance Requirements Your solution should be optimized to handle the upper limits of the constraints effectively. Non-optimized solutions might not perform adequately for larger values.","solution":"from typing import List def coinChange(coins: List[int], amount: int) -> int: This function returns the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the given coins, it returns -1. # Create a list to hold the minimum number of coins needed for each amount dp = [float(\'inf\')] * (amount + 1) dp[0] = 0 # No coins needed to make amount 0 # Loop over each coin and update the dp array for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Return the answer for the original amount return dp[amount] if dp[amount] != float(\'inf\') else -1"},{"question":"# Scenario Robotic automation has become an integral part of modern inventory management systems. You are developing software to assist in optimizing warehouse layouts. Your task involves calculating the maximum area of a rectangle that can be formed by selecting elements from an `n x m` grid of integer heights, where each rectangle must be homogeneous (i.e., all heights within the rectangle are the same). # Task Write a function `largest_homogeneous_rectangle` that calculates the maximum area of a homogeneous rectangle that can be formed in the grid, where all heights within the rectangle are the same. # Input/Output - **Input**: A 2D list `grid` of integers where `grid[i][j]` represents the height at the `i-th` row and `j-th` column. - **Output**: The function should return an integer representing the maximum area of a homogeneous rectangle. # Constraints - The dimensions of the grid, `n` and `m`, have the following constraints: `1 <= n <= 100` and `1 <= m <= 100`. - Each height in the grid is a positive integer. # Function Signature ```python def largest_homogeneous_rectangle(grid: list[list[int]]) -> int: ``` # Example ```python # Example grid grid = [ [1, 2, 2, 3], [1, 2, 2, 3], [1, 1, 1, 3] ] print(largest_homogeneous_rectangle(grid)) # Output should be 4 because the largest homogeneous rectangle with height 2 has an area of 2x2. ``` # Notes - You may utilize dynamic programming techniques to efficiently calculate the maximum area. - Consider edge cases such as a grid with all elements being the same or a grid where each element is unique.","solution":"def largest_homogeneous_rectangle(grid): if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_area = 0 for row in range(n): for col in range(m): height = grid[row][col] width = 0 for k in range(col, m): if grid[row][k] == height: width += 1 else: break for h in range(row, n): if all(grid[h][j] == height for j in range(col, col + width)): max_area = max(max_area, width * (h - row + 1)) else: break return max_area"},{"question":"# Problem Statement You are tasked with implementing a library that manipulates and optimizes a list of unique numeric IDs. The library should provide functions to add, remove, and retrieve these IDs while ensuring that no duplicates exist and the operations are performed efficiently. # Requirements: 1. **Class to Manage IDs**: - Name: `UniqueIDManager` - Properties: - `ids` (a list that stores the unique numeric IDs). - Methods: 1. **add_id** - Name: `add_id` - Input: A single integer `id`. - Output: None - Constraints: - Add the given ID to the list if it does not already exist. - Raise a `ValueError` if the ID already exists. - Ensure the operation is efficient. 2. **remove_id** - Name: `remove_id` - Input: A single integer `id`. - Output: None - Constraints: - Remove the given ID from the list if it exists. - Raise a `ValueError` if the ID does not exist in the list. - Ensure the operation is efficient. 3. **get_all_ids** - Name: `get_all_ids` - Input: None - Output: A sorted list of all unique IDs currently stored. - Constraints: - Ensure the list is returned in ascending order. - Return a copy of the internal list to prevent external modifications. # Example: ```python class UniqueIDManager: def __init__(self): self.ids = [] def add_id(self, id: int) -> None: if id in self.ids: raise ValueError(\\"ID already exists.\\") self.ids.append(id) def remove_id(self, id: int) -> None: if id not in self.ids: raise ValueError(\\"ID not found.\\") self.ids.remove(id) def get_all_ids(self) -> list[int]: return sorted(self.ids) # Usage example: manager = UniqueIDManager() manager.add_id(5) manager.add_id(10) print(manager.get_all_ids()) # Output: [5, 10] manager.remove_id(5) print(manager.get_all_ids()) # Output: [10] ``` # Notes: - Ensure the `add_id` and `remove_id` methods handle errors appropriately by raising `ValueError`. - Implement the `get_all_ids` method to return a sorted list, ensuring the original list is not altered. - Consider optimizing the implementations for efficiency, especially when dealing with a large number of IDs. - Include comprehensive tests to validate your solution against various cases.","solution":"class UniqueIDManager: def __init__(self): self.ids_set = set() def add_id(self, id: int) -> None: if id in self.ids_set: raise ValueError(\\"ID already exists.\\") self.ids_set.add(id) def remove_id(self, id: int) -> None: if id not in self.ids_set: raise ValueError(\\"ID not found.\\") self.ids_set.remove(id) def get_all_ids(self) -> list[int]: return sorted(self.ids_set)"},{"question":"# Coding Challenge: Event Duration Calculation **Objective:** Write a Python function `calculate_event_duration(start: str, end: str) -> Tuple[int, int, int]` that computes the duration of an event given its start and end times. **Input:** * Two strings, `start` and `end`, representing the start and end times of the event in the format \\"HH:MM:SS\\". **Output:** * A tuple of three integers representing the duration of the event as `(hours, minutes, seconds)`. **Constraints:** * The `start` time will always be less than or equal to the `end` time and both times are within the same day. * Times are based on a 24-hour format. **Context:** Imagine you are building a feature for an event management application where users can input the start and end times of their events, and you need to calculate the exact duration of these events for reporting purposes. **Requirements:** 1. Parse the input strings and convert them to appropriate time units. 2. Compute the difference between the `end` and `start` times. 3. Return the result as a tuple `(hours, minutes, seconds)`. **Example Usage:** ```python duration = calculate_event_duration(\\"12:30:15\\", \\"14:45:30\\") print(f\\"Duration: {duration[0]} hours, {duration[1]} minutes, and {duration[2]} seconds\\") ``` Expected output for input `calculate_event_duration(\\"12:30:15\\", \\"14:45:30\\")`: ``` Duration: 2 hours, 15 minutes, and 15 seconds ``` Here’s another example: ```python duration = calculate_event_duration(\\"09:05:00\\", \\"17:30:45\\") print(f\\"Duration: {duration[0]} hours, {duration[1]} minutes, and {duration[2]} seconds\\") ``` Expected output for input `calculate_event_duration(\\"09:05:00\\", \\"17:30:45\\")`: ``` Duration: 8 hours, 25 minutes, and 45 seconds ``` Note: Ensure proper handling of edge cases such as midnight boundaries and ensure the solution performs accurately for all valid inputs within the given constraints.","solution":"from typing import Tuple def calculate_event_duration(start: str, end: str) -> Tuple[int, int, int]: Calculate the duration of an event given the start and end times. :param start: Start time in \\"HH:MM:SS\\" format :param end: End time in \\"HH:MM:SS\\" format :return: Tuple of (hours, minutes, seconds) representing the event duration # Parse the input strings into hours, minutes, and seconds start_h, start_m, start_s = map(int, start.split(\':\')) end_h, end_m, end_s = map(int, end.split(\':\')) # Convert start and end times into total seconds start_total_seconds = start_h * 3600 + start_m * 60 + start_s end_total_seconds = end_h * 3600 + end_m * 60 + end_s # Calculate the difference in total seconds duration_total_seconds = end_total_seconds - start_total_seconds # Convert total seconds back to hours, minutes, and seconds duration_h = duration_total_seconds // 3600 duration_m = (duration_total_seconds % 3600) // 60 duration_s = duration_total_seconds % 60 return (duration_h, duration_m, duration_s)"},{"question":"# Problem Statement Given a list of integers, your goal is to identify the subarray (continuous segment of the list) with the maximum sum. # Objective Implement a function `max_subarray_sum(arr: List[int]) -> int` that: - Receives a list of integers `arr` as an argument. - Returns the maximum sum of any contiguous subarray within `arr`. # Rules & Constraints 1. The input `arr` will be a list of integers. 2. If the input is not a list of integers, raise a `ValueError` with an appropriate message: - For non-list inputs: `\\"the input must be a list of integers\\"` - For lists containing non-integer elements: `\\"all elements in the list must be integers\\"` 3. Your implementation should handle lists of length up to 10,000 efficiently. # Examples ```python >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([0, 0, -1, 0, 5, -1]) 5 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([]) Traceback (most recent call last): ... ValueError: the input list must contain at least one integer >>> max_subarray_sum(\\"string\\") Traceback (most recent call last): ... ValueError: the input must be a list of integers >>> max_subarray_sum([1, 2, 3, \\"A\\"]) Traceback (most recent call last): ... ValueError: all elements in the list must be integers ``` # Notes - You can assume that the list `arr` can contain negative as well as positive integers. - The function should handle edge cases like empty lists, lists containing non-integer elements, etc. - The problem tests your understanding of algorithms, specifically those related to dynamic programming, and efficient handling of contiguous subarray sums.","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the given list. if not isinstance(arr, list): raise ValueError(\\"the input must be a list of integers\\") if not arr: # If the list is empty raise ValueError(\\"the input list must contain at least one integer\\") for element in arr: if not isinstance(element, int): raise ValueError(\\"all elements in the list must be integers\\") # Implementing Kadane\'s Algorithm max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Word Frequency Analysis In text processing, it is often useful to analyze the frequency of words in a given text. This information can help in tasks such as text summarization, keyword extraction, and more. Your task is to implement a function `word_frequency(text: str) -> dict` that calculates the frequency of each word in the input text. The words should be treated as case-insensitive, and the output dictionary should have words in lowercase as keys and their corresponding frequencies as values. # Input * `text` (str): A string of text which may include punctuation, numbers, and whitespace. # Output * Returns a dictionary where keys are lowercase words (str) and values are their frequency (int) in the input text. # Constraints 1. Exclude all punctuation from the words. 2. Treat words case-insensitively. 3. Words can include numbers (alphanumeric). # Examples ```python >>> word_frequency(\\"Hello, world! This is a test. Hello!\\") {\'hello\': 2, \'world\': 1, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 1} >>> word_frequency(\\"Numbers like 123 and 456 are treated as words.\\") {\'numbers\': 1, \'like\': 1, \'123\': 1, \'and\': 1, \'456\': 1, \'are\': 1, \'treated\': 1, \'as\': 1, \'words\': 1} >>> word_frequency(\\"Case insensitive TEST.\\") {\'case\': 1, \'insensitive\': 1, \'test\': 1} >>> word_frequency(\\"E-mail e-mail E-mailing emails.\\") {\'e-mail\': 2, \'e-mailing\': 1, \'emails\': 1} ``` # Additional Information - Use appropriate string methods and regular expressions to remove punctuation and normalize word cases. - Ensure the function efficiently handles large input texts. - Address edge cases such as empty strings and pure punctuation inputs gracefully. --- This new question aligns with the original set by requiring similar levels of analytical thinking and programming skills, while distinguishing itself with a different yet related problem domain within text processing.","solution":"import re from collections import defaultdict def word_frequency(text: str) -> dict: Calculates the frequency of each word in the input text. Words are case-insensitive and stripped of punctuation. Args: text (str): A string of text which may include punctuation, numbers, and whitespace. Returns: dict: A dictionary with words in lowercase as keys and their frequency in the text as values. # Remove punctuation using regex and lower the text text = re.sub(r\'[^ws-]\', \'\', text).lower() # Split the text into words words = text.split() # Use dictionary to count the frequency of each word frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"# Check if a Graph is Bipartite You need to determine if an undirected graph is bipartite, which means the graph can be colored using two colors such that no two adjacent vertices share the same color. **Function Signature:** ```python def is_bipartite(vertices, edges): :param vertices: List[int] - list of vertex identifiers (e.g., [0, 1, 2]). :param edges: List[Tuple[int, int]] - list of edges represented as tuples (v1, v2). :return: bool - True if the graph is bipartite, False otherwise. pass ``` **Specifications:** 1. **Input Format**: - `vertices`: List of `n` integers representing graph vertices. - `edges`: List of `m` tuples (v1, v2) representing `m` edges. 2. **Constraints**: - Vertices are zero-indexed integers. - The graph does not contain self-loops. 3. **Output**: - A boolean value `True` if the graph is bipartite, `False` otherwise. **Example**: ```python vertices = [0, 1, 2, 3] edges = [(0, 1), (1, 2), (2, 3), (3, 0)] print(is_bipartite(vertices, edges)) # Expected Output: False vertices = [0, 1, 2, 3, 4, 5] edges = [(0, 1), (0, 2), (1, 3), (2, 4), (3, 5), (4, 5)] print(is_bipartite(vertices, edges)) # Expected Output: True ``` **Description**: Implement a function to check whether the input graph is bipartite. Use an appropriate graph traversal algorithm to verify if each connected component of the graph can be colored using just two colors without any two adjacent vertices sharing the same color.","solution":"from collections import deque def is_bipartite(vertices, edges): Determines if the given graph is bipartite. :param vertices: List[int] - list of vertex identifiers. :param edges: List[Tuple[int, int]] - list of edges represented as tuples (v1, v2). :return: bool - True if the graph is bipartite, False otherwise. if len(vertices) == 0: return True color = {} graph = {vertex: [] for vertex in vertices} for v1, v2 in edges: graph[v1].append(v2) graph[v2].append(v1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: vertex = queue.popleft() current_color = color[vertex] for neighbor in graph[vertex]: if neighbor not in color: color[neighbor] = 1 - current_color queue.append(neighbor) elif color[neighbor] == current_color: return False return True for vertex in vertices: if vertex not in color: # Check unvisited components if not bfs(vertex): return False return True"},{"question":"# Problem Statement You are tasked with implementing a class that emulates a basic trie (prefix tree) for managing a list of strings. Your implementation should support the following operations: 1. **Insert**: The method, `insert`, should add a new string into the trie. 2. **Search**: The method, `search`, should return `True` if a given string is in the trie, and `False` otherwise. 3. **Starts With**: The method, `starts_with`, should return `True` if there is any string in the trie that starts with the given prefix, and `False` otherwise. Input Format - Multiple queries where the first argument indicates the operation (`insert`, `search`, or `starts_with`), followed by the appropriate string input for the operation. Output Format - For `search` and `starts_with` operations, return `True` or `False`. - For `insert` operation, there is no output. Constraints - The input strings will have a length between 1 and 50 characters. - All input strings will comprise only lowercase English letters. - The total number of operations will not exceed 10^5. Functions to Implement ```python class Trie: def __init__(self): pass def insert(self, word: str) -> None: pass def search(self, word: str) -> bool: pass def starts_with(self, prefix: str) -> bool: pass ``` Example ```python # Initialize the trie trie = Trie() # Insert operation trie.insert(\\"apple\\") # Search operation print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False # Starts With operation print(trie.starts_with(\\"app\\")) # Output: True # Insert another word trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True ``` Note: The exact implementation of the Trie class\'s internal structure is left to your discretion as long as it correctly supports the required operations.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"# Array Rotation Scenario In data processing, it\'s common to perform transformations on arrays for various purposes such as data normalization, visualization, or algorithm optimizations. One transformation that often arises is circular array rotation. Your task is to write a function that takes an array and a rotation count, and then returns the array rotated to the right by the given count. The rotation should be performed cyclically. Function Signature ```python def rotate_array(arr: list, k: int) -> list: pass ``` Input - A list `arr` of integers (0 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9). - An integer `k` (0 ≤ k ≤ 10^5). Output - A list of integers representing the rotated array. Example ```python assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] # Rotating right by 2 positions assert rotate_array([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] # Rotating by the array length doesn\'t change the array assert rotate_array([1, 2, 3, 4, 5], 7) == [4, 5, 1, 2, 3] # Rotating by 7 is the same as rotating by 2 due to cyclic nature assert rotate_array([], 3) == [] # An empty array remains unchanged assert rotate_array([10, 20], 0) == [10, 20] # Rotation by 0 leaves the array unchanged ``` Constraints - You may assume that the input will always be a valid list of integers and a non-negative integer as the rotation count. - Aim to achieve an efficient solution that handles the upper limits of the input size. Guidelines - Consider the cyclic property of array rotation which implies rotation by `k` is equivalent to rotation by `k % len(arr)`. - Utilize slicing or list manipulation techniques to revamp the array efficiently. - Ensure the function handles edge cases appropriately, such as empty arrays or rotations equal to zero.","solution":"def rotate_array(arr: list, k: int) -> list: Rotates the array to the right by k positions. if not arr: return arr n = len(arr) k = k % n # Normalize k to avoid unnecessary full rotations # Split the array into two parts and reverse the order return arr[-k:] + arr[:-k]"},{"question":"# Fibonacci Series: Dynamic Programming Approach Context You are working on a mathematical software that requires efficient computation of Fibonacci series values. Building both recursive and iterative implementations is straightforward but may not be efficient for very large inputs due to redundant calculations. Instead, use dynamic programming to solve the problem more efficiently. Task Implement a function `fibonacci(n: int) -> int` that calculates the nth Fibonacci number using a dynamic programming approach. The 0th Fibonacci number is defined as 0, and the 1st Fibonacci number is defined as 1. Input * `n`: An integer representing the position in the Fibonacci sequence you wish to calculate. Output * The nth Fibonacci number as an integer. Constraints * `0 <= n <= 10^5` * Ensure the solution efficiently handles large inputs and optimizes memory usage as much as possible. Function Signature ```python def fibonacci(n: int) -> int: pass ``` Example Scenarios 1. nth Fibonacci number for small input: * Input: `(5)` * Output: `5` 2. nth Fibonacci number for zero: * Input: `(0)` * Output: `0` 3. nth Fibonacci number for a large input: * Input: `(30)` * Output: `832040` Write the code to fulfill these requirements using dynamic programming techniques. Ensure your function is optimized for performance and handles a wide range of input values efficiently.","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 # Initialize the base cases prev1, prev2 = 0, 1 # Compute subsequent Fibonacci numbers for _ in range(2, n + 1): curr = prev1 + prev2 prev1, prev2 = prev2, curr return prev2"},{"question":"# Coding Task: Enhanced GCD and LCM Calculator **Objective**: Develop an advanced version of the Euclidean algorithm to calculate the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of two given integers. Additionally, implement a function to calculate the GCD and LCM of a list of integers. Functions to Implement: 1. **`find_gcd(a: int, b: int) -> int`**: - **Input**: - `a` (Integer): The first integer. - `b` (Integer): The second integer. - **Output**: - Returns the GCD of the two integers (Integer). - **Constraints**: - Both `a` and `b` must be integers. - Raise `ValueError` if either `a` or `b` is less than or equal to zero. - Raise `TypeError` if either `a` or `b` is not an integer. 2. **`find_lcm(a: int, b: int) -> int`**: - **Input**: - `a` (Integer): The first integer. - `b` (Integer): The second integer. - **Output**: - Returns the LCM of the two integers (Integer). - **Constraints**: - Both `a` and `b` must be integers. - Raise `ValueError` if either `a` or `b` is less than or equal to zero. - Raise `TypeError` if either `a` or `b` is not an integer. 3. **`gcd_list(numbers: list) -> int`**: - **Input**: - `numbers` (List of Integers): A list of integers for which to calculate the GCD. - **Output**: - Returns the GCD of the list of integers (Integer). - **Constraints**: - The list must contain at least two integers. - Raise `ValueError` if the list contains less than two integers or any integer is less than or equal to zero. - Raise `TypeError` if the list or any of its elements are not integers. 4. **`lcm_list(numbers: list) -> int`**: - **Input**: - `numbers` (List of Integers): A list of integers for which to calculate the LCM. - **Output**: - Returns the LCM of the list of integers (Integer). - **Constraints**: - The list must contain at least two integers. - Raise `ValueError` if the list contains less than two integers or any integer is less than or equal to zero. - Raise `TypeError` if the list or any of its elements are not integers. **Example Usages**: ```python assert find_gcd(54, 24) == 6 assert find_lcm(54, 24) == 216 assert gcd_list([54, 24, 36]) == 6 assert lcm_list([54, 24, 36]) == 216 ``` **Notes**: - Ensure that your code is efficient and can handle large integers. - Provide appropriate documentation and doctests for each function. - Optimize your implementation for both time and space complexity where possible. - Remember that GCD(a, b) * LCM(a, b) = |a * b| for any two integers a and b. This can help in calculating one from the other efficiently.","solution":"def find_gcd(a, b): Returns the GCD of two integers a and b. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both a and b must be integers.\\") if a <= 0 or b <= 0: raise ValueError(\\"Both a and b must be greater than zero.\\") while b: a, b = b, a % b return a def find_lcm(a, b): Returns the LCM of two integers a and b. if not isinstance(a, int) or not isinstance(b, int): raise TypeError(\\"Both a and b must be integers.\\") if a <= 0 or b <= 0: raise ValueError(\\"Both a and b must be greater than zero.\\") gcd = find_gcd(a, b) return abs(a * b) // gcd def gcd_list(numbers): Returns the GCD of a list of integers. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"All elements of the list must be integers.\\") if len(numbers) < 2: raise ValueError(\\"List must contain at least two integers.\\") if any(num <= 0 for num in numbers): raise ValueError(\\"All numbers in the list must be greater than zero.\\") from functools import reduce return reduce(find_gcd, numbers) def lcm_list(numbers): Returns the LCM of a list of integers. if not all(isinstance(num, int) for num in numbers): raise TypeError(\\"All elements of the list must be integers.\\") if len(numbers) < 2: raise ValueError(\\"List must contain at least two integers.\\") if any(num <= 0 for num in numbers): raise ValueError(\\"All numbers in the list must be greater than zero.\\") from functools import reduce return reduce(find_lcm, numbers)"},{"question":"# Graph Traversal: Shortest Path Calculation Problem Statement: You are given a directed, weighted graph represented as an adjacency list. Your task is to implement the Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in the graph. Function Specifications: 1. **`dijkstra(graph: Dict[Any, List[Tuple[Any, int]]], source: Any) -> Dict[Any, int]`**: - **Input**: - `graph`: A dictionary where the keys are the vertices of the graph, and the values are lists of tuples. Each tuple consists of a destination vertex and the weight of the edge leading to that vertex. - `source`: The starting vertex for calculating the shortest paths. - **Output**: - A dictionary where the keys are the vertices of the graph, and the values are the minimum distances from the `source` vertex to each vertex. Constraints: - The graph will not contain negative weight edges. - The graph is connected, and each vertex is reachable from the `source`. - Vertices can be represented by any hashable type, such as integers or strings. Example Usage: ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } source = \'A\' # Expected output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} shortest_paths = dijkstra(graph, source) ``` Implementation Details: - Initialize the distance to the source vertex as 0 and to all other vertices as infinity. - Use a priority queue to explore the vertices with the smallest known distances first. - For each vertex, update the distances to its neighbors if a shorter path is found. - Return the dictionary containing the shortest paths from the source vertex to all other vertices.","solution":"import heapq def dijkstra(graph, source): Implements Dijkstra\'s algorithm to find the shortest path from the source vertex to all other vertices in a weighted directed graph. :param graph: Dict representing the adjacency list of the graph :param source: The starting vertex for calculating the shortest paths :return: Dict with the shortest distance from source to each vertex # Initial distances are infinity distances = {vertex: float(\'infinity\') for vertex in graph} distances[source] = 0 # The distance to the source is 0 priority_queue = [(0, source)] # Priority queue to hold vertices to explore while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # Nodes can get added to the priority queue multiple times, we only process the first time we remove it if current_distance > distances[current_vertex]: continue # Examine and update the distances to each neighbor of the current vertex for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s shorter if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question **Scenario**: Developing user-friendly functionalities for a library management system is critical. One such functionality is the ability to find books based on part or full title searches, returning relevant information such as the author, publication year, and availability status. **Task**: Implement a class `Library` that includes methods to add books to the library and search for books by title. Each book should have a title, author\'s name, publication year, and availability status (True if available, False if checked out). **Class Definition**: ```python class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year: int, available: bool): Adds a new book to the library. Args: title (str): The title of the book. author (str): The author\'s name. year (int): Publication year of the book. available (bool): Availability status of the book. def search_books(self, query: str) -> list: Searches for books containing the query string in their titles. Args: query (str): The search query (substring to search in the book titles). Returns: list: List of dictionaries with book details (title, author, year, availability). ``` **Example**: ```python library = Library() library.add_book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 1925, True) library.add_book(\\"Great Expectations\\", \\"Charles Dickens\\", 1861, False) library.add_book(\\"The Grapes of Wrath\\", \\"John Steinbeck\\", 1939, True) results = library.search_books(\\"Great\\") for book in results: print(f\\"Title: {book[\'title\']}, Author: {book[\'author\']}, Year: {book[\'year\']}, Available: {book[\'available\']}\\") ``` **Expected Output**: ```python Title: The Great Gatsby, Author: F. Scott Fitzgerald, Year: 1925, Available: True Title: Great Expectations, Author: Charles Dickens, Year: 1861, Available: False ``` **Constraints**: 1. The `add_book` method should ensure no duplicate titles exist in the library. 2. The `search_books` method should be case-insensitive. 3. The library can store up to 1000 books. 4. Ensure efficient searching and adding operations considering a large number of books. **Additional Notes**: - Ensure proper error handling and input validation. - Comment your code appropriately for readability.","solution":"class Library: def __init__(self): self.books = [] def add_book(self, title: str, author: str, year: int, available: bool): Adds a new book to the library. Args: title (str): The title of the book. author (str): The author\'s name. year (int): Publication year of the book. available (bool): Availability status of the book. # Ensure no duplicate titles exist if any(book[\'title\'].lower() == title.lower() for book in self.books): raise ValueError(\\"A book with this title already exists.\\") # Add the book to the library self.books.append({ \'title\': title, \'author\': author, \'year\': year, \'available\': available }) def search_books(self, query: str) -> list: Searches for books containing the query string in their titles. Args: query (str): The search query (substring to search in the book titles). Returns: list: List of dictionaries with book details (title, author, year, availability). query_lower = query.lower() return [ book for book in self.books if query_lower in book[\'title\'].lower() ]"},{"question":"# Resource Allocation Optimization **Context**: You are responsible for managing the resource allocation in a large-scale distributed system. The system processes a list of tasks, each with a specific execution time. Your objective is to distribute these tasks across available servers to minimize the maximum time any single server takes to complete its assigned tasks. **Objective**: Write a function that allocates tasks to servers in a way that minimizes the makespan, i.e., the maximum time taken by any server. **Function Signature**: ```python def minimize_makespan(tasks, servers): pass ``` **Input and Output Format**: * **Input**: * `tasks`: A list of integers where each integer represents the execution time of a task. * `servers`: An integer representing the number of available servers. * **Output**: Return an integer representing the minimized maximum execution time for the most loaded server. **Constraints**: * `1 <= len(tasks) <= 10^4` * `1 <= servers <= 100` * `1 <= task execution time <= 10^6` # Example **Example 1**: ```python tasks = [10, 7, 8, 12, 6, 8] servers = 3 print(minimize_makespan(tasks, servers)) # Output: 18 ``` * **Explanation**: The tasks can be distributed as: * Server 1: [10, 8] with total time 18 * Server 2: [7, 8] with total time 15 * Server 3: [12, 6] with total time 18 * The maximum time taken by any server is 18. **Example 2**: ```python tasks = [10, 20, 30] servers = 2 print(minimize_makespan(tasks, servers)) # Output: 30 ``` * **Explanation**: The tasks can be distributed as: * Server 1: [10, 20] with total time 30 * Server 2: [30] with total time 30 * The maximum time taken by any server is 30. # Performance Requirements * The solution should be efficient, preferably with a time complexity of `O(n log m)`, where `n` is the number of tasks and `m` is the number of servers. * Consider edge cases, such as when the number of servers is greater than the number of tasks, or when all tasks have the same execution time. **Notes**: Utilize algorithms such as Binary Search in combination with Greedy methods to achieve an optimal solution efficiently. Consider various allocation strategies to find the most balanced distribution of tasks.","solution":"def minimize_makespan(tasks, servers): def can_distribute_with_max_load(max_load): # Array to keep track of load on each server server_loads = [0] * servers for task in sorted(tasks, reverse=True): # Find the server with the least load that can take the current task if server_loads[0] + task > max_load: return False # Add the task to this server server_loads[0] += task # Re-sort the server loads to maintain the min-heap property server_loads.sort() return True # Binary search for the minimum possible max_load low, high = max(tasks), sum(tasks) while low < high: mid = (low + high) // 2 if can_distribute_with_max_load(mid): high = mid else: low = mid + 1 return low"},{"question":"Problem Statement You are given a list of non-negative integers where each integer represents a point in a Cartesian plane where the x-coordinate is the index of the integer and the y-coordinate is the value at that index. Your task is to implement a function that finds the maximum area of a rectangle formed by two indices in the list and the x-axis. # Function Signature ```python def max_area(heights: List[int]) -> int: pass ``` # Input 1. `heights` (1 <= len(heights) <= 10**5): A list of non-negative integers where each integer represents the height of a point on the Cartesian plane. # Output Return a single integer which is the maximum area of the rectangle formed by any two points and the x-axis. # Examples ```python max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) # Output: 49 max_area([1, 1]) # Output: 1 max_area([4, 3, 2, 1, 4]) # Output: 16 max_area([1, 2, 1]) # Output: 2 max_area([1, 0, 0, 0, 1]) # Output: 4 max_area([2, 3, 4, 5, 18, 17, 6]) # Output: 17 ``` # Constraints - The function must operate within a time complexity of O(n) and space complexity of O(1). - You are not allowed to use brute force solutions that have a time complexity greater than O(n). # Notes - Ensure to handle edge cases such as when all elements in the list are zeros except for one non-zero element. - Think about using an optimal approach such as two pointers technique to achieve the required time complexity.","solution":"from typing import List def max_area(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of points on the Cartesian plane, finds the maximum area of a rectangle formed by two points and the x-axis. left, right = 0, len(heights) - 1 max_area_res = 0 while left < right: # Calculate the width of the rectangle width = right - left # Calculate the height of the rectangle current_height = min(heights[left], heights[right]) # Calculate the area current_area = width * current_height # Update max_area_res if the current_area is larger if current_area > max_area_res: max_area_res = current_area # Move the pointers if heights[left] < heights[right]: left += 1 else: right -= 1 return max_area_res"},{"question":"# Problem Statement Alex is learning about palindromic numbers and their interesting properties. A palindromic number is a number that remains the same when its digits are reversed. Alex wants to find the smallest palindromic number that is greater than a given integer `x`. Your task is to implement a function `next_palindrome(x: int) -> int` that returns the smallest palindromic number greater than `x`. Input: * `x` (1 <= x <= 10^6): An integer for which we need to find the next palindromic number. Output: * Returns an integer representing the smallest palindromic number greater than `x`. Example: * `next_palindrome(123)` should return `131`. * `next_palindrome(808)` should return `818`. * `next_palindrome(999)` should return `1001`. Constraints: * Ensure that the function handles edge cases such as very small or very large values of `x`. * Aim for optimal performance, considering the range of possible values. Notes: * Consider including helper functions to determine if a number is palindromic and to incrementally check larger numbers until the next palindromic one is found. * Comment on your approach and any potential optimizations.","solution":"def is_palindromic(num): Helper function to check if a number is palindromic. str_num = str(num) return str_num == str_num[::-1] def next_palindrome(x): Returns the smallest palindromic number greater than x. x += 1 # Start checking from the next number while not is_palindromic(x): x += 1 return x"},{"question":"# Problem Scenario You are developing a system that processes student scores for a class. The system needs to determine the highest and lowest scores achieved by students, as well as compute the average score of the class. Write a function `analyze_scores` to compute these values based on the following input parameters: - `scores`: A list of integers representing the scores of the students. The function should return a tuple containing three values: - The highest score in the list. - The lowest score in the list. - The average score of the list rounded to two decimal places. Function Signature ```python def analyze_scores(scores: List[int]) -> Tuple[int, int, float]: ``` Input - `scores` (List[int]): A list of scores (1 ≤ `len(scores)` ≤ 10^5) where each score is an integer between 0 and 100 inclusive. Output - Returns a tuple containing three values: - The highest score (int). - The lowest score (int). - The average score (float) rounded to two decimal places. Constraints - The list `scores` will contain at least one score. Examples ```python >>> analyze_scores([85, 90, 78, 92, 88, 76]) (92, 76, 84.83) >>> analyze_scores([50, 50, 50, 50]) (50, 50, 50.00) >>> analyze_scores([95]) (95, 95, 95.00) ```","solution":"from typing import List, Tuple def analyze_scores(scores: List[int]) -> Tuple[int, int, float]: Analyzes the scores of students and returns the highest, lowest, and average score. Args: scores (List[int]): A list of integers representing the scores of students. Returns: Tuple[int, int, float]: A tuple containing the highest score, lowest score, and the average score rounded to two decimal places. highest_score = max(scores) lowest_score = min(scores) average_score = round(sum(scores) / len(scores), 2) return highest_score, lowest_score, average_score"},{"question":"# File Type Filter **Problem Statement:** Write a function `filter_files` that filters a list of filenames based on a given file extension or pattern. The function should return a list of filenames that match the provided extension or pattern. If no filenames match the given extension or pattern, the function should return an empty list. The function should also handle cases where an invalid extension or pattern is provided by raising a `ValueError` with an appropriate error message. **Function Signature:** ```python def filter_files(filenames: list[str], pattern: str) -> list[str]: pass ``` **Input:** - `filenames` (list of str): A list of filenames to be filtered. - `pattern` (str): The file extension or pattern to filter the filenames. This can include wildcard characters \'*\' and \'?\'. **Output:** - (list of str): A list of filenames that match the given extension or pattern. **Constraints:** - Each filename in the input list will be a string containing the full filename with its extension. - The pattern string can either be a simple extension like `.txt` or a pattern with wildcard characters. - The pattern string is not guaranteed to be a valid pattern, and invalid patterns should raise a `ValueError`. **Examples:** ```python >>> filter_files([\\"report.pdf\\", \\"summary.docx\\", \\"data.csv\\", \\"presentation.pptx\\"], \\"*.pdf\\") [\\"report.pdf\\"] >>> filter_files([\\"report.pdf\\", \\"summary.docx\\", \\"data.csv\\", \\"presentation.pptx\\"], \\"*.docx\\") [\\"summary.docx\\"] >>> filter_files([\\"report.pdf\\", \\"summary.docx\\", \\"data.csv\\", \\"presentation.pptx\\"], \\"*.xlsx\\") [] >>> filter_files([\\"note.txt\\", \\"diary.txt\\", \\"log.txt\\", \\"script.py\\"], \\"*.txt\\") [\\"note.txt\\", \\"diary.txt\\", \\"log.txt\\"] >>> filter_files([\\"note.txt\\", \\"diary.txt\\", \\"log.txt\\", \\"script.py\\"], \\"*.py\\") [\\"script.py\\"] >>> filter_files([\\"image.jpeg\\", \\"photo.png\\", \\"graphic.jpg\\", \\"illustration.gif\\"], \\"*.bmp\\") [] >>> filter_files([\\"a.jpg\\", \\"b.jpg\\", \\"c.gif\\", \\"d.png\\", \\"e.jpg\\"], \\"*.jpg\\") [\\"a.jpg\\", \\"b.jpg\\", \\"e.jpg\\"] >>> filter_files([\\"report.pdf\\", \\"summary.docx\\", \\"data.csv\\", \\"presentation.pptx\\"], \\"*.pdfx\\") ValueError: Invalid pattern: Supported wildcards are \'*\' and \'?\' ``` **Technical Notes:** 1. Utilize the `fnmatch` module for pattern matching. 2. Ensure to raise a `ValueError` for invalid pattern strings with a descriptive error message. 3. Return the filenames that match the pattern or an empty list if no matches are found.","solution":"import fnmatch def filter_files(filenames, pattern): Filters a list of filenames based on a given file extension or pattern. Args: filenames (list of str): A list of filenames to be filtered. pattern (str): The file extension or pattern to filter the filenames, including wildcard characters \'*\' and \'?\'. Returns: list of str: A list of filenames that match the given extension or pattern. Raises: ValueError: If the pattern contains invalid characters other than \'*\' and \'?\'. # Check for invalid characters in the pattern if any(char not in \'*?.\' and not char.isalnum() for char in pattern): raise ValueError(\\"Invalid pattern: Supported wildcards are \'*\' and \'?\'\\") # Filter the filenames using the pattern filtered_files = fnmatch.filter(filenames, pattern) return filtered_files"},{"question":"# Coding Question: Unique Character Count **Context**: You\'re developing a feature for a text analysis tool that needs to determine the diversity of characters in a string. This feature will provide insights by counting how many unique characters are present in a given input string. **Task**: Write a function that takes a string as input and returns the count of unique characters in that string. **Input**: * A single string `text` where `|text| <= 100000`. **Output**: * An integer representing the number of unique characters in the given string. **Constraints**: * The function should be case-sensitive, meaning \'A\' and \'a\' are considered different characters. * You should aim for an O(n) time complexity where `n` is the length of the input string. * Use appropriate data structures to ensure efficient look-up and insertion operations. **Specification**: Function Signature: `def count_unique_characters(text: str) -> int:` **Example**: ```python >>> count_unique_characters(\\"hello\\") 4 >>> count_unique_characters(\\"world\\") 5 >>> count_unique_characters(\\"aabbc\\") 3 >>> count_unique_characters(\\"123321\\") 3 >>> count_unique_characters(\\"\\") 0 ```","solution":"def count_unique_characters(text: str) -> int: Returns the count of unique characters in the given string. Parameters: text (str): The input string. Returns: int: The number of unique characters in the string. unique_characters = set(text) return len(unique_characters)"},{"question":"Matrix Region Sum Query You are given a 2D integer matrix and a list of queries. Each query contains the indices of two diagonal corners of a rectangular submatrix and your task is to compute the sum of all elements contained within each submatrix. The matrix and queries are zero-indexed. Function Signature ```python def matrix_region_sum(matrix: list[list[int]], queries: list[tuple[int, int, int, int]]) -> list[int]: pass ``` Input - **matrix**: A 2D list of integers representing the matrix. - **queries**: A list of tuples, each containing four integers `(r1, c1, r2, c2)` representing the coordinates of the top-left `(r1, c1)` and bottom-right `(r2, c2)` corners of the submatrix. Output - **A list of integers**: Each integer represents the sum of the submatrix for the corresponding query. Constraints - The matrix dimensions will not exceed 1000 x 1000. - Each element in the matrix is an integer between -1000 and 1000. - Each query has valid indices, meaning `0 <= r1 <= r2 < number of rows` and `0 <= c1 <= c2 < number of columns`. Example ```python matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] queries = [ (2, 1, 4, 3), (1, 1, 2, 2), (1, 2, 2, 4) ] result = matrix_region_sum(matrix, queries) # Expected output: [8, 11, 12] # Explanation: # For (2, 1, 4, 3): sum of submatrix = 2 + 0 + 1 + 1 + 0 + 3 + 0 + 0 = 8 # For (1, 1, 2, 2): sum of submatrix = 6 + 3 + 2 + 0 = 11 # For (1, 2, 2, 4): sum of submatrix = 3 + 2 + 1 + 2 + 0 + 1 + 5 = 12 ``` # Additional Notes * Implement an efficient solution to handle multiple queries efficiently. * You may use prefix sums or other preprocessing techniques to optimize query response time. * Ensure your solution is clear and well-documented. --- This question is designed to test the candidate\'s ability to work with 2D arrays, implement efficient algorithms, and handle multiple queries. By providing a clear problem statement with constraints and examples, it ensures the candidate\'s solution is both correct and efficient.","solution":"def matrix_region_sum(matrix: list[list[int]], queries: list[tuple[int, int, int, int]]) -> list[int]: Computes the sum of the elements inside the specified submatrix for each query. Args: matrix (list[list[int]]): 2D list of integers representing the matrix. queries (list[tuple[int, int, int, int]]): List of tuples, each containing four integers (r1, c1, r2, c2). Returns: list[int]: List of sums for each query. if not matrix or not matrix[0]: return [] rows, cols = len(matrix), len(matrix[0]) # Create prefix sum matrix prefix_sum = [[0] * (cols + 1) for _ in range(rows + 1)] # Fill prefix sum matrix for r in range(1, rows + 1): for c in range(1, cols + 1): prefix_sum[r][c] = (matrix[r - 1][c - 1] + prefix_sum[r - 1][c] + prefix_sum[r][c - 1] - prefix_sum[r - 1][c - 1]) result = [] # Process each query for r1, c1, r2, c2 in queries: total = (prefix_sum[r2 + 1][c2 + 1] - prefix_sum[r1][c2 + 1] - prefix_sum[r2 + 1][c1] + prefix_sum[r1][c1]) result.append(total) return result"},{"question":"# Task: Implement a Singleton Logger Develop a Python class `Logger` that supports the following operations and ensures only one instance of the logger exists at any time: 1. `log(message)`: Logs the provided message with a unique identifier. 2. `get_logs()`: Retrieves all logged messages in the order they were logged. # Class Interface ```python class Logger: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super(Logger, cls).__new__(cls) cls._instance._log_counter = 0 cls._instance._logs = [] return cls._instance def log(self, message: str) -> None: Logs the provided message with a unique identifier. pass def get_logs(self) -> list: Retrieves all logged messages in the order they were logged. pass ``` # Constraints * The logger should handle any reasonable number of log messages. # Example ```python # Testing the Logger class logger1 = Logger() logger2 = Logger() # Ensuring both loggers are the same instance assert logger1 is logger2 # Logging messages logger1.log(\\"First message\\") logger2.log(\\"Second message\\") # Retrieving logged messages logs = logger1.get_logs() assert logs == [ \\"1: First message\\", \\"2: Second message\\" ] ``` In this example, the `Logger` class uses the Singleton pattern to ensure that only a single instance of the logger exists. The `log` method adds a new log message with a unique identifier, and `get_logs` retrieves all logged messages in the order they were logged.","solution":"class Logger: _instance = None def __new__(cls): if cls._instance is None: cls._instance = super(Logger, cls).__new__(cls) cls._instance._log_counter = 0 cls._instance._logs = [] return cls._instance def log(self, message: str) -> None: self._log_counter += 1 log_message = f\\"{self._log_counter}: {message}\\" self._logs.append(log_message) def get_logs(self) -> list: return self._logs"},{"question":"# Problem Statement You need to write a Python function that determines the minimum number of steps required to reduce a given integer `M` to 1. You can perform the following operations: 1. If `M` is divisible by 2, divide it by 2. 2. If `M` is divisible by 3, divide it by 3. 3. Subtract 1 from `M`. # Function Signature Your task is to implement the following function: ```python def min_steps_to_one(M: int) -> int: This function returns the minimum number of steps required to reduce the integer M to 1. :param M: The integer to be reduced to 1 :type M: int :return: The minimum number of steps required :rtype: int :raises ValueError: If M is less than 1. Example: >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 pass ``` # Input * A single integer `M` representing the starting number (where 1 <= M <= 1000). # Output * An integer representing the minimum number of steps required to reduce `M` to 1. # Constraints * The input `M` will always be a positive integer up to 1000. # Example ```python >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 >>> min_steps_to_one(1) 0 ``` # Additional Information * To solve this problem efficiently, consider using a dynamic programming approach where you maintain an array `dp` where `dp[i]` denotes the minimum number of steps to reduce `i` to 1. * Initialize `dp[1]` to 0 since no steps are needed to reduce 1 to 1. * For every integer from 2 to `M`, determine the minimum steps by considering the aforementioned operations.","solution":"def min_steps_to_one(M: int) -> int: if M < 1: raise ValueError(\\"M must be a positive integer.\\") # Array to store the minimum steps required for each number dp = [0] * (M + 1) # Initialize dp[1] to 0 because we need 0 steps to reduce 1 to 1 dp[1] = 0 # Fill the dp array for all numbers from 2 to M for i in range(2, M + 1): # Start with the step for subtracting 1 steps = dp[i - 1] + 1 # If divisible by 2, consider the minimum steps from dp[i // 2] if i % 2 == 0: steps = min(steps, dp[i // 2] + 1) # If divisible by 3, consider the minimum steps from dp[i // 3] if i % 3 == 0: steps = min(steps, dp[i // 3] + 1) # Store the minimum steps found for dp[i] dp[i] = steps # Return the minimum steps required for M return dp[M]"},{"question":"# Understanding Nested Dictionary Data Retrieval **Context**: You are provided with a nested dictionary structure that contains various levels of information. Your task is to write a function that searches for a given key within this nested structure and returns all occurrences of that key along with their corresponding values. **Function Specification**: Write a function `find_nested_key(data: dict, key: str) -> list` that takes in a nested dictionary `data` and a string `key`, and returns a list of all values associated with the given key found anywhere within the nested data structure. **Input**: - A dictionary `data` where values can be either more dictionaries, lists of dictionaries, or simple data types. - A string `key` representing the key to search for within the dictionary. **Output**: - A list containing all values associated with the given key throughout the structure. If the key is not found, the list should be empty. **Constraints**: - The function should be able to handle dictionaries nested within lists, and lists nested within dictionaries to any depth. - Keys may or may not be unique within the dictionary. **Example**: Consider the nested dictionary: ```python data = { \\"level1\\": { \\"level2\\": { \\"target_key\\": \\"value1\\", \\"another_key\\": { \\"target_key\\": \\"value2\\" } }, \\"target_key\\": \\"value3\\", \\"list_of_dicts\\": [ {\\"target_key\\": \\"value4\\"}, {\\"key_not_target\\": \\"value5\\"} ] } } ``` Calling `find_nested_key(data, \\"target_key\\")` should return: ```python [\\"value1\\", \\"value2\\", \\"value3\\", \\"value4\\"] ``` **Sample Input and Output**: ```python data1 = { \\"a\\": { \\"b\\": {\\"key_to_find\\": 1}, \\"c\\": [{\\"key_to_find\\": 2}, {\\"d\\": \\"test\\"}], \\"key_to_find\\": 3 } } assert find_nested_key(data1, \\"key_to_find\\") == [1, 2, 3] data2 = { \\"x\\": {\\"y\\": {\\"z\\": {\\"key_to_find\\": \\"found\\"}}}, \\"key_to_find\\": \\"top_level\\" } assert find_nested_key(data2, \\"key_to_find\\") == [\\"found\\", \\"top_level\\"] data3 = {\\"no_key\\": {\\"another_no_key\\": \\"value\\"}} assert find_nested_key(data3, \\"missing_key\\") == [] ```","solution":"def find_nested_key(data, key): Recursively searches for a given key in a nested dictionary and returns all values associated with that key. :param data: The nested dictionary to search. :param key: The key to search for. :return: A list of values associated with the given key. values = [] if isinstance(data, dict): for k, v in data.items(): if k == key: values.append(v) if isinstance(v, (dict, list)): values.extend(find_nested_key(v, key)) elif isinstance(data, list): for item in data: if isinstance(item, (dict, list)): values.extend(find_nested_key(item, key)) return values"},{"question":"# Coding Assessment Question: Least Frequently Used (LFU) Cache Implementation **Objective**: Your task is to implement a data structure that models a Least Frequently Used (LFU) cache, supporting the `get` and `put` operations. # Problem Statement You need to implement an `LFUCache` class with the following methods: 1. `__init__(self, capacity: int)`: Initializes the LFU Cache with the given capacity. 2. `get(self, key: int) -> int`: Returns the value of the `key` if the `key` exists in the cache. Otherwise, returns `-1`. 3. `put(self, key: int, value: int) -> None`: Updates the value of the `key` if the `key` exists. Otherwise, adds the `key-value` pair to the cache. If the cache reaches its capacity, it should invalidate and remove the least frequently used item before inserting a new item. In case of a tie, the least recently used key should be removed. # Input * The initialization parameter `capacity` is an integer representing the maximum number of items the cache can hold. * The `put` method receives two integers, `key` and `value`. * The `get` method receives one integer, `key`. # Output * The `get` method returns the value associated with the provided key, or `-1` if the key is not found. # Constraints 1. 0 ≤ `capacity` ≤ 10^4 2. 0 ≤ `key`, `value` ≤ 10^5 3. The `get` and `put` methods should operate in O(1) average time complexity. # Examples 1. ```python lfu = LFUCache(2) lfu.put(1, 1) # cache is {1=1} lfu.put(2, 2) # cache is {1=1, 2=2} assert lfu.get(1) == 1 # return 1 lfu.put(3, 3) # evicts key 2, cache is {1=1, 3=3} assert lfu.get(2) == -1 # return -1 assert lfu.get(3) == 3 # return 3 lfu.put(4, 4) # evicts key 1, cache is {4=4, 3=3} assert lfu.get(1) == -1 # return -1 assert lfu.get(3) == 3 # return 3 assert lfu.get(4) == 4 # return 4 ``` 2. ```python lfu = LFUCache(1) lfu.put(2, 2) # cache is {2=2} assert lfu.get(2) == 2 # return 2 lfu.put(3, 3) # evicts key 2, cache is {3=3} assert lfu.get(2) == -1 # return -1 assert lfu.get(3) == 3 # return 3 ``` # Class Signature ```python class LFUCache: def __init__(self, capacity: int): # Your initialization code here def get(self, key: int) -> int: # Your get method code here def put(self, key: int, value: int) -> None: # Your put method code here ``` # Additional Notes * Use appropriate data structures to ensure the efficient retrieval and update of both frequency and recency. * Consider edge cases such as initializing with a capacity of 0 or attempting to get a key that was never added. # Guidance To implement the LFU Cache, utilize a combination of hash maps and double-linked lists. Maintain counts of key access frequencies and utilize ordering to manage ties based on recency.","solution":"import collections class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.min_freq = 0 self.cache = {} self.freq_map = collections.defaultdict(collections.OrderedDict) def _update(self, key: int, value: int = None): freq = self.cache[key][1] if value is not None: self.cache[key][0] = value del self.freq_map[freq][key] if not self.freq_map[freq]: del self.freq_map[freq] if freq == self.min_freq: self.min_freq += 1 self.cache[key][1] += 1 freq = self.cache[key][1] self.freq_map[freq][key] = None def get(self, key: int) -> int: if key not in self.cache: return -1 self._update(key) return self.cache[key][0] def put(self, key: int, value: int) -> None: if self.capacity == 0: return if key in self.cache: self._update(key, value) return if len(self.cache) == self.capacity: k, _ = self.freq_map[self.min_freq].popitem(last=False) del self.cache[k] self.cache[key] = [value, 1] self.freq_map[1][key] = None self.min_freq = 1"},{"question":"# Problem Statement Objective Implement a function in language L that, given a sorted array of integers and a target integer, returns the index of the target if it exists in the array and -1 if it does not. Motivation This task tests your understanding of binary search algorithm, an efficient way to locate a target value within a sorted array. # Requirements 1. **Function Signature** ``` (language L) function binary_search(sorted_array: List[int], target: int) -> int ``` 2. **Input**: - `sorted_array` (a list of integers) where n is the number of elements (0 ≤ n ≤ 10^4). - `target` (an integer) which is the target element to search for in `sorted_array`. 3. **Output**: - An integer that is the index of the target in `sorted_array` if present. - Return -1 if the target is not in `sorted_array`. # Constraints - You must implement a binary search algorithm. - The input array will always be sorted in non-decreasing order. - The search should be completed in O(log n) time complexity. # Performance - Ensure your implementation runs efficiently for input sizes up to the constraint limit. - Consider edge cases like empty arrays and single-element arrays. # Specification Example If you were to solve this in Python, a valid function might resemble: ```python def binary_search(sorted_array, target): left, right = 0, len(sorted_array) - 1 while left <= right: mid = (left + right) // 2 if sorted_array[mid] == target: return mid elif sorted_array[mid] < target: left = mid + 1 else: right = mid - 1 return -1 ``` **Examples:** 1. Given `sorted_array = [1, 2, 3, 4, 5]` and `target = 3`, the output should be `2`. 2. Given `sorted_array = [1, 2, 3, 4, 5]` and `target = 6`, the output should be `-1`. Notes - You can assume there will be no duplicate elements in the array. - Test the function thoroughly with edge cases such as an empty array and target values at the bounds of the array. - Pay attention to the integer division and boundary conditions in the binary search implementation. This question tests your ability to implement a classic algorithm that is crucial in many real-world applications, ensuring you can apply efficient problem-solving techniques in your coding tasks.","solution":"def binary_search(sorted_array, target): Performs binary search on the sorted array to find the index of the target value. Parameters: sorted_array (list): A list of sorted integers. target (int): The target integer to search for in the array. Returns: int: The index of the target if found, otherwise -1. left, right = 0, len(sorted_array) - 1 while left <= right: mid = (left + right) // 2 if sorted_array[mid] == target: return mid elif sorted_array[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario You are developing software for a home automation system that includes various sensors and devices. One of the tasks is to monitor temperature readings from a sensor and determine if the readings are within a comfortable range. The comfortable temperature range is defined to be between a minimum and maximum threshold (inclusive). If any temperature reading falls outside this range, an alert should be generated. # Task Write a function: 1. **check_temperature_readings** - **Input**: * `readings` (list of float): the list of temperature readings in Celsius. * `min_threshold` (float): the minimum comfortable temperature in Celsius. * `max_threshold` (float): the maximum comfortable temperature in Celsius. - **Output**: * Returns a list of indices where the temperature readings fall outside the comfortable range. - **Constraints**: * All readings, min_threshold, and max_threshold must be float values. * The length of the readings list will be at most 1000. - **Example**: ```python check_temperature_readings([22.5, 25.6, 19.8, 28.1, 30.0], 20.0, 26.0) # Returns [2, 3, 4] ``` # Performance Requirements Your implementation should efficiently handle the given constraints in terms of time and space complexity. # Additional Notes - Ensure to raise a `ValueError` for invalid arguments such as an empty readings list or if the minimum threshold is greater than the maximum threshold, with an appropriate error message. - Validate your solution using unit tests to handle typical and edge cases.","solution":"def check_temperature_readings(readings, min_threshold, max_threshold): Returns a list of indices where the temperature readings fall outside the comfortable range. Parameters: readings (list of float): The list of temperature readings in Celsius. min_threshold (float): The minimum comfortable temperature in Celsius. max_threshold (float): The maximum comfortable temperature in Celsius. Returns: list of int: Indices where the readings fall outside the comfortable range. if not readings: raise ValueError(\\"The readings list cannot be empty.\\") if min_threshold > max_threshold: raise ValueError(\\"min_threshold cannot be greater than max_threshold.\\") out_of_range_indices = [] for idx, temp in enumerate(readings): if temp < min_threshold or temp > max_threshold: out_of_range_indices.append(idx) return out_of_range_indices"},{"question":"# Validate and Parse Nested JSON-like Strings **Context**: You are building a lightweight parser for an application that deals with a custom configuration language. This format is similar to JSON but with specific restrictions. Your task is to validate and parse these strings to ensure they conform to the expected format. **Task**: Implement the function `validate_and_parse(json_str: str) -> dict` that validates and parses a nested JSON-like string into a Python dictionary. **Function Signature**: ```python def validate_and_parse(json_str: str) -> dict: ``` **Input**: - `json_str` (str): A string representing a nested JSON-like structure which contains: - Keys that are strings enclosed in double quotes `\\"` - Values that are strings (enclosed in double quotes `\\"`), numbers, boolean (`true` or `false`), or nested objects - Objects denoted by curly braces `{}`, with key-value pairs separated by colons `:` and pairs separated by commas `,` **Output**: - (dict): The parsed Python dictionary representing the JSON-like structure. **Constraints**: - The input string is guaranteed to be a well-formed JSON-like string without any syntax errors. - The input string does not contain arrays or null values. - Keys always have string values that are unique within each object. **Examples**: ```python assert validate_and_parse(\'{\\"name\\": \\"John\\", \\"age\\": 30, \\"isStudent\\": false}\') == {\\"name\\": \\"John\\", \\"age\\": 30, \\"isStudent\\": False} assert validate_and_parse(\'{\\"person\\": {\\"name\\": \\"John\\", \\"age\\": 30}, \\"city\\": \\"New York\\"}\') == {\\"person\\": {\\"name\\": \\"John\\", \\"age\\": 30}, \\"city\\": \\"New York\\"} assert validate_and_parse(\'{\\"nested\\": {\\"level1\\": {\\"level2\\": {\\"key\\": \\"value\\"}}}}\') == {\\"nested\\": {\\"level1\\": {\\"level2\\": {\\"key\\": \\"value\\"}}}} ``` **Additional Notes**: 1. **You may use Python’s built-in `json` module** after converting the custom format to standard JSON if necessary, but ensure that the function strictly adheres to the input format constraints. 2. Your implementation should effectively handle deeply nested objects and various valid value types. 3. The solution should be robust, efficiently transforming the input string into the corresponding dictionary without unnecessary operations.","solution":"import json def validate_and_parse(json_str: str) -> dict: Validates and parses a nested JSON-like string into a Python dictionary. Args: json_str (str): A JSON-like string. Returns: dict: The corresponding parsed Python dictionary. # Python\'s json.loads is capable of directly converting a JSON-like string to a dictionary result = json.loads(json_str) return result"},{"question":"**Question**: Implement a **Dynamic Programming Algorithm** to solve the Longest Increasing Subsequence (LIS) problem. # Context In a system where data analysis over time is crucial, you need to identify the longest increasing subsequence from a list of data points to help in predictive modeling. Given the nature of the problem, utilizing a dynamic programming approach ensures efficiency. # Task - Write a function `longest_increasing_subsequence(arr: List[int]) -> int` that takes a list of integers and returns the length of the longest increasing subsequence. # Requirements - **Input**: A list of integers `arr` with size ( n ), where ( 0 leq n leq 10^4 ). - **Output**: An integer representing the length of the longest increasing subsequence. # Constraints - You cannot use built-in functions that directly solve the longest increasing subsequence problem. - You should consider edge cases, such as an empty list or a list with all elements the same. - The solution should have a time complexity of ( O(n^2) ) and space complexity of ( O(n) ). # Example ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 # The LIS is [2, 3, 7, 18] assert longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3 # The LIS is [4, 8, 9] or [3, 8, 9] assert longest_increasing_subsequence([7, 7, 7, 7, 7]) == 1 # The LIS is [7] assert longest_increasing_subsequence([]) == 0 # The LIS is [] assert longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6 # The LIS is [1, 3, 6, 7, 9, 10] assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 # The LIS is [3, 10, 20] ``` Write the `longest_increasing_subsequence` function to meet the above requirements and ensure it passes the examples provided.","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis)"},{"question":"# Coding Assessment Question Context Develop a function that evaluates the balance of parentheses in an expression. This is a common problem used to test understanding of stacks and recursion. Problem Statement Write a function `is_balanced(expression: str) -> bool` that returns `True` if the parentheses in the given `expression` are balanced and `False` otherwise. The expression will consist of only three types of brackets: `()`, `{}`, and `[]`. Function Signature ```python def is_balanced(expression: str) -> bool: # Your code here ``` Input - `expression`: A string composed of characters including and potentially interspersed with `(`, `)`, `{`, `}`, `[` and `]`. Output - A boolean value `True` if the given `expression` has balanced parentheses/brackets and `False` otherwise. Example ```python assert is_balanced(\\"(){}[]\\") == True assert is_balanced(\\"({[()]})\\") == True assert is_balanced(\\"{[(])}\\") == False assert is_balanced(\\"(({{[[]]}}))\\") == True assert is_balanced(\\"[({})](]\\") == False ``` Constraints - The length of `expression` will be between 0 and 10^5 characters. - The function should handle both typical and edge case inputs efficiently. Hints - Consider using a stack to keep track of opening brackets and match them with closing brackets. - Ensure your solution is efficient in both time and space, and handles edge cases where the expression is empty or contains no brackets.","solution":"def is_balanced(expression: str) -> bool: Returns True if the parentheses/brackets in the given expression are balanced, else returns False. stack = [] matching_bracket = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in expression: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == []"},{"question":"# Problem Statement You are required to implement a function that performs an in-order traversal of a binary tree. The function should return the values of the nodes in a list. **Function Signature**: ```python def inorder_traversal(root: \'TreeNode\') -> list: Perform an in-order traversal of a binary tree. @input: root (root node of the binary tree) @returns: A list of node values in in-order traversal. @example: >>> class TreeNode: >>> def __init__(self, val=0, left=None, right=None): >>> self.val = val >>> self.left = left >>> self.right = right >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.left = TreeNode(3) >>> inorder_traversal(root) [1, 3, 2] pass ``` # Requirements: 1. **Input Constraints**: - The tree node values are integers and can be positive, negative, or zero. - The number of nodes in the tree is in the range [0, 1000]. 2. **Output**: - A list of integers representing the in-order traversal of the binary tree. 3. **Performance**: - The function should handle up to 1000 nodes efficiently given the constraints. # Description - Traverse the binary tree starting from the root. - Follow the in-order traversal rules: visit the left subtree, the root node, and then the right subtree. - Return the values of the nodes in a list. # Edge Cases: - If the binary tree is empty (root is `None`), the function should return an empty list. - Consider large unbalanced trees where all nodes are only left children or right children. # Example You can validate your solution with the following example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(1) root.right = TreeNode(2) root.right.left = TreeNode(3) print(inorder_traversal(root)) # Expected Output: # [1, 3, 2] root2 = TreeNode(5) root2.left = TreeNode(3) root2.left.left = TreeNode(2) root2.left.right = TreeNode(4) root2.right = TreeNode(7) root2.right.left = TreeNode(6) print(inorder_traversal(root2)) # Expected Output: # [2, 3, 4, 5, 6, 7] ``` # Note: - Define a class `TreeNode` if not provided. - Ensure that the in-order traversal function is implemented correctly. - Do not use built-in traversal functions. Implement the traversal logic manually.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> list: Perform an in-order traversal of a binary tree. @input: root (root node of the binary tree) @returns: A list of node values in in-order traversal. result = [] def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) traverse(root) return result"},{"question":"# Reverse Words in a String Context You have been tasked with creating a functionality that reverses the order of words in a given string. The system should handle edge cases such as multiple spaces between words and leading or trailing spaces in the input string effectively. Task Implement the following function: 1. `reverse_words(input_string: str) -> str`: * Reverses the order of words in the input string while keeping the words themselves in the original order. Input * `input_string`: The original string containing words separated by spaces. Output * A string where the words are in reverse order compared to the input string. Constraints * `0 <= len(input_string) <= 10^5` * Words are separated by one or more spaces. * The function should remove leading or trailing spaces and ensure that there is only a single space between words in the output. Function Signature ```python def reverse_words(input_string: str) -> str: pass ``` Example Scenarios 1. Basic scenario: * Input: `\\"Hello world\\"` * Output: `\\"world Hello\\"` 2. With leading and trailing spaces: * Input: `\\" a quick brown fox \\"` * Output: `\\"fox brown quick a\\"` 3. With multiple spaces between words: * Input: `\\"I love programming\\"` * Output: `\\"programming love I\\"` Write the code to achieve this reversing functionality, ensuring it handles edge cases such as multiple spaces and leading/trailing spaces in an efficient manner.","solution":"def reverse_words(input_string: str) -> str: Reverses the order of words in the input string while keeping the words themselves in the original order. words = input_string.strip().split() return \' \'.join(words[::-1])"},{"question":"# Question: Implement a Robust Newton-Raphson Method Context You are tasked with developing an enhanced version of the Newton-Raphson method for root-finding in numerical analysis. The main function should find a root of a given real-valued function more reliably by handling division errors and optimizing performance for a variety of edge cases. Objective Write a Python function `robust_newton_raphson` that takes in four parameters: the function `f` for which the root is to be determined, its derivative `df`, an initial guess `initial_guess`, the maximum number of iterations `max_iterations`, and an optional parameter `tolerance` which determines the acceptable error margin for the root. The function should return the root of the function if found within the given constraints, otherwise return a `ValueError` indicating non-convergence. Input Format 1. `f`: A callable function that takes a single float input and returns a float value. 2. `df`: A callable function that represents the derivative of `f` and also takes a single float input and returns a float value. 3. `initial_guess`: A float representing the initial guess for the root. 4. `max_iterations`: An integer representing the maximum number of iterations allowed. 5. `tolerance` (optional): A float representing the acceptable error margin (default is (10^{-6})). Output Format * Return a float value representing the root found by the method. * Raise a `ValueError` if the root is not found within the given `max_iterations`. Constraints * `max_iterations` is a positive integer. * `tolerance` is a positive float. Performance Requirements * Ensure robust handling of derivative values that are close to zero to avoid division by zero errors. * Converge within a reasonable number of iterations for well-behaved functions. * Handle edge cases and potential floating-point precision issues gracefully. Example ```python def example_function(x): return x**2 - 2 def example_derivative(x): return 2*x # Find the root of the function `example_function` starting with an initial guess of 1.5 root = robust_newton_raphson(example_function, example_derivative, 1.5, 100) print(f\\"Root found: {root}\\") ```","solution":"def robust_newton_raphson(f, df, initial_guess, max_iterations, tolerance=1e-6): Enhanced Newton-Raphson method to find the root of the function `f` using its derivative `df`. :param f: callable, the function to find the root of :param df: callable, the derivative of the function :param initial_guess: float, the initial guess for the root :param max_iterations: int, the maximum number of iterations allowed :param tolerance: float, the acceptable error margin (default is 1e-6) :return: float, the root found :raises: ValueError, if the root is not found within the given max_iterations x = initial_guess for i in range(max_iterations): fx = f(x) dfx = df(x) # Ensure the derivative is not zero to avoid division by zero if dfx == 0: raise ValueError(f\\"Derivative was zero at iteration {i}, x = {x}.\\") # Updating x value using Newton-Raphson formula x_new = x - fx / dfx # Checking for convergence if abs(x_new - x) < tolerance: return x_new x = x_new # If maximum iterations were reached without convergence raise ValueError(f\\"Did not converge within {max_iterations} iterations.\\")"},{"question":"# Generating All Subsets (Power Set) Context You are given a list of distinct integers. Your task is to implement a function that returns all possible subsets of the list (the power set). Each subset should be represented as a sorted list, and the power set should contain no duplicate subsets. Function Signature ```python def generate_subsets(nums: list[int]) -> list[list[int]]: Generate all possible subsets of the given list of integers. Args: nums (list[int]): A list of distinct integers. Returns: list[list[int]]: A list of all possible subsets, where each subset is sorted in non-decreasing order. ``` Input Format * `nums`: A list of distinct integers. Output Format * A list of lists, where each list is a subset of `nums`, and each subset is sorted in non-decreasing order. Constraints * The list contains between 1 and 10 distinct integers. * The integers are within the range -10 to 10. Example ```python nums = [1, 2, 3] print(generate_subsets(nums)) # Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] ``` Notes * Ensure that each subset is listed only once in the output. * The order of subsets in the output list does not matter. * You can use iterative, recursive, or backtracking approaches to solve this problem.","solution":"from itertools import chain, combinations def generate_subsets(nums: list[int]) -> list[list[int]]: Generate all possible subsets of the given list of integers. Args: nums (list[int]): A list of distinct integers. Returns: list[list[int]]: A list of all possible subsets, where each subset is sorted in non-decreasing order. nums.sort() # Ensure the list is sorted subsets = list(chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1))) return [list(subset) for subset in subsets]"},{"question":"# Context Linked lists are a fundamental data structure in computer science. A common problem involves combining two sorted linked lists into a single sorted linked list. This can be useful in various applications, such as merging results from different sources or simply combining and sorting data. # Task You need to create a function that takes two linked lists, each sorted in non-decreasing order, and merges them into a new linked list that is also sorted in non-decreasing order. The new linked list should be made by splicing together the nodes of the given two linked lists. # Function Signature: ```python def merge_two_sorted_lists(list1: ListNode, list2: ListNode) -> ListNode: pass ``` # Input - `list1`: The head node of the first sorted linked list. - `list2`: The head node of the second sorted linked list. # Output - The head node of the merged linked list which is sorted. # Constraints 1. The number of nodes in both linked lists is in the range `[0, 50]`. 2. `-100 <= Node.val <= 100` 3. Both `list1` and `list2` are sorted in non-decreasing order. # Performance Requirements - Time Complexity: O(n + m), where n and m are the lengths of the two linked lists. - Space Complexity: O(1), since the merged linked list is formed by reusing nodes from the input linked lists. # Class Definition for ListNode You are provided with the definition for a singly-linked list node: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Example ```python # Creating list1: 1 -> 2 -> 4 list1 = ListNode(1, ListNode(2, ListNode(4))) # Creating list2: 1 -> 3 -> 4 list2 = ListNode(1, ListNode(3, ListNode(4))) result = merge_two_sorted_lists(list1, list2) # Resulting linked list: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # Printing result current = result while current: print(current.val, end=\\" -> \\") current = current.next # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> ``` # Notes - Ensure your function handles edge cases, such as one of the lists being empty (i.e., None). - Do not create new nodes; instead, re-arrange the nodes from the input lists. - You may assume that the ListNode class and the function signature are part of the codebase and do not need to be defined within your function.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(list1: ListNode, list2: ListNode) -> ListNode: # Create a prehead node that helps to simplify the merging process prehead = ListNode(-1) # Maintain a reference to the current node for building the merged list current = prehead # While both linked list pointers have not yet reached the ends while list1 and list2: if list1.val <= list2.val: current.next = list1 list1 = list1.next else: current.next = list2 list2 = list2.next current = current.next # At least one of list1 and list2 can still have remaining nodes current.next = list1 if list1 is not None else list2 # The prehead\'s next node is the head of the merged linked list return prehead.next"},{"question":"# Task You are provided with a function that identifies whether a string is a palindrome. However, the current implementation only considers alphabetic characters and ignores case sensitivity, but it fails to take into account digits and special characters correctly. Your task is to extend this functionality to include all characters and ensure case insensitivity. # Requirements 1. **Function**: Implement a function `is_palindrome(input_string: str) -> bool` that checks whether the input string is a palindrome. 2. **Input**: A string `input_string` which may contain a mix of alphabets, digits, spaces, and special characters. 3. **Output**: A boolean `True` if the string is a palindrome, `False` otherwise. 4. **Constraints**: * The input string will have a maximum length of 10^5 characters. # Example ```python def is_palindrome(input_string: str) -> bool: # Your implementation here # Test case print(is_palindrome(\\"A man, a plan, a canal, Panama\\")) # Output: True print(is_palindrome(\\"No lemon, no melon!!\\")) # Output: True print(is_palindrome(\\"Was it a car or a cat I saw?\\")) # Output: True print(is_palindrome(\\"Not a palindrome\\")) # Output: False print(is_palindrome(\\"12321\\")) # Output: True print(is_palindrome(\\"12345\\")) # Output: False ``` # Explanation - The function should iterate over each character in the input string `input_string`. - It should ignore case and consider all characters, including digits and special characters, while checking for palindrome properties. - A string is considered a palindrome if it reads the same backward as forward. By handling alphabetic characters, digits, and special characters equally, you ensure comprehensive palindrome verification.","solution":"def is_palindrome(input_string: str) -> bool: Returns True if input_string is a palindrome, ignoring case sensitivity and considering all characters including digits and special characters. cleaned_string = \'\'.join(c.lower() for c in input_string if c.isalnum()) return cleaned_string == cleaned_string[::-1]"},{"question":"# Problem Statement You need to develop a program that calculates the sum of the first N prime numbers. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Objectives 1. Write a function `is_prime(n: int) -> bool` that checks if a given integer `n` is a prime number. 2. Write a function `sum_of_primes(n: int) -> int` that returns the sum of the first `n` prime numbers. # Function Signature ```python def is_prime(n: int) -> bool: # Implementation def sum_of_primes(n: int) -> int: # Implementation ``` # Input - `n`: An integer representing the count of the first N prime numbers to be summed. # Output - The sum of the first N prime numbers. # Constraints - The input integer `n` will always be a positive integer and within a reasonable range to compute the sum of the first N primes efficiently. # Example ```python >>> assert is_prime(5) == True >>> assert is_prime(10) == False >>> assert sum_of_primes(5) == 28 # 2 + 3 + 5 + 7 + 11 ``` # Guidelines 1. The `is_prime` function should efficiently determine if a number is prime. 2. The `sum_of_primes` function should keep a count of how many prime numbers have been found and sum them until the count reaches `n`. 3. Avoid using unnecessary large loops and optimize for performance.","solution":"import math def is_prime(n: int) -> bool: Check if a number n is prime. Args: n: int - Number to be checked Returns: bool - True if n is prime, False otherwise if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes(n: int) -> int: Calculate the sum of the first n prime numbers. Args: n: int - Number of prime numbers to sum up Returns: int - Sum of the first n prime numbers prime_count = 0 current_num = 2 prime_sum = 0 while prime_count < n: if is_prime(current_num): prime_sum += current_num prime_count += 1 current_num += 1 return prime_sum"},{"question":"# Background: Matrix manipulation is a core concept in various fields such as computer graphics, machine learning, and scientific computing. One common operation is transposing a matrix, which involves flipping the matrix over its diagonal, switching the row and column indices of the elements. # Task: Write a function that transposes a given 2D list (matrix). The function should be able to handle non-square matrices and should raise appropriate errors for incorrect input types. # Function Signature: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input: - `matrix`: A 2D list of integers representing the matrix to be transposed. # Output: - Returns the transposed matrix as a 2D list of integers. # Constraints: - The input `matrix` should not be empty. - All rows in the `matrix` should have the same length. - Inputs should be integers. # Examples: ```python print(transpose_matrix([[1, 2, 3], [4, 5, 6]])) # Expected: [[1, 4], [2, 5], [3, 6]] print(transpose_matrix([[1, 2], [3, 4], [5, 6]])) # Expected: [[1, 3, 5], [2, 4, 6]] print(transpose_matrix([[1]])) # Expected: [[1]] print(transpose_matrix([[1, 2, 3]])) # Expected: [[1], [2], [3]] print(transpose_matrix([[1, \\"2\\", 3]])) # Expected: TypeError raised ``` # Scenario: You are developing a data analysis tool that performs various matrix operations. One of the features is to transpose matrices to analyze data from different perspectives. Ensure your function is efficient and handles edge cases properly.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # Check if matrix is empty if not matrix or not matrix[0]: raise ValueError(\\"The input matrix must not be empty.\\") # Check if all rows have the same length and contain only integers row_length = len(matrix[0]) for row in matrix: if len(row) != row_length: raise ValueError(\\"All rows in the matrix should have the same length.\\") if not all(isinstance(element, int) for element in row): raise TypeError(\\"All elements in the matrix should be integers.\\") # Transpose the matrix transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] return transposed"},{"question":"# Coding Assessment Question Scenario You are tasked with improving a record-keeping system by writing a function that can identify and count the unique words in a document. The function should ignore case, punctuation, and special characters, considering only alphanumeric characters as part of words. Additionally, it should return a count of each unique word found. Task Implement a function `count_unique_words` that takes a single string input representing the document and returns a dictionary mapping each unique word to its corresponding count. Words should be considered case-insensitively, and punctuation/special characters should be ignored. Input - A single string `s` containing any characters (length between 0 and 10000). Output - A dictionary where keys are unique words in lowercase and values are the counts of each word in the document. Constraints - The input string can include uppercase letters (`A-Z`), lowercase letters (`a-z`), digits (`0-9`), punctuation marks, and special characters. - Words are sequences of alphanumeric characters. - You may assume the input string only contains printable ASCII characters. Examples ```python >>> count_unique_words(\\"Hello, world! Hello!!\\") {\'hello\': 2, \'world\': 1} >>> count_unique_words(\\"Testing, testing, 123. TESTING!\\") {\'testing\': 3, \'123\': 1} >>> count_unique_words(\\"Unique words are counted. Unique, UNIQUE!\\") {\'unique\': 3, \'words\': 1, \'are\': 1, \'counted\': 1} >>> count_unique_words(\\"No words here?! 123 456.\\") {\'no\': 1, \'words\': 1, \'here\': 1, \'123\': 1, \'456\': 1} >>> count_unique_words(\\"\\") {} ``` Implementation ```python import re from collections import defaultdict def count_unique_words(s: str) -> dict: Count unique words in a given string, ignoring case and punctuation. # Convert to lowercase and use regex to find alphanumeric word sequences s = s.lower() words = re.findall(r\'bw+b\', s) word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count) # Sample test cases to validate your function assert count_unique_words(\\"Hello, world! Hello!!\\") == {\'hello\': 2, \'world\': 1} assert count_unique_words(\\"Testing, testing, 123. TESTING!\\") == {\'testing\': 3, \'123\': 1} assert count_unique_words(\\"Unique words are counted. Unique, UNIQUE!\\") == {\'unique\': 3, \'words\': 1, \'are\': 1, \'counted\': 1} assert count_unique_words(\\"No words here?! 123 456.\\") == {\'no\': 1, \'words\': 1, \'here\': 1, \'123\': 1, \'456\': 1} assert count_unique_words(\\"\\") == {} print(\\"All tests passed!\\") ```","solution":"import re from collections import defaultdict def count_unique_words(s: str) -> dict: Count unique words in a given string, ignoring case and punctuation. # Convert to lowercase and use regex to find alphanumeric word sequences s = s.lower() words = re.findall(r\'bw+b\', s) word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Objective: Implement a function in Python to determine if a given string follows a valid email address format, adhering to a simplified set of rules. # Problem Statement: You need to write a function that checks if a given string is a valid email address. The rules for validation are simplified and should be enforced as follows: - The string must contain exactly one `@` character. - The local part (before the `@`) must contain only letters, digits, underscores, hyphens, and periods. - The domain part (after the `@`) must be a valid domain name, which is composed of letters, digits, hyphens, and at least one period. - The last part of the domain must be between 2 to 4 characters long (e.g., .com, .net, .org). # Function Signature: ```python def is_valid_email(email: str) -> bool: ``` # Input: - `email`: a string representing the email address to be validated. # Output: - Returns `True` if the email address is valid according to the specified rules. - Returns `False` otherwise. # Constraints: - The input string can have a length up to 320 characters. - Both the local part and domain part must not be empty. # Examples: ```python >>> is_valid_email(\\"user@example.com\\") True >>> is_valid_email(\\"user.name+tag+sorting@example.com\\") False >>> is_valid_email(\\"user@name@domain.com\\") False >>> is_valid_email(\\"username@.com\\") False >>> is_valid_email(\\"username@com\\") False >>> is_valid_email(\\"username@domain.c\\") False >>> is_valid_email(\\"username@domain.com1\\") True >>> is_valid_email(\\"user.name@example.com\\") True ``` # Requirements: - Implement the function adhering to the signature and constraints. - Ensure the function handles edge cases like invalid characters, multiple `@` symbols, missing parts correctly. - Do not use any external libraries for validation (e.g., `re` module or email validators).","solution":"def is_valid_email(email: str) -> bool: # Check for exactly one \'@\' parts = email.split(\'@\') if len(parts) != 2: return False # Split into local and domain parts local, domain = parts # Check local part with allowed characters if not all(c.isalnum() or c in \'._-\' for c in local) or len(local) == 0: return False # Split domain into subparts domain_parts = domain.split(\'.\') # Domain must have at least one period if len(domain_parts) < 2: return False # Check the last part of domain (TLD) length tld = domain_parts[-1] if not (2 <= len(tld) <= 4): return False # Check the other parts of domain for part in domain_parts[:-1]: if not part.isalnum() and \'-\' not in part: return False return True"},{"question":"# Problem Statement A tech company is developing a data processing module that deals with lists of integers. Your task is to implement a utility that performs specific operations on these lists. Users can input a list of integers and perform operations such as finding the second largest number, checking if the list is strictly increasing, and computing the sum of squares of all even numbers. # Requirements You need to implement three functions `second_largest`, `is_strictly_increasing`, and `sum_of_squares_of_evens` based on the specified functionality and input validation logic. Additionally, you need to implement a composite function `list_operations_summary` that leverages these three functions to provide a summary of the list operations. # Input and Output 1. **Input** - `list_operations_summary(numbers: List[int]) -> dict` - `numbers`: List of integers (must contain at least two elements). 2. **Output** - Return a dictionary containing: - `\'second_largest\'`: int (the second largest number in the list) - `\'is_strictly_increasing\'`: bool (True if the list is strictly increasing, False otherwise) - `\'sum_of_squares_of_evens\'`: int (sum of squares of all even numbers in the list) # Constraints - The list must contain at least two elements. - All elements in the list are integers and can be negative, zero, or positive. # Example ```python list_operations_summary([1, 7, 3, 5, 9, 2]) # Output: {\'second_largest\': 7, \'is_strictly_increasing\': False, \'sum_of_squares_of_evens\': 4} list_operations_summary([2, 4, 6]) # Output: {\'second_largest\': 4, \'is_strictly_increasing\': True, \'sum_of_squares_of_evens\': 56} ``` # Notes - Handle invalid inputs by raising appropriate exceptions. - Ensure all calculations and checks are efficient, considering potential edge cases of the input list. # Implementation Implement the required functions with careful consideration of input validation and algorithm efficiency.","solution":"def second_largest(numbers): if len(numbers) < 2: raise ValueError(\\"The list must contain at least two elements.\\") unique_numbers = list(set(numbers)) if len(unique_numbers) < 2: raise ValueError(\\"The list must contain at least two unique elements.\\") unique_numbers.sort(reverse=True) return unique_numbers[1] def is_strictly_increasing(numbers): return all(x < y for x, y in zip(numbers, numbers[1:])) def sum_of_squares_of_evens(numbers): return sum(x * x for x in numbers if x % 2 == 0) def list_operations_summary(numbers): return { \'second_largest\': second_largest(numbers), \'is_strictly_increasing\': is_strictly_increasing(numbers), \'sum_of_squares_of_evens\': sum_of_squares_of_evens(numbers) }"},{"question":"# Context A linear search is a fundamental search algorithm that scans an array or list sequentially to find a given element. It is straightforward and works by iterating through elements until the target value is found or the end of the list is reached. # Task Write a function `linear_search(arr: list, target: int) -> int` that implements a linear search to find the position of a given `target` element in the list `arr`. # Input - A list of integers `arr` where each element can be any positive or negative integer. - An integer `target` which is the element you need to search for in the list `arr`. # Output - Returns the index of the `target` in the list `arr` if it is present. Otherwise, returns `-1`. # Constraints - The list `arr` can be of length between `0` and `1000` elements. - The integers in the list `arr` can be in any order, and they can have any positive or negative integer value. # Example ```python >>> linear_search([10, 20, 30, 40, 50], 30) 2 >>> linear_search([10, 20, 30, 40, 50], 60) -1 >>> linear_search([], 60) -1 >>> linear_search([-1, -2, -3, -4, -5], -3) 2 >>> linear_search([1, 1, 1, 1, 1], 1) 0 ``` # Notes - If the `target` appears multiple times in the list, return the index of its first occurrence. - Handle cases where the list might be empty.","solution":"def linear_search(arr, target): Perform a linear search to find the target in the list arr. :param arr: List of integers. :param target: The integer value to search for. :return: The index of the target if found, otherwise -1. for index, value in enumerate(arr): if value == target: return index return -1"},{"question":"# Binary Tree Level Order Traversal **Problem Statement:** You need to implement a function that performs a level order traversal (also known as breadth-first traversal) on a binary tree. The function should return the values of the nodes in each level from top to bottom. **Function Signature:** ```python def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: pass ``` **Input:** - `root` (TreeNode): The root node of the binary tree, defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output:** - A list of lists, where each inner list contains the values of the nodes at the corresponding level. **Constraints:** - The number of nodes in the tree will be between 0 and 10^4. - The values of the nodes in the tree will be between -1000 and 1000. **Requirements:** 1. Implement the level order traversal using a queue to manage the nodes at each level. 2. Ensure that the function handles edge cases, such as an empty tree (`root` is `None`). **Example:** ```python # Binary tree example # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) # Expected output: [[3], [9, 20], [15, 7]] expected_output = [[3], [9, 20], [15, 7]] output = level_order_traversal(root) assert output == expected_output, \\"Test case failed!\\" print(\\"Test case passed!\\") ``` **Note:** Ensure to test your function with various binary trees with different structures to verify its robustness and correctness.","solution":"from typing import List, Optional import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = collections.deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"# Problem Statement: Given a string containing digits from \'2\' to \'9\', write a function `generate_combinations` that returns all possible letter combinations that the number could represent. The digit-to-letter mapping is the same as on traditional telephone keypads (i.e., 2 maps to \'abc\', 3 maps to \'def\', etc.). The function should return the combinations in lexicographical order. # Function Signature: ```python def generate_combinations(digits: str) -> List[str] ``` # Input: - `digits` (str): A string containing the digits \'2\' to \'9\'. # Output: - A list of strings, each string being a valid letter combination. # Constraints: - The input string `digits` will contain at most 4 digits. - Each digit in `digits` is in the range \'2\' to \'9\'. # Example: ```python assert generate_combinations(\\"23\\") == [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] assert generate_combinations(\\"\\") == [] assert generate_combinations(\\"9\\") == [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] ``` # Hint: Use a recursive approach or backtracking to generate all possible combinations. Consider keeping a dictionary that maps each digit to its corresponding letters for quick lookups. Ensure the order of combinations is lexicographical. # Context: This problem tests the student\'s ability to work with mappings and permutations, demonstrating understanding of string manipulation and recursive algorithms or backtracking methods.","solution":"from typing import List def generate_combinations(digits: str) -> List[str]: if not digits: return [] digit_to_letters = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_letters[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return sorted(combinations)"},{"question":"**Context**: You are developing software for an environmental monitoring system that tracks real-time data of an ecosystem from various sensors. One of the tasks involved is processing temperature data to ensure it falls within safe operational thresholds. Any anomaly detected needs to be flagged for further analysis. The system will record hourly temperature readings, which will be analyzed to identify periods when the temperature exceeds a given threshold. **Task**: Implement a function to determine continuous periods during which the recorded temperature readings exceed a specified threshold value. The function should identify the start and end hours of such periods and return them in a list of tuples. # Requirements: * Implement a function named `detect_temperature_anomalies` in Python. * The inputs will be: - `temperatures`: list of floats, representing hourly temperature readings in degrees Celsius. - `threshold`: float, the temperature threshold in degrees Celsius. * The output should be a list of tuples, each containing the start and end hour of the periods during which temperatures consistently exceed the threshold. If no such periods are found, return an empty list. # Additional Constraints: * The function should consider only continuous periods. A gap of one or more hours with temperatures below the threshold should break the period. * Ensure that the function works for any length of the `temperatures` list, and handle edge cases where no temperature exceeds the threshold. # Function Signature: ```python def detect_temperature_anomalies(temperatures: list[float], threshold: float) -> list[tuple[int, int]]: pass ``` # Example: ```python >>> detect_temperature_anomalies([22.5, 23.0, 25.1, 27.5, 24.3, 21.0, 20.9], 24.0) [(2, 4)] >>> detect_temperature_anomalies([19.5, 20.0, 18.5, 21.0, 22.5, 23.0, 19.0], 22.0) [(4, 5)] >>> detect_temperature_anomalies([16.0, 18.2, 19.1, 20.5, 21.3, 19.4, 18.5], 22.0) [] ``` # Hint: Loop through the `temperatures` list and track the start of a period when you first encounter a temperature exceeding the threshold. Continue until you find a temperature below the threshold, then record the end of the period and start a new one if the temperature exceeds the threshold again.","solution":"def detect_temperature_anomalies(temperatures: list[float], threshold: float) -> list[tuple[int, int]]: Detects continuous periods during which the recorded temperature readings exceed a specified threshold value. Args: temperatures (list[float]): List of hourly temperature readings in degrees Celsius. threshold (float): The temperature threshold in degrees Celsius. Returns: list[tuple[int, int]]: List of tuples, each containing the start and end hour of periods where temperatures consistently exceed the threshold. periods = [] start = None for hour, temp in enumerate(temperatures): if temp > threshold: if start is None: start = hour else: if start is not None: periods.append((start, hour - 1)) start = None if start is not None: periods.append((start, len(temperatures) - 1)) return periods"},{"question":"# String Reversal with Special Characters Write a function `reverse_string_with_special_chars` that reverses the characters in a string while keeping special characters (non-alphabetic characters) in their original positions. Requirements: 1. **Character Identification**: Identify and maintain the positions of all special characters and whitespaces in the string. 2. **Reversal Logic**: Reverse only the alphabetic characters, ensuring the special characters remain in their original positions. 3. **Output**: The modified string with appropriate characters reversed and special characters in their original positions. Input and Output Format: * **Input**: One string `s` containing alphabetic characters, digits, and special characters. * **Output**: A string with the described transformation. Constraints: * The input string `s` will have at most 1000 characters. * Special characters are non-alphabetic characters including whitespaces. # Example Usage ```python >>> reverse_string_with_special_chars(\\"a,bc\\") \\"c,ba\\" >>> reverse_string_with_special_chars(\\"A!!B C\\") \\"C!!B A\\" >>> reverse_string_with_special_chars(\\"docker!!!launch\\") \\"hcnual!!!rekcod\\" ``` # Function Signature ```python def reverse_string_with_special_chars(s: str) -> str: pass ```","solution":"def reverse_string_with_special_chars(s: str) -> str: Reverses the characters in the string `s` while keeping special characters in their original positions. Parameters: s (str): input string containing alphabetic characters, digits, and special characters. Returns: str: the modified string with the alphabetic characters reversed and special characters in their original positions. # Identify the list of positions that are alphabetic characters alpha_positions = [pos for pos, char in enumerate(s) if char.isalpha()] # Create a new list from the input string as a starting point s_list = list(s) # Reverse the alphabetic positions list reversed_alpha_positions = alpha_positions[::-1] # Replace the characters at the alphabetic positions with reversed alphabetic characters for i, pos in enumerate(alpha_positions): s_list[pos] = s[reversed_alpha_positions[i]] return \'\'.join(s_list)"},{"question":"# Problem You are given a log file containing multiple lines of user activities. Each line represents a single activity and contains a timestamp (in the format `YYYY-MM-DD HH:MM:SS`), a user ID, and an activity description. Your task is to write a function `parse_log_file` that reads and processes this log file to extract meaningful information. Specifically, you need to write two functions `most_active_user` and `user_activity_count`. # Requirements 1. The function `parse_log_file` should read the log file and store the activities in a data structure suitable for further processing. 2. The function `most_active_user` should return the user ID that appears the most in the log file. 3. The function `user_activity_count` should take a user ID as input and return the number of activities performed by this user. # Constraints * The log file will contain at least one line of user activity. * Each line in the log file is properly formatted according to the given specification. * The user ID is a string of alphanumeric characters. * Activity descriptions can contain spaces and punctuation marks. * Assume the log file fits into memory. # Input and Output Format - `parse_log_file(filename: str) -> None` - `most_active_user() -> str` - `user_activity_count(user_id: str) -> int` Here\'s an example of how these functions should work: Log file content (`log.txt`): ``` 2023-01-01 09:00:00 user1 Logged in 2023-01-01 09:05:00 user2 Viewed dashboard 2023-01-01 09:10:00 user1 Posted a comment 2023-01-01 09:15:00 user1 Logged out 2023-01-01 09:20:00 user3 Logged in ``` Example usage: ```python parse_log_file(\'log.txt\') assert most_active_user() == \'user1\' assert user_activity_count(\'user1\') == 3 assert user_activity_count(\'user2\') == 1 ``` # Additional Information - Use a dictionary to store user activities efficiently. - Consider edge cases such as multiple users performing the same number of activities. # Solution Template ```python from collections import defaultdict # Data structure to store parsed activities activities = defaultdict(list) def parse_log_file(filename: str) -> None: Reads the log file and stores the activities in a data structure. global activities activities.clear() with open(filename, \'r\') as file: for line in file: timestamp, user_id, activity = parse_line(line) activities[user_id].append((timestamp, activity)) def parse_line(line: str): Parses a single line of log file. parts = line.split(\' \', 2) timestamp = f\\"{parts[0]} {parts[1]}\\" user_id = parts[2].split(\' \', 1)[0] activity = parts[2].split(\' \', 1)[1] return timestamp, user_id, activity def most_active_user() -> str: Returns the user ID that appears the most in the log file. max_user = None max_activities = 0 for user, acts in activities.items(): if len(acts) > max_activities: max_activities = len(acts) max_user = user return max_user def user_activity_count(user_id: str) -> int: Takes a user ID as input and returns the number of activities performed by this user. return len(activities[user_id]) ```","solution":"from collections import defaultdict # Data structure to store parsed activities activities = defaultdict(list) def parse_log_file(filename: str) -> None: Reads the log file and stores the activities in a data structure. global activities activities.clear() with open(filename, \'r\') as file: for line in file: timestamp, user_id, activity = parse_line(line) activities[user_id].append((timestamp, activity)) def parse_line(line: str): Parses a single line of the log file. parts = line.split(\' \', 2) timestamp = f\\"{parts[0]} {parts[1]}\\" user_id = parts[2].split(\' \', 1)[0] activity = parts[2].split(\' \', 1)[1] return timestamp, user_id, activity def most_active_user() -> str: Returns the user ID that appears the most in the log file. max_user = None max_activities = 0 for user, acts in activities.items(): if len(acts) > max_activities: max_activities = len(acts) max_user = user return max_user def user_activity_count(user_id: str) -> int: Takes a user ID as input and returns the number of activities performed by this user. return len(activities.get(user_id, []))"},{"question":"Question: Implement a Custom Linked List with Basic Operations You are tasked with implementing a custom singly linked list in Python. This exercise will test your understanding of data structures, specifically linked lists, and your ability to manipulate data stored within them. # Operations to Implement 1. **Node Class**: Create a Node class to store a value and reference to the next node. ```python class Node: def __init__(self, value: int): self.value = value self.next = None ``` 2. **LinkedList Class**: Implement a LinkedList class that supports the following operations: 1. **Insert at the End**: Inserts a new node with a specified value at the end of the list. ```python def insert_end(self, value: int): pass ``` 2. **Delete by Value**: Deletes the first node with the specified value. ```python def delete_value(self, value: int): pass ``` 3. **Search by Value**: Returns `True` if a node with the specified value exists in the list, `False` otherwise. ```python def search_value(self, value: int) -> bool: pass ``` 4. **Get Length**: Returns the total number of nodes in the list. ```python def get_length(self) -> int: pass ``` 3. **Extra Method** - **Print List**: Implement an extra method to print all values in the list for easy debugging. ```python def print_list(self): pass ``` # Input & Output Specifications: - All node values will be integers. - For `delete_value` method, if the specified value does not exist in the list, the list remains unchanged. # Example Usage: ```python linked_list = LinkedList() linked_list.insert_end(10) linked_list.insert_end(20) linked_list.insert_end(30) linked_list.print_list() # Output: 10 -> 20 -> 30 linked_list.delete_value(20) linked_list.print_list() # Output: 10 -> 30 print(linked_list.search_value(20)) # Output: False print(linked_list.get_length()) # Output: 2 linked_list.delete_value(10) linked_list.print_list() # Output: 30 ``` # Constraints: - Assume the linked list can store up to 10,000 nodes. - All integer values will be in the range [-10^6, 10^6]. # Implementation Notes: - Focus on efficiency for both insertion and deletion operations. - Maintain good code readability and proper error handling where applicable.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def insert_end(self, value: int): new_node = Node(value) if self.head is None: self.head = new_node return current = self.head while current.next is not None: current = current.next current.next = new_node def delete_value(self, value: int): current = self.head previous = None while current is not None: if current.value == value: if previous is None: self.head = current.next else: previous.next = current.next return previous = current current = current.next def search_value(self, value: int) -> bool: current = self.head while current is not None: if current.value == value: return True current = current.next return False def get_length(self) -> int: count = 0 current = self.head while current is not None: count += 1 current = current.next return count def print_list(self): values = [] current = self.head while current is not None: values.append(current.value) current = current.next print(\\" -> \\".join(map(str, values)))"},{"question":"# Question Root\'s Distance Sum Challenge You are required to implement a function to compute the sum of distances of all nodes from the root in a binary tree. The distance of a node is defined as the number of edges from the root to that node. Function Signature ```python def distance_sum(root: Optional[TreeNode]) -> int: ``` Input * `root`: The root of the binary tree. The structure `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * Returns an integer representing the sum of distances of all nodes from the root. Constraints * The number of nodes in the tree is in the range `[0, 10^5]`. * The value of each node is an integer within the range `[-10^5, 10^5]`. * If the tree is empty, the distance sum should be `0`. Performance Requirements * The solution should aim for a time complexity of O(n), where `n` is the number of nodes in the tree. Description and Steps 1. Traverse the tree starting from the root. 2. Maintain a counter to track the distance of the current node from the root. 3. Sum up the distances of all nodes during traversal. 4. Return the computed sum. # Example ```python root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) print(distance_sum(root)) # Output: 6 (distances: 0 + 1 + 1 + 2 + 2) root = TreeNode(2) root.left = TreeNode(3) root.left.left = TreeNode(4) print(distance_sum(root)) # Output: 3 (distances: 0 + 1 + 2) root = None print(distance_sum(root)) # Output: 0 (empty tree) ``` Considerations * Handling of edge cases such as empty trees. * Verifying the correctness for various tree structures, including skewed and balanced binary trees. * Efficient handling of large trees within the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def distance_sum(root: TreeNode) -> int: def dfs(node, depth): if node is None: return 0 return depth + dfs(node.left, depth + 1) + dfs(node.right, depth + 1) return dfs(root, 0)"},{"question":"Problem Description You have been assigned to implement a basic log management system for an application. The system needs to handle creation and retrieval of log entries, which each consist of a timestamp and a message. # Function Requirements 1. **Function Name**: `create_log_entry` - **Input**: - `timestamp` (str): A string representing the time at which the log was created, in the format \\"YYYY-MM-DD HH:MM:SS\\". - `message` (str): The log message. - `log_entries` (list): A list of current log entries. - **Output**: - `updated_log_entries` (list): The list of log entries updated to include the new log entry. 2. **Function Name**: `retrieve_log_entries` - **Input**: - `start_timestamp` (str): The start time (inclusive) for the log entries to be retrieved, in the format \\"YYYY-MM-DD HH:MM:SS\\". - `end_timestamp` (str): The end time (inclusive) for the log entries to be retrieved, in the format \\"YYYY-MM-DD HH:MM:SS\\". - `log_entries` (list): The list of current log entries. - **Output**: - `filtered_log_entries` (list): The list of log entries that fall within the given time range (inclusive). # Constraints - The `timestamp` must follow the format \\"YYYY-MM-DD HH:MM:SS\\". - Log entries are stored as tuples, where each tuple consists of a `timestamp` and a `message` i.e., `(\\"YYYY-MM-DD HH:MM:SS\\", \\"message\\")`. - The `log_entries` list can have zero or more entries. - The `retrieve_log_entries` function should return log entries sorted in chronological order. # Performance Requirements - The functions should have O(m) and O(n) time complexity respectively, where m is the number of log entries to be added, and n is the total number of log entries for the retrieval. # Example ```python log_entries = [] # Adding log entries log_entries = create_log_entry(\\"2023-10-05 12:00:00\\", \\"Log entry 1\\", log_entries) log_entries = create_log_entry(\\"2023-10-06 14:30:00\\", \\"Log entry 2\\", log_entries) log_entries = create_log_entry(\\"2023-10-06 16:45:00\\", \\"Log entry 3\\", log_entries) # Retrieving log entries filtered_log_entries = retrieve_log_entries(\\"2023-10-06 00:00:00\\", \\"2023-10-06 23:59:59\\", log_entries) print(filtered_log_entries) # Output: [(\\"2023-10-06 14:30:00\\", \\"Log entry 2\\"), (\\"2023-10-06 16:45:00\\", \\"Log entry 3\\")] ``` # Task Write the `create_log_entry` and `retrieve_log_entries` functions to achieve the above requirements. You can use helper functions if necessary.","solution":"from datetime import datetime def create_log_entry(timestamp, message, log_entries): Adds a new log entry to the log_entries list. Args: timestamp (str): The timestamp for the log entry in the format \\"YYYY-MM-DD HH:MM:SS\\". message (str): The log message. log_entries (list): The current list of log entries. Returns: list: Updated list of log entries, including the new entry. log_entries.append((timestamp, message)) return log_entries def retrieve_log_entries(start_timestamp, end_timestamp, log_entries): Retrieves log entries that fall within the specified time range. Args: start_timestamp (str): The start time (inclusive) for the log entries in the format \\"YYYY-MM-DD HH:MM:SS\\". end_timestamp (str): The end time (inclusive) for the log entries in the format \\"YYYY-MM-DD HH:MM:SS\\". log_entries (list): The current list of log entries. Returns: list: The filtered list of log entries within the time range. start = datetime.strptime(start_timestamp, \\"%Y-%m-%d %H:%M:%S\\") end = datetime.strptime(end_timestamp, \\"%Y-%m-%d %H:%M:%S\\") filtered_entries = [ entry for entry in log_entries if start <= datetime.strptime(entry[0], \\"%Y-%m-%d %H:%M:%S\\") <= end ] return sorted(filtered_entries, key=lambda x: x[0])"},{"question":"# Coding Challenge: Fraction to Decimal Conversion Objective: You need to write a function that converts a given fraction into its equivalent decimal representation, ensuring that any repeating decimal sequences are identified and enclosed in parentheses. Detailed Task Description: 1. **Function Implementation**: - Implement `fraction_to_decimal(numerator: int, denominator: int) -> str`: This function should convert the given numerator and denominator of a fraction into its corresponding decimal representation. If the decimal is repeating, the repeating sequence should be enclosed in parentheses. Input: - Two integers `numerator` and `denominator` where the absolute value of numerator and denominator does not exceed (2^{31} - 1). Output: - A string representing the decimal form of the given fraction. Repeating sequences, if any, should be denoted within parentheses. Constraints: - The denominator will not be zero. - The numerator can be zero. Example: 1. For `numerator = 1` and `denominator = 2`: - The function should return `\\"0.5\\"`. 2. For `numerator = 2` and `denominator = 3`: - The function should return `\\"0.(6)\\"`. 3. For `numerator = 4` and `denominator = 333`: - The function should return `\\"0.(012)\\"`. 4. For `numerator = 1` and `denominator = 5`: - The function should return `\\"0.2\\"`. # Function Signature: - `fraction_to_decimal(numerator: int, denominator: int) -> str` Code Template (for reference): ```python def fraction_to_decimal(numerator: int, denominator: int) -> str: # Implement the logic to convert the fraction to its # corresponding decimal representation with repeating parts # enclosed in parentheses. pass ``` Ensure your function correctly handles both positive and negative integers, and accurately identifies the repeating sequence in the decimal fraction.","solution":"def fraction_to_decimal(numerator: int, denominator: int) -> str: if numerator == 0: return \\"0\\" result = [] # Determine the sign if (numerator < 0) ^ (denominator < 0): result.append(\'-\') # Convert to positive numerator, denominator = abs(numerator), abs(denominator) # Integer part integer_part = numerator // denominator result.append(str(integer_part)) # If there is no remainder, return the integer part remainder = numerator % denominator if remainder == 0: return \'\'.join(result) result.append(\'.\') # Dictionary to store seen remainders and their corresponding index in result remainder_dict = {} while remainder != 0: # If the remainder is already in the dictionary, we found a repeating fraction if remainder in remainder_dict: result.insert(remainder_dict[remainder], \'(\') result.append(\')\') break # Record the position of this remainder remainder_dict[remainder] = len(result) remainder *= 10 quotient = remainder // denominator result.append(str(quotient)) remainder %= denominator return \'\'.join(result)"},{"question":"# Coding Assessment Question Scenario: You are developing a software application that processes sequences of integers for analysis. One part of the analysis involves determining specific characteristics of subarrays. You need to implement a function that finds the maximum product of any contiguous subarray within a given array of integers. Objective: Write a function named `max_subarray_product` that: - Accepts a list of integers `arr` (1 <= len(arr) <= 10^5, -10^5 <= arr[i] <= 10^5). - Returns the maximum product obtained from any contiguous subarray within `arr`. Implementation Requirements: - **Input**: A list `arr` of integers. - **Output**: An integer representing the maximum product of any contiguous subarray. Function Signature: ```python def max_subarray_product(arr: List[int]) -> int: pass ``` Constraints: - The length of the array will be between 1 and 100,000. - Each element of the array will be between -100,000 and 100,000. Example: ```python assert max_subarray_product([2, 3, -2, 4]) == 6 # The subarray [2, 3] has the maximum product 6 assert max_subarray_product([-2, 0, -1]) == 0 # The subarray [0] has the maximum product 0 assert max_subarray_product([-2, 3, -4]) == 24 # The subarray [3, -4] has the maximum product 12 or the entire array [-2, 3, -4] has the maximum product 24 ``` Note: - Ensure your function runs efficiently for the upper limit of input size. - Consider both positive and negative integers and the impact of zeroes in your array.","solution":"from typing import List def max_subarray_product(arr: List[int]) -> int: if not arr: return 0 max_product = min_product = result = arr[0] for num in arr[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"# Unique Characters in a String You are required to implement a function that checks if a given string has all unique characters. The function should return `True` if all characters in the string are unique, and `False` otherwise. Follow the constraints and restrictions outlined below. **Function Signature**: ```python def is_unique(string: str) -> bool: pass ``` # Constraints and Rules 1. **Input Characteristics**: - The input string will only contain ASCII characters (both lowercase and uppercase letters from \'a\' to \'z\', \'A\' to \'Z\', digits from \'0\' to \'9\', and symbols). 2. **Uniqueness Check**: - The function must determine if all characters in the string appear exactly once. 3. **Performance Requirements**: - The function should run in O(n) time complexity, where n is the length of the input string. - The function should use O(1) additional space (excluding the input string). # Expected Input and Output Formats **Input**: - A string `string` representing the string whose characters\' uniqueness is to be checked. **Output**: - A boolean value `True` if all characters in the string are unique, otherwise `False`. # Example ```python assert is_unique(\\"algorithm\\") == True assert is_unique(\\"programming\\") == False ```","solution":"def is_unique(string: str) -> bool: Checks if all characters in the input string are unique. :param string: The string to be checked. :return: True if all characters are unique, False otherwise. # Using a set to track characters we have seen. seen_chars = set() for char in string: # If the character is already in the set, return False. if char in seen_chars: return False # Add character to the set. seen_chars.add(char) # If we finish the loop without finding duplicates, return True. return True"},{"question":"# Problem Statement **Substring Count** You are to implement a function that counts the number of times a given substring appears within a provided string. The function should be case-sensitive and should not count overlapping occurrences. **Function Signature**: ```python def substring_count(s: str, sub: str) -> int: pass ``` # Input * `s` (str): The string in which to search for the substring. It can be empty or contain any ASCII characters. * `sub` (str): The substring to count occurrences of. It can be empty or contain any ASCII characters. # Output * `int`: The number of times the substring `sub` appears in the string `s`. # Constraints * The function should raise a ValueError if either `s` or `sub` is not a string. * The function should handle empty strings correctly: an empty `sub` should return a count of zero. # Example ```python print(substring_count(\\"hello world\\", \\"o\\")) # Output: 2 print(substring_count(\\"hello world\\", \\"hello\\")) # Output: 1 print(substring_count(\\"hello world\\", \\"world\\")) # Output: 1 print(substring_count(\\"hello world\\", \\"lo\\")) # Output: 1 print(substring_count(\\"hello world\\", \\"l\\")) # Output: 3 print(substring_count(\\"hello world\\", \\"el\\")) # Output: 1 print(substring_count(\\"ababababa\\", \\"aba\\")) # Output: 2 print(substring_count(\\"abcdefg\\", \\"xyz\\")) # Output: 0 print(substring_count(\\"aaaaa\\", \\"aa\\")) # Output: 2 ``` # Additional Requirements 1. Ensure your function handles typical edge cases: empty strings, substrings that do not exist within the string, very long and very short strings and substrings. 2. Efficient implementation is encouraged, though clear and correct functionality is paramount. # Hints * Consider using string methods or regular expressions for counting occurrences. * Understand how to handle non-overlapping occurrences in strings.","solution":"def substring_count(s: str, sub: str) -> int: Returns the number of non-overlapping occurrences of sub in s. if not isinstance(s, str) or not isinstance(sub, str): raise ValueError(\\"Both s and sub should be strings\\") if not sub: return 0 count = 0 start = 0 while True: start = s.find(sub, start) if start == -1: break count += 1 start += len(sub) # Move start index to the end of the current match return count"},{"question":"# Scenario You need to implement a caching mechanism to optimize repeated computations in a dynamic programming algorithm. The goal is to create a memoization function decorator that can be applied to recursive functions to store and reuse previously computed results, thus improving efficiency. # Requirements 1. **Implementation of Memoization Decorator** - Write a decorator `memoize` that can be applied to any function to cache its computed results. - The decorator should store the results in a dictionary using the function arguments as keys. - The decorated function should return cached results for previously seen arguments instead of recomputing them. # Input - Any recursive function where caching of results would improve performance. # Output - Optimized function with caching capabilities. # Constraints - The function arguments will be hashable. - Test functions will not have more than 2 arguments. # Function Signature ```python def memoize(func): def wrapper(*args): pass return wrapper ``` # Example Usage ```python >>> @memoize ... def fibonacci(n): ... if n <= 1: ... return n ... else: ... return fibonacci(n-1) + fibonacci(n-2) >>> fibonacci(10) 55 >>> fibonacci(50) 12586269025 >>> @memoize ... def gcd(a, b): ... if b == 0: ... return a ... else: ... return gcd(b, a % b) >>> gcd(48, 18) 6 >>> gcd(1071, 462) 21 ``` # Instructions 1. **Caching**: Ensure that the decorator correctly caches function results using the arguments as keys. 2. **Decorator Usage**: The memoization decorator should be reusable with any recursive function where memoization can enhance performance.","solution":"from functools import wraps def memoize(func): cache = {} @wraps(func) def wrapper(*args): if args in cache: return cache[args] result = func(*args) cache[args] = result return result return wrapper"},{"question":"# Task: Graph Traversal using Depth-First Search Context: A startup company is developing a tool for analyzing social network data. The tool needs to efficiently traverse user relationships represented as a graph in order to identify connected groups of users. The company has decided to use Depth-First Search (DFS) to explore the network. Problem: Implement the Depth-First Search (DFS) algorithm in a graph structure to identify and return all connected components of the graph. Your task is to build the `Graph` class and implement DFS to explore the graph. Requirements: - **Key Functionality**: - Create a `Graph` class that uses an adjacency list representation. - Implement the DFS functionality to identify and return all connected components in the graph. - Each connected component should be a list of vertices. - **Input/Output**: ```python class Graph: def __init__(self, vertices: int) -> None def add_edge(self, v: int, w: int) -> None # Adds an edge between vertices v and w def get_connected_components(self) -> List[List[int]] # Returns a list of connected components ``` - **Constraints**: - Minimum number of vertices: `2` - Vertices are zero-indexed integers: `[0, vertices-1]` - **Performance Expectations**: - Average-case time complexity O(V + E) for DFS traversal, where `V` is the number of vertices and `E` is the number of edges. Function Signatures: You need to define the following: ```python def __init__(self, vertices: int) -> None: def add_edge(self, v: int, w: int) -> None: def _dfs(self, v: int, visited: List[bool], component: List[int]) -> None: def get_connected_components(self) -> List[List[int]]: ``` Example: ```python # Create a graph with 5 vertices graph = Graph(5) # Add edges to the graph graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(3, 4) # Get all connected components connected_components = graph.get_connected_components() print(connected_components) # Output: [[0, 1, 2], [3, 4]] ``` Implement the `Graph` class and the DFS algorithm to explore and return all connected components.","solution":"from typing import List class Graph: def __init__(self, vertices: int) -> None: self.vertices = vertices self.adj_list = [[] for _ in range(vertices)] def add_edge(self, v: int, w: int) -> None: self.adj_list[v].append(w) self.adj_list[w].append(v) def _dfs(self, v: int, visited: List[bool], component: List[int]) -> None: visited[v] = True component.append(v) for neighbor in self.adj_list[v]: if not visited[neighbor]: self._dfs(neighbor, visited, component) def get_connected_components(self) -> List[List[int]]: visited = [False] * self.vertices components = [] for v in range(self.vertices): if not visited[v]: component = [] self._dfs(v, visited, component) components.append(component) return components"},{"question":"# Task Description You are given two sorted linked lists represented by the `ListNode` class. Implement a function `merge_alternate(l1: ListNode | None, l2: ListNode | None) -> ListNode | None` that merges the two linked lists by alternating elements from each list. If one list runs out of elements, append the remaining elements from the other list to the end of the merged list. # Function Signature ```python def merge_alternate(l1: ListNode | None, l2: ListNode | None) -> ListNode | None: ``` # Class Definition ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Input - **l1**: The head of the first sorted linked list (ListNode | None). If the list is empty, its head is None. - **l2**: The head of the second sorted linked list (ListNode | None). If the list is empty, its head is None. # Output - Returns the head of a new linked list which is formed by alternating elements of `l1` and `l2`. # Constraints - The linked lists have at most `10^4` elements each. # Example Given the linked lists: - list1: `1 -> 3 -> 5` - list2: `2 -> 4 -> 6` The merged result should be: - `1 -> 2 -> 3 -> 4 -> 5 -> 6` If the linked lists are: - list1: `7 -> 9` - list2: `8 -> 10 -> 11 -> 12` The merged result should be: - `7 -> 8 -> 9 -> 10 -> 11 -> 12` # Notes - Thoroughly test cases where one or both lists are initially empty. - Consider all edge cases. # Implementation Implement the function `merge_alternate` in Python, ensuring it handles large lists efficiently and covers all discussed edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_alternate(l1: ListNode | None, l2: ListNode | None) -> ListNode | None: # Dummy node to serve as the start of the merged list dummy = ListNode() current = dummy # Alternate merging nodes from l1 and l2 while l1 and l2: current.next = l1 l1 = l1.next current = current.next current.next = l2 l2 = l2.next current = current.next # Attach the remaining nodes from l1 or l2 if l1: current.next = l1 elif l2: current.next = l2 return dummy.next"},{"question":"# Advanced Problem: Implementing a Multithreaded Web Crawler Scenario You are to design a multithreaded web crawler that can crawl a list of URLs concurrently. The crawler should avoid crawling the same URL multiple times and should handle potential errors such as timeouts or HTTP errors gracefully. # Problem Statement Write a Python function `multithreaded_web_crawler(urls, num_threads)` that crawls a list of URLs concurrently using multiple threads. Requirements: 1. **Input**: - `urls`: a list of strings where each string is a URL to be crawled. - `num_threads`: an integer representing the number of threads to use for crawling. 2. **Output**: - The function should return a dictionary where keys are URLs and values are the HTTP response statuses (e.g., 200 for OK, 404 for Not Found). 3. **Constraints**: - Ensure that each URL is crawled only once. - The implementation must use Python\'s `threading` or `concurrent.futures` modules to handle concurrent execution of URL fetching tasks. - Handle errors gracefully, including retries for transient errors and skipping URLs that repeatedly fail. 4. **Performance**: - Optimize the implementation to minimize the total crawling time. # Example: ```python urls = [ \\"http://example.com\\", \\"http://example.org\\", \\"http://example.net\\" ] result = multithreaded_web_crawler(urls, 3) ``` This call should crawl the three URLs using 3 threads and return a dictionary with the URLs as keys and their HTTP statuses as values. # Additional Notes: - Use appropriate synchronization mechanisms to avoid race conditions when accessing shared resources. - Provide sufficient logging to track the progress of the crawling process. - Make sure to consider the impact of robots.txt and respect any crawling constraints specified by websites.","solution":"import threading from concurrent.futures import ThreadPoolExecutor, as_completed import requests def fetch_url(url): try: response = requests.get(url, timeout=5) return url, response.status_code except requests.RequestException as e: return url, None def multithreaded_web_crawler(urls, num_threads): results = {} visited_urls = set() lock = threading.Lock() def worker(url): nonlocal lock, results, visited_urls if url not in visited_urls: with lock: visited_urls.add(url) result = fetch_url(url) with lock: results[url] = result[1] with ThreadPoolExecutor(max_workers=num_threads) as executor: future_to_url = {executor.submit(worker, url): url for url in urls} for future in as_completed(future_to_url): future.result() return results"},{"question":"# Problem Statement You are tasked with developing a utility for processing election results from a voting database. Each candidate\'s votes are represented in a list of integers, where each integer denotes the number of votes they received in a given district. Your goal is to determine the candidate with the highest total votes across all districts. Write a function that takes a list of lists containing the vote counts for each candidate and returns the index of the candidate with the highest total votes. # Function Signature ```python def find_winner(votes: List[List[int]]) -> int: pass ``` # Input * A list of lists, `votes`, where each inner list contains integers representing the number of votes that candidate received in each district. It\'s guaranteed that there will be at least one candidate and one district, and at most 100 candidates with 1000 districts each. # Output * An integer representing the index of the candidate with the highest total votes. If there is a tie, return the index of the candidate who appears first in the input list. # Constraints * Each inner list of integers will have the same length. * If `votes` is `[]`, return `-1`. # Examples ```python >>> find_winner([[10, 20, 30], [15, 25, 35]]) 1 >>> find_winner([[5, 5], [8, 7], [3, 4]]) 1 >>> find_winner([]) -1 ``` # Notes 1. The function should handle ties by returning the first candidate in the event of a tie. 2. You should consider the efficiency of your solution as the number of candidates and districts can be large.","solution":"from typing import List def find_winner(votes: List[List[int]]) -> int: Returns the index of the candidate with the highest total votes. if not votes: return -1 max_votes_index = 0 max_votes = sum(votes[0]) for i in range(1, len(votes)): total_votes_i = sum(votes[i]) if total_votes_i > max_votes: max_votes = total_votes_i max_votes_index = i return max_votes_index"},{"question":"# Problem Statement You are given a grid of dimensions `m x n` representing a garden. Each cell in the grid can either be empty soil (\'0\') or a flower (\'1\'). Flowers can spread their seeds to the adjacent cells in four directions: up, down, left, and right. If an empty soil cell has at least two or more neighboring cells with flowers, it will also become a flower in the next time unit. Write a function `timeToBloom(m: int, n: int, garden: List[List[int]]) -> int` that returns the minimum number of time units required for the entire garden to be covered with flowers. If it is impossible for the entire garden to bloom, return `-1`. # Input Format - Two integers `m` and `n` representing the dimensions of the grid. - A 2D list `garden` with `m` rows and `n` columns, where each element is either \'0\' or \'1\'. # Output Format - A single integer representing the minimum number of time units required for the entire garden to bloom, or `-1` if it is impossible. # Examples ```python >>> timeToBloom(3, 3, [[0, 1, 0], [0, 0, 1], [1, 0, 0]]) 2 >>> timeToBloom(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> timeToBloom(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) -1 ``` # Constraints - The values of `m` and `n` are such that `1 ≤ m, n ≤ 100`. - The elements of the 2D array `garden` are either `0` or `1`. - The function should handle edge cases efficiently and ensure that the algorithm performs optimally for the given constraints. # Guidelines - Use a queue to simulate the spread of flowers from their initial positions. - Track the time units required and implement a breadth-first search (BFS) to explore all possible bloom states. - If after the maximum iterations there are still empty cells, return `-1`.","solution":"from typing import List, Tuple from collections import deque def timeToBloom(m: int, n: int, garden: List[List[int]]) -> int: if not garden or not garden[0]: return -1 queue = deque() flower_count = 0 for i in range(m): for j in range(n): if garden[i][j] == 1: queue.append((i, j, 0)) # add initial flowers to the queue flower_count += 1 if flower_count == m * n: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_time = 0 while queue: i, j, time = queue.popleft() for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < m and 0 <= nj < n and garden[ni][nj] == 0: # Check if there are at least two neighboring flowers neighbors = sum(1 for di_, dj_ in directions if 0 <= ni + di_ < m and 0 <= nj + dj_ < n and garden[ni + di_][nj + dj_] == 1) if neighbors >= 2: garden[ni][nj] = 1 queue.append((ni, nj, time + 1)) max_time = max(max_time, time + 1) for row in garden: if 0 in row: return -1 return max_time"},{"question":"# Problem: Image Blurring Using Gaussian Kernel Objective: Implement the class `GaussianBlur` to apply Gaussian blur to a given grayscale image. The class should follow the provided interface and method structure adhering to the complexity constraints. Function Signature: ```python class GaussianBlur: def __init__(self, sigma, image): Initialize the GaussianBlur object with a standard deviation for the Gaussian kernel and the image (2D list of integers). pass def __generate_kernel(self): Generate the Gaussian kernel matrix based on the given sigma. pass def __apply_blur(self): Apply the Gaussian blur to the input image using the kernel. pass def get_blurred_image(self): Return the blurred image as a 2D list of integers. pass def __str__(self): Return the string representation of the original and blurred images. pass ``` # Input: 1. **sigma**: Float value representing the standard deviation of the Gaussian distribution. Controls the amount of blurring. 2. **image**: 2D list (list of lists) of integers representing the grayscale pixel values (0-255) of the image. # Output: - A 2D list (list of lists) of integers representing the blurred grayscale image. # Constraints: - Input image dimensions may range up to (500 times 500). - Pixel values are integers within the range [0, 255]. # Requirements: 1. Your implementation must correctly generate the Gaussian kernel using the supplied sigma. 2. The blurring process should correctly convolve the image with the generated kernel. 3. The implementation should handle edge cases such as image boundaries properly, potentially using edge padding or other techniques. 4. The time complexity should be managed efficiently to process large images. # Examples: ```python # Example 1: sigma = 1.0 image = [ [200, 200, 200, 200], [200, 200, 200, 200], [200, 200, 200, 200], [200, 200, 200, 200] ] blur = GaussianBlur(sigma, image) print(blur.get_blurred_image()) # Expected: Blurred values close to [200, 200, 200, 200] due to uniform initial image # Example 2: sigma = 2.0 image = [ [0, 0, 0, 0], [0, 255, 255, 0], [0, 255, 255, 0], [0, 0, 0, 0] ] blur = GaussianBlur(sigma, image) print(blur.get_blurred_image()) # Expected: Blurred values with smooth transitions where 255 are concentrated in center. ``` Implement the `GaussianBlur` class in Python as per the function signature provided above to solve the problem while maintaining the expected time and space complexity.","solution":"import math import numpy as np from scipy.ndimage import gaussian_filter class GaussianBlur: def __init__(self, sigma, image): self.sigma = sigma self.image = np.array(image) self.kernel = self.__generate_kernel() self.blurred_image = self.__apply_blur() def __generate_kernel(self): Generate the Gaussian kernel matrix based on the given sigma. size = int(2 * (math.ceil(3 * self.sigma)) + 1) kernel = np.zeros((size, size)) center = size // 2 sum_val = 0 for i in range(size): for j in range(size): x, y = i - center, j - center kernel[i, j] = math.exp(-(x**2 + y**2) / (2 * self.sigma**2)) sum_val += kernel[i, j] kernel /= sum_val return kernel def __apply_blur(self): Apply the Gaussian blur to the input image using the kernel. return gaussian_filter(self.image, sigma=self.sigma) def get_blurred_image(self): Return the blurred image as a 2D list of integers. return self.blurred_image.tolist() def __str__(self): Return the string representation of the original and blurred images. return f\\"Original Image:n{self.image}nBlurred Image:n{self.blurred_image}\\""},{"question":"# Reversing Words in a String Objective Write a function to reverse the words in a given string. You need to implement both an iterative solution and a stack-based solution to achieve this. Description A word is defined as a sequence of characters without any spaces. Given a string `s`, you need to reverse the order of words in the string. The function should remove any leading, trailing, and extra spaces between words before reversing. # Function Signature ```python def iterative_reverse_words(s: str) -> str: pass def stack_reverse_words(s: str) -> str: pass ``` Input - `s`: A string containing words separated by spaces. # Constraints - The length of the input string `s` will not exceed 1000. - The string may contain leading, trailing, or multiple spaces between words. Output - Return a string with words reversed and single spaces between words. Examples 1. Given: - s = \\"the sky is blue\\" - Output: `\\"blue is sky the\\"` 2. Given: - s = \\" hello world! \\" - Output: `\\"world! hello\\"` 3. Given: - s = \\"a good example\\" - Output: `\\"example good a\\"` 4. Given: - s = \\" Bob Loves Alice \\" - Output: `\\"Alice Loves Bob\\"` Detailed Requirements 1. Implement the `iterative_reverse_words` function using iteration with the specified signature. 2. Implement the `stack_reverse_words` function using a stack-based approach with the specified signature. 3. Ensure to remove any extra spaces between words before reversing. 4. Conduct thorough testing with various edge cases such as empty strings, strings with only spaces, and strings with multiple spaces between words. 5. Analyze the performance of both methods with regards to time and space complexity.","solution":"def iterative_reverse_words(s: str) -> str: Reverses the words in a given string using an iterative approach. # Split the string into words, filtering out any extra whitespace words = s.strip().split() # Reverse the list of words reversed_words = words[::-1] # Join the reversed list of words with a single space return \' \'.join(reversed_words) def stack_reverse_words(s: str) -> str: Reverses the words in a given string using a stack-based approach. words = s.strip().split() stack = [] for word in words: stack.append(word) reversed_words = [] while stack: reversed_words.append(stack.pop()) return \' \'.join(reversed_words)"},{"question":"**Context**: You are given a list of email addresses. Your task is to extract and count unique domains from these email addresses. The domain of an email is the part after the \'@\' character. # Task: Implement a function `count_unique_domains(emails: List[str]) -> int` that takes in a list of email addresses and returns the count of unique domains. # Detailed Steps: 1. Extract the domain from each email address. 2. Store unique domains in a suitable data structure. 3. Return the count of these unique domains. # Input: * `emails`: A list of strings where each string is an email address. # Output: * Returns an integer representing the count of unique domains. # Constraints: * The list `emails` contains a maximum of 10,000 email addresses. * Each email address is valid and follows the standard format (e.g., `username@domain.com`). # Example: ```python def count_unique_domains(emails: List[str]) -> int: # Your implementation here # Usage email_list = [\\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\"] result = count_unique_domains(email_list) print(result) # Expected output: 2 ``` # Performance Requirements: * Your solution should be efficient in terms of both time and space complexity, capable of handling the maximum input size within reasonable limits.","solution":"def count_unique_domains(emails): Returns the count of unique domains in the given list of email addresses. # Create a set to store unique domains unique_domains = set() # Extract domains from each email and add to the set for email in emails: domain = email.split(\'@\')[1] unique_domains.add(domain) # Return the count of unique domains return len(unique_domains)"},{"question":"# Spam Email Classifier using Natural Language Processing (NLP) Objective You need to implement and train a Natural Language Processing (NLP) model to classify email messages as spam or not spam. Instructions 1. Download the spam email dataset from the provided link. 2. Organize the dataset into training and test sets: - Split the dataset into 80% training and 20% test sets. 3. Preprocess the email text using techniques such as tokenization, removing stop words, and stemming. 4. Implement a classifier using a suitable machine learning algorithm like Naive Bayes, SVM, or a neural network. 5. Train your model on the training set. 6. Evaluate your model on the test set. 7. Save your trained model and use it to make predictions on new email texts. Requirements 1. **Input**: Your model should accept raw text emails. 2. **Output**: Your model should output a binary prediction: 0 for not spam, 1 for spam. 3. **Constraints**: - Use an appropriate text preprocessing pipeline. - Use a bag-of-words model or TF-IDF for feature extraction. - Train for an adequate number of epochs (if using a neural network) or with suitable hyperparameters (for other classifiers). 4. **Performance**: - Aim for an accuracy of at least 90% on your test set. - Use cross-validation to tune the hyperparameters. Example After training your model, load and predict on a new email text: ```python import joblib from sklearn.feature_extraction.text import TfidfVectorizer # Load the saved model and the vectorizer model = joblib.load(\'spam_classifier.pkl\') vectorizer = joblib.load(\'tfidf_vectorizer.pkl\') # Sample text for prediction new_email = [\\"Congratulations! You\'ve won a 1000 Walmart gift card. Click here to claim your prize.\\"] # Preprocess and vectorize the text new_email_vectorized = vectorizer.transform(new_email) # Make prediction result = model.predict(new_email_vectorized) if result[0] == 0: prediction = \'Not Spam\' else: prediction = \'Spam\' print(prediction) ``` Hints - Consider using libraries such as NLTK or spaCy for text preprocessing. - Use the `CountVectorizer` or `TfidfVectorizer` from Scikit-learn for feature extraction. - Pay close attention to imbalanced classes and consider using techniques like oversampling or class weights.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB from sklearn.pipeline import make_pipeline from sklearn.metrics import accuracy_score import joblib def spam_email_classifier_pipeline(): # Load the dataset (assuming it\'s a CSV file with \'text\' and \'label\' columns) url = \\"https://raw.githubusercontent.com/justmarkham/pycon-2016-tutorial/master/data/sms.tsv\\" data = pd.read_csv(url, delimiter=\'t\', header=None, names=[\'label\', \'text\']) # Encode labels (ham: 0, spam: 1) data[\'label\'] = data[\'label\'].map({\'ham\': 0, \'spam\': 1}) # Split the data into training and test sets X_train, X_test, y_train, y_test = train_test_split(data[\'text\'], data[\'label\'], test_size=0.2, random_state=42) # Create a pipeline with a TfidfVectorizer and a MultinomialNB classifier model = make_pipeline(TfidfVectorizer(stop_words=\'english\'), MultinomialNB()) # Train the model model.fit(X_train, y_train) # Save the trained model and the vectorizer joblib.dump(model, \'spam_classifier.pkl\') # Evaluate and print the model accuracy y_pred = model.predict(X_test) accuracy = accuracy_score(y_test, y_pred) print(f\'Model Accuracy: {accuracy * 100:.2f}%\') return model spam_email_classifier_pipeline()"},{"question":"# Coding Assessment Question Context: Sorting is one of the essential operations in computer science used in data manipulation and algorithms. Merge Sort is a popular divide-and-conquer algorithm that often requires an auxiliary space to hold the merged results temporarily. Task: Write a function `merge_sort(arr)` that performs a Merge Sort on a given list of integers `arr` and returns the sorted list. Requirements: 1. Implement a function `merge_sort(arr: list) -> list`. 2. The function should: - Handle the sorting in a recursive manner. - Ensure the original array is not modified (sorting should be done in a function scope without side effects on the input). 3. Utilize the Merge Sort algorithm\'s logic to ensure the list is sorted correctly. 4. Optimize for the expected average-case complexity of Merge Sort (O(n log n)). Input: - `arr` (list): A list of integers that need to be sorted. Output: - Returns the sorted list. Constraints: - The function should work for arrays of length up to 10^6. - The input list elements are in the range of -10^6 to 10^6. - The function must handle lists with zero or more elements. Performance Expectations: - The function should efficiently sort large lists as per Merge Sort\'s time complexity. Example: ```python >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([1, 20, 6, 4, 5]) [1, 4, 5, 6, 20] >>> merge_sort([]) [] >>> merge_sort([-1, -3, -2]) [-3, -2, -1] ``` Edge Cases: - An empty list should return an empty list. - Lists containing a single element should return the same list. - Lists with negative values should be sorted in non-decreasing order. Implement the function `merge_sort(arr)` and ensure it adheres to the constraints and requirements provided.","solution":"def merge_sort(arr): if len(arr) <= 1: return arr def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"**Database System Performance Analysis** As a data engineer, you are given the task to analyze and improve the performance of a relational database system. One of the key aspects you need to examine is the efficiency of an indexing strategy on retrieving specific records from a large dataset. # Input Format: * A list of dictionaries, where each dictionary represents a record in the database with the keys being the column names and the values being the corresponding values for those columns. ``` analyze_performance(records) ``` # Output Format: * A list of tuples, where each tuple contains a column name and the number of times it was used as a key in indexing. # Constraints: * Each dictionary in the records list contains non-null values. * The keys in the dictionaries are strings representing column names. * The values in the dictionaries are either integers or strings. * The number of records will be at least 10,000. * Columns can include, but are not limited to: `id`, `name`, `age`, `email`, `address`, `registration_date`. # Example: ```python records = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"email\\": \\"alice@example.com\\", \\"address\\": \\"123 Main St\\", \\"registration_date\\": \\"2021-03-01\\"}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 24, \\"email\\": \\"bob@example.com\\", \\"address\\": \\"456 Elm St\\", \\"registration_date\\": \\"2020-09-15\\"}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35, \\"email\\": \\"charlie@example.com\\", \\"address\\": \\"789 Oak St\\", \\"registration_date\\": \\"2019-11-08\\"}, {\\"id\\": 4, \\"name\\": \\"Diana\\", \\"age\\": 28, \\"email\\": \\"diana@example.com\\", \\"address\\": \\"101 Pine St\\", \\"registration_date\\": \\"2022-05-20\\"} # Additional records... ] print(analyze_performance(records)) # Output: [(\'id\', 1), (\'name\', 1), (\'age\', 1), (\'email\', 1), (\'address\', 1), (\'registration_date\', 1)] ``` # Performance Requirements: * The function should handle a large dataset efficiently, with an overall time complexity of O(n), where n is the number of records. # Scenario Imagine you are tasked with advising a client on optimal indexing strategies for their database system. By analyzing the column usage patterns, you can suggest which columns should be indexed to improve the query performance. Implement the function `analyze_performance` to meet the requirements and satisfy the above test cases.","solution":"def analyze_performance(records): Analyzes and counts the occurrences of column names in the provided records. Parameters: records (list): A list of dictionaries representing the database records. Returns: List[Tuple]: A list of tuples where each tuple contains a column name and the number of times it was used as a key in the records. if not records: return [] column_occurrences = {} # Iterate through each record for record in records: # Iterate through each key in the record for key in record.keys(): # Increment the count for the column if key in column_occurrences: column_occurrences[key] += 1 else: column_occurrences[key] = 1 # Create a list of tuples from the dictionary result = [(column, count) for column, count in column_occurrences.items()] return result"},{"question":"Problem Statement You are given a string `s` and a dictionary of words `wordDict`. Add spaces in `s` to construct a sentence where each word is a valid word in `wordDict`. Return all such possible sentences. Note that the same word in the dictionary may be reused multiple times in the segmentation. # Function Signature ```python def word_break(s: str, wordDict: List[str]) -> List[str]: ``` # Input * `s`: A non-empty string consisting of lowercase English letters. * `wordDict`: A list of non-empty words representing the dictionary. # Output * Returns a list of all possible sentences that can be formed by adding spaces in `s` so that each word is a valid word in `wordDict`. # Constraints * The input string `s` will not be longer than 20 characters. * All words in `wordDict` are distinct. * The length of `wordDict` will not exceed 1000 words. * Each word in `wordDict` is a non-empty string of at most length 10. # Example ```python s = \\"catsanddog\\" wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] print(word_break(s, wordDict)) # Output: [\\"cats and dog\\", \\"cat sand dog\\"] ``` # Notes * You can assume that `wordDict` contains all necessary words to form at least one valid sentence. * Optimize the solution to handle the constraints efficiently. * Recursive depth-first search with memoization could be helpful in solving this problem.","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> List[str]: def dfs(s): if s in memo: return memo[s] if not s: return [\\"\\"] res = [] for word in wordDict: if s.startswith(word): sublist = dfs(s[len(word):]) for sub in sublist: res.append(word + (\\"\\" if sub == \\"\\" else \\" \\" + sub)) memo[s] = res return res wordDict = set(wordDict) memo = {} return dfs(s)"},{"question":"# Coding Assessment Question Context: You are tasked with implementing a simple rate limiter for an API endpoint to prevent abuse by limiting the number of requests a user can make within a specified time window. Task: Write a Python class `RateLimiter` that enforces a rate limit of `max_requests` requests within `time_window` seconds for each user. The class should provide a method `is_request_allowed(user_id: str) -> bool` that returns whether a new request from `user_id` within the current window is allowed. Implementation Steps: 1. Initialize the RateLimiter with `max_requests` and `time_window`. 2. Maintain a data structure to track request timestamps for each user. 3. In the `is_request_allowed` method, check if the current time is within the limit for the given user and update the timestamps accordingly. 4. Return `True` if the request is allowed, `False` otherwise. Input Format: - `user_id`: A string representing the unique ID of the user making the request. Output Format: - Return a boolean: `True` if the request is allowed, `False` otherwise. Constraints: - Assume the number of unique users will not exceed 10,000. - Assume `user_id` strings are unique and between 1 and 100 characters in length. - The `max_requests` integer will be greater than 0. - The `time_window` integer will be greater than 0 (in seconds). - Requests are processed in real-time, and the method can be called multiple times with small intervals. Performance Requirements: - The solution should efficiently handle the tracking of request timestamps and ensure the rate limit is correctly enforced. - The space complexity should be O(u), where u is the number of unique users. Example: ```python import time rate_limiter = RateLimiter(max_requests=3, time_window=10) # Assuming time.time() returns 0 at the start assert rate_limiter.is_request_allowed(\\"user1\\") == True # Request 1 assert rate_limiter.is_request_allowed(\\"user1\\") == True # Request 2 assert rate_limiter.is_request_allowed(\\"user1\\") == True # Request 3 assert rate_limiter.is_request_allowed(\\"user1\\") == False # Request 4 (Not allowed, limit reached) time.sleep(5) assert rate_limiter.is_request_allowed(\\"user1\\") == False # Request 5 (Not allowed, still within window) time.sleep(5) assert rate_limiter.is_request_allowed(\\"user1\\") == True # Request 6 (Allowed, new window) ``` Note: - You may use `time.time()` to get the current time in seconds. - Ensure the class handles concurrent requests in a thread-safe manner (though explicit thread handling is not required for this implementation). Additional Challenge (Optional): Consider optimizing the data structure to avoid memory bloat as the number of requests grows.","solution":"import time from collections import deque from typing import Dict class RateLimiter: def __init__(self, max_requests: int, time_window: int): self.max_requests = max_requests self.time_window = time_window self.user_requests: Dict[str, deque] = {} def is_request_allowed(self, user_id: str) -> bool: current_time = time.time() if user_id not in self.user_requests: self.user_requests[user_id] = deque() user_queue = self.user_requests[user_id] # Remove outdated requests while user_queue and user_queue[0] <= current_time - self.time_window: user_queue.popleft() if len(user_queue) < self.max_requests: user_queue.append(current_time) return True else: return False"},{"question":"# Stack Min Tracking The following is a coding challenge to assess your understanding of stack data structures and their application in problem-solving scenarios. You are required to enhance a basic stack data structure with an additional capability to track the minimum element in the stack efficiently. # Scenario Alice is often working with a stack data structure in her programming tasks. Recently, she faces the need to track the minimum element in the stack at any given time, alongside the usual stack operations (push, pop, and top). She wants an optimized solution that provides these operations in constant time. # Task Write a class `MinStack` that supports the following functionalities: - `push(x)`: Push element `x` onto the stack. - `pop()`: Removes the element on the top of the stack. - `top()`: Get the top element. - `getMin()`: Retrieve the minimum element in the stack. # Class Signature ```python class MinStack: def __init__(self): pass def push(self, x: int) -> None: pass def pop(self) -> None: pass def top(self) -> int: pass def getMin(self) -> int: pass ``` # Constraints - All operations must be performed in constant time, O(1). - The stack will only contain integers. - It is guaranteed that the stack will have at least one element when `pop`, `top`, or `getMin` is called. # Example **Input** ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) assert min_stack.getMin() == -3 min_stack.pop() assert min_stack.top() == 0 assert min_stack.getMin() == -2 ``` **Output** ```python -3 0 -2 ``` You are required to implement the `MinStack` class such that all the provided examples and constraints are met.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] return None def getMin(self) -> int: if self.min_stack: return self.min_stack[-1] return None"},{"question":"# Coding Assessment Question: Building a Basic Calculator with Operator Precedence Scenario: You are tasked with building a simple calculator as a part of an introductory toolbox for beginner programmers. The calculator should support standard mathematical operations and evaluate expressions with correct operator precedence. Problem Statement: Write a Python function to evaluate mathematical expressions passed as strings. The function should handle addition, subtraction, multiplication, division, and parentheses to override precedence. It should also manage spaces within the string and provide meaningful error messages for invalid expressions. Requirements: 1. A function: `calculate(expression: str) -> float`. 2. The expression can contain integers, floating-point numbers, and operators `+`, `-`, `*`, `/`, and parentheses `()`. 3. Handle edge cases such as division by zero, malformed expressions, and invalid characters. 4. Provide clear error messages for invalid expressions. 5. Ensure the solution handles operator precedence correctly and executes in optimal time. Input: - A string `expression` representing the mathematical expression to be evaluated. Output: - A floating-point number representing the evaluated result of the expression. Constraints: - The expression should contain only valid arithmetic operators and digits (0-9), along with spaces. - Parentheses should be used correctly to override standard operator precedence. Example: ```python expression = \\"3 + 5 * 2 / (7 - 3)\\" result = calculate(expression) print(result) # 5.5 expression = \\"(2.5 + 1.5) * 2\\" result = calculate(expression) print(result) # 8.0 ``` Additional Notes: - Consider edge cases such as empty strings, invalid expressions, and single number inputs. - Your solution should efficiently handle nested parentheses and complex arithmetic expressions. - Think about using the Shunting Yard algorithm or other relevant algorithms to manage operator precedence and parentheses. This question tests the candidate\'s ability to parse and evaluate expressions involving multiple arithmetic operations while respecting operator precedence and handling potential edge cases effectively.","solution":"def calculate(expression: str) -> float: def get_precedence(op): precedences = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} return precedences[op] if op in precedences else 0 def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': if right == 0: raise ValueError(\\"Division by zero.\\") values.append(left / right) def greater_precedence(op1, op2): return get_precedence(op1) > get_precedence(op2) def evaluate(expression): tokens = expression.replace(\'(\', \' ( \').replace(\')\', \' ) \').split() values = [] operators = [] for token in tokens: if token.isnumeric() or ((\'.\' in token) and token.replace(\'.\', \'\', 1).isdigit()): values.append(float(token)) elif token in [\'+\', \'-\', \'*\', \'/\']: while (operators and operators[-1] != \'(\' and greater_precedence(operators[-1], token)): apply_operator(operators, values) operators.append(token) elif token == \'(\': operators.append(token) elif token == \')\': while operators[-1] != \'(\': apply_operator(operators, values) operators.pop() # Remove the \'(\' from the stack else: raise ValueError(f\\"Invalid character found: {token}\\") while operators: apply_operator(operators, values) return values[0] if not expression: raise ValueError(\\"Empty expression.\\") try: return evaluate(expression) except IndexError: raise ValueError(\\"Malformed expression.\\") except ValueError as e: raise ValueError(str(e))"},{"question":"# Context You are developing a more efficient and dynamic approach to processing data logs. The log entries contain various events, each with a timestamp. Your task is to create a system that can efficiently append new log entries, retrieve events within a specific time range, and clean logs by removing entries older than a given timestamp. The implementation should ensure high performance even with an increasing number of log entries. # Task Write and optimize three functions: `add_log_entry`, `get_entries_in_range`, and `clean_old_logs`. The `add_log_entry` function appends a new event with a timestamp to the log. The `get_entries_in_range` function retrieves all events between a start and end timestamp. The `clean_old_logs` function removes all entries older than a given timestamp. # Function Signatures ```python from typing import List, Tuple from datetime import datetime def add_log_entry(log: List[Tuple[str, datetime]], event: str, timestamp: datetime) -> List[Tuple[str, datetime]]: Appends a new log entry to the log with the specified event and timestamp. Args: log (List[Tuple[str, datetime]]): The list of log entries. event (str): The event description. timestamp (datetime): The event timestamp. Returns: List[Tuple[str, datetime]]: The updated log with the new entry added. pass def get_entries_in_range(log: List[Tuple[str, datetime]], start: datetime, end: datetime) -> List[Tuple[str, datetime]]: Retrieves log entries that fall within the specified start and end timestamp range. Args: log (List[Tuple[str, datetime]]): The list of log entries. start (datetime): The start timestamp. end (datetime): The end timestamp. Returns: List[Tuple[str, datetime]]: The list of log entries within the specified range. pass def clean_old_logs(log: List[Tuple[str, datetime]], cutoff: datetime) -> List[Tuple[str, datetime]]: Removes log entries that are older than the specified cutoff timestamp. Args: log (List[Tuple[str, datetime]]): The list of log entries. cutoff (datetime): The cutoff timestamp. Returns: List[Tuple[str, datetime]]: The updated log with old entries removed. pass ``` # Constraints - The `timestamp` should be a valid `datetime` object. - All log entries are assumed to be in chronological order. - The `start`, `end`, and `cutoff` timestamps provided are also assumed to be valid `datetime` objects. - Optimize the functions for performance. # Example Usage ```python from datetime import datetime log = [ (\\"Event1\\", datetime(2023, 1, 10, 10, 0, 0)), (\\"Event2\\", datetime(2023, 1, 12, 15, 30, 0)), (\\"Event3\\", datetime(2023, 1, 15, 9, 0, 0)) ] # Adding a new log entry updated_log = add_log_entry(log, \\"Event4\\", datetime(2023, 1, 20, 11, 0, 0)) print(updated_log) # Getting entries in a date range entries = get_entries_in_range(updated_log, datetime(2023, 1, 11, 0, 0, 0), datetime(2023, 1, 16, 0, 0, 0)) print(entries) # Should output: [(\\"Event2\\", datetime(2023, 1, 12, 15, 30, 0)), (\\"Event3\\", datetime(2023, 1, 15, 9, 0, 0))] # Cleaning old log entries cleaned_log = clean_old_logs(updated_log, datetime(2023, 1, 12, 0, 0, 0)) print(cleaned_log) # Should output: [(\\"Event2\\", datetime(2023, 1, 12, 15, 30, 0)), (\\"Event3\\", datetime(2023, 1, 15, 9, 0, 0)), (\\"Event4\\", datetime(2023, 1, 20, 11, 0, 0))] ``` # Objective - Implement and optimize the system for adding, retrieving, and cleaning log entries, ensuring that performance is maintained even as the log grows. - Ensure your functions can handle the edge cases, like when the log is empty or the specified range has no entries.","solution":"from typing import List, Tuple from datetime import datetime def add_log_entry(log: List[Tuple[str, datetime]], event: str, timestamp: datetime) -> List[Tuple[str, datetime]]: Appends a new log entry to the log with the specified event and timestamp. Args: log (List[Tuple[str, datetime]]): The list of log entries. event (str): The event description. timestamp (datetime): The event timestamp. Returns: List[Tuple[str, datetime]]: The updated log with the new entry added. log.append((event, timestamp)) return log def get_entries_in_range(log: List[Tuple[str, datetime]], start: datetime, end: datetime) -> List[Tuple[str, datetime]]: Retrieves log entries that fall within the specified start and end timestamp range. Args: log (List[Tuple[str, datetime]]): The list of log entries. start (datetime): The start timestamp. end (datetime): The end timestamp. Returns: List[Tuple[str, datetime]]: The list of log entries within the specified range. return [entry for entry in log if start <= entry[1] <= end] def clean_old_logs(log: List[Tuple[str, datetime]], cutoff: datetime) -> List[Tuple[str, datetime]]: Removes log entries that are older than the specified cutoff timestamp. Args: log (List[Tuple[str, datetime]]): The list of log entries. cutoff (datetime): The cutoff timestamp. Returns: List[Tuple[str, datetime]]: The updated log with old entries removed. return [entry for entry in log if entry[1] >= cutoff]"},{"question":"# Question Overview You are given a set of tickets, where each ticket has a unique ID and a priority level. The priority level is represented by an integer, where a smaller number indicates a higher priority. Your task is to design an algorithm that will continuously yield tickets based on their priority level in an efficient manner. # Problem Statement **Function Signature**: ```python def prioritized_tickets(tickets: List[Tuple[int, int]]) -> Generator[int, None, None]: pass ``` **Input**: - A list of tuples `tickets`, where each tuple comprises: - An integer `ID` that uniquely identifies a ticket. - An integer `priority` representing the ticket\'s priority level. **Output**: - A generator that yields ticket IDs based on their priority levels, starting from the highest priority (smallest integer) to the lowest priority (highest integer). # Constraints - The function should handle lists containing up to `10^5` tickets. - The tickets are guaranteed to have unique IDs but may have duplicate priorities. - Ensure your solution handles the edge case of an empty list gracefully. # Hints - Consider using an appropriate data structure to manage the priority of tickets efficiently. - Aim for an overall time complexity in the range of (O(n log n)) due to sorting or (O(n log k)) with data structures optimized for retrieval of the smallest elements. # Additional Requirements - Include meaningful comments in your code explaining each step of the logic. - Ensure your solution passes the following test cases: ```python assert list(prioritized_tickets([])) == [] assert list(prioritized_tickets([(1, 5), (2, 2), (3, 3), (4, 1)])) == [4, 2, 3, 1] assert list(prioritized_tickets([(1, 10), (2, 10), (3, 10), (4, 4)])) == [4, 1, 2, 3] assert list(prioritized_tickets([(1, 5), (2, 7), (3, 6), (4, 5), (5, 1)])) == [5, 1, 4, 3, 2] assert list(prioritized_tickets([(3, 0), (4, 2), (1, 1), (2, 3)])) == [3, 1, 4, 2] ``` # Performance Testing - Your solution should efficiently handle up to `10^5` tickets within a reasonable time frame.","solution":"from typing import List, Tuple, Generator import heapq def prioritized_tickets(tickets: List[Tuple[int, int]]) -> Generator[int, None, None]: This function yields ticket IDs based on their priority levels, starting from the highest priority (smallest integer) to the lowest priority (largest integer). Parameters: tickets (List[Tuple[int, int]]): A list of tuples where each tuple contains an ID and a priority level. Yields: Generator[int, None, None]: A generator that yields the IDs based on their priority. # Create a min-heap from the given list of tickets. The heap is sorted by priority. heap = [(priority, ticket_id) for ticket_id, priority in tickets] heapq.heapify(heap) # Continuously pop the smallest element from the heap until it\'s empty. while heap: _, ticket_id = heapq.heappop(heap) yield ticket_id"},{"question":"# Question: - Balanced Binary Search Tree Construction from Sorted Array You are tasked with creating a balanced Binary Search Tree (BST) from a sorted array. This problem assesses your understanding of tree data structures and recursive algorithms. The function should create a BST such that the tree is height-balanced, meaning the depths of the two subtrees of every node never differ by more than 1. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums: list[int]) -> TreeNode: pass ``` # Input: 1. `nums` (list[int]): A sorted list of integers. # Output: 1. The root node of the Binary Search Tree (BST). # Constraints: 1. `nums` contains between 1 and 10^4 elements. # Example Usage: ```python bst_root = sorted_array_to_bst([-10, -3, 0, 5, 9]) ``` The created BST looks like this: ``` 0 / -3 9 / / -10 5 ``` # Performance Requirements: 1. The function should run in O(n) time where n is the number of elements in the input list. 2. Ensure the resulting tree is height-balanced for optimized search operations. # Task: * Implement the described function. * Use a recursive approach to ensure the BST is balanced. * Perform necessary checks and handle any edge cases. * Test the function with arrays of various sizes to verify correct BST construction. # Notes: * Consider edge cases where the array might be empty (though guaranteed to contain at least one element) or have only one element. * Ensure the returned tree structure is properly tested for balance and correctness of BST properties. This question involves constructing a balanced BST, requiring a solid understanding of recursion and tree structures, making it an intermediate-level coding challenge.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(nums): Converts a sorted array to a height-balanced binary search tree. :param nums: List[int] A sorted list of integers :return: TreeNode The root node of the height-balanced binary search tree if not nums: return None def build_bst(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(nums[mid]) node.left = build_bst(left, mid - 1) node.right = build_bst(mid + 1, right) return node return build_bst(0, len(nums) - 1)"},{"question":"# Coding Assessment Question: Triangular Number Computation **Context**: Triangular numbers represent the count of objects that can form an equilateral triangle. The nth triangular number is the sum of the first n natural numbers and can be expressed as: * T(n) = n * (n + 1) / 2 # Problem Statement Your task is to implement the function `calculate_triangular_number(n: int) -> int` that computes the nth triangular number. To efficiently handle large values and ensure correctness, utilize a formula-based approach. # Function Specification * **Input**: * An integer `n` (0 <= n <= 1,000,000) * **Output**: * The nth triangular number as an integer. * **Constraints**: * Your implementation should handle large values of `n` efficiently. * You should raise a `TypeError` if `n` is not an integer. * You should raise a `ValueError` if `n` is negative. # Examples ```python >>> calculate_triangular_number(0) 0 >>> calculate_triangular_number(1) 1 >>> calculate_triangular_number(5) 15 >>> calculate_triangular_number(100) 5050 >>> calculate_triangular_number(1000000) 500000500000 >>> calculate_triangular_number(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer. >>> calculate_triangular_number(\'a\') Traceback (most recent call last): ... TypeError: n must be an integer. ``` # Guidelines * Use the formula T(n) = n * (n + 1) / 2 to compute the nth triangular number directly. * Ensure your function can handle the maximum input constraint within a reasonable time frame. * Properly handle edge cases by raising appropriate exceptions for invalid inputs.","solution":"def calculate_triangular_number(n): Returns the nth triangular number. :param n: an integer (0 <= n <= 1,000,000) :return: the nth triangular number if not isinstance(n, int): raise TypeError(\\"n must be an integer.\\") if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") return n * (n + 1) // 2 # Use integer division to avoid floating point results"},{"question":"# Problem Statement: You are working on a software tool for signal processing and need to implement a function that calculates the Fast Fourier Transform (FFT) of a given list of complex numbers. # Requirements: Implement a function `fft(data: List[complex]) -> List[complex]` that computes the FFT of the input list using the Divide and Conquer approach. The function should: 1. Raise a `ValueError` with a descriptive message if the length of the input list is not a power of 2. 2. Return a list of complex numbers representing the FFT of the input list. # Input: * A list of complex numbers, where the length of the list is a power of 2. # Output: * A list of complex numbers representing the FFT of the input list. # Constraints: * The length of the input list will be between 1 and 1024 and is guaranteed to be a power of 2. * The input list can contain zero or more elements with both real and imaginary parts. # Example: ```python from typing import List import cmath def fft(data: List[complex]) -> List[complex]: pass # Example Usage: try: result = fft([complex(1, 0), complex(0, 0), complex(0, 0), complex(0, 0)]) print([round(c.real, 5) + round(c.imag, 5) * 1j for c in result]) # Output might be [(1+0j), (1+0j), (1+0j), (1+0j)] except ValueError as e: print(e) try: result = fft([complex(1, 0), complex(0, 0), complex(0, 1)]) # Should raise ValueError except ValueError as e: print(e) # Output: \\"Length of input list must be a power of 2\\" ``` # Note: * Ensure proper error handling for invalid inputs. * Utilize the Cooley-Tukey algorithm for the FFT calculation. * You may use the `cmath` module for handling complex number arithmetic.","solution":"from typing import List import cmath def fft(data: List[complex]) -> List[complex]: Computes the Fast Fourier Transform (FFT) of the input list of complex numbers. :param data: A list of complex numbers where the length of the list is a power of 2. :return: A list of complex numbers representing the FFT of the input list. :raises ValueError: If the length of the input list is not a power of 2. n = len(data) # Check if the length of the input list is a power of 2 if n & (n - 1) != 0: raise ValueError(\\"Length of input list must be a power of 2\\") if n <= 1: return data even = fft(data[0::2]) odd = fft(data[1::2]) T = [cmath.exp(-2j * cmath.pi * k / n) * odd[k] for k in range(n // 2)] return [even[k] + T[k] for k in range(n // 2)] + [even[k] - T[k] for k in range(n // 2)]"},{"question":"# Binary Search Tree - Depth Calculation At a tech company focused on database optimization, your task is to help improve query efficiency by analyzing the structure of search trees. You have been assigned to write a function to calculate the depth of a given Binary Search Tree (BST). Binary Search Tree Depth The depth (or height) of a BST is defined as the number of edges on the longest path from the root node to a leaf node. # Task You need to implement a function `calculate_depth(root: Optional[TreeNode]) -> int` that calculates the depth of a BST. # Input and Output Formats * **Input**: - `root`: The root node of the BST, where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right ``` - `root` can be `None`, which represents an empty tree. * **Output**: - An integer representing the depth of the given BST. # Example: ```python # Example tree # 3 # / # 2 5 # / / # 1 4 6 root = TreeNode(3) root.left = TreeNode(2, TreeNode(1)) root.right = TreeNode(5, TreeNode(4), TreeNode(6)) print(calculate_depth(root)) # Output: 2 ``` # Constraints: * The nodes in the BST will have unique values. * The tree depth will not exceed 1000 nodes. # Performance: * Ensure the depth calculation function operates efficiently even for large trees. **Note**: Consider edge cases such as an empty tree and single-node tree when implementing your solution. # Hints: 1. You can use a recursive approach to determine the depth by exploring the left and right subtrees. 2. Use the `max` function to compare the depths of the left and right subtrees at each node.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def calculate_depth(root: Optional[TreeNode]) -> int: Calculate the depth of a Binary Search Tree (BST). Args: root (Optional[TreeNode]): The root node of the BST. Returns: int: The depth of the BST. if root is None: return 0 left_depth = calculate_depth(root.left) right_depth = calculate_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Context: You are developing a text processing library in which one of the features is to identify and remove duplicate words from a sentence while maintaining the order of their first appearance. # Task: Implement the `remove_duplicates` function that takes a sentence as input and returns the sentence with duplicate words removed. # Specification: 1. **Function Name**: `remove_duplicates` 2. **Parameters**: * `sentence` (str): The input sentence from which duplicate words should be removed. 3. **Returns**: A string representing the sentence with all duplicate words removed. 4. **Constraints**: * The input sentence consists of lowercase alphabetic words separated by single spaces. 5. **Input/Output**: * Example: ```python remove_duplicates(\\"hello world hello\\") ``` Should return: ```python \\"hello world\\" ``` # Performance Requirements: The function should operate in linear time O(n), where n is the number of words in the sentence, due to the need to maintain a record of seen words and construct the output sentence. # Edge Cases: Consider the following scenarios: - A sentence with no duplicate words. - A sentence where all words are duplicates. - An empty sentence. # Example Usage: ```python def remove_duplicates(sentence: str) -> str: >>> remove_duplicates(\\"hello world hello\\") # doctest: +NORMALIZE_WHITESPACE \'hello world\' >>> remove_duplicates(\\"this is a test test is a\\") # doctest: +NORMALIZE_WHITESPACE \'this is a test\' >>> remove_duplicates(\\"unique words only\\") # doctest: +NORMALIZE_WHITESPACE \'unique words only\' >>> remove_duplicates(\\"\\") # doctest: +NORMALIZE_WHITESPACE \'\' # Your implementation here pass # Write your code here. ```","solution":"def remove_duplicates(sentence: str) -> str: Removes duplicate words from a sentence while maintaining the order of their first appearance. Parameters: sentence (str): The input sentence from which duplicate words should be removed. Returns: str: A string representing the sentence with all duplicate words removed. Examples: >>> remove_duplicates(\\"hello world hello\\") \'hello world\' >>> remove_duplicates(\\"this is a test test is a\\") \'this is a test\' >>> remove_duplicates(\\"unique words only\\") \'unique words only\' >>> remove_duplicates(\\"\\") \'\' seen = set() result = [] for word in sentence.split(): if word not in seen: seen.add(word) result.append(word) return \\" \\".join(result)"},{"question":"# Maximum Increasing Subsequence Sum Objective Write a function that finds the maximum sum of an increasing subsequence within a given list of integers. The subsequence must be strictly increasing, but the elements do not need to be contiguous in the original list. Input * A list of integers `arr` where `1 <= len(arr) <= 10^3` and every element in `arr` is in the range `[-10^4, 10^4]`. Output * An integer representing the maximum sum of a strictly increasing subsequence in the list. Constraints * The sequence must be strictly increasing. * Handle both positive and negative numbers effectively. * Aim for an efficient solution that avoids unnecessary computations, such as a dynamic programming approach. Example ```python assert max_increasing_subsequence_sum([10, 5, 4, 3]) == 10 assert max_increasing_subsequence_sum([3, 4, 5, 10]) == 22 assert max_increasing_subsequence_sum([8, 7, 2, 3, 4]) == 9 assert max_increasing_subsequence_sum([-1, -2, -3, -4]) == -1 ``` Implementation details 1. Consider edge cases like having all elements the same or all negative. 2. Utilize dynamic programming for optimal performance. 3. Efficiently track the maximum sum at each step to ensure correctness.","solution":"def max_increasing_subsequence_sum(arr): Find the maximum sum of a strictly increasing subsequence in the list. Args: arr (list of int): List of integers. Returns: int: Maximum sum of a strictly increasing subsequence. if not arr: return 0 n = len(arr) dp = arr[:] # Initialize dp array with the values of arr for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + arr[i]) return max(dp)"},{"question":"# Coding Assessment Question Problem Description You are required to write a function that finds the most frequent value in a list of integers. If there are multiple values with the same frequency, return the smallest one. Function Signature ```python def most_frequent_smallest(nums: list) -> int: pass ``` Input * `nums` (list): A list of integers containing at least one element and at most ( 10^4 ) elements. Output * Returns an integer which is the most frequent value in the list. If there is a tie, return the smallest one. Constraints * The list will contain at least one element and at most ( 10^4 ) elements. * Each integer in the list will be between (-10^6) and (10^6). Examples ```python assert most_frequent_smallest([1, 3, 3, 3, 1, 2, 2, 2]) == 2 assert most_frequent_smallest([4, 4, 4, 4, 7, 1, 7, 8, 8, 8, 1, 1, 1]) == 1 assert most_frequent_smallest([5, 5, 5]) == 5 assert most_frequent_smallest([-1, -1, -2, -3, -1, -2, -2]) == -2 ``` Requirements * The function must handle large lists efficiently in terms of time and space. * Edge cases like all identical elements or lists with both negative and positive integers should be correctly handled.","solution":"from collections import Counter def most_frequent_smallest(nums: list) -> int: Finds the most frequent value in a list of integers. If multiple values have the same frequency, return the smallest one. freq = Counter(nums) most_common = freq.most_common() max_frequency = most_common[0][1] candidates = [num for num, count in most_common if count == max_frequency] return min(candidates)"},{"question":"Transform List into ZigZag Pattern Given a list of integers, your task is to rearrange the list in a \\"zigzag\\" pattern. A list is considered to be in a zigzag pattern if element at every even index is greater than its subsequent element and smaller than its previous element (if they exist), and every odd index element is smaller than its subsequent element and greater than its previous element (if they exist). # Details: 1. **List Length**: The list can be of any length greater than or equal to 1. 2. **Zigzag Criteria**: * For all even indices `i`: `arr[i] > arr[i+1]` and `arr[i] < arr[i-1]` (if applicable). * For all odd indices `i`: `arr[i] < arr[i+1]` and `arr[i] > arr[i-1]` (if applicable). # Class Definition: Implement a class `ZigZagList` with the following method: * **`__init__(self, arr: List[int]) -> None`**: Initializes the list from the given array of integers. * **`rearrange(self) -> None`**: Rearranges the list into a zigzag pattern. # Constraints: * You may assume all elements in the list are integers. * If the length of the list is 1, it should remain unchanged. * The reordering must occur in-place, modifying the original list. # Example: ```python zl = ZigZagList([4, 3, 7, 8, 6, 2, 1]) zl.rearrange() print(zl.arr) # Output might be [3, 4, 6, 7, 2, 8, 1] or any valid zigzag pattern zl = ZigZagList([1, 4, 3, 2]) zl.rearrange() print(zl.arr) # Output might be [1, 4, 2, 3] or any valid zigzag pattern ``` # Task: Implement the `ZigZagList` class as described. Ensure that your solution transforms any provided list into a zigzag pattern correctly.","solution":"from typing import List class ZigZagList: def __init__(self, arr: List[int]) -> None: self.arr = arr def rearrange(self) -> None: n = len(self.arr) for i in range(n - 1): if i % 2 == 0: if self.arr[i] < self.arr[i + 1]: self.arr[i], self.arr[i + 1] = self.arr[i + 1], self.arr[i] else: if self.arr[i] > self.arr[i + 1]: self.arr[i], self.arr[i + 1] = self.arr[i + 1], self.arr[i]"},{"question":"# Coding Assessment Question Problem Statement You are tasked with manipulating a linked list to perform certain operations efficiently. The linked list is implemented as a class with methods to insert values at the beginning and to find the length of the list. Your task is to extend this class to include a function that reverses the linked list and returns the head of the new list. Objective 1. Write a function `reverse_list` that reverses the linked list. 2. Your function should return the new head of the reversed linked list. Implementation Details Extend the provided class with the following function: ```python def reverse_list(self, head: ListNode) -> ListNode: ``` - **Input**: - `head`: The head node of the linked list (type `ListNode`). - **Output**: - Returns the new head node of the reversed linked list (type `ListNode`). Constraints - A linked list node is defined as follows: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next ``` - The function should handle an empty list correctly (should return `None`). Performance Requirements - The solution should run in O(n) time complexity, where n is the number of nodes in the linked list. - Optimize for space as well by not using extra space for reversing the list. Example ```python # Example linked list: 1 -> 2 -> 3 -> 4 -> None # After reversing: 4 -> 3 -> 2 -> 1 -> None head = ListNode(1) head.next = ListNode(2) head.next.next = ListNode(3) head.next.next.next = ListNode(4) ll = LinkedList() new_head = ll.reverse_list(head) # Traversing the reversed list current = new_head while current: print(current.value, end=\\" -> \\") current = current.next # Output: 4 -> 3 -> 2 -> 1 -> None ``` Notes - You may use a helper function if needed to maintain clear and efficient code. - Ensure to handle the edge case of an empty linked list (should return `None`). - Do not alter the values of the nodes; only change the pointers to reverse the list. By following these instructions, the problem will test the candidates\' familiarity with linked list manipulation and ensure they can implement pointer reassignments efficiently.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next class LinkedList: def reverse_list(self, head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev # New head after reversing the list"},{"question":"# Problem Statement Create a Python function `find_longest_substring(s: str) -> str` that identifies and returns the longest substring of the input string `s` that contains at most two distinct characters. Follow the specifications below to ensure optimal performance and edge case handling. # Function Specifications: - **find_longest_substring(s: str) -> str**: - Identifies and returns the longest substring containing at most two distinct characters. - **Input**: A single string `s` composed of lowercase English letters (1 <= len(s) <= 10^6). - **Output**: A string representing the longest valid substring. - **Constraints**: If the input string is empty, return an empty string. # Implementation Details - The function should efficiently process the input string to find the target substring within the given constraints. - Take into account various edge cases, such as the string containing fewer than two distinct characters. # Example Usage ```python def find_longest_substring(s: str) -> str: if not s: return \\"\\" max_len = 0 start = 0 max_start = 0 char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_len = end - start + 1 if current_len > max_len: max_len = current_len max_start = start return s[max_start:max_start + max_len] # Example usage print(find_longest_substring(\\"eceba\\")) # Output: \\"ece\\" print(find_longest_substring(\\"ccaabbb\\")) # Output: \\"aabbb\\" ``` # Explanation and Edge Cases - The function leverages a sliding window approach to track the valid substring, ensuring that the operation remains efficient even for large input sizes. - The dictionary `char_count` helps maintain the count of distinct characters within the window, enabling quick updates and checks. - If the string `s` has fewer than two distinct characters or is very short, the function correctly returns the appropriate substring or an empty string.","solution":"def find_longest_substring(s: str) -> str: if not s: return \\"\\" max_len = 0 start = 0 max_start = 0 char_count = {} for end in range(len(s)): char_count[s[end]] = char_count.get(s[end], 0) + 1 while len(char_count) > 2: char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 current_len = end - start + 1 if current_len > max_len: max_len = current_len max_start = start return s[max_start:max_start + max_len]"},{"question":"# 2D List Transposition # Implement a function that takes as input a non-square 2D list (matrix) and returns its transpose. **Function Signature**: ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: ``` **Input**: * `matrix`: A 2D list of integers representing the matrix to transpose. The dimensions of the matrix can be non-square, meaning the number of rows and columns may differ. **Output**: * Returns a 2D list of integers representing the transposed matrix. **Constraints**: * 1 <= len(matrix) <= 50 * 1 <= len(matrix[0]) <= 50 * Each element in the matrix: -1000 <= element <= 1000 **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6] ] transpose_matrix(matrix) # Output: [[1, 4], [2, 5], [3, 6]] matrix = [ [1, 2], [3, 4], [5, 6] ] transpose_matrix(matrix) # Output: [[1, 3, 5], [2, 4, 6]] ``` **Note**: 1. The transpose of a matrix is obtained by swapping rows and columns. 2. If the input matrix is empty, return an empty list. 3. Ensure that your function handles irregular matrix inputs gracefully, without errors. **Performance Requirements**: - Your solution should be efficient and able to handle the upper constraint limits comfortably.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a given 2D matrix. Args: - matrix: List[List[int]], a 2D list representing the matrix to transpose Returns: - List[List[int]], the transposed 2D list # Check if the matrix is empty if not matrix: return [] # Use zip to transpose the matrix and convert the result back to list of lists transposed = list(map(list, zip(*matrix))) return transposed"},{"question":"# Problem Statement You are tasked to implement a function `minimum_window_substring(s, t)` that finds the minimum window substring in `s` which contains all the characters in `t`. If there is no such substring, return an empty string. # Input * Two non-null strings `s` and `t`. * `1 <= len(t) <= len(s) <= 10^5` # Output * A single string which is the minimum window of `s` that contains all characters in `t`. # Constraints * If multiple minimum windows satisfy the conditions, return the one that appears first in `s`. * The function should handle edge cases where `t` is larger than `s` or `t` contains characters not present in `s`. * Aim for optimal time complexity. # Examples * Example 1: ```python minimum_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") ``` Expected Output: ``` \\"BANC\\" ``` * Example 2: ```python minimum_window_substring(\\"a\\", \\"a\\") ``` Expected Output: ``` \\"a\\" ``` # Additional Context Imagine you are processing a large document and need to find the smallest possible section that contains all the unique characters from another given word. This function will help in highlighting the most relevant segment efficiently. Write the function `minimum_window_substring` that achieves this objective.","solution":"from collections import Counter, defaultdict def minimum_window_substring(s, t): Returns the minimum window substring of s that contains all characters in t. if not s or not t: return \\"\\" dict_t = Counter(t) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = defaultdict(int) ans = float(\\"inf\\"), None, None # window length, left, right while r < len(s): char = s[r] window_counts[char] += 1 if char in dict_t and window_counts[char] == dict_t[char]: formed += 1 while l <= r and formed == required: char = s[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[char] -= 1 if char in dict_t and window_counts[char] < dict_t[char]: formed -= 1 l += 1 r += 1 if ans[1] is None: return \\"\\" else: return s[ans[1]:ans[2] + 1]"},{"question":"# Problem Statement You are given a positive integer `n`. Your task is to implement a function that returns a string representation of all numbers from 1 to `n`, concatenated together in reverse order. # Function Signature ```python def concatenate_reversed_numbers(n: int) -> str: pass ``` # Input * `n`: A positive integer. - Constraints: (1 leq n leq 10^4) # Output * Returns a single string that is the result of concatenating the string representations of numbers from 1 to `n`, but in reverse order. # Examples 1. `concatenate_reversed_numbers(5)` should return `\\"54321\\"`. 2. `concatenate_reversed_numbers(12)` should return `\\"121110987654321\\"`. 3. `concatenate_reversed_numbers(3)` should return `\\"321\\"`. # Edge Cases Consider the following edge cases: 1. For the smallest value of `n` (i.e., 1), the function should return `\\"1\\"`. 2. Ensure the function handles larger values of `n` efficiently within the given constraints. # Constraints - The solution should run efficiently for values up to (n = 10^4).","solution":"def concatenate_reversed_numbers(n: int) -> str: Returns a single string containing numbers from 1 to n concatenated in reverse order. Parameters: n (int): A positive integer up to 10,000. Returns: str: A concatenated string of numbers from 1 to n in reverse order. # Create a string by concatenating numbers from n to 1 return \'\'.join(str(i) for i in range(n, 0, -1))"},{"question":"# Implementing Dijkstra\'s Algorithm with Path Reconstruction **Context:** You are given a directed graph with `n` vertices and `m` edges, where each edge has a positive weight. Your task is to find the shortest path from a given source vertex `src` to a destination vertex `dest` using Dijkstra\'s algorithm and return the path. **Function Signature:** ```python def dijkstra(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> List[int]: ``` **Input:** * `n`: An integer representing the number of vertices (0 <= n <= 10^5). * `edges`: A list of tuples, where each tuple (u, v, w) represents a directed edge from vertex `u` to vertex `v` with weight `w` (1 <= w <= 10^4). * `src`: An integer representing the source vertex. * `dest`: An integer representing the destination vertex. **Output:** * A list of integers representing the shortest path from the source vertex to the destination vertex. The path should include both `src` and `dest` vertices. If no path exists, return an empty list. **Constraints:** * 1 <= m <= 2*10^5 * The vertices are zero-indexed. **Performance Requirements:** * The solution must efficiently handle the upper constraint limits for both time and space. **Example:** ```python # Example 1 n = 5 edges = [(0, 1, 10), (0, 2, 3), (1, 2, 1), (1, 3, 2), (2, 1, 4), (2, 3, 8), (2, 4, 2), (3, 4, 7), (4, 3, 9)] src = 0 dest = 3 print(dijkstra(n, edges, src, dest)) # Output: [0, 2, 1, 3] # Example 2 n = 4 edges = [(0, 1, 5), (0, 2, 10), (1, 2, 3), (1, 3, 7), (2, 3, 2)] src = 0 dest = 3 print(dijkstra(n, edges, src, dest)) # Output: [0, 1, 2, 3] ``` **Assignment:** Implement the `dijkstra` function to compute the shortest path from `src` to `dest` using Dijkstra\'s Algorithm based on the provided signature. Return the full path as specified. **Evaluation Criteria:** * Correctness and Efficiency of the solution. * Handling of edge cases. * Clarity and readability of the implemented code.","solution":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], src: int, dest: int) -> List[int]: # Create an adjacency list for the graph graph = [[] for _ in range(n)] for u, v, w in edges: graph[u].append((v, w)) # Initialize distances and parent array for path reconstruction dist = [float(\'inf\')] * n parent = [-1] * n dist[src] = 0 # Priority queue for Dijkstra\'s algorithm pq = [(0, src)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance parent[v] = u heapq.heappush(pq, (distance, v)) # Reconstruct the path from src to dest path = [] if dist[dest] == float(\'inf\'): return [] current = dest while current != -1: path.append(current) current = parent[current] return path[::-1]"},{"question":"# Unique Character Counter You are given a program that analyzes a string to count the number of unique characters in it. Your task is to implement a function that returns the count of unique characters while ignoring case and non-alphabetic characters. Function Signature ```python def count_unique_characters(text: str) -> int: ``` # Input * `text` (str): The input text containing alphabetic and non-alphabetic characters. # Output * (int): The count of unique alphabetic characters in the input text, considering case insensitivity. # Implementation Steps 1. **Normalize Case**: Convert all characters of the input text to lowercase. 2. **Filter Non-Alphabetic Characters**: Consider only alphabetic characters. 3. **Count Unique Characters**: Count the number of unique alphabetic characters in the filtered text. # Constraints * The length of the input string `text` will be in the range [1, 10^6]. # Example ```python # Test case 1 text = \\"Hello World\\" print(count_unique_characters(text)) # Expected output: 7, since the unique alphabetic characters are {\'h\', \'e\', \'l\', \'o\', \'w\', \'r\', \'d\'} # Test case 2 text = \\"1234!@# print(count_unique_characters(text)) # Expected output: 0, since there are no alphabetic characters in the string # Test case 3 text = \\"Programming\\" print(count_unique_characters(text)) # Expected output: 8, since the unique alphabetic characters are {\'p\', \'r\', \'o\', \'g\', \'a\', \'m\', \'i\', \'n\'} ``` # Hints * Utilize the `set` data structure which inherently handles uniqueness. * Use string methods to filter and normalize characters. * Consider edge cases such as an empty string or a string with only non-alphabetic characters.","solution":"def count_unique_characters(text: str) -> int: Count the number of unique alphabetic characters in the text, ignoring case and non-alphabetic characters. # Normalize case text = text.lower() # Filter non-alphabetic characters and create a set of unique characters unique_characters = {char for char in text if char.isalpha()} # Return the count of unique characters return len(unique_characters)"},{"question":"# Unique Array Element Identification Context and Objective In a system where data integrity is crucial, arrays are frequently analyzed for uniqueness of their elements. A common task is to identify the first unique (non-repeating) element in an array to ensure no duplicates affect the system\'s operations. Problem Statement Given an array of integers, write a function `first_unique_element` that returns the first unique (non-repeating) element in the array. If no unique element exists, return `-1`. Function Signature ```python def first_unique_element(array: list[int]) -> int: pass ``` Input Constraints - `array`: A list of integers representing the array. Assume: - `0 <= len(array) <= 10^5` - Each integer in the array, if present, lies within the range `-10^6` to `10^6`. Output - Return the first unique element in the array. - If no unique element exists, return `-1`. Example ```python # Example 1: array = [2, 3, 4, 2, 3, 5, 6] # First unique element: 4 assert first_unique_element(array) == 4 # Example 2: array = [7, 7, 8, 8, 9, 9] # No unique element assert first_unique_element(array) == -1 # Example 3: array = [1] # Only one element which is unique by default assert first_unique_element(array) == 1 ``` Notes - The function should efficiently handle the array\'s length and the range of values. - Consider utilizing additional data structures to aid in tracking element frequencies and positions.","solution":"def first_unique_element(array: list[int]) -> int: Returns the first unique (non-repeating) element in the array. If no unique element exists, return -1. from collections import Counter # Count the frequency of each element in the array element_counts = Counter(array) # Iterate over the array and find the first element with a count of 1 for element in array: if element_counts[element] == 1: return element # If no unique element is found, return -1 return -1"},{"question":"Counting Islands # Context In computer science, the problem of counting islands in a grid is a classic exercise that illustrates breadth-first search (BFS) or depth-first search (DFS) algorithms. An island is defined as a group of \'1\'s (land) connected vertically or horizontally. This problem is a fundamental topic for mastering graph traversal techniques in programming. # Task Write a Python function `count_islands()` that takes a 2D grid made up of \'0\'s (water) and \'1\'s (land) as input and returns the number of islands. # Function Signature ```python def count_islands(grid: List[List[int]]) -> int: pass ``` # Input - `grid`: A 2D list of integers where each element is either 0 or 1. The grid dimensions are guaranteed to be at least 1x1 and at most 50x50. # Output - An integer representing the number of distinct islands found in the grid. # Requirements - Implement either BFS or DFS to traverse and detect connected components of \'1\'s. - Ensure error handling for invalid input types or out-of-bound grid dimensions. # Constraints 1. The function should raise a `TypeError` if the input grid is not a list of lists. 2. The function should raise a `ValueError` if any row in the grid does not have the same length as the others or contains values other than 0 or 1. 3. The grid should not contain more than 50 rows or 50 columns. 4. The grid should have at least one row and one column. # Example ```python grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ] result = count_islands(grid) print(result) # Expected output: 5 ``` # Notes - Utilize helper functions to perform BFS or DFS to find and mark visited islands. - An island is defined to include vertical and horizontal connections only (no diagonal connections). - Ensure the visited nodes are managed properly to avoid recounting. # Reference: - [Island Counting](https://en.wikipedia.org/wiki/Island_counting_problem)","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not isinstance(grid, list) or any(not isinstance(row, list) for row in grid): raise TypeError(\\"Input grid must be a list of lists.\\") if len(grid) == 0 or len(grid) > 50 or len(grid[0]) == 0 or len(grid[0]) > 50: raise ValueError(\\"Grid dimensions are out of bound. Allowed dimensions are 1x1 to 50x50.\\") row_len = len(grid[0]) for row in grid: if len(row) != row_len: raise ValueError(\\"All rows in the grid must have the same length.\\") if any(cell != 0 and cell != 1 for cell in row): raise ValueError(\\"Grid can only contain 0\'s and 1\'s.\\") def dfs(r, c): if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]) or grid[r][c] == 0: return grid[r][c] = 0 dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) count = 0 for r in range(len(grid)): for c in range(len(grid[0])): if grid[r][c] == 1: count += 1 dfs(r, c) return count"},{"question":"# Problem Statement In a data processing system, you need to verify if the datasets you are working with satisfy certain requirements. Each dataset is represented as a list of integers. Write a program that: 1. Takes a list of integers as input. 2. Checks if the list is strictly increasing (i.e., every element is greater than the previous one). 3. If the list is strictly increasing, return the sum of all the elements in the list. 4. If the list is not strictly increasing, identify and return the first element that violates the condition. # Input Format - A single list of integers. # Output Format - If the list is strictly increasing, print the sum of the elements. - If the list is not strictly increasing, print the first element that violates the condition. # Constraints - The list can have up to 1000 elements. - The integers in the list can be negative, zero, or positive. # Example Input ```python [1, 2, 3, 4, 5] ``` Output ``` Sum: 15 ``` Input ```python [1, 3, 3, 5, 6] ``` Output ``` Violation: 3 ``` # Function Signature The implementation should include the following function: ```python def process_dataset(data: List[int]) -> Union[int, str]: pass ``` # Requirements 1. The function should handle empty lists and return a sum of 0 in such cases. 2. Use clear and readable code to ensure maintainability. 3. Optimize for performance and handle edge cases effectively.","solution":"from typing import List, Union def process_dataset(data: List[int]) -> Union[int, str]: This function checks if the given list of integers is strictly increasing. If it is, it returns the sum of all the elements in the list. Otherwise, it returns the first element that violates the strictly increasing condition. :param data: List of integers :return: Sum of elements if list is strictly increasing, else the first violating element for i in range(1, len(data)): if data[i] <= data[i - 1]: return f\\"Violation: {data[i]}\\" return f\\"Sum: {sum(data)}\\""},{"question":"# Question: Find the Next Greater Element Given an array of integers, write a function to find the next greater element for each element in the array. The next greater element for an element x is the first greater element to the right of x in the array. If no such element exists, return -1 for that position. Function Signature ```python def next_greater_elements(nums: List[int]) -> List[int]: ... ``` Input - `nums` (List[int]): A list of integers. Output - `List[int]`: A list of integers representing the next greater elements. Constraints - 1 <= len(nums) <= 10^4 - -10^9 <= nums[i] <= 10^9 Example ```python # Example 1: nums = [4, 5, 2, 25] assert next_greater_elements(nums) == [5, 25, 25, -1] # Example 2: nums = [13, 7, 6, 12] assert next_greater_elements(nums) == [-1, 12, 12, -1] ``` Explanation The function `next_greater_elements` should return a list of integers where each position contains the next greater element for the corresponding position in the input list. If no greater element is found to the right, the position should contain -1. In Example 1: - For 4, the next greater element is 5. - For 5, the next greater element is 25. - For 2, the next greater element is 25. - For 25, there is no greater element, so it is -1. In Example 2: - For 13, there is no greater element, so it is -1. - For 7, the next greater element is 12. - For 6, the next greater element is 12. - For 12, there is no greater element, so it is -1.","solution":"from typing import List def next_greater_elements(nums: List[int]) -> List[int]: Finds the next greater element for each element in the array. The next greater element for an element x is the first greater element to the right of x in the array. If no such element exists, return -1 for that position. Args: nums (List[int]): A list of integers. Returns: List[int]: A list of integers representing the next greater elements. result = [-1] * len(nums) stack = [] for idx, value in enumerate(nums): while stack and nums[stack[-1]] < value: last_idx = stack.pop() result[last_idx] = value stack.append(idx) return result"},{"question":"# Problem: Word Frequency Counter Context: You are analyzing customer reviews of a product and need to determine how frequently each word appears in the text to identify commonly mentioned terms. This will help in understanding common sentiments and features discussed by customers. Function Signature: ```python def word_frequency_counter(text: str) -> dict: ``` Description: Implement a function `word_frequency_counter` that takes a string of text as input and returns a dictionary where the keys are the unique words in the text and the values are their respective counts. For the purpose of this function, words are considered sequences of characters separated by spaces, and punctuation should be ignored. Input: * `text`: A string containing the text for which the word frequencies need to be calculated. Output: * Returns a dictionary where keys are words (as lowercase strings) and values are integers representing the count of each word’s occurrences in the text. Constraints: * The input string `text` may contain punctuation, which should be ignored. * The input string can be empty or contain only spaces. * Words should be considered case-insensitively (e.g., \\"Apple\\" and \\"apple\\" should be counted as the same word). Examples: ```python text1 = \\"Wow, this product is amazing! Absolutely fantastic product!\\" assert word_frequency_counter(text1) == {\'wow\': 1, \'this\': 1, \'product\': 2, \'is\': 1, \'amazing\': 1, \'absolutely\': 1, \'fantastic\': 1} text2 = \\"Good stuff. Very good. Recommending to everyone.\\" assert word_frequency_counter(text2) == {\'good\': 2, \'stuff\': 1, \'very\': 1, \'recommending\': 1, \'to\': 1, \'everyone\': 1} text3 = \\"\\" assert word_frequency_counter(text3) == {} text4 = \\"No punctuation here\\" assert word_frequency_counter(text4) == {\'no\': 1, \'punctuation\': 1, \'here\': 1} text5 = \\"Multiple spaces between words shouldn\'t affect the count.\\" assert word_frequency_counter(text5) == {\'multiple\': 1, \'spaces\': 1, \'between\': 1, \'words\': 1, \'shouldnt\': 1, \'affect\': 1, \'the\': 1, \'count\': 1} ``` Requirements: Make sure to handle cases where text contains punctuation or multiple spaces correctly and produce the expected word counts efficiently for longer texts.","solution":"import re from collections import defaultdict def word_frequency_counter(text: str) -> dict: Takes a string of text and returns a dictionary with the frequency of each word appearing in the text, ignoring punctuation and case. # Remove punctuation and make text lowercase text = re.sub(r\'[^ws]\', \'\', text).lower() # Split the text into words words = text.split() # Use a dictionary to count word frequencies word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Scenario As a software engineer, you are asked to write a function that can validate the structural integrity of HTML-like nested tags within a string. The goal is to ensure that each opening tag has a corresponding closing tag and that tags are properly nested. # Task Implement a function `validate_html_nesting` that returns a boolean indicating whether the tags in the given input string are correctly nested. # Function Signature ```python def validate_html_nesting(input_string: str) -> bool: ``` # Input - `input_string`: A string containing HTML-like tags. Each tag starts with \'<\' and ends with \'>\', and the tags are case-insensitive. Tags follow the format `<tagname>` for opening tags and `</tagname>` for closing tags. Valid tag names consist of lowercase or uppercase alphabets only. # Output - A boolean: `True` if the tags are correctly nested, and `False` otherwise. # Constraints - The `input_string` length will be between 1 and 10,000 characters. - Tags within the string are case-insensitive. For example, `<TAG>` and `</tag>` are considered a matching pair. # Example ```python input_string = \\"<a><b></b><c></c></a>\\" # Expected Output: True input_string = \\"<A><b></B></a>\\" # Expected Output: True input_string = \\"<a><b></a></b>\\" # Expected Output: False input_string = \\"<a><b></b></a><c><d></d></C>\\" # Expected Output: True ``` # Notes 1. Tags are case-insensitive, meaning `<TAG>` and `</tag>` match. 2. Ensure that the function returns `True` only if every opening tag has a corresponding closing tag and all tags are properly nested. 3. Consider edge cases, such as strings with no tags, strings with single tags, and strings with improperly closed tags. Here\'s the function signature again for your reference: ```python def validate_html_nesting(input_string: str) -> bool: ```","solution":"def validate_html_nesting(input_string: str) -> bool: import re tag_pattern = re.compile(r\'<(/?[^>]+)>\') stack = [] for match in tag_pattern.finditer(input_string): tag = match.group(1) if not tag.startswith(\'/\'): # Opening tag stack.append(tag.lower()) else: # Closing tag if not stack: return False if stack.pop() != tag[1:].lower(): return False return not stack"},{"question":"# Coding Assessment Question: You are tasked with managing a school system where students\' grades need to be processed and analyzed. **Problem Statement:** You are provided with a list of students\' grades for different subjects. Each student\'s record contains the student\'s name and a dictionary of subjects along with the corresponding grades. Your task is to implement a function that will process these records and identify the student with the highest average grade across all subjects. **Requirements:** 1. **calculate_average(grades: Dict[str, int]) -> float**: Given a dictionary of subjects and grades, compute the average grade of the student. - Input: A dictionary with subject names as keys and integer grades (0-100) as values. - Output: A float representing the average grade of the student. 2. **find_top_student(students_grades: List[Dict[str, Any]]) -> str**: Identify the student with the highest average grade. - Input: A list of dictionaries, each representing a student\'s record with the student\'s name and a dictionary of subjects and grades. - Output: A string representing the name of the student with the highest average grade. If there is a tie, return the name that comes first alphabetically. **Input/Output Format:** - The `calculate_average` function should return a float representing the average grade of the student. - The `find_top_student` function should return a string representing the name of the student with the highest average grade. **Example:** ```python def calculate_average(grades): # Your average calculation logic here def find_top_student(students_grades): # Your implementation here # Example use case students_grades = [ {\\"name\\": \\"Alice\\", \\"grades\\": {\\"Math\\": 90, \\"Science\\": 85, \\"English\\": 92}}, {\\"name\\": \\"Bob\\", \\"grades\\": {\\"Math\\": 85, \\"Science\\": 88, \\"English\\": 91}}, {\\"name\\": \\"Charlie\\", \\"grades\\": {\\"Math\\": 92, \\"Science\\": 87, \\"English\\": 90}}, ] assert find_top_student(students_grades) == \\"Alice\\" ``` **Constraints/Limitations:** - Each student record in `students_grades` will have a unique name. - Each grade in the dictionary will be an integer between 0 and 100, inclusive. - There will be at least one student in the list.","solution":"from typing import Dict, List, Any def calculate_average(grades: Dict[str, int]) -> float: Calculate the average grade from a dictionary of subjects and grades. Parameters: grades (Dict[str, int]): Dictionary with subjects as keys and grades as values. Returns: float: The average grade. total = sum(grades.values()) count = len(grades) return total / count def find_top_student(students_grades: List[Dict[str, Any]]) -> str: Identify the student with the highest average grade. Parameters: students_grades (List[Dict[str, Any]]): List of dictionaries with each dictionary containing a student\'s name and their grades. Returns: str: Name of the student with the highest average grade. highest_average = -1 top_student = \\"\\" for student in students_grades: average = calculate_average(student[\'grades\']) if average > highest_average or (average == highest_average and student[\'name\'] < top_student): highest_average = average top_student = student[\'name\'] return top_student"},{"question":"# Minimum Spanning Tree Problem You are given an undirected graph with vertices connected by weighted edges. Your task is to find the sum of the weights for the Minimum Spanning Tree (MST) of the graph using Kruskal\'s algorithm. **Problem**: Write a function `mst_kruskal` that calculates the total weight of the Minimum Spanning Tree. **Function signature**: ```python def mst_kruskal(vertices: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` **Input**: - `vertices`: An integer representing the total number of vertices in the graph. - `edges`: A list of tuples, where each tuple `(u, v, w)` represents an undirected edge between vertex `u` and vertex `v` with weight `w`. **Output**: - Return an integer representing the sum of the weights of the Minimum Spanning Tree. **Constraints**: - `1 <= vertices <= 100` - `0 <= w <= 1000` for each edge weight - Each vertex in the graph is labeled from `0` to `vertices-1` - The graph is connected and undirected **Example**: ```python vertices = 4 edges = [ (0, 1, 10), (0, 2, 6), (0, 3, 5), (1, 3, 15), (2, 3, 4) ] assert mst_kruskal(vertices, edges) == 19 ``` **Notes**: - Ensure your function handles edge cases and is efficient within the provided constraints. - The function should utilize Kruskal\'s algorithm, which involves sorting the edges and using a union-find structure to avoid cycles.","solution":"from typing import List, Tuple def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def mst_kruskal(vertices: int, edges: List[Tuple[int, int, int]]) -> int: result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(vertices): parent.append(node) rank.append(0) while e < vertices - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) minimumCost = 0 for u, v, weight in result: minimumCost += weight return minimumCost"},{"question":"# Scenario: A logistics company wants to optimize the delivery routes for a fleet of delivery trucks. They have multiple delivery points, and some points must be visited before others due to dependency constraints. Each delivery point and its dependencies are represented as a node in a Directed Acyclic Graph (DAG). You are tasked with writing a function to determine one valid sequence of delivery points that respects all the constraints. # Implement the Function: **Function Signature**: ```python def delivery_schedule(graph: List[List[int]], locations: Dict[int, str]) -> List[str]: pass ``` **Input**: * A graph represented as an adjacency list: `graph` (List[List[int]]). * A dictionary mapping each node to its delivery point name: `locations` (Dict[int, str]). **Output**: * A list of delivery point names in the order they should be visited. **Constraints**: * Delivery point names will be unique. * The graph is guaranteed to be a Directed Acyclic Graph (DAG). # Example: **Input**: ```python graph = [[1, 2], [2, 3], [3], [], [1, 5], [6], [], [5], []] locations = {0: \\"warehouse\\", 1: \\"store_A\\", 2: \\"store_B\\", 3: \\"store_C\\", 4: \\"hub\\", 5: \\"facility\\", 6: \\"stockpile\\", 7: \\"dock\\", 8: \\"branch\\"} ``` **Output**: ```python [\'warehouse\', \'hub\', \'store_A\', \'dock\', \'facility\', \'stockpile\', \'store_B\', \'store_C\', \'branch\'] ``` **Explanation**: The provided graph and location mapping imply specific orders of visits due to dependencies, such as \\"warehouse\\" before \\"store_A\\" and \\"store_A\\" before \\"store_B.\\" The topological sorting ensures that these constraints are respected. # Tips: * Utilize depth-first search for topological sorting. * Properly manage the recursion stack to account for dependency checks. * Ensure the correct sequence is derived by utilizing the properties of DAGs.","solution":"from typing import List, Dict def delivery_schedule(graph: List[List[int]], locations: Dict[int, str]) -> List[str]: def dfs(node, graph, visited, stack): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, graph, visited, stack) stack.append(node) n = len(graph) visited = [False] * n stack = [] for i in range(n): if not visited[i]: dfs(i, graph, visited, stack) stack.reverse() return [locations[node] for node in stack]"},{"question":"# Merge K Sorted Linked Lists You are given an array of linked lists, where each linked list is sorted in ascending order. Your task is to implement a function that merges all the linked lists into one single sorted linked list, efficiently. Function Signature: ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: pass ``` # Input - `lists`: A list of `k` linked lists, where each linked list is sorted in ascending order. # Output - Returns the head of the merged linked list. # Constraints - The total number of nodes across all lists will be in the range [0, 10^4]. - The values of the nodes are within the range `-10^4 <= node.val <= 10^4`. # Scenario You are provided with several speakers at a conference, and each speaker has prepared slides listed in an increasing order of importance. Your task is to create a single, cohesive presentation that integrates all topics in a most concise and coherent manner by merging the sorted slides. # Example ```python # Example representation of linked lists # Let\'s define a helper function to create linked lists for demonstration: def list_to_nodes(lst): dummy = ListNode(None) curr = dummy for val in lst: curr.next = ListNode(val) curr = curr.next return dummy.next list1 = list_to_nodes([1, 4, 5]) list2 = list_to_nodes([1, 3, 4]) list3 = list_to_nodes([2, 6]) merged_head = merge_k_lists([list1, list2, list3]) # Expected output for the merged list: 1->1->2->3->4->4->5->6 ``` # Considerations * Implement efficient merging using a priority queue (heap) to achieve optimal time complexity. * Ensure robustness to handle empty lists and lists of varying lengths. * Carefully manage memory and avoid excessive operations to handle up to the maximum constraint effectively.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merges k sorted linked lists into one sorted linked list. :param lists: A list of k sorted linked lists. :return: A merged sorted linked list. min_heap = [] # Initialize the heap with the head node of each list for i in range(len(lists)): if lists[i]: heapq.heappush(min_heap, (lists[i].val, i)) lists[i] = lists[i].next dummy = ListNode() current = dummy # Pop the smallest element from the heap and then add the next node from that list into the heap while min_heap: val, index = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if lists[index]: heapq.heappush(min_heap, (lists[index].val, index)) lists[index] = lists[index].next return dummy.next"},{"question":"# String Anagram Checker Context Anagrams are words or phrases formed by rearranging the letters of another, using all the original letters exactly once. Detecting if two strings are anagrams of each other is a common problem in text processing. Task Write a function `are_anagrams(s1: str, s2: str) -> bool` that determines whether two given strings are anagrams of each other. The function should adhere to the following constraints and characteristics: 1. If either string contains any non-alphabetical character (excluding spaces), raise a `ValueError` with the message \\"Strings must contain only alphabetical characters and spaces\\". 2. Ignore spaces and consider the strings case-insensitive for anagram detection. 3. The function should return `True` if the strings are anagrams, otherwise `False`. Input - `s1`: A string that may contain spaces and alphabetical characters. - `s2`: A string that may contain spaces and alphabetical characters. Output - Return `True` if the strings are anagrams, otherwise return `False`. Constraints - Strings are case-insensitive and can include spaces. - Strings must contain only alphabetical characters and spaces. Example ```python are_anagrams(\\"Listen\\", \\"Silent\\") # Output: True are_anagrams(\\"A gentleman\\", \\"Elegant man\\") # Output: True are_anagrams(\\"The eyes\\", \\"They see\\") # Output: True are_anagrams(\\"Hello\\", \\"Oleh\\") # Output: False are_anagrams(\\"The eyes!\\", \\"They see\\") # Raises ValueError ``` Hints - Normalize the strings by converting them to lower case and removing spaces before comparison. - Utilize data structures such as dictionaries or sorted lists to facilitate the comparison.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. Parameters: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. # Check for invalid characters (non-alphabetical and non-space) if not all(c.isalpha() or c.isspace() for c in s1 + s2): raise ValueError(\\"Strings must contain only alphabetical characters and spaces\\") # Normalize strings: convert to lowercase and remove spaces normalized_s1 = sorted(s1.replace(\\" \\", \\"\\").lower()) normalized_s2 = sorted(s2.replace(\\" \\", \\"\\").lower()) # Compare the processed strings return normalized_s1 == normalized_s2"},{"question":"# Coding Assessment Question: Human Body Mass Index (BMI) Calculation **Context**: As part of a health monitoring system, you are tasked with implementing a function to calculate the Body Mass Index (BMI) of a person. The BMI is an important metric used in assessing whether an individual has an appropriate body weight for their height. # Task: Implement a Python function named `calculate_bmi_and_category` that computes the BMI given a person\'s weight in kilograms and height in meters and categorizes the BMI based on standard BMI categories. # Requirements: 1. **Function Signature**: ```python def calculate_bmi_and_category(weight: float, height: float) -> (float, str): ``` 2. **Inputs**: - `weight` (float): Weight of the person in kilograms (kg). - `height` (float): Height of the person in meters (m). 3. **Output**: - Returns a tuple of two elements: - A float representing the calculated BMI. - A string indicating the BMI category. 4. **Constraints**: - `weight > 0`, `height > 0` - The function should handle potential floating-point arithmetic issues intelligently. 5. **Performance**: - The function should have O(1) time complexity and O(1) space complexity. 6. **BMI Categories**: - Underweight: BMI < 18.5 - Normal weight: 18.5 ≤ BMI < 24.9 - Overweight: 25 ≤ BMI < 29.9 - Obesity: BMI ≥ 30 # Example: ```python >>> calculate_bmi_and_category(70, 1.75) (22.857142857142858, \'Normal weight\') >>> calculate_bmi_and_category(95, 1.8) (29.320987654320987, \'Overweight\') ``` # Hints: - Use the formula ( BMI = frac{weight}{height^2} ) to calculate BMI. - Then, determine the BMI category based on the calculated BMI value. This question requires solid understanding of arithmetic operations, conditionals, and the ability to apply health-related formulas for meaningful categorization.","solution":"def calculate_bmi_and_category(weight: float, height: float) -> (float, str): Calculate the BMI given weight in kg and height in meters, and categorize it. Parameters: weight (float): Weight of the person in kilograms (kg). height (float): Height of the person in meters (m). Returns: (float, str): A tuple containing the calculated BMI and the corresponding BMI category. # Calculate BMI bmi = weight / (height ** 2) # Determine BMI category if bmi < 18.5: category = \'Underweight\' elif 18.5 <= bmi < 24.9: category = \'Normal weight\' elif 25 <= bmi < 29.9: category = \'Overweight\' else: category = \'Obesity\' return bmi, category"},{"question":"# Problem Statement You are tasked with implementing a data structure that can keep track of the k most frequently occurring elements in a stream of data. Design and implement a class called `TopKFrequent` that supports the following functionalities: 1. Adding an element to the stream. 2. Retrieving the k most frequent elements at any point in time. # Task Requirements 1. Implement the `TopKFrequent` class with the following methods: * `__init__(self, k: int)`: Initializes the class with the value of k. * `add(self, element: T)`: Adds an element to the stream. T can be any hashable type (strings, integers, etc.). * `top_k_frequent(self) -> list[T]`: Returns a list of the k most frequent elements in descending order of their frequencies. If two elements have the same frequency, they should be ordered by the element value. # Input - You will be provided with multiple add operations for different elements. - You will be required to fetch the k most frequent elements after a series of these add operations. # Output - For `top_k_frequent`, return a list of k elements. - The list should be sorted in descending order of frequency and if frequencies match, by element value. # Constraints 1. The stream of elements can have up to `10^5` entries. 2. Each element in the stream will have a maximum length of `100` characters (for strings). 3. The value of k will be positive and less than or equal to the number of unique elements in the stream at any point in time. # Example ```python topk = TopKFrequent(2) topk.add(\'apple\') topk.add(\'banana\') topk.add(\'apple\') topk.add(\'orange\') topk.add(\'banana\') topk.add(\'apple\') print(topk.top_k_frequent()) # Output: [\'apple\', \'banana\'] topk.add(\'banana\') print(topk.top_k_frequent()) # Output: [\'banana\', \'apple\'] ``` Implement the `TopKFrequent` class with efficient data structures to handle the given constraints.","solution":"from typing import List, TypeVar from collections import defaultdict import heapq T = TypeVar(\'T\', int, str) class TopKFrequent: def __init__(self, k: int): self.k = k self.freq_map = defaultdict(int) self.min_heap = [] def add(self, element: T): self.freq_map[element] += 1 def top_k_frequent(self) -> List[T]: if not self.freq_map: return [] for element, frequency in self.freq_map.items(): heapq.heappush(self.min_heap, (-frequency, element)) result = [] for _ in range(min(self.k, len(self.min_heap))): result.append(heapq.heappop(self.min_heap)[1]) return result"},{"question":"# Background You are assigned a task to implement a function that processes a list of strings by removing duplicate words within each string. The function should also disregard the case of the words when identifying duplicates, meaning \\"Word\\" and \\"word\\" should be treated as the same word. # Task Implement a function that takes a list of strings and returns a new list with duplicates removed from each string, preserving the order of their first occurrence. The comparison should be case-insensitive, but the original case of the words should be retained in the output. # Function Signature ```python def remove_duplicates_preserve_order(strings: list) -> list: pass ``` # Input - `strings` (list): A list of strings, where each string may contain multiple words separated by spaces. # Output - `result` (list): A new list of strings with duplicates removed from each string, preserving the order of their first occurrence. # Example ```python assert remove_duplicates_preserve_order([\\"Hello world hello\\", \\"This is is a test Test\\"]) == [ \\"Hello world\\", \\"This is a test\\" ] assert remove_duplicates_preserve_order([\\"Python python PYTHON\\", \\"Code code CODE\\"]) == [ \\"Python\\", \\"Code\\" ] ``` # Constraints - Each string in the list `strings` will only contain alphabetic characters (a-z, A-Z) and spaces. - The length of the list `strings` will be <= 100. - The length of each string in the list `strings` will be <= 200 characters.","solution":"def remove_duplicates_preserve_order(strings: list) -> list: def remove_duplicates_from_string(s): seen = set() result = [] for word in s.split(): lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) result.append(word) return \' \'.join(result) return [remove_duplicates_from_string(s) for s in strings]"},{"question":"# Problem Statement: You are required to implement a function to determine the longest stretch of unique letters in a given string. This is useful for various problems including substring search in text analysis. # Function Signature: ```python def longest_unique_substring(s: str) -> int: Finds the longest substring with all unique characters. Parameters: s (str): The input string to search within. Returns: int: The length of the longest substring with all unique characters. ``` # Input: - A string `s` representing the input text. - Constraints: The length of the string can be between 1 and 10^5 characters. The string will consist of printable ASCII characters. # Output: - An integer representing the length of the longest substring that contains all unique characters. # Examples: ```python # Example 1 s = \\"abcabcbb\\" print(longest_unique_substring(s)) # Expected Output: 3 # Example 2 s = \\"bbbbb\\" print(longest_unique_substring(s)) # Expected Output: 1 # Example 3 s = \\"pwwkew\\" print(longest_unique_substring(s)) # Expected Output: 3 # Example 4 s = \\"\\" print(longest_unique_substring(s)) # Expected Output: 0 ``` **Note**: Your solution should efficiently handle large inputs, ensuring an optimal time complexity. Consider using data structures like sets or hash maps to keep track of unique characters and their positions.","solution":"def longest_unique_substring(s: str) -> int: Finds the longest substring with all unique characters. Parameters: s (str): The input string to search within. Returns: int: The length of the longest substring with all unique characters. # Edge case for empty string if not s: return 0 # Dictionary to store the last seen index of each character last_seen = {} longest = 0 start = 0 for end in range(len(s)): if s[end] in last_seen and last_seen[s[end]] >= start: start = last_seen[s[end]] + 1 last_seen[s[end]] = end longest = max(longest, end - start + 1) return longest"},{"question":"# Problem Statement You have implemented a class `Polynomial` that represents a univariate polynomial. The `Polynomial` class includes a list of coefficients, where the i-th element represents the coefficient of the x^i term. Your task is to extend this class by implementing functionalities to find the derivative and integral of the polynomial. # Task 1. Write a method `derivative` in the `Polynomial` class that returns a new `Polynomial` object representing the derivative of the polynomial. 2. Write a method `integral` in the `Polynomial` class that returns a new `Polynomial` object representing the indefinite integral of the polynomial with a constant of integration as 0. # Input * The `Polynomial` object with coefficients as a list of integers or floats. # Output * The `derivative` method should return a new `Polynomial` object with the coefficients representing the derivative of the polynomial. * The `integral` method should return a new `Polynomial` object with the coefficients representing the indefinite integral of the polynomial. # Constraints * The polynomial can have any degree, but the coefficients list will have at least one element. * The input coefficients list will only contain numerical elements (integers or floats). # Example ```python class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients def derivative(self): # Implement this method pass def integral(self): # Implement this method pass # Example Input poly = Polynomial([3, 0, 2]) # Derivative: 6x, which is represented by the new coefficients [0, 6] derivative_poly = poly.derivative() print(derivative_poly.coefficients) # Output: [0, 6] # Integral: 3x + x^3/3, which is represented by the new coefficients [0, 3, 0, 1] integral_poly = poly.integral() print(integral_poly.coefficients) # Output: [0, 3, 0, 1] ``` # Notes * The derivative of ax^b is b*ax^(b-1). * The integral of ax^b is a/(b+1)*x^(b+1) + C, where C is the constant of integration and we assume C = 0. * Ensure to handle edge cases, such as an empty coefficients list gracefully. * Perform a thorough test of your implementation with polynomials of different degrees and coefficients.","solution":"class Polynomial: def __init__(self, coefficients): self.coefficients = coefficients def derivative(self): if len(self.coefficients) == 1: return Polynomial([0]) derivative_coeffs = [(i * self.coefficients[i]) for i in range(1, len(self.coefficients))] return Polynomial(derivative_coeffs) def integral(self): integral_coeffs = [0] + [(self.coefficients[i] / (i + 1)) for i in range(len(self.coefficients))] return Polynomial(integral_coeffs)"},{"question":"# Analyzing Large Data Files for Patterns Context You are working on a project where you need to analyze large data files to detect specific patterns. For this task, you will work with a delimited text file where each line represents a record of data. The goal is to identify and count the number of unique patterns within the data and generate a summary report. Problem Statement Implement two functions: `count_patterns` and `report_summary`. 1. **count_patterns**: This function takes two inputs - a file path `file_path` pointing to a delimited text file and a string `delimiter` which specifies the delimiter used in the file. The function should read the file, identify unique patterns of data based on entire lines, and count the occurrences of each pattern. 2. **report_summary**: This function takes the output dictionary from `count_patterns` and generates a summary report as a string, formatted as follows: - Each line in the summary should display a pattern followed by its count, separated by a colon and a space (`: `). - Patterns should be listed in descending order of their counts. If two patterns have the same count, they should be listed in the order they first appeared in the file. The functions should handle large files efficiently, making use of optimal reading and processing techniques. Requirements 1. **Input and Output Formats**: - Input for `count_patterns`: A string `file_path` representing the path to the file, and a string `delimiter` representing the delimiter in the file. - Output for `count_patterns`: A dictionary where keys are unique patterns (lines) and values are their respective counts. - Input for `report_summary`: A dictionary produced by `count_patterns`. - Output for `report_summary`: A summary string as specified. 2. **Constraints**: - The file can be very large, up to several gigabytes in size. - Each line in the file is a valid string of printable ASCII characters. - The delimiter is a single character. 3. **Performance**: - Ensure the implementation handles large files and generates the summary efficiently within reasonable time limits. Example Assume the file \\"data.txt\\" contains the following lines: ``` apple,banana,orange kiwi,banana,apple apple,banana,orange kiwi,banana,apple apple,orange,banana ``` ```python def count_patterns(file_path: str, delimiter: str) -> dict: # Implement this function pass def report_summary(pattern_counts: dict) -> str: # Implement this function pass # Example usage: pattern_counts = count_patterns(\\"data.txt\\", \\",\\") # Expected output: # { # \\"apple,banana,orange\\": 2, # \\"kiwi,banana,apple\\": 2, # \\"apple,orange,banana\\": 1 # } summary = report_summary(pattern_counts) # Expected output: # \\"apple,banana,orange: 2nkiwi,banana,apple: 2napple,orange,banana: 1\\" ``` Notes - Ensure the solution is efficient in terms of both time and space complexity, using techniques like streaming or buffered reading for large files. - Consider edge cases such as empty lines, varying delimiters, and lines with no data.","solution":"def count_patterns(file_path: str, delimiter: str) -> dict: pattern_counts = {} with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: pattern = line.strip() if pattern: if pattern in pattern_counts: pattern_counts[pattern] += 1 else: pattern_counts[pattern] = 1 return pattern_counts def report_summary(pattern_counts: dict) -> str: sorted_patterns = sorted(pattern_counts.items(), key=lambda item: (-item[1])) summary_lines = [f\\"{pattern}: {count}\\" for pattern, count in sorted_patterns] summary = \\"n\\".join(summary_lines) return summary"},{"question":"**Context**: Recursion is a powerful technique used to solve problems by breaking them down into smaller, more manageable sub-problems. The Fibonacci sequence is a classic example that demonstrates the use of recursion to compute values based on previously computed values. # Problem Statement Implement a function to calculate the nth Fibonacci number using recursion. Additionally, optimize the algorithm to handle large values of n by employing memoization techniques. # Requirements * **Function Name**: `fibonacci` * **Input**: An integer `n` representing the position in the Fibonacci sequence * **Output**: An integer representing the nth Fibonacci number # Constraints - The input `n` will be a non-negative integer. - Do not use iterative loops (for or while). - Use memoization to optimize the computation. # Performance - Aim for time complexity of O(n) with memoization. - Ensure that the space complexity does not exceed O(n). # Example ```python def fibonacci(n: int, memo={}) -> int: # Your code here # Examples: print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(20)) # Output: 6765 ``` # Special Considerations - Handle the base cases where `n` is 0 or 1 directly. - Implement memoization to store previously computed Fibonacci values to avoid redundant calculations. - Ensure your function can handle relatively large values of `n` efficiently. # Testing Create a series of unit tests to validate your function under different scenarios including edge cases (e.g., n being 0 or 1), average cases, and larger values of `n` to ensure performance.","solution":"def fibonacci(n: int, memo=None) -> int: if memo is None: memo = {} if n in memo: return memo[n] if n == 0: return 0 if n == 1: return 1 memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo) return memo[n]"},{"question":"# Question: Implement a Circular Queue Scenario A circular queue is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure efficiently utilizes storage space by allowing elements to wrap around to the beginning of the buffer once it reaches the end. This is particularly useful in scenarios like buffering, resource management, and task scheduling. Task Implement a class `CircularQueue` with the following methods: 1. **`__init__(self, k: int):`** * Initializes the queue with a given capacity `k`. 2. **`enqueue(self, value: int) -> bool:`** * Adds an element to the circular queue. Return `True` if the operation is successful, or `False` if the queue is full. 3. **`dequeue(self) -> int:`** * Removes and returns the front element from the circular queue. If the queue is empty, return `-1`. 4. **`Front(self) -> int:`** * Gets the front item from the queue. If the queue is empty, return `-1`. 5. **`Rear(self) -> int:`** * Gets the last item from the queue. If the queue is empty, return `-1`. 6. **`isEmpty(self) -> bool:`** * Checks whether the circular queue is empty or not. 7. **`isFull(self) -> bool:`** * Checks whether the circular queue is full or not. Constraints * All operations should complete with O(1) time complexity. * The methods will be called as follows: * `queue = CircularQueue(k)` * `param_1 = queue.enqueue(value)` * `param_2 = queue.dequeue()` * `param_3 = queue.Front()` * `param_4 = queue.Rear()` * `param_5 = queue.isEmpty()` * `param_6 = queue.isFull()` Example ```python queue = CircularQueue(3) print(queue.enqueue(1)) # returns True print(queue.enqueue(2)) # returns True print(queue.enqueue(3)) # returns True print(queue.enqueue(4)) # returns False, queue is full print(queue.Rear()) # returns 3 print(queue.isFull()) # returns True print(queue.dequeue()) # returns 1 print(queue.enqueue(4)) # returns True print(queue.Rear()) # returns 4 ```","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [None] * k self.head = -1 self.tail = -1 def enqueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.head = 0 self.tail = (self.tail + 1) % self.size self.queue[self.tail] = value return True def dequeue(self) -> int: if self.isEmpty(): return -1 value = self.queue[self.head] if self.head == self.tail: self.head = self.tail = -1 else: self.head = (self.head + 1) % self.size return value def Front(self) -> int: return -1 if self.isEmpty() else self.queue[self.head] def Rear(self) -> int: return -1 if self.isEmpty() else self.queue[self.tail] def isEmpty(self) -> bool: return self.head == -1 def isFull(self) -> bool: return (self.tail + 1) % self.size == self.head"},{"question":"# Coding Assessment Question Scenario You have been employed by a company working on a financial application that requires functionality to convert a given number of seconds into a human-readable format expressing days, hours, minutes, and seconds. Your task is to implement this conversion while handling various edge cases effectively. Objectives Implement a function that converts a given number of seconds into a tuple representing days, hours, minutes, and seconds. Function Signature ```python def convert_seconds(seconds: int) -> tuple: pass ``` Input * An integer `seconds` representing the total number of seconds to be converted. Output * A tuple of four integers `(days, hours, minutes, seconds)` representing the equivalent duration. Constraints * The input `seconds` will be a non-negative integer between 0 and 10<sup>9</sup> inclusive. Performance Requirements * The function should run in constant time and space complexity, O(1). Example ```python >>> convert_seconds(86461) (1, 0, 1, 1) >>> convert_seconds(1234567) (14, 6, 56, 7) >>> convert_seconds(59) (0, 0, 0, 59) >>> convert_seconds(3600) (0, 1, 0, 0) ``` Instructions 1. Implement the function to handle various ranges and edge cases, including zero seconds. 2. Ensure the function adheres to the specified input/output formats. 3. Do not import any additional libraries. Use only the standard mathematical operations available in Python.","solution":"def convert_seconds(seconds: int) -> tuple: Converts a given number of seconds into days, hours, minutes, and seconds. Parameters: seconds (int): The total number of seconds to be converted. Returns: tuple: A tuple of four integers representing days, hours, minutes, and seconds. days = seconds // 86400 seconds %= 86400 hours = seconds // 3600 seconds %= 3600 minutes = seconds // 60 seconds %= 60 return days, hours, minutes, seconds"},{"question":"# Problem Statement You are tasked with implementing a simple cache mechanism that stores the results of expensive function calls and reuses the cached result when the same inputs occur again. The key idea is to improve performance by avoiding repeated calculations. # Requirements 1. Implement a class `SimpleCache` that has the following methods: * `__init__(self)`: Initializes an empty cache. * `add(self, key: Any, value: Any)`: Adds a key-value pair to the cache. * `get(self, key: Any) -> Any`: Retrieves a value from the cache based on the provided key. If the key does not exist, raises a `KeyError`. * `exists(self, key: Any) -> bool`: Checks if a given key exists in the cache and returns a boolean. * `clear(self)`: Clears all items from the cache. 2. The cache should handle any hashable data types for keys and values. # Input Format ```python class SimpleCache: def __init__(self): # Your implementation here def add(self, key: Any, value: Any): # Your implementation here def get(self, key: Any) -> Any: # Your implementation here def exists(self, key: Any) -> bool: # Your implementation here def clear(self): # Your implementation here ``` # Output Format For each method: - `add`: Does not return anything. - `get`: Returns the value associated with the provided key. - `exists`: Returns True if the key exists, otherwise False. - `clear`: Does not return anything. # Example ```python cache = SimpleCache() cache.add(\'a\', 1) cache.add(\'b\', 2) print(cache.get(\'a\')) # Output: 1 print(cache.exists(\'b\')) # Output: True print(cache.exists(\'c\')) # Output: False cache.clear() print(cache.exists(\'a\')) # Output: False ``` # Constraints * Keys must be hashable. * The cache must handle insertion, retrieval, existence check, and clearing in constant time on average.","solution":"class SimpleCache: def __init__(self): self.cache = {} def add(self, key, value): self.cache[key] = value def get(self, key): if key in self.cache: return self.cache[key] else: raise KeyError(f\'Key {key} not found in cache\') def exists(self, key): return key in self.cache def clear(self): self.cache.clear()"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a feature for a text-processing application that frequently analyzes large documents. One of the essential features is the ability to count the frequency of each character in a given text efficiently. This function should be optimized to handle very large inputs while returning an accurate count of every character. **Task**: Write a function that takes a string as input and returns a dictionary where the keys are characters and the values are the respective frequencies of those characters in the given string. **Function Signature**: ```python def character_frequency(data: str) -> dict: Compute the frequency of each character in the given input string. :param data: str - Input string. :return: dict - A dictionary with characters as keys and their frequencies as values. ``` **Input**: - A single string `data` which can include alphanumeric characters and special characters (0 <= length of data <= 10^6). **Output**: - A dictionary with characters as keys and integers as values representing the frequency of each character in the input string. **Constraints**: - The function needs to handle an empty string gracefully. - Ensure the function executes efficiently even for very large strings. **Example**: ```python assert character_frequency(\'hello\') == {\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1} assert character_frequency(\'aabbbcccc\') == {\'a\': 2, \'b\': 3, \'c\': 4} assert character_frequency(\'\') == {} ```","solution":"def character_frequency(data: str) -> dict: Compute the frequency of each character in the given input string. :param data: str - Input string. :return: dict - A dictionary with characters as keys and their frequencies as values. frequency = {} for char in data: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Question Problem Statement You are developing a route planning feature for a ride-sharing application. The application aims to minimize the total travel distance for a driver who has to pick up multiple passengers from different locations and drop them off at their respective destinations. Each passenger has a specified pickup and drop-off location. You need to write a function to determine the optimal order in which the driver should visit all the locations to minimize the total travel distance using a greedy algorithm. Function Signature ```python def plan_route(pickup_dropoff_pairs: list, start_location: tuple) -> tuple: # Your code here ``` Definitions - `pickup_dropoff_pairs`: A list of tuples where each tuple consists of two tuples representing the pickup and drop-off locations of a passenger. Each location is represented as a coordinate pair (x, y). - `start_location`: A tuple representing the starting location of the driver, given as coordinates (x, y). Output The function should return a tuple containing: 1. A list of tuples representing the order in which the driver should visit the locations (both pickups and drop-offs). 2. The total travel distance for the completed route. Constraints - The greedy algorithm must prioritize the next closest location to minimize total travel distance at each step. - The function should handle cases where there are multiple pickups and drop-offs efficiently. Example Usage ```python locations = [((1, 2), (3, 4)), ((2, 3), (5, 6)), ((6, 7), (8, 9))] start = (0, 0) print(plan_route(locations, start)) # Output should match a sequence of locations to minimize total distance. ``` Notes - Ensure that your function accurately calculates the travel distance between locations. - Consider edge cases such as having only one passenger or very close locations. - The efficiency of your algorithm is critical, so consider the impact of your approach on larger datasets.","solution":"import math def plan_route(pickup_dropoff_pairs, start_location): def distance(loc1, loc2): return math.sqrt((loc1[0] - loc2[0]) ** 2 + (loc1[1] - loc2[1]) ** 2) def find_closest_location(current_location, remaining_locations): closest_location = None min_distance = float(\'inf\') for location in remaining_locations: curr_distance = distance(current_location, location) if curr_distance < min_distance: min_distance = curr_distance closest_location = location return closest_location, min_distance remaining_pickups = [pickup for pickup, _ in pickup_dropoff_pairs] remaining_dropoffs = [dropoff for _, dropoff in pickup_dropoff_pairs] route = [] current_location = start_location total_distance = 0 while remaining_pickups or remaining_dropoffs: if remaining_pickups: closest_pickup, dist_to_pickup = find_closest_location(current_location, remaining_pickups) closest_dropoff, dist_to_dropoff = find_closest_location(current_location, remaining_dropoffs) if dist_to_pickup < dist_to_dropoff: route.append(closest_pickup) total_distance += dist_to_pickup current_location = closest_pickup remaining_pickups.remove(closest_pickup) else: route.append(closest_dropoff) total_distance += dist_to_dropoff current_location = closest_dropoff remaining_dropoffs.remove(closest_dropoff) else: closest_dropoff, dist_to_dropoff = find_closest_location(current_location, remaining_dropoffs) route.append(closest_dropoff) total_distance += dist_to_dropoff current_location = closest_dropoff remaining_dropoffs.remove(closest_dropoff) return route, total_distance"},{"question":"# Problem Statement Create a function that analyzes a passage of text to find the top `N` most common words, excluding a given list of stop words. The primary objective is to handle string manipulation and data aggregation efficiently. # Functionality Requirements - Implement a function `common_words(text: str, stop_words: list, N: int) -> list` that takes a passage of text, a list of stop words, and an integer `N`. - The function should return the top `N` most common words in the text as a list of tuples, where each tuple contains a word and its frequency. - Words should be considered case-insensitively and punctuation should be ignored. # Constraints - The input text should be a single string containing multiple sentences. - Assume that words are separated by spaces and punctuation marks. - The stop words list will contain all lowercase characters. - You must use the `collections` module to handle frequency counting. # Input - `text` (str): The passage of text to analyze. - `stop_words` (list): A list of stop words to exclude from the analysis. - `N` (int): The number of top common words to return. # Output - A list of tuples, where each tuple contains a word (str) and its frequency (int). # Examples ```python common_words(\\"A journey of a thousand miles begins with a single step.\\", [\\"a\\", \\"of\\", \\"with\\"], 3) ``` should return: ```python [(\'journey\', 1), (\'thousand\', 1), (\'miles\', 1)] ``` ```python common_words(\\"To be, or not to be: that is the question.\\", [\\"to\\", \\"be\\", \\"is\\", \\"the\\"], 2) ``` should return: ```python [(\'or\', 1), (\'not\', 1)] ``` # Scenario You are developing an analytical tool that performs text analysis on large documents. Extracting the most frequent words, excluding common stop words, will help in identifying key topics within the document. # Performance Requirements - Ensure the solution handles large text inputs efficiently. - Optimize for minimal memory usage and quick processing time. # Hints - Consider using regular expressions to handle punctuation removal. - Use `collections.Counter` to simplify frequency counting.","solution":"import re from collections import Counter def common_words(text, stop_words, N): Find the top N most common words in the text, excluding the given stop words. Parameters: text (str): The passage of text to analyze. stop_words (list): A list of stop words to exclude from the analysis. N (int): The number of top common words to return. Returns: list: A list of tuples, where each tuple contains a word (str) and its frequency (int). # Normalize text to lowercase and remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text.lower()) words = text.split() # Filter out stop words filtered_words = [word for word in words if word not in stop_words] # Use Counter to count word frequencies word_counts = Counter(filtered_words) # Get the top N most common words as a list of tuples most_common = word_counts.most_common(N) return most_common"},{"question":"Question # Problem Statement: You are given a list of integers. Your task is to write a function `sum_of_powers(nums: List[int], p: int) -> int` that computes the sum of each integer in the list raised to the given power `p`. # Function Signature: ```python def sum_of_powers(nums: List[int], p: int) -> int: pass ``` # Input: - A list of integers `nums` where `1 <= len(nums) <= 1000` and each integer is `0 <= num <= 100`. - An integer `p` where `0 <= p <= 10`. # Output: - An integer representing the sum of each element in the list raised to the power `p`. # Constraints: - The list can contain zero or more integers with possible repeat values. - The function should behave correctly for any valid input as specified above. # Examples: ```python assert sum_of_powers([1, 2, 3], 2) == 14 assert sum_of_powers([0, 4, 5], 3) == 189 assert sum_of_powers([1, 1, 1, 1], 0) == 4 assert sum_of_powers([10, 20], 1) == 30 assert sum_of_powers([2, 2, 2], 10) == 3072 assert sum_of_powers([100], 2) == 10000 assert sum_of_powers([], 5) == 0 ``` # Additional Instructions: - Handle edge cases such as empty input list and zero power correctly. - Ensure efficient computation given the constraints. # Note: - Consider using built-in functions and list comprehensions for a concise implementation. --- This question provides a Python programming challenge that requires manipulating lists and performing mathematical operations over elements, fitting well within the style, complexity, and scope of the provided example question.","solution":"from typing import List def sum_of_powers(nums: List[int], p: int) -> int: Computes the sum of each integer in the list raised to the given power p. return sum(num ** p for num in nums)"},{"question":"# Problem Statement You are given an array of integers where each element represents the height of a building in a skyline. The distance between each building is the same. You need to implement a function to find the maximum rectangular area formed between the buildings, which is the same as finding the largest rectangle of contiguous buildings in the histogram. Function Signature ```python def largest_skyline_area(heights: list[int]) -> int: Finds the largest rectangular area of contiguous buildings in the skyline. :param heights: List of integers representing the heights of buildings. :return: An integer representing the area of the largest rectangular section. ``` Input - `heights`: A list of integers where each integer represents the height of a building. Output - An integer representing the area of the largest rectangle formed by contiguous buildings. Constraints - The list can contain up to (10^5) elements. - Each height is a non-negative integer and can be up to (10^4). Example ```python assert largest_skyline_area([2, 1, 5, 6, 2, 3]) == 10 assert largest_skyline_area([1, 2, 3, 4, 5]) == 9 ```","solution":"def largest_skyline_area(heights): Finds the largest rectangular area of contiguous buildings in the skyline. :param heights: List of integers representing the heights of buildings. :return: An integer representing the area of the largest rectangular section. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Reverse Level Order Traversal Objective Implement a function `reverse_level_order(root)` which takes the root of a binary tree and returns a list of its nodes\' values in reverse level order (bottom to top, left to right). Function Signature ```python def reverse_level_order(root: Optional[Node]) -> List[int]: ``` Input - `root`: The root node of a binary tree (Node), where Node is a class that has: - An `int` value. - A `Node` reference to the left child. - A `Node` reference to the right child. Output - A list of integers representing the nodes\' values in reverse level order. Example ```python # Implement Node class according to the given definition # Example usage: # Create a binary tree root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.left = Node(6) root.right.right = Node(7) # Function call result = reverse_level_order(root) # Expected Output: # [4, 5, 6, 7, 2, 3, 1] ``` Constraints - The number of nodes in the tree can be up to 10^4. - The values of the nodes are between -1000 and 1000. - Assume that the node values are distinct. Performance Requirements - Time complexity should be O(n), where n is the number of nodes in the tree. - Space complexity should consider the storage for the nodes along with the call stack for recursion. Notes - Implement the `Node` class as per the given definition. - Ensure to handle edge cases such as empty trees or trees with a single node.","solution":"from typing import Optional, List import collections class Node: def __init__(self, value: int, left: Optional[\'Node\'] = None, right: Optional[\'Node\'] = None): self.value = value self.left = left self.right = right def reverse_level_order(root: Optional[Node]) -> List[int]: if root is None: return [] queue = collections.deque([root]) result = collections.deque() while queue: node = queue.popleft() result.appendleft(node.value) if node.right: queue.append(node.right) if node.left: queue.append(node.left) return list(result)"},{"question":"# Task You are required to write a function `longest_increasing_subsequence(nums: list) -> int` that finds the length of the longest strictly increasing subsequence in a given list of integers. # Input - A list of integers `nums` with (1 leq len(nums) leq 10^4). # Output - An integer representing the length of the longest strictly increasing subsequence. # Constraints - ( -10^6 leq nums[i] leq 10^6 ) where (0 leq i < len(nums)) # Performance Requirements - The solution should have a time complexity of (O(n log n)). # Scenario You are developing a feature for a data analytics application that needs to identify patterns in time-series data. One of your tasks is to detect the longest period where values steadily increase. This functionality can be crucial for predicting trends or assessing performance metrics. # Example ```python >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 3, 6, 7, 9, 4, 10, 5, 6]) 6 ``` # Implementation ```python def longest_increasing_subsequence(nums: list) -> int: if not nums: return 0 lis = [] def binary_search(data, target): left, right = 0, len(data) while left < right: mid = (left + right) // 2 if data[mid] >= target: right = mid else: left = mid + 1 return left for num in nums: pos = binary_search(lis, num) if pos >= len(lis): lis.append(num) else: lis[pos] = num return len(lis) ``` This question assesses the candidate’s understanding of dynamic programming and binary search, ensuring they are capable of optimizing algorithms to meet higher complexity requirements.","solution":"def longest_increasing_subsequence(nums: list) -> int: if not nums: return 0 lis = [] def binary_search(data, target): left, right = 0, len(data) while left < right: mid = (left + right) // 2 if data[mid] >= target: right = mid else: left = mid + 1 return left for num in nums: pos = binary_search(lis, num) if pos >= len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# Coding Question Context In cryptography, a common task is to encode a string so that it is scrambled and unreadable without a key to decode it. One simple encoding method is the Caesar Cipher, which shifts each letter by a fixed number of positions in the alphabet. For example, with a shift of 3: - \'A\' becomes \'D\' - \'B\' becomes \'E\' - \'Z\' becomes \'C\' (wraps around the alphabet) You are tasked with implementing a program that can encode and decode a string using a Caesar Cipher. Tasks 1. Implement a function `caesar_encode` to encode a given string with a specified shift. 2. Implement a function `caesar_decode` to decode a given encoded string with the specified shift. # Function Signatures ```python def caesar_encode(text: str, shift: int) -> str: # your code here def caesar_decode(encoded_text: str, shift: int) -> str: # your code here ``` # Requirements - The encoding and decoding should be case-sensitive, meaning \'A\' and \'a\' are treated differently. - The functions should only shift alphabetic characters and leave other characters (such as punctuation and whitespace) unchanged. - For both encoding and decoding, use positive integer values for shift. # Constraints - `1 <= shift <= 25` - The input string may include spaces, punctuation, and numeric characters, but only alphabetic characters are shifted. # Example Usage ```python # Test cases for Caesar Cipher encoding caesar_encode(\\"Hello, World!\\", 3) # should return \\"Khoor, Zruog!\\" # Test cases for Caesar Cipher decoding caesar_decode(\\"Khoor, Zruog!\\", 3) # should return \\"Hello, World!\\" ``` Ensure your functions handle edge cases such as shifts that wrap around the end of the alphabet and strings with a mix of characters correctly.","solution":"def caesar_encode(text: str, shift: int) -> str: result = [] for char in text: if char.isalpha(): # Determine offset based on case offset = 65 if char.isupper() else 97 encoded_char = chr((ord(char) + shift - offset) % 26 + offset) result.append(encoded_char) else: result.append(char) return \'\'.join(result) def caesar_decode(encoded_text: str, shift: int) -> str: result = [] for char in encoded_text: if char.isalpha(): # Determine offset based on case offset = 65 if char.isupper() else 97 decoded_char = chr((ord(char) - shift - offset) % 26 + offset) result.append(decoded_char) else: result.append(char) return \'\'.join(result)"},{"question":"# Fibonacci Sequence Calculation Problem Statement The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. Given a positive integer `n`, compute the nth Fibonacci number using both iterative and recursive methods. You are required to implement the iterative and recursive versions for calculating the nth Fibonacci number. # Function Specifications 1. `fibonacci_iterative(n: int) -> int` * **Input**: A positive integer ( n ). * **Output**: The nth Fibonacci number. * **Constraints**: * Raise `ValueError` if `n` is not a positive integer. * Compute the result using an iterative approach. 2. `fibonacci_recursive(n: int) -> int` * **Input**: A positive integer ( n ). * **Output**: The nth Fibonacci number. * **Constraints**: * Raise `ValueError` if `n` is not a positive integer. * Compute the result using a recursive approach. * Ensure the recursion handles base cases and terminates correctly. # Example Usage: ```python >>> fibonacci_iterative(10) 55 >>> fibonacci_recursive(10) 55 >>> fibonacci_iterative(1) 1 >>> fibonacci_recursive(1) 1 >>> fibonacci_recursive(0) Traceback (most recent call last): ... ValueError: n must be a positive integer >>> fibonacci_iterative(-5) Traceback (most recent call last): ... ValueError: n must be a positive integer ``` # Submission Submit your code implementing both functions. Ensure it handles all edge cases and passes the above usage examples. Also, include a brief explanation of your approach for each method.","solution":"def fibonacci_iterative(n: int) -> int: Returns the nth Fibonacci number using an iterative approach. if n < 0: raise ValueError(\\"n must be a positive integer\\") if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b def fibonacci_recursive(n: int) -> int: Returns the nth Fibonacci number using a recursive approach. if n < 0: raise ValueError(\\"n must be a positive integer\\") if n == 0: return 0 elif n == 1: return 1 return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)"},{"question":"# Problem Statement: You are working on a file system analysis tool to help users understand their disk usage. Your tool should analyze a directory structure and compute the size of each directory, taking into account all files and subdirectories within it. # Objective: Write a function `directory_size_analysis` that accepts the following parameters: 1. **root_directory**: str - The path to the root directory from which the analysis should start. The function performs the following tasks: 1. Traverse the directory structure starting from the `root_directory`. 2. Compute the total size of each directory by summing the sizes of all files contained within it and its subdirectories. 3. Return a dictionary where the keys are directory paths and the values are their corresponding sizes in bytes. Constraints: 1. If a directory is empty, its size should be 0. 2. Account for hidden files and directories as well. 3. Handle possible errors gracefully, e.g., permissions issues, by skipping directories that cannot be accessed but continuing the analysis. 4. Symlinks may be ignored for simplicity. # Input/Output: Input: * A single string representing the root directory path. Output: * Dictionary: The keys are the directory paths (str) discovered during the traversal, and the values are their sizes (int) in bytes. # Example: ```python # Assuming the following directory structure and sizes: # /root # |-- /subdir1 # | |-- file1.txt (100 bytes) # | |-- file2.txt (200 bytes) # |-- /subdir2 # | |-- file3.txt (300 bytes) # | |-- /subsubdir1 # | |-- file4.txt (400 bytes) # |-- file5.txt (500 bytes) result = directory_size_analysis(\\"/root\\") print(result) # Expected output: # { # \\"/root\\": 1500, # \\"/root/subdir1\\": 300, # \\"/root/subdir2\\": 700, # \\"/root/subdir2/subsubdir1\\": 400 # } ``` # Your Task: Write the function `directory_size_analysis` that implements the specification detailed above.","solution":"import os def directory_size_analysis(root_directory): Computes the size of each directory starting from the root directory. Parameters: - root_directory (str): The path to the root directory from which the analysis starts. Returns: - dict: A dictionary where the keys are directory paths and the values are their corresponding sizes in bytes. directory_sizes = {} def calculate_directory_size(directory): total_size = 0 try: for entry in os.scandir(directory): if entry.is_dir(follow_symlinks=False): # Recursively calculate the size of the subdirectory total_size += calculate_directory_size(entry.path) elif entry.is_file(follow_symlinks=False): # Add file size total_size += entry.stat().st_size except PermissionError: # Skip directories that cannot be accessed due to permissions return 0 directory_sizes[directory] = total_size return total_size calculate_directory_size(root_directory) return directory_sizes"},{"question":"# Binary Tree Traversal Context You are provided with a binary tree and tasked with implementing different types of tree traversals. The goal is to ensure you grasp the distinction between depth-first and breadth-first traversal strategies as well as to exercise recursive and iterative solutions while handling edge cases such as empty trees. Requirements Implement three functions to perform in-order, pre-order, and post-order traversals of a binary tree. Each function should return a list of the values in the respective traversal order. # Function Signatures ```python def inorder_traversal(root: Optional[TreeNode]) -> List[int]: def preorder_traversal(root: Optional[TreeNode]) -> List[int]: def postorder_traversal(root: Optional[TreeNode]) -> List[int]: ``` # Definitions - `class TreeNode`: A class representing a node in a binary tree. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Input - `root`: The root node of the binary tree. Output - A list of integers representing the values of nodes in the specific traversal order. # Examples ```python # Example 1: # Input: # 1 # # 2 # / # 3 # In-order output: [1, 3, 2] # Pre-order output: [1, 2, 3] # Post-order output: [3, 2, 1] # Example 2: # Input: Empty tree # In-order output: [] # Pre-order output: [] # Post-order output: [] ```","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def inorder(node): if node: inorder(node.left) result.append(node.val) inorder(node.right) inorder(root) return result def preorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def preorder(node): if node: result.append(node.val) preorder(node.left) preorder(node.right) preorder(root) return result def postorder_traversal(root: Optional[TreeNode]) -> List[int]: result = [] def postorder(node): if node: postorder(node.left) postorder(node.right) result.append(node.val) postorder(root) return result"},{"question":"# Coding Assessment Question: Email Address Validator for Multiple Domains You are working for a company that operates in multiple regions, and your task is to validate employee email addresses according to region-specific domain rules. The company uses different domain names for each region, and an email is considered valid only if it matches one of the authorized domains: 1. Each email address must contain exactly one \'@\' symbol. 2. The local part (before the \'@\') can contain alphabets, numbers, and the symbols \'.\' and \'_\'. 3. The domain part (after the \'@\') should belong to one of the authorized domains. You need to implement an email validator that ensures the email conforms to the above rules and matches one of the approved domains. **Function Specification** ```python def validate_email(email: str) -> bool: Validate the given email address according to company-specific rules. Parameters: email (str): The email address to be checked. Returns: bool: True if the email address is valid, otherwise False. ``` Below are the steps and constraints to consider: # Input * A string `email` representing the email address to validate. The string can be any length from 0 upwards. # Output * Return `True` if the email is valid according to the company\'s rules. * Return `False` if the email does not match the rules, contains invalid characters, or does not belong to an authorized domain. # Constraints - The function should ignore case sensitivity for domain checks. - The local part of the email should start and end with an alphanumeric character. - The email should not contain consecutive \'.\' or \'_\' characters in the local part. # Authorized Domains ```python AUTHORIZED_DOMAINS = [\\"company.com\\", \\"company.org\\", \\"company.net\\"] ``` # Example ```python print(validate_email(\\"john.doe@company.com\\")) # True print(validate_email(\\"jane_doe@company.org\\")) # True print(validate_email(\\"invalid-email@otherdomain.com\\")) # False print(validate_email(\\"admin@company\\")) # False print(validate_email(\\"employee@company.com\\")) # True print(validate_email(\\"bad..syntax@company.com\\")) # False print(validate_email(\\"..leadingdots@company.com\\")) # False ``` # Notes - Ensure the function handles edge cases, such as emails with multiple \'@\' symbols or invalid domains. - Focus on correctness and adherence to the specified format when validating email addresses. - Optimize the function for readability and efficiency.","solution":"AUTHORIZED_DOMAINS = [\\"company.com\\", \\"company.org\\", \\"company.net\\"] def validate_email(email: str) -> bool: Validate the given email address according to company-specific rules. Parameters: email (str): The email address to be checked. Returns: bool: True if the email address is valid, otherwise False. if email.count(\'@\') != 1: return False local_part, domain_part = email.split(\'@\') if not local_part or not domain_part: return False if not domain_part.lower() in AUTHORIZED_DOMAINS: return False if not local_part[0].isalnum() or not local_part[-1].isalnum(): return False if \'..\' in local_part or \'__\' in local_part: return False valid_chars = set(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\\") return all(c in valid_chars for c in local_part)"},{"question":"Data Normalization In this task, you will implement a function to normalize a given list of numerical values. Normalization is the process of scaling values into a range of ([0, 1]) based on the formula: [ text{Normalized_value} = frac{text{value} - text{min}}{text{max} - text{min}} ] where: - (text{value}) is the individual number in the list. - (text{min}) is the minimum value in the list. - (text{max}) is the maximum value in the list. # Requirements: 1. Implement the function `normalize_values()` with the following signature: ```python def normalize_values(values: List[float]) -> List[float]: ``` 2. Ensure the function raises appropriate exceptions for the following invalid inputs: - `ValueError` if the input list is empty. - `ValueError` if `max` is equal to `min` (as this would result in division by zero). - Descriptive messages for these exceptions should be: - \\"Input list cannot be empty.\\" - \\"Normalization not possible when all values are identical.\\" 3. The function should return a list of float values rounded to three decimal places. 4. Constraints: - The length of the list will be (1 leq text{len(values)} leq 10000). - Each value in the list will be in the range ([-1000, 1000]). # Function Signature ```python from typing import List def normalize_values(values: List[float]) -> List[float]: ``` # Examples ```python # Example 1 print(normalize_values([2, 8, 3, 5])) # Output: [0.0, 1.0, 0.167, 0.5] # Example 2 print(normalize_values([-1, 0, 1])) # Output: [0.0, 0.5, 1.0] # Example 3: Input list is empty should raise an exception try: print(normalize_values([])) except ValueError as e: print(e) # Output: Input list cannot be empty. # Example 4: All values are identical should raise an exception try: print(normalize_values([5, 5, 5, 5])) except ValueError as e: print(e) # Output: Normalization not possible when all values are identical. ``` Implement the function and ensure it handles the constraints, edge cases, and performs the normalization accurately.","solution":"from typing import List def normalize_values(values: List[float]) -> List[float]: if not values: raise ValueError(\\"Input list cannot be empty.\\") min_val = min(values) max_val = max(values) if min_val == max_val: raise ValueError(\\"Normalization not possible when all values are identical.\\") normalized_values = [(value - min_val) / (max_val - min_val) for value in values] return [round(val, 3) for val in normalized_values]"},{"question":"# Problem: Longest Common Subsequence with Memory Optimization Context: You are developing a text processing tool to find common patterns in strings. The application needs to compute the Longest Common Subsequence (LCS) between two strings efficiently, particularly focusing on memory usage due to limited resources. Task: 1. Implement an algorithm to find the length of the Longest Common Subsequence (LCS) between two given strings. 2. Optimize memory usage during the implementation to handle longer strings effectively. Requirements: * Implement a dynamic programming approach with space optimization. * Handle edge cases such as empty strings gracefully. * Ensure that the memory usage is minimized, potentially using only a 1D array for storing intermediate results. Function Signature: ```python def optimized_lcs_length(str1: str, str2: str) -> int: pass ``` Input: * `str1` - A string with a maximum length of 1000 characters. * `str2` - Another string with a maximum length of 1000 characters. Output: * An integer representing the length of the Longest Common Subsequence. Constraints: * Strings consist of uppercase and lowercase Latin letters. Examples: 1. For strings: ```python str1 = \\"ABCDGH\\" str2 = \\"AEDFHR\\" ``` The result should be: ```python 3 ``` Explanation: The longest common subsequence is \\"ADH\\". 2. For strings: ```python str1 = \\"AGGTAB\\" str2 = \\"GXTXAYB\\" ``` The result should be: ```python 4 ``` Explanation: The longest common subsequence is \\"GTAB\\". 3. For edge cases: ```python str1 = \\"\\" str2 = \\"ABCDE\\" ``` The result should be: ```python 0 ``` Explanation: There is no common subsequence between an empty string and any string.","solution":"def optimized_lcs_length(str1: str, str2: str) -> int: Returns the length of the Longest Common Subsequence (LCS) between two strings. This implementation uses dynamic programming with space optimization. if not str1 or not str2: return 0 len1, len2 = len(str1), len(str2) # Initialize a 1D array to store the current and previous rows of DP table previous = [0] * (len2 + 1) for i in range(1, len1 + 1): current = [0] * (len2 + 1) for j in range(1, len2 + 1): if str1[i - 1] == str2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) previous = current return previous[len2]"},{"question":"# Problem Description You are required to implement a function that filters a list of integers based on multiple conditions. The conditions include removing duplicates, filtering out numbers below a threshold, and sorting the resulting list. # Objective Implement the following function: ```python def filter_and_sort_numbers(numbers: list[int], threshold: int) -> list[int]: Filters a list of integers by removing duplicates, excluding integers below a certain threshold, and then sorting the remaining integers. Parameters: numbers (list of int): The list of integers to be processed. threshold (int): The minimum value an integer must have to be included in the output list. Returns: list of int: A sorted list of unique integers that are greater than or equal to the threshold. ``` # Input * `numbers`: A list of integers. The list can contain from 1 to 10^6 integers. * `threshold`: An integer representing the minimum allowable value for integers to be included in the output list. # Output * A list of unique integers sorted in ascending order, where each integer is greater than or equal to the specified threshold. # Constraints * Each integer in the `numbers` list is within the range of -10^9 to 10^9. * The `threshold` integer is within the range of -10^9 to 10^9. # Example ```python # Example input input_numbers = [5, 3, 7, 3, 9, 1, 5, 8, 6, 4] min_threshold = 5 # Function call result = filter_and_sort_numbers(input_numbers, min_threshold) # Expected output # [5, 6, 7, 8, 9] ``` Implement the `filter_and_sort_numbers` function to complete the task.","solution":"def filter_and_sort_numbers(numbers: list[int], threshold: int) -> list[int]: Filters a list of integers by removing duplicates, excluding integers below a certain threshold, and then sorting the remaining integers. Parameters: numbers (list of int): The list of integers to be processed. threshold (int): The minimum value an integer must have to be included in the output list. Returns: list of int: A sorted list of unique integers that are greater than or equal to the threshold. # Remove duplicates by converting the list to a set unique_numbers = set(numbers) # Filter out numbers below the threshold filtered_numbers = [num for num in unique_numbers if num >= threshold] # Sort the resulting list in ascending order sorted_numbers = sorted(filtered_numbers) return sorted_numbers"},{"question":"# Problem Statement You have been hired to develop a module for an e-commerce platform to help manage inventory levels. Your task is to write a function that calculates the total stock of products given a list of stock updates. Each update increases or decreases the stock of a specific product. Implement the solution according to the specific requirements outlined below. # Function Signature ```python def calculate_total_stock(products: List[str], updates: List[Tuple[str, int]]) -> Dict[str, int]: pass ``` # Input - A list of strings `products` representing the names of products in the inventory. - A list of tuples `updates`, where each tuple contains a product name and an integer representing the change in stock (positive for increments and negative for decrements). # Output - Return a dictionary where the keys are product names and the values are the final stock levels after applying the updates. # Constraints - All product names in `updates` are guaranteed to be present in the `products` list. - No product will have a negative stock level as the result of the updates. - Each product\'s stock level should be initialized to 0 before applying updates. - The total number of products (P) (1 ≤ P ≤ 10^3). - The total number of updates (U) (1 ≤ U ≤ 10^5). # Examples 1. **Example 1:** - Input: `products = [\\"apple\\", \\"banana\\", \\"cherry\\"]` `updates = [(\\"apple\\", 50), (\\"banana\\", 30), (\\"apple\\", -20), (\\"cherry\\", 25)]` - Output: `{\\"apple\\": 30, \\"banana\\": 30, \\"cherry\\": 25}` - Explanation: - \\"apple\\" stock after updates: 0 + 50 - 20 = 30 - \\"banana\\" stock after updates: 0 + 30 = 30 - \\"cherry\\" stock after updates: 0 + 25 = 25 2. **Example 2:** - Input: `products = [\\"pen\\", \\"notebook\\", \\"eraser\\"]` `updates = [(\\"pen\\", 10), (\\"notebook\\", 15), (\\"pen\\", 5), (\\"eraser\\", 5), (\\"notebook\\", -5)]` - Output: `{\\"pen\\": 15, \\"notebook\\": 10, \\"eraser\\": 5}` - Explanation: - \\"pen\\" stock after updates: 0 + 10 + 5 = 15 - \\"notebook\\" stock after updates: 0 + 15 - 5 = 10 - \\"eraser\\" stock after updates: 0 + 5 = 5 3. **Example 3:** - Input: `products = [\\"chair\\", \\"desk\\"]` `updates = [(\\"chair\\", 40), (\\"desk\\", 12), (\\"chair\\", -10), (\\"desk\\", -2)]` - Output: `{\\"chair\\": 30, \\"desk\\": 10}` - Explanation: - \\"chair\\" stock after updates: 0 + 40 - 10 = 30 - \\"desk\\" stock after updates: 0 + 12 - 2 = 10 # Performance Requirements Your solution should efficiently handle up to 10^5 updates with a time complexity of (O(U)) and a space complexity of (O(P)).","solution":"from typing import List, Tuple, Dict def calculate_total_stock(products: List[str], updates: List[Tuple[str, int]]) -> Dict[str, int]: Calculate the total stock of products given a list of stock updates. Args: products (List[str]): List of product names. updates (List[Tuple[str, int]]): List of tuples where each tuple contains a product name and an integer representing the change in stock. Returns: Dict[str, int]: Dictionary where keys are product names and values are the final stock levels. # Initialize the dictionary with all product names and initial stock of 0 stock_levels = {product: 0 for product in products} # Process each update and modify the stock levels accordingly for product, change in updates: stock_levels[product] += change return stock_levels"},{"question":"# Unique Characters Challenge Objective You are tasked to implement a function to determine whether a given string has all unique characters. Scenario Consider a program that needs to check if user input strings are valid based on the uniqueness of their characters as part of its validation routine. The function must be efficient and handle edge cases appropriately. Function Specifications: * **Function Name**: `has_unique_characters` * **Input**: A string `s` of length `0 ≤ len(s) ≤ 256`. * **Output**: Returns `True` if all characters in the string are unique, otherwise returns `False`. * **Constraints**: - The function should be case-sensitive, e.g., \'A\' and \'a\' are considered different characters. - The function should not use any additional data structures except for simple primitives or built-in data structures. * **Performance Requirements**: The implementation should have a time complexity of O(n), where n is the length of the string. Example Usage ```python assert has_unique_characters(\\"abcdef\\") == True assert has_unique_characters(\\"hello\\") == False assert has_unique_characters(\\"Python\\") == True assert has_unique_characters(\\"apple\\") == False assert has_unique_characters(\\"12345!@#%\\") == True assert has_unique_characters(\\"AaBbCc\\") == True assert has_unique_characters(\\"\\") == True ``` # Constraints Handling - The solution should work efficiently even for the maximum length (256 characters) of the string. - No complex library functions allowed, use basic string operations. This question tests the candidate\'s ability to handle string manipulation, edge cases, and performance constraints related to character uniqueness efficiently.","solution":"def has_unique_characters(s): Determines if a given string has all unique characters. :param s: A string of length 0 ≤ len(s) ≤ 256 :return: True if all characters in the string are unique, otherwise False if len(s) > 256: return False # More characters than unique ASCII values char_set = [False] * 256 for char in s: val = ord(char) if char_set[val]: return False char_set[val] = True return True"},{"question":"# Problem Statement Implement a function `pivot_index(nums: list) -> int` that finds the \\"pivot index\\" of a given list of integers. The pivot index is the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index. If there is no such index, return -1. If there are multiple pivot indexes, return the left-most pivot index. Input - A list of integers `nums` (0 ≤ |nums| ≤ 10^4) where each integer is within the range [-10^6, 10^6]. Output - An integer representing the pivot index or -1 if no such pivot index exists. # Task Implement the function `pivot_index(nums: list) -> int` to find and return the pivot index according to the criteria outlined above. Utilize optimal algorithms to ensure the solution runs efficiently for large inputs. ```python def pivot_index(nums: list) -> int: # Your implementation here ``` Examples 1. **Input**: `pivot_index([1, 7, 3, 6, 5, 6])` - **Output**: `3` 2. **Input**: `pivot_index([1, 2, 3])` - **Output**: `-1` 3. **Input**: `pivot_index([2, 1, -1])` - **Output**: `0` Constraints - The length of the input list will be between 0 and 10,000. - Each integer in the input list will be in the range [-10^6, 10^6]. # Notes - Ensure that the solution efficiently computes the pivot index even for large lists. - Consider edge cases such as an empty list or lists with all identical elements.","solution":"def pivot_index(nums: list) -> int: total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"# Consecutive Character Checker A consecutive character segment in a string is a substring made of identical characters. For example, in \\"aaabbccc\\", \\"aaa\\" and \\"bbb\\" and \\"ccc\\" are consecutive character segments. Task Write a function `longest_consecutive_segment(s: str) -> int` that takes a string `s` as input and returns the length of the longest consecutive character segment in the string. Input * A non-empty string `s` where (1 leq text{len}(s) leq 10^5). Output * An integer representing the length of the longest consecutive character segment in the string. Constraints * The string consists of only lowercase English letters. * The function should operate efficiently even for larger strings up to length 100,000. Example ```python >>> longest_consecutive_segment(\\"aaabbccc\\") 3 >>> longest_consecutive_segment(\\"xyz\\") 1 >>> longest_consecutive_segment(\\"aabbbccccdd\\") 4 >>> longest_consecutive_segment(\\"a\\") 1 ``` You may assume the input string `s` contains only lowercase English letters and is guaranteed to be non-empty.","solution":"def longest_consecutive_segment(s: str) -> int: This function takes a string s and returns the length of the longest consecutive character segment. max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"# Question: Sorting Algorithm Optimization Context You are required to implement an optimized sorting algorithm that combines the concepts of QuickSort and MergeSort, known as \\"HybridSort\\". This hybrid algorithm first partitions the array using QuickSort until the subarrays reach a certain threshold size. Once the threshold is met, it switches to MergeSort for its remaining subarrays. This approach leverages the quick partitioning of QuickSort and the stable merging of MergeSort to achieve better performance on average. Task Implement the following functions within a Python class `HybridSort`: 1. `partition(self, array, low, high)`: - Perform the partitioning step of QuickSort. - Input: - `array`: List of integers. - `low`: Integer, starting index of the subarray. - `high`: Integer, ending index of the subarray. - Output: Tuple containing the index of the partition pivot and the partitioned array. 2. `quick_sort(self, array, low, high, threshold)`: - Perform QuickSort until the subarray sizes drop below the threshold. - Input: - `array`: List of integers. - `low`: Integer, starting index of the subarray. - `high`: Integer, ending index of the subarray. - `threshold`: Integer, the size at which the algorithm should switch to MergeSort. - Output: None. It should sort the elements in place. 3. `merge_sort(self, array)`: - Implement the MergeSort algorithm. - Input: - `array`: List of integers. - Output: Sorted list of integers. 4. `hybrid_sort(self, array, threshold)`: - Integrate both QuickSort and MergeSort where QuickSort handles the partitioning until the threshold is reached, after which MergeSort is applied. - Input: - `array`: List of integers. - `threshold`: Integer, the size at which the algorithm should switch to MergeSort. - Output: Sorted list of integers. Constraints - Ensure efficient sorting by appropriately switching between QuickSort and MergeSort algorithms. - The given array can contain duplicate elements. - The threshold will be less than or equal to the length of the array. # Solution Outline ```python class HybridSort: def partition(self, array, low, high): pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1, array def quick_sort(self, array, low, high, threshold): if low < high: if (high - low) + 1 <= threshold: self.merge_sort(array[low:high + 1]) else: pi, array = self.partition(array, low, high) self.quick_sort(array, low, pi - 1, threshold) self.quick_sort(array, pi + 1, high, threshold) def merge_sort(self, array): if len(array) > 1: mid = len(array) // 2 left_half = array[:mid] right_half = array[mid:] self.merge_sort(left_half) self.merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: array[k] = left_half[i] i += 1 else: array[k] = right_half[j] j += 1 k += 1 while i < len(left_half): array[k] = left_half[i] i += 1 k += 1 while j < len(right_half): array[k] = right_half[j] j += 1 k += 1 return array def hybrid_sort(self, array, threshold): self.quick_sort(array, 0, len(array) - 1, threshold) return array # Sample usage: hs = HybridSort() array = [38, 27, 43, 3, 9, 82, 10] sorted_array = hs.hybrid_sort(array, 4) print(sorted_array) ```","solution":"class HybridSort: def partition(self, array, low, high): pivot = array[high] i = low - 1 for j in range(low, high): if array[j] <= pivot: i += 1 array[i], array[j] = array[j], array[i] array[i + 1], array[high] = array[high], array[i + 1] return i + 1, array def quick_sort(self, array, low, high, threshold): if low < high: if (high - low) + 1 <= threshold: subarray = array[low:high + 1] sorted_subarray = self.merge_sort(subarray) array[low:high + 1] = sorted_subarray else: pi, array = self.partition(array, low, high) self.quick_sort(array, low, pi - 1, threshold) self.quick_sort(array, pi + 1, high, threshold) def merge_sort(self, array): if len(array) > 1: mid = len(array) // 2 left_half = array[:mid] right_half = array[mid:] self.merge_sort(left_half) self.merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: array[k] = left_half[i] i += 1 else: array[k] = right_half[j] j += 1 k += 1 while i < len(left_half): array[k] = left_half[i] i += 1 k += 1 while j < len(right_half): array[k] = right_half[j] j += 1 k += 1 return array def hybrid_sort(self, array, threshold): self.quick_sort(array, 0, len(array) - 1, threshold) return array"},{"question":"Implement a file version management system that tracks changes to a text document. This system will involve versioning files, retrieving file contents for a specific version, and comparing different versions of the file to highlight differences. # Objectives: 1. Write a function `init_system() -> None` to initialize the file version management system. 2. Implement a `add_version(content: str) -> int` function to add a new version of the file\'s content. 3. Implement a `get_version(version_number: int) -> str` function to retrieve the content of a specific version. 4. Create a `compare_versions(version1: int, version2: int) -> List[str]` function to compare two versions and return the differences. # Function Definitions: - `init_system() -> None` - **Output**: None - `add_version(content: str) -> int` - **Input**: - content: String content of the file. - **Output**: Integer representing the version number of the added content. - `get_version(version_number: int) -> str` - **Input**: - version_number: Integer representing the version number. - **Output**: String content of the specified version. - `compare_versions(version1: int, version2: int) -> List[str]` - **Input**: - version1: Integer representing the version number of the first version. - version2: Integer representing the version number of the second version. - **Output**: List of strings where each string represents a line of difference between the two versions. # Constraints: - Each version number will be a unique, non-negative integer. - The system can handle up to 100 versions of the file. - File content will be plain text and no longer than 10000 characters. # Example Usage: ```python # Initializing the version management system init_system() # Adding a new version of the file with some content version1 = add_version(\\"This is the first version of the file.\\") # Adding another version with slightly different content version2 = add_version(\\"This is the second version of the file with more text.\\") # Retrieving the content of version 1 content_v1 = get_version(version1) print(content_v1) # Retrieving the content of version 2 content_v2 = get_version(version2) print(content_v2) # Comparing versions 1 and 2 differences = compare_versions(version1, version2) print(differences) ``` Implement these functions in Python, ensuring that you adhere to the provided specifications and constraints. The `compare_versions` function should accurately highlight changes between the two versions using a simple line-by-line comparison.","solution":"from typing import List import difflib # Initialize a global variable to hold versions versions = [] def init_system() -> None: Initializes the file version management system. global versions versions = [] def add_version(content: str) -> int: Adds a new version of the file\'s content. Parameters: content (str): The content of the file to be added as a new version. Returns: int: The version number of the added content. global versions version_number = len(versions) versions.append(content) return version_number def get_version(version_number: int) -> str: Retrieves the content of a specific version. Parameters: version_number (int): The version number to retrieve. Returns: str: The content of the specified version. global versions if version_number < 0 or version_number >= len(versions): raise ValueError(\\"Invalid version number.\\") return versions[version_number] def compare_versions(version1: int, version2: int) -> List[str]: Compares two versions and returns the differences. Parameters: version1 (int): The version number of the first version. version2 (int): The version number of the second version. Returns: List[str]: The differences between the two versions. content1 = get_version(version1).splitlines() content2 = get_version(version2).splitlines() diff = difflib.unified_diff(content1, content2, lineterm=\'\', fromfile=f\'v{version1}\', tofile=f\'v{version2}\') return list(diff)"},{"question":"New Question for Coding Assessment # [Question 2]: Prime Number Sequence Generator **Problem Statement:** Write a function `prime_sequence_generator` that generates a sequence of prime numbers up to a given limit `n`. The function should return a list of prime numbers in ascending order starting from 2 up to less than or equal to `n`. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. **Function Signature:** ```python def prime_sequence_generator(n: int) -> list: pass ``` **Input:** - `n` (int): The upper limit for the prime numbers to be generated. **Output:** - (list): A list of prime numbers less than or equal to `n`. **Constraints:** - The input `n` will be a positive integer. - You may assume `n` can be a large number (up to 10^6). **Examples:** ```python >>> prime_sequence_generator(10) [2, 3, 5, 7] >>> prime_sequence_generator(30) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] >>> prime_sequence_generator(1) [] >>> prime_sequence_generator(2) [2] >>> prime_sequence_generator(50) [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` **Technical Notes:** 1. Use an efficient algorithm such as the Sieve of Eratosthenes for generating the list of prime numbers to ensure your function performs well for large values of `n`. 2. Ensure that your function handles edge cases where `n` is less than 2 appropriately by returning an empty list. 3. Optimize your code to handle the largest possible values within a reasonable time limit.","solution":"def prime_sequence_generator(n: int) -> list: Generates a sequence of prime numbers up to a given limit `n`. Parameters: n (int): The upper limit for the prime numbers to be generated. Returns: list: A list of prime numbers less than or equal to `n`. if n < 2: return [] # Boolean array to keep track of prime numbers sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False # Extracting the prime numbers from the sieve return [num for num in range(n + 1) if sieve[num]]"},{"question":"# Problem Statement You are provided with a text document encoded in an alien language where the documentation follows a specific formatting style. Each line in the document starts with a keyword indicating the format style followed by the content. There are three formatting styles: `HEADER`, `SUBHEADER`, and `PARAGRAPH`. Your task is to write a function `format_alien_document(document: List[str]) -> List[str]` that processes the document and returns the formatted output. # Function Signature ```python def format_alien_document(document: List[str]) -> List[str]: pass ``` # Input - `document`: A list of strings, where each string is a line of the document. Each line starts with one of the keywords `HEADER`, `SUBHEADER`, or `PARAGRAPH` followed by a colon `:` and then the content. # Output - A list of strings where each string represents a line of the formatted document. # Constraints - The length of the `document` list will be between 1 and 100 (inclusive). - Each line in the document will have at most 200 characters. - Each line in the document will follow the defined format: `HEADER: content`, `SUBHEADER: content`, `PARAGRAPH: content`. # Formatting Rules 1. Lines starting with `HEADER` should be formatted with all capital letters. 2. Lines starting with `SUBHEADER` should be formatted with the first letter of each word in uppercase. 3. Lines starting with `PARAGRAPH` should remain unchanged except removing the keyword `PARAGRAPH:`. # Example ```python assert format_alien_document([ \'HEADER: This is the main title\', \'SUBHEADER: This is a sub-section\', \'PARAGRAPH: This is some introductory text.\', \'PARAGRAPH: Additional details follow here.\' ]) == [ \'THIS IS THE MAIN TITLE\', \'This Is A Sub-Section\', \'This is some introductory text.\', \'Additional details follow here.\' ] assert format_alien_document([ \'HEADER: Another Document Title\', \'SUBHEADER: Subheader Example\', \'PARAGRAPH: Example paragraph text.\' ]) == [ \'ANOTHER DOCUMENT TITLE\', \'Subheader Example\', \'Example paragraph text.\' ] ``` # Additional Information - Handle edge cases such as empty content after the keyword. - Ensure the performance of the solution meets the constraints for larger inputs. - Consider splitting the logic for extracting the format and the content to ensure clarity and maintainability.","solution":"def format_alien_document(document): formatted_document = [] for line in document: if line.startswith(\'HEADER:\'): content = line[7:].strip() formatted_document.append(content.upper()) elif line.startswith(\'SUBHEADER:\'): content = line[10:].strip() formatted_document.append(content.title()) elif line.startswith(\'PARAGRAPH:\'): content = line[10:].strip() formatted_document.append(content) return formatted_document"},{"question":"# Coding Assessment Question: **Objective**: Implement a simplified version of a BankAccount system that supports various banking operations, including depositing, withdrawing, and checking the balance. Ensure the system handles edge cases like over-withdrawing gracefully. **Instructions**: Implement a `BankAccount` class with the following methods: 1. `__init__(self) -> None`: Initialize the account with a balance of 0. 2. `deposit(self, amount: float) -> None`: Deposit a specified amount into the account. 3. `withdraw(self, amount: float) -> bool`: Withdraw a specified amount from the account if sufficient funds are available. Return `True` if the withdrawal was successful, otherwise `False`. 4. `get_balance(self) -> float`: Return the current balance of the account. **Constraints**: * The amount for deposit and withdrawal operations will be a positive float. * Ensure that no negative balance occurs. Withdrawal should only proceed if there are sufficient funds. * The `get_balance` method must return the balance as a float with precision up to two decimal places. **Example**: ```python account = BankAccount() account.deposit(100.50) current_balance = account.get_balance() print(current_balance) # Expected: 100.50 withdrawal_status = account.withdraw(30.25) print(withdrawal_status) # Expected: True current_balance = account.get_balance() print(current_balance) # Expected: 70.25 withdrawal_status = account.withdraw(100.00) print(withdrawal_status) # Expected: False current_balance = account.get_balance() print(current_balance) # Expected: 70.25 ``` **Detailed Requirements**: * Ensure deposits correctly increase the account balance. * Ensure withdrawals only succeed if there are sufficient funds and correctly decrease the account balance. * Handle floating-point arithmetic accurately to maintain precision up to two decimal points for the balance. Good luck!","solution":"class BankAccount: def __init__(self): self.balance = 0.0 def deposit(self, amount: float) -> None: if amount > 0: self.balance += amount def withdraw(self, amount: float) -> bool: if amount <= 0: return False if self.balance >= amount: self.balance -= amount return True return False def get_balance(self) -> float: return round(self.balance, 2)"},{"question":"# Reverse Words in a Sentence **Context**: Nowadays, data modification and manipulation are essential in many real-world applications. One common task is reversing the order of words in a sentence while maintaining the original order of characters within each word. For example: ``` Input: \\"Hello World from Coding Assessment\\" Output: \\"Assessment Coding from World Hello\\" ``` # Task Write a function `reverse_words` that takes a string as input and returns a new string with the words in reversed order. ```python def reverse_words(sentence: str) -> str: # Your implementation here return ``` # Input * `sentence`: A string containing words separated by spaces. Assume the input string does not contain leading or trailing spaces, and words are separated by a single space. # Output * A string with the words in reversed order. # Constraints * The length of the input string is at most 10,000 characters. * The input string contains only printable ASCII characters. # Example ```python sentence = \\"Coding Assessments improve problem-solving skills\\" result = reverse_words(sentence) print(result) # Output should be \\"skills problem-solving improve Assessments Coding\\" ``` Provide edge case handling such as an empty string or a string with a single word. Ensure your implementation is efficient in terms of time and space complexity.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence while maintaining the original order of characters within each word. Parameters: sentence (str): A string containing words separated by spaces. Returns: str: A string with the words in reversed order. words = sentence.split() reversed_words = words[::-1] return \' \'.join(reversed_words)"},{"question":"# Question Title: Inventory Management System for a Bookstore # Question Description In this task, you are required to design and implement an inventory management system for a bookstore. The system should keep track of book details, add new books to inventory, update stock for existing books, and process purchase orders. # Function Signatures ```python def add_book(inventory: dict, book_id: str, title: str, author: str, price: float, stock: int) -> None: pass def update_stock(inventory: dict, book_id: str, stock: int) -> None: pass def process_order(inventory: dict, book_id: str, quantity: int) -> float: pass ``` # Inputs - `inventory` (Dict): Dictionary where the keys are book IDs and values are dictionaries containing book details (`title`, `author`, `price`, `stock`). - `book_id` (str): Unique identifier for the book. - `title` (str): Title of the book. - `author` (str): Author of the book. - `price` (float): Price of the book. - `stock` (int): Number of copies of the book in stock. - `quantity` (int): Number of copies to purchase. # Outputs - `add_book`: Adds a new book to the inventory. If the book ID already exists, updates the book details. - `update_stock`: Updates the stock for an existing book in the inventory. - `process_order`: Processes a purchase order, updates the stock, and returns the total cost of the order. If the stock is insufficient, raises an `Exception` with the message \\"Insufficient stock\\". # Instructions 1. **Add Book**: - Implement the function `add_book` to add new book details to `inventory`. If `book_id` already exists, update the book\'s information. 2. **Update Stock**: - Implement the function `update_stock` to update the stock quantity for a given `book_id`. 3. **Process Order**: - Implement the function `process_order` to process a customer\'s order. Deduct the quantity from stock and return the total price. If the stock is insufficient, raise an `Exception`. # Constraints 1. `price` will always be a non-negative float. 2. `stock` and `quantity` will always be non-negative integers. 3. `book_id`, `title`, and `author` will always be non-empty strings. 4. `inventory` will always be a valid dictionary object. # Example Cases Example 1 ```python inventory = {} add_book(inventory, \\"1\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 10.99, 5) update_stock(inventory, \\"1\\", 3) total_cost = process_order(inventory, \\"1\\", 4) assert total_cost == 43.96 ``` Example 2 ```python inventory = {} add_book(inventory, \\"2\\", \\"1984\\", \\"George Orwell\\", 8.99, 10) total_cost = process_order(inventory, \\"2\\", 5) assert total_cost == 44.95 try: process_order(inventory, \\"2\\", 6) except Exception as e: assert str(e) == \\"Insufficient stock\\" ``` Example 3 ```python inventory = {} add_book(inventory, \\"3\\", \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 7.99, 20) update_stock(inventory, \\"3\\", 25) total_cost = process_order(inventory, \\"3\\", 15) assert total_cost == 119.85 ``` Notes - Ensure to manage the inventory state correctly with the implemented functions. - Exceptions should be handled where stock is insufficient to fulfill an order.","solution":"def add_book(inventory: dict, book_id: str, title: str, author: str, price: float, stock: int) -> None: Adds a new book to the inventory or updates the existing book\'s details. :param inventory: Dictionary to store books. :param book_id: Unique identifier for the book. :param title: Title of the book. :param author: Author of the book. :param price: Price of the book. :param stock: Number of copies in stock. inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"price\\": price, \\"stock\\": stock } def update_stock(inventory: dict, book_id: str, stock: int) -> None: Updates the stock of a specified book in the inventory. :param inventory: Dictionary to store books. :param book_id: Unique identifier for the book. :param stock: New stock quantity. if book_id in inventory: inventory[book_id][\\"stock\\"] = stock else: raise KeyError(\\"Book ID does not exist in inventory\\") def process_order(inventory: dict, book_id: str, quantity: int) -> float: Processes an order for a specified book. :param inventory: Dictionary to store books. :param book_id: Unique identifier for the book. :param quantity: Number of copies to purchase. :return: Total cost of the order. :raises: Exception if stock is insufficient. if book_id in inventory: if inventory[book_id][\\"stock\\"] >= quantity: cost = inventory[book_id][\\"price\\"] * quantity inventory[book_id][\\"stock\\"] -= quantity return cost else: raise Exception(\\"Insufficient stock\\") else: raise KeyError(\\"Book ID does not exist in inventory\\")"},{"question":"# Problem Statement You are tasked with implementing a command line tool that processes user activity logs for a website. Specifically, you need to create a function to filter out logs that correspond to a given set of user IDs and sort the remaining logs by timestamp. # Requirements Create a function `filter_and_sort_logs` that filters user logs by a set of excluded user IDs and sorts the remaining logs by their timestamps in ascending order. Each log entry contains a user ID, timestamp, and activity description. # Function Signature ```python def filter_and_sort_logs(logs: list[dict], excluded_user_ids: set) -> list[dict]: pass ``` # Input * `logs` (list of dicts): A list where each element is a dictionary with three keys: `user_id`, `timestamp`, and `activity`. * `user_id` (int): An integer representing the unique ID of a user. * `timestamp` (str): A string representing the time of the log entry in the format `YYYY-MM-DD HH:MM:SS`. * `activity` (str): A string representing the user\'s activity description. * `excluded_user_ids` (set of ints): A set of user IDs to be excluded from the filtered logs. # Output * A list of dictionaries representing the filtered and sorted logs, without any entries from the excluded user IDs. # Constraints * The `timestamp` will always be in the valid format (`YYYY-MM-DD HH:MM:SS`). * If `logs` is empty, the function should return an empty list. * The function should handle edge cases, such as an empty set of excluded user IDs. # Examples ```python logs = [ {\'user_id\': 1, \'timestamp\': \'2023-01-01 12:00:00\', \'activity\': \'login\'}, {\'user_id\': 2, \'timestamp\': \'2023-01-01 12:05:00\', \'activity\': \'logout\'}, {\'user_id\': 3, \'timestamp\': \'2023-01-01 12:10:00\', \'activity\': \'purchase\'}, {\'user_id\': 1, \'timestamp\': \'2023-01-01 12:15:00\', \'activity\': \'update profile\'} ] excluded_user_ids = {1} print(filter_and_sort_logs(logs, excluded_user_ids)) # Output: [{\'user_id\': 2, \'timestamp\': \'2023-01-01 12:05:00\', \'activity\': \'logout\'}, {\'user_id\': 3, \'timestamp\': \'2023-01-01 12:10:00\', \'activity\': \'purchase\'}] logs = [ {\'user_id\': 2, \'timestamp\': \'2023-02-01 10:00:00\', \'activity\': \'login\'}, {\'user_id\': 3, \'timestamp\': \'2023-02-01 09:00:00\', \'activity\': \'purchase\'}, {\'user_id\': 4, \'timestamp\': \'2023-02-01 08:00:00\', \'activity\': \'logout\'} ] excluded_user_ids = {4} print(filter_and_sort_logs(logs, excluded_user_ids)) # Output: [{\'user_id\': 3, \'timestamp\': \'2023-02-01 09:00:00\', \'activity\': \'purchase\'}, {\'user_id\': 2, \'timestamp\': \'2023-02-01 10:00:00\', \'activity\': \'login\'}] ``` # Explanation In the first example, the logs for user ID 1 are excluded, and the remaining logs are sorted by their timestamps. In the second example, the log for user ID 4 is excluded, and the remaining logs are sorted by their timestamps. Good luck with your implementation!","solution":"def filter_and_sort_logs(logs, excluded_user_ids): Filters out logs with excluded user IDs and sorts the remaining logs by their timestamps. Args: logs (list of dict): List of logs where each log is a dictionary with keys \'user_id\', \'timestamp\', and \'activity\'. excluded_user_ids (set of int): Set of user IDs to be excluded from the logs. Returns: list of dict: Filtered and sorted logs. # Filter out logs where the user_id is in the excluded_user_ids set filtered_logs = [log for log in logs if log[\'user_id\'] not in excluded_user_ids] # Sort the filtered logs by timestamp sorted_logs = sorted(filtered_logs, key=lambda log: log[\'timestamp\']) return sorted_logs"},{"question":"# Coding Assessment Question: Parallel Data Processing with MapReduce Context: You are given a large dataset stored as a list of strings. Each string represents a line in a document containing multiple words. Your task is to implement a function that uses the MapReduce programming model to count the occurrences of each word across all documents in parallel. Task: Implement the `map_reduce_word_count` function that performs this task. The function should utilize the MapReduce paradigm, simulating the `map` and `reduce` phases. Function Signature: ```python def map_reduce_word_count(documents: list[str]) -> dict[str, int]: pass ``` Input: - `documents` (list[str]): List of strings where each string is a line of text. Output: - A dictionary where keys are words, and values are the count of occurrences of each word across all documents. Constraints: - Assume all words are separated by spaces and punctuation marks should be ignored. - The solution should demonstrate the understanding of the MapReduce model. - Handle edge cases such as an empty list of documents gracefully. Example: ```python documents = [ \\"The quick brown fox jumps over the lazy dog\\", \\"The dog was not amused\\", \\"MapReduce is a programming model\\" ] result = map_reduce_word_count(documents) # Expected output: # { # \'the\': 3, \'quick\': 1, \'brown\': 1, \'fox\': 1, \'jumps\': 1, \'over\': 1, # \'lazy\': 1, \'dog\': 2, \'was\': 1, \'not\': 1, \'amused\': 1, \'mapreduce\': 1, # \'is\': 1, \'a\': 1, \'programming\': 1, \'model\': 1 # } ``` **Note**: The function should tokenize the input strings into words, disregard punctuation, convert all words to lowercase, and correctly calculate the word counts using the MapReduce approach. It should simulate parallel data processing even if parallelism isn\'t actually implemented.","solution":"import re from collections import defaultdict from functools import reduce def map_function(document): The map function takes a document and returns a list of (word, 1) tuples. words = re.findall(r\'bw+b\', document.lower()) return [(word, 1) for word in words] def reduce_function(word_counts): The reduce function takes a list of (word, occurrences) tuples and returns a dictionary with the accumulated counts of each word. word_count_dict = defaultdict(int) for word, count in word_counts: word_count_dict[word] += count return word_count_dict def map_reduce_word_count(documents): Function to count occurrences of each word using MapReduce paradigm. Parameters: documents (list[str]): List of strings where each string is a line of text. Returns: dict[str, int]: Dictionary with word counts. # Perform the map step mapped = [] for document in documents: mapped.extend(map_function(document)) # Perform the reduce step reduced = reduce_function(mapped) return reduced"},{"question":"# Given Context You are developing a custom decorator function to track the execution time of functions within a codebase. This decorator should add logging functionality to any function it decorates, capturing the start time, end time, and total duration of the function\'s execution. # Task 1. Create a decorator function named `log_execution_time` which: - Logs the start and end time of the function\'s execution. - Calculates and logs the total execution time. 2. Ensure that the function\'s original behavior and return value are unaffected. # Input and Output Formats * **Decorator to implement**: * `log_execution_time` * **Constraints**: * The decorator should not modify the original function\'s return value. * Use Python\'s `logging` library for capturing logs. * The logs should include the function\'s name, start time in `isoformat()`, end time in `isoformat()`, and the duration in seconds. # Example Scenario Assume you have a function `compute_factorial` that calculates the factorial of a number and you want to measure its execution time using your decorator. # Example Code ```python import logging import time logging.basicConfig(level=logging.INFO) # Implement the decorator here def log_execution_time(func): def wrapper(*args, **kwargs): start_time = time.time() logging.info(f\\"Starting {func.__name__} at {time.strftime(\'%Y-%m-%d %H:%M:%S\', time.localtime(start_time))}\\") result = func(*args, **kwargs) end_time = time.time() logging.info(f\\"Finished {func.__name__} at {time.strftime(\'%Y-%m-%d %H:%M:%S\', time.localtime(end_time))}\\") logging.info(f\\"Execution time for {func.__name__}: {end_time - start_time:.6f} seconds\\") return result return wrapper # Apply the decorator to the compute_factorial function @log_execution_time def compute_factorial(n): if n == 0: return 1 else: return n * compute_factorial(n - 1) # Test the decorator and function compute_factorial(5) ``` # Expected Output (Logs displayed in the output are for illustrative purposes; the timestamps will vary based on the actual run time) ``` INFO:root:Starting compute_factorial at 2023-03-16 14:30:00 INFO:root:Finished compute_factorial at 2023-03-16 14:30:00 INFO:root:Execution time for compute_factorial: 0.000012 seconds ```","solution":"import logging import time logging.basicConfig(level=logging.DEBUG) def log_execution_time(func): def wrapper(*args, **kwargs): start_time = time.time() logging.info(f\\"Starting {func.__name__} at {time.strftime(\'%Y-%m-%dT%H:%M:%S\', time.localtime(start_time))}\\") result = func(*args, **kwargs) end_time = time.time() logging.info(f\\"Finished {func.__name__} at {time.strftime(\'%Y-%m-%dT%H:%M:%S\', time.localtime(end_time))}\\") logging.info(f\\"Execution time for {func.__name__}: {end_time - start_time:.6f} seconds\\") return result return wrapper @log_execution_time def compute_factorial(n): if n == 0: return 1 else: return n * compute_factorial(n - 1)"},{"question":"# Problem Description You are required to implement a function that simulates a Vending Machine system. The vending machine dispenses different items and calculates the change to be returned based on item prices and the amount of money inserted by the user. # Function Requirements Write a function `vending_machine` that takes a list of item prices and a list of amounts the user inserts. The function should return a list of change to be returned for each item in the order they are processed. If the inserted amount is less than the item price, return -1 as the change for that item. Input * `item_prices` (List[int]): A list of integers representing the prices of items in cents. * `amounts_inserted` (List[int]): A list of integers representing the amounts of money inserted by users in cents. Output * List[int]: A list of integers where each integer represents the change to be returned for each respective item. If the inserted amount is less than the item price, return -1 for that item. Constraints 1. The length of `item_prices` and `amounts_inserted` will be the same and will not exceed 1,000. 2. Each element in `item_prices` and `amounts_inserted` will be an integer between 1 and 10,000. # Examples ```python assert vending_machine([250, 100, 300], [300, 150, 200]) == [50, 50, -1] assert vending_machine([100, 200, 150], [100, 100, 200]) == [0, -1, 50] assert vending_machine([100, 200, 150], [150, 250, 150]) == [50, 50, 0] ``` # Instructions 1. Implement the `vending_machine` function that processes the input prices and amounts inserted. 2. Ensure your solution correctly calculates the change or identifies when the inserted amount is insufficient. # Test your implementation with the provided examples to ensure correctness.","solution":"def vending_machine(item_prices, amounts_inserted): Function to simulate a vending machine, returning change for each item or -1 if the inserted amount is less than the item price. :param item_prices: List[int] - List of item prices in cents :param amounts_inserted: List[int] - List of amounts inserted in cents :return: List[int] - List of change or -1 if amount is less than item price change_list = [] for price, amount in zip(item_prices, amounts_inserted): if amount < price: change_list.append(-1) else: change_list.append(amount - price) return change_list"},{"question":"Additional Question: Implement a Function to Check if a Number is Prime # Context Primality testing, a fundamental concept in number theory, is critical in various fields such as cryptography. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Task Write a function `is_prime(n: int) -> bool` that determines if a given integer `n` is a prime number. # Function Signature ```python def is_prime(n: int) -> bool: ``` # Inputs - `n`: A non-negative integer. # Outputs - Returns `True` if `n` is a prime number, `False` otherwise. # Constraints 1. `n` is a non-negative integer. 2. The function should validate the input value and raise appropriate exceptions: - `ValueError` if the input is negative. - `TypeError` if the input is not an integer. # Performance Requirements - The function should be optimized to handle large integers efficiently, up to 10^12. # Examples ```python >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(100) False >>> is_prime(104729) # one of the known larger prime numbers True ``` # Error Handling Examples ```python >>> is_prime(-10) Traceback (most recent call last): ... ValueError: the value of input must be non-negative >>> is_prime(3.14) Traceback (most recent call last): ... TypeError: \'float\' object cannot be interpreted as an integer >>> is_prime(\\"seven\\") Traceback (most recent call last): ... TypeError: \'str\' object cannot be interpreted as an integer ```","solution":"def is_prime(n: int) -> bool: Determines if a given number n is a prime number. :param n: A non-negative integer to check for primality. :return: True if n is a prime number, False otherwise. :raises ValueError: If n is a negative integer. :raises TypeError: If n is not an integer. if not isinstance(n, int): raise TypeError(f\'{type(n).__name__} object cannot be interpreted as an integer\') if n < 0: raise ValueError(\'the value of input must be non-negative\') if n < 2: return False if n == 2: return True if n % 2 == 0: return False limit = int(n**0.5) + 1 for i in range(3, limit, 2): if n % i == 0: return False return True"},{"question":"**Scenario**: You are designing a simplified version of a warehouse robot that needs to pick up and drop packages in a grid. The robot can move in four directions: up, down, left, and right. The robot starts at the top-left corner of the grid (0, 0), and its goal is to reach the bottom-right corner (n-1, m-1) while avoiding obstacles. The grid is represented as a 2D list where `0` denotes an empty space and `1` denotes an obstacle. **Problem Statement**: Write a function `robot_navigation` to navigate the robot from the start to the target location. The robot can only move to empty spaces and it must find a path to the target if one exists. **Function Signature**: ```python def robot_navigation(grid: List[List[int]]) -> bool: pass ``` **Input**: - `grid` (List[List[int]]): A 2D list representing the grid, where `0` is an empty space and `1` is an obstacle. **Output**: - Return `True` if there exists a path from the top-left to the bottom-right corner of the grid. Otherwise, return `False`. **Constraints**: 1. 2 <= grid size (rows `n` and columns `m`) <= 50 2. Only valid moves are to adjacent open cells (up, down, left, right) 3. Start and end positions are always empty (i.e., `grid[0][0] = 0` and `grid[n-1][m-1] = 0`) # Example: ```python # Example usage grid = [ [0, 0, 1], [0, 1, 0], [0, 0, 0] ] print(robot_navigation(grid)) # Expected Output: True grid = [ [0, 1, 1], [1, 1, 0], [0, 0, 0] ] print(robot_navigation(grid)) # Expected Output: False ``` **Explanation**: In the first example, there is a path from the start (0, 0) to the target (2, 2) that avoids obstacles. In the second example, no such path exists.","solution":"from typing import List from collections import deque def robot_navigation(grid: List[List[int]]) -> bool: rows, cols = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[rows-1][cols-1] == 1: return False directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False"},{"question":"# Online Bookstore Inventory Management You are tasked with designing an inventory management system for an online bookstore. The system should keep track of the inventory of books, including the addition of new books, the sale of books, and querying the current stock. **Objective**: Implement a class `BookInventory` that allows you to manage the bookstore\'s inventory efficiently. **Requirements**: 1. **Initialization**: * Initialize an empty inventory for books. 2. **Methods**: - `add_book(title: str, quantity: int) -> None`: * Add a specified quantity of a book to the inventory. If the book already exists, increment its stock by the given quantity. - `sell_book(title: str, quantity: int) -> bool`: * Sell a specified quantity of a book from the inventory. If the book is out of stock or the requested quantity exceeds the current stock, return `False`. Otherwise, decrement the stock by the given quantity and return `True`. - `check_stock(title: str) -> int`: * Return the current stock of the specified book. If the book is not in the inventory, return `0`. - `current_inventory() -> List[Tuple[str, int]]`: * Return a list of all books in the inventory and their quantities, sorted by book titles in alphabetical order. **Constraints**: * Books have unique titles. * Title length (`|title|` ≤ 100). * Quantity (`0 <= quantity <= 10^6`). * Maximum number of distinct books in the inventory (`1 <= b <= 10^5`). * Function methods must be optimized for efficient inventory management. **Example**: ```python # Create an instance of the inventory inventory = BookInventory() # Add books to the inventory inventory.add_book(\\"The Great Gatsby\\", 3) inventory.add_book(\\"1984\\", 5) # Check the stock of a book print(inventory.check_stock(\\"1984\\")) # Expected: 5 # Sell books from the inventory assert inventory.sell_book(\\"1984\\", 2) == True print(inventory.check_stock(\\"1984\\")) # Expected: 3 # Attempt to sell more books than available stock assert inventory.sell_book(\\"The Great Gatsby\\", 4) == False print(inventory.check_stock(\\"The Great Gatsby\\")) # Expected: 3 # Add more copies of an existing book inventory.add_book(\\"1984\\", 10) print(inventory.check_stock(\\"1984\\")) # Expected: 13 # List the current inventory print(inventory.current_inventory()) # Expected: [(\'1984\', 13), (\'The Great Gatsby\', 3)] ```","solution":"from typing import List, Tuple class BookInventory: def __init__(self): self.inventory = {} def add_book(self, title: str, quantity: int) -> None: if title in self.inventory: self.inventory[title] += quantity else: self.inventory[title] = quantity def sell_book(self, title: str, quantity: int) -> bool: if title not in self.inventory or self.inventory[title] < quantity: return False self.inventory[title] -= quantity if self.inventory[title] == 0: del self.inventory[title] return True def check_stock(self, title: str) -> int: return self.inventory.get(title, 0) def current_inventory(self) -> List[Tuple[str, int]]: return sorted(self.inventory.items())"},{"question":"# Problem Statement Scenario: You are developing a software system that manages user subscriptions for an online service. One of the key features is to identify the longest sequence of valid subscription days within a given month. Each day in a given list is either marked as subscribed or unsubscribed. The goal is to determine the duration of the longest streak of consecutively subscribed days. Task: Implement a function that finds the longest sequence of consecutive subscribed days in a given list of subscription statuses for a month. # Function Signature: ```python def longest_subscription_streak(subscriptions: list) -> int: ``` Input: - `subscriptions`: A list of integers of length 1 to 31, representing daily subscription status in a given month (1 for subscribed, 0 for unsubscribed). Output: - Returns an integer representing the length of the longest sequence of consecutive subscribed days. Constraints: - The input list may contain between 1 to 31 integers. - Each integer in the list is either 1 (subscribed) or 0 (unsubscribed). Example: ```python longest_subscription_streak([1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1]) # Expected Output: 4 longest_subscription_streak([0, 0, 0, 0, 0, 0]) # Expected Output: 0 longest_subscription_streak([1]) # Expected Output: 1 ``` # Note: 1. Focus on identifying contiguous sequences of subscribed days within the given list. 2. Optimize the function for both time and space complexity where feasible. 3. Consider edge cases such as an entirely subscribed or unsubscribed month.","solution":"def longest_subscription_streak(subscriptions: list) -> int: This function finds the longest sequence of consecutive subscribed days in a given list of subscription statuses for a month. max_streak = 0 current_streak = 0 for status in subscriptions: if status == 1: current_streak += 1 if current_streak > max_streak: max_streak = current_streak else: current_streak = 0 return max_streak"},{"question":"# Scenario: You are developing a real-time monitoring system that requires an efficient way to compute running averages of sensor readings. The sensor data comes in the form of a continuous stream, and the system must calculate the average of the last `k` readings, updating the result as each new reading comes in. # Task: Write a class `RunningAverage` that maintains a running average of the last `k` elements in a stream of floating-point numbers. Your implementation should be efficient with respect to both time and space. # Class Signature: ```python class RunningAverage: def __init__(self, k: int): pass def next(self, value: float) -> float: pass ``` # Methods: - `__init__(self, k: int)`: Initializes the object with the window size `k`. - `next(self, value: float) -> float`: Accepts a new value from the stream and returns the updated running average of the last `k` values. # Example: ```python >>> running_avg = RunningAverage(3) >>> running_avg.next(1) 1.0 >>> running_avg.next(10) 5.5 >>> running_avg.next(3) 4.666666666666667 >>> running_avg.next(5) 6.0 ``` # Notes: - Use a suitable data structure to keep track of the last `k` values. - Handle cases where fewer than `k` elements have been seen so far by appropriately adjusting the divisor when computing the average. - Ensure the class is efficient in terms of both updating the running average and managing the internal state. # Constraints: - `1 <= k <= 10^6`. - The stream values are floating-point numbers. - The solution should be capable of handling up to 10^7 updates efficiently.","solution":"from collections import deque class RunningAverage: def __init__(self, k: int): Initialize the RunningAverage with a window size `k`. self.k = k self.window = deque() self.total = 0.0 def next(self, value: float) -> float: Accept a new value and return the updated running average. if len(self.window) == self.k: self.total -= self.window.popleft() self.window.append(value) self.total += value return self.total / len(self.window)"},{"question":"# Implementing a Merge Sort Algorithm You are required to implement the merge sort algorithm from scratch without using any built-in sort functions. Your implementation should adhere to the traditional divide-and-conquer strategy, where the array is divided into halves recursively, each half is sorted independently, and the sorted halves are merged together. # Task: Implement a `MergeSort` class with the following methods: 1. `__init__(self, data: List[int])`: Initializes the class with a list of integers to be sorted. 2. `sort(self) -> List[int]`: Sorts the list in ascending order using the merge sort algorithm and returns the sorted list. 3. `merge(self, left: List[int], right: List[int]) -> List[int]`: Merges two sorted lists into one sorted list. # Constraints: - You must implement the merge sort algorithm from scratch without using Python\'s built-in `sort` or `sorted` functions. - The input list can have duplicate values and negative numbers. # Input Format: - The `__init__` method will be called with a list of integers as its input parameter. # Output Format: - The `sort` method should return the sorted list of integers. # Example: ```python merge_sort = MergeSort([38, 27, 43, 3, 9, 82, 10]) print(merge_sort.sort()) # [3, 9, 10, 27, 38, 43, 82] merge_sort = MergeSort([5, -1, 3, 0, 8, -2, 5, 1]) print(merge_sort.sort()) # [-2, -1, 0, 1, 3, 5, 5, 8] ``` Your implementation should correctly sort the list in ascending order using the merge sort algorithm, efficiently handling the merging of sublists. ```python from typing import List class MergeSort: def __init__(self, data: List[int]): self.data = data def sort(self) -> List[int]: return self._merge_sort(self.data) def _merge_sort(self, data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = self._merge_sort(data[:mid]) right = self._merge_sort(data[mid:]) return self.merge(left, right) def merge(self, left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list ```","solution":"from typing import List class MergeSort: def __init__(self, data: List[int]): self.data = data def sort(self) -> List[int]: return self._merge_sort(self.data) def _merge_sort(self, data: List[int]) -> List[int]: if len(data) <= 1: return data mid = len(data) // 2 left = self._merge_sort(data[:mid]) right = self._merge_sort(data[mid:]) return self.merge(left, right) def merge(self, left: List[int], right: List[int]) -> List[int]: sorted_list = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: sorted_list.append(left[i]) i += 1 else: sorted_list.append(right[j]) j += 1 while i < len(left): sorted_list.append(left[i]) i += 1 while j < len(right): sorted_list.append(right[j]) j += 1 return sorted_list"},{"question":"# Context You are working on a simplified file system simulation. In this file system, files are stored in directories, and directories can contain both files and other directories. Each file and directory has a name, with files containing some data (a string). # Task Implement a `FileSystem` class that manages this hierarchical structure. The `FileSystem` should support the following operations efficiently while maintaining the hierarchical nature of the file structure: # Requirements 1. **Constructor**: `FileSystem()` initializes the root directory. 2. **Methods**: * `mkdir(self, path: str)`: Creates a directory at the specified path. If intermediate directories do not exist, they should be created. * `addFile(self, path: str, content: str)`: Creates a file at the specified path with the given content. If intermediate directories do not exist, they should be created. * `readFile(self, path: str)`: Reads the content of the file at the specified path. * `delete(self, path: str)`: Deletes the file or directory at the specified path. If the path is a directory, all its contents (files and directories) should also be deleted to mimic a recursive deletion. 3. **Constraints**: - File and directory names contain only alphanumeric characters and \'/\'. - Path strings always start with a \'/\' and represent an absolute path from the root. - Ensure efficient path parsing and navigation within the file system structure. - Handle edge cases such as adding, reading, or deleting files or directories that do not exist. # Example ```python # Example with basic file system operations fs = FileSystem() fs.mkdir(\'/a/b/c\') fs.addFile(\'/a/b/c/d.txt\', \'Hello World\') assert fs.readFile(\'/a/b/c/d.txt\') == \'Hello World\' # Adding another file in an existing directory fs.addFile(\'/a/b/c/e.txt\', \'Goodbye World\') assert fs.readFile(\'/a/b/c/e.txt\') == \'Goodbye World\' # Deleting a file fs.delete(\'/a/b/c/d.txt\') try: fs.readFile(\'/a/b/c/d.txt\') assert False, \\"Expected FileNotFoundError\\" except FileNotFoundError: pass # Deleting a directory fs.delete(\'/a/b/c\') try: fs.addFile(\'/a/b/c/e.txt\', \'This should not be possible\') assert False, \\"Expected FileNotFoundError\\" except FileNotFoundError: pass ```","solution":"class FileNotFoundError(Exception): pass class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str): dirs = path.strip(\'/\').split(\'/\') current = self.root for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] def addFile(self, path: str, content: str): dirs = path.strip(\'/\').split(\'/\') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory not in current: current[directory] = {} current = current[directory] current[filename] = content def readFile(self, path: str): dirs = path.strip(\'/\').split(\'/\') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory in current: current = current[directory] else: raise FileNotFoundError(\\"File or directory does not exist\\") if filename in current: if isinstance(current[filename], str): return current[filename] else: raise FileNotFoundError(\\"Requested path is a directory, not a file\\") else: raise FileNotFoundError(\\"File does not exist\\") def delete(self, path: str): dirs = path.strip(\'/\').split(\'/\') filename = dirs.pop(-1) current = self.root for directory in dirs: if directory in current: current = current[directory] else: raise FileNotFoundError(\\"File or directory does not exist\\") if filename in current: del current[filename] else: raise FileNotFoundError(\\"File or directory does not exist\\")"},{"question":"# Coding Assessment Question Background In a software application, there is a need to handle and process large matrices of integers. One common operation is to find the first occurrence of a submatrix within a larger matrix and return its top-left corner position. This operation involves searching the larger matrix for a smaller submatrix and identifying the location of its first exact match. Objective Your task is to implement a function that finds the first occurrence of a submatrix within a larger matrix and returns the position of the top-left corner of the submatrix. Function Signature ```python def find_submatrix(matrix: List[List[int]], submatrix: List[List[int]]) -> Tuple[int, int]: ``` Input * `matrix` (List[List[int]]): A 2D list of integers representing the larger matrix. * `submatrix` (List[List[int]]): A 2D list of integers representing the smaller submatrix to find. Output The function should return a tuple `(i, j)`, where `i` and `j` are the row and column indices of the top-left corner of the first occurrence of the submatrix within the matrix. If the submatrix is not found, return `(-1, -1)`. Constraints 1. Both `matrix` and `submatrix` will be non-empty 2D lists of integers. 2. The dimensions of `matrix` will be greater than or equal to the dimensions of `submatrix`. Example 1 ```python matrix = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], ] submatrix = [ [8, 9], [13, 14] ] find_submatrix(matrix, submatrix) ``` Output: ``` (1, 2) ``` Example 2 ```python matrix = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] submatrix = [ [50, 60], [80, 90] ] find_submatrix(matrix, submatrix) ``` Output: ``` (1, 1) ``` Example 3 ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] submatrix = [ [5, 6], [8, 0] ] find_submatrix(matrix, submatrix) ``` Output: ``` (-1, -1) ``` Notes * Ensure the function performs efficiently with respect to both time and space complexity. * Consider edge cases such as submatrix being larger than the matrix, which should never happen based on constraints, and submatrix not being found at all. Your implementation should correctly identify the position of the submatrix within the larger matrix or return `(-1, -1)` if it does not exist.","solution":"from typing import List, Tuple def find_submatrix(matrix: List[List[int]], submatrix: List[List[int]]) -> Tuple[int, int]: m_rows, m_cols = len(matrix), len(matrix[0]) s_rows, s_cols = len(submatrix), len(submatrix[0]) for i in range(m_rows - s_rows + 1): for j in range(m_cols - s_cols + 1): match = True for x in range(s_rows): for y in range(s_cols): if matrix[i + x][j + y] != submatrix[x][y]: match = False break if not match: break if match: return (i, j) return (-1, -1)"},{"question":"# Scenario You are a software developer working on a project that deals with string manipulation. One of the requirements is to identify the longest substring of unique characters for a given string. You decide to write a function that finds this longest substring and returns both the substring and its length. # Problem Statement Write a function `longest_unique_substring(s: str) -> Tuple[str, int]` that returns the longest substring with all unique characters as well as the length of that substring. # Function Signature ```python from typing import Tuple def longest_unique_substring(s: str) -> Tuple[str, int]: ``` # Input * `s` (str): A string which may contain any characters. # Output * A tuple containing: * A string representing the longest substring with unique characters. * An integer representing the length of the longest substring with unique characters. # Constraints 1. `0 <= len(s) <= 10^5` # Examples ```python assert longest_unique_substring(\\"abcabcbb\\") == (\\"abc\\", 3) assert longest_unique_substring(\\"bbbbb\\") == (\\"b\\", 1) assert longest_unique_substring(\\"pwwkew\\") == (\\"wke\\", 3) assert longest_unique_substring(\\"\\") == (\\"\\", 0) assert longest_unique_substring(\\"dvdf\\") == (\\"vdf\\", 3) ``` # Note * The function should handle edge cases such as an empty string gracefully. * If there are multiple substrings with the same maximum length, returning any one of them is acceptable. # Performance Requirements * Your solution should complete within a reasonable time for the maximum input constraints. # Additional Context The problem can be efficiently solved using a sliding window approach and a hash set to track the characters in the current window. This ensures optimal performance even for large input strings.","solution":"from typing import Tuple def longest_unique_substring(s: str) -> Tuple[str, int]: # Dictionary to store the last indices of characters char_index_map = {} start = 0 max_len = 0 max_substring = \\"\\" for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substring = s[start:end + 1] return max_substring, max_len"},{"question":"# Context You are tasked with implementing a basic version of the Tic-Tac-Toe game, where two players take alternating turns to place their marks (\'X\' and \'O\') on a 3x3 grid. The goal is to determine the state of the game after each move: win, draw, or ongoing. # Task 1. Implement the `TicTacToe` class to manage the game flow and track the board state. 2. Provide methods for playing a move, checking the current state of the board for a winner, and determining if the game has ended in a draw. # Expected Input and Output * **play_move(player: str, row: int, col: int) -> str**: Takes the player\'s mark (\'X\' or \'O\'), and the board position (`row` and `col`), places the mark on the board, and returns one of the following strings: - `\'win\'`: if the move causes the player to win the game. - `\'draw\'`: if there are no more moves possible and no player has won. - `\'ongoing\'`: if the game should continue. * **current_state() -> List[List[str]]**: Returns the current state of the board as a 3x3 list of lists with \'X\', \'O\', or \'\' (empty string) representing each cell. # Constraints * Players always play one after the other, starting with \'X\'. * The coordinates (row, col) are zero-based integers. * Assume inputs to `play_move` are always valid (i.e., moves are made on empty positions within bounds). # Example ```python game = TicTacToe() print(game.play_move(\'X\', 0, 0)) # Output: \'ongoing\' print(game.play_move(\'O\', 0, 1)) # Output: \'ongoing\' print(game.play_move(\'X\', 1, 1)) # Output: \'ongoing\' print(game.play_move(\'O\', 2, 2)) # Output: \'ongoing\' print(game.play_move(\'X\', 2, 0)) # Output: \'ongoing\' print(game.play_move(\'O\', 1, 0)) # Output: \'ongoing\' print(game.play_move(\'X\', 1, 2)) # Output: \'ongoing\' print(game.play_move(\'O\', 0, 2)) # Output: \'ongoing\' print(game.play_move(\'X\', 2, 1)) # Output: \'win\' print(game.current_state()) # Output: [[\'X\', \'O\', \'O\'], [\'O\', \'X\', \'X\'], [\'X\', \'\', \'O\']] ``` # Performance Requirements * Ensure the game logic for checking win conditions and determining the game state is efficient.","solution":"class TicTacToe: def __init__(self): self.board = [[\'\'] * 3 for _ in range(3)] self.moves_played = 0 def play_move(self, player, row, col): if self.board[row][col] == \'\': self.board[row][col] = player self.moves_played += 1 if self.check_winner(player, row, col): return \'win\' elif self.moves_played == 9: return \'draw\' else: return \'ongoing\' def check_winner(self, player, row, col): # Check row if all(self.board[row][c] == player for c in range(3)): return True # Check column if all(self.board[r][col] == player for r in range(3)): return True # Check diagonal if row == col and all(self.board[i][i] == player for i in range(3)): return True if row + col == 2 and all(self.board[i][2 - i] == player for i in range(3)): return True return False def current_state(self): return self.board"},{"question":"# Problem Statement You are responsible for implementing a function that identifies the smallest positive integer missing from an unsorted list of integers. This is especially useful for operations involving inventory tracking or any sequence where you need the next available identifier. Write a function `find_smallest_missing_positive(nums: List[int]) -> int` that takes an unsorted list of integers and returns the smallest positive integer that is not present in the array. # Input - A list of integers `nums` where `1 <= len(nums) <= 10^5` and `-10^6 <= nums[i] <= 10^6`. # Output - An integer representing the smallest positive integer that is missing from the list. # Constraints - The function should have a linear time complexity, O(n). - The solution should use O(1) extra space, excluding the input list. # Performance Requirements - Ensure your function completes efficiently for large input sizes. # Example ```python from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: pass # Test cases print(find_smallest_missing_positive([3, 4, -1, 1])) # Expected: 2 print(find_smallest_missing_positive([1, 2, 0])) # Expected: 3 print(find_smallest_missing_positive([7, 8, 9, 11, 12])) # Expected: 1 print(find_smallest_missing_positive([1, 2, 3])) # Expected: 4 ``` # Additional Notes - The approach should be highly optimized to handle both the range of values and the length of the list efficiently. - Consider edge cases such as empty lists and lists that contain only negative numbers. - No additional data structures should be used that exceed O(1) extra space complexity. # Hints - Try to place each number in its correct position (i.e., 1 at index 0, 2 at index 1, etc.) and then iterate to find the first position where the index does not match the value.","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Binary Search Tree Balancing **Scenario**: You are given a Binary Search Tree (BST) which might be unbalanced. The task is to implement a function to balance the BST to ensure runtime efficiencies for operations like search, insertion, and deletion. You will create a function that takes an unbalanced BST and returns a balanced BST. **Task**: 1. **Understand** the structure of the Binary Search Tree. 2. **Implement** a function `balance_bst` which converts an unbalanced BST to a balanced one. 3. Verify the correctness and balance of your implementation using provided test cases. **Function Signature**: ```python class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def balance_bst(root: TreeNode) -> TreeNode: ``` **Expected Input and Output**: 1. **balance_bst()**: - Parameters: - `root` (TreeNode): The root of the unbalanced BST. - Returns: - `TreeNode`: The root of the balanced BST. **Constraints and Limitations**: - The input tree can contain up to 10,000 nodes. - All node values are unique. - Solution should ensure balanced property i.e., the depth of the two subtrees of every node never differ by more than 1. - Implement the most efficient algorithm for balancing BST, such as constructing a sorted array from the BST and using it to build a balanced BST. **Example Usage**: ```python # Helper function to print inorder traversal def inorder_traversal(root): return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) if root else [] # Construct an unbalanced BST root = TreeNode(10) root.left = TreeNode(5) root.left.left = TreeNode(1) root.right = TreeNode(20) root.right.right = TreeNode(30) root.right.right.right = TreeNode(40) # Balance the BST balanced_root = balance_bst(root) # Check if BST is balanced by printing inorder traversal print(inorder_traversal(balanced_root)) ``` **Example Output**: ```plaintext [1, 5, 10, 20, 30, 40] ``` Implement the `balance_bst` function to ensure the tree is well-balanced while preserving the binary search tree property. Ensure to test your implementation to check for correctness and performance.","solution":"class TreeNode: def __init__(self, value: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def inorder_traversal(root): Returns the inorder traversal of the BST as a list. return inorder_traversal(root.left) + [root.value] + inorder_traversal(root.right) if root else [] def sorted_array_to_bst(nums): Constructs a balanced BST from the sorted array. if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_array_to_bst(nums[:mid]) node.right = sorted_array_to_bst(nums[mid+1:]) return node def balance_bst(root: TreeNode) -> TreeNode: Converts an unbalanced BST to a balanced BST. if not root: return None # Get sorted list of values from BST sorted_values = inorder_traversal(root) # Convert sorted list to balanced BST return sorted_array_to_bst(sorted_values)"},{"question":"# Statistical Analysis: Mean and Median Calculation As part of a data analysis task, you need to implement functions that compute the mean and median of a given list of real numbers. The mean is the average value, and the median is the middle value when the list is sorted. Objective Write two functions `calculate_mean` and `calculate_median` that compute the mean and median of a given list of real numbers, respectively. Function Signatures ```python def calculate_mean(data: List[float]) -> float: def calculate_median(data: List[float]) -> float: ``` # Input - A list of `n` real numbers (floating-point values) `data`. # Output - For `calculate_mean`: A floating-point number representing the mean of the input list. - For `calculate_median`: A floating-point number representing the median of the input list. # Constraints - `1 <= n <= 10^6` - `-10^9 <= data[i] <= 10^9` for all `0 <= i < n` # Examples ```python assert calculate_mean([1, 2, 3, 4, 5]) == 3.0 assert calculate_mean([7.5, 3.5, 4.0, 6.0]) == 5.25 assert calculate_median([1, 2, 3, 4, 5]) == 3.0 assert calculate_median([3, 1, 4, 2]) == 2.5 assert calculate_median([5]) == 5.0 ``` **Explanation**: 1. For the first example, the mean of `[1, 2, 3, 4, 5]` is `3.0`, and the median is `3.0`. 2. For the second example, the mean of `[7.5, 3.5, 4.0, 6.0]` is `5.25`. 3. For the third example, the median of `[3, 1, 4, 2]` is `2.5` because when sorted, the list becomes `[1, 2, 3, 4]`, and the median is the average of `2` and `3`. # Requirements - Ensure your implementations handle large inputs efficiently. - Consider and handle edge cases such as the input list containing a single element. # Notes: - Remember to import necessary libraries for sorting and handling data if required. - Floating-point actual results are assumed to be accurate to at least two decimal places.","solution":"from typing import List def calculate_mean(data: List[float]) -> float: Calculate the mean of a list of floating point numbers. if not data: raise ValueError(\\"The input list is empty.\\") return sum(data) / len(data) def calculate_median(data: List[float]) -> float: Calculate the median of a list of floating point numbers. if not data: raise ValueError(\\"The input list is empty.\\") sorted_data = sorted(data) n = len(sorted_data) if n % 2 == 1: return float(sorted_data[n // 2]) else: mid1 = sorted_data[n // 2] mid2 = sorted_data[n // 2 - 1] return (mid1 + mid2) / 2"},{"question":"# Task: Log File Analyzer Scenario You are tasked with developing a tool for analyzing web server log files. Each line in the log file follows a specific format, including an IP address, a timestamp, the HTTP method, the URL, the HTTP status code, and the user agent. Your function should return the count of unique IP addresses that have accessed a specific URL within a given time frame. Construct a function `unique_ip_count(log_data: List[str], url: str, start_time: str, end_time: str) -> int` which, given a list of log lines, a URL, and a time range, returns the number of unique IP addresses that accessed the URL during that time range. Input - `log_data` (List[str]): A list of log entries, each as a string. Each log entry follows the format `\\"IP_ADDRESS - - [TIMESTAMP] \\"METHOD URL HTTP/1.1\\" STATUS_CODE USER_AGENT\\"`. - `url` (str): The URL to search for (e.g., \\"/index.html\\"). - `start_time` (str): The start of the time range in the format `\\"dd/MMM/yyyy:HH:mm:ss\\"` (e.g., \\"01/Jan/2022:00:00:00\\"). - `end_time` (str): The end of the time range in the same format as `start_time`. Output - Returns an integer indicating the number of unique IP addresses. Constraints - Assume log entries are well-formed and sorted by timestamp in ascending order. - The log file can contain up to 1,000,000 entries. - The time range provided is valid and `start_time` is earlier than or equal to `end_time`. Performance Requirements - The function should efficiently handle large log files and return results within a reasonable time frame. # Example Given the following log entries: ```python log_data = [ \\"192.168.1.1 - - [01/Jan/2022:12:00:00] \\"GET /index.html HTTP/1.1\\" 200 User-Agent\\", \\"192.168.1.2 - - [01/Jan/2022:12:05:00] \\"GET /index.html HTTP/1.1\\" 200 User-Agent\\", \\"192.168.1.1 - - [01/Jan/2022:12:10:00] \\"GET /contact.html HTTP/1.1\\" 200 User-Agent\\", \\"192.168.1.3 - - [01/Jan/2022:12:15:00] \\"GET /index.html HTTP/1.1\\" 200 User-Agent\\", ] ``` and the function call: ```python print(unique_ip_count(log_data, \\"/index.html\\", \\"01/Jan/2022:12:00:00\\", \\"01/Jan/2022:12:20:00\\")) ``` The output should be `3` because three unique IP addresses (`192.168.1.1`, `192.168.1.2`, `192.168.1.3`) accessed `/index.html` within the given time range.","solution":"from typing import List from datetime import datetime def unique_ip_count(log_data: List[str], url: str, start_time: str, end_time: str) -> int: Counts unique IP addresses that accessed a specific URL within a given time frame. :param log_data: List of log entries. :param url: The URL to search for. :param start_time: The start time of the range in \\"dd/MMM/yyyy:HH:mm:ss\\" format. :param end_time: The end time of the range in \\"dd/MMM/yyyy:HH:mm:ss\\" format. :return: Number of unique IP addresses. start_timestamp = datetime.strptime(start_time, \\"%d/%b/%Y:%H:%M:%S\\") end_timestamp = datetime.strptime(end_time, \\"%d/%b/%Y:%H:%M:%S\\") unique_ips = set() for entry in log_data: parts = entry.split() ip_address = parts[0] timestamp_str = parts[3].strip(\'[\') + \\" \\" + parts[4].strip(\']\') entry_timestamp = datetime.strptime(timestamp_str, \\"%d/%b/%Y:%H:%M:%S +0000\\") log_url = parts[6] if log_url == url and start_timestamp <= entry_timestamp <= end_timestamp: unique_ips.add(ip_address) return len(unique_ips)"},{"question":"# Description: You are given two implementations, `reverse_string_iteratively` and `reverse_string_recursively`, each of which reverses a string using iterative and recursive approaches, respectively. Your task is to create a combined method that uses both approaches based on the length of the input string. # Task: Implement a function `reverse_string_hybrid(s: str) -> str` that: 1. If the length of the string is less than or equal to a predefined threshold, use an iterative approach. 2. If the length of the string is greater than the threshold, use the recursive approach. # Constraints: - The string `s` consists of only ASCII characters. - The function must handle an empty string by returning an empty string. - The function must handle cases where the input is None by raising a `TypeError` with a message indicating the invalid input. # Inputs: - `s` (str): The string to be reversed. # Output: - Returns the reversed string. # Example Usage: ```python >>> reverse_string_hybrid(\\"hello\\") \\"olleh\\" >>> reverse_string_hybrid(\\"world\\") \\"dlrow\\" >>> reverse_string_hybrid(\\"a\\") \\"a\\" >>> reverse_string_hybrid(\\"\\") \\"\\" >>> reverse_string_hybrid(None) Traceback (most recent call last): ... TypeError: reverse_string_hybrid() arg is None ``` # Note: - Ensure your implementation is efficient and correctly handles edge cases. - Set the threshold for switching between iterative and recursive methods as 5 for this implementation. ```python def reverse_string_hybrid(s: str) -> str: # Define the threshold THRESHOLD = 5 if s is None: raise TypeError(\\"reverse_string_hybrid() arg is None\\") def reverse_string_recursively(s): if len(s) <= 1: return s return reverse_string_recursively(s[1:]) + s[0] def reverse_string_iteratively(s): reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str # Use iterative for small strings if len(s) <= THRESHOLD: return reverse_string_iteratively(s) else: return reverse_string_recursively(s) ```","solution":"def reverse_string_hybrid(s: str) -> str: Reverses a string using both iterative and recursive approaches based on string length. For strings with length <= 5, it uses an iterative approach. For longer strings, it uses a recursive approach. THRESHOLD = 5 if s is None: raise TypeError(\\"reverse_string_hybrid() arg is None\\") def reverse_string_recursively(s): if len(s) <= 1: return s return reverse_string_recursively(s[1:]) + s[0] def reverse_string_iteratively(s): reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str # Use iterative for small strings if len(s) <= THRESHOLD: return reverse_string_iteratively(s) else: return reverse_string_recursively(s)"},{"question":"# Prime Factorization In number theory, the prime factors of a positive integer are the prime numbers that divide the integer exactly, without leaving a remainder. # Task Implement a function `prime_factors` that computes the prime factors of a given integer `n`. Your function should take an integer `n` as input and return a list of tuples, where each tuple contains a prime factor and its exponent in the factorization. ```python def prime_factors(n: int) -> list: Determine the prime factors of a given integer n. :param n: Integer to factorize. :return: List of tuples with prime factors and their exponents. ``` # Input - An integer **n** where (2 leq n leq 10^{12}). # Output - Return a list of tuples, where each tuple contains a prime factor of `n` and its exponent in the factorization. The list should be sorted in ascending order of the prime factors. # Constraints - The input will always be an integer greater than 1. # Performance Requirement - Your solution should efficiently handle integers up to (10^{12}). # Example ```python assert prime_factors(60) == [(2, 2), (3, 1), (5, 1)] assert prime_factors(84) == [(2, 2), (3, 1), (7, 1)] assert prime_factors(29) == [(29, 1)] ``` # Notes - For instance, the number 60 has the prime factors (2^2, 3^1, ) and (5^1), so the result should be `[(2, 2), (3, 1), (5, 1)]`. - Optimize your solution for large values to ensure it completes within a reasonable time frame.","solution":"def prime_factors(n: int) -> list: Determine the prime factors of a given integer n. :param n: Integer to factorize. :return: List of tuples with prime factors and their exponents. i = 2 factors = [] # Check for each number starting from 2 while i * i <= n: if n % i: i += 1 else: count = 0 while n % i == 0: n //= i count += 1 factors.append((i, count)) if n > 1: factors.append((n, 1)) return factors"},{"question":"# Coding Assessment Question: Question 2: Implementing a Word Frequency Analyzer Scenario: You are working with a team of developers on a text analysis module for a content management system. Your task is to create a Word Frequency Analyzer that reads text from a file and calculates the frequency of each word present in the text. This tool will help identify the most common words used in the content, which is important for keyword optimization and content indexing. Problem Statement: Write a Python function to analyze the frequency of words in a given text file. The function should output a dictionary where the keys are words and the values are their corresponding frequencies. Your implementation should handle various edge cases such as punctuation, different casings, and empty files. Additionally, provide proper feedback if the specified input file is not found. Requirements: 1. A function `analyze_word_frequency(file_path: str) -> dict`. 2. Handle edge cases such as empty files and lines. 3. Normalize the text to ensure that words are counted case-insensitively. 4. Exclude punctuation from the word count. 5. Provide clear error messages for file-related issues. Input: - A string `file_path` which is the path to the text file to be analyzed. Output: - A dictionary where keys are unique words (in lowercase) and values are their frequencies. Constraints: - The text file will contain only printable ASCII characters. - The file path should be valid and accessible. Example: ```python file_path = \\"example.txt\\" # Content of example.txt: # \\"Hello, World! Hello world. This is a test. Test, test, test.\\" word_frequency = analyze_word_frequency(file_path) print(word_frequency) # Output: {\'hello\': 2, \'world\': 2, \'this\': 1, \'is\': 1, \'a\': 1, \'test\': 4} ``` Additional Notes: - Consider using Python\'s built-in libraries to handle file reading and text processing. - Your solution should be efficient and capable of processing large text files in a reasonable time. - Ensure that your implementation can handle large and complex text files seamlessly. --- Compose your code and thoroughly test it to verify its correctness and performance before submitting the solution.","solution":"import string def analyze_word_frequency(file_path: str) -> dict: Analyzes the frequency of words in the given text file. Args: - file_path: The path to the text file. Returns: - A dictionary where keys are unique words and values are their frequencies. word_count = {} try: with open(file_path, \'r\') as file: for line in file: # Remove punctuation and make lowercase translator = str.maketrans(\'\', \'\', string.punctuation) cleaned_line = line.translate(translator).lower() words = cleaned_line.split() for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 except FileNotFoundError: print(f\\"Error: The file at {file_path} was not found.\\") return {} return word_count"},{"question":"# Task You need to implement the `run_kmeans_clustering` function to perform the k-means clustering algorithm on a set of 2D points. Given a number of clusters `k` and a list of points, your function should iteratively refine the clusters by updating the cluster centroids until convergence is reached. You will also write a `test_kmeans_clustering` function to validate the cluster assignments of the data points. # Requirements: * Implement `run_kmeans_clustering` to: - Initialize the cluster centroids randomly from the given points. - Assign each point to the nearest centroid. - Update the centroids as the mean of the assigned points. - Repeat the assignment and update steps until the centroids change insignificantly or a maximum number of iterations is reached. - Print the final cluster centroids and the number of iterations taken to converge. * Implement `test_kmeans_clustering` to: - Print the assigned cluster for each test point. # Input Format: - `points`: A list of tuples representing 2D points. - `k`: An integer representing the number of clusters. - `tolerance`: A float representing the tolerance level for centroid changes to determine convergence. - `max_iterations`: An integer representing the maximum number of iterations. # Output Format: - Print the final positions of the cluster centroids and the number of iterations taken for the k-means algorithm to converge in `run_kmeans_clustering`. - For each point tested in `test_kmeans_clustering`, print the coordinates of the point and its assigned cluster. # Constraints: - Use a fixed `tolerance = 0.0001`. - Use a reasonable range for `max_iterations`. # Example Usage: Given: ```python points = [(1.5, 2.0), (3.0, 4.0), (5.0, 7.0), (8.0, 8.0), (3.5, 5.0), (4.5, 5.0), (3.5, 4.5)] k = 2 tolerance = 0.0001 max_iterations = 100 ``` After running `run_kmeans_clustering` function, the output might be: ```python Final cluster centroids: [(X1, Y1), (X2, Y2)] Number of iterations: N ``` After running `test_kmeans_clustering` function, the output might be: ```python Point (1.5, 2.0) is in cluster 0 Point (3.0, 4.0) is in cluster 1 ... ``` Implement the functions `run_kmeans_clustering` and `test_kmeans_clustering` to ensure your solution works correctly.","solution":"import random import math def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) def run_kmeans_clustering(points, k, tolerance=0.0001, max_iterations=100): # Randomly initialize the cluster centroids centroids = random.sample(points, k) prev_centroids = centroids for _ in range(max_iterations): # Assign points to the nearest centroid clusters = [[] for _ in range(k)] for point in points: distances = [euclidean_distance(point, centroid) for centroid in centroids] closest_centroid_idx = distances.index(min(distances)) clusters[closest_centroid_idx].append(point) # Update centroids new_centroids = [] for cluster in clusters: if len(cluster) == 0: new_centroids.append(random.choice(points)) else: mean_x = sum([point[0] for point in cluster]) / len(cluster) mean_y = sum([point[1] for point in cluster]) / len(cluster) new_centroids.append((mean_x, mean_y)) # Check for convergence if all(euclidean_distance(prev_centroids[i], new_centroids[i]) < tolerance for i in range(k)): print(f\\"Convergence reached after {_+1} iterations.\\") break prev_centroids = new_centroids centroids = new_centroids print(\\"Final cluster centroids:\\", centroids) print(\\"Number of iterations:\\", _+1) return centroids, clusters def test_kmeans_clustering(): points = [(1.5, 2.0), (3.0, 4.0), (5.0, 7.0), (8.0, 8.0), (3.5, 5.0), (4.5, 5.0), (3.5, 4.5)] k = 2 tolerance = 0.0001 max_iterations = 100 centroids, clusters = run_kmeans_clustering(points, k, tolerance, max_iterations) # Print the assigned cluster for each point for i, cluster in enumerate(clusters): for point in cluster: print(f\\"Point {point} is in cluster {i}\\") # Uncomment the following line to run the test function # test_kmeans_clustering()"},{"question":"# Path Compression in Disjoint Set (Union-Find Algorithm) Background The Disjoint Set Union (DSU) or Union-Find is a data structure that keeps track of a set of elements partitioned into several disjoint (non-overlapping) subsets. A useful operation that can be optimized in Union-Find is the \\"Find\\" operation, which can be made more efficient through path compression. Problem Statement Write a class `DisjointSet` which implements the Union-Find data structure with path compression. The class should support two main operations: 1. `find(x)`: Returns the representative (or root) of the set containing `x`. This method should implement path compression. 2. `union(x, y)`: Merges the sets containing `x` and `y`. ```python class DisjointSet: def __init__(self, size: int): Initializes an array of `size` elements where each element is its own representative. Arguments: size -- Number of elements in the disjoint set Example: >>> ds = DisjointSet(5) >>> ds.find(3) 3 self.parent = list(range(size)) self.rank = [0] * size def find(self, x: int) -> int: Finds the representative (or root) of the set containing `x` with path compression. Arguments: x -- Element to find its representative Example: >>> ds = DisjointSet(5) >>> ds.union(1, 2) >>> ds.find(1) == ds.find(2) True if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x: int, y: int) -> None: Merges the sets containing `x` and `y` by rank. Arguments: x -- First element y -- Second element Example: >>> ds = DisjointSet(5) >>> ds.union(1, 2) >>> ds.union(3, 4) >>> ds.union(1, 4) >>> ds.find(1) == ds.find(3) True rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 ``` # Input - `size` (int): The number of elements in the disjoint set. - `x`, `y` (int): Elements on which to perform Union-Find operations. # Output - `find(x)` (int): The representative (or root) of the set containing `x`. - `union(x, y)` (None): Merges the sets containing `x` and `y`. # Constraints - The number of elements in the disjoint set will be at most 100,000. - All elements will be non-negative integers and within the range of the size specified. - The \\"find\\" and \\"union\\" operations will be invoked multiple times. # Requirements - Implement path compression in the `find` operation to optimize performance. - Use union by rank in the `union` operation to keep the tree flat. - Ensure that the operations are efficient, ideally with near constant time complexity. # Testing You may assume the presence of a testing framework similar to `doctest`. Comprehensive tests covering all mentioned scenarios for both `find` and `union` operations will be appreciated. Good luck, and happy coding!","solution":"class DisjointSet: def __init__(self, size: int): Initializes an array of `size` elements where each element is its own representative. Arguments: size -- Number of elements in the disjoint set self.parent = list(range(size)) self.rank = [0] * size def find(self, x: int) -> int: Finds the representative (or root) of the set containing `x` with path compression. Arguments: x -- Element to find its representative if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) # Path compression return self.parent[x] def union(self, x: int, y: int) -> None: Merges the sets containing `x` and `y` by rank. Arguments: x -- First element y -- Second element rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1"},{"question":"# Problem Statement You are given an undirected graph with (n) vertices. Your task is to determine if it contains any cycles, and if so, return one of those cycles. The graph will be represented by a list of edges, where each edge connects two vertices. # Function Signature ```python def find_cycle(n: int, edges: List[Tuple[int, int]]) -> List[int]: ``` # Input - `n` (int): The number of vertices in the graph. - `edges` (List[Tuple[int, int]]): A list of tuples, each representing an edge in the graph, where the first element is one vertex and the second element is the other vertex of the edge. # Output - If a cycle is found, return a list of integers representing the vertices in the cycle (you can return any of the valid cycles if there are multiple). - If no cycle is found, return an empty list. # Constraints - (1 leq n leq 10^3) - (0 leq text{edges.length} leq 2 times 10^3) - Each edge connects two distinct vertices. - Vertices are indexed from 0 to (n-1). # Example ```python n = 4 edges = [(0, 1), (1, 2), (2, 0), (1, 3)] print(find_cycle(n, edges)) # Expected output: [0, 1, 2, 0] or any other valid cycle ``` # Requirements 1. Implement the function `find_cycle(n: int, edges: List[Tuple[int, int]]) -> List[int]` to find a single cycle in the undirected graph. 2. Ensure the implementation handles edge cases, such as no cycles in the graph, and multiple cycles, by finding and returning one valid cycle.","solution":"def find_cycle(n: int, edges: list[tuple[int, int]]) -> list[int]: from collections import defaultdict, deque def dfs(v, parent): visited[v] = True stack.append(v) for neighbor in graph[v]: if not visited[neighbor]: if dfs(neighbor, v): return True elif neighbor != parent: # Cycle detected cycle_start = neighbor cycle_stack_index = stack.index(cycle_start) cycle.extend(stack[cycle_stack_index:]) cycle.append(cycle_start) return True stack.pop() return False graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n cycle = [] stack = [] for node in range(n): if not visited[node]: if dfs(node, -1): return cycle return []"},{"question":"# Problem Statement: You are required to implement a **Concurrent Task Scheduler**. This scheduler should allow you to add new tasks, remove tasks, and execute all scheduled tasks in a sorted manner based on their priority levels. Each task has a unique identifier and a priority value, with lower values indicating higher priority. Function Signatures: 1. `__init__(self) -> None`: Initialize the task scheduler with no tasks. 2. `add_task(self, task_id: str, priority: int) -> None`: Add a new task with the given `task_id` and `priority`. If a task with the same `task_id` already exists, update its priority. 3. `remove_task(self, task_id: str) -> None`: Remove the task with the given `task_id` from the scheduler. If the task does not exist, this operation should do nothing. 4. `execute_tasks(self) -> List[str]`: Execute all tasks in the scheduler in order of their priority (from lowest to highest value), and return the list of `task_id`s in the order they were executed. After this operation, the scheduler should be empty. Constraints: - There can be at most `10^5` tasks in the scheduler. - Priorities will be integer values between `-10^6` and `10^6`. - `task_id` will be a string of at most length 100. - Each `task_id` is unique at any given time. Example: ```python >>> scheduler = TaskScheduler() >>> scheduler.add_task(\\"task1\\", 5) >>> scheduler.add_task(\\"task2\\", 3) >>> scheduler.add_task(\\"task3\\", 10) >>> scheduler.execute_tasks() [\'task2\', \'task1\', \'task3\'] >>> scheduler.add_task(\\"task1\\", 2) >>> scheduler.add_task(\\"task2\\", 3) >>> scheduler.remove_task(\\"task1\\") >>> scheduler.execute_tasks() [\'task2\'] >>> scheduler.add_task(\\"task4\\", 1) >>> scheduler.add_task(\\"task5\\", 4) >>> scheduler.execute_tasks() [\'task4\', \'task5\'] ``` # Implementation: You are required to implement the `TaskScheduler` class to meet the given specifications. Ensure that the operations are efficient and handle edge cases appropriately.","solution":"from typing import List import heapq class TaskScheduler: def __init__(self) -> None: self.tasks = {} self.task_queue = [] self.counter = 0 # To ensure stable sorting by order of insertion def add_task(self, task_id: str, priority: int) -> None: if task_id in self.tasks: self.remove_task(task_id) self.tasks[task_id] = priority heapq.heappush(self.task_queue, (priority, self.counter, task_id)) self.counter += 1 def remove_task(self, task_id: str) -> None: if task_id in self.tasks: del self.tasks[task_id] # Rebuild the heap without the removed task self.task_queue = [(p, i, tid) for p, i, tid in self.task_queue if tid != task_id] heapq.heapify(self.task_queue) def execute_tasks(self) -> List[str]: executed_task_ids = [] while self.task_queue: priority, count, task_id = heapq.heappop(self.task_queue) if task_id in self.tasks: executed_task_ids.append(task_id) del self.tasks[task_id] return executed_task_ids"},{"question":"# Scenario You are tasked with developing a function for a scientific application that processes a series of operations on matrices. The operation of interest is finding the transpose of a given matrix. The transpose of a matrix is a new matrix whose rows are the columns of the original, and whose columns are the rows of the original. # Task Write a function `matrix_transpose(matrix: List[List[int]]) -> List[List[int]]` that takes a 2D list of integers representing a matrix and returns its transpose. # Input - `matrix` (List[List[int]]): A 2D list where each sub-list represents a row of the matrix (1 ≤ number of rows ≤ 100, 1 ≤ number of columns ≤ 100). # Output - Returns a new 2D list (matrix) that represents the transpose of the input matrix. # Constraints - Each element of the matrix is an integer (-10^9 ≤ element ≤ 10^9). - The function should efficiently handle edge cases where the matrix is not square. # Example ```python assert matrix_transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert matrix_transpose([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]] assert matrix_transpose([[1]]) == [[1]] ``` # Implementation Notes - Ensure that the function handles matrices where the number of rows does not equal the number of columns. - Consider using list comprehension for a concise and efficient implementation. - Make sure to test the function with various sizes of matrices to validate correctness.","solution":"from typing import List def matrix_transpose(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of the given matrix. Parameters: matrix (List[List[int]]): The input matrix where each sub-list is a row. Returns: List[List[int]]: The transposed matrix where each sub-list is a column. return [[row[i] for row in matrix] for i in range(len(matrix[0]))]"},{"question":"# Question: Implementing a Custom in-place Merge Sort Create an in-place version of the merge sort algorithm for an array of integers. Your implementation should sort the array without using additional arrays, focusing on sorting within the original array itself, hence minimizing the extra space usage. **Function Signature:** ```python def in_place_merge_sort(arr: list[int]) -> None: pass ``` **Input:** * `arr`: A list of integers, which can include negative numbers. The length of the list can be up to (10^5). **Output:** * Modify the input list so that it is sorted in ascending order. **Constraints:** * The merge sort must be implemented in-place. * Your function should efficiently handle larger arrays. **Examples:** ```python arr1 = [10, -3, 5, 1, 0] in_place_merge_sort(arr1) assert arr1 == [-3, 0, 1, 5, 10] arr2 = [] in_place_merge_sort(arr2) assert arr2 == [] arr3 = [7] in_place_merge_sort(arr3) assert arr3 == [7] arr4 = [8, 4, 3, 3, 2, 1, 0, -1] in_place_merge_sort(arr4) assert arr4 == [-1, 0, 1, 2, 3, 3, 4, 8] ```","solution":"def in_place_merge_sort(arr): Sorts an array in-place using the merge sort algorithm. def merge(arr, start, mid, end): Helper function to merge two halves of the array. start2 = mid + 1 # If the direct merge is already sorted if arr[mid] <= arr[start2]: return # Two pointers to maintain start of both arrays to merge while start <= mid and start2 <= end: # If element 1 is in right place if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 # Shift all the elements between element 1 and element 2, right by 1. while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value # Update all the pointers start += 1 mid += 1 start2 += 1 def merge_sort(arr, l, r): Helper function to perform merge sort on the array from index l to r. if l < r: m = l + (r - l) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r) merge_sort(arr, 0, len(arr) - 1)"},{"question":"# Task Write a function `translate_matrix` that rotates a given NxN matrix 90 degrees clockwise. You must implement the rotation in-place with no additional data structures aside from temporary variables. # Function Signature ```python def translate_matrix(matrix: List[List[int]]) -> None: pass ``` # Input * `matrix` (List[List[int]]): An NxN matrix represented as a list of lists containing integers. Each sub-list represents a row in the matrix. The matrix has at least one element. # Output * The function should modify the input matrix in place, effectively rotating it 90 degrees clockwise. # Constraints * The input will always be a square matrix. * Handle both small and large matrices efficiently. # Examples ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> translate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> translate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] ``` # Notes * Ensure that the rotation is performed in-place with no additional space for another matrix. * The function should not return anything; it should modify the input matrix directly. * Consider edge cases such as the smallest matrix (1x1) and verify that your function handles them correctly.","solution":"from typing import List def translate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Regex Pattern Matching for File Names Context: In a large file system, you often need to search for files that match certain naming patterns. The file names are represented as strings and you are given patterns that can include special characters: - `*` matches any sequence of characters (including the empty sequence). - `?` matches any single character. Given a list of file names and a pattern, your task is to count how many files match the given pattern. Problem Statement: Given: - A list of `file_names` where each element is a file name represented as a string. - A `pattern` that may include the special characters `*` and `?` as mentioned above. Write a function `count_matching_files(file_names: List[str], pattern: str) -> int` that returns the count of files that match the given pattern. Function Signature: ```python def count_matching_files(file_names: List[str], pattern: str) -> int: ``` Input: - `file_names`: A list of strings representing file names. - `pattern`: A string representing the pattern to match. Output: - An integer representing the number of files that match the pattern. Constraints: - 1 ≤ len(file_names) ≤ 1000 - 1 ≤ len each file name ≤ 50 - 1 ≤ len(pattern) ≤ 50 Example: Input: ```python file_names = [\\"file1.txt\\", \\"file2.txt\\", \\"file3.doc\\", \\"file4.txt\\"] pattern = \\"file?.txt\\" ``` Output: ```python 3 ``` Explanation: For the given example: - \\"file1.txt\\" matches \\"file?.txt\\". - \\"file2.txt\\" matches \\"file?.txt\\". - \\"file4.txt\\" matches \\"file?.txt\\". - \\"file3.doc\\" does not match \\"file?.txt\\". Thus, the function should return 3. Consider the use of regular expressions or similar techniques to implement the pattern matching efficiently.","solution":"import re from typing import List def count_matching_files(file_names: List[str], pattern: str) -> int: Returns the count of files that match the given pattern. The pattern supports \'*\' to match any sequence of characters (including an empty sequence), and \'?\' to match any single character. # Convert the pattern to a regex pattern regex_pattern = \'^\' + re.escape(pattern).replace(r\'*\', \'.*\').replace(r\'?\', \'.\') + \'\' count = 0 for file_name in file_names: if re.match(regex_pattern, file_name): count += 1 return count"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=c(O,[["render",D],["__scopeId","data-v-de926b54"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/35.md","filePath":"drive/35.md"}'),j={name:"drive/35.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
