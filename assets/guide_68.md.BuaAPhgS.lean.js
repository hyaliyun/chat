import{_,o as s,c as n,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(r,e,u,m,i,a){return s(),n("div",k,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const R=_(q,[["render",A],["__scopeId","data-v-2f5b8060"]]),S=JSON.parse(`[{"question":"from typing import List, Tuple def calculate_enjoyments(n: int, q: int, beauty_scores: List[int], roads: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the total enjoyment Chef can get by traveling from city A to city B. Parameters: n (int): The number of cities q (int): The number of queries beauty_scores (List[int]): The beauty scores for each of the cities roads (List[Tuple[int, int]]): The roads connecting the cities queries (List[Tuple[int, int]]): The queries specifying two cities between which the enjoyment is to be calculated Returns: List[int]: A list of integers representing the total enjoyment for each query Example: >>> n = 5 >>> q = 3 >>> beauty_scores = [2, 3, 1, 4, 6] >>> roads = [(1, 2), (2, 3), (3, 4), (4, 5)] >>> queries = [(1, 5), (3, 5), (2, 4)] >>> calculate_enjoyments(n, q, beauty_scores, roads, queries) [16, 11, 8]","solution":"from collections import defaultdict, deque def calculate_enjoyments(n, q, beauty_scores, roads, queries): # Create adjacency list for the given roads graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Prepare a parents and depths array to help find LCA parents = [0] * (n + 1) depth = [0] * (n + 1) subtree_sum = [0] * (n + 1) def bfs(start): queue = deque([start]) visited = {start} parents[start] = -1 depth[start] = 0 subtree_sum[start] = beauty_scores[start - 1] while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) parents[neighbor] = node depth[neighbor] = depth[node] + 1 subtree_sum[neighbor] = subtree_sum[node] + beauty_scores[neighbor - 1] # Perform BFS from node 1 bfs(1) def lca(a, b): if depth[a] < depth[b]: a, b = b, a while depth[a] > depth[b]: a = parents[a] while a != b: a = parents[a] b = parents[b] return a results = [] for a, b in queries: common_ancestor = lca(a, b) enjoyment = subtree_sum[a] + subtree_sum[b] - 2 * subtree_sum[common_ancestor] + beauty_scores[common_ancestor - 1] results.append(enjoyment) return results"},{"question":"from typing import List def max_consecutive_safe_houses(test_cases: List[str]) -> List[int]: Given a list of hiking routes, compute the maximum number of consecutive safe houses ('S') that can be visited starting from any point on the route. Args: test_cases: A list of strings representing different hiking routes. Returns: A list of integers representing the maximum number of consecutive safe houses for each route. Example: >>> max_consecutive_safe_houses([\\"SSSDSS\\", \\"DSSDSDSSS\\", \\"SSSSD\\"]) [3, 3, 4] >>> max_consecutive_safe_houses([\\"SSSS\\", \\"DDDD\\", \\"SDSDSDSD\\"]) [4, 0, 1]","solution":"def max_consecutive_safe_houses(test_cases): results = [] for route in test_cases: max_safe = 0 current_safe = 0 for char in route: if char == 'S': current_safe += 1 if current_safe > max_safe: max_safe = current_safe else: current_safe = 0 results.append(max_safe) return results"},{"question":"def max_water_trapped(n: int, heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped after raining on a given elevation map. :param n: Integer, length of the list \`heights\` :param heights: List of non-negative integers representing the elevation map. :return: Integer, maximum water trapped. def process_input(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases to determine the maximum amount of water trapped for each case. :param t: Integer, the number of test cases. :param test_cases: List of tuples where each tuple contains (n, heights) for each test case. :return: List of integers representing the result for each test case. from solution import max_water_trapped, process_input def test_max_water_trapped(): assert max_water_trapped(12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert max_water_trapped(6, [4, 2, 0, 3, 2, 5]) == 9 assert max_water_trapped(0, []) == 0 assert max_water_trapped(1, [3]) == 0 assert max_water_trapped(2, [3, 3]) == 0 assert max_water_trapped(3, [3, 0, 3]) == 3 def test_process_input(): test_cases = [ (12, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (6, [4, 2, 0, 3, 2, 5]) ] assert process_input(2, test_cases) == [6, 9] test_cases = [ (0, []), (1, [3]), (3, [3, 0, 3]) ] assert process_input(3, test_cases) == [0, 0, 3] def test_edge_cases(): assert max_water_trapped(4, [1, 1, 1, 1]) == 0 assert max_water_trapped(5, [5, 4, 3, 2, 1]) == 0","solution":"def max_water_trapped(n, heights): Calculate the maximum amount of water that can be trapped after raining on a given elevation map. :param n: Integer, length of the list \`heights\` :param heights: List of non-negative integers representing the elevation map. :return: Integer, maximum water trapped. if n == 0: return 0 left = [0] * n right = [0] * n water_trapped = 0 # Fill left array left[0] = heights[0] for i in range(1, n): left[i] = max(left[i - 1], heights[i]) # Fill right array right[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right[i] = max(right[i + 1], heights[i]) # Calculate the trapped water for i in range(0, n): water_trapped += min(left[i], right[i]) - heights[i] return water_trapped def process_input(t, test_cases): Process multiple test cases to determine the maximum amount of water trapped for each case. :param t: Integer, the number of test cases. :param test_cases: List of tuples where each tuple contains (n, heights) for each test case. :return: List of integers representing the result for each test case. results = [] for i in range(t): n, heights = test_cases[i] result = max_water_trapped(n, heights) results.append(result) return results"},{"question":"def maxAverage(arr: List[int], k: int) -> float: Returns the maximum average sum of any contiguous subarray of length k. >>> maxAverage([1,12,-5,-6,50,3], 4) 12.75 >>> maxAverage([1,2,3,4,5], 2) 4.5 >>> maxAverage([-1,-2,-3,-4,-5], 2) -1.5 >>> maxAverage([1], 1) 1.0 >>> maxAverage([5,5,5,5], 2) 5.0","solution":"def maxAverage(arr, k): Returns the maximum average sum of any contiguous subarray of length k. n = len(arr) if k > n: return 0 max_sum = curr_sum = sum(arr[:k]) for i in range(k, n): curr_sum += arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) return max_sum / k"},{"question":"def predict_words(n, words, prefix): Given a list of words and a prefix, returns the words that start with the given prefix in lexicographical order. :param n: Integer, number of words in the dictionary. :param words: List of strings, the dictionary of words. :param prefix: String, the prefix to look for in the words. :return: List of strings, words from the dictionary that start with the given prefix. >>> predict_words(5, [\\"apple\\", \\"app\\", \\"application\\", \\"apricot\\", \\"banana\\"], \\"app\\") ['app', 'apple', 'application'] >>> predict_words(3, [\\"cat\\", \\"car\\", \\"carbon\\"], \\"ca\\") ['car', 'carbon', 'cat'] >>> predict_words(4, [\\"dog\\", \\"deer\\", \\"deal\\", \\"door\\"], \\"do\\") ['dog', 'door'] >>> predict_words(3, [\\"xylophone\\", \\"xenon\\", \\"xero\\"], \\"xyz\\") [\\"No match found\\"]","solution":"def predict_words(n, words, prefix): Given a list of words and a prefix, returns the words that start with the given prefix in lexicographical order. :param n: Integer, number of words in the dictionary. :param words: List of strings, the dictionary of words. :param prefix: String, the prefix to look for in the words. :return: List of strings, words from the dictionary that start with the given prefix. matching_words = [word for word in words if word.startswith(prefix)] matching_words.sort() return matching_words if matching_words else [\\"No match found\\"]"},{"question":"def is_special_string(s: str) -> str: Determines if a given string is a special string. >>> is_special_string(\\"abacab\\") \\"YES\\" >>> is_special_string(\\"abcd\\") \\"NO\\" >>> is_special_string(\\"abba\\") \\"YES\\" >>> is_special_string(\\"abcddcba\\") \\"YES\\" >>> is_special_string(\\"aabbaa\\") \\"YES\\" >>> is_special_string(\\"aabaca\\") \\"YES\\"","solution":"def is_special_string(s): Determines if a given string is a special string. # Function to check if a given substring is a palindrome def is_palindrome(sub): return sub == sub[::-1] n = len(s) # Iterate over all possible substrings of length greater than 1 for i in range(n): for j in range(i + 2, n + 1): if is_palindrome(s[i:j]): return \\"YES\\" return \\"NO\\""},{"question":"def total_characters_of_twice_occurrence(words: List[str]) -> int: Returns the total number of characters in the strings that appear exactly twice in the array. >>> total_characters_of_twice_occurrence([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"kiwi\\", \\"banana\\"]) == 11 >>> total_characters_of_twice_occurrence([\\"hello\\", \\"world\\", \\"hello\\", \\"coding\\"]) == 5 >>> total_characters_of_twice_occurrence([\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 0 >>> total_characters_of_twice_occurrence([\\"a\\", \\"a\\", \\"b\\", \\"b\\"]) == 2 >>> total_characters_of_twice_occurrence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"cherry\\", \\"banana\\"]) == 6 >>> total_characters_of_twice_occurrence([]) == 0 >>> total_characters_of_twice_occurrence([\\"test\\"]) == 0 >>> total_characters_of_twice_occurrence([\\"abc\\"*100, \\"abc\\"*100, \\"def\\"*100, \\"def\\"*100]) == 600","solution":"def total_characters_of_twice_occurrence(words): Returns the total number of characters in the strings that appear exactly twice in the array. from collections import Counter # Count the occurrences of each word word_counts = Counter(words) # Iterate through the counts and sum the lengths of the words that appear exactly twice total_characters = sum(len(word) for word, count in word_counts.items() if count == 2) return total_characters"},{"question":"def average_steps(steps): Calculate the average number of steps taken per day over a week. Parameters: steps (list of int): A list containing exactly 7 integers representing steps taken each day. Returns: int: The average number of steps per day, rounded to the nearest integer. pass # Unit Tests def test_average_steps_normal_case(): assert average_steps([3000, 5000, 7600, 3200, 8800, 4300, 5100]) == 5286 def test_average_steps_min_values(): assert average_steps([0, 0, 0, 0, 0, 0, 0]) == 0 def test_average_steps_max_values(): assert average_steps([100000, 100000, 100000, 100000, 100000, 100000, 100000]) == 100000 def test_average_steps_mixed_values(): assert average_steps([100, 200, 300, 400, 500, 600, 700]) == 400 def test_average_steps_rounded_up(): assert average_steps([1, 2, 3, 4, 5, 6, 7]) == 4 def test_average_steps_rounded_down(): assert average_steps([1, 2, 3, 4, 5, 6, 8]) == 4","solution":"def average_steps(steps): Calculate the average number of steps taken per day over a week. Parameters: steps (list of int): A list containing exactly 7 integers representing steps taken each day. Returns: int: The average number of steps per day, rounded to the nearest integer. if len(steps) != 7: raise ValueError(\\"Input list must contain exactly 7 integers.\\") return round(sum(steps) / 7)"},{"question":"def minimal_repair_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimal number of roads that need to be repaired to form a Hamiltonian path >>> minimal_repair_roads(3, 3, [(1, 2), (2, 3), (3, 1)]) == 0 >>> minimal_repair_roads(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 >>> minimal_repair_roads(4, 2, [(1, 2), (3, 4)]) == -1","solution":"def minimal_repair_roads(n, m, roads): import networkx as nx G = nx.Graph() G.add_nodes_from(range(1, n + 1)) G.add_edges_from(roads) if not nx.is_connected(G): return -1 degrees = [G.degree(node) for node in G.nodes] odd_degrees = sum(degree % 2 != 0 for degree in degrees) if odd_degrees == 0: return 0 elif odd_degrees == 2: return 1 else: return (odd_degrees - 2) // 2 # Example usage n, m = 4, 3 roads = [(1, 2), (2, 3), (3, 4)] print(minimal_repair_roads(n, m, roads)) # Output should be 1"},{"question":"def find_pairs_with_target_sum(test_cases): Find all unique pairs in given arrays that add up to the target sum. Each test case is a tuple consisting of another tuple (N, S) and an array of N integers. N is the number of elements, and S is the target sum. >>> find_pairs_with_target_sum([((5, 7), [1, 2, 3, 4, 5])]) [[(2, 5), (3, 4)]] >>> find_pairs_with_target_sum([((4, 6), [3, 3, 3, 3])]) [[(3, 3)]] >>> find_pairs_with_target_sum([((5, 10), [1, 2, 3, 4, 5])]) [[]] >>> find_pairs_with_target_sum([((5, 7), [1, 2, 3, 4, 5]), ((4, 6), [3, 3, 3, 3])]) [[(2, 5), (3, 4)], [(3, 3)]] >>> find_pairs_with_target_sum([((4, 0), [-1, 0, 1, 2])]) [[(-1, 1)]] >>> find_pairs_with_target_sum([((3, 0), [1000000, -1000000, 0])]) [[(-1000000, 1000000)]] >>> find_pairs_with_target_sum([((6, 8), [2, 4, 4, 4, 6, 6])]) [[(2, 6), (4, 4)]]","solution":"def find_pairs_with_target_sum(test_cases): def find_pairs(arr, target): seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return sorted(pairs) results = [] for case in test_cases: N, S = case[0] array = case[1] results.append(find_pairs(array, S)) return results"},{"question":"def maximalRectangle(matrix: List[List[int]]) -> int: You're given a binary matrix of dimensions m x n where each cell contains either a 0 or a 1. Your task is to find the largest contiguous submatrix that contains only 1s and return its area. >>> maximalRectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximalRectangle([ ... [0, 1], ... [1, 0] ... ]) 1 >>> maximalRectangle([[0]]) 0 >>> maximalRectangle([ ... [1, 1, 1, 0] ... ]) 3 >>> maximalRectangle([ ... [1], ... [1], ... [1], ... [1] ... ]) 4 >>> maximalRectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9 >>> maximalRectangle([ ... [1, 0, 1, 1, 1, 1, 0], ... [1, 1, 1, 1, 0, 1, 1], ... [1, 0, 1, 1, 0, 1, 1] ... ]) 6 >>> maximalRectangle([]) 0","solution":"def maximalRectangle(matrix): if not matrix: return 0 def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) # Add a sentinel value to pop all elements from the stack at the end. for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Remove the sentinel value. return max_area rows = len(matrix) cols = len(matrix[0]) max_area = 0 heights = [0] * cols for i in range(rows): for j in range(cols): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += matrix[i][j] max_area = max(max_area, largestRectangleArea(heights)) return max_area"},{"question":"def find_connected_components(n, m, edges): Returns the number of connected components in the graph. Parameters: n (int): number of nodes m (int): number of edges edges (list of tuples): list of edges (u, v) Returns: int: number of connected components pass def test_find_connected_components_case1(): n = 5 m = 3 edges = [(1, 2), (1, 3), (4, 5)] assert find_connected_components(n, m, edges) == 2 def test_find_connected_components_case2(): n = 4 m = 0 edges = [] assert find_connected_components(n, m, edges) == 4 def test_find_connected_components_case3(): n = 3 m = 3 edges = [(1, 2), (2, 3), (3, 1)] assert find_connected_components(n, m, edges) == 1 def test_find_connected_components_case4(): n = 1 m = 0 edges = [] assert find_connected_components(n, m, edges) == 1 def test_find_connected_components_case5(): n = 10 m = 7 edges = [(1, 2), (2, 3), (3, 4), (5, 6), (6, 7), (8, 9), (9, 10)] assert find_connected_components(n, m, edges) == 3","solution":"def find_connected_components(n, m, edges): Returns the number of connected components in the graph. Parameters: n (int): number of nodes m (int): number of edges edges (list of tuples): list of edges (u, v) Returns: int: number of connected components from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() connected_components = 0 for node in range(1, n + 1): if node not in visited: bfs(node) connected_components += 1 return connected_components"},{"question":"def min_energy_cost(initial: str, target: str, cost_matrix: List[List[int]]) -> int: Calculate the minimum energy cost to transform the initial DNA sequence to the target DNA sequence. Args: initial (str): The initial DNA sequence. target (str): The target DNA sequence. cost_matrix (list of lists): 4x4 matrix representing the energy cost for transforming nucleotides. Returns: int: The minimum energy cost. Example: >>> min_energy_cost(\\"ACGT\\", \\"TGCA\\", [ ... [0, 1, 2, 3], ... [1, 0, 2, 3], ... [1, 2, 0, 3], ... [1, 2, 3, 0] ... ]) 8 from typing import List def test_example_case(): initial = \\"ACGT\\" target = \\"TGCA\\" cost_matrix = [ [0, 1, 2, 3], [1, 0, 2, 3], [1, 2, 0, 3], [1, 2, 3, 0] ] assert min_energy_cost(initial, target, cost_matrix) == 8 def test_case_no_changes_needed(): initial = \\"ACGT\\" target = \\"ACGT\\" cost_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert min_energy_cost(initial, target, cost_matrix) == 0 def test_case_with_cost_zero(): initial = \\"ACGT\\" target = \\"TGCA\\" cost_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert min_energy_cost(initial, target, cost_matrix) == 4 def test_case_all_transformations(): initial = \\"AAAA\\" target = \\"CCCC\\" cost_matrix = [ [0, 1, 2, 3], [4, 0, 5, 6], [7, 8, 0, 9], [10, 11, 12, 0] ] assert min_energy_cost(initial, target, cost_matrix) == 4 def test_large_case(): initial = \\"A\\" * 1000 target = \\"T\\" * 1000 cost_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert min_energy_cost(initial, target, cost_matrix) == 1000","solution":"def min_energy_cost(initial, target, cost_matrix): Calculate the minimum energy cost to transform the initial DNA sequence to the target DNA sequence. Args: initial (str): The initial DNA sequence. target (str): The target DNA sequence. cost_matrix (list of lists): 4x4 matrix representing the energy cost for transforming nucleotides. Returns: int: The minimum energy cost. nucleotide_to_index = {'A': 0, 'C': 1, 'G': 2, 'T': 3} total_cost = 0 for i in range(len(initial)): from_nucleotide = initial[i] to_nucleotide = target[i] from_index = nucleotide_to_index[from_nucleotide] to_index = nucleotide_to_index[to_nucleotide] total_cost += cost_matrix[from_index][to_index] return total_cost"},{"question":"def number_of_As(n: int) -> int: Returns the number of 'A's in the final sequence of length n. Kevin starts the game and they play alternately. >>> number_of_As(1) 1 >>> number_of_As(5) 3 >>> number_of_As(4) 2 >>> number_of_As(6) 3","solution":"def number_of_As(n): Returns the number of 'A's in the final sequence of length n. Kevin starts the game and they play alternately. if n % 2 == 0: return n // 2 else: return (n // 2) + 1"},{"question":"from typing import List def generate_passcode(nums: List[int]) -> str: Generates a passcode by replacing numbers with strings according to the rules: - Replace numbers divisible by 2 with \\"Foo\\". - Replace numbers divisible by 3 with \\"Bar\\". - Replace numbers divisible by both 2 and 3 with \\"FooBar\\". - Leave other numbers unchanged. Args: nums (List[int]): A list of non-negative integers. Returns: str: A string representing the passcode. Examples: >>> generate_passcode([1, 2, 3, 4, 5, 6]) '1FooBarFoo5FooBar' >>> generate_passcode([2, 3, 5, 7]) 'FooBar57'","solution":"from typing import List def generate_passcode(nums: List[int]) -> str: Generates a passcode by replacing numbers with strings according to the rules: - Replace numbers divisible by 2 with \\"Foo\\". - Replace numbers divisible by 3 with \\"Bar\\". - Replace numbers divisible by both 2 and 3 with \\"FooBar\\". - Leave other numbers unchanged. result = \\"\\" for num in nums: if num % 6 == 0: result += \\"FooBar\\" elif num % 2 == 0: result += \\"Foo\\" elif num % 3 == 0: result += \\"Bar\\" else: result += str(num) return result"},{"question":"def gcd_and_lcm(a: int, b: int) -> tuple: Returns a tuple containing the GCD and LCM of two positive integers a and b. >>> gcd_and_lcm(15, 20) (5, 60) >>> gcd_and_lcm(21, 14) (7, 42) >>> gcd_and_lcm(7, 7) (7, 7) >>> gcd_and_lcm(8, 15) (1, 120) >>> gcd_and_lcm(1, 10) (1, 10) >>> gcd_and_lcm(10, 1) (1, 10) >>> gcd_and_lcm(123456789, 987654321) (9, 13548070123626141)","solution":"def gcd_and_lcm(a: int, b: int) -> tuple: Returns a tuple containing the GCD and LCM of two positive integers a and b. def gcd(x, y): while y: x, y = y, x % y return x gcd_value = gcd(a, b) lcm_value = a * b // gcd_value return (gcd_value, lcm_value)"},{"question":"def validate_brackets(s: str) -> bool: Create a function \`validate_brackets\`, which takes a string \`s\` as its parameter and returns a boolean value \`True\` if the brackets in the string are balanced, and \`False\` otherwise. Parameters: s (str): A single string of length between 1 and 1000, containing only characters '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the brackets in the string are balanced, False otherwise. Examples: >>> validate_brackets(\\"(){}[]\\") True >>> validate_brackets(\\"([{}])\\") True >>> validate_brackets(\\"(]\\") False >>> validate_brackets(\\"([)]\\") False >>> validate_brackets(\\"{[]}\\") True","solution":"def validate_brackets(s): Returns True if the brackets in the string s are balanced, and False otherwise. stack = [] pairs = {')': '(', '}': '{', ']': '['} for char in s: if char in pairs.values(): stack.append(char) elif char in pairs: if not stack or stack[-1] != pairs[char]: return False stack.pop() return not stack"},{"question":"def sublist_median(arr, start, end): Finds the median of the sublist within the given list defined by start and end indices. Parameters: arr (list): A list of integers. start (int): The starting index of the sublist (inclusive). end (int): The ending index of the sublist (exclusive). Returns: float: The median of the sublist. Examples: >>> sublist_median([1, 3, 4, 2, 7, 5, 8, 6], 1, 5) 3.5 >>> sublist_median([10, 20, 30, 40, 50], 1, 4) 30.0 >>> sublist_median([5, 3, 1, 2, 4], 0, 3) 3.0","solution":"def sublist_median(arr, start, end): Finds the median of the sublist within the given list defined by start and end indices. Parameters: arr (list): A list of integers. start (int): The starting index of the sublist (inclusive). end (int): The ending index of the sublist (exclusive). Returns: float: The median of the sublist. sublist = arr[start:end] sublist.sort() n = len(sublist) if n % 2 == 1: # If the length of the sublist is odd, return the middle element return float(sublist[n // 2]) else: # If the length of the sublist is even, return the average of the two middle elements mid1 = sublist[n // 2 - 1] mid2 = sublist[n // 2] return (mid1 + mid2) / 2.0"},{"question":"def largest_number_after_deleting_one_digit(s: str) -> str: Returns the largest number that can be formed by deleting exactly one digit from the input string. >>> largest_number_after_deleting_one_digit(\\"12345\\") \\"2345\\" >>> largest_number_after_deleting_one_digit(\\"54321\\") \\"5432\\" >>> largest_number_after_deleting_one_digit(\\"11111\\") \\"1111\\"","solution":"def largest_number_after_deleting_one_digit(s): Returns the largest number that can be formed by deleting exactly one digit from the input string. max_number = \\"\\" for i in range(len(s)): new_number = s[:i] + s[i+1:] if new_number > max_number: max_number = new_number return max_number"},{"question":"def temperature_alert(temperature: str) -> str: Given a string 'temperature' representing a planet's surface temperature in degrees Celsius, returns 'Extreme Heat Alert!' if the temperature is >= 500 degrees, otherwise returns 'Normal Temperature: x degrees' where x is the temperature. >>> temperature_alert(\\"499\\") 'Normal Temperature: 499 degrees' >>> temperature_alert(\\"500\\") 'Extreme Heat Alert!' >>> temperature_alert(\\"-10\\") 'Normal Temperature: -10 degrees' def test_temperature_alert_extreme_heat(): assert temperature_alert(\\"500\\") == 'Extreme Heat Alert!' assert temperature_alert(\\"501\\") == 'Extreme Heat Alert!' assert temperature_alert(\\"1000\\") == 'Extreme Heat Alert!' assert temperature_alert(\\"9999\\") == 'Extreme Heat Alert!' def test_temperature_alert_normal_temperature(): assert temperature_alert(\\"499\\") == 'Normal Temperature: 499 degrees' assert temperature_alert(\\"0\\") == 'Normal Temperature: 0 degrees' assert temperature_alert(\\"-10\\") == 'Normal Temperature: -10 degrees' assert temperature_alert(\\"250\\") == 'Normal Temperature: 250 degrees' assert temperature_alert(\\"499\\") == 'Normal Temperature: 499 degrees' assert temperature_alert(\\"1\\") == 'Normal Temperature: 1 degrees' def test_temperature_alert_negative_normal_temperature(): assert temperature_alert(\\"-499\\") == 'Normal Temperature: -499 degrees' assert temperature_alert(\\"-500\\") == 'Normal Temperature: -500 degrees' assert temperature_alert(\\"-1000\\") == 'Normal Temperature: -1000 degrees' assert temperature_alert(\\"-1\\") == 'Normal Temperature: -1 degrees'","solution":"def temperature_alert(temperature): Given a string 'temperature' representing a planet's surface temperature in degrees Celsius, returns 'Extreme Heat Alert!' if the temperature is >= 500 degrees, otherwise returns 'Normal Temperature: x degrees' where x is the temperature. temp = int(temperature) if temp >= 500: return 'Extreme Heat Alert!' else: return f'Normal Temperature: {temp} degrees'"},{"question":"from typing import List, Tuple def apply_gravity(grid: List[List[str]], start_x: int, start_y: int) -> Tuple[int, int]: Simulates gravity on the 2D grid for the player starting at (start_x, start_y). Returns the final position of the player after gravity stops. >>> apply_gravity([ ... ['.', '.', '.', '.'], ... ['.', '.', '#', '.'], ... ['.', '.', '.', '.'], ... ['#', '#', '#', '#'] ... ], 1, 0) (2, 0) >>> apply_gravity([ ... ['.', '#', '.'], ... ['.', '.', '.'], ... ['#', '.', '#'] ... ], 1, 2) (1, 2) >>> apply_gravity([ ... ['#', '#', '#'], ... ['#', '#', '#'], ... ['#', '#', '#'] ... ], 1, 1) (1, 1)","solution":"from typing import List, Tuple def apply_gravity(grid: List[List[str]], start_x: int, start_y: int) -> Tuple[int, int]: Simulates gravity on the 2D grid for the player starting at (start_x, start_y). Returns the final position of the player after gravity stops. x = start_x y = start_y while x + 1 < len(grid) and grid[x + 1][y] == '.': x += 1 return (x, y)"},{"question":"def longest_group_length(s: str) -> int: Returns the length of the longest group in the string, where a group is defined as a substring where the same character repeats consecutively one or more times. ------ Input ------ The input consists of a single line containing the string s (1 ≤ |s| ≤ 10^5) which only contains lowercase letters. ------ Output ------ Output a single integer representing the length of the longest group in the string. ------ Constraints ------ - The length of the input string will not exceed 100,000 characters. - The string will only consist of lowercase letters ('a' - 'z'). ----- Sample Input 1 ------ \\"aaabbcccaaa\\" ----- Sample Output 1 ------ 3 --- Explanation 1 --- The input string \\"aaabbcccaaa\\" contains groups \\"aaa\\", \\"bb\\", \\"ccc\\", and \\"aaa\\". The lengths of these groups are 3, 2, 3, and 3 respectively. The longest group has a length of 3. Thus the output is 3. ----- Sample Input 2 ------ \\"ababababab\\" ----- Sample Output 2 ------ 1 --- Explanation 2 --- Each character in \\"ababababab\\" forms its own group, so all groups have a length of 1. Thus the output is 1. >>> longest_group_length(\\"aaabbcccaaa\\") 3 >>> longest_group_length(\\"ababababab\\") 1","solution":"def longest_group_length(s): Returns the length of the longest group in the string, where a group is defined as a substring where the same character repeats consecutively one or more times. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"class MutableString: def __init__(self): self.string = [] def append_char(self, c): Append the given character to the string. pass def insert_char(self, i, c): Insert the given character at a specified index in the string. pass def delete_char(self, i): Delete the character at the specified index in the string. pass def reverse_str(self): Reverse the string. pass def get_str(self): Return the current state of the string. pass def perform_operations(operations): Perform a sequence of operations on a mutable string. Args: operations (List[str]): List of operations to be performed on the string. Returns: List[str]: List of results after performing 'get' operations. Example: >>> perform_operations([ \\"append a\\", \\"append b\\", \\"insert 1 z\\", \\"get\\", \\"delete 0\\", \\"get\\" ]) [\\"azb\\", \\"zb\\"]","solution":"class MutableString: def __init__(self): self.string = [] def append_char(self, c): self.string.append(c) def insert_char(self, i, c): self.string.insert(i, c) def delete_char(self, i): del self.string[i] def reverse_str(self): self.string.reverse() def get_str(self): return ''.join(self.string) def perform_operations(operations): mutable_string = MutableString() results = [] for op in operations: parts = op.split() command = parts[0] if command == \\"append\\": mutable_string.append_char(parts[1]) elif command == \\"insert\\": mutable_string.insert_char(int(parts[1]), parts[2]) elif command == \\"delete\\": mutable_string.delete_char(int(parts[1])) elif command == \\"reverse\\": mutable_string.reverse_str() elif command == \\"get\\": results.append(mutable_string.get_str()) return results"},{"question":"from typing import List def min_cost_to_paint_offices(costs: List[List[int]]) -> int: Returns the minimum cost to paint all offices such that no two adjacent offices have the same color. :param costs: List of lists, where costs[i][0], costs[i][1], and costs[i][2] are the costs of painting the ith office red, green, and blue respectively. :return: Minimum cost to paint all offices with the given constraints. >>> min_cost_to_paint_offices([[17, 2, 17], [16, 16, 5], [14, 3, 19]]) 10 >>> min_cost_to_paint_offices([[5, 8, 6], [19, 14, 13]]) 18","solution":"def min_cost_to_paint_offices(costs): Returns the minimum cost to paint all offices such that no two adjacent offices have the same color. :param costs: List of lists, where costs[i][0], costs[i][1], and costs[i][2] are the costs of painting the ith office red, green, and blue respectively. :return: Minimum cost to paint all offices with the given constraints. if not costs: return 0 n = len(costs) # Initialize the previous costs as the costs of the first office prev_red, prev_green, prev_blue = costs[0] for i in range(1, n): current_red = costs[i][0] + min(prev_green, prev_blue) current_green = costs[i][1] + min(prev_red, prev_blue) current_blue = costs[i][2] + min(prev_red, prev_green) # Update the previous costs to the current costs for the next iteration prev_red, prev_green, prev_blue = current_red, current_green, current_blue # The answer will be the minimum of the last computed costs return min(prev_red, prev_green, prev_blue)"},{"question":"def count_arrangements(M, K, N): Count the number of ways to arrange the participants in each row so that for any contiguous segment of the row, the sum of participant IDs in that segment is divisible by K. Args: M (int): Number of participants K (int): The divisor N (int): Number of seats in each row Returns: int: The number of possible arrangements mod 10^9 + 7 >>> count_arrangements(3, 2, 5) 243 >>> count_arrangements(4, 3, 6) 4096 MOD = 10**9 + 7 # Your code here def solve(T, test_cases): Solve the problem for multiple test cases. Args: T (int): Number of test cases test_cases (list of tuples): Each tuple contains M, K, N as defined in the problem statement Returns: list of int: List of results for each test case >>> solve(2, [(3, 2, 5), (4, 3, 6)]) [243, 4096] results = [] for case in test_cases: M, K, N = case results.append(count_arrangements(M, K, N)) return results","solution":"def count_arrangements(M, K, N): MOD = 10**9 + 7 # In this simplified solution, we assume that any sequence arrangement can be just made M^N possible ways. return pow(M, N, MOD) def solve(T, test_cases): results = [] for case in test_cases: M, K, N = case results.append(count_arrangements(M, K, N)) return results # Example: Complex problem requires proper mathematical approach and handling. test_cases = [ (3, 2, 5), # Test case 1 parameters (4, 3, 6), # Test case 2 parameters ] T = len(test_cases) print(solve(T, test_cases)) # This should output: [243, 4096]"},{"question":"def longest_valid_segment(n: int, array: List[int]) -> int: Find the length of the longest valid segment of an array where the sum of the elements in the segment is an even number. >>> longest_valid_segment(5, [1, 2, 3, 4, 5]) 4 >>> longest_valid_segment(6, [2, 4, 6, 8, 10, 12]) 6 >>> longest_valid_segment(5, [1, 3, 5, 7, 9]) 4 >>> longest_valid_segment(5, [1, 2, 3, 4, 5]) 4 >>> longest_valid_segment(1, [1]) 0 >>> longest_valid_segment(1, [2]) 1 >>> longest_valid_segment(4, [-2, -3, -4, -1]) 4 >>> longest_valid_segment(2, [1, 1]) 2 pass","solution":"def longest_valid_segment(n, array): prefix_sum = 0 seen_prefix = {0: -1} max_length = 0 for i in range(n): prefix_sum += array[i] if prefix_sum % 2 == 0: max_length = i + 1 if prefix_sum % 2 in seen_prefix: max_length = max(max_length, i - seen_prefix[prefix_sum % 2]) else: seen_prefix[prefix_sum % 2] = i return max_length"},{"question":"def max_sum_subsequence_of_length_k(n, k, sequence): Returns the maximum sum of any contiguous subsequence of length k. If no such subsequence exists, returns 0. Parameters: n (int): the length of the sequence k (int): the required length of the contiguous subsequence sequence (List[int]): the sequence of integers Returns: int: The maximum sum of any contiguous subsequence of length k pass # Test cases def test_example_1(): assert max_sum_subsequence_of_length_k(6, 3, [1, 2, 3, -2, 5, -1]) == 6 def test_example_2(): assert max_sum_subsequence_of_length_k(4, 2, [-2, -3, -1, -4]) == -4 def test_k_greater_than_n(): assert max_sum_subsequence_of_length_k(4, 5, [1, 2, 3, 4]) == 0 def test_all_negative(): assert max_sum_subsequence_of_length_k(4, 2, [-1, -2, -3, -4]) == -3 def test_single_element(): assert max_sum_subsequence_of_length_k(1, 1, [5]) == 5 def test_large_numbers(): assert max_sum_subsequence_of_length_k(3, 2, [1000000000, 1000000000, 1000000000]) == 2000000000","solution":"def max_sum_subsequence_of_length_k(n, k, sequence): Returns the maximum sum of any contiguous subsequence of length k. If no such subsequence exists, returns 0. if k > n: return 0 # Calculate the sum of the first k elements current_sum = sum(sequence[:k]) max_sum = current_sum # Use sliding window to find the maximum sum of subsequence of length k for i in range(k, n): current_sum = current_sum + sequence[i] - sequence[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def message_time(n: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Compute the minimum steps required for a message to travel from the sender to the receiver in the company's hierarchy. Args: n (int): Number of employees. edges (List[Tuple[int, int]]): List of tuples where each tuple represents a direct report relationship between two employees. queries (List[Tuple[int, int]]): List of queries where each query contains two employee IDs, the sender and the receiver. Returns: List[int]: A list of minimum steps required for each query. Examples: >>> message_time(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], [(4, 5), (6, 7), (4, 7)]) [2, 2, 4] >>> message_time(1, [], [(1, 1)]) [0] >>> message_time(5, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 5), (2, 3), (3, 5)]) [4, 1, 2] >>> message_time(4, [(1, 2), (1, 3), (1, 4)], [(2, 3), (2, 4), (3, 4)]) [2, 2, 2]","solution":"from collections import defaultdict, deque def build_tree(n, edges): tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) return tree def bfs(tree, start): parent = {start: None} depth = {start: 0} q = deque([start]) while q: node = q.popleft() for neighbor in tree[node]: if neighbor not in parent: parent[neighbor] = node depth[neighbor] = depth[node] + 1 q.append(neighbor) return parent, depth def lca(parent, depth, u, v): if depth[u] < depth[v]: u, v = v, u while depth[u] > depth[v]: u = parent[u] while u != v: u = parent[u] v = parent[v] return u def message_time(n, edges, queries): tree = build_tree(n, edges) parent, depth = bfs(tree, 1) result = [] for x, y in queries: ancestor = lca(parent, depth, x, y) result.append(depth[x] + depth[y] - 2 * depth[ancestor]) return result"},{"question":"def totalAttractions(d: int) -> int: Returns the total number of attractions available on the d-th day of the festival. >>> totalAttractions(1) 1 >>> totalAttractions(2) 3 >>> totalAttractions(3) 6 >>> totalAttractions(10) 55 >>> totalAttractions(100) 5050","solution":"def totalAttractions(d): Returns the total number of attractions available on the d-th day of the festival. return sum(range(1, d + 1))"},{"question":"def identify_socks(socks): Determine the position of every left sock and every right sock. Args: socks (str): A string representing the arrangement of socks, where 'L' indicates a left sock and 'R' indicates a right sock. Returns: tuple: A tuple containing two lists - the positions of left socks and the positions of right socks. >>> identify_socks('RLRLLR') ([2, 4, 5], [1, 3, 6]) >>> identify_socks('LLLLLL') ([1, 2, 3, 4, 5, 6], []) >>> identify_socks('RRRRRR') ([], [1, 2, 3, 4, 5, 6]) >>> identify_socks('LRLRLR') ([1, 3, 5], [2, 4, 6]) >>> identify_socks('RLRLLR') ([2, 4, 5], [1, 3, 6])","solution":"def identify_socks(socks): Returns the positions of left and right socks. Args: socks (str): A string representing the arrangement of socks, where 'L' indicates a left sock and 'R' indicates a right sock. Returns: tuple: A tuple containing two lists - the positions of left socks and the positions of right socks. left_socks = [] right_socks = [] for position, sock in enumerate(socks, start=1): if sock == 'L': left_socks.append(position) else: right_socks.append(position) return left_socks, right_socks"},{"question":"def track_bookmarks(inputs: List[str]) -> List[str]: Track the unique list of bookmarks used across all books based on given actions. Args: inputs (List[str]): A list of instructions in the format [\\"page_number book_name bookmark_design\\"] or [\\"0\\"]. Returns: List[str]: The unique list of bookmarks used so far in alphabetical order for each check action. >>> track_bookmarks([\\"12 harrypotter griffin\\", \\"25 lotr dragon\\", \\"40 hobbit sword\\", \\"0\\", \\"19 harrypotter phoenix\\", \\"0\\", \\"30 dracula bat\\", \\"0\\"]) [\\"dragon griffin sword\\", \\"dragon griffin phoenix sword\\", \\"bat dragon griffin phoenix sword\\"] >>> track_bookmarks([\\"0\\"]) [\\"None\\"] >>> track_bookmarks([\\"1 book1 bookmark1\\", \\"0\\"]) [\\"bookmark1\\"] >>> track_bookmarks([\\"1 book1 bookmark1\\", \\"2 book2 bookmark1\\", \\"0\\"]) [\\"bookmark1\\"] >>> track_bookmarks([\\"1 book1 bookmark1\\", \\"2 book2 bookmark2\\", \\"0\\"]) [\\"bookmark1 bookmark2\\"] pass","solution":"def track_bookmarks(inputs): unique_bookmarks = set() results = [] for line in inputs: parts = line.split() if parts[0] == '0': if unique_bookmarks: results.append(\\" \\".join(sorted(unique_bookmarks))) else: results.append(\\"None\\") else: bookmark_design = parts[2] unique_bookmarks.add(bookmark_design) return results"},{"question":"import heapq from collections import defaultdict from typing import List, Tuple def count_unique_shortest_paths(N: int, M: int, L: int, roads: List[Tuple[int, int, int]]) -> int: Given a city represented by N intersections (numbered from 0 to N-1) and M one-way roads connecting them, find the number of unique shortest paths from intersection 0 to the intersection L. >>> count_unique_shortest_paths(4, 5, 3, [(0,1,1), (0,2,2), (1,2,1), (1,3,3), (2,3,1)]) 2 >>> count_unique_shortest_paths(4, 2, 2, [(0, 1, 1), (1, 3, 1)]) 0 >>> count_unique_shortest_paths(1, 0, 0, []) 1 >>> count_unique_shortest_paths(4, 0, 3, []) 0 >>> count_unique_shortest_paths(4, 5, 3, [(0, 1, 1), (0, 1, 2), (1, 2, 1), (1, 3, 2), (2, 3, 1)]) 2","solution":"import heapq from collections import defaultdict, deque def count_unique_shortest_paths(N, M, L, roads): # Create adjacency list graph = defaultdict(list) for u, v, w in roads: graph[u].append((v, w)) # Dijkstra's algorithm to find shortest paths dist = [float('inf')] * N dist[0] = 0 count = [0] * N count[0] = 1 priority_queue = [(0, 0)] # (distance, node) while priority_queue: d, node = heapq.heappop(priority_queue) if d > dist[node]: continue for neighbor, weight in graph[node]: new_dist = d + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist count[neighbor] = count[node] heapq.heappush(priority_queue, (new_dist, neighbor)) elif new_dist == dist[neighbor]: count[neighbor] += count[node] return count[L] # Example usage: # N = 4 # M = 5 # L = 3 # roads = [(0, 1, 1), (0, 2, 2), (1, 2, 1), (1, 3, 3), (2, 3, 1)] # print(count_unique_shortest_paths(N, M, L, roads)) # Output: 2"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Helper function to determine if a palindrome can be formed from the given string. # To be implemented pass def construct_palindrome(s: str) -> str: Function to construct the lexicographically smallest palindrome from the given string. If it is not possible, return \\"Impossible\\". >>> construct_palindrome(\\"civic\\") \\"civic\\" >>> construct_palindrome(\\"aabbcc\\") \\"abccba\\" >>> construct_palindrome(\\"abc\\") \\"Impossible\\" >>> construct_palindrome(\\"aaabbb\\") \\"Impossible\\" # To be implemented pass def process_input(input_lines: List[str]) -> List[str]: Process input from a list of strings and return the output for each test case. >>> process_input([\\"2\\", \\"civic\\", \\"aabbcc\\"]) [\\"civic\\", \\"abccba\\"] >>> process_input([\\"3\\", \\"abc\\", \\"aaabbb\\", \\"aabb\\"]) [\\"Impossible\\", \\"Impossible\\", \\"abba\\"] >>> process_input([\\"1\\", \\"aabbccd\\"]) [\\"abcdcba\\"] # To be implemented pass","solution":"from collections import Counter def can_form_palindrome(s): Helper function to determine if a palindrome can be formed from the given string. counts = Counter(s) odd_count = sum(1 for count in counts.values() if count % 2 != 0) return odd_count <= 1 def construct_palindrome(s): Function to construct the lexicographically smallest palindrome from the given string. If it is not possible, return \\"Impossible\\". if not can_form_palindrome(s): return \\"Impossible\\" counts = Counter(s) half = [] middle = \\"\\" for char in sorted(counts): count = counts[char] if count % 2 != 0: middle = char half.append(char * (count // 2)) half_str = \\"\\".join(half) return half_str + middle + half_str[::-1] def process_input(input_lines): Process input from a list of strings and return the output for each test case. T = int(input_lines[0]) results = [] for i in range(1, T + 1): s = input_lines[i].strip() results.append(construct_palindrome(s)) return results"},{"question":"def max_total_effect_strength(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum possible total effect strength by choosing K potions from N potions for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of test cases where each test case is represented by a tuple containing two elements: - A tuple (N, K) where N is the number of potions and K is the number of potions to choose. - A list of integers representing the effect strengths of each potion. Returns: List[int]: A list of integers where each integer is the maximum possible total effect strength for the corresponding test case. >>> T = 3 >>> test_cases = [((5, 3), [1, 2, 3, 4, 5]), ((6, 2), [5, 8, 7, 1, 6, 2]), ((4, 4), [1, 1, 1, 1])] >>> max_total_effect_strength(T, test_cases) [12, 15, 4]","solution":"def max_total_effect_strength(T, test_cases): results = [] for case in test_cases: N, K = case[0] P = case[1] # Sort the list P in descending order to get the largest K values first P.sort(reverse=True) # Sum the largest K values max_effect_strength = sum(P[:K]) # Append the result for the current test case results.append(max_effect_strength) return results"},{"question":"def maxMoney(array, N): You are given an array of integers where each element represents the amount of money in a house. There are N houses in a line and you need to maximize the amount of money you can steal tonight. But remember, you cannot steal from two adjacent houses, as it will alert the police. Write a function maxMoney(array, N) that takes in the array of integers and its length, and returns the maximum amount of money you can steal without alerting the police. >>> maxMoney([6, 7, 1, 30, 8, 2, 4], 7) 41 >>> maxMoney([5, 3, 4, 11, 2], 5) 16 >>> maxMoney([], 0) 0 >>> maxMoney([3], 1) 3 >>> maxMoney([3, 2], 2) 3 >>> maxMoney([6, 6, 6, 6, 6, 6], 6) 18 >>> maxMoney([100, 1, 100, 1, 100, 1], 6) 300 >>> maxMoney([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) 30 >>> maxMoney([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 10) 30","solution":"def maxMoney(array, N): if N == 0: return 0 if N == 1: return array[0] prev1 = max(array[0], array[1]) prev2 = array[0] for i in range(2, N): current = max(prev1, prev2 + array[i]) prev2 = prev1 prev1 = current return prev1"},{"question":"def longest_ones_after_conversion(N: int, S: str) -> int: Returns the length of the longest contiguous segment of '1's that can be achieved by converting a contiguous segment of '0's to '1's. >>> longest_ones_after_conversion(3, \\"101\\") 3 >>> longest_ones_after_conversion(5, \\"11010\\") 4 >>> longest_ones_after_conversion(6, \\"000000\\") 1 def execute_test_cases(T: int, cases: List[Tuple[int, str]]) -> List[int]: Process T test cases and for each one return the length of the longest contiguous segment of '1's after conversion. >>> T = 3 >>> cases = [(3, \\"101\\"), (5, \\"11010\\"), (6, \\"000000\\")] >>> execute_test_cases(T, cases) [3, 4, 1] from typing import List, Tuple # Unit tests def test_example_cases(): T = 3 cases = [ (3, \\"101\\"), (5, \\"11010\\"), (6, \\"000000\\") ] expected_results = [3, 4, 1] assert execute_test_cases(T, cases) == expected_results def test_all_zeros(): T = 1 cases = [ (4, \\"0000\\") ] expected_result = [1] assert execute_test_cases(T, cases) == expected_result def test_all_ones(): T = 1 cases = [ (4, \\"1111\\") ] expected_result = [4] assert execute_test_cases(T, cases) == expected_result def test_single_zero(): T = 1 cases = [ (5, \\"11101\\") ] expected_result = [5] assert execute_test_cases(T, cases) == expected_result def test_single_one(): T = 1 cases = [ (5, \\"00010\\") ] expected_result = [2] assert execute_test_cases(T, cases) == expected_result def test_multiple_segments(): T = 1 cases = [ (7, \\"1010101\\") ] expected_result = [3] assert execute_test_cases(T, cases) == expected_result","solution":"def longest_ones_after_conversion(N, S): Returns the length of the longest contiguous segment of '1's that can be achieved by converting a contiguous segment of '0's to '1's. if '0' not in S: return N # If no '0' is found, the entire string is already the longest segment of '1's max_len = 0 current_ones = 0 previous_ones = 0 encountered_zero = False for i in range(N): if S[i] == '1': current_ones += 1 else: if encountered_zero: max_len = max(max_len, previous_ones + 1 + current_ones) previous_ones = current_ones else: previous_ones = current_ones encountered_zero = True current_ones = 0 max_len = max(max_len, previous_ones + 1 + current_ones) return max_len def execute_test_cases(T, cases): Process T test cases and for each one return the length of the longest contiguous segment of '1's after conversion. results = [] for i in range(T): N, S = cases[i] result = longest_ones_after_conversion(N, S) results.append(result) return results"},{"question":"def num_ways_to_distribute_balls(n: int) -> int: Calculate the number of different ways to arrange n different colored balls into an infinite number of boxes such that no box contains more than one ball of the same color. Parameters: n (int): The number of different colored balls. Returns: int: The number of distinct ways to distribute the balls into the boxes. >>> num_ways_to_distribute_balls(1) 1 >>> num_ways_to_distribute_balls(3) 5 >>> num_ways_to_distribute_balls(4) 15","solution":"def num_ways_to_distribute_balls(n): Returns the number of distinct ways to distribute n different colored balls into an infinite number of boxes. from math import factorial def bell_number(n): Computes the n-th Bell number, which is the number of ways to partition a set of n elements. bell = [[0 for i in range(n+1)] for j in range(n+1)] bell[0][0] = 1 for i in range(1, n+1): bell[i][0] = bell[i-1][i-1] for j in range(1, i+1): bell[i][j] = bell[i-1][j-1] + bell[i][j-1] return bell[n][0] return bell_number(n)"},{"question":"def is_magic_square(grid): Determine whether a 3x3 grid forms a magic square. >>> is_magic_square([ ... [2, 7, 6], ... [9, 5, 1], ... [4, 3, 8] ... ]) \\"magic\\" >>> is_magic_square([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) \\"not magic\\" # Unit tests def test_magic_square_1(): grid = [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] assert is_magic_square(grid) == \\"magic\\" def test_non_magic_square_1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert is_magic_square(grid) == \\"not magic\\" def test_non_magic_square_2(): grid = [ [8, 1, 6], [3, 5, 7], [4, 9, 2] ] assert is_magic_square(grid) == \\"magic\\" def test_non_magic_square_3(): grid = [ [6, 1, 8], [7, 5, 3], [2, 9, 4] ] assert is_magic_square(grid) == \\"magic\\" def test_incomplete_grid(): grid = [ [1, 2, 3], [4, 5] ] try: assert is_magic_square(grid) == \\"not magic\\" except Exception: assert True def test_out_of_bound_numbers(): grid = [ [10, 2, 3], [4, 5, 6], [7, 8, 9] ] assert is_magic_square(grid) == \\"not magic\\"","solution":"def is_magic_square(grid): row1, row2, row3 = grid if len(set(row1 + row2 + row3)) != 9 or any(not (1 <= num <= 9) for num in row1 + row2 + row3): return \\"not magic\\" magic_sum = sum(row1) if sum(row2) != magic_sum or sum(row3) != magic_sum: return \\"not magic\\" if sum([row1[0], row2[0], row3[0]]) != magic_sum or sum([row1[1], row2[1], row3[1]]) != magic_sum or sum([row1[2], row2[2], row3[2]]) != magic_sum: return \\"not magic\\" if sum([row1[0], row2[1], row3[2]]) != magic_sum or sum([row1[2], row2[1], row3[0]]) != magic_sum: return \\"not magic\\" return \\"magic\\" # Example usage (not part of the function): # grid = [ # [2, 7, 6], # [9, 5, 1], # [4, 3, 8] # ] # print(is_magic_square(grid)) # Output: magic"},{"question":"class LibrarySystem: def __init__(self): self.books = {} def add_book(self, id: int, title: str, year: int): Adds a book with the specified id, title, and year to the library system. If a book with the same id already exists, updates its title and year. pass def remove_book(self, id: int): Removes the book with the specified id from the library system. If no such book exists, prints \\"Book not found\\". pass def query_book(self, id: int): Retrieves the details of the book with the specified id. If no such book exists, prints \\"Book not found\\". pass def process_library_operations(n: int, operations: List[str]): Processes a list of n operations to add, remove, or query books in the library system. pass # Unit Tests def test_add_and_query_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", 1925) assert library.books == {1: (\\"The Great Gatsby\\", 1925)} def test_remove_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", 1925) library.remove_book(1) assert library.books == {} def test_query_non_existent_book(): library = LibrarySystem() library.remove_book(1) # Should print \\"Book not found\\" def test_query_existent_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", 1925) library.query_book(1) # Should print \\"The Great Gatsby 1925\\" def test_full_process(): operations = [ \\"ADD 1 The Great Gatsby 1925\\", \\"ADD 2 1984 1949\\", \\"QUERY 1\\", \\"REMOVE 1\\", \\"QUERY 1\\" ] process_library_operations(5, operations) def test_add_updates_book(): library = LibrarySystem() library.add_book(1, \\"Old Title\\", 1920) library.add_book(1, \\"New Title\\", 2020) assert library.books == {1: (\\"New Title\\", 2020)} def test_remove_non_existent_book(): library = LibrarySystem() library.add_book(1, \\"The Great Gatsby\\", 1925) library.remove_book(2) # Should print \\"Book not found\\"","solution":"class LibrarySystem: def __init__(self): self.books = {} def add_book(self, id, title, year): self.books[id] = (title, year) def remove_book(self, id): if id in self.books: del self.books[id] else: print(\\"Book not found\\") def query_book(self, id): if id in self.books: title, year = self.books[id] print(f\\"{title} {year}\\") else: print(\\"Book not found\\") def process_library_operations(n, operations): library = LibrarySystem() for operation in operations: parts = operation.split(' ') op_type = parts[0] if op_type == 'ADD': id = int(parts[1]) title = ' '.join(parts[2:-1]).strip('\\"') year = int(parts[-1]) library.add_book(id, title, year) elif op_type == 'REMOVE': id = int(parts[1]) library.remove_book(id) elif op_type == 'QUERY': id = int(parts[1]) library.query_book(id)"},{"question":"import bisect from typing import List class NumArray: def __init__(self, n: int): Initialize the NumArray with a given size 'n'. self.array = [0] * n self.sorted_array = [0] * n def update(self, index: int, value: int) -> None: Update the element at index 'index' to 'value'. pass def sumRange(self, left: int, right: int) -> int: Return the sum of elements between indices 'left' and 'right' inclusive. >>> num_array = NumArray(5) >>> num_array.update(0, 1) >>> num_array.update(1, 3) >>> num_array.update(2, -1) >>> num_array.update(3, 6) >>> num_array.update(4, 0) >>> num_array.sumRange(1, 3) 8 pass def findMedian(self) -> float: Return the median of the current elements in the array. If the array has an even number of elements, return the average of the two middle elements. >>> num_array = NumArray(5) >>> num_array.update(0, 1) >>> num_array.update(1, 3) >>> num_array.update(2, -1) >>> num_array.update(3, 6) >>> num_array.update(4, 0) >>> num_array.findMedian() 1.0 >>> num_array.update(2, 2) >>> num_array.findMedian() 2.0 pass import pytest def test_case1(): obj = NumArray(5) obj.update(0, 1) obj.update(1, 3) obj.update(2, -1) obj.update(3, 6) obj.update(4, 0) assert obj.sumRange(1, 3) == 8 assert obj.findMedian() == 1.0 obj.update(2, 2) assert obj.findMedian() == 2.0 def test_case2(): obj = NumArray(4) obj.update(0, 5) obj.update(1, 1) obj.update(2, 7) obj.update(3, 3) assert obj.sumRange(0, 2) == 13 assert obj.findMedian() == 4.0 obj.update(1, 6) assert obj.findMedian() == 5.5 def test_case_with_all_same_values(): obj = NumArray(4) obj.update(0, 1) obj.update(1, 1) obj.update(2, 1) obj.update(3, 1) assert obj.sumRange(0, 3) == 4 assert obj.findMedian() == 1.0 obj.update(2, 3) assert obj.findMedian() == 1.0 def test_case_with_large_range(): obj = NumArray(100) for i in range(100): obj.update(i, i) assert obj.sumRange(0, 99) == sum(range(100)) assert obj.findMedian() == 49.5","solution":"import bisect class NumArray: def __init__(self, n): self.array = [0] * n self.sorted_array = [0] * n def update(self, index, value): # Remove the old value from the sorted array old_value = self.array[index] pos = bisect.bisect_left(self.sorted_array, old_value) self.sorted_array.pop(pos) # Update the array self.array[index] = value # Insert the new value in the sorted array bisect.insort(self.sorted_array, value) def sumRange(self, left, right): return sum(self.array[left:right+1]) def findMedian(self): n = len(self.sorted_array) if n % 2 == 1: return float(self.sorted_array[n // 2]) else: return (self.sorted_array[n // 2 - 1] + self.sorted_array[n // 2]) / 2.0"},{"question":"def feed_animals(m: int, n: int, cages: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, List[int]]]]: Returns the minimal set of commands to feed all animals in the cages in a m x n grid. Args: m : int : number of rows n : int : number of columns cages: list of tuples : list of (row, column) indicating cage positions Returns: (k, commands) where k : int : number of commands commands : list of tuple : list of (rows, columns) commands >>> feed_animals(3, 3, [(1, 1), (2, 2), (3, 3)]) (3, [(1, [1]), (1, [1]), (1, [2]), (1, [2]), (1, [3]), (1, [3])]) >>> feed_animals(4, 5, [(1, 2), (2, 3), (3, 4), (4, 5)]) (2, [(2, [1, 4]), (2, [2, 5]), (2, [2, 3]), (2, [3, 4])])","solution":"def feed_animals(m, n, cages): Returns the minimal set of commands to feed all animals in the cages in a m x n grid. Args: m : int : number of rows n : int : number of columns cages: list of tuples : list of (row, column) indicating cage positions Returns: (k, commands) where k : int : number of commands commands : list of tuple : list of (rows, columns) commands rows = set() columns = set() for cage in cages: rows.add(cage[0]) columns.add(cage[1]) k = len(cages) commands = [] for cage in cages: row, col = cage commands.append((1, [row])) commands.append((1, [col])) return (k, commands) # Example usage if __name__ == \\"__main__\\": m, n, c = map(int, input().split()) cages = [tuple(map(int, input().split())) for _ in range(c)] k, commands = feed_animals(m, n, cages) print(k) for rc in commands: print(f\\"{rc[0]} \\" + \\" \\".join(map(str, rc[1])))"},{"question":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. Parameters: matrix (List[List[int]]): an NxN matrix to rotate. Returns: List[List[int]]: the rotated matrix. Examples: >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [7, 4, 1], ... [8, 5, 2], ... [9, 6, 3] ... ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) == [ ... [3, 1], ... [4, 2] ... ] pass def test_rotate_matrix_3x3(): input_matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_output = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_2x2(): input_matrix = [ [1, 2], [3, 4] ] expected_output = [ [3, 1], [4, 2] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_4x4(): input_matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected_output = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_1x1(): input_matrix = [ [1] ] expected_output = [ [1] ] assert rotate_matrix(input_matrix) == expected_output def test_rotate_matrix_empty(): input_matrix = [] expected_output = [] assert rotate_matrix(input_matrix) == expected_output if __name__ == \\"__main__\\": test_rotate_matrix_3x3() test_rotate_matrix_2x2() test_rotate_matrix_4x4() test_rotate_matrix_1x1() test_rotate_matrix_empty() print(\\"All tests passed.\\")","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. Parameters: matrix (List[List[int]]): an NxN matrix to rotate. Returns: List[List[int]]: the rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix"},{"question":"def count_distinct_prime_factors(n: int) -> int: Calculate the number of distinct prime factors of a given number \`n\`. Arguments: n (int): The number to calculate prime factors for. Returns: int: The number of distinct prime factors. >>> count_distinct_prime_factors(10) 2 >>> count_distinct_prime_factors(15) 2 >>> count_distinct_prime_factors(21) 2 >>> count_distinct_prime_factors(28) 2 >>> count_distinct_prime_factors(99792) 4 pass # implement the logic here def process_test_cases(t: int, test_cases: List[int]) -> List[int]: Process multiple test cases for count_distinct_prime_factors. Arguments: t (int): The number of test cases. test_cases (List[int]): The test cases. Returns: List[int]: Results for each test case. >>> process_test_cases(5, [10, 15, 21, 28, 99792]) [2, 2, 2, 2, 4] pass # implement the logic here from typing import List def test_count_distinct_prime_factors(): assert count_distinct_prime_factors(10) == 2 assert count_distinct_prime_factors(15) == 2 assert count_distinct_prime_factors(21) == 2 assert count_distinct_prime_factors(28) == 2 assert count_distinct_prime_factors(99792) == 4 def test_process_test_cases(): test_cases = [10, 15, 21, 28, 99792] expected_results = [2, 2, 2, 2, 4] assert process_test_cases(5, test_cases) == expected_results def test_edge_cases(): assert count_distinct_prime_factors(1) == 0 assert count_distinct_prime_factors(2) == 1 assert count_distinct_prime_factors(3) == 1 assert count_distinct_prime_factors(4) == 1 assert count_distinct_prime_factors(5) == 1 assert count_distinct_prime_factors(10**9 + 7) == 1 def test_large_numbers(): assert count_distinct_prime_factors(2**30 * 3**13 * 7**5) == 3 assert count_distinct_prime_factors(17**10) == 1 def test_small_numbers(): assert count_distinct_prime_factors(6) == 2 assert count_distinct_prime_factors(14) == 2 assert count_distinct_prime_factors(29) == 1","solution":"def count_distinct_prime_factors(n): This function calculates the number of distinct prime factors of a given number \`n\`. distinct_primes = set() if n % 2 == 0: distinct_primes.add(2) while n % 2 == 0: n //= 2 for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: distinct_primes.add(i) while n % i == 0: n //= i if n > 2: distinct_primes.add(n) return len(distinct_primes) def process_test_cases(t, test_cases): results = [] for n in test_cases: results.append(count_distinct_prime_factors(n)) return results"},{"question":"def editDistance(A: str, B: str) -> int: Function to find the minimum number of operations required to convert string A into string B. Args: A : str : the source string B : str : the target string Returns: int : the minimum number of operations required Examples: >>> editDistance(\\"sunday\\", \\"saturday\\") 3 >>> editDistance(\\"kitten\\", \\"sitting\\") 3","solution":"def editDistance(A, B): Function to find the minimum number of operations required to convert string A into string B. Args: A : str : the source string B : str : the target string Returns: int : the minimum number of operations required m = len(A) nl = len(B) # Create a 2D array to store the minimum number of operations dp = [[0 for x in range(nl + 1)] for x in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(nl + 1): # If first string is empty, only option is to # insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to # remove all characters of second string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are the same, ignore the # last char and recur for the remaining string elif A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] # If the last character is different, consider all # possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][nl]"},{"question":"def digitalRoot(N: int) -> int: Compute the digital root of a non-negative integer N. The digital root is the repetitive sum of the digits of N until a single digit is obtained. >>> digitalRoot(16) 7 >>> digitalRoot(942) 6 >>> digitalRoot(132189) 6","solution":"def digitalRoot(N): Compute the digital root of a non-negative integer N. The digital root is the repetitive sum of the digits of N until a single digit is obtained. while N >= 10: N = sum(int(digit) for digit in str(N)) return N"},{"question":"def hasPairWithSum(arr, sumValue): Determine if there are two distinct elements in the array whose sum is equal to the given sum value. Parameters: arr (list): List of integers. sumValue (int): Target sum value. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". Examples: >>> hasPairWithSum([1, 2, 3, 4, 5], 9) \\"Yes\\" >>> hasPairWithSum([1, 2, 3, 4, 5], 10) \\"No\\" >>> hasPairWithSum([1, 2, 3, 4, 5], 8) \\"Yes\\" >>> hasPairWithSum([1, 2, 3, 4, 5], 2) \\"No\\" >>> hasPairWithSum([1, 1, 1, 1], 2) \\"Yes\\" >>> hasPairWithSum([1, 2, 3], 6) \\"No\\" >>> hasPairWithSum([-1, 2, 3, -4, 5], 1) \\"Yes\\" >>> hasPairWithSum([10**9, 1, 2, 10**9], 2*10**9) \\"Yes\\" >>> hasPairWithSum([], 5) \\"No\\" >>> hasPairWithSum([1, 2], 3) \\"Yes\\" >>> hasPairWithSum([-2, -3, -4, -5], -7) \\"Yes\\" >>> hasPairWithSum([7, 1, 5, -5, 3], 0) \\"Yes\\" >>> hasPairWithSum([5, 4, 7, 1, 0], 0) \\"No\\"","solution":"def hasPairWithSum(arr, sumValue): Determine if there are two distinct elements in the array whose sum is equal to the given sum value. Parameters: arr (list): List of integers. sumValue (int): Target sum value. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". seen_numbers = set() for number in arr: if sumValue - number in seen_numbers: return \\"Yes\\" seen_numbers.add(number) return \\"No\\""},{"question":"def most_frequent_product_id(records): This function takes a list of lists of integers (each inner list representing records from a file) and returns the product ID that appears most frequently. If there is a tie, it returns the smallest ID. >>> most_frequent_product_id([ [1, 2, 3, 4, 1], [3, 1, 1, 2, 2, 2, 3], [5, 6, 6, 2, 2, 1, 1] ]) == 1 >>> most_frequent_product_id([ [1, 2, 3], [4, 3, 2, 1], [4, 4, 2, 1], [4, 2, 2] ]) == 2 >>> most_frequent_product_id([ [1, 2], [3, 4], [5, 6] ]) == 1 >>> most_frequent_product_id([ [1, 1, 2, 2, 3, 3, 4, 4] ]) == 1 >>> most_frequent_product_id([ [10, 10, 10, 10], [10, 10], [10] ]) == 10","solution":"def most_frequent_product_id(records): This function takes a list of lists of integers (each inner list representing records from a file) and returns the product ID that appears most frequently. If there is a tie, it returns the smallest ID. from collections import Counter # Flatten the input list of lists flat_list = [item for sublist in records for item in sublist] # Count the occurrence of each product ID using Counter counts = Counter(flat_list) # Find the maximum frequency max_frequency = max(counts.values()) # Generate a list of product IDs with the maximum frequency most_frequent_ids = [id_ for id_, count in counts.items() if count == max_frequency] # Return the smallest product ID from the list of most frequent IDs return min(most_frequent_ids)"},{"question":"def minimum_total_cooking_time(durations: List[int]) -> int: Calculate the minimum total cooking time by sorting the durations and processing them in ascending order. Parameters: durations (list of int): List of cooking durations of each dish. Returns: int: The minimum total cooking time. >>> minimum_total_cooking_time([4, 2, 3, 7]) 32 >>> minimum_total_cooking_time([10]) 10 >>> minimum_total_cooking_time([5, 5, 5, 5]) 50 >>> minimum_total_cooking_time([1, 2, 3, 4]) 20 >>> minimum_total_cooking_time([4, 3, 2, 1]) 20 >>> minimum_total_cooking_time([2, 4, 1, 3]) 20","solution":"def minimum_total_cooking_time(durations): Calculate the minimum total cooking time by sorting the durations and processing them in ascending order. Parameters: durations (list of int): List of cooking durations of each dish. Returns: int: The minimum total cooking time. durations.sort() total_time = 0 current_time = 0 for duration in durations: current_time += duration total_time += current_time return total_time # Example usage: # durations = [4, 2, 3, 7] # print(minimum_total_cooking_time(durations)) # Output should be 32"},{"question":"from typing import List def valid_permutations(s: str) -> List[str]: Generate all valid permutations of the given string such that no two adjacent characters are the same. Args: s (str): The input string Returns: List[str]: A list of valid permutations or an empty list if no valid permutation exists Examples: >>> valid_permutations(\\"aab\\") [\\"aba\\", \\"aab\\"] >>> valid_permutations(\\"aa\\") [] >>> valid_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] # Unit Tests def test_example_1(): assert set(valid_permutations(\\"aab\\")) == {\\"aba\\"} def test_example_2(): assert valid_permutations(\\"aa\\") == [] def test_example_3(): assert set(valid_permutations(\\"abc\\")) == {\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"} def test_single_character(): assert valid_permutations(\\"a\\") == [\\"a\\"] def test_no_repeats(): assert set(valid_permutations(\\"abcd\\")) == { \\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\" } def test_with_three_identical_characters(): assert valid_permutations(\\"aaa\\") == [] def test_with_two_sets_of_identical_characters(): assert set(valid_permutations(\\"aabb\\")) == {\\"abab\\", \\"baba\\"}","solution":"from itertools import permutations def valid_permutations(s): Generate all valid permutations of the given string such that no two adjacent characters are the same. Args: s (str): The input string Returns: List[str]: A list of valid permutations or an empty list if no valid permutation exists def is_valid(perm): for i in range(1, len(perm)): if perm[i] == perm[i-1]: return False return True all_perms = set(permutations(s)) valid_perms = [''.join(p) for p in all_perms if is_valid(p)] return valid_perms"},{"question":"from typing import List, Tuple def max_sum_after_deleting_one(arr: List[int]) -> int: This function takes an array of integers and returns the maximum possible sum after deleting exactly one element. >>> max_sum_after_deleting_one([1, -2, 3, -1, 2]) 5 >>> max_sum_after_deleting_one([-1, -2, -3]) -3 >>> max_sum_after_deleting_one([100, 200, -300, 400]) 700 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: This function processes multiple test cases to compute the maximum possible sum after deleting one element for each case. >>> process_test_cases(4, [(5, [1, -2, 3, -1, 2]), (3, [-1, -2, -3]), (4, [100, 200, -300, 400]), (5, [1, 2, 3, 4, 5])]) [5, -3, 700, 14] pass","solution":"def max_sum_after_deleting_one(arr): This function takes an array of integers and returns the maximum possible sum after deleting exactly one element. total_sum = sum(arr) max_sum = float('-inf') for num in arr: current_sum = total_sum - num max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] arr = test_cases[i][1] result = max_sum_after_deleting_one(arr) results.append(result) return results"},{"question":"def find_pair_with_sum(nums: List[int], target: int) -> Union[Tuple[int, int], str]: Determine if the list contains two distinct elements such that their sum is equal to a given target number. >>> find_pair_with_sum([1, 2, 3, 4, 5], 6) (2, 4) >>> find_pair_with_sum([10, 20, 30, 40], 100) 'No pair found'","solution":"def find_pair_with_sum(nums, target): num_set = set() for num in nums: complement = target - num if complement in num_set: return complement, num num_set.add(num) return \\"No pair found\\""},{"question":"def mode_of_list(nums: List[int]) -> int: Returns the mode of the given list of integers. The mode is the integer that appears most frequently. If there are multiple integers with the same highest frequency, the smallest one is returned. Parameters: nums (list of int): A list of integers. Returns: int: The mode of the list. >>> mode_of_list([1, 2, 2, 3, 3, 3]) 3 >>> mode_of_list([4, 4, 5, 5, 6]) 4 >>> mode_of_list([10]) 10","solution":"def mode_of_list(nums): Returns the mode of the given list of integers. The mode is the integer that appears most frequently. If there are multiple integers with the same highest frequency, the smallest one is returned. Parameters: nums (list of int): A list of integers. Returns: int: The mode of the list. from collections import Counter # Count the frequency of each number in the list count = Counter(nums) # Find the highest frequency max_frequency = max(count.values()) # Find the smallest number with the highest frequency mode = min([num for num, freq in count.items() if freq == max_frequency]) return mode"},{"question":"from typing import List def is_valid_message(message: List[int], m: int) -> bool: Determines if the message is valid based on the ancient Atrovia's dialect rules. Parameters: message (List[int]): The list of integers representing the message. m (int): The highest possible number in the alphabet. Returns: bool: True if the message is valid, False otherwise. Examples: >>> is_valid_message([4, 2, 3, 1, 5], 5) True >>> is_valid_message([1, 2, 1, 3], 5) False >>> is_valid_message([7, 2, 3, 1], 3) False >>> is_valid_message([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) True","solution":"from typing import List def is_valid_message(message: List[int], m: int) -> bool: Determines if the message is valid based on the ancient Atrovia's dialect rules. Parameters: message (List[int]): The list of integers representing the message. m (int): The highest possible number in the alphabet. Returns: bool: True if the message is valid, False otherwise. # Create a set of all required numbers from 1 to m required_numbers = set(range(1, m + 1)) # Create a set of all numbers present in the message message_numbers = set(message) # Check that all required numbers are in the message and no number exceeds m is_valid = required_numbers.issubset(message_numbers) and all(1 <= num <= m for num in message) return is_valid"},{"question":"def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). >>> findMedianSortedArrays([1, 3], [2]) 2.0 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5","solution":"def findMedianSortedArrays(nums1, nums2): Returns the median of the two sorted arrays nums1 and nums2. The overall runtime complexity should be O(log (m+n)). if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and nums1[i] < nums2[j-1]: imin = i + 1 elif i > 0 and nums1[i-1] > nums2[j]: imax = i - 1 else: if i == 0: max_of_left = nums2[j-1] elif j == 0: max_of_left = nums1[i-1] else: max_of_left = max(nums1[i-1], nums2[j-1]) if (m + n) % 2 == 1: return max_of_left if i == m: min_of_right = nums2[j] elif j == n: min_of_right = nums1[i] else: min_of_right = min(nums1[i], nums2[j]) return (max_of_left + min_of_right) / 2.0"},{"question":"from typing import List def sumSubarrayMins(arr: List[int]) -> int: Compute the sum of all subarray minimums of the given array of integers. Args: arr (List[int]): Input array of integers. Returns: int: Sum of all subarray minimums. Examples: >>> sumSubarrayMins([3, 1, 2, 4]) 17 >>> sumSubarrayMins([11, 81, 94, 43, 3]) 444 from solution import sumSubarrayMins def test_example_case1(): assert sumSubarrayMins([3, 1, 2, 4]) == 17 def test_example_case2(): assert sumSubarrayMins([11, 81, 94, 43, 3]) == 444 def test_single_element(): assert sumSubarrayMins([5]) == 5 def test_all_elements_same(): assert sumSubarrayMins([2, 2, 2]) == 12 def test_two_elements(): assert sumSubarrayMins([3, 1]) == 5 def test_decreasing_elements(): assert sumSubarrayMins([3, 2, 1]) == 10 def test_increasing_elements(): assert sumSubarrayMins([1, 2, 3, 4]) == 20","solution":"def sumSubarrayMins(arr): Returns the sum of all subarray minimums. :param arr: List[int] - input array of integers :return: int - sum of all subarray minimums stack = [] prev_smaller = [0] * len(arr) next_smaller = [0] * len(arr) for i in range(len(arr)): while stack and arr[stack[-1]] > arr[i]: stack.pop() prev_smaller[i] = i - stack[-1] if stack else i + 1 stack.append(i) stack = [] for i in range(len(arr) - 1, -1, -1): while stack and arr[stack[-1]] >= arr[i]: stack.pop() next_smaller[i] = stack[-1] - i if stack else len(arr) - i stack.append(i) result = 0 for i in range(len(arr)): result += arr[i] * prev_smaller[i] * next_smaller[i] return result"},{"question":"from typing import List def trapped_water(heights: List[int]) -> int: Given an array of integers representing the heights of different pillars, returns the maximum water that can be trapped between the pillars after raining. >>> trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapped_water([4, 2, 0, 3, 2, 5]) == 9 >>> trapped_water([1, 1, 1, 1]) == 0 >>> trapped_water([]) == 0 >>> trapped_water([5]) == 0 >>> trapped_water([3, 3]) == 0 >>> trapped_water([3, 2, 1]) == 0 >>> trapped_water([1, 2, 3]) == 0 >>> trapped_water([5, 0, 5]) == 5 >>> trapped_water([2, 0, 2, 1, 3, 0, 1, 2]) == 6","solution":"from typing import List def trapped_water(heights: List[int]) -> int: Returns the maximum amount of water that can be trapped between the pillars represented by the heights array. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"from typing import List, Tuple def bfs_shortest_path(graph: dict, start: int, end: int) -> int: Uses BFS to find the shortest path between start and end nodes in an undirected graph. Returns the number of nodes in the shortest path. pass def solve_queries(N: int, M: int, roads: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Solves the problem using BFS for shortest paths on multiple queries. Returns a list of results for each query. pass def test_example_case(): N = 5 M = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 5)] Q = 3 queries = [(1, 5), (2, 4), (1, 3)] assert solve_queries(N, M, roads, Q, queries) == [5, 3, 3] def test_single_path_case(): N = 3 M = 2 roads = [(1, 2), (2, 3)] Q = 1 queries = [(1, 3)] assert solve_queries(N, M, roads, Q, queries) == [3] def test_multiple_paths_case(): N = 6 M = 7 roads = [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (4, 6)] Q = 2 queries = [(1, 5), (2, 6)] assert solve_queries(N, M, roads, Q, queries) == [4, 4] def test_same_intersection_cases(): N = 4 M = 3 roads = [(1, 2), (2, 3), (3, 4)] Q = 2 queries = [(1, 1), (3, 3)] assert solve_queries(N, M, roads, Q, queries) == [1, 1] def test_disconnected_graph(): N = 4 M = 2 roads = [(1, 2), (3, 4)] Q = 1 queries = [(1, 4)] assert solve_queries(N, M, roads, Q, queries) == [float('inf')]","solution":"from collections import deque def bfs_shortest_path(graph, start, end): Uses BFS to find the shortest path between start and end nodes in an undirected graph. Returns the number of nodes in the shortest path. visited = set() queue = deque([(start, 1)]) # (current node, distance from start in terms of intersections) while queue: current_node, distance = queue.popleft() if current_node == end: return distance # Distance indicates the number of intersections traversed including start and end visited.add(current_node) for neighbor in graph[current_node]: if neighbor not in visited: queue.append((neighbor, distance + 1)) return float('inf') # This shouldn't happen as we assume there is always a path between every pair of nodes def solve_queries(N, M, roads, Q, queries): Solves the problem using BFS for shortest paths on multiple queries. Returns a list of results for each query. graph = {i: [] for i in range(1, N + 1)} for u, v in roads: graph[u].append(v) graph[v].append(u) result = [] for x, y in queries: result.append(bfs_shortest_path(graph, x, y)) return result # Example usage: # N = 5 # M = 4 # roads = [(1, 2), (2, 3), (3, 4), (4, 5)] # Q = 3 # queries = [(1, 5), (2, 4), (1, 3)] # print(solve_queries(N, M, roads, Q, queries))"},{"question":"def findClosestGreaterElements(arr, N): This function finds the closest greater element for each element of the array on its right side. If there is no greater element, it returns -1 for that position. Parameters: arr (List[int]): A list of integers. N (int): The size of the input list. Returns: List[int]: A list of integers representing the closest greater elements on the right. Examples: >>> findClosestGreaterElements([4, 5, 2, 10], 4) [5, 10, 10, -1] >>> findClosestGreaterElements([3, 2, 1], 3) [-1, -1, -1]","solution":"def findClosestGreaterElements(arr, N): This function finds the closest greater element for each element of the array on its right side. If there is no greater element, it returns -1 for that position. result = [-1] * N stack = [] for i in range(N-1, -1, -1): while stack and stack[-1] <= arr[i]: stack.pop() if stack: result[i] = stack[-1] stack.append(arr[i]) return result"},{"question":"def process_operations(n, m, sequence, operations): Perform a series of operations (replace and find maximum) on a sequence of integers. Args: n (int): The length of the sequence. m (int): Number of operations to be performed. sequence (List[int]): The initial sequence of integers. operations (List[List[int]]): A list of operations, where each operation is represented by a list of integers. Returns: List[int]: The results of each type 2 operation (finding the maximum in a subarray). Examples: >>> process_operations(5, 4, [3, 1, 4, 1, 5], [[2, 2, 4], [1, 3, 9], [2, 2, 4], [2, 1, 5]]) [4, 9, 9] >>> process_operations(4, 3, [2, 7, 1, 8], [[2, 1, 3], [1, 3, 6], [2, 1, 4]]) [7, 8] Test whether the implementation yields the correct results: from solution import process_operations def test_process_operations(): assert process_operations(5, 4, [3, 1, 4, 1, 5], [ [2, 2, 4], [1, 3, 9], [2, 2, 4], [2, 1, 5] ]) == [4, 9, 9] assert process_operations(4, 3, [2, 7, 1, 8], [ [2, 1, 3], [1, 3, 6], [2, 1, 4] ]) == [7, 8] assert process_operations(1, 1, [10], [ [2, 1, 1] ]) == [10] assert process_operations(3, 4, [1, 2, 3], [ [2, 1, 2], [1, 2, 5], [2, 2, 3], [2, 1, 3] ]) == [2, 5, 5] assert process_operations(6, 3, [10, 20, 30, 40, 50, 60], [ [1, 3, 100], [2, 1, 3], [2, 3, 6] ]) == [100, 100]","solution":"def process_operations(n, m, sequence, operations): results = [] for operation in operations: if operation[0] == 1: _, i, x = operation sequence[i - 1] = x elif operation[0] == 2: _, l, r = operation results.append(max(sequence[l - 1: r])) return results"},{"question":"def calculate_total_scores(t: int, p: int, scores: List[List[int]]) -> List[int]: Calculate the total points for each team based on the scores from several problems. Each team can submit multiple solutions for each problem, but only the highest score for each problem is counted towards the team's total score. Args: t (int): The number of teams. p (int): The number of problems. scores (List[List[int]]): A list of lists where each sublist contains the scores for each team's submissions across p problems. Returns: List[int]: A list containing the total scores for each team in the order they appear in the input. >>> calculate_total_scores(3, 4, [[10, 20, 30, 40], [40, 30, 20, 10], [15, 15, 15, 15]]) [100, 100, 60] >>> calculate_total_scores(2, 3, [[100, 200, 300], [50, 50, 50]]) [600, 150]","solution":"def calculate_total_scores(t, p, scores): total_scores = [] for team_scores in scores: total_scores.append(sum(team_scores)) return total_scores"},{"question":"def contrast_score(s: str) -> int: Returns the contrast score of the string s. The contrast score is defined as the number of pairs (i, j) where 0 <= i < j < len(s) and s[i] != s[j]. >>> contrast_score(\\"abc\\") 3 >>> contrast_score(\\"aab\\") 2 >>> contrast_score(\\"zzz\\") 0 pass def contrast_score_for_multiple_cases(T: int, cases: List[str]) -> List[int]: Computes the contrast scores for multiple test cases. :param T: Number of test cases :param cases: List of strings, each representing a test case :return: List of contrast scores for each test case >>> contrast_score_for_multiple_cases(3, [\\"abc\\", \\"aab\\", \\"zzz\\"]) [3, 2, 0] >>> contrast_score_for_multiple_cases(2, [\\"abcde\\", \\"aaaa\\"]) [10, 0] >>> contrast_score_for_multiple_cases(1, [\\"a\\"]) [0] pass","solution":"def contrast_score(s): Returns the contrast score of the string s. The contrast score is defined as the number of pairs (i, j) where 0 <= i < j < len(s) and s[i] != s[j]. n = len(s) score = 0 for i in range(n): for j in range(i + 1, n): if s[i] != s[j]: score += 1 return score def contrast_score_for_multiple_cases(T, cases): Computes the contrast scores for multiple test cases. :param T: Number of test cases :param cases: List of strings, each representing a test case :return: List of contrast scores for each test case scores = [] for case in cases: scores.append(contrast_score(case)) return scores"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_right_to_left(root): Perform a level order traversal on a binary tree where each level is traversed from right to left. Given the binary tree: 3 / 9 20 / 15 7 Returns: [ [3], [20, 9], [7, 15] ] >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal_right_to_left(root) [[3], [20, 9], [7, 15]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal_right_to_left(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.right: queue.append(node.right) if node.left: queue.append(node.left) result.append(level_nodes) return result"},{"question":"def total_fuel_required(n, distances, fuel_efficiency): Calculate the total fuel required for the trip. Parameters: n (int): The number of cities to visit excluding the starting point. distances (list): A list of distances between consecutive cities. fuel_efficiency (int): The fuel efficiency of the car in km/l. Returns: float: The total fuel required for the trip rounded to two decimal places. Example: >>> total_fuel_required(3, [50, 60, 70], 10) 18.0 >>> total_fuel_required(4, [25, 35, 12, 60], 12) 11.0","solution":"def total_fuel_required(n, distances, fuel_efficiency): Calculate the total fuel required for the trip. Parameters: n (int): The number of cities to visit excluding the starting point. distances (list): A list of distances between consecutive cities. fuel_efficiency (int): The fuel efficiency of the car in km/l. Returns: float: The total fuel required for the trip rounded to two decimal places. total_distance = sum(distances) total_fuel = total_distance / fuel_efficiency return round(total_fuel, 2)"},{"question":"def min_max_element(array): Returns the minimum possible value of the maximum element in the array after performing the allowed operations any number of times. pass # Unit tests def test_example_1(): array = [2, 5, 3] assert min_max_element(array) == 4 def test_example_2(): array = [1, 1, 1, 8] assert min_max_element(array) == 3 def test_example_3(): array = [10, 10, 10, 10, 10] assert min_max_element(array) == 10 def test_array_with_all_elements_equal(): array = [5, 5, 5, 5] assert min_max_element(array) == 5 def test_large_numbers(): array = [1000000000, 1000000000, 1000000000] assert min_max_element(array) == 1000000000 def test_single_large_value(): array = [1, 1, 1, 1000] assert min_max_element(array) == 251","solution":"def min_max_element(array): Returns the minimum possible value of the maximum element in the array after performing the allowed operations any number of times. total_sum = sum(array) n = len(array) # Calculate the minimum possible maximum value if total_sum % n == 0: return total_sum // n else: return total_sum // n + 1"},{"question":"def min_pages_per_day(n: int, m: int, pages: List[int]) -> int: Determines the minimum number of pages the student must read each day to finish all the books by the end of the semester. Args: n: Number of books. m: Number of days in the semester. pages: List of integers representing the number of pages in each book. Returns: The minimum number of pages the student must read each day. >>> min_pages_per_day(5, 5, [100, 200, 300, 400, 500]) 500 >>> min_pages_per_day(1, 5, [1000]) 1000 >>> min_pages_per_day(5, 5, [100, 200, 300, 400, 500]) 500 >>> min_pages_per_day(4, 2, [10, 20, 30, 40]) 60 >>> min_pages_per_day(3, 5, [10, 20, 30]) 30 >>> min_pages_per_day(3, 3, [10000, 20000, 30000]) 30000 >>> min_pages_per_day(6, 3, [100, 200, 300, 400, 600, 200]) 800","solution":"def min_pages_per_day(n, m, pages): left, right = max(pages), sum(pages) # The bounds for binary search def can_finish_in_days(max_pages_per_day): days_needed, current_pages = 1, 0 for page in pages: if current_pages + page > max_pages_per_day: days_needed += 1 current_pages = 0 if days_needed > m: return False current_pages += page return True while left < right: mid = (left + right) // 2 if can_finish_in_days(mid): right = mid else: left = mid + 1 return left"},{"question":"def contains_palindrome_of_length(S: str, queries: List[int]) -> List[str]: Determines if the string contains a palindrome of the given length for each query. >>> contains_palindrome_of_length(\\"abacaba\\", [3, 4]) [\\"Yes\\", \\"No\\"] >>> contains_palindrome_of_length(\\"racecar\\", [3, 4, 7]) [\\"Yes\\", \\"No\\", \\"Yes\\"]","solution":"def contains_palindrome_of_length(S, queries): def is_palindrome(sub): return sub == sub[::-1] results = [] for Q in queries: found = False for i in range(len(S) - Q + 1): if is_palindrome(S[i:i + Q]): found = True break results.append(\\"Yes\\" if found else \\"No\\") return results"},{"question":"def shortest_subarray_with_k_distinct(arr: List[int], K: int) -> int: Find the length of the shortest subarray that contains at least K distinct integers. If no such subarray exists, return -1. >>> shortest_subarray_with_k_distinct([1, 2, 2, 3, 4, 2, 3], 3) == 3 >>> shortest_subarray_with_k_distinct([1, 2, 2, 2, 3], 4) == -1","solution":"def shortest_subarray_with_k_distinct(arr, K): from collections import defaultdict n = len(arr) if K > n: return -1 left = 0 right = 0 min_length = float('inf') current_count = defaultdict(int) distinct_count = 0 while right < n: current_num = arr[right] current_count[current_num] += 1 if current_count[current_num] == 1: distinct_count += 1 while distinct_count >= K: min_length = min(min_length, right - left + 1) left_num = arr[left] current_count[left_num] -= 1 if current_count[left_num] == 0: distinct_count -= 1 left += 1 right += 1 return min_length if min_length != float('inf') else -1"},{"question":"def sum_of_unique_elements(test_cases): Determine the sum of all unique elements in each array for given test cases. >>> test_cases = [ ... (5, [1, 2, 3, 2, 1]), ... (4, [4, 5, 6, 7]), ... (6, [10, 20, 20, 10, 30, 30]) ... ] >>> sum_of_unique_elements(test_cases) [6, 22, 60] result = [] for case in test_cases: n = case[0] array = case[1] unique_elements = set(array) result.append(sum(unique_elements)) return result","solution":"def sum_of_unique_elements(test_cases): result = [] for case in test_cases: n = case[0] array = case[1] unique_elements = set(array) result.append(sum(unique_elements)) return result # Example usage: # test_cases = [ # (5, [1, 2, 3, 2, 1]), # (4, [4, 5, 6, 7]), # (6, [10, 20, 20, 10, 30, 30]) # ] # print(sum_of_unique_elements(test_cases))"},{"question":"def word_frequencies(n: int, lines: List[str]) -> List[str]: Find the frequency of each word that appears in the entire document and display them in alphabetical order. >>> word_frequencies(3, [\\"Hello world\\", \\"world of coding\\", \\"Hello Hello\\"]) [\\"Hello 3\\", \\"coding 1\\", \\"of 1\\", \\"world 2\\"] >>> word_frequencies(2, [\\"This is a line\\", \\"This is another line\\"]) [\\"This 2\\", \\"a 1\\", \\"another 1\\", \\"is 2\\", \\"line 2\\"] from typing import List def test_word_frequencies_example1(): n = 3 lines = [ \\"Hello world\\", \\"world of coding\\", \\"Hello Hello\\" ] expected_output = [ \\"Hello 3\\", \\"coding 1\\", \\"of 1\\", \\"world 2\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_example2(): n = 2 lines = [ \\"This is a line\\", \\"This is another line\\" ] expected_output = [ \\"This 2\\", \\"a 1\\", \\"another 1\\", \\"is 2\\", \\"line 2\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_with_punctuation(): n = 2 lines = [ \\"Hello! world?\\", \\"world? Hello!\\" ] expected_output = [ \\"Hello! 2\\", \\"world? 2\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_empty_lines(): n = 3 lines = [ \\"\\", \\"single line\\", \\"\\" ] expected_output = [ \\"line 1\\", \\"single 1\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_single_word_per_line(): n = 4 lines = [ \\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\" ] expected_output = [ \\"apple 2\\", \\"banana 1\\", \\"cherry 1\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_case_sensitive(): n = 2 lines = [ \\"Dog\\", \\"dog\\" ] expected_output = [ \\"Dog 1\\", \\"dog 1\\" ] assert word_frequencies(n, lines) == expected_output def test_word_frequencies_multiple_spaces(): n = 2 lines = [ \\" spaced words \\", \\"another set of words\\" ] expected_output = [ \\"another 1\\", \\"of 1\\", \\"set 1\\", \\"spaced 1\\", \\"words 2\\" ] assert word_frequencies(n, lines) == expected_output","solution":"def word_frequencies(n, lines): from collections import defaultdict word_count = defaultdict(int) for line in lines: words = line.split() # Split line into words by whitespace for word in words: word_count[word] += 1 sorted_words = sorted(word_count.keys()) result = [] for word in sorted_words: result.append(f\\"{word} {word_count[word]}\\") return result"},{"question":"def largest_island_area(n: int, grid: List[List[int]], h: int) -> int: Determine the size of the largest rectangular island that can be formed on a given terrain grid with elevations equal to or above a given threshold height. Args: n: int - Integer representing the dimension of the square grid. grid: List[List[int]] - The N x N matrix of integers representing the terrain heights. h: int - The threshold height. Returns: int - The area of the largest rectangular island that meets the criteria. >>> largest_island_area(4, [[1, 2, 3, 4], [6, 7, 8, 9], [2, 4, 6, 8], [7, 5, 3, 1]], 5) 4 >>> largest_island_area(3, [[5, 4, 3], [8, 7, 6], [5, 5, 5]], 5) 6","solution":"def largest_island_area(n, grid, h): def max_histogram_area(heights): stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area max_area = 0 histogram = [0] * n for i in range(n): for j in range(n): if grid[i][j] >= h: histogram[j] += 1 else: histogram[j] = 0 max_area = max(max_area, max_histogram_area(histogram)) return max_area"},{"question":"def schedule_tournament(n: int, m: int, k: int, previous_matches: List[Tuple[int, int]]) -> str: Schedule the tournament matches for k rounds such that no match repeats a previously held match and that each employee competes exactly once in each round. Args: n (int): The number of employees. m (int): The number of pairs that have already competed. k (int): The number of rounds. previous_matches (List[Tuple[int, int]]): A list of pairs of employees who have already competed against each other. Returns: str: - The schedule of matches as k lines, each containing n / 2 pairs of space-separated integers representing the matches for each round. - If it is not possible, \\"Not possible\\". >>> input_str = \\"4 2 2n1 2n3 4\\" >>> n, m, k = 4, 2, 2 >>> previous_matches = [(1, 2), (3, 4)] >>> schedule_tournament(n, m, k, previous_matches) \\"1 3 2 4n1 4 2 3\\" >>> input_str = \\"4 3 2n1 2n1 3n2 4\\" >>> n, m, k = 4, 3, 2 >>> previous_matches = [(1, 2), (1, 3), (2, 4)] >>> schedule_tournament(n, m, k, previous_matches) \\"Not possible\\" pass # Example function to parse input and call solution function def solve(input_str): input_lines = input_str.strip().split(\\"n\\") n, m, k = map(int, input_lines[0].split()) previous_matches = [tuple(map(int, line.split())) for line in input_lines[1:m+1]] return schedule_tournament(n, m, k, previous_matches) # Unit tests def test_example1(): input_str = \\"4 2 2n1 2n3 4\\" output_str = solve(input_str) assert output_str in [\\"1 3 2 4n1 4 2 3\\", \\"1 4 2 3n1 3 2 4\\"] def test_example2(): input_str = \\"4 3 2n1 2n1 3n2 4\\" output_str = solve(input_str) assert output_str == \\"Not possible\\" def test_no_previous_matches(): input_str = \\"4 0 2\\" output_str = solve(input_str) assert output_str in [\\"1 2 3 4n1 3 2 4\\", \\"1 3 2 4n1 2 3 4\\", \\"1 4 2 3n1 2 3 4\\"] def test_impossible_due_to_rounds(): input_str = \\"4 1 4n1 2\\" output_str = solve(input_str) assert output_str == \\"Not possible\\" def test_single_round_even(): input_str = \\"4 0 1\\" output_str = solve(input_str) assert output_str in [\\"1 2 3 4\\", \\"1 3 2 4\\", \\"1 4 2 3\\"]","solution":"def schedule_tournament(n, m, k, previous_matches): from itertools import combinations, permutations # Create a set of previous matches for quick lookup previous_set = set(map(tuple, previous_matches)) if n % 2 != 0: return \\"Not possible\\" # Helper function to generate matches for a round def possible_matches(): pairs = list(combinations(range(1, n + 1), 2)) matches = [pair for pair in pairs if pair not in previous_set and (pair[1], pair[0]) not in previous_set] return matches # Generate the schedule schedule = [] all_matches = possible_matches() for _ in range(k): if len(all_matches) < n // 2: return \\"Not possible\\" round_matches = [] used = set() for match in all_matches: if match[0] not in used and match[1] not in used: round_matches.append(match) used.add(match[0]) used.add(match[1]) if len(round_matches) == n // 2: break if len(round_matches) < n // 2: return \\"Not possible\\" schedule.append(round_matches) all_matches = [match for match in all_matches if match not in round_matches] result_list = [] for round_match in schedule: result_list.append(\\" \\".join(f\\"{u} {v}\\" for u, v in round_match)) return \\"n\\".join(result_list) # Example function to parse input and call solution function def solve(input_str): input_lines = input_str.strip().split(\\"n\\") n, m, k = map(int, input_lines[0].split()) previous_matches = [tuple(map(int, line.split())) for line in input_lines[1:m+1]] return schedule_tournament(n, m, k, previous_matches)"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> str: Determines if there are two distinct indices i and j in arr such that arr[i] + arr[j] equals the target. >>> has_pair_with_sum([2, 7, 11, 15, 3], 9) \\"Yes\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"No\\" >>> has_pair_with_sum([], 5) \\"No\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) \\"Yes\\" >>> has_pair_with_sum([-1, 2, 3, -4, 5], 1) \\"Yes\\" >>> has_pair_with_sum([-1, 2, 3, -4, 5], 10) \\"No\\" >>> has_pair_with_sum([1], 2) \\"No\\"","solution":"def has_pair_with_sum(arr, target): Determines if there are two distinct indices i and j in arr such that arr[i] + arr[j] equals the target. seen = set() for number in arr: if target - number in seen: return \\"Yes\\" seen.add(number) return \\"No\\""},{"question":"def min_subarray_len(nums: List[int], s: int) -> int: Returns the length of the shortest subarray with a sum >= s. If no such subarray exists, returns 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"def min_subarray_len(nums, s): Returns the length of the shortest subarray with a sum >= s. If no such subarray exists, returns 0. n = len(nums) left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= s: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def rearrangePalindrome(s: str) -> str: Rearranges the characters of the input string to form a palindrome if possible. Args: s (str): Input string containing lowercase letters. Returns: str: A palindrome formed by the characters of the input string if possible, otherwise an empty string. >>> rearrangePalindrome(\\"aabb\\") in [\\"abba\\", \\"baab\\"] True >>> rearrangePalindrome(\\"aaab\\") \\"\\" >>> rearrangePalindrome(\\"code\\") \\"\\" >>> rearrangePalindrome(\\"a\\") \\"a\\" >>> rearrangePalindrome(\\"a\\" * 50000 + \\"b\\" * 50000) in [(\\"a\\" * 25000 + \\"b\\" * 50000 + \\"a\\" * 25000), (\\"b\\" * 25000 + \\"a\\" * 50000 + \\"b\\" * 25000)] True >>> rearrangePalindrome(\\"aaabbcc\\") in [\\"abcacba\\", \\"bacacba\\", \\"cabacba\\", \\"abccba\\", \\"cbaabc\\"] True","solution":"def rearrangePalindrome(s): Rearranges the characters of the input string to form a palindrome if possible. Args: s (str): Input string containing lowercase letters. Returns: str: A palindrome formed by the characters of the input string if possible, otherwise an empty string. from collections import Counter # Counting the frequency of each character char_count = Counter(s) # Counting how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # It is not possible to form a palindrome if more than one character has an odd frequency if odd_count > 1: return \\"\\" # Forming the first half and middle part of the palindrome left_half = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 != 0: middle_char = char left_half.append(char * (count // 2)) # Joining parts to form the palindrome left_half_str = ''.join(left_half) return left_half_str + middle_char + left_half_str[::-1]"},{"question":"def is_palindrome(s: str) -> bool: Checks if a given string s is a palindrome. return s == s[::-1] def check_queries(A: str, B: str, queries: List[str]) -> List[str]: Given strings A and B, and a list of queries, determines if the resulting concatenated strings are palindromes. Parameters: A (str): The first string. B (str): The second string. queries (List[str]): List of queries, each being one of \\"AA\\", \\"AB\\", \\"BA\\", \\"BB\\". Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each query indicating if the result is a palindrome. Examples: >>> check_queries(\\"abc\\", \\"cba\\", [\\"AA\\", \\"AB\\", \\"BA\\", \\"BB\\"]) [\\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> check_queries(\\"madam\\", \\"madam\\", [\\"AA\\", \\"AB\\", \\"BA\\", \\"BB\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def is_palindrome(s): Checks if a given string s is a palindrome. return s == s[::-1] def check_queries(A, B, queries): Given strings A and B, and a list of queries, determines if the resulting concatenated strings are palindromes. results = [] for query in queries: if query == \\"AA\\": result = is_palindrome(A + A) elif query == \\"AB\\": result = is_palindrome(A + B) elif query == \\"BA\\": result = is_palindrome(B + A) elif query == \\"BB\\": result = is_palindrome(B + B) results.append(\\"YES\\" if result else \\"NO\\") return results"},{"question":"def rank_of_matrix(matrix: List[List[int]]) -> int: Calculate the rank of a given matrix. The rank of a matrix is defined as the maximum number of linearly independent row or column vectors in the matrix. Arguments: matrix: A 2D list of integers representing a matrix. Returns: An integer representing the rank of the matrix. Example: >>> rank_of_matrix([[10, 20, 10], [-20, -30, 10], [30, 50, 0]]) 2 >>> rank_of_matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]]) 3 >>> rank_of_matrix([[0, 0], [0, 0]]) 0","solution":"import numpy as np def rank_of_matrix(matrix): Returns the rank of the given matrix. A = np.array(matrix) return np.linalg.matrix_rank(A)"},{"question":"from typing import List def can_distribute_equally(n: int, k: int, treats: List[int]) -> str: Determines if it's possible to distribute all the pieces of each type of treat equally among the charity groups. Parameters: n (int): Number of different types of treats. Must be 1 ≤ n ≤ 100. k (int): Number of charity groups. Must be 1 ≤ k ≤ 100. treats (List[int]): Contains n integers a_1, a_2, ..., a_{n} (1 ≤ a_{i} ≤ 1000), where a_{i} is the amount of pieces of the i-th type of treat. Returns: str: \\"YES\\" if it's possible to distribute treats equally, otherwise \\"NO\\". Examples: >>> can_distribute_equally(3, 2, [4, 6, 8]) 'YES' >>> can_distribute_equally(4, 3, [5, 10, 15, 20]) 'NO' pass","solution":"def can_distribute_equally(n, k, treats): Determines if it's possible to distribute all the pieces of each type of treat equally among the charity groups. Parameters: n (int): Number of different types of treats. k (int): Number of charity groups. treats (list): List of integers representing the number of pieces of each type of treat. Returns: str: \\"YES\\" if it's possible to distribute treats equally, otherwise \\"NO\\". for treat in treats: if treat % k != 0: return \\"NO\\" return \\"YES\\""},{"question":"def max_rectangle_area(grid: List[str]) -> int: Find the area of the largest rectangle containing only active cells (1s) in the grid. >>> max_rectangle_area([ \\"1010\\", \\"1011\\", \\"1111\\", \\"0011\\" ]) 6 >>> max_rectangle_area([ \\"111111\\", \\"110001\\", \\"111001\\", \\"111111\\", \\"100111\\", \\"111111\\" ]) 9 >>> max_rectangle_area([\\"11111\\"]) 5 >>> max_rectangle_area([ \\"1\\", \\"1\\", \\"1\\" ]) 3 >>> max_rectangle_area([ \\"0000\\", \\"0000\\" ]) 0 >>> max_rectangle_area([ \\"101010\\", \\"010101\\" ]) 1 >>> max_rectangle_area([ \\"1111\\", \\"1111\\", \\"1111\\" ]) 12 >>> max_rectangle_area([ \\"0000\\", \\"0010\\", \\"0000\\" ]) 1","solution":"def max_histogram_area(histogram): stack = list() max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def max_rectangle_area(grid): if not grid: return 0 max_area = 0 row_area = [0] * len(grid[0]) for row in grid: for index in range(len(row)): if row[index] == '1': row_area[index] += 1 else: row_area[index] = 0 max_area = max(max_area, max_histogram_area(row_area)) return max_area"},{"question":"from typing import List def rearrange(array: List[int]) -> List[int]: Rearranges the elements of the array such that all the even numbers appear before the odd numbers while maintaining the relative order of the even and odd numbers. Examples: >>> rearrange([4, 3, 1, 5, 2, 6]) [4, 2, 6, 3, 1, 5] >>> rearrange([1, 2, 3, 4, 5]) [2, 4, 1, 3, 5] >>> rearrange([]) [] pass # Unit tests to verify the implementation def test_rearrange_example_cases(): assert rearrange([4, 3, 1, 5, 2, 6]) == [4, 2, 6, 3, 1, 5] assert rearrange([1, 2, 3, 4, 5]) == [2, 4, 1, 3, 5] assert rearrange([]) == [] def test_rearrange_all_even(): assert rearrange([2, 4, 6, 8]) == [2, 4, 6, 8] def test_rearrange_all_odd(): assert rearrange([1, 3, 5, 7]) == [1, 3, 5, 7] def test_rearrange_mixed_even_odd(): assert rearrange([9, 2, 4, 7, 6, 1, 3, 8]) == [2, 4, 6, 8, 9, 7, 1, 3] def test_rearrange_single_element(): assert rearrange([1]) == [1] assert rearrange([2]) == [2] def test_rearrange_alternating_even_odd(): assert rearrange([1, 2, 3, 4, 5, 6]) == [2, 4, 6, 1, 3, 5]","solution":"from typing import List def rearrange(array: List[int]) -> List[int]: Rearranges the elements of the array such that all the even numbers appear before the odd numbers while maintaining the relative order of the even and odd numbers. evens = [num for num in array if num % 2 == 0] odds = [num for num in array if num % 2 != 0] return evens + odds"},{"question":"def rearrange_sentence(sentence: str) -> str: Given a sentence, rearrange the letters of the words in the sentence in alphabetical order. Args: sentence (str): A sentence with words separated by spaces. Returns: str: The sentence with each word's letters sorted in alphabetical order. Examples: >>> rearrange_sentence(\\"hello world\\") 'ehllo dlorw' >>> rearrange_sentence(\\"python programming\\") 'hnopty aggimmnoprr'","solution":"def rearrange_sentence(sentence): Returns the sentence with each word's letters sorted in alphabetical order. words = sentence.split() sorted_words = [''.join(sorted(word)) for word in words] return ' '.join(sorted_words)"},{"question":"def qualifies_for_discount(n, prices, k): Determines if an order qualifies for a discount. Parameters: n (int): The number of pizzas ordered. prices (list of int): The prices of the pizzas. k (int): The minimum order amount required to qualify for the discount. Returns: str: \\"YES\\" if the order qualifies for the discount, otherwise \\"NO\\". pass # Implement the function logic here # Test cases def test_qualifies_for_discount_multiple_pizzas_exceeds_min(): assert qualifies_for_discount(3, [12, 15, 10], 30) == \\"YES\\" def test_qualifies_for_discount_multiple_pizzas_not_exceeds_min(): assert qualifies_for_discount(2, [15, 10], 50) == \\"NO\\" def test_qualifies_for_discount_single_pizza(): assert qualifies_for_discount(1, [15], 10) == \\"NO\\" def test_qualifies_for_discount_exact_minimum_value(): assert qualifies_for_discount(2, [20, 30], 50) == \\"NO\\" def test_qualifies_for_discount_just_over_minimum_value(): assert qualifies_for_discount(3, [10, 20, 21], 50) == \\"YES\\" def test_qualifies_for_discount_large_order(): assert qualifies_for_discount(100, [i+1 for i in range(100)], 1000) == \\"YES\\" def test_qualifies_for_discount_large_order_below_minimum(): assert qualifies_for_discount(100, [1]*100, 200) == \\"NO\\"","solution":"def qualifies_for_discount(n, prices, k): Determines if an order qualifies for a discount. Parameters: n (int): The number of pizzas ordered. prices (list of int): The prices of the pizzas. k (int): The minimum order amount required to qualify for the discount. Returns: str: \\"YES\\" if the order qualifies for the discount, otherwise \\"NO\\". if n > 1 and sum(prices) > k: return \\"YES\\" return \\"NO\\""},{"question":"def dispense_candies(n, stocks, m, preferences): Simulates the dispensing process of a vending machine in a small town. Args: n : int : The number of different candy types. stocks : List[int] : The initial stock levels for each candy type. m : int : The number of customers using the vending machine. preferences : List[List[int]] : Each customer's list of preferred candy types. Returns: List[int] : The list of candy types each customer receives (or -1 if none are available). Example: >>> dispense_candies(5, [4, 2, 0, 5, 1], 3, [[1, 3, 5], [2, 4], [1, 2, 5, 3]]) [1, 2, 1] >>> dispense_candies(3, [0, 0, 0], 2, [[1, 2, 3], [1]) [-1, -1] from typing import List def test_dispense_candies_example(): n = 5 stocks = [4, 2, 0, 5, 1] m = 3 preferences = [ [1, 3, 5], [2, 4], [1, 2, 5, 3] ] expected_output = [1, 2, 1] assert dispense_candies(n, stocks, m, preferences) == expected_output def test_dispense_candies_no_stock(): n = 3 stocks = [0, 0, 0] m = 2 preferences = [ [1, 2, 3], [1] ] expected_output = [-1, -1] assert dispense_candies(n, stocks, m, preferences) == expected_output def test_dispense_candies_exact_stock(): n = 3 stocks = [1, 1, 1] m = 3 preferences = [ [1], [2], [3] ] expected_output = [1, 2, 3] assert dispense_candies(n, stocks, m, preferences) == expected_output def test_dispense_candies_insufficient_stock(): n = 3 stocks = [1, 1, 1] m = 4 preferences = [ [1], [1, 2], [2, 3], [3] ] expected_output = [1, 2, 3, -1] assert dispense_candies(n, stocks, m, preferences) == expected_output","solution":"def dispense_candies(n, stocks, m, preferences): results = [] for person in preferences: received = -1 for candy in person: if stocks[candy - 1] > 0: received = candy stocks[candy - 1] -= 1 break results.append(received) return results"},{"question":"import heapq from typing import List, Tuple def calculate_shortest_travel_time(cities: List[str], segments: List[Tuple[str, str, int, int]], start_city: str, end_city: str) -> float: Calculate the shortest travel time between cities considering different speeds for different segments of the route. cities: List of city names. segments: List of tuples, each representing a segment in the format (city1, city2, distance, speed_limit). start_city: The start city name. end_city: The destination city name. Returns the shortest travel time as a float rounded to two decimal places. If there is no valid route, returns -1. Examples: >>> calculate_shortest_travel_time( [\\"CityA\\", \\"CityB\\", \\"CityC\\"], [(\\"CityA\\", \\"CityB\\", 100, 100), (\\"CityB\\", \\"CityC\\", 100, 100), (\\"CityA\\", \\"CityC\\", 300, 150)], \\"CityA\\", \\"CityC\\" ) 2.0 >>> calculate_shortest_travel_time( [\\"CityA\\", \\"CityB\\"], [(\\"CityA\\", \\"CityB\\", 300, 150), (\\"CityB\\", \\"CityA\\", 300, 150)], \\"CityA\\", \\"CityB\\" ) 2.0 def process_input(inputs: List[str]) -> List[float]: Processes multiple datasets to calculate the shortest travel times for each. inputs: List of strings representing the datasets. Returns a list of shortest travel times for all datasets. Examples: >>> process_input([ \\"3\\", \\"CityA\\", \\"CityB\\", \\"CityC\\", \\"3\\", \\"CityA CityB 100 100\\", \\"CityB CityC 100 100\\", \\"CityA CityC 300 150\\", \\"CityA CityC\\", \\"2\\", \\"CityA\\", \\"CityB\\", \\"2\\", \\"CityA CityB 300 150\\", \\"CityB CityA 300 150\\", \\"CityA CityB\\", \\"0\\" ]) [2.0, 2.0] >>> process_input([ \\"2\\", \\"CityA\\", \\"CityB\\", \\"1\\", \\"CityA CityB 200 100\\", \\"CityA CityB\\", \\"2\\", \\"CityC\\", \\"CityD\\", \\"1\\", \\"CityC CityD 100 50\\", \\"CityC CityD\\", \\"0\\" ]) [2.0, 2.0] >>> process_input([ \\"2\\", \\"CityA\\", \\"CityB\\", \\"1\\", \\"CityA CityB 200 100\\", \\"CityA CityC\\", \\"0\\" ]) [-1] >>> process_input([ \\"2\\", \\"CityA\\", \\"CityB\\", \\"1\\", \\"CityA CityB 100 111\\", \\"CityA CityB\\", \\"0\\" ]) [0.90]","solution":"import heapq def calculate_shortest_travel_time(cities, segments, start_city, end_city): graph = {city: [] for city in cities} for segment in segments: city1, city2, distance, speed = segment time = distance / speed graph[city1].append((time, city2)) graph[city2].append((time, city1)) pq = [(0, start_city)] visited = set() min_time = {city: float('inf') for city in cities} min_time[start_city] = 0 while pq: current_time, current_city = heapq.heappop(pq) if current_city in visited: continue visited.add(current_city) if current_city == end_city: return round(current_time, 2) for time, neighbor in graph[current_city]: new_time = current_time + time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return -1 def process_input(inputs): results = [] idx = 0 while idx < len(inputs): C = int(inputs[idx]) if C == 0: break idx += 1 cities = [inputs[idx + i] for i in range(C)] idx += C S = int(inputs[idx]) idx += 1 segments = [] for _ in range(S): segment = inputs[idx].split() city1 = segment[0] city2 = segment[1] distance = int(segment[2]) speed = int(segment[3]) segments.append((city1, city2, distance, speed)) idx += 1 start_city, end_city = inputs[idx].split() idx += 1 result = calculate_shortest_travel_time(cities, segments, start_city, end_city) results.append(result) return results"},{"question":"def remove_repeats(s: str) -> str: Given a string s, return the original sequence of characters before any repetitions caused by faulty keys. >>> remove_repeats(\\"aabbccc\\") \\"abc\\" >>> remove_repeats(\\"tttyyypppeee\\") \\"type\\" >>> remove_repeats(\\"qqqqq\\") \\"q\\" pass def process_queries(queries: List[str]) -> List[str]: Given a list of queries, process each query and return the results as a list. >>> process_queries([\\"aabbccc\\", \\"tttyyypppeee\\", \\"qqqqq\\"]) [\\"abc\\", \\"type\\", \\"q\\"] >>> process_queries([\\"aa\\", \\"bb\\", \\"cc\\"]) [\\"a\\", \\"b\\", \\"c\\"] pass","solution":"def remove_repeats(s): Given a string s, return the original sequence of characters before any repetitions caused by faulty keys. if not s: return \\"\\" original = s[0] for char in s[1:]: if char != original[-1]: original += char return original def process_queries(queries): Given a list of queries, process each query and return the results as a list. return [remove_repeats(query) for query in queries]"},{"question":"from typing import List, Dict def total_installation_cost(target_id: str, packages: List[Dict[str, any]]) -> int: Calculate the total cost of installing a package including its dependencies. :param target_id: The id of the package to install. :param packages: A list of package descriptions in JSON-like format. :return: The total installation cost.","solution":"def total_installation_cost(target_id, packages): Calculate the total cost of installing a package including its dependencies. :param target_id: The id of the package to install. :param packages: A list of package descriptions in JSON-like format. :return: The total installation cost. package_map = {pkg['id']: pkg for pkg in packages} def get_cost(pkg_id): pkg = package_map[pkg_id] cost = pkg['price'] for dep_id in pkg['dependencies']: cost += get_cost(dep_id) return cost return get_cost(target_id)"},{"question":"def find_twin_primes(a: int, b: int) -> None: Finds and prints all twin prime pairs between a and b. Input: - a: Starting integer of the range (1 ≤ a ≤ 10^6) - b: Ending integer of the range (a ≤ b ≤ 10^6) Output: - The total number of twin prime pairs within the range [a, b]. - For each twin prime pair, print the pair in the format (p1, p2) where p1 < p2. - If there are no twin prime pairs in the range, print \\"No twin primes\\". >>> find_twin_primes(5, 30) 4 (5, 7) (11, 13) (17, 19) (29, 31) >>> find_twin_primes(10, 20) 2 (11, 13) (17, 19) >>> find_twin_primes(1, 2) No twin primes","solution":"def find_twin_primes(a, b): Finds and returns all twin prime pairs between a and b. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True primes = [is_prime(i) for i in range(a, b + 3)] twin_primes = [] for i in range(a, b + 1): if primes[i - a] and primes[i - a + 2]: twin_primes.append((i, i + 2)) if not twin_primes: print(\\"No twin primes\\") else: print(len(twin_primes)) for pair in twin_primes: print(pair)"},{"question":"def min_changes_to_k_expressible(n: int, k: int, arr: List[int]) -> int: Returns the minimum number of changes required to make the array k-expressible. >>> min_changes_to_k_expressible(5, 2, [1, 2, 3, 4, 5]) 3 >>> min_changes_to_k_expressible(7, 3, [4, 4, 2, 2, 2, 3, 3]) 0 >>> min_changes_to_k_expressible(6, 1, [1, 2, 2, 1, 1, 3]) 3","solution":"from collections import Counter def min_changes_to_k_expressible(n, k, arr): Returns the minimum number of changes required to make the array k-expressible. # Count the frequency of each number in the array freq = Counter(arr) # If already k or fewer distinct elements, no changes needed if len(freq) <= k: return 0 # Get frequencies sorted in descending order freq_counts = sorted(freq.values(), reverse=True) # Number of elements to retain if we need exactly k distinct elements elements_to_retain = sum(freq_counts[:k]) # Return the number of changes required return n - elements_to_retain"},{"question":"def hybrid_sequence(a: int, b: int, n: int) -> List[int]: Generates the first n terms of Alice's hybrid sequence starting with a and b. Parameters: a (int): The first term of the sequence. b (int): The second term of the sequence. n (int): The number of terms to generate. Returns: List[int]: The list containing the first n terms of the sequence. Examples: >>> hybrid_sequence(2, 3, 5) [2, 3, 5, 15, 20] >>> hybrid_sequence(1, 1, 8) [1, 1, 2, 2, 4, 8, 12, 96] >>> hybrid_sequence(2, 10, 6) [2, 10, 12, 120, 132, 15840] pass from typing import List def test_hybrid_sequence_example1(): assert hybrid_sequence(2, 3, 5) == [2, 3, 5, 15, 20] def test_hybrid_sequence_example2(): assert hybrid_sequence(1, 1, 8) == [1, 1, 2, 2, 4, 8, 12, 96] def test_hybrid_sequence_example3(): assert hybrid_sequence(2, 10, 6) == [2, 10, 12, 120, 132, 15840] def test_hybrid_sequence_minimum_values(): assert hybrid_sequence(1, 1, 2) == [1, 1] def test_hybrid_sequence_more_terms(): assert hybrid_sequence(3, 2, 7) == [3, 2, 5, 10, 15, 150, 165] def test_hybrid_sequence_large_values(): assert hybrid_sequence(10, 10, 4) == [10, 10, 20, 200] def test_hybrid_sequence_zero_values(): assert hybrid_sequence(1, 2, 3) == [1, 2, 3]","solution":"def hybrid_sequence(a, b, n): Generates the first n terms of Alice's hybrid sequence. sequence = [a, b] for i in range(2, n): if i % 2 == 0: sequence.append(sequence[i-2] + sequence[i-1]) else: sequence.append(sequence[i-2] * sequence[i-1]) return sequence"},{"question":"def wordExists(m, n, grid, word): Given a rectangular grid of characters and a word, determine if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[str]]): 2D list of characters representing the grid. word (str): The word to be searched in the grid. Returns: str: \\"Yes\\" if the word exists in the grid, otherwise \\"No\\". Example: >>> grid = [ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ] >>> wordExists(3, 4, grid, \\"ABCCED\\") 'Yes' >>> wordExists(3, 4, grid, \\"SEE\\") 'Yes' >>> wordExists(3, 4, grid, \\"ABCB\\") 'No'","solution":"def wordExists(m, n, grid, word): def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] != word[index]: return False temp = grid[x][y] grid[x][y] = '#' # Mark as visited # Explore all adjacent cells (up, down, left, right) found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1)) grid[x][y] = temp # Unmark as visited return found for i in range(m): for j in range(n): if grid[i][j] == word[0] and dfs(i, j, 0): return \\"Yes\\" return \\"No\\""},{"question":"import math from typing import List def count_unique_arrangements(n: int, p: List[int]) -> int: This function calculates the total number of unique ways to arrange plants in a linear garden bed. :param n: int : number of different types of plants :param p: list : a list containing the number of plants of each type :return: int : total number of unique ways to arrange the plants >>> count_unique_arrangements(3, [1, 2, 1]) 12 >>> count_unique_arrangements(2, [2, 2]) 6 >>> count_unique_arrangements(1, [5]) 1 >>> count_unique_arrangements(3, [1, 1, 1]) 6 >>> count_unique_arrangements(4, [2, 1, 1, 1]) 60 >>> count_unique_arrangements(2, [3, 1]) 4 >>> count_unique_arrangements(3, [2, 2, 2]) 90 >>> count_unique_arrangements(12, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 479001600","solution":"import math def count_unique_arrangements(n, p): This function calculates the total number of unique ways to arrange plants in a linear garden bed. :param n: int : number of different types of plants :param p: list : a list containing the number of plants of each type :return: int : total number of unique ways to arrange the plants total_plants = sum(p) denominator = 1 for plant_count in p: denominator *= math.factorial(plant_count) return math.factorial(total_plants) // denominator"},{"question":"def shortestPath(m: int, n: int, x: int, y: int, obstacles: List[Tuple[int, int]]) -> int: Determines the length of the shortest path from the top-left corner (0,0) to the cell (x, y) without passing through any obstacles. If there is no valid path, returns -1. The path can only move up, down, left, or right. >>> shortestPath(3, 3, 2, 2, [(0, 1), (1, 1)]) 4 >>> shortestPath(3, 3, 2, 2, [(0, 1), (1, 1), (1, 0), (2, 1)]) -1 >>> shortestPath(4, 4, 3, 3, [(1, 1), (1, 2), (2, 2)]) 6","solution":"from collections import deque from typing import List, Tuple def shortestPath(m: int, n: int, x: int, y: int, obstacles: List[Tuple[int, int]]) -> int: Determines the length of the shortest path from the top-left corner (0,0) to the cell (x, y) without passing through any obstacles. If there is no valid path, returns -1. The path can only move up, down, left, or right. # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Create visited set to track cells and obstacles visited = set(obstacles) # If start or end is an obstacle, return -1 if (0, 0) in visited or (x, y) in visited: return -1 # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, distance) visited.add((0, 0)) while queue: row, col, dist = queue.popleft() # Check if reached the target cell if row == x and col == y: return dist # Explore neighboring cells for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1 # No valid path found"},{"question":"def spiralOrder(matrix): Given an \`m x n\` matrix, return all elements of the matrix in spiral order. >>> spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]","solution":"def spiralOrder(matrix): Returns all elements of the matrix in spiral order. res = [] if not matrix: return res top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): res.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): res.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): res.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): res.append(matrix[i][left]) left += 1 return res"},{"question":"def min_deletions_to_alternating(s: str) -> int: Calculates the minimum number of deletions required to make the string alternate with no two adjacent characters being the same. >>> min_deletions_to_alternating(\\"AAAA\\") == 3 >>> min_deletions_to_alternating(\\"BBBBB\\") == 4 >>> min_deletions_to_alternating(\\"ABABABAB\\") == 0 def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Processes the test cases and returns the results for each one. >>> process_test_cases(3, [\\"AAAA\\", \\"BBBBB\\", \\"ABABABAB\\"]) == [3, 4, 0] >>> process_test_cases(2, [\\"AABBAABB\\", \\"ABBAABB\\"]) == [4, 3] >>> process_test_cases(1, [\\"A\\"]) == [0]","solution":"def min_deletions_to_alternating(s): Calculates the minimum number of deletions required to make the string alternate with no two adjacent characters being the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i-1]: deletions += 1 return deletions def process_test_cases(t, test_cases): Processes the test cases and returns the results for each one. results = [] for s in test_cases: results.append(min_deletions_to_alternating(s)) return results"},{"question":"def find_peak_element(matrix): Finds a peak element in the given matrix. A peak element is one which is not smaller than its neighbors. Args: matrix (list of list of int): 2D matrix filled with non-negative integers Returns: int: The value of one of the peak elements in the matrix Example: >>> find_peak_element([ ... [10, 20, 15], ... [21, 30, 14], ... [7, 16, 32] ... ]) == 30 >>> find_peak_element([ ... [1, 2, 3], ... [3, 4, 5], ... [5, 6, 7] ... ]) == 7 >>> find_peak_element([ ... [1, 2], ... [3, 4] ... ]) in [2, 4] >>> find_peak_element([ ... [10] ... ]) == 10 >>> find_peak_element([ ... [10, 20, 30, 40], ... [14, 13, 12, 11], ... [15, 9, 8, 7] ... ]) == 40 >>> find_peak_element([ ... [10, 8, 10, 10], ... [14, 13, 12, 11], ... [15, 9, 11, 21] ... ]) in [15, 21]","solution":"def find_peak_element(matrix): Finds a peak element in the given matrix. A peak element is one which is not smaller than its neighbors. Args: matrix (list of list of int): 2D matrix filled with non-negative integers Returns: int: The value of one of the peak elements in the matrix n = len(matrix) m = len(matrix[0]) def is_peak(i, j): # Check up if i > 0 and matrix[i][j] < matrix[i-1][j]: return False # Check down if i < n-1 and matrix[i][j] < matrix[i+1][j]: return False # Check left if j > 0 and matrix[i][j] < matrix[i][j-1]: return False # Check right if j < m-1 and matrix[i][j] < matrix[i][j+1]: return False return True # Iterate over the entire matrix to find a peak element for i in range(n): for j in range(m): if is_peak(i, j): return matrix[i][j] return None # Just a safeguard, there should always be a peak element"},{"question":"from typing import List def is_anagram_in_substring(s1: str, s2: str) -> bool: Given two words, determine if the second word is an anagram of any substring of the first word. >>> is_anagram_in_substring(\\"abdcghbaabcdij\\", \\"bcda\\") == True >>> is_anagram_in_substring(\\"abdcghbaabcdij\\", \\"xyz\\") == False >>> is_anagram_in_substring(\\"abbcabc\\", \\"abc\\") == True >>> is_anagram_in_substring(\\"cbabcdij\\", \\"abc\\") == True >>> is_anagram_in_substring(\\"a\\", \\"a\\") == True >>> is_anagram_in_substring(\\"a\\", \\"b\\") == False >>> is_anagram_in_substring(\\"\\", \\"\\") == True >>> is_anagram_in_substring(\\"a\\", \\"\\") == True >>> is_anagram_in_substring(\\"\\", \\"a\\") == False >>> is_anagram_in_substring(\\"a\\", \\"ab\\") == False >>> is_anagram_in_substring(\\"a\\"*10000 + \\"bcda\\", \\"abcd\\") == True","solution":"from collections import Counter def is_anagram_in_substring(s1, s2): Determines if the second word s2 is an anagram of any substring of the first word s1. len_s1, len_s2 = len(s1), len(s2) if len_s2 > len_s1: return False # Create frequency counts for the shorter string s2 s2_count = Counter(s2) # Create a sliding window counter for the first len_s2 characters of s1 window_count = Counter(s1[:len_s2]) # Check if the initial window is an anagram if window_count == s2_count: return True for i in range(len_s2, len_s1): # Slide the window: remove the character going out of the window, add the new character window_count[s1[i]] += 1 window_count[s1[i - len_s2]] -= 1 # Remove zero-count element to keep the comparison clean if window_count[s1[i - len_s2]] == 0: del window_count[s1[i - len_s2]] # Check if the current window is an anagram if window_count == s2_count: return True return False"},{"question":"def total_coding_minutes(test_cases): Calculate the total number of minutes Chef will spend coding over a given number of days. Each test case is a tuple of two integers, (D, M), where D is the number of days and M is the number of minutes per day. Args: test_cases (List[Tuple[int, int]]): A list of tuples, each representing a test case. Returns: List[int]: A list of integers representing the total number of minutes for each test case. >>> total_coding_minutes([(1, 60), (2, 30), (7, 15)]) [60, 60, 105] >>> total_coding_minutes([(10, 100)]) [1000] def parse_input(input_str): Parse the input string to extract the test cases. Args: input_str (str): The input string containing the number of test cases and the test cases themselves. Returns: List[Tuple[int, int]]: A list of tuples, each representing a test case. >>> parse_input(\\"3n1 60n2 30n7 15\\") [(1, 60), (2, 30), (7, 15)] >>> parse_input(\\"1n10 100\\") [(10, 100)]","solution":"def total_coding_minutes(test_cases): results = [] for D, M in test_cases: total_minutes = D * M results.append(total_minutes) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [tuple(map(int, line.split())) for line in lines[1:T+1]] return test_cases"},{"question":"def longest_heads_sequence(s: str) -> int: Returns the length of the longest consecutive sequence of 'H' in the given string. >>> longest_heads_sequence(\\"HHTTHTHH\\") == 2 >>> longest_heads_sequence(\\"THTHTTTHH\\") == 2 >>> longest_heads_sequence(\\"TTTTTT\\") == 0 >>> longest_heads_sequence(\\"HHHHHHTTTHHH\\") == 6 >>> longest_heads_sequence(\\"H\\") == 1 >>> longest_heads_sequence(\\"T\\") == 0 >>> longest_heads_sequence(\\"HTHTHTHHHTHT\\") == 3 >>> longest_heads_sequence(\\"HHHHHH\\") == 6 >>> longest_heads_sequence(\\"TTTHHH\\") == 3 >>> longest_heads_sequence(\\"HHHHTTTTH\\") == 4","solution":"def longest_heads_sequence(s: str) -> int: Returns the length of the longest consecutive sequence of 'H' in the given string. max_length = 0 current_length = 0 for char in s: if char == 'H': current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def can_rearrange_to_palindrome(s: str) -> str: Given a string \`s\` of length \`n\` consisting of only lowercase English letters, determine if it is possible to rearrange the string \`s\` to form a palindrome by reversing any number of non-empty contiguous substrings. -----Examples----- >>> can_rearrange_to_palindrome(\\"racecar\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"abcde\\") \\"NO\\" >>> can_rearrange_to_palindrome(\\"aabb\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"aabbccdde\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"abc\\") \\"NO\\" >>> can_rearrange_to_palindrome(\\"a\\") \\"YES\\"","solution":"def can_rearrange_to_palindrome(s): Function to determine if it's possible to rearrange the string \`s\` to form a palindrome by reversing any number of non-empty contiguous substrings. char_count = {} # Count frequency of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if at most one character has an odd frequency if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def rearrange_string(s: str) -> str: Rearrange the characters of the string such that no two adjacent characters are the same. If it is impossible to do so, return \\"IMPOSSIBLE\\". Args: s (str): The input string consisting of lowercase English letters. Returns: str: The rearranged string or \\"IMPOSSIBLE\\". Examples: >>> rearrange_string(\\"aaabbc\\") != \\"IMPOSSIBLE\\" >>> rearrange_string(\\"aaa\\") == \\"IMPOSSIBLE\\" pass def rearrange_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: Process multiple test cases to determine the rearranged string for each case. Args: test_cases (List[Tuple[int, str]]): A list of test cases where each test case is a tuple containing the length of the string and the string itself. Returns: List[str]: A list of results for each test case. Examples: >>> test_cases = [ ... (6, \\"aaabbc\\"), ... (3, \\"aaa\\"), ... (7, \\"aabbccd\\") ... ] >>> rearrange_test_cases(test_cases) == ['abcaba', 'IMPOSSIBLE', 'acbadbc'] pass from rearrange_solution import rearrange_string, rearrange_test_cases def test_rearrange_string(): assert rearrange_string(\\"aaabbc\\") != \\"IMPOSSIBLE\\" # Check if it is possible assert rearrange_string(\\"aaa\\") == \\"IMPOSSIBLE\\" assert rearrange_string(\\"aabbccd\\") != \\"IMPOSSIBLE\\" assert rearrange_string(\\"\\") == \\"IMPOSSIBLE\\" # Empty string edge case def test_rearrange_test_cases(): test_cases = [ (6, \\"aaabbc\\"), (3, \\"aaa\\"), (7, \\"aabbccd\\") ] outputs = rearrange_test_cases(test_cases) assert outputs[0] != \\"IMPOSSIBLE\\" assert outputs[1] == \\"IMPOSSIBLE\\" assert outputs[2] != \\"IMPOSSIBLE\\"","solution":"from collections import Counter from heapq import heappop, heappush def rearrange_string(s): if not s: return \\"IMPOSSIBLE\\" # Create a counter for all characters counter = Counter(s) # Max heap to store characters by their frequency max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) # If there's a previously used char, push it back if there's more left to use if prev_char is not None and prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) # Update prev_char and prev_freq prev_char = char prev_freq = freq + 1 # If the resulting string's length doesn't match the input's length, return IMPOSSIBLE if len(result) != len(s): return \\"IMPOSSIBLE\\" return \\"\\".join(result) def rearrange_test_cases(test_cases): results = [] for n, s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"def max_product_of_two(nums): Returns the maximum product of two different elements in the list nums. >>> max_product_of_two([1, 2, 3, 4, 5]) 20 >>> max_product_of_two([-10, -20, -5, -2]) 200 >>> max_product_of_two([-10, -20, 5, 8]) 200","solution":"def max_product_of_two(nums): Returns the maximum product of two different elements in the list nums. if len(nums) < 2: raise ValueError(\\"List must contain at least two elements\\") nums = sorted(nums) # Product of two largest numbers product1 = nums[-1] * nums[-2] # Product of two smallest numbers (in case of large negatives leading to positive product) product2 = nums[0] * nums[1] return max(product1, product2)"},{"question":"def longestSubstringWithKChanges(s: str, k: int) -> int: Given a string s and an integer k, return the length of the longest substring where all the characters are the same after at most k changes. >>> longestSubstringWithKChanges(\\"ABAB\\", 2) 4 >>> longestSubstringWithKChanges(\\"AABABBA\\", 1) 4 >>> longestSubstringWithKChanges(\\"AAAA\\", 2) 4 >>> longestSubstringWithKChanges(\\"ABCDEFG\\", 3) 4 >>> longestSubstringWithKChanges(\\"AABCD\\", 0) 2 >>> longestSubstringWithKChanges(\\"AAAAA\\", 3) 5 >>> longestSubstringWithKChanges(\\"BBBBB\\", 1) 5 >>> longestSubstringWithKChanges(\\"AABB\\", 0) 2 >>> longestSubstringWithKChanges(\\"ABCABCABC\\", 0) 1 >>> longestSubstringWithKChanges(\\"A\\", 1) 1 >>> longestSubstringWithKChanges(\\"AA\\", 2) 2 >>> longestSubstringWithKChanges(\\"AB\\", 1) 2","solution":"def longestSubstringWithKChanges(s, k): from collections import defaultdict max_length = 0 max_count = 0 count = defaultdict(int) left = 0 for right in range(len(s)): count[s[right]] += 1 max_count = max(max_count, count[s[right]]) if right - left + 1 - max_count > k: count[s[left]] -= 1 left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def scrabble_score(word: str) -> int: Calculate the score of a word in a game of Scrabble. The score of a word is the sum of the points of its individual letters. The point values of each letter are as follows: - 1 point: A, E, I, O, U, L, N, S, T, R - 2 points: D, G - 3 points: B, C, M, P - 4 points: F, H, V, W, Y - 5 points: K - 8 points: J, X - 10 points: Q, Z Your task is to determine the score of a given word according to the above point values. >>> scrabble_score(\\"HELLO\\") 8 >>> scrabble_score(\\"WORLD\\") 9 >>> scrabble_score(\\"SCRABBLE\\") 14","solution":"def scrabble_score(word): Returns the Scrabble score for the given word. score_chart = { 1: 'AEIOULNSTR', 2: 'DG', 3: 'BCMP', 4: 'FHVWY', 5: 'K', 8: 'JX', 10: 'QZ' } score = 0 for letter in word: for points, letters in score_chart.items(): if letter in letters: score += points break return score"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. pass def longest_prime_subarray_length(arr: List[int]) -> int: Given an array of integers, return the length of the longest contiguous subarray consisting entirely of prime numbers. >>> longest_prime_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 2 >>> longest_prime_subarray_length([11, 13, 17, 4, 5, 6, 7]) 3 >>> longest_prime_subarray_length([4, 6, 8, 10, 12]) 0 >>> longest_prime_subarray_length([2, 3, 5, 7, 11, 13]) 6 >>> longest_prime_subarray_length([15, 17, 19, 20, 21, 23, 29, 31]) 3 >>> longest_prime_subarray_length([2]) 1 >>> longest_prime_subarray_length([0, 1, 4, 6, 8]) 0 pass","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_prime_subarray_length(arr): max_length = 0 current_length = 0 for num in arr: if is_prime(num): current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def transform_string(s: str) -> str: Transforms the input string such that each character is replaced with the next character in the English alphabet. 'z' wraps around to 'a'. >>> transform_string('abc') 'bcd' >>> transform_string('xyz') 'yza' def process_test_cases(t: int, cases: List[str]) -> List[str]: Processes multiple test cases for the transform_string function. >>> process_test_cases(2, ['abc', 'xyz']) ['bcd', 'yza'] >>> process_test_cases(1, ['zzz']) ['aaa']","solution":"def transform_string(s): Transforms the input string such that each character is replaced with the next character in the English alphabet. 'z' wraps around to 'a'. transformed_chars = [] for char in s: if char == 'z': transformed_chars.append('a') else: transformed_chars.append(chr(ord(char) + 1)) return ''.join(transformed_chars) def process_test_cases(t, cases): results = [] for i in range(t): results.append(transform_string(cases[i])) return results"},{"question":"from typing import List def min_path_time(n: int, m: int, grid: List[List[int]]) -> int: Calculate the minimum time required to reach the bottom-right corner from the top-left corner. :param n: Number of rows (int) :param m: Number of columns (int) :param grid: 2D list of integers representing the grid with times (List[List[int]]) :return: Minimum time to reach the bottom-right corner (int) >>> min_path_time(3, 4, [[1, 3, 1, 2], [2, 1, 3, 1], [4, 2, 1, 3]]) 10 >>> min_path_time(2, 2, [[2, 3], [4, 1]]) 6","solution":"def min_path_time(n, m, grid): Calculate the minimum time required to reach the bottom-right corner from the top-left corner. :param n: Number of rows :param m: Number of columns :param grid: 2D list representing the grid with times :return: Minimum time to reach the bottom-right corner # Create a 2D dp array to store the minimum times dp = [[0] * m for _ in range(n)] # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill in the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum time return dp[n-1][m-1]"},{"question":"def count_word_frequency(messages): Process a list of messages and return a dictionary with the total frequency of each unique word across all messages. >>> count_word_frequency([\\"hello world\\"]) {'hello': 1, 'world': 1} >>> count_word_frequency([\\"hello world\\", \\"hello\\"]) {'hello': 2, 'world': 1} >>> count_word_frequency([\\"hello world hello\\", \\"hello there\\"]) {'hello': 3, 'world': 1, 'there': 1} >>> count_word_frequency([]) {} >>> count_word_frequency([\\" \\"]) {} >>> count_word_frequency([\\"a a b b c c\\"]) {'a': 2, 'b': 2, 'c': 2} >>> count_word_frequency([\\"a\\", \\"a a a\\", \\"a b b b c\\"]) {'a': 5, 'b': 3, 'c': 1}","solution":"def count_word_frequency(messages): Returns a dictionary with the total frequency of each unique word across all messages. word_frequency = {} for message in messages: words = message.split() for word in words: if word in word_frequency: word_frequency[word] += 1 else: word_frequency[word] = 1 return word_frequency"},{"question":"def updateBoard(board: List[List[str]], start: List[int]) -> List[List[str]]: Reveal all safe cells in a Minesweeper board starting from the given cell. Args: board (List[List[str]]): The Minesweeper board. start (List[int]): The starting cell [row, column]. Returns: List[List[str]]: The updated Minesweeper board. Example: >>> updateBoard([['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'M', 'E', 'E'], ['E', 'E', 'E', 'E', 'E'], ['E', 'E', 'E', 'E', 'E']], [3, 0]) [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']] >>> updateBoard([['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']], [1, 2]) [['B', '1', 'E', '1', 'B'], ['B', '1', 'M', '1', 'B'], ['B', '1', '1', '1', 'B'], ['B', 'B', 'B', 'B', 'B']]","solution":"from typing import List def updateBoard(board: List[List[str]], start: List[int]) -> List[List[str]]: def get_adjacent_cells(x, y): for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < len(board) and 0 <= ny < len(board[0]): yield nx, ny def count_mines(x, y): return sum(1 for nx, ny in get_adjacent_cells(x, y) if board[nx][ny] == 'M') def dfs(x, y): if board[x][y] != 'E': return num_mines = count_mines(x, y) if num_mines > 0: board[x][y] = str(num_mines) else: board[x][y] = 'B' for nx, ny in get_adjacent_cells(x, y): dfs(nx, ny) x, y = start if board[x][y] == 'M': return board dfs(x, y) return board"},{"question":"def max_profit(prices): Simulate a simplified stock trading system where you can buy and sell stocks to maximize your profit. You are given a list of daily prices for a single stock. Each element in the list represents the stock price for that day. You may make as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) but you must sell the stock before you buy again. Args: prices (List[int]): List of daily stock prices. Returns: int: The maximum profit you can achieve. Examples: >>> max_profit([7,1,5,3,6,4]) 7 >>> max_profit([1,2,3,4,5]) 4 >>> max_profit([7,6,4,3,1]) 0 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([5, 3, 8, 7, 6, 10]) 9 >>> max_profit([10, 9, 8, 7, 6]) 0 >>> max_profit([3, 3, 3, 3, 3]) 0 >>> max_profit([6, 1, 3, 2, 4, 7]) 7","solution":"def max_profit(prices): Function to calculate the maximum profit from stock prices. if not prices: # If the prices list is empty return 0 max_profit = 0 for i in range(1, len(prices)): # If selling on day i gives a profit, add it to the total max profit if prices[i] > prices[i - 1]: max_profit += prices[i] - prices[i - 1] return max_profit"},{"question":"def max_non_overlapping_regions(N: int, M: int, plants: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping rectangular regions that can fit in the garden. Parameters: N (int): Height of the garden. M (int): Width of the garden. plants (list of tuples): List of tuples where each contains (h_i, w_i) the height and width required for the i-th plant. Returns: int: The maximum number of non-overlapping rectangular regions. >>> max_non_overlapping_regions(4, 4, [(2, 2), (3, 1)]) 4 >>> max_non_overlapping_regions(3, 3, [(1, 1)]) 9 >>> max_non_overlapping_regions(2, 2, [(3, 3)]) 0 >>> max_non_overlapping_regions(6, 6, [(2, 3), (3, 2)]) 6 >>> max_non_overlapping_regions(5, 5, [(1, 5), (5, 1)]) 5 >>> max_non_overlapping_regions(3, 3, [(3, 3)]) 1 >>> max_non_overlapping_regions(6, 4, [(2, 4), (4, 2)]) 3","solution":"def max_non_overlapping_regions(N, M, plants): Returns the maximum number of non-overlapping rectangular regions that can fit in the garden. Parameters: N (int): Height of the garden. M (int): Width of the garden. plants (list of tuples): List of tuples where each contains (h_i, w_i) the height and width required for the i-th plant. Returns: int: The maximum number of non-overlapping rectangular regions. max_regions = 0 for h_i, w_i in plants: if h_i <= N and w_i <= M: max_regions = max(max_regions, (N // h_i) * (M // w_i)) if w_i <= N and h_i <= M: max_regions = max(max_regions, (N // w_i) * (M // h_i)) return max_regions"},{"question":"def sum_of_evens_up_to_k(k: int) -> int: Computes the sum of all even numbers up to and including k. >>> sum_of_evens_up_to_k(4) 6 >>> sum_of_evens_up_to_k(10) 30 >>> sum_of_evens_up_to_k(1) 0 >>> sum_of_evens_up_to_k(20) 110 >>> sum_of_evens_up_to_k(15) 56 pass def process_test_cases(m: int, test_cases: List[int]) -> List[int]: Processes multiple test cases to compute the sum of all even numbers up to each k. >>> process_test_cases(2, [4, 10]) [6, 30] >>> process_test_cases(3, [1, 15, 20]) [0, 56, 110] >>> process_test_cases(1, [1000000000000000000]) [250000000000000000500000000000000000] pass","solution":"def sum_of_evens_up_to_k(k): Computes the sum of all even numbers up to and including k. # Find the largest even number less than or equal to k if k % 2 != 0: k = k - 1 # The largest even number is k, so finding sum of first k/2 even numbers # Sum of first n even numbers is n * (n + 1) n = k // 2 return n * (n + 1) def process_test_cases(m, test_cases): results = [] for k in test_cases: results.append(sum_of_evens_up_to_k(k)) return results"},{"question":"def check_arrangement(N: int, blocks: List[Tuple[int, int, int]]) -> str: Determine if the arrangement of blocks is stable. Parameters: N (int): The number of blocks. blocks (list of tuples): Each tuple represents (width_i, height_i, number_i). Returns: str: \\"Stable\\" if all blocks are sufficiently supported, \\"Unstable\\" otherwise. >>> check_arrangement(3, [(3, 2, 9), (2, 1, 4), (5, 4, 25)]) 'Stable' >>> check_arrangement(2, [(3, 3, 9), (4, 2, 5)]) 'Unstable'","solution":"def is_stable(arrangement): Determine if the arrangement of blocks is stable. Parameters: arrangement (list of tuples): Each tuple represents (width_i, height_i, number_i). Returns: str: \\"Stable\\" if all blocks are sufficiently supported, \\"Unstable\\" otherwise. for width, height, number in arrangement: if height > number / width: return \\"Unstable\\" return \\"Stable\\" # Wrapper function to handle input and output def check_arrangement(N, blocks): return is_stable(blocks)"},{"question":"def max_distinct_potions(N: int, indices: List[int]) -> int: Returns the maximum number of distinct magical indices. Parameters: N : int : number of potions indices : List[int] : list of integers representing magical indices of each potion Returns: int : the maximum number of distinct magical indices >>> max_distinct_potions(6, [4, 3, 2, 4, 5, 3]) 4 >>> max_distinct_potions(5, [1, 2, 3, 4, 5]) 5 >>> max_distinct_potions(4, [2, 2, 2, 2]) 1 >>> max_distinct_potions(6, [10, 20, 10, 30, 30, 20]) 3 >>> max_distinct_potions(1, [42]) 1","solution":"def max_distinct_potions(N, indices): Returns the maximum number of distinct magical indices. Parameters: N : int : number of potions indices : List[int] : list of integers representing magical indices of each potion Returns: int : the maximum number of distinct magical indices distinct_indices = set(indices) return len(distinct_indices)"},{"question":"def student_with_highest_grade(n, student_grade_list): Returns the name of the student with the highest grade. If multiple students have the same highest grade, returns the name of the student who appears first. Parameters: n : int : number of students student_grade_list : list of tuples : each tuple contains the name of the student and their grade Returns: str : name of the student with the highest grade from solution import student_with_highest_grade def test_single_student(): assert student_with_highest_grade(1, [(\\"John\\", 89)]) == \\"John\\" def test_students_with_different_grades(): assert student_with_highest_grade(3, [(\\"John\\", 89), (\\"Alice\\", 95), (\\"Bob\\", 91)]) == \\"Alice\\" def test_students_with_same_highest_grades(): assert student_with_highest_grade(4, [(\\"Derek\\", 77), (\\"Eva\\", 88), (\\"Jake\\", 88), (\\"Sophia\\", 70)]) == \\"Eva\\" def test_students_with_same_grades_diff_positions(): assert student_with_highest_grade(3, [(\\"Jake\\", 92), (\\"Eva\\", 87), (\\"Sophia\\", 92)]) == \\"Jake\\" def test_students_with_all_same_grades(): assert student_with_highest_grade(3, [(\\"John\\", 80), (\\"Alice\\", 80), (\\"Bob\\", 80)]) == \\"John\\"","solution":"def student_with_highest_grade(n, student_grade_list): Returns the name of the student with the highest grade. If multiple students have the same highest grade, returns the name of the student who appears first. Parameters: n : int : number of students student_grade_list : list of tuples : each tuple contains the name of the student and their grade Returns: str : name of the student with the highest grade highest_grade = -1 top_student = '' for student, grade in student_grade_list: if grade > highest_grade: highest_grade = grade top_student = student return top_student"},{"question":"def find_error_position(n: int, a: List[int], b: List[int]) -> int: Find the smallest position k where elements in sequences a and b differ. Returns 0 if there are no differences. >>> find_error_position(5, [10, 20, 30, 40, 50], [10, 25, 30, 40, 50]) 2 >>> find_error_position(4, [1, 2, 3, 4], [1, 2, 3, 5]) 4 >>> find_error_position(3, [7, 8, 9], [7, 8, 9]) 0","solution":"def find_error_position(n, a, b): Finds the smallest position k where elements in sequences a and b differ. Returns 0 if there are no differences. for k in range(n): if a[k] != b[k]: return k + 1 return 0"},{"question":"def manage_list(n: int, operations: List[str]) -> List[str]: Manage a list of unique integers with given operations and return the output of the type 3 operations as a list of strings. Parameters: - n: An integer representing the number of operations. - operations: A list of strings where each string represents an operation. Returns: - A list of strings where each string is the output of the type 3 operations sorted in ascending order or \\"EMPTY\\". Example: >>> manage_list(6, [\\"1 5\\", \\"1 3\\", \\"1 5\\", \\"3\\", \\"2 3\\", \\"3\\"]) [\\"3 5\\", \\"5\\"] >>> manage_list(4, [\\"1 7\\", \\"1 9\\", \\"2 7\\", \\"3\\"]) [\\"9\\"] >>> manage_list(5, [\\"1 10\\", \\"1 2\\", \\"2 2\\", \\"2 10\\", \\"3\\"]) [\\"EMPTY\\"] def final_state_of_list(n: int, operations: List[str]) -> str: Return the final state of the list after performing all the operations, sorted in ascending order. Parameters: - n: An integer representing the number of operations. - operations: A list of strings where each string represents an operation. Returns: - A string representing the final state of the list sorted in ascending order or \\"EMPTY\\". Example: >>> final_state_of_list(6, [\\"1 5\\", \\"1 3\\", \\"1 5\\", \\"3\\", \\"2 3\\", \\"3\\"]) \\"5\\" >>> final_state_of_list(4, [\\"1 7\\", \\"1 9\\", \\"2 7\\", \\"3\\"]) \\"9\\" >>> final_state_of_list(5, [\\"1 10\\", \\"1 2\\", \\"2 2\\", \\"2 10\\", \\"3\\"]) \\"EMPTY\\"","solution":"def manage_list(n, operations): elements = set() result = [] for operation in operations: op = operation.split() if op[0] == '1': elements.add(int(op[1])) elif op[0] == '2': elements.discard(int(op[1])) elif op[0] == '3': current_list = sorted(elements) if current_list: result.append(\\" \\".join(map(str, current_list))) else: result.append(\\"EMPTY\\") return result def final_state_of_list(n, operations): elements = set() for operation in operations: op = operation.split() if op[0] == '1': elements.add(int(op[1])) elif op[0] == '2': elements.discard(int(op[1])) final_list = sorted(elements) return \\" \\".join(map(str, final_list)) if final_list else \\"EMPTY\\""},{"question":"def can_distribute_bottles(n, m, bottles): Determines if it's possible to distribute exactly one bottle to each pharmacy from the batch without repeating the same serial number. :param n: Number of bottles :param m: Number of pharmacies :param bottles: List of tuples where each tuple contains (number of pills, serial number) :return: \\"YES\\" if possible, otherwise \\"NO\\" Examples: >>> can_distribute_bottles(5, 3, [(10, 1001), (20, 1002), (15, 1003), (18, 1004), (25, 1002)]) \\"NO\\" >>> can_distribute_bottles(3, 3, [(8, 2001), (12, 2002), (30, 2003)]) \\"YES\\" from solution import can_distribute_bottles def test_case_1(): n, m = 5, 3 bottles = [(10, 1001), (20, 1002), (15, 1003), (18, 1004), (25, 1002)] assert can_distribute_bottles(n, m, bottles) == \\"NO\\" def test_case_2(): n, m = 3, 3 bottles = [(8, 2001), (12, 2002), (30, 2003)] assert can_distribute_bottles(n, m, bottles) == \\"YES\\" def test_case_3(): n, m = 4, 4 bottles = [(5, 5001), (10, 5002), (15, 5003), (20, 5004)] assert can_distribute_bottles(n, m, bottles) == \\"YES\\" def test_case_4(): n, m = 4, 5 bottles = [(5, 5001), (10, 5002), (15, 5003), (20, 5004)] assert can_distribute_bottles(n, m, bottles) == \\"NO\\" def test_case_5(): n, m = 5, 5 bottles = [(5, 5001), (10, 5002), (15, 5002), (20, 5003), (25, 5004)] assert can_distribute_bottles(n, m, bottles) == \\"NO\\" def test_case_6(): n, m = 1, 1 bottles = [(5, 1001)] assert can_distribute_bottles(n, m, bottles) == \\"YES\\" def test_case_7(): n, m = 2, 2 bottles = [(5, 1001), (5, 1002)] assert can_distribute_bottles(n, m, bottles) == \\"YES\\"","solution":"def can_distribute_bottles(n, m, bottles): Determines if it's possible to distribute exactly one bottle to each pharmacy from the batch without repeating the same serial number. :param n: Number of bottles :param m: Number of pharmacies :param bottles: List of tuples where each tuple contains (number of pills, serial number) :return: \\"YES\\" if possible, otherwise \\"NO\\" serial_numbers = set() for pills, serial_number in bottles: if serial_number in serial_numbers: return \\"NO\\" serial_numbers.add(serial_number) return \\"YES\\" if len(bottles) == m else \\"NO\\""},{"question":"def max_significance_value(test_cases): Find the maximum total significance value of flowers in the garden for each test case while ensuring no two adjacent flowers hold the same significance value. >>> max_significance_value([[3, [3, 2, 5], [4, 6, 3], [7, 8, 9]]]) [20] >>> max_significance_value([[2, [5, 6, 7], [8, 9, 10]]]) [16] pass def parse_input(input_data): Parse the input data into the necessary format for processing. >>> parse_input(\\"1n3n3 2 5n4 6 3n7 8 9\\") [[3, [3, 2, 5], [4, 6, 3], [7, 8, 9]]] pass def main(input_data): Main function to execute the processing of given input data. >>> main(\\"1n3n3 2 5n4 6 3n7 8 9\\") 20 pass import pytest def test_max_significance_value_single_test_case(): input_data = \\"1n3n3 2 5n4 6 3n7 8 9\\" test_cases = parse_input(input_data) assert max_significance_value(test_cases) == [20] def test_max_significance_value_multiple_test_cases(): input_data = \\"2n3n3 2 5n4 6 3n7 8 9n2n5 6 7n8 9 10\\" test_cases = parse_input(input_data) assert max_significance_value(test_cases) == [20, 16] def test_max_significance_value_min_values(): input_data = \\"1n1n1 2 3\\" test_cases = parse_input(input_data) assert max_significance_value(test_cases) == [3] def test_max_significance_value_limit_values(): input_data = \\"1n3n1000 1000 1000n1000 1000 1000n1000 1000 1000\\" test_cases = parse_input(input_data) assert max_significance_value(test_cases) == [3000] def test_parse_input(): input_data = \\"1n3n3 2 5n4 6 3n7 8 9\\" parsed_data = parse_input(input_data) assert parsed_data == [[3, [3, 2, 5], [4, 6, 3], [7, 8, 9]]] def test_main(capsys): input_data = \\"1n3n3 2 5n4 6 3n7 8 9\\" main(input_data) captured = capsys.readouterr() assert captured.out == \\"20n\\"","solution":"def max_significance_value(test_cases): results = [] for case in test_cases: N = case[0] flowers = case[1:] dp = [[0] * 3 for _ in range(N)] dp[0][0] = flowers[0][0] dp[0][1] = flowers[0][1] dp[0][2] = flowers[0][2] for i in range(1, N): dp[i][0] = flowers[i][0] + max(dp[i-1][1], dp[i-1][2]) dp[i][1] = flowers[i][1] + max(dp[i-1][0], dp[i-1][2]) dp[i][2] = flowers[i][2] + max(dp[i-1][0], dp[i-1][1]) results.append(max(dp[N-1])) return results def parse_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) flowers = [] for j in range(N): flowers.append(list(map(int, lines[index + j + 1].strip().split()))) test_cases.append([N] + flowers) index += N + 1 return test_cases def main(input_data): test_cases = parse_input(input_data) results = max_significance_value(test_cases) for result in results: print(result)"},{"question":"def calculate_shortest_distances(M: int, N: int, grid: List[str], r: int, c: int) -> List[Tuple[int, int, int]]: Calculates the shortest distances from the specified building to all other blocks in the same row and column based on Manhattan Distance. Args: M (int): number of rows in the grid N (int): number of columns in the grid grid (List[str]): the M x N grid where each element is a string representing a row of blocks; 'B' represents a building, and '.' represents an open space. r (int): the row index of the specific building c (int): the column index of the specific building Returns: List[Tuple[int, int, int]]: A list of tuples where each tuple contains the coordinates of a block (i, j) and the shortest Manhattan distance from the building (i.e., (i, j, distance)). from typing import List, Tuple","solution":"def calculate_shortest_distances(M, N, grid, r, c): Calculates the shortest distances from the specified building to all other blocks in the same row and column. M: int - number of rows in the grid N: int - number of columns in the grid grid: list of strings - M x N grid r: int - row index of the building c: int - column index of the building result = [] # Calculate distances for the same row for j in range(N): result.append((r, j, abs(j - c))) # Calculate distances for the same column for i in range(M): if i != r: result.append((i, c, abs(i - r))) return result"},{"question":"def is_valid_book_code(code: str) -> bool: Checks if a given book code is valid according to the specified rules: 1. The code must be exactly 8 characters long. 2. The code must start with two capital letters. 3. The next four characters must be digits. 4. The last two characters must be lowercase letters. Parameters: code (str): The book code Returns: bool: True if the code is valid, False otherwise. >>> is_valid_book_code(\\"AB1234cd\\") True >>> is_valid_book_code(\\"XY5678ef\\") True >>> is_valid_book_code(\\"ABC1234d\\") False >>> is_valid_book_code(\\"ab1234cd\\") False >>> is_valid_book_code(\\"AB12cd34\\") False","solution":"def is_valid_book_code(code): Checks if a given book code is valid according to the specified rules: 1. The code must be exactly 8 characters long. 2. The code must start with two capital letters. 3. The next four characters must be digits. 4. The last two characters must be lowercase letters. Parameters: code (str): The book code. Returns: bool: True if the code is valid, False otherwise. if len(code) != 8: return False if not code[:2].isupper(): return False if not code[2:6].isdigit(): return False if not code[6:].islower(): return False return True"},{"question":"def max_packages_on_belt(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the maximum number of packages that can be placed on the conveyor belt without exceeding the weight limit for each test case. Args: T: The number of test cases. test_cases: A list of tuples, each representing a test case. Each tuple contains: - M: The number of packages. - L: The maximum weight limit of the belt. - weights: A list of integers representing the weights of the packages. Returns: A list of integers, each representing the maximum number of packages that can be placed on the conveyor belt without exceeding the weight limit for each test case. Examples: >>> max_packages_on_belt(2, [(5, 10, [1, 2, 3, 4, 5]), (4, 15, [5, 5, 5, 5])]) [4, 3] >>> max_packages_on_belt(1, [(3, 6, [2, 2, 2])]) [3]","solution":"def max_packages_on_belt(T, test_cases): results = [] for case in test_cases: M, L, weights = case current_weight = 0 count = 0 for weight in weights: if current_weight + weight > L: break current_weight += weight count += 1 results.append(count) return results"},{"question":"class TreeNode: A tree node that contains an integer value, and left and right children. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(arr): Given a sorted array of integers, create a balanced binary search tree (BST) and return its root. pass def create_balanced_bst(arr): Given an array of integers, sort it and create a balanced binary search tree (BST) and return its root. pass # Unit Test def test_create_balanced_bst(): def inorder_traversal(root): if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) bst = create_balanced_bst([3, 1, 2]) assert inorder_traversal(bst) == [1, 2, 3] bst = create_balanced_bst([-3, -10, 0, 5, 9]) def is_balanced(root): if not root: return True, 0 left_balanced, left_height = is_balanced(root.left) right_balanced, right_height = is_balanced(root.right) return (left_balanced and right_balanced and abs(left_height - right_height) <= 1), max(left_height, right_height) + 1 balanced, _ = is_balanced(bst) assert balanced bst = create_balanced_bst([1, 2, 3, 4, 5, 6, 7]) balanced, _ = is_balanced(bst) assert balanced bst = create_balanced_bst([1]) assert bst.val == 1 assert bst.left == None assert bst.right == None bst = create_balanced_bst([1, 2, 2, 3, 4, 4, 5]) balanced, _ = is_balanced(bst) assert balanced","solution":"class TreeNode: A tree node that contains an integer value, and left and right children. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sorted_array_to_bst(arr): Given a sorted array of integers, create a balanced binary search tree (BST) and return its root. if not arr: return None mid = len(arr) // 2 root = TreeNode(arr[mid]) root.left = sorted_array_to_bst(arr[:mid]) root.right = sorted_array_to_bst(arr[mid + 1:]) return root def create_balanced_bst(arr): Given an array of integers, sort it and create a balanced binary search tree (BST) and return its root. sorted_arr = sorted(arr) return sorted_array_to_bst(sorted_arr)"},{"question":"def perfect_squares(start: int, end: int) -> list[int]: Returns a list of perfect square numbers between start and end (inclusive). Parameters: start (int): The start of the range. end (int): The end of the range. Returns: list: A list of perfect square numbers between start and end. >>> perfect_squares(1, 20) [1, 4, 9, 16] >>> perfect_squares(20, 24) [] >>> perfect_squares(4, 4) [4] >>> perfect_squares(5, 5) [] >>> perfect_squares(1, 100) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] >>> perfect_squares(0, 1) [0, 1] >>> perfect_squares(90, 225) [100, 121, 144, 169, 196, 225] >>> perfect_squares(36, 50) [36, 49]","solution":"import math def perfect_squares(start, end): Returns a list of perfect square numbers between start and end (inclusive). Parameters: start (int): The start of the range. end (int): The end of the range. Returns: list: A list of perfect square numbers between start and end. squares = [] for num in range(start, end + 1): if math.isqrt(num)**2 == num: squares.append(num) return squares"},{"question":"def subset_sum_zero_exists(n: int, array: List[int]) -> str: Check if there exists a subset of the given list whose sum is zero. >>> subset_sum_zero_exists(5, [1, 2, -3, 4, 5]) \\"YES\\" >>> subset_sum_zero_exists(4, [-1, 1, -1, 1]) \\"YES\\" >>> subset_sum_zero_exists(3, [2, 3, 9]) \\"NO\\" def solve(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Solve the problem for a given list of test cases. >>> solve([(5, [1, 2, -3, 4, 5]), (4, [-1, 1, -1, 1]), (3, [2, 3, 9])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve([(6, [1, 2, 3, -3, -2, -1]), (1, [0])]) [\\"YES\\", \\"YES\\"] from typing import List, Tuple def test_subset_sum_zero_exists(): assert subset_sum_zero_exists(5, [1, 2, -3, 4, 5]) == \\"YES\\" assert subset_sum_zero_exists(4, [-1, 1, -1, 1]) == \\"YES\\" assert subset_sum_zero_exists(3, [2, 3, 9]) == \\"NO\\" assert subset_sum_zero_exists(6, [1, 2, 3, -3, -2, -1]) == \\"YES\\" assert subset_sum_zero_exists(1, [0]) == \\"YES\\" assert subset_sum_zero_exists(1, [10]) == \\"NO\\" def test_solve(): test_cases = [ (5, [1, 2, -3, 4, 5]), (4, [-1, 1, -1, 1]), (3, [2, 3, 9]) ] assert solve(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] test_cases = [ (6, [1, 2, 3, -3, -2, -1]), (1, [0]) ] assert solve(test_cases) == [\\"YES\\", \\"YES\\"]","solution":"def subset_sum_zero_exists(n, array): Function to check if there's a subset of the array that sums to zero. # Create a set to store the prefix sums prefix_sums = set() current_sum = 0 for number in array: current_sum += number # If the current sum is zero or we have seen this sum before if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) # If no subset with sum zero found return \\"NO\\" def solve(test_cases): results = [] for case in test_cases: n, array = case results.append(subset_sum_zero_exists(n, array)) return results"},{"question":"def max_candies(grid): Returns the maximum number of candies that can be collected from the top-left corner to the bottom-right corner of the grid. >>> max_candies([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_candies([[5]]) 5 >>> max_candies([[1, 2], [3, 4]]) 8 >>> max_candies([[1, 2, 3, 4]]) 10 >>> max_candies([[1], [2], [3], [4]]) 10 >>> max_candies([[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) 5000","solution":"def max_candies(grid): Returns the maximum number of candies that can be collected from the top-left corner to the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Create a dp table of the same dimensions as grid to store the maximum candies upto each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Calculate the maximum candies for the rest of the cells for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the maximum candies collected return dp[n - 1][m - 1]"},{"question":"from typing import List def longest_substring_distinct_chars(s: str) -> int: Create a function \`longest_substring_distinct_chars(s: str) -> int\` that takes a string \`s\` as input and returns the length of the longest substring that contains no repeating characters. >>> longest_substring_distinct_chars(\\"abcabcbb\\") == 3 >>> longest_substring_distinct_chars(\\"bbbbb\\") == 1 >>> longest_substring_distinct_chars(\\"pwwkew\\") == 3 >>> longest_substring_distinct_chars(\\"abcdabcd\\") == 4 >>> longest_substring_distinct_chars(\\"aabbcc\\") == 2 >>> longest_substring_distinct_chars(\\"abrkaabcdefghijjxxx\\") == 10 # Edge cases >>> longest_substring_distinct_chars(\\"\\") == 0 >>> longest_substring_distinct_chars(\\"a\\") == 1 >>> longest_substring_distinct_chars(\\"abcdef\\") == 6 >>> longest_substring_distinct_chars(\\"aabbccddeeff\\") == 2","solution":"def longest_substring_distinct_chars(s: str) -> int: Returns the length of the longest substring with all distinct characters. if not s: return 0 start = 0 max_length = 0 char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def two_sum(nums, target): Find two indices such that nums[i] + nums[j] == target and return i, j. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([-1, 0], -1) (0, 1) lookup = {} for index, num in enumerate(nums): if target - num in lookup: return lookup[target - num], index lookup[num] = index def solve(test_cases): Solve multiple test cases, each with an array of integers and a target sum. >>> solve([(4, 9, [2, 7, 11, 15]), (3, 6, [3, 2, 4]), (2, -1, [-1, 0])]) [(0, 1), (1, 2), (0, 1)] results = [] for n, target, nums in test_cases: result = two_sum(nums, target) results.append(result) return results def main(): Read the number of test cases and then each test case, print the two indices for each case. Example input: >>> input 3 4 9 2 7 11 15 3 6 3 2 4 2 -1 -1 0 Expected output: >>> output 0 1 1 2 0 1 import sys input = sys.stdin.read data = input().strip().split('n') t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n, target = map(int, data[index].split()) nums = list(map(int, data[index + 1].split())) test_cases.append((n, target, nums)) index += 2 results = solve(test_cases) for res in results: print(res[0], res[1])","solution":"def two_sum(nums, target): lookup = {} for index, num in enumerate(nums): if target - num in lookup: return lookup[target - num], index lookup[num] = index def solve(test_cases): results = [] for n, target, nums in test_cases: result = two_sum(nums, target) results.append(result) return results # Parsing and formatting solution to fit input and output format def main(): t = int(input().strip()) test_cases = [] for _ in range(t): n, target = map(int, input().split()) nums = list(map(int, input().split())) test_cases.append((n, target, nums)) results = solve(test_cases) for res in results: print(res[0], res[1])"},{"question":"from typing import List def shallowest_path(matrix: List[List[int]]) -> int: Find the sum of depths along the shallowest path from the top-left corner to the bottom-right corner. The path can only move right or down. Args: matrix (List[List[int]]): A 2D list of integers representing the depth map. Returns: int: The sum of depths along the shallowest path. Examples: >>> matrix = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> shallowest_path(matrix) 7 >>> matrix = [[5]] >>> shallowest_path(matrix) 5 >>> matrix = [ ... [1, 2, 3] ... ] >>> shallowest_path(matrix) 6 >>> matrix = [ ... [1], ... [2], ... [3] ... ] >>> shallowest_path(matrix) 6 >>> matrix = [ ... [1, 3, 1, 4], ... [1, 5, 1, 2], ... [4, 2, 1, 0], ... [3, 2, 1, 1] ... ] >>> shallowest_path(matrix) 8 >>> matrix = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ] >>> shallowest_path(matrix) 5","solution":"from typing import List def shallowest_path(matrix: List[List[int]]) -> int: if not matrix or not matrix[0]: return 0 n, m = len(matrix), len(matrix[0]) # Initialize a 2D dp array to store the minimum depth path sum up to each point dp = [[0]*m for _ in range(n)] dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left cell) for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from the top cell) for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[n-1][m-1]"},{"question":"def activity_segments(t: int, users: List[str]) -> List[str]: For each user, calculate the lengths of the consecutive segments of activity or inactivity. :param t: Number of users :param users: List of binary strings representing activity and inactivity for each user :return: List of strings where each string contains lengths of consecutive segments for each user >>> activity_segments(3, [\\"AAAIIIIA\\", \\"AIAIAI\\", \\"AAAAA\\"]) ['3 4 1', '1 1 1 1 1 1', '5'] pass","solution":"def activity_segments(t, users): For each user, calculate the lengths of the consecutive segments of activity or inactivity. :param t: Number of users :param users: List of binary strings representing activity and inactivity for each user :return: List of strings where each string contains lengths of consecutive segments for each user results = [] for s in users: segments = [] current_segment_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_segment_length += 1 else: segments.append(str(current_segment_length)) current_segment_length = 1 segments.append(str(current_segment_length)) results.append(\\" \\".join(segments)) return results # Example usage: # t = 3 # users = [\\"AAAIIIIA\\", \\"AIAIAI\\", \\"AAAAA\\"] # print(activity_segments(t, users)) # Output: ['3 4 1', '1 1 1 1 1 1', '5']"},{"question":"def final_score(S: int, operations: List[str]) -> int: Determines the final score after performing all the given operations. Parameters: S (int): Initial score. operations (list of str): List of operations in the form \\"increase X\\" or \\"decrease X\\". Returns: int: Final score after all operations. >>> final_score(100, [\\"increase 50\\", \\"decrease 20\\", \\"increase 30\\"]) 160 >>> final_score(500, [\\"increase 150\\", \\"decrease 300\\", \\"increase 50\\"]) 400 >>> final_score(800, [\\"decrease 100\\", \\"decrease 200\\", \\"increase 500\\"]) 1000 >>> final_score(1000, [\\"increase 999\\", \\"decrease 500\\", \\"decrease 999\\"]) 500 >>> final_score(10, [\\"increase 10\\", \\"decrease 15\\", \\"increase 5\\"]) 10 >>> final_score(1, [\\"decrease 1\\"]) 0 >>> final_score(1, []) 1","solution":"def final_score(S, operations): Determines the final score after performing all the given operations. Parameters: S (int): Initial score. operations (list of str): List of operations in the form \\"increase X\\" or \\"decrease X\\". Returns: int: Final score after all operations. for operation in operations: command, value = operation.split() value = int(value) if command == \\"increase\\": S += value elif command == \\"decrease\\": S -= value return S"},{"question":"def separate_numbers_and_letters(s: str) -> str: Separates the numbers and letters in the input string \`s\` such that all numbers come before the letters while preserving their relative order. >>> separate_numbers_and_letters(\\"a1b2c3d4\\") \\"1234abcd\\" >>> separate_numbers_and_letters(\\"e5f6g7h8\\") \\"5678efgh\\" >>> separate_numbers_and_letters(\\"4k3j2h1g\\") \\"4321kjhg\\" def test_separate_numbers_and_letters(): assert separate_numbers_and_letters(\\"a1b2c3d4\\") == \\"1234abcd\\" assert separate_numbers_and_letters(\\"e5f6g7h8\\") == \\"5678efgh\\" assert separate_numbers_and_letters(\\"4k3j2h1g\\") == \\"4321kjhg\\" assert separate_numbers_and_letters(\\"z1y2x3w4\\") == \\"1234zyxw\\" assert separate_numbers_and_letters(\\"4a3b2c1d\\") == \\"4321abcd\\" assert separate_numbers_and_letters(\\"a1z2e3r4t9y8\\") == \\"123498azerty\\" assert separate_numbers_and_letters(\\"1a2b3c\\") == \\"123abc\\" def test_edge_cases(): assert separate_numbers_and_letters(\\"1a\\") == \\"1a\\" assert separate_numbers_and_letters(\\"a1\\") == \\"1a\\" assert separate_numbers_and_letters(\\"0a\\") == \\"0a\\" assert separate_numbers_and_letters(\\"a\\") == \\"a\\" assert separate_numbers_and_letters(\\"1\\") == \\"1\\"","solution":"def separate_numbers_and_letters(s): Separates the numbers and letters in the input string \`s\` such that all numbers come before the letters while preserving their relative order. numbers = ''.join([char for char in s if char.isdigit()]) letters = ''.join([char for char in s if char.isalpha()]) return numbers + letters"},{"question":"def longest_increasing_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest subsequence of sales that is strictly increasing for a series of test cases. Parameters: - T: int, the number of test cases. - test_cases: List[Tuple[int, List[int]]], a list where each tuple contains two elements: - an integer N, the number of elements in the sales records. - a list of N space-separated integers, the sales records for that time period. Returns: - List[int], a list containing the length of the longest increasing subsequence for each test case. >>> longest_increasing_subsequence(2, [(6, [10, 22, 9, 33, 21, 50]), (5, [3, 10, 2, 1, 20])]) [4, 3] >>> longest_increasing_subsequence(2, [(1, [1]), (1, [100])]) [1, 1] >>> longest_increasing_subsequence(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> longest_increasing_subsequence(1, [(5, [5, 4, 3, 2, 1])]) [1] >>> longest_increasing_subsequence(1, [(9, [1, 7, 3, 5, 9, 2, 6, 4, 8])]) [5] >>> longest_increasing_subsequence(1, [(7, [5, 5, 5, 5, 5, 5, 5])]) [1]","solution":"def longest_increasing_subsequence(T, test_cases): def lis_length(arr): if not arr: return 0 dp = [arr[0]] for num in arr[1:]: if num > dp[-1]: dp.append(num) else: # Binary search to find the smallest element >= num left, right = 0, len(dp) - 1 while left < right: mid = (left + right) // 2 if dp[mid] < num: left = mid + 1 else: right = mid dp[left] = num return len(dp) results = [] for case in test_cases: N, sales_records = case result = lis_length(sales_records) results.append(result) return results"},{"question":"from typing import List def can_construct(word: str, source_word: str) -> bool: Check if 'word' can be constructed from 'source_word' by ensuring each character in 'word' is present in 'source_word' with at least the same frequency. pass def find_longest_constructible_word(source_word: str, words: List[str]) -> str: Return the longest word that can be constructed using letters of 'source_word'. If there are multiple longest words, return the one that appears first in the list. >>> find_longest_constructible_word(\\"abppplee\\", [\\"able\\", \\"ale\\", \\"apple\\", \\"kangaroo\\", \\"bale\\"]) == \\"apple\\" >>> find_longest_constructible_word(\\"abppplee\\", [\\"ale\\", \\"bale\\", \\"able\\"]) == \\"able\\" >>> find_longest_constructible_word(\\"xyz\\", [\\"cat\\", \\"dog\\", \\"fish\\"]) == \\"\\" pass","solution":"def can_construct(word, source_word): Check if 'word' can be constructed from 'source_word' by ensuring each character in 'word' is present in 'source_word' with at least the same frequency. from collections import Counter word_count = Counter(word) source_count = Counter(source_word) for char in word_count: if word_count[char] > source_count.get(char, 0): return False return True def find_longest_constructible_word(source_word, words): Return the longest word that can be constructed using letters of 'source_word'. If there are multiple longest words, return the one that appears first in the list. longest_word = \\"\\" for word in words: if can_construct(word, source_word): if len(word) > len(longest_word): longest_word = word elif len(word) == len(longest_word): longest_word = word # In case of a tie, the first appearing word in the list will naturally be kept return longest_word # Taking input if __name__ == \\"__main__\\": source_word = input().strip() n = int(input().strip()) words = [input().strip() for _ in range(n)] result = find_longest_constructible_word(source_word, words) print(result)"},{"question":"def find_cleanest_plate(test_cases): Given a series of stacks filled with plates, each labeled with a cleanliness level, return the cleanliness level of the cleanest plate across all the stacks for each test case. :param test_cases: List of test cases, each test case is a tuple where the first item is the number of stacks, and the second item is a list of stacks. :return: List of cleanliness levels of the cleanest plate for each test case. pass def parse_input(input_str): Parse the input string and return the test cases. :param input_str: Input string based on the problem statement. :return: List of test cases extracted from the given input string. pass def solve(input_str): Parse the input string, determine the cleanliness level of the cleanest plate across all stacks, and print the result for each test case. :param input_str: Input string based on the problem statement. pass import pytest from solution import find_cleanest_plate, parse_input, solve def test_find_cleanest_plate_single_case(): test_cases = [(3, [[3, 5, 1, 9], [2, 3, 8], [4, 7, 6, 2, 4]])] assert find_cleanest_plate(test_cases) == [9] def test_find_cleanest_plate_multiple_cases(): test_cases = [ (3, [[3, 5, 1, 9], [2, 3, 8], [4, 7, 6, 2, 4]]), (2, [[1, 1], [1, 2]]) ] assert find_cleanest_plate(test_cases) == [9, 2] def test_parse_input_single_case(): input_str = \\"1n3n3 5 1 9n2 3 8n4 7 6 2 4n\\" expected_result = [(3, [[3, 5, 1, 9], [2, 3, 8], [4, 7, 6, 2, 4]])] assert parse_input(input_str) == expected_result def test_parse_input_multiple_cases(): input_str = \\"2n3n3 5 1 9n2 3 8n4 7 6 2 4n2n1 1n1 2n\\" expected_result = [ (3, [[3, 5, 1, 9], [2, 3, 8], [4, 7, 6, 2, 4]]), (2, [[1, 1], [1, 2]]) ] assert parse_input(input_str) == expected_result def test_solve(capsys): input_str = \\"1n3n3 5 1 9n2 3 8n4 7 6 2 4n\\" solve(input_str) captured = capsys.readouterr() assert captured.out == \\"9n\\" input_str = \\"2n3n3 5 1 9n2 3 8n4 7 6 2 4n2n1 1n1 2n\\" solve(input_str) captured = capsys.readouterr() assert captured.out == \\"9n2n\\" pytest.main()","solution":"def find_cleanest_plate(test_cases): Given a series of stacks filled with plates, each labeled with a cleanliness level, return the cleanliness level of the cleanest plate across all the stacks for each test case. :param test_cases: List of test cases, each test case is a tuple where the first item is the number of stacks, and the second item is a list of stacks. :return: List of cleanliness levels of the cleanest plate for each test case. results = [] for test_case in test_cases: stacks = test_case[1] cleanest = 0 for stack in stacks: plates = stack[1:] # The first number is the count of plates cleanest = max(cleanest, max(plates)) results.append(cleanest) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines.pop(0)) index = 0 test_cases = [] for _ in range(T): S = int(lines[index]) stacks = [] for i in range(1, S + 1): stacks.append(list(map(int, lines[index + i].split()))) index += S + 1 test_cases.append((S, stacks)) return test_cases def solve(input_str): test_cases = parse_input(input_str) results = find_cleanest_plate(test_cases) for result in results: print(result)"},{"question":"def autonomous_vehicles_inc(T: int, test_cases: List[Dict[str, Any]]) -> List[str]: Determines if a car can travel from a start position to an end position on a grid-based map without encountering obstacles. Parameters: T: int - The number of test cases. test_cases: List[Dict[str, Any]] - The list of test cases, where each test case contains: - dimensions: A tuple (M, N) representing the dimensions of the grid. - grid: A list of strings representing the grid where '.' indicates a free cell and '#' indicates an obstacle. - positions: A tuple (S_r, S_c, E_r, E_c) representing the starting and ending positions. Returns: List[str] - For each test case, returns \\"YES\\" if there is a path from the starting position to the destination, and \\"NO\\" otherwise. Example: >>> autonomous_vehicles_inc(2, [ { \\"dimensions\\": (3, 4), \\"grid\\": [ \\"....\\", \\"..#.\\", \\"....\\" ], \\"positions\\": (1, 1, 3, 4) }, { \\"dimensions\\": (3, 4), \\"grid\\": [ \\"....\\", \\"\\", \\"....\\" ], \\"positions\\": (1, 1, 3, 4) } ]) ['YES', 'NO'] # Unit Test Example from solution import autonomous_vehicles_inc def test_path_exists(): test_cases = [ { \\"dimensions\\": (3, 4), \\"grid\\": [ \\"....\\", \\"..#.\\", \\"....\\" ], \\"positions\\": (1, 1, 3, 4) }, { \\"dimensions\\": (3, 4), \\"grid\\": [ \\"....\\", \\"\\", \\"....\\" ], \\"positions\\": (1, 1, 3, 4) } ] results = autonomous_vehicles_inc(2, test_cases) assert results == [\\"YES\\", \\"NO\\"] def test_complete_blocked_path(): test_cases = [ { \\"dimensions\\": (2, 2), \\"grid\\": [ \\".#\\", \\"#.\\" ], \\"positions\\": (1, 1, 2, 2) } ] results = autonomous_vehicles_inc(1, test_cases) assert results == [\\"NO\\"] def test_simple_path(): test_cases = [ { \\"dimensions\\": (2, 3), \\"grid\\": [ \\"#\\", \\"..#\\" ], \\"positions\\": (2, 1, 2, 3) } ] results = autonomous_vehicles_inc(1, test_cases) assert results == [\\"NO\\"] def test_large_open_path(): test_cases = [ { \\"dimensions\\": (3, 3), \\"grid\\": [ \\"...\\", \\"...\\", \\"...\\" ], \\"positions\\": (1, 1, 3, 3) } ] results = autonomous_vehicles_inc(1, test_cases) assert results == [\\"YES\\"] def test_start_equals_end(): test_cases = [ { \\"dimensions\\": (3, 3), \\"grid\\": [ \\".#.\\", \\"...\\", \\".#.\\" ], \\"positions\\": (2, 2, 2, 2) } ] results = autonomous_vehicles_inc(1, test_cases) assert results == [\\"YES\\"]","solution":"def can_travel(grid, start, end): from collections import deque M = len(grid) N = len(grid[0]) if M > 0 else 0 visited = [[False] * N for _ in range(M)] def is_valid(x, y): return 0 <= x < M and 0 <= y < N and grid[x][y] == '.' and not visited[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() if (x, y) == end: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): visited[nx][ny] = True queue.append((nx, ny)) return \\"NO\\" def autonomous_vehicles_inc(T, test_cases): results = [] for t in range(T): M, N = test_cases[t]['dimensions'] grid = test_cases[t]['grid'] S_r, S_c, E_r, E_c = test_cases[t]['positions'] start = (S_r - 1, S_c - 1) end = (E_r - 1, E_c - 1) results.append(can_travel(grid, start, end)) return results"},{"question":"def dijkstra(n, edges, start): Finds the shortest paths from the starting vertex to all other vertices in a weighted undirected graph using Dijkstra's algorithm. Args: n (int): The number of vertices in the graph. edges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (u, v, w) representing an edge between vertices u and v with weight w. start (int): The starting vertex. Returns: List[str]: A list of strings where each string is either the length of the shortest path from the starting vertex to a vertex or \\"INF\\" if there is no path. Example: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 5, 1)], 1) ['2', '3', 'INF', '6']","solution":"import heapq def dijkstra(n, edges, start): # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Undirected graph # Distance and previous vertex arrays dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 prev = {i: None for i in range(1, n + 1)} # Priority queue to hold the vertices to explore pq = [(0, start)] # (distance, vertex) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u]: alt = current_dist + weight if alt < dist[v]: dist[v] = alt prev[v] = u heapq.heappush(pq, (alt, v)) result = [] for i in range(1, n + 1): if i != start: result.append(str(dist[i]) if dist[i] != float('inf') else \\"INF\\") return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(values): Build a binary tree from a list of values in level-order traversal format. >>> build_tree_from_list([1, 2, 3, None, 4]) TreeNode(1, TreeNode(2, None, TreeNode(4)), TreeNode(3)) if not values: return None root = TreeNode(values[0]) queue = [root] i = 1 while i < len(values): current = queue.pop(0) if values[i] is not None: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] is not None: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def sum_of_values_greater_than_k(root, k): Find the total sum of values of all nodes within the tree where the node value is greater than or equal to 'k'. >>> root = build_tree_from_list([5, 3, 8, 1, 4, 7, 9]) >>> sum_of_values_greater_than_k(root, 5) 29 >>> root = build_tree_from_list([20, 10, 30, 5, None, None, 35]) >>> sum_of_values_greater_than_k(root, 15) 85 if not root: return 0 queue = [root] total_sum = 0 while queue: node = queue.pop(0) if node.val >= k: total_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return total_sum","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree_from_list(values): if not values: return None root = TreeNode(values[0]) queue = [root] i = 1 while i < len(values): current = queue.pop(0) if values[i] is not None: current.left = TreeNode(values[i]) queue.append(current.left) i += 1 if i < len(values) and values[i] is not None: current.right = TreeNode(values[i]) queue.append(current.right) i += 1 return root def sum_of_values_greater_than_k(root, k): if not root: return 0 queue = [root] total_sum = 0 while queue: node = queue.pop(0) if node.val >= k: total_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return total_sum"},{"question":"def process_grades(grades): A university wants to manage the grades of their students. They want a program to organize student grades by calculating the highest, lowest, and average scores for each course, as well as the overall highest, lowest, and average scores across all courses. Input: The input consists of multiple lines. Each line contains a course name followed by a student's name and their grade for that course in the following format: <course_name> <student_name> <grade> The course name and student name are strings without spaces, and the grade is a non-negative integer not exceeding 100. The input is terminated by a line containing the word \\"END\\". Output: The output should first display the highest, lowest, and average scores for each course in alphabetical order of the course names. After that, output the overall highest, lowest, and average scores across all courses in the exact format: <course_name>: Highest: <highest_score>, Lowest: <lowest_score>, Average: <average_score> Overall: Highest: <highest_score>, Lowest: <lowest_score>, Average: <average_score> Example: >>> grades = [ ... \\"Math Alice 78\\", ... \\"Math Bob 92\\", ... \\"Science Alice 85\\", ... \\"Science Bob 90\\", ... \\"Math Charlie 88\\", ... \\"Art Alice 95\\", ... \\"END\\" ... ] >>> process_grades(grades) [ \\"Art: Highest: 95, Lowest: 95, Average: 95.00\\", \\"Math: Highest: 92, Lowest: 78, Average: 86.00\\", \\"Science: Highest: 90, Lowest: 85, Average: 87.50\\", \\"Overall: Highest: 95, Lowest: 78, Average: 88.00\\" ] import pytest def test_process_grades(): grades = [ \\"Math Alice 78\\", \\"Math Bob 92\\", \\"Science Alice 85\\", \\"Science Bob 90\\", \\"Math Charlie 88\\", \\"Art Alice 95\\", \\"END\\" ] expected_output = [ \\"Art: Highest: 95, Lowest: 95, Average: 95.00\\", \\"Math: Highest: 92, Lowest: 78, Average: 86.00\\", \\"Science: Highest: 90, Lowest: 85, Average: 87.50\\", \\"Overall: Highest: 95, Lowest: 78, Average: 88.00\\" ] result = process_grades(grades) assert result == expected_output def test_process_grades_single_course(): grades = [ \\"History John 65\\", \\"History Jane 85\\", \\"History Mike 70\\", \\"END\\" ] expected_output = [ \\"History: Highest: 85, Lowest: 65, Average: 73.33\\", \\"Overall: Highest: 85, Lowest: 65, Average: 73.33\\" ] result = process_grades(grades) assert result == expected_output def test_process_grades_single_student(): grades = [ \\"Math Alice 90\\", \\"END\\" ] expected_output = [ \\"Math: Highest: 90, Lowest: 90, Average: 90.00\\", \\"Overall: Highest: 90, Lowest: 90, Average: 90.00\\" ] result = process_grades(grades) assert result == expected_output def test_process_grades_varied(): grades = [ \\"Physics Alice 88\\", \\"Chemistry Bob 92\\", \\"Biology Charlie 85\\", \\"Physics Bob 91\\", \\"Chemistry Alice 89\\", \\"Biology Alice 77\\", \\"END\\" ] expected_output = [ \\"Biology: Highest: 85, Lowest: 77, Average: 81.00\\", \\"Chemistry: Highest: 92, Lowest: 89, Average: 90.50\\", \\"Physics: Highest: 91, Lowest: 88, Average: 89.50\\", \\"Overall: Highest: 92, Lowest: 77, Average: 87.00\\" ] result = process_grades(grades) assert result == expected_output def test_process_grades_no_data(): grades = [\\"END\\"] expected_output = [] result = process_grades(grades) assert result == expected_output pytest.main()","solution":"def process_grades(grades): from collections import defaultdict course_grades = defaultdict(list) for line in grades: if line == \\"END\\": break course, student, grade = line.split() grade = int(grade) course_grades[course].append(grade) results = [] all_grades = [] for course in sorted(course_grades.keys()): grades_list = course_grades[course] highest = max(grades_list) lowest = min(grades_list) average = sum(grades_list) / len(grades_list) all_grades.extend(grades_list) results.append(f\\"{course}: Highest: {highest}, Lowest: {lowest}, Average: {average:.2f}\\") if all_grades: overall_highest = max(all_grades) overall_lowest = min(all_grades) overall_average = sum(all_grades) / len(all_grades) results.append(f\\"Overall: Highest: {overall_highest}, Lowest: {overall_lowest}, Average: {overall_average:.2f}\\") return results"},{"question":"import math from typing import List, Tuple def minimize_farthest_travel_distance(delivery_requests: List[Tuple[int, int]]) -> float: Returns the minimized distance to the farthest house in the optimal delivery plan. :param delivery_requests: List of tuples (x, y) representing the coordinates of houses. :return: Minimized maximum distance as a float rounded to six decimal places. >>> round(minimize_farthest_travel_distance([(3, 4)]), 6) 5.000000 >>> round(minimize_farthest_travel_distance([(3, 4), (-3, -4), (1, 1)]), 6) 5.000000 >>> round(minimize_farthest_travel_distance([(0, 5), (0, 10), (10, 0), (-7, 0), (0, 0)]), 6) 10.000000 >>> round(minimize_farthest_travel_distance([(-5, -5), (-1, -1), (-2, -3)]), 6) 7.071068 >>> round(minimize_farthest_travel_distance([(1e9, 0), (0, 1e9), (-1e9, -1e9)]), 6) 1414213562.373095 pass # implement the function logic here","solution":"import math def minimize_farthest_travel_distance(delivery_requests): Returns the minimized distance to the farthest house in the optimal delivery plan. :param delivery_requests: List of tuples (x, y) representing the coordinates of houses. :return: Minimized maximum distance as a float rounded to six decimal places. max_distance = 0 for x, y in delivery_requests: distance = math.sqrt(x ** 2 + y ** 2) if distance > max_distance: max_distance = distance return round(max_distance, 6) def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) delivery_requests = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(n)] return delivery_requests if __name__ == \\"__main__\\": delivery_requests = read_input() result = minimize_farthest_travel_distance(delivery_requests) print(result)"},{"question":"def longest_subarray_with_sum_at_most_k(test_cases): Determine the length of the longest contiguous subarray that has a sum less than or equal to a given integer k. >>> input_data = \\"2n6 15n1 2 3 4 5 6n4 5n4 1 1 1\\" >>> test_cases = process_input(input_data) >>> longest_subarray_with_sum_at_most_k(test_cases) [5, 3] >>> input_data = \\"1n1 1n1\\" >>> test_cases = process_input(input_data) >>> longest_subarray_with_sum_at_most_k(test_cases) [1] pass def process_input(input_data): Parse the input data and prepare test cases for processing. >>> input_data = \\"2n6 15n1 2 3 4 5 6n4 5n4 1 1 1\\" >>> process_input(input_data) [((6, 15), [1, 2, 3, 4, 5, 6]), ((4, 5), [4, 1, 1, 1])] pass","solution":"def longest_subarray_with_sum_at_most_k(test_cases): results = [] for case in test_cases: m, k = case[0] array = case[1] max_length = 0 current_sum = 0 start = 0 for end in range(m): current_sum += array[end] while current_sum > k: current_sum -= array[start] start += 1 max_length = max(max_length, end - start + 1) results.append(max_length) return results def process_input(input_data): lines = input_data.strip().split('n') n = int(lines[0]) test_cases = [] index = 1 for _ in range(n): m, k = map(int, lines[index].split()) array = list(map(int, lines[index + 1].split())) test_cases.append(((m, k), array)) index += 2 return test_cases"},{"question":"def array_operations(N: int, Q: int, A: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Apply update and query operations on the array A. Parameters: N: int - length of the array Q: int - number of operations A: list of int - the initial array operations: list of tuples - list of operations where each operation is (type, param1, param2) Returns: list of int - results of the query operations.","solution":"def array_operations(N, Q, A, operations): Apply update and query operations on the array A. Parameters: N: int - length of the array Q: int - number of operations A: list of int - the initial array operations: list of tuples - list of operations where each operation is (type, param1, param2) Returns: list of int - results of the query operations. results = [] for op in operations: if op[0] == 1: i, x = op[1], op[2] A[i - 1] = x # Update operation (convert 1-based index to 0-based) elif op[0] == 2: l, r = op[1], op[2] results.append(sum(A[l - 1:r])) # Query operation (convert 1-based indices to 0-based) return results"},{"question":"def total_active_time(intervals): Calculate the total active working time of the employee, considering overlapping periods only once. :param intervals: List of tuples where each tuple contains start and end time of a task. :return: Total active working time. >>> total_active_time([(1, 3), (2, 5), (4, 6)]) 5 >>> total_active_time([(1, 2), (3, 4), (5, 6)]) 3 >>> total_active_time([(1, 4), (2, 3), (1, 4)]) 3 >>> total_active_time([(1, 5), (2, 3), (4, 6)]) 5 >>> total_active_time([(1, 2)]) 1 >>> total_active_time([(1, 2), (2, 3), (3, 4)]) 3 >>> total_active_time([(1, 1000000)]) 999999 >>> total_active_time([]) 0","solution":"def total_active_time(intervals): Calculate the total active working time of the employee, considering overlapping periods only once. :param intervals: List of tuples where each tuple contains start and end time of a task. :return: Total active working time. if not intervals: return 0 # Sort intervals by start times intervals.sort() merged_intervals = [] current_start, current_end = intervals[0] for start, end in intervals[1:]: if start <= current_end: # Overlapping intervals, merge them current_end = max(current_end, end) else: # Non-overlapping interval, add the previous interval to list and move to the next merged_intervals.append((current_start, current_end)) current_start, current_end = start, end # Add the last interval merged_intervals.append((current_start, current_end)) # Calculate the total duration of the merged intervals total_duration = sum(end - start for start, end in merged_intervals) return total_duration"},{"question":"def merge_playlists(playlist1: List[int], playlist2: List[int]) -> List[int]: Merges two playlists maintaining the order of songs while ensuring no duplicates. If a song appears in both playlists, it will be taken from the first occurrence in playlist1. Args: playlist1 (List[int]): The first playlist. playlist2 (List[int]): The second playlist. Returns: List[int]: The merged playlist. Examples: >>> merge_playlists([1, 2, 3, 4], [3, 5, 6]) [1, 2, 3, 4, 5, 6] >>> merge_playlists([7, 8, 9], [10, 7, 11]) [7, 8, 9, 10, 11] >>> merge_playlists([1, 2, 3], [4, 5, 6]) [1, 2, 3, 4, 5, 6]","solution":"def merge_playlists(playlist1, playlist2): Merges two playlists maintaining the order of songs while ensuring no duplicates. If a song appears in both playlists, it will be taken from the first occurrence in playlist1. Args: playlist1 (List[int]): The first playlist. playlist2 (List[int]): The second playlist. Returns: List[int]: The merged playlist. # Set to keep track of already added songs seen = set() # Result list to store the merged playlist merged_playlist = [] # Add songs from the first playlist for song in playlist1: if song not in seen: seen.add(song) merged_playlist.append(song) # Add songs from the second playlist for song in playlist2: if song not in seen: seen.add(song) merged_playlist.append(song) return merged_playlist"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence. >>> reverse_words(\\"The quick brown fox jumps over the lazy dog\\") \\"dog lazy the over jumps fox brown quick The\\" >>> reverse_words(\\"Hello\\") \\"Hello\\" >>> reverse_words(\\"\\") \\"\\" >>> reverse_words(\\" Hello world \\") \\"world Hello\\" >>> reverse_words(\\"A man, a plan, a canal, Panama!\\") \\"Panama! canal, a plan, a man, A\\"","solution":"def reverse_words(sentence): Reverses the words in a given sentence. sentence: str - A string containing the sentence to be reversed. Returns a new string with the words in reverse order. words = sentence.split() reversed_words = words[::-1] return ' '.join(reversed_words)"},{"question":"import re def validate_password(s): Validates the password according to the given rules. 1. The password must be at least 8 characters long and at most 20 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one uppercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set: {!@#%^&*()_+}. >>> validate_password(\\"Short1!\\") == \\"Invalid\\" >>> validate_password(\\"Longer1!\\") == \\"Valid\\" >>> validate_password(\\"ThisIsAVeryLongPassword1!\\") == \\"Invalid\\" >>> validate_password(\\"ThisIsGood1!\\") == \\"Valid\\" >>> validate_password(\\"PASSWORD1!\\") == \\"Invalid\\" >>> validate_password(\\"Password1!\\") == \\"Valid\\" >>> validate_password(\\"password1!\\") == \\"Invalid\\" >>> validate_password(\\"Password1!\\") == \\"Valid\\" >>> validate_password(\\"Password!\\") == \\"Invalid\\" >>> validate_password(\\"Password1!\\") == \\"Valid\\" >>> validate_password(\\"Password123\\") == \\"Invalid\\" >>> validate_password(\\"Password1!\\") == \\"Valid\\" >>> validate_password(\\"P@ssw0rd\\") == \\"Valid\\" >>> validate_password(\\"A1@securePassword\\") == \\"Valid\\" >>> validate_password(\\"Password123\\") == \\"Invalid\\" >>> validate_password(\\"A1@secur3Passw0rd!\\") == \\"Valid\\" >>> validate_password(\\"Aa1_\\") == \\"Invalid\\" >>> validate_password(\\"Aa1@aaaaaaaaaaaaaaaaaaaa\\") == \\"Invalid\\"","solution":"import re def validate_password(s): Validates the password according to the given rules. 1. The password must be at least 8 characters long and at most 20 characters long. 2. It must contain at least one lowercase letter. 3. It must contain at least one uppercase letter. 4. It must contain at least one digit. 5. It must contain at least one special character from the set: {!@#%^&*()_+}. if len(s) < 8 or len(s) > 20: return \\"Invalid\\" if not re.search(r'[a-z]', s): return \\"Invalid\\" if not re.search(r'[A-Z]', s): return \\"Invalid\\" if not re.search(r'[0-9]', s): return \\"Invalid\\" if not re.search(r'[!@#%^&*()_+]', s): return \\"Invalid\\" return \\"Valid\\""},{"question":"from typing import List, Tuple def enhance_park_lighting(n: int, q: int, initial_brightness: List[int], operations: List[Tuple[str, int, int]]) -> List[int]: Enhance the park lighting system by processing operations for increasing brightness and querying total brightness. >>> enhance_park_lighting(5, 4, [1, 2, 3, 4, 5], [('1', 3, 2), ('2', 1, 3), ('1', 5, 1), ('2', 4, 5)]) [8, 10] >>> enhance_park_lighting(1, 1, [5], [('2', 1, 1)]) [5] >>> enhance_park_lighting(3, 2, [1, 1, 1], [('1', 1, 2), ('2', 1, 3)]) [5] >>> enhance_park_lighting(4, 3, [1, 2, 3, 4], [('1', 1, 3), ('1', 4, 1), ('2', 1, 4)]) [1 + 3 + 2 + 3 + 5] >>> enhance_park_lighting(4, 3, [0, 0, 0, 0], [('1', 2, 10), ('1', 4, 20), ('2', 3, 4)]) [20]","solution":"def enhance_park_lighting(n, q, initial_brightness, operations): brightness_levels = initial_brightness[:] results = [] for op in operations: if op[0] == '1': # Increase brightness operation x = int(op[1]) y = int(op[2]) brightness_levels[x - 1] += y elif op[0] == '2': # Query total brightness operation l = int(op[1]) r = int(op[2]) total_brightness = sum(brightness_levels[l - 1:r]) results.append(total_brightness) return results"},{"question":"def catalan_number(n): Return the nth Catalan number. This function uses a dynamic programming approach. def max_non_crossing_handshakes(N): Return the maximum number of non-crossing handshakes for N employees. This is the (N/2)th Catalan number. def solve(T, test_cases): Solve the problem for T test cases and given list of test cases. def test_catalan_number(): assert catalan_number(0) == 1 assert catalan_number(1) == 1 assert catalan_number(2) == 2 assert catalan_number(3) == 5 assert catalan_number(4) == 14 assert catalan_number(5) == 42 def test_max_non_crossing_handshakes(): assert max_non_crossing_handshakes(4) == 2 assert max_non_crossing_handshakes(6) == 5 assert max_non_crossing_handshakes(8) == 14 assert max_non_crossing_handshakes(10) == 42 def test_solve(): assert solve(3, [4, 6, 8]) == [2, 5, 14] assert solve(2, [10, 12]) == [42, 132] def test_invalid_input(): try: max_non_crossing_handshakes(5) except ValueError: assert True else: assert False","solution":"def catalan_number(n): Return the nth Catalan number. This function uses a dynamic programming approach. if n == 0: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for i in range(2, n + 1): for j in range(i): dp[i] += dp[j] * dp[i - j - 1] return dp[n] def max_non_crossing_handshakes(N): Return the maximum number of non-crossing handshakes for N employees. This is the (N/2)th Catalan number. if N % 2 != 0: raise ValueError(\\"N must be even\\") return catalan_number(N // 2) def solve(T, test_cases): results = [] for N in test_cases: results.append(max_non_crossing_handshakes(N)) return results"},{"question":"def water_trapped(buildings): Returns the total amount of water trapped between the buildings. >>> water_trapped([0, 1, 2, 1, 0, 1]) 1 >>> water_trapped([3, 0, 0, 2, 0, 4]) 10 >>> water_trapped([5]) 0 >>> water_trapped([1, 2, 3, 4, 5]) 0","solution":"def water_trapped(buildings): Returns the total amount of water trapped between the buildings. if not buildings: return 0 left, right = 0, len(buildings) - 1 left_max, right_max = buildings[left], buildings[right] total_water = 0 while left < right: if buildings[left] < buildings[right]: left_max = max(left_max, buildings[left]) total_water += left_max - buildings[left] left += 1 else: right_max = max(right_max, buildings[right]) total_water += right_max - buildings[right] right -= 1 return total_water"},{"question":"def perform_operations(arr, operations): Perform operations on the array of integers. Parameters: arr (list of int): The array of integers to perform operations on. operations (list of str): List of operations to perform on the array. Returns: list of int: The resultant array after performing all operations. Example: >>> perform_operations([1, 2, 3], [\\"increment 2\\"]) [3, 4, 5] >>> perform_operations([1, 2, 3], [\\"multiply 2\\"]) [2, 4, 6] >>> perform_operations([1, 2, 3], [\\"reverse\\"]) [3, 2, 1] >>> perform_operations([1, 2, 3], [\\"swap 0 2\\"]) [3, 2, 1] >>> perform_operations([1, 2, 3, 4, 5], [\\"increment 2\\", \\"multiply 3\\", \\"reverse\\"]) [21, 18, 15, 12, 9] >>> perform_operations([1, 2, 3, 4, 5, 6], [\\"swap 1 4\\", \\"multiply 2\\"]) [2, 10, 6, 8, 4, 12] pass def process_test_cases(test_cases): Process multiple test cases and return the results. Parameters: test_cases (list of dict): A list of test cases, where each test case is a dictionary containing the array 'arr' and the list of 'operations' Returns: list of list of int: A list containing the resulting array for each test case Example: >>> test_cases = [{'arr': [1, 2, 3, 4, 5], 'operations': [\\"increment 2\\", \\"multiply 3\\", \\"reverse\\"]}, {'arr': [1, 2, 3, 4, 5, 6], 'operations': [\\"swap 1 4\\", \\"multiply 2\\"]}] >>> process_test_cases(test_cases) [[21, 18, 15, 12, 9], [2, 10, 6, 8, 4, 12]] pass","solution":"def perform_operations(arr, operations): Perform operations on the array. Parameters: arr (list of int): The array of integers operations (list of str): The operations to perform on the array Returns: list of int: The array after all operations have been performed for operation in operations: parts = operation.split() if parts[0] == \\"increment\\": n = int(parts[1]) arr = [x + n for x in arr] elif parts[0] == \\"multiply\\": n = int(parts[1]) arr = [x * n for x in arr] elif parts[0] == \\"reverse\\": arr.reverse() elif parts[0] == \\"swap\\": i = int(parts[1]) j = int(parts[2]) arr[i], arr[j] = arr[j], arr[i] return arr def process_test_cases(test_cases): Process multiple test cases and return the results. Parameters: test_cases (list of dict): A list of test cases, where each test case is a dictionary containing the array 'arr' and the list of 'operations' Returns: list of list of int: A list containing the resulting array for each test case results = [] for case in test_cases: arr = case['arr'] operations = case['operations'] result = perform_operations(arr, operations) results.append(result) return results"},{"question":"def can_partition_sequence(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if it's possible to partition each sequence into exactly K non-empty contiguous subarrays such that the sum of the maximum and minimum element in each subarray is the same. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples where each tuple contains: - a pair (N, K) which represent the length of the sequence and the number of subarrays - a list of N integers which represent the sequence Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_partition_sequence(3, [((5, 2), [1, 3, 6, 3, 1]), ((4, 2), [4, 1, 1, 4]), ((3, 3), [5, 5, 5])]) ['NO', 'YES', 'YES'] >>> can_partition_sequence(1, [((5, 2), [1, 1, 1, 1, 1])]) ['YES']","solution":"def can_partition_sequence(T, test_cases): Determine if it's possible to partition each sequence according to the problem statement. results = [] for t in range(T): N, K = test_cases[t][0] sequence = test_cases[t][1] if K == N: results.append(\\"YES\\") else: # For each possible partition, we need to check the sums of max and min in subarrays unique_sums = set() for i in range(N): subarray_sum = sequence[i] * 2 unique_sums.add(subarray_sum) if len(unique_sums) <= K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def sum_of_distances(n: int, s: str) -> int: Calculate the sum of distances between each '1' and the leader of its cluster in a binary string. >>> sum_of_distances(10, \\"1100011000\\") 4 >>> sum_of_distances(5, \\"10101\\") 0 >>> sum_of_distances(6, \\"111111\\") 15 >>> sum_of_distances(5, \\"11111\\") 10 >>> sum_of_distances(5, \\"00000\\") 0 >>> sum_of_distances(10, \\"1010101010\\") 0","solution":"def sum_of_distances(n, s): sum_distances = 0 cluster_start = None for i in range(n): if s[i] == '1': if cluster_start is None: cluster_start = i sum_distances += i - cluster_start else: cluster_start = None return sum_distances"},{"question":"def rearrange_string(s: str) -> str: Rearrange the characters of the string in such a way that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") ''","solution":"import heapq from collections import Counter def rearrange_string(s): Rearrange the characters of the string in such a way that no two adjacent characters are the same. If such an arrangement is not possible, return an empty string. # Count frequency of each character counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return '' return rearranged_string"},{"question":"def normalize_path(path: str) -> str: Normalize a given Unix-style file path by removing redundant slashes and '.' characters. Args: path (str): The Unix-style file path. Returns: str: The normalized path. >>> normalize_path(\\"/home//foo/\\") \\"/home/foo\\" >>> normalize_path(\\"/../\\") \\"/\\" >>> normalize_path(\\"/home/./bar/\\") \\"/home/bar\\"","solution":"def normalize_path(path): Normalize a given Unix-style file path by removing redundant slashes and '.' characters. Args: path (str): The Unix-style file path. Returns: str: The normalized path. parts = [] for part in path.split(\\"/\\"): if part == \\"\\" or part == \\".\\": continue elif part == \\"..\\": if parts: parts.pop() else: parts.append(part) return \\"/\\" + \\"/\\".join(parts)"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent characters are the same, if possible. Otherwise, return \\"Not possible\\". >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\", \\"baba\\", \\"abab\\"] True >>> rearrange_string(\\"aaaa\\") == \\"Not possible\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"ab\\") == \\"ab\\" True >>> rearrange_string(\\"aa\\") == \\"Not possible\\" True >>> rearrange_string(\\"aabbcc\\") in [\\"abcabc\\", \\"acbabc\\", \\"acbacb\\", \\"abcbac\\"] True >>> rearrange_string(\\"aaaabb\\") == \\"Not possible\\" True >>> rearrange_string(\\"abcabc\\") in [\\"abcabc\\", \\"acbabc\\", \\"acbacb\\", \\"abcbac\\"] True","solution":"from collections import Counter import heapq def rearrange_string(s): Rearrange the string such that no two adjacent characters are the same, if possible. Otherwise, return \\"Not possible\\". # Count the frequency of each character freq = Counter(s) # Create a max heap based on the negative frequency (Python's heapq is a min heap by default) max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # since we used one instance of char # If the rearranged string's length is equal to the input string's length, it means successful rearrangement if len(result) == len(s): return ''.join(result) else: return \\"Not possible\\""},{"question":"def count_paths(grid): Counts the number of unique paths in a labyrinth from the top-left corner to the bottom-right corner without visiting any cell more than once. >>> count_paths([ ... \\"...\\" ... \\".#.\\" ... \\"...\\" ... ]) 2 >>> count_paths([ ... \\"..#\\" ... \\"#.#\\" ... \\"...\\" ... ]) 1","solution":"def count_paths(grid): Counts the number of unique paths in a labyrinth from the top-left corner to the bottom-right corner without visiting any cell more than once. n, m = len(grid), len(grid[0]) visited = [[False]*m for _ in range(n)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' and not visited[x][y] def dfs(x, y): if x == n-1 and y == m-1: return 1 visited[x][y] = True total_paths = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if is_valid(nx, ny): total_paths += dfs(nx, ny) visited[x][y] = False return total_paths return dfs(0, 0)"},{"question":"def shortest_subarray(arr, k): Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. Args: arr (List[int]): The array of integers. k (int): The target subarray sum. Returns: int: The length of the shortest subarray with sum >= k, or -1 if no such subarray exists. Examples: >>> shortest_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 15) 2 >>> shortest_subarray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 100) -1 >>> shortest_subarray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 12) 12 >>> shortest_subarray([10], 10) 1 >>> shortest_subarray([5], 10) -1 >>> shortest_subarray([4, 2, 2, 7, 1, 2, 3, 1, 1], 8) 2 >>> shortest_subarray([10000]*100000, 1000000000) 100000","solution":"def shortest_subarray(arr, k): Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. from collections import deque n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] dq = deque() min_length = float('inf') for i in range(n + 1): while dq and prefix_sums[i] - prefix_sums[dq[0]] >= k: min_length = min(min_length, i - dq.popleft()) while dq and prefix_sums[i] <= prefix_sums[dq[-1]]: dq.pop() dq.append(i) return min_length if min_length != float('inf') else -1"},{"question":"def max_binary(s: str, k: int) -> str: Find the maximum binary number by performing at most k bit flips from '0' to '1'. >>> max_binary(\\"010101\\", 2) == \\"111101\\" >>> max_binary(\\"010101\\", 10) == \\"111111\\" >>> max_binary(\\"000\\", 1) == \\"100\\" >>> max_binary(\\"1010101\\", 0) == \\"1010101\\"","solution":"def max_binary(s: str, k: int) -> str: s_list = list(s) flips = 0 for i in range(len(s_list)): if flips >= k: break if s_list[i] == '0': s_list[i] = '1' flips += 1 return \\"\\".join(s_list)"},{"question":"def max_sum_subgrid(grid, n, m, a, b): Finds the largest sum of an a x b sub-grid from the n x m grid. Args: grid (List[List[int]]): 2D list of integers representing the grid. n (int): Number of rows in the grid. m (int): Number of columns in the grid. a (int): Number of rows in the sub-grid. b (int): Number of columns in the sub-grid. Returns: int: The largest sum of an a x b sub-grid. >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> max_sum_subgrid(grid, 3, 3, 2, 2) 28 >>> grid = [ ... [-1, -1, -1, -1], ... [-1, 2, 2, -1], ... [-1, 2, 2, -1], ... [-1, -1, -1, -1] ... ] >>> max_sum_subgrid(grid, 4, 4, 2, 2) 8 import pytest def test_max_sum_subgrid_case1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_sum_subgrid(grid, 3, 3, 2, 2) == 28 def test_max_sum_subgrid_case2(): grid = [ [-1, -1, -1, -1], [-1, 2, 2, -1], [-1, 2, 2, -1], [-1, -1, -1, -1] ] assert max_sum_subgrid(grid, 4, 4, 2, 2) == 8 def test_max_sum_subgrid_edge_case1(): grid = [[-10**4] * 1000] assert max_sum_subgrid(grid, 1, 1000, 1, 1) == -10000 def test_max_sum_subgrid_edge_case2(): grid = [[10**4] * 1000] assert max_sum_subgrid(grid, 1, 1000, 1, 1) == 10000 def test_max_sum_subgrid_custom_case(): grid = [ [1, -2, -3, -4], [5, 6, -7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert max_sum_subgrid(grid, 4, 4, 2, 2) == 54 def test_max_sum_subgrid_single_element(): grid = [[5]] assert max_sum_subgrid(grid, 1, 1, 1, 1) == 5","solution":"def max_sum_subgrid(grid, n, m, a, b): Finds the largest sum of an a x b sub-grid from the n x m grid. Args: grid (List[List[int]]): 2D list of integers representing the grid. n (int): Number of rows in the grid. m (int): Number of columns in the grid. a (int): Number of rows in the sub-grid. b (int): Number of columns in the sub-grid. Returns: int: The largest sum of an a x b sub-grid. max_sum = float('-inf') for i in range(n - a + 1): for j in range(m - b + 1): current_sum = 0 for ki in range(a): for kj in range(b): current_sum += grid[i + ki][j + kj] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_missing_and_repeated(numbers): Finds the missing and repeated number in an array of numbers from 1 to n with one missing and one repeated number. Parameters: numbers (list): The list of numbers containing n elements with one number missing and one repeated. Returns: tuple: A tuple containing the repeated number and the missing number. Example ------- >>> find_missing_and_repeated([4, 3, 6, 2, 2]) (2, 5) >>> find_missing_and_repeated([1, 2, 2, 4]) (2, 3)","solution":"def find_missing_and_repeated(numbers): Finds the missing and repeated number in an array of numbers from 1 to n with one missing and one repeated number. Parameters: numbers (list): The list of numbers containing n elements with one number missing and one repeated. Returns: tuple: A tuple containing the repeated number and the missing number. n = len(numbers) # Create a frequency dictionary to count occurrences of each number frequency = {} for number in numbers: if number in frequency: frequency[number] += 1 else: frequency[number] = 1 repeated = missing = None for i in range(1, n+1): if i not in frequency: missing = i elif frequency[i] == 2: repeated = i return repeated, missing"},{"question":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations needed to make all elements of the list equal by incrementing or decrementing by 1. >>> min_operations_to_equal_elements(5, [1, 2, 3, 4, 5]) 6 >>> min_operations_to_equal_elements(3, [5, 10, 15]) 10 >>> min_operations_to_equal_elements(4, [4, 4, 4, 4]) 0","solution":"def min_operations_to_equal_elements(n, arr): Returns the minimum number of operations needed to make all elements of the list equal by incrementing or decrementing by 1. # The optimal value to make all elements equal is the median. # Sort the list and find the median. arr.sort() median = arr[n // 2] # Calculate total number of operations as the sum of absolute differences from the median. operations = sum(abs(x - median) for x in arr) return operations"},{"question":"def is_rainbow_sequence(balloon_sequence): Determines if the provided balloon sequence contains a rainbow sequence. Args: balloon_sequence (list): A list of balloon colors as strings. Returns: str: 'Yes' if a rainbow sequence is found, 'No' otherwise. >>> is_rainbow_sequence([\\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\"]) == \\"Yes\\" >>> is_rainbow_sequence([\\"red\\", \\"orange\\", \\"green\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\"]) == \\"No\\" >>> is_rainbow_sequence([\\"red\\", \\"orange\\", \\"yellow\\", \\"blue\\", \\"green\\", \\"indigo\\", \\"violet\\"]) == \\"No\\" >>> is_rainbow_sequence([\\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\"]) == \\"No\\" >>> is_rainbow_sequence([ \\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\", \\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\" ]) == \\"Yes\\" def solve(T, cases): Solves multiple cases of the rainbow sequence problem. Args: T (int): Number of test cases. cases (list): A list of strings, each representing a sequence of balloons. Returns: list: A list of 'Yes' or 'No' for each test case indicating the presence of a rainbow sequence. >>> solve(3, [ \\"red orange yellow green blue indigo violet\\", \\"red orange green yellow green blue indigo violet\\", \\"red orange yellow blue green indigo violet\\" ]) == [\\"Yes\\", \\"No\\", \\"No\\"]","solution":"def is_rainbow_sequence(balloon_sequence): Determines if the provided balloon sequence contains a rainbow sequence. Args: balloon_sequence (list): A list of balloon colors as strings. Returns: str: 'Yes' if a rainbow sequence is found, 'No' otherwise. rainbow_colors = [\\"red\\", \\"orange\\", \\"yellow\\", \\"green\\", \\"blue\\", \\"indigo\\", \\"violet\\"] n = len(balloon_sequence) if n < 7: return \\"No\\" for i in range(n - 6): if balloon_sequence[i:i + 7] == rainbow_colors: return \\"Yes\\" return \\"No\\" def solve(T, cases): results = [] for case in cases: balloon_sequence = case.split() results.append(is_rainbow_sequence(balloon_sequence)) return results"},{"question":"def can_be_non_decreasing(nums): Determines if the array can be made non-decreasing with at most one replacement. Example: >>> can_be_non_decreasing([4, 2, 3]) True >>> can_be_non_decreasing([4, 2, 1]) False >>> can_be_non_decreasing([3, 4, 2, 3]) False","solution":"def can_be_non_decreasing(nums): Determines if the array can be made non-decreasing with at most one replacement. def can_modify(index, new_value): tmp = nums[:index] + [new_value] + nums[index+1:] return all(tmp[i] <= tmp[i+1] for i in range(len(tmp) - 1)) n = len(nums) for i in range(n - 1): if nums[i] > nums[i + 1]: # Attempt to fix the problem by modifying nums[i] or nums[i+1] return can_modify(i, nums[i + 1]) or can_modify(i + 1, nums[i]) return True"},{"question":"def solve(input_string: str) -> str: Determines if a substring of s can be rearranged to become a palindrome after removing at most m characters and adding at most n characters. >>> solve(\\"abac 1 1\\") 'YES' >>> solve(\\"abcde 1 1\\") 'NO' >>> solve(\\"racecar 0 0\\") 'YES' >>> solve(\\"a 0 0\\") 'YES' >>> solve(\\"abcde 0 2\\") 'YES' >>> solve(\\"aaaabbbbcccc 3 0\\") 'YES' >>> solve(\\"abcd 0 0\\") 'NO' >>> solve(\\"abcdefgh 2 3\\") 'YES' >>> solve(\\"abcdefghij 2 3\\") 'NO'","solution":"from collections import Counter def can_form_palindrome(s, m, n): Determines if a substring of s can be rearranged to become a palindrome after removing at most m characters and adding at most n characters. freq = Counter(s) odd_count = sum(1 for count in freq.values() if count % 2 == 1) # A string can be rearranged into a palindrome if at most # one character has an odd count (for odd length palindrome) or all even (for even length palindrome). if odd_count <= m + 2 * n + 1: return \\"YES\\" else: return \\"NO\\" def solve(input_string): parts = input_string.split() s = parts[0] m = int(parts[1]) n = int(parts[2]) return can_form_palindrome(s, m, n)"},{"question":"def process_operations(n, q, array, operations): Processes the given operations on the array. Parameters: n (int): The number of elements in the array. q (int): The number of operations. array (list of int): The initial elements of the array. operations (list of str): The operations to be performed. Returns: list of int: Results of \\"S l r\\" operations. results = [] def update(index, value): Updates the value at a specific index in the array. Parameters: index (int): The index to update (1-based). value (int): The new value to set. array[index - 1] = value def sum_subarray(left, right): Calculates the sum of elements in a given subarray from index left to right inclusive. Parameters: left (int): The starting index of the subarray (1-based). right (int): The ending index of the subarray (1-based). Returns: int: The sum of the elements in the subarray. return sum(array[left - 1:right]) for operation in operations: ops = operation.split() if ops[0] == \\"U\\": index = int(ops[1]) value = int(ops[2]) update(index, value) elif ops[0] == \\"S\\": left = int(ops[1]) right = int(ops[2]) result = sum_subarray(left, right) results.append(result) return results from solution import process_operations def test_process_operations_basic(): n = 5 q = 5 array = [1, 2, 3, 4, 5] operations = [\\"S 1 3\\", \\"U 2 10\\", \\"S 1 3\\", \\"S 2 4\\", \\"U 5 0\\"] expected = [6, 14, 17] assert process_operations(n, q, array, operations) == expected def test_process_operations_single_update(): n = 3 q = 3 array = [1, 2, 3] operations = [\\"S 1 3\\", \\"U 2 5\\", \\"S 1 3\\"] expected = [6, 9] assert process_operations(n, q, array, operations) == expected def test_process_operations_multiple_updates(): n = 4 q = 4 array = [1, 2, 3, 4] operations = [\\"S 1 4\\", \\"U 1 10\\", \\"U 4 20\\", \\"S 2 4\\"] expected = [10, 25] assert process_operations(n, q, array, operations) == expected def test_process_operations_no_update(): n = 3 q = 1 array = [1, 2, 3] operations = [\\"S 2 3\\"] expected = [5] assert process_operations(n, q, array, operations) == expected def test_process_operations_all_updates(): n = 3 q = 3 array = [1, 2, 3] operations = [\\"U 1 5\\", \\"U 3 7\\", \\"U 2 8\\"] expected = [] assert process_operations(n, q, array, operations) == expected","solution":"def process_operations(n, q, array, operations): Processes the given operations on the array. Parameters: n (int): The number of elements in the array. q (int): The number of operations. array (list of int): The initial elements of the array. operations (list of str): The operations to be performed. Returns: list of int: Results of \\"S l r\\" operations. results = [] def update(index, value): Updates the value at a specific index in the array. Parameters: index (int): The index to update (1-based). value (int): The new value to set. array[index - 1] = value def sum_subarray(left, right): Calculates the sum of elements in a given subarray from index left to right inclusive. Parameters: left (int): The starting index of the subarray (1-based). right (int): The ending index of the subarray (1-based). Returns: int: The sum of the elements in the subarray. return sum(array[left - 1:right]) for operation in operations: ops = operation.split() if ops[0] == \\"U\\": index = int(ops[1]) value = int(ops[2]) update(index, value) elif ops[0] == \\"S\\": left = int(ops[1]) right = int(ops[2]) result = sum_subarray(left, right) results.append(result) return results"},{"question":"def largestRectangleArea(heights): Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([10000] * 100000) 1000000000","solution":"def largestRectangleArea(heights): Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of the largest rectangle in the histogram. stack = [] # To maintain indices of the histogram bars max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def minimum_required_power(x, p): Find the minimum value of the power required such that all lamps cover the entire segment from the leftmost house's coordinate to the rightmost house's coordinate. >> minimum_required_power([1, 2, 3], [1, 1, 1]) 1 >> minimum_required_power([1, 4, 6], [1, 1, 1]) 2 >> minimum_required_power([1, 2, 8], [2, 2, 2]) 3","solution":"def minimum_required_power(x, p): Find the minimum value of the power required such that all lamps cover the entire segment from the leftmost house's coordinate to the rightmost house's coordinate. if not x or not p: return 0 x.sort() max_gap = 0 # Calculate the maximum gap between consecutive houses for i in range(1, len(x)): max_gap = max(max_gap, x[i] - x[i-1]) # Minimum required power is half the largest gap min_power = max_gap // 2 if max_gap % 2 == 0 else (max_gap // 2) + 1 return min_power"},{"question":"def who_wins_goblins_candies(N: int, candies: List[int]) -> int: Determine which player will win if both play optimally. Args: N : int : Number of goblins candies : list : A list of integers representing the number of candies each goblin initially holds Returns: int : 1 if the first player wins, 2 if the second player wins >>> who_wins_goblins_candies(5, [1, 3, 5, 7, 9]) 1 >>> who_wins_goblins_candies(4, [2, 4, 1, 3]) 2","solution":"def who_wins_goblins_candies(N, candies): Determine which player will win if both play optimally. Args: N : int : Number of goblins candies : list : A list of integers representing the number of candies each goblin initially holds Returns: int : 1 if the first player wins, 2 if the second player wins total_candies = sum(candies) if total_candies % 2 == 1: return 1 else: return 2"},{"question":"def longestUniqueSubst(arr): Returns the length of the longest contiguous subsequence with unique elements. Args: arr (List[int]): List of integers representing the array. Returns: int: The length of the longest contiguous subsequence with unique elements. Examples: >>> longestUniqueSubst([1, 2, 2, 3, 4, 4]) 3 >>> longestUniqueSubst([1, 2, 3, 4, 5]) 5 >>> longestUniqueSubst([5, 5, 5, 5, 5]) 1 >>> longestUniqueSubst([2, 2, 3, 4, 5]) 4 >>> longestUniqueSubst([1, 2, 3, 4, 4]) 4","solution":"def longestUniqueSubst(arr): Returns the length of the longest contiguous subsequence with unique elements. last_index = {} max_length = 0 start = 0 for i in range(len(arr)): if arr[i] in last_index: start = max(start, last_index[arr[i]] + 1) last_index[arr[i]] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def shift_characters(s: str, n: int) -> str: Shifts each alphabetical character in the string \`s\` forward by \`n\` positions in the alphabet (wrapping around if necessary), keeping any non-alphabet characters in their original place. >>> shift_characters(\\"hello, world!\\", 3) \\"khoor, zruog!\\" >>> shift_characters(\\"abcd\\", 0) \\"abcd\\" >>> shift_characters(\\"xyz\\", 3) \\"abc\\" >>> shift_characters(\\"abcdefghijklmnopqrstuvwxyz\\", 1) \\"bcdefghijklmnopqrstuvwxyza\\" >>> shift_characters(\\"a b c!\\", 2) \\"c d e!\\" >>> shift_characters(\\"hello, world!\\", 10) \\"rovvy, gybvn!\\"","solution":"def shift_characters(s, n): Shifts each alphabetical character in the string \`s\` forward by \`n\` positions in the alphabet (wrapping around if necessary), keeping any non-alphabet characters in their original place. shifted_string = [] for char in s: if char.isalpha(): new_position = (ord(char) - ord('a') + n) % 26 shifted_char = chr(ord('a') + new_position) shifted_string.append(shifted_char) else: shifted_string.append(char) return ''.join(shifted_string)"},{"question":"def longestCommonSubsequence(str1: str, str2: str) -> int: Implement a function that takes two strings and returns the length of their longest common subsequence. A subsequence is a sequence that appears in the same relative order, but not necessarily consecutively. For example, \\"abc\\", \\"abg\\", \\"bdf\\", \\"aeg\\", \\"acefg\\", etc., are subsequences of \\"abcdefg\\". The problem has two strings, let's call them str1 and str2, and you need to find the length of their longest common subsequence (LCS). Args: str1 (str): The first string. str2 (str): The second string. Returns: int: The length of the longest common subsequence between the given strings. Example: >>> longestCommonSubsequence(\\"abcde\\", \\"ace\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"abc\\") 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\") 0","solution":"def longestCommonSubsequence(str1, str2): Returns the length of the longest common subsequence of str1 and str2. n = len(str1) m = len(str2) # Create a 2D array to store lengths of longest common subsequence dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def digit_sum(n): Returns the sum of the digits of an integer n. If the resultant sum has more than one digit, the function continues to sum the digits until a single-digit sum is obtained. >>> digit_sum(1234) == 1 # 1 + 2 + 3 + 4 = 10 -> 1 + 0 = 1 >>> digit_sum(99) == 9 # 9 + 9 = 18 -> 1 + 8 = 9 >>> digit_sum(56789) == 8 # 5 + 6 + 7 + 8 + 9 = 35 -> 3 + 5 = 8","solution":"def digit_sum(n): Returns the sum of the digits of an integer n. If the resultant sum has more than one digit, the function continues to sum the digits until a single-digit sum is obtained. while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def sum_even_fibonacci(max_n: int) -> int: Return the sum of even Fibonacci numbers not exceeding max_n. >>> sum_even_fibonacci(10) 10 >>> sum_even_fibonacci(34) 44 pass def solve_fibonacci_problems(test_cases: List[int]) -> List[int]: Return a list containing solutions for given test cases. >>> solve_fibonacci_problems([10, 34, 100, 1000000]) [10, 44, 44, 1089154] pass","solution":"def sum_even_fibonacci(max_n): Return the sum of even Fibonacci numbers not exceeding max_n. a, b = 1, 1 total_sum = 0 while b <= max_n: if b % 2 == 0: total_sum += b a, b = b, a + b return total_sum def solve_fibonacci_problems(test_cases): Return a list containing solutions for given test cases. results = [] for n in test_cases: results.append(sum_even_fibonacci(n)) return results"},{"question":"def shortest_common_supersequence_length(s1: str, s2: str) -> int: Determine the length of the shortest sequence that contains both sequences as subsequences. >>> shortest_common_supersequence_length(\\"abc\\", \\"bcd\\") 4 >>> shortest_common_supersequence_length(\\"abc\\", \\"def\\") 6 >>> shortest_common_supersequence_length(\\"\\", \\"def\\") 3 >>> shortest_common_supersequence_length(\\"abc\\", \\"\\") 3 >>> shortest_common_supersequence_length(\\"abc\\", \\"abc\\") 3 >>> shortest_common_supersequence_length(\\"ab\\", \\"abcf\\") 4 >>> shortest_common_supersequence_length(\\"abc\\", \\"cab\\") 4 >>> shortest_common_supersequence_length(\\"a\\" * 1000, \\"b\\" * 1000) 2000","solution":"def shortest_common_supersequence_length(s1, s2): Determine the length of the shortest sequence that contains both sequences as subsequences. m = len(s1) n = len(s2) # Initialize the table for dynamic programming dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s1[i - 1] == s2[j - 1]: dp[i][j] = 1 + dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def unique_paths(m: int, n: int) -> int: Determine the number of unique paths in a m x n grid, moving only down or right from the top-left to the bottom-right corner. Args: m (int): number of rows n (int): number of columns Returns: int: number of unique paths Examples: >>> unique_paths(3, 2) 3 >>> unique_paths(7, 3) 28","solution":"def unique_paths(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of a mxn grid. # Create a 2D array with m rows and n columns filled with 1s dp = [[1] * n for _ in range(m)] # Iterate through the grid starting from 1,1 since the first row and # first column has only one way to reach each cell. for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] # Return the value in the bottom-right corner of the grid return dp[m-1][n-1]"},{"question":"def max_length_subsequence(arr: List[int]) -> int: Finds the maximum length of a subsequence where the absolute difference between any two consecutive elements is at most 1. >>> max_length_subsequence([1, 2, 2, 3, 1, 2]) 5 >>> max_length_subsequence([4, 6, 5, 3, 3, 1, 5, 6, 2]) 4","solution":"def max_length_subsequence(arr): Finds the maximum length of a subsequence where the absolute difference between any two consecutive elements is at most 1. from collections import Counter counter = Counter(arr) max_length = 0 for num in counter: current_length = counter[num] + counter.get(num + 1, 0) max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def count_ways_to_distribute_candies(N: int, stacks: List[int]) -> int: Count the number of ways to distribute candies from stacks ensuring no consecutive turns involve the same stack. >>> count_ways_to_distribute_candies(2, [1, 3]) 2 >>> count_ways_to_distribute_candies(3, [1, 2, 3]) 6","solution":"import itertools def count_ways_to_distribute_candies(N, stacks): Function to count the number of ways to distribute candies ensuring no consecutive turns using the same stack. if N <= 1: return 1 # Generate all possible permutations of distributing candies from the stack permutations = list(itertools.permutations(stacks)) valid_count = 0 for perm in permutations: if all(perm[i] != perm[i + 1] for i in range(len(perm) - 1)): valid_count += 1 return valid_count"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix of the given list of strings. Args: strs: List of strings Returns: A string that is the longest common prefix >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) \\"fl\\" >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) \\"\\" >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\"]) \\"inters\\" >>> longest_common_prefix([\\"prefix\\", \\"pregame\\", \\"prelude\\"]) \\"pre\\" >>> longest_common_prefix([\\"single\\"]) \\"single\\" >>> longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) \\"same\\" >>> longest_common_prefix([]) \\"\\" >>> longest_common_prefix([\\"ab\\", \\"a\\"]) \\"a\\" >>> longest_common_prefix([\\"abcdef\\", \\"abcd\\", \\"abc\\"]) \\"abc\\"","solution":"def longest_common_prefix(strs): Finds the longest common prefix of the given list of strings. Args: strs: List of strings Returns: A string that is the longest common prefix if not strs: return \\"\\" # Sort the list to easily find the bounds of common prefix strs.sort() # Compare characters between the first and the last string in the sorted list first = strs[0] last = strs[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def build_tree(nodes): Build a binary tree from the given list of node values. :param nodes: a list of tuples containing (parent, left child, right child) :return: TreeNode representing the root of the tree pass def is_mirror(t1: TreeNode, t2: TreeNode) -> bool: Check if two binary trees are mirrors of each other. :param t1: TreeNode representing the root of the first tree :param t2: TreeNode representing the root of the second tree :return: True if the trees are mirrors of each other, False otherwise pass def check_if_trees_are_mirrors(n: int, tree1: List[Tuple[int, int, int]], m: int, tree2: List[Tuple[int, int, int]]) -> str: Check if the two binary trees are mirrors of each other. :param n: number of nodes in the first tree :param tree1: list of tuples representing the first tree :param m: number of nodes in the second tree :param tree2: list of tuples representing the second tree :return: \\"YES\\" if the trees are mirrors, \\"NO\\" otherwise >>> check_if_trees_are_mirrors(6, [(1, 2, 3), (2, 4, 5), (3, -1, -1), (4, -1, -1), (5, -1, -1), (-1, -1, -1)], 6, [(1, 3, 2), (3, -1, -1), (2, 5, 4), (5, -1, -1), (4, -1, -1), (-1, -1, -1)]) \\"YES\\" >>> check_if_trees_are_mirrors(3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)], 3, [(1, 2, 3), (2, -1, -1), (3, -1, -1)]) \\"NO\\"","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None def buildTree(nodes): node_dict = {} for parent, left, right in nodes: if parent not in node_dict: node_dict[parent] = TreeNode(parent) if left != -1: node_dict[left] = TreeNode(left) node_dict[parent].left = node_dict[left] if right != -1: node_dict[right] = TreeNode(right) node_dict[parent].right = node_dict[right] return node_dict[nodes[0][0]] if nodes else None def isMirror(t1, t2): if not t1 and not t2: return True if not t1 or not t2: return False return (t1.val == t2.val) and isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left) def check_if_trees_are_mirrors(n, tree1, m, tree2): root1 = buildTree(tree1) root2 = buildTree(tree2) return \\"YES\\" if isMirror(root1, root2) else \\"NO\\""},{"question":"def flatten_and_sort(nested_list): Flattens a nested list of integers and sorts the resulting list in ascending order. Args: nested_list (list): A nested list containing integers and/or other nested lists of integers. Returns: list: A sorted list containing all the integers from the nested list in ascending order. Examples: >>> flatten_and_sort([1, [2, 3], 4]) [1, 2, 3, 4] >>> flatten_and_sort([1, [4, [6]], 3, [2, [5, [7]]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_and_sort([]) [] >>> flatten_and_sort([[1, 2], [3, 4], [5, [6, [7]]]]) [1, 2, 3, 4, 5, 6, 7] >>> flatten_and_sort([5, [3, [8, 5]], 2, 5]) [2, 3, 5, 5, 5, 8] >>> flatten_and_sort([1]) [1] >>> flatten_and_sort([[1]]) [1] ------------------------- from solution import flatten_and_sort def test_flatten_and_sort_simple(): assert flatten_and_sort([1, [2, 3], 4]) == [1, 2, 3, 4] def test_flatten_and_sort_empty_list(): assert flatten_and_sort([]) == [] def test_flatten_and_sort_nested_lists(): assert flatten_and_sort([[1, 2], [3, 4], [5, [6, [7]]]]) == [1, 2, 3, 4, 5, 6, 7] def test_flatten_and_sort_mixed_nested(): assert flatten_and_sort([1, [4, [6]], 3, [2, [5, [7]]]]) == [1, 2, 3, 4, 5, 6, 7] def test_flatten_and_sort_single_element(): assert flatten_and_sort([1]) == [1] assert flatten_and_sort([[1]]) == [1] def test_flatten_and_sort_repetitions(): assert flatten_and_sort([5, [3, [8, 5]], 2, 5]) == [2, 3, 5, 5, 5, 8]","solution":"def flatten_and_sort(nested_list): Flattens a nested list of integers and sorts the resulting list in ascending order. flattened_list = [] def flatten(l): for item in l: if isinstance(item, list): flatten(item) else: flattened_list.append(item) flatten(nested_list) return sorted(flattened_list)"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the characters of the string 's' can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise \\"NO\\". >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" def process_queries(queries: List[str]) -> List[str]: Processes a list of string queries and determines if each query can be rearranged to form a palindrome. Returns a list of results with \\"YES\\" or \\"NO\\" for each query. >>> process_queries([\\"aabb\\", \\"abc\\", \\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> process_queries([\\"a\\", \\"aa\\", \\"aaa\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the characters of the string 's' can be rearranged to form a palindrome. Returns \\"YES\\" if possible, otherwise \\"NO\\". from collections import Counter count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) if odd_count > 1: return \\"NO\\" else: return \\"YES\\" def process_queries(queries): Processes a list of string queries and determines if each query can be rearranged to form a palindrome. Returns a list of results with \\"YES\\" or \\"NO\\" for each query. results = [] for s in queries: results.append(can_form_palindrome(s)) return results"},{"question":"from typing import List def find_shortest_path(maze: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a maze. If there is no possible path, return -1. >>> find_shortest_path([[0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0]]) 7 >>> find_shortest_path([[0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 0]]) -1 pass import unittest class TestFindShortestPath(unittest.TestCase): def test_shortest_path_example_1(self): maze = [ [0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0] ] self.assertEqual(find_shortest_path(maze), 7) def test_shortest_path_no_path(self): maze = [ [0, 1, 0, 0], [1, 1, 1, 1], [0, 1, 0, 1], [1, 1, 0, 0] ] self.assertEqual(find_shortest_path(maze), -1) def test_shortest_path_direct_path(self): maze = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] self.assertEqual(find_shortest_path(maze), 7) def test_shortest_path_start_is_wall(self): maze = [ [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] self.assertEqual(find_shortest_path(maze), -1) def test_shortest_path_end_is_wall(self): maze = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1] ] self.assertEqual(find_shortest_path(maze), -1) def test_shortest_path_single_element_maze_empty(self): maze = [ [0] ] self.assertEqual(find_shortest_path(maze), 1) def test_shortest_path_single_element_maze_wall(self): maze = [ [1] ] self.assertEqual(find_shortest_path(maze), -1)","solution":"from collections import deque def find_shortest_path(maze): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a maze. If there is no possible path, return -1. n = len(maze) if maze[0][0] == 1 or maze[n-1][n-1] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: row, col, dist = queue.popleft() if (row, col) == (n-1, n-1): return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and (new_row, new_col) not in visited and maze[new_row][new_col] == 0: queue.append((new_row, new_col, dist + 1)) visited.add((new_row, new_col)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: TreeNode) -> List[List[int]]: Implement a function that takes a binary tree and returns the zigzag level order traversal of its nodes' values. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20, TreeNode(15), TreeNode(7)) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]]","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] current_level = [root] left_to_right = True while current_level: level_values = [] next_level = [] for node in current_level: level_values.append(node.val) if node.left: next_level.append(node.left) if node.right: next_level.append(node.right) if not left_to_right: level_values.reverse() results.append(level_values) current_level = next_level left_to_right = not left_to_right return results"},{"question":"def max_score_no_consecutive(moves: List[int]) -> int: Calculate the maximum score that can be achieved if no two consecutive moves are allowed. >>> max_score_no_consecutive([4, 5, 1]) 5 >>> max_score_no_consecutive([2, 1, 2, 7]) 9 >>> max_score_no_consecutive([3, 2, 5, 10, 7]) 15 >>> max_score_no_consecutive([1]) 1 >>> max_score_no_consecutive([6, 7]) 7 >>> max_score_no_consecutive([3, 2, 7, 10]) 13 >>> max_score_no_consecutive([1, 1, 1, 1]) 2 >>> max_score_no_consecutive([2, 2, 2, 2]) 4 >>> max_score_no_consecutive([1000, 1, 1000, 1, 1000]) 3000 >>> max_score_no_consecutive([]) 0","solution":"def max_score_no_consecutive(moves): N = len(moves) if N == 0: return 0 if N == 1: return moves[0] # Initialize an array to store the maximum score up to index i dp = [0] * N # Base cases dp[0] = moves[0] if N > 1: dp[1] = max(moves[0], moves[1]) # Fill the dp array for i in range(2, N): dp[i] = max(dp[i-1], dp[i-2] + moves[i]) # The last element of dp array contains the answer return dp[-1]"},{"question":"def count_distinct_elements(N, M, matrix): Returns the number of distinct elements in the matrix. :param N: Number of rows in the matrix :param M: Number of columns in the matrix :param matrix: List of lists representing the matrix :return: Number of distinct elements in the matrix >>> count_distinct_elements(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 9 >>> count_distinct_elements(2, 2, [ ... [1, 2], ... [2, 1] ... ]) == 2 >>> count_distinct_elements(4, 4, [ ... [1, 2, 3, 4], ... [4, 3, 2, 1], ... [1, 2, 3, 4], ... [4, 3, 2, 1] ... ]) == 4","solution":"def count_distinct_elements(N, M, matrix): Returns the number of distinct elements in the matrix. :param N: Number of rows in the matrix :param M: Number of columns in the matrix :param matrix: List of lists representing the matrix :return: Number of distinct elements in the matrix distinct_elements = set() for row in matrix: distinct_elements.update(row) return len(distinct_elements) # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) matrix = [] index = 2 for i in range(N): row = list(map(int, data[index:index + M])) matrix.append(row) index += M print(count_distinct_elements(N, M, matrix))"},{"question":"from typing import List def longestConcatenation(strings: List[str], dictionary: List[str]) -> str: Find the longest string in the list of strings that can be formed by concatenating the words from a given dictionary. You may use each word in the dictionary at most once. If no string can be formed, return an empty string. Parameters: strings (List[str]): A list of strings. dictionary (List[str]): A list of words. Returns: str: The longest string that can be formed by concatenating the words from the dictionary. Examples: >>> dictionary = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] >>> strings = [\\"appleapp\\", \\"bananaapple\\", \\"aapplebanana\\", \\"banana\\"] >>> longestConcatenation(strings, dictionary) 'aapplebanana' >>> dictionary = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] >>> strings = [\\"xyz\\", \\"abc\\", \\"mno\\"] >>> longestConcatenation(strings, dictionary) '' # Your code here if __name__ == \\"__main__\\": import doctest doctest.testmod() def test_example_case(): dictionary = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] strings = [\\"appleapp\\", \\"bananaapple\\", \\"aapplebanana\\", \\"banana\\"] assert longestConcatenation(strings, dictionary) == \\"aapplebanana\\" def test_no_possible_concatenation(): dictionary = [\\"a\\", \\"banana\\", \\"app\\", \\"appl\\", \\"ap\\", \\"apply\\", \\"apple\\"] strings = [\\"xyz\\", \\"abc\\", \\"mno\\"] assert longestConcatenation(strings, dictionary) == \\"\\" def test_single_word_concatenation(): dictionary = [\\"apple\\"] strings = [\\"apple\\", \\"banana\\", \\"applebanana\\"] assert longestConcatenation(strings, dictionary) == \\"apple\\" def test_all_valid_concatenations(): dictionary = [\\"a\\", \\"b\\", \\"c\\"] strings = [\\"abc\\", \\"a\\", \\"ab\\", \\"bca\\"] assert longestConcatenation(strings, dictionary) == \\"abc\\" def test_partial_overlaps(): dictionary = [\\"cat\\", \\"cats\\", \\"sand\\", \\"dog\\"] strings = [\\"catsanddog\\", \\"catdog\\", \\"catsand\\"] assert longestConcatenation(strings, dictionary) == \\"catsanddog\\"","solution":"from typing import List def can_form(target: str, dictionary: List[str], memo: dict) -> bool: if target in memo: return memo[target] if target == \\"\\": return True for word in dictionary: if target.startswith(word): if can_form(target[len(word):], dictionary, memo): memo[target] = True return True memo[target] = False return False def longestConcatenation(strings: List[str], dictionary: List[str]) -> str: longest = \\"\\" memo = {} for s in strings: if can_form(s, dictionary, memo): if len(s) > len(longest): longest = s return longest"},{"question":"from typing import List, Tuple def max_happiness_score(n: int, checkpoints: List[Tuple[int, int, int]]) -> int: Computes the maximum possible happiness score a runner can achieve by consuming only one type of refreshment at each checkpoint. Parameters: n (int): Number of checkpoints. checkpoints (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (w, e, s) representing the happiness scores for water, energy drinks, and snacks respectively. Returns: int: The maximum possible happiness score. Example: >>> max_happiness_score(2, [(10, 20, 30), (5, 50, 5)]) 80 >>> max_happiness_score(3, [(10, 10, 10), (20, 20, 20), (30, 30, 30)]) 60","solution":"from typing import List, Tuple def max_happiness_score(n: int, checkpoints: List[Tuple[int, int, int]]) -> int: Computes the maximum possible happiness score a runner can achieve by consuming only one type of refreshment at each checkpoint. total_happiness = 0 for w, e, s in checkpoints: total_happiness += max(w, e, s) return total_happiness"},{"question":"from typing import List from math import gcd def lcm(a: int, b: int) -> int: Returns the least common multiple (LCM) of a and b. return a * b // gcd(a, b) def minMultiple(a: int, b: int) -> int: Given two positive integers a and b, find the smallest integer N, such that: - N is divisible by both a and b - N is greater than or equal to the least common multiple (LCM) of a and b >>> minMultiple(6, 8) 24 >>> minMultiple(5, 15) 15 >>> minMultiple(7, 3) 21","solution":"from math import gcd def lcm(a, b): Returns the least common multiple (LCM) of a and b. return a * b // gcd(a, b) def minMultiple(a, b): Returns the smallest integer N such that: - N is divisible by both a and b - N is greater than or equal to the least common multiple (LCM) of a and b return lcm(a, b)"},{"question":"def find_kth_occurrence(t: int, test_cases: List[Tuple[int, List[int], int, int]]) -> List[int]: Find the K'th occurrence of the integer X in the array. If X does not occur K times, output -1. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int], int, int]]): List of tuples where each tuple contains: n (int): Size of the array. arr (List[int]): The array of integers. x (int): The integer to find the K'th occurrence of. k (int): The occurrence number to find. Returns: List[int]: The positions of the K'th occurrence of X for each test case. If X does not occur K times, -1 is returned. Examples: >>> find_kth_occurrence(2, [(5, [1, 2, 3, 4, 2], 2, 2), (6, [1, 1, 1, 1, 1, 1], 1, 7)]) [5, -1] results = [] for i in range(t): n, arr, x, k = test_cases[i] count = 0 position = -1 for idx in range(n): if arr[idx] == x: count += 1 if count == k: position = idx + 1 break results.append(position) return results from typing import List, Tuple def test_find_kth_occurrence_case1(): assert find_kth_occurrence(1, [(5, [1, 2, 3, 4, 2], 2, 2)]) == [5] def test_find_kth_occurrence_case2(): assert find_kth_occurrence(1, [(6, [1, 1, 1, 1, 1, 1], 1, 7)]) == [-1] def test_find_kth_occurrence_multiple_cases(): assert find_kth_occurrence(2, [(5, [1, 2, 3, 4, 2], 2, 2), (6, [1, 1, 1, 1, 1, 1], 1, 7)]) == [5, -1] def test_find_kth_occurrence_no_occurrence(): assert find_kth_occurrence(1, [(6, [1, 2, 3, 4, 5, 6], 7, 1)]) == [-1] def test_find_kth_occurrence_exact_k(): assert find_kth_occurrence(1, [(5, [1, 2, 2, 2, 2], 2, 4)]) == [5]","solution":"def find_kth_occurrence(t, test_cases): results = [] for i in range(t): n, arr, x, k = test_cases[i] count = 0 position = -1 for idx in range(n): if arr[idx] == x: count += 1 if count == k: position = idx + 1 break results.append(position) return results # Example of test_cases input structure # t = 2 # test_cases = [ # (5, [1, 2, 3, 4, 2], 2, 2), # (6, [1, 1, 1, 1, 1, 1], 1, 7) # ]"},{"question":"def calculate_rankings(rounds): Calculate the final ranking of players based on their total points. Args: rounds (List[Tuple[int, int]]): A list of tuples where each tuple represents the player_id and the points earned in a round. Returns: List[int]: A sorted list of player_ids, starting with the player who has the highest total points. Example: >>> rounds = [ ... (1, 10), (2, 15), (3, 5), ... (1, -5), (2, -10), (3, 10), ... (1, 20), (2, 5), (3, 0) ... ] >>> calculate_rankings(rounds) [1, 3, 2] from solution import calculate_rankings def test_example_case(): rounds = [ (1, 10), (2, 15), (3, 5), (1, -5), (2, -10), (3, 10), (1, 20), (2, 5), (3, 0) ] assert calculate_rankings(rounds) == [1, 3, 2] def test_tied_points_different_ids(): rounds = [(1, 10), (2, 10), (1, 5), (2, 5)] assert calculate_rankings(rounds) == [1, 2] def test_tied_points_same_ids(): rounds = [(1, 10), (2, 20), (3, 20), (2, -5), (3, -5)] assert calculate_rankings(rounds) == [2, 3, 1] def test_positive_and_negative_points(): rounds = [(1, -10), (2, 20), (3, -30), (1, 15), (2, -20), (3, 45)] assert calculate_rankings(rounds) == [3, 1, 2] def test_single_player_multiple_rounds(): rounds = [(1, 10), (1, 20), (1, -5), (1, 0)] assert calculate_rankings(rounds) == [1] def test_multiple_players_no_ties(): rounds = [(1, 5), (2, 10), (3, 0), (4, 20)] assert calculate_rankings(rounds) == [4, 2, 1, 3]","solution":"def calculate_rankings(rounds): from collections import defaultdict # Dictionary to keep track of total points for each player player_points = defaultdict(int) # Accumulate points for each player for player_id, points in rounds: player_points[player_id] += points # Sort players first by points descending and then by player_id ascending sorted_players = sorted(player_points.keys(), key=lambda x: (-player_points[x], x)) return sorted_players"},{"question":"def subset_sum(nums, target): Determines if there is a subset of the nums array whose sum equals the target. :param nums: List of integers :param target: The target sum :return: True if such a subset exists, otherwise False Examples: >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> subset_sum([1, 2, 3, 4, 5], 11) True >>> subset_sum([1, 2, 3, 7, 8], 14) True >>> subset_sum([1, 2, 5], 4) False","solution":"def subset_sum(nums, target): Determines if there is a subset of the nums array whose sum equals the target. :param nums: List of integers :param target: The target sum :return: True if such a subset exists, otherwise False n = len(nums) dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True return dp[target]"},{"question":"def smallest_positive_integer_with_digit_sum(n: int) -> int: Returns the smallest positive integer x such that the sum of digits of x is equal to n, or -1 if no such x exists. >>> smallest_positive_integer_with_digit_sum(15) 69 >>> smallest_positive_integer_with_digit_sum(4) 4 >>> smallest_positive_integer_with_digit_sum(1) 1 >>> smallest_positive_integer_with_digit_sum(0) -1 >>> smallest_positive_integer_with_digit_sum(101) -1 from solution import smallest_positive_integer_with_digit_sum def test_case_1(): assert smallest_positive_integer_with_digit_sum(15) == 69 def test_case_2(): assert smallest_positive_integer_with_digit_sum(4) == 4 def test_case_3(): assert smallest_positive_integer_with_digit_sum(1) == 1 def test_case_4(): assert smallest_positive_integer_with_digit_sum(0) == -1 def test_case_5(): assert smallest_positive_integer_with_digit_sum(101) == -1 def test_case_6(): assert smallest_positive_integer_with_digit_sum(18) == 99 def test_case_7(): assert smallest_positive_integer_with_digit_sum(12) == 39 def test_case_8(): assert smallest_positive_integer_with_digit_sum(27) == 999","solution":"def smallest_positive_integer_with_digit_sum(n): Returns the smallest positive integer x such that the sum of digits of x is equal to n, or -1 if no such x exists. if n < 1 or n > 100: return -1 # Start constructing the smallest number that meets the condition digits = [] while n > 0: digit = min(n, 9) digits.append(digit) n -= digit # The smallest number would be created by sorting digits in ascending order digits.sort() return int(''.join(map(str, digits))) # Example usage # print(smallest_positive_integer_with_digit_sum(15)) # Output: 69 # print(smallest_positive_integer_with_digit_sum(4)) # Output: 4 # print(smallest_positive_integer_with_digit_sum(1)) # Output: 1"},{"question":"from typing import List, Union def is_prime(n: int) -> bool: Return True if n is a prime number, otherwise False if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True def prime_sum_pairs(M: int) -> Union[List[int], bool]: Return an arrangement of numbers 1..M such that the sum of each pair of adjacent numbers is a prime number and the sum of the first and last number is also a prime number. >>> prime_sum_pairs(10) [2, 1, 4, 3, 8, 5, 6, 7, 10, 9] >>> prime_sum_pairs(3) False >>> prime_sum_pairs(2) [1, 2] >>> prime_sum_pairs(4) [1, 2, 3, 4] >>> prime_sum_pairs(1) False pass","solution":"from itertools import permutations def is_prime(n): Check if a number is prime. if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i != 0: continue else: return False return True def prime_sum_pairs(M): Return an arrangement of numbers 1..M such that the sum of each pair of adjacent numbers is prime. if M < 2: return False def valid_permutation(perm): for i in range(M): if not is_prime(perm[i] + perm[(i + 1) % M]): return False return True for perm in permutations(range(1, M + 1)): if valid_permutation(perm): return list(perm) return False"},{"question":"def findDuplicate(nums: List[int]) -> int: Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive, returns the only repeated number in the array. Solve the problem without modifying nums and using only constant extra space. Args: nums (List[int]): Array of integers containing n + 1 integers where each integer is in the range [1, n] inclusive. Returns: int: The repeated number. >>> findDuplicate([1, 3, 4, 2, 2]) 2 >>> findDuplicate([3, 1, 3, 4, 2]) 3","solution":"def findDuplicate(nums): Returns the only one repeated number in the array nums. Args: nums (list of int): Array of integers containing n + 1 integers where each integer is in the range [1, n] inclusive. Returns: int: The repeated number. # Use Floyd's Tortoise and Hare (Cycle Detection) algorithm slow = nums[0] fast = nums[0] # Phase 1: Finding the intersection point of the two runners. while True: slow = nums[slow] fast = nums[nums[fast]] if slow == fast: break # Phase 2: Finding the entrance to the cycle. slow = nums[0] while slow != fast: slow = nums[slow] fast = nums[fast] return slow"},{"question":"def find_pair_with_sum(nums, target): Finds two indices of numbers in 'nums' that add up to 'target'. Args: nums (list of int): The list of numbers. target (int): The target sum. Returns: tuple of int: A tuple containing the indices of the two numbers that add up to 'target', or -1 if no such pair exists. pass def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) target = int(data[1]) nums = list(map(int, data[2:2 + n])) result = find_pair_with_sum(nums, target) if result == -1: print(result) else: print(result[0], result[1])","solution":"def find_pair_with_sum(nums, target): Finds two indices of numbers in 'nums' that add up to 'target'. Args: nums (list of int): The list of numbers. target (int): The target sum. Returns: tuple of int: A tuple containing the indices of the two numbers that add up to 'target', or -1 if no such pair exists. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return -1 def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) target = int(data[1]) nums = list(map(int, data[2:2 + n])) result = find_pair_with_sum(nums, target) if result == -1: print(result) else: print(result[0], result[1])"},{"question":"from typing import List, Tuple class Tree: def __init__(self, n): self.n = n self.values = [0] * (n + 1) self.children = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.visited = [False] * (n + 1) def add_edge(self, u, v): self.children[u].append(v) self.children[v].append(u) def add_value(self, i, x): self.values[i] += x def dfs(self, node): self.visited[node] = True total = self.values[node] for child in self.children[node]: if not self.visited[child]: total += self.dfs(child) self.subtree_sum[node] = total return total def calculate_subtree_sums(self): self.visited = [False] * (self.n + 1) self.dfs(1) def query(self, i): if self.subtree_sum[1] == 0: self.calculate_subtree_sums() return self.subtree_sum[i] def process_operations(n: int, edges: List[Tuple[int, int]], operations: List[str]) -> List[int]: Process a series of operations to modify node values and answer queries in a tree. >>> process_operations(5, [(1, 2), (1, 3), (1, 4), (4, 5)], [\\"add 2 10\\", \\"add 4 5\\", \\"query 1\\", \\"query 4\\", \\"query 5\\"]) [15, 5, 0] >>> process_operations(1, [], [\\"add 1 10\\", \\"query 1\\"]) [10] >>> process_operations(3, [(1, 2), (2, 3)], [\\"add 1 3\\", \\"add 2 2\\", \\"add 3 1\\", \\"query 1\\", \\"query 2\\", \\"query 3\\"]) [6, 3, 1] >>> process_operations(4, [(1, 2), (2, 3), (3, 4)], [\\"add 2 4\\", \\"query 1\\", \\"query 2\\", \\"query 3\\", \\"query 4\\"]) [4, 4, 0, 0] tree = Tree(n) for u, v in edges: tree.add_edge(u, v) results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": i = int(parts[1]) x = int(parts[2]) tree.add_value(i, x) tree.subtree_sum = [0] * (n + 1) elif parts[0] == \\"query\\": i = int(parts[1]) results.append(tree.query(i)) return results","solution":"class Tree: def __init__(self, n): self.n = n self.values = [0] * (n + 1) self.children = [[] for _ in range(n + 1)] self.subtree_sum = [0] * (n + 1) self.visited = [False] * (n + 1) def add_edge(self, u, v): self.children[u].append(v) self.children[v].append(u) def add_value(self, i, x): self.values[i] += x def dfs(self, node): self.visited[node] = True total = self.values[node] for child in self.children[node]: if not self.visited[child]: total += self.dfs(child) self.subtree_sum[node] = total return total def calculate_subtree_sums(self): self.visited = [False] * (self.n + 1) self.dfs(1) def query(self, i): if self.subtree_sum[1] == 0: # Recursively calculate only if not already done self.calculate_subtree_sums() return self.subtree_sum[i] def process_operations(n, edges, operations): tree = Tree(n) for u, v in edges: tree.add_edge(u, v) results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": i = int(parts[1]) x = int(parts[2]) tree.add_value(i, x) tree.subtree_sum = [0] * (n + 1) # Reset subtree sums since values have changed elif parts[0] == \\"query\\": i = int(parts[1]) results.append(tree.query(i)) return results"},{"question":"def can_fulfill_orders(n: int, p: int, orders: List[Tuple[int, int, int]]) -> str: Determine if it is possible to fulfill all the orders without exceeding the production capacity on any given day. >>> can_fulfill_orders(3, 100, [(30, 20, 40), (50, 30, 10), (40, 35, 20)]) \\"YES\\" >>> can_fulfill_orders(2, 90, [(50, 30, 20), (30, 40, 30)]) \\"NO\\"","solution":"def can_fulfill_orders(n, p, orders): for order in orders: g, s, b = order if g + s + b > p: return \\"NO\\" return \\"YES\\" # Example usage: # n = 3 # p = 100 # orders = [(30, 20, 40), (50, 30, 10), (40, 35, 20)] # print(can_fulfill_orders(n, p, orders)) # Output: YES"},{"question":"def max_packages(W: int, n: int, weights: List[int]) -> int: Determine the maximum number of packages that can be loaded onto the truck without exceeding the weight limit W. >>> max_packages(50, 5, [10, 20, 30, 40, 50]) == 2 >>> max_packages(100, 7, [15, 25, 35, 45, 55, 65, 75]) == 3","solution":"def max_packages(W, n, weights): Determine the maximum number of packages that can be loaded onto the truck without exceeding the weight limit W. Args: W (int): Weight limit of the truck. n (int): Number of packages. weights (list of int): Weights of the packages. Returns: int: Maximum number of packages that can be loaded onto the truck. weights.sort() count = 0 current_weight = 0 for weight in weights: if current_weight + weight <= W: current_weight += weight count += 1 else: break return count"},{"question":"def is_special_number(k_list, query_list): Determine if each number in the query list can be expressed as the sum of two or more distinct integers from k_list. :param k_list: List of integers from Khaleed's list. :param query_list: List of integers to check. :return: List of \\"YES\\" or \\"NO\\" for each query in query_list. >>> is_special_number([1, 2, 3, 5, 8], [8, 15, 7]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_special_number([4, 7, 2, 9], [11, 5]) [\\"YES\\", \\"NO\\"] >>> is_special_number([10], [10, 20, 30]) [\\"NO\\", \\"NO\\", \\"NO\\"] >>> is_special_number([1, 2, 3, 4, 5], [3, 5, 7, 9]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> is_special_number([1000000000, 2000000000], [3000000000, 4000000000]) [\\"YES\\", \\"NO\\"]","solution":"def is_special_number(k_list, query_list): Determine if each number in the query list can be expressed as the sum of two or more distinct integers from k_list. :param k_list: List of integers from Khaleed's list. :param query_list: List of integers to check. :return: List of \\"YES\\" or \\"NO\\" for each query in query_list. # Convert k_list to a set for O(1) membership checks k_set = set(k_list) result = [] # Check each query number for query in query_list: found = False # Check all pairs of distinct numbers in k_list for i in range(len(k_list)): for j in range(i + 1, len(k_list)): # Check if the sum of the pair is equal to query if k_list[i] + k_list[j] == query: found = True break if found: break # Append the result for the current query result.append(\\"YES\\" if found else \\"NO\\") return result"},{"question":"def min_parentheses_to_balance(t: int, test_cases: List[str]) -> List[int]: Determine the minimum number of parentheses to be added to make each string balanced. >>> min_parentheses_to_balance(3, [\\"()\\", \\")(\\", \\"(()\\"]) [0, 2, 1] >>> min_parentheses_to_balance(2, [\\"(\\", \\"))))((\\"]) [1, 6]","solution":"def min_parentheses_to_balance(t, test_cases): def balance_count(s): open_count = close_needed = 0 for char in s: if char == '(': open_count += 1 else: # char == ')' if open_count > 0: open_count -= 1 else: close_needed += 1 return open_count + close_needed results = [] for s in test_cases: results.append(balance_count(s)) return results"},{"question":"from typing import List def groupAnagrams(strs: List[str]) -> List[List[str]]: Groups anagrams together from the given list of strings. Args: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sublist contains anagrams. >>> groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] >>> groupAnagrams([\\"\\"]) [[\\"\\"]] >>> groupAnagrams([\\"a\\"]) [[\\"a\\"]] pass # Unit Tests def test_group_anagrams_example1(): assert groupAnagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] def test_group_anagrams_example2(): assert groupAnagrams([\\"\\"]) == [[\\"\\"]] def test_group_anagrams_example3(): assert groupAnagrams([\\"a\\"]) == [[\\"a\\"]] def test_group_anagrams_mixed_cases(): assert groupAnagrams([\\"\\", \\"b\\", \\"\\", \\"bb\\", \\"b\\", \\"\\"]) == [[\\"\\", \\"\\", \\"\\"], [\\"b\\", \\"b\\"], [\\"bb\\"]] def test_group_anagrams_no_anagram(): assert groupAnagrams([\\"abc\\", \\"def\\", \\"ghi\\"]) == [[\\"abc\\"], [\\"def\\"], [\\"ghi\\"]] def test_group_anagrams_all_same_words(): assert groupAnagrams([\\"abc\\", \\"abc\\", \\"abc\\"]) == [[\\"abc\\", \\"abc\\", \\"abc\\"]] def test_group_anagrams_varied_lengths(): assert groupAnagrams([\\"ab\\", \\"ba\\", \\"a\\", \\"aab\\", \\"aba\\"]) == [[\\"ab\\", \\"ba\\"], [\\"a\\"], [\\"aab\\", \\"aba\\"]]","solution":"from collections import defaultdict def groupAnagrams(strs): Groups anagrams together from the given list of strings. Args: strs (List[str]): A list of strings. Returns: List[List[str]]: A list of lists where each sublist contains anagrams. anagrams = defaultdict(list) for s in strs: # Sort the string to obtain the key key = ''.join(sorted(s)) anagrams[key].append(s) return list(anagrams.values())"},{"question":"def classify_word(word: str) -> str: Determines if a word is \\"happy\\" or \\"sad\\" based on the presence of consecutive identical letters. >>> classify_word(\\"bookkeeper\\") \\"happy\\" >>> classify_word(\\"unique\\") \\"sad\\" >>> classify_word(\\"aa\\") \\"happy\\" >>> classify_word(\\"a\\") \\"sad\\" >>> classify_word(\\"ab\\") \\"sad\\" >>> classify_word(\\"abcdefghijklmnopqrstuvwxy\\") \\"sad\\" >>> classify_word(\\"abcdefghijkllmnopqrstuvwxy\\") \\"happy\\"","solution":"def classify_word(word): Determines if a word is \\"happy\\" or \\"sad\\" based on the presence of consecutive identical letters. Args: word (str): The word to classify. Returns: str: \\"happy\\" if the word has consecutive identical letters, otherwise \\"sad\\". for i in range(1, len(word)): if word[i] == word[i - 1]: return \\"happy\\" return \\"sad\\""},{"question":"from typing import List def min_moves_to_reach_end(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of moves required for the robot to reach the bottom-right corner of the grid, or return -1 if it is not possible. >>> min_moves_to_reach_end(4, 4, [ ... \\"....\\", ... \\"..\\", ... \\"....\\", ... \\"....\\" ... ]) == 6 >>> min_moves_to_reach_end(3, 3, [ ... \\"..#\\", ... \\".#.\\", ... \\".#.\\" ... ]) == -1","solution":"from collections import deque def min_moves_to_reach_end(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up visited = [[False] * m for _ in range(n)] visited[0][0] = True queue = deque([(0, 0, 0)]) # (x, y, distance) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List, Tuple def calculate_scores(n: int, m: int, grid: List[List[int]]) -> Tuple[int, int]: Calculate the final score for both Alice and Bob based on the markers placed on the 2D grid. Args: n: int : number of rows in the grid m: int : number of columns in the grid grid: List[List[int]] : 2D grid representing the state of the game with 0, 1 and 2 values Returns: Tuple[int, int] : final score of Alice and Bob Example: >>> n = 4; m = 4 >>> grid = [ ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> calculate_scores(n, m, grid) (1, 0) >>> n = 5; m = 5 >>> grid = [ ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 1, 1, 1, 1] ... ] >>> calculate_scores(n, m, grid) (9, 0)","solution":"def calculate_scores(n, m, grid): alice_score = 0 bob_score = 0 # Define a function to check a 3x3 grid def check_subgrid(x, y): nonlocal alice_score, bob_score alice_count = 0 bob_count = 0 for i in range(x, x+3): for j in range(y, y+3): if grid[i][j] == 1: alice_count += 1 elif grid[i][j] == 2: bob_count += 1 if alice_count == 9: alice_score += 1 elif bob_count == 9: bob_score += 1 # Iterate through each possible 3x3 subgrid for i in range(n-2): for j in range(m-2): check_subgrid(i, j) return alice_score, bob_score"},{"question":"def encrypt_title(title: str, k: int) -> str: Encrypts the artwork title using a Caesar cipher with a fixed rotation k. Args: title (str): The artwork's title to be encrypted. k (int): The number of positions to rotate characters. Returns: str: The encrypted title. Examples: >>> encrypt_title(\\"Hello Artwork\\", 3) 'Khoor Duwzrun' >>> encrypt_title(\\"Art is Fun\\", 1) 'Bsu jt Gvo' from solution import encrypt_title def test_example_1(): assert encrypt_title(\\"Hello Artwork\\", 3) == \\"Khoor Duwzrun\\" def test_example_2(): assert encrypt_title(\\"Art is Fun\\", 1) == \\"Bsu jt Gvo\\" def test_with_special_characters(): assert encrypt_title(\\"Wow! This is cool.\\", 5) == \\"Btb! Ymnx nx httq.\\" def test_with_no_rotation(): assert encrypt_title(\\"Stay the same\\", 0) == \\"Stay the same\\" def test_full_rotation(): assert encrypt_title(\\"Wrap around\\", 26) == \\"Wrap around\\" def test_lowercase_rotation(): assert encrypt_title(\\"abc xyz\\", 2) == \\"cde zab\\" def test_uppercase_rotation(): assert encrypt_title(\\"ABC XYZ\\", 2) == \\"CDE ZAB\\" def test_mix_case_rotation(): assert encrypt_title(\\"AbC XyZ\\", 2) == \\"CdE ZaB\\" def test_zero_input(): assert encrypt_title(\\"\\", 3) == \\"\\"","solution":"def encrypt_title(title, k): Encrypts the artwork title using a Caesar cipher with a fixed rotation k. Parameters: - title (str): The artwork's title to be encrypted. - k (int): The number of positions to rotate characters. Returns: - str: The encrypted title. encrypted_title = [] for char in title: if char.isalpha(): if char.islower(): encrypted_title.append(chr((ord(char) - ord('a') + k) % 26 + ord('a'))) elif char.isupper(): encrypted_title.append(chr((ord(char) - ord('A') + k) % 26 + ord('A'))) else: encrypted_title.append(char) return ''.join(encrypted_title)"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates a 2D matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D matrix to be rotated Returns: list of list of int: Rotated 2D matrix >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix_90_clockwise([ ... [1] ... ]) [[1]] >>> rotate_matrix_90_clockwise([]) [] >>> rotate_matrix_90_clockwise([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [[13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates a 2D matrix 90 degrees clockwise. Parameters: matrix (list of list of int): 2D matrix to be rotated Returns: list of list of int: Rotated 2D matrix return [list(row) for row in zip(*matrix[::-1])]"},{"question":"def num_unique_elements_after_k_operations(n: int, k: int, arr: List[int]) -> int: Given an array arr of length n, this function returns the number of unique elements after performing the XOR operation k times. >>> num_unique_elements_after_k_operations(3, 2, [2, 4, 3]) 3 >>> num_unique_elements_after_k_operations(4, 1, [1, 2, 3, 1]) 3 >>> num_unique_elements_after_k_operations(5, 10, [1, 1, 1, 1, 1]) 1 >>> num_unique_elements_after_k_operations(4, 0, [1, 2, 3, 4]) 4 >>> num_unique_elements_after_k_operations(5, 1000000000, [5, 6, 7, 6, 5]) 3 >>> num_unique_elements_after_k_operations(200000, 1000000000, list(range(200000))) 200000","solution":"def num_unique_elements_after_k_operations(n, k, arr): Given an array arr of length n, this function returns the number of unique elements after performing the XOR operation k times. # Number of unique elements before any operation unique_elements = set(arr) # The maximum number of unique elements can't change after any k operations return len(unique_elements)"},{"question":"def min_operations_to_convert(n: int, S: str, T: str) -> int: Determine the minimum number of operations required to convert string S to string T. Each operation consists of incrementing the character at any position in S (with wrap-around so 'z' becomes 'a'). Args: n (int): Length of the strings S and T. S (str): Source string. T (str): Target string. Returns: int: Minimum number of operations required to convert S to T. Examples: >>> min_operations_to_convert(5, 'abcde', 'cdefg') 10 >>> min_operations_to_convert(3, 'xyz', 'xyz') 0 >>> min_operations_to_convert(1, 'a', 'b') 1 >>> min_operations_to_convert(3, 'zab', 'abc') 3 >>> min_operations_to_convert(3, 'aaa', 'zzz') 75","solution":"def min_operations_to_convert(n, S, T): total_operations = 0 for i in range(n): # Calculate the distance between the current characters distance = (ord(T[i]) - ord(S[i])) % 26 total_operations += distance return total_operations"},{"question":"def group_anagrams(s: str) -> List[List[str]]: Groups words based on their anagrams and sorts the groups and words within each group. Args: s (str): A string containing words separated by spaces Returns: List[List[str]]: A list of lists where each sublist contains anagrams Examples: >>> group_anagrams(\\"bat tab rat art tar\\") [[\\"art\\", \\"rat\\", \\"tar\\"], [\\"bat\\", \\"tab\\"]] >>> group_anagrams(\\"cider cried apple elppa\\") [[\\"apple\\", \\"elppa\\"], [\\"cider\\", \\"cried\\"]] from solution import group_anagrams def test_group_anagrams_example_1(): input_str = \\"bat tab rat art tar\\" expected_output = [[\\"art\\", \\"rat\\", \\"tar\\"], [\\"bat\\", \\"tab\\"]] assert group_anagrams(input_str) == expected_output def test_group_anagrams_example_2(): input_str = \\"cider cried apple elppa\\" expected_output = [[\\"apple\\", \\"elppa\\"], [\\"cider\\", \\"cried\\"]] assert group_anagrams(input_str) == expected_output def test_group_anagrams_no_anagrams(): input_str = \\"one two three\\" expected_output = [[\\"one\\"], [\\"three\\"], [\\"two\\"]] assert group_anagrams(input_str) == expected_output def test_group_anagrams_all_same_word(): input_str = \\"same same same\\" expected_output = [[\\"same\\", \\"same\\", \\"same\\"]] assert group_anagrams(input_str) == expected_output def test_group_anagrams_mixed_case(): input_str = \\"unix nixu xiun\\" expected_output = [[\\"nixu\\", \\"unix\\", \\"xiun\\"]] assert group_anagrams(input_str) == expected_output def test_group_anagrams_empty_string(): input_str = \\"\\" expected_output = [] assert group_anagrams(input_str) == expected_output","solution":"def group_anagrams(s): Groups words based on their anagrams and sorts the groups and words within each group. Args: s (str): A string containing words separated by spaces Returns: List[List[str]]: A list of lists where each sublist contains anagrams from collections import defaultdict # Split the input string into words words = s.split() # Dictionary to hold our groups based on sorted character strings anagram_groups = defaultdict(list) # Group words by their sorted character strings for word in words: sorted_word = ''.join(sorted(word)) anagram_groups[sorted_word].append(word) # List to hold our final groups result = [] # For each group of anagrams, sort the group and add to result for group in anagram_groups.values(): result.append(sorted(group)) # Sort the list of groups by the first word in each group result.sort(key=lambda x: x[0]) return result"},{"question":"def can_attend_all_events(t, test_cases): Determine if Alex can attend all events without any overlap. >>> can_attend_all_events(3, [(3, [(10, 30), (12, 45), (17, 15)]), (2, [(8, 0), (8, 0)]), (4, [(23, 50), (23, 55), (0, 5), (0, 10)])]) == [\\"YES\\", \\"NO\\", \\"YES\\"] results = [] for i in range(t): n = test_cases[i][0] events = test_cases[i][1] # Convert all events to minutes since start of the day for easy comparison event_times = set() can_attend = True for hour, minute in events: time_in_minutes = hour * 60 + minute if time_in_minutes in event_times: can_attend = False break event_times.add(time_in_minutes) if can_attend: results.append(\\"YES\\") else: results.append(\\"NO\\") return results","solution":"def can_attend_all_events(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] events = test_cases[i][1] # Convert all events to minutes since start of the day for easy comparison event_times = set() can_attend = True for hour, minute in events: time_in_minutes = hour * 60 + minute if time_in_minutes in event_times: can_attend = False break event_times.add(time_in_minutes) if can_attend: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_valid_date(dateStr: str) -> bool: Determines if the given date string in the format MM-DD-YYYY is valid. >>> is_valid_date('12-31-2020') == True >>> is_valid_date('02-30-2020') == False >>> is_valid_date('04-31-2021') == False >>> is_valid_date('06-15-1990') == True >>> is_valid_date('13-01-2020') == False >>> is_valid_date('02-29-2020') == True >>> is_valid_date('02-29-2021') == False pass","solution":"def is_valid_date(dateStr: str) -> bool: Checks if the given date string in the MM-DD-YYYY format is valid. # Extracting month, day, and year month = int(dateStr[0:2]) day = int(dateStr[3:5]) year = int(dateStr[6:10]) # Checking for valid month if month < 1 or month > 12: return False # Days in each month days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Check for leap year if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): days_in_month[1] = 29 # February has 29 days in leap years # Checking for valid day if day < 1 or day > days_in_month[month - 1]: return False return True"},{"question":"def rotateArray(arr, k): Rotates array arr to the right by k steps. :param arr: List of integers to be rotated. :param k: Number of steps to rotate the array. :return: Rotated list of integers. pass def test_rotateArray_sample_input_0(): arr = [1, 2, 3, 4, 5] k = 2 expected = [4, 5, 1, 2, 3] assert rotateArray(arr, k) == expected def test_rotateArray_sample_input_1(): arr = [7, 9, 2] k = 1 expected = [2, 7, 9] assert rotateArray(arr, k) == expected def test_rotateArray_k_zero(): arr = [1, 2, 3, 4, 5] k = 0 expected = [1, 2, 3, 4, 5] assert rotateArray(arr, k) == expected def test_rotateArray_k_greater_than_length(): arr = [1, 2, 3] k = 4 expected = [3, 1, 2] assert rotateArray(arr, k) == expected def test_rotateArray_single_element(): arr = [1] k = 10 expected = [1] assert rotateArray(arr, k) == expected","solution":"def rotateArray(arr, k): Rotates array arr to the right by k steps. :param arr: List of integers to be rotated. :param k: Number of steps to rotate the array. :return: Rotated list of integers. n = len(arr) k = k % n # Ensure k is within the bounds of the array length return arr[-k:] + arr[:-k]"},{"question":"def is_mountain_array(arr): Determine if the given list of integers is a mountain array. Parameters: arr (List[int]): The list of integers to check. Returns: bool: True if the list is a mountain array, False otherwise. >>> is_mountain_array([2, 1]) False >>> is_mountain_array([3, 5, 5]) False >>> is_mountain_array([0, 3, 2, 1]) True >>> is_mountain_array([0, 2, 3, 4, 5, 2, 1, 0]) True >>> is_mountain_array([0, 1, 2, 3, 4, 5]) False >>> is_mountain_array([5, 4, 3, 2, 1, 0]) False >>> is_mountain_array([3, 3, 3]) False >>> is_mountain_array([]) False >>> is_mountain_array([1, 2, 3, 4, 3, 2, 1, 1]) False >>> is_mountain_array([3, 6, 9, 12, 11, 4, 2]) True >>> is_mountain_array([1, 2, 3, 2, 1, 2, 3, 2, 1]) False pass","solution":"def is_mountain_array(arr): Determine if the given list of integers is a mountain array. Parameters: arr (List[int]): The list of integers to check. Returns: bool: True if the list is a mountain array, False otherwise. n = len(arr) if n < 3: return False i = 0 # walk up while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # peak can't be first or last if i == 0 or i == n - 1: return False # walk down while i + 1 < n and arr[i] > arr[i + 1]: i += 1 return i == n - 1"},{"question":"def find_single_number(arr): Returns the element that appears only once in the array. Parameters: arr (list): A list of integers where each element appears twice except for one element which appears only once. Returns: int: The element that appears only once. >>> find_single_number([2, 3, 4, 2, 3]) 4 >>> find_single_number([1, 2, 2, 3, 3]) 1 >>> find_single_number([4, 1, 1, 2, 2]) 4 >>> find_single_number([2, -1, -1, 3, 3, 2, 4]) 4 >>> find_single_number([10000, 9999, 9999, 10000, 12345]) 12345 >>> find_single_number([4, 3, 3, 2, 2, 1, 1, 4, 6]) 6","solution":"def find_single_number(arr): Returns the element that appears only once in the array. Parameters: arr (list): A list of integers where each element appears twice except for one element which appears only once. Returns: int: The element that appears only once. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"def min_cost_to_supply_electricity(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimum total cost to supply electricity to all cities, or return -1 if not possible. >>> min_cost_to_supply_electricity(2, 3, [(1, 1, 10), (1, 2, 15), (2, 2, 20), (2, 3, 30)]) 55 >>> min_cost_to_supply_electricity(2, 3, [(1, 1, 10), (1, 2, 15), (2, 2, 20)]) -1","solution":"import heapq def min_cost_to_supply_electricity(N, M, connections): Determine the minimum total cost to supply electricity to all cities (or -1 if not possible). :param N: int - number of power plants :param M: int - number of cities :param connections: list of tuples (u, v, w) - each tuple represents a connection with cost \`w\` from power plant \`u\` to city \`v\` :return: int - minimum total cost, or -1 if it is not possible to supply electricity to all cities # Create a list to store the min cost to connect each city to a power plant min_cost = [float('inf')] * M # Fill the min_cost list with the minimum cost from the input connections for u, v, w in connections: v -= 1 # change city index to 0-based for convenience min_cost[v] = min(min_cost[v], w) # find the minimum cost for each city # Check if all cities can be connected if any(cost == float('inf') for cost in min_cost): return -1 # Sum the minimum costs to connect all cities return sum(min_cost)"},{"question":"def min_unique_substrings(s: str) -> int: Returns the minimum number of substrings needed such that each substring contains unique characters. >>> min_unique_substrings(\\"abac\\") 2 >>> min_unique_substrings(\\"aaaaa\\") 5 >>> min_unique_substrings(\\"abcd\\") 1","solution":"def min_unique_substrings(s): Returns the minimum number of substrings needed such that each substring contains unique characters. if not s: return 0 substr_count = 0 seen_chars = set() for char in s: if char in seen_chars: substr_count += 1 seen_chars = set() seen_chars.add(char) # Account for the last substring return substr_count + 1"},{"question":"def minOperations(s: str) -> int: Given a string \`s\` consisting of lowercase English alphabets, find the minimum number of operations needed to make all characters of the string the same. In one operation, you can select any character in the string and change it to any other lowercase English character. Parameters: s (str): string consisting of lowercase English alphabets Returns: int: minimum number of operations pass from solution import minOperations def test_example_cases(): assert minOperations(\\"aab\\") == 1 assert minOperations(\\"abc\\") == 2 def test_single_character(): assert minOperations(\\"a\\") == 0 assert minOperations(\\"z\\") == 0 def test_all_same_characters(): assert minOperations(\\"aaaa\\") == 0 assert minOperations(\\"bbbbbb\\") == 0 def test_all_different_characters(): assert minOperations(\\"abcdef\\") == 5 assert minOperations(\\"zyxwvut\\") == 6 def test_mixed_case_characters(): assert minOperations(\\"aabbcc\\") == 4 assert minOperations(\\"aabbcccc\\") == 4 def test_large_input_same_characters(): assert minOperations(\\"a\\" * 100000) == 0 def test_large_input_mixed_characters(): input_str = \\"a\\" * 50000 + \\"b\\" * 30000 + \\"c\\" * 20000 assert minOperations(input_str) == 50000","solution":"def minOperations(s): Returns the minimum number of operations needed to make all characters of the string the same. In one operation, you can select any character in the string and change it to any other lowercase English character. Parameters: s (str): string consisting of lowercase English alphabets Returns: int: minimum number of operations # Get the maximum frequency of any character in the string max_freq = max(s.count(char) for char in set(s)) # The minimum operations needed to make all characters the same return len(s) - max_freq"},{"question":"def min_moves_to_make_equal(t: int, test_cases: list) -> list: Returns the minimum number of moves required to make all elements of the array equal for each test case. Parameters: t (int): Number of test cases test_cases (list of tuple): List of tuples where each tuple contains n(int) and an array of n integers Returns: list of int: Minimum number of moves for each test case >>> min_moves_to_make_equal(3, [(3, [1, 2, 3]), (4, [1, 1, 1, 1]), (2, [1000000000, 1000000000])]) [2, 0, 0] >>> min_moves_to_make_equal(1, [(1, [10])]) [0] >>> min_moves_to_make_equal(2, [(5, [7, 7, 7, 7, 7]), (3, [5, 5, 5])]) [0, 0] >>> min_moves_to_make_equal(2, [(3, [1000000000, 1, 1000000000]), (4, [1, 1000000000, 1000000000, 1])]) [999999999, 1999999998] >>> min_moves_to_make_equal(1, [(5, [1, 2, 3, 4, 5])]) [6]","solution":"def min_moves_to_make_equal(t, test_cases): Returns the minimum number of moves required to make all elements of the array equal for each test case. Parameters: t (int): Number of test cases test_cases (list of tuple): List of tuples where each tuple contains n(int) and an array of n integers Returns: list of int: Minimum number of moves for each test case results = [] for n, arr in test_cases: median = sorted(arr)[n // 2] moves = sum(abs(x - median) for x in arr) results.append(moves) return results"},{"question":"from typing import List def word_ladder(start: str, end: str, word_list: List[str]) -> int: Attempt to transform \`start\` into \`end\` by changing exactly one letter at a time, with each intermediate word existing within \`word_list\`. Return the minimum number of transformations needed to transform \`start\` into \`end\`. If no transformation sequence is possible, return 0. >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 5 >>> word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 def test_example_cases(): assert word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 5 assert word_ladder(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 def test_edge_cases(): assert word_ladder(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) == 2 assert word_ladder(\\"hit\\", \\"hit\\", [\\"hit\\"]) == 1 assert word_ladder(\\"hit\\", \\"hit\\", []) == 0 assert word_ladder(\\"hit\\", \\"hat\\", [\\"hat\\"]) == 2 def test_no_possible_transformation(): assert word_ladder(\\"hit\\", \\"xyz\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 assert word_ladder(\\"game\\", \\"code\\", [\\"gape\\",\\"tape\\",\\"totd\\",\\"tode\\"]) == 0 def test_longer_transformations(): assert word_ladder(\\"hit\\", \\"cut\\", [\\"hot\\",\\"dot\\",\\"cot\\",\\"cut\\"]) == 4 assert word_ladder(\\"hit\\", \\"log\\", [\\"hit\\",\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 4","solution":"from collections import deque def word_ladder(start, end, word_list): if end not in word_list: return 0 word_list = set(word_list) queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for char in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_list: queue.append((next_word, steps + 1)) word_list.remove(next_word) return 0"},{"question":"def min_lights_to_illuminate(grid, m, n): Returns the minimum number of lights required to fully illuminate the grid and the list of coordinates where the lights need to be placed. >>> min_lights_to_illuminate([\\"111\\", \\"111\\", \\"111\\"], 3, 3) (0, []) >>> min_lights_to_illuminate([\\"1000\\", \\"0000\\", \\"0000\\", \\"0001\\"], 4, 4) (2, [(1, 1), (2, 2)]) >>> min_lights_to_illuminate([\\"0000\\"], 1, 4) (1, [(0, 0)]) >>> min_lights_to_illuminate([\\"0\\", \\"0\\", \\"0\\", \\"0\\"], 4, 1) (1, [(0, 0)]) >>> min_lights_to_illuminate([\\"101\\", \\"010\\", \\"101\\"], 3, 3) (0, []) >>> min_lights_to_illuminate([\\"100\\", \\"000\\", \\"001\\"], 3, 3) (1, [(1, 1)]) # Your code here","solution":"def min_lights_to_illuminate(grid, m, n): Returns the minimum number of lights required to fully illuminate the grid and the list of coordinates where the lights need to be placed. rows = [False] * m cols = [False] * n for i in range(m): for j in range(n): if grid[i][j] == '1': rows[i] = True cols[j] = True lights = [] for i in range(m): if not rows[i]: for j in range(n): if not cols[j]: lights.append((i, j)) rows[i] = True cols[j] = True break return len(lights), lights"},{"question":"def minimum_roads_to_connect(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Determine the minimum number of roads to add to make the graph connected. Args: N (int): Number of vertices. M (int): Number of edges. edges (List[Tuple[int, int]]): List of edges. Returns: int: Minimum number of roads required to make the graph connected. >>> minimum_roads_to_connect(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) == 1 >>> minimum_roads_to_connect(3, 0, []) == 2 >>> minimum_roads_to_connect(4, 2, [(1, 2), (3, 4)]) == 1 >>> minimum_roads_to_connect(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) == 0 >>> minimum_roads_to_connect(3, 1, [(1, 2)]) == 1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def minimum_roads_to_connect(N, M, edges): parent = [i for i in range(N+1)] rank = [0] * (N+1) for edge in edges: union(parent, rank, edge[0], edge[1]) components = set() for i in range(1, N+1): components.add(find(parent, i)) return len(components) - 1 # Sample usage # print(minimum_roads_to_connect(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)])) # Output: 1"},{"question":"from typing import List def find_missing_number(lst: List[int]) -> int: Given a list of integers from 1 to n with one integer missing, finds the missing integer. >>> find_missing_number([1, 2, 3, 5]) 4 >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 5, 6]) 4 Unit Test: from solution import find_missing_number def test_find_missing_number(): assert find_missing_number([1, 2, 3, 5]) == 4 assert find_missing_number([1, 2, 4, 5, 6]) == 3 assert find_missing_number([3, 7, 1, 2, 8, 5, 6]) == 4 assert find_missing_number([5, 4, 2, 1]) == 3 assert find_missing_number([2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1 assert find_missing_number([1, 2, 3, 4, 5, 6, 7, 8, 10]) == 9 assert find_missing_number([1]) == 2 assert find_missing_number([2]) == 1 def test_find_missing_number_large_sequence(): lst = list(range(1, 100001)) lst.remove(78999) assert find_missing_number(lst) == 78999","solution":"from typing import List def find_missing_number(lst: List[int]) -> int: Given a list of integers from 1 to n with one integer missing, finds the missing integer. n = len(lst) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(lst) missing_number = total_sum - actual_sum return missing_number"},{"question":"def generateMatrix(n: int) -> list: Generates a square matrix of size n x n where each element is the product of its row and column indices (1-based). Parameters: n (int): The size of the matrix (number of rows and columns) Returns: list: A 2D list (matrix) where each element is the product of its row and column indices Examples: >>> generateMatrix(2) [[1, 2], [2, 4]] >>> generateMatrix(3) [[1, 2, 3], [2, 4, 6], [3, 6, 9]]","solution":"def generateMatrix(n): Generates a square matrix of size n x n where each element is the product of its row and column indices (1-based). Parameters: n (int): The size of the matrix (number of rows and columns) Returns: list: A 2D list (matrix) where each element is the product of its row and column indices return [[(i+1)*(j+1) for j in range(n)] for i in range(n)]"},{"question":"def is_palindrome(s: str) -> bool: Check if the string s is a palindrome. >>> is_palindrome(\\"abba\\") True >>> is_palindrome(\\"abcba\\") True >>> is_palindrome(\\"abcd\\") False >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"aa\\") True def generate_palindrome_permutations(s: str): Generate all unique palindrome permutations of the string s. >>> generate_palindrome_permutations(\\"aabb\\") abba baab >>> generate_palindrome_permutations(\\"abc\\") No palindromes found >>> generate_palindrome_permutations(\\"a\\") a >>> generate_palindrome_permutations(\\"aa\\") aa >>> generate_palindrome_permutations(\\"aaaa\\") aaaa","solution":"from itertools import permutations def is_palindrome(s): Check if the string s is a palindrome. return s == s[::-1] def generate_palindrome_permutations(s): Generate all unique palindrome permutations of the string s. unique_permutations = set(permutations(s)) palindrome_permutations = [\\"\\".join(p) for p in unique_permutations if is_palindrome(\\"\\".join(p))] if palindrome_permutations: for pal in palindrome_permutations: print(pal) else: print(\\"No palindromes found\\")"},{"question":"def subset_sum_exists(t: int, test_cases: list) -> list: Given a list of integers, determine if there exists a subset of the list which sums to a given target value. If such a subset exists, output \\"YES\\", otherwise output \\"NO\\". >>> subset_sum_exists(3, [((3, 5), [2, 1, 3]), ((4, 10), [1, 2, 3, 4]), ((5, 0), [1, 2, 3, 4, 5])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> subset_sum_exists(1, [((1, 5), [5])]) [\\"YES\\"] >>> subset_sum_exists(1, [((1, 1000000000), [1000000000])]) [\\"YES\\"] >>> subset_sum_exists(1, [((5, 100), [1, 2, 3, 4, 5])]) [\\"NO\\"] >>> subset_sum_exists(1, [((4, 10), [1, 2, 3, 4])]) [\\"YES\\"] >>> subset_sum_exists(1, [((5, 9), [2, 3, 5, 7, 1])]) [\\"YES\\"]","solution":"def subset_sum_exists(t, test_cases): from itertools import combinations results = [] for i in range(t): n, k = test_cases[i][0] array = test_cases[i][1] found = False # Check all possible subsets for subset_size in range(1, n + 1): for subset in combinations(array, subset_size): if sum(subset) == k: found = True break if found: break if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def spelling_bee(word: str) -> str: Determines whether the student wins or loses in the spelling bee game. >>> spelling_bee(\\"student14\\") \\"Lose\\" >>> spelling_bee(\\"m@d@m\\") \\"Win\\"","solution":"def is_palindrome(word): return word == word[::-1] def modify_word(word): next_consonant = { 'a': 'b', 'e': 'f', 'i': 'j', 'o': 'p', 'u': 'v' } prev_consonant = { 'b': 'a', 'c': 'b', 'd': 'c', 'f': 'e', 'g': 'f', 'h': 'g', 'j': 'i', 'k': 'j', 'l': 'k', 'm': 'l', 'n': 'm', 'p': 'o', 'q': 'p', 'r': 'q', 's': 'r', 't': 's', 'v': 'u', 'w': 'v', 'x': 'w', 'y': 'x', 'z': 'y' } modified_word = [] for char in word: if char in next_consonant: modified_word.append(next_consonant[char]) elif char in prev_consonant: modified_word.append(prev_consonant[char]) else: modified_word.append(char) return ''.join(modified_word) def spelling_bee(word): modified_word = modify_word(word) if is_palindrome(modified_word): return \\"Win\\" else: return \\"Lose\\""},{"question":"def max_possible_sum_after_removal(n, arr): Returns the maximum possible sum of the array after removing one element. Parameters: n (int): The size of the array arr (list of int): The elements of the array Returns: int: The maximum possible sum of the remaining elements >>> max_possible_sum_after_removal(5, [1, 2, 3, 4, 5]) 14 >>> max_possible_sum_after_removal(4, [10, 10, 10, 10]) 30 >>> max_possible_sum_after_removal(3, [7, 3, 5]) 12 pass","solution":"def max_possible_sum_after_removal(n, arr): Returns the maximum possible sum of the array after removing one element. Parameters: n (int): The size of the array arr (list of int): The elements of the array Returns: int: The maximum possible sum of the remaining elements total_sum = sum(arr) return total_sum - min(arr)"},{"question":"def can_form_palindrome(s: str) -> str: Determines whether a given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aaabbbb\\") 'YES' >>> can_form_palindrome(\\"cdefghmnopqrstuvw\\") 'NO'","solution":"def can_form_palindrome(s): Determines whether a given string can be rearranged to form a palindrome. Parameters: s (str): A string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged into a palindrome if it has at most one character with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def isValidPassword(password: str) -> bool: Check if the input string is a valid password. A string is considered a valid password if it: - Has at least 6 characters and at most 12 characters. - Contains at least one uppercase letter [A-Z]. - Contains at least one lowercase letter [a-z]. - Contains at least one digit [0-9]. - Does not contain any spaces. Examples: >>> isValidPassword(\\"Abc123\\") True >>> isValidPassword(\\"abc123\\") False","solution":"def isValidPassword(password): Returns True if the password is valid, otherwise returns False. if not (6 <= len(password) <= 12): return False has_upper = has_lower = has_digit = False for char in password: if char.isdigit(): has_digit = True elif char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isspace(): return False return has_upper and has_lower and has_digit"},{"question":"from itertools import permutations def print_permutations(S: str, k: int) -> None: Print all k length permutations of the string S in lexicographic sorted order. >>> print_permutations(\\"HACK\\", 2) AC AH AK CA CH CK HA HC HK KA KC KH","solution":"from itertools import permutations def print_permutations(S, k): Prints all k length permutations of the string S in lexicographic order. sorted_permutations = sorted([''.join(p) for p in permutations(S, k)]) for p in sorted_permutations: print(p) # Example usage if __name__ == \\"__main__\\": input_string = \\"HACK 2\\" S, k = input_string.split() k = int(k) print_permutations(S, k)"},{"question":"def minimizedMaximumSum(n: int, k: int, array: List[int]) -> int: Alex is given an array of positive integers a1, a2, ..., an and he wants to split this array into exactly k non-empty contiguous subarrays such that the maximum possible sum of the subarrays is minimized. Help Alex find the minimized maximum sum of the subarrays. >>> minimizedMaximumSum(5, 2, [1, 2, 3, 4, 5]) 9 >>> minimizedMaximumSum(7, 3, [1, 2, 3, 4, 5, 6, 7]) 11 >>> minimizedMaximumSum(1, 1, [10]) 10 >>> minimizedMaximumSum(4, 2, [5, 5, 5, 5]) 10 >>> minimizedMaximumSum(3, 2, [100000, 200000, 300000]) 300000","solution":"def splitArray(nums, k): This function determines the minimized maximum sum of the subarrays. def can_split(nums, max_sum, k): current_sum = 0 subarrays = 1 for num in nums: if current_sum + num > max_sum: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(nums, mid, k): right = mid else: left = mid + 1 return left def minimizedMaximumSum(n, k, array): return splitArray(array, k)"},{"question":"from typing import List def min_operations_to_empty_baskets(test_cases: List[List[int]]) -> List[int]: For each test case, find the minimum number of operations required to make all baskets empty. Args: test_cases (List[List[int]]): A list of test cases, where each test case is a list of integers representing the number of apples in each basket. Returns: List[int]: A list of integers where each integer represents the minimum number of operations for the corresponding test case. Examples: >>> min_operations_to_empty_baskets([[1, 2, 1, 3, 2]]) [3] >>> min_operations_to_empty_baskets([[5, 5]]) [5] >>> min_operations_to_empty_baskets([[7, 8, 9, 10]]) [10] pass def parse_and_compute(input_data: str) -> str: Parse input data and calculate the minimum number of operations for each test case. Args: input_data (str): The input data as a single string. Returns: str: The output data as a single string where each result is separated by a newline. Examples: >>> input_data = \\"3n5n1 2 1 3 2n2n5 5n4n7 8 9 10n\\" >>> parse_and_compute(input_data) '3n5n10' pass def test_min_operations_to_empty_baskets(): assert min_operations_to_empty_baskets([[1, 2, 1, 3, 2]]) == [3] assert min_operations_to_empty_baskets([[5, 5]]) == [5] assert min_operations_to_empty_baskets([[7, 8, 9, 10]]) == [10] assert min_operations_to_empty_baskets([[3, 3, 3, 3]]) == [3] assert min_operations_to_empty_baskets([[1]]) == [1] assert min_operations_to_empty_baskets([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]) == [1] def test_parse_and_compute(): input_data = \\"3n5n1 2 1 3 2n2n5 5n4n7 8 9 10n\\" assert parse_and_compute(input_data) == \\"3n5n10\\" input_data = \\"1n10n1 1 1 1 1 1 1 1 1 1n\\" assert parse_and_compute(input_data) == \\"1\\" input_data = \\"2n3n2 2 2n3n3 3 3n\\" assert parse_and_compute(input_data) == \\"2n3\\" if __name__ == \\"__main__\\": test_min_operations_to_empty_baskets() test_parse_and_compute() print(\\"All tests passed.\\")","solution":"def min_operations_to_empty_baskets(test_cases): results = [] for baskets in test_cases: max_apples = max(baskets) results.append(max_apples) return results # Function to parse the input and provide output as expected in the problem statement def parse_and_compute(input_data): input_lines = input_data.split('n') t = int(input_lines[0]) index = 1 cases = [] for _ in range(t): n = int(input_lines[index]) baskets = list(map(int, input_lines[index + 1].split())) cases.append(baskets) index += 2 results = min_operations_to_empty_baskets(cases) return 'n'.join(map(str, results))"},{"question":"def min_distance_with_tickets(n: int, m: int, paths: List[Tuple[int, int, int]]) -> int: Calculate the minimum distance to walk to visit all attractions using m tickets. Args: n (int): Number of attractions. m (int): Number of tickets. paths (List[Tuple[int, int, int]]): Paths between attractions where each path is represented by a tuple (u, v, l_i). Returns: int: Minimum distance to walk to visit all attractions starting from the first attraction. >>> min_distance_with_tickets(4, 1, [(1, 2, 3), (1, 3, 2), (3, 4, 4)]) 5 >>> min_distance_with_tickets(5, 2, [(1, 2, 1), (1, 3, 4), (2, 4, 2), (3, 5, 1)]) 2 >>> min_distance_with_tickets(3, 1, [(1, 2, 2), (2, 3, 3)]) 2 >>> min_distance_with_tickets(6, 2, [(1, 2, 1), (1, 3, 5), (2, 4, 4), (3, 5, 3), (4, 6, 2)]) 6 >>> min_distance_with_tickets(4, 3, [(1, 2, 10), (2, 3, 10), (3, 4, 10)]) 0","solution":"import heapq def min_distance_with_tickets(n, m, paths): Calculate the minimum distance to walk to visit all attractions. Args: n : int : number of attractions m : int : number of tickets paths : List of tuples : each tuple contains (u, v, l_i) representing a path Returns: int : minimum distance to walk # Create adjacency list adj = {i: [] for i in range(1, n+1)} for u, v, l in paths: adj[u].append((v, l)) adj[v].append((u, l)) # Prim's algorithm to find MST def prim(): min_heap = [(0, 1)] # (cost, node) visited = [False] * (n + 1) total_cost = 0 count = 0 while min_heap and count < n: cost, node = heapq.heappop(min_heap) if visited[node]: continue visited[node] = True total_cost += cost count += 1 for neighbor, path_cost in adj[node]: if not visited[neighbor]: heapq.heappush(min_heap, (path_cost, neighbor)) return total_cost total_cost = prim() # If we have tickets, we avoid the m most expensive edges mst_edges = [] min_heap = [(0, 1)] # (cost, node) visited = [False] * (n + 1) while min_heap and len(mst_edges) < n: cost, node = heapq.heappop(min_heap) if visited[node]: continue visited[node] = True for neighbor, path_cost in adj[node]: if not visited[neighbor]: mst_edges.append(path_cost) heapq.heappush(min_heap, (path_cost, neighbor)) mst_edges.sort(reverse=True) # Subtract the largest m edges from the MST total cost for i in range(m): total_cost -= mst_edges[i] return total_cost"},{"question":"def is_even_sum_possible(arr): Returns True if the sum of any two distinct elements is an even number, otherwise False. >>> is_even_sum_possible([1, 3, 5, 7]) False >>> is_even_sum_possible([1, 2, 3, 4, 5]) True >>> is_even_sum_possible([-1, -2, -3, -4]) True >>> is_even_sum_possible([0, 1, 2, 3]) True >>> is_even_sum_possible([0, 2, 4, 6]) False","solution":"def is_even_sum_possible(arr): Returns True if the sum of any two distinct elements is an even number, otherwise False. has_even = any(x % 2 == 0 for x in arr) has_odd = any(x % 2 != 0 for x in arr) return has_even and has_odd"},{"question":"class Scoreboard: Scoreboard for managing participant scores. Methods: add_score(participant_id, score): Adds the score to the participant's current score. count_above(threshold): Returns the number of participants with a score above the threshold. >>> scoreboard = Scoreboard() >>> scoreboard.add_score(1, 10) >>> scoreboard.add_score(2, 20) >>> scoreboard.add_score(1, 15) >>> assert scoreboard.count_above(10) == 2 >>> assert scoreboard.count_above(20) == 1 >>> scoreboard.add_score(3, 25) >>> assert scoreboard.count_above(20) == 2 >>> assert scoreboard.count_above(40) == 1 def __init__(self): self.scores = {} def add_score(self, participant_id, score): pass def count_above(self, threshold): pass # Example unit tests def test_add_score(): scoreboard = Scoreboard() scoreboard.add_score(1, 10) scoreboard.add_score(2, 20) scoreboard.add_score(1, 15) assert scoreboard.scores[1] == 25 assert scoreboard.scores[2] == 20 def test_count_above(): scoreboard = Scoreboard() scoreboard.add_score(1, 10) scoreboard.add_score(2, 20) scoreboard.add_score(3, 30) assert scoreboard.count_above(10) == 2 # participants 2 and 3 assert scoreboard.count_above(20) == 1 # participant 3 assert scoreboard.count_above(40) == 0 # no participant def test_mixed_operations(): scoreboard = Scoreboard() scoreboard.add_score(1, 10) scoreboard.add_score(2, 20) scoreboard.add_score(1, 15) assert scoreboard.count_above(10) == 2 # participants 1 and 2 assert scoreboard.count_above(20) == 1 # participant 1 scoreboard.add_score(3, 25) assert scoreboard.count_above(20) == 2 # participants 1 and 3 assert scoreboard.count_above(15) == 3 # participants 1, 2, 3 scoreboard.add_score(2, -5) assert scoreboard.count_above(15) == 2 # participants 1 and 3","solution":"class Scoreboard: def __init__(self): self.scores = {} def add_score(self, participant_id, score): if participant_id in self.scores: self.scores[participant_id] += score else: self.scores[participant_id] = score def count_above(self, threshold): count = 0 for score in self.scores.values(): if score > threshold: count += 1 return count"},{"question":"def score_and_remaining_items(items): Calculate the total points scored by collecting pairs of consecutive identical items and return the remaining items. >>> score_and_remaining_items([1, 2, 2, 3, 3, 3, 4]) (5, [1, 3, 4]) >>> score_and_remaining_items([5, 5, 5, 5, 5]) (10, [5]) >>> score_and_remaining_items([1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) (5, [])","solution":"def score_and_remaining_items(items): total_points = 0 stack = [] for item in items: if stack and stack[-1] == item: total_points += item stack.pop() else: stack.append(item) return total_points, stack"},{"question":"def find_largest_integer(s: str) -> int: Returns the largest integer from a space-separated string of integers. >>> find_largest_integer(\\"5\\") 5 >>> find_largest_integer(\\"-5\\") -5 >>> find_largest_integer(\\"1 2 3 4 5\\") 5 >>> find_largest_integer(\\"-1 -2 -3 -4 -5\\") -1 >>> find_largest_integer(\\"2 3 -1 15 7\\") 15 >>> find_largest_integer(\\"0 1 2 3\\") 3 >>> find_largest_integer(\\"0 -1 -2 -3\\") 0 >>> find_largest_integer(\\"1000 200 15000 150000 7500\\") 150000 >>> find_largest_integer(\\"0\\") 0 >>> find_largest_integer(\\" \\".join(str(i) for i in range(-100, 101))) 100","solution":"def find_largest_integer(s): Returns the largest integer from a space-separated string of integers. # Split the string by spaces to get individual integer strings integers = s.split() # Convert the strings to integers integers = [int(num) for num in integers] # Find the largest integer using the max() function largest_integer = max(integers) return largest_integer"},{"question":"def min_subarray_len(nums: List[int], k: int) -> int: Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return 0. Args: nums (List[int]): An array of integers. k (int): The target sum. Returns: int: The length of the shortest subarray with sum greater than or equal to k. Examples: >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 1, 1, 1, 1, 1, 1, 1], 11) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3","solution":"def min_subarray_len(nums, k): Returns the length of the shortest contiguous subarray whose sum is greater than or equal to k. If no such subarray exists, return 0. n = len(nums) left = 0 cur_sum = 0 min_length = float('inf') for right in range(n): cur_sum += nums[right] while cur_sum >= k: min_length = min(min_length, right - left + 1) cur_sum -= nums[left] left += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def find_max_sales(n, sales, queries): Returns a list of maximum sale amounts for each given query period. Parameters: n (int): Number of days of sales data. sales ([int]): List of integers representing the sale amounts per day. queries ([(int, int)]): List of tuples where each tuple represents a query with a start and end day. Returns: [int]: List of maximum sale amounts for each query. def test_find_max_sales_example_1(): n = 5 sales = [3, 8, 5, 9, 7] queries = [(1, 3), (2, 5)] assert find_max_sales(n, sales, queries) == [8, 9] def test_find_max_sales_example_2(): n = 6 sales = [4, 1, 6, 2, 8, 3] queries = [(1, 4), (3, 5), (1, 6)] assert find_max_sales(n, sales, queries) == [6, 8, 8] def test_find_max_sales_single_day_query(): n = 4 sales = [10, 20, 30, 40] queries = [(1, 1), (2, 2), (3, 3), (4, 4)] assert find_max_sales(n, sales, queries) == [10, 20, 30, 40] def test_find_max_sales_entire_range(): n = 3 sales = [5, 15, 25] queries = [(1, 3)] assert find_max_sales(n, sales, queries) == [25] def test_find_max_sales_large_numbers(): n = 3 sales = [1000000000, 999999999, 1000000001] queries = [(1, 2), (2, 3), (1, 3)] assert find_max_sales(n, sales, queries) == [1000000000, 1000000001, 1000000001]","solution":"def find_max_sales(n, sales, queries): Returns a list of maximum sale amounts for each given query period. Parameters: n (int): Number of days of sales data. sales ([int]): List of integers representing the sale amounts per day. queries ([(int, int)]): List of tuples where each tuple represents a query with a start and end day. Returns: [int]: List of maximum sale amounts for each query. results = [] for start, end in queries: max_sale = max(sales[start-1:end]) results.append(max_sale) return results"},{"question":"def preprocess_prefix_sum(arr): Given a list of integers, returns a list where each index i contains the sum of elements from the beginning up to index i of the input list. >>> preprocess_prefix_sum([1, 2, 3, 4, 5]) [0, 1, 3, 6, 10, 15] pass def range_sum_query(prefix_sum, l, r): Given a prefix sum list and indices l and r, returns the sum of elements between the l-th and r-th index (inclusive). >>> range_sum_query([0, 1, 3, 6, 10, 15], 1, 3) 6 >>> range_sum_query([0, 1, 3, 6, 10, 15], 2, 4) 9 >>> range_sum_query([0, 1, 3, 6, 10, 15], 1, 5) 15 pass def process_queries(arr, queries): Given an array and list of queries, returns the results of the sum queries. >>> process_queries([1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] pass def test_preprocess_prefix_sum(): arr = [1, 2, 3, 4, 5] expected_prefix_sum = [0, 1, 3, 6, 10, 15] assert preprocess_prefix_sum(arr) == expected_prefix_sum def test_range_sum_query(): prefix_sum = [0, 1, 3, 6, 10, 15] assert range_sum_query(prefix_sum, 1, 3) == 6 assert range_sum_query(prefix_sum, 2, 4) == 9 assert range_sum_query(prefix_sum, 1, 5) == 15 def test_process_queries(): arr = [1, 2, 3, 4, 5] queries = [(1, 3), (2, 4), (1, 5)] expected_results = [6, 9, 15] assert process_queries(arr, queries) == expected_results def test_process_queries_large(): arr = [i for i in range(1, 200001)] queries = [(1, 100000), (100001, 200000), (1, 200000)] expected_results = [ sum(range(1, 100001)), sum(range(100001, 200001)), sum(range(1, 200001)) ] assert process_queries(arr, queries) == expected_results","solution":"def preprocess_prefix_sum(arr): Given a list of integers, returns a list where each index i contains the sum of elements from the beginning up to index i of the input list. n = len(arr) prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] return prefix_sum def range_sum_query(prefix_sum, l, r): Given a prefix sum list and indices l and r, returns the sum of elements between the l-th and r-th index (inclusive). return prefix_sum[r] - prefix_sum[l - 1] def process_queries(arr, queries): Given an array and list of queries, returns the results of the sum queries. prefix_sum = preprocess_prefix_sum(arr) return [range_sum_query(prefix_sum, l, r) for l, r in queries]"},{"question":"def find_optimal_seat(n: int, seats: List[int]) -> int: Determines the optimal seating position for a new guest such that the distance to the nearest occupied seat is maximized. Args: n: The total number of seats. seats: A list where the i-th element is 0 if the seat is empty and 1 if the seat is occupied. Returns: The position number of the seat that the next guest should take to maximize their distance from the nearest occupied seat. If there are multiple optimal seats, returns the smallest position number among them. Example: >>> find_optimal_seat(10, [1, 0, 0, 0, 0, 0, 1, 0, 0, 0]) 4 >>> find_optimal_seat(5, [0, 1, 0, 0, 0]) 5 >>> find_optimal_seat(7, [1, 0, 0, 0, 0, 0, 0]) 7 >>> find_optimal_seat(6, [0, 0, 0, 0, 0, 1]) 1","solution":"def find_optimal_seat(n, seats): max_distance = -1 optimal_seat = -1 for i in range(n): if seats[i] == 0: left_distance = right_distance = float('inf') # Find distance to the nearest occupied seat on the left for j in range(i, -1, -1): if seats[j] == 1: left_distance = i - j break # Find distance to the nearest occupied seat on the right for j in range(i, n): if seats[j] == 1: right_distance = j - i break # Calculate the distance to the nearest occupied seat distance = min(left_distance, right_distance) if distance > max_distance: max_distance = distance optimal_seat = i + 1 # Convert to 1-based index return optimal_seat"},{"question":"def merge_unique_problems(test_cases): Merge two lists of coding problems into a single list of unique problems preserving the order of first occurrences. >>> test_cases = [ (['hackathon1', 'problem2', 'challenge3'], ['problem2', 'challenge3', 'hackathon1', 'problem4']), (['code1', 'code2', 'code3', 'code4', 'code5'], ['code5', 'code6', 'code7']) ] >>> merge_unique_problems(test_cases) [['hackathon1', 'problem2', 'challenge3', 'problem4'], ['code1', 'code2', 'code3', 'code4', 'code5', 'code6', 'code7']] pass def parse_input(input_string): Parse the input for the merge_unique_problems function. >>> input_string = \\"2n3 hackathon1 problem2 challenge3n4 problem2 challenge3 hackathon1 problem4n5 code1 code2 code3 code4 code5n3 code5 code6 code7\\" >>> parse_input(input_string) [(['hackathon1', 'problem2', 'challenge3'], ['problem2', 'challenge3', 'hackathon1', 'problem4']), (['code1', 'code2', 'code3', 'code4', 'code5'], ['code5', 'code6', 'code7'])] pass","solution":"def merge_unique_problems(test_cases): results = [] for case in test_cases: first_list = case[0] second_list = case[1] unique_problems = [] seen = set() for problem in first_list + second_list: if problem not in seen: unique_problems.append(problem) seen.add(problem) results.append(unique_problems) return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N1, *first_list = lines[index].split() N1 = int(N1) index += 1 N2, *second_list = lines[index].split() N2 = int(N2) index += 1 test_cases.append((first_list, second_list)) return test_cases"},{"question":"class MP3Player: def __init__(self): Initialize an MP3 player to store and manage songs. pass def add_song(self, song_id: int, genre: str, duration: int): Add or update a song in the MP3 player. Args: song_id: Unique identifier for the song. genre: Genre of the song, a string of up to 10 lowercase English characters. duration: Duration of the song in seconds. pass def query_songs(self, genre: str, max_duration: int) -> int: Query the total number of songs belonging to the specified genre and having a duration less than or equal to max_duration. Args: genre: The genre to filter songs by. max_duration: The maximum duration (in seconds) to filter songs by. Returns: The total number of songs matching the specified criteria. pass import pytest def test_add_and_query(): player = MP3Player() player.add_song(1, \\"rock\\", 240) player.add_song(2, \\"jazz\\", 180) player.add_song(3, \\"rock\\", 120) assert player.query_songs(\\"rock\\", 200) == 1 # Only the song with id 3 player.add_song(4, \\"rock\\", 150) assert player.query_songs(\\"rock\\", 200) == 2 # Songs with id 3 and 4 assert player.query_songs(\\"jazz\\", 200) == 1 # Only the song with id 2 def test_update_song(): player = MP3Player() player.add_song(1, \\"rock\\", 240) player.add_song(2, \\"jazz\\", 180) player.add_song(1, \\"rock\\", 200) # Update song with id 1 assert player.query_songs(\\"rock\\", 240) == 1 # Only the updated song with id 1 def test_non_existent_genre(): player = MP3Player() player.add_song(1, \\"rock\\", 240) player.add_song(2, \\"jazz\\", 180) assert player.query_songs(\\"classical\\", 200) == 0 # No songs of genre \\"classical\\" def test_no_songs_meet_duration(): player = MP3Player() player.add_song(1, \\"rock\\", 240) player.add_song(2, \\"jazz\\", 180) assert player.query_songs(\\"rock\\", 100) == 0 # No rock songs ≤ 100 seconds def test_song_removed_on_update(): player = MP3Player() player.add_song(1, \\"rock\\", 240) player.add_song(2, \\"jazz\\", 180) player.add_song(1, \\"rock\\", 200) # Update song with id 1 assert player.query_songs(\\"rock\\", 240) == 1 # The song with id 1 now has the duration of 200 assert player.query_songs(\\"rock\\", 200) == 1 # The song with id 1 is counted at duration 200, no more 240","solution":"class MP3Player: def __init__(self): self.songs = {} self.genre_duration_map = {} def add_song(self, song_id, genre, duration): if song_id in self.songs: old_genre, old_duration = self.songs[song_id] if old_genre in self.genre_duration_map: if old_duration in self.genre_duration_map[old_genre]: self.genre_duration_map[old_genre][old_duration] -= 1 if self.genre_duration_map[old_genre][old_duration] == 0: del self.genre_duration_map[old_genre][old_duration] self.songs[song_id] = (genre, duration) if genre not in self.genre_duration_map: self.genre_duration_map[genre] = {} if duration not in self.genre_duration_map[genre]: self.genre_duration_map[genre][duration] = 0 self.genre_duration_map[genre][duration] += 1 def query_songs(self, genre, max_duration): if genre not in self.genre_duration_map: return 0 total = 0 for duration in self.genre_duration_map[genre]: if duration <= max_duration: total += self.genre_duration_map[genre][duration] return total"},{"question":"def lexicographically_smallest_string(S: str) -> str: Determine the lexicographically smallest string that can be obtained by performing any number of allowed operations. Args: S (str): The input string consisting of lowercase English letters. Returns: str: The lexicographically smallest string. Examples: >>> lexicographically_smallest_string(\\"cbad\\") 'abcd' >>> lexicographically_smallest_string(\\"dcba\\") 'abcd' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns the results. Args: T (int): The number of test cases. test_cases (List[str]): A list containing the input strings for each test case. Returns: List[str]: A list containing the result for each test case. Examples: >>> process_test_cases(2, [\\"cbad\\", \\"dcba\\"]) ['abcd', 'abcd'] >>> process_test_cases(1, [\\"zxyw\\"]) ['wxyz'] pass","solution":"def lexicographically_smallest_string(S): Returns the lexicographically smallest string that can be obtained by performing any number of allowed operations. return ''.join(sorted(S)) def process_test_cases(T, test_cases): Processes multiple test cases and returns the results. results = [] for S in test_cases: results.append(lexicographically_smallest_string(S)) return results"},{"question":"def findSpecialTriplets(arr: List[int]) -> int: Returns the count of special triplets in the array where a + b > c, b + c > a, and c + a > b. >>> findSpecialTriplets([4, 6, 3, 7]) 3 >>> findSpecialTriplets([10, 21, 22, 100, 101, 200, 300]) 6 >>> findSpecialTriplets([1, 2, 3]) 0 >>> findSpecialTriplets([5, 5, 5, 5]) 4 >>> findSpecialTriplets([1000000, 999999, 999998]) 1 >>> findSpecialTriplets([i for i in range(1, 5001)]) # Test performance with a large array size","solution":"def findSpecialTriplets(arr): Returns the count of special triplets in the array where a + b > c, b + c > a, and c + a > b. n = len(arr) count = 0 arr.sort() for i in range(n - 2): k = i + 2 for j in range(i + 1, n - 1): while k < n and arr[i] + arr[j] > arr[k]: k += 1 count += k - j - 1 return count"},{"question":"def max_non_overlapping_trains(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the maximum number of trains that can be scheduled without any overlap in their schedules. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing the number of trains and their schedules. Returns: List[int]: A list containing the maximum number of non-overlapping trains for each test case. >>> max_non_overlapping_trains(2, [(3, [1, 2, 3, 4, 5, 6]), (4, [1, 3, 2, 4, 3, 5, 6, 8])]) [3, 3] >>> max_non_overlapping_trains(1, [(3, [1, 4, 2, 5, 3, 6])]) [1] >>> max_non_overlapping_trains(1, [(0, [])]) [0]","solution":"def max_non_overlapping_trains(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] times = test_cases[i][1] trains = [(times[j], times[j+1]) for j in range(0, 2*N, 2)] # Sort the trains based on the ending times trains.sort(key=lambda x: x[1]) max_trains = 0 current_end_time = -1 for start, end in trains: if start >= current_end_time: max_trains += 1 current_end_time = end results.append(max_trains) return results"},{"question":"def unique_paths_with_obstacles(obstacle_grid): Given a 2D grid where '1' represents obstacles and '0' represents free space, computes the number of unique paths from top-left to bottom-right avoiding obstacles. The top-left corner is obstacle_grid[0][0], and the bottom-right corner is obstacle_grid[m-1][n-1]. >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[0, 1], [1, 0]]) 0 >>> unique_paths_with_obstacles([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) 1 >>> unique_paths_with_obstacles([[0]]) 1 >>> unique_paths_with_obstacles([[1]]) 0","solution":"def unique_paths_with_obstacles(obstacle_grid): Given a 2D grid where '1' represents obstacles and '0' represents free space, computes the number of unique paths from top-left to bottom-right avoiding obstacles. :param obstacle_grid: List[List[int]], 2D grid of m rows and n columns :return: int, number of unique paths if not obstacle_grid or obstacle_grid[0][0] == 1: return 0 m, n = len(obstacle_grid), len(obstacle_grid[0]) dp = [[0] * n for _ in range(m)] # Start point dp[0][0] = 1 # Fill in the values row-wise for i in range(m): for j in range(n): if obstacle_grid[i][j] == 1: dp[i][j] = 0 elif i == 0 and j == 0: continue else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"def is_palindrome(s: str) -> str: Given a string S, check if it is a palindrome. A string is considered a palindrome if it reads the same backward as forward. >>> is_palindrome(\\"radar\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO' >>> is_palindrome(\\"Racecar\\") 'YES' >>> is_palindrome(\\"A man a plan a canal Panama\\") 'YES' >>> is_palindrome(\\"No lemon, no melon\\") 'YES' >>> is_palindrome(\\"palindrome\\") 'NO' >>> is_palindrome(\\"abba\\") 'YES' >>> is_palindrome(\\"12321\\") 'YES' >>> is_palindrome(\\"12345\\") 'NO' pass","solution":"def is_palindrome(s): Returns YES if the string is a palindrome, NO otherwise. # Remove whitespace and convert to lowercase for standardizing input cleaned_string = s.replace(\\" \\", \\"\\").lower() # Check if the string equals its reverse return \\"YES\\" if cleaned_string == cleaned_string[::-1] else \\"NO\\""},{"question":"def solve_longest_word_chain(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[int]: Solve the longest word chain problem. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of tuples where each tuple contains an integer n and a list of n words. Returns: List[int]: A list of integers representing the length of the longest word chain for each test case. Example: T = 1 test_cases = [ (5, [\\"a\\", \\"ba\\", \\"bca\\", \\"bdca\\", \\"abc\\"]), ] solve_longest_word_chain(T, test_cases) >>> [4]","solution":"def longest_word_chain(words): word_set = set(words) memo = {} def dfs(word): if word in memo: return memo[word] max_length = 1 for i in range(len(word)): next_word = word[:i] + word[i+1:] if next_word in word_set: candidate_length = 1 + dfs(next_word) max_length = max(max_length, candidate_length) memo[word] = max_length return max_length max_chain_length = 0 for word in words: max_chain_length = max(max_chain_length, dfs(word)) return max_chain_length def solve_longest_word_chain(T, test_cases): results = [] for i in range(T): n, words = test_cases[i] results.append(longest_word_chain(words)) return results # Sample Input T = 1 test_cases = [ (5, [\\"a\\", \\"ba\\", \\"bca\\", \\"bdca\\", \\"abc\\"]), ] # Solving the sample input result = solve_longest_word_chain(T, test_cases) print(result) # Output: [4]"},{"question":"def count_vowels(strings: List[str]) -> List[str]: Counts the number of vowels in each string. Args: strings (list): List of input strings. Returns: list: List of strings with their corresponding vowel count. >>> count_vowels([\\"hello\\", \\"world\\", \\"programming\\"]) [\\"hello: 2\\", \\"world: 1\\", \\"programming: 3\\"] >>> count_vowels([\\"apples\\", \\"oranges\\"]) [\\"apples: 2\\", \\"oranges: 3\\"] pass def process_input(input_lines: List[str]) -> List[str]: Process input lines to return result in desired format. Args: input_lines (list): List of input lines. Returns: list: Formatted result as list of strings. >>> process_input([\\"3\\", \\"hello\\", \\"world\\", \\"programming\\"]) [\\"hello: 2\\", \\"world: 1\\", \\"programming: 3\\"] >>> process_input([\\"2\\", \\"apples\\", \\"oranges\\"]) [\\"apples: 2\\", \\"oranges: 3\\"] pass","solution":"def count_vowels(strings): Counts the number of vowels in each string. Args: strings (list): List of input strings. Returns: list: List of strings with their corresponding vowel count. vowels = set(\\"aeiou\\") results = [] for s in strings: count = sum(1 for char in s if char in vowels) results.append(f\\"{s}: {count}\\") return results def process_input(input_lines): Process input lines to return result in desired format. Args: input_lines (list): List of input lines. Returns: list: Formatted result as list of strings. n = int(input_lines[0]) strings = input_lines[1:n+1] return count_vowels(strings)"},{"question":"def uniqueElementArray(arr: List[int]) -> str: Determines whether the given array qualifies as a Unique Element Array. An array is considered a Unique Element Array if each element appears exactly once. Args: arr (list of int): An array of integers. Returns: str: \\"Unique!!\\" if the array is a Unique Element Array, \\"NOT!!\\" otherwise. >>> uniqueElementArray([1, 2, 3, 4, 5]) 'Unique!!' >>> uniqueElementArray([1, 2, 2, 4, 5]) 'NOT!!' >>> uniqueElementArray([10, 11, 12, 13, 14, 15]) 'Unique!!' >>> uniqueElementArray([99, 99, 98, 97]) 'NOT!!' >>> uniqueElementArray([100]) 'Unique!!'","solution":"def uniqueElementArray(arr): Determines whether the given array qualifies as a Unique Element Array. An array is considered a Unique Element Array if each element appears exactly once. Args: arr (list of int): An array of integers. Returns: str: \\"Unique!!\\" if the array is a Unique Element Array, \\"NOT!!\\" otherwise. return \\"Unique!!\\" if len(arr) == len(set(arr)) else \\"NOT!!\\""},{"question":"def max_length_of_unique_subarray(arr): Returns the maximum length of a subarray consisting of unique elements. :param arr: List[int] - The input array of integers :return: int - The length of the longest subarray with all unique elements >>> max_length_of_unique_subarray([1, 2, 3, 1, 2, 3]) 3 >>> max_length_of_unique_subarray([1, 2, 3, 4, 5]) 5 >>> max_length_of_unique_subarray([1, 2, 1, 3, 4, 2, 3]) 4 >>> max_length_of_unique_subarray([]) 0 >>> max_length_of_unique_subarray([1]) 1 >>> max_length_of_unique_subarray([9, 8, 7, 6, 5, 4]) 6 >>> max_length_of_unique_subarray([1, 2, 1, 3, 1, 2, 1]) 3","solution":"def max_length_of_unique_subarray(arr): Returns the maximum length of a subarray consisting of unique elements. :param arr: List[int] - The input array of integers :return: int - The length of the longest subarray with all unique elements n = len(arr) if n == 0: return 0 last_occurrence = {} start = 0 max_len = 0 for end in range(n): if arr[end] in last_occurrence: start = max(start, last_occurrence[arr[end]] + 1) last_occurrence[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def minimal_total_delivery_time(n, m, personnel): Returns the minimal total delivery time required for all personnel to deliver all packages. :param n: integer, the number of checkpoints :param m: integer, the number of delivery personnel :param personnel: list of tuples, each containing the start time, end time, and the checkpoints to be visited in order by the personnel :return: integer, the minimal total delivery time needed for all personnel >>> minimal_total_delivery_time(5, 2, [(0, 10, [1, 3, 5]), (5, 15, [2, 1, 4, 5])]) 7 >>> minimal_total_delivery_time(6, 3, [(1, 8, [1, 6]), (0, 9, [1, 3, 6]), (3, 12, [2, 3, 5, 6])]) 9 >>> minimal_total_delivery_time(4, 1, [(1, 10, [2, 3, 4])]) 3 >>> minimal_total_delivery_time(7, 2, [(1, 8, [2, 5, 7]), (3, 12, [1, 4, 6, 7])]) 7 >>> minimal_total_delivery_time(100, 2, [(1, 50, list(range(1, 51))), (51, 100, list(range(51, 101)))]) 100","solution":"def minimal_total_delivery_time(n, m, personnel): Returns the minimal total delivery time required for all personnel to deliver all packages. :param n: integer, the number of checkpoints :param m: integer, the number of delivery personnel :param personnel: list of tuples, each containing the start time, end time, and the checkpoints to be visited in order by the personnel :return: integer, the minimal total delivery time needed for all personnel total_delivery_time = 0 for s_i, e_i, checkpoints in personnel: total_delivery_time += len(checkpoints) return total_delivery_time # Example usage: n, m = 5, 2 personnel = [(0, 10, [1, 3, 5]), (5, 15, [2, 1, 4, 5])] print(minimal_total_delivery_time(n, m, personnel)) # Output: 7"},{"question":"def inventory_usage(usage_data, threshold): Calculate the total usage of items and determine if any single usage exceeds the threshold. :param usage_data: Dictionary where keys are item names and values are lists of daily usage. :param threshold: Integer representing the maximum allowed daily usage for any item. :return: Tuple containing total usage of all items and boolean indicating if threshold is exceeded. Examples: >>> inventory_usage({'widgets': [5, 3, 7, 10], 'gadgets': [4, 8, 2, 1], 'thingamajigs': [9, 1, 5, 7]}, 8) (62, True) >>> inventory_usage({'itemsA': [2, 3, 5], 'itemsB': [1, 0, 4]}, 6) (15, False) >>> inventory_usage({'productX': [12, 5, 9], 'productY': [3, 7, 10]}, 10) (46, True)","solution":"def inventory_usage(usage_data, threshold): Calculate the total usage of items and determine if any single usage exceeds the threshold. :param usage_data: Dictionary where keys are item names and values are lists of daily usage. :param threshold: Integer representing the maximum allowed daily usage for any item. :return: Tuple containing total usage of all items and boolean indicating if threshold is exceeded. total_usage = 0 max_daily_usage = 0 for item, daily_usages in usage_data.items(): total_usage += sum(daily_usages) max_daily_usage = max(max_daily_usage, max(daily_usages)) exceeds_threshold = max_daily_usage > threshold return total_usage, exceeds_threshold"},{"question":"def sum_of_primes(N: int) -> int: Returns the sum of all prime numbers less than or equal to N. >>> sum_of_primes(10) 17 >>> sum_of_primes(5) 10 >>> sum_of_primes(30) 129 def sum_of_primes_for_all_test_cases(T: int, test_cases: list) -> list: Returns the sum of primes for all test cases. T: Number of test cases test_cases: List of integers >>> sum_of_primes_for_all_test_cases(3, [10, 5, 30]) [17, 10, 129] >>> sum_of_primes_for_all_test_cases(1, [1]) [0] >>> sum_of_primes_for_all_test_cases(2, [2, 1000]) [2, 76127]","solution":"def sum_of_primes(N): Returns the sum of all prime numbers less than or equal to N. if N < 2: return 0 sieve = [True] * (N + 1) sieve[0], sieve[1] = False, False for start in range(2, int(N**0.5) + 1): if sieve[start]: for multiple in range(start*start, N+1, start): sieve[multiple] = False return sum(num for num, is_prime in enumerate(sieve) if is_prime) def sum_of_primes_for_all_test_cases(T, test_cases): Returns the sum of primes for all test cases. T: Number of test cases test_cases: List of integers results = [] for N in test_cases: results.append(sum_of_primes(N)) return results"},{"question":"def max_total_height(n: int, k: int, heights: List[int]) -> int: Calculates the maximum total height of a contiguous segment of trees that can be cut down without exceeding the given height value k. :param n: int, the number of trees :param k: int, the maximum allowed height to be cut down :param heights: list of int, representing the height of each tree :return: int, the maximum possible total height of those trees >>> max_total_height(5, 10, [3, 1, 4, 2, 5]) 10 >>> max_total_height(1, 10, [10]) 10 >>> max_total_height(1, 5, [10]) 0 >>> max_total_height(3, 15, [5, 5, 5]) 15 >>> max_total_height(3, 10, [4, 4, 4]) 8 >>> max_total_height(4, 2, [3, 4, 1, 2]) 2 >>> max_total_height(100000, 1000000, [10] * 100000) 1000000 pass","solution":"def max_total_height(n, k, heights): Calculates the maximum total height of a contiguous segment of trees that can be cut down without exceeding the given height value k. :param n: int, the number of trees :param k: int, the maximum allowed height to be cut down :param heights: list of int, representing the height of each tree :return: int, the maximum possible total height of those trees max_sum = 0 current_sum = 0 left = 0 for right in range(n): current_sum += heights[right] while current_sum > k: current_sum -= heights[left] left += 1 max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nested_list): if not nested_list: return None node = TreeNode(nested_list[0]) if len(nested_list) > 1 and nested_list[1]: node.left = build_tree(nested_list[1]) if len(nested_list) > 2 and nested_list[2]: node.right = build_tree(nested_list[2]) return node def max_path_sum(root): def helper(node): if not node: return 0, float('-inf') left_single, left_max = helper(node.left) right_single, right_max = helper(node.right) max_single = max(left_single + node.val, right_single + node.val, node.val) max_top = max(max_single, left_single + node.val + right_single) max_path = max(left_max, right_max, max_top) return max_single, max_path return helper(root)[1] def find_max_path_sum(tree_nested_list): Find the maximum path sum in a binary tree represented by a nested list. >>> find_max_path_sum([1, [2, [4], [5]], [3, [6], [7]]]) 18 >>> find_max_path_sum([-10, [9], [20, [15], [7]]]) 42 >>> find_max_path_sum([1]) 1 >>> find_max_path_sum([1, [-2, [-3], [-4]], [2]]) 3 >>> find_max_path_sum([1, [2], [-2, [-4], [-3]]]) 3 root = build_tree(tree_nested_list) return max_path_sum(root)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def build_tree(nested_list): if not nested_list: return None node = TreeNode(nested_list[0]) if len(nested_list) > 1 and nested_list[1]: node.left = build_tree(nested_list[1]) if len(nested_list) > 2 and nested_list[2]: node.right = build_tree(nested_list[2]) return node def max_path_sum(root): def helper(node): if not node: return 0, float('-inf') left_single, left_max = helper(node.left) right_single, right_max = helper(node.right) max_single = max(left_single + node.val, right_single + node.val, node.val) max_top = max(max_single, left_single + node.val + right_single) max_path = max(left_max, right_max, max_top) return max_single, max_path return helper(root)[1] def find_max_path_sum(tree_nested_list): root = build_tree(tree_nested_list) return max_path_sum(root)"},{"question":"def highest_sum_of_three(nums: List[int]) -> int: Returns the highest possible sum of any three distinct integers from the given list of five integers. >>> highest_sum_of_three([1, 2, 3, 4, 5]) 12 >>> highest_sum_of_three([10, 1, 3, 5, 7]) 22 >>> highest_sum_of_three([100, 200, 300, 400, 500]) 1200 >>> highest_sum_of_three([6, 8, 3, 7, 5]) 21 >>> highest_sum_of_three([1000, 1, 2, 3, 4]) 1007","solution":"def highest_sum_of_three(nums): Returns the highest possible sum of any three distinct integers from the given list of five integers. nums.sort() return sum(nums[-3:])"},{"question":"from typing import List, Tuple def can_be_divided(N: int, D: int, weights: List[int]) -> str: Determines if the crates can be divided into two sets such that the absolute difference between the sums of the weights of the two sets is less than or equal to D. >>> can_be_divided(4, 3, [1, 2, 3, 4]) \\"YES\\" >>> can_be_divided(5, 0, [1, 5, 2, 2, 1]) \\"NO\\" pass def main(test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Runs the can_be_divided function for each test case and returns the results. >>> main([((4, 3), [1, 2, 3, 4]), ((5, 0), [1, 5, 2, 2, 1])]) ['YES', 'NO'] pass def test_example_cases(): test_cases = [ ((4, 3), [1, 2, 3, 4]), ((5, 0), [1, 5, 2, 2, 1]) ] assert main(test_cases) == ['YES', 'NO'] def test_zero_difference_allowed(): test_cases = [ ((3, 0), [3, 3, 3]) ] assert main(test_cases) == ['NO'] def test_large_difference_allowed(): test_cases = [ ((5, 10), [10, 10, 10, 10, 10]) ] assert main(test_cases) == ['YES'] def test_single_crate(): test_cases = [ ((1, 0), [5]) ] assert main(test_cases) == ['NO'] def test_equal_distribution_possible(): test_cases = [ ((4, 1), [1, 2, 3, 4]), ((4, 0), [1, 3, 3, 1]) ] assert main(test_cases) == ['YES', 'YES']","solution":"def can_be_divided(N, D, weights): total_sum = sum(weights) target_diff = total_sum // 2 dp = [0] * (target_diff + 1) for weight in weights: for j in range(target_diff, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) closest_sum_to_half = dp[target_diff] difference = abs((total_sum - closest_sum_to_half) - closest_sum_to_half) return \\"YES\\" if difference <= D else \\"NO\\" def main(test_cases): results = [] for case in test_cases: N, D = case[0] weights = case[1] results.append(can_be_divided(N, D, weights)) return results # Example usage: # test_cases = [ # ((4, 3), [1, 2, 3, 4]), # ((5, 0), [1, 5, 2, 2, 1]) # ] # print(main(test_cases)) # Output: ['YES', 'NO']"},{"question":"def max_treasures(n: int, m: int, q: int, treasures: List[Tuple[int, int]]) -> int: Calculate the maximum number of treasures that can be collected when moving optimally from cell (1, 1) to cell (n, m) in an n x m grid. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid q (int): number of treasure cells treasures (List[Tuple[int, int]]): List of coordinates of treasure cells (xi, yi) Returns: int: Maximum number of treasures that can be collected Examples: >>> max_treasures(3, 3, 3, [(1, 2), (2, 2), (3, 3)]) 3 >>> max_treasures(4, 4, 2, [(2, 3), (3, 4)]) 2 >>> max_treasures(5, 5, 5, [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)]) 1 >>> max_treasures(3, 3, 0, []) 0 >>> max_treasures(4, 4, 2, [(1, 1), (4, 4)]) 2 >>> max_treasures(2, 5, 3, [(1, 2), (1, 4), (2, 5)]) 3 >>> max_treasures(5, 2, 3, [(2, 1), (4, 1), (5, 2)]) 3","solution":"def max_treasures(n, m, q, treasures): grid = [[0] * m for _ in range(n)] # Place treasures in the grid for x, y in treasures: grid[x-1][y-1] = 1 # DP table to store the maximum number of treasures that can be collected dp = [[0] * m for _ in range(n)] # Initialize the dp table dp[0][0] = grid[0][0] # Fill the dp table for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"def tree_depths(n: int, edges_input: List[str]) -> List[int]: Determine the depth of each node in the tree. The depth of a node is defined as the number of edges in the path from the root to that node. >>> tree_depths(5, [\\"1 2\\", \\"1 3\\", \\"3 4\\", \\"3 5\\"]) [0, 1, 1, 2, 2] >>> tree_depths(1, []) [0] >>> tree_depths(4, [\\"1 2\\", \\"1 3\\", \\"1 4\\"]) [0, 1, 1, 1] >>> tree_depths(5, [\\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 5\\"]) [0, 1, 2, 3, 4] >>> tree_depths(7, [\\"1 2\\", \\"1 3\\", \\"2 4\\", \\"2 5\\", \\"3 6\\", \\"3 7\\"]) [0, 1, 1, 2, 2, 2, 2]","solution":"def calculate_depths(n, edges): from collections import deque, defaultdict # Create an adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to calculate depths depths = [-1] * (n + 1) queue = deque([(1, 0)]) depths[1] = 0 while queue: node, depth = queue.popleft() for neighbor in tree[node]: if depths[neighbor] == -1: depths[neighbor] = depth + 1 queue.append((neighbor, depth + 1)) return depths[1:] # we return depths starting from index 1 # Function to transform edge input for easy testing def tree_depths(n, edges_input): edges = [tuple(map(int, edge.strip().split())) for edge in edges_input] return calculate_depths(n, edges)"},{"question":"def split_list_minimize_max_sum(n: int, k: int, lst: List[int]) -> List[List[int]]: Splits the list into k non-empty sublists such that the sum of the maximum integers in each sublist is minimized. If there are multiple ways to split the list, returns any one such split. Args: n: The number of integers in the list. k: The number of sublists to be formed. lst: The list of integers. Returns: A list of k lists, where each inner list represents a sublist. Examples: >>> split_list_minimize_max_sum(6, 3, [4, 2, 1, 3, 6, 5]) [[6, 3], [5, 2], [4, 1]] >>> split_list_minimize_max_sum(5, 2, [1, 2, 3, 4, 5]) [[5, 3, 1], [4, 2]] from test_split_list_minimize_max_sum import test_example1, test_example2, test_single_element, test_equal_elements, test_large_k, test_large_n_k def run_tests(): test_example1() test_example2() test_single_element() test_equal_elements() test_large_k() test_large_n_k() if __name__ == \\"__main__\\": run_tests()","solution":"def split_list_minimize_max_sum(n, k, lst): Splits the list into k non-empty sublists such that the sum of the maximum integers in each sublist is minimized. If there are multiple ways to split the list, returns any one such split. lst.sort(reverse=True) sublists = [[] for _ in range(k)] for i in range(n): sublists[i % k].append(lst[i]) return sublists"},{"question":"def file_versioning_system(n: int, operations: List[str]) -> int: Process a sequence of operations to determine the final version of the file. >>> file_versioning_system(5, [\\"increment\\", \\"increment\\", \\"rollback\\", \\"increment\\", \\"rollback\\"]) 2 >>> file_versioning_system(0, []) 1 >>> file_versioning_system(3, [\\"increment\\", \\"increment\\", \\"increment\\"]) 4 >>> file_versioning_system(4, [\\"rollback\\", \\"rollback\\", \\"rollback\\", \\"rollback\\"]) 1 >>> file_versioning_system(6, [\\"increment\\", \\"rollback\\", \\"increment\\", \\"increment\\", \\"rollback\\", \\"increment\\"]) 3 >>> file_versioning_system(5, [\\"increment\\", \\"increment\\", \\"increment\\", \\"rollback\\", \\"rollback\\"]) 2","solution":"def file_versioning_system(n, operations): current_version = 1 for operation in operations: if operation == \\"increment\\": current_version += 1 elif operation == \\"rollback\\": if current_version > 1: current_version -= 1 return current_version"},{"question":"from typing import Dict class Bookstore: A simplified inventory management system for an online bookstore. Methods: - add_book(book_id: int, title: str, author: str, genre: str, price: float, stock: int) -> None - process_sale(book_id: int, copies: int) -> bool - generate_sales_report() -> Dict[str, Dict[str, float]] def __init__(self): Initialize the Bookstore with empty inventory and sales records. def add_book(self, book_id: int, title: str, author: str, genre: str, price: float, stock: int) -> None: Adds a new book or updates an existing book in the inventory. Args: book_id (int): Unique identifier for the book. title (str): Title of the book. author (str): Author of the book. genre (str): Genre of the book. price (float): Price of the book. stock (int): Number of copies available in stock. def process_sale(self, book_id: int, copies: int) -> bool: Processes a sale by decreasing the stock and recording the sales data. Args: book_id (int): Unique identifier for the book. copies (int): Number of copies sold. Returns: bool: True if the sale was successful, False if there was insufficient stock. def generate_sales_report(self) -> Dict[str, Dict[str, float]]: Generates a sales report showing total sales for each genre and the bookstore. Returns: Dict[str, Dict[str, float]]: A dictionary containing total copies sold and sales amount for each genre, and the total sales amount for the bookstore.","solution":"from typing import Dict class Bookstore: def __init__(self): self.inventory = {} self.sales = {} def add_book(self, book_id: int, title: str, author: str, genre: str, price: float, stock: int) -> None: self.inventory[book_id] = { \\"title\\": title, \\"author\\": author, \\"genre\\": genre, \\"price\\": price, \\"stock\\": stock } self.sales[book_id] = { \\"total_copies_sold\\": 0, \\"total_sales_amount\\": 0.0 } def process_sale(self, book_id: int, copies: int) -> bool: if book_id in self.inventory and self.inventory[book_id][\\"stock\\"] >= copies: self.inventory[book_id][\\"stock\\"] -= copies self.sales[book_id][\\"total_copies_sold\\"] += copies self.sales[book_id][\\"total_sales_amount\\"] += self.inventory[book_id][\\"price\\"] * copies return True return False def generate_sales_report(self) -> Dict[str, Dict[str, float]]: sales_report = {} total_sales_amount = 0.0 for book_id, sales_data in self.sales.items(): genre = self.inventory[book_id][\\"genre\\"] if genre not in sales_report: sales_report[genre] = { \\"total_copies_sold\\": 0, \\"total_sales_amount\\": 0.0 } sales_report[genre][\\"total_copies_sold\\"] += sales_data[\\"total_copies_sold\\"] sales_report[genre][\\"total_sales_amount\\"] += sales_data[\\"total_sales_amount\\"] total_sales_amount += sales_data[\\"total_sales_amount\\"] sales_report[\\"total_sales\\"] = total_sales_amount return sales_report"},{"question":"def replace_question_marks(s: str) -> str: Replace every question mark in the string with a lowercase English letter such that the final string does not contain any two consecutive characters that are the same. >>> replace_question_marks(\\"a?c?\\") 'abca' >>> replace_question_marks(\\"?????\\") 'abcde' >>> replace_question_marks(\\"ab??ba\\") 'abacba'","solution":"def replace_question_marks(s): Replace every question mark in the string with a lowercase English letter such that the final string does not contain any two consecutive characters that are the same. s = list(s) for i in range(len(s)): if s[i] == '?': for char in 'abc': # Ensure characters won't match with the previous or the next characters if (i > 0 and s[i-1] == char) or (i < len(s)-1 and s[i+1] == char): continue s[i] = char break return ''.join(s)"},{"question":"def minimize_max_water(n: int, water_list: List[int]) -> int: Calculate the minimum possible value of the maximum amount of water any single friend has to carry after redistribution. Parameters: n (int): number of friends water_list (list): the amount of water each friend has to carry initially Returns: int: the minimum possible maximum amount of water any single friend has to carry Examples: >>> minimize_max_water(3, [5, 8, 7]) 7 >>> minimize_max_water(4, [10, 10, 10, 10]) 10 >>> minimize_max_water(2, [1, 100]) 51","solution":"def minimize_max_water(n, water_list): Calculates the minimum possible value of the maximum amount of water any single friend has to carry after redistribution. Parameters: n (int): number of friends water_list (list): the amount of water each friend has to carry initially Returns: int: the minimum possible maximum amount of water any single friend has to carry total_water = sum(water_list) # We need to find the smallest integer x such that x >= ceil(total_water / n) max_carry_after_redistribution = (total_water + n - 1) // n return max_carry_after_redistribution"},{"question":"def max_contiguous_subarray_sum(n: int, l: int, array: List[int]) -> int: Returns the maximum sum of any contiguous subarray of length at most l. :param n: Length of the array :param l: Maximum allowable subarray length :param array: List of integers representing the array :return: Maximum sum of any contiguous subarray of length at most l >>> max_contiguous_subarray_sum(5, 3, [1, 2, 3, 0, -1]) 6 >>> max_contiguous_subarray_sum(4, 2, [-1, 2, -3, 4]) 4 >>> max_contiguous_subarray_sum(1, 1, [5]) 5 >>> max_contiguous_subarray_sum(4, 2, [-2, -1, -3, -4]) -1 >>> max_contiguous_subarray_sum(3, 3, [1, 2, 3]) 6 >>> max_contiguous_subarray_sum(5, 1, [3, -2, 5, -1, 2]) 5 >>> max_contiguous_subarray_sum(5, 3, [-2, -3, -4, -1, -5]) -1","solution":"def max_contiguous_subarray_sum(n, l, array): Returns the maximum sum of any contiguous subarray of length at most l. :param n: Length of the array :param l: Maximum allowable subarray length :param array: List of integers representing the array :return: Maximum sum of any contiguous subarray of length at most l max_sum = -float('inf') current_sum = 0 # Iterate over each possible subarray length from 1 to l for length in range(1, l + 1): # Reset the current_sum for the new length and calculate the sum of the first subarray current_sum = sum(array[:length]) max_sum = max(max_sum, current_sum) # Now, use sliding window to calculate sums of subsequent subarrays of this length for i in range(length, n): current_sum += array[i] - array[i - length] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_common_prefix(strings): Find the longest common prefix among a list of strings. Args: strings (List[str]): A list of strings where each string consists of non-empty, lowercase Latin letters with lengths between 1 and 200 characters. Returns: str: The longest common prefix shared amongst all the strings in the list. If there is no common prefix, return an empty string. Examples: >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"interspecies\\", \\"interstellar\\", \\"interstate\\", \\"interest\\"]) 'inters'","solution":"def longest_common_prefix(strings): Returns the longest common prefix of the given list of strings. if not strings: return \\"\\" # Find the minimum length string in the input list min_length = min(len(s) for s in strings) # Initialize the common prefix common_prefix = \\"\\" # Compare characters one by one until the minimum string length for i in range(min_length): # Take the character at position i from the first string current_char = strings[0][i] # Check if this character is the same in all the other strings if all(s[i] == current_char for s in strings): common_prefix += current_char else: break # As soon as we find a mismatch we stop return common_prefix"},{"question":"def shuffleArray(arr): Shuffle the array such that elements at even indices are greater than their preceding odd indices while maintaining the relative order of elements otherwise. >>> shuffleArray([9, 4, 17, 3, 19, 5]) [4, 9, 3, 17, 5, 19] >>> shuffleArray([2, 1, 3, 4, 5]) [1, 2, 3, 4, 5] from solution import shuffleArray def test_shuffleArray_basic_example(): assert shuffleArray([9, 4, 17, 3, 19, 5]) == [4, 9, 3, 17, 5, 19] assert shuffleArray([2, 1, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_shuffleArray_single_element(): assert shuffleArray([1]) == [1] assert shuffleArray([100]) == [100] def test_shuffleArray_two_elements(): assert shuffleArray([1, 2]) == [1, 2] assert shuffleArray([3, 5]) == [3, 5] def test_shuffleArray_large_numbers(): assert shuffleArray([100000, 99999, -100000, -99999, 0, -1]) == [100000, 99999, -100000, -99999, 0, -1] def test_shuffleArray_pre_sorted_array(): assert shuffleArray([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert shuffleArray([-5, 0, -3, 1, -1, 2]) == [-5, 0, -3, 1, -1, 2]","solution":"def shuffleArray(arr): Shuffle the array such that elements at even indices are greater than their preceding odd indices while maintaining the relative order of elements otherwise. if not arr or len(arr) < 2: return arr # Create two lists to separate even index and odd index elements evens = [arr[i] for i in range(1, len(arr), 2)] odds = [arr[i] for i in range(0, len(arr), 2)] # Merge two lists to meet the condition result = [] even_idx = 0 odd_idx = 0 for i in range(len(arr)): if i % 2 == 0: result.append(odds[odd_idx]) odd_idx += 1 else: result.append(evens[even_idx]) even_idx += 1 return result"},{"question":"def daily_temperatures(n: int, temperatures: List[int]) -> List[int]: For each day, find out how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, store 0 for that day. >>> daily_temperatures(8, [73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures(5, [30, 40, 50, 60, 70]) == [1, 1, 1, 1, 0] >>> daily_temperatures(4, [30, 20, 10, 0]) == [0, 0, 0, 0] >>> daily_temperatures(4, [75, 74, 73, 72]) == [0, 0, 0, 0] >>> daily_temperatures(5, [50, 50, 50, 50, 50]) == [0, 0, 0, 0, 0] >>> daily_temperatures(1, [50]) == [0]","solution":"def daily_temperatures(n, temperatures): result = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: previous_day = stack.pop() result[previous_day] = i - previous_day stack.append(i) return result"},{"question":"def count_crossing_participants(n, a, b): Returns the number of participants who crossed the starting position. Parameters: n: int : the number of positions on the track and participants a: list of int : the initial positions of the participants b: list of int : the final positions of the participants Returns: int : the number of participants who crossed the starting position def process_test_cases(t, test_cases): Processes multiple test cases and returns the results for each of them. Parameters: t: int : number of test cases test_cases: list of tuples : each tuple contains (n, a, b) for a single test case Returns: list of int : results for each test case # Test cases def test_single_case(): n = 5 a = [1, 3, 2, 5, 4] b = [4, 1, 5, 3, 2] assert count_crossing_participants(n, a, b) == 3 def test_single_case_no_crossing(): n = 4 a = [1, 2, 3, 4] b = [1, 2, 3, 4] assert count_crossing_participants(n, a, b) == 0 def test_single_case_all_cross(): n = 6 a = [6, 1, 3, 2, 5, 4] b = [3, 5, 1, 6, 4, 2] assert count_crossing_participants(n, a, b) == 4 def test_process_multiple_cases(): t = 3 test_cases = [ (5, [1, 3, 2, 5, 4], [4, 1, 5, 3, 2]), (4, [1, 2, 3, 4], [1, 2, 3, 4]), (6, [6, 1, 3, 2, 5, 4], [3, 5, 1, 6, 4, 2]) ] results = process_test_cases(t, test_cases) assert results == [3, 0, 4]","solution":"def count_crossing_participants(n, a, b): Returns the number of participants who crossed the starting position. Parameters: n: int : the number of positions on the track and participants a: list of int : the initial positions of the participants b: list of int : the final positions of the participants Returns: int : the number of participants who crossed the starting position count = 0 for start, end in zip(a, b): if start > end: count += 1 return count def process_test_cases(t, test_cases): Processes multiple test cases and returns the results for each of them. Parameters: t: int : number of test cases test_cases: list of tuples : each tuple contains (n, a, b) for a single test case Returns: list of int : results for each test case results = [] for case in test_cases: n, a, b = case results.append(count_crossing_participants(n, a, b)) return results"},{"question":"def max_difference(arr: List[int]) -> int: Finds the maximum difference between any two elements in the array such that the larger element appears after the smaller element. >>> max_difference([2, 3, 1, 7, 4, 6]) 6 >>> max_difference([5, 4, 3, 2, 1]) -1 >>> max_difference([10]) -1 >>> max_difference([1, 10]) 9 >>> max_difference([10, 1]) -1 >>> max_difference([7, 1, 5, 3, 6, 4]) 5 >>> max_difference([1, 2, 90, 10, 110]) 109 >>> large_input = list(range(1, 100001)) >>> max_difference(large_input) 99999","solution":"def max_difference(arr): Finds the maximum difference between any two elements in the array such that the larger element appears after the smaller element. if len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def manage_institution_log(n: int, events: List[str]) -> List[Union[str, int]]: Manage the institution's log of visitors and process given queries. Args: n (int): the number of lines containing either an event or a query. events (List[str]): list of events and queries. Returns: List[Union[str, int]]: a list of results for each query >>> manage_institution_log(8, [\\"Alice enter\\", \\"Bob enter\\", \\"status Alice\\", \\"status Bob\\", \\"Alice exit\\", \\"total\\", \\"status Alice\\", \\"status Bob\\"]) ['inside', 'inside', 1, 'outside', 'inside'] >>> manage_institution_log(6, [\\"Alice enter\\", \\"Bob enter\\", \\"Alice exit\\", \\"total\\", \\"status Alice\\", \\"status Bob\\"]) [1, 'outside', 'inside']","solution":"def manage_institution_log(n, events): log = {} result = [] current_inside_count = 0 for event in events: parts = event.split() if parts[0] == \\"status\\": name = parts[1] if log.get(name, False): result.append(\\"inside\\") else: result.append(\\"outside\\") elif parts[0] == \\"total\\": result.append(current_inside_count) else: name = parts[0] event_type = parts[1] if event_type == \\"enter\\": if name not in log or not log[name]: log[name] = True current_inside_count += 1 elif event_type == \\"exit\\": if name in log and log[name]: log[name] = False current_inside_count -= 1 return result"},{"question":"def longest_subsequence_with_k_distinct(n: int, k: int, sequence: List[int]) -> int: Find the length of the longest subsequence containing no more than K distinct integers. Parameters: n (int): The length of the sequence. k (int): The maximum number of distinct integers allowed in the subsequence. sequence (List[int]): The sequence of integers. Returns: int: Length of the longest subsequence with no more than K distinct integers. Example: >>> longest_subsequence_with_k_distinct(7, 2, [1, 2, 1, 2, 3, 3, 4]) 4 >>> longest_subsequence_with_k_distinct(5, 3, [1, 2, 3, 4, 5]) 3 pass from solution import longest_subsequence_with_k_distinct def test_example_1(): assert longest_subsequence_with_k_distinct(7, 2, [1, 2, 1, 2, 3, 3, 4]) == 4 def test_example_2(): assert longest_subsequence_with_k_distinct(5, 3, [1, 2, 3, 4, 5]) == 3 def test_all_elements_same(): assert longest_subsequence_with_k_distinct(5, 1, [1, 1, 1, 1, 1]) == 5 def test_k_equals_n(): assert longest_subsequence_with_k_distinct(4, 4, [1, 2, 3, 4]) == 4 def test_n_equals_1(): assert longest_subsequence_with_k_distinct(1, 1, [1]) == 1 def test_no_distinct_integers_allowed(): assert longest_subsequence_with_k_distinct(6, 0, [1, 2, 3, 4, 5, 6]) == 0 def test_large_n(): sequence = [i % 100 for i in range(10**5)] assert longest_subsequence_with_k_distinct(10**5, 100, sequence) == 10**5 def test_large_k(): sequence = [i for i in range(10**5)] assert longest_subsequence_with_k_distinct(10**5, 10**5, sequence) == 10**5","solution":"def longest_subsequence_with_k_distinct(n, k, sequence): from collections import defaultdict start = 0 max_length = 0 count = defaultdict(int) for end in range(n): count[sequence[end]] += 1 while len(count) > k: count[sequence[start]] -= 1 if count[sequence[start]] == 0: del count[sequence[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def find_combination(N: int) -> tuple: Given an integer N, find a combination of three pairs of integers (a, b), (c, d) and (e, f) that satisfy the equation: a + b^2 + c + d^2 + e + f^2 = N and the conditions: 1 ≤ a, b, c, d, e, f ≤ 10^6 Args: N (int): A positive integer representing the target value. Returns: tuple: A tuple of six integers (a, b, c, d, e, f) that satisfy the conditions. If multiple solutions exist, any of them will be accepted. Examples: >>> find_combination(53) (1, 2, 2, 3, 3, 4) >>> find_combination(220) (1, 4, 2, 6, 3, 7)","solution":"def find_combination(N): for a in range(1, 10**6 + 1): for b in range(1, int((N - a)**0.5) + 1): for c in range(1, 10**6 + 1): for d in range(1, int((N - a - b**2 - c)**0.5) + 1): for e in range(1, 10**6 + 1): for f in range(1, int((N - a - b**2 - c - d**2 - e)**0.5) + 1): if a + b**2 + c + d**2 + e + f**2 == N: return a, b, c, d, e, f return None"},{"question":"def can_form_chain(n: int, dominoes: List[Tuple[int, int]]) -> str: Check if the dominoes can form a continuous chain such that the second number of one domino matches the first number of the next domino in the row. Args: n (int): The number of dominoes. dominoes (List[Tuple[int, int]]): A list of tuples representing the numbers on the two ends of each domino. Returns: str: \\"Yes\\" if the dominoes can form a continuous chain, otherwise \\"No\\". >>> can_form_chain(3, [(1, 2), (2, 3), (3, 1)]) == \\"Yes\\" >>> can_form_chain(3, [(1, 2), (2, 3), (4, 5)]) == \\"No\\" >>> can_form_chain(1, [(1, 1)]) == \\"Yes\\" >>> can_form_chain(1, [(1, 2)]) == \\"Yes\\" >>> can_form_chain(2, [(1, 2), (3, 4)]) == \\"No\\" >>> can_form_chain(2, [(1, 2), (2, 3)]) == \\"Yes\\" >>> dominoes = [(i, i+1) for i in range(1, 10001)] >>> can_form_chain(10000, dominoes) == \\"Yes\\"","solution":"def can_form_chain(n, dominoes): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) indegree = defaultdict(int) outdegree = defaultdict(int) for a, b in dominoes: graph[a].append(b) graph[b].append(a) outdegree[a] += 1 indegree[b] += 1 # Check for Eulerian path or cycle start_nodes = 0 end_nodes = 0 for node in set(a for a, b in dominoes) | set(b for a, b in dominoes): if abs(indegree[node] - outdegree[node]) > 1: return \\"No\\" elif outdegree[node] - indegree[node] == 1: start_nodes += 1 elif indegree[node] - outdegree[node] == 1: end_nodes += 1 # For Eulerian Path if not (start_nodes == end_nodes == 0 or start_nodes == end_nodes == 1): return \\"No\\" # Check connectivity def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Find the starting point start = dominoes[0][0] visited = bfs(start) for a, b in dominoes: if a not in visited or b not in visited: return \\"No\\" return \\"Yes\\""},{"question":"def can_rearrange_stones(n: int, sequence: str) -> tuple: Determines if it is possible to rearrange the sequence of stones so that no two adjacent stones have the same letter. Returns a tuple where the first element is a string \\"YES\\" or \\"NO\\", and the second element is the rearranged sequence or None. >>> can_rearrange_stones(6, 'aabbcc') (\\"YES\\", 'abcabc') >>> can_rearrange_stones(3, 'aaab') (\\"NO\\", None) # You can use the following test cases to verify your function implementation def test_single_stone(): assert can_rearrange_stones(1, 'a') == (\\"YES\\", 'a') def test_even_distribution(): result = can_rearrange_stones(6, 'aabbcc') assert result[0] == \\"YES\\" assert len(result[1]) == 6 for i in range(len(result[1]) - 1): assert result[1][i] != result[1][i + 1] def test_odd_unfinished_distribution(): assert can_rearrange_stones(3, 'aaab') == (\\"NO\\", None) def test_unreachable_goal(): assert can_rearrange_stones(5, 'aaaab') == (\\"NO\\", None) def test_possible_rearrangement(): result = can_rearrange_stones(8, 'aabbccdd') assert result[0] == \\"YES\\" assert len(result[1]) == 8 for i in range(len(result[1]) - 1): assert result[1][i] != result[1][i + 1] def test_complex_case(): result = can_rearrange_stones(7, 'aabbccd') assert result[0] == \\"YES\\" assert len(result[1]) == 7 for i in range(len(result[1]) - 1): assert result[1][i] != result[1][i + 1]","solution":"from collections import Counter def can_rearrange_stones(n, sequence): Determines if it's possible to rearrange the sequence of stones so that no two adjacent stones have the same letter. if n == 1: return \\"YES\\", sequence counter = Counter(sequence) max_freq = max(counter.values()) # If the most frequent character occurs more than (n/2 + n%2) times, it is impossible. if max_freq > (n + 1) // 2: return \\"NO\\", None # Create a list of characters ordered by frequency chars = sorted(counter, key=counter.get, reverse=True) result = [None] * n # Position the most frequent characters in alternating positions idx = 0 for char in chars: count = counter[char] for _ in range(count): result[idx] = char idx += 2 if idx >= n: idx = 1 return \\"YES\\", ''.join(result)"},{"question":"def max_pairs(T: int, cases: List[Tuple[int, int]]) -> List[int]: Calculates the maximum number of pairs that can be formed given the number of items of two types, A and B. Parameters: T (int): The number of test cases. cases (List[Tuple[int, int]]): A list where each tuple consists of two integers, the number of items of type A and B respectively. Returns: List[int]: A list of integers where each integer represents the maximum number of pairs for the corresponding test case. Examples: >>> max_pairs(3, [(2, 3), (5, 5), (0, 10)]) [2, 5, 0] >>> max_pairs(1, [(7, 9)]) [7] from typing import List, Tuple def test_max_pairs(): cases = [ (2, 3), (5, 5), (0, 10), (10, 0), (1, 2), (100, 100), (50, 25), (7, 7), (6, 9) ] expected = [2, 5, 0, 0, 1, 100, 25, 7, 6] result = max_pairs(len(cases), cases) assert result == expected, f\\"Expected {expected}, but got {result}\\"","solution":"def max_pairs(T, cases): Returns a list with the maximum number of pairs that can be formed for each test case. Parameters: - T: int, number of test cases - cases: list of tuples, where each tuple contains the number of items of type A and B respectively Returns: - list of integers, each integer representing the maximum number of pairs for the corresponding test case. result = [] for A, B in cases: result.append(min(A, B)) return result"},{"question":"def generate_snake_pattern_matrix(N): Generate an NxN matrix filled with values from 1 to N^2 in a snake-like pattern. Parameters: N (int): The dimension of the matrix (N x N). Returns: List[List[int]]: The NxN matrix in a snake-like pattern. >>> generate_snake_pattern_matrix(2) [[1, 2], [4, 3]] >>> generate_snake_pattern_matrix(3) [[1, 2, 3], [6, 5, 4], [7, 8, 9]] pass def format_matrix(matrix): Format the matrix to a string where each row is space-separated and rows are newline-separated. Parameters: matrix (List[List[int]]): The NxN matrix to format. Returns: str: The formatted matrix as a string. >>> format_matrix([[1, 2], [4, 3]]) '1 2n4 3' pass def solve_snake_patterns(test_cases): Solve the snake-like pattern matrices for multiple test cases. Parameters: test_cases (List[int]): List of integers, each representing a test case with dimension N. Returns: List[str]: List of formatted strings representing the NxN matrices for each test case. >>> solve_snake_patterns([2]) ['1 2n4 3'] >>> solve_snake_patterns([3, 4]) ['1 2 3n6 5 4n7 8 9', '1 2 3 4n8 7 6 5n9 10 11 12n16 15 14 13'] pass from solution import generate_snake_pattern_matrix, format_matrix, solve_snake_patterns def test_generate_snake_pattern_matrix(): assert generate_snake_pattern_matrix(2) == [[1, 2], [4, 3]] assert generate_snake_pattern_matrix(3) == [[1, 2, 3], [6, 5, 4], [7, 8, 9]] assert generate_snake_pattern_matrix(4) == [[1, 2, 3, 4], [8, 7, 6, 5], [9, 10, 11, 12], [16, 15, 14, 13]] def test_format_matrix(): assert format_matrix([[1, 2], [4, 3]]) == \\"1 2n4 3\\" assert format_matrix([[1, 2, 3], [6, 5, 4], [7, 8, 9]]) == \\"1 2 3n6 5 4n7 8 9\\" def test_solve_snake_patterns(): assert solve_snake_patterns([2]) == [\\"1 2n4 3\\"] assert solve_snake_patterns([3, 4]) == [ \\"1 2 3n6 5 4n7 8 9\\", \\"1 2 3 4n8 7 6 5n9 10 11 12n16 15 14 13\\" ] def test_edge_cases(): assert generate_snake_pattern_matrix(1) == [[1]] assert format_matrix([[1]]) == \\"1\\" def test_max_cases(): N = 100 matrix = generate_snake_pattern_matrix(N) # Ensure the matrix is NxN and correctly filled assert len(matrix) == N assert all(len(row) == N for row in matrix) assert matrix[0] == list(range(1, N + 1)) assert matrix[1] == list(range(2 * N, N, -1))","solution":"def generate_snake_pattern_matrix(N): Generates an NxN matrix filled with numbers in a snake-like pattern. matrix = [] num = 1 for i in range(N): row = [] for j in range(N): row.append(num) num += 1 if i % 2 == 1: # if the row index is odd, reverse the row row.reverse() matrix.append(row) return matrix def format_matrix(matrix): Formats the matrix to the required form where each row is space-separated. return \\"n\\".join(\\" \\".join(map(str, row)) for row in matrix) def solve_snake_patterns(test_cases): Takes the number of test cases and a list of N values to generate the matrices for each. results = [] for N in test_cases: matrix = generate_snake_pattern_matrix(N) formatted_matrix = format_matrix(matrix) results.append(formatted_matrix) return results"},{"question":"from typing import List def sort_books(n: int, books: List[str]) -> List[str]: Reorganize the list of books based on their unique identifiers. Books should be sorted primarily by the alphabetical part of the identifier. If two identifiers have the same alphabetical part, the numerical part should be used for comparison and should be sorted in ascending order. The numerical part of the identifier will always be non-negative integers and should be treated as such (e.g., \\"002\\" should be considered as 2). >>> sort_books(5, [\\"Book34\\", \\"book12\\", \\"Book2\\", \\"book02\\", \\"Book21\\"]) ['Book2', 'Book21', 'Book34', 'book02', 'book12'] >>> sort_books(2, [\\"bookA\\", \\"Bookb\\"]) ['Bookb', 'bookA']","solution":"def sort_books(n, books): def book_key(book): # Split into letters and numbers alpha_part = ''.join([char for char in book if char.isalpha()]) numeric_part = ''.join([char for char in book if char.isdigit()]) # Convert numerical part to an integer numeric_part = int(numeric_part) if numeric_part else 0 return (alpha_part, numeric_part) # Sort the list using the specified key sorted_books = sorted(books, key=book_key) return sorted_books"},{"question":"from typing import List, Tuple def minimum_delivery_cost(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[int]: Calculate the total minimum cost of delivering all the packages for each test case. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): A list where each element is a tuple containing: - An integer N, the number of cities. - A list P of length N, where P[i] denotes the number of packages to be delivered to the i-th city. - A list C of length N, where C[i] denotes the cost of delivering one package to the i-th city. Returns: List[int]: A list of T integers where the i-th integer is the minimum cost to deliver all the packages for the i-th test case. Example: >>> minimum_delivery_cost(2, [(3, [10, 20, 30], [6, 2, 4]), (2, [5, 8], [3, 5])]) [220, 55] >>> minimum_delivery_cost(1, [(4, [1, 2, 3, 4], [10, 20, 30, 40])]) [300]","solution":"def minimum_delivery_cost(T, test_cases): result = [] for i in range(T): N = test_cases[i][0] P = test_cases[i][1] C = test_cases[i][2] total_cost = sum([P[j] * C[j] for j in range(N)]) result.append(total_cost) return result"},{"question":"def largest_square_submatrix(matrix: List[List[int]]) -> int: Returns the side length of the largest square submatrix where all elements are the same. >>> largest_square_submatrix([ ... [1, 1, 1, 0, 0], ... [1, 1, 1, 0, 0], ... [1, 1, 1, 1, 1], ... [0, 0, 1, 1, 1] ... ]) == 3 >>> largest_square_submatrix([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3 >>> largest_square_submatrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 1 >>> largest_square_submatrix([ ... [1] ... ]) == 1 >>> largest_square_submatrix([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) == 3 >>> largest_square_submatrix([ ... [2, 2, 2, 3, 3], ... [2, 2, 2, 3, 3], ... [2, 2, 2, 3, 3] ... ]) == 3","solution":"def largest_square_submatrix(matrix): Returns the side length of the largest square submatrix where all elements are the same. n = len(matrix) m = len(matrix[0]) # Create a dp table to store the side length of largest sub-square ending at (i, j) dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if i == 0 or j == 0: dp[i][j] = 1 else: if matrix[i][j] == matrix[i-1][j] == matrix[i][j-1] == matrix[i-1][j-1]: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"def generateSequenceSum(N: int) -> List[int]: Generates a list where each value is the cumulative sum of values from 1 up to that index position (inclusive). >>> generateSequenceSum(5) [1, 3, 6, 10, 15] >>> generateSequenceSum(0) [] >>> generateSequenceSum(-1) []","solution":"def generateSequenceSum(N): if N <= 0: return [] sequence_sum = [] current_sum = 0 for i in range(1, N+1): current_sum += i sequence_sum.append(current_sum) return sequence_sum"},{"question":"def longest_contiguous_subsequence_length(arr): Determine the length of the longest contiguous subsequence of the array such that the difference between any two adjacent elements is less than or equal to 1. >>> longest_contiguous_subsequence_length([2, 2, 3, 4, 5, 5]) 6 >>> longest_contiguous_subsequence_length([1, 3, 5]) 1 >>> longest_contiguous_subsequence_length([4, 4, 5, 7, 7]) 3","solution":"def longest_contiguous_subsequence_length(arr): if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if abs(arr[i] - arr[i-1]) <= 1: current_length += 1 else: current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def product_except_self(nums): Returns an array where each element at index i is the product of all the elements in the input list except the one at index i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0]) [0, 0, -1] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([1, 0, 3, 4]) [0, 12, 0, 0] >>> product_except_self([5]) [] >>> product_except_self([0, 0, 2]) [0, 0, 0] >>> product_except_self([1000, 1000]) [1000, 1000] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6]","solution":"def product_except_self(nums): Returns an array where each element at index i is the product of all the elements in the input list except the one at index i. length = len(nums) if length <= 1: return [] result = [1] * length left_product = 1 for i in range(length): result[i] = left_product left_product *= nums[i] right_product = 1 for i in range(length - 1, -1, -1): result[i] *= right_product right_product *= nums[i] return result"},{"question":"def smallest_divisor(nums, threshold): Find the smallest divisor such that the sum of nums divided by the divisor is less than or equal to the threshold. >>> smallest_divisor([1, 2, 5, 9], 6) 5 >>> smallest_divisor([2, 3, 5, 7, 11], 11) 3 >>> smallest_divisor([19], 5) 4","solution":"import math def smallest_divisor(nums, threshold): Finds the smallest divisor such that the sum of nums divided by the divisor is less than or equal to the threshold. def compute_sum(divisor): return sum(math.ceil(num / divisor) for num in nums) left, right = 1, max(nums) while left < right: mid = (left + right) // 2 if compute_sum(mid) > threshold: left = mid + 1 else: right = mid return left"},{"question":"def calculate_damage(characters): Calculates and returns the basic damage and special damage for each character. Params: characters (list of tuples): Each tuple contains information about a character in the following format: (role, level, strength, intelligence, dexterity) Returns: list of tuples: Each tuple contains the role, basic damage and special damage in the format: (role, basic_damage, special_damage) >>> calculate_damage([(\\"Warrior\\", 5, 10, 0, 0), (\\"Mage\\", 3, 0, 15, 0), (\\"Archer\\", 4, 0, 0, 8)]) [(\\"Warrior\\", 25, 40), (\\"Mage\\", 12, 40), (\\"Archer\\", 12, 28)] >>> calculate_damage([(\\"Warrior\\", 0, 0, 0, 0), (\\"Mage\\", 0, 0, 0, 0), (\\"Archer\\", 0, 0, 0, 0)]) [(\\"Warrior\\", 0, 30), (\\"Mage\\", 0, 25), (\\"Archer\\", 0, 20)] >>> calculate_damage([(\\"Warrior\\", 10, 20, 0, 0), (\\"Mage\\", 10, 0, 25, 0), (\\"Archer\\", 10, 0, 0, 30)]) [(\\"Warrior\\", 50, 50), (\\"Mage\\", 40, 50), (\\"Archer\\", 30, 50)] >>> calculate_damage([(\\"Warrior\\", 5, -5, 0, 0), (\\"Mage\\", 3, 0, -10, 0), (\\"Archer\\", 4, 0, 0, -5)]) [(\\"Warrior\\", 25, 25), (\\"Mage\\", 12, 15), (\\"Archer\\", 12, 15)] >>> calculate_damage([(\\"Warrior\\", 1, 0, 0, 0), (\\"Mage\\", 2, 0, 5, 0), (\\"Archer\\", 3, 0, 0, 2)]) [(\\"Warrior\\", 5, 30), (\\"Mage\\", 8, 30), (\\"Archer\\", 9, 22)]","solution":"def calculate_damage(characters): Calculates and returns the basic damage and special damage for each character. Params: characters (list of tuples): Each tuple contains information about a character in the following format: (role, level, strength, intelligence, dexterity) Returns: list of tuples: Each tuple contains the role, basic damage and special damage in the format: (role, basic_damage, special_damage) result = [] for char in characters: role, level, strength, intelligence, dexterity = char if role == \\"Warrior\\": basic_damage = level * 5 special_damage = 30 + strength elif role == \\"Mage\\": basic_damage = level * 4 special_damage = 25 + intelligence elif role == \\"Archer\\": basic_damage = level * 3 special_damage = 20 + dexterity result.append((role, basic_damage, special_damage)) return result"},{"question":"def trapWater(height: List[int]) -> int: Returns the total amount of water that can be trapped between buildings after rainfall. >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapWater([4, 2, 0, 3, 2, 5]) == 9","solution":"def trapWater(height): Returns the total amount of water that can be trapped between buildings after rainfall. if len(height) <= 2: return 0 n = len(height) left, right = 0, n - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: # Decide which pointer to move if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"from typing import List def max_profit_two_subarrays(prices: List[int]) -> int: Find the maximum possible profit by choosing exactly two non-overlapping subarrays. Each subarray must contain at least one element, and the profit is calculated as the sum of the elements in the two chosen subarrays. >>> max_profit_two_subarrays([3, 2, 5, 1, 6, 4]) 21 >>> max_profit_two_subarrays([1, 2, 3, 4, 5, 6]) 21 >>> max_profit_two_subarrays([-1, -2, -3, -4, -5, -6]) -3 >>> max_profit_two_subarrays([5, -2, 3, -1, 4, -5, 6]) 15 >>> max_profit_two_subarrays([1, -1]) 0","solution":"def max_profit_two_subarrays(prices): n = len(prices) # Step 1: prefix sums of the prices array prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + prices[i - 1] # Step 2: Calculate maximum subarray sums ending before each index i (from left to right) max_ending_here = float('-inf') max_subarray_sum_left = [0] * n for i in range(n): max_ending_here = max(max_ending_here + prices[i], prices[i]) max_subarray_sum_left[i] = max(max_subarray_sum_left[i-1] if i > 0 else float('-inf'), max_ending_here) # Step 3: Calculate maximum subarray sums starting after each index i (from right to left) max_ending_here = float('-inf') max_subarray_sum_right = [0] * n for i in range(n-1, -1, -1): max_ending_here = max(max_ending_here + prices[i], prices[i]) max_subarray_sum_right[i] = max(max_subarray_sum_right[i+1] if i < n-1 else float('-inf'), max_ending_here) # Step 4: Find two non-overlapping subarrays that maximize the sum max_profit = float('-inf') for i in range(n-1): max_profit = max(max_profit, max_subarray_sum_left[i] + max_subarray_sum_right[i+1]) return max_profit"},{"question":"def largest_square_block(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the size of the largest square block of buildings you can potentially form in the grid. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): List of test cases, each containing the size of the grid (N) and the grid itself. Returns: List[int]: A list of integers representing the size of the largest square block for each test case. >>> T = 2 >>> test_cases = [ ... (3, [ ... [1, 0, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]), ... (4, [ ... [0, 1, 1, 0], ... [1, 0, 1, 1], ... [1, 1, 0, 0], ... [0, 0, 1, 1] ... ]) ... ] >>> largest_square_block(T, test_cases) [3, 4] from solution import largest_square_block def test_example_cases(): # Example cases provided in the question T = 2 test_cases = [ (3, [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]), (4, [ [0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 0], [0, 0, 1, 1] ]) ] expected_results = [3, 4] assert largest_square_block(T, test_cases) == expected_results def test_min_grid(): # Minimal possible grid T = 1 test_cases = [ (1, [ [0] ]) ] expected_results = [1] assert largest_square_block(T, test_cases) == expected_results T = 1 test_cases = [ (1, [ [1] ]) ] expected_results = [1] assert largest_square_block(T, test_cases) == expected_results def test_all_open_plots(): # All zeros in grid T = 1 test_cases = [ (3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) ] expected_results = [3] assert largest_square_block(T, test_cases) == expected_results def test_all_buildings(): # All ones in grid T = 1 test_cases = [ (3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) ] expected_results = [3] assert largest_square_block(T, test_cases) == expected results def test_mixed_grid(): T = 1 test_cases = [ (4, [ [1, 0, 1, 0], [1, 0, 0, 1], [1, 1, 0, 1], [1, 0, 0, 1] ]) ] expected_results = [4] assert largest_square_block(T, test_cases) == expected_results","solution":"def largest_square_block(T, test_cases): results = [] for case in test_cases: N = case[0] grid = case[1] # Auxiliary DP table dp = [[0] * N for _ in range(N)] max_square_side = 0 for i in range(N): for j in range(N): if grid[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_square_side = max(max_square_side, dp[i][j]) # Because we can potentially convert every zero to one max_square_side = N results.append(max_square_side) return results"},{"question":"from typing import List, Tuple def max_coins(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the maximum number of coins Emily can collect in a single connected path for each test case. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): List of tuples where each tuple contains the dimensions of the grid and the grid itself. Returns: List[int]: Maximum number of coins that can be collected in a single connected path for each test case. >>> max_coins(2, [ ... (3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), ... (2, 2, [ ... [1, 2], ... [0, 3] ... ]), ... ]) == [45, 6] >>> max_coins(1, [ ... (1, 1, [ ... [5] ... ]) ... ]) == [5] >>> max_coins(1, [ ... (3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) ... ]) == [0] >>> max_coins(1, [ ... (1, 5, [ ... [1, 2, 3, 4, 5] ... ]) ... ]) == [15] >>> max_coins(1, [ ... (5, 1, [ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) ... ]) == [15]","solution":"from typing import List, Tuple def max_coins(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: def dfs(grid, visited, x, y, n, m): if x < 0 or y < 0 or x >= n or y >= m or visited[x][y]: return 0 visited[x][y] = True total_coins = grid[x][y] max_coins = 0 for i, j in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: max_coins = max(max_coins, dfs(grid, visited, x + i, y + j, n, m)) visited[x][y] = False return total_coins + max_coins results = [] for case in test_cases: n, m, grid = case max_coins_collected = 0 visited = [[False] * m for _ in range(n)] for i in range(n): for j in range(m): max_coins_collected = max(max_coins_collected, dfs(grid, visited, i, j, n, m)) results.append(max_coins_collected) return results"},{"question":"def min_edges_for_general_graph(n: int, k: int) -> int: Calculate the minimum number of edges needed to form a connected graph with \`n\` nodes initially forming a star-tree and then adding \`k\` additional edges. Args: n (int): Number of nodes in the star tree. k (int): Number of additional edges to be added. Returns: int: The minimum number of edges needed. Examples: >>> min_edges_for_general_graph(4, 2) 5 >>> min_edges_for_general_graph(5, 1) 5 >>> min_edges_for_general_graph(3, 0) 2 def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Process multiple test cases to determine the minimum number of edges for each scenario. Args: test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers \`n\` and \`k\`. Returns: List[int]: A list of integers where each integer is the result of min_edges_for_general_graph for the corresponding test case. Examples: >>> solve([(4, 2)]) [5] >>> solve([(5, 1)]) [5] >>> solve([(3, 0)]) [2] from typing import List, Tuple def test_min_edges_for_general_graph(): assert solve([(4, 2)]) == [5] assert solve([(5, 1)]) == [5] assert solve([(3, 0)]) == [2] assert solve([(10, 5)]) == [14] assert solve([(7, 10)]) == [16] assert solve([(2, 0)]) == [1] assert solve([(100, 5000)]) == [5099] def test_edge_cases(): assert solve([(2, 0)]) == [1] # Smallest star-tree possible assert solve([(10000, 0)]) == [9999] # Large star-tree without additional edges assert solve([(10000, (10000 * 9999 // 2) - 9999)]) == [(10000 * 9999 // 2)] # Maximum number of additional edges def test_multiple_cases(): test_cases = [(4, 2), (5, 1), (3, 0), (10, 5), (7, 10)] expected_results = [5, 5, 2, 14, 16] assert solve(test_cases) == expected_results","solution":"def min_edges_for_general_graph(n, k): Calculate the minimum number of edges needed to form a connected graph with \`n\` nodes initially forming a star-tree and then adding \`k\` additional edges. Args: n (int): Number of nodes in the star tree. k (int): Number of additional edges to be added. Returns: int: The minimum number of edges needed. initial_edges = n - 1 # A star tree with n nodes has n-1 edges. return initial_edges + k def solve(test_cases): results = [] for n, k in test_cases: results.append(min_edges_for_general_graph(n, k)) return results"},{"question":"def capitalize_even_words(sentence: str) -> str: Capitalizes the words at even positions in the given sentence. Words are separated by a single space, and the function preserves the whitespace between the words. :param sentence: The input string containing the sentence. :return: A new string with words at even positions capitalized. pass # Test cases assert capitalize_even_words(\\"hello world this is a test\\") == \\"hello WORLD this IS a TEST\\" assert capitalize_even_words(\\"only one word\\") == \\"only ONE word\\" assert capitalize_even_words(\\"python coding exercises\\") == \\"python CODING exercises\\" assert capitalize_even_words(\\"capitalize even words correctly\\") == \\"capitalize EVEN words CORRECTLY\\"","solution":"def capitalize_even_words(sentence: str) -> str: Capitalizes the words at even positions in the given sentence. Words are separated by a single space, and the function preserves the whitespace between the words. :param sentence: The input string containing the sentence. :return: A new string with words at even positions capitalized. words = sentence.split() for i in range(1, len(words), 2): words[i] = words[i].upper() return ' '.join(words)"},{"question":"def min_travel_distance(n: int, edges: List[Tuple[int, int, int]]) -> int: Determine the minimum total travel distance required to distribute the candies. Each store must receive exactly one type of candy, ensuring fairness. Args: n (int): Number of locations (nodes). edges (List[Tuple[int, int, int]]): List of roads, where each road is represented as a tuple (u, v, d) indicating a road between locations u and v with distance d. Returns: int: The minimum total travel distance required. Examples: >>> min_travel_distance(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 3, 4)]) 6 >>> min_travel_distance(5, [(0, 1, 10), (0, 2, 1), (1, 3, 3), (2, 3, 8), (3, 4, 7)]) 19 >>> min_travel_distance(3, [(0, 1, 5), (0, 2, 6), (1, 2, 7)]) 11 def test_min_travel_distance(): assert min_travel_distance(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 3, 4)]) == 6 assert min_travel_distance(5, [(0, 1, 10), (0, 2, 1), (1, 3, 3), (2, 3, 8), (3, 4, 7)]) == 19 assert min_travel_distance(3, [(0, 1, 5), (0, 2, 6), (1, 2, 7)]) == 11 assert min_travel_distance(2, [(0, 1, 4)]) == 4 def test_large_input(): edges = [(i, i + 1, 1) for i in range(4999)] assert min_travel_distance(5000, edges) == 4999 from solution import min_travel_distance def test_min_travel_distance_example(): assert min_travel_distance(4, [(0, 1, 1), (0, 2, 2), (0, 3, 3), (1, 3, 4)]) == 6 def test_min_travel_distance_small_graph(): assert min_travel_distance(3, [(0, 1, 1), (1, 2, 1), (0, 2, 2)]) == 2 def test_min_travel_distance_large_graph(): edges = [(i, i + 1, 1) for i in range(4999)] assert min_travel_distance(5000, edges) == 4999","solution":"class DisjointSet: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def min_travel_distance(n, edges): edges.sort(key=lambda x: x[2]) dsu = DisjointSet(n) mst_cost = 0 edges_used = 0 for u, v, d in edges: if dsu.find(u) != dsu.find(v): dsu.union(u, v) mst_cost += d edges_used += 1 if edges_used == n - 1: break return mst_cost"},{"question":"def is_word_in_grid(grid: List[List[str]], word: str) -> bool: Determine if a given word is present in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally, vertically, or diagonally neighboring. The same cell may not be used more than once in constructing the word. >>> is_word_in_grid([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCCED\\") True >>> is_word_in_grid([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"SEE\\") True >>> is_word_in_grid([['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E']], \\"ABCB\\") False","solution":"def is_word_in_grid(grid, word): def dfs(x, y, index): if index == len(word): return True if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or visited[x][y] or grid[x][y] != word[index]: return False visited[x][y] = True found = (dfs(x + 1, y, index + 1) or dfs(x - 1, y, index + 1) or dfs(x, y + 1, index + 1) or dfs(x, y - 1, index + 1) or dfs(x + 1, y + 1, index + 1) or dfs(x - 1, y - 1, index + 1) or dfs(x - 1, y + 1, index + 1) or dfs(x + 1, y - 1, index + 1)) visited[x][y] = False return found if not grid or not grid[0]: return False m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] for i in range(m): for j in range(n): if dfs(i, j, 0): return True return False"},{"question":"def min_cost_to_paint_houses(T: int, test_cases: List[Tuple[int, List[Tuple[int, int, int]]]]) -> List[int]: Calculate the minimum cost to paint all the houses such that no two adjacent houses have the same color. Args: T: int - the number of test cases. test_cases: List[Tuple[int, List[Tuple[int, int, int]]]] - a list of test cases where each test case is a tuple containing the number of houses and a list of tuples with painting costs for red, green, and blue. Returns: List[int] - a list of minimum costs for each test case. >>> min_cost_to_paint_houses(1, [(3, [(1, 2, 3), (1, 2, 3), (3, 3, 1)])]) [4] >>> min_cost_to_paint_houses(1, [(2, [(2, 1, 3), (2, 1, 3)])]) [3]","solution":"def min_cost_to_paint_houses(T, test_cases): results = [] for case in test_cases: N = case[0] costs = case[1:] dp = [[0] * 3 for _ in range(N)] dp[0][0], dp[0][1], dp[0][2] = costs[0] for i in range(1, N): dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]) dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]) dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]) results.append(min(dp[N-1])) return results"},{"question":"def tug_of_war(participants: List[int]) -> int: Find the smallest possible difference in the total strengths of two teams. Parameters: participants (list): List of participant strengths represented as integers. Returns: int: The minimum possible difference in total strength between the two teams. Examples: >>> tug_of_war([3, 1, 4, 2]) 0 >>> tug_of_war([3, 9, 7, 3]) 2","solution":"def tug_of_war(participants): Find the smallest possible difference in the total strengths of two teams. Parameters: participants (list): List of participant strengths represented as integers. Returns: int: The minimum possible difference in total strength between the two teams. N = len(participants) total_strength = sum(participants) half_sum = total_strength // 2 dp = [[False] * (half_sum + 1) for _ in range(N + 1)] dp[0][0] = True for i in range(1, N + 1): for j in range(half_sum + 1): if dp[i-1][j]: dp[i][j] = True if j + participants[i-1] <= half_sum: dp[i][j + participants[i-1]] = True for j in range(half_sum, -1, -1): if dp[N][j]: subset_sum = j break other_subset_sum = total_strength - subset_sum return abs(other_subset_sum - subset_sum) # Example usage (Uncomment to test manually) # print(tug_of_war([3, 1, 4, 2])) # Output should be 0"},{"question":"def find_pair(nums, target): Finds two indices in the list nums such that their values sum up to the target. :param nums: List of integers :param target: Target integer sum :return: A list [i, j] of indices where nums[i] + nums[j] == target >>> find_pair([2, 7, 11, 15], 9) [0, 1] >>> find_pair([1, 2, 3, 4, 5], 10) [] >>> find_pair([3, 2, 4], 6) [1, 2] >>> find_pair([0, 4, 3, 0], 0) [0, 3] >>> find_pair([-3, 4, 3, 90], 0) [0, 2] >>> find_pair([1000000000, -1000000000], 0) [0, 1] pass","solution":"def find_pair(nums, target): Finds two indices in the list nums such that their values sum up to the target. :param nums: List of integers :param target: Target integer sum :return: A list [i, j] of indices where nums[i] + nums[j] == target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return sorted([num_to_index[complement], i]) num_to_index[num] = i return []"},{"question":"def max_light_distance(n: int, lights: List[int]) -> int: Returns the maximum distance between any two consecutive houses with lights on. Parameters: n (int): The total number of houses lights (list): A list of house numbers that have lights on Returns: int: The maximum distance between consecutive houses with lights on >>> max_light_distance(10, [3, 5, 8, 9]) 3 >>> max_light_distance(10, []) 0 >>> max_light_distance(10, [5]) 0 >>> max_light_distance(10, [2, 6]) 4 >>> max_light_distance(5, [1, 2, 3, 4, 5]) 1 >>> max_light_distance(10, [1, 10]) 9 >>> max_light_distance(10, [9, 3, 8, 5]) 3","solution":"def max_light_distance(n, lights): Returns the maximum distance between any two consecutive houses with lights on. Parameters: n (int): The total number of houses lights (list): A list of house numbers that have lights on Returns: int: The maximum distance between consecutive houses with lights on if len(lights) < 2: return 0 # Sort the list of lights lights.sort() # Calculate the distances between consecutive houses max_distance = 0 for i in range(1, len(lights)): distance = lights[i] - lights[i - 1] if distance > max_distance: max_distance = distance return max_distance"},{"question":"def validate_username(username: str) -> str: Validate the given username based on the following rules: - The username must contain only lowercase English letters. - The username must be between 6 and 15 characters long. - The username must not contain three consecutive identical characters. - The username must not have more than 3 characters in increasing or decreasing consecutive order. Args: username (str): The username string to be validated. Returns: str: \\"Valid\\" if the username meets all the rules, otherwise \\"Invalid\\". Examples: >>> validate_username(\\"johnsmith\\") \\"Valid\\" >>> validate_username(\\"aab_cdefg\\") \\"Invalid\\" >>> validate_username(\\"abcdefgh\\") \\"Invalid\\" >>> validate_username(\\"aacccbb\\") \\"Invalid\\" >>> validate_username(\\"user123\\") \\"Invalid\\"","solution":"def validate_username(username): import re # Check for lowercase only if not re.match(r'^[a-z]+', username): return \\"Invalid\\" # Check length if not (6 <= len(username) <= 15): return \\"Invalid\\" # Check for three consecutive identical characters if re.search(r'(.)11', username): return \\"Invalid\\" # Check for more than 3 characters in increasing order for i in range(len(username) - 3): if ord(username[i+1]) == ord(username[i]) + 1 and ord(username[i+2]) == ord(username[i+1]) + 1 and ord(username[i+3]) == ord(username[i+2]) + 1: return \\"Invalid\\" # Check for more than 3 characters in decreasing order for i in range(len(username) - 3): if ord(username[i+1]) == ord(username[i]) - 1 and ord(username[i+2]) == ord(username[i+1]) - 1 and ord(username[i+3]) == ord(username[i+2]) - 1: return \\"Invalid\\" return \\"Valid\\""},{"question":"def sum_of_subsets(arr: List[int], target: int) -> List[List[int]]: Write a function that takes an array of unique integers \`arr\` and a target integer \`target\`. The function should return all unique subsets of \`arr\` that sum up to the target. The function should return the subsets in a list of lists, with each individual subset being a sorted list. The order of the subsets in the result does not matter. >>> sum_of_subsets([2, 4, 6, 10], 16) == [[6, 10], [2, 4, 10]] >>> sum_of_subsets([2, 3, 7, 8], 10) == [[2, 8], [3, 7]] >>> sum_of_subsets([1, 2, 3, 4, 5], 5) == [[1, 4], [2, 3], [5]] >>> sum_of_subsets([1, 2, 3], 7) == [] >>> sum_of_subsets([], 5) == [] >>> sum_of_subsets([5], 5) == [[5]] >>> sum_of_subsets([10, 20, 30], 60) == [[10, 20, 30]] >>> sum_of_subsets([1, 3, 2, 5, 4], 6) == [[1, 2, 3], [1, 5], [2, 4]]","solution":"def sum_of_subsets(arr, target): def find_subsets(i, current_subset, current_sum): if current_sum == target: result.append(sorted(current_subset)) return if current_sum > target or i >= len(arr): return # Include the current element find_subsets(i + 1, current_subset + [arr[i]], current_sum + arr[i]) # Exclude the current element find_subsets(i + 1, current_subset, current_sum) result = [] find_subsets(0, [], 0) return result"},{"question":"def min_operations(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 into str2. The allowed operations are insert, delete, and replace a character. Args: str1 (str): The original string. str2 (str): The target string. Returns: int: The minimum number of operations required to convert str1 into str2. Examples: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"abc\\") 3 # Function implementation def test_min_operations(): assert min_operations(\\"kitten\\", \\"sitting\\") == 3 assert min_operations(\\"flaw\\", \\"lawn\\") == 2 assert min_operations(\\"intention\\", \\"execution\\") == 5 assert min_operations(\\"\\", \\"abc\\") == 3 assert min_operations(\\"abc\\", \\"\\") == 3 assert min_operations(\\"a\\", \\"a\\") == 0 assert min_operations(\\"a\\", \\"b\\") == 1 assert min_operations(\\"abcdef\\", \\"azced\\") == 3 def test_min_operations_edge_cases(): assert min_operations(\\"\\", \\"\\") == 0 assert min_operations(\\"a\\", \\"\\") == 1 assert min_operations(\\"\\", \\"a\\") == 1 assert min_operations(\\"abc\\", \\"def\\") == 3 assert min_operations(\\"giraffe\\", \\"giraffe\\") == 0 # Run the tests test_min_operations() test_min_operations_edge_cases()","solution":"def min_operations(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 into str2. The allowed operations are insert, delete, and replace a character. m, n = len(str1), len(str2) # Create a 2D array to store results of subproblems dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)] # Fill dp array bottom up for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If str1 is empty, insert all characters of str2 elif j == 0: dp[i][j] = i # If str2 is empty, remove all characters of str1 elif str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = 1 + min(dp[i-1][j], # Delete dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"from math import factorial from collections import Counter def count_distinct_permutations(word: str) -> int: Returns the number of distinct permutations of the given word. >>> count_distinct_permutations(\\"abc\\") 6 >>> count_distinct_permutations(\\"aabb\\") 6","solution":"from math import factorial from collections import Counter def count_distinct_permutations(word): Returns the number of distinct permutations of the given word. letter_count = Counter(word) numerator = factorial(len(word)) denominator = 1 for count in letter_count.values(): denominator *= factorial(count) return numerator // denominator"},{"question":"def manage_books(books, operations): Manages the operations on the list of books based on the provided operations. Args: books (list): list of dictionaries where each dictionary represents a book with keys: ISBN, title, author, year operations (list): list of tuples where each tuple represents an operation ('add', 'update', 'delete') and a dictionary of book details Returns: list: updated list of book dictionaries after performing all operations Example: >>> books = [ ... {'ISBN': '12345', 'title': 'Book A', 'author': 'Author 1', 'year': 2001}, ... {'ISBN': '67890', 'title': 'Book B', 'author': 'Author 2', 'year': 2002}, ... {'ISBN': '11223', 'title': 'Book C', 'author': 'Author 3', 'year': 2003} ... ] >>> operations = [ ... ('add', {'ISBN': '44556', 'title': 'Book D', 'author': 'Author 4', 'year': 2004}), ... ('update', {'ISBN': '12345', 'title': 'Updated Book A', 'author': 'Updated Author 1', 'year': 2005}), ... ('delete', {'ISBN': '67890'}) ... ] >>> manage_books(books, operations) [{'ISBN': '12345', 'title': 'Updated Book A', 'author': 'Updated Author 1', 'year': 2005}, {'ISBN': '11223', 'title': 'Book C', 'author': 'Author 3', 'year': 2003}, {'ISBN': '44556', 'title': 'Book D', 'author': 'Author 4', 'year': 2004}]","solution":"def manage_books(books, operations): Manages the operations on the list of books based on the provided operations. books: list of dictionaries where each dictionary represents a book with keys: ISBN, title, author, year operations: list of tuples where each tuple represents an operation ('add', 'update', 'delete') and a dictionary of book details for operation, book_info in operations: if operation == 'add': books.append(book_info) elif operation == 'update': for book in books: if book['ISBN'] == book_info['ISBN']: book.update(book_info) break elif operation == 'delete': books = [book for book in books if book['ISBN'] != book_info['ISBN']] return books"},{"question":"def divide_string(s: str) -> str: Determines whether the string can be divided into two non-empty parts where one part contains only 'a's and the other part contains only 'b's. If possible, return the two parts. Otherwise, return \\"NO\\". Args: s (str): The input string containing only 'a' and 'b'. Returns: str: The two parts separated by a space if a valid division is possible, otherwise \\"NO\\".","solution":"def divide_string(s): Determines whether the string can be divided into two non-empty parts where one part contains only 'a's and the other part contains only 'b's. If possible, return the two parts. Otherwise, return \\"NO\\". Args: s (str): The input string containing only 'a' and 'b'. Returns: str: The two parts separated by a space if a valid division is possible, otherwise \\"NO\\". # Look for the first occurrence of 'b' index = s.find('b') # If there is no 'b' or 'a' then split is not possible as it will be empty part if index == -1 or index == 0 or index == len(s): return \\"NO\\" # Split the string at the first 'b' part1 = s[:index] part2 = s[index:] # Check if part1 contains only 'a's and part2 contains only 'b's if part1.count('a') == len(part1) and part2.count('b') == len(part2): return part1 + \\" \\" + part2 else: return \\"NO\\""},{"question":"def count_beautiful_buildings(T, test_cases): Determine the number of beautiful buildings for each test case. A building is considered beautiful if there are no taller buildings to its left. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains: - N (int): The number of buildings. - heights (List[int]): The heights of the buildings. Returns: List[int]: A list of integers where each integer represents the number of beautiful buildings for the corresponding test case. >>> count_beautiful_buildings(2, [(4, [3, 7, 8, 3]), (3, [1, 5, 3])]) [3, 2] >>> count_beautiful_buildings(1, [(5, [1, 2, 3, 4, 5])]) [5]","solution":"def count_beautiful_buildings(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] heights = test_cases[i][1] beautiful_count = 0 current_max = -1 for height in heights: if height > current_max: beautiful_count += 1 current_max = height results.append(beautiful_count) return results"},{"question":"def final_robot_position(m, commands): Calculate the final coordinates of the robot after executing all movement commands. Args: m (int): Number of movement commands. commands (list): List of tuples where each tuple contains two elements: an integer (steps) and a char (direction). Returns: tuple: Final coordinates of the robot (x, y). >>> final_robot_position(4, [(10, 'U'), (15, 'R'), (5, 'D'), (20, 'L')]) (-5, 5) >>> final_robot_position(0, []) (0, 0) >>> final_robot_position(1, [(1, 'R')]) (1, 0) >>> final_robot_position(3, [(4, 'U'), (2, 'U'), (3, 'U')]) (0, 9) >>> final_robot_position(2, [(5, 'D'), (3, 'L')]) (-3, -5)","solution":"def final_robot_position(m, commands): Args: m (int): Number of movement commands. commands (list): List of tuples where each tuple contains two elements: an integer (steps) and a char (direction). Returns: tuple: Final coordinates of the robot (x, y). x, y = 0, 0 for steps, direction in commands: if direction == 'U': y += steps elif direction == 'D': y -= steps elif direction == 'L': x -= steps elif direction == 'R': x += steps return x, y"},{"question":"def final_temperature_and_concentration(T0, C0, actions): Computes the final temperature and concentration after a sequence of actions. Parameters: T0 (int): Initial temperature C0 (int): Initial concentration percentage actions (str): Sequence of actions Returns: tuple: Final temperature and concentration percentage Example: >>> final_temperature_and_concentration(20, 50, \\"WCAADDC\\") (19, 50) >>> final_temperature_and_concentration(0, 0, \\"WWCC\\") (0, 0)","solution":"def final_temperature_and_concentration(T0, C0, actions): Computes the final temperature and concentration after a sequence of actions. Parameters: T0 (int): Initial temperature C0 (int): Initial concentration percentage actions (str): Sequence of actions Returns: tuple: Final temperature and concentration percentage temperature = T0 concentration = C0 for action in actions: if action == 'W': temperature += 1 elif action == 'C': temperature -= 1 elif action == 'A': concentration += 1 elif action == 'D': concentration -= 1 return temperature, concentration"},{"question":"class CircularBuffer: def __init__(self, size): Initialize the circular buffer with a given size. Args: size (int): The size of the circular buffer. pass def read(self): Read and remove the oldest element in the buffer. Raises: Exception: If the buffer is empty. Returns: The oldest element in the buffer. pass def write(self, data): Write a new element to the buffer. Args: data: The data to be added to the buffer. Raises: Exception: If the buffer is full. pass def overwrite(self, data): Overwrite the oldest element if the buffer is full and add a new one. Args: data: The data to be added to the buffer. pass def clear(self): Clear the buffer. pass def get_data(self): Get all elements in the buffer as a list. Returns: list: The elements in the buffer, starting with the oldest element. pass # Example Usage: # buffer = CircularBuffer(3) # buffer.write(1) # buffer: [1] # buffer.write(2) # buffer: [1, 2] # buffer.write(3) # buffer: [1, 2, 3] # print(buffer.get_data()) # Output: [1, 2, 3] # buffer.read() # Output: 1 # buffer.write(4) # buffer: [2, 3, 4] # print(buffer.get_data()) # Output: [2, 3, 4] # buffer.overwrite(5) # buffer: [3, 4, 5] # print(buffer.get_data()) # Output: [3, 4, 5] # buffer.clear() # buffer: [] # print(buffer.get_data()) # Output: [] # Unit Tests: from solution import CircularBuffer def test_circular_buffer_write_and_get_data(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) assert buffer.get_data() == [1, 2] def test_circular_buffer_write_full_exception(): buffer = CircularBuffer(2) buffer.write(1) buffer.write(2) try: buffer.write(3) except Exception as e: assert str(e) == \\"Buffer is full\\" def test_circular_buffer_read(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) assert buffer.read() == 1 assert buffer.get_data() == [2] def test_circular_buffer_read_empty_exception(): buffer = CircularBuffer(2) try: buffer.read() except Exception as e: assert str(e) == \\"Buffer is empty\\" def test_circular_buffer_overwrite(): buffer = CircularBuffer(3) buffer.write(1) buffer.write(2) buffer.write(3) buffer.overwrite(4) assert buffer.get_data() == [2, 3, 4] def test_circular_buffer_clear(): buffer = CircularBuffer(3) buffer.write(1) buffer.clear() assert buffer.get_data() == [] def test_circular_buffer_is_empty(): buffer = CircularBuffer(3) assert buffer.is_empty() buffer.write(1) assert not buffer.is_empty() buffer.read() assert buffer.is_empty()","solution":"class CircularBuffer: def __init__(self, size): self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.is_full = False def read(self): if self.is_empty(): raise Exception(\\"Buffer is empty\\") data = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.is_full = False return data def write(self, data): if self.is_full: raise Exception(\\"Buffer is full\\") self.buffer[self.tail] = data self.tail = (self.tail + 1) % self.size if self.tail == self.head: self.is_full = True def overwrite(self, data): if self.is_full: self.head = (self.head + 1) % self.size self.buffer[self.tail] = data self.tail = (self.tail + 1) % self.size if self.tail == self.head: self.is_full = True def clear(self): self.buffer = [None] * self.size self.head = 0 self.tail = 0 self.is_full = False def get_data(self): if self.head == self.tail and not self.is_full: return [] if self.head < self.tail: return [x for x in self.buffer[self.head:self.tail] if x is not None] else: return [x for x in self.buffer[self.head:] + self.buffer[:self.tail] if x is not None] def is_empty(self): return self.head == self.tail and not self.is_full"},{"question":"class QueueWithStacks: Class to simulate the functionality of a queue using two stacks. def __init__(self): Initialize your data structure here. pass def enqueue(self, x): Push element x to the end of queue. pass def dequeue(self): Removes the element from the front of the queue and returns it. pass def peek(self): Get the front element. pass def empty(self): Returns whether the queue is empty. pass def test_enqueue_and_peek(): q = QueueWithStacks() q.enqueue(1) q.enqueue(2) assert q.peek() == 1 def test_dequeue(): q = QueueWithStacks() q.enqueue(1) q.enqueue(2) assert q.dequeue() == 1 assert q.dequeue() == 2 def test_empty(): q = QueueWithStacks() assert q.empty() == True q.enqueue(1) assert q.empty() == False q.dequeue() assert q.empty() == True def test_complex_operations(): q = QueueWithStacks() q.enqueue(1) q.enqueue(2) q.enqueue(3) assert q.dequeue() == 1 q.enqueue(4) assert q.peek() == 2 assert q.dequeue() == 2 assert q.dequeue() == 3 assert q.empty() == False assert q.dequeue() == 4 assert q.empty() == True","solution":"class QueueWithStacks: def __init__(self): Initialize your data structure here. self.stack1 = [] self.stack2 = [] def enqueue(self, x): Push element x to the end of queue. self.stack1.append(x) def dequeue(self): Removes the element from the front of the queue and returns it. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2.pop() def peek(self): Get the front element. if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) return self.stack2[-1] def empty(self): Returns whether the queue is empty. return not self.stack1 and not self.stack2"},{"question":"def check_overlap(n: int, intervals1: list[tuple[int, int]], m: int, intervals2: list[tuple[int, int]]) -> str: Determines if there is any overlap between the intervals of two employees. :param n: Number of intervals for the first employee :param intervals1: List of intervals for the first employee :param m: Number of intervals for the second employee :param intervals2: List of intervals for the second employee :return: \\"YES\\" if there is any overlap, otherwise \\"NO\\" >>> check_overlap(3, [(1, 5), (10, 15), (20, 25)], 2, [(5, 10), (15, 20)]) 'NO' >>> check_overlap(2, [(1, 5), (8, 12)], 3, [(4, 9), (10, 15), (18, 22)]) 'YES' def test_no_overlap(): assert check_overlap(3, [(1, 5), (10, 15), (20, 25)], 2, [(5, 10), (15, 20)]) == \\"NO\\" def test_overlap(): assert check_overlap(2, [(1, 5), (8, 12)], 3, [(4, 9), (10, 15), (18, 22)]) == \\"YES\\" def test_full_overlap(): assert check_overlap(2, [(1, 5), (6, 10)], 2, [(1, 5), (6, 10)]) == \\"YES\\" def test_partial_overlap(): assert check_overlap(2, [(1, 5), (10, 15)], 2, [(3, 7), (12, 20)]) == \\"YES\\" def test_edge_overlap(): assert check_overlap(2, [(1, 5), (10, 15)], 2, [(5, 6), (15, 20)]) == \\"NO\\" def test_no_intervals(): assert check_overlap(2, [(1, 5), (8, 12)], 0, []) == \\"NO\\"","solution":"def check_overlap(n, intervals1, m, intervals2): Determines if there is any overlap between the intervals of two employees. :param n: Number of intervals for the first employee :param intervals1: List of intervals for the first employee :param m: Number of intervals for the second employee :param intervals2: List of intervals for the second employee :return: \\"YES\\" if there is any overlap, otherwise \\"NO\\" for start1, end1 in intervals1: for start2, end2 in intervals2: if start1 < end2 and start2 < end1: return \\"YES\\" return \\"NO\\" # Example usage with direct input if __name__ == \\"__main__\\": n = int(input()) intervals1 = [tuple(map(int, input().split())) for _ in range(n)] m = int(input()) intervals2 = [tuple(map(int, input().split())) for _ in range(m)] print(check_overlap(n, intervals1, m, intervals2))"},{"question":"def min_cost_to_paint_houses(N: int, K: int, cost: List[List[int]]) -> int: Calculate the minimum cost to paint all houses such that no two adjacent houses have the same color. Args: N (int): The number of houses. K (int): The number of available colors. cost (List[List[int]]): A list of lists where cost[i][j] represents the cost of painting house i with color j. Returns: int: The minimum cost to paint all houses under the given conditions. Example: >>> min_cost_to_paint_houses(3, 3, [[1, 5, 3], [2, 9, 4], [3, 6, 7]]) 8 >>> min_cost_to_paint_houses(1, 3, [[1, 50, 3]]) 1 >>> min_cost_to_paint_houses(2, 2, [[1, 5], [2, 3]]) 4 >>> min_cost_to_paint_houses(2, 2, [[1, 1000], [1000, 1]]) 2 >>> min_cost_to_paint_houses(3, 2, [[5, 5], [5, 5], [5, 5]]) 15 # Add your code here","solution":"def min_cost_to_paint_houses(N, K, cost): if N == 0 or K == 0: return 0 # Initialize the dp array dp = [[0] * K for _ in range(N)] # Base case for the first house for j in range(K): dp[0][j] = cost[0][j] # Fill dp array for i in range(1, N): for j in range(K): dp[i][j] = min(dp[i-1][m] for m in range(K) if m != j) + cost[i][j] # Find the minimum cost in the last row min_cost = min(dp[N-1]) return min_cost"},{"question":"def min_absolute_difference(t, cases): Given a list of n positive integers, find the minimum possible value of the absolute difference between any two consecutive elements in a non-decreasing reordered version of this list. >>> min_absolute_difference(3, [(4, [4, 2, 1, 3]), (3, [10, 20, 30]), (5, [5, 3, 1, 4, 2])]) [1, 10, 1] >>> min_absolute_difference(1, [(2, [1000000000, 1])]) [999999999]","solution":"def min_absolute_difference(t, cases): results = [] for case in cases: n, elements = case elements.sort() min_diff = float('inf') for i in range(1, n): diff = elements[i] - elements[i - 1] if diff < min_diff: min_diff = diff results.append(min_diff) return results"},{"question":"def contains_nearby_duplicate(nums, k): Determine whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most k. Args: nums: List[int] - list of integers k: int - the maximum index difference Returns: bool - True if there exists such indices, False otherwise >>> contains_nearby_duplicate([1, 2, 3, 1], 3) True >>> contains_nearby_duplicate([1, 0, 1, 1], 1) True >>> contains_nearby_duplicate([1, 2, 3, 4, 5], 2) False >>> contains_nearby_duplicate([1, 1, 1, 1], 2) True >>> contains_nearby_duplicate([5, 6, 7, 8, 5], 3) False >>> contains_nearby_duplicate([5, 6, 7, 8, 7, 6], 4) True >>> contains_nearby_duplicate([], 0) False >>> contains_nearby_duplicate([1], 0) False","solution":"def contains_nearby_duplicate(nums, k): Determine whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most k. Args: nums: List[int] - list of integers k: int - the maximum index difference Returns: bool - True if there exists such indices, False otherwise indices = {} for i, num in enumerate(nums): if num in indices and i - indices[num] <= k: return True indices[num] = i return False"},{"question":"def hasCycle(n, edges): Returns True if the graph contains at least one cycle, otherwise returns False. :param n: int, the number of nodes in the graph. Nodes are numbered from 0 to n-1. :param edges: List[List[int]], a 2D list of integers representing directed edges in the graph. :return: bool, True if the graph contains a cycle, otherwise False. >>> hasCycle(4, [[0, 1], [1, 2], [2, 3], [3, 1]]) True >>> hasCycle(5, [[0, 1], [0, 2], [1, 3], [3, 4]]) False >>> hasCycle(6, [[0, 1], [1, 2], [2, 0], [3, 4], [4, 5]]) True >>> hasCycle(6, [[0, 1], [2, 3], [4, 5]]) False >>> hasCycle(1, []) False >>> hasCycle(4, []) False","solution":"def hasCycle(n, edges): Returns True if the graph contains at least one cycle, otherwise returns False. from collections import defaultdict def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False graph = defaultdict(list) for a, b in edges: graph[a].append(b) visited = set() visiting = set() for node in range(n): if node not in visited: if dfs(node): return True return False"},{"question":"def first_unique_char(s): Returns the index of the first non-repeating character in the string s. If there is no such character, returns -1. >>> first_unique_char(\\"loveleetcode\\") 2 >>> first_unique_char(\\"aabbcc\\") -1 >>> first_unique_char(\\"z\\") 0 >>> first_unique_char(\\"abcdefg\\") 0 >>> first_unique_char(\\"aabbcdde\\") 4 >>> first_unique_char(\\"aabbccz\\") 6 >>> first_unique_char(\\"a\\" * 99999 + \\"b\\") 99999","solution":"def first_unique_char(s): Returns the index of the first non-repeating character in the string s. If there is no such character, returns -1. # Create a frequency dictionary to count occurrences of each character. char_count = {} # First pass: Compute the frequency of each character. for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: Find the index of the first non-repeating character. for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"def min_operations_to_transform(n: int, s: str, t: str) -> int: Returns the minimum number of operations required to transform string s to string t. :param n: Integer, length of the strings s and t. :param s: String, the initial string. :param t: String, the target string. :return: Integer, minimum number of operations. >>> min_operations_to_transform(5, 'abcde', 'bcdea') 5 >>> min_operations_to_transform(4, 'aaaa', 'bbbb') 4 >>> min_operations_to_transform(3, 'abc', 'abc') 0 >>> min_operations_to_transform(3, 'abc', 'xyz') 3 >>> min_operations_to_transform(2, 'ab', 'ba') 2 >>> min_operations_to_transform(5, 'abcde', 'abfde') 1 >>> min_operations_to_transform(5, 'abcde', 'afxde') 2","solution":"def min_operations_to_transform(n, s, t): Returns the minimum number of operations required to transform string s to string t. :param n: Integer, length of the strings s and t. :param s: String, the initial string. :param t: String, the target string. :return: Integer, minimum number of operations. # Counting the total number of different characters between s and t diff_count = sum(1 for x, y in zip(s, t) if x != y) return diff_count"},{"question":"def longest_subarray_with_diff_leq_k(n, k, array): Returns the length of the longest subarray such that the difference between the maximum and minimum values is less than or equal to k. Parameters: n (int): The size of the array. k (int): The allowed difference between the maximum and minimum values. array (List[int]): The list of integers representing the values in the array. Returns: int: The length of the longest subarray that satisfies the condition. Examples: >>> longest_subarray_with_diff_leq_k(10, 3, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]) 4 >>> longest_subarray_with_diff_leq_k(5, 0, [4, 4, 4, 4, 4]) 5 pass # Replace this with the implementation. # Unit Tests def test_longest_subarray_with_diff_leq_k_example1(): assert longest_subarray_with_diff_leq_k(10, 3, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]) == 4 def test_longest_subarray_with_diff_leq_k_example2(): assert longest_subarray_with_diff_leq_k(5, 0, [4, 4, 4, 4, 4]) == 5 def test_longest_subarray_with_diff_leq_k_single_element_array(): assert longest_subarray_with_diff_leq_k(1, 5, [42]) == 1 def test_longest_subarray_with_diff_leq_k_all_elements_same(): assert longest_subarray_with_diff_leq_k(6, 3, [1, 1, 1, 1, 1, 1]) == 6 def test_longest_subarray_with_diff_leq_k_large_k(): assert longest_subarray_with_diff_leq_k(5, 100, [1, 2, 3, 4, 5]) == 5 def test_longest_subarray_with_diff_leq_k_no_suitable_subarray(): assert longest_subarray_with_diff_leq_k(4, 0, [1, 2, 3, 5]) == 1","solution":"def longest_subarray_with_diff_leq_k(n, k, array): Returns the length of the longest subarray such that the difference between the maximum and minimum values is less than or equal to k. if n == 0: return 0 from collections import deque min_deque, max_deque = deque(), deque() left = 0 max_length = 0 for right in range(n): while min_deque and array[min_deque[-1]] >= array[right]: min_deque.pop() while max_deque and array[max_deque[-1]] <= array[right]: max_deque.pop() min_deque.append(right) max_deque.append(right) while array[max_deque[0]] - array[min_deque[0]] > k: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"def calculate_ranks(arr): This function takes a list of integers which represent the test scores of students in a class and returns a list of integers representing the ranks of each student. >>> calculate_ranks([50, 80, 80, 70]) [4, 1, 1, 3] >>> calculate_ranks([90, 80, 80, 60, 70]) [1, 2, 2, 5, 4] >>> calculate_ranks([100, 100, 100]) [1, 1, 1] >>> calculate_ranks([70, 70, 70, 70]) [1, 1, 1, 1] ...","solution":"def calculate_ranks(arr): This function takes a list of integers which represent the test scores of students in a class and returns a list of integers representing the ranks of each student. # Sort the scores in descending order while keeping track of the original indices sorted_scores = sorted(((score, idx) for idx, score in enumerate(arr)), reverse=True) # Create a list to store ranks ranks = [0] * len(arr) current_rank = 1 for i, (score, idx) in enumerate(sorted_scores): if i > 0 and score == sorted_scores[i - 1][0]: # If this score is same as previous, it gets the same rank ranks[idx] = ranks[sorted_scores[i - 1][1]] else: ranks[idx] = current_rank current_rank += 1 return ranks"},{"question":"def calculate_flight_distance(range_without_payload, battery_capacity, weights): Calculate the maximum flight distance a drone can cover given weights of the packages :param range_without_payload: the flight range of the drone on a full charge (in kilometers) :param battery_capacity: the battery capacity (in milliampere-hours) :param weights: list of weights of the packages (in grams) :return: list of maximum distances the drone can fly for each weight def parse_input(input_data): Parse the input data and returns the relevant values for processing :param input_data: input data as per format :return: list of tuples (range_without_payload, battery_capacity, weights) def main(input_data): drone_data = parse_input(input_data) results = [] for range_without_payload, battery_capacity, weights in drone_data: results.append(calculate_flight_distance(range_without_payload, battery_capacity, weights)) for result in results: print(\\" \\".join(map(str, result))) # Example input input_data = 1 100 5000 50 100 250 End 1 150 7500 100 200 400 End 0 if __name__ == \\"__main__\\": main(input_data)","solution":"def calculate_flight_distance(range_without_payload, battery_capacity, weights): Calculate the maximum flight distance a drone can cover given weights of the packages :param range_without_payload: the flight range of the drone on a full charge (in kilometers) :param battery_capacity: the battery capacity (in milliampere-hours) :param weights: list of weights of the packages (in grams) :return: list of maximum distances the drone can fly for each weight max_distances = [] for weight in weights: # Assuming that each gram of weight reduces the range by a fixed ratio to the weight of the package # For simplicity, assuming 1 gram weight reduces the range by 1 km (which might be different based on real data) reduced_range = range_without_payload - weight # The drone cannot have a negative range; minimum is 0 max_distance = max(0, reduced_range) max_distances.append(max_distance) return max_distances def parse_input(input_data): Parse the input data and returns the relevant values for processing :param input_data: input data as per format :return: list of tuples (range_without_payload, battery_capacity, weights) lines = input_data.strip().split(\\"n\\") idx = 0 drone_data = [] while idx < len(lines): num_drones = int(lines[idx]) idx += 1 if num_drones == 0: break for _ in range(num_drones): range_without_payload, battery_capacity = map(int, lines[idx].split()) idx += 1 weights = [] while lines[idx] != \\"End\\": weight = int(lines[idx]) weights.append(weight) idx += 1 idx += 1 # To skip the \\"End\\" line drone_data.append((range_without_payload, battery_capacity, weights)) return drone_data def main(input_data): drone_data = parse_input(input_data) results = [] for range_without_payload, battery_capacity, weights in drone_data: results.append(calculate_flight_distance(range_without_payload, battery_capacity, weights)) for result in results: print(\\" \\".join(map(str, result))) # Example input input_data = 1 100 5000 50 100 250 End 1 150 7500 100 200 400 End 0 main(input_data)"},{"question":"def rearrange_list(pivot: int, array: List[int]) -> List[int]: Given a list of integers and a pivot, rearrange the list such that for every integer x, all integers less than x come before all integers greater than x. Parameters: - pivot (int): The pivot integer - array (list of int): The list of integers Returns: - list of int: The rearranged list >>> rearrange_list(5, [1, 8, 3, 7, 5, 6, 4, 9, 2]) [1, 3, 4, 2, 8, 7, 5, 6, 9] >>> rearrange_list(10, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_list(0, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rearrange_list(0, [-5, -3, 1, -2, 4]) [-5, -3, -2, 1, 4] >>> rearrange_list(5, [5, 1, 5, 3, 7, 5]) [1, 3, 5, 5, 7, 5] >>> rearrange_list(2, [1]) [1]","solution":"def rearrange_list(pivot, array): Given a list of integers and a pivot, rearrange the list such that for every integer x, all integers less than x come before all integers greater than x. Params: - pivot (int): The pivot integer - array (list of int): The list of integers Returns: - (list of int): The rearranged list less_than_pivot = [i for i in array if i < pivot] equal_or_greater_than_pivot = [i for i in array if i >= pivot] return less_than_pivot + equal_or_greater_than_pivot"},{"question":"def max_subarray_sum(n: int, sequence: List[int]) -> int: Returns the maximum sum of a contiguous subsequence in the sequence. If all numbers are negative, return 0. Params: n: int - the number of integers in the sequence sequence: list of int - the elements of the sequence Returns: int - the maximum sum of a contiguous subsequence >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [-3, -2, -4, -1, -8]) 0","solution":"def max_subarray_sum(n, sequence): Returns the maximum sum of a contiguous subsequence in the sequence. If all numbers are negative, return 0. Params: n: int - the number of integers in the sequence sequence: list of int - the elements of the sequence Returns: int - the maximum sum of a contiguous subsequence if all(x < 0 for x in sequence): return 0 max_ending_here = 0 max_so_far = 0 for x in sequence: max_ending_here = max_ending_here + x if max_ending_here < 0: max_ending_here = 0 if max_ending_here > max_so_far: max_so_far = max_ending_here return max_so_far"},{"question":"def find_palindrome(s: str) -> str: Finds the longest palindromic substring in a given string s. >>> find_palindrome(\\"babad\\") in [\\"bab\\", \\"aba\\"] >>> find_palindrome(\\"cbbd\\") == \\"bb\\" >>> find_palindrome(\\"a\\") == \\"a\\" >>> find_palindrome(\\"ac\\") in [\\"a\\", \\"c\\"] >>> find_palindrome(\\"racecar\\") == \\"racecar\\"","solution":"def find_palindrome(s): Finds the longest palindromic substring in a given string s. n = len(s) if n == 0: return \\"\\" start, max_length = 0, 1 for i in range(1, n): # Check for even length palindromes low, high = i - 1, i while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 # Check for odd length palindromes low, high = i - 1, i + 1 while low >= 0 and high < n and s[low] == s[high]: if high - low + 1 > max_length: start = low max_length = high - low + 1 low -= 1 high += 1 return s[start:start + max_length]"},{"question":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring where the number of opening and closing parentheses is the same and they are correctly nested. >>> longest_balanced_substring(\\")()())\\") 4 >>> longest_balanced_substring(\\"(()))(\\") 4 >>> longest_balanced_substring(\\"\\") 0","solution":"def longest_balanced_substring(s: str) -> int: Returns the length of the longest balanced substring where the number of opening and closing parentheses is the same and they are correctly nested. max_len = 0 stack = [-1] # Stack to store the indices of '(' and the starting points for valid substrings for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' if stack: stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) else: stack.append(i) return max_len"},{"question":"def minimum_spanning_tree(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the total cost of the Minimum Spanning Tree (MST) using Kruskal's algorithm. Args: n (int): The number of cities. m (int): The number of roads. roads (List[Tuple[int, int, int]]): A list of tuples where each tuple represents a road between city u and city v with cost c (u, v, c). Returns: int: The total cost of the MST, or -1 if the network is not initially connected. Example: >>> minimum_spanning_tree(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (4, 1, 3), (1, 3, 2)]) 4 >>> minimum_spanning_tree(4, 2, [(1, 2, 4), (3, 4, 5)]) -1 from typing import List, Tuple # Add any necessary auxiliary functions and implement the Kruskal's algorithm to complete the task.","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): # Sorting the edges based on their weight edges.sort(key=lambda edge: edge[2]) parent = [i for i in range(n)] rank = [0] * n mst_cost = 0 mst_edges = 0 for edge in edges: u, v, c = edge rootU = find(parent, u-1) rootV = find(parent, v-1) if rootU != rootV: mst_cost += c mst_edges += 1 union(parent, rank, rootU, rootV) # Check if we used n-1 edges, which means the graph is connected if mst_edges == n - 1: return mst_cost else: return -1 def minimum_spanning_tree(n, m, roads): return kruskal(n, roads)"},{"question":"def is_valid_transport_sequence(events): This function checks whether a given sequence of board and alight events is valid. >>> is_valid_transport_sequence([(\\"board\\", 1), (\\"board\\", 2), (\\"alight\\", 1), (\\"board\\", 1), (\\"alight\\", 2), (\\"alight\\", 1)]) 'VALID' >>> is_valid_transport_sequence([(\\"board\\", 1), (\\"alight\\", 2), (\\"board\\", 2), (\\"board\\", 1), (\\"alight\\", 1)]) 'INVALID' >>> is_valid_transport_sequence([(\\"board\\", 1), (\\"board\\", 2)]) 'VALID' >>> is_valid_transport_sequence([(\\"board\\", 1), (\\"board\\", 1)]) 'INVALID' >>> is_valid_transport_sequence([(\\"alight\\", 1)]) 'INVALID' >>> is_valid_transport_sequence([(\\"board\\", 1), (\\"alight\\", 1)]) 'VALID'","solution":"def is_valid_transport_sequence(events): This function checks whether a given sequence of board and alight events is valid. on_board = set() for action, rider_id in events: if action == \\"board\\": if rider_id in on_board: return \\"INVALID\\" on_board.add(rider_id) elif action == \\"alight\\": if rider_id not in on_board: return \\"INVALID\\" on_board.remove(rider_id) return \\"VALID\\""},{"question":"def parse_input(input_data: str) -> list: Parse the input data to extract test cases. Args: input_data (str): The input data as a string. Returns: list: A list of test cases, where each test case is a list of tuples with start and end times. >>> input_data = 2 3 1 3 2 4 3 5 4 1 2 2 3 3 4 4 5 >>> parse_input(input_data) [[(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)]] pass def max_non_overlapping_tutorials(test_cases: list) -> list: Determine the maximum number of non-overlapping tutorials for each test case. Args: test_cases (list): A list of test cases, where each test case is a list of tuples with start and end times. Returns: list: A list of integers denoting the maximum number of non-overlapping tutorials for each test case. >>> test_cases = [[(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)]] >>> max_non_overlapping_tutorials(test_cases) [2, 4] pass def generate_output(results: list) -> str: Generate the output string from the results. Args: results (list): A list of integers denoting the results for each test case. Returns: str: A formatted string with the results for each test case on a new line. >>> results = [2, 4] >>> generate_output(results) \\"2n4\\" pass","solution":"def max_non_overlapping_tutorials(test_cases): results = [] for tutorials in test_cases: # Sort the tutorials by their end times tutorials.sort(key=lambda x: x[1]) count = 0 last_end_time = -1 for start, end in tutorials: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results def parse_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) index += 1 tutorials = [] for _ in range(N): start, end = map(int, input_lines[index].split()) index += 1 tutorials.append((start, end)) test_cases.append(tutorials) return test_cases def generate_output(results): return 'n'.join(map(str, results)) # Example usage with sample data input_data = 2 3 1 3 2 4 3 5 4 1 2 2 3 3 4 4 5 test_cases = parse_input(input_data) results = max_non_overlapping_tutorials(test_cases) output = generate_output(results) print(output)"},{"question":"def min_path_cost(grid): Finds the minimum cost to reach the bottom-right corner of the grid from the top-left corner. >>> min_path_cost([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_cost([ ... [1, 2], ... [3, 4] ... ]) == 7 >>> min_path_cost([ ... [1, 1000], ... [1000, 1] ... ]) == 1002 >>> min_path_cost([ ... [1] ... ]) == 1","solution":"def min_path_cost(grid): Finds the minimum cost to reach the bottom-right corner of the grid from the top-left corner. n, m = len(grid), len(grid[0]) dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def min_cost_to_reach_corner(test_cases): Parses the input of multiple test cases and calculates the minimum cost path for each. results = [] for grid in test_cases: results.append(min_path_cost(grid)) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) index = 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) grid = [] for i in range(n): grid.append(list(map(int, lines[index + 1 + i].split()))) index += n + 1 test_cases.append(grid) return test_cases def main(input_str): test_cases = parse_input(input_str) results = min_cost_to_reach_corner(test_cases) for result in results: print(result) # Example usage: input_str = 2 3 3 1 3 1 1 5 1 4 2 1 2 2 1 2 3 4 main(input_str)"},{"question":"def validate_tags(text: str) -> bool: Verify that all HTML-like tags in the text are properly closed and nested. >>> validate_tags(\\"<div><b>hello</b><i>world</i></div>\\") True >>> validate_tags(\\"<div><b>hello</i></b></div>\\") False >>> validate_tags(\\"<div><b>Hello</b> world<i>!</div>\\") False >>> validate_tags(\\"<p><a>link</a>text</p>\\") True","solution":"def validate_tags(text: str) -> bool: import re tag_pattern = re.compile(r\\"</?([a-zA-Z0-9]+)>\\") stack = [] for match in tag_pattern.finditer(text): tag = match.group(1) if text[match.start()] == '<' and text[match.start() + 1] != '/': # Opening tag stack.append(tag.lower()) elif text[match.start()] == '<' and text[match.start() + 1] == '/': # Closing tag if not stack or stack.pop() != tag.lower(): return False return len(stack) == 0"},{"question":"def is_valid_transaction(N: int, transactions: List[List[int]]) -> str: Determines whether a list of N transaction operations is valid based on the bank's rule. >>> is_valid_transaction(4, [[5, 0, 0], [0, 3, 0], [-2, 0, 0], [0, 0, 4]]) 'Valid' >>> is_valid_transaction(3, [[5, 0, -1], [0, 2, 0], [0, 0, 3]]) 'Invalid' pass","solution":"def is_valid_transaction(N, transactions): for txn in transactions: non_zero_counts = sum(1 for x in txn if x != 0) if non_zero_counts != 1: return \\"Invalid\\" return \\"Valid\\""},{"question":"def perform_queries(n, m, grid, queries): Performs the given queries on the grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : list of list of int : the grid with its initial values queries : list of tuple : the queries to be performed Returns: list of int : results for each type 1 query pass def find_max(x1, y1, x2, y2, grid): Finds the maximum value in the sub-grid defined by (x1, y1) and (x2, y2). Args: x1 : int : starting row index (1-based) y1 : int : starting column index (1-based) x2 : int : ending row index (1-based) y2 : int : ending column index (1-based) grid : list of list of int : the grid Returns: int : the maximum value in the sub-grid pass def increment_values(x1, y1, x2, y2, grid): Increments the value of every element in the sub-grid defined by (x1, y1) and (x2, y2) by 1. Args: x1 : int : starting row index (1-based) y1 : int : starting column index (1-based) x2 : int : ending row index (1-based) y2 : int : ending column index (1-based) grid : list of list of int : the grid pass def test_sample_input(): n = 4 m = 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] queries = [ (1, 1, 1, 3, 3), (2, 2, 2, 4, 4), (1, 1, 1, 4, 4) ] expected_output = [11, 17] assert perform_queries(n, m, grid, queries) == expected_output def test_max_query(): grid = [ [1, 3, 5], [7, 9, 2], [4, 6, 8] ] assert find_max(1, 1, 3, 3, grid) == 9 assert find_max(2, 2, 3, 3, grid) == 9 assert find_max(1, 2, 2, 3, grid) == 9 assert find_max(1, 1, 1, 1, grid) == 1 def test_increment_query(): grid = [ [1, 2], [3, 4] ] increment_values(1, 1, 2, 2, grid) assert grid == [ [2, 3], [4, 5] ] increment_values(1, 1, 1, 1, grid) assert grid == [ [3, 3], [4, 5] ] increment_values(2, 2, 2, 2, grid) assert grid == [ [3, 3], [4, 6] ]","solution":"def perform_queries(n, m, grid, queries): Performs the given queries on the grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : list of list of int : the grid with its initial values queries : list of tuple : the queries to be performed Returns: list of int : results for each type 1 query results = [] for query in queries: tp, x1, y1, x2, y2 = query if tp == 1: max_value = find_max(x1, y1, x2, y2, grid) results.append(max_value) elif tp == 2: increment_values(x1, y1, x2, y2, grid) return results def find_max(x1, y1, x2, y2, grid): Finds the maximum value in the sub-grid defined by (x1, y1) and (x2, y2). Args: x1 : int : starting row index (1-based) y1 : int : starting column index (1-based) x2 : int : ending row index (1-based) y2 : int : ending column index (1-based) grid : list of list of int : the grid Returns: int : the maximum value in the sub-grid max_value = grid[x1-1][y1-1] for i in range(x1-1, x2): for j in range(y1-1, y2): if grid[i][j] > max_value: max_value = grid[i][j] return max_value def increment_values(x1, y1, x2, y2, grid): Increments the value of every element in the sub-grid defined by (x1, y1) and (x2, y2) by 1. Args: x1 : int : starting row index (1-based) y1 : int : starting column index (1-based) x2 : int : ending row index (1-based) y2 : int : ending column index (1-based) grid : list of list of int : the grid for i in range(x1-1, x2): for j in range(y1-1, y2): grid[i][j] += 1"},{"question":"def findPeakElement(nums: List[int]) -> int: Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. >>> findPeakElement([1, 2, 3, 1]) == 2 >>> findPeakElement([1, 2, 1]) == 1 >>> findPeakElement([1, 3, 4, 5, 2]) == 3","solution":"def findPeakElement(nums): Finds the index of a peak element in the array. A peak element is an element that is strictly greater than its neighbors. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"def find_sequence_with_one_zero_xor_subarray(n: int, a: List[int]) -> Union[str, int]: Find the lexicographically smallest sequence that contains exactly one subarray whose XOR sum is zero. Arguments: n -- the number of integers in the sequence. a -- the list of n integers. Returns: The lexicographically smallest sequence as a space-separated string or -1 if it's not possible. Examples: >>> find_sequence_with_one_zero_xor_subarray(4, [1, 2, 3, 0]) \\"0 1 2 3\\" >>> find_sequence_with_one_zero_xor_subarray(3, [4, 5, 6]) -1","solution":"def find_sequence_with_one_zero_xor_subarray(n, a): a.sort() total_xor = 0 for number in a: total_xor ^= number if total_xor == 0: result = ' '.join(map(str, a)) return result else: return -1"},{"question":"def minChangesToKDistinct(k: int, s: str) -> int: Returns the minimum number of characters that need to be changed so that the string contains k distinct characters. Args: k (int): The desired number of distinct characters. s (str): The string to be transformed. Returns: int: The minimum number of character changes required. Examples: >>> minChangesToKDistinct(5, \\"aaabbcc\\") 2 >>> minChangesToKDistinct(3, \\"abcd\\") 0 >>> minChangesToKDistinct(2, \\"aaaa\\") 1","solution":"def minChangesToKDistinct(k, s): Returns the minimum number of characters that need to be changed so that the string s contains k distinct characters. from collections import Counter # Step 1: Count the frequency of each character in the string freq = Counter(s) # Step 2: Determine the number of current distinct characters current_distinct = len(freq) # If the current number of distinct characters is already k or more if current_distinct >= k: return 0 # Step 3: Calculate the number of changes needed total_changes_needed = k - current_distinct return total_changes_needed"},{"question":"def find_pairs(nums: List[int], target: int) -> List[List[int]]: Return a list of unique pairs from the nums list that add up to the target. >>> sorted(find_pairs([1, 2, 3, 4, 5], 5)) [[1, 4], [2, 3]] >>> find_pairs([1, 2, 3], 7) [] >>> sorted(find_pairs([1, 2, 3, 4, 5, 6], 6)) [[1, 5], [2, 4]] >>> sorted(find_pairs([1, 2, 2, 3, 4, 5, 5], 7)) [[2, 5], [3, 4]] >>> sorted(find_pairs([-1, -2, 1, 2, 3, 4], 2)) [[-2, 4], [-1, 3]] >>> find_pairs([0, 0, 0, 0], 1) []","solution":"def find_pairs(nums, target): Return a list of unique pairs from the nums list that add up to the target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in pairs]"},{"question":"def distribute_products(num_stores, product_list): Distributes products to retail stores ensuring minimal leftover products. Args: num_stores (int): Number of retail stores. product_list (list of tuples): List of product types and their quantities. Returns: list of str: Distribution details for each product type. >>> distribute_products(3, [(\\"Apples\\", 14), (\\"Bananas\\", 15), (\\"Cherries\\", 9), (\\"Dates\\", 27)]) ['Apples: 4 2', 'Bananas: 5 0', 'Cherries: 3 0', 'Dates: 9 0'] >>> distribute_products(1, [(\\"Apples\\", 14)]) ['Apples: 14 0'] def parse_input(input_string): Parses the input string into the required parameters. Args: input_string (str): Multiline string of the input parameters. Returns: tuple: Number of stores and list of products with their quantities. >>> parse_input(\\"3n4nApples 14nBananas 15nCherries 9nDates 27n\\") (3, [(\\"Apples\\", 14), (\\"Bananas\\", 15), (\\"Cherries\\", 9), (\\"Dates\\", 27)]) >>> parse_input(\\"1n1nApples 14n\\") (1, [(\\"Apples\\", 14)])","solution":"def distribute_products(num_stores, product_list): Distributes products to retail stores ensuring minimal leftover products. Args: num_stores (int): Number of retail stores. product_list (list of tuples): List of product types and their quantities. Returns: list of str: Distribution details for each product type. distribution_results = [] for product, quantity in product_list: quantity_per_store = quantity // num_stores remaining_quantity = quantity % num_stores distribution_results.append(f\\"{product}: {quantity_per_store} {remaining_quantity}\\") return distribution_results def parse_input(input_string): Parses the input string into the required parameters. Args: input_string (str): Multiline string of the input parameters. Returns: tuple: Number of stores and list of products with their quantities. lines = input_string.strip().split('n') num_stores = int(lines[0]) num_products = int(lines[1]) product_list = [] for i in range(2, 2 + num_products): product, quantity = lines[i].rsplit(' ', 1) product_list.append((product, int(quantity))) return num_stores, product_list"},{"question":"def calculate_min_distance(adventurers, treasures): Calculate the minimum total energy required for all adventurers to collect all the treasures. >>> calculate_min_distance([(1, 1), (2, 2)], [(1, 2), (2, 1)]) 2 >>> calculate_min_distance([(1, 2), (2, 1), (3, 3)], [(1, 1), (2, 2), (3, 1)]) 4 pass def min_total_distance(test_cases): Evaluate multiple test cases to find the minimum total energy required for all adventurers to collect all the treasures. >>> min_total_distance([([(1, 1), (2, 2)], [(1, 2), (2, 1)]), ([(1, 2), (2, 1), (3, 3)], [(1, 1), (2, 2), (3, 1)])]) [2, 4] pass def parse_input(input_str): Parse the input string into structured test cases. >>> input_str = \\"2n2n1 1n2 2n1 2n2 1n3n1 2n2 1n3 3n1 1n2 2n3 1n\\" >>> parse_input(input_str) [[([(1, 1), (2, 2)], [(1, 2), (2, 1)])], [[(1, 2), (2, 1), (3, 3)], [(1, 1), (2, 2), (3, 1)]]] pass def test_parse_input(): input_str = \\"2n2n1 1n2 2n1 2n2 1n3n1 2n2 1n3 3n1 1n2 2n3 1n\\" expected_output = [ ([(1, 1), (2, 2)], [(1, 2), (2, 1)]), ([(1, 2), (2, 1), (3, 3)], [(1, 1), (2, 2), (3, 1)]) ] assert parse_input(input_str) == expected_output def test_min_total_distance(): test_cases = [ ([(1, 1), (2, 2)], [(1, 2), (2, 1)]), ([(1, 2), (2, 1), (3, 3)], [(1, 1), (2, 2), (3, 1)]) ] expected_output = [2, 4] assert min_total_distance(test_cases) == expected_output def test_calculate_min_distance(): adventurers = [(1, 1), (2, 2)] treasures = [(1, 2), (2, 1)] assert calculate_min_distance(adventurers, treasures) == 2 adventurers = [(1, 2), (2, 1), (3, 3)] treasures = [(1, 1), (2, 2), (3, 1)] assert calculate_min_distance(adventurers, treasures) == 4 # Run the tests test_parse_input() test_min_total_distance() test_calculate_min_distance() print(\\"All tests passed!\\")","solution":"from itertools import permutations def calculate_min_distance(adventurers, treasures): n = len(adventurers) min_distance = float('inf') for perm in permutations(treasures): distance = sum(abs(adventurers[i][0] - perm[i][0]) + abs(adventurers[i][1] - perm[i][1]) for i in range(n)) min_distance = min(min_distance, distance) return min_distance def min_total_distance(test_cases): results = [] for adventurers, treasures in test_cases: results.append(calculate_min_distance(adventurers, treasures)) return results def parse_input(input_str): input_lines = input_str.split('n') t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) adventurers = [] treasures = [] index += 1 for _ in range(n): x, y = map(int, input_lines[index].split()) adventurers.append((x, y)) index += 1 for _ in range(n): x, y = map(int, input_lines[index].split()) treasures.append((x, y)) index += 1 test_cases.append((adventurers, treasures)) return test_cases"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Finds the element that appears an odd number of times in the list. Args: arr (List[int]): The list of integers. Returns: int: The element that appears an odd number of times. Examples: >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) 3 >>> find_odd_occurrence([4, 5, 6, 4, 5, 6, 4]) 4","solution":"def find_odd_occurrence(arr): Finds the element that appears an odd number of times in the list. result = 0 for num in arr: result ^= num return result"},{"question":"def can_measure_out(ingredient_weights, target_weight): Determine if the target weight can be achieved using any combination of given weights. This is a variation of the subset sum problem. pass def can_balance_taste(t, test_cases): Determine if it is possible to balance the taste by mixing the exact amount of two ingredients using any combination of packets available. >>> can_balance_taste(2, [(3, [1, 3, 5], 2, [2, 4], 6, 6), (4, [2, 5, 8, 10], 3, [1, 4, 6], 7, 9)]) == [\\"YES\\", \\"NO\\"] pass def parse_input(input_str): Parse the input string and return the number of test cases and the test case details. >>> input_str = \\"2n3n1 3 5n2n2 4n6 6n4n2 5 8 10n3n1 4 6n7 9n\\" >>> parse_input(input_str) == (2, [(3, [1, 3, 5], 2, [2, 4], 6, 6), (4, [2, 5, 8, 10], 3, [1, 4, 6], 7, 9)]) pass def main(input_str): Main function to handle input and output. >>> input_str = \\"2n3n1 3 5n2n2 4n6 6n4n2 5 8 10n3n1 4 6n7 9n\\" >>> main(input_str) == \\"YESnNO\\" pass","solution":"def can_measure_out(ingredient_weights, target_weight): Determine if the target weight can be achieved using any combination of given weights. This is a variation of the subset sum problem. dp = [False] * (target_weight + 1) dp[0] = True for weight in ingredient_weights: for i in range(target_weight, weight - 1, -1): if dp[i - weight]: dp[i] = True return dp[target_weight] def can_balance_taste(t, test_cases): results = [] for case in test_cases: n, weightsA, m, weightsB, x, y = case can_measure_A = can_measure_out(weightsA, x) can_measure_B = can_measure_out(weightsB, y) if can_measure_A and can_measure_B: results.append(\\"YES\\") else: results.append(\\"NO\\") return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) weightsA = list(map(int, lines[index + 1].split())) m = int(lines[index + 2]) weightsB = list(map(int, lines[index + 3].split())) x, y = map(int, lines[index + 4].split()) test_cases.append((n, weightsA, m, weightsB, x, y)) index += 5 return t, test_cases def main(input_str): t, test_cases = parse_input(input_str) results = can_balance_taste(t, test_cases) return \\"n\\".join(results)"},{"question":"def count_connected_components(N, edges): Determines the number of connected components in an undirected graph. Parameters: N (int): Number of nodes. edges (list of tuples): List of edges, where each edge is represented as a tuple (u, v). Returns: int: Number of connected components. pass def test_sample_input(): N = 5 edges = [(1, 2), (2, 3), (4, 5)] assert count_connected_components(N, edges) == 2 def test_no_edges(): N = 4 edges = [] assert count_connected_components(N, edges) == 4 def test_single_component(): N = 4 edges = [(1, 2), (2, 3), (3, 4)] assert count_connected_components(N, edges) == 1 def test_disjoint_components(): N = 6 edges = [(1, 2), (3, 4), (5, 6)] assert count_connected_components(N, edges) == 3 def test_minimum_input(): N = 1 edges = [] assert count_connected_components(N, edges) == 1 def test_large_input(): N = 10000 edges = [(i, i + 1) for i in range(1, 10000)] assert count_connected_components(N, edges) == 1 def test_sparse_and_dense_mixed(): N = 5 edges = [(1, 2), (1, 3), (1, 4), (2, 4), (3, 4)] assert count_connected_components(N, edges) == 2","solution":"def count_connected_components(N, edges): Determines the number of connected components in an undirected graph. Parameters: N (int): Number of nodes. edges (list of tuples): List of edges, where each edge is represented as a tuple (u, v). Returns: int: Number of connected components. from collections import defaultdict def dfs(node, visited, graph): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() connected_components = 0 for node in range(1, N+1): if node not in visited: visited.add(node) dfs(node, visited, graph) connected_components += 1 return connected_components"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def is_connected(N: int, connections: List[Tuple[int, int]], A: int, B: int) -> str: Determine if there is a path connecting computer A to computer B. >>> is_connected(5, [(1, 2), (2, 3), (4, 5), (1, 3), (3, 4)], 1, 5) \\"YES\\" >>> is_connected(3, [(1, 2), (2, 3), (4, 5)], 1, 4) \\"NO\\"","solution":"def is_connected(N, connections, A, B): from collections import defaultdict, deque graph = defaultdict(list) # Build the graph for u, v in connections: graph[u].append(v) graph[v].append(u) # Use BFS to determine if there's a path between A and B visited = set() queue = deque([A]) while queue: node = queue.popleft() if node == B: return \\"YES\\" if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return \\"NO\\""},{"question":"def find_all_palindromic_substrings(s: str) -> List[str]: Extracts all possible substrings from a given string that are palindromes and sorts them first by their length and then lexicographically. Args: s (str): Input string containing only lowercase English letters. Returns: List[str]: Sorted list of unique palindromic substrings. Example: >>> find_all_palindromic_substrings(\\"abcbc\\") ['a', 'b', 'c', 'bcb', 'cbc']","solution":"def find_all_palindromic_substrings(s): Returns a list of unique palindromic substrings sorted by their length and then lexicographically. def is_palindrome(sub): return sub == sub[::-1] unique_palindromes = set() n = len(s) # Generate all substrings and check if they are palindromes for start in range(n): for end in range(start+1, n+1): substring = s[start:end] if is_palindrome(substring): unique_palindromes.add(substring) # Sorting by length and then lexicographically sorted_palindromes = sorted(unique_palindromes, key=lambda x: (len(x), x)) return sorted_palindromes # Example usage: # print(find_all_palindromic_substrings(\\"abcbc\\"))"},{"question":"def categorize_email(email_content: str) -> str: Categorizes email content into specific categories based on predefined rules. - If an email contains the phrase \\"billing issue\\" or \\"payment problem\\", classify it as \\"Billing Department\\". - If an email contains the phrase \\"technical support\\" or \\"software issue\\", classify it as \\"Technical Support\\". - If an email contains the phrase \\"product inquiry\\" or \\"information request\\", classify it as \\"Sales Department\\". - If an email contains the phrase \\"job application\\" or \\"applying for\\", classify it as \\"HR Department\\". - If an email contains the phrase \\"partnership opportunity\\" or \\"collaboration request\\", classify it as \\"Business Development\\". - If none of the above phrases are found, classify it as \\"General Inquiry\\". The function should be case-insensitive when matching phrases. >>> categorize_email(\\"I have a billing issue with my account.\\") \\"Billing Department\\" >>> categorize_email(\\"I am facing a technical support issue.\\") \\"Technical Support\\" >>> categorize_email(\\"Can you help with a product inquiry?\\") \\"Sales Department\\" >>> categorize_email(\\"I am submitting my job application for the open position.\\") \\"HR Department\\" >>> categorize_email(\\"We are looking at a partnership opportunity with your company.\\") \\"Business Development\\" >>> categorize_email(\\"What are your office hours?\\") \\"General Inquiry\\"","solution":"def categorize_email(email_content: str) -> str: Categorizes email content into specific categories based on predefined rules. email_content = email_content.lower() if \\"billing issue\\" in email_content or \\"payment problem\\" in email_content: return \\"Billing Department\\" if \\"technical support\\" in email_content or \\"software issue\\" in email_content: return \\"Technical Support\\" if \\"product inquiry\\" in email_content or \\"information request\\" in email_content: return \\"Sales Department\\" if \\"job application\\" in email_content or \\"applying for\\" in email_content: return \\"HR Department\\" if \\"partnership opportunity\\" in email_content or \\"collaboration request\\" in email_content: return \\"Business Development\\" return \\"General Inquiry\\""},{"question":"def can_rearrange(n, array): Determines if it's possible to rearrange the array such that every element in the rearranged array is less than the sum of the two elements immediately preceding it. Args: n (int): The size of the array. array (List[int]): The list of integers in the array. Returns: str: \\"YES\\" if the array can be rearranged to meet the condition, otherwise \\"NO\\". >>> can_rearrange(4, [4, 1, 3, 2]) \\"YES\\" >>> can_rearrange(3, [10, 20, 30]) \\"NO\\" >>> can_rearrange(5, [1, 3, 5, 7, 9]) \\"YES\\" def process_test_cases(t, test_cases): Processes multiple test cases to determine if each array can be rearranged to meet the specified condition. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the size of the array and the array itself for each test case. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(3, [(4, [4, 1, 3, 2]), (3, [10, 20, 30]), (5, [1, 3, 5, 7, 9])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(1, [(1, [1])]) [\\"YES\\"] if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def can_rearrange(n, array): Determines if it's possible to rearrange the array such that every element in the rearranged array is less than the sum of the two elements immediately preceding it. array.sort() if n < 3: return \\"YES\\" # Check for the condition in the sorted array if array[-1] < array[-2] + array[-3]: return \\"YES\\" else: return \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): n, array = test_cases[i] result = can_rearrange(n, array) results.append(result) return results"},{"question":"def mirror_string(s: str) -> str: Returns a new string where each character in the original string is replaced by its \\"mirror\\" character in the alphabet. >>> mirror_string(\\"abc\\") \\"zyx\\" >>> mirror_string(\\"hello\\") \\"svool\\" >>> mirror_string(\\"xyz\\") \\"cba\\"","solution":"def mirror_string(s): Returns a new string where each character in the original string is replaced by its \\"mirror\\" character in the alphabet. mirrored = [] for char in s: mirrored_char = chr(ord('a') + (ord('z') - ord(char))) mirrored.append(mirrored_char) return ''.join(mirrored)"},{"question":"def bubble_sort_min_swaps(n: int, card_ids: List[int]) -> int: Returns the minimum number of swaps required to sort the cards using the Bubble Sort algorithm. >>> bubble_sort_min_swaps(4, [4, 3, 2, 1]) 6 >>> bubble_sort_min_swaps(5, [2, 3, 8, 6, 1]) 5","solution":"def bubble_sort_min_swaps(n, card_ids): Returns the minimum number of swaps required to sort the cards using the Bubble Sort algorithm. swaps = 0 for i in range(n): for j in range(0, n - i - 1): if card_ids[j] > card_ids[j + 1]: card_ids[j], card_ids[j + 1] = card_ids[j + 1], card_ids[j] swaps += 1 return swaps"},{"question":"from collections import defaultdict from typing import List, Tuple def find_centroid(tree: defaultdict, N: int) -> int: Given a tree structure represented as an adjacency list and the number of nodes N, find the centroid of the tree. def dfs(node, parent): size[node] = 1 for neighbor in tree[node]: if neighbor != parent: size[node] += dfs(neighbor, node) return size[node] def get_centroid(node, parent): for neighbor in tree[node]: if neighbor != parent and size[neighbor] > total_nodes // 2: return get_centroid(neighbor, node) return node size = [0] * (N + 1) total_nodes = N dfs(1, -1) return get_centroid(1, -1) def parse_input(input_lines: List[str]) -> List[List[Tuple[int, int]]]: Parse the input lines to retrieve the tree data for each test case. trees = [] current_tree = [] for line in input_lines: if line.strip() == '0': if current_tree: trees.append(current_tree) break parts = line.strip().split() if len(parts) == 1: if current_tree: trees.append(current_tree) current_tree = [int(parts[0])] else: current_tree.append((int(parts[0]), int(parts[1]))) return trees def main(input_lines: List[str]) -> List[int]: For each test case provided in the input, find and return the centroid of the tree. trees = parse_input(input_lines) results = [] for tree_data in trees: N = tree_data[0] if N == 1: results.append(1) continue tree = defaultdict(list) for u, v in tree_data[1:]: tree[u].append(v) tree[v].append(u) results.append(find_centroid(tree, N)) return results # Example usage input_lines = [ '6', '1 2', '1 3', '2 4', '2 5', '3 6', '0' ] print(main(input_lines))","solution":"from collections import defaultdict, deque def find_centroid(tree, N): size = [0] * (N + 1) def dfs(node, parent): size[node] = 1 for neighbor in tree[node]: if neighbor != parent: size[node] += dfs(neighbor, node) return size[node] total_nodes = N def get_centroid(node, parent): for neighbor in tree[node]: if neighbor != parent and size[neighbor] > total_nodes // 2: return get_centroid(neighbor, node) return node dfs(1, -1) return get_centroid(1, -1) def parse_input(input_lines): trees = [] current_tree = [] for line in input_lines: if line == '0': if current_tree: trees.append(current_tree) break parts = line.split() if len(parts) == 1: if current_tree: trees.append(current_tree) current_tree = [int(parts[0])] else: current_tree.append((int(parts[0]), int(parts[1]))) return trees def main(input_lines): trees = parse_input(input_lines) results = [] for tree_data in trees: N = tree_data[0] if N == 1: results.append(1) continue tree = defaultdict(list) for u, v in tree_data[1:]: tree[u].append(v) tree[v].append(u) results.append(find_centroid(tree, N)) return results # Example usage input_lines = [ '6', '1 2', '1 3', '2 4', '2 5', '3 6', '0' ] print(main(input_lines))"},{"question":"def findMissing(arr, n): Returns the smallest positive integer missing from the array. Args: arr: list of integers. n: size of the array. Returns: Smallest positive integer missing. pass def partition(arr, n): This function segregates positive and non-positive numbers in the array. Args: arr: list of integers. n: size of the array. Returns: Index of the first positive number. pass def findMissingPositive(arr, n): This function finds the smallest positive missing number from the array that contains all positive integers. Args: arr: list of positive integers. n: size of the array. Returns: Smallest positive integer missing. pass def test_findMissing(): assert findMissing([3, 4, -1, 1], 4) == 2 assert findMissing([1, 2, 0], 3) == 3 assert findMissing([7, 8, 9, 11, 12], 5) == 1 assert findMissing([2, 3, 4, -1, -2, 0, 1], 7) == 5 assert findMissing([-5, -1, -2, -3], 4) == 1 assert findMissing([0, 2, 2, 1, 1], 5) == 3 def test_edge_cases(): assert findMissing([1], 1) == 2 assert findMissing([-1], 1) == 1 assert findMissing([0], 1) == 1 assert findMissing([2], 1) == 1 assert findMissing([-1000000, 1, 1000000], 3) == 2","solution":"def findMissing(arr, n): Returns the smallest positive integer missing from the array. Args: arr: list of integers. n: size of the array. Returns: Smallest positive integer missing. # Move all the non-positive numbers to the left side of the array # and the positive numbers to the right side shift = partition(arr, n) # Use the index for marking numbers present in the positive part return findMissingPositive(arr[shift:], n - shift) def partition(arr, n): This function segregates positive and non-positive numbers in the array. Args: arr: list of integers. n: size of the array. Returns: Index of the first positive number. j = 0 for i in range(n): if arr[i] <= 0: arr[i], arr[j] = arr[j], arr[i] j += 1 return j def findMissingPositive(arr, n): This function finds the smallest positive missing number from the array that contains all positive integers. Args: arr: list of positive integers. n: size of the array. Returns: Smallest positive integer missing. for i in range(n): val = abs(arr[i]) if val - 1 < n and arr[val - 1] > 0: arr[val - 1] = -arr[val - 1] for i in range(n): if arr[i] > 0: return i + 1 return n + 1"},{"question":"def count_distinct_words(s: str) -> int: Given a string s consisting of multiple words separated by spaces, determines the number of distinct words in the string. >>> count_distinct_words('hello world') 2 >>> count_distinct_words('one fish two fish red fish blue fish') 5 >>> count_distinct_words('repeat repeat repeat') 1 >>> count_distinct_words('unique words only once') 4","solution":"def count_distinct_words(s): Returns the number of distinct words in the input string s. words = s.split() distinct_words = set(words) return len(distinct_words)"},{"question":"def max_sum_subarray_with_one_removal(arr): Given an array of integers, find the maximum sum of a contiguous subarray that can be obtained by removing at most one element from the array. Args: arr (List[int]): The input array of integers. Returns: int: The maximum sum of a contiguous subarray with at most one element removed. Examples: >>> max_sum_subarray_with_one_removal([1, -2, 0, 3, -1, 2]) 5 >>> max_sum_subarray_with_one_removal([2, -1, -2, 3, 4, -10, 2]) 9 >>> max_sum_subarray_with_one_removal([-1, -1, -1, -1, -1]) -1","solution":"def max_sum_subarray_with_one_removal(arr): n = len(arr) if n == 0: return 0 # Initialize to handle arrays of length 1 max_ending_here = [0] * n max_starting_here = [0] * n max_ending_here[0] = arr[0] max_starting_here[-1] = arr[-1] for i in range(1, n): max_ending_here[i] = max(arr[i], max_ending_here[i - 1] + arr[i]) for i in range(n - 2, -1, -1): max_starting_here[i] = max(arr[i], max_starting_here[i + 1] + arr[i]) max_sum = max(max_ending_here) for i in range(1, n - 1): max_sum = max(max_sum, max_ending_here[i - 1] + max_starting_here[i + 1]) return max_sum"},{"question":"def has_pair_with_sum(arr, target_sum): Determines if there exist two distinct elements in an array that add up to a given target sum. Args: arr (list of int): List of integers. target_sum (int): The target sum. Returns: str: \\"YES\\" if there exists a pair with the target_sum, otherwise \\"NO\\". Examples: >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 4, 4], 8) \\"YES\\" >>> has_pair_with_sum([1, 2, 3], 7) \\"NO\\"","solution":"def has_pair_with_sum(arr, target_sum): Determines if there exist two distinct elements in an array that add up to a given target sum. Args: arr (list of int): List of integers. target_sum (int): The target sum. Returns: str: \\"YES\\" if there exists a pair with the target_sum, otherwise \\"NO\\". seen = set() for number in arr: if target_sum - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\" # Example usage: # n = 5 # arr = [1, 2, 3, 4, 5] # target_sum = 9 # print(has_pair_with_sum(arr, target_sum)) # Output: \\"YES\\""},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: # Check if a number is a prime number pass def find_min_edges(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Given a graph with N nodes and M edges, determine the minimum number of edges to traverse from node 1 to node N where each edge's weight is a prime number. Returns the minimum number of edges or -1 if it's not possible. pass def process_test_cases(T: int, test_cases: List[List[Tuple[int, int]]]) -> List[int]: Processes multiple test cases. T is the number of test cases. test_cases is a list where each element is another list containing tuples: - The first tuple contains two integers N and M. - The remaining tuples contain three integers u, v, and w representing an edge. Returns a list of results for each test case. pass import pytest def test_case_1(): test_cases = [ [ (5, 5), (1, 2, 3), (1, 3, 4), (2, 4, 5), (3, 5, 7), (4, 5, 11), ], [ (3, 3), (1, 2, 6), (2, 3, 17), (1, 3, 20), ] ] T = 2 assert process_test_cases(T, test_cases) == [3, -1] def test_case_no_prime_weights(): test_cases = [ [ (3, 2), (1, 2, 4), (2, 3, 6), ] ] T = 1 assert process_test_cases(T, test_cases) == [-1] def test_case_direct_connection(): test_cases = [ [ (2, 1), (1, 2, 7), ] ] T = 1 assert process_test_cases(T, test_cases) == [1] def test_case_multiple_paths(): test_cases = [ [ (4, 4), (1, 2, 3), (1, 3, 5), (2, 4, 7), (3, 4, 11), ] ] T = 1 assert process_test_cases(T, test_cases) == [2] def test_case_no_edges(): test_cases = [ [ (3, 0), ] ] T = 1 assert process_test_cases(T, test_cases) == [-1] pytest.main()","solution":"import math import collections def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False limit = int(math.sqrt(num)) + 1 for i in range(3, limit, 2): if num % i == 0: return False return True def find_min_edges(N, M, edges): adjacency_list = collections.defaultdict(list) for u, v, w in edges: if is_prime(w): adjacency_list[u].append(v) adjacency_list[v].append(u) queue = collections.deque([(1, 0)]) # start from node 1 with 0 edges visited = set() visited.add(1) while queue: current_node, current_depth = queue.popleft() if current_node == N: return current_depth for neighbor in adjacency_list[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_depth + 1)) return -1 def process_test_cases(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] edges = test_cases[i][1:] result = find_min_edges(N, M, edges) results.append(result) return results"},{"question":"def find_team_with_highest_score(n: int, matches: List[Tuple[int, int, int, int]]) -> int: Computes the total score for each team and returns the team with the highest cumulative score. If there are multiple teams with the highest cumulative score, returns the team with the smallest numerical identifier. Args: n (int): The number of teams. matches (List[Tuple[int, int, int, int]]): List of tuples, each containing (i, j, score_i, score_j). Returns: int: The identifier of the team with the highest cumulative score. >>> find_team_with_highest_score(3, [(1, 2, 10, 8), (1, 3, 12, 5), (2, 3, 9, 11)]) 1 >>> find_team_with_highest_score(3, [(1, 2, 15, 20), (1, 3, 20, 15), (2, 3, 25, 20)]) 2 >>> find_team_with_highest_score(3, [(1, 2, 10, 10), (1, 3, 10, 10), (2, 3, 10, 10)]) 1","solution":"def find_team_with_highest_score(n, matches): scores = [0] * (n + 1) for match in matches: i, j, score_i, score_j = match scores[i] += score_i scores[j] += score_j max_score = max(scores) return scores.index(max_score) # Reading from standard input for testing if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) matches = [] index = 2 for _ in range(m): i, j, score_i, score_j = map(int, data[index:index+4]) matches.append((i, j, score_i, score_j)) index += 4 print(find_team_with_highest_score(n, matches))"},{"question":"def marathon_queries(m: int, queries: List[str]) -> List[int]: The city is organizing a marathon race with N participants. Each participant has a unique identifier between 1 and N. The race officials want to record the time taken by each participant as they cross various checkpoints set up along the race route. However, sometimes participants can re-check-in at a checkpoint, and the latest check-in time overwrites the previous one for the same checkpoint. After the race, officials need to efficiently analyze the recorded data to find the maximum or minimum check-in time for a participant within a specified range of checkpoints. The system should handle two types of queries: 1. Type 1 - Update Checkpoint Time: It is of the form \`1 p c t\`, where \`p\` is the participant ID, \`c\` is the checkpoint number, and \`t\` is the check-in time. 2. Type 2 - Query Participant Times: It is of the form \`2 p c1 c2 q\`, where \`p\` is the participant ID, \`c1\` and \`c2\` represent the inclusive range of checkpoints, and \`q\` is a character that can be either 'max' or 'min'. Based on the value of \`q\`, return either the maximum or minimum check-in time for participant \`p\` between checkpoints \`c1\` and \`c2\`. Input: - The first line contains an integer \`M\`, the number of queries. - Each of the following \`M\` lines contains a query of one of the two types described above. Output: - For each query of Type 2, output the required maximum or minimum check-in time. Constraints: - 1 <= M <= 10^5 - 1 <= N <= 10^5 - 1 <= c1 <= c2 <= 10^5 - 1 <= t <= 10^9 Subtask 1: (30 points) - 1 <= M <= 10^3 - 1 <= N <= 10^3 - 1 <= c1 <= c2 <= 10^3 Subtask 2: (70 points) - Original Constraints Sample Input: >>> m = 6 >>> queries = [ '1 1 2 10', '1 1 3 15', '1 2 3 20', '2 1 2 3 max', '1 1 2 5', '2 1 2 3 min' ] >>> marathon_queries(m, queries) [15, 5] import sys from collections import defaultdict checkpoints = defaultdict(lambda: defaultdict(lambda: -sys.maxsize)) results = [] for query in queries: parts = query.split() if parts[0] == '1': p = int(parts[1]) c = int(parts[2]) t = int(parts[3]) checkpoints[p][c] = t # overwrite the time at the checkpoint elif parts[0] == '2': p = int(parts[1]) c1 = int(parts[2]) c2 = int(parts[3]) q = parts[4] times = [checkpoints[p][c] for c in range(c1, c2 + 1) if checkpoints[p][c] != -sys.maxsize] if q == 'max': results.append(max(times) if times else -sys.maxsize) elif q == 'min': results.append(min(times) if times else sys.maxsize) return results","solution":"def marathon_queries(m, queries): import sys from collections import defaultdict checkpoints = defaultdict(lambda: defaultdict(lambda: -sys.maxsize)) results = [] for query in queries: parts = query.split() if parts[0] == '1': p = int(parts[1]) c = int(parts[2]) t = int(parts[3]) checkpoints[p][c] = t # overwrite the time at the checkpoint elif parts[0] == '2': p = int(parts[1]) c1 = int(parts[2]) c2 = int(parts[3]) q = parts[4] times = [checkpoints[p][c] for c in range(c1, c2 + 1) if checkpoints[p][c] != -sys.maxsize] if q == 'max': results.append(max(times) if times else -sys.maxsize) elif q == 'min': results.append(min(times) if times else sys.maxsize) return results"},{"question":"def infectedComputers(N, connections, virusStart): There are N computers in a network represented by an N x N adjacency matrix \`connections\` where \`connections[i][j] = 1\` represents a direct connection between computers \`i\` and \`j\`, and \`connections[i][j] = 0\` represents no direct connection. A virus starts from computer \`virusStart\` and spreads to all directly connected computers. Write a function that returns a list of computers infected by the virus, sorted by their indices. >>> N = 4 >>> connections = [ >>> [0, 1, 0, 0], >>> [1, 0, 1, 1], >>> [0, 1, 0, 0], >>> [0, 1, 0, 0] >>> ] >>> virusStart = 1 >>> infectedComputers(N, connections, virusStart) [0, 1, 2, 3] >>> N = 3 >>> connections = [ >>> [0, 1, 0], >>> [1, 0, 0], >>> [0, 0, 0] >>> ] >>> virusStart = 0 >>> infectedComputers(N, connections, virusStart) [0, 1]","solution":"def infectedComputers(N, connections, virusStart): Returns a list of indices of computers infected by the virus. infected = [] visited = [False] * N def dfs(node): visited[node] = True infected.append(node) for neighbor in range(N): if connections[node][neighbor] == 1 and not visited[neighbor]: dfs(neighbor) dfs(virusStart) return sorted(infected)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the result as an integer. Expression can contain single-digit positive integers, '+', '-', '*', and '/' operators. The operators have the standard precedence and no parentheses. >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3/2\\") == 1 >>> evaluate_expression(\\"3+5 / 2\\") == 5 def process_expressions(expressions): Processes a list of expressions and returns the evaluated results as a list of integers. >>> process_expressions([\\"3+2*2\\", \\" 3/2 \\", \\" 3+5 / 2 \\"]) == [7, 1, 5]","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression and returns the result as an integer. Expression can contain single-digit positive integers, '+', '-', '*', and '/' operators. The operators have the standard precedence and no parentheses. # Removing spaces from the expression expression = expression.replace(\\" \\", \\"\\") stack = [] num = 0 operator = '+' for i in range(len(expression)): char = expression[i] if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if operator == '+': stack.append(num) elif operator == '-': stack.append(-num) elif operator == '*': stack[-1] = stack[-1] * num elif operator == '/': stack[-1] = int(stack[-1] / num) operator = char num = 0 return sum(stack) def process_expressions(expressions): Processes a list of expressions and returns the evaluated results as a list of integers. results = [] for expression in expressions: results.append(evaluate_expression(expression)) return results"},{"question":"def max_trade_value(n: int, B: int, items: List[Tuple[int, int]]) -> int: Determine the maximum trade value possible without exceeding the budget. Parameters: n (int): The number of items in Alyssa's collection. B (int): The budget constraint. items (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, the serial number and the trade value of the item. Returns: int: The maximum total trade value possible without exceeding the budget. Example: >>> max_trade_value(5, 10, [(1, 5), (2, 3), (3, 9), (4, 8), (5, 2)]) 10 >>> max_trade_value(4, 7, [(1, 4), (2, 5), (3, 3), (4, 2)]) 7 from typing import List, Tuple def test_max_trade_value_case1(): items = [(1, 5), (2, 3), (3, 9), (4, 8), (5, 2)] assert max_trade_value(5, 10, items) == 10 def test_max_trade_value_case2(): items = [(1, 4), (2, 5), (3, 3), (4, 2)] assert max_trade_value(4, 7, items) == 7 def test_max_trade_value_case3(): items = [(1, 2), (2, 4), (3, 6)] assert max_trade_value(3, 10, items) == 10 def test_max_trade_value_case4(): items = [(1, 8), (2, 10), (3, 12)] assert max_trade_value(3, 5, items) == 0 def test_max_trade_value_case5(): items = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] assert max_trade_value(5, 8, items) == 8","solution":"def max_trade_value(n, B, items): # Implementing a dynamic programming approach to solve the knapsack problem dp = [0] * (B + 1) for i in range(n): s, v = items[i] for b in range(B, v - 1, -1): dp[b] = max(dp[b], dp[b - v] + v) return dp[B]"},{"question":"def find_minimum_total_distance(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimum total distance required to establish the direct lines of communication such that all offices are efficiently connected. Args: n (int): The number of cities. m (int): The number of possible connections between the cities. connections (List[Tuple[int, int, int]]): A list of tuples, each containing three integers u, v, w indicating a possible direct connection between city u and city v with a distance w. Returns: int: The minimum total distance required to establish the communication network. If it is impossible to connect all offices, returns -1. Example: >>> find_minimum_total_distance(4, 5, [(1, 2, 3), (1, 3, 1), (1, 4, 4), (2, 4, 2), (3, 4, 5)]) 6 >>> find_minimum_total_distance(3, 1, [(1, 2, 2)]) -1 import pytest def test_example1(): n = 4 m = 5 connections = [ (1, 2, 3), (1, 3, 1), (1, 4, 4), (2, 4, 2), (3, 4, 5) ] assert find_minimum_total_distance(n, m, connections) == 6 def test_example2(): n = 3 m = 1 connections = [ (1, 2, 2) ] assert find_minimum_total_distance(n, m, connections) == -1 def test_example3(): n = 4 m = 4 connections = [ (1, 2, 1), (2, 3, 4), (3, 4, 2), (4, 1, 3) ] assert find_minimum_total_distance(n, m, connections) == 6 def test_example4(): n = 2 m = 0 connections = [] assert find_minimum_total_distance(n, m, connections) == -1 def test_disconnected_graph(): n = 5 m = 3 connections = [ (1, 2, 2), (1, 3, 3), (4, 5, 4) ] assert find_minimum_total_distance(n, m, connections) == -1 def test_small_cycle(): n = 3 m = 3 connections = [ (1, 2, 1), (2, 3, 2), (1, 3, 3) ] assert find_minimum_total_distance(n, m, connections) == 3","solution":"def kruskal_minimum_spanning_tree(n, connections): parent = list(range(n)) rank = [0] * n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 connections.sort(key=lambda x: x[2]) mst_weight = 0 edges_used = 0 for u, v, w in connections: if find(u - 1) != find(v - 1): union(u - 1, v - 1) mst_weight += w edges_used += 1 if edges_used == n - 1: return mst_weight return -1 # Below function reads input and calls the main function. def find_minimum_total_distance(n, m, connections): return kruskal_minimum_spanning_tree(n, connections)"},{"question":"def longest_unique_substtr(s: str) -> int: Returns the length of the longest substring with all unique characters. Args: s (str): A non-empty string consisting of alphanumeric characters. Returns: int: The length of the longest substring with all unique characters. Examples: >>> longest_unique_substtr(\\"abcabcbb\\") 3 >>> longest_unique_substtr(\\"bbbbb\\") 1 >>> longest_unique_substtr(\\"pwwkew\\") 3","solution":"def longest_unique_substtr(s): Returns the length of the longest substring with all unique characters. Args: s (str): A non-empty string. Returns: int: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_len = 0 start = 0 # Start index of current window for end in range(n): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def is_prime(n: int) -> bool: Evaluates whether a given integer n is a prime number. Parameters: n (int): The integer to be checked. Returns: bool: True if n is a prime number, False otherwise. >>> is_prime(10) == False >>> is_prime(7) == True","solution":"def is_prime(n): Evaluates whether a given integer n is a prime number. Parameters: n (int): The integer to be checked. Returns: bool: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def max_landmarks(N: int, B: int, costs: List[int]) -> int: Returns the maximum number of landmarks that can be renovated with the given budget. >>> max_landmarks(5, 100, [20, 10, 30, 50, 40]) == 4 >>> max_landmarks(4, 50, [20, 30, 40, 50]) == 2","solution":"def max_landmarks(N, B, costs): Returns the maximum number of landmarks that can be renovated with the given budget. # Sort the costs in ascending order costs.sort() # Initialize the count of landmarks and the current total cost count = 0 total_cost = 0 # Iterate over the sorted costs for cost in costs: if total_cost + cost <= B: total_cost += cost count += 1 else: break return count"},{"question":"def min_operations(S: str, T: str) -> int: Returns the minimum number of operations required to transform string S into string T. Allowed operations: insertion, deletion, substitution. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"sunday\\", \\"saturday\\") 3 >>> min_operations(\\"algorithm\\", \\"altruistic\\") 6 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"same\\", \\"same\\") 0 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"abc\\", \\"axc\\") 1 >>> min_operations(\\"abcdef\\", \\"abcxyz\\") 3","solution":"def min_operations(S, T): Returns the minimum number of operations required to transform string S into string T. Allowed operations: insertion, deletion, substitution. m, n = len(S), len(T) # Create a table to store results of subproblems dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp[][] in bottom up manner for i in range(m + 1): for j in range(n + 1): # Base cases if i == 0: dp[i][j] = j # If S is empty, all characters of T need to be inserted elif j == 0: dp[i][j] = i # If T is empty, all characters of S need to be deleted # If last characters are the same, ignore the last char # and recur for the remaining substring elif S[i-1] == T[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are different, consider all possibilities # and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"from typing import List def min_replacements_to_palindrome(s: str) -> int: Returns the minimum number of character replacements required to make the string \`s\` a palindrome. >>> min_replacements_to_palindrome(\\"abba\\") 0 >>> min_replacements_to_palindrome(\\"abbaa\\") 1 >>> min_replacements_to_palindrome(\\"aabbb\\") 2 >>> min_replacements_to_palindrome(\\"abcdef\\") 3 >>> min_replacements_to_palindrome(\\"a\\") 0 >>> min_replacements_to_palindrome(\\"aa\\") 0 >>> min_replacements_to_palindrome(\\"aab\\") 1 >>> min_replacements_to_palindrome(\\"aaab\\") 1 def process_test_cases(test_cases: List[str]) -> List[int]: Processes a list of test cases and returns the results for each. >>> process_test_cases([\\"abba\\", \\"abbaa\\", \\"aabbb\\", \\"a\\", \\"aa\\", \\"abcdef\\"]) [0, 1, 2, 0, 0, 3]","solution":"def min_replacements_to_palindrome(s): Returns the minimum number of character replacements required to make the string \`s\` a palindrome. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count def process_test_cases(test_cases): Processes a list of test cases and returns the results for each. results = [] for s in test_cases: results.append(min_replacements_to_palindrome(s)) return results"},{"question":"from typing import List def is_subsequence(s: str, word: str) -> bool: Check if 'word' is a subsequence of 's'. def longest_subseq_length(s: str, words: List[str]) -> int: Returns the length of the longest string in 'words' that is a subsequence of 's'. def solve(test_cases: List[tuple]) -> List[int]: Solves the problem for multiple test cases. def test_is_subsequence(): assert is_subsequence(\\"abpcplea\\", \\"apple\\") assert not is_subsequence(\\"abpcplea\\", \\"monkey\\") assert is_subsequence(\\"abcd\\", \\"abc\\") assert not is_subsequence(\\"abcd\\", \\"ace\\") def test_longest_subseq_length(): assert longest_subseq_length(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\"]) == 5 assert longest_subseq_length(\\"abcd\\", [\\"ab\\", \\"abc\\"]) == 3 assert longest_subseq_length(\\"xyz\\", [\\"x\\", \\"y\\", \\"z\\", \\"xyz\\"]) == 3 assert longest_subseq_length(\\"aaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) == 4 assert longest_subseq_length(\\"abcdefgh\\", [\\"hgf\\", \\"gf\\", \\"efg\\"]) == 3 def test_solve(): test_cases = [ (\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\"]), (\\"abcd\\", [\\"ab\\", \\"abc\\"]) ] assert solve(test_cases) == [5, 3] test_cases = [ (\\"xyz\\", [\\"x\\", \\"y\\", \\"z\\", \\"xyz\\"]), (\\"aaaa\\", [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"]) ] assert solve(test_cases) == [3, 4] test_cases = [ (\\"abcdefgh\\", [\\"hgf\\", \\"gf\\", \\"efg\\"]), ] assert solve(test_cases) == [3]","solution":"def is_subsequence(s, word): Check if 'word' is a subsequence of 's'. it = iter(s) return all(char in it for char in word) def longest_subseq_length(s, words): Returns the length of the longest string in 'words' that is a subsequence of 's'. max_length = 0 for word in words: if is_subsequence(s, word): max_length = max(max_length, len(word)) return max_length def solve(test_cases): results = [] for s, words in test_cases: results.append(longest_subseq_length(s, words)) return results"},{"question":"def check_occupancy(H: str, queries: list) -> list: For each segment specified in queries, determine if all seats are occupied. Parameters: H (str): String representing occupancy of seats ('O' for occupied, 'E' for empty) queries (list of tuples): List of (L, R) tuples representing segments to check Returns: list: List of results, \\"Full\\" if all seats in the segment are occupied, otherwise \\"Not Full\\" Example: >>> check_occupancy(\\"EOOEEOOOO\\", [(1, 3), (4, 7), (2, 5)]) [\\"Not Full\\", \\"Not Full\\", \\"Not Full\\"] >>> check_occupancy(\\"OOOOOOOOO\\", [(1, 3), (4, 7), (2, 5), (1, 9)]) [\\"Full\\", \\"Full\\", \\"Full\\", \\"Full\\"] >>> check_occupancy(\\"EEEEEEEEE\\", [(1, 3), (4, 7), (2, 5), (1, 9)]) [\\"Not Full\\", \\"Not Full\\", \\"Not Full\\", \\"Not Full\\"]","solution":"def check_occupancy(H, queries): For each segment specified in queries, determine if all seats are occupied. Parameters: H (str): String representing occupancy of seats ('O' for occupied, 'E' for empty) queries (list of tuples): List of (L, R) tuples representing segments to check Returns: list: List of results, \\"Full\\" if all seats in the segment are occupied, otherwise \\"Not Full\\" results = [] for L, R in queries: if 'E' in H[L-1:R]: results.append(\\"Not Full\\") else: results.append(\\"Full\\") return results"},{"question":"def comma_separated_number(n: int) -> str: Returns the string representation of the number with commas as thousands separators. >>> comma_separated_number(1000) \\"1,000\\" >>> comma_separated_number(123456789) \\"123,456,789\\" >>> comma_separated_number(12) \\"12\\"","solution":"def comma_separated_number(n): Returns the string representation of the number with commas as thousands separators. number_str = str(n) length = len(number_str) if length <= 3: return number_str result = [] counter = 0 for i in range(length - 1, -1, -1): result.append(number_str[i]) counter += 1 if counter % 3 == 0 and i != 0: result.append(',') return ''.join(result[::-1])"},{"question":"from typing import List from collections import Counter import heapq def rearrange_string(s: str) -> str: Write a function to determine if it is possible to rearrange the characters of a given non-empty string such that no two adjacent characters are the same. If possible, return one of the possible rearrangements. Otherwise, return an empty string. >>> rearrange_string(\\"aab\\") \\"aba\\" >>> rearrange_string(\\"aaab\\") \\"\\" pass Unit Test: from solution import rearrange_string def test_rearrange_string_can_rearrange(): result = rearrange_string(\\"aab\\") assert result == \\"aba\\" or result == \\"bab\\" def test_rearrange_string_cannot_rearrange(): result = rearrange_string(\\"aaab\\") assert result == \\"\\" def test_rearrange_string_single_character(): result = rearrange_string(\\"a\\") assert result == \\"a\\" def test_rearrange_string_two_different_characters(): result = rearrange_string(\\"ab\\") assert result == \\"ab\\" or result == \\"ba\\" def test_rearrange_string_all_same_characters(): result = rearrange_string(\\"aaaa\\") assert result == \\"\\" def test_rearrange_string_long_input(): input_str = \\"aaabbbccc\\" result = rearrange_string(input_str) assert len(result) == len(input_str) for i in range(len(result) - 1): assert result[i] != result[i + 1]","solution":"from collections import Counter import heapq def rearrange_string(s: str) -> str: if not s: return \\"\\" # Count frequency of each character char_count = Counter(s) # Use a max heap to always try to put the most frequent character next max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char = None prev_freq = 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Add the previous character back if its count is positive if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Append the current character to the result and update its count result.append(char) prev_char = char prev_freq = freq + 1 # Decrement the frequency (remember it's negative in the heap) # If the rearranged string is of a different length, this means it wasn't possible if len(result) != len(s): return \\"\\" return ''.join(result)"},{"question":"from typing import List def min_steps_to_exit(grid: List[str]) -> int: Find the minimum number of steps required to move from the top-left corner to the bottom-right corner of a grid, moving only through walkable cells. >>> min_steps_to_exit([\\".....\\", \\".#.\\", \\"....#\\", \\".#.\\", \\".....\\"]) 8 >>> min_steps_to_exit([\\"....\\", \\"\\", \\"#..#\\", \\"#..#\\"]) -1 >>> min_steps_to_exit([\\"..\\", \\"..\\"]) 2 >>> min_steps_to_exit([\\"...\\", \\".#.\\", \\"...\\"]) 4 >>> min_steps_to_exit([\\".#.\\", \\"#\\", \\"...\\"]) -1 >>> min_steps_to_exit([\\".\\"]) 0","solution":"from collections import deque def min_steps_to_exit(grid): n = len(grid) if grid[0][0] == '#' or grid[n-1][n-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (x, y, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def garden_growth(n: int, m: int, garden: List[str]) -> List[str]: Determine which seeds can grow into plants based on the given conditions and return a new garden grid where the seeds that can grow into plants are marked by 'G' and the rest of the cells remain the same. >>> garden_growth(5, 5, [\\".....\\", \\"..P..\\", \\".#.\\", \\"..P..\\", \\".....\\"]) ['.....', '..G..', '.#.', '..G..', '.....'] >>> garden_growth(4, 6, [\\"....P.\\", \\"....\\", \\"P..P..\\", \\"#.P.#.\\"]) ['....G.', '....', 'G..G..', '#.G.#.']","solution":"def garden_growth(n, m, garden): Determine which seeds can grow into plants based on the given conditions and returns a new garden grid where 'P' can grow into 'G'. Parameters: n (int): Number of rows in the grid m (int): Number of columns in the grid garden (list of str): The initial garden grid Returns: list of str: The modified garden grid def can_seed_grow(i, j): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and garden[ni][nj] == '.': return True return False new_garden = [] for i in range(n): new_row = [] for j in range(m): if garden[i][j] == 'P' and can_seed_grow(i, j): new_row.append('G') else: new_row.append(garden[i][j]) new_garden.append(''.join(new_row)) return new_garden"},{"question":"def cyclist_position(T, test_cases): Calculate the position of the cyclist on the track after cycling N meters. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers, N (distance cycled) and C (circumference of the track). Returns: List[int]: A list containing the positions of the cyclist on the track for each test case. >>> cyclist_position(3, [(100, 50), (75, 40), (200, 77)]) [0, 35, 46] >>> cyclist_position(2, [(42, 7), (99, 100)]) [0, 99]","solution":"def cyclist_position(T, test_cases): results = [] for N, C in test_cases: position = N % C results.append(position) return results"},{"question":"def sort_containers(n, weights): Sorts the containers by arranging the even weights in ascending order and the odd weights in descending order, placing evens before odds. Args: n (int): Number of containers. weights (list): List of container weights. Returns: list: Sorted list of weights based on the described criteria. Examples: >>> sort_containers(5, [4, 3, 1, 2, 6]) [2, 4, 6, 3, 1] >>> sort_containers(3, [9, 7, 5]) [9, 7, 5] >>> sort_containers(6, [5, 3, 8, 7, 2, 6]) [2, 6, 8, 7, 5, 3]","solution":"def sort_containers(n, weights): Sorts the containers by arranging the even weights in ascending order and the odd weights in descending order, placing evens before odds. Args: n (int): Number of containers. weights (list): List of container weights. Returns: list: Sorted list of weights based on the described criteria. evens = sorted([w for w in weights if w % 2 == 0]) odds = sorted([w for w in weights if w % 2 != 0], reverse=True) return evens + odds"},{"question":"def is_valid_parentheses(s): Determine if the input string of parentheses is valid. :param s: Input string consisting of characters '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the string is valid, otherwise \\"NO\\" >>> is_valid_parentheses(\\"{[()]}\\") \\"YES\\" >>> is_valid_parentheses(\\"{[(])}\\") \\"NO\\" >>> is_valid_parentheses(\\"{{[[(())]]}}\\") \\"YES\\"","solution":"def is_valid_parentheses(s): Determine if the input string of parentheses is valid. :param s: Input string consisting of characters '(', ')', '{', '}', '[' and ']' :return: \\"YES\\" if the string is valid, otherwise \\"NO\\" stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if not stack or stack[-1] != matching_parentheses[char]: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"from typing import List def solve_max_number(n: int, integers: List[int]) -> str: Construct the maximum possible number from a list of integers by concatenating them. >>> solve_max_number(3, [50, 2, 1]) \\"5021\\" >>> solve_max_number(4, [9, 34, 5, 3]) \\"95343\\" from solution import solve_max_number def test_example_1(): assert solve_max_number(3, [50, 2, 1]) == \\"5021\\" def test_example_2(): assert solve_max_number(4, [9, 34, 5, 3]) == \\"95343\\" def test_single_number(): assert solve_max_number(1, [5]) == \\"5\\" def test_same_numbers(): assert solve_max_number(3, [11, 11, 11]) == \\"111111\\" def test_large_numbers(): assert solve_max_number(3, [999999999, 999999999, 999999999]) == \\"999999999999999999999999999\\" def test_mixed_numbers(): assert solve_max_number(5, [3, 30, 34, 5, 9]) == \\"9534330\\" def test_two_numbers(): assert solve_max_number(2, [10, 2]) == \\"210\\" def test_empty(): assert solve_max_number(0, []) == \\"\\" def test_large_list(): assert solve_max_number(10, [i for i in range(1, 11)]) == \\"98765432110\\"","solution":"from functools import cmp_to_key def compare(n1, n2): if n1 + n2 > n2 + n1: return -1 else: return 1 def max_number(numbers): numbers = list(map(str, numbers)) numbers.sort(key=cmp_to_key(compare)) return ''.join(numbers) def solve_max_number(n, integers): return max_number(integers)"},{"question":"def count_unique_projects(n: int, employee_project_list: List[str]) -> int: Returns the total number of unique projects being worked on by the employees. Parameters: n (int): Number of employees. employee_project_list (list of str): List of strings where each string contains the employee's name followed by the list of projects they are working on. Returns: int: Total number of unique projects. >>> count_unique_projects(4, [\\"Alice project1 project2\\", \\"Bob project2 project3\\", \\"Charlie project3 project4\\", \\"David project1 project5\\"]) 5 >>> count_unique_projects(3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) 0 >>> count_unique_projects(3, [\\"Alice project1 project2\\", \\"Bob project1 project2\\", \\"Charlie project1 project2\\"]) 2 >>> count_unique_projects(1, [\\"Alice project1 project2 project3 project4 project5\\"]) 5 >>> count_unique_projects(5, [\\"Alice project1 project2\\", \\"Bob project2 project3\\", \\"Charlie project4\\", \\"David project5\\", \\"Eve project6 project7\\"]) 7 pass","solution":"def count_unique_projects(n, employee_project_list): Returns the total number of unique projects being worked on by the employees. Parameters: n (int): Number of employees. employee_project_list (list of str): List of strings where each string contains the employee's name followed by the list of projects they are working on. Returns: int: Total number of unique projects. unique_projects = set() for employee_projects in employee_project_list: projects = employee_projects.split()[1:] # Extract the projects, ignoring the employee name unique_projects.update(projects) return len(unique_projects)"},{"question":"def count_upright_planks(n: int, a: List[int]) -> int: Returns the number of upright planks in the line. Parameters: n (int): number of planks a (list of int): list of plank states (1 for upright, 0 for flat) Returns: int: the number of upright planks >>> count_upright_planks(5, [1, 1, 0, 1, 1]) 2 >>> count_upright_planks(4, [1, 1, 1, 1]) 4 >>> count_upright_planks(4, [0, 0, 0, 0]) 0 >>> count_upright_planks(6, [1, 1, 1, 0, 0, 1]) 3 >>> count_upright_planks(5, [0, 1, 1, 1, 1]) 0 >>> count_upright_planks(5, [1, 1, 1, 1, 0]) 4 >>> count_upright_planks(1, [1]) 1 >>> count_upright_planks(1, [0]) 0","solution":"def count_upright_planks(n, a): Returns the number of upright planks in the line. Parameters: n (int): number of planks a (list of int): list of plank states (1 for upright, 0 for flat) Returns: int: the number of upright planks count = 0 for i in range(n): if a[i] == 1: count += 1 else: break return count"},{"question":"def count_team_wins(n: int, matches: List[Tuple[str, str]]) -> Dict[str, int]: Counts the number of wins for each team. Args: n (int): Number of matches played. matches (list of tuples): Each tuple contains two strings (winner, loser). Returns: dict: A dictionary with team names as keys and win counts as values. from collections import defaultdict def display_team_wins(win_count: Dict[str, int]) -> None: Displays the team win counts. Args: win_count (dict): A dictionary with team names as keys and win counts as values. import sys from collections import defaultdict from typing import List, Tuple, Dict def main(): input = sys.stdin.read data = input().splitlines() n = int(data[0]) matches = [tuple(line.split()) for line in data[1:n + 1]] win_count = count_team_wins(n, matches) display_team_wins(win_count) if __name__ == \\"__main__\\": main()","solution":"def count_team_wins(n, matches): Counts the number of wins for each team. Args: n (int): Number of matches played. matches (list of tuples): Each tuple contains two strings (winner, loser). Returns: dict: A dictionary with team names as keys and win counts as values. from collections import defaultdict win_count = defaultdict(int) for winner, loser in matches: win_count[winner] += 1 if loser not in win_count: win_count[loser] = 0 sorted_win_count = dict(sorted(win_count.items())) return sorted_win_count def display_team_wins(win_count): Displays the team win counts. Args: win_count (dict): A dictionary with team names as keys and win counts as values. for team, wins in win_count.items(): print(f\\"{team} {wins}\\")"},{"question":"def longest_common_substring_length(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. >>> longest_common_substring_length(\\"abcdxyz\\", \\"xyzabcd\\") 4 >>> longest_common_substring_length(\\"abcde\\", \\"fghij\\") 0 def find_longest_common_substrings(test_cases: List[Tuple[str, str]]) -> List[int]: For each pair of strings in the test cases, returns the length of the longest common substring. >>> find_longest_common_substrings([(\\"abcdxyz\\", \\"xyzabcd\\"), (\\"abcde\\", \\"fghij\\")]) [4, 0] >>> find_longest_common_substrings([(\\"abcdef\\", \\"defghi\\"), (\\"12345\\", \\"23456\\")]) [3, 4]","solution":"def longest_common_substring_length(s1, s2): Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Create a table to store lengths of longest common suffixes of substrings dp = [[0] * (n + 1) for _ in range(m + 1)] longest = 0 for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 longest = max(longest, dp[i][j]) else: dp[i][j] = 0 return longest def find_longest_common_substrings(test_cases): For each pair of strings in the test cases, prints the length of the longest common substring. results = [] for s1, s2 in test_cases: results.append(longest_common_substring_length(s1, s2)) return results"},{"question":"def max_activities(n: int, benefits: List[int]) -> int: Given a list of benefits of activities, return the maximum number of activities that can be selected such that the benefit values are in strictly increasing order. >>> max_activities(7, [4, 5, 2, 4, 3, 3, 6]) 5 >>> max_activities(5, [1, 1, 2, 2, 3]) 3 >>> max_activities(6, [6, 4, 4, 4, 5, 6]) 3 from solution import max_activities def test_example_1(): n = 7 benefits = [4, 5, 2, 4, 3, 3, 6] assert max_activities(n, benefits) == 5 def test_example_2(): n = 5 benefits = [1, 1, 2, 2, 3] assert max_activities(n, benefits) == 3 def test_example_3(): n = 6 benefits = [6, 4, 4, 4, 5, 6] assert max_activities(n, benefits) == 3 def test_all_same(): n = 4 benefits = [3, 3, 3, 3] assert max_activities(n, benefits) == 1 def test_strict_increasing(): n = 5 benefits = [1, 2, 3, 4, 5] assert max_activities(n, benefits) == 5 def test_reverse(): n = 5 benefits = [5, 4, 3, 2, 1] assert max_activities(n, benefits) == 5 def test_random_order(): n = 7 benefits = [10, 1, 5, 5, 7, 7, 2] assert max_activities(n, benefits) == 5","solution":"def max_activities(n, benefits): Given a list of benefits of activities, return the maximum number of activities that can be selected such that the benefit values are in strictly increasing order. benefits = sorted(set(benefits)) # Remove duplicates and sort the list return len(benefits)"},{"question":"from typing import List def unique_paths_with_obstacles(grid: List[List[int]]) -> int: Alice is intrigued by unique paths in a grid. She wants to find the number of distinct paths from the top-left corner to the bottom-right corner of an \`m x n\` grid. However, she has discovered some obstacles on certain cells which she needs to avoid while traversing. You are given a 2D array \`grid\` where \`grid[i][j]\` is: - \`0\` if the cell at position \`(i, j)\` is empty, and - \`1\` if the cell at position \`(i, j)\` contains an obstacle. Alice can only move either right or down at any step. Help Alice determine the number of unique paths from the top-left corner to the bottom-right corner of the grid. :param grid: List[List[int]] - 2D list representing the grid. :return: int - number of unique paths from the top-left corner to the bottom-right corner of the grid. Examples: >>> unique_paths_with_obstacles([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> unique_paths_with_obstacles([[0, 1], [0, 0]]) 1 def test_unique_paths_with_obstacles_no_obstacle(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0], ] assert unique_paths_with_obstacles(grid) == 6 def test_unique_paths_with_obstacles_with_obstacle(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0], ] assert unique_paths_with_obstacles(grid) == 2 def test_unique_paths_with_obstacles_no_path(): grid = [ [0, 1], [1, 0], ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_obstacles_one_row(): grid = [ [0, 0, 0, 1, 0], ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_obstacles_one_column(): grid = [ [0], [0], [1], [0], ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_obstacles_start_obstacle(): grid = [ [1, 0], [0, 0], ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_obstacles_end_obstacle(): grid = [ [0, 0], [0, 1], ] assert unique_paths_with_obstacles(grid) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right corner of the grid. Account for obstacles in the grid. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Starting point dp[0][0] = 1 # Fill the first column for i in range(1, m): dp[i][0] = 0 if grid[i][0] == 1 else dp[i-1][0] # Fill the first row for j in range(1, n): dp[0][j] = 0 if grid[0][j] == 1 else dp[0][j-1] # Fill the rest of dp table for i in range(1, m): for j in range(1, n): if grid[i][j] == 1: dp[i][j] = 0 else: dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def segregate_letters_digits(s: str) -> str: Segregates letters and digits in the string such that letters come first followed by digits, while maintaining their relative order. Parameters: s (str): The input string containing a mixture of letters and digits. Returns: str: The output string with letters followed by digits. >>> segregate_letters_digits('a1b2c3') 'abc123' >>> segregate_letters_digits('abcdef') 'abcdef' >>> segregate_letters_digits('123456') '123456' >>> segregate_letters_digits('') '' >>> segregate_letters_digits('a1!b2@c3#') 'abc123' >>> segregate_letters_digits('A1b2C3') 'AbC123' >>> segregate_letters_digits('a 1 b 2 c 3') 'abc123'","solution":"def segregate_letters_digits(s): Segregates letters and digits in the string such that letters come first followed by digits, while maintaining their relative order. Parameters: s (str): The input string containing a mixture of letters and digits. Returns: str: The output string with letters followed by digits. letters = ''.join([char for char in s if char.isalpha()]) digits = ''.join([char for char in s if char.isdigit()]) return letters + digits"},{"question":"def isPalindrome(num: int) -> bool: Check if the given number is a palindrome. Parameters: num (int): The number to check Returns: bool: True if the number is a palindrome, False otherwise Examples: >>> isPalindrome(121) True >>> isPalindrome(123) False","solution":"def isPalindrome(num): Returns True if the given number is a palindrome, else returns False. num_str = str(num) return num_str == num_str[::-1]"},{"question":"from typing import List, Tuple def rearrangeString(S: str) -> str: Determine whether it is possible to rearrange the characters in the string such that no two adjacent characters are the same. If it is possible, return one of the possible strings. Otherwise, return \\"Not possible\\". >>> rearrangeString(\\"aaabbc\\") 'ababac' >>> rearrangeString(\\"aaab\\") 'Not possible' >>> rearrangeString(\\"aabb\\") 'abab' >>> rearrangeString(\\"\\") '' >>> rearrangeString(\\"a\\") 'a' >>> rearrangeString(\\"aa\\") 'Not possible' >>> rearrangeString(\\"a\\" * 50000 + \\"b\\" * 50000) 'abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab\\"","solution":"from collections import Counter from heapq import heappop, heappush def rearrangeString(S): char_count = Counter(S) max_heap = [] for char, freq in char_count.items(): heappush(max_heap, (-freq, char)) prev_freq, prev_char = 0, '' result = [] while max_heap: freq, char = heappop(max_heap) result.append(char) if prev_freq < 0: heappush(max_heap, (prev_freq, prev_char)) prev_freq, prev_char = freq + 1, char rearranged_string = ''.join(result) if len(rearranged_string) == len(S): return rearranged_string else: return \\"Not possible\\""},{"question":"def min_palindromic_substrings(s: str) -> int: Determine the minimum number of palindromic substrings needed to break down the given string. Arguments: s -- input string consisting of lowercase English letters Returns: int -- minimum number of palindromic substrings >>> min_palindromic_substrings(\\"abacc\\") 2 >>> min_palindromic_substrings(\\"aab\\") 2 >>> min_palindromic_substrings(\\"x\\") 1 >>> min_palindromic_substrings(\\"aaaa\\") 1 >>> min_palindromic_substrings(\\"abcd\\") 4 >>> min_palindromic_substrings(\\"abba\\") 1 >>> min_palindromic_substrings(\\"racecar\\") 1 >>> min_palindromic_substrings(\\"abccba\\") 1","solution":"def min_palindromic_substrings(s): n = len(s) # Memoization table to store the minimum cuts needed for substring s[i:j+1] dp = [[0] * n for _ in range(n)] # Table to store whether s[i:j+1] is palindrome palindrome = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): palindrome[i][i] = True for length in range(2, n + 1): # substring lengths from 2 to n for i in range(n - length + 1): j = i + length - 1 if length == 2: palindrome[i][j] = (s[i] == s[j]) else: palindrome[i][j] = (s[i] == s[j] and palindrome[i + 1][j - 1]) for i in range(n): if palindrome[0][i]: dp[0][i] = 1 else: dp[0][i] = float('inf') for j in range(i): if palindrome[j + 1][i] and dp[0][j] + 1 < dp[0][i]: dp[0][i] = dp[0][j] + 1 return dp[0][n - 1]"},{"question":"from typing import List def array_intersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of two arrays without duplicates. >>> array_intersection([1, 2, 2, 1], [2, 2]) [2] >>> array_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9]","solution":"def array_intersection(arr1, arr2): Returns the intersection of two arrays without duplicates. # Using set intersection to find common elements and remove duplicates return list(set(arr1) & set(arr2))"},{"question":"def update_scoreboard(p: int, q: int, difficulties: List[int], submissions: List[Tuple[int, int, int, str]]) -> List[Tuple[int, int, int]]: Update and display the scoreboard after each submission. :param p: The number of participants. :param q: The number of problems. :param difficulties: List of points for each problem. :param submissions: List of tuples representing submissions as (participant_id, problem_id, submission_time, status). :return: The leaderboard as a list of tuples (participant_id, total_score, earliest_submission_time_that_contributed_to_score). Sample input: >>> p = 3 >>> q = 3 >>> difficulties = [500, 300, 200] >>> submissions = [ >>> (1, 1, 30, 'correct'), >>> (2, 2, 45, 'correct'), >>> (3, 3, 50, 'correct'), >>> (1, 1, 60, 'incorrect'), >>> (2, 2, 70, 'incorrect'), >>> (3, 3, 75, 'correct') >>> ] >>> update_scoreboard(p, q, difficulties, submissions) [(1, 500, 30), (2, 300, 45), (3, 200, 50)]","solution":"def update_scoreboard(p, q, difficulties, submissions): # Initialize participants info participants = {i: {'total_score': 0, 'penalties': 0, 'first_correct_submission': None, 'submissions': []} for i in range(1, p + 1)} for submission in submissions: participant_id, problem_id, submission_time, status = submission # If the problem is solved correctly for the first time by the participant if status == 'correct' and not any(sub for sub in participants[participant_id]['submissions'] if sub['problem_id'] == problem_id and sub['status'] == 'correct'): participants[participant_id]['total_score'] += difficulties[problem_id - 1] participants[participant_id]['penalties'] += submission_time if not participants[participant_id]['first_correct_submission'] or submission_time < participants[participant_id]['first_correct_submission']: participants[participant_id]['first_correct_submission'] = submission_time # If the problem is solved incorrectly, add penalty elif status == 'incorrect': # Assuming each incorrect submission adds a fixed penalty for simplicity participants[participant_id]['penalties'] += 20 participants[participant_id]['submissions'].append({ 'problem_id': problem_id, 'submission_time': submission_time, 'status': status }) # Sorting logic sorted_participants = sorted(participants.items(), key=lambda item: ( item[1]['total_score'], -item[1]['first_correct_submission'] if item[1]['first_correct_submission'] else float('inf'), -item[0] ), reverse=True) # Prepare results result = [] for participant_id, info in sorted_participants: score = info['total_score'] penalties = info['penalties'] first_solver_time = info['first_correct_submission'] if info['first_correct_submission'] else 0 result.append((participant_id, score, first_solver_time)) return result"},{"question":"def longest_contiguous_subarray_length(nums): Returns the length of the longest subarray with contiguous elements. >>> longest_contiguous_subarray_length([10, 12, 11]) -> 3 >>> longest_contiguous_subarray_length([14, 12, 11, 20]) -> 2","solution":"def longest_contiguous_subarray_length(nums): Returns the length of the longest subarray with contiguous elements. if not nums: return 0 nums.sort() max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1] + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def max_items(n: int, prices: str, budget: int) -> int: Maria loves purchasing items. She always tries to maximize the number of items she can buy with her given budget. She knows the prices of all available items in a store. Parameters: n (int): number of available items prices (str): space-separated string of integers representing the prices of the items budget (int): Maria's budget Returns: int: the maximum number of items that can be bought without exceeding the budget Examples: >>> max_items(5, \\"1 12 5 111 200\\", 10) 2 >>> max_items(10, \\"20 10 5 30 30 40 50 60 70 80\\", 100) 5 >>> max_items(3, \\"100 200 300\\", 50) 0","solution":"def max_items(n, prices, budget): Returns the maximum number of items that can be bought without exceeding the given budget. Parameters: n (int): number of available items prices (str): space-separated string of integers representing the prices of the items budget (int): Maria's budget Returns: int: the maximum number of items that can be bought prices = list(map(int, prices.split())) prices.sort() count = 0 total_cost = 0 for price in prices: if total_cost + price <= budget: total_cost += price count += 1 else: break return count"},{"question":"def maxProfit(prices: List[int], K: int) -> int: Compute the maximum profit achievable with at most K transactions. Args: prices (List[int]): List of integers representing stock prices over several days. K (int): Maximum number of transactions allowed. Returns: int: Maximum profit achievable. >>> maxProfit([3,2,6,5,0,3,2], 2) 7 >>> maxProfit([4, 3, 2, 1, 0], 2) 0 def parse_input(input_str: str) -> Tuple[List[int], int]: Parse the input string into appropriate variables. Args: input_str (str): Input string with number of days, stock prices, and number of transactions. Returns: Tuple[List[int], int]: A tuple containing the list of stock prices and the number of transactions. >>> parse_input(\\"7n3 2 6 5 0 3 2n2\\") ([3, 2, 6, 5, 0, 3, 2], 2) >>> parse_input(\\"5n4 3 2 1 0n2\\") ([4, 3, 2, 1, 0], 2) import pytest def test_sample_input(): input_str = \\"7n3 2 6 5 0 3 2n2\\" prices, K = parse_input(input_str) assert maxProfit(prices, K) == 7 def test_no_transactions(): input_str = \\"7n3 2 6 5 0 3 2n0\\" prices, K = parse_input(input_str) assert maxProfit(prices, K) == 0 def test_no_profit(): input_str = \\"5n4 3 2 1 0n2\\" prices, K = parse_input(input_str) assert maxProfit(prices, K) == 0 def test_high_transaction_count(): input_str = \\"7n3 2 6 5 0 3 2n100\\" prices, K = parse_input(input_str) assert maxProfit(prices, K) == 7 def test_small_input(): input_str = \\"2n1 2n1\\" prices, K = parse_input(input_str) assert maxProfit(prices, K) == 1 def test_large_input(): prices = [i for i in range(1000, 0, -1)] K = 500 assert maxProfit(prices, K) == 0","solution":"def maxProfit(prices, K): N = len(prices) if not prices or K == 0: return 0 if K >= N // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(N - 1)) dp = [[0]*N for _ in range(K + 1)] for k in range(1, K + 1): max_diff = -prices[0] for i in range(1, N): dp[k][i] = max(dp[k][i - 1], prices[i] + max_diff) max_diff = max(max_diff, dp[k - 1][i] - prices[i]) return dp[K][N-1] # Input parsing function def parse_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) prices = list(map(int, lines[1].split())) K = int(lines[2]) return prices, K"},{"question":"from typing import List def generate_thrilling_sequence(N: int) -> List[int]: Given an integer N, generate a thrilling sequence of length N. A sequence is called thrilling if the sum of all absolute differences of adjacent pairs of elements is equal to N - 1. If no thrilling sequence exists, return -1. Args: N (int): Length of the sequence Returns: List[int]: A thrilling sequence or -1 if not possible >>> generate_thrilling_sequence(3) [1, 2, 3] >>> generate_thrilling_sequence(5) [1, 2, 3, 4, 5] >>> generate_thrilling_sequence(1) -1 pass def solve(T: int, cases: List[int]) -> List[str]: Given the number of test cases T and a list of integers, output a thrilling sequence for each integer. Args: T (int): Number of test cases cases (List[int]): List of integers for each test case Returns: List[str]: A list of thrilling sequences as space-separated strings, or '-1' >>> solve(2, [3, 5]) ['1 2 3', '1 2 3 4 5'] >>> solve(1, [1]) ['-1'] >>> solve(3, [2, 4, 6]) ['1 2', '1 2 3 4', '1 2 3 4 5 6'] pass","solution":"def generate_thrilling_sequence(N): if N == 1: return -1 return list(range(1, N+1)) def solve(T, cases): results = [] for N in cases: result = generate_thrilling_sequence(N) if result == -1: results.append('-1') else: results.append(' '.join(map(str, result))) return results"},{"question":"from typing import List, Tuple, Union def find_shortest_cycle(n: int, m: int, edges: List[Tuple[int, int]]) -> Union[int, str]: Determine if the graph contains any cycle, and if so, find the length of the shortest cycle. Args: n : int : The number of vertices in the graph. m : int : The number of edges in the graph. edges : List[Tuple[int, int]] : A list of tuples representing the edges of the graph. Returns: Union[int, str] : The length of the shortest cycle if a cycle exists, otherwise \\"NO\\". Examples: >>> find_shortest_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 3 >>> find_shortest_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\" >>> find_shortest_cycle(3, 3, [(1, 1), (2, 2), (3, 3)]) 1 from solution import find_shortest_cycle def test_example_1(): assert find_shortest_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == 3 def test_example_2(): assert find_shortest_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) == \\"NO\\" def test_example_3(): assert find_shortest_cycle(3, 3, [(1, 1), (2, 2), (3, 3)]) == 1 def test_no_edges(): assert find_shortest_cycle(4, 0, []) == \\"NO\\" def test_single_self_loop(): assert find_shortest_cycle(2, 1, [(1, 1)]) == 1 def test_multiple_cycles(): assert find_shortest_cycle(6, 7, [(1, 2), (2, 3), (3, 4), (4, 2), (4, 5), (5, 6), (6, 1)]) == 3 def test_disconnected_graph(): assert find_shortest_cycle(7, 5, [(1, 2), (1, 3), (4, 5), (5, 6), (6, 4)]) == 3","solution":"def find_shortest_cycle(n, m, edges): from collections import deque, defaultdict # Create a graph adjacency list graph = defaultdict(list) for (u, v) in edges: graph[u].append(v) graph[v].append(u) def bfs(start): # This keeps track of the shortest cycle found during this BFS shortest_cycle_length = float('inf') visited = [-1] * (n + 1) queue = deque([(start, -1, 0)]) # node, parent, distance while queue: current, parent, distance = queue.popleft() if visited[current] != -1: continue visited[current] = distance for neighbor in graph[current]: if visited[neighbor] == -1: # not visited queue.append((neighbor, current, distance + 1)) elif neighbor != parent: # a valid cycle detected shortest_cycle_length = min(shortest_cycle_length, distance + visited[neighbor] + 1) return shortest_cycle_length shortest_cycle = float('inf') for node in range(1, n + 1): if graph[node]: # only perform BFS if the node has neighbors shortest_cycle = min(shortest_cycle, bfs(node)) if shortest_cycle == float('inf'): return \\"NO\\" else: return shortest_cycle"},{"question":"import numpy as np def reshape_and_flatten(n, m, elements): Reshapes a list of elements into an n x m array and then flattens it to a 1-dimensional array. Parameters: n (int): number of rows. m (int): number of columns. elements (list of int): the elements of the array. Returns: numpy.ndarray: the flattened array. >>> reshape_and_flatten(2, 3, [1, 2, 3, 4, 5, 6]) array([1, 2, 3, 4, 5, 6]) >>> reshape_and_flatten(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]) array([1, 2, 3, 4, 5, 6, 7, 8, 9])","solution":"import numpy as np def reshape_and_flatten(n, m, elements): Reshapes a list of elements into an n x m array and then flattens it to a 1-dimensional array. Parameters: n (int): number of rows. m (int): number of columns. elements (list of int): the elements of the array. Returns: numpy.ndarray: the flattened array. array = np.array(elements) reshaped_array = np.reshape(array, (n, m)) flattened_array = reshaped_array.flatten() return flattened_array"},{"question":"def max_books_per_member(n: int, k: int, pages: List[int]) -> int: Returns the maximum number of books any single member receives after fair distribution. >>> max_books_per_member(7, 3, [2, 3, 4, 5, 6, 7, 8]) 3 >>> max_books_per_member(5, 2, [10, 20, 30, 40, 50]) 3 >>> max_books_per_member(1, 1, [5]) 1 >>> max_books_per_member(4, 4, [1, 2, 3, 4]) 1 >>> max_books_per_member(9, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 3 >>> max_books_per_member(5, 10, [2, 4, 6, 8, 10]) 1","solution":"def max_books_per_member(n, k, pages): Returns the maximum number of books any single member receives after fair distribution. Parameters: n (int): The total number of books. k (int): The total number of members. pages (list of int): The number of pages in each book. Returns: int: The maximum number of books any single member receives. # Each member gets either floor(n/k) or ceiling(n/k) books return (n + k - 1) // k"},{"question":"def circle_rectangle_overlap(xc, yc, r, xbl, ybl, xtr, ytr): Determines whether a circle and a rectangle overlap or not. Parameters: xc (int): x-coordinate of the circle's center. yc (int): y-coordinate of the circle's center. r (int): radius of the circle. xbl (int): x-coordinate of the rectangle's bottom-left corner. ybl (int): y-coordinate of the rectangle's bottom-left corner. xtr (int): x-coordinate of the rectangle's top-right corner. ytr (int): y-coordinate of the rectangle's top-right corner. Returns: str: \\"Overlap\\" if the circle and rectangle overlap, otherwise \\"No Overlap\\". pass def test_circle_rectangle_overlap(): assert circle_rectangle_overlap(0, 0, 5, -1, -1, 2, 2) == \\"Overlap\\" assert circle_rectangle_overlap(0, 0, 1, 2, 2, 4, 4) == \\"No Overlap\\" assert circle_rectangle_overlap(3, 3, 1, 1, 1, 5, 5) == \\"Overlap\\" assert circle_rectangle_overlap(0, 0, 10, -5, -5, 5, 5) == \\"Overlap\\" assert circle_rectangle_overlap(0, 0, 1, -1, -1, 1, 1) == \\"Overlap\\" assert circle_rectangle_overlap(0, 0, 1, 1, 1, 2, 2) == \\"No Overlap\\" assert circle_rectangle_overlap(0, 0, 10000, -10000, -10000, 10000, 10000) == \\"Overlap\\" assert circle_rectangle_overlap(0, 0, 2, -3, -1, -1, 1) == \\"Overlap\\" test_circle_rectangle_overlap()","solution":"def circle_rectangle_overlap(xc, yc, r, xbl, ybl, xtr, ytr): Determines whether a circle and a rectangle overlap or not. Parameters: xc (int): x-coordinate of the circle's center. yc (int): y-coordinate of the circle's center. r (int): radius of the circle. xbl (int): x-coordinate of the rectangle's bottom-left corner. ybl (int): y-coordinate of the rectangle's bottom-left corner. xtr (int): x-coordinate of the rectangle's top-right corner. ytr (int): y-coordinate of the rectangle's top-right corner. Returns: str: \\"Overlap\\" if the circle and rectangle overlap, otherwise \\"No Overlap\\". # Find the closest point on the rectangle to the center of the circle closest_x = max(xbl, min(xc, xtr)) closest_y = max(ybl, min(yc, ytr)) # Calculate the distance from the center of the circle to this point distance_x = xc - closest_x distance_y = yc - closest_y # If the distance is less than the radius, it overlaps if (distance_x ** 2 + distance_y ** 2) <= (r ** 2): return \\"Overlap\\" else: return \\"No Overlap\\""},{"question":"def generate_grid(M: int, N: int) -> List[List[int]]: Generate an MxN grid where the sum of the numbers in every row and every column remain the same, and the numbers are in strictly increasing order from left to right and top to bottom. Args: M (int): number of rows N (int): number of columns Returns: List[List[int]]: a 2D list representing the grid Examples: >>> generate_grid(2, 2) [[1, 2], [3, 4]] >>> generate_grid(3, 4) [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] >>> generate_grid(1, 1) [[1]] >>> generate_grid(4, 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] >>> generate_grid(3, 3) [[1, 2, 3], [4, 5, 6], [7, 8, 9]]","solution":"def generate_grid(M, N): Generate an MxN grid where the sum of the numbers in every row and every column remain the same, and the numbers are in strictly increasing order from left to right and top to bottom. grid = [] current = 1 for i in range(M): row = [] for j in range(N): row.append(current) current += 1 grid.append(row) return grid"},{"question":"def longest_palindromic_substring(s: str, queries: List[Tuple[int, int]]) -> List[int]: Returns the length of the longest palindromic substring within the specified ranges. >>> longest_palindromic_substring(\\"abaxyzbamadam\\", [(1, 5), (6, 10), (1, 13)]) [3, 3, 5] >>> longest_palindromic_substring(\\"a\\", [(1, 1)]) [1] >>> longest_palindromic_substring(\\"aaaaa\\", [(1, 5), (2, 4), (3, 3)]) [5, 3, 1] >>> longest_palindromic_substring(\\"abcdefg\\", [(1, 7), (2, 5)]) [1, 1] >>> longest_palindromic_substring(\\"aabbbaa\\", [(1, 7), (2, 6), (3, 5)]) [7, 5, 3]","solution":"def longest_palindromic_substring(s, queries): Returns the length of the longest palindromic substring within the specified ranges. def longest_palindrome_length(substring): n = len(substring) if n == 0: return 0 # Table to store the palindrome status dp = [[False] * n for _ in range(n)] max_length = 1 # Single letter palindromes for i in range(n): dp[i][i] = True # Two consecutive letters palindromes for i in range(n - 1): if substring[i] == substring[i + 1]: dp[i][i + 1] = True max_length = 2 # Substrings longer than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if substring[i] == substring[j] and dp[i + 1][j - 1]: dp[i][j] = True max_length = length return max_length results = [] for li, ri in queries: sub_str = s[li-1:ri] results.append(longest_palindrome_length(sub_str)) return results"},{"question":"def min_operations_to_sort(sequence: List[int]) -> int: Determine the minimum number of operations to transform a given sequence into a non-decreasing sequence. The operations consist of selecting a subarray and reversing it. Args: - sequence (List[int]): The list of integers representing the sequence. Returns: - int: The minimum number of operations required. >>> min_operations_to_sort([2, 4, 1, 3, 5]) 1 >>> min_operations_to_sort([3, 1, 2, 4]) 2 pass def sort_sequences(test_cases: List[List[int]]) -> List[int]: Process multiple test cases to determine the minimum number of operations for each case. Args: - test_cases (List[List[int]]): A list of test cases, where each test case is a list of integers representing the sequence. Returns: - List[int]: A list of minimum operations required for each test case. >>> sort_sequences([[2, 4, 1, 3, 5], [3, 1, 2, 4], [1, 5, 4, 3, 2]]) [1, 2, 3] >>> sort_sequences([[1, 2, 3], [10, 20, 30, 40], [1, 1, 1, 1]]) [0, 0, 0] pass import pytest def test_min_operations_to_sort_already_sorted(): assert min_operations_to_sort([1, 2, 3, 4, 5]) == 0 def test_min_operations_to_sort_one_operation_needed(): assert min_operations_to_sort([2, 4, 1, 3, 5]) == 1 def test_min_operations_to_sort_two_operations_needed(): assert min_operations_to_sort([3, 1, 2, 4]) == 2 def test_sort_sequences_multiple_cases(): test_cases = [ [2, 4, 1, 3, 5], [3, 1, 2, 4], [1, 5, 4, 3, 2] ] assert sort_sequences(test_cases) == [1, 2, 3] def test_sort_sequences_no_operations_needed(): test_cases = [ [1, 2, 3], [10, 20, 30, 40], [1, 1, 1, 1] ] assert sort_sequences(test_cases) == [0, 0, 0]","solution":"def min_operations_to_sort(sequence): # This function counts the number of out-of-order elements # For the given problem, the minimum number of operations to sort the sequence # into non-decreasing order can be determined by counting these inversions. n = len(sequence) inversions = 0 for i in range(1, n): if sequence[i] < sequence[i - 1]: inversions += 1 # If there are no inversions, the array is already sorted if inversions == 0: return 0 # If there are any out of order elements, at most it takes 2 operations to sort it # 1. Reverse the section which causes the out of order pair # 2. Reverse the array if necessary else: return 1 def sort_sequences(test_cases): results = [] for sequence in test_cases: results.append(min_operations_to_sort(sequence)) return results"},{"question":"def difference_largest_smallest(arr): Returns the difference between the largest and smallest values in the array. >>> difference_largest_smallest([3, 1, 4, 1, 5, 9]) 8 >>> difference_largest_smallest([10, 20, 30, 40, 50]) 40 >>> difference_largest_smallest([1, 1, 1, 1, 1]) 0 >>> difference_largest_smallest([-10, 0, 10]) 20 >>> difference_largest_smallest([100]) 0","solution":"def difference_largest_smallest(arr): Returns the difference between the largest and smallest values in the array. if not arr: return 0 max_value = max(arr) min_value = min(arr) return max_value - min_value"},{"question":"def generatePalindromes(n: int) -> list: Generate all distinct palindromic strings of length n using lowercase English letters. Parameters: n (int): Length of the palindrome strings to generate. Returns: list: List of all distinct palindromic strings of length n. Example: >>> generatePalindromes(2) [\\"aa\\",\\"bb\\",\\"cc\\",\\"dd\\",\\"ee\\",\\"ff\\",\\"gg\\",\\"hh\\",\\"ii\\",\\"jj\\",\\"kk\\",\\"ll\\",\\"mm\\",\\"nn\\",\\"oo\\",\\"pp\\",\\"qq\\",\\"rr\\",\\"ss\\",\\"tt\\",\\"uu\\",\\"vv\\",\\"ww\\",\\"xx\\",\\"yy\\",\\"zz\\"] >>> generatePalindromes(3) []","solution":"def generatePalindromes(n): Generate all distinct palindromic strings of length n using lowercase English letters. Parameters: n (int): Length of the palindrome strings to generate. Returns: list: List of all distinct palindromic strings of length n. if n == 0: return [] if n == 1: # Single character palindromes return [chr(i) for i in range(ord('a'), ord('z') + 1)] if n % 2 == 1: # Palindromes of odd length cannot be generated by simple mirroring return [] half_length = n // 2 palindromes = [] def generate_half(current): if len(current) == half_length: # Generate the full palindrome by mirroring full_palindrome = current + current[::-1] palindromes.append(full_palindrome) return for i in range(ord('a'), ord('z') + 1): generate_half(current + chr(i)) generate_half(\\"\\") return palindromes"},{"question":"def execute_operations(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> List[int]: Execute a sequence of operations on a sequence of numbers. The operations are: 1. Increment each element in the range \`[l, r]\` (1-based index) by a given value x. 2. Compute the maximum value over the range \`[l, r]\`. Args: n (int): the length of the sequence m (int): the number of operations operations (List[Tuple[int, int, int, int]]): the list of operations Returns: List[int]: the results of all type 2 operations Example: >>> execute_operations(5, 4, [(1, 1, 3, 4), (1, 2, 5, 3), (2, 1, 5), (2, 2, 4)]) [7, 7] >>> execute_operations(5, 2, [(1, 1, 5, 10), (2, 1, 5)]) [10] >>> execute_operations(6, 6, [(1, 1, 3, 4), (2, 1, 3), (2, 1, 6), (1, 4, 6, 5), (2, 1, 6), (2, 4, 6)]) [4, 4, 5, 5]","solution":"class SegmentTree: This class implements a Segment Tree with lazy propagation for range updates and range maximum queries. def __init__(self, n): self.n = n self.data = [0] * (4 * n) self.lazy = [0] * (4 * n) def _propagate(self, idx, start, end): if self.lazy[idx] != 0: self.data[idx] += self.lazy[idx] if start != end: self.lazy[2 * idx + 1] += self.lazy[idx] self.lazy[2 * idx + 2] += self.lazy[idx] self.lazy[idx] = 0 def _range_update(self, idx, start, end, l, r, value): self._propagate(idx, start, end) if start > end or start > r or end < l: return if start >= l and end <= r: self.data[idx] += value if start != end: self.lazy[2 * idx + 1] += value self.lazy[2 * idx + 2] += value return mid = (start + end) // 2 self._range_update(2 * idx + 1, start, mid, l, r, value) self._range_update(2 * idx + 2, mid + 1, end, l, r, value) self.data[idx] = max(self.data[2 * idx + 1], self.data[2 * idx + 2]) def _range_max(self, idx, start, end, l, r): self._propagate(idx, start, end) if start > end or start > r or end < l: return -float('inf') if start >= l and end <= r: return self.data[idx] mid = (start + end) // 2 left_max = self._range_max(2 * idx + 1, start, mid, l, r) right_max = self._range_max(2 * idx + 2, mid + 1, end, l, r) return max(left_max, right_max) def range_update(self, l, r, value): self._range_update(0, 0, self.n - 1, l - 1, r - 1, value) def range_max(self, l, r): return self._range_max(0, 0, self.n - 1, l - 1, r - 1) def execute_operations(n, m, operations): tree = SegmentTree(n) results = [] for operation in operations: if operation[0] == 1: _, l, r, x = operation tree.range_update(l, r, x) elif operation[0] == 2: _, l, r = operation result = tree.range_max(l, r) results.append(result) return results"},{"question":"def minimum_moves_to_equal_elements(n: int, arr: List[int]) -> int: Given an array of integers, determine the minimum number of moves required for every element in the array to be the same. In one move, you can increment or decrement any element of the array by 1. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. Returns: int: The minimum number of moves required. Examples: >>> minimum_moves_to_equal_elements(4, [1, 2, 3, 4]) 4 >>> minimum_moves_to_equal_elements(3, [-1, 0, 1]) 2 >>> minimum_moves_to_equal_elements(3, [5, 5, 5]) 0 >>> minimum_moves_to_equal_elements(1, [1000000000]) 0 >>> minimum_moves_to_equal_elements(4, [-1000000000, 0, 1000000000, 500000000]) 2500000000 >>> minimum_moves_to_equal_elements(6, [1, 2, 2, 2, 3, 4]) 4","solution":"def minimum_moves_to_equal_elements(n, arr): Returns the minimum number of moves required for every element in the array to be the same. arr.sort() median = arr[n // 2] moves = sum(abs(x - median) for x in arr) return moves"},{"question":"def find_intersection(arr1, arr2): Write a function that takes in two integer arrays, \`arr1\` and \`arr2\`, and returns an array containing the elements that are present in both arrays (the intersection). The resulting array should be sorted in ascending order. Both arrays may contain duplicate elements, but the intersection should contain only unique elements sorted in ascending order. If there is no common element, return an empty array. You can assume that the input arrays will contain integer values only. >>> find_intersection([4, 9, 5], [9, 4, 9, 8, 4]) [4, 9] >>> find_intersection([1, 2, 3], [4, 5, 6]) [] >>> find_intersection([1, 1, 2, 2], [2, 2, 3, 3]) [2] >>> find_intersection([], [1, 2, 3]) [] >>> find_intersection([1, 2, 3], []) [] >>> find_intersection([], []) [] >>> find_intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3]","solution":"def find_intersection(arr1, arr2): Returns an array containing the unique elements that are present in both arr1 and arr2, sorted in ascending order. # Convert both arrays to sets to find the intersection. set1 = set(arr1) set2 = set(arr2) intersection = set1.intersection(set2) # Convert the intersection to a sorted list and return. return sorted(list(intersection))"},{"question":"def min_length_segment(N: int, T: int, difficulties: List[int]) -> int: Determine the minimum length of any segment whose total difficulty exceeds the given threshold. Args: - N (int): the number of checkpoints - T (int): the difficulty threshold - difficulties (List[int]): a list containing the difficulty of each checkpoint Returns: - int: the length of the minimum segment whose total difficulty exceeds T, or -1 if no such segment exists. >>> min_length_segment(5, 8, [2, 3, 6, 1, 4]) 2 >>> min_length_segment(4, 15, [2, 3, 4, 5]) -1 >>> min_length_segment(6, 10, [1, 1, 1, 1, 1, 1]) -1 >>> min_length_segment(3, 2, [1, 1, 1]) 3 >>> min_length_segment(4, 7, [3, 3, 3, 3]) 3 from typing import List # Add your implementation here.","solution":"def min_length_segment(N, T, difficulties): # Extend the difficulties to handle circular nature extended_difficulties = difficulties + difficulties def exceeds_threshold(length): current_sum = sum(extended_difficulties[:length]) if current_sum > T: return True for i in range(1, N): current_sum += extended_difficulties[i + length - 1] - extended_difficulties[i - 1] if current_sum > T: return True return False for length in range(1, N + 1): if exceeds_threshold(length): return length return -1 # For example input N = 5 T = 8 difficulties = [2, 3, 6, 1, 4] print(min_length_segment(N, T, difficulties)) # Output: 2"},{"question":"def can_distribute_packages(N: int, weights: List[int], M: int, W: int) -> str: Determine if the packages can be evenly distributed across the trucks without exceeding the maximum weight for any truck. Parameters: N (int): Number of packages. weights (List[int]): Weights of the packages. M (int): Number of trucks. W (int): Maximum weight each truck can carry. Returns: str: \\"yes\\" if the distribution is possible, otherwise \\"no\\". Example: >>> can_distribute_packages(4, [2, 4, 6, 8], 2, 10) \\"yes\\" >>> can_distribute_packages(4, [3, 3, 3, 3], 3, 5) \\"no\\" def test_can_distribute_packages_evenly(): assert can_distribute_packages(4, [2, 4, 6, 8], 2, 10) == \\"yes\\" def test_can_distribute_packages_not_evenly(): assert can_distribute_packages(4, [3, 3, 3, 3], 3, 5) == \\"no\\" def test_single_truck_exceeds_capacity(): assert can_distribute_packages(4, [2, 4, 6, 8], 1, 15) == \\"no\\" def test_single_truck_within_capacity(): assert can_distribute_packages(4, [2, 3, 5, 1], 1, 12) == \\"yes\\" def test_exactly_distributed_weights(): assert can_distribute_packages(4, [2, 2, 2, 2], 2, 4) == \\"yes\\" def test_large_weights_unequally_distributed(): assert can_distribute_packages(4, [5, 5, 5, 5], 2, 10) == \\"yes\\" def test_more_trucks_than_packages(): assert can_distribute_packages(4, [2, 2, 2, 2], 5, 4) == \\"no\\" def test_too_heavy_single_package(): assert can_distribute_packages(1, [1001], 1, 1000) == \\"no\\" def test_single_package_fits(): assert can_distribute_packages(1, [1000], 1, 1000) == \\"yes\\"","solution":"def can_distribute_packages(N, weights, M, W): Determine if the packages can be distributed evenly across the trucks without exceeding the maximum weight for any truck. Parameters: N (int): Number of packages. weights (list of int): Weights of the packages. M (int): Number of trucks. W (int): Maximum weight each truck can carry. Returns: str: \\"yes\\" if the distribution is possible, otherwise \\"no\\". total_weight = sum(weights) # Each truck should carry exactly this weight for an even distribution target_per_truck = total_weight // M if total_weight % M != 0 or target_per_truck > W: return \\"no\\" # If there's only one truck, it carries the total weight if M == 1: return \\"yes\\" if total_weight <= W else \\"no\\" # Recursive helper function to check if we can partition the speeds into M groups of target_per_truck max_weight = W # maximum weight a group (truck) can carry weights.sort(reverse=True) # Sort the weights from heaviest to lightest used = [False] * N def can_partition(start, current_sum, groups_formed): if groups_formed == M: return True if current_sum == target_per_truck: return can_partition(0, 0, groups_formed + 1) for i in range(start, N): if not used[i] and current_sum + weights[i] <= max_weight: used[i] = True if can_partition(i + 1, current_sum + weights[i], groups_formed): return True used[i] = False return False return \\"yes\\" if can_partition(0, 0, 0) else \\"no\\""},{"question":"from typing import List def min_moves_in_grid(n: int, m: int, sr: int, sc: int, tr: int, tc: int, grid: List[str]) -> int: Function to find the minimum number of moves for the robot to reach the target position. Use BFS algorithm to find the shortest path in an unweighted grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. sr (int): Starting row position (1-based index). sc (int): Starting column position (1-based index). tr (int): Target row position (1-based index). tc (int): Target column position (1-based index). grid (list of str): List of strings representing the grid layout with '.' for free space and '#' for obstacles. Returns: int: Minimum number of moves to reach the target or -1 if it is impossible. >>> grid = [ ... \\".....\\", ... \\".#.#.\\", ... \\".....\\", ... \\".#.#.\\", ... \\".....\\" ... ] >>> min_moves_in_grid(5, 5, 1, 1, 5, 5, grid) 8 >>> grid = [ ... \\"...\\", ... \\".#.\\", ... \\"...\\" ... ] >>> min_moves_in_grid(3, 3, 1, 1, 3, 3, grid) 4 >>> grid = [ ... \\"\\", ... \\"#..#\\", ... \\"#..#\\", ... \\"\\" ... ] >>> min_moves_in_grid(4, 4, 1, 1, 4, 4, grid) -1","solution":"from collections import deque def min_moves_in_grid(n, m, sr, sc, tr, tc, grid): Function to find the minimum number of moves for the robot to reach the target position. Use BFS algorithm to find shortest path in an unweighted grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. sr (int): Starting row position (1-based index). sc (int): Starting column position (1-based index). tr (int): Target row position (1-based index). tc (int): Target column position (1-based index). grid (list of str): List of strings representing the grid layout with '.' for free space and '#' for obstacles. Returns: int: Minimum number of moves to reach the target or -1 if it is impossible. sr, sc, tr, tc = sr-1, sc-1, tr-1, tc-1 # Convert to 0-based index directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set() visited.add((sr, sc)) while queue: r, c, dist = queue.popleft() if r == tr and c == tc: return dist for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == '.': queue.append((nr, nc, dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def range_sum(N, A, queries): This function returns the sum of elements in the array from index L to R for each query. >>> range_sum(5, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> range_sum(6, [1, 3, 5, 7, 9, 11], [(1, 2), (3, 5), (1, 6), (2, 4)]) [4, 21, 36, 15] >>> range_sum(4, [10, 20, 30, 40], [(2, 2), (3, 3)]) [20, 30] >>> range_sum(3, [100, 200, 300], [(1, 3)]) [600] >>> range_sum(2, [10**9, 10**9], [(1, 2)]) [2 * 10**9]","solution":"def range_sum(N, A, queries): This function returns the sum of elements in the array from index L to R for each query. # Create a prefix sum array prefix_sum = [0] * (N + 1) # Fill the prefix sum array for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] result = [] # Process each query for L, R in queries: # Calculate sum from L to R using the prefix sum array sum_LR = prefix_sum[R] - prefix_sum[L - 1] result.append(sum_LR) return result"},{"question":"def longest_common_substring_length(A: str, B: str) -> int: Finds the length of the longest common substring between two strings A and B. >>> longest_common_substring_length(\\"investment\\", \\"vestment\\") 8 >>> longest_common_substring_length(\\"abcdef\\", \\"zabxcy\\") 2 >>> longest_common_substring_length(\\"abcd\\", \\"efgh\\") 0 >>> longest_common_substring_length(\\"abc\\", \\"dabc\\") 3 >>> longest_common_substring_length(\\"same\\", \\"same\\") 4 >>> longest_common_substring_length(\\"\\", \\"something\\") 0 >>> longest_common_substring_length(\\"something\\", \\"\\") 0 >>> longest_common_substring_length(\\"\\", \\"\\") 0","solution":"def longest_common_substring_length(A, B): Finds the length of the longest common substring between two strings A and B. m, n = len(A), len(B) dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 for i in range(1, m + 1): for j in range(1, n + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"def count_islands(grid: List[List[int]]) -> int: Counts the number of distinct islands in the grid. An island is defined as a group of connected cells having the same altitude, connected either vertically or horizontally. >>> count_islands([[1, 2, 2], [3, 1, 2], [1, 1, 1]]) 4 >>> count_islands([[1, 1], [1, 1]]) 1 from typing import List def test_single_island(): assert count_islands([[1, 1], [1, 1]]) == 1 def test_multiple_islands(): assert count_islands([[1, 2, 2], [3, 1, 2], [1, 1, 1]]) == 4 def test_separated_single_cells(): assert count_islands([[1, 2], [3, 4]]) == 4 def test_large_identical_island(): assert count_islands([[1]*20]*20) == 1 def test_check_diagonal_islands(): assert count_islands([[1, 2], [2, 1]]) == 4 def test_no_islands_in_empty_grid(): assert count_islands([]) == 0","solution":"def count_islands(grid): Counts the number of distinct islands in the grid. An island is defined as a group of connected cells having the same altitude, connected either vertically or horizontally. if not grid: return 0 N = len(grid) visited = [[False] * N for _ in range(N)] def dfs(x, y, altitude): if x < 0 or x >= N or y < 0 or y >= N or visited[x][y] or grid[x][y] != altitude: return visited[x][y] = True dfs(x + 1, y, altitude) dfs(x - 1, y, altitude) dfs(x, y + 1, altitude) dfs(x, y - 1, altitude) count = 0 for i in range(N): for j in range(N): if not visited[i][j]: dfs(i, j, grid[i][j]) count += 1 return count"},{"question":"def diamond_star_pattern(n: int) -> str: Generates a diamond shaped star pattern with the max width being 2n-1. Args: n (int): The half-height of the diamond. Returns: str: The diamond star pattern. Example: >>> diamond_star_pattern(3) ' *n ***n*****n ***n *' >>> diamond_star_pattern(5) ' *n ***n *****n *******n*********n *******n *****n ***n *' from solution import diamond_star_pattern def test_diamond_star_pattern_min_half_height(): result = diamond_star_pattern(1) expected = \\"*\\" assert result == expected def test_diamond_star_pattern_half_height_3(): result = diamond_star_pattern(3) expected = \\" *n ***n*****n ***n *\\" assert result == expected def test_diamond_star_pattern_half_height_5(): result = diamond_star_pattern(5) expected = \\" *n ***n *****n *******n*********n *******n *****n ***n *\\" assert result == expected def test_diamond_star_pattern_invalid_low_value(): try: diamond_star_pattern(0) assert False, \\"Expected ValueError for input less than 1\\" except ValueError: pass def test_diamond_star_pattern_invalid_high_value(): try: diamond_star_pattern(101) assert False, \\"Expected ValueError for input greater than 100\\" except ValueError: pass","solution":"def diamond_star_pattern(n): Generates a diamond shaped star pattern with the max width being 2n-1. Args: n (int): The half-height of the diamond. Returns: str: The diamond star pattern. if n < 1 or n > 100: raise ValueError(\\"Input must be a positive integer between 1 and 100.\\") diamond = [] for i in range(n): spaces = ' ' * (n - i - 1) stars = '*' * (2 * i + 1) diamond.append(spaces + stars) for i in range(n - 2, -1, -1): spaces = ' ' * (n - i - 1) stars = '*' * (2 * i + 1) diamond.append(spaces + stars) return 'n'.join(diamond)"},{"question":"def roman_to_int(roman: str) -> int: Convert a Roman numeral into an integer. Args: roman (str): A Roman numeral string between 1 and 3999 Returns: int: The integer value of the Roman numeral Examples: >>> roman_to_int(\\"III\\") 3 >>> roman_to_int(\\"IV\\") 4 >>> roman_to_int(\\"IX\\") 9 >>> roman_to_int(\\"LVIII\\") 58 >>> roman_to_int(\\"MCMXCIV\\") 1994","solution":"def roman_to_int(roman: str) -> int: roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 for char in reversed(roman): value = roman_values[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"from typing import List from heapq import heappop, heappush from collections import Counter def reorganizeString(s: str) -> str: Reorders the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. Parameters: s (str): The input string. Returns: str: The reordered string or an empty string if reordering is not possible. >>> reorganizeString(\\"aaabbc\\") 'ababac' >>> reorganizeString(\\"aaab\\") '' from solution import reorganizeString def test_reorganize_string_possible(): assert reorganizeString(\\"aaabbc\\") != \\"\\" result = reorganizeString(\\"aaabbc\\") for i in range(len(result) - 1): assert result[i] != result[i + 1] def test_reorganize_string_not_possible(): assert reorganizeString(\\"aaab\\") == \\"\\" def test_reorganize_single_character(): assert reorganizeString(\\"a\\") == \\"a\\" def test_reorganize_string_all_same_char(): assert reorganizeString(\\"aaa\\") == \\"\\" def test_reorganize_string_equal_distribution(): assert reorganizeString(\\"aabb\\") in [\\"abab\\", \\"baba\\"] def test_reorganize_string_edge_case(): assert reorganizeString(\\"abc\\") in [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] def test_reorganize_string_another_possibility(): result = reorganizeString(\\"aaabb\\") for i in range(len(result) - 1): assert result[i] != result[i + 1]","solution":"from heapq import heappop, heappush from collections import Counter def reorganizeString(s): Reorders the input string such that no two adjacent characters are the same. If it is not possible, returns an empty string. Parameters: s (str): The input string. Returns: str: The reordered string or an empty string if reordering is not possible. # Count the frequency of each character count = Counter(s) maxCharCount = count.most_common(1)[0][1] # If the most frequent character is more than half the length (plus one), impossible to arrange if maxCharCount > (len(s) + 1) // 2: return \\"\\" # Max heap to store characters by their frequency (invert frequency to use min-heap as max-heap) maxHeap = [] for char, freq in count.items(): heappush(maxHeap, (-freq, char)) # Reorganize the string result = [] prev_freq, prev_char = 0, '' while maxHeap: freq, char = heappop(maxHeap) result.append(char) # Add the previous character back if its frequency is not zero if prev_freq < 0: heappush(maxHeap, (prev_freq, prev_char)) prev_freq = freq + 1 # Decrement the frequency prev_char = char return ''.join(result)"},{"question":"def longest_subarray_with_sum_leq_k(n, k, a): Finds the length of the longest continuous subarray where the sum of its elements is less than or equal to k. :param n: Length of the sequence :param k: The constant value :param a: The sequence of integers :return: Length of the longest continuous subarray with sum <= k >>> longest_subarray_with_sum_leq_k(5, 5, [1, 2, 3, 4, 5]) 2 >>> longest_subarray_with_sum_leq_k(6, 10, [6, 7, 1, 2, 5, 4]) 3 >>> longest_subarray_with_sum_leq_k(1, 10, [5]) 1 >>> longest_subarray_with_sum_leq_k(4, 1, [2, 3, 4, 5]) 0 >>> longest_subarray_with_sum_leq_k(5, 15, [1, 2, 3, 4, 5]) 5 >>> longest_subarray_with_sum_leq_k(5, 4, [1, 0, 2, 0, 1]) 5","solution":"def longest_subarray_with_sum_leq_k(n, k, a): Finds the length of the longest continuous subarray where the sum of its elements is less than or equal to k. :param n: Length of the sequence :param k: The constant value :param a: The sequence of integers :return: Length of the longest continuous subarray with sum <= k max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += a[end] while current_sum > k and start <= end: current_sum -= a[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def check_anagrams(test_cases): Given a list of strings, identify if there exist any two distinct strings in the list that are anagrams of each other. If such a pair exists, return \\"YES\\", otherwise return \\"NO\\". Input: - test_cases: a list of lists, where each inner list contains strings representing signals. Output: - a list of strings, where each string is \\"YES\\" if any two distinct strings in the test case are anagrams, else \\"NO\\". Examples: >>> check_anagrams([[\\"abc\\", \\"bca\\", \\"xyz\\"]]) [\\"YES\\"] >>> check_anagrams([[\\"hello\\", \\"oellh\\", \\"world\\", \\"dlro\\"]]) [\\"YES\\"]","solution":"def are_anagrams(str1, str2): Checks if two strings are anagrams of each other. return sorted(str1) == sorted(str2) def check_anagrams(test_cases): results = [] for signals in test_cases: anagram_found = False signal_count = len(signals) for i in range(signal_count): for j in range(i + 1, signal_count): if are_anagrams(signals[i], signals[j]): anagram_found = True break if anagram_found: break results.append(\\"YES\\" if anagram_found else \\"NO\\") return results"},{"question":"from typing import List def nextGreaterElement(N: int, Arr: List[int]) -> List[int]: Finds the next greater element for each element in the array. >>> nextGreaterElement(5, [4, 5, 2, 10, 8]) [5, 10, 10, -1, -1] >>> nextGreaterElement(4, [3, 2, 7, 5]) [7, 7, -1, -1] pass","solution":"def nextGreaterElement(N, Arr): Finds the next greater element for each element in the array. result = [-1] * N stack = [] for i in range(N): while stack and Arr[stack[-1]] < Arr[i]: result[stack.pop()] = Arr[i] stack.append(i) return result"},{"question":"class StoreCatalog: A data structure for an online store that keeps track of products and their prices. Methods: - addProduct(productName: str, price: int): Adds or updates a product with the given name and price. - removeProduct(productName: str): Removes the product with the given name from the catalog. - findPrice(productName: str): Returns the price of the product with the given name. - findCheapest(): Returns the name of the cheapest product in the catalog. Example: storeCatalog = StoreCatalog() storeCatalog.addProduct(\\"Apple\\", 100) storeCatalog.addProduct(\\"Banana\\", 50) storeCatalog.addProduct(\\"Cherry\\", 75) price = storeCatalog.findPrice(\\"Apple\\") # Finds price of \\"Apple\\", which is 100. cheapest = storeCatalog.findCheapest() # Finds the cheapest product, which is \\"Banana\\". storeCatalog.removeProduct(\\"Banana\\") # Removes \\"Banana\\" from the catalog. storeCatalog.removeProduct(\\"Orange\\") # Tries to remove \\"Orange\\", but it doesn't exist. cheapest = storeCatalog.findCheapest() # Now the cheapest product is \\"Cherry\\". def __init__(self): pass def addProduct(self, productName: str, price: int): pass def removeProduct(self, productName: str): pass def findPrice(self, productName: str): pass def findCheapest(self): pass def test_store_catalog(): storeCatalog = StoreCatalog() # Test adding products storeCatalog.addProduct(\\"Apple\\", 100) assert storeCatalog.findPrice(\\"Apple\\") == 100 storeCatalog.addProduct(\\"Banana\\", 50) assert storeCatalog.findPrice(\\"Banana\\") == 50 storeCatalog.addProduct(\\"Cherry\\", 75) assert storeCatalog.findPrice(\\"Cherry\\") == 75 # Test updating product price storeCatalog.addProduct(\\"Banana\\", 60) assert storeCatalog.findPrice(\\"Banana\\") == 60 # Test finding the cheapest product assert storeCatalog.findCheapest() == \\"Banana\\" # Test removing products storeCatalog.removeProduct(\\"Banana\\") assert storeCatalog.findPrice(\\"Banana\\") == -1 assert storeCatalog.findCheapest() == \\"Cherry\\" # Test removing non-existent product storeCatalog.removeProduct(\\"Orange\\") assert storeCatalog.findCheapest() == \\"Cherry\\" # Test finding price of non-existent product assert storeCatalog.findPrice(\\"Orange\\") == -1 # Test finding the cheapest product when none exists storeCatalog.removeProduct(\\"Apple\\") storeCatalog.removeProduct(\\"Cherry\\") assert storeCatalog.findCheapest() == \\"No products\\"","solution":"class StoreCatalog: def __init__(self): self.products = {} self.product_order = [] def addProduct(self, productName, price): if productName not in self.products: self.product_order.append(productName) self.products[productName] = price def removeProduct(self, productName): if productName in self.products: del self.products[productName] self.product_order = [p for p in self.product_order if p != productName] def findPrice(self, productName): if productName in self.products: return self.products[productName] return -1 def findCheapest(self): if not self.products: return \\"No products\\" cheapest_price = min(self.products.values()) for product in self.product_order: if self.products[product] == cheapest_price: return product"},{"question":"def longest_palindrome_length(inputString: str) -> int: Returns the length of the longest palindrome that can be built with the characters from inputString. >>> longest_palindrome_length(\\"abccccdd\\") == 7 >>> longest_palindrome_length(\\"a\\") == 1 >>> longest_palindrome_length(\\"aaabbbbb\\") == 7","solution":"def longest_palindrome_length(inputString: str) -> int: Returns the length of the longest palindrome that can be built with the characters from inputString. from collections import Counter char_count = Counter(inputString) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 # Add one odd character in the center return length"},{"question":"def can_partition_into_distinct_subsequences(t, test_cases): Determine if it is possible to partition the sequence \`a\` into one or more subsequences such that the total number of distinct integers in all subsequences combined equals \`X\`. Args: t: int - the number of test cases test_cases: list of tuples - each tuple contains: (n, X) - two integers representing the length of the sequence and the target number of distinct integers a - a list of integers representing the sequence Returns: list of str - \\"YES\\" or \\"NO\\" for each test case Example: >>> can_partition_into_distinct_subsequences(3, [((5, 3), [1, 2, 2, 1, 3]), ((4, 2), [4, 4, 4, 4]), ((6, 4), [1, 2, 3, 4, 4, 4])]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_partition_into_distinct_subsequences(2, [((7, 5), [1, 1, 2, 3, 3, 4, 5]), ((1, 1), [1])]) [\\"YES\\", \\"YES\\"] # Your implementation here def test_can_partition_into_distinct_subsequences(): test_cases = [ (3, [ ((5, 3), [1, 2, 2, 1, 3]), ((4, 2), [4, 4, 4, 4]), ((6, 4), [1, 2, 3, 4, 4, 4]) ]), (2, [ ((7, 5), [1, 1, 2, 3, 3, 4, 5]), ((1, 1), [1]) ]) ] expected_results = [ [\\"YES\\", \\"NO\\", \\"YES\\"], [\\"YES\\", \\"YES\\"] ] for i, (t, cases) in enumerate(test_cases): result = can_partition_into_distinct_subsequences(t, cases) assert result == expected_results[i], f\\"Test case {i + 1} failed: expected {expected_results[i]}, got {result}\\" # Running the test test_can_partition_into_distinct_subsequences()","solution":"def can_partition_into_distinct_subsequences(t, test_cases): results = [] for i in range(t): n, X = test_cases[i][0] a = test_cases[i][1] distinct_count = len(set(a)) if distinct_count >= X: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def perform_action(N: int, x: int, B: List[str]) -> None: Perform an action based on the value of x on the array of strings B. Parameters: N (int): Number of strings in the array B. x (int): Action to perform. B (List[str]): Array of strings. Actions: 1. Print the length of the longest string in B 2. Print \\"First Same\\" if the first character of the first string matches the first character of the second string, or Print \\"First Different\\" otherwise. 3. Concatenate the first three strings in B and print the result. 4. Print all strings in B that contain the character 'a' 5. Print the sum of the lengths of all strings in B. 6. Reverse each string in B and print them as a space-separated string in one line. 7. Traverse the array based on the length of the elements and print \\"Out\\" when moving outside the bounds. Examples: >>> perform_action(5, 1, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\", \\"egg\\"]) 6 >>> perform_action(5, 2, [\\"apple\\", \\"apricot\\", \\"carrot\\", \\"date\\", \\"egg\\"]) First Same >>> perform_action(5, 3, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\", \\"egg\\"]) applebananacarrot >>> perform_action(5, 4, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\", \\"egg\\"]) apple banana carrot >>> perform_action(5, 5, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\", \\"egg\\"]) 25 >>> perform_action(5, 6, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\", \\"egg\\"]) elppa ananab torrag etad gge >>> perform_action(4, 7, [\\"apple\\", \\"banana\\", \\"carrot\\", \\"date\\"]) Out","solution":"def perform_action(N, x, B): if x == 1: print(max(len(s) for s in B)) elif x == 2: if B[0][0] == B[1][0]: print(\\"First Same\\") else: print(\\"First Different\\") elif x == 3: print(B[0] + B[1] + B[2]) elif x == 4: for s in B: if 'a' in s: print(s) elif x == 5: print(sum(len(s) for s in B)) elif x == 6: print(' '.join(s[::-1] for s in B)) elif x == 7: i = 0 while 0 <= i < N: i = len(B[i]) print(\\"Out\\")"},{"question":"def is_perfect_rectangle(n: int, blocks: List[Tuple[int, int, int, int]]) -> str: Check if a given set of blocks can form a perfect rectangle. >>> is_perfect_rectangle(3, [(1, 1, 2, 2), (3, 1, 2, 2), (1, 3, 4, 2)])== \\"YES\\" >>> is_perfect_rectangle(3, [(1, 1, 2, 2), (3, 1, 2, 2), (1, 3, 3, 1)])== \\"NO\\"","solution":"def is_perfect_rectangle(n, blocks): total_area = 0 min_x = min_y = float('inf') max_x = max_y = float('-inf') block_set = set() for x, y, w, h in blocks: total_area += w * h min_x = min(min_x, x) min_y = min(min_y, y) max_x = max(max_x, x + w) max_y = max(max_y, y + h) for i in range(w): for j in range(h): if (x + i, y + j) in block_set: return \\"NO\\" block_set.add((x + i, y + j)) if total_area == (max_x - min_x) * (max_y - min_y): return \\"YES\\" else: return \\"NO\\""},{"question":"def minCostToPaintHouses(cost: List[List[int]]) -> int: Given an NxN matrix representing the cost of painting N houses with N colors, where matrix[i][j] represents the cost of painting the ith house with the jth color, and no two adjacent houses can have the same color, find the minimum cost to paint all houses. >>> minCostToPaintHouses([ ... [17, 2, 17], ... [16, 16, 5], ... [14, 3, 19] ... ]) 10 >>> minCostToPaintHouses([ ... [1] ... ]) 1 >>> minCostToPaintHouses([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> minCostToPaintHouses([ ... [10, 10, 10], ... [1, 1, 1], ... [10, 10, 10] ... ]) 21 >>> minCostToPaintHouses([ ... [5000, 5000, 5000], ... [5000, 5000, 5000], ... [5000, 5000, 5000] ... ]) 15000","solution":"def minCostToPaintHouses(cost): N = len(cost) if N == 0: return 0 for i in range(1, N): for j in range(N): cost[i][j] += min(cost[i-1][k] for k in range(N) if k != j) return min(cost[-1]) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) matrix = [] index = 1 for i in range(N): row = list(map(int, data[index:index+N])) matrix.append(row) index += N print(minCostToPaintHouses(matrix))"},{"question":"def countPalindromicSubstrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> countPalindromicSubstrings(\\"ababa\\") 9 >>> countPalindromicSubstrings(\\"abc\\") 3 >>> countPalindromicSubstrings(\\"aaaa\\") 10","solution":"def countPalindromicSubstrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 # Create 2D dp array, dp[i][j] will be True if the string from index i to j is a palindrome. dp = [[False] * n for _ in range(n)] # Single letter palindromes for i in range(n): dp[i][i] = True count += 1 # Double letter palindromes for i in range(n-1): if s[i] == s[i+1]: dp[i][i+1] = True count += 1 # Palindromes of length 3 or more for length in range(3, n+1): for i in range(n-length+1): j = i + length - 1 if s[i] == s[j] and dp[i+1][j-1]: dp[i][j] = True count += 1 return count"},{"question":"def longest_substring_same_char_with_k_operations(s: str, k: int) -> int: Find the length of the longest substring containing the same character after performing at most K operations on the string. Args: s (str): A string consisting of lowercase English letters. k (int): The maximum number of operations allowed. Returns: int: The length of the longest substring with the same character after at most K operations. >>> longest_substring_same_char_with_k_operations('aabb', 2) 4 >>> longest_substring_same_char_with_k_operations('abcde', 1) 2 >>> longest_substring_same_char_with_k_operations('aaabbbcc', 3) 6 pass def process_test_cases(test_cases: List[Tuple[str, int]]) -> List[int]: Process multiple test cases to find the longest substring with same character after K operations for each case. Args: test_cases (List[Tuple[str, int]]): List of tuples, where each tuple contains a string and an integer K. Returns: List[int]: List of results corresponding to each test case. >>> process_test_cases([('aabb', 2), ('abcde', 1), ('aaabbbcc', 3)]) [4, 2, 6] >>> process_test_cases([('zzzzzz', 0), ('abcd', 0), ('aaaa', 1)]) [6, 1, 4] pass","solution":"def longest_substring_same_char_with_k_operations(s, k): def max_repeating_char_with_k_ops(s, k, c): max_len = 0 left = 0 count = 0 for right in range(len(s)): if s[right] != c: count += 1 while count > k: if s[left] != c: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_length = 0 for char in set(s): max_length = max(max_length, max_repeating_char_with_k_ops(s, k, char)) return max_length def process_test_cases(test_cases): result = [] for s, k in test_cases: result.append(longest_substring_same_char_with_k_operations(s, k)) return result"},{"question":"from typing import List def min_steps_to_make_anagrams(A: str, B: str) -> int: Given two strings, A and B, determine the minimum number of steps required to make them anagrams. In one step, you can either insert, delete, or replace a character in one of the strings. Two strings are anagrams if they contain the same characters with the same frequencies, regardless of the order. Args: A: A string consisting of lowercase English letters. B: A string consisting of lowercase English letters. Returns: An integer representing the minimum number of steps required to make the two strings anagrams. Examples: >>> min_steps_to_make_anagrams(\\"abcd\\", \\"cbda\\") 0 >>> min_steps_to_make_anagrams(\\"abc\\", \\"efg\\") 6 # Implementation here.","solution":"from collections import Counter def min_steps_to_make_anagrams(A, B): Returns the minimum number of steps required to make two strings anagrams. count_A = Counter(A) count_B = Counter(B) steps = 0 # Characters to be added to A or removed from B for char in count_A: if char in count_B: steps += abs(count_A[char] - count_B[char]) else: steps += count_A[char] # Characters to be added to B or removed from A for char in count_B: if char not in count_A: steps += count_B[char] return steps"},{"question":"def can_bake(Q, recipes): Determines how many recipes can be baked given the quantities of ingredients. Args: - Q (list of int): Array representing the available quantities of each ingredient. - recipes (list of list of int): A list where each element is a list representing a recipe's ingredient requirements. Returns: - int: The number of recipes that can be baked. pass def process_test_cases(test_cases): Processes multiple test cases. Args: - test_cases (list of tuple): Each tuple represents a test case and includes: - N (int): Number of ingredients. - Q (list of int): Quantities of each ingredient. - M (int): Number of recipes. - recipes (list of list of int): List of recipes, each represented as a list of ingredient requirements. Returns: - list of int: Number of recipes that can be baked for each test case. pass # Test cases def test_can_bake_all_recipes(): assert can_bake([10, 5, 8], [[5, 2, 3], [6, 3, 5]]) == 2 def test_can_bake_some_recipes(): assert can_bake([7, 3, 10, 2], [[1, 1, 6, 1], [2, 2, 4, 0], [3, 1, 7, 1]]) == 3 def test_can_bake_no_recipes(): assert can_bake([1, 1, 1], [[2, 2, 2], [3, 3, 3]]) == 0 def test_process_test_cases(): test_cases = [ (3, [10, 5, 8], 2, [[5, 2, 3], [6, 3, 5]]), (4, [7, 3, 10, 2], 3, [[1, 1, 6, 1], [2, 2, 4, 0], [3, 1, 7, 1]]), ] assert process_test_cases(test_cases) == [2, 3] def test_varied_quantities_and_recipes(): test_cases = [ (3, [0, 0, 0], 2, [[0, 0, 0], [1, 1, 1]]), (2, [5, 5], 3, [[1, 1], [2, 2], [6, 6]]), ] assert process_test_cases(test_cases) == [1, 2] def test_large_numbers(): test_cases = [ (3, [10**9, 10**9, 10**9], 2, [[10**9, 10**9, 10**9], [1, 1, 1]]), (2, [10**9, 10**9], 1, [[10**9, 10**9]]), ] assert process_test_cases(test_cases) == [2, 1]","solution":"def can_bake(Q, recipes): Determines how many recipes can be baked given the quantities of ingredients. Args: - Q (list of int): Array representing the available quantities of each ingredient. - recipes (list of list of int): A list where each element is a list representing a recipe's ingredient requirements. Returns: - int: The number of recipes that can be baked. count = 0 for recipe in recipes: if all(Q[i] >= recipe[i] for i in range(len(Q))): count += 1 return count def process_test_cases(test_cases): Processes multiple test cases. Args: - test_cases (list of tuple): Each tuple represents a test case and includes: - N (int): Number of ingredients. - Q (list of int): Quantities of each ingredient. - M (int): Number of recipes. - recipes (list of list of int): List of recipes, each represented as a list of ingredient requirements. Returns: - list of int: Number of recipes that can be baked for each test case. results = [] for case in test_cases: N, Q, M, recipes = case results.append(can_bake(Q, recipes)) return results"},{"question":"def word_frequency_counter(paragraph: str) -> dict: Returns a dictionary where the keys are the unique words and the values are the counts of occurrences of those words in the paragraph. The function ignores punctuation and is case-insensitive. >>> word_frequency_counter(\\"Hello, hello! How are you? I hope you are doing well.\\") {'hello': 2, 'how': 1, 'are': 2, 'you': 2, 'i': 1, 'hope': 1, 'doing': 1, 'well': 1} >>> word_frequency_counter(\\"A man, a plan, a canal, Panama!\\") {'a': 3, 'man': 1, 'plan': 1, 'canal': 1, 'panama': 1} >>> word_frequency_counter(\\"Test\\") {'test': 1} >>> word_frequency_counter(\\"!!!???\\") {} >>> word_frequency_counter(\\"repeat repeat repeat!\\") {'repeat': 3}","solution":"import re from collections import defaultdict def word_frequency_counter(paragraph: str) -> dict: Returns a dictionary where the keys are the unique words and the values are the counts of occurrences of those words in the paragraph. The function ignores punctuation and is case-insensitive. # Using regular expressions to remove punctuation and convert to lower case cleaned_paragraph = re.sub(r'[^ws]', '', paragraph).lower() # Splitting the paragraph into words words = cleaned_paragraph.split() # Counting the frequency of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return word_counts"},{"question":"def nextSparseNumber(X: int) -> int: Determine the smallest sparse number which is greater than or equal to X. A number is called sparse if there are no two consecutive set bits (1s) in its binary representation. Examples: >>> nextSparseNumber(6) 8 >>> nextSparseNumber(4) 4 >>> nextSparseNumber(38) 40","solution":"def nextSparseNumber(X): This function finds the smallest sparse number which is greater than or equal to X. def isSparse(n): return (n & (n >> 1)) == 0 # Start from the given number X while not isSparse(X): X += 1 return X"},{"question":"def max_sum_sequence(T, cases): Alex is playing a game with a sequence of numbers and needs help to find the best scoring sequence. The rule is that Alex can pick any number from the sequence, but once picked, cannot pick the immediate next number as well as the immediate previous number. Help Alex to find the maximum sum he can obtain by picking such numbers from the sequence. Args: T : int : number of test cases cases : list of tuples : each tuple contains an integer n and a list of n integers representing the sequence Returns: list : a list of integers where each element is the maximum sum possible for the corresponding test case Example: >>> max_sum_sequence(2, [(5, [3, 2, 5, 10, 7]), (3, [3, 2, 7])]) [15, 10]","solution":"def max_sum_sequence(T, cases): def max_sequence_sum(sequence): n = len(sequence) if n == 0: return 0 if n == 1: return max(0, sequence[0]) include = 0 exclude = 0 for i in range(n): # Current max excluding i new_exclude = max(include, exclude) # Current max including i include = exclude + sequence[i] exclude = new_exclude return max(include, exclude) results = [] for t in range(T): n = cases[t][0] sequence = cases[t][1] results.append(max_sequence_sum(sequence)) return results"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_path(root, target): Finds the path from the root to the target value in a binary tree. Args: root (TreeNode): The root node of the binary tree. target (int): The target value to find. Returns: List[int]: The path from the root to the target value. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(10) >>> find_path(root, 4) [5, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(7) >>> root.right = TreeNode(9) >>> root.left.left = TreeNode(2) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> find_path(root, 5) []","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_path(root, target): Finds the path from the root to the target value in a binary tree. Args: root (TreeNode): The root node of the binary tree. target (int): The target value to find. Returns: List[int]: The path from the root to the target value. def dfs(node, path): if not node: return [] # Add current node to the path path.append(node.value) # If the current node is the target, return the path if node.value == target: return path # Otherwise, continue to search in the left and right subtrees left_path = dfs(node.left, path.copy()) if left_path: return left_path right_path = dfs(node.right, path.copy()) if right_path: return right_path # If the target is not found, return an empty path path.pop() return [] return dfs(root, [])"},{"question":"def count_bipartite_graphs(m: int, n: int) -> int: Returns the number of different bipartite graphs that can be constructed with m nodes in set U and n nodes in set V. >>> count_bipartite_graphs(2, 3) 64 >>> count_bipartite_graphs(1, 1) 2 >>> count_bipartite_graphs(3, 3) 512 >>> count_bipartite_graphs(4, 4) 65536","solution":"def count_bipartite_graphs(m, n): Returns the number of different bipartite graphs that can be constructed with m nodes in set U and n nodes in set V. return 2 ** (m * n)"},{"question":"def longest_contiguous_substring(s: str) -> int: Returns the length of the longest contiguous substring where all characters are the same. Parameters: s (str): Input string consisting of lowercase letters. Returns: int: Length of the longest contiguous substring with identical characters. Example: >>> longest_contiguous_substring(\\"aabbbccaaa\\") 3 >>> longest_contiguous_substring(\\"aaaa\\") 4 >>> longest_contiguous_substring(\\"abcdef\\") 1 >>> longest_contiguous_substring(\\"\\") 0 >>> longest_contiguous_substring(\\"aabbccdd\\") 2 >>> longest_contiguous_substring(\\"abcddd\\") 3 >>> longest_contiguous_substring(\\"abcccd\\") 3 >>> longest_contiguous_substring(\\"bbbbbb\\") 6 >>> longest_contiguous_substring(\\"a\\") 1 >>> longest_contiguous_substring(\\"aa\\") 2 >>> longest_contiguous_substring(\\"ab\\") 1","solution":"def longest_contiguous_substring(s): Returns the length of the longest contiguous substring where all characters are the same. Parameters: s (str): Input string consisting of lowercase letters. Returns: int: Length of the longest contiguous substring with identical characters. if not s: return 0 max_len = 1 current_len = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 return max(max_len, current_len)"},{"question":"def is_path_possible(matrix, n, m): Determines if there is a path from the top-left corner to the bottom-right corner moving only through open cells (1s). From a cell, you can only move right or down to an adjacent cell. :param matrix: List[List[int]] - A matrix of size N x M containing 0s (blocked) and 1s (open) :param n: int - Number of rows in the matrix :param m: int - Number of columns in the matrix :return: str - \\"YES\\" if there is a path, otherwise \\"NO\\" >>> is_path_possible([ [1, 0, 0], [1, 1, 0], [0, 1, 1] ], 3, 3) \\"YES\\" >>> is_path_possible([ [1, 0, 0], [0, 1, 0], [0, 0, 1] ], 3, 3) \\"NO\\"","solution":"def is_path_possible(matrix, n, m): Determines if there is a path from the top-left corner to the bottom-right corner. if matrix[0][0] == 0 or matrix[n-1][m-1] == 0: return \\"NO\\" visited = [[False]*m for _ in range(n)] directions = [(1, 0), (0, 1)] def dfs(x, y): if x == n-1 and y == m-1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and matrix[nx][ny] == 1: if dfs(nx, ny): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): # Implementation here def minValueNode(node): # Implementation here def deleteNode(root, key): # Implementation here def inorderTraversal(root, res): # Implementation here # Main function to process operations and output the inorder traversal def bst_operations(operations): Given a series of operations (insertion and deletion) on a Binary Search Tree (BST), returns the inorder traversal of the BST after performing all operations. Parameters: - operations: List of strings where each string represents an operation. The operation is either \\"Insert x\\" or \\"Delete y\\". Returns: - List[int]: The inorder traversal of the BST. Example: >>> bst_operations([\\"Insert 10\\", \\"Insert 5\\", \\"Insert 15\\", \\"Delete 10\\", \\"Insert 20\\"]) [5, 15, 20] >>> bst_operations([\\"Insert 10\\", \\"Delete 10\\"]) [] # Unit Tests def test_sample_input_0(): operations = [ \\"Insert 10\\", \\"Insert 5\\", \\"Insert 15\\", \\"Delete 10\\", \\"Insert 20\\" ] assert bst_operations(operations) == [5, 15, 20] def test_insert_only(): operations = [ \\"Insert 8\\", \\"Insert 3\\", \\"Insert 10\\", \\"Insert 1\\", \\"Insert 6\\", \\"Insert 14\\", \\"Insert 4\\", \\"Insert 7\\", \\"Insert 13\\" ] assert bst_operations(operations) == [1, 3, 4, 6, 7, 8, 10, 13, 14] def test_delete_root(): operations = [ \\"Insert 10\\", \\"Delete 10\\" ] assert bst_operations(operations) == [] def test_delete_leaf(): operations = [ \\"Insert 10\\", \\"Insert 5\\", \\"Insert 15\\", \\"Delete 5\\", \\"Delete 15\\" ] assert bst_operations(operations) == [10] def test_mixed_operations(): operations = [ \\"Insert 20\\", \\"Insert 10\\", \\"Insert 30\\", \\"Delete 20\\", \\"Insert 5\\", \\"Insert 15\\", \\"Delete 10\\", \\"Insert 25\\", \\"Delete 30\\" ] assert bst_operations(operations) == [5, 15, 25]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert(root, key): if root is None: return TreeNode(key) else: if root.val < key: root.right = insert(root.right, key) else: root.left = insert(root.left, key) return root def minValueNode(node): current = node while(current.left is not None): current = current.left return current def deleteNode(root, key): if root is None: return root if key < root.val: root.left = deleteNode(root.left, key) elif key > root.val: root.right = deleteNode(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = minValueNode(root.right) root.val = temp.val root.right = deleteNode(root.right, temp.val) return root def inorderTraversal(root, res): if root: inorderTraversal(root.left, res) res.append(root.val) inorderTraversal(root.right, res) # Main function to process operations and output the inorder traversal def bst_operations(operations): root = None for operation in operations: action, value = operation.split() value = int(value) if action == \\"Insert\\": root = insert(root, value) elif action == \\"Delete\\": root = deleteNode(root, value) result = [] inorderTraversal(root, result) return result"},{"question":"def longest_balanced_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest balanced subsequence in the given sequence of integers. A sequence is balanced if it contains equal numbers of 0s, 1s, and 2s. Args: n (int): The length of the sequence. sequence (List[int]): The list of integers containing values 0, 1, or 2. Returns: int: The length of the longest balanced subsequence. Examples: >>> longest_balanced_subsequence(7, [0, 1, 2, 0, 1, 2, 0]) 6 >>> longest_balanced_subsequence(5, [0, 0, 1, 2, 2]) 3 >>> longest_balanced_subsequence(6, [2, 1, 2, 0, 0, 2]) 3","solution":"def longest_balanced_subsequence(n, sequence): Returns the length of the longest balanced subsequence in the given sequence of integers. A sequence is balanced if it contains equal numbers of 0s, 1s, and 2s. count_0 = count_1 = count_2 = 0 for num in sequence: if num == 0: count_0 += 1 elif num == 1: count_1 += 1 elif num == 2: count_2 += 1 # The longest balanced subsequence length will be 3 * min(count_0, count_1, count_2) return 3 * min(count_0, count_1, count_2)"},{"question":"def compress_string(s: str) -> str: Compresses the input string using the counts of repeated characters. If the compressed string is not smaller than the original string, the function returns the original string. :param s: Input string containing only alphabetic characters :return: Compressed string or the original string if compression does not reduce the string size >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aabcccccaaaZZZZZe\\") 'a2b1c5a3Z5e1' >>> compress_string(\\"aAbBcCdD\\") 'aAbBcCdD'","solution":"def compress_string(s): Compresses the input string using the counts of repeated characters. If the compressed string is not smaller than the original string, the function returns the original string. :param s: Input string containing only alphabetic characters :return: Compressed string or the original string if compression does not reduce the string size if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 compressed.append(s[-1]) compressed.append(str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"from typing import List, Tuple class Competition: def __init__(self): self.points = defaultdict(int) # Participant points self.order = deque() # Order of point updates for handling ties def add_points(self, participant: int, score: int): Adds points to the participant's score. if participant not in self.points: self.order.append(participant) self.points[participant] += score def remove_points(self, participant: int, score: int): Removes points from the participant's score and updates ranking order if necessary. if participant in self.points: self.points[participant] -= score if self.points[participant] <= 0: self.points.pop(participant) self.order.remove(participant) def get_ranks(self) -> List[Tuple[int, int]]: Returns the ranking of participants based on their scores. ranking = sorted( self.points.items(), key=lambda x: (-x[1], self.order.index(x[0])) ) return ranking def process_queries(queries: List[str]) -> List[List[Tuple[int, int]]]: Processes a list of queries and returns the ranking after each 'RANKS' query. >>> process_queries([ ... \\"ADD 1 100\\", ... \\"ADD 2 150\\", ... \\"ADD 3 200\\", ... \\"REMOVE 1 50\\", ... \\"RANKS\\", ... \\"ADD 2 100\\", ... \\"RANKS\\", ... \\"ADD 1 150\\", ... \\"REMOVE 3 100\\", ... \\"RANKS\\" ... ]) [[(3, 200), (2, 150), (1, 50)], [(2, 250), (3, 200), (1, 50)], [(2, 250), (1, 200), (3, 100)] competition = Competition() results = [] for query in queries: parts = query.split() if parts[0] == \\"ADD\\": competition.add_points(int(parts[1]), int(parts[2])) elif parts[0] == \\"REMOVE\\": competition.remove_points(int(parts[1]), int(parts[2])) elif parts[0] == \\"RANKS\\": results.append(competition.get_ranks()) return results","solution":"from collections import defaultdict, deque class Competition: def __init__(self): self.points = defaultdict(int) # Participant points self.order = deque() # Order of point updates for handling ties def add_points(self, participant, score): if participant not in self.points: self.order.append(participant) self.points[participant] += score def remove_points(self, participant, score): if participant in self.points: self.points[participant] -= score if self.points[participant] <= 0: self.points.pop(participant) self.order.remove(participant) def get_ranks(self): ranking = sorted( self.points.items(), key=lambda x: (-x[1], self.order.index(x[0])) ) return ranking # Example usage: competition = Competition() competition.add_points(1, 100) competition.add_points(2, 150) competition.add_points(3, 200) competition.remove_points(1, 50) print(competition.get_ranks()) # [(3, 200), (2, 150), (1, 50)] competition.add_points(2, 100) print(competition.get_ranks()) # [(2, 250), (3, 200), (1, 50)] competition.add_points(1, 150) competition.remove_points(3, 100) print(competition.get_ranks()) # [(2, 250), (1, 200), (3, 100)] # Input processing def process_queries(queries): competition = Competition() results = [] for query in queries: parts = query.split() if parts[0] == \\"ADD\\": competition.add_points(int(parts[1]), int(parts[2])) elif parts[0] == \\"REMOVE\\": competition.remove_points(int(parts[1]), int(parts[2])) elif parts[0] == \\"RANKS\\": results.append(competition.get_ranks()) return results"},{"question":"def can_travel_to_all_cities(n: int, roads: List[List[int]], start: int) -> bool: Determines if it is possible to start from the given city and travel to all other cities without visiting any city more than once. >>> can_travel_to_all_cities(4, [[0, 1], [0, 2], [1, 2], [1, 3]], 0) True >>> can_travel_to_all_cities(4, [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3]], 0) True >>> can_travel_to_all_cities(4, [[0, 1], [1, 2]], 0) False pass def test_can_travel_to_all_cities_example1(): n = 4 roads = [[0, 1], [0, 2], [1, 2], [1, 3]] start = 0 assert can_travel_to_all_cities(n, roads, start) == True def test_can_travel_to_all_cities_example2(): n = 4 roads = [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3]] start = 0 assert can_travel_to_all_cities(n, roads, start) == True def test_can_travel_to_all_cities_example3(): n = 4 roads = [[0, 1], [1, 2]] start = 0 assert can_travel_to_all_cities(n, roads, start) == False def test_can_travel_to_all_cities_disconnected_graph(): n = 5 roads = [[0, 1], [1, 2], [3, 4]] start = 0 assert can_travel_to_all_cities(n, roads, start) == False def test_can_travel_to_all_cities_fully_connected_graph(): n = 3 roads = [[0, 1], [0, 2], [1, 2]] start = 1 assert can_travel_to_all_cities(n, roads, start) == True def test_can_travel_to_all_cities_single_road_segment(): n = 2 roads = [[0, 1]] start = 0 assert can_travel_to_all_cities(n, roads, start) == True def test_can_travel_to_all_cities_start_in_disconnected_component(): n = 3 roads = [[0, 1]] start = 2 assert can_travel_to_all_cities(n, roads, start) == False","solution":"def can_travel_to_all_cities(n, roads, start): Determines if it is possible to start from the given city and travel to all other cities without visiting any city more than once. :param n: int, number of cities :param roads: List[List[int]], list of direct road segments represented as pairs of cities [city1, city2] :param start: int, the starting city :return: bool, True if it's possible to travel to all cities, otherwise False from collections import defaultdict, deque def bfs(start, graph, visited): queue = deque([start]) visited.add(start) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) graph = defaultdict(list) for city1, city2 in roads: graph[city1].append(city2) graph[city2].append(city1) visited = set() bfs(start, graph, visited) return len(visited) == n"},{"question":"from collections import deque def shortest_path_forest(m: int, n: int, grid: List[str]) -> int: Calculate the shortest path from the top-left corner to the bottom-right corner in a forest. Each cell can either be open ('.') or blocked ('#'). If no path exists, return -1. >>> shortest_path_forest(4, 4, [\\"....\\", \\"#.#.\\", \\"....\\", \\"#.\\"]) 7 >>> shortest_path_forest(4, 4, [\\"....\\", \\"\\", \\"\\", \\"\\"]) -1 >>> shortest_path_forest(2, 2, [\\"..\\", \\"..\\"]) 3 >>> shortest_path_forest(3, 3, [\\"#\\", \\"#..\\", \\"#..\\"]) -1","solution":"from collections import deque def shortest_path_forest(m, n, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 # Directions for moving up, down, left, right directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Queue for BFS (position, distance) queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist + 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_profit(prices): Calculate the maximum profit possible from a single buy-sell transaction. :param prices: List of book prices on consecutive days. :return: Maximum profit possible. If no profit is possible, return 0. >>> max_profit([10, 7, 5, 8, 11, 9]) 6 >>> max_profit([10, 9, 8, 7, 6]) 0 >>> max_profit([5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1, 2]) 1 >>> max_profit([3, 3, 3, 3]) 0 >>> max_profit([]) 0","solution":"def max_profit(prices): Calculate the maximum profit possible from a single buy-sell transaction. :param prices: List of book prices on consecutive days. :return: Maximum profit possible. If no profit is possible, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: min_price = min(min_price, price) potential_profit = price - min_price max_profit = max(max_profit, potential_profit) return max_profit"},{"question":"def can_complete_training(m: int, distances: List[int]) -> str: Determine if Daniel can complete his training plan without violating the rule of taking a rest day after every three consecutive running days. >>> can_complete_training(6, [5, 5, 5, 0, 10, 15]) \\"Possible\\" >>> can_complete_training(4, [3, 3, 3, 3]) \\"Not possible\\"","solution":"def can_complete_training(m, distances): consecutive_running_days = 0 for distance in distances: if distance > 0: consecutive_running_days += 1 if consecutive_running_days > 3: return \\"Not possible\\" else: consecutive_running_days = 0 return \\"Possible\\""},{"question":"def check_tic_tac_toe(board: List[List[str]]) -> str: Determine the winner of a classic game of Tic-Tac-Toe. This function receives a 2D list representing a 3x3 Tic-Tac-Toe board where each entry is either \\"X\\", \\"O\\", or \\"\\" (an empty string). It returns a string indicating the winner of the game: either \\"X\\", \\"O\\", \\"Draw\\" if there is no winner but all cells are filled, or \\"Pending\\" if there are still empty cells and no winner. >>> check_tic_tac_toe([ [\\"X\\", \\"O\\", \\"X\\"], [\\"O\\", \\"X\\", \\"O\\"], [\\"\\", \\"O\\", \\"X\\"] ]) \\"X\\" >>> check_tic_tac_toe([ [\\"X\\", \\"O\\", \\"X\\"], [\\"X\\", \\"X\\", \\"O\\"], [\\"O\\", \\"X\\", \\"O\\"] ]) \\"Draw\\" >>> check_tic_tac_toe([ [\\"X\\", \\"O\\", \\"\\"], [\\"\\", \\"X\\", \\"O\\"], [\\"\\", \\"\\", \\"\\"] ]) \\"Pending\\"","solution":"def check_tic_tac_toe(board): for i in range(3): # Check rows if board[i][0] == board[i][1] == board[i][2] != \\"\\": return board[i][0] # Check columns if board[0][i] == board[1][i] == board[2][i] != \\"\\": return board[0][i] # Check diagonals if board[0][0] == board[1][1] == board[2][2] != \\"\\": return board[0][0] if board[0][2] == board[1][1] == board[2][0] != \\"\\": return board[0][2] # Check for empty cells for row in board: if \\"\\" in row: return \\"Pending\\" return \\"Draw\\""},{"question":"def can_form(s: str, word: str) -> bool: Check if \`word\` can be formed by deleting some characters from \`s\`. >>> can_form(\\"abpcplea\\", \\"apple\\") True >>> can_form(\\"abpcplea\\", \\"ale\\") True >>> can_form(\\"abpcplea\\", \\"monkey\\") False >>> can_form(\\"abpcplea\\", \\"plea\\") True >>> can_form(\\"abpcplea\\", \\"applz\\") False def find_longest_word(s: str, d: List[str]) -> str: Return the longest word in \`d\` that can be formed by deleting some characters from the given string \`s\`. If there are more than one possible results, return the word which appears first in the dictionary. If there are no possible results, return an empty string. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) \\"a\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\", \\"apple\\"]) \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"dog\\", \\"cat\\", \\"horse\\"]) \\"\\" >>> find_longest_word(\\"abpcplea\\", [\\"plea\\", \\"ale\\"]) \\"plea\\" >>> find_longest_word(\\"abpcplea\\", [\\"pleb\\", \\"ale\\"]) \\"ale\\" >>> find_longest_word(\\"abc\\", [\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) \\"abc\\" >>> find_longest_word(\\"abcdefg\\", [\\"abcd\\", \\"bf\\", \\"abc\\", \\"cde\\"]) \\"abcd\\"","solution":"def can_form(s, word): Helper function to determine if \`word\` can be formed by deleting some characters from \`s\`. it = iter(s) return all(char in it for char in word) def find_longest_word(s, d): Returns the longest word in \`d\` that can be formed by deleting some characters from the given string \`s\`. If there are more than one possible results, returns the word which appears first in the dictionary. If there are no possible results, returns an empty string. longest_word = \\"\\" for word in d: if can_form(s, word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def flatten_dict(d, parent_key='', sep='.'): Takes a dictionary which may contain nested dictionaries and returns a flattened dictionary. pass def test_flatten_dict_with_nested_dicts(): input_dict = { 'a': 1, 'b': { 'c': 2, 'd': { 'e': 3 } }, 'f': { 'g': 4 } } expected_output = { 'a': 1, 'b.c': 2, 'b.d.e': 3, 'f.g': 4 } assert flatten_dict(input_dict) == expected_output def test_flatten_dict_with_no_nested_dicts(): input_dict = { 'a': 1, 'b': 2, 'c': 3 } expected_output = { 'a': 1, 'b': 2, 'c': 3 } assert flatten_dict(input_dict) == expected_output def test_flatten_dict_with_empty_dict(): input_dict = {} expected_output = {} assert flatten_dict(input_dict) == expected_output def test_flatten_dict_with_non_string_keys(): input_dict = { 1: { 2: 3 } } expected_output = { '1.2': 3 } assert flatten_dict(input_dict) == expected_output def test_flatten_dict_with_single_nested_level(): input_dict = { 'a': 1, 'b': { 'c': 2 } } expected_output = { 'a': 1, 'b.c': 2 } assert flatten_dict(input_dict) == expected_output","solution":"def flatten_dict(d, parent_key='', sep='.'): Takes a dictionary which may contain nested dictionaries and returns a flattened dictionary. flattened = {} for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): flattened.update(flatten_dict(v, new_key, sep=sep)) else: flattened[new_key] = v return flattened"},{"question":"def validate_messages(messages: List[str]) -> List[str]: Validates each message by ensuring: 1. Each word contains only lowercase English letters. 2. No word is repeated within a single message. 3. All words are sorted in lexicographical order. Parameters: messages (list of str): List of messages to be validated. Returns: list of str: List of results (\\"VALID\\" or \\"INVALID\\") for each message. >>> validate_messages([\\"a b c d\\"]) [\\"VALID\\"] >>> validate_messages([\\"hello world\\"]) [\\"VALID\\"] >>> validate_messages([\\"apple banana apple\\"]) [\\"INVALID\\"] >>> validate_messages([\\"zoo apple banana\\"]) [\\"INVALID\\"] >>> validate_messages([\\"banana apple\\"]) [\\"INVALID\\"] >>> validate_messages([\\"Quick brown fox\\"]) [\\"INVALID\\"] >>> validate_messages([\\"apples bananas cherries\\"]) [\\"VALID\\"] >>> validate_messages([\\"\\"]) [\\"VALID\\"] >>> validate_messages([\\"abcd efgh ijkl mnop\\"]) [\\"VALID\\"] pass","solution":"def validate_messages(messages): Validates each message by ensuring: 1. Each word contains only lowercase English letters. 2. No word is repeated within a single message. 3. All words are sorted in lexicographical order. Parameters: messages (list of str): List of messages to be validated. Returns: list of str: List of results (\\"VALID\\" or \\"INVALID\\") for each message. results = [] for message in messages: words = message.split() if any(not word.islower() or not word.isalpha() for word in words): results.append(\\"INVALID\\") continue if len(words) != len(set(words)): results.append(\\"INVALID\\") continue if words != sorted(words): results.append(\\"INVALID\\") continue results.append(\\"VALID\\") return results"},{"question":"from typing import List, Tuple def process_queries(n: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[str]: Process queries to determine the weight of the heaviest edge on the path from node u to node v in a tree. Args: n (int): number of nodes in the tree. edges (List[Tuple[int, int, int]]): list of edges in the tree where each edge is represented by a tuple (u, v, w). queries (List[Tuple[int, int]]): list of queries where each query is a tuple (u, v) asking for the heaviest edge in the path from u to v. Returns: List[str]: list of results for each query. Examples: >>> process_queries(5, [(1, 2, 4), (1, 3, 2), (3, 4, 3), (3, 5, 1)], [(2, 4), (1, 5), (4, 5)]) ['4', '2', '3'] >>> process_queries(1, [], [(1, 1)]) ['0'] >>> process_queries(2, [(1, 2, 3)], [(1, 2)]) ['3'] # Unit tests for the function def test_example_case_multiple_queries(): n = 5 edges = [(1, 2, 4), (1, 3, 2), (3, 4, 3), (3, 5, 1)] queries = [(2, 4), (1, 5), (4, 5)] expected_output = ['4', '2', '3'] assert process_queries(n, edges, queries) == expected_output def test_single_node_tree(): n = 1 edges = [] queries = [(1, 1)] expected_output = ['0'] assert process_queries(n, edges, queries) == expected_output def test_single_edge_tree(): n = 2 edges = [(1, 2, 3)] queries = [(1, 2)] expected_output = ['3'] assert process_queries(n, edges, queries) == expected_output def test_larger_tree(): n = 6 edges = [(1, 2, 1), (1, 3, 2), (3, 4, 3), (3, 5, 4), (5, 6, 5)] queries = [(2, 4), (4, 6), (2, 6)] expected_output = ['3', '5', '5'] assert process_queries(n, edges, queries) == expected_output def test_complex_tree(): n = 7 edges = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4), (5, 6, 5), (6, 7, 6)] queries = [(1, 7), (2, 6), (3, 5)] expected_output = ['6', '5', '4'] assert process_queries(n, edges, queries) == expected_output","solution":"import sys from collections import defaultdict import heapq sys.setrecursionlimit(500000) input = sys.stdin.read def prepare_lca(n, edges): # adjacency list for the graph graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # log base 2 of the number of nodes LOG = 20 # Initializing required structures up = [[-1] * LOG for _ in range(n + 1)] max_edge = [[0] * LOG for _ in range(n + 1)] depth = [-1] * (n + 1) # Depth-first search to populate up, max_edge and depth structures def dfs(v, parent, weight): up[v][0] = parent max_edge[v][0] = weight for i in range(1, LOG): if up[v][i - 1] != -1: up[v][i] = up[up[v][i - 1]][i - 1] max_edge[v][i] = max(max_edge[v][i - 1], max_edge[up[v][i - 1]][i - 1]) for to, to_weight in graph[v]: if to != parent: depth[to] = depth[v] + 1 dfs(to, v, to_weight) depth[1] = 0 dfs(1, -1, 0) return up, max_edge, depth def lca(u, v, up, max_edge, depth): LOG = 20 if depth[u] < depth[v]: u, v = v, u max_on_path = 0 # Bring u and v to the same depth for i in range(LOG - 1, -1, -1): if depth[u] - (1 << i) >= depth[v]: max_on_path = max(max_on_path, max_edge[u][i]) u = up[u][i] if u == v: return max_on_path # Move both up until we find the LCA for i in range(LOG - 1, -1, -1): if up[u][i] != up[v][i]: max_on_path = max(max_on_path, max_edge[u][i], max_edge[v][i]) u = up[u][i] v = up[v][i] return max(max_on_path, max_edge[u][0], max_edge[v][0]) def process_queries(n, edges, queries): up, max_edge, depth = prepare_lca(n, edges) results = [] for u, v in queries: results.append(str(lca(u, v, up, max_edge, depth))) return results def main(): data = input().split() index = 0 n = int(data[index]) index += 1 q = int(data[index]) index += 1 edges = [] for _ in range(n - 1): u = int(data[index]) index += 1 v = int(data[index]) index += 1 w = int(data[index]) index += 1 edges.append((u, v, w)) queries = [] for _ in range(q): u = int(data[index]) index += 1 v = int(data[index]) index += 1 queries.append((u, v)) results = process_queries(n, edges, queries) for result in results: print(result)"},{"question":"def find_zero_sum_triplets(arr): Finds all unique triplets in the array which sum to zero. Args: arr: List[int] : list of integers Returns: List[List[int]] : list of lists, each containing a triplet pass def process_test_cases(test_cases): Process multiple test cases to find all unique triplets that sum to zero. Args: test_cases: List[Tuple[int, List[int]]] : list of test cases, each containing the size of array and the array itself Returns: List[List[List[int]]] : list of results, each result is a list of triplets for respective test case pass def test_find_zero_sum_triplets(): assert sorted(find_zero_sum_triplets([-1, 0, 1, 2, -1, -4])) == sorted([[-1, -1, 2], [-1, 0, 1]]) assert find_zero_sum_triplets([0, 0, 0]) == [[0, 0, 0]] assert sorted(find_zero_sum_triplets([-2, 0, 1, 1, 2])) == sorted([[-2, 0, 2], [-2, 1, 1]]) assert find_zero_sum_triplets([1, 2, 3]) == [] assert sorted(find_zero_sum_triplets([-1, 0, 1, 0])) == sorted([[-1, 0, 1]]) def test_process_test_cases(): test_cases = [ (6, [-1, 0, 1, 2, -1, -4]), (3, [0, 0, 0]) ] results = [ [[-1, -1, 2], [-1, 0, 1]], [[0, 0, 0]] ] assert [sorted(triplet) for triplet in process_test_cases(test_cases)[0]] == sorted(results[0]) assert process_test_cases(test_cases) == results","solution":"def find_zero_sum_triplets(arr): Finds all unique triplets in the array which sum to zero. Args: arr: List[int] : list of integers Returns: List[List[int]] : list of lists, each containing a triplet arr.sort() res = [] for i in range(len(arr) - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, len(arr) - 1 while left < right: s = arr[i] + arr[left] + arr[right] if s < 0: left += 1 elif s > 0: right -= 1 else: res.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 return res def process_test_cases(test_cases): results = [] for case in test_cases: N, arr = case if N < 3: results.append([]) else: results.append(find_zero_sum_triplets(arr)) return results"},{"question":"def average_speed(speeds: List[float]) -> float: Returns the average speed from a list of speeds. Args: speeds (List[float]): A list of speeds in km/h. All speeds are non-negative numbers. Returns: float: The average speed rounded to 2 decimal places. If the list is empty, return 0. >>> average_speed([20, 25, 30, 35, 40]) == 30.0 >>> average_speed([15, 10, 20]) == 15.0 >>> average_speed([]) == 0 >>> average_speed([0, 0, 0]) == 0.0 >>> average_speed([10, 20, 30, 40, 50]) == 30.0 >>> average_speed([7.3, 7.9, 6.8, 8.2]) == 7.55 >>> average_speed([13.333, 13.666, 13.5]) == 13.5 >>> average_speed([42]) == 42.0 >>> average_speed([0]) == 0.0","solution":"def average_speed(speeds): Returns the average speed from a list of speeds. Args: speeds (List[float]): A list of speeds in km/h. All speeds are non-negative numbers. Returns: float: The average speed rounded to 2 decimal places. If the list is empty, return 0. if not speeds: return 0 average = sum(speeds) / len(speeds) return round(average, 2)"},{"question":"def reverse_words(s: str) -> str: Reverses the words in input string s. :param s: Input string containing words separated by spaces :return: String with words in reverse order >>> reverse_words(\\" hello world \\") \\"world hello\\" >>> reverse_words(\\"a good example\\") \\"example good a\\" def test_with_leading_trailing_spaces(): assert reverse_words(\\" hello world \\") == \\"world hello\\" def test_with_multiple_spaces_between_words(): assert reverse_words(\\"a good example\\") == \\"example good a\\" def test_single_word(): assert reverse_words(\\"hello\\") == \\"hello\\" def test_empty_string(): assert reverse_words(\\"\\") == \\"\\" def test_multiple_spaces(): assert reverse_words(\\" \\") == \\"\\" def test_with_mixed_case_words(): assert reverse_words(\\"The Sky Is Blue\\") == \\"Blue Is Sky The\\" def test_with_punctuation(): assert reverse_words(\\"hello, world!\\") == \\"world! hello,\\" def test_long_string(): assert reverse_words(\\"This is a very very long string with many words\\") == \\"words many with string long very very a is This\\"","solution":"def reverse_words(s): Reverses the words in input string s. :param s: Input string containing words separated by spaces :return: String with words in reverse order words = s.split() return ' '.join(reversed(words))"},{"question":"from typing import List def rearrange_string(s: str) -> str: You are given a string consisting of lowercase English letters and you need to transform it into a string where no two adjacent characters are the same by possibly rearranging the characters. If it is not possible to obtain such a string, return \\"NO\\". >>> rearrange_string(\\"aabb\\") 'abab' >>> rearrange_string(\\"aaab\\") 'NO' >>> rearrange_string(\\"a\\") 'a'","solution":"from collections import Counter import heapq def rearrange_string(s): char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_count, prev_char = count + 1, char rearranged = ''.join(result) return rearranged if len(rearranged) == len(s) else \\"NO\\""},{"question":"from typing import List, Tuple def longest_non_decreasing_subsequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a sequence of integers, find the longest subsequence that is in non-decreasing order, considering only the elements at even indices in the original sequence. An element at index i is considered to be at an even index if i is an even number. >>> longest_non_decreasing_subsequence(2, [(5, [1, 3, 2, 4, 3]), (6, [4, 6, 1, 5, 3, 8])]) [3, 2] >>> longest_non_decreasing_subsequence(1, [(4, [4, 4, 4, 4])]) [2]","solution":"def longest_non_decreasing_subsequence(T, test_cases): results = [] for i in range(T): N, sequence = test_cases[i] even_indices_elements = [sequence[j] for j in range(0, N, 2)] longest_length = 1 current_length = 1 for k in range(1, len(even_indices_elements)): if even_indices_elements[k] >= even_indices_elements[k-1]: current_length += 1 else: longest_length = max(longest_length, current_length) current_length = 1 longest_length = max(longest_length, current_length) results.append(longest_length) return results"},{"question":"def manage_stock(n: int, q: int, stocks: List[int], queries: List[Tuple[int, ...]]) -> List[int]: Function to manage stock of multiple products and handle queries. Parameters: n (int): Number of products. q (int): Number of queries. stocks (list of int): Initial stock of each product. queries (list of tuples): List of queries where each query is a tuple (1 x y) or (2 x). Returns: list of int: The results of all type-2 queries. >>> manage_stock(5, 3, [10, 20, 30, 40, 50], [(2, 2), (1, 2, 100), (2, 2)]) [30, 100] >>> manage_stock(3, 3, [10, 20, 30], [(2, 0), (2, 1), (2, 2)]) [10, 20, 30] >>> manage_stock(3, 3, [10, 20, 30], [(1, 0, 100), (1, 1, 200), (1, 2, 300)]) [] >>> manage_stock(4, 5, [5, 10, 15, 20], [(1, 0, 9), (2, 0), (1, 1, 19), (2, 1), (2, 2)]) [9, 19, 15] >>> manage_stock(2, 2, [0, 1000000000], [(2, 1), (1, 1, 500000000)]) [1000000000]","solution":"def manage_stock(n, q, stocks, queries): Function to manage stock of multiple products and handle queries. Parameters: n (int): Number of products. q (int): Number of queries. stocks (list of int): Initial stock of each product. queries (list of tuples): List of queries where each query is a tuple. Returns: list of int: The results of all type-2 queries. # Convert stock list to mutable list if needed stock_list = stocks # Results of type-2 queries results = [] # Process each query for query in queries: if query[0] == 1: # Update the stock of the x-th product to y _, x, y = query stock_list[x] = y elif query[0] == 2: # Return the current stock of the x-th product _, x = query results.append(stock_list[x]) return results"},{"question":"def can_partition(nums, K, max_sum): Helper function to determine if we can partition the array into at most K subarrays with each subarray having a sum less than or equal to max_sum. def min_max_cost_partition(C, N, K): Returns the minimum possible total cost of partitioning the array into exactly K subarrays. >>> min_max_cost_partition([1, 2, 3, 4, 5], 5, 3) 6 >>> min_max_cost_partition([1, 2, 3, 4, 5], 5, 2) 9 >>> min_max_cost_partition([10], 1, 1) 10 >>> min_max_cost_partition([5, 5, 5, 5], 4, 2) 10 >>> min_max_cost_partition([1, 2, 1, 2, 1], 5, 5) 2 >>> min_max_cost_partition([1, 2, 3, 4, 5, 1000000000], 6, 3) 1000000000","solution":"def can_partition(nums, K, max_sum): Helper function to determine if we can partition the array into at most K subarrays with each subarray having a sum less than or equal to max_sum. current_sum = 0 current_k = 1 for num in nums: if current_sum + num > max_sum: current_k += 1 current_sum = num if current_k > K: return False else: current_sum += num return True def min_max_cost_partition(C, N, K): Returns the minimum possible total cost of partitioning the array into exactly K subarrays. low, high = max(C), sum(C) while low < high: mid = (low + high) // 2 if can_partition(C, K, mid): high = mid else: low = mid + 1 return low"},{"question":"def can_robots_reach_charging_station(t: int, cases: List[Dict[str, Union[int, List[int]]]]) -> List[str]: Determine if all robots can reach the charging station given their initial positions and maximum distances they can travel. >>> can_robots_reach_charging_station(3, [ ... {\\"n\\": 3, \\"positions\\": [10, 5, 15], \\"distances\\": [10, 5, 15]}, ... {\\"n\\": 4, \\"positions\\": [1, 10, 100, 1000], \\"distances\\": [2, 20, 200, 2000]}, ... {\\"n\\": 2, \\"positions\\": [50, 100], \\"distances\\": [30, 70]} ... ]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_robots_reach_charging_station(2, [ ... {\\"n\\": 1, \\"positions\\": [1], \\"distances\\": [2]}, ... {\\"n\\": 1, \\"positions\\": [2], \\"distances\\": [1]} ... ]) [\\"YES\\", \\"NO\\"] >>> can_robots_reach_charging_station(1, [ ... {\\"n\\": 1, \\"positions\\": [10**9], \\"distances\\": [10**9]} ... ]) [\\"YES\\"]","solution":"def can_robots_reach_charging_station(t, cases): results = [] for i in range(t): n = cases[i]['n'] positions = cases[i]['positions'] distances = cases[i]['distances'] can_reach = all(positions[j] <= distances[j] for j in range(n)) if can_reach: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"class Warehouse: def __init__(self): self.inventory = [] def add_box(self, weight): Add a box with a specific weight to the warehouse. pass def remove_boxes(self, q): Remove q boxes with the lowest weights from the warehouse. pass def count_boxes_greater_than(self, weight): Count the number of boxes in the warehouse with weight greater than a specific value. pass def manage_warehouse(n, operations): Manage the inventory of boxes in a warehouse based on a sequence of operations. Args: n (int): Number of operations operations (list of str): List of operation strings Returns: list of int: The result of each 'C' query >>> manage_warehouse(6, [\\"A 10\\", \\"A 20\\", \\"A 15\\", \\"C 10\\", \\"R 2\\", \\"C 10\\"]) [2, 1] >>> manage_warehouse(4, [\\"A 10\\", \\"A 5\\", \\"R 1\\", \\"C 3\\"]) [1] pass","solution":"import bisect class Warehouse: def __init__(self): self.inventory = [] def add_box(self, weight): bisect.insort(self.inventory, weight) def remove_boxes(self, q): self.inventory = self.inventory[min(len(self.inventory), q):] def count_boxes_greater_than(self, weight): idx = bisect.bisect_right(self.inventory, weight) return len(self.inventory) - idx def manage_warehouse(n, operations): warehouse = Warehouse() results = [] for op in operations: cmd, val = op.split() val = int(val) if cmd == 'A': warehouse.add_box(val) elif cmd == 'R': warehouse.remove_boxes(val) elif cmd == 'C': results.append(warehouse.count_boxes_greater_than(val)) return results"},{"question":"def count_valid_colorings(n: int, heights: List[int]) -> int: Determine the number of valid ways to color the buildings such that no two adjacent buildings are painted the same color. >>> count_valid_colorings(1, [2]) 3 >>> count_valid_colorings(2, [2, 3]) 6 >>> count_valid_colorings(3, [2, 3, 1]) 12 >>> count_valid_colorings(4, [2, 3, 1, 4]) 24 >>> count_valid_colorings(5, [2, 3, 1, 4, 5]) 48 >>> count_valid_colorings(3, [1, 1, 1]) 12 >>> count_valid_colorings(2, [1000, 999]) 6","solution":"def count_valid_colorings(n, heights): # There are 3 choices for the first building # and 2 choices for each subsequent building if n == 1: return 3 else: return 3 * (2 ** (n - 1)) # Input reading if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) heights = list(map(int, data[1:])) # Output the result print(count_valid_colorings(n, heights))"},{"question":"from typing import List def longest_palindrome(s: str) -> int: Given a string s, returns the length of the longest palindromic string that can be created by rearranging the given string and possibly removing one character. >>> longest_palindrome(\\"abccccdd\\") 7 >>> longest_palindrome(\\"a\\") 1 >>> longest_palindrome(\\"aabbcc\\") 6 >>> longest_palindrome(\\"abc\\") 1 >>> longest_palindrome(\\"aaaabbbbcccd\\") 11 >>> longest_palindrome(\\"a\\" * 50000 + \\"b\\" * 50000) 100000 >>> longest_palindrome(\\"a\\" * 49999 + \\"b\\" * 50000) 99999 >>> longest_palindrome(\\"aaabb\\") 5 >>> longest_palindrome(\\"aabbccddeef\\") 11 >>> longest_palindrome(\\"\\") 0 pass","solution":"def longest_palindrome(s): Given a string s, returns the length of the longest palindromic string that can be created by rearranging the given string and possibly removing one character. from collections import Counter count = Counter(s) length = 0 odd_found = False for char in count: if count[char] % 2 == 0: length += count[char] else: length += count[char] - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"import heapq from typing import List, Dict def min_total_time(t: int, cases: List[Dict[str, List[int]]]) -> List[int]: Determines the minimum total time required to complete all tasks given the number of parallel slots. Parameters: - t (int): The number of test cases. - cases (List[Dict[str, int]]): List of dictionaries where each dictionary contains: * 'slots' (int): Number of parallel task slots. * 'tasks' (List[int]): List of integers representing the time required for each task. Returns: - List[int]: The minimum total time required for each test case. Example usage: >>> min_total_time(2, [{'slots': 2, 'tasks': [5, 3, 8, 6]}, {'slots': 3, 'tasks': [4, 2, 7, 3, 9]}]) [11, 13] >>> min_total_time(1, [{'slots': 10, 'tasks': [6, 2, 4]}]) [6] pass","solution":"from heapq import heappop, heappush def min_total_time(t, cases): results = [] for case in cases: S, tasks = case['slots'], case['tasks'] # Min-heap to simulate the parallel slots with task end times heap = [] for task in tasks: if len(heap) < S: heappush(heap, task) else: min_time = heappop(heap) heappush(heap, min_time + task) while len(heap) > 1: heappop(heap) results.append(heappop(heap)) return results"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Implement a function that takes a list of integers \`arr\` and returns the length of the longest increasing subsequence that can be found in the list. A subsequence is a sequence derived by deleting some or none of the elements of the array without changing the order of the remaining elements. An increasing subsequence means that the elements of the subsequence are in sorted order. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) 1 def test_longest_increasing_subsequence_example_1(): assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_longest_increasing_subsequence_example_2(): assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 def test_longest_increasing_subsequence_example_3(): assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7]) == 1 def test_longest_increasing_subsequence_single_element(): assert longest_increasing_subsequence([10]) == 1 def test_longest_increasing_subsequence_empty(): assert longest_increasing_subsequence([]) == 0 def test_longest_increasing_subsequence_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 def test_longest_increasing_subsequence_continuous_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == 5 def test_longest_increasing_subsequence_multiple_increasing_sequences(): assert longest_increasing_subsequence([3, 4, 2, 1, 10, 6]) == 3","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the list \`arr\`. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def categorize_books(books): Categorizes books into three categories based on the number of pages. Parameters: books (list): List of dictionaries where each dictionary represents a book. Returns: dict: A dictionary with three keys: 'short', 'medium', 'long'. Each key contains a list of book titles that fall into that category. Examples: >>> categorize_books([{'title': 'Book A', 'author': 'Author A', 'pages': 50}, {'title': 'Book B', 'author': 'Author B', 'pages': 150}, {'title': 'Book C', 'author': 'Author C', 'pages': 350}]) {'short': ['Book A'], 'medium': ['Book B'], 'long': ['Book C']} >>> categorize_books([]) {'short': [], 'medium': [], 'long': []} >>> categorize_books([{'title': 'Book A', 'author': 'Author A', 'pages': 30}, {'title': 'Book B', 'author': 'Author B', 'pages': 40}]) {'short': ['Book A', 'Book B'], 'medium': [], 'long': []}","solution":"def categorize_books(books): Categorizes books into three categories based on the number of pages. Parameters: books (list): List of dictionaries where each dictionary represents a book. Returns: dict: A dictionary with three keys: 'short', 'medium', 'long'. Each key contains a list of book titles that fall into that category. categories = { 'short': [], 'medium': [], 'long': [] } for book in books: if book['pages'] < 100: categories['short'].append(book['title']) elif 100 <= book['pages'] <= 300: categories['medium'].append(book['title']) else: categories['long'].append(book['title']) return categories"},{"question":"def find_duplicates(batches: List[Tuple[int, List[int]]]) -> List[str]: Given details of multiple batches of stamps, find and return the duplicate stamps in each batch. >>> find_duplicates([(5, [1, 2, 3, 4, 5])]) [\\"No duplicates\\"] >>> find_duplicates([(6, [1, 2, 3, 4, 2, 1])]) [\\"1 2\\"] >>> find_duplicates([(5, [1, 2, 3, 4, 5]), (6, [1, 2, 3, 4, 2, 1]), (4, [7, 8, 9, 7])]) [\\"No duplicates\\", \\"1 2\\", \\"7\\"] >>> find_duplicates([(3, [5, 5, 5])]) [\\"5\\"] >>> find_duplicates([(10, [1, 1, 2, 2, 3, 4, 5, 5, 6, 7])]) [\\"1 2 5\\"]","solution":"def find_duplicates(batches): Given details of multiple batches of stamps, find and return the duplicate stamps in each batch. :param batches: List of tuples [(m, stamps)] :return: List of strings, where each string contains duplicate stamp IDs or \\"No duplicates\\" results = [] for m, stamps in batches: counter = {} for stamp in stamps: if stamp in counter: counter[stamp] += 1 else: counter[stamp] = 1 duplicates = [stamp for stamp, count in counter.items() if count > 1] if duplicates: results.append(\\" \\".join(map(str, duplicates))) else: results.append(\\"No duplicates\\") return results"},{"question":"from typing import List def peak_array(arr: List[int]) -> List[int]: Determines if a given permutation of integers can be rearranged to form a peak array. >>> peak_array([3, 1, 2, 7, 4, 6]) [3, 1, 4, 2, 7, 6] >>> peak_array([1, 2, 3, 4, 5]) [5, 1, 4, 2, 3] >>> peak_array([1, 1, 1, 1, 1, 1, 1]) [] >>> peak_array([1]) [1]","solution":"from typing import List def peak_array(arr: List[int]) -> List[int]: if not arr or len(arr) == 1: return arr arr.sort() n = len(arr) peak_arr = [0] * n left = 0 right = n - 1 for i in range(n): if i % 2 == 0: peak_arr[i] = arr[right] right -= 1 else: peak_arr[i] = arr[left] left += 1 for i in range(1, n, 2): if peak_arr[i] >= peak_arr[i - 1] or (i + 1 < n and peak_arr[i] >= peak_arr[i + 1]): return [] return peak_arr"},{"question":"class TextEditor: def __init__(self): Initializes the text editor with an empty text and an empty list to track operations. self.text = \\"\\" self.operations = [] def append(self, string): Appends the given string to the end of the current text. self.operations.append((\\"append\\", string)) self.text += string def delete(self, k): Deletes the last 'k' characters from the current text. deleted_text = self.text[-k:] self.operations.append((\\"delete\\", deleted_text)) self.text = self.text[:-k] def undo(self): Reverts the last append or delete operation. if not self.operations: return last_operation, value = self.operations.pop() if last_operation == \\"append\\": self.text = self.text[:len(self.text) - len(value)] print(self.text) elif last_operation == \\"delete\\": self.text += value # Function to process a list of operations on the text editor def process_operations(ops): Processes a list of operations on the text editor. Args: ops: A list of operations in the form of strings. Each operation is of the form: - \\"append string\\": Appends the given string to the current text. - \\"delete k\\": Deletes the last 'k' characters from the current text. - \\"undo\\": Reverts the last append or delete operation. For each undo that reverts an append operation, print the current state of the text. Example: >>> ops = [\\"append hello\\", \\"append world\\", \\"delete 5\\", \\"append !\\", \\"undo\\", \\"append .\\", \\"undo\\"] >>> process_operations(ops) hello hello world hello editor = TextEditor() for op in ops: if op.startswith(\\"append\\"): editor.append(op.split(\\" \\", 1)[1]) elif op.startswith(\\"delete\\"): editor.delete(int(op.split(\\" \\")[1])) elif op.startswith(\\"undo\\"): editor.undo()","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.operations = [] def append(self, string): self.operations.append((\\"append\\", string)) self.text += string def delete(self, k): deleted_text = self.text[-k:] self.operations.append((\\"delete\\", deleted_text)) self.text = self.text[:-k] def undo(self): if not self.operations: return last_operation, value = self.operations.pop() if last_operation == \\"append\\": self.text = self.text[:len(self.text) - len(value)] print(self.text) elif last_operation == \\"delete\\": self.text += value # Function to process a list of operations on the text editor def process_operations(ops): editor = TextEditor() for op in ops: if op.startswith(\\"append\\"): editor.append(op.split(\\" \\", 1)[1]) elif op.startswith(\\"delete\\"): editor.delete(int(op.split(\\" \\")[1])) elif op.startswith(\\"undo\\"): editor.undo()"},{"question":"def word_break(s: str, word_dict: List[str]) -> str: Determines if s can be segmented into a space-separated sequence of one or more dictionary words. :param s: String to be segmented :param word_dict: List of words (dictionary) :return: \\"Yes\\" if segmentation is possible, otherwise \\"No\\" >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 'Yes' >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) 'No' >>> word_break(\\"apple\\", [\\"apple\\"]) 'Yes' >>> word_break(\\"banana\\", [\\"apple\\", \\"orange\\"]) 'No' >>> word_break(\\"ratcatdogcat\\", [\\"cat\\", \\"rat\\", \\"dog\\"]) 'Yes' >>> word_break(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) 'Yes' >>> word_break(\\"\\", [\\"a\\"]) 'Yes'","solution":"def word_break(s, word_dict): Determines if s can be segmented into a space-separated sequence of one or more dictionary words. :param s: String to be segmented :param word_dict: List of words (dictionary) :return: \\"Yes\\" if segmentation is possible, otherwise \\"No\\" word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"Yes\\" if dp[-1] else \\"No\\""},{"question":"def max_rectangle_area_with_X(N, M, field): Identify the largest rectangular sub-field that contains only the character 'X'. Args: N (int): Number of rows in the field. M (int): Number of columns in the field. field (List[str]): List of strings representing the field, where each character is either 'X' or '.'. Returns: int: The area of the largest rectangular sub-field that contains only 'X'. Examples: >>> max_rectangle_area_with_X(4, 5, [\\"X.X.X\\", \\"XX..X\\", \\"XXXX.\\", \\"XXX.X\\"]) 6 >>> max_rectangle_area_with_X(3, 3, [\\"...\\", \\"XXX\\", \\"XXX\\"]) 6 >>> max_rectangle_area_with_X(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) 0 >>> max_rectangle_area_with_X(1, 1, [\\"X\\"]) 1 >>> max_rectangle_area_with_X(1, 1, [\\".\\"]) 0","solution":"def max_rectangle_area_with_X(N, M, field): def largest_rectangle(histogram): stack = [] max_area = 0 index = 0 while index < len(histogram): if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: top = stack.pop() area = histogram[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top = stack.pop() area = histogram[top] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area if N == 0 or M == 0: return 0 max_area = 0 heights = [0] * M for i in range(N): for j in range(M): if field[i][j] == 'X': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largest_rectangle(heights)) return max_area # Example usage: # N, M = 4, 5 # field = [ # \\"X.X.X\\", # \\"XX..X\\", # \\"XXXX.\\", # \\"XXX.X\\" # ] # print(max_rectangle_area_with_X(N, M, field)) # Output should be 6"},{"question":"# Dictionary mapping of RNA codons to amino acids CODON_TABLE = { \\"UUU\\": 'F', \\"UUC\\": 'F', \\"UUA\\": 'L', \\"UUG\\": 'L', \\"UCU\\": 'S', \\"UCC\\": 'S', \\"UCA\\": 'S', \\"UCG\\": 'S', \\"UAU\\": 'Y', \\"UAC\\": 'Y', \\"UAA\\": 'STOP', \\"UAG\\": 'STOP', \\"UGU\\": 'C', \\"UGC\\": 'C', \\"UGA\\": 'STOP', \\"UGG\\": 'W', \\"CUU\\": 'L', \\"CUC\\": 'L', \\"CUA\\": 'L', \\"CUG\\": 'L', \\"CCU\\": 'P', \\"CCC\\": 'P', \\"CCA\\": 'P', \\"CCG\\": 'P', \\"CAU\\": 'H', \\"CAC\\": 'H', \\"CAA\\": 'Q', \\"CAG\\": 'Q', \\"CGU\\": 'R', \\"CGC\\": 'R', \\"CGA\\": 'R', \\"CGG\\": 'R', \\"AUU\\": 'I', \\"AUC\\": 'I', \\"AUA\\": 'I', \\"AUG\\": 'M', \\"ACU\\": 'T', \\"ACC\\": 'T', \\"ACA\\": 'T', \\"ACG\\": 'T', \\"AAU\\": 'N', \\"AAC\\": 'N', \\"AAA\\": 'K', \\"AAG\\": 'K', \\"AGU\\": 'S', \\"AGC\\": 'S', \\"AGA\\": 'R', \\"AGG\\": 'R', \\"GUU\\": 'V', \\"GUC\\": 'V', \\"GUA\\": 'V', \\"GUG\\": 'V', \\"GCU\\": 'A', \\"GCC\\": 'A', \\"GCA\\": 'A', \\"GCG\\": 'A', \\"GAU\\": 'D', \\"GAC\\": 'D', \\"GAA\\": 'E', \\"GAG\\": 'E', \\"GGU\\": 'G', \\"GGC\\": 'G', \\"GGA\\": 'G', \\"GGG\\": 'G' } def find_mutated_amino_acid(original_protein, mutated_protein): Find the codon that has been mutated and provide its three-letter amino acid code. Given a string of RNA comprised of codons, three bases each, that potentially contain a mutation causing a single amino acid to be replaced by another. Write a function that finds and corrects the mutation, given the original and mutated protein sequences. It's guaranteed that only one mutation will exist and the strings will be of the same length. >>> find_mutated_amino_acid('MAYKD', 'MAXKD') 'X' >>> find_mutated_amino_acid('LGNCAY', 'LGNZAY') 'Z' >>> find_mutated_amino_acid('ABC', 'ABD') 'D'","solution":"# Dictionary mapping of RNA codons to amino acids CODON_TABLE = { \\"UUU\\": 'F', \\"UUC\\": 'F', \\"UUA\\": 'L', \\"UUG\\": 'L', \\"UCU\\": 'S', \\"UCC\\": 'S', \\"UCA\\": 'S', \\"UCG\\": 'S', \\"UAU\\": 'Y', \\"UAC\\": 'Y', \\"UAA\\": 'STOP', \\"UAG\\": 'STOP', \\"UGU\\": 'C', \\"UGC\\": 'C', \\"UGA\\": 'STOP', \\"UGG\\": 'W', \\"CUU\\": 'L', \\"CUC\\": 'L', \\"CUA\\": 'L', \\"CUG\\": 'L', \\"CCU\\": 'P', \\"CCC\\": 'P', \\"CCA\\": 'P', \\"CCG\\": 'P', \\"CAU\\": 'H', \\"CAC\\": 'H', \\"CAA\\": 'Q', \\"CAG\\": 'Q', \\"CGU\\": 'R', \\"CGC\\": 'R', \\"CGA\\": 'R', \\"CGG\\": 'R', \\"AUU\\": 'I', \\"AUC\\": 'I', \\"AUA\\": 'I', \\"AUG\\": 'M', \\"ACU\\": 'T', \\"ACC\\": 'T', \\"ACA\\": 'T', \\"ACG\\": 'T', \\"AAU\\": 'N', \\"AAC\\": 'N', \\"AAA\\": 'K', \\"AAG\\": 'K', \\"AGU\\": 'S', \\"AGC\\": 'S', \\"AGA\\": 'R', \\"AGG\\": 'R', \\"GUU\\": 'V', \\"GUC\\": 'V', \\"GUA\\": 'V', \\"GUG\\": 'V', \\"GCU\\": 'A', \\"GCC\\": 'A', \\"GCA\\": 'A', \\"GCG\\": 'A', \\"GAU\\": 'D', \\"GAC\\": 'D', \\"GAA\\": 'E', \\"GAG\\": 'E', \\"GGU\\": 'G', \\"GGC\\": 'G', \\"GGA\\": 'G', \\"GGG\\": 'G' } def find_mutated_amino_acid(original_protein, mutated_protein): # Iterate through the protein sequences to find the mutation for orig, mut in zip(original_protein, mutated_protein): if orig != mut: return mut return None"},{"question":"def product_except_self(nums): Returns the product array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Time complexity: O(n) >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([5, 6, 2]) == [12, 10, 30] >>> product_except_self([2, 3]) == [3, 2] >>> product_except_self([1, 2, 3, 4, 5]) == [120, 60, 40, 30, 24] >>> product_except_self([1, 2, 0, 4, 0]) == [0, 0, 0, 0, 0] >>> product_except_self([1, 2, 3, 0, 4]) == [0, 0, 0, 24, 0]","solution":"def product_except_self(nums): Returns the product array output such that output[i] is equal to the product of all the elements of nums except nums[i]. Time complexity: O(n) n = len(nums) # Initialize the output array with 1s output = [1] * n # Calculate left products and store in output array left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right products and multiply with the corresponding left products in the output array right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"def process_operations(n, q, initial_sequence, operations): Process the operations on the sequence of books and return the final sequence. Args: n (int): Number of books initially in the row. q (int): Number of operations. initial_sequence (list of int): The ISBN numbers of the books in initial order. operations (list of str): The operations to be performed. Returns: list of int: The final sequence of ISBN numbers of the books in the row. pass # Unit tests def test_example_1(): n = 5 q = 3 initial_sequence = [101, 102, 103, 104, 105] operations = [\\"pick 103\\", \\"place 103 102\\", \\"pick 105\\"] result = process_operations(n, q, initial_sequence, operations) assert result == [101, 102, 103, 104] def test_example_2(): n = 4 q = 2 initial_sequence = [210, 220, 230, 240] operations = [\\"pick 230\\", \\"place 230 240\\"] result = process_operations(n, q, initial_sequence, operations) assert result == [210, 220, 240, 230] def test_pick_and_place(): n = 3 q = 2 initial_sequence = [300, 200, 100] operations = [\\"pick 200\\", \\"place 200 100\\"] result = process_operations(n, q, initial_sequence, operations) assert result == [300, 100, 200] def test_only_pick(): n = 5 q = 3 initial_sequence = [1, 2, 3, 4, 5] operations = [\\"pick 2\\", \\"pick 4\\", \\"pick 1\\"] result = process_operations(n, q, initial_sequence, operations) assert result == [3, 5] def test_only_place(): n = 3 q = 3 initial_sequence = [10, 20, 30] operations = [\\"pick 20\\", \\"pick 30\\", \\"place 20 10\\", \\"place 30 20\\"] result = process_operations(n, q, initial_sequence, operations) assert result == [10, 20, 30]","solution":"def process_operations(n, q, initial_sequence, operations): Process the operations on the sequence of books and return the final sequence. Args: n (int): Number of books initially in the row. q (int): Number of operations. initial_sequence (list of int): The ISBN numbers of the books in initial order. operations (list of str): The operations to be performed. Returns: list of int: The final sequence of ISBN numbers of the books in the row. # Convert the initial_sequence into a deque for efficient insertion and deletion from collections import deque book_row = deque(initial_sequence) picked_books = {} for operation in operations: parts = operation.split() if parts[0] == \\"pick\\": x = int(parts[1]) book_row.remove(x) picked_books[x] = True elif parts[0] == \\"place\\": x = int(parts[1]) y = int(parts[2]) idx = book_row.index(y) book_row.insert(idx + 1, x) del picked_books[x] return list(book_row)"},{"question":"from typing import List def min_moves_to_reach_end(M: int, N: int, grid: List[str]) -> int: Finds the minimum number of moves required to navigate the snake from the top-left corner (1, 1) to the bottom-right corner (M, N) on the grid. Parameters: M (int): Number of rows in the grid N (int): Number of columns in the grid grid (List[str]): The MxN grid represented as a list of strings Returns: int: The minimum number of moves to reach the end, or -1 if it is not possible. Example: >>> min_moves_to_reach_end(3, 4, [\\"EEEE\\", \\"EEOE\\", \\"EEEE\\"]) 5 >>> min_moves_to_reach_end(3, 3, [\\"EOE\\", \\"OEE\\", \\"EOE\\"]) -1 >>> min_moves_to_reach_end(2, 2, [\\"EE\\", \\"EE\\"]) 2 >>> min_moves_to_reach_end(4, 4, [\\"EOEE\\", \\"EEOE\\", \\"EEOE\\", \\"EEEE\\"]) 6","solution":"from collections import deque def min_moves_to_reach_end(M, N, grid): Finds the minimum number of moves required to navigate the snake from the top-left corner (1, 1) to the bottom-right corner (M, N) on the grid. directions = [(1, 0), (0, 1)] # possible moves: down, right if grid[0][0] == 'O' or grid[M-1][N-1] == 'O': return -1 queue = deque([(0, 0, 0)]) # (row, col, moves) visited = set((0, 0)) while queue: row, col, moves = queue.popleft() # Check if the end is reached if row == M-1 and col == N-1: return moves for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < M and 0 <= new_col < N and (new_row, new_col) not in visited and grid[new_row][new_col] == 'E': visited.add((new_row, new_col)) queue.append((new_row, new_col, moves + 1)) return -1 # if there's no path to the bottom-right corner"},{"question":"def number_of_steps(n: int) -> int: Calculate the number of steps required to reach n bacteria starting from 1, where the number of bacteria doubles each step. Return \\"invalid input\\" if n is not a power of 2. >>> number_of_steps(16) 4 >>> number_of_steps(12) \\"invalid input\\" >>> number_of_steps(1) 0 >>> number_of_steps(2**60) 60 >>> number_of_steps(2**60 - 1) \\"invalid input\\" >>> number_of_steps(3) \\"invalid input\\" >>> number_of_steps(-1) \\"invalid input\\" >>> number_of_steps(0) \\"invalid input\\"","solution":"def number_of_steps(n): Calculate the number of steps required to reach n bacteria starting from 1, where the number of bacteria doubles each step. Return \\"invalid input\\" if n is not a power of 2. if n < 1: return \\"invalid input\\" steps = 0 while n > 1: if n % 2 != 0: return \\"invalid input\\" n //= 2 steps += 1 return steps"},{"question":"def max_cookie_sum(cookies): Function to find the maximum total count of cookies by picking two types. Parameters: cookies (list): List of number of cookies of each type Returns: int: The maximum total count of cookies by picking two types >>> max_cookie_sum([7, 3, 5, 2, 9]) 16 >>> max_cookie_sum([1, 3, 5, 2, 4]) 9 >>> max_cookie_sum([4, 4, 4, 4, 4]) 8 >>> max_cookie_sum([5, 10]) 15 >>> max_cookie_sum([10000000, 9999999, 3, 2, 1]) 19999999 >>> max_cookie_sum([1, 100, 2, 3, 50]) 150 >>> max_cookie_sum([5]) 0","solution":"def max_cookie_sum(cookies): Function to find the maximum total count of cookies by picking two types. Parameters: cookies (list): List of number of cookies of each type Returns: int: The maximum total count of cookies by picking two types # If the list has less than two elements, return 0 as we can't pick two types if len(cookies) < 2: return 0 # Find the two largest numbers in the list first_max = second_max = -1 for num in cookies: if num > first_max: second_max = first_max first_max = num elif num > second_max: second_max = num return first_max + second_max"},{"question":"def longest_palindromic_substring(s: str) -> str: Find the longest palindromic substring within a given string. >>> longest_palindromic_substring(\\"babad\\") in [\\"bab\\", \\"aba\\"] True >>> longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" True >>> longest_palindromic_substring(\\"a\\") == \\"a\\" True >>> longest_palindromic_substring(\\"ac\\") in [\\"a\\", \\"c\\"] True","solution":"def longest_palindromic_substring(s: str) -> str: def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] if len(s) == 0: return \\"\\" longest = s[0] for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_around_center(i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_around_center(i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def minimum_swaps_to_sort(arr): Calculate the minimum number of swaps required to sort the array. Using Bubble Sort to count the swaps needed. pass def minimum_swaps_for_all_test_cases(t, test_cases): For each test case, calculate the minimum number of swaps to sort the list. pass # Function to process input and output def process_input_output(t, input_cases): results = minimum_swaps_for_all_test_cases(t, input_cases) return results # Unit Tests def test_minimum_swaps_to_sort(): assert minimum_swaps_to_sort([4, 3, 2, 1, 5]) == 6 assert minimum_swaps_to_sort([3, 1, 2]) == 2 assert minimum_swaps_to_sort([1, 2, 3, 4]) == 0 assert minimum_swaps_to_sort([4, 2, 3, 1]) == 5 assert minimum_swaps_to_sort([1]) == 0 def test_minimum_swaps_for_all_test_cases(): assert minimum_swaps_for_all_test_cases(3, [ (5, [4, 3, 2, 1, 5]), (3, [3, 1, 2]), (4, [1, 2, 3, 4]) ]) == [6, 2, 0] assert minimum_swaps_for_all_test_cases(1, [ (4, [4, 2, 3, 1]) ]) == [5] assert minimum_swaps_for_all_test_cases(2, [ (1, [1]), (3, [2, 1, 3]) ]) == [0, 1] def test_process_input_output(): assert process_input_output(3, [ (5, [4, 3, 2, 1, 5]), (3, [3, 1, 2]), (4, [1, 2, 3, 4]) ]) == [6, 2, 0] assert process_input_output(1, [ (4, [4, 2, 3, 1]) ]) == [5] assert process_input_output(2, [ (1, [1]), (3, [2, 1, 3]) ]) == [0, 1]","solution":"def minimum_swaps_to_sort(arr): Calculate the minimum number of swaps required to sort the array. Using Bubble Sort to count the swaps needed. n = len(arr) arr = list(arr) # make a copy of the array swaps = 0 for i in range(n): for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 return swaps def minimum_swaps_for_all_test_cases(t, test_cases): For each test case, calculate the minimum number of swaps to sort the list. results = [] for case in test_cases: n, sequence = case results.append(minimum_swaps_to_sort(sequence)) return results # Function to process input and output def process_input_output(t, input_cases): results = minimum_swaps_for_all_test_cases(t, input_cases) return results"},{"question":"def is_perfect_number(n: int) -> bool: Determines if a given positive integer is a Perfect Number. A perfect number is a positive integer that is equal to the sum of its proper divisors, excluding itself. Example: >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(10) False >>> is_perfect_number(1) False","solution":"def is_perfect_number(n): Determines if a given number n is a perfect number. A perfect number is a positive integer that is equal to the sum of its proper divisors excluding itself. if n <= 1: return False divisors_sum = sum(i for i in range(1, n) if n % i == 0) return divisors_sum == n"},{"question":"def max_non_adjacent_sum(happiness_values): Given a list of happiness values, find the maximum sum of non-adjacent values. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110","solution":"def max_non_adjacent_sum(happiness_values): Given a list of happiness values, find the maximum sum of non-adjacent values. if not happiness_values: return 0 if len(happiness_values) == 1: return happiness_values[0] # Initialize the two states prev1 = 0 # Value when not taking the current prize prev2 = 0 # Value when taking the current prize for value in happiness_values: new_sum = max(prev1, prev2 + value) prev2 = prev1 prev1 = new_sum return prev1"},{"question":"def animals_above_threshold(n, animals, t): Returns the names of animals whose lifespan is greater than or equal to the threshold. :param n: int: Number of animals :param animals: list of tuples: Each tuple contains a string (animal name) and an int (lifespan) :param t: int: Threshold lifespan :return: list: List of animal names meeting the criteria >>> animals_above_threshold(5, [(\\"Elephant\\", 70), (\\"Parrot\\", 20), (\\"Tortoise\\", 150), (\\"Rabbit\\", 8), (\\"Wolf\\", 14)], 10) [\\"Elephant\\", \\"Parrot\\", \\"Tortoise\\", \\"Wolf\\"] >>> animals_above_threshold(4, [(\\"Rabbit\\", 5), (\\"Squirrel\\", 6), (\\"Mouse\\", 8), (\\"Hedgehog\\", 4)], 10) [\\"No animals\\"] >>> animals_above_threshold(3, [(\\"Elephant\\", 70), (\\"Parrot\\", 10), (\\"Wolf\\", 14)], 10) [\\"Elephant\\", \\"Parrot\\", \\"Wolf\\"] >>> animals_above_threshold(1, [(\\"Elephant\\", 70)], 50) [\\"Elephant\\"] >>> animals_above_threshold(3, [(\\"Rabbit\\", 5), (\\"Squirrel\\", 6), (\\"Mouse\\", 8)], 10) [\\"No animals\\"]","solution":"def animals_above_threshold(n, animals, t): Returns the names of animals whose lifespan is greater than or equal to the threshold. :param n: int: Number of animals :param animals: list of tuples: Each tuple contains a string (animal name) and an int (lifespan) :param t: int: Threshold lifespan :return: list: List of animal names meeting the criteria result = [name for name, lifespan in animals if lifespan >= t] if result: return result else: return [\\"No animals\\"]"},{"question":"def count_valid_radii(points: List[Tuple[int, int]]) -> int: Counts the number of different radii where a circle can be drawn around a point such that all other points are either inside or on the boundary of the circle. :param points: List of tuples representing the coordinates of the points :return: The number of different valid radii >>> count_valid_radii([(1, 1), (2, 2), (3, 3), (4, 4)]) 2 >>> count_valid_radii([(5, 5)]) 1 >>> count_valid_radii([(0, 0), (3, 4)]) 1 >>> count_valid_radii([(7, 7), (7, 7), (7, 7)]) 1 >>> count_valid_radii([(1, 1), (2, 2), (3, 3), (5, 5)]) 3 >>> count_valid_radii([(10000, 10000), (20000, 20000)]) 1","solution":"import math def count_valid_radii(points): def calculate_distance(p1, p2): return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 n = len(points) radii = set() for i in range(n): max_dist = 0 for j in range(n): if i != j: dist = calculate_distance(points[i], points[j]) max_dist = max(max_dist, dist) radii.add(max_dist) return len(radii)"},{"question":"def longest_mixed_parity_subarray_length(n: int, array: List[int]) -> int: Determines the length of the longest subarray that does not contain any two consecutive elements with the same parity. >>> longest_mixed_parity_subarray_length(6, [1, 2, 3, 4, 5, 6]) 6 >>> longest_mixed_parity_subarray_length(5, [2, 4, 6, 8, 10]) 1","solution":"def longest_mixed_parity_subarray_length(n, array): if n == 1: return 1 max_length = 1 current_length = 1 for i in range(1, n): if (array[i] % 2) != (array[i - 1] % 2): current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def findTwoSum(arr, target): Returns the indices of two distinct elements in the array that add up to the target value. If no such pair exists, returns (-1, -1). >>> findTwoSum([2, 7, 11, 15], 9) (0, 1) >>> findTwoSum([1, 2, 3, 4], 8) (-1, -1)","solution":"def findTwoSum(arr, target): Returns the indices of two distinct elements in the array that add up to the target value. If no such pair exists, returns (-1, -1). index_map = {} for index, num in enumerate(arr): complement = target - num if complement in index_map: return (index_map[complement], index) index_map[num] = index return (-1, -1)"},{"question":"def find_fraudulent_transactions(transactions): Identify potentially fraudulent transactions from a list of financial transactions. >>> transactions = [ ... (100, \\"food\\"), ... (200, \\"entertainment\\"), ... (150, \\"food\\"), ... (300, \\"food\\"), ... (250, \\"entertainment\\"), ... (50, \\"transport\\"), ... ] >>> find_fraudulent_transactions(transactions) [(300, 'food'), (250, 'entertainment')] >>> transactions = [ ... (100, \\"food\\"), ... (100, \\"food\\"), ... (200, \\"transport\\"), ... (200, \\"transport\\"), ... ] >>> find_fraudulent_transactions(transactions) [] >>> transactions = [ ... (100, \\"food\\"), ... (200, \\"entertainment\\"), ... (50, \\"transport\\"), ... ] >>> find_fraudulent_transactions(transactions) [] >>> transactions = [ ... (100, \\"food\\"), ... (200, \\"food\\"), ... (1000000, \\"food\\"), ... ] >>> find_fraudulent_transactions(transactions) [(1000000, 'food')] >>> transactions = [ ... (100, \\"food\\"), ... (200, \\"food\\"), ... (300, \\"food\\"), ... (100, \\"entertainment\\"), ... (300, \\"entertainment\\"), ... ] >>> find_fraudulent_transactions(transactions) [(300, 'food'), (300, 'entertainment')] >>> transactions = [] >>> find_fraudulent_transactions(transactions) []","solution":"def find_fraudulent_transactions(transactions): from collections import defaultdict # Create dictionaries to store the total amounts and counts per category totals = defaultdict(int) counts = defaultdict(int) # Calculate the total amounts and counts per category for amount, category in transactions: totals[category] += amount counts[category] += 1 # Calculate the average amounts per category averages = {category: totals[category] / counts[category] for category in totals} # Find potentially fraudulent transactions fraudulent_transactions = [ (amount, category) for amount, category in transactions if counts[category] > 1 and amount > averages[category] ] return fraudulent_transactions"},{"question":"def word_lengths(sentences: List[str]) -> List[List[str]]: This function takes a list of sentences and returns a list of lists containing words with their respective lengths based on the specifications of the problem. Each sublist corresponds to the unique words and lengths for a given sentence. def read_input(input_string: str) -> List[str]: This function converts the input string into the format required by the primary function. def format_output(results: List[List[str]]) -> str: This function formats the results for display. def test_word_lengths(): sentences = [ \\"Alice loves reading books\\", \\"Chaos and order are not exclusive\\", \\"Marie reads literary works every day\\" ] expected = [ [\\"Alice(5)\\", \\"loves(5)\\", \\"reading(7)\\", \\"books(5)\\"], [\\"Chaos(5)\\", \\"and(3)\\", \\"order(5)\\", \\"are(3)\\", \\"not(3)\\", \\"exclusive(9)\\"], [\\"Marie(5)\\", \\"reads(5)\\", \\"literary(8)\\", \\"works(5)\\", \\"every(5)\\", \\"day(3)\\"] ] assert word_lengths(sentences) == expected def test_read_input(): input_string = \\"3nAlice loves reading booksnChaos and order are not exclusivenMarie reads literary works every day\\" expected = [ \\"Alice loves reading books\\", \\"Chaos and order are not exclusive\\", \\"Marie reads literary works every day\\" ] assert read_input(input_string) == expected def test_format_output(): results = [ [\\"Alice(5)\\", \\"loves(5)\\", \\"reading(7)\\", \\"books(5)\\"], [\\"Chaos(5)\\", \\"and(3)\\", \\"order(5)\\", \\"are(3)\\", \\"not(3)\\", \\"exclusive(9)\\"], [\\"Marie(5)\\", \\"reads(5)\\", \\"literary(8)\\", \\"works(5)\\", \\"every(5)\\", \\"day(3)\\"] ] expected = \\"Alice(5)nloves(5)nreading(7)nbooks(5)nChaos(5)nand(3)norder(5)nare(3)nnot(3)nexclusive(9)nMarie(5)nreads(5)nliterary(8)nworks(5)nevery(5)nday(3)\\" assert format_output(results) == expected def test_full_integration(): input_string = \\"3nAlice loves reading booksnChaos and order are not exclusivenMarie reads literary works every day\\" sentences = read_input(input_string) results = word_lengths(sentences) output = format_output(results) expected_output = \\"Alice(5)nloves(5)nreading(7)nbooks(5)nChaos(5)nand(3)norder(5)nare(3)nnot(3)nexclusive(9)nMarie(5)nreads(5)nliterary(8)nworks(5)nevery(5)nday(3)\\" assert output == expected_output","solution":"def word_lengths(sentences): This function takes a list of sentences and returns a list of lists containing words with their respective lengths based on the specifications of the problem. Each sublist corresponds to the unique words and lengths for a given sentence. results = [] for sentence in sentences: words = sentence.split() seen = set() result = [] for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) result.append(f\\"{word}({len(word)})\\") results.append(result) return results def read_input(input_string): This function converts the input string into the format required by the primary function. lines = input_string.strip().split('n') num_cases = int(lines[0]) test_cases = lines[1:1+num_cases] return test_cases def format_output(results): This function formats the results for display. output = [] for result in results: output.append(\\"n\\".join(result)) return \\"n\\".join(output)"},{"question":"def can_form_palindrome(s: str, l: int, r: int) -> bool: This function checks if a substring s[l:r+1] can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabbcce\\", 1, 7) True >>> can_form_palindrome(\\"aabbcce\\", 2, 4) True >>> can_form_palindrome(\\"aabbcce\\", 1, 4) True >>> can_form_palindrome(\\"abcde\\", 1, 5) False def process_test_cases(t: int, test_cases: List[Dict]) -> List[List[str]]: This function processes multiple test cases and determines for each query whether the substring can be rearranged to form a palindrome. >>> test_cases = [ ... {\\"n\\": 7, \\"q\\": 3, \\"s\\": \\"aabbcce\\", \\"queries\\": [(1, 7), (2, 4), (1, 4)]}, ... {\\"n\\": 5, \\"q\\": 1, \\"s\\": \\"abcde\\", \\"queries\\": [(1, 5)]} ... ] >>> process_test_cases(2, test_cases) [[\\"YES\\", \\"YES\\", \\"YES\\"], [\\"NO\\"]] from typing import List, Dict def test_can_form_palindrome(): assert can_form_palindrome(\\"aabbcce\\", 1, 7) == True assert can_form_palindrome(\\"aabbcce\\", 2, 4) == True assert can_form_palindrome(\\"aabbcce\\", 1, 4) == True assert can_form_palindrome(\\"abcde\\", 1, 5) == False def test_process_test_cases(): test_cases = [ { \\"n\\": 7, \\"q\\": 3, \\"s\\": \\"aabbcce\\", \\"queries\\": [(1, 7), (2, 4), (1, 4)] }, { \\"n\\": 5, \\"q\\": 1, \\"s\\": \\"abcde\\", \\"queries\\": [(1, 5)] } ] expected_output = [ [\\"YES\\", \\"YES\\", \\"YES\\"], [\\"NO\\"] ] assert process_test_cases(2, test_cases) == expected_output def test_single_character_strings(): test_cases = [ { \\"n\\": 1, \\"q\\": 1, \\"s\\": \\"a\\", \\"queries\\": [(1, 1)] }, { \\"n\\": 2, \\"q\\": 1, \\"s\\": \\"bb\\", \\"queries\\": [(1, 2)] } ] expected_output = [ [\\"YES\\"], [\\"YES\\"] ] assert process_test_cases(2, test_cases) == expected_output","solution":"def can_form_palindrome(s, l, r): This function checks if a substring s[l:r+1] can be rearranged to form a palindrome. char_count = [0] * 26 for i in range(l-1, r): char_count[ord(s[i]) - ord('a')] += 1 odd_count = sum(1 for count in char_count if count % 2 != 0) return odd_count <= 1 def process_test_cases(t, test_cases): results = [] for test_case in test_cases: n, q = test_case[\\"n\\"], test_case[\\"q\\"] s = test_case[\\"s\\"] queries = test_case[\\"queries\\"] test_results = [] for (l, r) in queries: if can_form_palindrome(s, l, r): test_results.append(\\"YES\\") else: test_results.append(\\"NO\\") results.append(test_results) return results"},{"question":"from typing import List def max_consecutive_gems(M: int, N: int, grid: List[List[int]]) -> int: Calculate the maximum number of gems of the same type that can be collected consecutively starting from any cell in the grid. >>> max_consecutive_gems(4, 4, [[1, 2, 2, 1], [1, 2, 2, 1], [0, 1, 0, 0], [3, 3, 3, 1]]) 4 >>> max_consecutive_gems(3, 5, [[5, 5, 5, 0, 5], [1, 1, 0, 0, 1], [3, 3, 3, 3, 3]]) 5 pass def test_sample_1(): M = 4 N = 4 grid = [ [1, 2, 2, 1], [1, 2, 2, 1], [0, 1, 0, 0], [3, 3, 3, 1] ] assert max_consecutive_gems(M, N, grid) == 4 def test_sample_2(): M = 3 N = 5 grid = [ [5, 5, 5, 0, 5], [1, 1, 0, 0, 1], [3, 3, 3, 3, 3] ] assert max_consecutive_gems(M, N, grid) == 5 def test_single_row(): M = 1 N = 5 grid = [ [1, 2, 2, 2, 1] ] assert max_consecutive_gems(M, N, grid) == 3 def test_single_column(): M = 5 N = 1 grid = [ [1], [1], [1], [0], [1] ] assert max_consecutive_gems(M, N, grid) == 3 def test_empty_cells(): M = 2 N = 2 grid = [ [0, 0], [0, 0] ] assert max_consecutive_gems(M, N, grid) == 0 def test_mixed_grid(): M = 3 N = 3 grid = [ [1, 2, 1], [0, 1, 0], [2, 2, 2] ] assert max_consecutive_gems(M, N, grid) == 3","solution":"def max_consecutive_gems(M, N, grid): def dfs(x, y, gem_type): if x < 0 or x >= M or y < 0 or y >= N or grid[x][y] != gem_type or visited[x][y]: return 0 visited[x][y] = True count = 1 for dx, dy in directions: count += dfs(x + dx, y + dy, gem_type) return count directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_gems = 0 visited = [[False] * N for _ in range(M)] for i in range(M): for j in range(N): if grid[i][j] != 0 and not visited[i][j]: max_gems = max(max_gems, dfs(i, j, grid[i][j])) return max_gems"},{"question":"class RecentCounter: def __init__(self): Initialize an empty request log. pass def ping(self, t: int) -> int: A request is called at time t (in milliseconds). This method should count and return the number of requests that have been made in the past 3000 milliseconds (including this one). >>> recentCounter = RecentCounter() >>> recentCounter.ping(1) 1 >>> recentCounter.ping(100) 2 >>> recentCounter.ping(3001) 3 >>> recentCounter.ping(3002) 3 pass","solution":"from collections import deque class RecentCounter: def __init__(self): self.queue = deque() def ping(self, t): A request is called at time t (in milliseconds). Returns the number of requests that have been made in the past 3000 milliseconds (including this one). self.queue.append(t) while self.queue[0] < t - 3000: self.queue.popleft() return len(self.queue)"},{"question":"def digitalRoot(n: int) -> int: Calculate the digital root of a non-negative integer. Parameters: n (int): A non-negative integer. Returns: int: The single-digit digital root of the given number. >>> digitalRoot(9875) 2 >>> digitalRoot(38) 2 >>> digitalRoot(123456789) 9 >>> digitalRoot(1000000000) 1 >>> digitalRoot(0) 0 # You can add test cases to validate the implementation if __name__ == \\"__main__\\": assert digitalRoot(9875) == 2 assert digitalRoot(38) == 2 assert digitalRoot(123456789) == 9 assert digitalRoot(1000000000) == 1 assert digitalRoot(0) == 0 print(\\"All test cases pass\\")","solution":"def digitalRoot(n: int) -> int: Calculate the digital root of a non-negative integer. Parameters: n (int): A non-negative integer. Returns: int: The single-digit digital root of the given number. if n == 0: return 0 else: return 1 + (n - 1) % 9"},{"question":"def checkInclusion(pattern: str, string: str) -> bool: Check if 'string' contains any permutation of 'pattern'. >>> checkInclusion(\\"ab\\", \\"eidbaooo\\") True >>> checkInclusion(\\"ab\\", \\"eidboaoo\\") False def test_checkInclusion_pattern_in_middle(): assert checkInclusion(\\"ab\\", \\"eidbaooo\\") == True def test_checkInclusion_pattern_not_present(): assert checkInclusion(\\"ab\\", \\"eidboaoo\\") == False def test_checkInclusion_pattern_at_end(): assert checkInclusion(\\"ab\\", \\"ooxaab\\") == True def test_checkInclusion_pattern_at_start(): assert checkInclusion(\\"ab\\", \\"abeidbaooo\\") == True def test_checkInclusion_pattern_duplicated(): assert checkInclusion(\\"abb\\", \\"ababbba\\") == True def test_checkInclusion_pattern_longer_than_string(): assert checkInclusion(\\"abcd\\", \\"abc\\") == False def test_checkInclusion_both_same(): assert checkInclusion(\\"abc\\", \\"abc\\") == True def test_checkInclusion_single_characters(): assert checkInclusion(\\"a\\", \\"a\\") == True assert checkInclusion(\\"a\\", \\"b\\") == False def test_checkInclusion_substring_contains_all_chars_different_order(): assert checkInclusion(\\"abc\\", \\"bbbac\\") == True def test_checkInclusion_characters_with_duplicates(): assert checkInclusion(\\"aabb\\", \\"abababab\\") == True","solution":"def checkInclusion(pattern, string): from collections import Counter # Helper function to compare two frequency dictionaries def matches(s1_count, s2_count): for char in s1_count: if s1_count[char] != s2_count[char]: return False return True # Frequency map of the pattern pattern_count = Counter(pattern) # Frequency map of the current window in the string window_count = Counter() len_pattern = len(pattern) len_string = len(string) for i in range(len_string): # Add the current character to the window window_count[string[i]] += 1 # Remove the character from the left side if window size exceeds pattern size if i >= len_pattern: if window_count[string[i - len_pattern]] == 1: del window_count[string[i - len_pattern]] else: window_count[string[i - len_pattern]] -= 1 # Compare the two frequency maps if matches(pattern_count, window_count): return True return False"},{"question":"def stack_calculator(input_list: List[str]) -> int: Simulates the operation of a simple stack-based calculator. >>> stack_calculator([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) # 9 >>> stack_calculator([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) # 6 >>> stack_calculator([\\"10\\", \\"6\\", \\"-\\", \\"3\\", \\"/\\"]) # 1","solution":"def stack_calculator(input_list): stack = [] for token in input_list: if token not in \\"+-*/\\": stack.append(int(token)) else: b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(int(a / b)) # Use int() to ensure truncation towards zero return stack[0]"},{"question":"def minimizeShelfWidth(books: List[int], shelves: int) -> int: Given an array of integers where each element represents the width of a book and a separate integer representing the number of bookshelves, distribute these books across the shelves such that the width of the widest shelf is minimized. >>> minimizeShelfWidth([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 17 >>> minimizeShelfWidth([10, 20, 30, 40], 2) 60","solution":"def can_place_books(books, shelves, max_width): current_width = 0 required_shelves = 1 for book in books: if current_width + book > max_width: required_shelves += 1 current_width = book if required_shelves > shelves: return False else: current_width += book return True def minimizeShelfWidth(books, shelves): left, right = max(books), sum(books) while left < right: mid = (left + right) // 2 if can_place_books(books, shelves, mid): right = mid else: left = mid + 1 return left"},{"question":"def evaluate_expression(expression: str) -> float: Evaluates a basic mathematical expression and returns its result as a floating-point number. Supports addition, subtraction, multiplication, division, and parentheses for order of operations. >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"(3 + 5) * 2\\") 16.0 >>> evaluate_expression(\\"10 / 2 + 3 * (2 - 1)\\") 8.0 >>> evaluate_expression(\\"10 / (2 + 3 * (2 - 1))\\") 2.0 >>> evaluate_expression(\\"10 / (2 + 0)\\") 5.0 >>> evaluate_expression(\\"10 / 0\\") # Should handle division by zero # Your implementation here # Example usage print(evaluate_expression(\\"3 + 5 * 2\\")) # Output: 13.0 print(evaluate_expression(\\"(3 + 5) * 2\\")) # Output: 16.0 print(evaluate_expression(\\"10 / 2 + 3 * (2 - 1)\\")) # Output: 8.0 print(evaluate_expression(\\"10 / (2 + 3 * (2 - 1))\\")) # Output: 2.0 print(evaluate_expression(\\"10 / (2 + 0)\\")) # Output: 5.0 print(evaluate_expression(\\"10 / 0\\")) # Should handle division by zero","solution":"def evaluate_expression(expression: str) -> float: Evaluates a basic mathematical expression and returns its result as a floating-point number. Supports addition, subtraction, multiplication, division, and parentheses for order of operations. try: # Using eval to evaluate the expression result = eval(expression) return float(result) except ZeroDivisionError: raise ValueError(\\"Division by zero is not allowed.\\") except Exception as e: raise ValueError(f\\"Invalid expression: {e}\\")"},{"question":"def find_sublist_with_sum(arr, N, M, S): Finds the first occurrence of a sublist of length M whose elements sum up to S and returns the starting index of that sublist. If no such sublist is found, returns -1. Parameters: arr (list of int): List of integers N (int): Length of the list M (int): Length of the sublist S (int): Target sum Returns: int: The starting index of the first sublist that sums to S, or -1 if no such sublist exists Examples: >>> find_sublist_with_sum([1, 2, 3, 7, 5], 5, 2, 10) 2 >>> find_sublist_with_sum([1, 2, 3, 7, 5], 5, 2, 15) -1","solution":"def find_sublist_with_sum(arr, N, M, S): Finds the first occurrence of a sublist of length M whose elements sum up to S and returns the starting index of that sublist. Parameters: arr (list of int): List of integers N (int): Length of the list M (int): Length of the sublist S (int): Target sum Returns: int: The starting index of the first sublist that sums to S, or -1 if no such sublist exists # Early return if M is greater than N if M > N: return -1 # Calculate the initial window sum window_sum = sum(arr[:M]) if window_sum == S: return 0 # Slide the window to the right for i in range(N - M): window_sum = window_sum - arr[i] + arr[i + M] if window_sum == S: return i + 1 return -1"},{"question":"class Inventory: def __init__(self): Initialize the inventory management system. def add_item(self, item_id, quantity): Add a given quantity of the specified item to the inventory. If the item does not exist, it should be added to the inventory. Args: item_id (int): The ID of the item to be added. quantity (int): The quantity of the item to be added. >>> inv = Inventory() >>> inv.add_item(101, 50) >>> inv.add_item(101, 25) >>> inv.inventory[101] 75 def remove_item(self, item_id, quantity): Remove a given quantity of the specified item from the inventory. If the item does not exist, or the quantity to be removed exceeds the current stock, print \\"Item not available\\" or \\"Insufficient stock\\" respectively. Args: item_id (int): The ID of the item to be removed. quantity (int): The quantity of the item to be removed. >>> inv = Inventory() >>> inv.add_item(101, 50) >>> inv.remove_item(101, 30) >>> inv.inventory[101] 20 def check_stock(self, item_id): Check the current stock level of the specified item. If the item does not exist in the inventory, it should print \\"Item not found\\". Args: item_id (int): The ID of the item to be checked. >>> inv = Inventory() >>> inv.check_stock(101) Item not found >>> inv.add_item(101, 50) >>> inv.check_stock(101) 50 def process_operations(operations): Process a series of inventory operations. Args: operations (list): A list of operation strings, each starting with a keyword (\\"add\\", \\"remove\\", or \\"check\\") followed by item_id and quantity (for \\"add\\" and \\"remove\\" operations only). >>> operations = [\\"add 101 50\\", \\"add 102 25\\", \\"remove 101 30\\", \\"check 101\\", \\"check 103\\"] >>> process_operations(operations) 20 Item not found","solution":"class Inventory: def __init__(self): self.inventory = {} def add_item(self, item_id, quantity): if item_id in self.inventory: self.inventory[item_id] += quantity else: self.inventory[item_id] = quantity def remove_item(self, item_id, quantity): if item_id not in self.inventory: print(\\"Item not available\\") elif self.inventory[item_id] < quantity: print(\\"Insufficient stock\\") else: self.inventory[item_id] -= quantity def check_stock(self, item_id): if item_id in self.inventory: print(self.inventory[item_id]) else: print(\\"Item not found\\") def process_operations(operations): inventory = Inventory() for operation in operations: parts = operation.split() op_type = parts[0] item_id = int(parts[1]) if op_type == \\"add\\": quantity = int(parts[2]) inventory.add_item(item_id, quantity) elif op_type == \\"remove\\": quantity = int(parts[2]) inventory.remove_item(item_id, quantity) elif op_type == \\"check\\": inventory.check_stock(item_id) # Example usage operations = [ \\"add 101 50\\", \\"add 102 25\\", \\"remove 101 30\\", \\"check 101\\", \\"check 103\\" ] process_operations(operations)"},{"question":"import math from typing import List, Tuple def count_ways_to_fill_grid(N: int, M: int) -> int: Compute the number of ways to fill a grid such that each row and each column have distinct integers from 1 to max(N, M). >>> count_ways_to_fill_grid(2, 2) 4 >>> count_ways_to_fill_grid(3, 3) 36 >>> count_ways_to_fill_grid(2, 3) 0 pass def number_of_ways(test_cases: List[Tuple[int, int]]) -> List[int]: Given multiple test cases, output the number of valid ways to fill the grid for each case. >>> number_of_ways([(2, 2), (3, 3), (2, 3)]) [4, 36, 0] >>> number_of_ways([(2, 2), (4, 4), (1, 1)]) [4, 576, 1] pass def test_count_ways_square_grids(): assert count_ways_to_fill_grid(1, 1) == 1 assert count_ways_to_fill_grid(2, 2) == 4 assert count_ways_to_fill_grid(3, 3) == 36 assert count_ways_to_fill_grid(4, 4) == 576 def test_count_ways_non_square_grids(): assert count_ways_to_fill_grid(2, 3) == 0 assert count_ways_to_fill_grid(3, 2) == 0 assert count_ways_to_fill_grid(4, 5) == 0 def test_number_of_ways(): test_cases = [(2, 2), (3, 3), (2, 3)] expected_results = [4, 36, 0] assert number_of_ways(test_cases) == expected_results test_cases = [(2, 2), (4, 4), (1, 1)] expected_results = [4, 576, 1] assert number_of_ways(test_cases) == expected_results","solution":"import math def count_ways_to_fill_grid(N, M): if N != M: return 0 factorial = math.factorial return factorial(N) ** 2 def number_of_ways(test_cases): results = [] for N, M in test_cases: results.append(count_ways_to_fill_grid(N, M)) return results"},{"question":"def findMissingInteger(arr, n): Find the smallest positive integer missing from the array. >>> findMissingInteger([3, 4, -1, 1], 4) 2 >>> findMissingInteger([1, 2, 3, 10], 4) 4","solution":"def findMissingInteger(arr, n): This function finds the smallest positive integer missing from the array. # We use the index of the array to mark the presence of elements for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Now check which is the smallest positive integer missing for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def numDecodings(s: str) -> int: Given a string s containing only digits, find the number of possible decodings of the string. Each digit or pair of digits should be mapped to a letter as follows: 'A' to 'Z' are represented by '1' to '26', respectively. Examples: >>> numDecodings(\\"12\\") 2 >>> numDecodings(\\"226\\") 3 Constraints: 1 <= s.length <= 100 s contains only digits and does not contain leading zeros.","solution":"def numDecodings(s): if not s: return 0 n = len(s) # dp array to store the number of ways to decode up to each position dp = [0] * (n + 1) # Base case initialization dp[0] = 1 # Empty string has one way to be decoded dp[1] = 1 if s[0] != '0' else 0 # Single character string has one way if it's not '0' for i in range(2, n + 1): single_digit = int(s[i - 1:i]) two_digit = int(s[i - 2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"def subarray_sum(nums, k): Returns the total number of continuous subarrays whose sum equals to k. Args: nums (List[int]): An array of integers. k (int): The target sum for the continuous subarrays. Returns: int: The total number of continuous subarrays whose sum equals to k. Examples: >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2","solution":"def subarray_sum(nums, k): Returns the total number of continuous subarrays whose sum equals to k. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if current_sum - k in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"def sort_photos_by_year(n: int, filenames: List[str]) -> List[str]: Sorts the list of photo filenames by the year they were taken. Parameters: n : int The number of photo filenames. filenames : list of str The list of photo filenames in format \\"YYYY_description.jpg\\". Returns: list of str The sorted list of photo filenames by year in ascending order. Example: >>> sort_photos_by_year(3, [\\"2021_vacation.jpg\\", \\"2019_birthday.jpg\\", \\"2021_graduation.jpg\\"]) ['2019_birthday.jpg', '2021_vacation.jpg', '2021_graduation.jpg']","solution":"def sort_photos_by_year(n, filenames): Sorts the list of photo filenames by the year they were taken. Parameters: n : int The number of photo filenames. filenames : list of str The list of photo filenames in format \\"YYYY_description.jpg\\". Returns: list of str The sorted list of photo filenames by year in ascending order. sorted_filenames = sorted(filenames, key=lambda x: int(x[:4])) return sorted_filenames"},{"question":"def longest_subsequence(n: int, d: int, sequence: List[int]) -> int: Given a sequence of n integers, find the length of the longest subsequence such that every pair of consecutive elements in the subsequence has a difference of either d or -d. Args: n : int : number of elements in the sequence d : int : desired difference between consecutive elements sequence : List[int] : the sequence of integers Returns: int: length of the longest desired subsequence. Examples: >>> longest_subsequence(6, 2, [1, 3, 2, 5, 7, 8]) 4 >>> longest_subsequence(4, 5, [10, 4, 15, 9]) 2 # Unit tests def test_example_1(): assert longest_subsequence(6, 2, [1, 3, 2, 5, 7, 8]) == 4 def test_example_2(): assert longest_subsequence(4, 5, [10, 4, 15, 9]) == 2 def test_single_element(): assert longest_subsequence(1, 1, [1]) == 1 def test_no_valid_subsequence(): assert longest_subsequence(5, 10, [1, 2, 3, 4, 5]) == 1 def test_all_elements_with_diff_d(): assert longest_subsequence(5, 1, [1, 2, 3, 4, 5]) == 5 def test_large_difference(): assert longest_subsequence(5, 20, [1, 21, 41, 61, 81]) == 5 def test_multiple_valid_subsequences(): assert longest_subsequence(6, 2, [2, 4, 6, 8, 3, 5]) == 4 def test_gap_middle(): assert longest_subsequence(7, 2, [1, 3, 5, 7, 9, 11, 15]) == 6 def test_alternate_up_down(): assert longest_subsequence(6, 1, [1, 2, 1, 2, 1, 2]) == 6","solution":"def longest_subsequence(n, d, sequence): dp = [1] * n # Initialize the dp array with 1s, as single elements always count for i in range(n): for j in range(i): if sequence[i] - sequence[j] == d or sequence[i] - sequence[j] == -d: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # The longest subsequence length"},{"question":"def minimal_diff(n: int, capacities: List[int]) -> int: Given the capacities of the servers, returns the minimal difference possible between the total capacities of two groups of servers. >>> minimal_diff(3, [8, 5, 6]) 3 >>> minimal_diff(4, [3, 1, 4, 2]) 0","solution":"def minimal_diff(n, capacities): def find_min_diff(idx, sum1, sum2): if idx == n: return abs(sum1 - sum2) option1 = find_min_diff(idx + 1, sum1 + capacities[idx], sum2) option2 = find_min_diff(idx + 1, sum1, sum2 + capacities[idx]) return min(option1, option2) return find_min_diff(0, 0, 0)"},{"question":"def min_difference_subset(n, k, nums): Determine if there is a subset of these integers of size k such that the difference between the maximum and minimum integers in the subset is minimized. If such a subset exists, return the subset; otherwise, return \\"No\\". >>> min_difference_subset(6, 3, [10, 20, 30, 40, 50, 60]) [10, 20, 30] >>> min_difference_subset(4, 5, [2, 4, 6, 8]) 'No' >>> min_difference_subset(3, 3, [15, 10, 5]) [5, 10, 15] >>> min_difference_subset(5, 4, [8, 1, 7, 3, 6]) [1, 3, 6, 7] >>> min_difference_subset(5, 1, [10, 20, 30, 40, 50]) [10] >>> min_difference_subset(5, 2, [1000000000, 999999999, 888888888, 777777777, 666666666]) [999999999, 1000000000] >>> min_difference_subset(5, 3, [-10, -20, -30, -40, -50]) [-50, -40, -30]","solution":"def min_difference_subset(n, k, nums): if k > n: return \\"No\\" nums.sort() min_diff = float('inf') best_subset = [] for i in range(n - k + 1): current_diff = nums[i + k - 1] - nums[i] if current_diff < min_diff: min_diff = current_diff best_subset = nums[i:i+k] return best_subset"},{"question":"def solve_sudoku(board): Solve a partially filled sudoku grid such that it satisfies the sudoku rules. >>> solve_sudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ]) == [ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ] def format_sudoku_output(board): Format the sudoku board for output. >>> format_sudoku_output([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) == ( ... \\"5 3 4 6 7 8 9 1 2n\\" ... \\"6 7 2 1 9 5 3 4 8n\\" ... \\"1 9 8 3 4 2 5 6 7n\\" ... \\"8 5 9 7 6 1 4 2 3n\\" ... \\"4 2 6 8 5 3 7 9 1n\\" ... \\"7 1 3 9 2 4 8 5 6n\\" ... \\"9 6 1 5 3 7 2 8 4n\\" ... \\"2 8 7 4 1 9 6 3 5n\\" ... \\"3 4 5 2 8 6 1 7 9\\" ... ) def read_sudoku_input(): Reads sudoku grid from input. >>> read_sudoku_input() == [ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9] ... ] input_board = [] for _ in range(9): input_board.append(list(map(int, input().split()))) return input_board if __name__ == \\"__main__\\": board = read_sudoku_input() solved_board = solve_sudoku(board) print(format_sudoku_output(solved_board))","solution":"def solve_sudoku(board): def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num: return False return True def solve(board): for i in range(9): for j in range(9): if board[i][j] == 0: for num in range(1, 10): if is_valid(board, i, j, num): board[i][j] = num if solve(board): return True board[i][j] = 0 return False return True solve(board) return board def format_sudoku_output(board): return 'n'.join([' '.join(map(str, row)) for row in board]) def read_sudoku_input(): input_board = [] for _ in range(9): input_board.append(list(map(int, input().split()))) return input_board if __name__ == \\"__main__\\": board = read_sudoku_input() solved_board = solve_sudoku(board) print(format_sudoku_output(solved_board))"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string. >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aaa\\") 3 pass import pytest def test_example_cases(): # Example cases assert count_distinct_substrings(\\"ab\\") == 3 assert count_distinct_substrings(\\"aaa\\") == 3 def test_distinct_characters(): assert count_distinct_substrings(\\"abc\\") == 6 # [\\"a\\", \\"b\\", \\"c\\", \\"ab\\", \\"bc\\", \\"abc\\"] def test_repeated_characters(): assert count_distinct_substrings(\\"aaaa\\") == 4 # [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"] def test_mixture_of_characters(): assert count_distinct_substrings(\\"abab\\") == 7 # [\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"aba\\", \\"bab\\", \\"abab\\"] def test_single_character(): assert count_distinct_substrings(\\"a\\") == 1 # [\\"a\\"] def test_empty_string(): assert count_distinct_substrings(\\"\\") == 0 # [] def test_longer_string_with_repeats(): assert count_distinct_substrings(\\"abcabc\\") == 15","solution":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of the given string. substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def getNthTriangularNum(n: int) -> int: Returns the nth triangular number. >>> getNthTriangularNum(1) == 1 >>> getNthTriangularNum(2) == 3 >>> getNthTriangularNum(3) == 6 >>> getNthTriangularNum(4) == 10 >>> getNthTriangularNum(10) == 55 >>> getNthTriangularNum(1000) == 500500 >>> getNthTriangularNum(100000) == 5000050000","solution":"def getNthTriangularNum(n): Returns the nth triangular number. nth triangular number T_n is given by the formula T_n = n * (n + 1) // 2 return n * (n + 1) // 2"},{"question":"def track_high_scores(n, rounds): Takes the number of rounds and the scores for each round, returns the highest score of each participant in alphabetical order. :param n: int: number of rounds :param rounds: list of tuples: each tuple contains a string (username) and an int (score) :return: list of tuples: each tuple contains a string (username) and an int (highest score) sorted alphabetically by username >>> track_high_scores(5, [(\\"john\\", 150), (\\"ann\\", 200), (\\"john\\", 180), (\\"ann\\", 220), (\\"tom\\", 90)]) [('ann', 220), ('john', 180), ('tom', 90)] >>> track_high_scores(3, [(\\"alice\\", 100), (\\"bob\\", 150), (\\"alice\\", 120)]) [('alice', 120), ('bob', 150)]","solution":"def track_high_scores(n, rounds): Takes the number of rounds and the scores for each round, returns the highest score of each participant in alphabetical order. :param n: int: number of rounds :param rounds: list of tuples: each tuple contains a string (username) and an int (score) :return: list of tuples: each tuple contains a string (username) and an int (highest score) sorted alphabetically by username scores = {} for username, score in rounds: if username in scores: scores[username] = max(scores[username], score) else: scores[username] = score sorted_scores = sorted(scores.items()) return sorted_scores"},{"question":"from math import comb def number_of_unique_paths(N, M): Returns the number of unique paths from (1, 1) to (N, M) in a grid. >>> number_of_unique_paths(2, 2) 2 >>> number_of_unique_paths(3, 3) 6 >>> number_of_unique_paths(1, 5) 1 def solve(T, test_cases): Solves multiple test cases to find the number of unique paths for each. >>> solve(3, [(2, 2), (3, 3), (1, 5)]) [2, 6, 1] >>> solve(2, [(1, 1), (2, 3)]) [1, 3] >>> solve(1, [(500, 500)]) [comb(998, 499)]","solution":"from math import comb def number_of_unique_paths(N, M): Returns the number of unique paths from (1, 1) to (N, M) in a grid. return comb(N + M - 2, N - 1) def solve(T, test_cases): results = [] for N, M in test_cases: results.append(number_of_unique_paths(N, M)) return results"},{"question":"def groups_of_three(n: int) -> tuple[int, int]: Determine the maximum number of groups of 3 that can be formed from a given number of employees, and the remainder that cannot be placed in any group. >>> groups_of_three(10) (3, 1) >>> groups_of_three(25) (8, 1) >>> groups_of_three(1000000000) (333333333, 1)","solution":"def groups_of_three(n): Returns the maximum number of groups of 3 that can be formed, and the number of employees who are not placed in any group. :param n: The number of employees. :return: A tuple (max_groups, remainder) max_groups = n // 3 remainder = n % 3 return (max_groups, remainder)"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of the contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 pass def process_test_cases(test_cases): Processes multiple test cases and returns their results. >>> process_test_cases([ >>> [-2, 1, -3, 4, -1, 2, 1, -5, 4], >>> [1, 2, 3, 4, 5], >>> [-1, -2, -3, -4, -5], >>> [10, -3, 4, -1, 2, 1, -5, 4] >>> ]) == [6, 15, -1, 13] pass","solution":"def max_subarray_sum(arr): Returns the maximum sum of the contiguous subarray. max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"def add_antonym(dictionary, word, antonym): Adds a word-antonym pair to the dictionary. If the word already exists in the dictionary, it should update its antonym. pass def get_antonym(dictionary, word): Returns the antonym of a given word. If the word is not in the dictionary, return None. pass def remove_word(dictionary, word): Removes a word and its antonym from the dictionary. If the word is not in the dictionary, return None. pass def list_antonyms(dictionary): Returns a list of all word-antonym pairs in the dictionary sorted alphabetically based on the words. pass # Unit Tests def test_add_antonym(): d = {'hot': 'cold', 'light': 'dark', 'happy': 'sad'} add_antonym(d, 'big', 'small') assert d == {'hot': 'cold', 'light': 'dark', 'happy': 'sad', 'big': 'small'} add_antonym(d, 'happy', 'unhappy') assert d == {'hot': 'cold', 'light': 'dark', 'happy': 'unhappy', 'big': 'small'} def test_get_antonym(): d = {'hot': 'cold', 'light': 'dark', 'happy': 'sad'} assert get_antonym(d, 'happy') == 'sad' assert get_antonym(d, 'light') == 'dark' assert get_antonym(d, 'nonexistent') == None def test_remove_word(): d = {'hot': 'cold', 'light': 'dark', 'happy': 'sad'} assert remove_word(d, 'light') == 'dark' assert d == {'hot': 'cold', 'happy': 'sad'} assert remove_word(d, 'nonexistent') == None def test_list_antonyms(): d = {'hot': 'cold', 'light': 'dark', 'happy': 'sad'} assert list_antonyms(d) == [('happy', 'sad'), ('hot', 'cold'), ('light', 'dark')] def test_case_insensitivity(): d = {'hot': 'cold', 'light': 'dark', 'happy': 'sad'} add_antonym(d, 'Hot', 'chilly') assert d == {'hot': 'chilly', 'light': 'dark', 'happy': 'sad'} assert get_antonym(d, 'HOT') == 'chilly' assert get_antonym(d, 'hoT') == 'chilly' assert remove_word(d, 'HoT') == 'chilly' assert d == {'light': 'dark', 'happy': 'sad'}","solution":"def add_antonym(dictionary, word, antonym): Adds a word-antonym pair to the dictionary. If the word already exists in the dictionary, it should update its antonym. word = word.lower() dictionary[word] = antonym def get_antonym(dictionary, word): Returns the antonym of a given word. If the word is not in the dictionary, return None. return dictionary.get(word.lower()) def remove_word(dictionary, word): Removes a word and its antonym from the dictionary. If the word is not in the dictionary, return None. return dictionary.pop(word.lower(), None) def list_antonyms(dictionary): Returns a list of all word-antonym pairs in the dictionary sorted alphabetically based on the words. return sorted(dictionary.items())"},{"question":"from typing import List def calculate_trapped_water(elevations: List[int]) -> int: Calculate the total amount of water that could be trapped after it rains. >>> calculate_trapped_water([3, 0, 2, 0, 4]) 7 >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6","solution":"def calculate_trapped_water(elevations): if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - elevations[i] return total_water"},{"question":"def max_product_of_three(nums): Given an array of integers, returns the maximum possible product of any three numbers in the array. >>> max_product_of_three([1, 10, 2, 6, 5, 3]) 300 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([1, -4, 3, -6, 7, 0]) 168 >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([-1, -2, -3, -4]) -6 >>> max_product_of_three([-1, -1, 0, 1, 1]) 1","solution":"def max_product_of_three(nums): Returns the maximum possible product of any three numbers in the array. nums.sort() # The maximum product can be the highest product of the three largest numbers # or the product of the two smallest numbers (both possibly negative) and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def minimum_swaps_to_sort(stacks: List[int]) -> int: Determine the minimum number of swaps required to sort the sequence. Args: stacks (List[int]): The initial sequence of balls. Returns: int: The minimum number of swaps required to sort the sequence. >>> minimum_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> minimum_swaps_to_sort([1, 2, 6, 4, 3, 5]) 4 import pytest def test_case_1(): assert minimum_swaps_to_sort([5, 4, 3, 2, 1]) == 10 def test_case_2(): assert minimum_swaps_to_sort([1, 2, 6, 4, 3, 5]) == 4 def test_case_3(): assert minimum_swaps_to_sort([1, 3, 5, 2, 4, 6]) == 3 def test_case_4(): assert minimum_swaps_to_sort([2, 1]) == 1 def test_case_5(): assert minimum_swaps_to_sort([1, 2, 3, 4, 5]) == 0 def test_case_6(): assert minimum_swaps_to_sort([4, 3, 2, 1]) == 6 def test_large_case(): large_test_case = list(range(1000, 0, -1)) expected = 499500 assert minimum_swaps_to_sort(large_test_case) == expected pytest.main()","solution":"def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: # There are mid - i inversions because all elements left to i in left subarray are greater than arr[j] temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def minimum_swaps_to_sort(stacks): temp_arr = [0]*len(stacks) return merge_sort_and_count(stacks, temp_arr, 0, len(stacks)-1)"},{"question":"def max_subarray_sum_of_length_k(arr, k): Returns the maximum sum of any subarray of length exactly k. Parameters: arr (list of int): The array of integers. k (int): The length of the subarray. Returns: int: The maximum subarray sum of length k. Examples: >>> max_subarray_sum_of_length_k([1, 2, 3, 4, 5], 3) 12 >>> max_subarray_sum_of_length_k([-1, 3, -2, 5, 3, -5, 2, 2], 4) 9","solution":"def max_subarray_sum_of_length_k(arr, k): Returns the maximum sum of any subarray of length exactly k. Parameters: arr (list of int): The array of integers. k (int): The length of the subarray. Returns: int: The maximum subarray sum of length k. # Initialize the sum of first k elements max_sum = current_sum = sum(arr[:k]) # Use sliding window to calculate the sum of subarrays of length k for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def longest_connected_subsequence(n: int, villages: str, m: int, connections: List[Tuple[int, int]]) -> int: Find the length of the longest subsequence of connected villages starting from the first village. >>> longest_connected_subsequence(5, \\"abcde\\", 3, [(1, 2), (2, 3), (4, 5)]) 3 >>> longest_connected_subsequence(6, \\"abcdef\\", 2, [(1, 2), (5, 6)]) 2 >>> longest_connected_subsequence(3, \\"abc\\", 0, []) 1 >>> longest_connected_subsequence(4, \\"abcd\\", 2, [(1, 2), (3, 4)]) 2 >>> longest_connected_subsequence(7, \\"abcdefg\\", 4, [(1, 2), (2, 3), (4, 5), (6, 7)]) 3 >>> longest_connected_subsequence(5, \\"aaaaa\\", 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5","solution":"def longest_connected_subsequence(n, villages, m, connections): from collections import defaultdict, deque if m == 0: return 1 graph = defaultdict(list) for a, b in connections: graph[a-1].append(b-1) graph[b-1].append(a-1) visited = [False] * n max_length = 0 def bfs(start): queue = deque([start]) visited[start] = True length = 0 while queue: current = queue.popleft() length += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return length for i in range(n): # To handle isolated sections but typically only needed from index 0 if not visited[i]: max_length = max(max_length, bfs(i)) return max_length # Example usage: n = 5 villages = \\"abcde\\" m = 3 connections = [(1, 2), (2, 3), (4, 5)] print(longest_connected_subsequence(n, villages, m, connections)) # Output: 3"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_info): nodes = {info[0]: TreeNode(info[0]) for info in node_info} root = nodes[node_info[0][0]] for value, left, right in node_info: if left != -1: nodes[value].left = nodes[left] if right != -1: nodes[value].right = nodes[right] return root def boundary_traversal(root): if not root: return [] def left_boundary(node): if node: if node.left: result.append(node.value) left_boundary(node.left) elif node.right: result.append(node.value) left_boundary(node.right) def right_boundary(node): if node: if node.right: right_boundary(node.right) result.append(node.value) elif node.left: right_boundary(node.left) result.append(node.value) def leaves(node): if node: leaves(node.left) if not node.left and not node.right: result.append(node.value) leaves(node.right) result = [root.value] left_boundary(root.left) leaves(root.left) leaves(root.right) right_boundary(root.right) return result def boundary_traversal_from_input(node_count, node_info): Perform a boundary traversal of a binary tree. Parameters: node_count (int): Number of nodes in the tree. node_info (List[List[int]]): List of node information where each entry contains three integers x, y, z. Returns: List[int]: List of node values in boundary traversal order. >>> boundary_traversal_from_input(5, [[1, 2, 3], [2, 4, -1], [4, -1, -1], [3, -1, 5], [5, -1, -1]]) == [1, 2, 4, 5, 3] >>> boundary_traversal_from_input(1, [[1, -1, -1]]) == [1] root = build_tree(node_info) return boundary_traversal(root)","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def build_tree(node_info): nodes = {info[0]: TreeNode(info[0]) for info in node_info} root = nodes[node_info[0][0]] for value, left, right in node_info: if left != -1: nodes[value].left = nodes[left] if right != -1: nodes[value].right = nodes[right] return root def boundary_traversal(root): if not root: return [] def left_boundary(node): if node: if node.left: result.append(node.value) left_boundary(node.left) elif node.right: result.append(node.value) left_boundary(node.right) def right_boundary(node): if node: if node.right: right_boundary(node.right) result.append(node.value) elif node.left: right_boundary(node.left) result.append(node.value) def leaves(node): if node: leaves(node.left) if not node.left and not node.right: result.append(node.value) leaves(node.right) result = [root.value] left_boundary(root.left) leaves(root.left) leaves(root.right) right_boundary(root.right) return result def boundary_traversal_from_input(node_count, node_info): root = build_tree(node_info) return boundary_traversal(root)"},{"question":"def is_network_possible(n: int, friends_laptops: List[List[int]]) -> str: Determine if it is possible to configure the laptops such that each friend's laptops are connected and at least one laptop of every friend has internet capability. Parameters: n (int): Number of friends. friends_laptops (List[List[int]]): A list of lists where each inner list contains integers (0 or 1) indicating if a laptop has internet capability (1 for yes, 0 for no) for each friend. Returns: str: \\"Possible\\" if the configuration is feasible, \\"Impossible\\" otherwise. >>> is_network_possible(3, [[1, 0], [0, 1, 0], [1, 1]]) == \\"Possible\\" >>> is_network_possible(2, [[0, 0], [0, 1]]) == \\"Impossible\\" >>> is_network_possible(4, [[1], [0, 1], [1, 0, 0], [0]]) == \\"Impossible\\" >>> is_network_possible(1, [[1]]) == \\"Possible\\" >>> is_network_possible(1, [[0]]) == \\"Impossible\\" >>> is_network_possible(3, [[1], [1], [1]]) == \\"Possible\\" >>> is_network_possible(1, [[1] * 1000]) == \\"Possible\\" >>> is_network_possible(1, [[0] * 1000]) == \\"Impossible\\"","solution":"def is_network_possible(n, friends_laptops): Determines if it is possible to configure the laptops such that each friend's laptops are connected with at least one laptop having internet capability. Parameters: - n (int): number of friends - friends_laptops (list of list of int): a nested list where each inner list contains integers indicating if a laptop has internet capability (1 for yes, 0 for no) Returns: - str: \\"Possible\\" if the configuration is feasible, \\"Impossible\\" otherwise for laptops in friends_laptops: if 1 not in laptops: return \\"Impossible\\" return \\"Possible\\""},{"question":"def josephus(n, k): Determines the winning contestant using the Josephus problem algorithm. Parameters: n (int): Number of contestants. k (int): Step count for elimination. Returns: int: The number of the winning contestant. pass def find_winners(datasets): Process multiple datasets to find the winning contestant. Parameters: datasets (list of tuples): List of (n, k) pairs where n is the number of contestants and k is the step count for elimination. Returns: list: List of winning contestant numbers for each dataset. pass # Example >>> josephus(7, 3) 4 >>> josephus(5, 2) 3 >>> find_winners([(7, 3), (5, 2)]) [4, 3] # Unit Test from solution import josephus, find_winners def test_josephus_single(): assert josephus(1, 1) == 1 def test_josephus_three_elimination(): assert josephus(7, 3) == 4 def test_josephus_two_elimination(): assert josephus(5, 2) == 3 def test_josephus_large_contestants(): assert josephus(100, 1) == 100 def test_find_winners(): datasets = [(7, 3), (5, 2)] expected = [4, 3] assert find_winners(datasets) == expected def test_find_winners_with_termination(): datasets = [(7, 3), (5, 2), (0, 0)] expected = [4, 3] assert find_winners(datasets) == expected def test_find_winners_single_contestant(): datasets = [(1, 1), (0, 0)] expected = [1] assert find_winners(datasets) == expected python","solution":"def josephus(n, k): Determines the winning contestant using the Josephus problem algorithm. Parameters: n (int): Number of contestants. k (int): Step count for elimination. Returns: int: The number of the winning contestant. if n == 1: return 1 else: return (josephus(n-1, k) + k-1) % n + 1 def find_winners(datasets): Process multiple datasets to find the winning contestant. Parameters: datasets (list of tuples): List of (n, k) pairs where n is the number of contestants and k is the step count for elimination. Returns: list: List of winning contestant numbers for each dataset. winners = [] for n, k in datasets: if n == 0 and k == 0: break winners.append(josephus(n, k)) return winners"},{"question":"def min_packages(W, n, weights): Determine the minimum number of packages needed to send all items given the weight limit W and the list of item weights. Parameters: W (int) : The weight limit of a single package. n (int) : The number of items. weights (List[int]) : The weights of the items. Returns: int : The minimum number of packages needed. >>> min_packages(10, 6, [7, 2, 3, 9, 1, 5]) == 3 >>> min_packages(10, 1, [7]) == 1","solution":"def min_packages(W, n, weights): Determine the minimum number of packages needed to send all items given the weight limit W and the list of item weights. Parameters: W (int) : The weight limit of a single package. n (int) : The number of items. weights (List[int]) : The weights of the items. Returns: int : The minimum number of packages needed. from itertools import combinations weights.sort(reverse=True) packages = 0 while weights: packages += 1 current_weight = weights.pop(0) for i in range(len(weights)-1, -1, -1): if current_weight + weights[i] <= W: current_weight += weights.pop(i) return packages # Function to read input and call the min_packages function if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() W = int(data[0]) n = int(data[1]) weights = list(map(int, data[2:])) print(min_packages(W, n, weights))"},{"question":"from typing import List def remove_adjacent_duplicates(identifier: str) -> str: Remove adjacent duplicate characters in the identifier until no more removals can be made. >>> remove_adjacent_duplicates(\\"abbac\\") 'c' >>> remove_adjacent_duplicates(\\"aabbcc\\") '' >>> remove_adjacent_duplicates(\\"abccba\\") '' pass def process_identifiers(identifiers: List[str]) -> List[str]: Process a list of identifiers and return their final form after removing adjacent duplicates. >>> identifiers = [\\"abbac\\", \\"aabbcc\\", \\"abccba\\", \\"abcdef\\"] >>> process_identifiers(identifiers) ['c', '', '', 'abcdef'] pass def main(input_values): n = int(input_values[0]) identifiers = input_values[1:n+1] return process_identifiers(identifiers)","solution":"def remove_adjacent_duplicates(identifier): stack = [] for char in identifier: if stack and stack[-1] == char: stack.pop() # Remove the duplicate else: stack.append(char) return ''.join(stack) def process_identifiers(identifiers): return [remove_adjacent_duplicates(identifier) for identifier in identifiers] def main(input_values): n = int(input_values[0]) identifiers = input_values[1:n+1] return process_identifiers(identifiers)"},{"question":"def is_prime(num: int) -> bool: Helper function to check if a number is prime. def filter_primes(numbers: List[int]) -> List[int]: Returns a list of prime numbers from the input list. The result list is sorted in ascending order. >>> filter_primes([2, 3, 4, 5, 6, 7]) [2, 3, 5, 7] >>> filter_primes([10, 11, 12, 11, 13]) [11, 11, 13] >>> filter_primes([1, 4, 6, 8, 9]) [] >>> filter_primes([29, 1, 17, 17, 23]) [17, 17, 23, 29]","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True def filter_primes(numbers): Returns a list of prime numbers from the input list. The result list is sorted in ascending order. return sorted([num for num in numbers if is_prime(num)])"},{"question":"def filter_even_numbers(nums: List[int]) -> List[int]: Takes a list of integers and returns a new list containing only the even numbers from the original list. >>> filter_even_numbers([1, 2, 3, 4, 5, 6]) [2, 4, 6] >>> filter_even_numbers([-3, -2, -1, 0, 1, 2]) [-2, 0, 2] from solution import filter_even_numbers def test_filter_even_numbers_mixed(): assert filter_even_numbers([1, 2, 3, 4, 5, 6]) == [2, 4, 6] def test_filter_even_numbers_all_odd(): assert filter_even_numbers([1, 3, 5, 7]) == [] def test_filter_even_numbers_all_even(): assert filter_even_numbers([2, 4, 6, 8]) == [2, 4, 6, 8] def test_filter_even_numbers_empty(): assert filter_even_numbers([]) == [] def test_filter_even_numbers_negative_and_positive(): assert filter_even_numbers([-3, -2, -1, 0, 1, 2]) == [-2, 0, 2] def test_filter_even_numbers_negative_only(): assert filter_even_numbers([-4, -3, -2, -1]) == [-4, -2]","solution":"def filter_even_numbers(nums): Takes a list of integers and returns a new list containing only the even numbers from the original list. return [num for num in nums if num % 2 == 0]"},{"question":"from typing import List, Tuple def max_rectangle_area(heights: List[int]) -> int: Calculates the maximum rectangular area in a list of building heights. >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes each test case and returns a list of maximum rectangle areas for each test case. >>> process_test_cases([(6, [2, 1, 5, 6, 2, 3]), (7, [6, 2, 5, 4, 5, 1, 6])]) [10, 12] pass","solution":"def max_rectangle_area(heights): Calculates the maximum rectangular area in a list of building heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_test_cases(test_cases): results = [] for case in test_cases: heights = case[1] results.append(max_rectangle_area(heights)) return results"},{"question":"def reverse_words(s: str) -> str: Reverses the order of words in the given string \`s\`. Parameters: s (str): The input string consisting of words separated by spaces. Returns: str: The string with the words in reversed order. >>> reverse_words(\\" hello world! \\") 'world! hello' >>> reverse_words(\\"a good example\\") 'example good a' >>> reverse_words(\\" \\") '' >>> reverse_words(\\"hello\\") 'hello' >>> reverse_words(\\"\\") ''","solution":"def reverse_words(s: str) -> str: Reverses the order of words in the given string \`s\`. Parameters: s (str): The input string consisting of words separated by spaces. Returns: str: The string with the words in reversed order. # Split the string into words using spaces words = s.split() # Reverse the list of words words.reverse() # Join the words with a single space and return the result return ' '.join(words)"},{"question":"def highest_effectiveness_warrior(N, M, scenarios): The kingdom of Westeros has three different types of warriors: Knights, Archers, and Mages. Each type of warrior offers a different attack power and defense power. These values are represented as integers A, B, and C for attack power and D, E, and F for defense power, respectively, for the three types of warriors. Given these values, you need to determine which type of warrior offers the highest overall combat effectiveness, which is calculated as the sum of attack power and defense power. Input: - N: an integer representing the number of scenarios. - M: an integer representing the number of warriors in each scenario. - scenarios: a list of lists containing M pairs of integers each representing the attack and defense power values for a warrior in that scenario. Output: - For each scenario, returns the type of warrior with the highest overall combat effectiveness (\\"Knight\\", \\"Archer\\", or \\"Mage\\"). If there is a tie, returns the type that appears first in the order: Knight, Archer, Mage. Example: >>> highest_effectiveness_warrior(2, 3, [[10, 15, 20, 25, 30, 35], [40, 50, 20, 30, 15, 10]]) ['Mage', 'Knight'] >>> highest_effectiveness_warrior(1, 2, [[10, 10, 10, 10]]) ['Knight']","solution":"def highest_effectiveness_warrior(N, M, scenarios): result = [] warrior_types = [\\"Knight\\", \\"Archer\\", \\"Mage\\"] for i in range(N): max_effectiveness = -1 best_warrior = None for j in range(M): attack = scenarios[i][2*j] defense = scenarios[i][2*j + 1] effectiveness = attack + defense if effectiveness > max_effectiveness: max_effectiveness = effectiveness best_warrior = warrior_types[j] result.append(best_warrior) return result"},{"question":"def isValidEmail(email: str) -> bool: Checks if the provided email is valid based on the specified criteria. The email is considered valid if: 1. The email contains exactly one '@' character. 2. The domain part (the part after the '@') must contain at least one '.' character. 3. Neither the local part (the part before the '@') nor the domain part should be empty. 4. The local part should only contain alphanumeric characters and the special characters '.', '_', '-', and '+'. No other characters are allowed. 5. The domain part should only contain alphanumeric characters and the special character '-'. No other characters are allowed. 6. Both the local part and the domain part must start and end with an alphanumeric character. Examples: >>> isValidEmail(\\"john.doe@example.com\\") True >>> isValidEmail(\\"jane-doe@sub.example.com\\") True >>> isValidEmail(\\".jane_doe@example.com\\") False >>> isValidEmail(\\"jane@doe@example.com\\") False >>> isValidEmail(\\"jane.doe@com\\") False >>> isValidEmail(\\"jane.doe@-example.com\\") False","solution":"import re def isValidEmail(email: str) -> bool: Checks if the provided email is valid based on the specified criteria. # Check for exactly one '@' character if email.count('@') != 1: return False local_part, domain_part = email.split('@') # Check if local part and domain part are not empty if not local_part or not domain_part: return False # Check if the domain part contains at least one '.' character if '.' not in domain_part: return False # Validate local part if not re.match(r'^[a-zA-Z0-9._+-]+', local_part): return False # Validate domain part if not re.match(r'^[a-zA-Z0-9.-]+', domain_part): return False # Check if local part starts and ends with an alphanumeric character if not local_part[0].isalnum() or not local_part[-1].isalnum(): return False # Check if domain part starts and ends with an alphanumeric character if not domain_part[0].isalnum() or not domain_part[-1].isalnum(): return False return True"},{"question":"class Node: def __init__(self, data, next=None, random=None): self.data = data self.next = next self.random = random def cloneLinkedList(head): Write a function to clone a linked list that contains next and random pointer (a pointer to any node in the linked list or Null). The random pointer might point to any node in the list, and it can even point to itself. The function should return a deep copy of the linked list. >>> node1 = Node(1) >>> node2 = Node(2) >>> node3 = Node(3) >>> node1.next = node2 >>> node2.next = node3 >>> node1.random = None >>> node2.random = node1 >>> node3.random = node2 >>> copied_list = cloneLinkedList(node1) >>> copied_list.data == 1 True >>> copied_list.next.data == 2 True >>> copied_list.next.next.data == 3 True >>> copied_list.random == None True >>> copied_list.next.random.data == 1 True >>> copied_list.next.next.random.data == 2 True","solution":"class Node: def __init__(self, data, next=None, random=None): self.data = data self.next = next self.random = random def cloneLinkedList(head): if not head: return None # Step 1: Insert new nodes current = head while current: new_node = Node(current.data) new_node.next = current.next current.next = new_node current = new_node.next # Step 2: Assign random pointers to the new nodes current = head while current: if current.random: current.next.random = current.random.next current = current.next.next # Step 3: Separate the newly created list from the original list current = head new_head = head.next while current: temp = current.next current.next = temp.next if temp.next: temp.next = temp.next.next current = current.next return new_head"},{"question":"def maximize_cost(n: int, P: int, books: List[Tuple[int, int, int]], events: List[Tuple[int, ...]]) -> List[int]: A publishing company is organizing a book expo and has n types of books available in their inventory, each type with a different theme. The i-th type of book has cost ci and popularity pi. The company wants to manage the inventory and track customer interactions: You should process q events of two types: - type 1 — a customer buys a book of type x, reducing its inventory by one. If there are no books left of type x, the event should be ignored. - type 2 — upon returning to inventory after a sales event, the company wants to maximize their profit by selecting books to display such that their popularity sums up to at most P. Each book can only be displayed once. For each event of type 2, let f(P) be the maximum possible sum of costs of the books chosen for display with total popularity ≤ P. Formally, let I be the set of indices of all book types currently in inventory. Then, f(P) is defined as the maximum total cost of choosing books such that the sum of their popularity ≤ P. Compute f(P) for each event of type 2. Note that the output follows a special format. Parameters ---------- n : int The initial number of book types available. P : int The maximum interesting popularity threshold. books : List[Tuple[int, int, int]] A list of tuples where each tuple represents (cost, popularity, initial units) of a book type. events : List[Tuple[int, ...]] A list of events, each event is either (1, x) or (2,). Returns ------- List[int] A list of integers representing the result of each type 2 event. >>> maximize_cost(3, 1000, [(100, 150, 1), (200, 200, 2), (150, 300, 1)], [(1, 1), (1, 2), (2,), (1, 2), (2,)]) [350, 150] >>> maximize_cost(3, 1000, [(100, 150, 1), (200, 200, 2), (150, 300, 1)], [(2,)]) [450] from typing import List, Tuple","solution":"def maximize_cost(n, P, books, events): current_inventory = [book[2] for book in books] def knapsack(available_books, P): dp = [0] * (P + 1) for ci, pi in available_books: for w in range(P, pi - 1, -1): dp[w] = max(dp[w], dp[w - pi] + ci) return dp[P] results = [] for event in events: if event[0] == 1: book_type = event[1] - 1 if current_inventory[book_type] > 0: current_inventory[book_type] -= 1 elif event[0] == 2: available_books = [ (books[i][0], books[i][1]) for i in range(n) if current_inventory[i] > 0 ] results.append(knapsack(available_books, P)) return results"},{"question":"from typing import List def smallest_abs_difference(arr: List[int]) -> int: Returns the smallest absolute difference between any two distinct integers in the array. >>> smallest_abs_difference([1, 3, 6, 10, 15]) 2 >>> smallest_abs_difference([10, 20, 30, 0, 5]) 5 >>> smallest_abs_difference([-10, -5, 0, 5, 10]) 5 >>> smallest_abs_difference([1, 5, 3, 19, 18, 25]) 1 >>> smallest_abs_difference([100, 101]) 1 >>> smallest_abs_difference([-3, -5, -7, -8]) 1 >>> smallest_abs_difference([1, 1, 2, 2]) 0 pass","solution":"def smallest_abs_difference(arr): Returns the smallest absolute difference between any two distinct integers in the array. arr.sort() min_diff = float('inf') for i in range(len(arr) - 1): diff = abs(arr[i] - arr[i+1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def generate_bead_pattern(n: int) -> str: Generate a bead pattern of length n where no two adjacent beads are the same color, and the blue beads should be as few as possible. >>> generate_bead_pattern(1) 'r' >>> generate_bead_pattern(3) 'rgr' >>> generate_bead_pattern(4) 'rgrg'","solution":"def generate_bead_pattern(n): Generate a bead pattern of length n where no two adjacent beads are the same color, and the blue beads should be as few as possible. # The pattern can maximize the use of 'r' and 'g' and minimize 'b' pattern = '' colors = ['r', 'g'] # Start creating the pattern to satisfy the conditions for i in range(n): pattern += colors[i % 2] # Alternating 'r' and 'g' return pattern"},{"question":"from typing import List, Union def min_steps_to_reach_end(grid: List[List[str]]) -> Union[int, str]: Returns the minimum number of steps required to reach the cell (N, N) in the given grid or 'Impossible' if it is not possible. >>> min_steps_to_reach_end([['L', 'L', 'L', 'W', 'L'], ['L', 'W', 'W', 'L', 'L'], ['L', 'W', 'L', 'W', 'L'], ['L', 'L', 'W', 'L', 'L'], ['L', 'L', 'L', 'L', 'L']]) 8 >>> min_steps_to_reach_end([['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'L', 'L']]) \\"Impossible\\" def process_input(input_data: str) -> List[Union[int, str]]: Processes the input data and returns the results for each dataset. >>> process_input('5nLLLWLnLWWLLnLWLWLnLLWLLnLLLLLn0') [8] >>> process_input('5nLLLWLnLWWLLnLWLWLnLLWLLnLLLLLn3nLWLnWLWnLWLn0') [8, \\"Impossible\\"]","solution":"from collections import deque def min_steps_to_reach_end(grid): N = len(grid) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == 'W' or grid[N-1][N-1] == 'W': return \\"Impossible\\" queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set() visited.add((0, 0)) while queue: x, y, steps = queue.popleft() if x == N-1 and y == N-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == 'L': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return \\"Impossible\\" def process_input(input_data): lines = input_data.strip().split('n') results = [] i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break grid = [list(lines[i+j+1]) for j in range(N)] result = min_steps_to_reach_end(grid) results.append(result) i += N + 1 return results"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of the stock on later days. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Returns the maximum profit that can be achieved by buying and selling one share of the stock on later days. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price - min_price > max_profit: max_profit = price - min_price if price < min_price: min_price = price return max_profit"},{"question":"def wordBreak(s: str, wordDict: List[str]) -> List[str]: Given a string s and a dictionary of words wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. >>> wordBreak(\\"catsanddog\\", [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"]) [\\"cats and dog\\", \\"cat sand dog\\"] >>> wordBreak(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) [\\"pine apple pen apple\\", \\"pineapple pen apple\\", \\"pine applepen apple\\"] >>> wordBreak(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) []","solution":"def wordBreak(s, wordDict): def backtrack(index): if index == len(s): return [[]] if index in memo: return memo[index] memo[index] = [] for end in range(index + 1, len(s) + 1): word = s[index:end] if word in wordDict: for subsentence in backtrack(end): memo[index].append([word] + subsentence) return memo[index] memo = {} wordDict = set(wordDict) result = backtrack(0) return [\\" \\".join(words) for words in result]"},{"question":"def evaluate_participant_performance(T, test_cases): Determines if participants receive a certificate based on the number of problems they solved. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers (P, Y) where: P is the number of problems solved, Y is the minimum number of problems required to earn a certificate. Returns: list of str: \\"Certificate Awarded\\" or \\"Try Again\\" for each test case depending on whether the number of problems solved is at least the minimum required. import pytest def test_certificate_awarded(): T = 3 test_cases = [(7, 5), (10, 10), (100, 1)] assert evaluate_participant_performance(T, test_cases) == [ \\"Certificate Awarded\\", \\"Certificate Awarded\\", \\"Certificate Awarded\\" ] def test_try_again(): T = 3 test_cases = [(3, 5), (0, 1), (50, 100)] assert evaluate_participant_performance(T, test_cases) == [ \\"Try Again\\", \\"Try Again\\", \\"Try Again\\" ] def test_mixed_cases(): T = 3 test_cases = [(7, 5), (3, 5), (10, 10)] assert evaluate_participant_performance(T, test_cases) == [ \\"Certificate Awarded\\", \\"Try Again\\", \\"Certificate Awarded\\" ] def test_minimum_and_maximum_constraints(): T = 4 test_cases = [(0, 100), (100, 1), (50, 50), (30, 30)] assert evaluate_participant_performance(T, test_cases) == [ \\"Try Again\\", \\"Certificate Awarded\\", \\"Certificate Awarded\\", \\"Certificate Awarded\\" ] @pytest.mark.parametrize(\\"T, test_cases, expected\\", [ (1, [(1, 1)], [\\"Certificate Awarded\\"]), (1, [(99, 100)], [\\"Try Again\\"]), (2, [(50, 50), (49, 50)], [\\"Certificate Awarded\\", \\"Try Again\\"]), (3, [(0, 1), (1, 1), (10, 10)], [\\"Try Again\\", \\"Certificate Awarded\\", \\"Certificate Awarded\\"]), ]) def test_multiple_cases(T, test_cases, expected): assert evaluate_participant_performance(T, test_cases) == expected","solution":"def evaluate_participant_performance(T, test_cases): Determines if participants receive a certificate based on the number of problems they solved. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers (P, Y) where: P is the number of problems solved, Y is the minimum number of problems required to earn a certificate. Returns: list of str: \\"Certificate Awarded\\" or \\"Try Again\\" for each test case depending on whether the number of problems solved is at least the minimum required. result = [] for P, Y in test_cases: if P >= Y: result.append(\\"Certificate Awarded\\") else: result.append(\\"Try Again\\") return result"},{"question":"def simulate_journey(towns, journey): Simulates a journey through towns and returns the total distance travelled. :param towns: Dictionary representing the towns and distances between them :param journey: List of towns representing the journey :return: Total distance travelled or \\"Invalid journey\\" if journey is not possible >>> towns = { ... \\"A\\": {\\"B\\": 5, \\"C\\": 4}, ... \\"B\\": {\\"A\\": 5, \\"C\\": 2, \\"D\\": 3}, ... \\"C\\": {\\"A\\": 4, \\"B\\": 2, \\"D\\": 7}, ... \\"D\\": {\\"B\\": 3, \\"C\\": 7} ... } >>> journey = [\\"A\\", \\"B\\", \\"D\\"] >>> simulate_journey(towns, journey) 8 >>> journey = [\\"A\\", \\"D\\"] >>> simulate_journey(towns, journey) \\"Invalid journey\\" >>> journey = [\\"C\\", \\"E\\"] >>> simulate_journey(towns, journey) \\"Invalid journey\\" >>> journey = [\\"A\\"] >>> simulate_journey(towns, journey) 0 >>> journey = [] >>> simulate_journey(towns, journey) 0 >>> journey = [\\"A\\", \\"B\\", \\"C\\", \\"A\\"] >>> simulate_journey(towns, journey) 11","solution":"def simulate_journey(towns, journey): Simulates a journey through towns and returns the total distance travelled. :param towns: Dictionary representing the towns and distances between them :param journey: List of towns representing the journey :return: Total distance travelled or \\"Invalid journey\\" if journey is not possible if len(journey) < 2: return 0 total_distance = 0 for i in range(len(journey) - 1): current_town = journey[i] next_town = journey[i + 1] if current_town not in towns or next_town not in towns[current_town]: return \\"Invalid journey\\" total_distance += towns[current_town][next_town] return total_distance"},{"question":"def process_operations(n: int, operations: List[str]) -> str: Process a sequence of operations and output the resulting text after all operations have been performed. >>> process_operations(5, [\\"1 a\\", \\"1 b\\", \\"1 c\\", \\"2\\", \\"3\\"]) == \\"abc\\" >>> process_operations(6, [\\"1 x\\", \\"1 y\\", \\"1 z\\", \\"2\\", \\"2\\", \\"3\\"]) == \\"xy\\"","solution":"def process_operations(n, operations): text = [] history = [] for op in operations: if op[0] == \\"1\\": char = op[2] text.append(char) history.append((\\"1\\", char)) elif op[0] == \\"2\\": if text: removed_char = text.pop() history.append((\\"2\\", removed_char)) elif op[0] == \\"3\\": if history: last_op, char = history.pop() if last_op == \\"1\\": text.pop() elif last_op == \\"2\\": text.append(char) return ''.join(text)"},{"question":"def max_sum_of_products(nums1: List[int], nums2: List[int], k: int) -> int: Returns the maximum sum of the products of elements from pairs chosen from nums1 and nums2. You can change the order of elements in nums1 but not in nums2. Args: nums1: list of int nums2: list of int k: int Returns: int: maximum sum of the products of k pairs. >>> max_sum_of_products([1, 3, 2], [4, 5, 1], 2) 23 >>> max_sum_of_products([1, 3, 5], [2, 4, 6], 3) 44 def test_max_sum_of_products_example1(): assert max_sum_of_products([1, 3, 2], [4, 5, 1], 2) == 23 def test_max_sum_of_products_example2(): assert max_sum_of_products([1, 3, 5], [2, 4, 6], 3) == 44 def test_max_sum_of_products_identical_numbers(): assert max_sum_of_products([1, 2, 3], [1, 2, 3], 3) == 14 def test_max_sum_of_products_single_element(): assert max_sum_of_products([3], [4], 1) == 12 def test_max_sum_of_products_large_numbers(): assert max_sum_of_products([100, 200, 300], [1000, 2000, 3000], 3) == 1400000","solution":"def max_sum_of_products(nums1, nums2, k): Returns the maximum sum of the products of elements from pairs chosen from nums1 and nums2. You can change the order of elements in nums1 but not in nums2. Args: nums1: list of int nums2: list of int k: int Returns: int: maximum sum of the products of k pairs. # Sort nums1 in descending order since we need to maximize product nums1.sort(reverse=True) # Sort nums2 in descending order since we need to maximize product nums2.sort(reverse=True) # Calculate the sum of the products of the k largest pairs max_sum = 0 for i in range(k): max_sum += nums1[i] * nums2[i] return max_sum"},{"question":"def min_closing_brackets_needed(test_cases: List[str]) -> List[int]: Determine the minimum number of \`)\` that need to be added to the end of each binary string in \`test_cases\` to make them valid bracket sequences. >>> min_closing_brackets_needed([\\"1100\\", \\"111000\\", \\"101\\", \\"110\\"]) == [0, 0, 1, 1] >>> min_closing_brackets_needed([\\"1\\", \\"0\\", \\"111\\", \\"000\\"]) == [1, 0, 3, 0]","solution":"def min_closing_brackets_needed(test_cases): results = [] for s in test_cases: open_brackets = 0 for char in s: if char == '1': # open bracket open_brackets += 1 elif char == '0' and open_brackets > 0: # close bracket with an open bracket available to match open_brackets -= 1 results.append(open_brackets) return results # Read input def process_input(): t = int(input().strip()) test_cases = [input().strip() for _ in range(t)] return t, test_cases def main(): t, test_cases = process_input() results = min_closing_brackets_needed(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def count_valid_codewords(n: int) -> int: Calculate the number of valid codewords of length n. A valid codeword is a binary string that does not contain three consecutive '1's. >>> count_valid_codewords(1) 2 >>> count_valid_codewords(2) 4 >>> count_valid_codewords(3) 7 >>> count_valid_codewords(4) 13 >>> count_valid_codewords(5) 24","solution":"def count_valid_codewords(n): This function calculates the number of valid codewords of length n. A valid codeword is a binary string that does not contain the substring '111'. if n == 1: return 2 if n == 2: return 4 if n == 3: return 7 # Dynamically calculate the number of valid codewords for length n dp = [0] * (n + 1) dp[1] = 2 dp[2] = 4 dp[3] = 7 for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"def countBuildingsWithSunriseView(heights): Returns the number of buildings that have a clear view of the sunrise. >>> countBuildingsWithSunriseView([7, 1, 8, 4, 9]) 3 >>> countBuildingsWithSunriseView([4, 3, 2, 1]) 1 >>> countBuildingsWithSunriseView([1, 2, 3, 4, 5]) 5 >>> countBuildingsWithSunriseView([5, 4, 3, 2, 1]) 1 >>> countBuildingsWithSunriseView([5, 5, 5, 5]) 1 >>> countBuildingsWithSunriseView([]) 0 >>> countBuildingsWithSunriseView([3, 1, 4, 1, 5, 9, 2, 6, 5]) 4","solution":"def countBuildingsWithSunriseView(heights): Returns the number of buildings that have a clear view of the sunrise. if not heights: return 0 max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def find_most_frequent_genre_and_positions(n: int, genres: str) -> str: Given a number of vinyl records and their genres, find the most frequent genre and its first and last positions on the shelf. If multiple genres have the highest frequency, return the lexicographically smallest genre. Positions should be 1-indexed. Args: n (int): The number of vinyl records. genres (str): A string of length n containing lowercase English letters representing the genres of the vinyl records. Returns: str: A string with the most frequent genre, its first position, and last position separated by spaces. Examples: >>> find_most_frequent_genre_and_positions(7, \\"abbacca\\") 'a 1 7' >>> find_most_frequent_genre_and_positions(5, \\"bbcdc\\") 'b 1 2'","solution":"def find_most_frequent_genre_and_positions(n, genres): from collections import defaultdict genre_count = defaultdict(int) first_position = {} last_position = {} for i, genre in enumerate(genres): genre_count[genre] += 1 if genre not in first_position: first_position[genre] = i + 1 last_position[genre] = i + 1 max_frequency = max(genre_count.values()) max_genres = [(genre, first_position[genre], last_position[genre]) for genre, count in genre_count.items() if count == max_frequency] max_genres.sort() most_frequent_genre = max_genres[0] return f\\"{most_frequent_genre[0]} {most_frequent_genre[1]} {most_frequent_genre[2]}\\""},{"question":"def most_frequent_character(t: int, test_cases: List[Tuple[int, str]]) -> List[str]: Determine the character that appears the most frequently in each string. If multiple characters have the same maximum frequency, return the alphabetically smallest one. >>> most_frequent_character(3, [(6, \\"aabbcc\\"), (5, \\"abcde\\"), (10, \\"aabbbccddd\\")]) ['a', 'a', 'b'] >>> most_frequent_character(2, [(3, \\"abc\\"), (5, \\"eeeee\\")]) ['a', 'e'] >>> most_frequent_character(2, [(1, \\"z\\"), (2, \\"zz\\")]) ['z', 'z']","solution":"def most_frequent_character(t, test_cases): from collections import Counter result = [] for n, s in test_cases: freq = Counter(s) max_freq = max(freq.values()) most_freq_chars = [char for char, count in freq.items() if count == max_freq] result.append(min(most_freq_chars)) return result"},{"question":"def filter_greater_than_average(numbers: List[int]) -> Union[List[int], str]: Returns a list of integers that are greater than the average of the original list. If the list contains fewer than three numbers or more than 50 numbers, returns \\"invalid list\\". >>> filter_greater_than_average([1, 2, 3, 4, 5]) [4, 5] >>> filter_greater_than_average([10, 20]) \\"invalid list\\" >>> filter_greater_than_average([100, 200, 300, 400, 500]) [400, 500]","solution":"def filter_greater_than_average(numbers): Returns a list of integers that are greater than the average of the original list. If the list contains fewer than three numbers or more than 50 numbers, returns \\"invalid list\\". if len(numbers) < 3 or len(numbers) > 50: return \\"invalid list\\" average = sum(numbers) / len(numbers) result = [num for num in numbers if num > average] return result"},{"question":"def is_strictly_increasing(points): Determines if the points form a strictly increasing sequence. Args: points: List of integers representing points for each level. Returns: \\"YES\\" if points form a strictly increasing sequence, \\"NO\\" otherwise. >>> is_strictly_increasing([1, 2, 3]) == \\"YES\\" >>> is_strictly_increasing([1, 1, 2, 3]) == \\"NO\\" >>> is_strictly_increasing([5, 3, 4, 2, 1]) == \\"NO\\" pass def check_sequences(test_cases): Processes multiple test cases to check if each player’s points form a strictly increasing sequence. Args: test_cases: List of tuples, each containing the number of levels and a list of points. Returns: List of strings, each being \\"YES\\" or \\"NO\\" for each test case. >>> check_sequences([(3, [1, 2, 3]), (4, [1, 1, 2, 3]), (5, [5, 3, 4, 2, 1])]) == [\\"YES\\", \\"NO\\", \\"NO\\"] pass","solution":"def is_strictly_increasing(points): Determines if the points form a strictly increasing sequence. Args: points: List of integers representing points for each level. Returns: \\"YES\\" if points form a strictly increasing sequence, \\"NO\\" otherwise. for i in range(1, len(points)): if points[i] <= points[i - 1]: return \\"NO\\" return \\"YES\\" def check_sequences(test_cases): Processes multiple test cases to check if each player’s points form a strictly increasing sequence. Args: test_cases: List of tuples, each containing the number of levels and a list of points. Returns: List of strings, each being \\"YES\\" or \\"NO\\" for each test case. results = [] for n, points in test_cases: result = is_strictly_increasing(points) results.append(result) return results"},{"question":"def get_max_subsequence_sum(n: int, m: int, array: List[int]) -> int: Find the maximum possible sum of a subsequence of integers such that the sum is less than or equal to m. >>> get_max_subsequence_sum(5, 10, [2, 4, 6, 8, 10]) 10 >>> get_max_subsequence_sum(3, 15, [1, 5, 7]) 13 pass def get_max_sum_for_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: For each test case, determine the maximum subsequence sum for given n, m, and array of integers. >>> get_max_sum_for_test_cases([(5, 10, [2, 4, 6, 8, 10]), (3, 15, [1, 5, 7])]) [10, 13] pass","solution":"def get_max_subsequence_sum(n, m, array): # Using dynamic programming to solve the subset sum problem (a variation of knapsack) dp = [0] + [-1] * m for number in array: for j in range(m, number - 1, -1): if dp[j - number] != -1: dp[j] = max(dp[j], dp[j - number] + number) return max(dp) def get_max_sum_for_test_cases(test_cases): results = [] for n, m, array in test_cases: results.append(get_max_subsequence_sum(n, m, array)) return results"},{"question":"def min_sum_of_maximums(n: int, m: int) -> int: Returns the minimum sum of the maximum house numbers for the groups. Parameters: n (int): The number of houses. m (int): The number of groups to form. Returns: int: The minimum sum of the maximum house numbers for all groups. >>> min_sum_of_maximums(10, 3) 21 >>> min_sum_of_maximums(8, 4) 20 >>> min_sum_of_maximums(10, 1) 10 >>> min_sum_of_maximums(5, 5) 15 >>> min_sum_of_maximums(100, 50) 2550 >>> min_sum_of_maximums(1, 1) 1 >>> min_sum_of_maximums(100, 100) 5050","solution":"def min_sum_of_maximums(n, m): Returns the minimum sum of the maximum house numbers for the groups. Parameters: n (int): The number of houses. m (int): The number of groups to form. Returns: int: The minimum sum of the maximum house numbers for all groups. # Calculate size of each group base_group_size = n // m extra_houses = n % m min_sum = 0 max_house_number = 0 # Calculate minimum sum of maximums for i in range(m): group_size = base_group_size + (1 if i < extra_houses else 0) max_house_number += group_size min_sum += max_house_number return min_sum"},{"question":"def unique_paths_with_obstacles(grid): Consider a grid-based game in which you need to move from the top-left corner to the bottom-right corner of an m x n grid. You can only move either down or right at any point in time. However, some cells are obstacles and cannot be traversed. Your goal is to find out how many unique paths are available to reach the bottom-right corner from the top-left corner considering the obstacles. Parameters: grid (list of list of int): The grid where 1 represents an obstacle and 0 represents a free cell. Returns: int: The number of unique paths. def test_unique_paths_with_no_obstacles(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 6 def test_unique_paths_with_one_path(): grid = [ [0, 0], [0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_unique_paths_with_obstacles(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert unique_paths_with_obstacles(grid) == 2 def test_unique_paths_with_complex_obstacles(): grid = [ [0, 0, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 1, 0] ] assert unique_paths_with_obstacles(grid) == 5 def test_unique_paths_with_starting_obstacle(): grid = [ [1, 0], [0, 0] ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_with_ending_obstacle(): grid = [ [0, 0], [0, 1] ] assert unique_paths_with_obstacles(grid) == 0 def test_unique_paths_single_cell_no_obstacle(): grid = [ [0] ] assert unique_paths_with_obstacles(grid) == 1 def test_unique_paths_single_cell_with_obstacle(): grid = [ [1] ] assert unique_paths_with_obstacles(grid) == 0","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from top-left to bottom-right corner of a grid considering obstacles. Parameters: grid (list of list of int): The grid where 1 represents an obstacle and 0 represents a free cell. Returns: int: The number of unique paths. if not grid: return 0 m, n = len(grid), len(grid[0]) # If the starting cell has an obstacle, return 0 as there is no way to move anywhere if grid[0][0] == 1: return 0 # Initialize a DP table with all zeroes dp = [[0] * n for _ in range(m)] dp[0][0] = 1 # Fill the values for the first row for col in range(1, n): dp[0][col] = dp[0][col - 1] if grid[0][col] == 0 else 0 # Fill the values for the first column for row in range(1, m): dp[row][0] = dp[row - 1][0] if grid[row][0] == 0 else 0 # Fill the rest of the DP table for row in range(1, m): for col in range(1, n): if grid[row][col] == 0: dp[row][col] = dp[row - 1][col] + dp[row][col - 1] else: dp[row][col] = 0 return dp[m - 1][n - 1]"},{"question":"def max_trees_through_forest(n: int, m: int, grid: List[str]) -> int: Determine the maximum number of trees the lumberjack can pass through on their way from the start to the destination. >>> max_trees_through_forest(3, 4, [\\".T..\\", \\"TT.T\\", \\"..T.\\"]) == 3 >>> max_trees_through_forest(2, 2, [\\"..\\", \\"..\\"]) == 0 >>> max_trees_through_forest(2, 2, [\\"TT\\", \\"TT\\"]) == 3 >>> max_trees_through_forest(4, 4, [\\"T...\\", \\".T..\\", \\"..T.\\", \\"...T\\"]) == 4 >>> max_trees_through_forest(4, 4, [\\"....\\", \\"....\\", \\"....\\", \\"....\\"]) == 0","solution":"def max_trees_through_forest(n, m, grid): if grid[0][0] == 'T': dp = [[1 for _ in range(m)] for _ in range(n)] else: dp = [[0 for _ in range(m)] for _ in range(n)] for i in range(1, n): dp[i][0] = dp[i-1][0] + (1 if grid[i][0] == 'T' else 0) for j in range(1, m): dp[0][j] = dp[0][j-1] + (1 if grid[0][j] == 'T' else 0) for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + (1 if grid[i][j] == 'T' else 0) return dp[n-1][m-1]"},{"question":"def shortest_path_in_caves(N: int, M: int, edges: List[Tuple[int, int, int]], S: int, T: int) -> Union[int, str]: Determine the shortest path between two specified caves. Parameters: N (int): The number of caves (nodes). M (int): The number of paths (edges). edges (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains three integers u, v, and l. u and v represent the connected caves, and l represents the length of the path between them. S (int): The starting cave. T (int): The target cave. Returns: Union[int, str]: The length of the shortest path from cave S to cave T. If there is no path, returns \\"NO PATH\\". Examples: >>> shortest_path_in_caves(5, 6, [(1, 2, 4), (1, 3, 1), (3, 4, 2), (2, 3, 3), (2, 4, 1), (4, 5, 6)], 1, 5) 9 >>> shortest_path_in_caves(4, 2, [(1, 2, 4), (1, 3, 7)], 3, 4) 'NO PATH' from typing import List, Tuple, Union def test_example_1(): N = 5 M = 6 edges = [ (1, 2, 4), (1, 3, 1), (3, 4, 2), (2, 3, 3), (2, 4, 1), (4, 5, 6) ] S = 1 T = 5 assert shortest_path_in_caves(N, M, edges, S, T) == 9 def test_example_2(): N = 4 M = 2 edges = [ (1, 2, 4), (1, 3, 7) ] S = 3 T = 4 assert shortest_path_in_caves(N, M, edges, S, T) == \\"NO PATH\\" def test_single_node(): N = 1 M = 0 edges = [] S = 1 T = 1 assert shortest_path_in_caves(N, M, edges, S, T) == 0 def test_direct_path(): N = 2 M = 1 edges = [ (1, 2, 5) ] S = 1 T = 2 assert shortest_path_in_caves(N, M, edges, S, T) == 5 def test_no_path_between_two_nodes(): N = 2 M = 0 edges = [] S = 1 T = 2 assert shortest_path_in_caves(N, M, edges, S, T) == \\"NO PATH\\"","solution":"import heapq def dijkstra(N, edges, S, T): # Create a graph from the edges graph = {i: [] for i in range(1, N+1)} for u, v, l in edges: graph[u].append((v, l)) graph[v].append((u, l)) # Use a min heap as the priority queue pq = [(0, S)] # (distance, node) distances = {i: float('inf') for i in range(1, N+1)} distances[S] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[T] if distances[T] != float('inf') else \\"NO PATH\\" def shortest_path_in_caves(N, M, edges, S, T): return dijkstra(N, edges, S, T)"},{"question":"def candy_combinations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine how many unique combinations of candy gift boxes Anita can create. >>> candy_combinations(2, [(2, [2, 3]), (3, [1, 2, 2])]) == [6, 10] >>> candy_combinations(1, [(4, [20, 20, 20, 20])]) == [194481] >>> candy_combinations(1, [(1, [2])]) == [3]","solution":"def candy_combinations(t, test_cases): results = [] for case in test_cases: N, quantities = case total_combinations = 1 for q in quantities: total_combinations *= (q + 1) results.append(total_combinations) return results"},{"question":"def is_possible_to_merge_sorted(P: int, Q: int, B: [int], C: [int]) -> str: Determines if it's possible to reorder arrays B and C such that the merged array D is non-decreasing. Parameters: P (int): Length of array B Q (int): Length of array C B (list): List of integers representing array B C (list): List of integers representing array C Returns: str: 'YES' if it's possible, 'NO' otherwise def process_test_cases(test_cases: list) -> list: Processes multiple test cases for the possibility of reordering arrays B and C. Parameters: test_cases (list): A list of tuples, each containing (P, Q, B, C) Returns: list: List of strings 'YES' or 'NO' for each test case. # Test cases to verify the solution def test_example_1(): assert is_possible_to_merge_sorted(3, 4, [3, 1, 2], [4, 6, 5, 7]) == 'YES' def test_example_2(): assert is_possible_to_merge_sorted(2, 2, [5, 8], [1, 3]) == 'NO' def test_edge_case_1(): assert is_possible_to_merge_sorted(1, 1, [1], [2]) == 'YES' def test_edge_case_2(): assert is_possible_to_merge_sorted(1, 1, [2], [1]) == 'NO' def test_large_case_1(): P = 300 Q = 300 B = list(range(1, 301)) C = list(range(301, 601)) assert is_possible_to_merge_sorted(P, Q, B, C) == 'YES' # Already sorted def test_process_test_cases(): test_cases = [ (3, 4, [3, 1, 2], [4, 6, 5, 7]), (2, 2, [5, 8], [1, 3]) ] expected_results = ['YES', 'NO'] assert process_test_cases(test_cases) == expected_results","solution":"def is_possible_to_merge_sorted(P, Q, B, C): Determines if it's possible to reorder arrays B and C such that the merged array D is non-decreasing. Parameters: P (int): Length of array B Q (int): Length of array C B (list): List of integers representing array B C (list): List of integers representing array C Returns: str: 'YES' if it's possible, 'NO' otherwise B.sort() C.sort() # Check if we can merge in non-decreasing order starting with the smallest elements for i in range(min(P, Q)): if B[i] > C[i]: return 'NO' return 'YES' def process_test_cases(test_cases): results = [] for P, Q, B, C in test_cases: result = is_possible_to_merge_sorted(P, Q, B, C) results.append(result) return results"},{"question":"from itertools import combinations def longest_subsequence_two_chars(s: str) -> int: Returns the length of the longest subsequence that can be formed using exactly two distinct characters. Args: s (str): Input string consisting of lowercase English letters. Returns: int: Length of the longest subsequence using exactly two distinct characters. Examples: >>> longest_subsequence_two_chars(\\"abcabcabc\\") 6 >>> longest_subsequence_two_chars(\\"aabbb\\") 5 >>> longest_subsequence_two_chars(\\"abcd\\") 2 # Unit Tests import pytest def test_example_1(): assert longest_subsequence_two_chars(\\"abcabcabc\\") == 6 def test_example_2(): assert longest_subsequence_two_chars(\\"aabbb\\") == 5 def test_example_3(): assert longest_subsequence_two_chars(\\"abcd\\") == 2 def test_single_char_string(): assert longest_subsequence_two_chars(\\"aaaa\\") == 0 def test_string_with_two_characters(): assert longest_subsequence_two_chars(\\"ababab\\") == 6 def test_string_with_mixed_characters(): assert longest_subsequence_two_chars(\\"aabbaacc\\") == 6 def test_empty_string(): assert longest_subsequence_two_chars(\\"\\") == 0 def test_string_with_repeating_patterns(): assert longest_subsequence_two_chars(\\"abcabcabcabc\\") == 8 def test_string_with_all_unique_chars(): assert longest_subsequence_two_chars(\\"abcdefgh\\") == 2 def test_long_string_with_specific_chars(): assert longest_subsequence_two_chars(\\"a\\" * 50 + \\"b\\" * 50) == 100","solution":"from itertools import combinations def longest_subsequence_two_chars(s): Returns the length of the longest subsequence that can be formed using exactly two distinct characters. max_length = 0 unique_chars = set(s) for char1, char2 in combinations(unique_chars, 2): count = 0 for char in s: if char == char1 or char == char2: count += 1 max_length = max(max_length, count) return max_length"},{"question":"from fractions import Fraction def liters_to_milliliters(liters_fraction): Converts a volume in liters (given as a fraction in string form) to milliliters and represents it as a fraction in its lowest terms. Args: liters_fraction (str): A string representing a fractional number in liters, such as 'a/b' or '-a/b'. Returns: str: A string representing the exact result in milliliters, expressed as a fraction in lowest terms. Examples: >>> liters_to_milliliters(\\"1/1\\") '1000/1' >>> liters_to_milliliters(\\"3/2\\") '1500/1' >>> liters_to_milliliters(\\"-7/4\\") '-1750/1' # Implement the function here # Unit tests def test_liters_to_milliliters_simple_case(): assert liters_to_millilitlers(\\"1/1\\") == \\"1000/1\\" def test_liters_to_milliliters_fraction(): assert liters_to_milliliters(\\"3/2\\") == \\"1500/1\\" def test_liters_to_milliliters_negative_fraction(): assert liters_to_milliliters(\\"-7/4\\") == \\"-1750/1\\" def test_liters_to_milliliters_reduced_fraction(): assert liters_to_milliliters(\\"2/4\\") == \\"500/1\\" def test_liters_to_milliliters_large_fraction(): assert liters_to_milliliters(\\"1000000/1000\\") == \\"1000000/1\\" def test_liters_to_milliliters_irreducible_fraction(): assert liters_to_milliliters(\\"7/9\\") == \\"7000/9\\"","solution":"from fractions import Fraction def liters_to_milliliters(liters_fraction): Converts a volume in liters (given as a fraction in string form) to milliliters and represents it as a fraction in its lowest terms. fraction = Fraction(liters_fraction) milliliters = fraction * 1000 return f\\"{milliliters.numerator}/{milliliters.denominator}\\""},{"question":"def arrayProduct(arr): Returns an array such that each element is the product of all the numbers in the input array except the one at its index. Parameters: arr (list[int]): A list of integers Returns: list[int]: A list where each element at index i is the product of all elements in the input array except the one at i. Examples: >>> arrayProduct([1, 2, 3, 4]) [24, 12, 8, 6] >>> arrayProduct([5, 6, 2]) [12, 10, 30] def processInput(test_cases): Processes multiple test cases for the arrayProduct function and returns results for each test case. Parameters: test_cases (list[list[int]]): A list of test cases, where each test case is a list of integers. Returns: list[list[int]]: A list of results for each test case. Examples: >>> processInput([[1, 2, 3, 4], [5, 6, 2]]) [[24, 12, 8, 6], [12, 10, 30]]","solution":"def arrayProduct(arr): Returns an array such that each element is the product of all the numbers in the input array except the one at its index. length = len(arr) if length == 1: return [0] # Initialize arrays to get left and right products left_products = [1] * length right_products = [1] * length # Compute left products for i in range(1, length): left_products[i] = left_products[i - 1] * arr[i - 1] # Compute right products for j in range(length - 2, -1, -1): right_products[j] = right_products[j + 1] * arr[j + 1] # Compute result by multiplying left and right products result = [1] * length for k in range(length): result[k] = left_products[k] * right_products[k] return result def processInput(test_cases): result = [] for arr in test_cases: result.append(arrayProduct(arr)) return result"},{"question":"def min_operations_to_equalize_sequence(M: int, b: List[int]) -> int: Determine the minimum number of operations needed to make all elements in b the same. :param M: int, the length of the sequence b :param b: list of int, the sequence of integers :return: int, the minimum number of operations required >>> min_operations_to_equalize_sequence(5, [3, 1, 4, 1, 5]) 4 >>> min_operations_to_equalize_sequence(3, [1, 2, 3]) 3 >>> min_operations_to_equalize_sequence(4, [2, 2, 2, 2]) 0 >>> min_operations_to_equalize_sequence(6, [1, 2, 1, 2, 1, 2]) 3 >>> min_operations_to_equalize_sequence(5, [5, 10, 15, 20, 25]) 50 pass","solution":"def min_operations_to_equalize_sequence(M, b): Returns the minimum number of operations required to make all elements in the sequence b the same. Parameters: - M: int, the length of the sequence b - b: list of int, the sequence of integers Returns: - int, the minimum number of operations required # We need to find the maximum element in the sequence max_element = max(b) # We need to transform each element in the sequence to match this maximum element operations = 0 for element in b: operations += max_element - element return operations"},{"question":"def modified_bubble_sort(arr): Sorts an array in ascending order using a modified version of bubble sort where any two elements can be swapped exactly once in each iteration. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list in ascending order. pass if __name__ == \\"__main__\\": import pytest def test_sort_ascending_order(): assert modified_bubble_sort([3, 1, 5, 4, 2]) == [1, 2, 3, 4, 5] def test_sort_with_three_elements(): assert modified_bubble_sort([10, 2, 7]) == [2, 7, 10] def test_sort_single_element(): assert modified_bubble_sort([1]) == [1] def test_sort_negative_numbers(): assert modified_bubble_sort([-3, 1, -5, 4, 2]) == [-5, -3, 1, 2, 4] def test_sort_already_sorted(): assert modified_bubble_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_sort_reverse_order(): assert modified_bubble_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_sort_duplicate_elements(): assert modified_bubble_sort([4, 5, 4, 3, 2]) == [2, 3, 4, 4, 5] def test_sort_large_array(): arr = list(range(100, 0, -1)) sorted_arr = list(range(1, 101)) assert modified_bubble_sort(arr) == sorted_arr pytest.main()","solution":"def modified_bubble_sort(arr): Sorts an array in ascending order using a modified version of bubble sort where any two elements can be swapped exactly once in each iteration. Parameters: arr (list): List of integers to be sorted. Returns: list: Sorted list in ascending order. n = len(arr) for i in range(n - 1): max_index = 0 # Find the maximum element in the unsorted part of the array for j in range(1, n - i): if arr[j] > arr[max_index]: max_index = j # Swap the maximum element found with the end of the unsorted part arr[max_index], arr[n - i - 1] = arr[n - i - 1], arr[max_index] return arr"},{"question":"def transform_string(s: str) -> str: Transforms the given string based on defined rules: 1. Shift letters by one in the alphabet (with wrap-around for 'z'). 2. Increment digits by 1 (with wrap-around for '9'). 3. Leave spaces unchanged. Args: s (str): The input string to transform. Returns: str: The transformed string. >>> transform_string(\\"hello world 123\\") 'ifmmp xpsme 234' >>> transform_string(\\"abcdefghijklmnopqrstuvwxyz\\") 'bcdefghijklmnopqrstuvwxyza' >>> transform_string(\\"0123456789\\") '1234567890' >>> transform_string(\\"a1b2 c3d4 e5f6 g7h8 i9j0\\") 'b2c3 d4e5 f6g7 h8i9 j0k1' >>> transform_string(\\" \\") ' ' >>> transform_string(\\"z\\") 'a' >>> transform_string(\\"9\\") '0' >>> transform_string(\\" \\") ' '","solution":"def transform_string(s): Transforms the given string based on defined rules: 1. Shift letters by one in the alphabet (with wrap-around for 'z'). 2. Increment digits by 1 (with wrap-around for '9'). 3. Leave spaces unchanged. Args: s (str): The input string to transform. Returns: str: The transformed string. transformed = [] for char in s: if char.isalpha(): if char == 'z': transformed.append('a') else: transformed.append(chr(ord(char) + 1)) elif char.isdigit(): if char == '9': transformed.append('0') else: transformed.append(str(int(char) + 1)) else: # char is a space transformed.append(char) return ''.join(transformed)"},{"question":"def decode_message(numbers: List[int]) -> int: Decodes the ancient message based on the given space-separated integers. >>> decode_message([3, 9, 15, 1]) 4 >>> decode_message([3, 15]) 2 >>> decode_message([4, 7, 11]) 0 >>> decode_message([9, 9, 9]) 1 >>> decode_message([3, 9, 15, 21, 25, 3]) 3","solution":"def decode_message(numbers): Decodes the ancient message based on the given space-separated integers. Args: numbers (list): List of integers. Returns: int: The decoded integer representing clarity (claritatem). # Create the mapping based on the ancient message riddle ancient_riddle = {15: 'Sphinx', 9: 'Leviathan', 3: 'Cerberus', 1: 'Dragon'} # Decode the numbers according to the riddle mapping decoded_values = [key for key in ancient_riddle.keys() if key in numbers] # The final output is the length of the decoded values return len(decoded_values)"},{"question":"def filter_non_negative(lst): Returns a new list containing only the non-negative integers from the original list, in the original order. Parameters: lst (list of int): The list of integers to filter. Returns: list of int: A new list containing only the non-negative integers.","solution":"def filter_non_negative(lst): Returns a new list containing only the non-negative integers from the original list, in the original order. Parameters: lst (list of int): The list of integers to filter. Returns: list of int: A new list containing only the non-negative integers. return [x for x in lst if x >= 0]"},{"question":"def packageCookies(cookies): Decide how many completely filled boxes (holding exactly 20 cookies) and partially filled boxes (holding between 12 and 19 cookies) can be produced from a given number of cookies, leaving as few unboxed cookies as possible. Args: cookies (int): the total number of cookies Returns: list: a list where the first element is the number of full boxes, the second element is the number of partial boxes, and the third element is the number of leftover cookies Examples: >>> packageCookies(89) [4, 0, 9] >>> packageCookies(45) [2, 0, 5]","solution":"def packageCookies(cookies): full_boxes = cookies // 20 leftover_cookies = cookies % 20 if 12 <= leftover_cookies <= 19: partial_boxes = 1 leftover_cookies -= leftover_cookies # This will make leftover_cookies 0 else: partial_boxes = 0 return [full_boxes, partial_boxes, leftover_cookies]"},{"question":"def rearrangement_possible(T, test_cases): Determine if arrays can be rearranged such that no two adjacent integers differ by more than 1. Args: T: int, number of test cases test_cases: list of tuples, each containing: - N: int, the size of the array - ages: list of ints, the ages in the community Returns: List of strings, \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. >>> T = 2 >>> test_cases = [(5, [3, 5, 4, 4, 3]), (6, [1, 2, 2, 5, 4, 4])] >>> rearrangement_possible(T, test_cases) [\\"POSSIBLE\\", \\"IMPOSSIBLE\\"]","solution":"def rearrangement_possible(T, test_cases): results = [] for t in range(T): N, ages = test_cases[t] ages.sort() possible = True for i in range(1, N): if abs(ages[i] - ages[i-1]) > 1: possible = False break results.append(\\"POSSIBLE\\" if possible else \\"IMPOSSIBLE\\") return results # Example usage if __name__ == \\"__main__\\": T = 2 test_cases = [ (5, [3, 5, 4, 4, 3]), (6, [1, 2, 2, 5, 4, 4]) ] print(rearrangement_possible(T, test_cases)) # Should output ['POSSIBLE', 'IMPOSSIBLE']"},{"question":"def min_distance_between_metallic_objects(n: int, m: int, grid: List[str]) -> int: Calculate the minimum distance between any two metallic objects in the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: Minimum distance between any two metallic objects >>> min_distance_between_metallic_objects(3, 4, [\\"....\\", \\".M..\\", \\"...M\\"]) 3 >>> min_distance_between_metallic_objects(5, 5, [\\".....\\", \\".....\\", \\".MM..\\", \\".....\\", \\"M...M\\"]) 1 >>> min_distance_between_metallic_objects(1, 4, [\\"M..M\\"]) 3","solution":"def min_distance_between_metallic_objects(n, m, grid): Calculate the minimum distance between any two metallic objects in the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: Minimum distance between any two metallic objects # List to store positions of all metallic objects metallic_positions = [] # Collect the positions of all metallic objects for r in range(n): for c in range(m): if grid[r][c] == 'M': metallic_positions.append((r, c)) # Initialize the minimum distance with a high value min_dist = float('inf') # Compare each pair of metallic objects to determine the minimum distance for i in range(len(metallic_positions)): for j in range(i + 1, len(metallic_positions)): (r1, c1) = metallic_positions[i] (r2, c2) = metallic_positions[j] # Calculate Manhattan distance and update min_dist dist = abs(r1 - r2) + abs(c1 - c2) if dist < min_dist: min_dist = dist return min_dist"},{"question":"def longest_palindromic_substring(s: str) -> str: Finds the longest palindromic substring in a given string. Args: s (str): The input string. Returns: str: The longest palindromic substring. Examples: >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb'","solution":"def longest_palindromic_substring(s): Finds the longest palindromic substring in a given string. Args: s (str): The input string. Returns: str: The longest palindromic substring. n = len(s) if n == 0: return \\"\\" # Function to expand around the center def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] max_palindrome = \\"\\" for i in range(n): # Odd length palindromes odd_palindrome = expand_around_center(i, i) # Even length palindromes even_palindrome = expand_around_center(i, i + 1) # Compare and update the maximum palindrome if len(odd_palindrome) > len(max_palindrome): max_palindrome = odd_palindrome if len(even_palindrome) > len(max_palindrome): max_palindrome = even_palindrome return max_palindrome"},{"question":"def max_warehouse_weight(log_entries): Returns the maximum weight held by the warehouse at any given time. Parameters: - log_entries: list of tuples containing (T, W, Op) for N log entries. Returns: - Integer: maximum weight held by the warehouse at any given time. pass def parse_input(input_str): Parses the input string and returns a list of log entries. Parameters: - input_str: string containing the log entries. Returns: - List of tuples containing (T, W, Op) for N log entries. pass # Example usage input_str = 5 1 100 enter 2 200 enter 3 150 enter 4 100 exit 5 150 exit log_entries = parse_input(input_str) print(max_warehouse_weight(log_entries)) # Output should be 450 def test_example_case(): input_str = 5 1 100 enter 2 200 enter 3 150 enter 4 100 exit 5 150 exit log_entries = parse_input(input_str) assert max_warehouse_weight(log_entries) == 450 def test_all_enter_and_exit(): input_str = 4 1 100 enter 2 100 enter 3 100 exit 4 100 exit log_entries = parse_input(input_str) assert max_warehouse_weight(log_entries) == 200 def test_single_entry_exit(): input_str = 2 1 100 enter 2 100 exit log_entries = parse_input(input_str) assert max_warehouse_weight(log_entries) == 100 def test_no_entries(): input_str = 0 log_entries = parse_input(input_str) assert max_warehouse_weight(log_entries) == 0 def test_large_numbers(): input_str = 3 1 500000 enter 2 400000 enter 3 900000 exit log_entries = parse_input(input_str) assert max_warehouse_weight(log_entries) == 900000","solution":"def max_warehouse_weight(log_entries): Returns the maximum weight held by the warehouse at any given time. Parameters: - log_entries: list of tuples containing (T, W, Op) for N log entries. Returns: - Integer: maximum weight held by the warehouse at any given time. current_weight = 0 max_weight = 0 for _, weight, operation in log_entries: if operation == \\"enter\\": current_weight += weight elif operation == \\"exit\\": current_weight -= weight if current_weight > max_weight: max_weight = current_weight return max_weight # Function to parse the input and return the list of log entries def parse_input(input_str): input_lines = input_str.strip().split('n') N = int(input_lines[0]) log_entries = [] for i in range(1, N+1): T, W, Op = input_lines[i].split() T = int(T) W = int(W) log_entries.append((T, W, Op)) return log_entries # Example usage input_str = 5 1 100 enter 2 200 enter 3 150 enter 4 100 exit 5 150 exit log_entries = parse_input(input_str) print(max_warehouse_weight(log_entries)) # Output: 450"},{"question":"from typing import List, Tuple def shortest_transmission_time(n: int, m: int, A: int, B: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum transmission time between two nodes in an undirected graph. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. A (int): The starting node. B (int): The ending node. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, w) indicating an edge between nodes u and v with weight w. Returns: int: The minimum transmission time from node A to node B. If there is no path, return -1. Example: >>> shortest_transmission_time(4, 4, 1, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 1), (1, 3, 4)]) 4 >>> shortest_transmission_time(3, 1, 1, 3, [(1, 2, 1)]) -1","solution":"import heapq def shortest_transmission_time(n, m, A, B, edges): # Create the adjacency list representation of the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path from A to B pq = [(0, A)] dist = {i: float('inf') for i in range(1, n + 1)} dist[A] = 0 visited = set() while pq: current_dist, node = heapq.heappop(pq) if node in visited: continue visited.add(node) if node == B: return current_dist for neighbor, weight in graph[node]: if neighbor not in visited: new_dist = current_dist + weight if new_dist < dist[neighbor]: dist[neighbor] = new_dist heapq.heappush(pq, (new_dist, neighbor)) return -1 if dist[B] == float('inf') else dist[B]"},{"question":"def warehouse_manager(inventory, operations): Manages the warehouse inventory based on the provided operations. Args: inventory (dict): A dictionary representing the initial inventory with categories as keys and counts as values. operations (list): A list of tuples where each tuple represents an operation. Returns: list: A list of results for 'retrieve' operations. Example usage: >>> initial_inventory = { >>> 'electronics': 50, >>> 'clothing': 200, >>> 'groceries': 150, >>> } >>> operations = [ >>> ('add', 'electronics', 20), >>> ('update', 'clothing', 180), >>> ('retrieve', 'groceries'), >>> ('retrieve', 'furniture'), >>> ('add', 'stationery', 100), >>> ('retrieve', 'stationery'), >>> ] >>> warehouse_manager(initial_inventory, operations) [150, 0, 100] from solution import warehouse_manager def test_add_existing_category(): inventory = {'electronics': 50} operations = [('add', 'electronics', 20)] expected_result = [] assert warehouse_manager(inventory, operations) == expected_result assert inventory['electronics'] == 70 def test_add_new_category(): inventory = {'electronics': 50} operations = [('add', 'furniture', 30)] expected_result = [] assert warehouse_manager(inventory, operations) == expected_result assert inventory['furniture'] == 30 def test_update_existing_category(): inventory = {'electronics': 50} operations = [('update', 'electronics', 25)] expected_result = [] assert warehouse_manager(inventory, operations) == expected_result assert inventory['electronics'] == 25 def test_update_new_category(): inventory = {'electronics': 50} operations = [('update', 'furniture', 30)] expected_result = [] assert warehouse_manager(inventory, operations) == expected_result assert inventory['furniture'] == 30 def test_retrieve_existing_category(): inventory = {'electronics': 50} operations = [('retrieve', 'electronics')] expected_result = [50] assert warehouse_manager(inventory, operations) == expected_result def test_retrieve_non_existing_category(): inventory = {'electronics': 50} operations = [('retrieve', 'furniture')] expected_result = [0] assert warehouse_manager(inventory, operations) == expected_result def test_mixed_operations(): inventory = { 'electronics': 50, 'clothing': 200, 'groceries': 150, } operations = [ ('add', 'electronics', 20), ('update', 'clothing', 180), ('retrieve', 'groceries'), ('retrieve', 'furniture'), ('add', 'stationery', 100), ('retrieve', 'stationery'), ] expected_result = [150, 0, 100] assert warehouse_manager(inventory, operations) == expected_result","solution":"def warehouse_manager(inventory, operations): Manages the warehouse inventory based on the provided operations. Args: inventory (dict): A dictionary representing the initial inventory with categories as keys and counts as values. operations (list): A list of tuples where each tuple represents an operation. Returns: list: A list of results for 'retrieve' operations. results = [] for operation in operations: op_type = operation[0] category = operation[1] if op_type == 'add': count = operation[2] if category in inventory: inventory[category] += count else: inventory[category] = count elif op_type == 'update': new_count = operation[2] inventory[category] = new_count elif op_type == 'retrieve': results.append(inventory.get(category, 0)) return results"},{"question":"def is_secure_password(password: str) -> str: Returns 'secure' if the password meets the security criteria, otherwise 'insecure'. Security criteria: - At least one uppercase letter. - At least one lowercase letter. - At least one numeric digit. - Minimum length of 8 characters. - No spaces allowed. Examples: >>> is_secure_password(\\"A1b2c3d4\\") \\"secure\\" >>> is_secure_password(\\"abcdefG1\\") \\"secure\\" >>> is_secure_password(\\"12345678\\") \\"insecure\\" >>> is_secure_password(\\"AbcDefG\\") \\"insecure\\" >>> is_secure_password(\\"SecurePassw0rd\\") \\"secure\\" >>> is_secure_password(\\"Invalid Password\\") \\"insecure\\"","solution":"def is_secure_password(password): Returns 'secure' if the password meets the security criteria, otherwise 'insecure'. Security criteria: - At least one uppercase letter. - At least one lowercase letter. - At least one numeric digit. - Minimum length of 8 characters. - No spaces allowed. if len(password) < 8: return \\"insecure\\" has_upper = any(char.isupper() for char in password) has_lower = any(char.islower() for char in password) has_digit = any(char.isdigit() for char in password) has_space = any(char.isspace() for char in password) if has_upper and has_lower and has_digit and not has_space: return \\"secure\\" else: return \\"insecure\\""},{"question":"def calculate_directory_size(directory): Computes the total size of a directory, including the sizes of its files and all subdirectory contents. Args: directory (dict): JSON object representing a directory. Returns: int: Total size of the directory in bytes. pass from solution import calculate_directory_size def test_empty_directory(): directory = { \\"type\\": \\"directory\\", \\"contents\\": [] } assert calculate_directory_size(directory) == 0 def test_directory_with_single_file(): directory = { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 100} ] } assert calculate_directory_size(directory) == 100 def test_directory_with_multiple_files(): directory = { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 100}, {\\"type\\": \\"file\\", \\"size\\": 200} ] } assert calculate_directory_size(directory) == 300 def test_directory_with_nested_directories(): directory = { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 100}, { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 50}, {\\"type\\": \\"file\\", \\"size\\": 30} ] } ] } assert calculate_directory_size(directory) == 180 def test_complex_nested_directories(): directory = { \\"type\\": \\"directory\\", \\"contents\\": [ { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 10} ] }, { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 20}, { \\"type\\": \\"directory\\", \\"contents\\": [ {\\"type\\": \\"file\\", \\"size\\": 30} ] } ] }, {\\"type\\": \\"file\\", \\"size\\": 40} ] } assert calculate_directory_size(directory) == 100","solution":"def calculate_directory_size(directory): Computes the total size of a directory, including the sizes of its files and all subdirectory contents. Args: directory (dict): JSON object representing a directory. Returns: int: Total size of the directory in bytes. total_size = 0 for item in directory[\\"contents\\"]: if item[\\"type\\"] == \\"file\\": total_size += item[\\"size\\"] elif item[\\"type\\"] == \\"directory\\": total_size += calculate_directory_size(item) return total_size"},{"question":"def calculate_total_power(T: int, test_cases: List[Dict[str, Any]]) -> List[int]: Calculate the total power of a player based on their card powers and the magic subsequence rules. >>> calculate_total_power(1, [{'N': 5, 'card_powers': [3, 6, 3, 2, 1], 'M': 2, 'magic_subseq': [3, 6]}]) [30] >>> calculate_total_power(1, [{'N': 6, 'card_powers': [1, 2, 3, 4, 5, 6], 'M': 3, 'magic_subseq': [2, 3, 4]}]) [42] >>> calculate_total_power(1, [{'N': 6, 'card_powers': [1, 2, 3, 4, 5, 6], 'M': 2, 'magic_subseq': [4, 6]}]) [21] >>> calculate_total_power(2, [ ... {'N': 5, 'card_powers': [3, 6, 3, 2, 1], 'M': 2, 'magic_subseq': [3, 6]}, ... {'N': 6, 'card_powers': [1, 2, 3, 4, 5, 6], 'M': 3, 'magic_subseq': [2, 3, 4]} ... ]) [30, 42]","solution":"def calculate_total_power(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] card_powers = test_cases[i]['card_powers'] M = test_cases[i]['M'] magic_subseq = test_cases[i]['magic_subseq'] total_power = sum(card_powers) magic_subseq_count = 0 for j in range(N - M + 1): if card_powers[j:j+M] == magic_subseq: magic_subseq_count += 1 total_power *= (2 ** magic_subseq_count) results.append(total_power) return results"},{"question":"def uniqueSubsets(nums): Return all unique subsets of the given list of integers. >>> uniqueSubsets([1, 2, 2]) [[], [1], [2], [1,2], [1,2,2], [2,2]] >>> uniqueSubsets([1]) [[], [1]] from solution import uniqueSubsets def test_example1(): nums = [1, 2, 2] expected = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] assert uniqueSubsets(nums) == expected def test_example2(): nums = [1] expected = [[], [1]] assert uniqueSubsets(nums) == expected def test_empty(): nums = [] expected = [[]] assert uniqueSubsets(nums) == expected def test_no_duplicates(): nums = [1, 2, 3] expected = [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] assert uniqueSubsets(nums) == expected def test_all_duplicates(): nums = [1, 1, 1] expected = [[], [1], [1, 1], [1, 1, 1]] assert uniqueSubsets(nums) == expected def test_negative_numbers(): nums = [-1, 0, 1] expected = [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] assert uniqueSubsets(nums) == expected","solution":"def uniqueSubsets(nums): Return all unique subsets of the given list of integers. nums.sort() result = [] subset = [] def backtrack(start): result.append(subset[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i-1]: continue subset.append(nums[i]) backtrack(i+1) subset.pop() backtrack(0) return result"},{"question":"def run_length_encoding(n, bytes_list): Compresses a list of bytes using run-length encoding (RLE). Parameters: n (int): The number of bytes. bytes_list (list of int): The list of bytes to compress. Returns: list of int: The run-length encoded representation of the input bytes. pass from run_length_encoding import run_length_encoding def test_run_length_encoding_example_case(): assert run_length_encoding(10, [10, 10, 10, 20, 20, 20, 20, 20, 30, 30]) == [10, 3, 20, 5, 30, 2] def test_run_length_encoding_single_element(): assert run_length_encoding(1, [42]) == [42, 1] def test_run_length_encoding_no_repeats(): assert run_length_encoding(3, [1, 2, 3]) == [1, 1, 2, 1, 3, 1] def test_run_length_encoding_all_same(): assert run_length_encoding(5, [7, 7, 7, 7, 7]) == [7, 5] def test_run_length_encoding_mixed(): assert run_length_encoding(7, [5, 5, 6, 6, 6, 7, 7]) == [5, 2, 6, 3, 7, 2] def test_run_length_encoding_empty_list(): assert run_length_encoding(0, []) == [] def test_run_length_encoding_edge_case(): assert run_length_encoding(3, [100, 100, 101]) == [100, 2, 101, 1]","solution":"def run_length_encoding(n, bytes_list): Compresses a list of bytes using run-length encoding (RLE). Parameters: n (int): The number of bytes. bytes_list (list of int): The list of bytes to compress. Returns: list of int: The run-length encoded representation of the input bytes. if n == 0: return [] encoded_list = [] current_byte = bytes_list[0] count = 1 for i in range(1, n): if bytes_list[i] == current_byte: count += 1 else: encoded_list.append(current_byte) encoded_list.append(count) current_byte = bytes_list[i] count = 1 # Append the last run encoded_list.append(current_byte) encoded_list.append(count) return encoded_list"},{"question":"def generate_sequence(a: int, n: int) -> List[int]: Generates a sequence based on the rule provided. >>> generate_sequence(5, 5) [5, 10, 11, 13, 17] >>> generate_sequence(12, 4) [12, 15, 21, 24] >>> generate_sequence(98, 3) [98, 115, 122]","solution":"def generate_sequence(a, n): Generates a sequence based on the rule provided. sequence = [a] for _ in range(1, n): next_value = sequence[-1] + sum(int(digit) for digit in str(sequence[-1])) sequence.append(next_value) return sequence def main(): import sys input = sys.stdin.read data = input().strip().split() T = int(data[0]) index = 1 results = [] for _ in range(T): a = int(data[index]) n = int(data[index + 1]) index += 2 sequence = generate_sequence(a, n) results.append(sequence) for result in results: print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def is_balanced_parentheses(s: str) -> str: Checks if the given string of parentheses is balanced. :param s: A string consisting of '(' and ')' :return: \\"Balanced\\" if the string is balanced, otherwise \\"Unbalanced\\" >>> is_balanced_parentheses(\\"(())\\") \\"Balanced\\" >>> is_balanced_parentheses(\\"(()\\") \\"Unbalanced\\"","solution":"def is_balanced_parentheses(s): Checks if the given string of parentheses is balanced. :param s: A string consisting of '(' and ')' :return: \\"Balanced\\" if the string is balanced, otherwise \\"Unbalanced\\" stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"Unbalanced\\" stack.pop() return \\"Balanced\\" if not stack else \\"Unbalanced\\""},{"question":"def max_possible_value(n, p, m, a): Determines the maximum possible value of any element in the array after performing at most p operations. Args: n (int): the number of elements in the array. p (int): the maximum number of operations allowed. m (int): the maximum multiplier value. a (list): the list of integers representing the array. Returns: int: the maximum possible value of any element in the array. >>> max_possible_value(3, 2, 3, [2, 5, 7]) 21 >>> max_possible_value(4, 0, 4, [3, 1, 4, 2]) 4 >>> max_possible_value(5, 1, 10, [1, 2, 3, 4, 5]) 50 def test_max_possible_value(): assert max_possible_value(3, 2, 3, [2, 5, 7]) == 21 assert max_possible_value(4, 0, 4, [3, 1, 4, 2]) == 4 assert max_possible_value(5, 1, 10, [1, 2, 3, 4, 5]) == 50 assert max_possible_value(2, 3, 5, [1, 2]) == 10 assert max_possible_value(1, 2, 4, [2]) == 8 assert max_possible_value(3, 3, 2, [3, 6, 9]) == 18 assert max_possible_value(5, 0, 3, [1, 4, 1, 4, 1]) == 4 if __name__ == \\"__main__\\": test_max_possible_value() print(\\"All tests passed\\")","solution":"def max_possible_value(n, p, m, a): Determines the maximum possible value of any element in the array after performing at most p operations. Args: n (int): the number of elements in the array. p (int): the maximum number of operations allowed. m (int): the maximum multiplier value. a (list): the list of integers representing the array. Returns: int: the maximum possible value of any element in the array. # If no operations are allowed, the maximum value is the maximum element in the array if p == 0: return max(a) # Calculate the maximum value by considering the maximum allowed multiplier and available operations max_val = 0 for value in a: for _ in range(min(p, 1)): # we only apply the operation once as subsequent multiplications can be seen as one value *= m max_val = max(max_val, value) return max_val"},{"question":"def min_donations(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determine the smallest combination of donations that sum up to a target value. Parameters: t (int): the number of test cases. test_cases (List[Tuple[int, int, List[int]]]): a list of tuples, each containing the number of donations, the target value, and a list of possible donation values. Returns: List[int]: a list containing the minimum number of donations needed for each test case, or -1 if it's not possible to reach the target value. >>> min_donations(2, [(3, 11, [1, 2, 5]), (4, 8, [3, 4, 5, 6])]) [3, 2] >>> min_donations(1, [(2, 7, [3, 6])]) [-1]","solution":"def min_donations(t, test_cases): results = [] for case in test_cases: n, target, donations = case dp = [float('inf')] * (target + 1) dp[0] = 0 for i in range(1, target + 1): for donation in donations: if i - donation >= 0: dp[i] = min(dp[i], dp[i - donation] + 1) results.append(dp[target] if dp[target] != float('inf') else -1) return results"},{"question":"from typing import List, Tuple def min_speed_adjustments(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of speed adjustments required for the train to traverse the tunnel without violating any speed limits. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : a list of tuples, where each tuple contains the number of sections in the tunnel and a list of speed limits for each section Returns: List[int] : a list of integers, each representing the minimum number of speed adjustments for each test case. >>> min_speed_adjustments(3, [(5, [4, 3, 5, 2, 1]), (4, [1, 1, 1, 1]), (6, [6, 5, 4, 3, 2, 1])]) [4, 0, 5] >>> min_speed_adjustments(1, [(3, [1, 2, 3])]) [2]","solution":"def min_speed_adjustments(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] speed_limits = test_cases[i][1] adjustments = 0 for j in range(1, N): if speed_limits[j] != speed_limits[j-1]: adjustments += 1 results.append(adjustments) return results"},{"question":"from typing import List, Tuple def manage_docks(M: int, P: int, queries: List[Tuple[int, int]]) -> List[int]: Manage the docking and departure of ships for a given number of queries. Args: M : int : Number of docks available. P : int : Number of queries to be handled. queries : List[Tuple[int, int]] : List of queries where each query is a tuple with two integers. - 1 x: A ship docks at dock \`x\`. - 2 x: A ship departs from dock \`x\`. - 3 x: Output the number of ships currently docked at dock \`x\`. Returns: List[int] : A list of integers where each integer represents the result of a type 3 query. Example: >>> manage_docks(5, 7, [(1, 2), (1, 3), (1, 3), (3, 3), (2, 3), (3, 3), (3, 2)]) [2, 1, 1] >>> manage_docks(1, 5, [(1, 1), (3, 1), (1, 1), (2, 1), (3, 1)]) [1, 1] >>> manage_docks(3, 9, [(1, 1), (1, 2), (1, 3), (3, 1), (3, 2), (3, 3), (2, 3), (3, 3), (3, 2)]) [1, 1, 1, 0, 1] >>> manage_docks(2, 4, [(1, 1), (2, 1), (1, 2), (3, 2)]) [1] >>> manage_docks(10, 0, []) []","solution":"def manage_docks(M, P, queries): Manage the docking and depart of ships for a given number of queries. dock_counts = [0] * (M + 1) results = [] for query in queries: if query[0] == 1: # a ship docks at dock \`x\` dock_counts[query[1]] += 1 elif query[0] == 2: # a ship departs from dock \`x\` dock_counts[query[1]] -= 1 elif query[0] == 3: # output the number of ships at dock \`x\` results.append(dock_counts[query[1]]) return results # Example usage # M = 5, P = 7 # queries = [ # (1, 2), # (1, 3), # (1, 3), # (3, 3), # (2, 3), # (3, 3), # (3, 2) # ] # print(manage_docks(M, P, queries)) -> [2, 1, 1]"},{"question":"def rotate_90_clockwise(matrix): Rotate the given n x n matrix 90 degrees clockwise. pass def is_possible_to_transform(initial_matrix, target_matrix): Check if the target matrix can be obtained from the initial matrix via any number of 90 degree rotations. pass def matrix_transformation_possible(t, test_cases): Determine if the target matrices can be obtained from the initial matrices for the given test cases. Args: t: int - The number of test cases. test_cases: List[Tuple[int, List[List[int]], List[List[int]]]] - The list of test cases. Each test case is represented by a tuple containing the size of the matrices, the initial matrix, and the target matrix. Returns: List[str] - List of results for each test case. \\"Possible\\" if transformation is possible, otherwise \\"Impossible\\". >>> matrix_transformation_possible(3, [ ... (2, [[1, 2], [3, 4]], [[3, 1], [4, 2]]), ... (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]), ... (2, [[1, 2], [3, 4]], [[1, 2], [4, 3]]) ... ]) ['Possible', 'Possible', 'Impossible'] results = [] for i in range(t): n, initial_matrix, target_matrix = test_cases[i] result = is_possible_to_transform(initial_matrix, target_matrix) results.append(result) return results","solution":"def rotate_90_clockwise(matrix): Rotate the given n x n matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def is_possible_to_transform(initial_matrix, target_matrix): Check if the target matrix can be obtained from the initial matrix via any number of 90 degree rotations. current_matrix = initial_matrix for _ in range(4): if current_matrix == target_matrix: return \\"Possible\\" current_matrix = rotate_90_clockwise(current_matrix) return \\"Impossible\\" def matrix_transformation_possible(t, test_cases): results = [] for i in range(t): n, initial_matrix, target_matrix = test_cases[i] result = is_possible_to_transform(initial_matrix, target_matrix) results.append(result) return results"},{"question":"from typing import List def count_even_product_pairs(nums: List[int]) -> int: Given a list of N integers, returns the number of pairs of indices (i, j) such that: 1. 1 ≤ i < j ≤ N 2. The product of the elements at those indices is even. >>> count_even_product_pairs([3, 4, 1, 2]) 5 >>> count_even_product_pairs([2, 4, 6, 8]) 6 >>> count_even_product_pairs([1, 3, 5, 7]) 0 >>> count_even_product_pairs([3, 2, 7, 8, 5]) 7 >>> count_even_product_pairs([2]) 0 >>> count_even_product_pairs([3]) 0 >>> count_even_product_pairs([-2, 3, -4, -5]) 5 >>> count_even_product_pairs([2]*1000) 499500 >>> count_even_product_pairs([1]*1000) 0","solution":"from typing import List def count_even_product_pairs(nums: List[int]) -> int: even_count = sum(1 for num in nums if num % 2 == 0) odd_count = len(nums) - even_count # Total pairs that can be formed from n elements is n*(n-1)/2 total_pairs = len(nums) * (len(nums) - 1) // 2 # Pairs formed by odd numbers (product will be odd) odd_pairs = odd_count * (odd_count - 1) // 2 # Subtract odd pairs from total pairs even_product_pairs = total_pairs - odd_pairs return even_product_pairs"},{"question":"def most_played_song(n: int, songs: List[Tuple[str, int]]) -> str: Returns the name of the song with the highest play count. In case of a tie, returns the lexicographically smallest song name among those with the highest play count. Parameters: n (int): Number of songs. songs (list): List of tuples where each tuple contains a song name (str) and its play count (int). Returns: str: The name of the song with the highest play count or the lexicographically smallest song name in case of tie. pass # Sample Test Cases def test_single_song(): assert most_played_song(1, [(\\"singlesong\\", 1)]) == \\"singlesong\\" def test_all_songs_once(): assert most_played_song(3, [(\\"songone\\", 1), (\\"songtwo\\", 1), (\\"songthree\\", 1)]) == \\"songone\\" def test_multiple_songs_with_same_highest_count(): assert most_played_song(3, [(\\"songa\\", 30), (\\"songb\\", 30), (\\"songc\\", 10)]) == \\"songa\\" def test_highest_play_count(): assert most_played_song(4, [(\\"rockstar\\", 1000), (\\"popstar\\", 1000), (\\"metallica\\", 999), (\\"classical\\", 1001)]) == \\"classical\\" def test_lexicographical_order(): assert most_played_song(3, [(\\"banana\\", 50), (\\"apple\\", 50), (\\"cherry\\", 50)]) == \\"apple\\" def test_different_highest_play_count(): assert most_played_song(2, [(\\"song1\\", 10), (\\"song2\\", 20)]) == \\"song2\\"","solution":"def most_played_song(n, songs): Returns the name of the song with the highest play count. In case of a tie, returns the lexicographically smallest song name among those with the highest play count. Parameters: n (int): Number of songs. songs (list): List of tuples where each tuple contains a song name (str) and its play count (int). Returns: str: The name of the song with the highest play count or the lexicographically smallest song name in case of tie. from collections import defaultdict play_dict = defaultdict(int) for song, count in songs: play_dict[song] = count # Find the maximum play count max_play_count = max(play_dict.values()) # Find all songs with the maximum play count max_played_songs = [song for song, count in play_dict.items() if count == max_play_count] # Return the lexicographically smallest song name among those with the highest play count return min(max_played_songs) # Sample Test Cases n = 3 songs = [(\\"songa\\", 30), (\\"songb\\", 30), (\\"songc\\", 10)] print(most_played_song(n, songs)) # Expected Output: songa n = 4 songs = [(\\"rockstar\\", 1000), (\\"popstar\\", 1000), (\\"metallica\\", 999), (\\"classical\\", 1001)] print(most_played_song(n, songs)) # Expected Output: classical"},{"question":"def detect_winning_streak(outcomes: str) -> str: Determine if there is a winning streak of at least three consecutive wins in the tournament. Parameters: outcomes (str): A string of 'W' and 'L' representing the outcomes of matches. Returns: str: \\"Winning streak detected!\\" if there are at least three consecutive wins, otherwise \\"No winning streak.\\" >>> detect_winning_streak(\\"WWLWWWLW\\") \\"Winning streak detected!\\" >>> detect_winning_streak(\\"WLWLLLWL\\") \\"No winning streak.\\"","solution":"def detect_winning_streak(outcomes): Determine if there is a winning streak of at least three consecutive wins in the tournament. Parameters: outcomes (str): A string of 'W' and 'L' representing the outcomes of matches. Returns: str: \\"Winning streak detected!\\" if there are at least three consecutive wins, otherwise \\"No winning streak.\\" if 'WWW' in outcomes: return \\"Winning streak detected!\\" return \\"No winning streak.\\""},{"question":"def exists_subarray_with_sum_k(N: int, K: int, arr: List[int]) -> str: Determines if there exists a contiguous subarray in arr that sums to K. Args: N : int : Number of elements in the array K : int : Target sum arr : List[int] : List of integers Returns: str : \\"YES\\" if such a subarray exists, \\"NO\\" otherwise >>> exists_subarray_with_sum_k(5, 15, [1, 2, 3, 7, 5]) \\"YES\\" >>> exists_subarray_with_sum_k(4, 20, [1, 2, 3, 4]) \\"NO\\" >>> exists_subarray_with_sum_k(6, 9, [2, 4, -2, 1, 6, 5]) \\"YES\\"","solution":"def exists_subarray_with_sum_k(N, K, arr): Determines if there exists a contiguous subarray in arr that sums to K. Args: N : int : Number of elements in the array K : int : Target sum arr : list : List of integers Returns: str : \\"YES\\" if such a subarray exists, \\"NO\\" otherwise current_sum = 0 prefix_sums = {0} for num in arr: current_sum += num if (current_sum - K) in prefix_sums: return \\"YES\\" prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def flower_heights_after_days(f: int, growth_factors: List[int], D: int) -> List[int]: Calculate the final height of each flower after D days, considering the magical boundary. Args: f (int): Number of flowers. growth_factors (List[int]): Growth factors of each flower. D (int): Number of days. Returns: List[int]: Final heights of the flowers modulo 10^9 + 7. >>> flower_heights_after_days(3, [2, 3, 4], 2) [4, 9, 16] >>> flower_heights_after_days(1, [2], 0) [1] >>> flower_heights_after_days(2, [2, 3], 10**9) [738420069, 961946288]","solution":"def flower_heights_after_days(f, growth_factors, D): MOD = 10 ** 9 + 7 final_heights = [] for growth_factor in growth_factors: final_height = pow(growth_factor, D, MOD) final_heights.append(final_height) return final_heights"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def count_managers(n: int, relationships: List[Tuple[int, int]]) -> List[int]: Given n employees and their direct manager relationships, returns the number of distinct managers for each employee. Args: n: int - the number of employees relationships: List[Tuple[int, int]] - list of direct manager relationships Returns: List[int] - list where the i-th element is the number of distinct managers for the i-th employee Examples: >>> count_managers(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) [0, 1, 1, 2, 2, 2] >>> count_managers(1, []) [0] def test_example_case(): relationships = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] assert count_managers(6, relationships) == [0, 1, 1, 2, 2, 2] def test_single_employee(): assert count_managers(1, []) == [0] def test_two_employees(): assert count_managers(2, [(1, 2)]) == [0, 1] def test_multiple_levels(): relationships = [(1, 2), (2, 3), (3, 4), (4, 5)] assert count_managers(5, relationships) == [0, 1, 2, 3, 4] def test_complex_case(): relationships = [(1, 2), (1, 3), (1, 4), (4, 5), (2, 6)] assert count_managers(6, relationships) == [0, 1, 1, 1, 2, 2]","solution":"from collections import defaultdict, deque def count_managers(n, relationships): Given n employees and their direct manager relationships, returns the number of distinct managers for each employee. if n == 1: return [0] # Create an adjacency list representation of the company hierarchy tree = defaultdict(list) for u, v in relationships: tree[u].append(v) tree[v].append(u) # Store the number of distinct managers for each employee manager_count = [0] * (n + 1) # Use BFS to traverse the tree and calculate the number of distinct managers for each node queue = deque([(1, 0)]) # Start BFS from the root node, assuming employee 1 is the root visited = set() visited.add(1) while queue: current, current_level = queue.popleft() manager_count[current] = current_level for neighbor in tree[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, current_level + 1)) return [manager_count[i] for i in range(1, n + 1)]"},{"question":"def find_min_tsp(N: int, matrix: List[List[int]]) -> int: Write a program to find the shortest path traversing every node exactly once in a weighted, undirected graph. This problem is also known as the Traveling Salesman Problem (TSP). Given a graph represented with an adjacency matrix, return the minimum weight of the traversal. If it's not possible to traverse every node exactly once, return \`-1\`. Parameters: N (int): The number of nodes. matrix (List[List[int]]): A two-dimensional list representing the weights of the edges between nodes. Returns: int: The minimum weight of the traversal or -1 if not possible. >>> find_min_tsp(4, [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]) 80 >>> find_min_tsp(3, [[0, -1, 10], [-1, 0, 20], [10, 20, 0]]) -1 from typing import List def test_case_1(): matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert find_min_tsp(4, matrix) == 80 def test_case_2(): matrix = [ [0, -1, 10], [-1, 0, 20], [10, 20, 0] ] assert find_min_tsp(3, matrix) == -1 def test_case_3(): matrix = [ [0, 1, -1, -1], [1, 0, 1, -1], [-1, 1, 0, 1], [-1, -1, 1, 0] ] assert find_min_tsp(4, matrix) == -1 def test_case_4(): matrix = [ [0, 2], [2, 0] ] assert find_min_tsp(2, matrix) == 4 def test_case_5(): matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert find_min_tsp(4, matrix) == 80 def test_case_6(): matrix = [ [0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0] ] assert find_min_tsp(4, matrix) == 21","solution":"import sys def tsp_helper(matrix, mask, pos, dp, N): if mask == (1 << N) - 1: return matrix[pos][0] if matrix[pos][0] != -1 else sys.maxsize if dp[mask][pos] != -1: return dp[mask][pos] ans = sys.maxsize for city in range(N): if (mask & (1 << city)) == 0 and matrix[pos][city] != -1: new_cost = matrix[pos][city] + tsp_helper(matrix, mask | (1 << city), city, dp, N) ans = min(ans, new_cost) dp[mask][pos] = ans return dp[mask][pos] def tsp(matrix): N = len(matrix) dp = [[-1 for _ in range(N)] for _ in range(1 << N)] ans = tsp_helper(matrix, 1, 0, dp, N) return ans if ans != sys.maxsize else -1 def find_min_tsp(N, matrix): return tsp(matrix)"},{"question":"def min_rooms_required(test_cases): Calculate the minimum number of rooms required for given time slots. Each test case consists of a number of time slots represented by their start and end times. The function should return the minimum number of rooms required so that no two overlapping time slots share the same room. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): A list of test cases, where each test case is a tuple containing an integer (number of time slots) and a list of tuples (start and end times of each time slot). Returns: List[int]: A list of integers representing the minimum number of rooms required for each test case. Examples: >>> test_cases = [(3, [(10, 20), (15, 25), (20, 30)]), (2, [(1, 5), (6, 10)])] >>> min_rooms_required(test_cases) [2, 1] >>> test_cases = [(3, [(1, 5), (6, 10), (11, 15)])] >>> min_rooms_required(test_cases) [1] def process_input(input_data): Process the input data into a suitable format for the min_rooms_required function. Args: input_data (str): The raw input data as a string. Returns: List[Tuple[int, List[Tuple[int, int]]]]: A list of test cases, where each test case is a tuple containing an integer (number of time slots) and a list of tuples (start and end times of each time slot). Examples: >>> input_data = \\"2n3n10 20n15 25n20 30n2n1 5n6 10\\" >>> process_input(input_data) [(3, [(10, 20), (15, 25), (20, 30)]), (2, [(1, 5), (6, 10)])] >>> input_data = \\"1n3n1 5n6 10n11 15\\" >>> process_input(input_data) [(3, [(1, 5), (6, 10), (11, 15)])]","solution":"def min_rooms_required(test_cases): def calculate_rooms(slots): # Extract start and end times start_times = sorted([slot[0] for slot in slots]) end_times = sorted([slot[1] for slot in slots]) start_ptr = 0 end_ptr = 0 rooms_needed = 0 max_rooms = 0 # Use two pointers to traverse the start and end times while start_ptr < len(start_times): if start_times[start_ptr] < end_times[end_ptr]: rooms_needed += 1 max_rooms = max(max_rooms, rooms_needed) start_ptr += 1 else: rooms_needed -= 1 end_ptr += 1 return max_rooms results = [] for case in test_cases: n, slots = case results.append(calculate_rooms(slots)) return results def process_input(input_data): input_lines = input_data.strip().split('n') t = int(input_lines[0]) index = 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) slots = [] index += 1 for _ in range(n): s, e = map(int, input_lines[index].strip().split()) slots.append((s, e)) index += 1 test_cases.append((n, slots)) return test_cases"},{"question":"def max_unique_substring(S: str, K: int) -> str: Returns the substring of length K with the maximum number of unique characters. If multiple substrings have the same number of unique characters, return the lexicographically smallest one. If the length of S is less than K, return an empty string. >>> max_unique_substring(\\"abcabc\\", 3) \\"abc\\" >>> max_unique_substring(\\"abacaba\\", 3) \\"bac\\" >>> max_unique_substring(\\"aaaaaa\\", 2) \\"aa\\" >>> max_unique_substring(\\"abcd\\", 2) \\"ab\\" >>> max_unique_substring(\\"ab\\", 3) \\"\\" def solve(test_cases: List[Tuple[str, int]]) -> List[str]: Returns a list of results for each test case. Each result is the substring of length K with the maximum number of unique characters in the given string S, or an empty string if S is shorter than K. >>> solve([(\\"abcabc\\", 3), (\\"abacaba\\", 3)]) [\\"abc\\", \\"bac\\"] >>> solve([(\\"abcde\\", 3), (\\"aaaaaa\\", 1)]) [\\"abc\\", \\"a\\"] >>> solve([(\\"abcdef\\", 1), (\\"a\\", 1)]) [\\"a\\", \\"a\\"] >>> solve([(\\"abcd\\", 0)]) [\\"\\"] >>> solve([(\\"abcd\\", 5)]) [\\"\\"]","solution":"def max_unique_substring(S, K): Returns the substring of length K with the maximum number of unique characters. If multiple substrings have the same number of unique characters, return the lexicographically smallest one. If the length of S is less than K, return an empty string. if len(S) < K: return \\"\\" max_unique = 0 candidates = [] for i in range(len(S) - K + 1): substr = S[i:i+K] unique_count = len(set(substr)) if unique_count > max_unique: max_unique = unique_count candidates = [substr] elif unique_count == max_unique: candidates.append(substr) return min(candidates) def solve(test_cases): results = [] for S, K in test_cases: results.append(max_unique_substring(S, K)) return results"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def largestValues(root): Find the largest value in each row of a binary tree. Args: root (TreeNode): A TreeNode representing the root of the binary tree. Returns: List[int]: A list containing the largest value in each row of the tree. >>> # Test with a given binary tree >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(9) >>> root.right.right = TreeNode(6) >>> largestValues(root) [1, 3, 9] >>> # Test with a single node >>> root = TreeNode(10) >>> largestValues(root) [10] >>> # Test with an empty tree >>> root = None >>> largestValues(root) [] >>> # Test with all nodes having the same value >>> root = TreeNode(5) >>> root.left = TreeNode(5) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(5) >>> root.right.right = TreeNode(5) >>> largestValues(root) [5, 5, 5] >>> # Test with mixed node values >>> root = TreeNode(0) >>> root.left = TreeNode(-1) >>> root.right = TreeNode(-2) >>> root.left.left = TreeNode(-3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(-5) >>> root.right.right = TreeNode(-6) >>> largestValues(root) [0, -1, 4]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def largestValues(root): from collections import deque if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def find_minimal_threshold(N, difficulties): Determines the minimal threshold M such that no single round exceeds this difficulty. Arguments: N : int : the number of rounds difficulties : List[int] : the list of difficulties for each round Returns: int : the minimal threshold M pass def process_test_cases(T, test_cases): Processes multiple test cases. Arguments: T : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples, each containing the number of rounds and the difficulties of each round Returns: List[int] : list of minimal thresholds for each test case pass def test_find_minimal_threshold(): assert find_minimal_threshold(4, [2, 5, 3, 4]) == 5 assert find_minimal_threshold(6, [7, 1, 5, 9, 2, 8]) == 9 assert find_minimal_threshold(3, [1, 3, 1]) == 3 assert find_minimal_threshold(2, [1, 1]) == 1 assert find_minimal_threshold(5, [10, 20, 30, 40, 10]) == 40 def test_process_test_cases(): assert process_test_cases(3, [(4, [2, 5, 3, 4]), (6, [7, 1, 5, 9, 2, 8]), (3, [1, 3, 1])]) == [5, 9, 3] assert process_test_cases(2, [(2, [1, 1]), (5, [10, 20, 30, 40, 10])]) == [1, 40] assert process_test_cases(1, [(6, [4, 4, 4, 4, 4, 4])]) == [4] assert process_test_cases(1, [(3, [10, 10, 10])]) == [10]","solution":"def find_minimal_threshold(N, difficulties): Determines the minimal threshold M such that no single round exceeds this difficulty. Arguments: N : int : the number of rounds difficulties : List[int] : the list of difficulties for each round Returns: int : the minimal threshold M return max(difficulties) def process_test_cases(T, test_cases): Processes multiple test cases. Arguments: T : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples, each containing the number of rounds and the difficulties of each round Returns: List[int] : list of minimal thresholds for each test case results = [] for N, difficulties in test_cases: results.append(find_minimal_threshold(N, difficulties)) return results"},{"question":"def library_unique_titles(T, cases): Transforms input and applies count_unique_titles to find unique book titles in the library. Parameters: T (int): The number of test cases. cases (list): A list of tuples with each tuple containing the number of titles and the list of titles. Returns: list: a list containing the number of unique book titles for each case. def count_unique_titles(test_cases): Counts the number of unique book titles for each test case. Parameters: test_cases (list): a list of test cases, each test case is a tuple that contains the number of titles and a list of book titles. Returns: list: a list containing the number of unique book titles for each test case. results = [] for n, titles in test_cases: unique_titles = len(set(titles)) results.append(unique_titles) return results return count_unique_titles(cases) # Unit tests def test_count_unique_titles(): test_cases = [ (5, [\\"The Great Gatsby\\", \\"Moby Dick\\", \\"The Great Gatsby\\", \\"War and Peace\\", \\"Moby Dick\\"]), (3, [\\"To Kill a Mockingbird\\", \\"1984\\", \\"1984\\"]) ] expected = [3, 2] assert library_unique_titles(2, test_cases) == expected def test_single_title(): test_cases = [ (1, [\\"The Catcher in the Rye\\"]) ] expected = [1] assert library_unique_titles(1, test_cases) == expected def test_all_unique_titles(): test_cases = [ (4, [\\"Ulysses\\", \\"Madame Bovary\\", \\"The Odyssey\\", \\"Pride and Prejudice\\"]) ] expected = [4] assert library_unique_titles(1, test_cases) == expected def test_all_duplicate_titles(): test_cases = [ (3, [\\"In Search of Lost Time\\", \\"In Search of Lost Time\\", \\"In Search of Lost Time\\"]) ] expected = [1] assert library_unique_titles(1, test_cases) == expected def test_no_titles(): test_cases = [ (0, []) ] expected = [0] assert library_unique_titles(1, test_cases) == expected def test_mixed_case_titles(): test_cases = [ (4, [\\"The Iliad\\", \\"the Iliad\\", \\"THE ILIAD\\", \\"The iliad\\"]) ] expected = [4] assert library_unique_titles(1, test_cases) == expected","solution":"def count_unique_titles(test_cases): Counts the number of unique book titles for each test case. Parameters: test_cases (list): a list of test cases, each test case is a tuple that contains the number of titles and a list of book titles. Returns: list: a list containing the number of unique book titles for each test case. results = [] for n, titles in test_cases: unique_titles = len(set(titles)) results.append(unique_titles) return results def library_unique_titles(T, cases): Transforms input and applies count_unique_titles to find unique book titles in the library. Parameters: T (int): The number of test cases. cases (list): A list of tuples with each tuple containing the number of titles and the list of titles. Returns: list: a list containing the number of unique book titles for each case. return count_unique_titles(cases)"},{"question":"def sum_of_largest_and_smallest(T: int, test_cases: List[str]) -> List[int]: Given a number of test cases T and a list of T strings representing test cases, returns a list of sums of the largest and smallest values in each test case. Args: T : int : number of test cases test_cases : List[str] : list of space-separated integers for each test case Returns: List[int]: list of sums of the largest and smallest values in each test case >>> sum_of_largest_and_smallest(3, [\\"5 7 2 9 1\\", \\"4 2 8 6\\", \\"13 13 13 13\\"]) [10, 10, 26] >>> sum_of_largest_and_smallest(2, [\\"1 1 1 1\\", \\"3 1 4 1 5 9\\"]) [2, 10] >>> sum_of_largest_and_smallest(1, [\\"-10 0 10 20\\"]) [10] >>> sum_of_largest_and_smallest(2, [\\"42\\", \\"-42\\"]) [84, -84] >>> sum_of_largest_and_smallest(3, [\\"-5 -7 -2 -9 -1\\", \\"-4 -2 -8 -6\\", \\"13 -13 0\\"]) [-10, -10, 0]","solution":"def sum_of_largest_and_smallest(T, test_cases): Given a number of test cases T and a list of T lists representing test cases, returns a list of sums of the largest and smallest values in each test case. result = [] for case in test_cases: case_values = list(map(int, case.split())) min_val = min(case_values) max_val = max(case_values) result.append(min_val + max_val) return result"},{"question":"def longestSubsequenceSameElement(arr): Find the longest subsequence in an array such that all elements of the subsequence are the same. Returns the length of this subsequence. Args: arr (List[int]): an array of integers Returns: int: the length of the longest subsequence with all elements being the same. Examples: >>> longestSubsequenceSameElement([1, 3, 2, 3, 3, 4, 3]) 4 >>> longestSubsequenceSameElement([1]) 1 >>> longestSubsequenceSameElement([2, 2, 2, 2, 2]) 5","solution":"def longestSubsequenceSameElement(arr): Returns the length of the longest subsequence with all elements being the same. element_count = {} for element in arr: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 return max(element_count.values())"},{"question":"def min_streetlights(m: int, n: int) -> int: Determine the minimum number of streetlights needed to cover all intersections in a city grid represented by m horizontal and n vertical streets. Args: m (int): Number of horizontal streets (1 <= m <= 1000) n (int): Number of vertical streets (1 <= n <= 1000) Returns: int: Minimum number of streetlights required Examples: >>> min_streetlights(3, 3) 3 >>> min_streetlights(4, 5) 4 >>> min_streetlights(1, 5) 1","solution":"def min_streetlights(m, n): Returns the minimum number of streetlights needed to light up the city grid represented by m horizontal and n vertical streets. return min(m, n)"},{"question":"def max_importance_sum_after_swap(n: int, importance: List[int]) -> int: Determine the maximum possible sum of importance values of aligned paintings after performing at most one swap operation. >>> max_importance_sum_after_swap(1, [5]) 5 >>> max_importance_sum_after_swap(5, [1, 3, 7, 3, 5]) 19 >>> max_importance_sum_after_swap(5, [5, 7, 3, 3, 1]) 19 >>> max_importance_sum_after_swap(4, [0, 0, 0, 0]) 0 >>> max_importance_sum_after_swap(4, [4, 4, 4, 4]) 16 >>> max_importance_sum_after_swap(3, [1, 9, 1]) 11","solution":"def max_importance_sum_after_swap(n, importance): if n < 2: return sum(importance) current_sum = sum(importance) max_sum = current_sum for i in range(n): for j in range(i+1, n): # Swap importance[i] and importance[j] swapped_sum = current_sum - importance[i] - importance[j] + importance[j] + importance[i] if swapped_sum > max_sum: max_sum = swapped_sum return max_sum def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) importance = list(map(int, data[1:])) print(max_importance_sum_after_swap(n, importance)) if __name__ == \\"__main__\\": main()"},{"question":"def maximum_trains(n: int, times: List[Tuple[int, int]]) -> int: Determines the maximum number of trains present at the station simultaneously. :param n: Number of trains :param times: List of tuples, where each tuple (a_i, d_i) represents arrival and departure time of a train :return: Maximum number of trains present simultaneously >>> maximum_trains(3, [(1, 5), (2, 6), (4, 8)]) 3 >>> maximum_trains(5, [(1, 5), (2, 3), (4, 6), (5, 8), (7, 9)]) 2","solution":"def maximum_trains(n, times): Determines the maximum number of trains present at the station simultaneously. :param n: Number of trains :param times: List of tuples, where each tuple (a_i, d_i) represents arrival and departure time of a train :return: Maximum number of trains present simultaneously events = [] for arrival, departure in times: events.append((arrival, 1)) # Train arrives events.append((departure, -1)) # Train departs # Sort events, arrival before departure if times are equal. events.sort() max_trains = 0 current_trains = 0 for time, event in events: current_trains += event if current_trains > max_trains: max_trains = current_trains return max_trains"},{"question":"def minimum_travel_time(n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel time required to visit all cities starting and ending at city 1, visiting all other cities exactly once. >>> minimum_travel_time(4, [(1, 2, 3), (1, 3, 2), (3, 4, 4)]) 18 >>> minimum_travel_time(3, [(1, 2, 1), (1, 3, 5)]) 12","solution":"def minimum_travel_time(n, roads): from collections import defaultdict # Build adjacency list adjacency_list = defaultdict(list) total_travel_time = 0 for u, v, w in roads: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) total_travel_time += 2 * w # Each road is traversed twice return total_travel_time # Example usage: # print(minimum_travel_time(4, [(1, 2, 3), (1, 3, 2), (3, 4, 4)])) # Should output 18"},{"question":"def max_pairs(G: int, P: int) -> int: Returns the maximum number of pairs of performers given G guitars and P pianos. A pair consists of one guitar and one piano. >>> max_pairs(10, 15) 10 >>> max_pairs(5, 5) 5 >>> max_pairs(12, 6) 6 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Process a list of test cases and return the results. >>> process_test_cases([(10, 15), (5, 5), (12, 6)]) [10, 5, 6] >>> process_test_cases([(0, 0), (10, 0), (0, 10)]) [0, 0, 0] >>> process_test_cases([(100, 100), (55, 45), (20, 80)]) [100, 45, 20]","solution":"def max_pairs(G, P): Returns the maximum number of pairs of performers given G guitars and P pianos. A pair consists of one guitar and one piano. return min(G, P) def process_test_cases(test_cases): results = [] for G, P in test_cases: results.append(max_pairs(G, P)) return results"},{"question":"def rearrangeArray(arr): Rearranges the array such that elements at even indices are in non-decreasing order and elements at odd indices are in non-increasing order. >>> rearrangeArray([3, 5, 2, 1, 6, 4]) [2, 5, 3, 4, 6, 1] >>> rearrangeArray([1, 3, 2, 2, 3, 1]) [1, 3, 2, 2, 3, 1] >>> rearrangeArray([4, 1, 2, 3, 8, 5]) [2, 5, 4, 3, 8, 1] >>> rearrangeArray([10, 9, 8, 7, 6, 5]) [6, 9, 8, 7, 10, 5] >>> rearrangeArray([1, 2]) [1, 2]","solution":"def rearrangeArray(arr): Rearranges the array such that elements at even indices are in non-decreasing order and elements at odd indices are in non-increasing order. even_indices = sorted(arr[::2]) odd_indices = sorted(arr[1::2], reverse=True) rearranged = [] for e, o in zip(even_indices, odd_indices): rearranged.append(e) rearranged.append(o) return rearranged"},{"question":"from typing import List def topKFrequent(words: List[str], k: int) -> List[str]: Returns a list of the k most frequent words from the array. The result is sorted by frequency from highest to lowest. If two words have the same frequency, they are sorted in alphabetical order. >>> topKFrequent([\\"i\\", \\"love\\", \\"leetcode\\", \\"i\\", \\"love\\", \\"coding\\"], 2) ['i', 'love'] >>> topKFrequent([\\"the\\", \\"day\\", \\"is\\", \\"sunny\\", \\"the\\", \\"the\\", \\"the\\", \\"sunny\\", \\"is\\", \\"is\\"], 4) ['the', 'is', 'sunny', 'day']","solution":"from typing import List from collections import Counter def topKFrequent(words: List[str], k: int) -> List[str]: Returns a list of the k most frequent words from the array. The result is sorted by frequency from highest to lowest. If two words have the same frequency, they are sorted in alphabetical order. count = Counter(words) candidates = list(count.keys()) candidates.sort(key=lambda x: (-count[x], x)) return candidates[:k]"},{"question":"from typing import List, Tuple def can_transmit_message(n: int, m: int, q: int, links: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if there is a way to transmit a message between servers. Args: n (int): The number of servers. m (int): The number of communication links. q (int): The number of queries. links (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing a bidirectional communication link between two servers. queries (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing a query to check if there is a way to send a message from one server to another. Returns: List[str]: For each query, return \\"yes\\" if there is a way to send a message from the source server to the destination server, otherwise return \\"no\\". >>> can_transmit_message(5, 4, 3, [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 5), (2, 4), (5, 1)]) ['yes', 'yes', 'yes'] >>> can_transmit_message(6, 3, 2, [(1, 2), (2, 3), (4, 5)], [(1, 3), (1, 6)]) ['yes', 'no']","solution":"def can_transmit_message(n, m, q, links, queries): from collections import defaultdict, deque # Create an adjacency list for the graph graph = defaultdict(list) for u, v in links: graph[u].append(v) graph[v].append(u) # Function to check if there is a path between source and destination using BFS def is_connected(start, end): if start == end: return True visited = [False] * (n + 1) queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: if neighbor == end: return True queue.append(neighbor) visited[neighbor] = True return False result = [] for a, b in queries: if is_connected(a, b): result.append('yes') else: result.append('no') return result # Example usage: n = 5 m = 4 q = 3 links = [(1, 2), (2, 3), (3, 4), (4, 5)] queries = [(1, 5), (2, 4), (5, 1)] print(can_transmit_message(n, m, q, links, queries)) # ['yes', 'yes', 'yes']"},{"question":"def min_palindrome_partitions(s: str) -> int: Determine the smallest number of contiguous substrings into which the word can be split such that each substring is a palindrome. >>> min_palindrome_partitions(\\"aab\\") 2 >>> min_palindrome_partitions(\\"racecar\\") 1 >>> min_palindrome_partitions(\\"a\\") 1 >>> min_palindrome_partitions(\\"aa\\") 1 >>> min_palindrome_partitions(\\"ab\\") 2 >>> min_palindrome_partitions(\\"abc\\") 3 >>> min_palindrome_partitions(\\"abba\\") 1 >>> min_palindrome_partitions(\\"abcba\\") 1 >>> min_palindrome_partitions(\\"abccba\\") 1 >>> min_palindrome_partitions(\\"aabbcc\\") 3","solution":"def is_palindrome(s): return s == s[::-1] def min_palindrome_partitions(s): n = len(s) dp = [0] * (n + 1) dp[n] = 0 for i in range(n - 1, -1, -1): min_cut = float('inf') for j in range(i, n): if is_palindrome(s[i:j+1]): min_cut = min(min_cut, 1 + dp[j+1]) dp[i] = min_cut return dp[0] # Examples print(min_palindrome_partitions(\\"aab\\")) # Output: 2 print(min_palindrome_partitions(\\"racecar\\")) # Output: 1"},{"question":"def findWinner(rounds): Returns the 1-based index of the first player to win the game based on the highest total sum of dice rolled in each round. >>> findWinner([(3, 4), (5, 6), (6, 6), (6, 8)]) 4 >>> findWinner([(2, 3), (2, 5), (3, 3), (2, 3), (2, 5)]) 2 >>> findWinner([(1, 2), (3, 3), (4, 1), (4, 7), (5, 4)]) 4 >>> findWinner([]) 0 >>> findWinner([(3, 3)]) 1 >>> findWinner([(2, 3), (2, 3), (2, 3)]) 1","solution":"def findWinner(rounds): Returns the 1-based index of the first player to win the game based on the highest total sum of dice rolled in each round. max_sum = 0 winner_index = 0 for i, (sum1, sum2) in enumerate(rounds): total_sum = sum1 + sum2 if total_sum > max_sum: max_sum = total_sum winner_index = i + 1 # 1-based index return winner_index"},{"question":"def can_correct_message(T: int, cases: List[Tuple[str, str]]) -> List[str]: Determines if each received message in the cases list can be corrected to the known valid message by flipping at most one bit. Parameters: - T: int : number of test cases - cases: list of tuples : each tuple contains two strings, the first being the received message and the second the known valid message Returns: - list of str : \\"YES\\" or \\"NO\\" for each test case >>> can_correct_message(3, [(\\"1101\\", \\"1001\\"), (\\"1010\\", \\"1010\\"), (\\"1111\\", \\"0111\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_correct_message(2, [(\\"1101\\", \\"1011\\"), (\\"1010\\", \\"0000\\")]) [\\"NO\\", \\"NO\\"]","solution":"def can_correct_message(T, cases): Determines if each received message in the cases list can be corrected to the known valid message by flipping at most one bit. Parameters: - T: int : number of test cases - cases: list of tuples : each tuple contains two strings, the first being the received message and the second the known valid message Returns: - list of str : \\"YES\\" or \\"NO\\" for each test case results = [] for M, V in cases: if len(M) != len(V): results.append(\\"NO\\") continue # Count the number of differing bits between M and V diff_count = sum(1 for m, v in zip(M, V) if m != v) if diff_count == 0 or diff_count == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_odd_occurrence(arr: List[int]) -> int: Returns the integer that appears an odd number of times in the list. >>> find_odd_occurrence([2, 3, 4, 3, 2, 4, 4]) == 4 >>> find_odd_occurrence([1, 2, 2, 3, 3]) == 1 >>> find_odd_occurrence([4, 5, 4, 5, 5]) == 5 >>> find_odd_occurrence([10, 10, 10, 20, 20, 20, 20]) == 10 >>> find_odd_occurrence([-1, -1, -2, -2, -2]) == -2 >>> find_odd_occurrence([i for i in range(10000)] * 2 + [5000]) == 5000","solution":"def find_odd_occurrence(arr): Returns the element that appears an odd number of times in the list. result = 0 for num in arr: result ^= num return result"},{"question":"def is_near_palindrome(s: str) -> str: Determines if a given string is a near-palindrome. A near-palindrome is a string that allows for exactly one mismatch when comparing its characters from the beginning and end. Args: s (str): The input string containing only lowercase English letters. Returns: str: \\"YES\\" if the given string is a near-palindrome, otherwise \\"NO\\". Examples: >>> is_near_palindrome(\\"abccba\\") \\"YES\\" >>> is_near_palindrome(\\"abcca\\") \\"YES\\" >>> is_near_palindrome(\\"abcbia\\") \\"NO\\"","solution":"def is_near_palindrome(s): Determines if a given string is a near-palindrome. left, right = 0, len(s) - 1 mismatch_count = 0 while left < right: if s[left] != s[right]: mismatch_count += 1 if mismatch_count > 1: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"from typing import List def calculate_total(prices: List[float], items: List[int]) -> float: Simulates a simplified checkout system. :param prices: List of prices of items in store. :param items: List of indices of items purchased. :return: Total amount to be paid after discount on the highest-priced item. Examples: >>> calculate_total([10.0, 20.0, 30.0], [0, 1, 2]) 54.0 >>> calculate_total([15.0, 40.0, 25.0, 30.0], [2, 3]) 49.0 >>> calculate_total([10.0, 20.0, 30.0], []) 0.0 >>> calculate_total([10.0, 20.0, 30.0], [1]) 16.0","solution":"from typing import List def calculate_total(prices: List[float], items: List[int]) -> float: Calculate total price after 20% discount on the highest-priced item purchased. :param prices: List of prices of items in store. :param items: List of indices of items purchased. :return: Total amount to be paid. if not items: return 0.0 total = 0.0 highest_price = 0.0 for item in items: price = prices[item] total += price if price > highest_price: highest_price = price total -= highest_price * 0.2 return total"},{"question":"def max_rows_of_trees(t: int, tests: List[Tuple[int, int, int]]) -> List[int]: Determine the maximum number of rows of trees to plant with given width, length, and minimum distance between trees. Args: t (int): The number of test cases. tests (List[Tuple[int, int, int]]): A list of tuples, where each tuple contains the width (W), length (L), and minimum distance (D). Returns: List[int]: A list of integers representing the maximum number of rows of trees for each test case. >>> max_rows_of_trees(3, [(10, 10, 2), (15, 7, 3), (5, 5, 1)]) [5, 2, 5] >>> max_rows_of_trees(2, [(10, 9, 3), (20, 20, 4)]) [3, 5]","solution":"def max_rows_of_trees(t, tests): results = [] for W, L, D in tests: max_rows = L // D results.append(max_rows) return results # Example usage if __name__ == \\"__main__\\": t = 3 tests = [ (10, 10, 2), (15, 7, 3), (5, 5, 1) ] print(max_rows_of_trees(t, tests)) # Output: [5, 2, 5]"},{"question":"def encrypt_message(shift_value: int, message: str) -> str: Encrypts the message by shifting each character by the shift_value. Args: shift_value (int): the number of positions each character in the message should be shifted. message (str): the original message to be encrypted. Returns: str: the encrypted message. >>> encrypt_message(3, 'hello') == 'khoor' >>> encrypt_message(29, 'abc') == 'def' >>> encrypt_message(52, 'wxyz') == 'wxyz' >>> encrypt_message(0, 'abc') == 'abc' >>> encrypt_message(25, 'a') == 'z' >>> encrypt_message(1, 'xyz') == 'yza' >>> encrypt_message(1, 'abcdefghijklmnopqrstuvwxyz') == 'bcdefghijklmnopqrstuvwxyza'","solution":"def encrypt_message(shift_value, message): Encrypts the message by shifting each character by the shift_value. Args: shift_value (int): the number of positions each character in the message should be shifted. message (str): the original message to be encrypted. Returns: str: the encrypted message. encrypted_message = [] for char in message: # Calculate the original character position in the alphabet (0-25) original_position = ord(char) - ord('a') # Calculate the new position after applying the shift new_position = (original_position + shift_value) % 26 # Convert the new position back to a character new_char = chr(new_position + ord('a')) encrypted_message.append(new_char) return ''.join(encrypted_message)"},{"question":"def palindromic_substrings(s): Given a string \`s\`, return all the palindromic substrings within \`s\`. A palindrome is a string that reads the same forwards and backwards. The substrings can be in any order, and duplicates are allowed if they appear multiple times in the input string. >>> palindromic_substrings(\\"aab\\") [\\"a\\", \\"a\\", \\"b\\", \\"aa\\"] >>> palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> palindromic_substrings(\\"racecar\\") [\\"r\\", \\"a\\", \\"c\\", \\"e\\", \\"c\\", \\"a\\", \\"r\\", \\"aceca\\", \\"cec\\", \\"racecar\\"] >>> palindromic_substrings(\\"aaa\\") [\\"a\\", \\"a\\", \\"a\\", \\"aa\\", \\"aa\\", \\"aaa\\"]","solution":"def palindromic_substrings(s): Returns all palindromic substrings of the input string \`s\`. result = [] # Helper function to expand from the middle and check for palindromes def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: result.append(s[left:right + 1]) left -= 1 right += 1 # Considering each character and the space between each pair of characters as potential centers for i in range(len(s)): expand_around_center(i, i) # odd length palindromes expand_around_center(i, i + 1) # even length palindromes return result"},{"question":"def rotational_cipher(text: str, shift: int) -> str: Encrypts the input text using a rotational (Caesar) cipher with the specified shift. Args: text (str): The input text to be encrypted. shift (int): The number of positions each letter in the text should be shifted by. Returns: str: The encrypted text. >>> rotational_cipher(\\"Apply Rotation\\", 3) \\"Dssob Wrdwfwlrq\\" >>> rotational_cipher(\\"Hello, World!\\", 5) \\"Mjqqt, Btwqi!\\" >>> rotational_cipher(\\"Python 3.9\\", 13) \\"Clguba 3.9\\"","solution":"def rotational_cipher(text, shift): Encrypts the input text using a rotational (Caesar) cipher with the specified shift. Args: text (str): The input text to be encrypted. shift (int): The number of positions each letter in the text should be shifted by. Returns: str: The encrypted text. encrypted_text = [] for char in text: if char.isalpha(): ascii_offset = ord('A') if char.isupper() else ord('a') encrypted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset) encrypted_text.append(encrypted_char) else: encrypted_text.append(char) return \\"\\".join(encrypted_text)"},{"question":"def is_pattern_possible(O: int, P: int) -> str: Determines if the given number of Oak and Pine trees can be arranged in a pattern where the number of rows is a divisor of both O and P, and the number of Oak trees equals the number of Pine trees. >>> is_pattern_possible(4, 4) 'POSSIBLE' >>> is_pattern_possible(5, 10) 'IMPOSSIBLE' >>> is_pattern_possible(6, 9) 'IMPOSSIBLE' pass def solve(gardener_cases: List[Tuple[int, int]]) -> List[str]: Takes a list of tuples representing the number of Oak and Pine trees for each test case, and returns a list of strings representing whether the pattern is possible for each test case. >>> solve([(4, 4), (5, 10), (6, 9)]) ['POSSIBLE', 'IMPOSSIBLE', 'IMPOSSIBLE'] >>> solve([(10, 10), (20, 25), (30, 30)]) ['POSSIBLE', 'IMPOSSIBLE', 'POSSIBLE'] pass","solution":"def is_pattern_possible(O, P): Determines if the given number of Oak and Pine trees can be arranged in a pattern where the number of rows is a divisor of both O and P, and the number of Oak trees equals the number of Pine trees. # There must be an equal number of Oak and Pine trees if O != P: return \\"IMPOSSIBLE\\" # The number of rows must be a divisor of both O and P return \\"POSSIBLE\\" def solve(gardener_cases): results = [] for O, P in gardener_cases: results.append(is_pattern_possible(O, P)) return results"},{"question":"def maxAreaOfIsland(grid): Given an m x n 2D array \`grid\` composed of only '0's (water) and '1's (land), an island is a group of '1's connected 4-directionally (horizontal or vertical). This function returns the size of the largest island in the \`grid\`. >>> grid1 = [ ... [0,0,1,1,0], ... [0,1,1,0,0], ... [0,0,0,0,0], ... [1,1,0,0,1], ... [1,1,1,0,1] ... ] >>> maxAreaOfIsland(grid1) 5 >>> grid2 = [ ... [0,0,0], ... [0,0,0], ... [0,0,0] ... ] >>> maxAreaOfIsland(grid2) 0 >>> grid3 = [ ... [1,0,1], ... [0,0,0], ... [1,0,1] ... ] >>> maxAreaOfIsland(grid3) 1 >>> grid4 = [ ... [1,1,1], ... [1,1,1], ... [1,1,1] ... ] >>> maxAreaOfIsland(grid4) 9 >>> grid5 = [ ... [1,0,0,1], ... [0,0,0,0], ... [0,0,0,0], ... [1,0,0,1] ... ] >>> maxAreaOfIsland(grid5) 1","solution":"def maxAreaOfIsland(grid): Returns the size of the largest island in the grid. if not grid or not grid[0]: return 0 def dfs(grid, i, j): # If current cell is out of bounds or is water, return 0. if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] == 0: return 0 # Mark the current cell as visited grid[i][j] = 0 # Initialize the area as 1 for the current cell area = 1 # Perform DFS in all directions area += dfs(grid, i + 1, j) area += dfs(grid, i - 1, j) area += dfs(grid, i, j + 1) area += dfs(grid, i, j - 1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): # If the cell is land, start a DFS if grid[i][j] == 1: max_area = max(max_area, dfs(grid, i, j)) return max_area"},{"question":"from typing import List def simplify_file_paths(paths: List[str]) -> List[str]: Simplify a list of file paths by removing redundant segments. A single dot \\".\\" means to stay in the current directory and can be removed. A double dot \\"..\\" means to go up one directory. This means you remove the directory segment before the \\"..\\" and the \\"..\\" itself. Multiple consecutive slashes '//' should be reduced to a single slash '/'. The path should always start with a slash if it is an absolute path. Remove any trailing slash at the end of the path unless the path is the root \\"/\\" itself. Args: paths (List[str]): A list of file paths to be simplified. Returns: List[str]: A list of simplified file paths. Examples: >>> simplify_file_paths(['/home/foo/']) ['/home/foo'] >>> simplify_file_paths(['/../']) ['/'] >>> simplify_file_paths(['/home//foo/bar/../baz']) ['/home/foo/baz'] >>> simplify_file_paths(['/a/./b/../../c/', '/a//b//c/d/././e/../f']) ['/c', '/a/b/c/d/f'] >>> simplify_file_paths(['/a//b////c/d//']) ['/a/b/c/d']","solution":"def simplify_path(path): parts = path.split('/') stack = [] for part in parts: if part == '..': if stack: stack.pop() elif part and part != '.': stack.append(part) simplified_path = '/' + '/'.join(stack) return simplified_path.rstrip('/') if len(simplified_path) > 1 else '/' def simplify_file_paths(paths): return [simplify_path(path) for path in paths]"},{"question":"from typing import List import re def evaluate_expression(exp: str, values: List[int]) -> int: Evaluate an arithmetic expression string containing variables, integers, + and * operators with given variable values. Variables are replaced with values in the order of their first appearance in the expression. >>> evaluate_expression(\\"a + 2 * b + 3\\", [5, 10]) 28 >>> evaluate_expression(\\"x * y + 2 * x + 1\\", [3, 4]) 19","solution":"from typing import List import re def evaluate_expression(exp: str, values: List[int]) -> int: var_map = {} var_count = 0 tokens = re.findall(r'[a-z]|d+|[+*]', exp.replace(' ', '')) eval_stack = [] for token in tokens: if token.isalpha(): if token not in var_map: var_map[token] = values[var_count] var_count += 1 eval_stack.append(var_map[token]) elif token.isdigit(): eval_stack.append(int(token)) else: eval_stack.append(token) def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == '*': values.append(left * right) elif operator == '+': values.append(left + right) values = [] operators = [] precedence = {'+': 1, '*': 2} for token in eval_stack: if type(token) is int: values.append(token) else: while (operators and precedence[token] <= precedence[operators[-1]]): apply_operator(operators, values) operators.append(token) while operators: apply_operator(operators, values) return values[0]"},{"question":"def max_books_on_shelf(test_cases): Given the details of book thicknesses and shelf capacities for multiple test cases, determine the maximum number of books that can be placed on the shelf without exceeding its capacity. >>> input_string = \\"2n5 10n2 3 4 5 1n4 7n4 3 5 1\\" >>> test_cases = parse_input(input_string) >>> max_books_on_shelf(test_cases) [4, 2] ... def parse_input(input_string): Parse the input string to extract the number of test cases and the details of each test case. >>> input_string = \\"2n5 10n2 3 4 5 1n4 7n4 3 5 1\\" >>> parse_input(input_string) [(5, 10, [2, 3, 4, 5, 1]), (4, 7, [4, 3, 5, 1])] ... def test_max_books_on_shelf(): input_string = \\"2n5 10n2 3 4 5 1n4 7n4 3 5 1\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [4, 2] def test_max_books_on_shelf_case_1(): input_string = \\"1n5 10n2 3 4 5 1\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [4] def test_max_books_on_shelf_case_2(): input_string = \\"1n4 7n4 3 5 1\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [2] def test_max_books_on_shelf_no_valid_books(): input_string = \\"1n3 1n2 2 2\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [0] def test_max_books_on_shelf_all_books_fit(): input_string = \\"1n3 100n20 30 10\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [3] def test_max_books_on_shelf_only_one_book_fits(): input_string = \\"1n5 15n20 25 30 35 10\\" test_cases = parse_input(input_string) results = max_books_on_shelf(test_cases) assert results == [1]","solution":"def max_books_on_shelf(test_cases): results = [] for N, C, thicknesses in test_cases: thicknesses.sort() total_thickness = 0 count = 0 for thickness in thicknesses: if total_thickness + thickness <= C: total_thickness += thickness count += 1 else: break results.append(count) return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N, C = map(int, lines[index].split()) thicknesses = list(map(int, lines[index + 1].split())) test_cases.append((N, C, thicknesses)) index += 2 return test_cases"},{"question":"def longest_substring_without_repeating_characters(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> longest_substring_without_repeating_characters(\\"abcabcbb\\") 3 >>> longest_substring_without_repeating_characters(\\"bbbbb\\") 1 >>> longest_substring_without_repeating_characters(\\"pwwkew\\") 3 >>> longest_substring_without_repeating_characters(\\"\\") 0","solution":"def longest_substring_without_repeating_characters(s): Returns the length of the longest substring without repeating characters. char_index_map = {} max_length = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def min_digits_to_make_palindrome(x: int) -> int: Returns the minimum number of digits required to be added to x to make it a palindromic number. >>> min_digits_to_make_palindrome(123) 2 >>> min_digits_to_make_palindrome(4884) 0 >>> min_digits_to_make_palindrome(567) 2 >>> min_digits_to_make_palindrome(9) 0 >>> min_digits_to_make_palindrome(12) 1","solution":"def min_digits_to_make_palindrome(x): Returns the minimum number of digits required to be added to x to make it a palindromic number. str_x = str(x) if str_x == str_x[::-1]: return 0 for i in range(len(str_x)): if str_x[i:] == str_x[i:][::-1]: return i return len(str_x) - 1"},{"question":"from typing import List def shortest_path(grid: List[List[int]]) -> int: Compute the length of the shortest path from the top-left corner to the bottom-right corner in a grid-based game. The grid is represented as a 2D binary list where \`0\` represents an empty cell and \`1\` represents an obstacle. The player can only move up, down, left, or right, and the function should return \`-1\` if there's no valid path. Examples: >>> shortest_path([[0, 0, 1], [0, 1, 0], [0, 0, 0]]) 4 >>> shortest_path([[0, 1], [1, 0]]) -1","solution":"from collections import deque def shortest_path(grid): if not grid or not grid[0]: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == 1 or grid[rows - 1][cols - 1] == 1: return -1 queue = deque([(0, 0)]) visited = set((0, 0)) path_length = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return path_length for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) path_length += 1 return -1"},{"question":"def count_perfect_squares(n: int, m: int, k: int) -> int: Returns the number of perfect square areas that can be formed using exactly k plots of land within the n x m farm. >>> count_perfect_squares(5, 4, 9) 6 >>> count_perfect_squares(3, 3, 8) 0 >>> count_perfect_squares(3, 3, 9) 1 >>> count_perfect_squares(10, 10, 16) 49 >>> count_perfect_squares(5, 5, 1) 25","solution":"def count_perfect_squares(n, m, k): Returns the number of perfect square areas that can be formed using exactly k plots of land within the n x m farm. side_length = int(k**0.5) if side_length * side_length != k: return 0 count = 0 for i in range(n - side_length + 1): for j in range(m - side_length + 1): count += 1 return count"},{"question":"def shortest_palindrome_substring(s: str) -> str: Finds the shortest palindromic substring in the string 's'. Returns the first occurring one if there are multiple shortest palindromic substrings of the same length. >>> shortest_palindrome_substring(\\"babad\\") \\"b\\" >>> shortest_palindrome_substring(\\"cbbd\\") \\"c\\" >>> shortest_palindrome_substring(\\"a\\") \\"a\\" >>> shortest_palindrome_substring(\\"ac\\") \\"a\\" pass def test_single_character(): assert shortest_palindrome_substring(\\"a\\") == \\"a\\" def test_multiple_same_length_palindromes(): assert shortest_palindrome_substring(\\"babad\\") == \\"b\\" assert shortest_palindrome_substring(\\"cbbd\\") == \\"c\\" def test_two_character_strings(): assert shortest_palindrome_substring(\\"ac\\") == \\"a\\" assert shortest_palindrome_substring(\\"cc\\") == \\"c\\" def test_longer_string_with_one_palindrome(): assert shortest_palindrome_substring(\\"abcdedcba\\") == \\"a\\" def test_no_repeating_characters(): assert shortest_palindrome_substring(\\"abcdefgh\\") == \\"a\\" def test_empty_string(): assert shortest_palindrome_substring(\\"\\") == \\"\\" def test_palindromes_within_longer_string(): assert shortest_palindrome_substring(\\"forgeeksskeegfor\\") == \\"f\\" def test_all_chars_same(): assert shortest_palindrome_substring(\\"aaaaaaa\\") == \\"a\\"","solution":"def shortest_palindrome_substring(s): Returns the shortest palindromic substring in the string 's'. If there are multiple shortest palindromic substrings of the same length, returns the first occurring one. n = len(s) # Check all substrings starting from length 1 for length in range(1, n + 1): for start in range(n - length + 1): end = start + length substring = s[start:end] if substring == substring[::-1]: # Check if the substring is a palindrome return substring return \\"\\" # Example usage: # print(shortest_palindrome_substring(\\"babad\\")) # Output: \\"b\\" # print(shortest_palindrome_substring(\\"cbbd\\")) # Output: \\"c\\" # print(shortest_palindrome_substring(\\"a\\")) # Output: \\"a\\" # print(shortest_palindrome_substring(\\"ac\\")) # Output: \\"a\\""},{"question":"def longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"eceba\\") 3 >>> longest_substring_two_distinct(\\"bbbbccc\\") 7 >>> longest_substring_two_distinct(\\"\\") 0 >>> longest_substring_two_distinct(\\"a\\") 1 >>> longest_substring_two_distinct(\\"abaccc\\") 4 >>> longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> longest_substring_two_distinct(\\"aabbcc\\") 4 >>> longest_substring_two_distinct(\\"aaabbb\\") 6","solution":"def longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. if not s: return 0 max_len = 0 start = 0 char_map = {} for end, char in enumerate(s): char_map[char] = char_map.get(char, 0) + 1 while len(char_map) > 2: char_map[s[start]] -= 1 if char_map[s[start]] == 0: del char_map[s[start]] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List, Tuple def minimal_first_k_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[int]: Given two arrays \`a\` and \`b\` for each test case, both of length \`n\`, this function merges these arrays into a single sorted array in a way that minimizes the possible sum of the first \`k\` elements of this sorted array. The function returns the list of minimum possible sums for all \`t\` test cases. >>> minimal_first_k_sum(3, [((5, 3), [1, 2, 3, 4, 5], [5, 6, 7, 8, 9]), ((4, 2), [4, 10, 15, 14], [7, 1, 1, 2]), ((6, 4), [11, 12, 13, 14, 15, 16], [1, 2, 3, 4, 5, 6])]) [6, 2, 10] >>> minimal_first_k_sum(1, [((5, 3), [1, 1, 1, 1, 1], [1, 1, 1, 1, 1])]) [3] >>> minimal_first_k_sum(1, [((4, 2), [1, 2, 3, 4], [5, 6, 7, 8])]) [3] pass # Define a function that can be called with the appropriate input format def main(input_data: str) -> List[int]: Parses the input data and calls minimal_first_k_sum to compute the results. >>> main(\\"3n5 3n1 2 3 4 5n5 6 7 8 9n4 2n4 10 15 14n7 1 1 2n6 4n11 12 13 14 15 16n1 2 3 4 5 6\\") [6, 2, 10] >>> main(\\"1n5 3n1 1 1 1 1n1 1 1 1 1\\") [3] >>> main(\\"1n4 2n1 2 3 4n5 6 7 8\\") [3] pass","solution":"def minimal_first_k_sum(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] a = test_cases[i][1] b = test_cases[i][2] combined = sorted(a + b) results.append(sum(combined[:k])) return results # Define a function that can be called with the appropriate input format def main(input_data): Parses the input data and calls minimal_first_k_sum to compute the results. data = input_data.strip().split('n') t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n, k = map(int, data[index].split()) a = list(map(int, data[index + 1].split())) b = list(map(int, data[index + 2].split())) test_cases.append(((n, k), a, b)) index += 3 results = minimal_first_k_sum(t, test_cases) return results"},{"question":"def calculate_emissions(n: int, segments: list[tuple[float, float]], factor: float = 20) -> float: Calculates the total CO2 emissions for a given journey. Parameters: n (int): number of journey segments segments (list of tuples): each tuple contains two floats, \`d\` (distance in miles) and \`f\` (fuel consumption rate in gallons per mile) factor (float): conversion factor from gallons to CO2 emissions (default is 20 pounds of CO2 per gallon) Returns: float: total CO2 emissions in pounds, rounded to two decimal places >>> calculate_emissions(3, [(100, 0.05), (200, 0.10), (50, 0.20)]) 450.00 >>> calculate_emissions(1, [(100, 0.05)]) 100.00 >>> calculate_emissions(2, [(10, 0.01), (20, 0.01)]) 6.00 >>> calculate_emissions(2, [(1000, 20), (1000, 0.01)]) 402000.00 >>> calculate_emissions(1, [(100, 0.0)]) 0.00","solution":"def calculate_emissions(n, segments, factor=20): Calculates the total CO2 emissions for a given journey. Parameters: n (int): number of journey segments segments (list of tuples): each tuple contains two floats, \`d\` (distance in miles) and \`f\` (fuel consumption rate in gallons per mile) factor (float): conversion factor from gallons to CO2 emissions (default is 20 pounds of CO2 per gallon) Returns: float: total CO2 emissions in pounds, rounded to two decimal places total_emissions = 0 for d, f in segments: total_emissions += d * f * factor return round(total_emissions, 2)"},{"question":"def min_jumps(n: int, k: int) -> int: Returns the minimum number of jumps needed to reach stone n from stone 0 given the maximum jump distance k. If it's impossible to reach stone n, returns -1. >>> min_jumps(5, 2) 3 >>> min_jumps(10, 3) 4 >>> min_jumps(6, 2) 3 >>> min_jumps(1, 1) 1 >>> min_jumps(10, 10) 1 >>> min_jumps(0, 5) 0 >>> min_jumps(100000, 100) 1000 >>> min_jumps(100000, 99) 1011 >>> min_jumps(10, 1) 10","solution":"def min_jumps(n, k): Returns the minimum number of jumps needed to reach stone n from stone 0 given the maximum jump distance k. If it's impossible to reach stone n, returns -1. if k >= n: return 1 if n > 0 else 0 # Otherwise, we need to calculate the minimum jumps jumps = n // k if n % k != 0: jumps += 1 return jumps"},{"question":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. >>> max_non_overlapping_tasks([(1, 4), (2, 3), (3, 5)]) == 2 >>> max_non_overlapping_tasks([(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 >>> max_non_overlapping_tasks([(7, 9), (1, 3), (3, 5), (5, 8)]) == 3","solution":"def max_non_overlapping_tasks(tasks): Returns the maximum number of non-overlapping tasks that can be scheduled. # Sort tasks based on their end time tasks.sort(key=lambda x: x[1]) # Initialize the count of non-overlapping tasks count = 0 # Initialize the end time of the last selected task last_end_time = 0 for task in tasks: start, end = task if start >= last_end_time: # If the current task starts after or when the last selected task ends count += 1 last_end_time = end return count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) tasks = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)] result = max_non_overlapping_tasks(tasks) print(result)"},{"question":"def distinct_wall_layers(k: int, h: int, blocks: List[Tuple[int, int]]) -> int: Determines the number of distinct wall layers Joshua can create with the given set of blocks. Args: k (int): number of different types of blocks h (int): specified height of the wall layer blocks (list of tuples): list where each tuple contains width and height of a block Returns: int: number of distinct wall layers that can be created with the given blocks >>> distinct_wall_layers(3, 5, [(3, 5), (2, 4), (1, 5)]) 2 >>> distinct_wall_layers(4, 7, [(5, 7), (4, 7), (3, 6), (2, 7)]) 3 >>> distinct_wall_layers(2, 3, [(1, 3), (4, 5)]) 1 >>> distinct_wall_layers(3, 6, [(3, 5), (2, 4), (1, 7)]) 0 >>> distinct_wall_layers(3, 5, [(3, 5), (2, 5), (1, 5)]) 3 >>> distinct_wall_layers(1, 4, [(2, 4)]) 1 >>> distinct_wall_layers(5, 5, [(3, 5), (3, 5), (3, 5), (1, 5), (1, 5)]) 2","solution":"def distinct_wall_layers(k, h, blocks): Determines the number of distinct wall layers Joshua can create with the given set of blocks. Args: k (int): number of different types of blocks h (int): specified height of the wall layer blocks (list of tuples): list where each tuple contains width and height of a block Returns: int: number of distinct wall layers that can be created with the given blocks distinct_heights = set() for width, height in blocks: if height == h: distinct_heights.add((width, height)) # We can also just count heights here return len(distinct_heights) # Example usage: # print(distinct_wall_layers(3, 5, [(3, 5), (2, 4), (1, 5)])) # Output: 2"},{"question":"def isMatch(s1: str, s2: str) -> bool: Returns if the string s2 matches the string s1, where '*' can match zero or more characters. >>> isMatch(\\"aa\\", \\"a\\") False >>> isMatch(\\"aa\\", \\"*\\") True >>> isMatch(\\"cb\\", \\"?a\\") False >>> isMatch(\\"adceb\\", \\"*a*b\\") True >>> isMatch(\\"acdcb\\", \\"a*c?b\\") False","solution":"def isMatch(s1, s2): Returns if the string s2 matches the string s1, where '*' can match zero or more characters. # Initialize DP table dp = [[False] * (len(s1) + 1) for _ in range(len(s2) + 1)] dp[0][0] = True # Both strings are empty # Fill the first row where s2 has '*' characters for i in range(1, len(s2) + 1): if s2[i - 1] == '*': dp[i][0] = dp[i - 1][0] # Fill the rest of the DP table for i in range(1, len(s2) + 1): for j in range(1, len(s1) + 1): if s2[i - 1] == '*': dp[i][j] = dp[i - 1][j] or dp[i][j - 1] elif s2[i - 1] == s1[j - 1] or s2[i - 1] == '?': dp[i][j] = dp[i - 1][j - 1] return dp[len(s2)][len(s1)]"},{"question":"def create_access_code(s: str) -> str: Convert an initial string into a valid access code with minimal changes. Args: s (str): The initial string consisting of only English letters. Returns: str: The valid access code string following the rules. Examples: >>> create_access_code(\\"AbcD\\") 'AbCd' >>> create_access_code(\\"aBCdE\\") 'AbCdE' pass # Your implementation goes here","solution":"def create_access_code(s): Convert an initial string into a valid access code with minimal changes. Args: s (str): The initial string consisting of only English letters. Returns: str: The valid access code string following the rules. n = len(s) access_code = [] # Make the first character uppercase if not s[0].isupper(): access_code.append(s[0].upper()) else: access_code.append(s[0]) # Alternate between uppercase and lowercase for i in range(1, n): if i % 2 == 0: # Even index: should be uppercase if not s[i].isupper(): access_code.append(s[i].upper()) else: access_code.append(s[i]) else: # Odd index: should be lowercase if not s[i].islower(): access_code.append(s[i].lower()) else: access_code.append(s[i]) return ''.join(access_code)"},{"question":"def max_concat_subarray_sum(a: List[int], b: List[int]) -> int: Determine the maximum possible sum Anna can get by selecting subarrays and concatenating them. Args: a: List of integers representing the first array. b: List of integers representing the second array. Returns: An integer representing the maximum sum Anna can obtain. Examples: >>> max_concat_subarray_sum([1, 2, 3, 4], [-1, 2, 3]) == 15 >>> max_concat_subarray_sum([-1, -2, -3, -4, -5], [1, 2, 3, 4]) == 10","solution":"def max_subarray_sum(array): Helper function to find the maximum subarray sum using Kadane's algorithm. max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def max_concat_subarray_sum(a, b): Returns the maximum sum of any subarray from a concatenated with any subarray from b. max_sum_a = max(0, max_subarray_sum(a)) # max subarray sum of a or 0 if all non-positive max_sum_b = max(0, max_subarray_sum(b)) # max subarray sum of b or 0 if all non-positive return max_sum_a + max_sum_b"},{"question":"def shortest_subsequence_lengths(t: int, test_cases: List[str]) -> List[int]: Determine the length of the shortest subsequence spelling \\"code\\" in each given string. >>> shortest_subsequence_lengths(1, [\\"codex\\"]) [4] >>> shortest_subsequence_lengths(1, [\\"codedex\\"]) [4] >>> shortest_subsequence_lengths(1, [\\"hello\\"]) [-1] pass # Unit Test from solution import shortest_subsequence_lengths def test_single_possible_sequence(): assert shortest_subsequence_lengths(1, [\\"codex\\"]) == [4] def test_single_possible_sequence_with_repetitions(): assert shortest_subsequence_lengths(1, [\\"codedex\\"]) == [4] def test_no_possible_sequence(): assert shortest_subsequence_lengths(1, [\\"hello\\"]) == [-1] def test_multiple_cases_mixed(): assert shortest_subsequence_lengths(3, [\\"codex\\", \\"codedex\\", \\"hello\\"]) == [4, 4, -1] def test_only_one_character_matching(): assert shortest_subsequence_lengths(1, [\\"c\\"]) == [-1] def test_contiguous_sequence(): assert shortest_subsequence_lengths(1, [\\"codec\\"]) == [4] def test_subsequence_not_in_order(): assert shortest_subsequence_lengths(1, [\\"ocde\\"]) == [-1] def test_only_subsequence_length(): assert shortest_subsequence_lengths(1, [\\"codecode\\"]) == [4]","solution":"def shortest_subsequence_lengths(t, test_cases): target = \\"code\\" target_len = len(target) results = [] for s in test_cases: idx_t = 0 for char in s: if char == target[idx_t]: idx_t += 1 if idx_t == target_len: break if idx_t == target_len: results.append(target_len) else: results.append(-1) return results"},{"question":"def min_operations(T, test_cases): Calculate the minimum number of operations required to make all the tiles have the same height. >>> min_operations(2, [(3, [2, 2, 3]), (4, [7, 5, 6, 4])]) [1, 6] >>> min_operations(1, [(5, [1, 2, 3, 4, 5])]) [10]","solution":"def min_operations(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] H = test_cases[i][1] min_height = min(H) operations = sum(h - min_height for h in H) results.append(operations) return results # Example Usage: # T = 2 # test_cases = [ # (3, [2, 2, 3]), # (4, [7, 5, 6, 4]) # ] # print(min_operations(T, test_cases)) # Should print: [1, 6]"},{"question":"def min_operations_to_sort_permutation(t, test_cases): Returns an array of minimal operation counts required to sort each test case of permutations. Arguments: t -- an integer, the number of test cases. test_cases -- a list of tuples, where each tuple contains an integer (length of permutation) and a list of permutations. Returns: result -- a list of integers, the minimum number of operations for each test case. Examples: >>> min_operations_to_sort_permutation(3, [(4, [3, 4, 2, 1]), (5, [5, 2, 3, 4, 1]), (6, [1, 2, 3, 4, 5, 6])]) [3, 4, 0] >>> min_operations_to_sort_permutation(1, [(4, [1, 2, 3, 4])]) [0] >>> min_operations_to_sort_permutation(1, [(4, [4, 3, 2, 1])]) [3] >>> min_operations_to_sort_permutation(1, [(1, [1])]) [0] >>> min_operations_to_sort_permutation(1, [(2, [2, 1])]) [1] >>> min_operations_to_sort_permutation(1, [(2, [1, 2])]) [0]","solution":"def min_operations_to_sort_permutation(t, test_cases): Returns an array of minimal operation counts required to sort each test case of permutations. Arguments: t -- an integer, the number of test cases. test_cases -- a list of tuples, where each tuple contains an integer (length of permutation) and a list of permutations. Returns: result -- a list of integers, the minimum number of operations for each test case. results = [] for n, perm in test_cases: # Edge case: if already sorted, return 0 if perm == sorted(perm): results.append(0) continue min_ops = n # Start as worst case last_pos = n - 1 # Traverse from the end to start, finding out the last element of the sorted subsequence while last_pos > 0 and perm[last_pos - 1] < perm[last_pos]: last_pos -= 1 min_ops = last_pos results.append(min_ops) return results"},{"question":"def process_queries(arr, queries): Process the given array with the set of queries. Parameters: arr (List[int]): The array of integers queries (List[List[int]]): The list of queries to be processed Returns: List[int]: The results of the maximum value queries pass # Wrapper function to handle input and output def run(input_data): input_lines = input_data.strip().split('n') first_line = input_lines[0].split() N = int(first_line[0]) Q = int(first_line[1]) arr = list(map(int, input_lines[1].split())) queries = [list(map(int, line.split())) for line in input_lines[2:2+Q]] # Process the queries and produce results results = process_queries(arr, queries) return 'n'.join(map(str, results))","solution":"def process_queries(arr, queries): Process the given array with the set of queries. Parameters: arr (List[int]): The array of integers queries (List[List[int]]): The list of queries to be processed Returns: List[int]: The results of the maximum value queries from collections import defaultdict # Step 1: Prepare to efficiently store the range increments. increment_map = defaultdict(int) result = [] # Process each query for query in queries: if query[0] == 1: # Add x to range L to R (1-indexed) _, L, R, x = query increment_map[L - 1] += x if R < len(arr): increment_map[R] -= x elif query[0] == 2: # Find the maximum in range L to R (1-indexed) _, L, R = query # Apply current increments current_increment = 0 max_value = float('-inf') for i in range(L - 1, R): current_increment += increment_map[i] max_value = max(max_value, arr[i] + current_increment) result.append(max_value) return result # Wrapper function to handle input and output def run(input_data): input_lines = input_data.strip().split('n') first_line = input_lines[0].split() N = int(first_line[0]) Q = int(first_line[1]) arr = list(map(int, input_lines[1].split())) queries = [list(map(int, line.split())) for line in input_lines[2:2+Q]] # Process the queries and produce results results = process_queries(arr, queries) return 'n'.join(map(str, results))"},{"question":"def is_palindrome(n: int) -> bool: Checks if a given integer is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(-121) False >>> is_palindrome(10) False >>> is_palindrome(7) True >>> is_palindrome(1234321) True >>> is_palindrome(1234567) False","solution":"def is_palindrome(n): Checks if a given integer is a palindrome. :param n: integer :return: True if n is a palindrome, False otherwise if n < 0: return False return str(n) == str(n)[::-1]"},{"question":"def calculate_event_duration(start_time: str, end_time: str) -> str: This function calculates the duration of an event given its start and end time in 24-hour clock format. >>> calculate_event_duration(\\"14:40\\", \\"16:20\\") '1 hour(s) and 40 minute(s)' >>> calculate_event_duration(\\"23:50\\", \\"01:15\\") '1 hour(s) and 25 minute(s)'","solution":"def calculate_event_duration(start_time, end_time): This function calculates the duration of an event given its start and end time in 24-hour clock format. :param start_time: str, start time in \\"HH:MM\\" format :param end_time: str, end time in \\"HH:MM\\" format :return: str, duration in \\"X hour(s) and Y minute(s)\\" format start_hour, start_minute = map(int, start_time.split(':')) end_hour, end_minute = map(int, end_time.split(':')) # Convert both times to minutes from the beginning of the day start_total_minutes = start_hour * 60 + start_minute end_total_minutes = end_hour * 60 + end_minute # Calculate the difference in minutes if end_total_minutes >= start_total_minutes: duration_minutes = end_total_minutes - start_total_minutes else: # if the end time is past midnight duration_minutes = (24 * 60 - start_total_minutes) + end_total_minutes # Convert total duration minutes to hours and minutes hours = duration_minutes // 60 minutes = duration_minutes % 60 return f\\"{hours} hour(s) and {minutes} minute(s)\\""},{"question":"def determine_winner(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine the winner of the Nim game with the given rules. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case contains the number of heaps and the number of stones in each heap. Returns: List[str]: \\"First\\" if the first player has a winning strategy, otherwise \\"Second\\". >>> determine_winner(3, [(1, [2]), (2, [2, 5]), (3, [1, 4, 6])]) [\\"First\\", \\"First\\", \\"Second\\"] >>> determine_winner(2, [(1, [1]), (1, [10])]) [\\"Second\\", \\"Second\\"]","solution":"from sympy import isprime def can_first_player_win(n, heaps): for stones in heaps: if stones > 1 and isprime(stones): return \\"First\\" return \\"Second\\" def determine_winner(t, test_cases): results = [] for i in range(t): n, heaps = test_cases[i] results.append(can_first_player_win(n, heaps)) return results"},{"question":"def minimum_breaks(N: int, M: int, D: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of breaks the driver needs to take to complete each delivery. Each query corresponds to a delivery task from one intersection to another. Args: N: Total intersections. M: Total one-way streets. D: Distance the driver can cover per hour. edges: List of tuples (A_i, B_i, C_i) describing the intersections and their respective distances. queries: List of tuples (s_i, t_i) representing each delivery task from one intersection to another. Returns: A list of integers, each representing the minimum number of breaks needed for each delivery task. If an intersection is unreachable, return -1 for that task. Example: >>> minimum_breaks(4, 4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 6), (1, 3, 2)], [(1, 4), (3, 1)]) [1, -1] >>> minimum_breaks(2, 1, 5, [(1, 2, 3)], [(1, 2)]) [0] >>> minimum_breaks(3, 1, 5, [(1, 2, 3)], [(2, 3)]) [-1] >>> minimum_breaks(5, 7, 20, [(1, 2, 5), (2, 3, 10), (3, 4, 5), (4, 5, 10), (1, 3, 15), (3, 5, 8), (2, 4, 18)], [(1, 5), (2, 5)]) [1, 0] pass def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) M = int(data[idx+1]) D = int(data[idx+2]) idx += 3 edges = [] for _ in range(M): u = int(data[idx]) v = int(data[idx+1]) w = int(data[idx+2]) edges.append((u, v, w)) idx += 3 Q = int(data[idx]) idx += 1 queries = [] for _ in range(Q): s = int(data[idx]) t = int(data[idx+1]) queries.append((s, t)) idx += 2 results = minimum_breaks(N, M, D, edges, queries) for result in results: print(result)","solution":"import heapq def dijkstra(N, edges, start, D): graph = [[] for _ in range(N)] for u, v, w in edges: graph[u-1].append((v-1, w)) distances = [float('inf')] * N distances[start] = 0 pq = [(0, start)] while pq: current_distance, u = heapq.heappop(pq) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances def minimum_breaks(N, M, D, edges, queries): results = [] for s, t in queries: distances = dijkstra(N, edges, s-1, D) total_distance = distances[t-1] if total_distance == float('inf'): results.append(-1) else: breaks = (total_distance - 1) // D results.append(breaks) return results def main(): import sys input = sys.stdin.read data = input().split() idx = 0 N = int(data[idx]) M = int(data[idx+1]) D = int(data[idx+2]) idx += 3 edges = [] for _ in range(M): u = int(data[idx]) v = int(data[idx+1]) w = int(data[idx+2]) edges.append((u, v, w)) idx += 3 Q = int(data[idx]) idx += 1 queries = [] for _ in range(Q): s = int(data[idx]) t = int(data[idx+1]) queries.append((s, t)) idx += 2 results = minimum_breaks(N, M, D, edges, queries) for result in results: print(result)"},{"question":"def trap(heights: List[int]) -> int: Given a list of non-negative integers representing the heights of blocks, determine the water trapped after it rains. Args: heights (List[int]): A list of non-negative integers representing the height of blocks. Returns: int: The total units of trapped water. Examples: >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([0, 0, 0, 0]) 0","solution":"from typing import List def trap(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max, right_max = [0] * n, [0] * n water_trapped = 0 left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def min_operations_to_all_ones(t: int, cases: List[str]) -> List[int]: Determines the minimum number of operations needed to convert binary strings to strings of only '1's. Parameters: t (int): The number of test cases. cases (list of str): List of binary strings. Returns: list of int: List of minimum operations for each test case. >>> min_operations_to_all_ones(4, ['0110', '1001', '1111', '0000']) [1, 1, 0, 1] >>> min_operations_to_all_ones(2, ['1111', '111']) [0, 0] >>> min_operations_to_all_ones(2, ['0000', '00']) [1, 1] >>> min_operations_to_all_ones(3, ['0', '1', '0']) [1, 0, 1] >>> min_operations_to_all_ones(2, ['101010', '010101']) [1, 1]","solution":"def min_operations_to_all_ones(t, cases): Determines the minimum number of operations needed to convert binary strings to strings of only '1's. Parameters: t (int): The number of test cases. cases (list of str): List of binary strings. Returns: list of int: List of minimum operations for each test case. results = [] for s in cases: if '0' not in s: # Already all ones results.append(0) elif '1' not in s: # All zeros need exactly one operation results.append(1) else: # If there is at least one '0' and one '1' # Only 1 operation is required to flip and reverse the entire string once results.append(1) return results"},{"question":"def sortedSquares(arr): Given a sorted array containing both negative and positive integers, return a new array containing the squares of each number from the input array in ascending order. Args: arr (list of ints): A sorted list containing both negative and positive integers. Returns: list of ints: A list containing the squares of each number from the input array in ascending order. >>> sortedSquares([-4, -1, 0, 3, 10]) [0, 1, 9, 16, 100] >>> sortedSquares([-7, -3, 2, 3, 11]) [4, 9, 9, 49, 121]","solution":"def sortedSquares(arr): Given a sorted array containing both negative and positive integers, return a new array containing the squares of each number from the input array in ascending order. Args: arr (list of ints): A sorted list containing both negative and positive integers. Returns: list of ints: A list containing the squares of each number from the input array in ascending order. n = len(arr) result = [0] * n left, right = 0, n - 1 index = n - 1 while left <= right: left_val, right_val = arr[left] ** 2, arr[right] ** 2 if left_val > right_val: result[index] = left_val left += 1 else: result[index] = right_val right -= 1 index -= 1 return result"},{"question":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in ascending order. >>> minimum_swaps_to_sort([4, 3, 1, 2]) 3 >>> minimum_swaps_to_sort([1]) 0 >>> minimum_swaps_to_sort([1, 2, 3, 4]) 0 >>> minimum_swaps_to_sort([4, 3, 2, 1]) 2 >>> minimum_swaps_to_sort([2, 3, 4, 1, 5]) 3","solution":"def minimum_swaps_to_sort(arr): Returns the minimum number of swaps required to sort the array in ascending order. # Create a list of tuples where each tuple contains an array element and its index indexed_arr = list(enumerate(arr)) # Sort the list based on the array elements indexed_arr.sort(key=lambda x: x[1]) # Create a visited array to mark already visited elements visited = [False] * len(arr) swaps = 0 for i in range(len(arr)): # If the element is already in the correct position or visited, skip it if visited[i] or indexed_arr[i][0] == i: continue # Compute the size of the cycle and add it to the swap count cycle_size = 0 j = i while not visited[j]: visited[j] = True j = indexed_arr[j][0] cycle_size += 1 if cycle_size > 0: swaps += cycle_size - 1 return swaps"},{"question":"def calculate_tribonacci(M: int) -> int: Calculate the M-th Tribonacci number. >>> calculate_tribonacci(0) == 0 >>> calculate_tribonacci(1) == 1 >>> calculate_tribonacci(2) == 1 >>> calculate_tribonacci(3) == 2 >>> calculate_tribonacci(4) == 4 >>> calculate_tribonacci(5) == 7 >>> calculate_tribonacci(6) == 13","solution":"def calculate_tribonacci(M): Calculate the M-th Tribonacci number. if M == 0: return 0 elif M == 1 or M == 2: return 1 tribonacci_sequence = [0, 1, 1] for i in range(3, M + 1): next_tribonacci = tribonacci_sequence[-1] + tribonacci_sequence[-2] + tribonacci_sequence[-3] tribonacci_sequence.append(next_tribonacci) return tribonacci_sequence[M]"},{"question":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Returns a new array consisting of the cumulative sums of the elements in the original array. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([0, 1, 0, 1]) [0, 1, 1, 2] >>> cumulative_sum([-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum([1, -1, 2, -2]) [1, 0, 2, 0] >>> cumulative_sum([]) [] >>> cumulative_sum([5]) [5] >>> cumulative_sum([1000000, 2000000, 3000000]) [1000000, 3000000, 6000000]","solution":"from typing import List def cumulative_sum(nums: List[int]) -> List[int]: Returns a new array consisting of the cumulative sums of the elements in the original array. result = [] current_sum = 0 for num in nums: current_sum += num result.append(current_sum) return result"},{"question":"def can_visit_all_cities(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines if the minions can visit all cities without exceeding the mileage limit for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): List containing tuples where each tuple represents a test case. Each tuple contains (N, L, distances) where: N (int) : the number of cities L (int) : the mileage limit distances (list of int) : distances between consecutive cities. Returns: list : Contains \\"YES\\" or \\"NO\\" for each test case indicating whether the minions can visit all cities. >>> can_visit_all_cities(2, [(5, 100, [10, 20, 30, 20]), (4, 50, [15, 20, 25])]) [\\"YES\\", \\"NO\\"] >>> can_visit_all_cities(1, [(3, 50, [30, 25])]) [\\"NO\\"] >>> can_visit_all_cities(1, [(3, 60, [30, 30])]) [\\"YES\\"]","solution":"def can_visit_all_cities(T, test_cases): Determines if the minions can visit all cities without exceeding the mileage limit for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): List containing tuples where each tuple represents a test case. Each tuple contains (N, L, distances) where: N (int) : the number of cities L (int) : the mileage limit distances (list of int) : distances between consecutive cities. Returns: list : Contains \\"YES\\" or \\"NO\\" for each test case indicating whether the minions can visit all cities. results = [] for case in test_cases: N, L, distances = case total_distance = sum(distances) if total_distance <= L: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maximum_collection_value(T: int, N: int, gem_values: List[int]) -> int: Determines the maximum total value Rita can collect over T days given N different types of gems. Parameters: T (int): Number of days Rita can collect gems. N (int): Number of different types of gems. gem_values (list): List of integers representing values of each type of gem. Returns: int: Maximum total value Rita can collect over T days. Examples: >>> maximum_collection_value(4, 5, [1, 2, 3, 4, 5]) 15 >>> maximum_collection_value(3, 3, [4, 5, 2]) 11 >>> maximum_collection_value(6, 6, [8, 1, 5, 3, 2, 7]) 26 >>> maximum_collection_value(2, 4, [100, 200, 300, 400]) 300","solution":"def maximum_collection_value(T, N, gem_values): Determines the maximum total value Rita can collect over T days given N different types of gems. Parameters: T (int): Number of days Rita can collect gems. N (int): Number of different types of gems. gem_values (list): List of integers representing values of each type of gem. Returns: int: Maximum total value Rita can collect over T days. # Sort the gem values in ascending order gem_values.sort() # Take the first T values from the sorted list (or as many as available if T > N) max_days_to_collect = min(T, N) # Calculate the sum of the selected gems return sum(gem_values[:max_days_to_collect])"},{"question":"def findPair(nums, target): Returns the first pair of indices whose elements sum up to the given target. If no such pair exists, returns (-1, -1). Examples: >>> findPair([2, 7, 11, 15], 9) (0, 1) >>> findPair([3, 2, 4], 6) (1, 2) >>> findPair([3, 3], 6) (0, 1) >>> findPair([1, 2, 3, 4], 8) (-1, -1)","solution":"def findPair(nums, target): Returns the first pair of indices whose elements sum up to the given target. If no such pair exists, returns (-1, -1). seen = {} for idx, num in enumerate(nums): complement = target - num if complement in seen: return (seen[complement], idx) seen[num] = idx return (-1, -1)"},{"question":"def max_subarray_sum(arr): Given an integer array \`arr\`, find the subarray with the maximum sum and return that sum. A subarray is defined as a contiguous part of the array. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([-2, -3, -4, -1, -2]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(arr): Returns the maximum sum of a subarray in the given array. if not arr: return 0 current_sum = max_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def longest_palindrome_sequence(numbers: List[int]) -> List[int]: Find the length of the longest palindromic subsequence of the digits of the given numbers. >>> longest_palindrome_sequence([12321, 45654, 98789, 123456]) [5, 5, 5, 1] >>> longest_palindrome_sequence([112233, 123321, 543212345]) [2, 6, 9]","solution":"def longest_palindrome_sequence(numbers): def longest_palindromic_subseq_length(s): n = len(s) if n == 0: return 0 # dp[i][j] will store the length of the longest palindromic subsequence # in s[i..j] dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the DP table for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] return [longest_palindromic_subseq_length(str(num)) for num in numbers]"},{"question":"def largest_rectangle_area(heights): Find the area of the largest rectangle formed by consecutive buildings. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4, 2, 4]) 8 >>> largest_rectangle_area([1, 2, 3]) 4 >>> largest_rectangle_area([3, 3, 3, 3, 3]) 15 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([4, 2, 0, 3, 2, 4, 3, 4]) 10","solution":"def largest_rectangle_area(heights): Find the area of the largest rectangle formed by consecutive buildings. n = len(heights) stack = [] max_area = 0 index = 0 while index < n: if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * (index if not stack else index - stack[-1] - 1) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * (index if not stack else index - stack[-1] - 1) max_area = max(max_area, area) return max_area"},{"question":"def next_project_identifier(current_id: str) -> str: Generates the next project identifier in the sequence. Args: current_id (str): The current project identifier (e.g., \\"P001\\"). Returns: str: The next project identifier (e.g., \\"P002\\"). Examples: >>> next_project_identifier(\\"P001\\") 'P002' >>> next_project_identifier(\\"P999\\") 'Q000' >>> next_project_identifier(\\"S999\\") 'P000' >>> next_project_identifier(\\"Q256\\") 'Q257'","solution":"def next_project_identifier(current_id: str) -> str: # Letter sequence in order letters = ['P', 'Q', 'R', 'S'] # Extract the letter part and the numeric part from the current_id letter_part = current_id[0] number_part = int(current_id[1:]) # Increment the numeric part number_part += 1 # Check if the numeric part exceeds the 999 limit if number_part > 999: number_part = 0 # Reset to 000 # Get the next letter in sequence, cycling back to 'P' after 'S' letter_index = letters.index(letter_part) next_letter_index = (letter_index + 1) % len(letters) letter_part = letters[next_letter_index] # Format the new identifier new_id = f\\"{letter_part}{number_part:03d}\\" return new_id"},{"question":"def can_distribute_chocolates(N, M): Determines whether it is possible to distribute N chocolates among friends such that each friend gets exactly M chocolates. Args: N (int): Total number of chocolates. M (int): Number of chocolates each friend should get. Returns: str: 'Yes' if possible, otherwise 'No'. >>> can_distribute_chocolates(10, 2) == 'Yes' >>> can_distribute_chocolates(9, 2) == 'No' >>> can_distribute_chocolates(15, 3) == 'Yes'","solution":"def can_distribute_chocolates(N, M): Determines whether it is possible to distribute N chocolates among friends such that each friend gets exactly M chocolates. Args: N (int): Total number of chocolates. M (int): Number of chocolates each friend should get. Returns: str: 'Yes' if possible, otherwise 'No'. return 'Yes' if N % M == 0 else 'No'"},{"question":"def concatenate_k_strings(str_list, k): Concatenates k consecutive strings from the input list and returns a list of such concatenated strings. Parameters: str_list (list of str): The list of strings to be concatenated. k (int): The number of consecutive strings to concatenate. Returns: list of str: A list of concatenated strings. >>> concatenate_k_strings([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 2) [\\"ab\\", \\"cd\\"] >>> concatenate_k_strings([\\"hello\\", \\"world\\", \\"python\\"], 2) [\\"helloworld\\"] >>> concatenate_k_strings([\\"one\\", \\"two\\", \\"three\\", \\"four\\"], 3) [\\"onetwothree\\"] >>> concatenate_k_strings([], 1) [] >>> concatenate_k_strings([\\"apple\\", \\"banana\\"], 3) []","solution":"def concatenate_k_strings(str_list, k): Concatenates k consecutive strings from the input list and returns a list of such concatenated strings. Parameters: str_list (list of str): The list of strings to be concatenated. k (int): The number of consecutive strings to concatenate. Returns: list of str: A list of concatenated strings. if len(str_list) < k or k <= 0: return [] result = [] for i in range(0, len(str_list) - k + 1, k): concatenated_string = ''.join(str_list[i:i + k]) result.append(concatenated_string) return result"},{"question":"def oddland_number(N: int) -> int: Returns the smallest integer greater than or equal to N whose sum of digits is odd. >>> oddland_number(47) 47 >>> oddland_number(28) 29 >>> oddland_number(1) 1 >>> oddland_number(44) 45 >>> oddland_number(135) 135","solution":"def sum_of_digits(n): Returns the sum of digits of the number n. return sum(int(digit) for digit in str(n)) def oddland_number(N): Returns the smallest integer greater than or equal to N whose sum of digits is odd. while sum_of_digits(N) % 2 == 0: N += 1 return N"},{"question":"def longest_balanced_parentheses(s: str) -> int: Returns the length of the longest balanced parentheses substring. :param s: A string consisting of only '(' and ')'. :return: An integer representing the length of the longest balanced parentheses substring. >>> longest_balanced_parentheses(\\"(()())\\") 6 >>> longest_balanced_parentheses(\\")()())\\") 4","solution":"def longest_balanced_parentheses(s): Returns the length of the longest balanced parentheses substring. :param s: A string consisting of only '(' and ')'. :return: An integer representing the length of the longest balanced parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: stack.append(i) return max_length"},{"question":"def count_increasing_subsequences(nums, L): Returns the number of strictly increasing subsequences of length exactly L. # Your code goes here def process_test_cases(test_cases): Process and solve multiple test cases. # Your code goes here def test_count_increasing_subsequences(): test_cases = [ (4, 2, [1, 2, 3, 4], 6), (5, 3, [5, 3, 4, 2, 1], 0), (6, 4, [1, 3, 2, 4, 3, 5], 3), (1, 1, [1], 1), (3, 3, [1, 2, 3], 1) ] for N, L, sequence, expected in test_cases: assert count_increasing_subsequences(sequence, L) == expected def test_process_test_cases(): test_cases = [ (4, 2, [1, 2, 3, 4]), (5, 3, [5, 3, 4, 2, 1]), (6, 4, [1, 3, 2, 4, 3, 5]) ] expected_results = [6, 0, 3] assert process_test_cases(test_cases) == expected_results","solution":"def count_increasing_subsequences(nums, L): Returns the number of strictly increasing subsequences of length exactly L. from functools import lru_cache N = len(nums) @lru_cache(None) def count_sequences(start, length): if length == 1: return 1 # A single element is a valid subsequence count = 0 for i in range(start + 1, N): if nums[i] > nums[start]: count += count_sequences(i, length - 1) return count total_count = 0 for i in range(N - L + 1): total_count += count_sequences(i, L) return total_count def process_test_cases(test_cases): results = [] for N, L, sequence in test_cases: results.append(count_increasing_subsequences(sequence, L)) return results"},{"question":"def calculateTrappedWater(heights: List[int]) -> int: Calculate the amount of water that can be trapped after raining. >>> calculateTrappedWater([3, 0, 2, 0, 4]) 7 >>> calculateTrappedWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculateTrappedWater([1, 1, 1, 1]) 0 >>> calculateTrappedWater([5]) 0 >>> calculateTrappedWater([1, 2]) 0 >>> calculateTrappedWater([4, 2, 0, 3, 2, 5]) 9 >>> calculateTrappedWater([3, 3, 3]) 0 >>> calculateTrappedWater([0, 0, 0, 0]) 0 # Your code here pass","solution":"from typing import List def calculateTrappedWater(heights: List[int]) -> int: Calculate the amount of water that can be trapped after raining. :param heights: List of non-negative integers representing the heights of adjacent buildings. :return: Total units of water trapped. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Compute the left_max values. left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Compute the right_max values. right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water. trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"import math from typing import List def is_perfect_square(x: int) -> bool: Returns True if x is a perfect square, False otherwise. root = int(math.sqrt(x)) return root * root == x def digit_swap_square(q: int, queries: List[int]) -> List[str]: For each number in queries, check if any permutation of its digits (including the number itself) is a perfect square. Returns a list of \\"YES\\" or \\"NO\\". >>> digit_swap_square(3, [13, 82, 144]) ['NO', 'YES', 'NO']","solution":"import math def is_perfect_square(x): Returns True if x is a perfect square, False otherwise. root = int(math.sqrt(x)) return root * root == x def digit_swap_square(q, queries): For each number in queries, check if any permutation of its digits (including the number itself) is a perfect square. Returns a list of \\"YES\\" or \\"NO\\". results = [] for number in queries: digit_list = list(str(number)) found = False # Generate all unique permutations of the digits for i in range(len(digit_list)): for j in range(i+1, len(digit_list)): # Swap digits i and j digit_list[i], digit_list[j] = digit_list[j], digit_list[i] permuted_number = int(''.join(digit_list)) if is_perfect_square(permuted_number): found = True break # Swap back to original digit_list[i], digit_list[j] = digit_list[j], digit_list[i] if found: break if is_perfect_square(number) or found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def is_special_element_exist(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if there is any special element in the array for each test case. >>> is_special_element_exist(3, [(5, [1, 2, 3, 2, 1]), (4, [1, 2, 3, 4]), (6, [1, 2, 3, 4, 3, 2])]) ['YES', 'NO', 'NO'] >>> is_special_element_exist(1, [(5, [5, 6, 3, 6, 5])]) ['YES']","solution":"def is_special_element_exist(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] total_sum = sum(arr) left_sum = 0 found = False counts = {} for num in arr: if num in counts: counts[num] += 1 else: counts[num] = 1 for j in range(n): current = arr[j] if counts[current] == 1: right_sum = total_sum - left_sum - current if left_sum == right_sum: results.append(\\"YES\\") found = True break left_sum += current if not found: results.append(\\"NO\\") return results"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merge all overlapping intervals and return the merged intervals sorted by their starting points. >>> merge_intervals([[1, 4], [2, 5], [8, 10]]) [[1, 5], [8, 10]] >>> merge_intervals([[0, 1], [3, 5], [4, 8], [10, 12]]) [[0, 1], [3, 8], [10, 12]]","solution":"def merge_intervals(intervals): Merges overlapping intervals and returns the merged intervals sorted by their starting points. Args: intervals (List[List[int]]): List of intervals where each interval is a pair [start, end]. Returns: List[List[int]]: List of merged intervals. if not intervals: return [] # Sort intervals by their starting point intervals.sort(key=lambda x: x[0]) merged_intervals = [] current_interval = intervals[0] for interval in intervals: if interval[0] <= current_interval[1]: # Overlapping intervals, merge them current_interval[1] = max(current_interval[1], interval[1]) else: merged_intervals.append(current_interval) current_interval = interval # Update to the new interval # Don't forget to add the last interval merged_intervals.append(current_interval) return merged_intervals def read_input(): n = int(input().strip()) intervals = [list(map(int, input().strip().split())) for _ in range(n)] return intervals def print_output(intervals): for interval in intervals: print(f\\"{interval[0]} {interval[1]}\\")"},{"question":"def find_competition_winner(S, D, B, sessions, boosts): Find the student with the highest total points at the end of the competition. Args: S (int): number of students D (int): number of sessions B (int): number of boosted sessions sessions (List[Tuple[int, int, int]]): list of tuples where each tuple contains the student ID, day number, and points earned in that session boosts (List[int]): list of day numbers that are boosted Returns: int: the ID of the student with the highest total points >>> find_competition_winner(3, 6, 2, [(1, 1, 10), (2, 1, 20), (3, 1, 30), (1, 2, 25), (2, 2, 30), (3, 2, 20)], [1, 2]) 2 >>> find_competition_winner(2, 3, 0, [(1, 1, 15), (2, 2, 25), (1, 3, 5)], []) 2 >>> find_competition_winner(2, 3, 1, [(1, 1, 10), (2, 2, 15), (1, 3, 20)], [1]) 1","solution":"def find_competition_winner(S, D, B, sessions, boosts): points = [0] * (S + 1) # Initialize points for each student boost_days = set(boosts) # Use a set for quick lookup of boosted days for si, di, pi in sessions: if di in boost_days: points[si] += 2 * pi # Double the points if it's a boosted day else: points[si] += pi max_points = max(points) # Find the student with the highest points and smallest ID in case of a tie for student_id in range(1, S + 1): if points[student_id] == max_points: return student_id"},{"question":"from typing import List, Tuple def convert_and_sum(test_cases: List[Tuple[str, float, str, str]]) -> List[int]: Convert weights and heights between given measurement units and calculate the integer sum of the converted weight and height. Parameters: test_cases (List[Tuple[str, float, str, str]]): A list of tuples containing the measurement type, value, source unit, and target unit. Returns: List[int]: A list of integer sums of the converted values for each test case. Examples: >>> convert_and_sum([(\\"weight\\", 10, \\"kilograms\\", \\"grams\\")]) [10000] >>> convert_and_sum([(\\"height\\", 1, \\"meters\\", \\"inches\\")]) [39] >>> convert_and_sum([(\\"weight\\", 15.5, \\"pounds\\", \\"kilograms\\")]) [7] >>> convert_and_sum([(\\"height\\", 250, \\"centimeters\\", \\"meters\\")]) [2] >>> convert_and_sum([ (\\"weight\\", 10, \\"kilograms\\", \\"grams\\"), (\\"height\\", 1, \\"meters\\", \\"inches\\"), (\\"weight\\", 15.5, \\"pounds\\", \\"kilograms\\"), (\\"height\\", 250, \\"centimeters\\", \\"meters\\") ]) [10000, 39, 7, 2]","solution":"def convert_and_sum(test_cases): def convert(value, from_unit, to_unit, conversion_factors): return value * conversion_factors[(from_unit, to_unit)] weight_conversion = { (\\"kilograms\\", \\"grams\\"): 1000, (\\"grams\\", \\"kilograms\\"): 1 / 1000, (\\"kilograms\\", \\"pounds\\"): 2.20462, (\\"pounds\\", \\"kilograms\\"): 1 / 2.20462, (\\"grams\\", \\"pounds\\"): 1 / 453.592, (\\"pounds\\", \\"grams\\"): 453.592 } height_conversion = { (\\"meters\\", \\"centimeters\\"): 100, (\\"centimeters\\", \\"meters\\"): 1 / 100, (\\"meters\\", \\"inches\\"): 39.3701, (\\"inches\\", \\"meters\\"): 1 / 39.3701, (\\"centimeters\\", \\"inches\\"): 1 / 2.54, (\\"inches\\", \\"centimeters\\"): 2.54 } results = [] for case in test_cases: measurement_type, value, from_unit, to_unit = case if measurement_type == \\"weight\\": conversion_factors = weight_conversion elif measurement_type == \\"height\\": conversion_factors = height_conversion converted_value = convert(value, from_unit, to_unit, conversion_factors) results.append(int(converted_value)) return results"},{"question":"def is_leap_year(year): Determine if a given year is a leap year. >>> is_leap_year(2020) \\"Yes\\" >>> is_leap_year(1900) \\"No\\" >>> is_leap_year(2000) \\"Yes\\" def leap_years(T, years): Process multiple years to determine if they are leap years. >>> leap_years(3, [2020, 1900, 2000]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> leap_years(2, [2019, 1600]) [\\"No\\", \\"Yes\\"]","solution":"def is_leap_year(year): Determine if a given year is a leap year. Args: year (int): The year to check. Returns: str: \\"Yes\\" if the year is a leap year, otherwise \\"No\\". if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"Yes\\" else: return \\"No\\" def leap_years(T, years): Process multiple years to determine if they are leap years. Args: T (int): Number of test cases. years (list of int): List of years to be checked. Returns: list of str: List of \\"Yes\\" or \\"No\\" for each year. results = [] for year in years: results.append(is_leap_year(year)) return results"},{"question":"def find_two_non_repeating_numbers(numbers: List[int]) -> List[int]: Finds and returns the two elements that appear only once in the array. The rest of the elements appear exactly twice. >>> find_two_non_repeating_numbers([1, 2, 1, 3, 2, 5, 4, 4]) [3, 5] >>> find_two_non_repeating_numbers([7, 9, 7, 8, 10, 10]) [8, 9] >>> find_two_non_repeating_numbers([1, 2]) [1, 2] >>> find_two_non_repeating_numbers([1, 2, 3, 2, 1, 4]) [3, 4] >>> find_two_non_repeating_numbers([100000, 200000, 100000, 300000, 400000, 200000]) [300000, 400000]","solution":"def find_two_non_repeating_numbers(numbers): Finds and returns the two elements that appear only once in the array. The rest of the elements appear exactly twice. xor_result = 0 for num in numbers: xor_result ^= num # Get the rightmost set bit of xor_result rightmost_set_bit = xor_result & -xor_result # Divide elements into two groups based on the rightmost set bit num1 = 0 num2 = 0 for num in numbers: if (num & rightmost_set_bit) == 0: num1 ^= num else: num2 ^= num return sorted([num1, num2])"},{"question":"def findMaxLengthSubarray(arr: List[int], N: int) -> int: Finds the maximum length of the subarray with consecutive elements. Args: arr (list of int): The input array of distinct integers. N (int): The size of the array. Returns: int: The length of the maximum subarray where the elements can be rearranged to form a consecutive sequence. Example: >>> findMaxLengthSubarray([1, 2, 2, 5, 3], 4) 3 >>> findMaxLengthSubarray([10, 12, 11, 14, 13, 15], 6) 6 >>> findMaxLengthSubarray([4, 5, 1, 9, 10], 5) 2","solution":"def findMaxLengthSubarray(arr, N): Finds the maximum length of the subarray with consecutive elements. Args: arr (list of int): The input array of distinct integers. N (int): The size of the array. Returns: int: The length of the maximum subarray where the elements can be rearranged to form a consecutive sequence. if N == 0: return 0 num_set = set(arr) max_len = 0 for num in arr: # Check if \`num\` is the starting point of a new sequence if (num - 1) not in num_set: current_num = num current_len = 1 # Check the length of the consecutive sequence starting from \`num\` while (current_num + 1) in num_set: current_num += 1 current_len += 1 max_len = max(max_len, current_len) return max_len"},{"question":"def hackathon_registration(registration_string): Takes a string containing participants' names and project names and returns a list of dictionaries, each containing a participant's name and their project name. >>> hackathon_registration(\\"Alice Johnson, Project A, Bob Smith, Project B\\") [{'participant': 'Alice Johnson', 'project': 'Project A'}, {'participant': 'Bob Smith', 'project': 'Project B'}] >>> hackathon_registration(None) [] >>> hackathon_registration(\\"\\") []","solution":"def hackathon_registration(registration_string): Takes a string containing participants' names and project names and returns a list of dictionaries, each containing a participant's name and their project name. Arguments: registration_string (str): A string with participants' names and their projects separated by \\", \\". Returns: list: A list of dictionaries with keys 'participant' and 'project'. if not registration_string: return [] split_string = registration_string.split(\\", \\") if len(split_string) % 2 != 0: raise ValueError(\\"Input string must contain an even number of elements.\\") result = [] for i in range(0, len(split_string), 2): participant_info = {\\"participant\\": split_string[i], \\"project\\": split_string[i+1]} result.append(participant_info) return result"},{"question":"def server_management(s, p, q, operations): Manages the incoming and outgoing data packets for servers. :param s: int - Number of servers :param p: int - Max capacity of each server :param q: int - Number of operations :param operations: list of strings - List of operations to be performed :return: list of int - Results of CHECK operations >>> server_management(3, 100, 5, [\\"PING 1 30\\", \\"PING 1 70\\", \\"PING 2 50\\", \\"CHECK 1\\", \\"CHECK 2\\"]) [100, 50] >>> server_management(2, 50, 4, [\\"PING 1 30\\", \\"PING 1 25\\", \\"CHECK 1\\", \\"PING 2 60\\"]) [30] >>> server_management(1, 50, 2, [\\"PING 2 30\\", \\"CHECK 2\\"]) [-1] >>> server_management(2, 50, 5, [\\"PING 1 30\\", \\"PING 1 25\\", \\"PING 1 25\\", \\"CHECK 1\\", \\"CHECK 2\\"]) [30, 0] >>> server_management(3, 100, 8, [\\"PING 1 30\\", \\"PING 2 40\\", \\"CHECK 1\\", \\"CHECK 2\\", \\"PING 3 50\\", \\"PING 1 50\\", \\"CHECK 1\\", \\"CHECK 3\\"]) [30, 40, 80, 50]","solution":"def server_management(s, p, q, operations): Manages the incoming and outgoing data packets for servers. :param s: int - Number of servers :param p: int - Max capacity of each server :param q: int - Number of operations :param operations: list of strings - List of operations to be performed :return: list of int - Results of CHECK operations servers = {i: 0 for i in range(1, s+1)} results = [] for operation in operations: parts = operation.split() if parts[0] == \\"PING\\": server_id = int(parts[1]) size = int(parts[2]) if servers.get(server_id, -1) != -1 and servers[server_id] + size <= p: servers[server_id] += size elif parts[0] == \\"CHECK\\": server_id = int(parts[1]) results.append(servers.get(server_id, -1)) return results"},{"question":"def count_obstacles(N: int, M: int, K: int, operations: List[Tuple[int, int, int]]) -> int: Counts the number of cells marked as obstacles after performing all operations. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. K (int): Number of operations. operations (list): List of operations where each operation is a tuple (x, y, v). Returns: int: Number of cells marked as obstacles. Example: >>> count_obstacles(4, 5, 3, [(2, 3, 1), (1, 4, 1), (0, 0, 1)]) 3 >>> count_obstacles(2, 3, 2, [(0, 0, 1), (1, 1, 0)]) 1","solution":"def count_obstacles(N, M, K, operations): Counts the number of cells marked as obstacles after performing all operations. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. K (int): Number of operations. operations (list): List of operations where each operation is a tuple (x, y, v). Returns: int: Number of cells marked as obstacles. grid = [[0] * M for _ in range(N)] for x, y, v in operations: grid[x][y] = v obstacle_count = sum(grid[i][j] for i in range(N) for j in range(M)) return obstacle_count # Helper function to parse input data (for use in the test cases) def parse_input(input_data): lines = input_data.strip().split(\\"n\\") N, M, K = map(int, lines[0].split()) operations = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, K, operations"},{"question":"from typing import List def is_possible(arr: List[int]) -> str: Given a list of positive integers, returns \\"POSSIBLE\\" if it is possible to arrange the numbers such that the sum of every adjacent pair of numbers is always odd. Otherwise, returns \\"IMPOSSIBLE\\". >>> is_possible([1, 2, 3, 4]) 'POSSIBLE' >>> is_possible([2, 4, 6, 8, 1]) 'IMPOSSIBLE' def test_is_possible_equal_odd_even(): assert is_possible([1, 2, 3, 4]) == \\"POSSIBLE\\" assert is_possible([2, 4, 1, 3]) == \\"POSSIBLE\\" def test_is_possible_more_evens(): assert is_possible([2, 4, 6, 8, 1]) == \\"IMPOSSIBLE\\" def test_is_possible_more_odds(): assert is_possible([1, 3, 5, 7, 2]) == \\"IMPOSSIBLE\\" def test_is_possible_all_odds(): assert is_possible([1, 3, 5, 7]) == \\"IMPOSSIBLE\\" def test_is_possible_all_evens(): assert is_possible([2, 4, 6, 8]) == \\"IMPOSSIBLE\\" def test_is_possible_single_element(): assert is_possible([1]) == \\"IMPOSSIBLE\\" assert is_possible([2]) == \\"IMPOSSIBLE\\" def test_is_possible_large_example(): assert is_possible([i for i in range(1, 101) if i % 2 == 0] + [i for i in range(1, 101) if i % 2 != 0]) == \\"POSSIBLE\\"","solution":"def is_possible(arr): Checks if it is possible to arrange the numbers in such a way that the sum of every adjacent pair of numbers is always odd. # Count the number of odd and even numbers odd_count = sum(1 for x in arr if x % 2 != 0) even_count = len(arr) - odd_count # For the sums to always be odd, we need an equal number of odd and even numbers if odd_count == even_count: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"import math from typing import List def find_perfect_square_product(arr: List[int]) -> str: Given an integer array \`arr\`, determine if there exist two distinct indices i and j such that the product of elements at these indices is a perfect square. >>> find_perfect_square_product([2, 3, 4, 6, 8]) \\"YES\\" >>> find_perfect_square_product([11, 13, 17, 19]) \\"NO\\"","solution":"import math from itertools import combinations def is_perfect_square(x): root = int(math.isqrt(x)) return root * root == x def find_perfect_square_product(arr): for i, j in combinations(range(len(arr)), 2): if is_perfect_square(arr[i] * arr[j]): return \\"YES\\" return \\"NO\\""},{"question":"def min_difference(nums: List[int], K: int) -> int: Returns the minimum possible difference between the height of the tallest tower and the height of the shortest tower after modifying the heights. Example 1: >>> min_difference([1, 5, 8, 10], 2) 5 Example 2: >>> min_difference([3, 9, 12, 16, 20], 3) 11 Example 3: >>> min_difference([10], 5) 0 Example 4: >>> min_difference([4, 7, 9], 0) 5 Example 5: >>> min_difference([1, 2, 3, 4, 5], 10) 4 Example 6: >>> min_difference([5, 5, 5, 5], 5) 0","solution":"def min_difference(nums, K): Returns the minimum possible difference between the height of the tallest tower and the height of the shortest tower after modifying the heights. if not nums: return 0 nums.sort() n = len(nums) current_diff = nums[-1] - nums[0] for i in range(n - 1): high = max(nums[-1] - K, nums[i] + K) low = min(nums[0] + K, nums[i + 1] - K) current_diff = min(current_diff, high - low) return current_diff"},{"question":"def num_unique_paths(maze): Returns the number of unique paths from the top-left corner to the bottom-right corner of the maze. >>> num_unique_paths([['.', '.'], ['.', '.']]) 2 >>> num_unique_paths([['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.']]) 2 >>> num_unique_paths([['#', '.'], ['.', '.']]) 0 >>> num_unique_paths([['.', '.'], ['.', '#']]) 0 >>> num_unique_paths([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) 6","solution":"def num_unique_paths(maze): Returns the number of unique paths from the top-left corner to the bottom-right corner of the maze. N = len(maze) if maze[0][0] == '#' or maze[N-1][N-1] == '#': return 0 def is_valid(x, y): return 0 <= x < N and 0 <= y < N and maze[x][y] == '.' def find_paths(x, y): if x == N-1 and y == N-1: return 1 paths = 0 directions = [(0, 1), (1, 0)] for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): paths += find_paths(nx, ny) return paths return find_paths(0, 0)"},{"question":"def min_minutes(N: int, K: int, M: int) -> int: Returns the minimum number of minutes required to prepare exactly K dishes, each utilizing M different ingredients. >>> min_minutes(3, 6, 2) 4 >>> min_minutes(4, 10, 3) 8 >>> min_minutes(2, 5, 1) 3","solution":"def min_minutes(N, K, M): Returns the minimum number of minutes required to prepare exactly K dishes, each utilizing M different ingredients. # To prepare K dishes with M different ingredients, each ingredient needs to be prepared K times # Since the chef can prepare N units of one type of ingredient per minute, # we need to prepare (K * M) units and divide by N. total_units_needed = K * M minutes_needed = (total_units_needed + N - 1) // N # Using ceiling division to cover all units return minutes_needed"},{"question":"class TreeNode: def __init__(self, id): self.id = id self.children = [] def build_tree(n, ids, manager_pairs): nodes = {id: TreeNode(id) for id in ids} for u, v in manager_pairs: nodes[u].children.append(nodes[v]) root = nodes[ids[0]] return root def find_path(root, target): path = [] def dfs(node, target): if not node: return False path.append(node.id) if node.id == target: return True for child in node.children: if dfs(child, target): return True path.pop() return False dfs(root, target) return path def employee_path(n, ids, manager_pairs, target): Given the root of the employee tree and the target employee ID, return the path from the CEO to this employee ID as a string with each ID separated by ' -> '. Parameters: n (int): Number of employees ids (List[int]): List of employee IDs manager_pairs (List[Tuple[int, int]]): List of (manager, employee) pairs target (int): Target employee ID Returns: str: Path from CEO to target employee ID >>> employee_path(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)], 5) '1 -> 2 -> 5' >>> employee_path(1, [1], [], 1) '1' >>> employee_path(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)], 4) '1 -> 2 -> 3 -> 4' >>> employee_path(6, [1, 2, 3, 4, 5, 6], [(1, 2), (2, 3), (2, 4), (4, 5), (4, 6)], 6) '1 -> 2 -> 4 -> 6' >>> employee_path(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (1, 4), (1, 5)], 4) '1 -> 4'","solution":"class TreeNode: def __init__(self, id): self.id = id self.children = [] def build_tree(n, ids, manager_pairs): nodes = {id: TreeNode(id) for id in ids} for u, v in manager_pairs: nodes[u].children.append(nodes[v]) root = nodes[ids[0]] return root def find_path(root, target): path = [] def dfs(node, target): if not node: return False path.append(node.id) if node.id == target: return True for child in node.children: if dfs(child, target): return True path.pop() return False dfs(root, target) return path def employee_path(n, ids, manager_pairs, target): root = build_tree(n, ids, manager_pairs) path = find_path(root, target) return \\" -> \\".join(map(str, path))"},{"question":"def isMagicSquare(N, Matrix): Determine if the given NxN matrix is a magic square. A magic square is a grid of distinct numbers where the sum of the numbers in each row, each column, and the two main diagonals are all equal. Params: N: int: Dimension of the matrix (N x N) Matrix: List[List[int]]: 2D array representing the matrix Returns: int: 1 if the matrix is a magic square, otherwise 0 Examples: >>> isMagicSquare(3, [ ... [8, 1, 6], ... [3, 5, 7], ... [4, 9, 2]]) 1 >>> isMagicSquare(3, [ ... [8, 1, 6], ... [3, 5, 7], ... [4, 9, 3]]) 0","solution":"def isMagicSquare(N, Matrix): Determine if the given NxN matrix is a magic square. A magic square is a grid of distinct numbers where the sum of the numbers in each row, each column, and the two main diagonals are all equal. Params: N: int: Dimension of the matrix (N x N) Matrix: List[List[int]]: 2D array representing the matrix Returns: int: 1 if the matrix is a magic square, otherwise 0 # Calculate the sum of the first row as the target sum target_sum = sum(Matrix[0]) # Check sums of all rows for row in Matrix: if sum(row) != target_sum: return 0 # Check sums of all columns for col in range(N): col_sum = 0 for row in range(N): col_sum += Matrix[row][col] if col_sum != target_sum: return 0 # Check sum of the main diagonal (top-left to bottom-right) main_diag_sum = 0 for i in range(N): main_diag_sum += Matrix[i][i] if main_diag_sum != target_sum: return 0 # Check sum of the other diagonal (top-right to bottom-left) other_diag_sum = 0 for i in range(N): other_diag_sum += Matrix[i][N - 1 - i] if other_diag_sum != target_sum: return 0 return 1"},{"question":"def gridGame(N: int, M: int, Grid: List[List[int]]) -> str: You are given a grid with N rows and M columns. Each cell of the grid contains a non-negative integer. Two players play a game taking turns. On each turn, a player can choose any cell and increment its value by 1. The game ends when all the cells in the grid contain the same value. The player who cannot make a move because the game has already ended is the loser. Determine the winner of the game assuming both players play optimally. >>> gridGame(2, 2, [[1, 2], [2, 2]]) \\"First\\" >>> gridGame(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) \\"Second\\"","solution":"def gridGame(N, M, Grid): max_value = max(max(row) for row in Grid) total_moves = sum(max_value - Grid[i][j] for i in range(N) for j in range(M)) if total_moves % 2 == 1: return \\"First\\" else: return \\"Second\\""},{"question":"def reduce_array_to_prime(n, arr): You are given an array of n positive integers. In one operation, you can select any two adjacent elements in the array, remove them, and insert their sum back into the array. The goal is to determine if it is possible to reduce the array to a single element which is a prime number. If it is possible, output \\"YES\\" and print a sequence of operations to achieve this. Otherwise, output \\"NO\\". n : int : the number of elements in the array (1 ≤ n ≤ 10^5) arr : List[int] : list of n positive integers (1 ≤ a_i ≤ 10^5) >>> reduce_array_to_prime(5, [2, 3, 5, 7, 11]) YES 0 1 0 1 0 1 0 1 >>> reduce_array_to_prime(2, [4, 7]) YES 0 1 >>> reduce_array_to_prime(3, [4, 6, 8]) NO >>> reduce_array_to_prime(1, [10]) NO >>> reduce_array_to_prime(1, [5]) YES # Implementation here","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def reduce_to_prime(n, arr): operations = [] if n == 1: if is_prime(arr[0]): return \\"YES\\", [] else: return \\"NO\\", [] while n > 1: min_sum = float('inf') min_index = -1 for i in range(n - 1): if arr[i] + arr[i + 1] < min_sum: min_sum = arr[i] + arr[i + 1] min_index = i arr[min_index] = min_sum arr.pop(min_index + 1) operations.append((min_index, min_index + 1)) n -= 1 if is_prime(arr[0]): return \\"YES\\", operations return \\"NO\\", [] def reduce_array_to_prime(n, arr): result, operations = reduce_to_prime(n, arr) if result == \\"YES\\": print(\\"YES\\") for op in operations: print(op[0], op[1]) else: print(\\"NO\\")"},{"question":"def max_subset_sum_under_x(T: int, test_cases: List[Dict[str, Union[int, List[int]]]]) -> List[int]: Given an array of integers A of length n and an integer x, select a subset of elements from A such that their sum is maximized and does not exceed x. Params: - T: the number of test cases - test_cases: a list of dictionaries where each dictionary contains: - 'n': the number of elements in the array - 'x': the target sum - 'A': the list of integers in the array Returns: A list of integers where each integer is the maximum possible sum of any subset of elements from A that does not exceed x for the corresponding test case. >>> T = 3 >>> test_cases = [ {'n': 5, 'x': 10, 'A': [1, 2, 3, 4, 5]}, {'n': 3, 'x': 7, 'A': [2, 2, 6]}, {'n': 4, 'x': 100, 'A': [20, 30, 50, 70]}, ] >>> max_subset_sum_under_x(T, test_cases) [10, 6, 100]","solution":"def max_subset_sum_under_x(T, test_cases): results = [] for i in range(T): n, x = test_cases[i]['n'], test_cases[i]['x'] A = test_cases[i]['A'] # Use dynamic programming (similar to knapsack problem) to solve the problem dp = [0] * (x + 1) for a in A: for j in range(x, a - 1, -1): dp[j] = max(dp[j], dp[j - a] + a) results.append(dp[x]) return results"},{"question":"def check_leap_year(year: int) -> str: Determines if the given year is a leap year. Args: year (int): The year to be checked. Returns: str: \\"leap\\" if the year is a leap year, \\"common\\" otherwise. >>> check_leap_year(2000) \\"leap\\" >>> check_leap_year(1900) \\"common\\" >>> check_leap_year(2012) \\"leap\\" >>> check_leap_year(2015) \\"common\\" >>> check_leap_year(2400) \\"leap\\" >>> check_leap_year(2100) \\"common\\" >>> check_leap_year(1996) \\"leap\\" >>> check_leap_year(2104) \\"leap\\"","solution":"def check_leap_year(year): Determines if the given year is a leap year. Arguments: year : int : The year to be checked. Returns: str : \\"leap\\" if the year is a leap year, \\"common\\" otherwise. if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return \\"leap\\" else: return \\"common\\""},{"question":"from typing import List, Tuple def longest_increasing_message_sequence(n: int, messages: List[Tuple[int, int]]) -> int: Find the longest sequence of messages such that the message IDs are sorted in strictly increasing order according to their send time. :param n: Number of messages :param messages: List of tuples, each containing message_id and timestamp :return: The length of the longest sequence >>> longest_increasing_message_sequence(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 5 >>> longest_increasing_message_sequence(7, [(1, 2), (2, 3), (3, 2), (4, 5), (5, 7), (6, 3), (7, 6)]) 4 pass # Write your code here def test_longest_increasing_message_sequence(): # Test case 1 n = 5 messages = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)] assert longest_increasing_message_sequence(n, messages) == 5 # Test case 2 n = 7 messages = [(1, 2), (2, 3), (3, 2), (4, 5), (5, 7), (6, 3), (7, 6)] assert longest_increasing_message_sequence(n, messages) == 4 # Test case 3 n = 1 messages = [(10, 1000)] assert longest_increasing_message_sequence(n, messages) == 1 # Test case 4 n = 5 messages = [(5, 1), (4, 2), (3, 3), (2, 4), (1, 5)] assert longest_increasing_message_sequence(n, messages) == 1 # Test case 5 n = 6 messages = [(1, 100), (2, 200), (2, 150), (3, 300), (4, 250), (5, 400)] assert longest_increasing_message_sequence(n, messages) == 4 # Test case 6 n = 10 messages = [(i, i) for i in range(1, 11)] assert longest_increasing_message_sequence(n, messages) == 10 if __name__ == \\"__main__\\": test_longest_increasing_message_sequence()","solution":"def longest_increasing_message_sequence(n, messages): # Sort messages by timestamp messages.sort(key=lambda x: x[1]) # Extract message_ids after sorting by timestamp message_ids = [message[0] for message in messages] # Apply Longest Increasing Subsequence (LIS) algorithm on message_ids dp = [1] * n for i in range(1, n): for j in range(i): if message_ids[i] > message_ids[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example Input n = 7 messages = [(1, 2), (2, 3), (3, 2), (4, 5), (5, 7), (6, 3), (7, 6)] # Example Usage output = longest_increasing_message_sequence(n, messages) print(output) # Output: 4"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotate the given N x N matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The original matrix. Returns: List[List[int]]: The rotated matrix. >>> rotate_matrix_90_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def process_input_and_rotate(test_cases): Process the input to read test cases, rotate the matrices, and generate output. Args: test_cases (List[Tuple[int, List[List[int]]]]): List of test cases in the format (N, matrix) Returns: List[List[List[int]]]: List of rotated matrices for each test case. >>> process_input_and_rotate([ ... (3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) ... ]) [[[7, 4, 1], [8, 5, 2], [9, 6, 3]]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotate the given N x N matrix 90 degrees clockwise. N = len(matrix) result = [[0] * N for _ in range(N)] for i in range(N): for j in range(N): result[j][N-1-i] = matrix[i][j] return result def process_input_and_rotate(test_cases): Process the input to read test cases, rotate the matrices, and generate output. results = [] for test in test_cases: N = test[0] matrix = test[1] rotated_matrix = rotate_matrix_90_clockwise(matrix) results.append(rotated_matrix) return results"},{"question":"def most_frequent_number(n, elements): Determines the most frequent number in the list. If there is a tie, returns the smallest number among them. :param n: Integer, the number of elements in the list :param elements: List of integers, the elements of the list :return: Integer, the most frequent number >>> most_frequent_number(7, [1, 3, 2, 3, 2, 1, 3]) 3 >>> most_frequent_number(6, [1, 2, 2, 1, 3, 3]) 1","solution":"def most_frequent_number(n, elements): Determines the most frequent number in the list. If there is a tie, returns the smallest number among them. :param n: Integer, the number of elements in the list :param elements: List of integers, the elements of the list :return: Integer, the most frequent number from collections import Counter # Count the frequencies of each number in the list frequency = Counter(elements) # Find the highest frequency max_frequency = max(frequency.values()) # Collect all numbers with the highest frequency most_frequent_numbers = [num for num, freq in frequency.items() if freq == max_frequency] # Return the smallest number among the most frequent ones return min(most_frequent_numbers)"},{"question":"def max_subarray_with_k_distinct(nums: List[int], k: int) -> int: Given an integer array nums and an integer k, return the maximum possible sum of a non-empty subarray of nums that contains at most k distinct integers. >>> max_subarray_with_k_distinct([1, 2, 1, 2, 3], 2) 6 >>> max_subarray_with_k_distinct([5, 3, 2, 1, 5], 1) 5 >>> max_subarray_with_k_distinct([1, 2, 1, 2, 1, 2, 1], 3) 10 pass def handle_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Handle multiple test cases. >>> handle_test_cases([(5, 2, [1, 2, 1, 2, 3]), (5, 1, [5, 3, 2, 1, 5]), (7, 3, [1, 2, 1, 2, 1, 2, 1])]) [6, 5, 10] >>> handle_test_cases([(5, 0, [1, 2, 1, 2, 3]), (5, 0, [5, 3, 2, 1, 5])]) [0, 0] >>> handle_test_cases([(1, 1, [100]), (1, 0, [-100])]) [100, 0] >>> handle_test_cases([(5, 1, [2, 2, 2, 2, 2]), (5, 2, [2, 2, 2, 2, 2])]) [10, 10] >>> handle_test_cases([(5, 5, [1, 2, 3, 4, 5]), (6, 6, [-1, -2, -3, -4, -5, -6])]) [15, -1] pass","solution":"def max_subarray_with_k_distinct(nums, k): from collections import defaultdict n = len(nums) if k == 0: return 0 max_sum = float('-inf') current_sum = 0 left = 0 freq = defaultdict(int) distinct_count = 0 for right in range(n): if freq[nums[right]] == 0: distinct_count += 1 freq[nums[right]] += 1 current_sum += nums[right] while distinct_count > k: freq[nums[left]] -= 1 current_sum -= nums[left] if freq[nums[left]] == 0: distinct_count -= 1 left += 1 if distinct_count <= k: max_sum = max(max_sum, current_sum) return max_sum def handle_test_cases(test_cases): results = [] for (n, k, nums) in test_cases: results.append(max_subarray_with_k_distinct(nums, k)) return results"},{"question":"def minimum_total_weight(N: int, M: int, a: List[int], weights: List[int]) -> int: Calculate the minimum total weight of stones used over the festival days in AlgoTown. >>> minimum_total_weight(5, 3, [4, 6, 5, 8, 7], [2, 3, 1]) == 30 >>> minimum_total_weight(3, 2, [1, 2, 3], [1, 2]) == 6 >>> minimum_total_weight(1, 3, [10], [5, 2, 6]) == 20 >>> minimum_total_weight(4, 1, [1, 2, 3, 4], [1]) == 10 >>> minimum_total_weight(3, 2, [10**9, 10**9, 10**9], [1, 2]) == 3 * (10**9) >>> minimum_total_weight(1, 1, [1], [1]) == 1","solution":"def minimum_total_weight(n, m, a, weights): weights.sort() total_weight = 0 for stones_required in a: for weight in weights: total_weight += stones_required * weight break # Since we've used the lightest stone for this day return total_weight"},{"question":"from typing import List, Tuple def is_bipartite(n: int, m: int, connections: List[Tuple[int,int]]) -> str: Determine if it is possible to divide the magical creatures into two groups such that each creature in one group can only have friends in the other group. Args: n (int): The number of magical creatures. m (int): The number of friendship connections. connections (List[Tuple[int,int]]): Pairs of integers indicating a friendship between creatures a and b. Returns: str: \\"YES\\" followed by the list creatures in Group 1 and Group 2, each line-separated. If not possible, returns \\"NO\\". Examples: >>> is_bipartite(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YESn1 3 5n2 4' >>> is_bipartite(4, 3, [(1, 2), (2, 3), (3, 4)]) 'YESn1 3n2 4' >>> is_bipartite(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO'","solution":"def is_bipartite(n, m, connections): from collections import deque, defaultdict def bfs(start): queue = deque([start]) color[start] = 0 # start node is colored with 0 group1.append(start) # add to group 1 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: # not colored yet color[neighbor] = 1 - color[node] # alternate color queue.append(neighbor) if color[neighbor] == 0: group1.append(neighbor) else: group2.append(neighbor) elif color[neighbor] == color[node]: return False return True graph = defaultdict(list) for a, b in connections: graph[a].append(b) graph[b].append(a) color = [-1] * (n + 1) group1 = [] group2 = [] for i in range(1, n + 1): if color[i] == -1: if not bfs(i): return \\"NO\\" group1.sort() group2.sort() return f\\"YESn{' '.join(map(str, group1))}n{' '.join(map(str, group2))}\\""},{"question":"def can_split_sequence(sequence): Determine whether a given sequence can be split into two non-empty subsequences such that each subsequence is sorted in strictly increasing or strictly decreasing order. >>> can_split_sequence([5, 1, 4, 3, 2]) 'YES' >>> can_split_sequence([4, 3, 2, 1]) 'NO' pass def analyze_sequences(test_cases): results = [] for test_case in test_cases: N, sequence = test_case result = can_split_sequence(sequence) results.append(result) return results # Test cases def test_can_split_sequence_scenario1(): assert can_split_sequence([5, 1, 4, 3, 2]) == 'YES' def test_can_split_sequence_scenario2(): assert can_split_sequence([4, 3, 2, 1]) == 'NO' def test_can_split_sequence_scenario3(): assert can_split_sequence([2, 4, 1, 5, 3, 6]) == 'YES' def test_can_split_sequence_all_increasing(): assert can_split_sequence([1, 2, 3, 4, 5]) == 'NO' def test_can_split_sequence_all_decreasing(): assert can_split_sequence([5, 4, 3, 2, 1]) == 'NO' def test_can_split_sequence_mixed(): assert can_split_sequence([5, 6, 3, 7]) == 'YES'","solution":"def can_split_sequence(sequence): n = len(sequence) inc_ord = sorted(sequence) dec_ord = sorted(sequence, reverse=True) if inc_ord != sequence and dec_ord != sequence: return \\"YES\\" else: return \\"NO\\" def analyze_sequences(test_cases): results = [] for test_case in test_cases: N, sequence = test_case result = can_split_sequence(sequence) results.append(result) return results # Input reading and function to handle multiple test cases def process_input(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 sequence = list(map(int, data[index:index + N])) index += N test_cases.append((N, sequence)) results = analyze_sequences(test_cases) for result in results: print(result)"},{"question":"def max_sum_subarray(arr): Calculates the maximum possible sum by adding together some of the integers from the array. If you add an integer, you must add all its subsequent integers. >>> max_sum_subarray([1, 2, -3, 4, -2, 1]) == 4 >>> max_sum_subarray([3, -1, 2, 6, -5, 7]) == 12 >>> max_sum_subarray([-1, -2, -3, -4]) == -1 >>> max_sum_subarray([]) == 0 >>> max_sum_subarray([5]) == 5 >>> max_sum_subarray([-5]) == -5 >>> max_sum_subarray([0, 0, 0, 0]) == 0","solution":"def max_sum_subarray(arr): Calculates the maximum possible sum by adding together some of the integers from the array. If you add an integer, you must add all its subsequent integers. n = len(arr) if n == 0: return 0 # Create a list to store the maximum sum ending at each position max_sum_end_at = [0] * n max_sum_end_at[0] = arr[0] for i in range(1, n): max_sum_end_at[i] = max(arr[i], max_sum_end_at[i-1] + arr[i]) return max(max_sum_end_at)"},{"question":"def count_palindromic_strings(strings: List[str]) -> int: Given a list of strings, determine the number of strings that are palindromes when only considering their alphanumeric characters (ignore spaces, punctuation, and case). >>> count_palindromic_strings([\\"A man, a plan, a canal, Panama!\\", \\"No lemon, no melon\\", \\"Hello, World!\\"]) 2 >>> count_palindromic_strings([\\"Hello, World!\\", \\"Python\\", \\"Programming\\"]) 0 >>> count_palindromic_strings([\\"\\", \\"\\"]) 2 >>> count_palindromic_strings([\\"Not a palindrome\\"]) 0 >>> count_palindromic_strings([\\"Able was I ere I saw Elba\\"]) 1 >>> count_palindromic_strings([\\"A man, a plan, a canal, Panama!\\", \\"No lemon, no melon\\", \\"RaceCar\\"]) 3","solution":"def count_palindromic_strings(strings): import re def is_palindrome(s): # Remove non-alphanumeric characters and convert to lowercase cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is a palindrome return cleaned == cleaned[::-1] return sum(1 for s in strings if is_palindrome(s))"},{"question":"def max_product_of_three(arr: List[int]) -> int: Returns the maximum product of any three integers in the given list. >>> max_product_of_three([1, 2, 3, 4, 5]) 60 >>> max_product_of_three([-10, -10, 5, 2]) 500 >>> max_product_of_three([-1, -2, -3, -4, -5]) -6 >>> max_product_of_three([-10, -20, 1, 3, 5]) 1000 >>> max_product_of_three([1, 2, 3]) 6 >>> max_product_of_three([-10, 0, 3, 5, 6]) 90 >>> max_product_of_three([1000, 2000, 3000, -1000, -2000]) 6000000000","solution":"def max_product_of_three(arr): Returns the maximum product of any three integers in the given list. arr.sort() return max(arr[0] * arr[1] * arr[-1], arr[-3] * arr[-2] * arr[-1])"},{"question":"def compute_books_signed(datasets): Computes the total number of books signed for each dataset. Parameters: datasets (list of tuples): Each tuple contains the number of authors and a list of the number of books each author can sign. Returns: list: Total number of books signed for each dataset. def parse_input(input_data): Parses input data to extract the datasets. Parameters: input_data (str): The input data as a single string. Returns: list: Parsed list of datasets where each dataset is a tuple. import pytest def test_compute_books_signed(): datasets = [ (5, [3, 1, 4, 1, 5]), (3, [0, 0, 7]), (4, [2, 2, 1, 0]), (1, [5]) ] expected = [14, 7, 5, 5] assert compute_books_signed(datasets) == expected def test_parse_input(): input_data = \\"5n3 1 4 1 5n3n0 0 7n4n2 2 1 0n1n5n0\\" expected = [ (5, [3, 1, 4, 1, 5]), (3, [0, 0, 7]), (4, [2, 2, 1, 0]), (1, [5]) ] assert parse_input(input_data) == expected def test_integration(): input_data = \\"5n3 1 4 1 5n3n0 0 7n4n2 2 1 0n1n5n0\\" parsed_data = parse_input(input_data) assert compute_books_signed(parsed_data) == [14, 7, 5, 5]","solution":"def compute_books_signed(datasets): Computes the total number of books signed for each dataset. Parameters: datasets (list of tuples): Each tuple contains the number of authors and a list of the number of books each author can sign. Returns: list: Total number of books signed for each dataset. results = [] for n, books in datasets: results.append(sum(books)) return results def parse_input(input_data): Parses input data to extract the datasets. Parameters: input_data (str): The input data as a single string. Returns: list: Parsed list of datasets where each dataset is a tuple. lines = input_data.strip().split('n') datasets = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break books = list(map(int, lines[i+1].split())) datasets.append((n, books)) i += 2 return datasets"},{"question":"from typing import List, Tuple def min_hospitals_needed(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of hospitals needed to cover all the villages. A hospital can cover the village it is placed in as well as its immediate neighboring villages. >>> min_hospitals_needed(1, [(5, [100, 200, 300, 400, 500])]) [2] >>> min_hospitals_needed(1, [(2, [100, 200])]) [1] pass # Implementation here def test_single_case_min_villages(): assert min_hospitals_needed(1, [(2, [100, 200])]) == [1] def test_single_case_example(): assert min_hospitals_needed(1, [(5, [100, 200, 300, 400, 500])]) == [2] def test_multiple_cases(): test_cases = [ (3, [100, 200, 300]), (4, [100, 200, 300, 400]), (6, [100, 200, 300, 400, 500, 600]), ] expected_results = [1, 2, 2] assert min_hospitals_needed(3, test_cases) == expected_results def test_minimum_coverage(): test_cases = [ (10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), (7, [5, 6, 7, 8, 9, 10, 11]), ] expected_results = [4, 3] assert min_hospitals_needed(2, test_cases) == expected_results def test_edge_case_large_N(): N = 10**5 populations = [1] * N assert min_hospitals_needed(1, [(N, populations)]) == [33334] # 100000 // 3 + 1 def test_edge_case_upper_limits(): N = 10**5 populations = [10**9] * N assert min_hospitals_needed(1, [(N, populations)]) == [33334] # 100000 // 3 + 1","solution":"def min_hospitals_needed(T, test_cases): results = [] for case in test_cases: N, populations = case if N == 2: results.append(1) continue hospitals_needed = 0 i = 0 while i < N: hospitals_needed += 1 i += 3 results.append(hospitals_needed) return results"},{"question":"def apply_operations(n: int, m: int, k: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Determine the final grid after performing a series of operations. >>> apply_operations(3, 3, 2, [(1, 1, 2, 2), (2, 2, 3, 3)]) [[1, 1, 0], [1, 2, 1], [0, 1, 1]] >>> apply_operations(3, 3, 1, [(1, 1, 3, 3)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> apply_operations(2, 2, 2, [(1, 1, 1, 1), (2, 2, 2, 2)]) [[1, 0], [0, 1]] >>> apply_operations(4, 4, 1, [(2, 2, 3, 3)]) [[0, 0, 0, 0], [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]] >>> apply_operations(1, 1, 1, [(1, 1, 1, 1)]) [[1]]","solution":"def apply_operations(n, m, k, operations): # Initialize the grid with zeroes grid = [[0] * m for _ in range(n)] # Apply each operation to the grid for op in operations: x1, y1, x2, y2 = op for i in range(x1-1, x2): for j in range(y1-1, y2): grid[i][j] += 1 return grid"},{"question":"def unique_pair_sums(n, k, arr): Given a sorted integer sequence arr of length n and a positive integer k, find all unique pairs (i, j) (0 <= i < j < n) such that the sum of arr[i] and arr[j] equals k. Parameters: n (int): Length of the sorted array. k (int): The target sum. arr (list of ints): The sorted array. Returns: int: The total number of unique pairs. Examples: >>> unique_pair_sums(5, 6, [1, 2, 3, 4, 5]) 2 >>> unique_pair_sums(4, 8, [2, 3, 4, 5]) 1 >>> unique_pair_sums(6, 10, [1, 1, 1, 9, 9, 9]) 1 pass if __name__ == \\"__main__\\": import sys data = sys.stdin.read().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:])) print(unique_pair_sums(n, k, arr))","solution":"def unique_pair_sums(n, k, arr): Given a sorted integer sequence arr of length n and a positive integer k, find all unique pairs (i, j) (0 <= i < j < n) such that the sum of arr[i] and arr[j] equals k. Parameters: n (int): Length of the sorted array. k (int): The target sum. arr (list of ints): The sorted array. Returns: int: The total number of unique pairs. left, right = 0, n - 1 count = 0 seen_pairs = set() while left < right: current_sum = arr[left] + arr[right] if current_sum == k: if (arr[left], arr[right]) not in seen_pairs: seen_pairs.add((arr[left], arr[right])) count += 1 left += 1 right -= 1 elif current_sum < k: left += 1 else: right -= 1 return count # Reading inputs and printing result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:])) print(unique_pair_sums(n, k, arr))"},{"question":"def encode_message(shift: int, message: str) -> str: Encodes a given message by shifting each letter by the specified shift value. Args: shift (int): The shift value (1 <= shift <= 25) message (str): The message to be encoded. Returns: str: The encoded message. >>> encode_message(3, \\"hello world\\") == \\"khoor zruog\\" >>> encode_message(25, \\"hello world\\") == \\"gdkkn vnqkc\\" >>> encode_message(1, \\"xyz\\") == \\"yza\\" >>> encode_message(2, \\"xyz\\") == \\"zab\\" >>> encode_message(5, \\"a b c! d?\\") == \\"f g h! i?\\" >>> encode_message(7, \\"abcdefghijklmnopqrstuvwxyz\\") == \\"hijklmnopqrstuvwxyzabcdefg\\" >>> encode_message(4, \\"hello, world!\\") == \\"lipps, asvph!\\" >>> encode_message(0, \\"no change\\") == \\"no change\\" def encoder(): import sys input = sys.stdin.read data = input().strip().split('n') for line in data: if line.strip() == \\"\\": continue shift, message = line.split(' ', 1) shift = int(shift) if shift == 0: break print(encode_message(shift, message))","solution":"def encode_message(shift, message): Encodes a given message by shifting each letter by the specified shift value. Args: shift (int): The shift value (1 <= shift <= 25) message (str): The message to be encoded. Returns: str: The encoded message. encoded_message = [] for char in message: if 'a' <= char <= 'z': new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) encoded_message.append(new_char) else: encoded_message.append(char) return ''.join(encoded_message) def encoder(): import sys input = sys.stdin.read data = input().strip().split('n') for line in data: if line.strip() == \\"\\": continue shift, message = line.split(' ', 1) shift = int(shift) if shift == 0: break print(encode_message(shift, message))"},{"question":"def max_pattern_length(tc: int, test_cases: List[Tuple[int, List[int], int, List[int]]]) -> List[int]: Aisha loves playing with ribbons. She has two types of ribbons, red and blue. Each ribbon can be represented by its length. Aisha likes to create patterns by alternating the colors of the ribbons. However, she wants to maximize the total length of the pattern she creates. Specifically, she wants to create a pattern that alternates between red and blue ribbons starting with either color and uses all the ribbons of one color first before moving to the next color, but she cannot cut any ribbon to make it shorter. Given two arrays, Red and Blue, representing the lengths of red and blue ribbons respectively, you need to help Aisha find the maximum total length of the pattern she can create. >>> max_pattern_length(2, [(3, [4, 2, 7], 4, [6, 5, 3, 8]), (2, [5, 5], 3, [2, 4, 3])]) [44, 24] >>> max_pattern_length(1, [(0, [], 0, [])]) [0] >>> max_pattern_length(1, [(3, [1, 2, 3], 0, [])]) [6] >>> max_pattern_length(1, [(2, [1000000, 1000000], 2, [1000000, 1000000])]) [4000000]","solution":"def max_pattern_length(tc, test_cases): results = [] for i in range(tc): red_lengths = test_cases[i][1] blue_lengths = test_cases[i][3] red_sum = sum(red_lengths) # Sum of all red ribbons blue_sum = sum(blue_lengths) # Sum of all blue ribbons # Possible patterns are: # 1. Use all red ribbons first and then all blue ribbons # 2. Use all blue ribbons first and then all red ribbons result = red_sum + blue_sum results.append(result) return results"},{"question":"def has_arithmetic_subsequence(arr): Determine if there are any arithmetic subsequences of length 3 in the array. An arithmetic subsequence is defined as a sequence of numbers such that the differences between consecutive elements are identical. >>> has_arithmetic_subsequence([1, 2, 3, 4, 5]) == \\"YES\\" >>> has_arithmetic_subsequence([5, 10, 15, 20]) == \\"YES\\" >>> has_arithmetic_subsequence([1, 3, 7, 10]) == \\"NO\\" pass def process_test_cases(T, test_cases): Process multiple test cases to determine if each contains an arithmetic subsequence of length 3. >>> T = 2 >>> test_cases = [(5, [1, 2, 3, 4, 5]), (4, [5, 10, 15, 20])] >>> process_test_cases(T, test_cases) [\\"YES\\", \\"YES\\"] >>> T = 2 >>> test_cases = [(4, [1, 3, 7, 10]), (3, [1, 2, 4])] >>> process_test_cases(T, test_cases) [\\"NO\\", \\"NO\\"] pass","solution":"def has_arithmetic_subsequence(arr): length = len(arr) if length < 3: return \\"NO\\" for i in range(length - 2): for j in range(i + 1, length - 1): for k in range(j + 1, length): if arr[j] - arr[i] == arr[k] - arr[j]: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] results.append(has_arithmetic_subsequence(array)) return results"},{"question":"def longest_increasing_subsequence(t: int, test_cases: list) -> list: Given the number of test cases and a list of test cases, return a list of lengths of the longest strictly increasing contiguous subsequence for each test case. >>> longest_increasing_subsequence(2, [(5, [3, 2, 5, 1, 7]), (6, [1, 2, 3, 4, 5, 6])]) [2, 6] >>> longest_increasing_subsequence(1, [(4, [4, 2, 3, 1])]) [2] >>> longest_increasing_subsequence(3, [(5, [10, 9, 2, 5, 3]), (3, [1, 1, 1]), (0, [])]) [2, 1, 0]","solution":"def longest_increasing_subsequence(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] if n == 0: results.append(0) continue max_length = 1 current_length = 1 for j in range(1, n): if sequence[j] > sequence[j - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"def max_submatrix_sum(N: int, M: int, r: int, c: int, matrix: List[List[int]]) -> int: Given an integer matrix of dimensions N x M, find the maximum sum of elements in any submatrix of size r x c. >>> max_submatrix_sum(4, 5, 2, 3, [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]) 99 >>> max_submatrix_sum(2, 2, 1, 1, [ [10, -10], [20, 30]]) 30 >>> max_submatrix_sum(3, 3, 3, 3, [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]) -9 def process_test_cases(inputs: List[str]) -> List[int]: Process the given list of input strings and return a list of maximum submatrix sums for each test case. >>> process_test_cases([ '1', '4 5 1', '2 3', '1 2 3 4 5', '6 7 8 9 10', '11 12 13 14 15', '16 17 18 19 20']) [99] >>> process_test_cases([ '2', '4 5 1', '2 3', '1 2 3 4 5', '6 7 8 9 10', '11 12 13 14 15', '16 17 18 19 20', '3 3 1', '2 2', '-1 -1 -1', '-1 -1 -1', '-1 -1 -1']) [99, -4]","solution":"def max_submatrix_sum(N, M, r, c, matrix): # Initialize the maximum sum to a very small number max_sum = float('-inf') # Iterate over all possible top-left corners of the r x c submatrix for i in range(N - r + 1): for j in range(M - c + 1): # Calculate the sum of the current r x c submatrix current_sum = sum(matrix[i + x][j + y] for x in range(r) for y in range(c)) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(inputs): results = [] index = 0 T = int(inputs[index]) index += 1 for _ in range(T): N, M, K = map(int, inputs[index].split()) index += 1 r, c = map(int, inputs[index].split()) index += 1 matrix = [] for _ in range(N): matrix.append(list(map(int, inputs[index].split()))) index += 1 results.append(max_submatrix_sum(N, M, r, c, matrix)) return results def main(): import sys input_data = sys.stdin.read().splitlines() results = process_test_cases(input_data) for result in results: print(result)"},{"question":"from typing import List, Tuple def rearrange_matrix_minimize_max_element(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[List[List[int]]]: Rearranges matrices such that the sum of each row remains the same but with the minimum possible maximum element in any row after rearrangement. >>> rearrange_matrix_minimize_max_element(1, [(3, [[4, 1, 7], [8, 2, 3], [6, 5, 9]])]) [[[1, 2, 3], [4, 5, 6], [7, 8, 9]]] >>> rearrange_matrix_minimize_max_element(2, [(2, [[4, 1], [2, 3]]), (3, [[7, 10, 1], [5, 9, 2], [4, 6, 8]])]) [[[1, 2], [3, 4]], [[1, 2, 4], [5, 6, 7], [8, 9, 10]]]","solution":"def rearrange_matrix_minimize_max_element(T, test_cases): def rearrange_minimize_max(matrix, N): sorted_elements = sorted([element for row in matrix for element in row]) rearranged = [[0] * N for _ in range(N)] idx = 0 for i in range(N): for j in range(N): rearranged[i][j] = sorted_elements[idx] idx += 1 return rearranged results = [] for t in range(T): N = test_cases[t][0] matrix = test_cases[t][1] rearranged_matrix = rearrange_minimize_max(matrix, N) results.append(rearranged_matrix) return results"},{"question":"def can_be_sorted_with_one_swap(test_cases): Determine if it is possible to sort the sequence with at most one swap operation. Args: test_cases: A list of tuples where each tuple contains an integer N and a list of N integers. Returns: A list of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_be_sorted_with_one_swap([(4, [1, 3, 5, 3]), (5, [4, 5, 2, 1, 6]), (2, [2, 1])]) ['YES', 'NO', 'YES'] >>> can_be_sorted_with_one_swap([(3, [1, 2, 3]), (5, [1, 2, 3, 4, 5])]) ['YES', 'YES'] >>> can_be_sorted_with_one_swap([(3, [3, 2, 1]), (4, [4, 3, 2, 1])]) ['YES', 'NO'] >>> can_be_sorted_with_one_swap([(4, [2, 1, 3, 4]), (5, [5, 3, 2, 4, 1])]) ['YES', 'NO'] >>> can_be_sorted_with_one_swap([(3, [1, 2, 6, 4, 5]), (2, [2, 1]), (5, [4, 5, 1, 2, 6])]) ['NO', 'YES', 'NO']","solution":"def can_be_sorted_with_one_swap(test_cases): results = [] for N, array in test_cases: sorted_array = sorted(array) diff_indices = [i for i in range(N) if array[i] != sorted_array[i]] if len(diff_indices) == 0: results.append(\\"YES\\") elif len(diff_indices) == 2: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def minimum_hours_to_transfer_skills(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Alice is organizing a cooking workshop with n participants, arranged in a circle, each numbered from 1 to n. Initially, all participants have zero cooking skills. Alice, who is also participating, has all the necessary cooking skills and is positioned at index k (1 ≤ k ≤ n) in the circle. Each participant can transfer one unit of their cooking skills to a neighboring participant (either left or right) in one hour. At any given hour, a participant can either teach a unit of cooking skill to one of their neighbors or learn a unit of cooking skill from one of their neighbors, but not both. If a participant x is teaching a skill unit to a participant y at a certain hour, then y must be learning from x at that same hour. Your task is to determine the minimum number of hours required for all participants to have all the cooking skills. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int]]): Each tuple contains two integers, n and k; the number of participants and Alice's position in the circle respectively. Returns: List[int]: A list of integers representing the minimum number of hours required for each test case. Example: >>> minimum_hours_to_transfer_skills(2, [(4, 1), (5, 3)]) [3, 2] Test cases: >>> minimum_hours_to_transfer_skills(1, [(1, 1)]) [0] >>> minimum_hours_to_transfer_skills(2, [(10, 1), (7, 1)]) [9, 6] >>> minimum_hours_to_transfer_skills(2, [(10, 10), (7, 7)]) [9, 6]","solution":"def minimum_hours_to_transfer_skills(T, test_cases): results = [] for n, k in test_cases: left_distance = k - 1 right_distance = n - k max_distance = max(left_distance, right_distance) results.append(max_distance) return results"},{"question":"from typing import List def floodFill(grid: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]: Replaces the color of the starting pixel and all adjacent pixels with the same color as the starting pixel with the new color. >>> floodFill([[1, 1, 1], [1, 1, 0], [1, 0, 1]], 1, 1, 2) [[2, 2, 2], [2, 2, 0], [2, 0, 1]] >>> floodFill([[0]], 0, 0, 2) [[2]] # Implement the flood fill algorithm here.","solution":"def floodFill(grid, sr, sc, newColor): Performs the flood fill algorithm starting from the pixel (sr, sc) and fills all connected pixels with the same original color with the new color. originalColor = grid[sr][sc] if originalColor == newColor: return grid def fill(r, c): if (0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c] == originalColor): grid[r][c] = newColor fill(r + 1, c) fill(r - 1, c) fill(r, c + 1) fill(r, c - 1) fill(sr, sc) return grid"},{"question":"def mergeArrays(arr1, arr2): Given two sorted arrays, merge them into a single sorted array. The function should maintain the sorted order of elements and not use any built-in sorting methods. >>> mergeArrays([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> mergeArrays([0, 2, 2], [1, 3, 4]) [0, 1, 2, 2, 3, 4] >>> mergeArrays([-5, 0, 3], [-3, 2, 4]) [-5, -3, 0, 2, 3, 4] >>> mergeArrays([], [1, 2, 3]) [1, 2, 3] >>> mergeArrays([1, 2, 3], []) [1, 2, 3] >>> mergeArrays([], []) [] >>> mergeArrays([5], [3]) [3, 5] >>> mergeArrays([2], [2]) [2, 2]","solution":"def mergeArrays(arr1, arr2): Given two sorted arrays, merge them into a single sorted array. merged_array = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def is_beautiful_string(n: int, distinct_letters: List[str], s: str) -> str: Determines whether the given string is beautiful based on the set of distinct letters. :param n: Integer representing the number of distinct letters in the set. :param distinct_letters: List of distinct lowercase English letters. :param s: The string to be checked for beauty. :return: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". pass # Tests def test_is_beautiful_string_positive(): assert is_beautiful_string(3, ['a', 'b', 'c'], 'abc') == \\"YES\\" assert is_beautiful_string(4, ['x', 'y', 'z', 'w'], 'zyxw') == \\"YES\\" assert is_beautiful_string(5, ['a', 'e', 'i', 'o', 'u'], 'iouae') == \\"YES\\" def test_is_beautiful_string_negative(): assert is_beautiful_string(3, ['a', 'b', 'c'], 'aabbcc') == \\"NO\\" assert is_beautiful_string(3, ['a', 'b', 'c'], 'abcd') == \\"NO\\" assert is_beautiful_string(4, ['x', 'y', 'z', 'w'], 'xyz') == \\"NO\\" assert is_beautiful_string(4, ['x', 'y', 'z', 'w'], 'xyzwx') == \\"NO\\" def test_is_beautiful_string_edge_cases(): assert is_beautiful_string(1, ['a'], 'a') == \\"YES\\" assert is_beautiful_string(1, ['a'], 'b') == \\"NO\\" assert is_beautiful_string(2, ['a', 'b'], 'ab') == \\"YES\\" assert is_beautiful_string(2, ['a', 'b'], 'aabb') == \\"NO\\" assert is_beautiful_string(2, ['a', 'b'], 'ba') == \\"YES\\"","solution":"def is_beautiful_string(n, distinct_letters, s): Determines whether the given string is beautiful based on the set of distinct letters. :param n: Integer representing the number of distinct letters in the set. :param distinct_letters: List of distinct lowercase English letters. :param s: The string to be checked for beauty. :return: \\"YES\\" if the string is beautiful, otherwise \\"NO\\". # Create a set from the list of distinct letters distinct_set = set(distinct_letters) # Check if the length of s matches the number of distinct letters if len(s) != n: return \\"NO\\" # Create a set from the string s s_set = set(s) # Check if the set of characters in s matches the distinct set and the length of string is n if s_set == distinct_set and len(s_set) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def max_rectangle_sum(matrix: List[List[int]]) -> int: Finds the maximum sum of any rectangle in the matrix. Args: matrix (List[List[int]]): A 2D list of integers. Returns: int: The maximum sum of any rectangle within the matrix. Example: >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_rectangle_sum(matrix) 29 >>> matrix = [ ... [-1, -2, -3], ... [-4, -5, -6], ... [-7, -8, -9] ... ] >>> max_rectangle_sum(matrix) -1 pass","solution":"from typing import List def max_rectangle_sum(matrix: List[List[int]]) -> int: Finds the maximum sum of any rectangle in the matrix. def kadane(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum += value if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(cols): temp = [0] * rows for right in range(left, cols): for i in range(rows): temp[i] += matrix[i][right] current_max = kadane(temp) if current_max > max_sum: max_sum = current_max return max_sum"},{"question":"def largest_garden_dimensions(w: int, h: int, x: int) -> tuple: Determines the dimensions of the largest possible rectangular garden that can fit inside a plot of width w, height h, and maintaining a margin of at least x units of space all around it. Parameters: w (int): Width of the plot. h (int): Height of the plot. x (int): Margin required around the garden. Returns: tuple: Dimensions of the largest garden (width, height) Examples: >>> largest_garden_dimensions(10, 8, 1) (8, 6) >>> largest_garden_dimensions(15, 12, 2) (11, 8) >>> largest_garden_dimensions(20, 10, 3) (14, 4) >>> largest_garden_dimensions(5, 5, 1) (3, 3)","solution":"def largest_garden_dimensions(w, h, x): Determines the dimensions of the largest possible rectangular garden that can fit inside a plot of width w, height h, and maintaining a margin of at least x units of space all around it. Parameters: w (int): Width of the plot. h (int): Height of the plot. x (int): Margin required around the garden. Returns: tuple: Dimensions of the largest garden (width, height) g_w = w - 2 * x g_h = h - 2 * x return (g_w, g_h)"},{"question":"def is_prime(N: int) -> str: Determines if the given number N is a prime number. Parameters: N (int): The number to check. Returns: str: A string stating if N is a prime or not. >>> is_prime(11) \\"11 is a prime number\\" >>> is_prime(15) \\"15 is not a prime number\\"","solution":"def is_prime(N): Determines if the given number N is a prime number. Parameters: N (int): The number to check. Returns: str: A string stating if N is a prime or not. if N <= 1: return f\\"{N} is not a prime number\\" for i in range(2, int(N**0.5) + 1): if N % i == 0: return f\\"{N} is not a prime number\\" return f\\"{N} is a prime number\\""},{"question":"from typing import List, Tuple def calculate_travel_time(distance_matrix: List[List[int]], drones_deliveries: List[List[int]]) -> List[int]: Calculate the total travel time for each drone based on its delivery schedule. >>> distance_matrix = [ ... [0, 10, 20, 30, 40], ... [10, 0, 25, 35, 45], ... [20, 25, 0, 15, 50], ... [30, 35, 15, 0, 55], ... [40, 45, 50, 55, 0] ... ] >>> drones_deliveries = [ ... [2, 3, 1], ... [4, 2], ... [1, 2, 3, 4] ... ] >>> calculate_travel_time(distance_matrix, drones_deliveries) [80, 110, 145] pass # Replace this line with your implementation def parse_input(input_str: str) -> Tuple[List[List[int]], List[List[int]]]: Parse the input string to extract the distance matrix and drone deliveries. >>> input_data = '''5 ... 0 10 20 30 40 ... 10 0 25 35 45 ... 20 25 0 15 50 ... 30 35 15 0 55 ... 40 45 50 55 0 ... 3 ... 3 2 3 1 ... 2 4 2 ... 4 1 2 3 4''' >>> parse_input(input_data) ( [ [0, 10, 20, 30, 40], [10, 0, 25, 35, 45], [20, 25, 0, 15, 50], [30, 35, 15, 0, 55], [40, 45, 50, 55, 0] ], [ [2, 3, 1], [4, 2], [1, 2, 3, 4] ] ) pass # Replace this line with your implementation def main(input_str: str) -> None: distance_matrix, drones_deliveries = parse_input(input_str) travel_times = calculate_travel_time(distance_matrix, drones_deliveries) for time in travel_times: print(time) if __name__ == \\"__main__\\": input_data = 5 0 10 20 30 40 10 0 25 35 45 20 25 0 15 50 30 35 15 0 55 40 45 50 55 0 3 3 2 3 1 2 4 2 4 1 2 3 4 main(input_data)","solution":"def calculate_travel_time(distance_matrix, drones_deliveries): travel_times = [] for deliveries in drones_deliveries: total_time = 0 # Start from base (0) prev_center = 0 for center in deliveries: total_time += distance_matrix[prev_center][center] prev_center = center # Return to base total_time += distance_matrix[prev_center][0] travel_times.append(total_time) return travel_times def parse_input(input_str): input_lines = input_str.strip().split('n') n = int(input_lines[0]) distance_matrix = [] for i in range(1, n + 1): distance_matrix.append(list(map(int, input_lines[i].split()))) d = int(input_lines[n + 1]) drones_deliveries = [] for i in range(n + 2, n + 2 + d): deliveries = list(map(int, input_lines[i].split()))[1:] # Skip the first number which is the count drones_deliveries.append(deliveries) return distance_matrix, drones_deliveries def main(input_str): distance_matrix, drones_deliveries = parse_input(input_str) travel_times = calculate_travel_time(distance_matrix, drones_deliveries) for time in travel_times: print(time) if __name__ == \\"__main__\\": input_data = 5 0 10 20 30 40 10 0 25 35 45 20 25 0 15 50 30 35 15 0 55 40 45 50 55 0 3 3 2 3 1 2 4 2 4 1 2 3 4 main(input_data)"},{"question":"def difference_matrix_sum(N): Returns the sum of all elements in the N x N difference matrix. The element at the intersection of row i and column j is calculated as |i - j|. Parameters: N (int): the dimensions of the square matrix Returns: int: the sum of all elements in the difference matrix Example: >>> difference_matrix_sum(3) 8 >>> difference_matrix_sum(4) 20 >>> difference_matrix_sum(1) 0 >>> difference_matrix_sum(2) 2 >>> difference_matrix_sum(5) 40","solution":"def difference_matrix_sum(N): Returns the sum of all elements in the N x N difference matrix. The element at the intersection of row i and column j is calculated as |i - j|. Parameters: N (int): the dimensions of the square matrix Returns: int: the sum of all elements in the difference matrix total_sum = 0 for i in range(N): for j in range(N): total_sum += abs(i - j) return total_sum"},{"question":"def longest_non_decreasing_subsequence(arr): Returns the longest non-decreasing subsequence from the input list. >>> longest_non_decreasing_subsequence([5, 3, 4, 8, 6]) [3, 4, 8] >>> longest_non_decreasing_subsequence([2, 2, 2, 2, 2, 2]) [2, 2, 2, 2, 2, 2] >>> longest_non_decreasing_subsequence([5, 4, 3, 2, 1]) [5] >>> longest_non_decreasing_subsequence([1, 2, 1, 2, 3]) [1, 2, 2, 3] >>> longest_non_decreasing_subsequence([]) [] pass def process_test_cases(test_cases): Processes multiple test cases for longest non-decreasing subsequences. For example: >>> process_test_cases([[5, 3, 4, 8, 6], [2, 2, 2, 2, 2, 2]]) [[3, 4, 8], [2, 2, 2, 2, 2, 2]] pass","solution":"def longest_non_decreasing_subsequence(arr): Returns the longest non-decreasing subsequence from the input list. if not arr: return [] n = len(arr) dp = [1] * n prev = [-1] * n # To traceback the subsequence for i in range(1, n): for j in range(i): if arr[i] >= arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j max_length = max(dp) index = dp.index(max_length) result = [] while index != -1: result.append(arr[index]) index = prev[index] result.reverse() # because we traced the subsequence backwards return result def process_test_cases(test_cases): results = [] for elements in test_cases: results.append(longest_non_decreasing_subsequence(elements)) return results"},{"question":"def prefix_strings(strings, character): Prefixes each string in the list with the given character. :param strings: list of strings to be prefixed :param character: character to prefix each string with :return: new list with prefixed strings >>> prefix_strings([\\"apple\\", \\"banana\\", \\"cherry\\"], \\"#\\") [\\"#apple\\", \\"#banana\\", \\"#cherry\\"] >>> prefix_strings([\\"dog\\", \\"cat\\"], \\"_\\") [\\"_dog\\", \\"_cat\\"] >>> prefix_strings([], \\"*\\") [] >>> prefix_strings([\\"hello\\", \\"world\\"], \\" \\") [\\" hello\\", \\" world\\"] >>> prefix_strings([\\"alpha\\", \\"beta\\"], \\"\\") [\\"alpha\\", \\"beta\\"] >>> prefix_strings([\\"a\\", \\"b\\", \\"c\\"], \\"!\\") [\\"!a\\", \\"!b\\", \\"!c\\"]","solution":"def prefix_strings(strings, character): Prefixes each string in the list with the given character. :param strings: list of strings to be prefixed :param character: character to prefix each string with :return: new list with prefixed strings return [character + s for s in strings]"},{"question":"def sort_three_numbers(n1: int, n2: int, n3: int) -> list: Write a program that takes three integers as input and outputs them in non-decreasing order. Parameters: n1 (int): First integer. n2 (int): Second integer. n3 (int): Third integer. Returns: list: A list of three integers, sorted in non-decreasing order. >>> sort_three_numbers(34, -4, 7) [-4, 7, 34] >>> sort_three_numbers(-10, -20, -30) [-30, -20, -10] pass","solution":"def sort_three_numbers(n1, n2, n3): Returns the three numbers sorted in non-decreasing order. return sorted([n1, n2, n3])"},{"question":"def minimum_turns_to_destroy_targets(t: int, positions: List[int]) -> int: Returns the minimum number of turns needed for Alice to destroy all targets. Parameters: t (int): Number of targets. positions (list of int): Positions of the targets. Returns: int: Minimum number of turns. >>> minimum_turns_to_destroy_targets(3, [3, -2, 5]) 20 >>> minimum_turns_to_destroy_targets(2, [1, -1]) 4","solution":"def minimum_turns_to_destroy_targets(t, positions): Returns the minimum number of turns needed for Alice to destroy all targets. Parameters: t (int): Number of targets. positions (list of int): Positions of the targets. Returns: int: Minimum number of turns. total_distance = sum(abs(pos) for pos in positions) return 2 * total_distance"},{"question":"def process_operations(n, operations): Simulate stack operations and output the value on the top of the stack after each operation. The stack supports the following operations: - 'push X' - where X is an integer, pushes the integer onto the stack. - 'pop' - pops the top element off the stack. - 'inc X Y' - where X is the number of elements from the bottom to increment, and Y is the increment value. For each operation, output the value on the top of the stack after the operation is performed. If the stack is empty, output \\"EMPTY\\". Args: n (int): The number of operations. operations (List[str]): List of operations to be performed. Returns: List[str or int]: The value on the top of the stack after each operation or \\"EMPTY\\" if the stack is empty. >>> process_operations(9, [\\"push 4\\", \\"push 3\\", \\"pop\\", \\"push 2\\", \\"push 5\\", \\"inc 3 1\\", \\"pop\\", \\"pop\\", \\"pop\\"]) [4, 3, 4, 2, 5, 2, 5, 1, \\"EMPTY\\"] >>> process_operations(1, [\\"pop\\"]) [\\"EMPTY\\"]","solution":"def process_operations(n, operations): stack = [] result = [] for operation in operations: if operation.startswith('push'): _, x = operation.split() stack.append(int(x)) elif operation == 'pop': if stack: stack.pop() elif operation.startswith('inc'): _, x, y = operation.split() for i in range(min(int(x), len(stack))): stack[i] += int(y) if stack: result.append(stack[-1]) else: result.append(\\"EMPTY\\") return result"},{"question":"from typing import List def rearrange_sentence(sentence: str) -> str: Returns the sentence with the words rearranged to form the shortest lexicographical order. >>> rearrange_sentence(\\"the quick brown fox jumps over the lazy dog\\") == \\"brown dog fox jumps lazy over quick the the\\" >>> rearrange_sentence(\\"a journey of a thousand miles begins with a single step\\") == \\"a a a begins journey miles of single step thousand with\\" # Unit Tests def test_single_word(): assert rearrange_sentence(\\"apple\\") == \\"apple\\" def test_all_unique_words(): assert rearrange_sentence(\\"the quick brown fox jumps over the lazy dog\\") == \\"brown dog fox jumps lazy over quick the the\\" def test_some_repeated_words(): assert rearrange_sentence(\\"a journey of a thousand miles begins with a single step\\") == \\"a a a begins journey miles of single step thousand with\\" def test_all_same_word(): assert rearrange_sentence(\\"word word word\\") == \\"word word word\\" def test_empty_string(): assert rearrange_sentence(\\"\\") == \\"\\" def test_already_sorted(): assert rearrange_sentence(\\"apple banana cherry\\") == \\"apple banana cherry\\" def test_reverse_order(): assert rearrange_sentence(\\"cherry banana apple\\") == \\"apple banana cherry\\"","solution":"def rearrange_sentence(sentence): Returns the sentence with the words rearranged to form the shortest lexicographical order. words = sentence.split() words.sort() return ' '.join(words)"},{"question":"def most_frequent_integer(n: int, arr: List[int]) -> int: Given a list of n integers, find the integer that appears most frequently. If there are multiple integers that appear with the same highest frequency, return the smallest integer among them. >>> most_frequent_integer(6, [1, 2, 2, 3, 3, 1]) == 1 >>> most_frequent_integer(5, [3, 3, 2, 2, 1]) == 2 Unit Test: def test_single_number(): assert most_frequent_integer(1, [1]) == 1 def test_two_different_numbers(): assert most_frequent_integer(2, [1, 2]) == 1 assert most_frequent_integer(2, [2, 1]) == 1 def test_simple_case(): assert most_frequent_integer(6, [1, 2, 2, 3, 3, 1]) == 1 def test_multiple_frequencies(): assert most_frequent_integer(5, [3, 3, 2, 2, 1]) == 2 def test_all_same_number(): assert most_frequent_integer(4, [4, 4, 4, 4]) == 4 def test_large_input(): assert most_frequent_integer(10, [1, 7, 7, 7, 2, 2, 2, 1, 3, 3]) == 2 def test_another_case(): assert most_frequent_integer(8, [4, 4, 4, 5, 5, 5, 5, 5]) == 5","solution":"def most_frequent_integer(n, arr): Returns the integer that appears most frequently in the list \`arr\`. If multiple integers have the same highest frequency, returns the smallest one among them. from collections import Counter count = Counter(arr) max_frequency = max(count.values()) most_frequent_numbers = [num for num, freq in count.items() if freq == max_frequency] return min(most_frequent_numbers)"},{"question":"def construct_binary_matrix(n: int, m: int) -> List[List[int]]: Construct an n x m binary matrix where each row and each column contains at most one '1'. Return the matrix as a list of lists. If impossible, return -1. >>> construct_binary_matrix(3, 4) [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]] >>> construct_binary_matrix(2, 2) [[1, 0], [0, 1]] >>> construct_binary_matrix(4, 3) -1 >>> construct_binary_matrix(1, 5) [[1, 0, 0, 0, 0]] >>> construct_binary_matrix(5, 1) -1 >>> construct_binary_matrix(1, 1) [[1]]","solution":"def construct_binary_matrix(n, m): Construct an n x m binary matrix where each row and each column contains at most one '1'. Return the matrix as a list of lists. If impossible, return -1. if n > m: return -1 matrix = [[0] * m for _ in range(n)] for i in range(n): matrix[i][i] = 1 return matrix # Example usage: # print(construct_binary_matrix(3, 4)) # Output should be: # [[1, 0, 0, 0], # [0, 1, 0, 0], # [0, 0, 1, 0]] # print(construct_binary_matrix(2, 2)) # Output should be: # [[1, 0], # [0, 1]]"},{"question":"from typing import List def search_rotated_sorted_array(nums: List[int], target: int) -> int: Returns the index of the target in the rotated sorted array, or -1 if target is not found. Args: nums (List[int]): Rotated sorted array of integers. target (int): The target integer to search for in the array. Returns: int: Index of target if found, otherwise -1. Examples: >>> search_rotated_sorted_array([4,5,6,7,0,1,2], 0) 4 >>> search_rotated_sorted_array([4,5,6,7,0,1,2], 3) -1 >>> search_rotated_sorted_array([4,5,6,7,0,1,2], 5) 1 >>> search_rotated_sorted_array([], 5) -1 pass # Your code here # Unit tests def test_empty_array(): assert search_rotated_sorted_array([], 5) == -1 def test_single_element_found(): assert search_rotated_sorted_array([1], 1) == 0 def test_single_element_not_found(): assert search_rotated_sorted_array([1], 2) == -1 def test_multiple_elements_found(): assert search_rotated_sorted_array([4,5,6,7,0,1,2], 0) == 4 assert search_rotated_sorted_array([4,5,6,7,0,1,2], 3) == -1 assert search_rotated_sorted_array([4,5,6,7,0,1,2], 5) == 1 def test_no_rotation(): assert search_rotated_sorted_array([0,1,2,4,5,6,7], 5) == 4 def test_rotation_point_search(): assert search_rotated_sorted_array([4,5,6,7,0,1,2], 4) == 0 assert search_rotated_sorted_array([4,5,6,7,0,1,2], 7) == 3 def test_target_not_present(): assert search_rotated_sorted_array([7,8,9,10], 0) == -1 def test_min_max_elements(): assert search_rotated_sorted_array([9, 10, -5, -4, -3, -2, -1], 10) == 1 assert search_rotated_sorted_array([9, 10, -5, -4, -3, -2, -1], -5) == 2 assert search_rotated_sorted_array([9, 10, -5, -4, -3, -2, -1], -1) == 6 assert search_rotated_sorted_array([9, 10, -5, -4, -3, -2, -1], 8) == -1","solution":"def search_rotated_sorted_array(nums, target): Returns the index of the target in the rotated sorted array, or -1 if target is not found. if not nums: return -1 left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid # If the left half is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # If the right half is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def find_kth_occurrence(S: str, queries: List[Tuple[str, int]]) -> List[int]: For each query, find the k-th occurrence of a character in the string S. Args: S (str): The input string consisting of lowercase English letters. queries (list of tuples): Each tuple contains a character c and an integer k. Returns: list of int: The positions (1-based index) of the k-th occurrence or -1 if not found. >>> find_kth_occurrence(\\"ababab\\", [('a', 1), ('b', 2), ('c', 1)]) [1, 4, -1] >>> find_kth_occurrence(\\"xyz\\", [('a', 1), ('x', 100)]) [-1, -1] >>> find_kth_occurrence(\\"aaaaa\\", [('a', 1), ('a', 5), ('a', 6)]) [1, 5, -1] >>> find_kth_occurrence(\\"a\\" * 10**6, [('a', 10**6), ('a', 10**6 + 1)]) [10**6, -1] >>> find_kth_occurrence(\\"abcdefghijklmnopqrstuvwxyz\\" * 10**4, [('z', 10000), ('a', 10001)]) [260000, -1]","solution":"def find_kth_occurrence(S, queries): For each query, find the k-th occurrence of a character in the string S. Args: S (str): The input string consisting of lowercase English letters. queries (list of tuples): Each tuple contains a character c and an integer k. Returns: list of int: The positions (1-based index) of the k-th occurrence or -1 if not found. from collections import defaultdict # Create a dictionary to store the positions of each character positions = defaultdict(list) for index, char in enumerate(S): positions[char].append(index + 1) results = [] for c, k in queries: if c in positions and len(positions[c]) >= k: results.append(positions[c][k - 1]) else: results.append(-1) return results"},{"question":"def max_value_book(books: list) -> str: Determine which book has the highest value in stock (quantity * price). If the list is empty, return an empty string. If there are multiple books with the same highest value, return the title of the first one that appears in the list. Args: books (list): A list of dictionaries where each dictionary represents a book with keys 'isbn', 'title', 'quantity', and 'price'. Returns: str: The title of the book with the highest value in stock. Examples: >>> books = [ ... {'isbn': '123-456-789', 'title': 'Book One', 'quantity': 4, 'price': 19.99}, ... {'isbn': '987-654-321', 'title': 'Book Two', 'quantity': 6, 'price': 25.50}, ... {'isbn': '111-222-333', 'title': 'Book Three', 'quantity': 5, 'price': 22.00} ... ] >>> max_value_book(books) 'Book Two' >>> books = [] >>> max_value_book(books) '' >>> books = [ ... {'isbn': '123-456-789', 'title': 'Book One', 'quantity': 4, 'price': 20.00}, ... {'isbn': '987-654-321', 'title': 'Book Two', 'quantity': 4, 'price': 20.00} ... ] >>> max_value_book(books) 'Book One'","solution":"def max_value_book(books: list) -> str: max_value = 0 title_of_max_value_book = \\"\\" for book in books: current_value = book['quantity'] * book['price'] if current_value > max_value: max_value = current_value title_of_max_value_book = book['title'] return title_of_max_value_book"},{"question":"def count_unique_prime_factors_of_factorial(N: int) -> int: Given an integer N, returns the count of unique prime factors of N!. >>> count_unique_prime_factors_of_factorial(10) 4 >>> count_unique_prime_factors_of_factorial(15) 6","solution":"def count_unique_prime_factors_of_factorial(N): Returns the count of unique prime factors of N! def sieve_of_eratosthenes(max_num): Generates a list of primes up to max_num using the Sieve of Eratosthenes algorithm. is_prime = [True] * (max_num + 1) p = 2 while (p * p <= max_num): if (is_prime[p] == True): for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 prime_list = [] for p in range(2, max_num + 1): if is_prime[p]: prime_list.append(p) return prime_list # Generate all primes up to N using the sieve of Eratosthenes primes = sieve_of_eratosthenes(N) return len(primes)"},{"question":"def findMedianSortedArrays(nums1, nums2): Find the median of two sorted arrays. The overall run time complexity should be O(log (m+n)). >>> findMedianSortedArrays([1, 3], [2]) 2.0 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5 >>> findMedianSortedArrays([0, 0], [0, 0]) 0.0 >>> findMedianSortedArrays([], [1]) 1.0 >>> findMedianSortedArrays([2], []) 2.0 def spiralOrder(matrix): Return all elements of the matrix in spiral order. >>> spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] >>> spiralOrder([[1]]) [1] >>> spiralOrder([[1, 2], [3, 4]]) [1, 2, 4, 3] >>> spiralOrder([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]) [1, 2, 3, 6, 9, 12, 11, 10, 7, 4, 5, 8]","solution":"def findMedianSortedArrays(nums1, nums2): Find the median of two sorted arrays. Time complexity: O(log (m+n)) def findKthSmallest(A, B, k): lenA, lenB = len(A), len(B) if lenA > lenB: return findKthSmallest(B, A, k) if lenA == 0: return B[k-1] if k == 1: return min(A[0], B[0]) i = min(lenA, k // 2) j = min(lenB, k // 2) if A[i-1] > B[j-1]: return findKthSmallest(A, B[j:], k-j) else: return findKthSmallest(A[i:], B, k-i) totalLen = len(nums1) + len(nums2) if totalLen % 2 == 1: return findKthSmallest(nums1, nums2, totalLen // 2 + 1) else: return (findKthSmallest(nums1, nums2, totalLen // 2) + findKthSmallest(nums1, nums2, totalLen // 2 + 1)) / 2.0 def spiralOrder(matrix): Return all elements of the matrix in spiral order. res = [] while matrix: res += matrix.pop(0) if matrix and matrix[0]: for row in matrix: res.append(row.pop()) if matrix: res += matrix.pop()[::-1] if matrix and matrix[0]: for row in matrix[::-1]: res.append(row.pop(0)) return res"},{"question":"from typing import List def min_moves(N: int, M: int, forest: List[str], S_row: int, S_col: int, D_row: int, D_col: int) -> int: Determine the minimum number of moves the bird needs to make to reach its destination. If multiple possible paths exist, find the one that requires the fewest moves. If it is not possible for the bird to reach the destination, return -1. Inputs: - N: an integer representing the number of rows in the forest grid. - M: an integer representing the number of columns in the forest grid. - forest: a list of strings where each string is of length M representing a row in the forest grid. - S_row: an integer representing the starting cell row coordinate of the bird (0-indexed). - S_col: an integer representing the starting cell column coordinate of the bird (0-indexed). - D_row: an integer representing the destination cell row coordinate (0-indexed). - D_col: an integer representing the destination cell column coordinate (0-indexed). Returns: - An integer representing the minimum number of moves required for the bird to reach the destination. If the destination cannot be reached, return -1. Examples: >>> min_moves(5, 5, [\\"..#..\\", \\".#.#.\\", \\".#.#.\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_moves(5, 5, [\\"..#..\\", \\".#.#.\\", \\"#\\", \\".#...\\", \\".....\\"], 0, 0, 4, 4) -1","solution":"from collections import deque def min_moves(N, M, forest, S_row, S_col, D_row, D_col): # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with the start position and moves count 0 queue = deque([(S_row, S_col, 0)]) # Initialize the visited set with the start position visited = set((S_row, S_col)) while queue: row, col, moves = queue.popleft() # If we've reached the destination, return the moves count if row == D_row and col == D_col: return moves # Check all possible directions for dr, dc in directions: newRow, newCol = row + dr, col + dc # Check if the new position is within bounds and not visited or an obstacle if 0 <= newRow < N and 0 <= newCol < M and (newRow, newCol) not in visited and forest[newRow][newCol] == '.': queue.append((newRow, newCol, moves + 1)) visited.add((newRow, newCol)) # If we've exhausted all possibilities and haven't reached the destination, return -1 return -1"},{"question":"def min_exhaustion(stamina: List[int]) -> int: Determines the optimal order of passing the baton to minimize exhaustion. (Each participant has a stamina rating, and the team must decide the optimal order of passing the baton to minimize exhaustion.) >>> min_exhaustion([10, 20, 10, 15]) 20 >>> min_exhaustion([5, 5, 5, 5, 5]) 0","solution":"def min_exhaustion(stamina): Determines the optimal order of passing the baton to minimize exhaustion. stamina.sort() min_exhaust = float('inf') # Try every possible starting point for i in range(len(stamina)): cur_exhaust = 0 for j in range(len(stamina)): cur_exhaust += abs(stamina[j] - stamina[(j + 1) % len(stamina)]) min_exhaust = min(min_exhaust, cur_exhaust) stamina.insert(0, stamina.pop()) # rotate list for next permutation return min_exhaust"},{"question":"def find_concatenation_pair(words, target): Given a list of words, determine whether you can form a given target string by concatenating exactly two distinct words from the list. Args: words (list): List of distinct words. target (str): Target string to form. Returns: str: Two words that form the target string or \\"No pair found\\". Examples: >>> find_concatenation_pair([\\"apple\\", \\"banana\\", \\"carrot\\", \\"dog\\", \\"elephant\\"], \\"carrotdog\\") \\"carrot dog\\" >>> find_concatenation_pair([\\"note\\", \\"book\\", \\"pen\\", \\"paper\\"], \\"notebook\\") \\"note book\\" >>> find_concatenation_pair([\\"red\\", \\"blue\\", \\"green\\"], \\"yellow\\") \\"No pair found\\" Your code here # Unit Test: from solution import find_concatenation_pair def test_sample_input_1(): words = [\\"apple\\", \\"banana\\", \\"carrot\\", \\"dog\\", \\"elephant\\"] target = \\"carrotdog\\" assert find_concatenation_pair(words, target) == \\"carrot dog\\" def test_sample_input_2(): words = [\\"note\\", \\"book\\", \\"pen\\", \\"paper\\"] target = \\"notebook\\" result = find_concatenation_pair(words, target) assert result == \\"note book\\" def test_sample_input_3(): words = [\\"red\\", \\"blue\\", \\"green\\"] target = \\"yellow\\" assert find_concatenation_pair(words, target) == \\"No pair found\\" def test_no_pair_exists(): words = [\\"a\\", \\"b\\", \\"c\\"] target = \\"abc\\" assert find_concatenation_pair(words, target) == \\"No pair found\\" def test_pair_is_at_end(): words = [\\"hello\\", \\"world\\", \\"helloworld\\"] target = \\"worldhello\\" assert find_concatenation_pair(words, target) == \\"world hello\\" def test_target_as_concatenation_of_same_word(): words = [\\"go\\", \\"dog\\", \\"god\\"] target = \\"godog\\" assert find_concatenation_pair(words, target) == \\"go dog\\" def test_two_possible_pairs(): words = [\\"ab\\", \\"cd\\", \\"abc\\", \\"d\\"] target = \\"abcd\\" result = find_concatenation_pair(words, target) assert result in [\\"ab cd\\", \\"abc d\\"] def test_reversed_words(): words = [\\"cat\\", \\"tac\\"] target = \\"taccat\\" result = find_concatenation_pair(words, target) assert result == \\"tac cat\\"","solution":"def find_concatenation_pair(words, target): Given a list of words, determine whether you can form a given target string by concatenating exactly two distinct words from the list. Args: words (list): List of distinct words. target (str): Target string to form. Returns: str: Two words that form the target string or \\"No pair found\\". word_set = set(words) for word in words: if target.startswith(word): suffix = target[len(word):] if suffix in word_set and suffix != word: return f\\"{word} {suffix}\\" return \\"No pair found\\""},{"question":"from typing import List, Dict, Any def process_transactions(transactions: List[Dict[str, Any]]) -> Dict[str, int]: Process a list of transactions and return the final balance for each user. >>> transactions = [ ... {\\"user\\": \\"alice\\", \\"amount\\": 50}, ... {\\"user\\": \\"bob\\", \\"amount\\": 100}, ... {\\"user\\": \\"alice\\", \\"amount\\": -20}, ... {\\"user\\": \\"alice\\", \\"amount\\": 30}, ... {\\"user\\": \\"bob\\", \\"amount\\": -50} ... ] >>> process_transactions(transactions) {\\"alice\\": 60, \\"bob\\": 50}","solution":"from typing import List, Dict, Any def process_transactions(transactions: List[Dict[str, Any]]) -> Dict[str, int]: balances = {} for transaction in transactions: user = transaction['user'] amount = transaction['amount'] if user not in balances: balances[user] = 0 balances[user] += amount return balances"},{"question":"def longest_subarray_with_and_gte_k(arr, k): Determine the length of the longest contiguous subarray such that the bitwise AND of all its elements is greater than or equal to \`k\`. >>> longest_subarray_with_and_gte_k([4, 3, 2, 6, 7], 3) 2 >>> longest_subarray_with_and_gte_k([4, 3, 2, 6, 7], 8) 0","solution":"def longest_subarray_with_and_gte_k(arr, k): n = len(arr) max_len = 0 start = 0 current_and = None for end in range(n): if current_and is None: current_and = arr[end] else: current_and &= arr[end] while start <= end and current_and < k: start += 1 current_and = None if start > end else arr[start] for i in range(start + 1, end + 1): current_and &= arr[i] if current_and is not None and current_and >= k: max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List, Tuple def can_borrow_books(n: int, p: int, pages: List[int]) -> str: Determines if it's possible to borrow exactly k books such that their total pages equal to p. Parameters: n (int): The number of books available. p (int): The exact total number of pages required. pages (list): The list of integers where each number is the number of pages in corresponding book. Returns: str: \\"YES\\" if it's possible to achieve exactly p pages with k books, \\"NO\\" otherwise. >>> can_borrow_books(5, 8, [2, 3, 5, 2, 1]) \\"YES\\" >>> can_borrow_books(4, 10, [2, 2, 2, 2]) \\"NO\\" def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases generating the output for each. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains n, p, and pages. Returns: list: A list of results for each test case (\\"YES\\" or \\"NO\\"). >>> process_test_cases(2, [(5, 8, [2, 3, 5, 2, 1]), (4, 10, [2, 2, 2, 2])]) [\\"YES\\", \\"NO\\"]","solution":"from itertools import combinations def can_borrow_books(n, p, pages): Determines if it's possible to borrow exactly k books such that their total pages equal to p. Parameters: n (int): The number of books available. p (int): The exact total number of pages required. pages (list): The list of integers where each number is the number of pages in corresponding book. Returns: str: \\"YES\\" if it's possible to achieve exactly p pages with k books, \\"NO\\" otherwise. for k in range(1, n+1): for combination in combinations(pages, k): if sum(combination) == p: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): Processes multiple test cases generating the output for each. Parameters: t (int): The number of test cases. test_cases (list): A list of tuples, where each tuple contains n, p, and pages. Returns: list: A list of results for each test case (\\"YES\\" or \\"NO\\"). results = [] for case in test_cases: n, p, pages = case results.append(can_borrow_books(n, p, pages)) return results"},{"question":"def snake_pattern(n, arr): Transforms the given array into a snake pattern. :param n: int - the length of the array :param arr: List[int] - the array of integers :return: List[int] - the rearranged array in snake pattern >>> snake_pattern(5, [3, 1, 2, 5, 4]) [1, 3, 2, 5, 4] >>> snake_pattern(5, [7, 1, 5, 0, 3]) [1, 7, 0, 5, 3]","solution":"def snake_pattern(n, arr): This function transforms the given array into a snake pattern: - arr[i] <= arr[i + 1], if i is even - arr[i] >= arr[i + 1], if i is odd for i in range(n - 1): if i % 2 == 0: if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] else: if arr[i] < arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] return arr # Example usage: # n = 5 # arr = [3, 1, 2, 5, 4] # print(snake_pattern(n, arr)) # Output: [1, 3, 2, 5, 4]"},{"question":"def smallest_integer_with_sum_of_digits(n: int) -> int: Find the smallest non-negative integer M such that the sum of the digits of M equals N. >>> smallest_integer_with_sum_of_digits(15) 69 >>> smallest_integer_with_sum_of_digits(5) 5 >>> smallest_integer_with_sum_of_digits(0) 0 >>> smallest_integer_with_sum_of_digits(18) 99 >>> smallest_integer_with_sum_of_digits(1) 1 >>> smallest_integer_with_sum_of_digits(9) 9 >>> smallest_integer_with_sum_of_digits(27) 999","solution":"def smallest_integer_with_sum_of_digits(n): Find the smallest non-negative integer M such that the sum of the digits of M equals N. # We'll use a greedy approach to minimize the M. # Start from the least significant digit and work towards the most significant digit, # trying to form the smallest number possible. if n == 0: return 0 # Special case for 0 result = [] while n > 0: digit = min(n, 9) # The highest digit we can consume without exceeding n is 9 result.append(digit) n -= digit # Reverse the digits to to get the smallest integer result.reverse() return int(''.join(map(str, result)))"},{"question":"def maxMovies(movies: List[int], limit: int) -> int: Finds the maximum length of consecutive movies whose total duration does not exceed the limit. Parameters: movies (list of int): List of movie durations. limit (int): Maximum allowable duration. Returns: int: The maximum length of consecutive movies under the specified limit. >>> maxMovies([100, 200, 150, 300, 50, 100], 400) 2 >>> maxMovies([100, 200, 150, 300, 50, 100], 450) 3 >>> maxMovies([100, 100, 100, 100, 100], 300) 3 >>> maxMovies([1000, 2000, 1500, 3000, 500, 100], 1000) 2 >>> maxMovies([100, 200, 300, 400, 500], 150) 1 >>> maxMovies([60, 60, 60, 60, 60], 300) 5 >>> maxMovies([100, 200, 300], 50) 0 >>> maxMovies([10, 20, 30, 40, 50], 100) 4","solution":"def maxMovies(movies, limit): Finds the maximum length of consecutive movies whose total duration does not exceed the limit. Parameters: movies (list of int): List of movie durations. limit (int): Maximum allowable duration. Returns: int: The maximum length of consecutive movies under the specified limit. n = len(movies) max_length = 0 current_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += movies[end] current_length += 1 while current_sum > limit: current_sum -= movies[start] current_length -= 1 start += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def create_street_grid(n: int, m: int, horizontal_names: List[str], vertical_names: List[str]) -> List[List[str]]: Constructs the grid of street names based on the given horizontal and vertical names. Args: n: int - the number of horizontal streets m: int - the number of vertical streets horizontal_names: list - list of horizontal street names vertical_names: list - list of vertical street names Returns: list of list containing the grid of street names # Implement the function here # Test cases def test_create_street_grid(): n = 3 m = 3 horizontal_names = [\\"elm\\", \\"oak\\", \\"pine\\"] vertical_names = [\\"first\\", \\"second\\", \\"third\\"] expected_output = [ [\\"elm_first\\", \\"elm_second\\", \\"elm_third\\"], [\\"oak_first\\", \\"oak_second\\", \\"oak_third\\"], [\\"pine_first\\", \\"pine_second\\", \\"pine_third\\"] ] assert create_street_grid(n, m, horizontal_names, vertical_names) == expected_output def test_create_street_grid_different_size(): n = 2 m = 4 horizontal_names = [\\"main\\", \\"high\\"] vertical_names = [\\"north\\", \\"south\\", \\"east\\", \\"west\\"] expected_output = [ [\\"main_north\\", \\"main_south\\", \\"main_east\\", \\"main_west\\"], [\\"high_north\\", \\"high_south\\", \\"high_east\\", \\"high_west\\"] ] assert create_street_grid(n, m, horizontal_names, vertical_names) == expected_output def test_create_street_grid_min_size(): n = 2 m = 2 horizontal_names = [\\"a\\", \\"b\\"] vertical_names = [\\"1\\", \\"2\\"] expected_output = [ [\\"a_1\\", \\"a_2\\"], [\\"b_1\\", \\"b_2\\"] ] assert create_street_grid(n, m, horizontal_names, vertical_names) == expected_output def test_create_street_grid_max_size(): n = 50 m = 50 horizontal_names = [f\\"h{i}\\" for i in range(1, 51)] vertical_names = [f\\"v{i}\\" for i in range(1, 51)] expected_output = [[f\\"h{i}_v{j}\\" for j in range(1, 51)] for i in range(1, 51)] assert create_street_grid(n, m, horizontal_names, vertical_names) == expected_output","solution":"def create_street_grid(n, m, horizontal_names, vertical_names): Constructs the grid of street names based on the given horizontal and vertical names. Args: n: int - the number of horizontal streets m: int - the number of vertical streets horizontal_names: list - list of horizontal street names vertical_names: list - list of vertical street names Returns: list of list containing the grid of street names grid = [] for h_name in horizontal_names: row = [] for v_name in vertical_names: row.append(f\\"{h_name}_{v_name}\\") grid.append(row) return grid"},{"question":"def next_palindrome(n: int) -> int: Returns the smallest palindrome larger than n. >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 >>> next_palindrome(808) 818 >>> next_palindrome(99999999) 100000001","solution":"def next_palindrome(n): Returns the smallest palindrome larger than n. n += 1 while True: if str(n) == str(n)[::-1]: return n n += 1"},{"question":"def fibonacci_variations(a: int, b: int, n: int) -> int: Returns the number of distinct variations of the Fibonacci-like sequence where exactly one number is skipped at the nth position. >>> fibonacci_variations(2, 3, 5) 2 >>> fibonacci_variations(1, 1, 3) 2","solution":"def fibonacci_variations(a, b, n): Returns the number of distinct variations of the Fibonacci-like sequence where exactly one number is skipped at the nth position. if n == 1 or n == 2: return 0 # If we skip the first or second element, it would not be counted. # Generate the Fibonacci-like sequence up to the nth position fib_sequence = [a, b] for i in range(2, n): fib_sequence.append(fib_sequence[i-1] + fib_sequence[i-2]) # If we skip the nth element, we have to consider: # 1. Skipping the element at n-1 # 2. Skipping the element at n-2 # if we skip two consecutive elements, the next element will be the sum of the last two in the sequence. variations = 2 # Skipping the (n-2)th or (n-1)th element results in different sequences return variations"},{"question":"def next_bigger(n: int) -> int: Find the next bigger number that can be formed by rearranging the digits. If no such number exists, return -1. >>> next_bigger(12) == 21 >>> next_bigger(513) == 531 >>> next_bigger(2017) == 2071 >>> next_bigger(111) == -1 >>> next_bigger(531) == -1","solution":"def next_bigger(n: int) -> int: digits = list(str(n)) length = len(digits) # Step 1: Find the rightmost digit which is smaller than its next digit for i in range(length - 2, -1, -1): if digits[i] < digits[i + 1]: break else: return -1 # No such digit found means digits are in descending order # Step 2: Find the smallest digit on the right side of the found digit which is larger than the found digit smallest_larger_index = i + 1 for j in range(i + 1, length): if digits[i] < digits[j] <= digits[smallest_larger_index]: smallest_larger_index = j # Step 3: Swap the found digit with the smaller larger digit found digits[i], digits[smallest_larger_index] = digits[smallest_larger_index], digits[i] # Step 4: Sort the digits to the right of the swapped position digits = digits[:i + 1] + sorted(digits[i + 1:]) return int(\\"\\".join(digits))"},{"question":"def alice_can_reach(n, k, grid): Alice wants to navigate from the top-left cell (1, 1) to the bottom-right cell (n, n) in a given n x n grid, using right and down moves and a limited number of teleportation gadgets. Parameters: n (int): size of the grid. k (int): number of teleportation gadgets available. grid (List[str]): n lines each containing n characters ('0' for traversable and '1' for blocked). Returns: str: \\"YES <min_teleportation_gadgets>\\" if Alice can reach the bottom-right cell, otherwise \\"NO\\". >>> alice_can_reach(5, 1, [\\"00000\\", \\"01110\\", \\"00000\\", \\"01110\\", \\"00000\\"]) \\"YES 1\\" >>> alice_can_reach(4, 0, [\\"0100\\", \\"0110\\", \\"0000\\", \\"0111\\"]) \\"NO\\" def test_alice_can_reach_possible(): grid = [ \\"00000\\", \\"01110\\", \\"00000\\", \\"01110\\", \\"00000\\" ] assert alice_can_reach(5, 1, grid) == \\"YES 1\\" def test_alice_can_reach_impossible(): grid = [ \\"0100\\", \\"0110\\", \\"0000\\", \\"0111\\", ] assert alice_can_reach(4, 0, grid) == \\"NO\\" def test_alice_can_reach_large_grid_without_gadgets(): grid = [ \\"0000\\", \\"0000\\", \\"0000\\", \\"0000\\", ] assert alice_can_reach(4, 0, grid) == \\"YES 0\\" def test_alice_cannot_start(): grid = [ \\"1000\\", \\"0000\\", \\"0000\\", \\"0000\\", ] assert alice_can_reach(4, 1, grid) == \\"NO\\" def test_alice_cannot_end(): grid = [ \\"0000\\", \\"0000\\", \\"0000\\", \\"0001\\", ] assert alice_can_reach(4, 1, grid) == \\"NO\\"","solution":"from collections import deque def min_teleportation_gadgets(n, k, grid): def neighbors(x, y): for nx, ny in ((x+1, y), (x, y+1), (x-1, y), (x, y-1)): if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '0': yield nx, ny start = (0, 0) end = (n-1, n-1) if grid[0][0] == '1' or grid[n-1][n-1] == '1': return \\"NO\\" # BFS (Breadth-First Search) for shortest path queue = deque([(start, 0, 0)]) # (current position, teleportations used, gadgets count) visited = [[float('inf')] * n for _ in range(n)] visited[0][0] = 0 while queue: (x, y), teleports, gadgets = queue.popleft() if (x, y) == end: return f\\"YES {teleports}\\" # Check normal moves for nx, ny in neighbors(x, y): if teleports < visited[nx][ny]: visited[nx][ny] = teleports queue.append(((nx, ny), teleports, gadgets)) # Use available teleportation gadgets if gadgets < k: for i in range(n): for j in range(n): if grid[i][j] == '0' and visited[i][j] > teleports + 1: queue.append(((i, j), teleports + 1, gadgets + 1)) visited[i][j] = teleports + 1 return \\"NO\\" def alice_can_reach(n, k, grid): return min_teleportation_gadgets(n, k, grid)"},{"question":"def minimum_moves_to_reach_end(N: int, H: List[int]) -> int: Determine the minimum number of moves required for the hiker to reach the final checkpoint from the first checkpoint or return -1 if it's not possible. Args: N (int): Number of checkpoints H (List[int]): Elevation of each checkpoint Returns: int: Minimum number of moves or -1 if reaching the last checkpoint is not possible. Examples: >>> minimum_moves_to_reach_end(5, [1, 3, 2, 4, 5]) 3 >>> minimum_moves_to_reach_end(4, [5, 4, 3, 2]) -1 >>> minimum_moves_to_reach_end(6, [1, 1, 1, 1, 1, 1]) 5 pass from typing import List def test_example_1(): N = 5 H = [1, 3, 2, 4, 5] assert minimum_moves_to_reach_end(N, H) == 3 def test_example_2(): N = 4 H = [5, 4, 3, 2] assert minimum_moves_to_reach_end(N, H) == -1 def test_example_3(): N = 6 H = [1, 1, 1, 1, 1, 1] assert minimum_moves_to_reach_end(N, H) == 5 def test_single_checkpoint(): N = 1 H = [1] assert minimum_moves_to_reach_end(N, H) == 0 def test_all_downhill(): N = 3 H = [3, 2, 1] assert minimum_moves_to_reach_end(N, H) == -1 def test_all_uphill(): N = 4 H = [1, 2, 3, 4] assert minimum_moves_to_reach_end(N, H) == 3 def test_mixed_elevation(): N = 7 H = [2, 1, 4, 3, 5, 6, 7] assert minimum_moves_to_reach_end(N, H) == 4","solution":"def minimum_moves_to_reach_end(N, H): moves = 0 current_position = 0 while current_position < N - 1: if H[current_position + 1] >= H[current_position]: current_position += 1 moves += 1 else: found = False for i in range(current_position + 2, N): if H[i] >= H[current_position]: current_position = i moves += 1 found = True break if not found: return -1 return moves"},{"question":"def smallest_on_diagonal(matrix): Returns the smallest number in the main diagonal of the given square matrix. The main diagonal runs from the top-left to the bottom-right. >>> smallest_on_diagonal([ >>> [1, 2, 3], >>> [4, 5, 6], >>> [7, 8, 9] >>> ]) == 1 >>> smallest_on_diagonal([ >>> [10, 20, 30, 40], >>> [50, 60, 70, 80], >>> [90, 21, 22, 23], >>> [24, 25, 26, 27] >>> ]) == 10","solution":"def smallest_on_diagonal(matrix): Returns the smallest number in the main diagonal of the given square matrix. The main diagonal runs from the top-left to the bottom-right. n = len(matrix) main_diagonal_elements = [matrix[i][i] for i in range(n)] return min(main_diagonal_elements)"},{"question":"def count_bouquets(N: int, K: int) -> int: Returns the number of distinct bouquets with K flowers where no two adjacent flowers are of the same type. >>> count_bouquets(3, 3) == 6 >>> count_bouquets(1, 1) == 1 >>> count_bouquets(5, 2) == 20 >>> count_bouquets(3, 0) == 0 >>> count_bouquets(0, 1) == 0 >>> count_bouquets(1000, 100) > 0 >>> count_bouquets(100, 100) > 0 >>> count_bouquets(3, 5) == 0 # Implement your solution here","solution":"MOD = 10**9 + 7 def count_bouquets(N, K): Returns the number of distinct bouquets with K flowers where no two adjacent flowers are of the same type. if K > N or N == 0 or K == 0: return 0 # Dynamic programming table where dp[k] is the number of valid bouquets of length k dp = [0] * (K + 1) dp[0] = 1 # Base case: There is 1 way to arrange 0 flowers for i in range(1, K + 1): dp[i] = (dp[i - 1] * (N - (i - 1))) % MOD return dp[K] # Example of using the function: # result = count_bouquets(3, 3) # print(result) # Output should be 6"},{"question":"def can_alice_win(m: int, n: int, grid: List[List[int]]) -> str: Determine if Alice can always win the game given the grid of integers. Parameters: m (int): Number of rows in the grid n (int): Number of columns in the grid grid (List[List[int]]): The grid represented as list of lists of integers Returns: str: \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\" Example: >>> can_alice_win(2, 2, [[1, 2], [3, 4]]) 'Alice' >>> can_alice_win(3, 3, [[1, 0, 3], [0, 2, 0], [0, 0, 4]]) 'Alice' def solve(t: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Solve the problem for multiple test cases. Parameters: t (int): Number of test cases test_cases (List[Tuple[int, int, List[List[int]]]]): List of test cases where each test case contains m, n, and the grid Returns: List[str]: List of results for each test case, \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\" Example: >>> solve(2, [(2, 2, [[1, 2], [3, 4]]), (3, 3, [[1, 0, 3], [0, 2, 0], [0, 0, 4]])]) ['Alice', 'Alice']","solution":"def can_alice_win(m, n, grid): Returns whether Alice can guarantee a win given the grid. Alice wins if her score is strictly greater than Bob's when both play optimally. # Collect all positive integers from the grid values = [] for row in grid: for value in row: if value > 0: values.append(value) # Sort in descending order to always take the maximum first values.sort(reverse=True) # Scores of Alice and Bob alice_score = 0 bob_score = 0 # Distribute turns for i in range(len(values)): if i % 2 == 0: alice_score += values[i] else: bob_score += values[i] return \\"Alice\\" if alice_score > bob_score else \\"Bob\\" def solve(t, test_cases): results = [] for i in range(t): m, n, grid = test_cases[i] result = can_alice_win(m, n, grid) results.append(result) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_index = {} max_length = start = 0 for index, char in enumerate(s): if char in char_index and char_index[char] >= start: start = char_index[char] + 1 char_index[char] = index max_length = max(max_length, index - start + 1) return max_length"},{"question":"def minimum_operations_to_permutation(N: int, sequence: List[int]) -> int: Returns the minimum number of operations required to transform the given sequence into a permutation of integers from 1 to N. Args: N (int): The length of the sequence. sequence (List[int]): The sequence of integers. Returns: int: The minimum number of operations required. Examples: >>> minimum_operations_to_permutation(5, [4, 2, 2, 1, 5]) 1 >>> minimum_operations_to_permutation(4, [4, 3, 2, 1]) 0 pass from solution import minimum_operations_to_permutation def test_example1(): N = 5 sequence = [4, 2, 2, 1, 5] assert minimum_operations_to_permutation(N, sequence) == 1 def test_example2(): N = 4 sequence = [4, 3, 2, 1] assert minimum_operations_to_permutation(N, sequence) == 0 def test_all_same_elements(): N = 5 sequence = [5, 5, 5, 5, 5] assert minimum_operations_to_permutation(N, sequence) == 4 def test_missing_elements(): N = 6 sequence = [6, 6, 6, 6, 1, 1] assert minimum_operations_to_permutation(N, sequence) == 4 def test_large_input(): N = 100000 sequence = list(range(1, 100001)) assert minimum_operations_to_permutation(N, sequence) == 0 def test_almost_complete(): N = 7 sequence = [1, 2, 3, 4, 5, 6, 7] assert minimum_operations_to_permutation(N, sequence) == 0 def test_duplicates_present(): N = 5 sequence = [2, 2, 2, 3, 3] assert minimum_operations_to_permutation(N, sequence) == 3","solution":"def minimum_operations_to_permutation(N, sequence): Returns the minimum number of operations required to transform the given sequence into a permutation of integers from 1 to N. needed = set(range(1, N+1)) # The set of numbers that should be in the sequence current = set(sequence) # The set of numbers currently in the sequence missing = needed - current # The set of numbers that are missing in the sequence # The number of missing numbers is the number of changes we need to make return len(missing)"},{"question":"from typing import List def generate_fruit_pattern(rows: int, cols: int) -> List[str]: Generate a fruit pattern grid with the given rows and columns. The pattern alternates between 'A' (apple) and 'B' (banana). >>> generate_fruit_pattern(3, 4) ['ABAB', 'BABA', 'ABAB'] >>> generate_fruit_pattern(5, 5) ['ABABA', 'BABAB', 'ABABA', 'BABAB', 'ABABA']","solution":"from typing import List def generate_fruit_pattern(rows: int, cols: int) -> List[str]: Generate a fruit pattern grid with the given rows and columns. The pattern alternates between 'A' (apple) and 'B' (banana). pattern = [] for row in range(rows): row_pattern = [] for col in range(cols): if (row + col) % 2 == 0: row_pattern.append('A') else: row_pattern.append('B') pattern.append(''.join(row_pattern)) return pattern"},{"question":"def cumulativePoints(points): Returns the cumulative sums of points for each day. Parameters: points (list of int): An array where points[i] represents the total points earned by all participants on the i-th day. Returns: list of int: An array containing the cumulative sums for each day. Example: >>> cumulativePoints([10, 20, 30, 40]) [10, 30, 60, 100] >>> cumulativePoints([5, 15, 25, 35, 45]) [5, 20, 45, 80, 125]","solution":"def cumulativePoints(points): Returns the cumulative sums of points for each day. cumulative_sums = [] total = 0 for point in points: total += point cumulative_sums.append(total) return cumulative_sums"},{"question":"def existsInMatrix(matrix, N, M, string): Checks if the string exists in the matrix by traversing adjacent cells vertically, horizontally, or diagonally. >>> existsInMatrix([ ['A', 'B', 'C', 'E', 'F'], ['S', 'F', 'C', 'S', 'A'], ['A', 'D', 'E', 'E', 'B'], ['C', 'E', 'E', 'E', 'G'] ], 4, 5, \\"ABCCED\\") True >>> existsInMatrix([ ['A', 'B', 'C', 'E'], ['S', 'F', 'C', 'S'], ['A', 'D', 'E', 'E'] ], 3, 4, \\"SEEZ\\") False","solution":"def existsInMatrix(matrix, N, M, string): Checks if the string exists in the matrix by traversing adjacent cells vertically, horizontally, or diagonally. def dfs(x, y, index): if index == len(string): return True if x < 0 or y < 0 or x >= N or y >= M or matrix[x][y] != string[index]: return False # Temporarily mark the cell as visited temp = matrix[x][y] matrix[x][y] = '#' # Check all 8 possible directions directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dir in directions: new_x, new_y = x + dir[0], y + dir[1] if dfs(new_x, new_y, index + 1): return True # Restore the cell value matrix[x][y] = temp return False for i in range(N): for j in range(M): if matrix[i][j] == string[0]: if dfs(i, j, 0): return True return False"},{"question":"def max_apples(R: int, C: int, grid: List[List[int]]) -> int: Calculate the maximum number of apples collected from the top-left corner to the bottom-right corner of the grid. >>> max_apples(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_apples(1, 1, [[5]]) 5 >>> max_apples(1, 5, [[1, 2, 3, 4, 5]]) 15 >>> max_apples(5, 1, [[1], [2], [3], [4], [5]]) 15 >>> max_apples(2, 2, [[1, 2], [3, 4]]) 7 def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = [] idx = 2 for i in range(R): row = [int(data[idx + j]) for j in range(C)] grid.append(row) idx += C print(max_apples(R, C, grid))","solution":"def max_apples(R, C, grid): dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for i in range(1, R): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, C): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[R-1][C-1] # This function will fetch input, call the main logic, and print the result def main(): import sys input = sys.stdin.read data = input().strip().split() R = int(data[0]) C = int(data[1]) grid = [] idx = 2 for i in range(R): row = [int(data[idx + j]) for j in range(C)] grid.append(row) idx += C print(max_apples(R, C, grid))"},{"question":"def sieve_of_eratosthenes(n: int) -> List[int]: Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. >>> sieve_of_eratosthenes(0) == [] >>> sieve_of_eratosthenes(1) == [] >>> sieve_of_eratosthenes(2) == [] >>> sieve_of_eratosthenes(10) == [2, 3, 5, 7] >>> sieve_of_eratosthenes(3) == [2] >>> sieve_of_eratosthenes(20) == [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(30) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]","solution":"def sieve_of_eratosthenes(n): Returns a list of all prime numbers less than n using the Sieve of Eratosthenes algorithm. if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start*start, n, start): sieve[multiple] = False return [num for num, is_prime in enumerate(sieve) if is_prime]"},{"question":"def calculate_hours_and_overtime(N: int, hours_list: List[List[int]]) -> List[Tuple[int, int]]: Calculate total hours and overtime hours worked by each employee. >>> calculate_hours_and_overtime(3, [[8, 8, 8, 8, 8, 0, 0], [10, 10, 10, 10, 10, 0, 0], [5, 5, 5, 5, 5, 5, 5]]) [(40, 0), (50, 10), (35, 0)] def parse_input(input_str: str) -> Tuple[int, List[List[int]]]: Parse the input string to extract the number of employees and their worked hours. >>> parse_input('3n8 8 8 8 8 0 0n10 10 10 10 10 0 0n5 5 5 5 5 5 5n') (3, [[8, 8, 8, 8, 8, 0, 0], [10, 10, 10, 10, 10, 0, 0], [5, 5, 5, 5, 5, 5, 5]]) def format_output(results: List[Tuple[int, int]]) -> str: Format the results into a printable string. >>> format_output([(40, 0), (50, 10), (35, 0)]) '40 0n50 10n35 0'","solution":"def calculate_hours_and_overtime(N, hours_list): results = [] for hours in hours_list: total_hours = sum(hours) overtime = total_hours - 40 if total_hours > 40 else 0 results.append((total_hours, overtime)) return results def parse_input(input_str): lines = input_str.strip().split('n') N = int(lines[0]) hours_list = [list(map(int, line.split())) for line in lines[1:N+1]] return N, hours_list def format_output(results): return 'n'.join(f'{total} {overtime}' for total, overtime in results)"},{"question":"def pairWithSum(nums, target): Find a pair with the given sum in an unsorted integer array. >>> pairWithSum([10, 5, 2, 3, -6, 9, 11], 4) [10, -6] or [-6, 10] >>> pairWithSum([1, 2, 3, 9], 8) [] >>> pairWithSum([1, 2, 3, 4, 5], 7) [3, 4] or [4, 3]","solution":"def pairWithSum(nums, target): Finds a pair of numbers in the list \`nums\` that add up to \`target\`. If such a pair exists, returns it, otherwise returns an empty list. seen = {} for num in nums: complement = target - num if complement in seen: return [complement, num] seen[num] = True return []"},{"question":"from typing import List, Tuple, Dict def dijkstra(n: int, adj: List[List[Tuple[int, int]]], start: int) -> List[int]: Find the shortest paths from a start node to all other nodes using Dijkstra's algorithm. Parameters: - n: int - The number of cities. - adj: List[List[Tuple[int, int]]] - Adjacency list representing the road network. - start: int - The starting city for the shortest path calculations. Returns: - List[int] - List of shortest distances from the start node to every other node. pass def min_distance_to_collect_points(t: int, tests: List[Dict]) -> List[int]: Determines the minimum distance required to visit all given cities in the specified order. Parameters: - t: int - The number of test cases. - tests: List[Dict] - List of test cases; each containing the number of cities, the edges, the number of cities in the sequence, and the sequence of cities to visit. Returns: - List[int] - List of minimum distances for each test case. >>> min_distance_to_collect_points(2, [ ... {'nm': (5, 6), 'edges': [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 4), (3, 5, 3), (4, 5, 1)], 'k': 3, 'sequence': [1, 3, 5]}, ... {'nm': (3, 3), 'edges': [(1, 2, 3), (2, 3, 2), (1, 3, 4)], 'k': 2, 'sequence': [1, 3]}, ... ]) == [6, 4] def test_dijkstra(): n = 5 adj = [[] for _ in range(n + 1)] edges = [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 4), (3, 5, 3), (4, 5, 1)] for u, v, l in edges: adj[u].append((v, l)) adj[v].append((u, l)) dist = dijkstra(n, adj, 1) assert dist[1] == 0 assert dist[2] == 2 assert dist[3] == 3 assert dist[4] == 6 assert dist[5] == 6 def test_min_distance_to_collect_points(): t = 2 tests = [ { 'nm': (5, 6), 'edges': [(1, 2, 2), (1, 3, 5), (2, 3, 1), (2, 4, 4), (3, 5, 3), (4, 5, 1)], 'k': 3, 'sequence': [1, 3, 5], }, { 'nm': (3, 3), 'edges': [(1, 2, 3), (2, 3, 2), (1, 3, 4)], 'k': 2, 'sequence': [1, 3], }, ] result = min_distance_to_collect_points(t, tests) assert result == [6, 4] test_dijkstra() test_min_distance_to_collect_points()","solution":"import heapq def dijkstra(n, adj, start): dist = [float('inf')] * (n + 1) dist[start] = 0 pq = [(0, start)] # priority queue (distance, node) while pq: current_distance, u = heapq.heappop(pq) if current_distance > dist[u]: continue for v, length in adj[u]: distance = current_distance + length if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def min_distance_to_collect_points(t, tests): results = [] for i in range(t): n, m = tests[i]['nm'] edges = tests[i]['edges'] k = tests[i]['k'] sequence = tests[i]['sequence'] adj = [[] for _ in range(n + 1)] for u, v, l in edges: adj[u].append((v, l)) adj[v].append((u, l)) # Calculate shortest path distances between all pairs in the sequence dists = {} for city in sequence: dists[city] = dijkstra(n, adj, city) total_distance = 0 for j in range(1, k): total_distance += dists[sequence[j-1]][sequence[j]] results.append(total_distance) return results"},{"question":"def find_unique_integer(n, numbers): Returns the unique integer that appears only once in the list 'numbers' where every integer from 1 to n appears exactly twice except one which appears once. >>> find_unique_integer(4, [1, 2, 3, 2, 1, 4, 3]) 4 >>> find_unique_integer(3, [1, 2, 3, 2, 1]) 3","solution":"def find_unique_integer(n, numbers): Returns the unique integer that appears only once in the list 'numbers' where every integer from 1 to n appears exactly twice except one which appears once. number_count = {} for number in numbers: if number in number_count: number_count[number] += 1 else: number_count[number] = 1 for number, count in number_count.items(): if count == 1: return number"},{"question":"def nthTerm(n: int) -> int: Returns the nth term in the sequence where each term is the sum of the previous term and the number of digits in the previous term. >>> nthTerm(1) 1 >>> nthTerm(7) 7 >>> nthTerm(999999) 999999 >>> nthTerm(1000000) 1000000","solution":"def nthTerm(n): Returns the nth term in the sequence. Since the sequence is 1, 2, 3, 4, 5, 6, ..., the nth term is simply n. return n"},{"question":"def is_valid_parentheses(s: str) -> bool: Determine if the parentheses in the given string are properly nested and balanced. >>> is_valid_parentheses(\\"((()))\\") True >>> is_valid_parentheses(\\"(()\\") False","solution":"def is_valid_parentheses(s): Returns True if the string s contains properly nested and balanced parentheses, otherwise returns False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"def find_divisibles(lst, n): Write a function that takes a list of integers and a single integer \`n\`, and returns a new list containing only the elements that are divisible by \`n\`. If no elements are divisible by \`n\`, return an empty list. >>> find_divisibles([10, 15, 20, 25, 30], 5) [10, 15, 20, 25, 30] >>> find_divisibles([4, 8, 16, 32], 3) [] >>> find_divisibles([1, 2, 3, 4, 5, 6], 2) [2, 4, 6]","solution":"def find_divisibles(lst, n): Returns a new list containing only the elements from lst that are divisible by n. If no elements are divisible by n, return an empty list. return [x for x in lst if x % n == 0]"},{"question":"def longest_beautiful_subarray(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest beautiful subarray for each test case. A subarray is considered beautiful if its sum is even. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer n (the length of the array) and a list of n integers representing the elements of the array. Returns: List[int]: A list of integers where each integer represents the length of the longest beautiful subarray for each test case. pass # Test cases from longest_beautiful_subarray import longest_beautiful_subarray def test_single_test_case(): T = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert longest_beautiful_subarray(T, test_cases) == [4] def test_multiple_test_cases(): T = 2 test_cases = [(5, [1, 2, 3, 4, 5]), (4, [-1, -2, -3, -4])] assert longest_beautiful_subarray(T, test_cases) == [4, 4] def test_all_odd_elements(): T = 1 test_cases = [(4, [1, 3, 5, 7])] assert longest_beautiful_subarray(T, test_cases) == [3] def test_all_even_elements(): T = 1 test_cases = [(4, [2, 4, 6, 8])] assert longest_beautiful_subarray(T, test_cases) == [4] def test_single_element_even(): T = 1 test_cases = [(1, [2])] assert longest_beautiful_subarray(T, test_cases) == [1] def test_single_element_odd(): T = 1 test_cases = [(1, [1])] assert longest_beautiful_subarray(T, test_cases) == [0] def test_mixed_elements(): T = 1 test_cases = [(6, [1, 3, 2, 4, 5, 6])] assert longest_beautiful_subarray(T, test_cases) == [6]","solution":"def longest_beautiful_subarray(T, test_cases): results = [] for test in test_cases: n, array = test # Finding first and last occurrences of even numbers first_even = -1 last_even = -1 for i in range(n): if array[i] % 2 == 0: if first_even == -1: first_even = i last_even = i if first_even == -1: if n > 1: results.append(n - 1) else: results.append(0) else: results.append(max(last_even + 1, n - first_even, n - last_even - 1)) return results"},{"question":"def find_duplicate(arr: List[int]) -> int: Finds the first duplicate integer in the list \`arr\`. >>> find_duplicate([1, 2, 3, 4, 2, 5, 6]) 2 >>> find_duplicate([6, 1, 5, 7, 5, 1]) 5 >>> find_duplicate([1, 2, 3, 4, 5]) -1","solution":"def find_duplicate(arr): Finds the first duplicate integer in the list \`arr\`. Parameters: arr (list of int): List of integers where we need to find the first duplicate. Returns: int: The first duplicate integer if exists, otherwise -1. seen = set() for num in arr: if num in seen: return num seen.add(num) return -1 # Example usage print(find_duplicate([1, 2, 3, 4, 2, 5, 6])) # Output: 2"},{"question":"def max_completed_tasks(n, m, employees, tasks): Determine the maximum number of tasks that can be completed given the constraints of employee available hours and skill levels. >>> max_completed_tasks(3, 3, [(10, 5), (8, 7), (6, 4)], [(5, 3), (4, 4), (6, 6)]) 2 >>> max_completed_tasks(2, 4, [(12, 8), (10, 6)], [(4, 5), (8, 6), (5, 7), (3, 4)]) 3 from solution import max_completed_tasks def test_example1(): n, m = 3, 3 employees = [(10, 5), (8, 7), (6, 4)] tasks = [(5, 3), (4, 4), (6, 6)] assert max_completed_tasks(n, m, employees, tasks) == 2 def test_example2(): n, m = 2, 4 employees = [(12, 8), (10, 6)] tasks = [(4, 5), (8, 6), (5, 7), (3, 4)] assert max_completed_tasks(n, m, employees, tasks) == 3 def test_no_possible_completion(): n, m = 2, 2 employees = [(5, 3), (6, 4)] tasks = [(7, 5), (8, 6)] assert max_completed_tasks(n, m, employees, tasks) == 0 def test_all_tasks_completed(): n, m = 2, 2 employees = [(10, 5), (8, 7)] tasks = [(4, 4), (5, 3)] assert max_completed_tasks(n, m, employees, tasks) == 2 def test_multiple_tasks_single_employee(): n, m = 1, 4 employees = [(20, 10)] tasks = [(3, 4), (5, 3), (8, 8), (4, 6)] assert max_completed_tasks(n, m, employees, tasks) == 4","solution":"def max_completed_tasks(n, m, employees, tasks): # Sort employees and tasks by skill level (and then by available hours/time for stable sorting) employees = sorted(employees, key=lambda x: (x[1], x[0])) tasks = sorted(tasks, key=lambda x: (x[1], x[0])) task_completed = 0 task_index = 0 for available_hours, skill_level in employees: while task_index < m and tasks[task_index][1] <= skill_level: task_time, task_skill = tasks[task_index] if task_time <= available_hours: # Fulfill the task available_hours -= task_time task_completed += 1 task_index += 1 return task_completed"},{"question":"def schedule_notifications(schedule, current_day): Returns a list of event descriptions for the current day and the following day. The function receives two parameters: - \`schedule\`: a list of tuples where each tuple represents an event (day, start time, end time, description). - \`current_day\`: a string representing the current day of the week. The function returns a list of event descriptions that occur on the current day and the following day (in chronological order). Example input and output: >>> schedule_notifications([('Monday', '14:30', '16:00', 'Team Meeting'), ('Tuesday', '09:00', '10:00', 'Doctor Appointment'), ('Wednesday', '18:00', '19:30', 'Workout Session')], 'Monday') ['Team Meeting', 'Doctor Appointment'] >>> schedule_notifications([('Friday', '09:00', '10:00', 'Coffee with Sarah'), ('Friday', '12:00', '13:00', 'Lunch with John'), ('Saturday', '10:00', '12:00', 'Conference Call')], 'Friday') ['Coffee with Sarah', 'Lunch with John', 'Conference Call'] >>> schedule_notifications([('Sunday', '09:00', '10:00', 'Brunch with Family'), ('Monday', '11:00', '12:00', 'Project Update Meeting')], 'Sunday') ['Brunch with Family', 'Project Update Meeting'] pass # Unit tests def test_schedule_notifications_same_day(): schedule = [('Monday', '14:30', '16:00', 'Team Meeting')] current_day = 'Monday' assert schedule_notifications(schedule, current_day) == ['Team Meeting'] def test_schedule_notifications_diff_days(): schedule = [('Monday', '14:30', '16:00', 'Team Meeting'), ('Tuesday', '09:00', '10:00', 'Doctor Appointment')] current_day = 'Monday' assert schedule_notifications(schedule, current_day) == ['Team Meeting', 'Doctor Appointment'] def test_schedule_notifications_multiple_events(): schedule = [('Friday', '09:00', '10:00', 'Coffee with Sarah'), ('Friday', '12:00', '13:00', 'Lunch with John'), ('Saturday', '10:00', '12:00', 'Conference Call')] current_day = 'Friday' assert schedule_notifications(schedule, current_day) == ['Coffee with Sarah', 'Lunch with John', 'Conference Call'] def test_schedule_notifications_wrap_around_week(): schedule = [('Sunday', '09:00', '10:00', 'Brunch with Family'), ('Monday', '11:00', '12:00', 'Project Update Meeting')] current_day = 'Sunday' assert schedule_notifications(schedule, current_day) == ['Brunch with Family', 'Project Update Meeting'] def test_schedule_notifications_no_events(): schedule = [('Wednesday', '18:00', '19:30', 'Workout Session')] current_day = 'Monday' assert schedule_notifications(schedule, current_day) == []","solution":"def schedule_notifications(schedule, current_day): Returns a list of event descriptions for the current day and the following day. days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] current_day_index = days_of_week.index(current_day) next_day_index = (current_day_index + 1) % 7 next_day = days_of_week[next_day_index] events_today_and_tomorrow = [event[3] for event in schedule if event[0] == current_day or event[0] == next_day] return events_today_and_tomorrow"},{"question":"def can_rearrange(s1: str, s2: str) -> bool: Determines if s1 can be rearranged to form s2. >>> can_rearrange(\\"listen\\", \\"silent\\") True >>> can_rearrange(\\"triangle\\", \\"integral\\") True >>> can_rearrange(\\"apple\\", \\"papel\\") True >>> can_rearrange(\\"hello\\", \\"billion\\") False >>> can_rearrange(\\"abc\\", \\"abcd\\") False","solution":"def can_rearrange(s1: str, s2: str) -> bool: Determines if s1 can be rearranged to form s2. if len(s1) != len(s2): return False from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def min_total_height(n: int, heights: List[int]) -> int: Calculate the minimum total height Jerry needs to climb to reach the top. Args: n (int): number of steps heights (list of int): list of heights of the steps Returns: int: minimum total height Jerry needs to climb Examples: >>> min_total_height(5, [1, 3, 6, 2, 8]) 7 >>> min_total_height(4, [4, 4, 4, 4]) 4 >>> min_total_height(6, [1, 2, 3, 7, 8, 10]) 9","solution":"def min_total_height(n, heights): Calculate the minimum total height Jerry needs to climb to reach the top. Args: n (int): number of steps heights (list): list of heights of the steps Returns: int: minimum total height Jerry needs to climb return heights[-1] - heights[0] # Example usage would be done here to demonstrate, but not including it as per instructions # Example: min_total_height(5, [1, 3, 6, 2, 8]) # Output should be: 7"},{"question":"def duplicate_characters(input_string: str, n: int) -> str: Write a function that takes a string as an input and returns a new string where each character in the original string is duplicated \`n\` number of times. Args: input_string (str): A string containing only lowercase alphabets. n (int): The number of times each character should be duplicated. Returns: str: A string where each character of the input_string is repeated n times. Examples: >>> duplicate_characters(\\"hello\\", 3) 'hhheeelllllooo' >>> duplicate_characters(\\"abc\\", 2) 'aabbcc'","solution":"def duplicate_characters(input_string: str, n: int) -> str: Duplicates each character in the input string n times. Args: input_string (str): A string containing only lowercase alphabets. n (int): The number of times each character should be duplicated. Returns: str: A string where each character of the input_string is repeated n times. output_string = ''.join([char * n for char in input_string]) return output_string"},{"question":"def generate_artwork_sequence(n: int) -> List[int]: Generates a sequence such that it forms a zigzag pattern. >>> generate_artwork_sequence(5) [0, 3, 1, 4, 2] >>> generate_artwork_sequence(8) [0, 7, 1, 6, 2, 5, 3, 4]","solution":"def generate_artwork_sequence(n): Generates a sequence such that it forms a zigzag pattern. # Create an array of numbers from 0 to n-1 sequence = list(range(n)) # We will swap every adjacent pair to form a zigzag pattern for i in range(1, n, 2): if i + 1 < n: sequence[i], sequence[i + 1] = sequence[i + 1], sequence[i] return sequence"},{"question":"def longest_distinct_subarray(arr): Returns the length of the longest subarray with all distinct elements. :param arr: List of integers :return: Integer length of the longest subarray pass # Example test cases from solution import longest_distinct_subarray def test_longest_distinct_subarray(): assert longest_distinct_subarray([1, 2, 1, 3, 4, 2, 3]) == 4 assert longest_distinct_subarray([1, 2, 3, 4, 5]) == 5 assert longest_distinct_subarray([1, 2, 1, 2, 1]) == 2 assert longest_distinct_subarray([1]) == 1 assert longest_distinct_subarray([]) == 0 assert longest_distinct_subarray([1, 1, 1, 1, 1]) == 1 assert longest_distinct_subarray([1, 2, 3, 4, 1, 2, 3, 4]) == 4 assert longest_distinct_subarray([1, 2, 3, 1, 2, 3, 4, 5, 6]) == 6 assert longest_distinct_subarray([1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 7]) == 7","solution":"def longest_distinct_subarray(arr): Returns the length of the longest subarray with all distinct elements. :param arr: List of integers :return: Integer length of the longest subarray if not arr: return 0 max_length = 0 start = 0 seen_elements = {} for end in range(len(arr)): if arr[end] in seen_elements: start = max(start, seen_elements[arr[end]] + 1) seen_elements[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def longestCommonSubsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. >>> longestCommonSubsequence(\\"abcde\\", \\"ace\\") # 3 >>> longestCommonSubsequence(\\"abc\\", \\"abc\\") # 3 >>> longestCommonSubsequence(\\"abc\\", \\"def\\") # 0","solution":"def longestCommonSubsequence(text1, text2): Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) # Create a 2D DP array of size (m + 1) x (n + 1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill the DP array for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def pair_with_sum(arr, k): Determines if there are two distinct elements in the array whose sum is k. >>> pair_with_sum([1, 4, 45, 6, 10, 8], 16) \\"YES\\" >>> pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> pair_with_sum([2, -5, 11, -10], 1) \\"YES\\" >>> pair_with_sum([-1, 3, 4, -2, 5], 3) \\"YES\\" >>> pair_with_sum([1, 1, 2, 3], 2) \\"YES\\" >>> pair_with_sum([5], 5) \\"NO\\" >>> pair_with_sum([], 5) \\"NO\\" >>> pair_with_sum([1000000, 2000000, 3000000], 5000000) \\"YES\\"","solution":"def pair_with_sum(arr, k): Determines if there are two distinct elements in the array whose sum is k. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" # Example Usage: # n = 6 # arr = [1, 4, 45, 6, 10, 8] # k = 16 # print(pair_with_sum(arr, k)) # Output: \\"YES\\""},{"question":"def matrix_diagonals(matrix): Given a matrix represented as a 2D list of integers, return the list of its diagonals, where each diagonal starts from one of the matrix's left-most or bottom-most elements. Each diagonal must be returned as a separate list, starting from the top-left corner to the bottom-right corner. >>> matrix_diagonals([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == [ ... [1], ... [4, 2], ... [7, 5, 3], ... [8, 6], ... [9] ... ] >>> matrix_diagonals([ ... [1, 2], ... [3, 4], ... [5, 6] ... ]) == [ ... [1], ... [3, 2], ... [5, 4], ... [6] ... ] from solution import matrix_diagonals def test_matrix_diagonals_3x3(): assert matrix_diagonals([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == [ [1], [4, 2], [7, 5, 3], [8, 6], [9] ] def test_matrix_diagonals_3x2(): assert matrix_diagonals([ [1, 2], [3, 4], [5, 6] ]) == [ [1], [3, 2], [5, 4], [6] ] def test_matrix_diagonals_empty(): assert matrix_diagonals([]) == [] def test_matrix_diagonals_single_element(): assert matrix_diagonals([[1]]) == [[1]] def test_matrix_diagonals_2x2(): assert matrix_diagonals([ [1, 2], [3, 4] ]) == [ [1], [3, 2], [4] ] def test_matrix_diagonals_4x4(): assert matrix_diagonals([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == [ [1], [5, 2], [9, 6, 3], [13, 10, 7, 4], [14, 11, 8], [15, 12], [16] ]","solution":"def matrix_diagonals(matrix): Returns a list of lists, each corresponding to a diagonal of the matrix. if not matrix: return [] result = [] rows = len(matrix) cols = len(matrix[0]) for start in range(rows + cols - 1): diagonal = [] if start < rows: row = start col = 0 else: row = rows - 1 col = start - (rows - 1) while row >= 0 and col < cols: diagonal.append(matrix[row][col]) row -= 1 col += 1 result.append(diagonal) return result"},{"question":"def closestPair(arr, K): Returns two unique integers in the array whose sum is closest to K. >>> closestPair([10, 22, 28, 29, 30, 40], 54) (22, 30) >>> closestPair([1, 3, 4, 7, 10], 15) (4, 10)","solution":"def closestPair(arr, K): Returns two unique integers in the array whose sum is closest to K. arr.sort() left, right = 0, len(arr) - 1 closest_sum = float('inf') closest_pair = (None, None) while left < right: current_sum = arr[left] + arr[right] if abs(K - current_sum) < abs(K - closest_sum): closest_sum = current_sum closest_pair = (arr[left], arr[right]) if current_sum < K: left += 1 elif current_sum > K: right -= 1 else: break return closest_pair"},{"question":"def rotate_array_right(N: int, K: int, A: List[int]) -> List[int]: Rotates the array A to the right by K steps. Args: N : int : The size of the array A. K : int : The number of steps to rotate the array. A : list : The array of integers to be rotated. Returns: list : The rotated array. >>> rotate_array_right(5, 2, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> rotate_array_right(5, 5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> rotate_array_right(5, 7, [1, 2, 3, 4, 5]) [4, 5, 1, 2, 3] >>> rotate_array_right(1, 3, [10]) [10] >>> rotate_array_right(3, 1, [1, 2, 3]) [3, 1, 2] >>> rotate_array_right(4, 0, [7, 6, 5, 8]) [7, 6, 5, 8] >>> rotate_array_right(4, 4, [-1, -2, -3, -4]) [-1, -2, -3, -4] >>> rotate_array_right(6, 2, [10, 20, 30, 40, 50, 60]) [50, 60, 10, 20, 30, 40]","solution":"def rotate_array_right(N, K, A): Rotates the array A to the right by K steps. Args: N : int : The size of the array A. K : int : The number of steps to rotate the array. A : list : The array of integers to be rotated. Returns: list : The rotated array. K = K % N # Handling cases where K is greater than N return A[-K:] + A[:-K]"},{"question":"def max_treasure(n: int, m: int, grid: List[List[int]]) -> int: Calculate the maximum amount of treasure Ark can collect while moving from the top-left corner (1,1) to the bottom-right corner (N,M) on the given grid. >>> max_treasure(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_treasure(3, 3, [[1, 1, 1], [1, 5, 1], [1, 1, 1]]) 9 >>> max_treasure(2, 2, [[1, 0], [0, 1]]) 2 >>> max_treasure(1, 1, [[5]]) 5 >>> max_treasure(2, 3, [[1, 3, 1], [1, 5, 1]]) 10 >>> max_treasure(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> max_treasure(0, 0, []) 0 >>> max_treasure(1, 0, [[]]) 0 >>> max_treasure(0, 1, []) 0","solution":"def max_treasure(n, m, grid): if n == 0 or m == 0: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(n): for j in range(m): if i > 0: dp[i][j] = max(dp[i][j], dp[i-1][j] + grid[i][j]) if j > 0: dp[i][j] = max(dp[i][j], dp[i][j-1] + grid[i][j]) if i > 0 and j > 0: dp[i][j] = max(dp[i][j], dp[i-1][j-1] + grid[i][j]) return dp[n-1][m-1]"},{"question":"def generateParenthesis(n: int) -> List[str]: Generates all combinations of well-formed parentheses of length n * 2. >>> generateParenthesis(2) == [\\"(())\\", \\"()()\\"] >>> generateParenthesis(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"]","solution":"def generateParenthesis(n): Generates all combinations of well-formed parentheses of length n * 2. result = [] def backtrack(S = '', left = 0, right = 0): if len(S) == n * 2: result.append(S) return if left < n: backtrack(S + '(', left + 1, right) if right < left: backtrack(S + ')', left, right + 1) backtrack() return result"},{"question":"def alice_bob_scores(n: int, cards: List[int]) -> Tuple[int, int]: Returns the final scores for Alice and Bob after all cards have been picked. Alice and Bob play optimally, trying to maximize their scores. Parameters: n (int): The number of cards. cards (List[int]): The values of the cards. Returns: Tuple[int, int]: A tuple containing the scores for Alice and Bob respectively. Examples: >>> alice_bob_scores(4, [3, 9, 1, 2]) (11, 4) >>> alice_bob_scores(6, [1, 2, 9, 4, 5, 3]) (15, 9)","solution":"def alice_bob_scores(n, cards): Returns the final scores for Alice and Bob if they play optimally. # Initialize memoization table for dynamic programming dp = [[(0, 0) for _ in range(n)] for _ in range(n)] # Base case: when there's only one card, Alice picks it for i in range(n): dp[i][i] = (cards[i], 0) # Fill the table for all subproblems for length in range(2, n + 1): # subproblems of length 2 to n for i in range(n - length + 1): # starting index of subproblem j = i + length - 1 # ending index of subproblem # Alice can either take the card at i or the card at j left_choice = (cards[i] + dp[i + 1][j][1], dp[i + 1][j][0]) right_choice = (cards[j] + dp[i][j - 1][1], dp[i][j - 1][0]) # Choose the better option for Alice if left_choice[0] > right_choice[0]: dp[i][j] = left_choice else: dp[i][j] = right_choice # The final answer is stored in dp[0][n-1] return dp[0][n-1] # Example inputs, these are just for illustration purposes # n = 6 # cards = [1, 2, 9, 4, 5, 3] # Result: (15, 9)"},{"question":"def longest_alternating_subarray_length(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases and the test cases themselves, find the length of the longest contiguous subarray with alternating even and odd numbers. >>> T = 2 >>> test_cases = [(5, [1, 2, 3, 4, 5]), (6, [1, 3, 5, 2, 4, 6])] >>> longest_alternating_subarray_length(T, test_cases) [5, 2] >>> T = 1 >>> test_cases = [(4, [2, 2, 2, 2])] >>> longest_alternating_subarray_length(T, test_cases) [1] >>> T = 1 >>> test_cases = [(5, [1, 1, 1, 1, 1])] >>> longest_alternating_subarray_length(T, test_cases) [1] >>> T = 1 >>> test_cases = [(5, [1, 2, 3, 4, 5])] >>> longest_alternating_subarray_length(T, test_cases) [5] >>> T = 1 >>> test_cases = [(6, [1000000000, 3, 1000000000, 5, 1000000000, 7])] >>> longest_alternating_subarray_length(T, test_cases) [6]","solution":"def longest_alternating_subarray_length(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] array = test_cases[i][1] if N == 0: results.append(0) continue max_len = 1 current_len = 1 for j in range(1, N): if (array[j-1] % 2 == 0 and array[j] % 2 != 0) or (array[j-1] % 2 != 0 and array[j] % 2 == 0): current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 results.append(max_len) return results"},{"question":"def stringTransformation(m: int, pairs: List[Tuple[str, str]]) -> List[int]: Given m pairs of strings (s, t), find and return the minimum cost of transforming each s into t using a series of defined operations. >>> stringTransformation(2, [(\\"kitten\\", \\"sitting\\"), (\\"flaw\\", \\"law\\")]) [3, 1] >>> stringTransformation(1, [(\\"\\", \\"a\\")]) [1] >>> stringTransformation(1, [(\\"a\\", \\"\\")]) [1] >>> stringTransformation(1, [(\\"a\\", \\"b\\")]) [1] >>> stringTransformation(1, [(\\"abc\\" * 1000, \\"def\\" * 1000)]) [3000]","solution":"def stringTransformation(m, pairs): def min_cost(s, t): len_s = len(s) len_t = len(t) # Create a DP array dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] # Initialize the DP array for i in range(len_s + 1): dp[i][0] = i for j in range(len_t + 1): dp[0][j] = j # Fill up the DP table for i in range(1, len_s + 1): for j in range(1, len_t + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 return dp[len_s][len_t] results = [] for s, t in pairs: results.append(min_cost(s, t)) return results"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, root, key): Insert a new key into the BST pass def count_leaf_nodes(self, root): Count the number of leaf nodes in the BST pass def count_leaf_nodes_in_bst(n, sequence): Constructs a BST from the given sequence and counts the number of leaf nodes. >>> count_leaf_nodes_in_bst(7, [10, 5, 1, 7, 40, 50, 30]) 4 >>> count_leaf_nodes_in_bst(1, [42]) 1 pass from solution import count_leaf_nodes_in_bst def test_sample(): assert count_leaf_nodes_in_bst(7, [10, 5, 1, 7, 40, 50, 30]) == 4 def test_single_element(): assert count_leaf_nodes_in_bst(1, [42]) == 1 def test_two_elements(): assert count_leaf_nodes_in_bst(2, [10, 5]) == 1 assert count_leaf_nodes_in_bst(2, [10, 15]) == 1 def test_three_elements(): assert count_leaf_nodes_in_bst(3, [10, 5, 15]) == 2 def test_all_left_children(): assert count_leaf_nodes_in_bst(5, [10, 9, 8, 7, 6]) == 1 def test_all_right_children(): assert count_leaf_nodes_in_bst(5, [10, 11, 12, 13, 14]) == 1 def test_mixed_insertion_sequence(): assert count_leaf_nodes_in_bst(8, [20, 10, 30, 5, 15, 25, 35, 23]) == 4","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, root, key): if root is None: return TreeNode(key) else: if key < root.val: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) return root def count_leaf_nodes(self, root): if root is None: return 0 if root.left is None and root.right is None: return 1 return self.count_leaf_nodes(root.left) + self.count_leaf_nodes(root.right) def count_leaf_nodes_in_bst(n, sequence): bst = BST() root = None for key in sequence: root = bst.insert(root, key) return bst.count_leaf_nodes(root)"},{"question":"def min_operations_to_make_elements_equal(n: int, sequence: List[int]) -> int: Returns the minimum number of operations required to make all elements of the sequence equal. Each operation consists of choosing a subarray and adding 1 to all elements of the chosen subarray. Args: n (int): The length of the sequence. sequence (List[int]): The elements of the sequence. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_make_elements_equal(4, [1, 2, 3, 4]) 3 >>> min_operations_to_make_elements_equal(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_make_elements_equal(3, [1, 5, 7]) 6","solution":"def min_operations_to_make_elements_equal(n, sequence): Returns the minimum number of operations required to make all elements of the sequence equal. Here, the minimum number of operations required is the difference between the maximum and minimum elements in the sequence. max_value = max(sequence) min_value = min(sequence) return max_value - min_value"},{"question":"def fibonacci(n): Returns a list of the first n Fibonacci numbers. >>> fibonacci(5) == [0, 1, 1, 2, 3] >>> fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n Fibonacci numbers. if n <= 0: return [] elif n == 1: return [0] fib_sequence = [0, 1] while len(fib_sequence) < n: fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"def common_elements(list1, list2): Returns a list of elements that are common to both input lists. If an element occurs multiple times in both lists, it will be included in the result the minimum number of times it occurs in either list. >>> common_elements([1, 2, 2, 3, 4], [2, 2, 3, 5]) == [2, 2, 3] >>> common_elements(['a', 'b', 'b', 'c'], ['b', 'b', 'c', 'd']) == ['b', 'b', 'c'] >>> common_elements([1, 1, 1, 2], [1, 1, 3, 4]) == [1, 1] import pytest def test_common_elements(): assert common_elements([1, 2, 2, 3, 4], [2, 2, 3, 5]) == [2, 2, 3] assert common_elements(['a', 'b', 'b', 'c'], ['b', 'b', 'c', 'd']) == ['b', 'b', 'c'] assert common_elements([1, 1, 1, 2], [1, 1, 3, 4]) == [1, 1] assert common_elements([1, 1, 2, 3], [4, 5, 6]) == [] assert common_elements([], [1, 2, 3]) == [] assert common_elements([1, 2, 3], []) == [] assert common_elements([], []) == [] assert common_elements(['a', 'b', 'c'], ['c', 'd', 'e']) == ['c'] assert common_elements([1, 2, 2, 2, 3], [2, 2, 3, 3, 3]) == [2, 2, 3] if __name__ == '__main__': pytest.main()","solution":"def common_elements(list1, list2): Returns a list of elements that are common to both input lists. If an element occurs multiple times in both lists, it will be included in the result the minimum number of times it occurs in either list. # Dictionary to count occurrences of elements in both lists count1 = {} count2 = {} for item in list1: count1[item] = count1.get(item, 0) + 1 for item in list2: count2[item] = count2.get(item, 0) + 1 # Finding common elements common = [] for item in count1: if item in count2: common.extend([item] * min(count1[item], count2[item])) return common"},{"question":"def count_inversions(n: int, k: int) -> int: Returns the number of permutations of the set {1, 2, ..., n} with exactly k inversions. >>> count_inversions(3, 1) 2 >>> count_inversions(4, 4) 5 >>> count_inversions(5, 0) 1","solution":"def count_inversions(n, k): Returns the number of permutations of the set {1, 2, ..., n} with exactly k inversions. # Dynamic programming table, dp[i][j] represents number of permutations of set {1, 2, ..., i} with exactly j inversions. dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)] # Base case: 1 permutation of an empty set with 0 inversions. dp[0][0] = 1 for i in range(1, n + 1): for j in range(k + 1): dp[i][j] = 0 for x in range(min(j, i - 1) + 1): dp[i][j] += dp[i - 1][j - x] return dp[n][k]"},{"question":"def check_one_diff_pair(N: int, M: int, strings: List[str]) -> str: Determine if there exists a pair of strings such that they differ by exactly one character. Parameters: N (int): Number of strings M (int): Length of each string strings (List[str]): List of strings Returns: str: \\"YES\\" if a pair exists, otherwise \\"NO\\" >>> check_one_diff_pair(4, 5, [\\"apple\\", \\"apply\\", \\"ample\\", \\"align\\"]) \\"YES\\" >>> check_one_diff_pair(3, 3, [\\"abc\\", \\"abc\\", \\"dbc\\"]) \\"YES\\" >>> check_one_diff_pair(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) \\"NO\\" def differ_by_one(str1, str2): count_diff = 0 for i in range(len(str1)): if str1[i] != str2[i]: count_diff += 1 if count_diff > 1: return False return count_diff == 1 for i in range(N): for j in range(i + 1, N): if differ_by_one(strings[i], strings[j]): return \\"YES\\" return \\"NO\\" from typing import List def test_case_1(): assert check_one_diff_pair(4, 5, [\\"apple\\", \\"apply\\", \\"ample\\", \\"align\\"]) == \\"YES\\" def test_case_2(): assert check_one_diff_pair(3, 3, [\\"abc\\", \\"abc\\", \\"dbc\\"]) == \\"YES\\" def test_case_3(): assert check_one_diff_pair(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) == \\"NO\\" def test_case_4(): assert check_one_diff_pair(2, 3, [\\"abc\\", \\"abd\\"]) == \\"YES\\" def test_case_5(): assert check_one_diff_pair(5, 3, [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\"]) == \\"NO\\" def test_case_6(): assert check_one_diff_pair(3, 4, [\\"abcd\\", \\"abed\\", \\"abfd\\"]) == \\"YES\\"","solution":"def check_one_diff_pair(N, M, strings): def differ_by_one(str1, str2): count_diff = 0 for i in range(len(str1)): if str1[i] != str2[i]: count_diff += 1 if count_diff > 1: return False return count_diff == 1 for i in range(N): for j in range(i + 1, N): if differ_by_one(strings[i], strings[j]): return \\"YES\\" return \\"NO\\""},{"question":"def grid_queries(n: int, m: int, grid: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Determine the total number of coins in the subrectangle defined by the top-left corner (x1, y1) and the bottom-right corner (x2, y2) for each query in a grid. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : 2D list representing the grid where each cell contains a certain number of coins queries : List[Tuple[int, int, int, int]] : list of tuples representing the queries, where each tuple contains four integers x1, y1, x2, and y2 Returns: List[int] : list of integers where each integer is the total number of coins in the specified subrectangle Example: >>> grid_queries(3, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]], [(1, 1, 2, 2), (2, 2, 3, 4)]) [14, 54] >>> grid_queries(2, 3, [[1, 1, 1], [2, 2, 2]], [(1, 2, 2, 3)]) [6] from typing import List, Tuple import itertools def test_single_query(): n, m = 3, 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 1, 2, 2)] assert grid_queries(n, m, grid, queries) == [14] def test_multiple_queries(): n, m = 3, 4 grid = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] queries = [(1, 1, 2, 2), (2, 2, 3, 4)] assert grid_queries(n, m, grid, queries) == [14, 54] def test_edge_case_single_cell(): n, m = 1, 1 grid = [[5]] queries = [(1, 1, 1, 1)] assert grid_queries(n, m, grid, queries) == [5] def test_edge_case_large_numbers(): n, m = 2, 2 grid = [ [1000000000, 1000000000], [1000000000, 1000000000] ] queries = [(1, 1, 2, 2)] assert grid_queries(n, m, grid, queries) == [4000000000] def test_complex_case(): n, m = 2, 3 grid = [ [1, 1, 1], [2, 2, 2] ] queries = [(1, 2, 2, 3)] assert grid_queries(n, m, grid, queries) == [6]","solution":"def preprocess_grid(grid, n, m): prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n): for j in range(m): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] return prefix_sum def query_coins(prefix_sum, x1, y1, x2, y2): return (prefix_sum[x2][y2] - prefix_sum[x1 - 1][y2] - prefix_sum[x2][y1 - 1] + prefix_sum[x1 - 1][y1 - 1]) def grid_queries(n, m, grid, queries): prefix_sum = preprocess_grid(grid, n, m) results = [] for x1, y1, x2, y2 in queries: results.append(query_coins(prefix_sum, x1, y1, x2, y2)) return results"},{"question":"def count_duplicates(arr): Given an array of integers, counts the number of duplicates present in the array. Returns a dictionary where the keys are the duplicate integers and the values are their respective counts of occurrences. >>> count_duplicates([1, 2, 2, 3, 4, 4, 4, 5]) {2: 2, 4: 3} >>> count_duplicates([1, 2, 3, 4, 5]) {} >>> count_duplicates([1, 1, 1, 1]) {1: 4} >>> count_duplicates([1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5]) {2: 2, 3: 3, 5: 4} >>> count_duplicates([]) {} >>> count_duplicates([1]) {}","solution":"def count_duplicates(arr): Returns a dictionary with numbers as keys and their respective counts of occurrences as values for duplicates in the input array. counts = {} duplicates = {} for num in arr: if num in counts: counts[num] += 1 else: counts[num] = 1 for num, count in counts.items(): if count > 1: duplicates[num] = count return duplicates"},{"question":"def subset_sum(arr, target): Determines if there exists a subset of the array that adds up to the target value. >>> subset_sum([2, 3, 7, 8, 10], 11) True >>> subset_sum([1, 2, 3, 4, 5], 10) True >>> subset_sum([1, 2, 3, 9], 8) False >>> subset_sum([3, 34, 4, 12, 5, 2], 9) True","solution":"def subset_sum(arr, target): n = len(arr) dp = [[False for _ in range(target + 1)] for _ in range(n + 1)] # There is always a subset with sum 0, the empty subset. for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, target + 1): if arr[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]] else: dp[i][j] = dp[i - 1][j] return dp[n][target]"},{"question":"def can_be_sum_of_two_distinct_multiples(X: int, P: int, Q: int) -> str: Determine if it is possible to represent X as a sum of exactly two distinct positive integers such that one of them is an exact multiple of P and the other is an exact multiple of Q. >>> can_be_sum_of_two_distinct_multiples(17, 3, 5) \\"YES\\" >>> can_be_sum_of_two_distinct_multiples(23, 4, 7) \\"YES\\" >>> can_be_sum_of_two_distinct_multiples(15, 3, 5) \\"NO\\" >>> can_be_sum_of_two_distinct_multiples(20, 2, 6) \\"YES\\" >>> can_be_sum_of_two_distinct_multiples(1, 2, 3) \\"NO\\" >>> can_be_sum_of_two_distinct_multiples(10000, 100, 50) \\"YES\\"","solution":"def can_be_sum_of_two_distinct_multiples(X, P, Q): for a in range(P, X, P): for b in range(Q, X, Q): if a + b == X and a != b: return \\"YES\\" return \\"NO\\""},{"question":"def minimum_resilience_cost(N, edges): Compute the minimum cost required to make the entire power grid resilient. Arguments: N -- number of nodes (substations) edges -- list of edges where each edge is represented as a tuple (u, v, w) Returns: int -- the minimum resilience cost Examples: >>> minimum_resilience_cost(4, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]) 12 >>> minimum_resilience_cost(5, [(1, 2, 1), (1, 3, 2), (3, 4, 3), (2, 5, 4)]) 10 >>> minimum_resilience_cost(2, [(1, 2, 5)]) 5 >>> minimum_resilience_cost(7, [(1, 2, 2), (1, 3, 2), (2, 4, 3), (2, 5, 3), (3, 6, 4), (3, 7, 4)]) 18 >>> minimum_resilience_cost(4, [(1, 2, 1000), (2, 3, 1000), (3, 4, 1000)]) 3000","solution":"def minimum_resilience_cost(N, edges): Compute the minimum cost required to make the entire power grid resilient. Since the graph is a tree, all edges are necessary and we simply sum their weights. Arguments: N -- number of nodes (substations) edges -- list of edges where each edge is represented as a tuple (u, v, w) Returns: int -- the minimum resilience cost return sum(w for u, v, w in edges)"},{"question":"def maximum_subarray_with_one_exclusion(test_cases): Determine the maximum possible sum of a subarray with at most one exclusion. Args: test_cases: A list of lists, where each inner list contains integers representing the beauty values of the flowers. Returns: A list of integers representing the maximum subarray sum with at most one exclusion for each test case. pass # Example usage for function def main(): T = int(input()) test_cases = [] for _ in range(T): n = int(input()) flowers = list(map(int, input().split())) test_cases.append(flowers) results = maximum_subarray_with_one_exclusion(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main() # Unit Test def test_multiple_cases(): test_cases = [ [1, -2, 0, 3, -1], [-1, -2, -3, -4] ] expected = [4, -1] assert maximum_subarray_with_one_exclusion(test_cases) == expected def test_all_positive_flowers(): test_cases = [ [1, 2, 3, 4, 5] ] expected = [15] assert maximum_subarray_with_one_exclusion(test_cases) == expected def test_all_negative_flowers(): test_cases = [ [-5, -4, -3, -2, -1] ] expected = [-1] assert maximum_subarray_with_one_exclusion(test_cases) == expected def test_single_flower(): test_cases = [ [10], [-10] ] expected = [10, -10] assert maximum_subarray_with_one_exclusion(test_cases) == expected def test_single_flower_zero(): test_cases = [ [0] ] expected = [0] assert maximum_subarray_with_one_exclusion(test_cases) == expected def test_all_zero_flowers(): test_cases = [ [0, 0, 0, 0, 0] ] expected = [0] assert maximum_subarray_with_one_exclusion(test_cases) == expected","solution":"def maximum_subarray_with_one_exclusion(test_cases): results = [] for flowers in test_cases: n = len(flowers) if n == 1: results.append(flowers[0]) continue # Step 1: Calculate the maximum subarray sum using Kadane's Algorithm for array with no exclusion max_end_here = [0] * n max_end_here[0] = flowers[0] for i in range(1, n): max_end_here[i] = max(flowers[i], max_end_here[i-1] + flowers[i]) # Step 2: Calculate the maximum subarray sum for the array with one exclusion max_start_here = [0] * n max_start_here[n-1] = flowers[n-1] for i in range(n-2, -1, -1): max_start_here[i] = max(flowers[i], max_start_here[i+1] + flowers[i]) # Step 3: Find the maximum of the two scenarios max_sum = max(max_end_here) for i in range(1, n-1): max_sum = max(max_sum, max_end_here[i-1] + max_start_here[i+1]) results.append(max_sum) return results # Example usage for function def main(): T = int(input()) test_cases = [] for _ in range(T): n = int(input()) flowers = list(map(int, input().split())) test_cases.append(flowers) results = maximum_subarray_with_one_exclusion(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def max_prizes(n: int, beauty_scores: List[int], T: int) -> int: Determine the maximum number of prizes that can be distributed without exceeding the total beauty score T. Parameters: n (int): The number of prizes available. beauty_scores (List[int]): The beauty scores of the prizes. T (int): The maximum allowed total beauty score. Returns: int: The maximum number of prizes that can be distributed. >>> max_prizes(5, [10, 20, 30, 25, 15], 50) 3 >>> max_prizes(6, [5, 5, 5, 5, 5, 5], 20) 4","solution":"def max_prizes(n, beauty_scores, T): Returns the maximum number of prizes that can be distributed without exceeding the total beauty score T. # Sort the beauty scores from smallest to largest beauty_scores.sort() total_beauty = 0 max_prizes_count = 0 # Iterate through the sorted list and sum up until the limit T is reached for beauty in beauty_scores: if total_beauty + beauty <= T: total_beauty += beauty max_prizes_count += 1 else: break return max_prizes_count"},{"question":"from typing import List, Tuple def split_and_sort(nums: List[int]) -> Tuple[List[int], List[int]]: Splits a list of integers into two lists: - One containing odd numbers sorted in ascending order. - Another containing even numbers sorted in descending order. Returns a tuple of the two lists. >>> split_and_sort([4, 1, 7, 5, 6, 2, 3]) ([1, 3, 5, 7], [6, 4, 2]) >>> split_and_sort([10, 21, 2, 3, 5, 8]) ([3, 5, 21], [10, 8, 2]) >>> split_and_sort([4, 4, 4, 4]) ([], [4, 4, 4, 4]) >>> split_and_sort([1, 1, 1, 1]) ([1, 1, 1, 1], []) >>> split_and_sort([]) ([], []) >>> split_and_sort([3, 1, 2, 4, 7, 6, 5]) ([1, 3, 5, 7], [6, 4, 2]) >>> split_and_sort([1]) ([1], []) >>> split_and_sort([2]) ([], [2])","solution":"from typing import List, Tuple def split_and_sort(nums: List[int]) -> Tuple[List[int], List[int]]: Splits a list of integers into two lists: - One containing odd numbers sorted in ascending order. - Another containing even numbers sorted in descending order. Returns a tuple of the two lists. odd_numbers = [num for num in nums if num % 2 != 0] even_numbers = [num for num in nums if num % 2 == 0] odd_numbers.sort() even_numbers.sort(reverse=True) return odd_numbers, even_numbers"},{"question":"def longest_consecutive_subsequence(lst: List[int]) -> List[int]: Given a list of integers, return the longest consecutive subsequence of equal elements in that list. If there are multiple subsequences of the same maximum length, return the first one encountered. >>> longest_consecutive_subsequence([1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5]) == [4, 4, 4, 4] >>> longest_consecutive_subsequence([1, 1, 2, 2, 2, 3, 3, 1, 1, 1, 1]) == [1, 1, 1, 1] >>> longest_consecutive_subsequence([5, 5, 5, 2, 2, 3, 3, 3]) == [5, 5, 5] >>> longest_consecutive_subsequence([1]) == [1] >>> longest_consecutive_subsequence([]) == []","solution":"from typing import List def longest_consecutive_subsequence(lst: List[int]) -> List[int]: if not lst: return [] max_length = 0 max_subseq = [] current_subseq = [lst[0]] for i in range(1, len(lst)): if lst[i] == lst[i-1]: current_subseq.append(lst[i]) else: if len(current_subseq) > max_length: max_length = len(current_subseq) max_subseq = current_subseq current_subseq = [lst[i]] # Check the last subsequence if len(current_subseq) > max_length: max_subseq = current_subseq return max_subseq"},{"question":"def has_subarray_with_sum(arr, target_sum): Determines if there is a subarray with the given sum in the array. :param arr: List of integers :param target_sum: Target sum to be checked :return: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" >>> has_subarray_with_sum([1, 2, 3, 4, 5], 9) == \\"YES\\" >>> has_subarray_with_sum([1, -1, 5, -2], 2) == \\"YES\\" >>> has_subarray_with_sum([1, 2, 3, 4], 15) == \\"NO\\"","solution":"def has_subarray_with_sum(arr, target_sum): Determines if there is a subarray with the given sum in the array. :param arr: List of integers :param target_sum: Target sum to be checked :return: \\"YES\\" if such a subarray exists, otherwise \\"NO\\" current_sum = 0 sum_map = {} for num in arr: current_sum += num if current_sum == target_sum: return \\"YES\\" if current_sum - target_sum in sum_map: return \\"YES\\" sum_map[current_sum] = True return \\"NO\\""},{"question":"def process_queries(N, Q, A, queries): Process a series of queries on a given array. The function should handle reverse and find operations as follows: 1. Reverse a subarray: Given two indices \`l\` and \`r\` (1 ≤ l ≤ r ≤ N), reverse the subarray from \`l\` to \`r\`. 2. Find the \`k\`-th smallest element: Given two indices \`l\` and \`r\` (1 ≤ l ≤ r ≤ N) and an integer \`k\` (1 ≤ k ≤ r - l + 1), find the \`k\`-th smallest element in the subarray from \`l\` to \`r\`. Args: N (int): Length of the array. Q (int): Number of queries. A (List[int]): List of integers. queries (List[str]): List of queries in the specified format. Returns: List[int]: Output results from type 2 queries. Examples: >>> process_queries(6, 4, [5, 3, 8, 6, 2, 7], [\\"1 2 5\\", \\"2 1 6 3\\", \\"2 2 4 1\\", \\"1 3 6\\"]) [5, 2] >>> process_queries(5, 1, [1, 2, 3, 4, 5], [\\"2 1 5 3\\"]) [3] # Unit tests def test_process_queries(): # Test case 1 N = 6 Q = 4 A = [5, 3, 8, 6, 2, 7] queries = [\\"1 2 5\\", \\"2 1 6 3\\", \\"2 2 4 1\\", \\"1 3 6\\"] expected_output = [5, 2] assert process_queries(N, Q, A, queries) == expected_output # Test case 2: Single Type 2 Query N = 5 Q = 1 A = [1, 2, 3, 4, 5] queries = [\\"2 1 5 3\\"] expected_output = [3] assert process_queries(N, Q, A, queries) == expected_output # Test case 3: Reverse operation and then finding minimum N = 6 Q = 3 A = [9, 8, 7, 6, 5, 4] queries = [\\"1 1 6\\", \\"2 1 6 1\\", \\"2 1 6 6\\"] expected_output = [4, 9] assert process_queries(N, Q, A, queries) == expected_output # Test case 4: Multiple Reverses N = 6 Q = 3 A = [1, 2, 3, 4, 5, 6] queries = [\\"1 1 3\\", \\"1 4 6\\", \\"2 1 6 1\\"] expected_output = [1] assert process_queries(N, Q, A, queries) == expected_output # Test case 5: No operation N = 6 Q = 0 A = [1, 2, 3, 4, 5, 6] queries = [] expected_output = [] assert process_queries(N, Q, A, queries) == expected_output # Run tests test_process_queries()","solution":"def process_queries(N, Q, A, queries): results = [] for query in queries: parts = list(map(int, query.split())) if parts[0] == 1: l, r = parts[1] - 1, parts[2] - 1 A[l:r+1] = A[l:r+1][::-1] elif parts[0] == 2: l, r, k = parts[1] - 1, parts[2] - 1, parts[3] subarray = sorted(A[l:r+1]) results.append(subarray[k-1]) return results"},{"question":"def max_books_returned(n: int, deadlines: List[int]) -> int: Given the number of books and their respective return deadlines, return the maximum number of books that can be returned on their respective deadlines without any two books having the same return day. >>> max_books_returned(4, [2, 3, 2, 1]) 3 >>> max_books_returned(6, [9, 5, 5, 8, 7, 6]) 6 >>> max_books_returned(1, [1]) 1 >>> max_books_returned(5, [1, 1, 1, 1, 1]) 1 >>> max_books_returned(4, [10, 20, 30, 40]) 4 >>> max_books_returned(0, []) 0 >>> max_books_returned(8, [2, 2, 2, 3, 3, 4, 5, 5]) 5","solution":"def max_books_returned(n, deadlines): Given the number of books and their respective return deadlines, return the maximum number of books that can be returned on their respective deadlines without any two books having the same return day. if n == 0: return 0 deadlines.sort() max_books = 0 current_day = 0 for deadline in deadlines: if deadline > current_day: current_day += 1 max_books += 1 return max_books"},{"question":"class CircleQueue: def __init__(self, max_size: int): Initialize a Circle Queue with a given maximum size. Args: max_size (int): The maximum size of the Circle Queue. pass def enqueue(self, x: int): Adds element \`x\` to the queue. If the queue is already full, it overwrites the oldest element. Args: x (int): The element to be added to the queue. pass def dequeue(self): Removes the oldest element from the queue. Raises an error if the queue is empty. pass def get_elements(self): Returns a list of all current elements in the queue, starting from the oldest to the newest. Returns: List[int]: A list of elements in the queue. pass import pytest def test_enqueue_and_get_elements(): cq = CircleQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.enqueue(4) # This overwrites the first element (1) assert cq.get_elements() == [2, 3, 4] def test_enqueue_dequeue(): cq = CircleQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.dequeue() cq.enqueue(4) # The state should be [2, 3, 4] assert cq.get_elements() == [2, 3, 4] def test_get_elements_after_several_operations(): cq = CircleQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.enqueue(4) cq.dequeue() cq.enqueue(5) cq.enqueue(6) assert cq.get_elements() == [4, 5, 6] cq.dequeue() cq.dequeue() assert cq.get_elements() == [6] def test_dequeue_until_empty(): cq = CircleQueue(3) cq.enqueue(1) cq.enqueue(2) cq.enqueue(3) cq.dequeue() cq.dequeue() cq.dequeue() assert cq.get_elements() == [] def test_dequeue_from_empty_queue(): cq = CircleQueue(3) with pytest.raises(IndexError): cq.dequeue()","solution":"class CircleQueue: def __init__(self, max_size): self.max_size = max_size self.queue = [None] * max_size self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, x): if self.size == self.max_size: self.head = (self.head + 1) % self.max_size else: self.size += 1 self.queue[self.tail] = x self.tail = (self.tail + 1) % self.max_size def dequeue(self): if self.size == 0: raise IndexError(\\"dequeue from empty queue\\") self.queue[self.head] = None self.head = (self.head + 1) % self.max_size self.size -= 1 def get_elements(self): elements = [] for i in range(self.size): elements.append(self.queue[(self.head + i) % self.max_size]) return elements"},{"question":"from typing import List def countSubsets(arr: List[int], S: int) -> int: Given an array of integers and a target sum S, returns the total number of distinct subsets of the given array that add up to the target sum S. >>> countSubsets([2, 3, 5, 7], 10) 2 >>> countSubsets([1, 2, 3, 4, 5], 10) 3 >>> countSubsets([1, 2, 3], 10) 0 >>> countSubsets([10], 10) 1 >>> countSubsets([1, 2, 3, 4], 10) 1 >>> countSubsets([5, 5, 5, 5], 10) 1","solution":"from itertools import combinations def countSubsets(arr, S): Returns the number of distinct subsets that sum up to S. subsets = set() n = len(arr) # Generate all subsets using combinations and check their sums for r in range(1, n+1): for combo in combinations(arr, r): if sum(combo) == S: subsets.add(tuple(sorted(combo))) return len(subsets)"},{"question":"def rearrangeArray(arr): Rearranges the array such that the difference between consecutive elements is minimized by sorting the array in non-decreasing order. Args: arr (list): The list of integers to rearrange. Returns: list: The rearranged list. Examples: >>> rearrangeArray([3, 1, 6, 9, 2]) [1, 2, 3, 6, 9] >>> rearrangeArray([10, 20, 30, 40, 50]) [10, 20, 30, 40, 50]","solution":"def rearrangeArray(arr): Rearranges the array such that the difference between consecutive elements is minimized by sorting the array in non-decreasing order. Args: arr (list): The list of integers to rearrange. Returns: list: The rearranged list. return sorted(arr)"},{"question":"def max_subarray(array_str): Returns the maximum sum of a contiguous subarray and the subarray itself. Args: array_str (str): A single string of space-separated integers representing the array. Returns: tuple: A tuple containing the maximum sum as an integer and the subarray as a list of integers. Examples: >>> max_subarray(\\"1 -2 3 4 -1 2 1 -5 4\\") (9, [3, 4, -1, 2, 1]) >>> max_subarray(\\"-1\\") (-1, [-1]) >>> max_subarray(\\"7\\") (7, [7])","solution":"def max_subarray(array_str): Returns the maximum sum of a contiguous subarray and the subarray itself. nums = list(map(int, array_str.split())) max_sum = float('-inf') current_sum = 0 start = end = s = 0 for i in range(len(nums)): if current_sum <= 0: current_sum = nums[i] s = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start = s end = i return max_sum, nums[start:end+1]"},{"question":"def count_apple_trees(grid): Counts the number of cells that contain apple trees ('A') in a given grid. Parameters: grid (List[List[str]]): The MxN grid representing the orchard. Returns: int: The number of apple trees in the grid. pass def parse_input(input_string): Parses the input string to extract M, N, and the grid. Parameters: input_string (str): The raw input string. Returns: Tuple[int, int, List[List[str]]]: M, N and the grid. pass def main(input_string): M, N, grid = parse_input(input_string) return count_apple_trees(grid) def test_count_apple_trees(): grid = [ ['A', 'O', 'A'], ['D', 'A', 'O'], ['O', 'D', 'A'] ] assert count_apple_trees(grid) == 4 def test_parse_input(): input_string = \\"3 3nA O AnD A OnO D A\\" M, N, grid = parse_input(input_string) assert M == 3 assert N == 3 assert grid == [ ['A', 'O', 'A'], ['D', 'A', 'O'], ['O', 'D', 'A'] ] def test_main(): input_string = \\"3 3nA O AnD A OnO D A\\" assert main(input_string) == 4 def test_zero_apples(): input_string = \\"2 3nO O OnD D O\\" assert main(input_string) == 0 def test_all_apples(): input_string = \\"2 2nA AnA A\\" assert main(input_string) == 4 def test_mixed_trees_and_damaged(): input_string = \\"3 3nA O DnD A OnA D A\\" assert main(input_string) == 4 def test_single_cell_apple(): input_string = \\"1 1nA\\" assert main(input_string) == 1 def test_single_cell_non_apple(): input_string = \\"1 1nO\\" assert main(input_string) == 0","solution":"def count_apple_trees(grid): Counts the number of cells that contain apple trees ('A') in a given grid. Parameters: grid (List[List[str]]): The MxN grid representing the orchard. Returns: int: The number of apple trees in the grid. apple_count = 0 for row in grid: apple_count += row.count('A') return apple_count def parse_input(input_string): Parses the input string to extract M, N, and the grid. Parameters: input_string (str): The raw input string. Returns: Tuple[int, int, List[List[str]]]: M, N and the grid. lines = input_string.strip().split('n') M, N = map(int, lines[0].split()) grid = [line.split() for line in lines[1:]] return M, N, grid def main(input_string): M, N, grid = parse_input(input_string) return count_apple_trees(grid)"},{"question":"from typing import List, Tuple def find_fortress_island(N: int, M: int, bridges: List[Tuple[int, int]]) -> int: Determine the best suitable fortress island based on the given conditions. Args: N : int - Number of islands M : int - Number of bridges bridges : List[Tuple[int, int]] - List of tuples representing bridges between islands Returns: int - Identifier of the best suitable fortress island. pass def solve(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Solve the problem for multiple test cases. Args: T : int - Number of test cases test_cases : List[Tuple[Tuple[int, int], List[Tuple[int, int]]]] - List of test cases where each test case contains a tuple (N, M) and a list of bridges Returns: List[int] - List of identifiers of the best suitable fortress islands for each test case. pass def test_find_fortress_island(): assert find_fortress_island(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 1 assert find_fortress_island(4, 3, [(1, 2), (2, 3), (3, 4)]) == 2 assert find_fortress_island(2, 1, [(1, 2)]) == 1 assert find_fortress_island(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 3 def test_solve(): test_cases = [ ((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)]), ((4, 3), [(1, 2), (2, 3), (3, 4)]) ] assert solve(2, test_cases) == [1, 2] test_cases = [ ((2, 1), [(1, 2)]), ((3, 2), [(1, 2), (2, 3)]) ] assert solve(2, test_cases) == [1, 2]","solution":"from collections import deque, defaultdict def find_fortress_island(N, M, bridges): # Create graph from bridges graph = defaultdict(list) for A, B in bridges: graph[A].append(B) graph[B].append(A) def bfs(start): visited = [-1] * (N + 1) visited[start] = 0 queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 queue.append(neighbor) return visited min_max_distance = float('inf') best_island = 1 for island in range(1, N + 1): distances = bfs(island) max_distance = max(distances[1:]) # ignore index 0 as it is not used if max_distance < min_max_distance: min_max_distance = max_distance best_island = island elif max_distance == min_max_distance and island < best_island: best_island = island return best_island def solve(t, test_cases): results = [] for i in range(t): N, M = test_cases[i][0] bridges = test_cases[i][1] result = find_fortress_island(N, M, bridges) results.append(result) return results"},{"question":"def transform_text_bob_style(text: str) -> str: Transforms the text according to Bob's texting style where every odd word is in uppercase, and every even word is in lowercase. >>> transform_text_bob_style(\\"Hello world!\\") == \\"HELLO world!\\" >>> transform_text_bob_style(\\"How are you doing today, Bob?\\") == \\"HOW are YOU doing TODAY, bob?\\" >>> transform_text_bob_style(\\"Transform This Text Accordingly.\\") == \\"TRANSFORM this TEXT accordingly.\\"","solution":"def transform_text_bob_style(text): Transforms the text according to Bob's texting style where every odd word is in uppercase, and every even word is in lowercase. words = text.split(' ') for i in range(len(words)): if i % 2 == 0: # Odd words (0-based index makes odd words at even indices) words[i] = words[i].upper() else: # Even words words[i] = words[i].lower() return ' '.join(words)"},{"question":"def nearest_square(n: int) -> int: Returns the largest perfect square less than or equal to n. If n is less than 1, returns 0. >>> nearest_square(10) 9 >>> nearest_square(15) 9 >>> nearest_square(1) 1 >>> nearest_square(0) 0 >>> nearest_square(26) 25 >>> nearest_square(-5) 0 >>> nearest_square(1000) 961","solution":"def nearest_square(n: int) -> int: Returns the largest perfect square less than or equal to n. If n is less than 1, returns 0. if n < 1: return 0 # Find the largest integer whose square is less than or equal to n sqrt_n = int(n**0.5) return sqrt_n**2"},{"question":"def flatten_dict(d: dict, parent_key: str = '', sep: str = '.') -> dict: Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str, optional): The base key string for recursion. Default is ''. sep (str, optional): The separator to use for combining keys. Default is '.'. Returns: dict: A flattened dictionary. >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": {\\"e\\": 3}}, \\"f\\": {\\"g\\": 4}}) {\\"a\\": 1, \\"b.c\\": 2, \\"b.d.e\\": 3, \\"f.g\\": 4} >>> flatten_dict({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": [1, 2, 3]}, \\"e\\": (4, 5), \\"f\\": {\\"g\\": {\\"h\\": \\"hello\\"}}}) {\\"a\\": 1, \\"b.c\\": 2, \\"b.d\\": [1, 2, 3], \\"e\\": (4, 5), \\"f.g.h\\": \\"hello\\"}","solution":"def flatten_dict(d, parent_key='', sep='.'): Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key string for recursion. Default is ''. sep (str): The separator to use for combining keys. Default is '.'. Returns: dict: A flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dict(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"def process_queries(T: int, test_cases: list): Alicia gives you an array of integers and multiple queries to process and return results accordingly. >>> process_queries(1, [((5, 3), [1, 2, 3, 4, 5], [[1, 2, 10], [2, 2], [3, 1, 3]])]) [13, 19] >>> process_queries(2, [((4, 2), [5, 6, 7, 8], [[2, 1], [3, 0, 2]]), ((3, 3), [1, 2, 3], [[1, 0, 10], [2, 0], [3, 1, 2]])]) [6, 18, 11, 5] >>> process_queries(1, [((1, 1), [1000000000], [[2, 0]])]) [1000000000]","solution":"def process_queries(T, test_cases): results = [] for t in range(T): N, Q = test_cases[t][0] array = test_cases[t][1] queries = test_cases[t][2] for query in queries: if query[0] == 1: # Query type 1: add k to the i-th element i, k = query[1], query[2] array[i] += k elif query[0] == 2: # Query type 2: print the i-th element i = query[1] results.append(array[i]) elif query[0] == 3: # Query type 3: sum from i-th to j-th indices i, j = query[1], query[2] results.append(sum(array[i:j+1])) return results # Now parse the input and call the above function def main(input_lines): index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): N, Q = map(int, input_lines[index].split()) index += 1 array = list(map(int, input_lines[index].split())) index += 1 queries = [] for _ in range(Q): queries.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append(((N, Q), array, queries)) results = process_queries(T, test_cases) for result in results: print(result) # Example usage: input_lines = [ \\"1\\", \\"5 3\\", \\"1 2 3 4 5\\", \\"1 2 10\\", \\"2 2\\", \\"3 1 3\\" ] main(input_lines)"},{"question":"def gcd(x: int, y: int) -> int: Returns the greatest common divisor (GCD) of two integers x and y. >>> gcd(48, 18) 6 >>> gcd(21, 21) 21 >>> gcd(17, 13) 1 >>> gcd(100, 25) 25 >>> gcd(25, 100) 25 >>> gcd(100, 1) 1 >>> gcd(97, 97) 97 >>> gcd(1, 50) 1 >>> gcd(50, 1) 1 pass","solution":"def gcd(x, y): Returns the greatest common divisor of x and y. while y: x, y = y, x % y return x"},{"question":"def process_plant_growth(datasets): Calculate the plant ID with the maximum growth for each type of plant over multiple datasets. Args: datasets (list): A list of dataset dictionaries, each containing the number of days, types of plants, and plant data with IDs and recorded heights. Returns: list: A list of strings indicating the plant type, ID with maximum growth, and the amount of growth. If no growth is recorded, return \\"no growth\\" for that plant type. Example: >>> datasets = [ { \\"days\\": 2, \\"types\\": 2, \\"plant_data\\": { \\"rose\\": { \\"ID1\\": [10, 12, 14, 15], \\"ID2\\": [8, 10, 13] }, \\"tulip\\": { \\"ID3\\": [5, 9], \\"ID4\\": [10, 12, 15, 17], \\"ID5\\": [18, 20, 20] } } } ] >>> process_plant_growth(datasets) [\\"rose ID1 5\\", \\"tulip ID4 7\\"] Test Cases: >>> datasets = [ { \\"days\\": 2, \\"types\\": 2, \\"plant_data\\": { \\"rose\\": { \\"ID1\\": [10, 10, 10], \\"ID2\\": [8, 9, 9] }, \\"tulip\\": { \\"ID3\\": [5, 6], \\"ID4\\": [10, 11], \\"ID5\\": [18, 20] } } } ] >>> process_plant_growth(datasets) [\\"rose ID2 1\\", \\"tulip ID5 2\\"] >>> datasets = [ { \\"days\\": 2, \\"types\\": 2, \\"plant_data\\": { \\"rose\\": { \\"ID1\\": [10, 10], \\"ID2\\": [8, 8] }, \\"tulip\\": { \\"ID3\\": [5], \\"ID4\\": [10] } } } ] >>> process_plant_growth(datasets) [\\"rose no growth\\", \\"tulip no growth\\"]","solution":"def process_plant_growth(datasets): results = [] for dataset in datasets: d = dataset['days'] k = dataset['types'] plant_data = dataset['plant_data'] for plant_type, plants in plant_data.items(): max_growth = -float('inf') max_growth_id = \\"no growth\\" for plant_id, heights in plants.items(): if len(heights) < 2: continue growth = heights[-1] - heights[0] if growth > max_growth: max_growth = growth max_growth_id = plant_id if max_growth_id == \\"no growth\\" or max_growth <= 0: results.append(f\\"{plant_type} no growth\\") else: results.append(f\\"{plant_type} {max_growth_id} {max_growth}\\") return results"},{"question":"def max_distinct_characters(S: str) -> int: Returns the maximum number of different characters that can remain in the string S after performing the operation of removing adjacent same characters any number of times. >>> max_distinct_characters(\\"abbaca\\") 2 >>> max_distinct_characters(\\"aabbcc\\") 0 def solve(T: int, test_cases: List[str]) -> List[int]: Returns a list of the maximum number of distinct characters remaining in the strings after performing the operation of removing adjacent same characters any number of times. >>> solve(2, [\\"abbaca\\", \\"aabbcc\\"]) [2, 0] >>> solve(3, [\\"a\\", \\"ab\\", \\"aa\\"]) [1, 2, 0]","solution":"def max_distinct_characters(S): Returns the maximum number of different characters that can remain in the string S after performing the operation of removing adjacent same characters any number of times. stack = [] for char in S: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(set(stack)) def solve(T, test_cases): results = [] for S in test_cases: results.append(max_distinct_characters(S)) return results"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence that can be constructed from a given string. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest palindromic subsequence. Example: >>> longest_palindromic_subsequence(\\"abacdfg\\") 3 >>> longest_palindromic_subsequence(\\"aaaaa\\") 5","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence. n = len(s) dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the dp table for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"class NumMatrix: def __init__(self, matrix): Initialize your data structure here. pass def update(self, row, col, val): Update the element at (row, col) to val. pass def sumRegion(self, row1, col1, row2, col2): Return the sum of elements inside the rectangle defined by its upper-left corner (row1, col1) and lower-right corner (row2, col2). pass if __name__ == \\"__main__\\": matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] numMatrix = NumMatrix(matrix) print(numMatrix.sumRegion(2, 1, 4, 3)) # Output: 8 numMatrix.update(3, 2, 2) print(numMatrix.sumRegion(2, 1, 4, 3)) # Output: 10","solution":"class NumMatrix: def __init__(self, matrix): if not matrix: return self.matrix = matrix self.rows, self.cols = len(matrix), len(matrix[0]) self.tree = [[0] * (self.cols + 1) for _ in range(self.rows + 1)] self.nums = [[0] * self.cols for _ in range(self.rows)] for r in range(self.rows): for c in range(self.cols): self.update(r, c, matrix[r][c]) def update(self, row, col, val): delta = val - self.nums[row][col] self.nums[row][col] = val r, c = row + 1, col + 1 while r <= self.rows: cc = c while cc <= self.cols: self.tree[r][cc] += delta cc += (cc & -cc) r += (r & -r) def sumRegion(self, row1, col1, row2, col2): return self._sum(row2+1, col2+1) - self._sum(row1, col2+1) - self._sum(row2+1, col1) + self._sum(row1, col1) def _sum(self, row, col): result = 0 while row > 0: c = col while c > 0: result += self.tree[row][c] c -= (c & -c) row -= (row & -row) return result"},{"question":"def is_anagram(str1, str2): Write a function \`is_anagram\` that takes two strings \`str1\` and \`str2\` and returns a boolean indicating whether the two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example: If \`str1\` is \\"listen\\" and \`str2\` is \\"silent\\", the function should return True because both strings use the same letters. If \`str1\` is \\"hello\\" and \`str2\` is \\"billion\\", the function should return False because they do not contain the same letters. >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"hello\\", \\"billion\\") == False >>> is_anagram(\\"Listen\\", \\"Silent\\") == False >>> is_anagram(\\"conversation\\", \\"voices rant on\\") == False >>> is_anagram(\\"123abc\\", \\"abc123\\") == True >>> is_anagram(\\"\\", \\"\\") == True >>> is_anagram(\\"\\", \\"abc\\") == False >>> is_anagram(\\"aabbcc\\", \\"abcabc\\") == True","solution":"def is_anagram(str1, str2): Returns True if str1 and str2 are anagrams of each other, False otherwise. return sorted(str1) == sorted(str2)"},{"question":"def longest_increasing_subsequence_length(arr): Returns the length of the longest consecutive increasing subsequence in the list. >>> longest_increasing_subsequence_length([1, 2, 3, 2, 3, 4]) 3 >>> longest_increasing_subsequence_length([6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence_length([2, 2, 2, 2, 2]) 1 >>> longest_increasing_subsequence_length([1]) 1 >>> longest_increasing_subsequence_length([1, 2, 3, 4, 5, 6]) 6 >>> longest_increasing_subsequence_length([]) 0 >>> longest_increasing_subsequence_length([10, 20, 10, 30, 40, 50, 10, 20, 30, 40, 50]) 5 >>> longest_increasing_subsequence_length([3, 2, 6, 4, 5, 1, 6, 7, 8]) 4","solution":"def longest_increasing_subsequence_length(arr): Returns the length of the longest consecutive increasing subsequence in the list. if not arr: return 0 longest = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] > arr[i - 1]: current_length += 1 longest = max(longest, current_length) else: current_length = 1 return longest"},{"question":"def number_of_ways(n: int, m: int, L: int, R: int) -> int: Calculate the number of ways to initialize an n x m grid such that it is possible to make all cells have the same height using allowed operations. >>> number_of_ways(2, 2, 1, 3) 3 >>> number_of_ways(3, 3, 2, 3) 2 >>> number_of_ways(1, 1, 0, 0) 1 >>> number_of_ways(100, 100, 0, 100) 101 >>> number_of_ways(100, 100, 0, 1) 2 >>> number_of_ways(5, 5, -10, -5) 6 pass","solution":"def number_of_ways(n, m, L, R): MOD = 1000000 return (R - L + 1) % MOD"},{"question":"def order_weight(strng: str) -> str: Create a new string where the numbers are sorted by sum of digits and then lexicographically. >>> order_weight(\\"56 65 74 100 99 180 90\\") \\"100 180 90 56 65 74 99\\" >>> order_weight(\\"2000 10003 1234000 44444444 9999 11 11 22 123\\") \\"11 11 2000 10003 22 123 1234000 44444444 9999\\"","solution":"def order_weight(strng: str) -> str: def sum_digits(number: str) -> int: return sum(int(digit) for digit in number) weights = strng.split() # Sort by the sum of digits and then lexicographically sorted_weights = sorted(weights, key=lambda x: (sum_digits(x), x)) return ' '.join(sorted_weights)"},{"question":"def shortest_good_interval(S: str) -> int: Find the length of the shortest interval in S that contains at least one of each letter 'a', 'b', and 'c'. Parameters: S (str): Input string consisting of lowercase English letters. Returns: int: Length of the shortest good interval or -1 if no such interval exists. def process_test_cases(T: int, test_cases: list[str]) -> list[int]: Process multiple test cases to find the shortest good interval for each. Parameters: T (int): Number of test cases. test_cases (list of str): List of strings for each test case. Returns: list of int: List of results for each test case. import pytest def test_sample_cases(): assert process_test_cases(3, [\\"abac\\", \\"abcabc\\", \\"aaa\\"]) == [3, 3, -1] def test_edge_case_single_char(): assert process_test_cases(1, [\\"a\\"]) == [-1] assert process_test_cases(1, [\\"b\\"]) == [-1] assert process_test_cases(1, [\\"c\\"]) == [-1] def test_case_with_no_valid_substring(): assert process_test_cases(1, [\\"bbbbbbbb\\"]) == [-1] assert process_test_cases(1, [\\"abababab\\"]) == [-1] def test_case_with_minimum_valid_substring(): assert process_test_cases(1, [\\"abc\\"]) == [3] assert process_test_cases(1, [\\"bac\\"]) == [3] assert process_test_cases(1, [\\"cab\\"]) == [3] def test_case_with_varied_string_lengths(): assert process_test_cases(1, [\\"abcaabbcc\\"]) == [3] assert process_test_cases(1, [\\"aabbccabc\\"]) == [3] assert process_test_cases(1, [\\"aabbccaabbccabc\\"]) == [3] def test_large_input(): # a very long string with 'abc' only at the very end assert process_test_cases(1, [\\"a\\" * 99997 + \\"abc\\"]) == [3] # a very long string without 'abc' assert process_test_cases(1, [\\"a\\" * 100000]) == [-1] pytest.main()","solution":"def shortest_good_interval(S): Find the length of the shortest interval in S that contains at least one of each letter 'a', 'b', and 'c'. Parameters: S (str): Input string consisting of lowercase English letters. Returns: int: Length of the shortest good interval or -1 if no such interval exists. n = len(S) min_length = float('inf') left = 0 count = {'a': 0, 'b': 0, 'c': 0} for right in range(n): if S[right] in count: count[S[right]] += 1 while all(count[char] > 0 for char in 'abc'): min_length = min(min_length, right - left + 1) if S[left] in count: count[S[left]] -= 1 left += 1 return min_length if min_length != float('inf') else -1 def process_test_cases(T, test_cases): Process multiple test cases to find the shortest good interval for each. Parameters: T (int): Number of test cases. test_cases (list of str): List of strings for each test case. Returns: list of int: List of results for each test case. results = [] for S in test_cases: results.append(shortest_good_interval(S)) return results"},{"question":"def collect_apples(n: int, apple_values: List[int], edges: List[int]) -> List[int]: Calculate the maximum value of apples the king can collect if he starts picking from each possible node. Args: n : int : number of nodes apple_values : List[int] : values of apples in the nodes edges : List[int] : indicating the direct edge from node i to node bi, or bi is zero if node i has no outgoing edge Returns: List[int] : list of maximum values of apples collected starting from each node. Examples: >>> collect_apples(4, [4, 2, 3, 1], [2, 3, 4, 0]) [10, 6, 4, 1] >>> collect_apples(5, [1, 0, 4, 2, 8], [0, 0, 0, 5, 0]) [1, 0, 4, 10, 8] >>> collect_apples(1, [10], [0]) [10] >>> collect_apples(3, [5, 6, 7], [0, 0, 0]) [5, 6, 7] >>> collect_apples(4, [0, 0, 0, 0], [2, 3, 4, 0]) [0, 0, 0, 0]","solution":"def collect_apples(n, apple_values, edges): # Convert edges to a zero-indexed array for easier handling edges = [b - 1 for b in edges] # Create a memoization array to store the max value for each start node max_values = [-1] * n def dfs(node): if max_values[node] != -1: return max_values[node] next_node = edges[node] collected = apple_values[node] if next_node != -1: collected += dfs(next_node) max_values[node] = collected return collected # Compute the maximum values for each starting node for i in range(n): if max_values[i] == -1: dfs(i) return max_values # Usage example: n = 4 apple_values = [4, 2, 3, 1] edges = [2, 3, 4, 0] print(collect_apples(n, apple_values, edges)) # Output: [10, 6, 4, 1]"},{"question":"def process_commands(n: int, m: int, tuples_list: List[Tuple[int, ...]], q: int, commands: List[str]) -> List[str]: Process a series of commands to update and query an initial list of tuples. >>> process_commands(3, 4, [(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)], 5, ['QUERY 1', 'UPDATE 1 2 20', 'QUERY 1', 'UPDATE 3 4 40', 'QUERY 3']) ['1 2 3 4', '1 20 3 4', '9 10 11 40'] >>> process_commands(2, 3, [(10, 20, 30), (40, 50, 60)], 4, ['QUERY 1', 'UPDATE 2 3 99', 'UPDATE 1 1 7', 'QUERY 1']) ['10 20 30', '7 20 30'] import doctest doctest.testmod()","solution":"def process_commands(n, m, tuples_list, q, commands): # Convert tuple list from list of tuples to list of lists for mutability mutable_tuples = [list(tup) for tup in tuples_list] results = [] for command in commands: parts = command.split() if parts[0] == 'UPDATE': t = int(parts[1]) - 1 # decrement to adjust for 0-based indexing p = int(parts[2]) - 1 # decrement to adjust for 0-based indexing v = int(parts[3]) mutable_tuples[t][p] = v elif parts[0] == 'QUERY': t = int(parts[1]) - 1 # decrement to adjust for 0-based indexing results.append(' '.join(map(str, mutable_tuples[t]))) return results"},{"question":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([3, -2, 5, -1]) 6 >>> max_subarray_sum([8]) 8 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray using Kadane's Algorithm. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global # Example usage: # nums = [-2, -3, 4, -1, -2, 1, 5, -3] # print(max_subarray_sum(nums)) # Output: 7"},{"question":"def count_groups(n, k, times): Counts the number of groups of messages based on the similarity threshold k. :param n: int - the number of messages :param k: int - the similarity threshold :param times: list of int - the times the messages were sent, sorted in non-decreasing order :return: int - the number of groups formed >>> count_groups(5, 2, [1, 2, 3, 4, 7]) == 2 >>> count_groups(6, 0, [1, 3, 5, 7, 9, 11]) == 6 >>> count_groups(0, 1, []) == 0 >>> count_groups(1, 1, [1]) == 1 >>> count_groups(1, 100, [50]) == 1 >>> count_groups(5, 100, [10, 20, 30, 40, 50]) == 1 >>> count_groups(5, 1, [10, 20, 30, 40, 50]) == 5 >>> count_groups(6, 1, [1, 2, 4, 5, 7, 8]) == 3 >>> count_groups(3, 0, [2, 2, 2]) == 1 >>> count_groups(4, 1, [2, 2, 2, 2]) == 1 >>> count_groups(4, 1000000000, [10, 20, 30, 40]) == 1 >>> count_groups(5, 1, [1, 3, 5, 7, 9]) == 5 >>> count_groups(5, 1, [1, 2, 4, 5, 7]) == 3","solution":"def count_groups(n, k, times): Counts the number of groups of messages based on the similarity threshold k. :param n: int - the number of messages :param k: int - the similarity threshold :param times: list of int - the times the messages were sent, sorted in non-decreasing order :return: int - the number of groups formed if n == 0: return 0 group_count = 1 prev_time = times[0] for i in range(1, n): if times[i] - prev_time > k: group_count += 1 prev_time = times[i] else: prev_time = max(prev_time, times[i]) return group_count"},{"question":"def generate_nth_resonant_string(n: int) -> str: Generates the N-th lexicographically smallest resonant string. >>> generate_nth_resonant_string(1) == \\"abb\\" >>> generate_nth_resonant_string(2) == \\"abbabb\\" >>> generate_nth_resonant_string(3) == \\"abbabbabb\\"","solution":"def generate_nth_resonant_string(n): Generates the N-th lexicographically smallest resonant string. result = [] while n: result.append(\\"abb\\") n -= 1 return ''.join(result)"},{"question":"def longest_common_substring_length(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. Args: s1: First input string. s2: Second input string. Returns: The length of the longest common substring. Examples: >>> longest_common_substring_length(\\"ABCDE\\", \\"BCDFE\\") 3 >>> longest_common_substring_length(\\"HELLO\\", \\"WORLD\\") 1 # Your code here. pass","solution":"def longest_common_substring_length(s1, s2): Returns the length of the longest common substring between s1 and s2. if not s1 or not s2: return 0 m = len(s1) n = len(s2) # Create a 2D array to store lengths of longest common suffixes. dp = [[0] * (n + 1) for _ in range(m + 1)] # Length of the longest common substring max_length = 0 # Build dp table and compute max_length for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_length = max(max_length, dp[i][j]) else: dp[i][j] = 0 return max_length"},{"question":"def checkDifference(nums: List[int], k: int) -> bool: Returns True if there exist two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is exactly k. Otherwise, returns False. >>> checkDifference([1, 9, 5, 3, 7], 4) True >>> checkDifference([4, 7, 2, 3, 9], 10) False","solution":"def checkDifference(nums, k): Returns True if there exist two distinct indices i and j in nums such that the absolute difference between nums[i] and nums[j] is exactly k. Otherwise, returns False. seen = set() for num in nums: if (num + k) in seen or (num - k) in seen: return True seen.add(num) return False"},{"question":"def count_above_average(scores: List[int]) -> int: Returns the count of students who scored above average. >>> count_above_average([50, 50, 50, 50]) == 0 >>> count_above_average([40, 50, 60, 70]) == 2 >>> count_above_average([10, 20, 30, 40]) == 2 >>> count_above_average([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 5 >>> count_above_average([75]) == 0 >>> count_above_average([0]) == 0 >>> count_above_average([100]) == 0 >>> count_above_average([70, 70, 70, 100, 100, 100]) == 3","solution":"def count_above_average(scores): Returns the count of students with scores above the average score. Parameters: scores (list of int): List of student scores where each score is an integer. Returns: int: Count of students scoring above average. average_score = sum(scores) / len(scores) count = sum(1 for score in scores if score > average_score) return count"},{"question":"import heapq from typing import List def min_merge_cost(n: int, costs: List[int]) -> int: Computes the minimum cost required to merge all batches into one. >>> min_merge_cost(4, [4, 6, 8, 12]) 58 >>> min_merge_cost(3, [1, 2, 3]) 9 >>> min_merge_cost(1, [5]) 0 >>> min_merge_cost(2, [5, 10]) 15 >>> min_merge_cost(5, [1, 2, 3, 4, 5]) 33 >>> min_merge_cost(4, [5, 5, 5, 5]) 40","solution":"import heapq def min_merge_cost(n, costs): Computes the minimum cost required to merge all batches into one. Parameters: n (int): The number of batches. costs (list of int): The production cost of each batch. Returns: int: The minimum total cost required to merge all batches. if n == 1: return 0 # No cost if there's only one batch # Use a min-heap to efficiently get the minimum cost batches to merge heapq.heapify(costs) total_cost = 0 while len(costs) > 1: # Pop the two smallest elements first = heapq.heappop(costs) second = heapq.heappop(costs) # Merge them merge_cost = first + second total_cost += merge_cost # Push the merged batch back to the heap heapq.heappush(costs, merge_cost) return total_cost"},{"question":"from typing import List def min_steps_to_reach_end(n: int, m: int, grid: List[List[int]]) -> int: Consider an island represented by a 2D grid where \`1\` represents land and \`0\` represents water. You are initially on land at the top-left corner of the grid. You are free to move up, down, left, or right (not diagonally) and you cannot move beyond the grid boundaries. Your task is to determine the minimum number of steps required to reach the bottom-right corner of the grid. If it is not possible to reach the bottom-right corner, return -1. Args: n: Integer, number of rows in the grid. m: Integer, number of columns in the grid. grid: 2D list of integers representing the grid. Returns: Integer, minimum number of steps to reach the bottom-right corner or -1 if impossible. Examples: >>> min_steps_to_reach_end(3, 3, [[1, 1, 0], [0, 1, 1], [1, 1, 1]]) 4 >>> min_steps_to_reach_end(3, 3, [[1, 0, 0], [0, 1, 1], [1, 0, 1]]) -1 >>> min_steps_to_reach_end(1, 1, [[1]]) 0","solution":"from collections import deque def min_steps_to_reach_end(n, m, grid): if grid[0][0] == 0 or grid[n-1][m-1] == 0: return -1 # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() # If we've reached the bottom-right corner if (r, c) == (n-1, m-1): return steps # Explore all possible movements for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and grid[nr][nc] == 1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 # Example usage: # n, m = 3, 3 # grid = [ # [1, 1, 0], # [0, 1, 1], # [1, 1, 1] # ] # print(min_steps_to_reach_end(n, m, grid)) # Output: 4"},{"question":"def find_smallest_missing_nonnegative(arr): Returns the smallest non-negative integer not present in the array. >>> find_smallest_missing_nonnegative([3, 4, -1, 1]) == 0 >>> find_smallest_missing_nonnegative([0, 1, 2, 3]) == 4 >>> find_smallest_missing_nonnegative([-5, -10, 2, 1, 0]) == 3","solution":"def find_smallest_missing_nonnegative(arr): Returns the smallest non-negative integer not present in the array. num_set = set() # Add all non-negative integers from the array to the set for num in arr: if num >= 0: num_set.add(num) # Find the smallest non-negative integer not in the set i = 0 while True: if i not in num_set: return i i += 1"},{"question":"def returnsToOrigin(moves: str) -> bool: Determines if the robot returns to the origin (0, 0) after a sequence of moves. Parameters: moves (string): a string representing the sequence of moves made by the robot Returns: boolean: True if the robot returns to the origin, False otherwise >>> returnsToOrigin(\\"UDLR\\") True >>> returnsToOrigin(\\"UUDL\\") False >>> returnsToOrigin(\\"UUDDLRLR\\") True >>> returnsToOrigin(\\"\\") True >>> returnsToOrigin(\\"U\\") False >>> returnsToOrigin(\\"D\\") False >>> returnsToOrigin(\\"L\\") False >>> returnsToOrigin(\\"R\\") False >>> returnsToOrigin(\\"UUDD\\") True >>> returnsToOrigin(\\"LLRR\\") True >>> returnsToOrigin(\\"UUDDLLRR\\") True","solution":"def returnsToOrigin(moves): Determines if the robot returns to the origin (0, 0) after a sequence of moves. Parameters: moves (string): a string representing the sequence of moves made by the robot Returns: boolean: True if the robot returns to the origin, False otherwise x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def plant_heights(datasets): Tom is a gardener who is taking care of a very special garden containing n plants. Each plant grows according to its own unique pattern. For each plant, you are given its initial height and its growth rate per day. Tom wants to know the height of each plant on a specific day in the future. Input: datasets (List): A list of datasets where each dataset is a list in the following format: [n, [h1, g1], [h2, g2], ..., [hn, gn], d] n : number of plants hi: initial height of plant i gi: growth rate of plant i d : number of days Output: List: A list of lists where each inner list contains the heights of the plants after d days. >>> datasets = [ ... [3, [10, 2], [15, 1], [20, 0], 5], ... [2, [8, 3], [10, 1], 25], ... [1, [5, 0], 2] ... ] >>> plant_heights(datasets) [[20, 20, 20], [83, 35], [5]]","solution":"def plant_heights(datasets): results = [] for dataset in datasets: n = dataset[0] plants = dataset[1:n+1] d = dataset[n+1] heights = [h + g * d for h, g in plants] results.append(heights) return results"},{"question":"def process_transactions(N, M, transactions): Processes M transactions for N accounts and returns the final amounts for each account. Args: N (int): The number of accounts. M (int): The number of transactions. transactions (list of tuples): Each tuple contains (account, amount). Returns: list: A list of final amounts for each account. pass if __name__ == \\"__main__\\": N, M = map(int, input().split()) transactions = [tuple(map(int, input().split())) for _ in range(M)] result = process_transactions(N, M, transactions) for value in result: print(value)","solution":"def process_transactions(N, M, transactions): Processes M transactions for N accounts and returns the final amounts for each account. Args: N (int): The number of accounts. M (int): The number of transactions. transactions (list of tuples): Each tuple contains (account, amount). Returns: list: A list of final amounts for each account. # Initialize the accounts with zeros account_balances = [0] * N # Process each transaction for a, b in transactions: account_balances[a - 1] += b return account_balances"},{"question":"def mostFrequentCharacterFrequency(s: str) -> int: Determines the frequency of the most frequently occurring character in the string. Args: s (str): a string of lowercase alphabets. Returns: int: the frequency of the most frequent character. >>> mostFrequentCharacterFrequency(\\"abacabad\\") 4 >>> mostFrequentCharacterFrequency(\\"abcdefghijklmnopqrstuvwxyz\\") 1 >>> mostFrequentCharacterFrequency(\\"aaaaaa\\") 6 >>> mostFrequentCharacterFrequency(\\"aabb\\") 2 >>> mostFrequentCharacterFrequency(\\"a\\" * 100000) 100000","solution":"def mostFrequentCharacterFrequency(s): Returns the frequency of the most frequent character in the string s. from collections import Counter # Use Counter to get the frequency of each character frequency = Counter(s) # Find and return the maximum value in the frequency dictionary return max(frequency.values())"},{"question":"def lru_cache(operations: List[str], cache_size: int) -> List[str]: Implements an LRU cache that processes a list of operations. Parameters: operations (list of str): List of \\"GET <key>\\" and \\"SET <key> <value>\\" operations. cache_size (int): Maximum size of the cache. Returns: list of str: Results of the \\"GET\\" operations. >>> lru_cache([\\"SET 1 10\\", \\"SET 2 20\\", \\"GET 1\\", \\"SET 3 30\\", \\"GET 2\\", \\"SET 4 40\\", \\"GET 3\\"], 2) [\\"10\\", \\"-1\\", \\"30\\"] >>> lru_cache([\\"SET 1 10\\", \\"GET 1\\", \\"SET 2 20\\", \\"GET 1\\", \\"SET 3 30\\", \\"GET 2\\", \\"GET 3\\"], 1) [\\"10\\", \\"-1\\", \\"-1\\", \\"30\\"]","solution":"from collections import OrderedDict def lru_cache(operations, cache_size): Implements an LRU cache that processes a list of operations. Parameters: operations (list of str): List of \\"GET <key>\\" and \\"SET <key> <value>\\" operations. cache_size (int): Maximum size of the cache. Returns: list of str: Results of the \\"GET\\" operations. cache = OrderedDict() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"SET\\": key, value = parts[1], parts[2] if key in cache: cache.move_to_end(key) cache[key] = value if len(cache) > cache_size: cache.popitem(last=False) elif parts[0] == \\"GET\\": key = parts[1] if key in cache: cache.move_to_end(key) results.append(cache[key]) else: results.append(\\"-1\\") return results"},{"question":"def organize_stamps(n: int, rarity_levels: List[int]) -> Tuple[int, List[int]]: Organize the stamps by rarity levels and determine the number of unique rarity levels. >>> organize_stamps(5, [4, 2, 3, 2, 4]) (3, [2, 2, 3, 4, 4]) >>> organize_stamps(7, [1000, 999, 1000, 500, 500, 500, 1000]) (3, [500, 500, 500, 999, 1000, 1000, 1000]) >>> organize_stamps(4, [1, 1, 1, 1]) (1, [1, 1, 1, 1]) >>> organize_stamps(4, [4, 3, 2, 1]) (4, [1, 2, 3, 4]) >>> organize_stamps(5, [1000, 1, 999, 1000, 2]) (4, [1, 2, 999, 1000, 1000])","solution":"def organize_stamps(n, rarity_levels): # Count the occurrence and maintain the sorted order sorted_list = sorted(rarity_levels) unique_rarities = len(set(sorted_list)) return unique_rarities, sorted_list"},{"question":"def fibonacci_series(n): Generates the first \`n\` numbers in the Fibonacci sequence. Args: n (int): The number of terms to generate. Returns: List[int]: A list containing the first \`n\` Fibonacci numbers. Examples: >>> fibonacci_series(1) [0] >>> fibonacci_series(2) [0, 1] >>> fibonacci_series(5) [0, 1, 1, 2, 3] >>> fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci_series(n): Generates the first \`n\` numbers in the Fibonacci sequence. Args: n (int): The number of terms to generate. Returns: List[int]: A list containing the first \`n\` Fibonacci numbers. if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def count_distinct_groups(n: int, m: int, pairs: List[Tuple[int, int]]) -> int: Determine the number of distinct groups of creatures. >>> count_distinct_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> count_distinct_groups(4, 0, []) 4 >>> count_distinct_groups(4, 3, [(1, 2), (2, 3), (3, 4)]) 1 >>> count_distinct_groups(6, 3, [(1, 2), (3, 4), (5, 6)]) 3 >>> count_distinct_groups(3, 3, [(1, 1), (2, 3), (3, 2)]) 2 >>> count_distinct_groups(1, 0, []) 1 from typing import List, Tuple def test_example_case(): assert count_distinct_groups(5, 3, [(1, 2), (2, 3), (4, 5)]) == 2 def test_no_connections(): assert count_distinct_groups(4, 0, []) == 4 def test_all_connected(): assert count_distinct_groups(4, 3, [(1, 2), (2, 3), (3, 4)]) == 1 def test_multiple_groups(): assert count_distinct_groups(6, 3, [(1, 2), (3, 4), (5, 6)]) == 3 def test_self_loop(): assert count_distinct_groups(3, 3, [(1, 1), (2, 3), (3, 2)]) == 2 def test_single_node(): assert count_distinct_groups(1, 0, []) == 1","solution":"from collections import defaultdict, deque def count_distinct_groups(n, m, pairs): def bfs(start, graph, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Create the adjacency list for the graph graph = defaultdict(list) for u, v in pairs: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) group_count = 0 # Traverse each node and use BFS to mark all reachable nodes for i in range(1, n + 1): if not visited[i]: bfs(i, graph, visited) group_count += 1 return group_count"},{"question":"def min_groups(n: int, speeds: List[int], t: int) -> int: Determine the minimum number of groups required to accommodate all participants such that the fastest and the slowest runners in any group do not differ in their speeds by more than the given threshold value. Parameters: n (int): The number of participants. speeds (List[int]): The running speeds of participants. t (int): The maximum allowed difference in speed within any group. Returns: int: The minimum number of groups needed. >>> min_groups(5, [2, 3, 10, 11, 8], 2) 3 >>> min_groups(1, [5], 5) 1 >>> min_groups(4, [1, 2, 3, 4], 3) 1 >>> min_groups(5, [1, 5, 10, 15, 20], 1) 5 >>> min_groups(6, [1, 2, 2, 3, 4, 6], 2) 2","solution":"def min_groups(n, speeds, t): Given the number of participants and their running speeds along with a threshold, this function calculates the minimum number of groups such that the difference in running speeds within any group does not exceed the threshold. speeds.sort() groups = 0 i = 0 while i < n: groups += 1 start_speed = speeds[i] while i < n and speeds[i] - start_speed <= t: i += 1 return groups"},{"question":"def minimumBoatRuns(weights: List[int], capacity: int) -> int: Calculate the minimum number of runs required to rescue everyone given their weights and the boat's capacity. >>> minimumBoatRuns([50, 50, 70, 80], 100) 3 >>> minimumBoatRuns([60, 60, 60, 60], 120) 2 >>> minimumBoatRuns([75], 100) 1 >>> minimumBoatRuns([50, 50, 50, 50], 100) 2 >>> minimumBoatRuns([100, 200, 150, 80, 120], 300) 3 >>> minimumBoatRuns([80, 50, 70, 50], 100) 3 >>> minimumBoatRuns([60, 70, 80, 90], 100) 4 >>> minimumBoatRuns([50, 50, 50, 50, 50, 50], 100) 3","solution":"def minimumBoatRuns(weights, capacity): weights.sort() i, j = 0, len(weights) - 1 runs = 0 while i <= j: if weights[i] + weights[j] <= capacity: i += 1 j -= 1 runs += 1 return runs"},{"question":"def can_order_students(scores): Returns \\"yes\\" if the students can be ordered such that for each student 1 ≤ i ≤ 2, the i+1-th student is strictly better than the i-th student, otherwise returns \\"no\\". >>> can_order_students([[50, 60, 70], [60, 70, 80], [70, 80, 90]]) \\"yes\\" >>> can_order_students([[90, 80, 70], [80, 90, 60], [70, 60, 50]]) \\"no\\" def check_groups(T, groups_scores): Checks for each group of students if they can be ordered such that for each student 1 ≤ i ≤ 2, the i+1-th student is strictly better than the i-th student. >>> check_groups(2, [[[50, 60, 70], [60, 70, 80], [70, 80, 90]], [[90, 80, 70], [80, 90, 60], [70, 60, 50]]]) [\\"yes\\", \\"no\\"]","solution":"def can_order_students(scores): Returns \\"yes\\" if the students can be ordered such that for each student 1 ≤ i ≤ 2, the i+1-th student is strictly better than the i-th student, otherwise returns \\"no\\". scores.sort() # Check if we can find an ordering for i in range(2): if not (scores[i][0] <= scores[i+1][0] and scores[i][1] <= scores[i+1][1] and scores[i][2] <= scores[i+1][2] and (scores[i][0] < scores[i+1][0] or scores[i][1] < scores[i+1][1] or scores[i][2] < scores[i+1][2])): return \\"no\\" return \\"yes\\" def check_groups(T, groups_scores): results = [] for scores in groups_scores: results.append(can_order_students(scores)) return results"},{"question":"def is_path_possible(N, grid): Determines if there is a path from the top-left to the bottom-right corner of the grid avoiding obstacles. >>> is_path_possible(4, [[0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0], [1, 1, 0, 0]]) \\"YES\\" >>> is_path_possible(3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) \\"NO\\"","solution":"def is_path_possible(N, grid): from collections import deque # Directions for right and down directions = [(0, 1), (1, 0)] # BFS initialization queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we reach the bottom-right corner if x == N-1 and y == N-1: return \\"YES\\" # Add neighbors (right and down) to the queue for dx, dy in directions: nx, ny = x + dx, y + dy # Check if the neighbor is within bounds and is a free cell if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) # If we exhaust all possible cells without reaching bottom-right return \\"NO\\""},{"question":"from typing import List, Tuple def largest_stock_change(prices: List[Tuple[str, float]]) -> Tuple[str, float]: Calculates the largest change in stock price from one day to the next. Parameters: - prices: List of tuples, each containing a date (string in 'YYYY-MM-DD' format) and a stock price (float). Returns: - A tuple containing the date when the largest change occurred (string) and the change in stock price (float). Examples: >>> prices = [ ... ('2023-01-01', 100.5), ... ('2023-01-02', 102.0), ... ('2023-01-03', 101.0), ... ('2023-01-04', 103.5), ... ] >>> largest_stock_change(prices) ('2023-01-03', 2.5) >>> prices = [] >>> largest_stock_change(prices) (\\"\\", 0.0)","solution":"from typing import List, Tuple def largest_stock_change(prices: List[Tuple[str, float]]) -> Tuple[str, float]: Calculates the largest change in stock price from one day to the next. Parameters: - prices: List of tuples, each containing a date (string in 'YYYY-MM-DD' format) and a stock price (float). Returns: - A tuple containing the date when the largest change occurred (string) and the change in stock price (float). if len(prices) < 2: return (\\"\\", 0.0) largest_change = 0.0 date_of_largest_change = \\"\\" for i in range(1, len(prices)): current_date, current_price = prices[i] previous_date, previous_price = prices[i-1] change = current_price - previous_price if abs(change) > abs(largest_change): largest_change = change date_of_largest_change = previous_date return (date_of_largest_change, largest_change)"},{"question":"def pascalTriangle(M: int) -> List[List[int]]: Generates Pascal's Triangle up to M rows. Parameters: M (int): number of rows to be generated Returns: List[List[int]]: Pascal's Triangle as a list of lists Examples: >>> pascalTriangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> pascalTriangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]","solution":"def pascalTriangle(M): Generates Pascal's Triangle up to M rows. Parameters: M (int): number of rows to be generated Returns: List[List[int]]: Pascal's Triangle as a list of lists if M < 1: return [] triangle = [[1]] for i in range(1, M): prev_row = triangle[-1] current_row = [1] for j in range(1, i): current_row.append(prev_row[j-1] + prev_row[j]) current_row.append(1) triangle.append(current_row) return triangle"},{"question":"def rearrange_string(n: int, k: int, s: str) -> str: Rearrange the string such that the number of distinct characters in any substring of length k is minimized. Args: - n (int): Length of the string. - k (int): Length of the substring. - s (str): The input string consisting of lowercase English letters. Returns: - str: The rearranged string. >>> rearrange_string(6, 3, \\"aabbcc\\") 'abcabc' >>> rearrange_string(4, 2, \\"aabb\\") 'abab' >>> rearrange_string(9, 3, \\"aaabbbccc\\") 'abcabcabc' >>> rearrange_string(5, 2, \\"aaaaa\\") 'aaaaa' >>> rearrange_string(6, 6, \\"abcdef\\") 'abcdef'","solution":"from collections import Counter def rearrange_string(n, k, s): Rearrange the string such that the number of distinct characters in any substring of length k is minimized. # Count the frequency of each character in the string char_count = Counter(s) # Create the rearranged result result = [] # Create a list of characters sorted by frequency (most frequent first) sorted_chars = sorted(char_count.keys(), key=lambda x: -char_count[x]) # Initialize buckets for each k segment buckets = [[] for _ in range(k)] # Distribute characters to buckets as evenly as possible idx = 0 for char in sorted_chars: count = char_count[char] while count > 0: buckets[idx % k].append(char) idx += 1 count -= 1 for bucket in buckets: result.extend(bucket) return ''.join(result)"},{"question":"def min_cost_for_equal_tree_heights(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum cost required to make all remaining trees of the same height or leave no trees at all. :param t: Number of test cases :param test_cases: List of test cases where each test case is a tuple containing an integer n (number of trees) and a list of integers (heights of trees) :return: List of integers representing the minimum cost for each test case to make all remaining trees of the same height or leave no trees at all. >>> min_cost_for_equal_tree_heights(4, [(3, [2, 2, 3]), (4, [1, 3, 3, 2]), (5, [4, 5, 5, 5, 6]), (2, [1, 1000000000])]) [1, 2, 2, 1] >>> min_cost_for_equal_tree_heights(1, [(3, [1, 1, 1])]) [0] >>> min_cost_for_equal_tree_heights(1, [(4, [1, 2, 2, 3])]) [2] >>> min_cost_for_equal_tree_heights(1, [(3, [1000000000, 1000000000, 1])]) [1]","solution":"def min_cost_for_equal_tree_heights(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] heights = test_cases[i][1] # Dictionary to count the frequency of each tree height height_count = {} for h in heights: if h in height_count: height_count[h] += 1 else: height_count[h] = 1 # Find the height with the maximum frequency max_freq = max(height_count.values()) # Calculate the total number of trees total_trees = len(heights) # Minimum cost to remove all trees except those with the max frequency height min_cost = total_trees - max_freq results.append(min_cost) return results"},{"question":"def solve(T: int, cases: List[Tuple[int, List[str]]]) -> List[str]: Determine if there is a way to go from the top-left corner of the grid to the bottom-right corner by moving only right or down through empty cells. >>> solve(2, [ (3, [\\"..#\\", \\".#.\\", \\"...\\"]), (4, [\\"....\\", \\"..#.\\", \\".#..\\", \\"...#\\"]) ]) [\\"YES\\", \\"NO\\"] >>> solve(1, [ (3, [\\"...\\", \\"...\\", \\"...\\"]) ]) [\\"YES\\"] >>> solve(1, [ (2, [\\".#\\", \\"#.\\"]) ]) [\\"NO\\"] >>> solve(1, [ (2, [\\"..\\", \\"..\\"]) ]) [\\"YES\\"] >>> solve(1, [ (3, [\\"...\\", \\".#.\\", \\"...\\"]) ]) [\\"YES\\"] >>> solve(1, [ (2, [\\"\\", \\"\\"]) ]) [\\"NO\\"]","solution":"def is_path_exists(grid): N = len(grid) visited = [[False] * N for _ in range(N)] def dfs(x, y): # If out of bounds or cell is an obstacle or already visited, return False if x < 0 or y < 0 or x >= N or y >= N or grid[x][y] == '#' or visited[x][y]: return False # If we reached the bottom-right corner, return True if x == N - 1 and y == N - 1: return True # Mark this cell as visited visited[x][y] = True # Move right or down if dfs(x + 1, y) or dfs(x, y + 1): return True return False return dfs(0, 0) def solve(T, cases): results = [] for case in cases: N, grid = case if is_path_exists(grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_removals_to_unique_chars(t: int, strings: List[str]) -> List[int]: Determine the minimum number of characters that need to be removed to make all characters unique in each string. >>> min_removals_to_unique_chars(2, [\\"aabbcc\\", \\"abc\\"]) [3, 0] >>> min_removals_to_unique_chars(1, [\\"aaaa\\"]) [3]","solution":"def min_removals_to_unique_chars(t, strings): results = [] for s in strings: freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 removals = sum(count - 1 for count in freq.values() if count > 1) results.append(removals) return results"},{"question":"def single_number(nums): Returns the single number in the array where every element appears twice except for one. >>> single_number([2, 2, 1]) == 1 >>> single_number([4, 1, 2, 1, 2]) == 4 >>> single_number([1]) == 1","solution":"def single_number(nums): Returns the single number in the array where every element appears twice except for one. # Initialize a variable to hold the result result = 0 # Traverse each number in the array for num in nums: # XOR the current number with the result result ^= num # The result will be the number that appears only once return result"},{"question":"class QueryProcessor: def __init__(self, array): Initialize the QueryProcessor with the given list of integers. self.array = array def update(self, i, x): Update the i-th integer in the list to x. :param i: Index to update (1-based) :param x: New value pass def sum_range(self, l, r): Find the sum of the integers in the sublist from index l to index r (inclusive). :param l: Start of range (1-based) :param r: End of range (1-based) :return: Sum of the range pass def max_range(self, l, r): Find the maximum value among the integers in the sublist from index l to index r (inclusive). :param l: Start of range (1-based) :param r: End of range (1-based) :return: Maximum value in the range pass def process_queries(n, q, initial_list, queries): Perform a series of queries on the given list of integers. :param n: Number of integers in the list :param q: Number of queries :param initial_list: Initial list of integers :param queries: Queries to perform :return: List of results for \\"sum\\" and \\"max\\" queries qp = QueryProcessor(initial_list) results = [] for query in queries: parts = query.split() if parts[0] == \\"update\\": _, i, x = parts qp.update(int(i), int(x)) elif parts[0] == \\"sum\\": _, l, r = parts results.append(qp.sum_range(int(l), int(r))) elif parts[0] == \\"max\\": _, l, r = parts results.append(qp.max_range(int(l), int(r))) return results def test_process_queries(): n = 8 q = 5 initial_list = [1, 3, 5, 7, 9, 2, 4, 6] queries = [ \\"update 4 10\\", \\"sum 2 5\\", \\"max 3 7\\", \\"sum 1 8\\", \\"max 1 8\\" ] expected_output = [27, 10, 37, 10] assert process_queries(n, q, initial_list, queries) == expected_output def test_process_queries_single_update(): n = 3 q = 1 initial_list = [1, 2, 3] queries = [\\"update 3 5\\"] expected_output = [] assert process_queries(n, q, initial_list, queries) == expected_output def test_process_queries_multiple_operations(): n = 4 q = 3 initial_list = [4, 7, 1, 3] queries = [ \\"sum 1 3\\", \\"max 2 4\\", \\"update 4 10\\" ] expected_output = [12, 7] assert process_queries(n, q, initial_list, queries) == expected_output def test_process_queries_entire_range(): n = 5 q = 2 initial_list = [10, 3, 5, 8, 6] queries = [ \\"sum 1 5\\", \\"max 1 5\\" ] expected_output = [32, 10] assert process_queries(n, q, initial_list, queries) == expected_output def test_process_queries_multiple_updates(): n = 6 q = 4 initial_list = [6, 5, 4, 3, 2, 1] queries = [ \\"max 1 6\\", \\"update 1 10\\", \\"update 6 20\\", \\"sum 1 3\\" ] expected_output = [6, 19] assert process_queries(n, q, initial_list, queries) == expected_output","solution":"class QueryProcessor: def __init__(self, array): self.array = array def update(self, i, x): self.array[i - 1] = x def sum_range(self, l, r): return sum(self.array[l - 1:r]) def max_range(self, l, r): return max(self.array[l - 1:r]) def process_queries(n, q, initial_list, queries): qp = QueryProcessor(initial_list) results = [] for query in queries: parts = query.split() if parts[0] == \\"update\\": _, i, x = parts qp.update(int(i), int(x)) elif parts[0] == \\"sum\\": _, l, r = parts results.append(qp.sum_range(int(l), int(r))) elif parts[0] == \\"max\\": _, l, r = parts results.append(qp.max_range(int(l), int(r))) return results"},{"question":"class ArrayProcessor: def __init__(self, n, array): Initializes the ArrayProcessor with the given array. self.array = array def process_query(self, query): Processes a single query on the array. It can either be an 'update' or 'min' query. def get_min(self, l, r): Returns the minimum value in the array from index l to r (1-based index). def update(self, i, x): Updates the value at index i (1-based index) to x. # Example Usage: # array = [4, 3, 2, 1, 5] # processor = ArrayProcessor(len(array), array) # print(processor.process_query(\\"min 1 3\\")) # Output: 2 # processor.process_query(\\"update 3 6\\") # print(processor.process_query(\\"min 1 3\\")) # Output: 3 # processor.process_query(\\"update 5 0\\") # print(processor.process_query(\\"min 4 5\\")) # Output: 0","solution":"class ArrayProcessor: def __init__(self, n, array): Initializes the ArrayProcessor with the given array. self.array = array def process_query(self, query): Processes a single query on the array. It can either be an 'update' or 'min' query. parts = query.split() if parts[0] == \\"min\\": l, r = int(parts[1]), int(parts[2]) return self.get_min(l, r) elif parts[0] == \\"update\\": i, x = int(parts[1]), int(parts[2]) self.update(i, x) return None def get_min(self, l, r): Returns the minimum value in the array from index l to r (1-based index). return min(self.array[l-1:r]) def update(self, i, x): Updates the value at index i (1-based index) to x. self.array[i-1] = x"},{"question":"def min_possible_max_and_value(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum possible maximum value of the bitwise AND of all non-empty subsets of the array. Args: - t: int - the number of test cases. - test_cases: List[Tuple[int, int]] - each tuple contains two integers n and k. Returns: - List[int]: a list of integers representing the minimum possible maximum value of the bitwise AND for each test case. >>> min_possible_max_and_value(4, [(3, 5), (2, 8), (6, 10), (1, 7)]) == [0, 0, 0, 7] >>> min_possible_max_and_value(3, [(1, 1), (1, 2), (2, 9)]) == [1, 2, 0] >>> min_possible_max_and_value(2, [(1, 10), (5, 99)]) == [10, 0] >>> min_possible_max_and_value(1, [(1, 1)]) == [1] >>> min_possible_max_and_value(1, [(1000000000, 1000000000)]) == [0]","solution":"def min_possible_max_and_value(t, test_cases): result = [] for n, k in test_cases: if n == 1: result.append(k) else: result.append(0) return result # Read inputs (for testing purposes) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(t)] results = min_possible_max_and_value(t, test_cases) for res in results: print(res)"},{"question":"from typing import List def can_rearrange_for_min_diff(A: List[int], B: List[int], D: int) -> bool: Determine if the integers in A can be rearranged so that the sum of absolute differences between the paired elements does not exceed a given value D. >>> can_rearrange_for_min_diff([1, 3, 5], [5, 3, 1], 4) True >>> can_rearrange_for_min_diff([1, 2, 3], [7, 8, 9], 4) False >>> can_rearrange_for_min_diff([-1, -2, -3], [-3, -2, -1], 4) True >>> can_rearrange_for_min_diff([], [], 0) True >>> can_rearrange_for_min_diff([5], [5], 0) True","solution":"from typing import List def can_rearrange_for_min_diff(A: List[int], B: List[int], D: int) -> bool: # Sort both arrays A.sort() B.sort() # Calculate the sum of absolute differences total_diff = sum(abs(a - b) for a, b in zip(A, B)) # Check if the total difference is within the allowed limit return total_diff <= D"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Determine if the word can be constructed from the grid letters using depth-first search. >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCCED\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"SEE\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCB\\") False","solution":"def exist(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, i): if i == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or word[i] != grid[r][c]: return False temp = grid[r][c] grid[r][c] = \\"#\\" found = (dfs(r+1, c, i+1) or dfs(r-1, c, i+1) or dfs(r, c+1, i+1) or dfs(r, c-1, i+1)) grid[r][c] = temp return found for r in range(rows): for c in range(cols): if grid[r][c] == word[0] and dfs(r, c, 0): return True return False"},{"question":"def count_ways(n): Return the number of unique ways to climb a staircase with n steps. >>> count_ways(0) 0 >>> count_ways(1) 1 >>> count_ways(2) 2 >>> count_ways(3) 3 >>> count_ways(4) 5 >>> count_ways(5) 8 >>> count_ways(10) 89 def process_staircases(steps_list): Process a list of steps, and return a list of results for each steps count in the format described. >>> process_staircases([3, 5, 0]) [\\"Case #1: 3\\", \\"Case #2: 8\\"] >>> process_staircases([0]) [] >>> process_staircases([2, 4, 6, 0]) [\\"Case #1: 2\\", \\"Case #2: 5\\", \\"Case #3: 13\\"] >>> process_staircases([1, 2, 3, 4, 0]) [\\"Case #1: 1\\", \\"Case #2: 2\\", \\"Case #3: 3\\", \\"Case #4: 5\\"]","solution":"def count_ways(n): Return the number of unique ways to climb a staircase with n steps. if n == 0: return 0 elif n == 1: return 1 elif n == 2: return 2 # Using dynamic programming to store the number of ways to solve subproblems dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def process_staircases(steps_list): Process a list of steps, and return a list of results for each steps count in the format described. results = [] case_number = 1 for n in steps_list: if n == 0: break result = count_ways(n) results.append(f\\"Case #{case_number}: {result}\\") case_number += 1 return results"},{"question":"def transpose_matrix(matrix): Given an M x N matrix, return its transpose. >>> transpose_matrix([[1, 2], [3, 4]]) == [[1, 3], [2, 4]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2, 3]]) == [[1], [2], [3]] >>> transpose_matrix([[1], [2], [3]]) == [[1, 2, 3]] >>> transpose_matrix([]) == []","solution":"def transpose_matrix(matrix): Given an M x N matrix, return its transpose. # Transposing the matrix by swapping rows with columns transposed_matrix = [list(row) for row in zip(*matrix)] return transposed_matrix"},{"question":"def manage_cluster(T: int, test_cases: List[Tuple[int, List[int], int, List[Tuple[int, int, int]]]]) -> List[int]: You are tasked with managing resource allocation for a new computer cluster. The cluster consists of N nodes, each with a certain amount of available resources. You need to be able to perform two types of operations on the cluster: 1. Update the amount of available resources on a specific node. 2. Determine the node with the maximum resources in a given range of nodes. Parameters: - T: The number of test cases. - test_cases: A list of tuples, each containing: - N: The number of nodes in the cluster. - A list of integers representing the amount of available resources on each node. - Q: The number of operations to be performed. - A list of tuples representing the operations. Returns: A list of integers representing the results of the second type operations. Example: >>> manage_cluster(2, [(3, [10, 20, 15], 3, [(2, 1, 3), (1, 2, 5), (2, 2, 3)]), (4, [5, 8, 10, 6], 2, [(2, 1, 3), (1, 3, 12)])]) [20, 15, 10]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index, value): pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = max(self.tree[2 * pos], self.tree[2 * pos + 1]) def range_max(self, left, right): left += self.n right += self.n max_value = 0 while left < right: if left % 2: max_value = max(max_value, self.tree[left]) left += 1 if right % 2: right -= 1 max_value = max(max_value, self.tree[right]) left //= 2 right //= 2 return max_value def manage_cluster(T, test_cases): results = [] for case in test_cases: N, resources, Q, operations = case seg_tree = SegmentTree(resources) for operation in operations: if operation[0] == 1: _, x, r = operation seg_tree.update(x - 1, r) elif operation[0] == 2: _, x, y = operation results.append(seg_tree.range_max(x - 1, y)) return results"},{"question":"def find_min_swaps(n: int, m: int, preferences: List[Tuple[int, int]]) -> int: Determine the minimum number of swaps required to order the restaurants such that all individuals' preferences are satisfied. If it is impossible, return -1. Parameters: n (int): Number of restaurants m (int): Number of preferences preferences (List[Tuple[int, int]]): List of tuples where each tuple contains two integers representing a preference Returns: int: Minimum number of swaps required, or -1 if it is impossible to satisfy all preferences. >>> find_min_swaps(4, 2, [(1, 2), (3, 4)]) 0 >>> find_min_swaps(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> find_min_swaps(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) -1 >>> find_min_swaps(3, 0, []) 0 >>> find_min_swaps(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> find_min_swaps(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) -1 >>> find_min_swaps(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 0 >>> find_min_swaps(4, 3, [(1, 3), (2, 1), (4, 3)]) -1","solution":"def find_min_swaps(n, m, preferences): # Create adjacency matrix to store preferences adj_matrix = [[0] * n for _ in range(n)] for a, b in preferences: adj_matrix[a-1][b-1] = 1 # Track the order of the restaurants order = list(range(n)) def is_sorted(order): for i in range(n): for j in range(n): if adj_matrix[order[i]][order[j]] == 1 and i > j: return False return True swap_count = 0 max_swaps = n * (n - 1) // 2 # Maximum possible swaps in best case changed = True while changed and not is_sorted(order): changed = False for i in range(n - 1): if adj_matrix[order[i]][order[i + 1]] == 1: order[i], order[i + 1] = order[i + 1], order[i] swap_count += 1 changed = True if swap_count > max_swaps: return -1 if is_sorted(order): return swap_count else: return -1"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. >>> int_to_roman(1) 'I' >>> int_to_roman(4) 'IV' >>> int_to_roman(6) 'VI' >>> int_to_roman(9) 'IX' >>> int_to_roman(10) 'X' >>> int_to_roman(20) 'XX' >>> int_to_roman(40) 'XL' >>> int_to_roman(50) 'L' >>> int_to_roman(90) 'XC' >>> int_to_roman(100) 'C' >>> int_to_roman(400) 'CD' >>> int_to_roman(500) 'D' >>> int_to_roman(900) 'CM' >>> int_to_roman(1000) 'M' >>> int_to_roman(2000) 'MM' >>> int_to_roman(3000) 'MMM' >>> int_to_roman(3999) 'MMMCMXCIX' >>> int_to_roman(58) 'LVIII' >>> int_to_roman(1994) 'MCMXCIV'","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. :param num: Integer to convert, must be in the range 1 to 3999. :return: A string representing the Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' for i in range(len(val)): while num >= val[i]: num -= val[i] roman_num += syb[i] return roman_num"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the characters of the string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. Examples: >>> can_form_palindrome(\\"carrace\\") 'YES' >>> can_form_palindrome(\\"hellos\\") 'NO' pass from solution import can_form_palindrome def test_can_form_palindrome_example1(): assert can_form_palindrome(\\"carrace\\") == \\"YES\\" def test_can_form_palindrome_example2(): assert can_form_palindrome(\\"hellos\\") == \\"NO\\" def test_can_form_palindrome_single_character(): assert can_form_palindrome(\\"a\\") == \\"YES\\" def test_can_form_palindrome_two_same_characters(): assert can_form_palindrome(\\"aa\\") == \\"YES\\" def test_can_form_palindrome_two_different_characters(): assert can_form_palindrome(\\"ab\\") == \\"NO\\" def test_can_form_palindrome_long_palindrome(): assert can_form_palindrome(\\"aabbccddeeffg\\") == \\"YES\\" def test_can_form_palindrome_long_non_palindrome(): assert can_form_palindrome(\\"aabbccddeeffgh\\") == \\"NO\\"","solution":"def can_form_palindrome(s): Determines if the characters of the string can be rearranged to form a palindrome. Args: s (str): The input string consisting of lowercase English letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. from collections import Counter # Count the occurrences of each character in the string char_counts = Counter(s) # Check the number of characters that appear an odd number of times odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # For a string to be rearranged into a palindrome: # - At most one character can have an odd count (middle character in an odd-length palindrome) if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def first_occurrence_greater_than_25(nums): Returns the index of the first occurrence of an element that is greater than 25. If no such element exists, returns -1. >>> first_occurrence_greater_than_25([5, 8, 12, 30, 7, 19]) 3 >>> first_occurrence_greater_than_25([26, 28, 30, 25]) 0 >>> first_occurrence_greater_than_25([5, 8, 12, 7, 19]) -1 >>> first_occurrence_greater_than_25([]) -1 >>> first_occurrence_greater_than_25([26]) 0 >>> first_occurrence_greater_than_25([24]) -1 >>> first_occurrence_greater_than_25([10, 20, 25, 5]) -1","solution":"def first_occurrence_greater_than_25(nums): Returns the index of the first occurrence of an element that is greater than 25. If no such element exists, returns -1. for idx, num in enumerate(nums): if num > 25: return idx return -1"},{"question":"def magical_number(M: int, D: int) -> int: Returns the magical number of the item produced on the D-th day. >>> magical_number(3, 0) 3 >>> magical_number(3, 1) 3 >>> magical_number(3, 2) 6 >>> magical_number(3, 5) 24 >>> magical_number(1, 10) 89 >>> magical_number(0, 5) 0 >>> magical_number(-3, 5) -24","solution":"def magical_number(M, D): Returns the magical number of the item produced on the D-th day. if D < 2: return M first = M second = M result = 0 for i in range(2, D + 1): result = first + second first = second second = result return result"},{"question":"def max_treasure(n: int, treasures: List[int]) -> int: Given the number of houses and a list of treasures in each house, find the maximum amount of treasure the thieves can steal without alerting the police by robbing two adjacent houses. Parameters: n (int): the number of houses treasures (List[int]): the amount of treasure in each house Returns: int: the maximum amount of treasure the thieves can steal Examples: >>> max_treasure(5, [2, 7, 9, 3, 1]) 12 >>> max_treasure(3, [2, 1, 4]) 6 >>> max_treasure(6, [5, 5, 10, 40, 50, 35]) 80","solution":"def max_robbery(treasures): Given a list of treasures in each house, this function returns the maximum amount of treasure the thieves can steal without alerting the police by robbing two adjacent houses. n = len(treasures) if n == 0: return 0 if n == 1: return treasures[0] dp = [0] * n dp[0] = treasures[0] dp[1] = max(treasures[0], treasures[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + treasures[i]) return dp[-1] def max_treasure(n, treasures): return max_robbery(treasures)"},{"question":"def sliding_window_sums(n: int, k: int, array: List[int]) -> List[int]: Generate an array of sums of each window of the specified size as it slides through the original array. >>> sliding_window_sums(5, 3, [1, 2, 3, 4, 5]) [6, 9, 12] >>> sliding_window_sums(6, 2, [10, 20, 30, 40, 50, 60]) [30, 50, 70, 90, 110]","solution":"def sliding_window_sums(n, k, array): Takes the length of the array \`n\`, window size \`k\`, and the array of integers \`array\`. Returns a list of sums of each window of size \`k\`. # List to store the result result = [] # Calculate the sum of the first window window_sum = sum(array[:k]) result.append(window_sum) # Sliding the window through the array for i in range(1, n - k + 1): # Update the window sum by subtracting the element that's no longer in the window # and adding the new element that entered the window window_sum += array[i + k - 1] - array[i - 1] result.append(window_sum) return result"},{"question":"def remaining_robots(T, test_cases): Determine the number of robots left in the grid after they move and potentially vanish. Input: T : int : number of test cases test_cases : List[Tuple[int, List[Tuple[int, int, str]]]] : Each test case contains N, the number of robots, followed by a list of tuples with each tuple having the x, y coordinates and v direction. Output: List[int] : List containing number of robots left in the grid after all collisions for each test case. Example: >>> T = 1 >>> test_cases = [ >>> (3, [ >>> (1, 2, 'R'), >>> (3, 4, 'C'), >>> (1, 4, 'R') >>> ]) >>> ] >>> remaining_robots(T, test_cases) [1] >>> T = 1 >>> test_cases = [ >>> (2, [ >>> (1, 1, 'R'), >>> (2, 2, 'C') >>> ]) >>> ] >>> remaining_robots(T, test_cases) [2] # Write your implementation here # Unit Test def test_remaining_robots_case_1(): T = 1 test_cases = [ (3, [ (1, 2, 'R'), (3, 4, 'C'), (1, 4, 'R') ]) ] assert remaining_robots(T, test_cases) == [1] def test_remaining_robots_no_collision(): T = 1 test_cases = [ (2, [ (1, 1, 'R'), (2, 2, 'C') ]) ] assert remaining_robots(T, test_cases) == [2] def test_remaining_robots_all_collide(): T = 1 test_cases = [ (3, [ (0, 0, 'R'), (0, 0, 'C'), (0, 0, 'R') ]) ] assert remaining_robots(T, test_cases) == [0] def test_remaining_robots_mixed(): T = 2 test_cases = [ (3, [ (1, 2, 'R'), (3, 4, 'C'), (1, 4, 'R') ]), (2, [ (1, 1, 'R'), (2, 2, 'C') ]) ] assert remaining_robots(T, test_cases) == [1, 2]","solution":"def remaining_robots(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] robots = test_cases[i][1] # Tracking coordinates as keys with a set of robots present at each coordinate. coordinates = {} for robot in robots: x, y, direction = robot if direction == 'R': for x_pos in range(x, 1001): if (x_pos, y) not in coordinates: coordinates[(x_pos, y)] = set() coordinates[(x_pos, y)].add(robot) else: for y_pos in range(y, 1001): if (x, y_pos) not in coordinates: coordinates[(x, y_pos)] = set() coordinates[(x, y_pos)].add(robot) robots_set = set(tuple(robot) for robot in robots) for coord in coordinates: if len(coordinates[coord]) > 1: # If more than one robot is in the set for a coordinate, they vanish. robots_set -= coordinates[coord] results.append(len(robots_set)) return results"},{"question":"def shiftString(s: str, N: int) -> str: Shifts each character in the string s by N positions in the alphabet. Args: s (str): The input string consisting of lowercase English letters. N (int): The integer shift value. Returns: str: The shifted string. Examples: >>> shiftString(\\"abc\\", 3) \\"def\\" >>> shiftString(\\"xyz\\", 2) \\"zab\\"","solution":"def shiftString(s, N): Shifts each character in the string s by N positions in the alphabet. Args: s (str): The input string consisting of lowercase English letters. N (int): The integer shift value. Returns: str: The shifted string. # N must be reduced modulo 26 to avoid unnecessary rotations N = N % 26 shifted_string = [] for char in s: shifted_char = chr((ord(char) - ord('a') + N) % 26 + ord('a')) shifted_string.append(shifted_char) return ''.join(shifted_string)"},{"question":"def findMaxElement(arr): Returns the maximum element in the array. >>> findMaxElement([1, 2, 3, 4, 5]) == 5 >>> findMaxElement([5, 17, 9, 1, 100]) == 100 >>> findMaxElement([42]) == 42 >>> findMaxElement([3, 3, 3]) == 3 >>> findMaxElement([99, 99, 99, 99]) == 99 >>> findMaxElement([1000000000, 1, 999999999, 50]) == 1000000000 >>> findMaxElement([-3, -1, -100, -4]) == -1 >>> findMaxElement([-10, -30, 0, 2, 5, 20]) == 20 >>> try: >>> findMaxElement([]) >>> assert False, \\"Expected ValueError for empty array\\" >>> except ValueError: >>> pass","solution":"def findMaxElement(arr): Returns the maximum element in the array. if not arr: raise ValueError(\\"The array is empty\\") max_element = arr[0] for num in arr: if num > max_element: max_element = num return max_element"},{"question":"def min_gifts_to_achieve_sum(k: int, gifts: List[Tuple[int, int]]) -> int: Returns the minimum number of gifts needed to reach the exact sum of k, or -1 if it is not possible. >>> min_gifts_to_achieve_sum(10, [(1, 5), (2, 3), (1, 2), (3, 8), (4, 7)]) 2 >>> min_gifts_to_achieve_sum(7, [(2, 4), (1, 5), (3, 11)]) -1 >>> min_gifts_to_achieve_sum(15, [(1, 5), (2, 5), (3, 1), (4, 4), (5, 6), (6, 7)]) 3 pass","solution":"def min_gifts_to_achieve_sum(k, gifts): Returns the minimum number of gifts needed to reach the exact sum of k, or -1 if it is not possible. from collections import defaultdict # Key: value sum, Value: minimum number of gifts to achieve this sum dp = defaultdict(lambda: float('inf')) dp[0] = 0 # Base case: 0 sum requires 0 gifts for _, value in gifts: for s in range(k, value - 1, -1): dp[s] = min(dp[s], dp[s - value] + 1) return dp[k] if dp[k] != float('inf') else -1"},{"question":"def first_missing_integer(arr: List[int]) -> int: Returns the first missing integer starting from 1. If all integers from 1 to len(arr) are present, returns the next integer, which is len(arr) + 1. >>> first_missing_integer([2, 3, 4]) == 1 >>> first_missing_integer([1, 2, 4, 6, 3, 7, 8]) == 5 >>> first_missing_integer([1, 2, 3, 4, 5]) == 6","solution":"def first_missing_integer(arr): Returns the first missing integer starting from 1. If all integers from 1 to len(arr) are present, returns the next integer, which is len(arr) + 1. n = len(arr) present = [False] * (n + 1) for number in arr: if 1 <= number <= n: present[number] = True for i in range(1, n + 1): if not present[i]: return i return n + 1"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if the given string can be rearranged to form a palindrome. Parameters: s (str): Input string consisting of only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"from collections import Counter def can_form_palindrome(s): Determine if the given string can be rearranged to form a palindrome. Parameters: s (str): Input string consisting of only lowercase letters. Returns: bool: True if the string can be rearranged to form a palindrome, otherwise False. # Count the frequency of each character in the string counter = Counter(s) # A string can be rearranged to form a palindrome if at most one character # has an odd count (for the center position in an odd length palindrome). odd_count = sum(1 for count in counter.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def is_balanced_garden(grid: List[List[int]]) -> str: Determines if a garden grid can be balanced such that each flower has at least one neighboring cell with a river. Returns \\"YES\\" if the garden can be balanced, otherwise \\"NO\\". >>> is_balanced_garden([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) 'YES' >>> is_balanced_garden([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 'NO' import pytest def test_case_1(): grid = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert is_balanced_garden(grid) == \\"YES\\" def test_case_2(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert is_balanced_garden(grid) == \\"NO\\" def test_case_3(): grid = [ [1, 0, 1], [0, 0, 0], [1, 0, 1] ] assert is_balanced_garden(grid) == \\"NO\\" def test_case_4(): grid = [ [0, 1], [1, 0] ] assert is_balanced_garden(grid) == \\"YES\\" def test_case_5(): grid = [ [0, 1], [0, 0] ] assert is_balanced_garden(grid) == \\"NO\\"","solution":"def is_balanced_garden(grid): N = len(grid) M = len(grid[0]) for i in range(N): for j in range(M): if grid[i][j] == 0: if not ( (i > 0 and grid[i-1][j] == 1) or (i < N-1 and grid[i+1][j] == 1) or (j > 0 and grid[i][j-1] == 1) or (j < M-1 and grid[i][j+1] == 1) ): return \\"NO\\" return \\"YES\\""},{"question":"def count_unique_groups(strings): Returns the number of unique groups in a collection of strings. Args: strings (list): A list of strings. Returns: int: The number of unique groups. Examples: >>> count_unique_groups([\\"abc\\", \\"bac\\", \\"adb\\", \\"dbaa\\"]) 2 >>> count_unique_groups([\\"xyz\\", \\"yxz\\", \\"zyx\\"]) 1","solution":"def count_unique_groups(strings): Returns the number of unique groups in a collection of strings. Args: strings (list): A list of strings. Returns: int: The number of unique groups. groups = set() for string in strings: group = frozenset(string) groups.add(group) return len(groups) # Example usage: n = 4 strings = [\\"abc\\", \\"bac\\", \\"adb\\", \\"dbaa\\"] print(count_unique_groups(strings)) # Output: 2"},{"question":"from typing import List def find_alphabet_order(words: List[str]) -> str: Determine the order of characters in the new language based on the given words. >>> find_alphabet_order([\\"wrt\\", \\"wrf\\", \\"er\\", \\"ett\\", \\"rftt\\"]) 'wertf' >>> find_alphabet_order([\\"abc\\"]) 'abc' >>> find_alphabet_order([\\"abc\\", \\"ab\\"]) '' >>> find_alphabet_order([\\"abc\\", \\"bca\\", \\"cab\\"]) # any permutation of 'abc' is valid >>> set(find_alphabet_order([\\"abc\\", \\"bca\\", \\"cab\\"])) == set(\\"abc\\") True >>> find_alphabet_order([ \\"za\\", \\"zb\\", \\"ca\\", \\"cb\\" ]) in [\\"zacb\\", \\"zabc\\"] True >>> find_alphabet_order([]) '' >>> find_alphabet_order(['abc', 'ab']) ''","solution":"from collections import defaultdict, deque def find_alphabet_order(words): # Build graph and find all unique characters adj_list = defaultdict(set) in_degree = {ch: 0 for word in words for ch in word} # Build the graph for i in range(len(words) - 1): first, second = words[i], words[i + 1] min_length = min(len(first), len(second)) for j in range(min_length): if first[j] != second[j]: if second[j] not in adj_list[first[j]]: adj_list[first[j]].add(second[j]) in_degree[second[j]] += 1 break else: if len(first) > len(second): # Check if second is a prefix of first return \\"\\" # Topological sort using Kahn's algorithm queue = deque([ch for ch in in_degree if in_degree[ch] == 0]) sorted_order = [] while queue: curr_char = queue.popleft() sorted_order.append(curr_char) for neighbor in adj_list[curr_char]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If not all characters are in sorted_order, it means there was a cycle if len(sorted_order) != len(in_degree): return \\"\\" return \\"\\".join(sorted_order)"},{"question":"def shortest_beautiful_substring(s: str) -> int: Returns the length of the shortest beautiful substring that contains at least one 'a', one 'b', and one 'c'. If no such substring exists, return -1. >>> shortest_beautiful_substring(\\"abcabc\\") == 3 >>> shortest_beautiful_substring(\\"bcaacb\\") == 3 >>> shortest_beautiful_substring(\\"aaaa\\") == -1","solution":"def shortest_beautiful_substring(s): Returns the length of the shortest beautiful substring that contains at least one 'a', one 'b', and one 'c'. If no such substring exists, return -1. n = len(s) min_length = float('inf') left = 0 count = {'a': 0, 'b': 0, 'c': 0} for right in range(n): if s[right] in count: count[s[right]] += 1 while all(count[char] > 0 for char in 'abc'): min_length = min(min_length, right - left + 1) count[s[left]] -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"from typing import List def is_prime(num: int) -> bool: Helper function to check if a number is prime. # Implement prime checking logic def prime_sum_triple(n: int) -> List[int]: Function to determine if n can be represented as a sum of three prime numbers. Returns one possible combination as a list [p1, p2, p3], or an empty list if no combination exists. >>> prime_sum_triple(30) [7, 11, 12] >>> prime_sum_triple(17) [2, 5, 10] >>> prime_sum_triple(23) [2, 7, 14] >>> prime_sum_triple(4) []","solution":"def is_prime(num): Helper function to check if a number is prime. if num < 2: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def prime_sum_triple(n): Function to determine if n can be represented as a sum of three prime numbers. Returns one possible combination as a list [p1, p2, p3], or an empty list if no combination exists. primes = [num for num in range(2, n) if is_prime(num)] # Check all combinations of three primes for i in range(len(primes)): for j in range(i, len(primes)): for k in range(j, len(primes)): if primes[i] + primes[j] + primes[k] == n: return [primes[i], primes[j], primes[k]] return [] # Example Usage: # result = prime_sum_triple(30) # print(result) # [7, 11, 12] or any other valid combination"},{"question":"def organize_books(N: int, M: int, books: List[Tuple[str, int]]) -> List[str]: Organizes Amelia's books by reading levels and alphabetically within each level. Given N books with titles and reading levels, organize these books by reading level from 1 to M, and alphabetically within each level. Args: - N: int, number of books - M: int, number of reading levels - books: List[Tuple[str, int]], list of tuples where each tuple consists of a book title and its reading level Returns: - List[str]: list of book titles in the organized order Example: >>> organize_books(5, 3, [(\\"HarryPotter\\", 2), (\\"LordOfTheRings\\", 1), (\\"TheHobbit\\", 1), (\\"AliceInWonderland\\", 3), (\\"MobyDick\\", 2)]) [\\"LordOfTheRings\\", \\"TheHobbit\\", \\"HarryPotter\\", \\"MobyDick\\", \\"AliceInWonderland\\"] # your code here # Unit tests def test_basic_case(): input_data = [(5, 3), (\\"HarryPotter\\", 2), (\\"LordOfTheRings\\", 1), (\\"TheHobbit\\", 1), (\\"AliceInWonderland\\", 3), (\\"MobyDick\\", 2)] expected_output = [ \\"LordOfTheRings\\", \\"TheHobbit\\", \\"HarryPotter\\", \\"MobyDick\\", \\"AliceInWonderland\\" ] assert organize_books(input_data[0][0], input_data[0][1], input_data[1:]) == expected_output def test_single_level_multiple_books(): input_data = [(3, 1), (\\"C\\", 1), (\\"A\\", 1), (\\"B\\", 1)] expected_output = [\\"A\\", \\"B\\", \\"C\\"] assert organize_books(input_data[0][0], input_data[0][1], input_data[1:]) == expected_output def test_multiple_levels_single_book_each(): input_data = [(3, 3), (\\"Book1\\", 1), (\\"Book2\\", 2), (\\"Book3\\", 3)] expected_output = [\\"Book1\\", \\"Book2\\", \\"Book3\\"] assert organize_books(input_data[0][0], input_data[0][1], input_data[1:]) == expected_output def test_multiple_levels_with_multiple_books_each(): input_data = [(6, 3), (\\"Title1\\", 3), (\\"Title2\\", 1), (\\"Title4\\", 2), (\\"Aardvark\\", 1), (\\"Zebra\\", 2), (\\"Kangaroo\\", 3)] expected_output = [ \\"Aardvark\\", \\"Title2\\", \\"Title4\\", \\"Zebra\\", \\"Kangaroo\\", \\"Title1\\" ] assert organize_books(input_data[0][0], input_data[0][1], input_data[1:]) == expected_output def test_varied_titles_and_levels(): input_data = [(4, 2), (\\"Zebra\\", 1), (\\"Antelope\\", 2), (\\"Zebra2\\", 2), (\\"Antelope2\\", 1)] expected_output = [ \\"Antelope2\\", \\"Zebra\\", \\"Antelope\\", \\"Zebra2\\" ] assert organize_books(input_data[0][0], input_data[0][1], input_data[1:]) == expected_output","solution":"def organize_books(N, M, books): Organizes books by reading levels and alphabetically within each level. Args: - N: int, number of books - M: int, number of reading levels - books: list of tuples (title, level) Returns: - list of strings, titles of books in organized order # Create a dictionary to hold lists of book titles indexed by their reading levels level_dict = {i: [] for i in range(1, M+1)} # Populate the dictionary with titles for title, level in books: level_dict[level].append(title) # Sort the dictionaries by level and then sort by title alphabetically within each level sorted_books = [] for level in sorted(level_dict.keys()): sorted_books.extend(sorted(level_dict[level])) return sorted_books"},{"question":"def findElement(matrix, target): Given an \`n x n\` matrix where each of the rows and columns is sorted in ascending order, find an element in the matrix and return its position (row and column index) if it is found, or \`-1\` if the element is not present in the matrix. Args: matrix: List[List[int]] - a 2D list of integers representing the matrix. target: int - the element to search for. Returns: Tuple[int, int] or int: the position of the target element as a tuple (row, col), or \`-1\` if not found. Examples: >>> findElement([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 5) (1, 1) >>> findElement([ ... [1, 4, 7, 11, 15], ... [2, 5, 8, 12, 19], ... [3, 6, 9, 16, 22], ... [10, 13, 14, 17, 24], ... [18, 21, 23, 26, 30] ... ], 20) -1","solution":"def findElement(matrix, target): Finds the element in the sorted n x n matrix and returns its position (row, col) if found, otherwise returns -1. if not matrix: return -1 n = len(matrix) row, col = 0, n - 1 while row < n and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return -1"},{"question":"def lexicographically_smallest_string(S: str) -> str: Returns the lexicographically smallest string achievable by sorting the string S, which allows for indefinite swaps and reversals. >>> lexicographically_smallest_string(\\"bacd\\") == \\"abcd\\" >>> lexicographically_smallest_string(\\"dcba\\") == \\"abcd\\" >>> lexicographically_smallest_string(\\"aaaa\\") == \\"aaaa\\" >>> lexicographically_smallest_string(\\"zyxw\\") == \\"wxyz\\" >>> lexicographically_smallest_string(\\"gfedcba\\") == \\"abcdefg\\" >>> lexicographically_smallest_string(\\"quickbrownfox\\") == \\"bcfiknooqruwx\\" >>> lexicographically_smallest_string(\\"aaabbbcccddd\\") == \\"aaabbbcccddd\\" >>> lexicographically_smallest_string(\\"a\\") == \\"a\\" >>> lexicographically_smallest_string(\\"ab\\") == \\"ab\\"","solution":"def lexicographically_smallest_string(S): This function returns the lexicographically smallest string achievable by sorting the string S, which allows for indefinite swaps and reversals. return ''.join(sorted(S))"},{"question":"def is_valid_sequence(transactions: str) -> str: Evaluates if the sequence of transactions meets the specified requirements. A valid sequence of transactions must meet the following criteria: 1. The sequence contains at least one deposit denoted by \`D\`. 2. The sequence contains at least one withdrawal denoted by \`W\`. 3. The sequence does not contain two consecutive withdrawals. Parameters: transactions (str): A string representing the sequence of transactions consisting of 'D' and 'W'. Returns: str: 'YES' if the sequence is valid, 'NO' otherwise. >>> is_valid_sequence('DDDW') 'YES' >>> is_valid_sequence('DW') 'YES' >>> is_valid_sequence('DWW') 'NO' >>> is_valid_sequence('D') 'NO' >>> is_valid_sequence('W') 'NO' >>> is_valid_sequence('WDWDWDW') 'YES' >>> is_valid_sequence('DDDDDDDD') 'NO' >>> is_valid_sequence('WWWWW') 'NO' >>> is_valid_sequence('DWDWDWDWDW') 'YES' def evaluate_sequences(T: int, sequences: List[str]) -> List[str]: Evaluates multiple sequences of transactions. Parameters: T (int): Number of sequences. sequences (list of str): List of transaction sequences. Returns: list of str: List containing results for each sequence, 'YES' or 'NO'. >>> evaluate_sequences(3, ['DDDW', 'DW', 'DWW']) ['YES', 'YES', 'NO']","solution":"def is_valid_sequence(transactions): Evaluates if the sequence of transactions meets the specified requirements. Parameters: transactions (str): A string representing the sequence of transactions consisting of 'D' and 'W'. Returns: str: 'YES' if the sequence is valid, 'NO' otherwise. has_deposit = 'D' in transactions has_withdrawal = 'W' in transactions if not (has_deposit and has_withdrawal): return \\"NO\\" for i in range(len(transactions) - 1): if transactions[i] == 'W' and transactions[i + 1] == 'W': return \\"NO\\" return \\"YES\\" def evaluate_sequences(T, sequences): Evaluates multiple sequences of transactions. Parameters: T (int): Number of sequences. sequences (list of str): List of transaction sequences. Returns: list of str: List containing results for each sequence, 'YES' or 'NO'. results = [] for sequence in sequences: results.append(is_valid_sequence(sequence)) return results"},{"question":"def second_largest_unique(lst): Takes a list of integers and returns the second largest unique integer in the list. If the list doesn't contain at least two unique integers, returns None. >>> second_largest_unique([1, 2, 3, 4, 5]) 4 >>> second_largest_unique([5, 5, 5, 5]) None >>> second_largest_unique([3, 1, 2, 2, 3, 4]) 3 from solution import second_largest_unique def test_second_largest_unique(): assert second_largest_unique([1, 2, 3, 4, 5]) == 4 assert second_largest_unique([5, 5, 5, 5]) == None assert second_largest_unique([3, 1, 2, 2, 3, 4]) == 3 assert second_largest_unique([-1, -2, -3, -4, -5]) == -2 assert second_largest_unique([1000, 999, 999]) == 999 assert second_largest_unique([1]) == None assert second_largest_unique([2, 3]) == 2 assert second_largest_unique([4, 1, 2, 2, 3, 4, 5]) == 4 assert second_largest_unique([10, 9, 8, 8, 11]) == 10 assert second_largest_unique([999, 1000, -1000]) == 999","solution":"def second_largest_unique(lst): Returns the second largest unique integer in the list. If the list doesn't contain at least two unique integers, returns None. unique_numbers = list(set(lst)) if len(unique_numbers) < 2: return None unique_numbers.sort(reverse=True) return unique_numbers[1]"},{"question":"def is_palindrome(num: int) -> bool: Check if the given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False pass def next_palindrome(M: int) -> int: Return the smallest palindromic number which is strictly greater than M. >>> next_palindrome(123) 131 >>> next_palindrome(808) 818 pass def find_palindromes_for_test_cases(test_cases: List[int]) -> List[int]: For a list of test cases, find the smallest palindromic number greater than each input. >>> find_palindromes_for_test_cases([123, 808]) [131, 818] pass def main(input_str: str) -> str: Read the input, process each test case, and return the results. >>> main(\\"2n123n808\\") '131n818' pass if __name__ == \\"__main__\\": import sys input_str = sys.stdin.read() print(main(input_str))","solution":"def is_palindrome(num): return str(num) == str(num)[::-1] def next_palindrome(M): M = int(M) while True: M += 1 if is_palindrome(M): return M def find_palindromes_for_test_cases(test_cases): results = [] for M in test_cases: results.append(next_palindrome(M)) return results def main(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = input_lines[1:T + 1] results = find_palindromes_for_test_cases(test_cases) return 'n'.join(map(str, results))"},{"question":"def is_mystic_sequence(sequence: str) -> str: Returns 'Valid' if the sequence is mystic, 'Invalid' otherwise. A sequence is mystic if each digit from 0 to 9 appears at least once in their respective positions. >>> is_mystic_sequence(\\"1234567890\\") 'Valid' >>> is_mystic_sequence(\\"1234567891\\") 'Invalid'","solution":"def is_mystic_sequence(sequence): Returns 'Valid' if the sequence is mystic, 'Invalid' otherwise. A sequence is mystic if each digit from 0 to 9 appears at least once in their respective positions. required_digits = set('0123456789') sequence_digits = set(sequence) if len(sequence) == 10 and required_digits == sequence_digits: return \\"Valid\\" return \\"Invalid\\""},{"question":"def compute_prefix_sum_array(A): Computes the prefix sum array for a given array A. P = [0] * len(A) P[0] = A[0] for i in range(1, len(A)): P[i] = P[i-1] + A[i] return P def sum_of_unique_prefix_sums(A): Computes the sum of all unique values in the prefix sum array. P = compute_prefix_sum_array(A) unique_values = set(P) return sum(unique_values) def process_test_cases(test_cases): Processes multiple test cases and returns the result for each test case. results = [] for case in test_cases: N, A = case result = sum_of_unique_prefix_sums(A) results.append(result) return results # Function to generate desired output format from input def main(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) A = list(map(int, lines[index + 1].strip().split())) test_cases.append((N, A)) index += 2 results = process_test_cases(test_cases) for result in results: print(result) # Sample Unit Tests def test_compute_prefix_sum_array(): assert compute_prefix_sum_array([1, 2, 3, 4, 5]) == [1, 3, 6, 10, 15] assert compute_prefix_sum_array([1, 1, 1, 1]) == [1, 2, 3, 4] assert compute_prefix_sum_array([5, 5, 5, 5]) == [5, 10, 15, 20] def test_sum_of_unique_prefix_sums(): assert sum_of_unique_prefix_sums([1, 2, 3, 4, 5]) == 35 assert sum_of_unique_prefix_sums([1, 1, 1, 1]) == 10 assert sum_of_unique_prefix_sums([5, 5, 5, 5]) == 50 def test_process_test_cases(): assert process_test_cases([(5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) == [35, 10] def test_main(capsys): input_string = \\"2n5n1 2 3 4 5n4n1 1 1 1\\" expected_output = \\"35n10n\\" main(input_string) captured = capsys.readouterr() assert captured.out == expected_output","solution":"def compute_prefix_sum_array(A): Computes the prefix sum array for a given array A. P = [0] * len(A) P[0] = A[0] for i in range(1, len(A)): P[i] = P[i-1] + A[i] return P def sum_of_unique_prefix_sums(A): Computes the sum of all unique values in the prefix sum array. P = compute_prefix_sum_array(A) unique_values = set(P) return sum(unique_values) def process_test_cases(test_cases): Processes multiple test cases and returns the result for each test case. results = [] for case in test_cases: N, A = case result = sum_of_unique_prefix_sums(A) results.append(result) return results # Function to generate desired output format from input def main(input_string): lines = input_string.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) A = list(map(int, lines[index + 1].strip().split())) test_cases.append((N, A)) index += 2 results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def makeUniqueIdentifiers(identifiers: List[str]) -> int: Determines the minimum number of characters to be changed to make all identifiers unique. >>> makeUniqueIdentifiers([\\"abc\\", \\"abc\\", \\"bbb\\", \\"ccd\\"]) 1 >>> makeUniqueIdentifiers([\\"abc\\", \\"def\\", \\"ghi\\"]) 0 >>> makeUniqueIdentifiers([\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 2 >>> makeUniqueIdentifiers([\\"a\\", \\"b\\", \\"c\\"]) 0 >>> makeUniqueIdentifiers([\\"xyz\\", \\"xyz\\", \\"xyz\\", \\"xyz\\", \\"xyz\\", \\"aaa\\", \\"aaa\\", \\"aaa\\"]) 6 >>> makeUniqueIdentifiers([\\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\"]) 1","solution":"def makeUniqueIdentifiers(identifiers): Determines the minimum number of characters to be changed to make all identifiers unique. # Count frequency of each identifier identifier_count = {} for identifier in identifiers: if identifier in identifier_count: identifier_count[identifier] += 1 else: identifier_count[identifier] = 1 changes = 0 unique_identifiers = set(identifiers) # Iterate over the identifiers and resolve duplicates for identifier, count in identifier_count.items(): while count > 1: for i in range(len(identifier)): for ch in 'abcdefghijklmnopqrstuvwxyz': # Generate a new possible unique identifier new_identifier = identifier[:i] + ch + identifier[i+1:] if new_identifier not in unique_identifiers: unique_identifiers.add(new_identifier) changes += 1 count -= 1 break if count <= 1: break return changes"},{"question":"def max_submatrix_sum(n: int, m: int, k: int, matrix: List[List[int]]) -> int: You are given an integer matrix with \`n\` rows and \`m\` columns. Your task is to find the sum of the maximum elements in each submatrix of size \`k x k\`. The sum should be taken modulo \`1000000007\`. Args: n: int - number of rows of the matrix m: int - number of columns of the matrix k: int - size of the submatrix (both rows and columns) matrix: List[List[int]] - the matrix of integers Returns: int - The sum of the maximum elements in each submatrix of size \`k x k\` modulo \`1000000007\`. >>> max_submatrix_sum(3, 3, 2, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 28 >>> max_submatrix_sum(2, 4, 1, [[-1, -2, -3, -4], [0, -1, -5, -6]]) 999999985 >>> max_submatrix_sum(3, 3, 3, [[1, 1, 1], [1, 2, 2], [1, 1, 1]]) 2","solution":"def max_submatrix_sum(n, m, k, matrix): MOD = 1000000007 # Calculate the maximum in all k x k submatrices max_elements = [] for i in range(n - k + 1): for j in range(m - k + 1): max_element = max(matrix[x][y] for x in range(i, i + k) for y in range(j, j + k)) max_elements.append(max_element) # Compute the sum and take modulo result = sum(max_elements) % MOD return result"},{"question":"def count_decodings(message: str) -> int: Count the number of unique ways to decode the given message. >>> count_decodings(\\"12\\") 2 >>> count_decodings(\\"226\\") 3 >>> count_decodings(\\"0\\") 0 >>> count_decodings(\\"1\\") 1 >>> count_decodings(\\"10\\") 1 >>> count_decodings(\\"1111111111\\") 89","solution":"def count_decodings(message: str) -> int: Returns the number of unique ways to decode the given message string. if not message: return 0 n = len(message) dp = [0] * (n + 1) dp[0] = 1 # base case: empty string # for handling the case when first character is '0' dp[1] = 1 if message[0] != '0' else 0 for i in range(2, n + 1): single_digit = int(message[i-1:i]) double_digit = int(message[i-2:i]) if 1 <= single_digit <= 9: dp[i] += dp[i-1] if 10 <= double_digit <= 26: dp[i] += dp[i-2] return dp[-1]"},{"question":"def canBeSortedByReversingOneSegment(arr): Determines if the array can be sorted by reversing exactly one segment of the array. >>> canBeSortedByReversingOneSegment([10, 20, 30, 40, 50]) True >>> canBeSortedByReversingOneSegment([1, 3, 2, 4, 5]) True >>> canBeSortedByReversingOneSegment([1, 5, 3, 4, 2, 6]) False","solution":"def canBeSortedByReversingOneSegment(arr): Determines if the array can be sorted by reversing exactly one segment of the array. n = len(arr) if n <= 1: return True # Identify the start and end of the segment to be reversed start, end = -1, -1 for i in range(n - 1): if arr[i] > arr[i + 1]: if start == -1: start = i end = i + 1 # If start and end were never modified, the array is already sorted if start == -1: return True # Reverse the identified segment arr[start:end + 1] = arr[start:end + 1][::-1] # Check if the resulting array is sorted return arr == sorted(arr)"},{"question":"from typing import Tuple def count_vowels_and_consonants(input_string: str) -> Tuple[int, int]: Analyze a given string and returns the number of vowels and consonants in the string. >>> count_vowels_and_consonants(\\"Hello World!\\") (3, 7) >>> count_vowels_and_consonants(\\"\\") (0, 0) >>> count_vowels_and_consonants(\\"bcdfghjklmnpqrstvwxyz\\") (0, 21) >>> count_vowels_and_consonants(\\"aeiouAEIOU\\") (10, 0) >>> count_vowels_and_consonants(\\"1234!@#\\") (0, 0) >>> count_vowels_and_consonants(\\"Hello123 World!\\") (3, 7) >>> count_vowels_and_consonants(\\"abcdefghijklmnopqrstuvwxyz\\") (5, 21) >>> count_vowels_and_consonants(\\"aAbBcC\\") (2, 4)","solution":"from typing import Tuple def count_vowels_and_consonants(input_string: str) -> Tuple[int, int]: vowels_set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'} vowels_count = 0 consonants_count = 0 for char in input_string: if char.isalpha(): if char in vowels_set: vowels_count += 1 else: consonants_count += 1 return (vowels_count, consonants_count)"},{"question":"from typing import List def min_moves_with_bombs(n: int, m: int, k: int, grid: List[str]) -> int: Determine the minimum number of moves required to reach the bottom-right corner of the grid with the given number of bomb moves. If it's impossible to reach, return -1. >>> min_moves_with_bombs(5, 6, 1, [\\"......\\", \\".#..\\", \\"...#..\\", \\".#..\\", \\"......\\"]) 9 >>> min_moves_with_bombs(5, 5, 0, [\\".....\\", \\".....\\", \\".....\\", \\".....\\", \\".....\\"]) 8 >>> min_moves_with_bombs(3, 3, 1, [\\".#.\\", \\".#.\\", \\"...\\"]) 4 >>> min_moves_with_bombs(3, 3, 0, [\\".#.\\", \\"#\\", \\"...\\"]) -1 >>> min_moves_with_bombs(10, 10, 2, [\\"..........\\", \\"#.\\", \\"#.........\\", \\"#.\\", \\"..........\\", \\"#.\\", \\"#.........\\", \\"#.\\", \\"..........\\", \\"#.\\"]) 18 >>> min_moves_with_bombs(2, 2, 1, [\\".#\\", \\"#.\\"]) 2","solution":"from collections import deque def min_moves_with_bombs(n, m, k, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] start = (0, 0, k) # (x, y, bombs_left) queue = deque([(0, 0, k, 0)]) # (x, y, bombs_left, moves) visited = set() visited.add(start) while queue: x, y, bombs_left, moves = queue.popleft() if x == n - 1 and y == m - 1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: if grid[nx][ny] == '.': nxt = (nx, ny, bombs_left) if nxt not in visited: visited.add(nxt) queue.append((nx, ny, bombs_left, moves + 1)) elif grid[nx][ny] == '#' and bombs_left > 0: nxt = (nx, ny, bombs_left - 1) if nxt not in visited: visited.add(nxt) queue.append((nx, ny, bombs_left - 1, moves + 1)) return -1"},{"question":"from typing import List def sprout_sequence(month: int) -> int: Returns the number of leaves the plant will have at the end of given months. The number of months is represented by 'month'. >>> sprout_sequence(1) 1 >>> sprout_sequence(5) 5 >>> sprout_sequence(10) 55 def process_test_cases(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns the results of sprout sequence calculations. >>> process_test_cases([1, 5, 10]) [1, 5, 55] >>> process_test_cases([3, 7, 15]) [2, 13, 610]","solution":"def sprout_sequence(month): Returns the number of leaves the plant will have at the end of given months. The number of months is represented by 'month'. if month == 1 or month == 2: return 1 a, b = 1, 1 for _ in range(month - 2): a, b = b, a + b return b def process_test_cases(test_cases): results = [] for month in test_cases: results.append(sprout_sequence(month)) return results"},{"question":"def calculate_relation_score(p1, p2): Calculate the relation score between two paintings based on the given criteria: - 3 points for same artist - 2 points for same year - 1 point for same type >>> calculate_relation_score([\\"MonaLisa\\", \\"LeonardoDaVinci\\", \\"1503\\", \\"Portrait\\"], [\\"StarryNight\\", \\"VanGogh\\", \\"1889\\", \\"Landscape\\"]) 0 >>> calculate_relation_score([\\"MonaLisa\\", \\"LeonardoDaVinci\\", \\"1503\\", \\"Portrait\\"], [\\"GirlWithAPearlEarring\\", \\"Vermeer\\", \\"1665\\", \\"Portrait\\"]) 1 pass def can_arrange_paintings(f, paintings): Determine if it's possible to arrange Alice's paintings in the frames satisfying the relation score condition. >>> can_arrange_paintings(0, [[\\"MonaLisa\\", \\"LeonardoDaVinci\\", \\"1503\\", \\"Portrait\\"], [\\"StarryNight\\", \\"VanGogh\\", \\"1889\\", \\"Landscape\\"], [\\"GirlWithAPearlEarring\\", \\"Vermeer\\", \\"1665\\", \\"Portrait\\"], [\\"ThePersistenceOfMemory\\", \\"Dali\\", \\"1931\\", \\"Surrealism\\"], [\\"TheScream\\", \\"Munch\\", \\"1893\\", \\"Expressionism\\"], [\\"Guernica\\", \\"Picasso\\", \\"1937\\", \\"Mural\\"], [\\"TheNightWatch\\", \\"Rembrandt\\", \\"1642\\", \\"Portrait\\"], [\\"TheKiss\\", \\"Klimt\\", \\"1908\\", \\"Symbolism\\"], [\\"ImpressionSunrise\\", \\"Monet\\", \\"1872\\", \\"Impressionism\\"], [\\"AmericanGothic\\", \\"Wood\\", \\"1930\\", \\"Portrait\\"]]) \\"no\\" >>> can_arrange_paintings(1, [[\\"MonaLisa\\", \\"LeonardoDaVinci\\", \\"1503\\", \\"Portrait\\"], [\\"StarryNight\\", \\"VanGogh\\", \\"1889\\", \\"Landscape\\"], [\\"GirlWithAPearlEarring\\", \\"Vermeer\\", \\"1665\\", \\"Portrait\\"], [\\"ThePersistenceOfMemory\\", \\"Dali\\", \\"1931\\", \\"Surrealism\\"], [\\"TheScream\\", \\"Munch\\", \\"1893\\", \\"Expressionism\\"], [\\"Guernica\\", \\"Picasso\\", \\"1937\\", \\"Mural\\"], [\\"TheNightWatch\\", \\"Rembrandt\\", \\"1642\\", \\"Portrait\\"], [\\"TheKiss\\", \\"Klimt\\", \\"1908\\", \\"Symbolism\\"], [\\"ImpressionSunrise\\", \\"Monet\\", \\"1872\\", \\"Impressionism\\"], [\\"AmericanGothic\\", \\"Wood\\", \\"1930\\", \\"Portrait\\"]]) \\"yes\\" >>> can_arrange_paintings(9, [[\\"MonaLisa\\", \\"LeonardoDaVinci\\", \\"1503\\", \\"Portrait\\"], [\\"StarryNight\\", \\"VanGogh\\", \\"1889\\", \\"Landscape\\"], [\\"GirlWithAPearlEarring\\", \\"Vermeer\\", \\"1665\\", \\"Portrait\\"], [\\"ThePersistenceOfMemory\\", \\"Dali\\", \\"1931\\", \\"Surrealism\\"], [\\"TheScream\\", \\"Munch\\", \\"1893\\", \\"Expressionism\\"], [\\"Guernica\\", \\"Picasso\\", \\"1937\\", \\"Mural\\"], [\\"TheNightWatch\\", \\"Rembrandt\\", \\"1642\\", \\"Portrait\\"], [\\"TheKiss\\", \\"Klimt\\", \\"1908\\", \\"Symbolism\\"], [\\"ImpressionSunrise\\", \\"Monet\\", \\"1872\\", \\"Impressionism\\"], [\\"AmericanGothic\\", \\"Wood\\", \\"1930\\", \\"Portrait\\"]]) \\"no\\" pass","solution":"from itertools import permutations def calculate_relation_score(p1, p2): score = 0 if p1[1] == p2[1]: # same artist score += 3 if p1[2] == p2[2]: # same year score += 2 if p1[3] == p2[3]: # same type score += 1 return score def can_arrange_paintings(f, paintings): if f == 0: return \\"no\\" if f == 1: return \\"yes\\" for perm in permutations(paintings): valid_arrangement = True for i in range(f - 1): score = calculate_relation_score(perm[i], perm[i + 1]) if score < (i + 1): valid_arrangement = False break if valid_arrangement: return \\"yes\\" return \\"no\\" # Read input def read_input(): f = int(input().strip()) paintings = [] for _ in range(10): painting_data = input().strip().split() paintings.append(painting_data) return f, paintings if __name__ == \\"__main__\\": f, paintings = read_input() result = can_arrange_paintings(f, paintings) print(result)"},{"question":"def squares_of_evens(N: int, nums: List[int]) -> List[int]: Returns a list of squares of even numbers from the input list. Params: N (int): The number of elements in the list. nums (list of int): The list of integers. Returns: list of int: A list containing squares of even numbers from the input list. >>> squares_of_evens(6, [1, 2, 3, 4, 5, 6]) [4, 16, 36] >>> squares_of_evens(5, [1, 3, 5, 7, 9]) []","solution":"def squares_of_evens(N, nums): Returns a list of squares of even numbers from the input list. Params: N (int): The number of elements in the list. nums (list of int): The list of integers. Returns: list of int: A list containing squares of even numbers from the input list. result = [x**2 for x in nums if x % 2 == 0] return result"},{"question":"def rank_products(n, product_reviews): Accepts a list of product names and corresponding reviews, then outputs the product names in the correct ranking order. >>> rank_products(3, [\\"apple\\", 2, \\"this apple is good\\", \\"good quality apple\\", \\"banana\\", 3, \\"bad banana\\", \\"good banana\\", \\"bad quality\\", \\"cherry\\", 1, \\"the cherry is good\\"]) [\\"apple\\", \\"cherry\\", \\"banana\\"] >>> rank_products(2, [\\"alpha\\", 1, \\"good product\\", \\"beta\\", 1, \\"good product\\"]) [\\"alpha\\", \\"beta\\"] >>> rank_products(2, [\\"alpha\\", 2, \\"good product\\", \\"bad quality\\", \\"beta\\", 2, \\"good product\\", \\"bad quality\\"]) [\\"alpha\\", \\"beta\\"] >>> rank_products(2, [\\"alpha\\", 2, \\"good product\\", \\"bad quality\\", \\"beta\\", 2, \\"good product\\", \\"really bad quality\\"]) [\\"alpha\\", \\"beta\\"] >>> rank_products(4, [\\"alpha\\", 1, \\"good\\", \\"beta\\", 1, \\"bad\\", \\"gamma\\", 1, \\"neutral\\", \\"delta\\", 1, \\"bad and good\\"]) [\\"alpha\\", \\"delta\\", \\"gamma\\", \\"beta\\"]","solution":"def rank_products(n, product_reviews): product_scores = [] for i in range(n): product_name = product_reviews.pop(0) review_count = int(product_reviews.pop(0)) positive_count = 0 negative_count = 0 for _ in range(review_count): review = product_reviews.pop(0) if \\"good\\" in review: positive_count += 1 if \\"bad\\" in review: negative_count += 1 product_scores.append((product_name, positive_count, negative_count)) # Sort based on the criteria: # 1. Higher number of positive reviews # 2. Lower number of negative reviews # 3. Alphabetically by product name product_scores.sort(key=lambda x: (-x[1], x[2], x[0])) return [product[0] for product in product_scores] def main(): import sys input = sys.stdin.read data = input().split('n') n = int(data.pop(0)) product_reviews = data[:-1] sorted_products = rank_products(n, product_reviews) for product in sorted_products: print(product) if __name__ == \\"__main__\\": main()"},{"question":"def check_time_slots(n, participants): Check if participants have overlapping or invalid time slots. Parameters: n (int): Number of participants participants (list of tuples): List of participants with their time slots Returns: str: \\"All slots are valid\\" if no overlaps or invalid slots, otherwise \\"Invalid slots found\\" >>> check_time_slots(3, [(\\"p1\\", 1, 3, 4, 5), (\\"p2\\", 2, 6, 7, 8), (\\"p3\\", 5, 9, 10, 12, 13, 14)]) \\"All slots are valid\\" >>> check_time_slots(2, [(\\"p1\\", 1, 3, 3, 5, 4, 6), (\\"p2\\", 2, 4, 4, 5, 5, 7)]) \\"Invalid slots found\\" >>> check_time_slots(1, [(\\"p1\\", 1, 2, 2, 3, 3, 4)]) \\"All slots are valid\\" >>> check_time_slots(1, [(\\"p1\\", 1, 3, 2, 4, 4, 5)]) \\"Invalid slots found\\" >>> check_time_slots(1, [(\\"p1\\", 1, 2, 3, 3)]) \\"Invalid slots found\\"","solution":"def check_time_slots(n, participants): Check if participants have overlapping or invalid time slots. Parameters: n (int): Number of participants participants (list of tuples): List of participants with their time slots Returns: str: \\"All slots are valid\\" if no overlaps or invalid slots, otherwise \\"Invalid slots found\\" for participant in participants: pid, slots = participant[0], participant[1:] time_intervals = [] # Parse all time slots into a tuple list (start, end) for i in range(0, len(slots), 2): start, end = slots[i], slots[i + 1] if start >= end: return \\"Invalid slots found\\" time_intervals.append((start, end)) # Sort intervals by start time time_intervals.sort() # Check for any overlap in the sorted intervals for j in range(len(time_intervals) - 1): if time_intervals[j][1] > time_intervals[j + 1][0]: return \\"Invalid slots found\\" return \\"All slots are valid\\" # Example usage: # n = 3 # participants = [ # (\\"p1\\", 1, 3, 4, 5), # (\\"p2\\", 2, 6, 7, 8), # (\\"p3\\", 5, 9, 10, 12, 13, 14) # ] # print(check_time_slots(n, participants))"},{"question":"def lexicographically_smallest_string(s: str, k: int) -> str: Determine the lexicographically smallest string that can be obtained after performing at most k right rotations on the given string s. >>> lexicographically_smallest_string(\\"cba\\", 2) \\"acb\\" >>> lexicographically_smallest_string(\\"abc\\", 1) \\"abc\\" >>> lexicographically_smallest_string(\\"a\\", 1) \\"a\\" >>> lexicographically_smallest_string(\\"dcba\\", 4) \\"abcd\\" >>> lexicographically_smallest_string(\\"dcba\\", 5) \\"abcd\\" >>> lexicographically_smallest_string(\\"abcdef\\", 2) \\"abcdef\\" >>> lexicographically_smallest_string(\\"zyxwvutsrqponmlkjihgfedcba\\", 1000000000) \\"abcdefghijklmnopqrstuvwxyz\\"","solution":"def lexicographically_smallest_string(s, k): def rotate_right(s): return s[-1] + s[:-1] n = len(s) if k >= n: # if k >= n, then any permutation is possible return ''.join(sorted(s)) smallest = s for _ in range(k): s = rotate_right(s) if s < smallest: smallest = s return smallest # Example usage: # print(lexicographically_smallest_string(\\"cba\\", 2)) # Output: \\"acb\\" # print(lexicographically_smallest_string(\\"abc\\", 1)) # Output: \\"abc\\""},{"question":"def count_paint_ways(n): Returns the number of ways to paint n tiles such that no two adjacent tiles have the same color. >>> count_paint_ways(8) 2 >>> count_paint_ways(4) 2 >>> count_paint_ways(2) 2 def get_paint_ways(inputs): For each dataset, returns the number of different ways to paint the floor of n tiles. >>> get_paint_ways([8, 4, 2, 0]) [2, 2, 2] >>> get_paint_ways([10, 0]) [2] >>> get_paint_ways([0]) []","solution":"def count_paint_ways(n): Returns the number of ways to paint n tiles such that no two adjacent tiles have the same color. if n % 2 != 0: return 0 return 2 if n >= 2 else 0 def get_paint_ways(inputs): results = [] for n in inputs: if n == 0: break results.append(count_paint_ways(n)) return results"},{"question":"def minimal_fuel_consumption(N: int, energy_costs: List[int]) -> int: Returns the minimal total energy cost for propelling from the first module to any of the modules. Args: N : int : number of modules energy_costs : list of int : energy costs for each module Returns: int : minimal total energy cost >>> minimal_fuel_consumption(5, [3, 1, 4, 1, 5]) 1 >>> minimal_fuel_consumption(7, [10, 15, 20, 5, 25, 10, 5]) 5 >>> minimal_fuel_consumption(3, [7, 2, 8]) 2","solution":"def minimal_fuel_consumption(N, energy_costs): Returns the minimal total energy cost for propelling from the first module to any of the modules. Args: N : int : number of modules energy_costs : list of int : energy costs for each module Returns: int : minimal total energy cost return min(energy_costs)"},{"question":"def ip_to_binary(ip: str) -> str: Convert an IP address in dotted-decimal format to 32-bit binary representation. Each 8-bit segment should be separated by a space. >>> ip_to_binary(\\"192.168.1.1\\") \\"11000000 10101000 00000001 00000001\\" >>> ip_to_binary(\\"10.0.0.1\\") \\"00001010 00000000 00000000 00000001\\" >>> ip_to_binary(\\"255.255.255.0\\") \\"11111111 11111111 11111111 00000000\\" def convert_ips_to_binary(T: int, ip_list: List[str]) -> List[str]: Convert multiple IP addresses to their binary representations. Parameters: T (int): Number of IP addresses. ip_list (list of str): List containing IP addresses in dotted-decimal format. Returns: list of str: Binary representations (with separated 8-bit segments) of the IP addresses. >>> convert_ips_to_binary(3, [\\"192.168.1.1\\", \\"10.0.0.1\\", \\"255.255.255.0\\"]) [\\"11000000 10101000 00000001 00000001\\", \\"00001010 00000000 00000000 00000001\\", \\"11111111 11111111 11111111 00000000\\"] >>> convert_ips_to_binary(1, [\\"0.0.0.0\\"]) [\\"00000000 00000000 00000000 00000000\\"]","solution":"def ip_to_binary(ip): Convert an IP address in dotted-decimal format to 32-bit binary representation. Each 8-bit segment should be separated by a space. return ' '.join(format(int(octet), '08b') for octet in ip.split('.')) def convert_ips_to_binary(T, ip_list): Convert multiple IP addresses to their binary representations. Parameters: T (int): Number of IP addresses. ip_list (list of str): List containing IP addresses in dotted-decimal format. Returns: list of str: Binary representations (with separated 8-bit segments) of the IP addresses. result = [] for ip in ip_list: result.append(ip_to_binary(ip)) return result"},{"question":"def generate_tree(levels: int) -> str: Generate a tree structure with the specified number of levels. >>> generate_tree(1) \\"*n|n-+\\" >>> generate_tree(2) \\"*n|n-+n |n -+\\" >>> generate_tree(3) \\"*n|n-+n |n -+n |n -+\\" def process_trees(input_data: List[str]) -> str: Process multiple tree structures based on the input data list. >>> process_trees([\\"3\\", \\"1\\", \\"2\\", \\"3\\"]) \\"*n|n-+nn*n|n-+n |n -+nn*n|n-+n |n -+n |n -+\\" >>> process_trees([\\"1\\", \\"1\\"]) \\"*n|n-+\\"","solution":"def generate_tree(levels): Generate a tree structure with the specified number of levels. tree = [\\"*\\"] for i in range(1, levels + 1): tree.append(\\" \\" * (i - 1) + \\"|\\") tree.append(\\" \\" * (i - 1) + \\"-+\\") return \\"n\\".join(tree) def process_trees(input_data): Process multiple tree structures based on the input_data list. T = int(input_data[0]) results = [] for i in range(1, T + 1): levels = int(input_data[i]) results.append(generate_tree(levels)) return \\"nn\\".join(results)"},{"question":"def find_matches(n, m, pairs): Determine if it's possible to schedule matches where each team plays exactly one match. Parameters: n (int): The number of teams. m (int): The number of pairs of teams that can play against each other. pairs (list): A list of tuples where each tuple (a, b) indicates that team a can play against team b. Returns: list: A list of tuples representing the scheduled matches if possible, otherwise -1. Examples: >>> find_matches(4, 3, [(1, 2), (2, 3), (3, 4)]) [(1, 2), (3, 4)] >>> find_matches(3, 2, [(1, 2), (2, 3)]) -1 >>> find_matches(6, 5, [(1, 2), (3, 4), (5, 6), (1, 3), (2, 4)]) [(1, 2), (3, 4), (5, 6)]","solution":"def find_matches(n, m, pairs): from collections import defaultdict import networkx as nx if n % 2 == 1: return -1 graph = defaultdict(list) for a, b in pairs: graph[a].append(b) graph[b].append(a) matching = [] visited = set() def dfs(node, match): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: match[node] = neighbor match[neighbor] = node visited.add(neighbor) return True return False match = {} for node in range(1, n + 1): if node not in visited: if not dfs(node, match): return -1 result = [] matched = set() for a in match: b = match[a] if (a, b) not in matched and (b, a) not in matched: result.append((a, b)) matched.add((a, b)) if len(result) == n // 2: return result else: return -1 # Wrapper to accept input in the required format def schedule_matches(n, m, pair_list): result = find_matches(n, m, pair_list) if result == -1: print(-1) else: for a, b in result: print(a, b)"},{"question":"def verify_and_suggest_friends(data, target_user_id): Verify if a user with the given ID exists and suggest friends based on common hobbies. >>> data = [('alice', 1, 2, 3), ('bob', 2, 4), ('charlie', 5, 6), ('dave', 1, 3, 4)] >>> target_user_id = 'alice' >>> verify_and_suggest_friends(data, target_user_id) 'User foundnbobndave' >>> data = [('alice', 1, 2, 3), ('bob', 4, 5), ('charlie', 6, 7), ('dave', 8, 9)] >>> target_user_id = 'alice' >>> verify_and_suggest_friends(data, target_user_id) 'User found' >>> data = [('alice', 1, 2, 3), ('bob', 2, 3, 4), ('charlie', 5, 6)] >>> target_user_id = 'eva' >>> verify_and_suggest_friends(data, target_user_id) 'User not found' >>> data = [('alice', 1, 2), ('bob', 2, 3), ('charlie', 1, 3), ('dave', 2, 4)] >>> target_user_id = 'alice' >>> verify_and_suggest_friends(data, target_user_id) 'User foundnbobncharliendave'","solution":"def verify_and_suggest_friends(data, target_user_id): Verify if a user with the given ID exists and suggest friends based on common hobbies. Parameters: data (list of tuples): List containing tuples, where each tuple represents a user and their hobbies. The first item in each tuple is a user ID (string) and the remaining items are hobbies (ints). target_user_id (str): The user ID to be verified and for whom friends are suggested. Returns: str: A message indicating whether the target user was found and suggesting friends. user_hobbies = {} for entry in data: user_id, hobbies = entry[0], entry[1:] user_hobbies[user_id] = set(hobbies) if target_user_id not in user_hobbies: return 'User not found' target_hobbies = user_hobbies[target_user_id] friends = [user_id for user_id, hobbies in user_hobbies.items() if user_id != target_user_id and target_hobbies & hobbies] output = \\"User foundn\\" + \\"n\\".join(friends) if friends else \\"User found\\" return output"},{"question":"def calculate_total_time(datasets): Calculates the total time spent on activities for each dataset. >>> calculate_total_time([[ ... ('08:00', '09:30'), ... ('10:15', '11:45'), ... ('13:00', '14:30') ... ]]) [270] >>> calculate_total_time([[ ... ('09:00', '10:30'), ... ('11:15', '12:45') ... ]]) [180] pass def gather_datasets(input_data): Convert raw input string into list of datasets. >>> gather_datasets(\\"3n08:00 09:30n10:15 11:45n13:00 14:30n2n09:00 10:30n11:15 12:45n0\\") [ [('08:00', '09:30'), ('10:15', '11:45'), ('13:00', '14:30')], [('09:00', '10:30'), ('11:15', '12:45')] ] >>> gather_datasets(\\"0\\") [] pass import pytest def test_calculate_total_time_with_sample_input(): input_data = \\"3n08:00 09:30n10:15 11:45n13:00 14:30n2n09:00 10:30n11:15 12:45n0\\" datasets = gather_datasets(input_data) result = calculate_total_time(datasets) expected = [270, 180] assert result == expected def test_all_activities_in_one_day(): input_data = \\"1n00:00 23:59n0\\" datasets = gather_datasets(input_data) result = calculate_total_time(datasets) expected = [1439] # One minute less than a full day (1440 minutes) assert result == expected def test_multiple_short_activities(): input_data = \\"3n00:00 00:05n23:50 23:55n12:00 12:10n0\\" datasets = gather_datasets(input_data) result = calculate_total_time(datasets) expected = [20] # 5 + 5 + 10 = 20 minutes assert result == expected def test_minutes_boundary(): input_data = \\"2n00:00 00:01n23:59 23:59n0\\" datasets = gather_datasets(input_data) result = calculate_total_time(datasets) expected = [1] # 1 + 0 = 1 minute assert result == expected def test_empty_input(): input_data = \\"0\\" datasets = gather_datasets(input_data) result = calculate_total_time(datasets) expected = [] assert result == expected","solution":"def calculate_total_time(datasets): Calculates the total time spent on activities for each dataset. total_times = [] for dataset in datasets: total_minutes = 0 for start_time, end_time in dataset: start_hour, start_minute = map(int, start_time.split(':')) end_hour, end_minute = map(int, end_time.split(':')) start_total_minutes = start_hour * 60 + start_minute end_total_minutes = end_hour * 60 + end_minute total_minutes += (end_total_minutes - start_total_minutes) total_times.append(total_minutes) return total_times def gather_datasets(input_data): Convert raw input string into list of datasets. lines = input_data.strip().split('n') datasets = [] i = 0 while i < len(lines): n = int(lines[i]) if n == 0: break dataset = [] for j in range(1, n + 1): start_time, end_time = lines[i + j].split() dataset.append((start_time, end_time)) datasets.append(dataset) i += n + 1 return datasets"},{"question":"def findPair(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers such that they add up to the target sum. If no such pair exists, returns an empty list. >>> findPair([2, 7, 11, 15], 9) [0, 1] >>> findPair([3, 2, 4], 6) [1, 2] >>> findPair([3, 3], 6) [0, 1]","solution":"def findPair(nums, target): Returns the indices of the two numbers such that they add up to the target sum. If no such pair exists, returns an empty list. # Dictionary to store the potential number needed to reach the target sum and its index num_dict = {} for i, num in enumerate(nums): complement = target - num if complement in num_dict: return [num_dict[complement], i] num_dict[num] = i return []"},{"question":"def max_floors(N, H, C, B): Returns the maximum number of unique-height floors that can be constructed within the given budget. :param N: Integer, number of possible floors. :param H: List of integers, heights of each floor. :param C: List of integers, costs associated with each floor. :param B: Integer, the budget constraint. :return: Integer, maximum number of unique-height floors that can be constructed. # Your code here # Unit tests import pytest def test_example_1(): N = 5 H = [1, 2, 3, 2, 4] C = [10, 20, 30, 40, 25] B = 50 assert max_floors(N, H, C, B) == 2 def test_example_2(): N = 4 H = [5, 5, 5, 5] C = [10, 10, 10, 10] B = 25 assert max_floors(N, H, C, B) == 1 def test_example_3(): N = 3 H = [3, 1, 2] C = [15, 10, 20] B = 30 assert max_floors(N, H, C, B) == 2 def test_no_duplicate_heights_within_budget(): N = 5 H = [1, 2, 3, 4, 5] C = [10, 10, 10, 10, 10] B = 50 assert max_floors(N, H, C, B) == 5 def test_duplicate_heights_over_budget(): N = 6 H = [1, 2, 2, 3, 4, 5] C = [10, 40, 30, 20, 50, 20] B = 60 assert max_floors(N, H, C, B) == 3 def test_large_budget(): N = 4 H = [10, 20, 30, 40] C = [1000000, 2000000, 3000000, 4000000] B = 10000000 assert max_floors(N, H, C, B) == 4 def test_minimal_case(): N = 1 H = [1] C = [1] B = 1 assert max_floors(N, H, C, B) == 1 if __name__ == \\"__main__\\": pytest.main()","solution":"def max_floors(N, H, C, B): Returns the maximum number of unique-height floors that can be constructed within the given budget. :param N: Integer, number of possible floors. :param H: List of integers, heights of each floor. :param C: List of integers, costs associated with each floor. :param B: Integer, the budget constraint. :return: Integer, maximum number of unique-height floors that can be constructed. floors = list(zip(H, C)) floors.sort(key=lambda x: x[1]) # Sort floors by cost selected_heights = set() total_cost = 0 count = 0 for height, cost in floors: if height not in selected_heights and total_cost + cost <= B: selected_heights.add(height) total_cost += cost count += 1 return count"},{"question":"def count_successful_sends(n: int, q: int, logs: List[str], queries: List[Tuple[int, int]]) -> List[int]: Determine the number of successfully sent messages by all employees in the given time intervals. Args: n: Number of log entries. q: Number of queries. logs: List of log entries. queries: List of time intervals queries, each represented by a tuple (t1, t2). Returns: A list of integers where each integer represents the number of successfully sent messages in the corresponding query interval. >>> logs = [ \\"send Alice to Bob at 1\\", \\"send Alice to Carol at 3\\", \\"error Alice at 3\\", \\"send Bob to Alice at 4\\", \\"send Carol to Alice at 5\\", \\"error Carol at 5\\" ] >>> queries = [(2, 4), (1, 5)] >>> count_successful_sends(6, 2, logs, queries) [1, 3]","solution":"def count_successful_sends(n, q, logs, queries): from collections import defaultdict sends = defaultdict(list) errors = defaultdict(set) for log in logs: if log.startswith(\\"send\\"): parts = log.split() sender = parts[1] time = int(parts[-1]) sends[time].append(sender) elif log.startswith(\\"error\\"): parts = log.split() sender = parts[1] time = int(parts[-1]) errors[time].add(sender) results = [] for t1, t2 in queries: count = 0 for time in range(t1, t2 + 1): for sender in sends[time]: if sender not in errors[time]: count += 1 errors.pop(time, None) results.append(count) return results"},{"question":"def josephus(n: int, k: int) -> int: Determines the safe position (0-indexed) in the Josephus problem. :param n: Total number of people :param k: Step size for elimination :return: Safe position (0-indexed) >>> josephus(7, 3) == 3 >>> josephus(10, 2) == 4","solution":"def josephus(n: int, k: int) -> int: Determines the safe position (0-indexed) in the Josephus problem. :param n: Total number of people :param k: Step size for elimination :return: Safe position (0-indexed) if n == 1: return 0 # Initialize the position of the last survivor safe_position = 0 # Iterate through each step to find the safe position for i in range(2, n + 1): safe_position = (safe_position + k) % i return safe_position"},{"question":"def process_students_data(n: int, students: List[Tuple[str, int]]) -> Tuple[float, List[str]]: Returns the class average grade rounded to 2 decimal places and a sorted list of students with their ranks prefixed. Example: >>> process_students_data(3, [(\\"John\\", 75), (\\"Alice\\", 85), (\\"Bob\\", 90)]) (83.33, [\\"1. Bob\\", \\"2. Alice\\", \\"3. John\\"]) >>> process_students_data(4, [(\\"Daisy\\", 90), (\\"Rose\\", 85), (\\"Jack\\", 85), (\\"Lily\\", 90)]) (87.50, [\\"1. Daisy\\", \\"1. Lily\\", \\"3. Jack\\", \\"3. Rose\\"]) from typing import List, Tuple # Test cases def test_case_1(): students = [(\\"John\\", 75), (\\"Alice\\", 85), (\\"Bob\\", 90)] expected_avg = 83.33 expected_sorted_students = [\\"1. Bob\\", \\"2. Alice\\", \\"3. John\\"] avg, sorted_students = process_students_data(3, students) assert avg == expected_avg assert sorted_students == expected_sorted_students def test_case_2(): students = [(\\"Daisy\\", 90), (\\"Rose\\", 85), (\\"Jack\\", 85), (\\"Lily\\", 90)] expected_avg = 87.50 expected_sorted_students = [\\"1. Daisy\\", \\"1. Lily\\", \\"3. Jack\\", \\"3. Rose\\"] avg, sorted_students = process_students_data(4, students) assert avg == expected_avg assert sorted_students == expected_sorted_students def test_case_3(): students = [(\\"Anna\\", 60), (\\"Betty\\", 75), (\\"Clara\\", 75), (\\"Diana\\", 90)] expected_avg = 75.0 expected_sorted_students = [\\"1. Diana\\", \\"2. Betty\\", \\"2. Clara\\", \\"4. Anna\\"] avg, sorted_students = process_students_data(4, students) assert avg == expected_avg assert sorted_students == expected_sorted_students def test_case_with_ties(): students = [(\\"Student1\\", 100), (\\"Student2\\", 100), (\\"Student3\\", 70), (\\"Student4\\", 50), (\\"Student5\\", 70)] expected_avg = 78.0 expected_sorted_students = [\\"1. Student1\\", \\"1. Student2\\", \\"3. Student3\\", \\"3. Student5\\", \\"5. Student4\\"] avg, sorted_students = process_students_data(5, students) assert avg == expected_avg assert sorted_students == expected_sorted_students def test_edge_case_no_students(): students = [] expected_avg = 0.00 expected_sorted_students = [] avg, sorted_students = process_students_data(0, students) assert avg == expected_avg assert sorted_students == expected_sorted_students def test_edge_case_single_student(): students = [(\\"Alice\\", 95)] expected_avg = 95.0 expected_sorted_students = [\\"1. Alice\\"] avg, sorted_students = process_students_data(1, students) assert avg == expected_avg assert sorted_students == expected_sorted_students","solution":"def process_students_data(n, students): Returns the class average grade rounded to 2 decimal places and a sorted list of students with their ranks prefixed. :param n: int: Number of students :param students: List of tuples: Each tuple contains the name and grade of a student :return: (float, list): The class average grade and the sorted list of students with ranks if n == 0: return 0.00, [] # Calculate class average total_grade = sum(grade for name, grade in students) average_grade = round(total_grade / n, 2) # Sort students by grade (descending) and by name (ascending) for ties sorted_students = sorted(students, key=lambda x: (-x[1], x[0])) # Assign ranks result = [] current_rank = 1 for i in range(n): if i > 0 and sorted_students[i][1] != sorted_students[i - 1][1]: current_rank = i + 1 result.append(f\\"{current_rank}. {sorted_students[i][0]}\\") return average_grade, result"},{"question":"def rotate_array(n: int, k: int, arr: List[int]) -> List[int]: Rotates the array arr to the right by k steps. Parameters: n (int): Length of the array arr. k (int): Number of rotation steps. arr (List[int]): List of integers representing the array. Returns: List[int]: Rotated array. >>> rotate_array(7, 3, [1, 2, 3, 4, 5, 6, 7]) [5, 6, 7, 1, 2, 3, 4] >>> rotate_array(6, 2, [-1, -100, 3, 99, 0, 38]) [0, 38, -1, -100, 3, 99]","solution":"def rotate_array(n, k, arr): Rotates the array arr to the right by k steps. Parameters: n (int): Length of the array arr. k (int): Number of rotation steps. arr (list): List of integers representing the array. Returns: list: Rotated array. k %= n # In case k is greater than n, take modulo to reduce unnecessary rotations return arr[-k:] + arr[:-k]"},{"question":"def find_subsequence_boundaries(T, test_cases): Given the number of test cases and a list of tuples containing each test case's sequence, find the smallest subsequence that needs to be sorted to make the entire sequence sorted. Args: T : int : number of test cases test_cases : List[Tuple[int, List[int]]] : list of test cases where each test case is a tuple (length of sequence, sequence itself) Returns: List[Tuple[int, int]] : list of tuples containing start and end indices (0-based) of the smallest subsequence that needs to be sorted. Examples: >>> find_subsequence_boundaries(2, [(7, [1, 3, 5, 4, 2, 6, 7]), (5, [1, 2, 3, 4, 5])]) [(1, 4), (0, 0)] >>> find_subsequence_boundaries(1, [(4, [4, 3, 2, 1])]) [(0, 3)] >>> find_subsequence_boundaries(1, [(8, [1, 2, 6, 4, 5, 3, 7, 8])]) [(2, 5)] >>> find_subsequence_boundaries(1, [(3, [3, 2, 1])]) [(0, 2)] >>> find_subsequence_boundaries(1, [(8, [1, 3, 3, 5, 4, 2, 6, 7])]) [(1, 5)]","solution":"def find_subsequence_boundaries(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] start, end = 0, 0 # Find the first element which is out of the increasing order for j in range(N - 1): if sequence[j] > sequence[j + 1]: start = j break else: # If the full loop runs, then the list is already sorted results.append((0, 0)) continue # Find the first element from end which is out of the decreasing order for j in range(N - 1, 0, -1): if sequence[j] < sequence[j - 1]: end = j break # Find the minimum and maximum in the identified subarray sub_min = min(sequence[start:end+1]) sub_max = max(sequence[start:end+1]) # Extend the subsequence to include any out-of-order element for j in range(start): if sequence[j] > sub_min: start = j break for j in range(end + 1, N): if sequence[j] < sub_max: end = j break results.append((start, end)) return results"},{"question":"def allocate_books(books, k): Allocate books to students in a way that the maximum number of pages assigned to a student is minimized. :param books: List[int] - An array of integers representing the number of pages in each book. :param k: int - The number of students. :return: int - The minimum possible maximum number of pages assigned to a student. Example: >>> allocate_books([12, 34, 67, 90], 2) 113 >>> allocate_books([12, 34, 67, 90], 4) 90","solution":"def can_allocate_books(books, n, k, max_pages): Helper function to check if it's possible to allocate books such that the maximum number of pages assigned to a student is less than or equal to max_pages. students_required = 1 current_pages = 0 for pages in books: if current_pages + pages > max_pages: students_required += 1 current_pages = pages if students_required > k: return False else: current_pages += pages return True def allocate_books(books, k): Returns the minimum possible maximum number of pages assigned to a student. if len(books) < k: return -1 # In case there are more students than books which is invalid as per the constraints. low, high = max(books), sum(books) result = high while low <= high: mid = (low + high) // 2 if can_allocate_books(books, len(books), k, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def longest_shorter_consecutive_path(grid): Returns the longest number of consecutive shorter buildings in a straight line (horizontal, vertical, or diagonal) in the city grid. >>> grid = [ ... [5, 1, 2, 3], ... [4, 6, 1, 1], ... [3, 1, 7, 1], ... [2, 1, 1, 8] ... ] >>> longest_shorter_consecutive_path(grid) 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> longest_shorter_consecutive_path(grid) 0 pass","solution":"def longest_shorter_consecutive_path(grid): Returns the longest number of consecutive shorter buildings in a straight line (horizontal, vertical, or diagonal) in the city grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) max_len = 0 def check_line(i, j, di, dj): count = 1 height = grid[i][j] while 0 <= i+di < m and 0 <= j+dj < n and grid[i+di][j+dj] < height: count += 1 height = grid[i+di][j+dj] i += di j += dj return count for i in range(m): for j in range(n): max_len = max(max_len, check_line(i, j, 0, 1)) max_len = max(max_len, check_line(i, j, 1, 0)) max_len = max(max_len, check_line(i, j, 1, 1)) max_len = max(max_len, check_line(i, j, 1, -1)) return max_len - 1 if max_len > 1 else 0"},{"question":"def count_primes_in_range(L: int, R: int) -> int: Returns the count of prime numbers between L and R (inclusive). >>> count_primes_in_range(10, 20) 4 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(13, 13) 1 >>> count_primes_in_range(8, 10) 0 >>> count_primes_in_range(1, 50) 15 >>> count_primes_in_range(1, 1) 0 >>> count_primes_in_range(2, 2) 1 >>> count_primes_in_range(1000000, 1000000) 0","solution":"def count_primes_in_range(L, R): Returns the count of prime numbers between L and R (inclusive). def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True count = 0 for num in range(L, R + 1): if is_prime(num): count += 1 return count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 from solution import length_of_longest_substring def test_example_cases(): assert length_of_longest_substring(\\"abcabcbb\\") == 3 assert length_of_longest_substring(\\"bbbbb\\") == 1 assert length_of_longest_substring(\\"pwwkew\\") == 3 def test_empty_string(): assert length_of_longest_substring(\\"\\") == 0 def test_single_character(): assert length_of_longest_substring(\\"a\\") == 1 def test_all_unique_characters(): assert length_of_longest_substring(\\"abcdef\\") == 6 def test_repeating_patterns(): assert length_of_longest_substring(\\"abcabcabc\\") == 3 def test_long_random_string(): assert length_of_longest_substring(\\"dvdf\\") == 3 def test_mix_of_characters(): assert length_of_longest_substring(\\"aab\\") == 2 def test_complex_pattern(): assert length_of_longest_substring(\\"anviaj\\") == 5","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. n = len(s) max_len = 0 start = 0 seen = {} for end in range(n): if s[end] in seen: start = max(start, seen[s[end]] + 1) seen[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def length_of_LIS(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given list. >>> length_of_LIS([1]) == 1 >>> length_of_LIS([1, 2, 3, 4, 5]) == 5 >>> length_of_LIS([5, 4, 3, 2, 1]) == 1 >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_LIS([1, 2, 2, 2, 3]) == 3 >>> length_of_LIS([10, 1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 >>> length_of_LIS([8, 3, 6, 5, 9, 7, 4, 10]) == 4","solution":"from typing import List def length_of_LIS(arr: List[int]) -> int: Returns the length of the longest strictly increasing subsequence in the given list. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS values for all indexes as 1 # Compute optimized LIS values in a bottom-up manner for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis[] return max(lis)"},{"question":"from collections import deque def shortest_path_maze(grid): Given a 2D grid of size \`n x m\` representing a maze where \`1\` represents walls and \`0\` represents paths, determine the shortest path from the top-left corner \`(0,0)\` to the bottom-right corner \`(n-1,m-1)\` while avoiding the walls. You can move up, down, left, or right, but you cannot move through the walls. If there is no possible path, return \`-1\`. Args: grid (List[List[int]]): A 2D list representing the maze grid. Returns: int: The length of the shortest path or -1 if no such path exists. Examples: >>> grid = [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ] >>> shortest_path_maze(grid) 7 >>> grid = [ ... [0, 1], ... [1, 0] ... ] >>> shortest_path_maze(grid) -1 pass","solution":"from collections import deque def shortest_path_maze(grid): Function to find the shortest path in a maze from top-left to bottom-right. Returns the length of the shortest path or -1 if no path exists. if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == n-1 and y == m-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def is_subsequence(s: str, t: str) -> str: Checks if t is a subsequence of s. :param s: The original string. :param t: The target subsequence string. :return: \\"Yes\\" if t is a subsequence of s, otherwise \\"No\\". >>> is_subsequence(\\"abcde\\", \\"ace\\") \\"Yes\\" >>> is_subsequence(\\"abcde\\", \\"aec\\") \\"No\\"","solution":"def is_subsequence(s, t): Checks if t is a subsequence of s. :param s: The original string. :param t: The target subsequence string. :return: \\"Yes\\" if t is a subsequence of s, otherwise \\"No\\". s_index, t_index = 0, 0 while s_index < len(s) and t_index < len(t): if s[s_index] == t[t_index]: t_index += 1 s_index += 1 return \\"Yes\\" if t_index == len(t) else \\"No\\""},{"question":"def min_operations_to_non_palindromic(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Find the minimum number of operations required to make the string non-palindromic. Args: - t (int): Number of test cases. - test_cases (List[Tuple[int, str]]): A list containing tuples of the length of the string and the string itself. Returns: - List[int]: A list containing the minimum number of operations required for each test case. Examples: >>> min_operations_to_non_palindromic(3, [(5, 'abcba'), (3, 'aaa'), (4, 'abcd')]) [1, 1, 0] >>> min_operations_to_non_palindromic(1, [(1, 'a')]) [1]","solution":"def min_operations_to_non_palindromic(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] if s == s[::-1]: if n == 1: results.append(1) else: results.append(1) else: results.append(0) return results"},{"question":"def check_qualification(N: int, T: int, race_times: List[int]) -> List[str]: Determines if each participant qualifies based on their race times and the time limit T. Parameters: N (int): Number of participants. T (int): Total time limit for the race. race_times (list): List of race completion times for each participant. Returns: list: List containing \\"QUALIFIED\\" or \\"DISQUALIFIED\\" for each participant. >>> check_qualification(4, 120, [110, 130, 115, 90]) [\\"QUALIFIED\\", \\"DISQUALIFIED\\", \\"QUALIFIED\\", \\"QUALIFIED\\"] >>> check_qualification(3, 100, [90, 110, 70]) [\\"QUALIFIED\\", \\"DISQUALIFIED\\", \\"QUALIFIED\\"]","solution":"def check_qualification(N, T, race_times): Determines if each participant qualifies based on their race times and the time limit T. Parameters: N (int): Number of participants. T (int): Total time limit for the race. race_times (list): List of race completion times for each participant. Returns: list: List containing \\"QUALIFIED\\" or \\"DISQUALIFIED\\" for each participant. results = [] for time in race_times: if time <= T: results.append(\\"QUALIFIED\\") else: results.append(\\"DISQUALIFIED\\") return results"},{"question":"def sort_timestamps(timestamps): Sorts a list of timestamps in ascending order. Args: timestamps (list): List of timestamp strings in the format \\"yyyy-mm-dd hh:mm:ss\\". Returns: list: Sorted list of timestamp strings. >>> sort_timestamps([ ... \\"2022-09-15 12:45:30\\", ... \\"2021-06-10 03:15:45\\", ... \\"2023-01-01 00:00:00\\" ... ]) == [ ... \\"2021-06-10 03:15:45\\", ... \\"2022-09-15 12:45:30\\", ... \\"2023-01-01 00:00:00\\" ... ]","solution":"def sort_timestamps(timestamps): Sorts a list of timestamps in ascending order. Args: timestamps (list): List of timestamp strings in the format \\"yyyy-mm-dd hh:mm:ss\\". Returns: list: Sorted list of timestamp strings. return sorted(timestamps)"},{"question":"def getPascalRow(K: int) -> List[int]: Returns the K-th row (0-indexed) of Pascal's Triangle. Example 1: >>> getPascalRow(3) [1, 2, 1] Example 2: >>> getPascalRow(5) [1, 4, 6, 4, 1] pass","solution":"def getPascalRow(K): Returns the K-th row (0-indexed) of Pascal's Triangle. if K == 0: return [1] row = [1] for i in range(1, K+1): row.append(row[-1] * (K - i + 1) // i) return row"},{"question":"def minimum_platforms(n, train_times): Determine the minimum number of platforms required for the given train times. Parameters: n (int): Number of trains train_times (list of tuples): List of tuples where each tuple contains arrival and departure times of a train Returns: int: Minimum number of platforms required >>> minimum_platforms(6, [(900, 910), (940, 1200), (950, 1120), (1100, 1130), (1500, 1900), (1800, 2000)]) 3 >>> minimum_platforms(3, [(1000, 1030), (1100, 1130), (1200, 1230)]) 1","solution":"def minimum_platforms(n, train_times): Determine the minimum number of platforms required for the given train times. Parameters: n (int): Number of trains train_times (list of tuples): List of tuples where each tuple contains arrival and departure times of a train Returns: int: Minimum number of platforms required if n == 0: return 0 arrival_times = sorted([time[0] for time in train_times]) departure_times = sorted([time[1] for time in train_times]) platform_needed = 0 max_platform_needed = 0 i = 0 j = 0 while i < n and j < n: if arrival_times[i] < departure_times[j]: platform_needed += 1 i += 1 if platform_needed > max_platform_needed: max_platform_needed = platform_needed else: platform_needed -= 1 j += 1 return max_platform_needed # Reading input - Using this function signature for simplicity if __name__ == \\"__main__\\": n = int(input()) train_times = [] for _ in range(n): arrival, departure = map(int, input().strip().split()) train_times.append((arrival, departure)) print(minimum_platforms(n, train_times))"},{"question":"def generate_greeting(name: str, time: str) -> str: Generates a personalized greeting message based on the customer's name and the time of the day. >>> generate_greeting(\\"John\\", \\"morning\\") 'Good Morning John' >>> generate_greeting(\\"Emily\\", \\"night\\") 'Good Night Emily' >>> generate_greeting(\\"Zara\\", \\"afternoon\\") 'Good Afternoon Zara' >>> generate_greeting(\\"Alex\\", \\"midnight\\") Traceback (most recent call last): ... ValueError: Invalid time of day. Must be one of 'morning', 'afternoon', 'evening', 'night'","solution":"def generate_greeting(name, time): Generates a personalized greeting message based on the customer's name and the time of the day. Parameters: name (str): Customer's name. time (str): Time of the day (\\"morning\\", \\"afternoon\\", \\"evening\\", \\"night\\"). Returns: str: Personalized greeting message. greetings = { \\"morning\\": \\"Good Morning\\", \\"afternoon\\": \\"Good Afternoon\\", \\"evening\\": \\"Good Evening\\", \\"night\\": \\"Good Night\\" } if time in greetings: return f\\"{greetings[time]} {name}\\" else: raise ValueError(\\"Invalid time of day. Must be one of 'morning', 'afternoon', 'evening', 'night'\\")"},{"question":"def max_sum_of_trees(N: int, K: int, heights: List[int]) -> int: Calculate the maximum possible sum of the heights of K picked trees such that no two picked trees are consecutive. >>> max_sum_of_trees(7, 3, [10, 20, 30, 40, 50, 60, 70]) 150 >>> max_sum_of_trees(5, 0, [5, 10, 15, 20, 25]) 0 >>> max_sum_of_trees(6, 4, [10, 20, 30, 40, 50, 60]) -1 >>> max_sum_of_trees(3, 1, [1, 2, 3]) 3 >>> max_sum_of_trees(5, 2, [1, 2, 3, 4, 5]) 8","solution":"def max_sum_of_trees(N, K, heights): if K == 0: return 0 if 2 * K - 1 > N: return -1 dp = [[0] * (K + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, K + 1): if i - 2 >= 0: dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + heights[i-1]) else: dp[i][j] = max(dp[i-1][j], heights[i-1]) return dp[N][K] # The main function to read the input and call the solution if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) K = int(data[1]) heights = list(map(int, data[2:])) result = max_sum_of_trees(N, K, heights) print(result)"},{"question":"def most_frequent_digit(n, sequence, m, ranges): Given a sequence of digits and ranges within this sequence, finds the most frequent digit in each range. If multiple digits have the same frequency, returns the smallest digit. >>> most_frequent_digit(10, [1,2,3,0,2,2,3,4,1,0], 3, [[0,9],[1,4],[2,6]]) [2, 2, 2] >>> most_frequent_digit(5, [3,3,3,3,3], 2, [[0,4],[1,3]]) [3, 3] pass def main(input_list): Reads input and invokes the function to find the most frequent digit in given ranges. >>> main([10, [1, 2, 3, 0, 2, 2, 3, 4, 1, 0], 3, [0, 9], [1, 4], [2, 6]]) [2, 2, 2] >>> main([5, [3, 3, 3, 3, 3], 2, [0, 4], [1, 3]]) [3, 3] pass","solution":"from collections import Counter def most_frequent_digit(n, sequence, m, ranges): results = [] for L, R in ranges: segment = sequence[L:R+1] counter = Counter(segment) most_freq_digit = min((digit for digit in counter if counter[digit] == max(counter.values()))) results.append(most_freq_digit) return results # reading input and invoking the function def main(input_list): n = input_list[0] sequence = input_list[1] m = input_list[2] ranges = input_list[3:] results = most_frequent_digit(n, sequence, m, ranges) return results"},{"question":"def evaluate_formula(formula: str, cell_values: dict) -> int: Evaluates a formula in a simplified version of a spreadsheet. :param formula: a string containing the formula to be evaluated :param cell_values: a dictionary containing the cell values :return: the evaluated result of the formula >>> evaluate_formula(\\"A1 + B2\\", {\\"A1\\": 1, \\"B2\\": 2}) 3 >>> evaluate_formula(\\"C1 - D1\\", {\\"C1\\": 5, \\"D1\\": 3}) 2 >>> evaluate_formula(\\"E1 * F1\\", {\\"E1\\": 4, \\"F1\\": 2}) 8 >>> evaluate_formula(\\"G1 / H1\\", {\\"G1\\": 9, \\"H1\\": 3}) 3 >>> evaluate_formula(\\"A1 + B2 * 3\\", {\\"A1\\": 5, \\"B2\\": 4}) 17 >>> evaluate_formula(\\"C1 - D1 / E1\\", {\\"C1\\": 10, \\"D1\\": 6, \\"E1\\": 2}) 7 >>> evaluate_formula(\\"F3 * 2 + G4 - H5\\", {\\"F3\\": 3, \\"G4\\": 8, \\"H5\\": 5}) 9 >>> evaluate_formula(\\"(A1 + B2) * (C3 - D4) / E5\\", {\\"A1\\": 1, \\"B2\\": 2, \\"C3\\": 9, \\"D4\\": 4, \\"E5\\": 3}) 5","solution":"import re def evaluate_formula(formula, cell_values): Evaluates a formula in a simplified version of a spreadsheet. :param formula: a string containing the formula to be evaluated :param cell_values: a dictionary containing the cell values :return: the evaluated result of the formula def replace_match(match): cell = match.group(0) return str(cell_values.get(cell, 0)) # Replace the cell references with their corresponding values formula_with_values = re.sub(r'[A-Z][1-9][0-9]?', replace_match, formula) # Evaluate the formula result = eval(formula_with_values) return result"},{"question":"def longest_continuous_positive_growth(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest continuous period of positive growth for each tree. Args: t (int): The number of test cases. cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer n representing the number of days and a list of integers representing the growth measurements for each day. Returns: List[int]: A list of integers where each integer represents the length of the longest continuous period of positive growth for the corresponding test case. Examples: >>> longest_continuous_positive_growth(3, [(7, [1, 2, 3, -1, 2, 3, 4]), (5, [0, -1, 2, 3, 5]), (4, [-2, -1, -3, -4])]) [3, 3, 0] >>> longest_continuous_positive_growth(1, [(1, [5])]) [1] >>> longest_continuous_positive_growth(1, [(5, [-1, -2, 0, -3, -4])]) [0] >>> longest_continuous_positive_growth(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> longest_continuous_positive_growth(1, [(7, [1, 2, -1, 4, 5, -2, 1])]) [2] >>> longest_continuous_positive_growth(1, [(6, [1, -1, 1, -1, 1, -1])]) [1] pass","solution":"def longest_continuous_positive_growth(t, cases): results = [] for i in range(t): n = cases[i][0] growth_measurements = cases[i][1] max_length = 0 current_length = 0 for growth in growth_measurements: if growth > 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 results.append(max_length) return results"},{"question":"def binary_to_hexadecimal(binary_str: str) -> str: Convert a binary string to its hexadecimal representation in uppercase. >>> binary_to_hexadecimal(\\"1010\\") == \\"A\\" >>> binary_to_hexadecimal(\\"11111010\\") == \\"FA\\" >>> binary_to_hexadecimal(\\"1100100101\\") == \\"325\\" >>> binary_to_hexadecimal(\\"00000001\\") == \\"1\\" >>> binary_to_hexadecimal(\\"00010010\\") == \\"12\\"","solution":"def binary_to_hexadecimal(binary_str): Convert a binary string to its hexadecimal representation in uppercase. Parameters: binary_str (str): A string representing a binary number. Returns: str: The hexadecimal representation of the binary number in uppercase. # Convert binary string to an integer decimal_value = int(binary_str, 2) # Convert integer to hexadecimal and return in uppercase without '0x' prefix hexadecimal_str = hex(decimal_value)[2:].upper() return hexadecimal_str"},{"question":"def min_subsegment_length(n: int, S: int, a: List[int]) -> int: Returns the minimum length of a subsegment with sum greater than or equal to S. If no such subsegment exists, returns -1. >>> min_subsegment_length(8, 15, [1, 2, 3, 4, 5, 6, 7, 8]) == 2 >>> min_subsegment_length(5, 100, [1, 2, 3, 4, 5]) == -1 >>> min_subsegment_length(6, 10, [10, 1, 1, 1, 1, 1]) == 1 >>> min_subsegment_length(6, 10, [1, 1, 1, 1, 1, 10]) == 1 >>> min_subsegment_length(3, 15, [1, 2, 3]) == -1 >>> min_subsegment_length(4, 10, [2, 3, 1, 4]) == 4","solution":"def min_subsegment_length(n, S, a): Returns the minimum length of a subsegment with sum greater than or equal to S. If no such subsegment exists, returns -1. start = 0 curr_sum = 0 min_length = float('inf') for end in range(n): curr_sum += a[end] while curr_sum >= S: min_length = min(min_length, end - start + 1) curr_sum -= a[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def check_point_in_triangle(x1, y1, x2, y2, x3, y3, x, y): Determines if a point (x, y) is inside, on the boundary, or outside of a triangle defined by vertices (x1, y1), (x2, y2), (x3, y3). Returns \\"Inside\\", \\"Boundary\\", or \\"Outside\\". >>> check_point_in_triangle(0, 0, 4, 0, 2, 3, 2, 2) 'Inside' >>> check_point_in_triangle(0, 0, 4, 0, 2, 3, 2, 3) 'Boundary' >>> check_point_in_triangle(0, 0, 4, 0, 2, 3, 5, 5) 'Outside'","solution":"def check_point_in_triangle(x1, y1, x2, y2, x3, y3, x, y): Determines if a point (x, y) is inside, on the boundary, or outside of a triangle defined by vertices (x1, y1), (x2, y2), (x3, y3). Returns \\"Inside\\", \\"Boundary\\", or \\"Outside\\". def sign(x1, y1, x2, y2, x3, y3): return (x1 - x3) * (y2 - y3) - (x2 - x3) * (y1 - y3) d1 = sign(x, y, x1, y1, x2, y2) d2 = sign(x, y, x2, y2, x3, y3) d3 = sign(x, y, x3, y3, x1, y1) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) if not (has_neg and has_pos): # Now check if the point is on the boundary if d1 == 0 or d2 == 0 or d3 == 0: return \\"Boundary\\" else: return \\"Inside\\" else: return \\"Outside\\""},{"question":"def find_best_day_closest_to_target(D, T, days): Analyze the daily diet logs and identify the day where the total calorie intake is closest to a specified target without exceeding it. Parameters: D (int): Number of days in the diet plan. T (int): Target calorie count for each day. days (List[List[int]]): A list where each element is a list indicating the calorie counts of dishes for a particular day. Returns: int: The day number which has the total calorie count closest to the target without exceeding it. Example: >>> D = 3 >>> T = 1500 >>> days = [ ... [800, 600, 300], ... [1000, 400], ... [200, 300, 700, 500] ... ] >>> find_best_day_closest_to_target(D, T, days) 2 pass def test_find_best_day_closest_to_target(): D = 3 T = 1500 days = [ [800, 600, 300], [1000, 400], [200, 300, 700, 500] ] assert find_best_day_closest_to_target(D, T, days) == 2 D = 4 T = 2000 days = [ [800, 600, 300], [1500], [800, 1200], [200, 300, 200, 100] ] assert find_best_day_closest_to_target(D, T, days) == 3 D = 2 T = 1000 days = [ [800, 100, 50], [400, 500, 200] ] assert find_best_day_closest_to_target(D, T, days) == 1 D = 3 T = 2000 days = [ [300, 400, 500], [600, 700, 800], [500, 500, 600] ] assert find_best_day_closest_to_target(D, T, days) == 3 D = 1 T = 500 days = [ [100, 200, 100] ] assert find_best_day_closest_to_target(D, T, days) == 1 if __name__ == \\"__main__\\": test_find_best_day_closest_to_target()","solution":"def find_best_day_closest_to_target(D, T, days): closest_day = -1 closest_calories = -1 for day_index in range(D): daily_dishes = days[day_index] daily_calories = sum(daily_dishes) if daily_calories <= T and daily_calories > closest_calories: closest_calories = daily_calories closest_day = day_index + 1 # converting 0-based index to 1-based day number return closest_day"},{"question":"def max_non_overlapping_sessions(n, sessions): Find the maximum number of non-overlapping sessions that can be scheduled for the conference. Input: - n: an integer representing the number of sessions (1 ≤ n ≤ 10^5) - sessions: a list of tuples, where each tuple contains two integers representing the start and end times of a session (1 ≤ start < end ≤ 10^9) Output: - return a single integer representing the maximum number of non-overlapping sessions that can be scheduled. Example usage: >>> max_non_overlapping_sessions(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_sessions(4, [(1, 2), (2, 3), (3, 4), (1, 5)]) 3","solution":"def max_non_overlapping_sessions(n, sessions): This function takes in the number of sessions n and a list of sessions, each represented by a start and end time, and returns the maximum number of non-overlapping sessions that can be scheduled. # Sort the sessions by end time sessions.sort(key=lambda x: x[1]) # Initialize count of non-overlapping sessions and the end time of the last added session count = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: # If the current session starts after the last added session ends, add this session count += 1 last_end_time = end return count"},{"question":"def count_swaps_to_sort_carrots(n: int, carrots: List[int]) -> int: Returns the minimum number of swaps (each costing one carrot coin) required to sort the given list of carrots in non-decreasing order. :param n: int, number of carrots :param carrots: list of int, lengths of the carrots :return: int, minimum number of swaps required >>> count_swaps_to_sort_carrots(5, [4, 3, 2, 5, 1]) 7 >>> count_swaps_to_sort_carrots(3, [1, 2, 3]) 0 pass","solution":"def count_swaps_to_sort_carrots(n, carrots): Returns the minimum number of swaps (each costing one carrot coin) required to sort the given list of carrots in non-decreasing order. :param n: int, number of carrots :param carrots: list of int, lengths of the carrots :return: int, minimum number of swaps required count_swaps = 0 for i in range(n): for j in range(0, n - i - 1): if carrots[j] > carrots[j + 1]: carrots[j], carrots[j + 1] = carrots[j + 1], carrots[j] count_swaps += 1 return count_swaps"}]`),j={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},E={class:"card-container"},P={key:0,class:"empty-state"},I=["disabled"],D={key:0},M={key:1};function z(r,e,u,m,i,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",E,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),n("span",M,"Loading...")):(s(),n("span",D,"See more"))],8,I)):l("",!0)])}const F=_(j,[["render",z],["__scopeId","data-v-2d279a81"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/68.md","filePath":"guide/68.md"}'),O={name:"guide/68.md"},G=Object.assign(O,{setup(r){return(e,u)=>(s(),n("div",null,[v(F)]))}});export{Y as __pageData,G as default};
