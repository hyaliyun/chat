import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(s,e,l,m,r,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-a206ff90"]]),S=JSON.parse('[{"question":"# Problem Statement You are developing a function to track the monthly expenses for a user. Each expense is categorized into specific types, and the function needs to determine the total expenditure for each category over a given period. Write a function named `calculate_monthly_expenses` that takes a list of tuples where each tuple consists of a string representing the category and an integer representing the amount spent in that category. The function should return a dictionary where each key is a category and the value is the total amount spent in that category. # Input * `expenses` (list of tuples): A list where each tuple contains: * a string representing the category (e.g., \\"Food\\", \\"Transportation\\", \\"Entertainment\\", etc.). * an integer representing the expense amount in that category. # Output * A dictionary where each key is a category (string) and the value is the total amount spent (integer) in that category. # Examples ```python # Example 1 assert calculate_monthly_expenses([(\\"Food\\", 200), (\\"Transportation\\", 50), (\\"Food\\", 150), (\\"Entertainment\\", 100)]) == {\\"Food\\": 350, \\"Transportation\\": 50, \\"Entertainment\\": 100} # Example 2 assert calculate_monthly_expenses([(\\"Groceries\\", 100), (\\"Bills\\", 200), (\\"Groceries\\", 50), (\\"Bills\\", 300)]) == {\\"Groceries\\": 150, \\"Bills\\": 500} # Example 3 assert calculate_monthly_expenses([(\\"Utilities\\", 75), (\\"Transport\\", 25)]) == {\\"Utilities\\": 75, \\"Transport\\": 25} # Example 4 assert calculate_monthly_expenses([(\\"Rent\\", 500), (\\"Rent\\", 500), (\\"Rent\\", 500)]) == {\\"Rent\\": 1500} # Example 5 assert calculate_monthly_expenses([]) == {} ``` # Constraints * Each expense amount is a non-negative integer. * The list of expenses will contain no more than 10^4 entries. * Each category string will be non-empty and have a maximum length of 50 characters. * The total amount for any category will not exceed 10^7. # Performance Requirements * The algorithm should efficiently process the expense list with a linear time complexity, O(n), where n is the number of expenses. # Additional Notes * If the input list is empty, the function should return an empty dictionary. * The function should handle cases where multiple expenses belong to the same category and sum their amounts correctly.","solution":"def calculate_monthly_expenses(expenses): Calculates the total expenses for each category. Parameters: expenses (list of tuples): A list where each tuple contains a category (string) and an amount spent (integer). Returns: dict: A dictionary where each key is a category and the value is the total amount spent in that category. expense_dict = {} for category, amount in expenses: if category in expense_dict: expense_dict[category] += amount else: expense_dict[category] = amount return expense_dict"},{"question":"# Problem Statement A company wants to analyze their employees\' working hours and identify those who are eligible for an overtime bonus. The criterion for eligibility is that an employee has worked more than 40 hours in a week. You are given the working hours of employees for a given week in the form of a list of tuples. Each tuple contains an employee ID (integer) and the total number of hours they worked in that week (integer). Your task is to write a function `find_overtime_employees` that returns a list of employee IDs who are eligible for the overtime bonus. Function Signature ```python def find_overtime_employees(hours: List[Tuple[int, int]]) -> List[int]: pass ``` Input * `hours` (List[Tuple[int, int]]): A list of tuples where each tuple contains an integer `employee_id` and an integer `worked_hours` (1 <= len(hours) <= 1000, 1 <= employee_id <= 100000, 0 <= worked_hours <= 168). Output * A list of integers representing the IDs of employees who worked more than 40 hours in the given week. Example ```python assert find_overtime_employees([(1, 45), (2, 38), (3, 50), (4, 40), (5, 42)]) == [1, 3, 5] assert find_overtime_employees([(1, 35), (2, 38), (3, 40), (4, 30), (5, 28)]) == [] ``` Constraints * Consider edge cases such as when no employee works more than 40 hours or when all employees work more than 40 hours. # Additional Context Ensure your solution is efficient and handles large input sizes effectively.","solution":"from typing import List, Tuple def find_overtime_employees(hours: List[Tuple[int, int]]) -> List[int]: Returns a list of employee IDs who worked more than 40 hours in the given week. overtime_employees = [] for employee_id, worked_hours in hours: if worked_hours > 40: overtime_employees.append(employee_id) return overtime_employees"},{"question":"# Coding Question Scenario In the field of data analytics, it\'s important to identify sections of a dataset where significant changes occur. One common method is to detect \\"local peaks\\" in a sequence of numbers, where a number is considered a peak if it is larger than its immediate neighbors. Task Implement the function `find_local_peaks` to identify all the local peaks in a list of numerical data points. # Function Signature ```python def find_local_peaks(data: list[int]) -> list[int]: ``` # Input * `data`: A list of integers representing the data points. # Output * A list of integers representing the positions (indices) of the local peaks in the input data. # Constraints * The length of `data` will be between 3 and 10^5. * Each element in `data` will be an integer. # Requirements 1. A local peak is defined as an element that is strictly greater than its neighbors. 2. The first and last elements of the list cannot be local peaks since they do not have both neighbors. # Example ```python # Input data = [1, 3, 7, 1, 2, 6, 3, 2, 9, 5] # Output [2, 5, 8] ``` **Notes:** - Use 0-based indexing to indicate positions. - Ensure efficiency to handle large datasets within the given constraints. **Edge cases to consider:** - Sequences with no local peaks. - Handling instances where multiple peaks occur consecutively. - The shortest possible valid input with exactly three elements.","solution":"def find_local_peaks(data: list[int]) -> list[int]: peaks = [] # Iterate from the second element to the second last element for i in range(1, len(data) - 1): if data[i] > data[i - 1] and data[i] > data[i + 1]: peaks.append(i) return peaks"},{"question":"# Coding Assessment Question Context: A fundamental task in programming is to determine the frequency of unique elements in a list. This time, we extend this concept to handle more complex data structures by incorporating both lists and dictionaries within a nested structure. Task: Write a function `count_unique_elements(data: list | dict) -> dict` that counts the frequency of unique elements within a nested list and dictionary structure. Your function should handle any level of nesting and return a dictionary where the keys are the unique elements, and the values are their respective frequencies. Input: * A list or dictionary, `data`, which can contain integers, strings, floats, other lists, or dictionaries nested within each other. Output: * A dictionary representing the frequency of each unique integer, string, or float in the input structure. Constraints: * The data structure can be deeply nested. * The elements can be integers, strings, floats, lists, or dictionaries containing these types. * The structure may contain mixed types and elements. Performance Requirements: * Aim for an O(n) time complexity where n is the total number of elements in the nested structure. * Space complexity should be minimized based on the nesting depth. Example: ```python def count_unique_elements(data: list | dict) -> dict: # Your implementation here # Test cases print(count_unique_elements([1, 2, [3, 1], {\\"a\\": 2, \\"b\\": [1]}])) # Output: {1: 3, 2: 2, 3: 1} print(count_unique_elements({\\"x\\": 1.1, \\"y\\": {\\"z\\": [1.1, 2.2]}})) # Output: {1.1: 2, 2.2: 1} print(count_unique_elements([{\\"a\\": \\"apple\\", \\"b\\": [\\"banana\\", \\"apple\\"]}, \\"banana\\", \\"cat\\"])) # Output: {\\"apple\\": 2, \\"banana\\": 2, \\"cat\\": 1} ``` Note: * Carefully consider the data structure\'s nested nature and ensure a robust solution. * Think through edge cases such as mixed nested empty structures, although elements within the structure are assumed to be present in minimal cases for the problem\'s validity. * The function should correctly iterate through the mixed and arbitrarily nested data hierarchy.","solution":"def count_unique_elements(data): Recursively counts the frequency of unique elements in a nested list or dictionary. freq_dict = {} def count_elements(elem): if isinstance(elem, (int, float, str)): if elem in freq_dict: freq_dict[elem] += 1 else: freq_dict[elem] = 1 elif isinstance(elem, list): for item in elem: count_elements(item) elif isinstance(elem, dict): for key, value in elem.items(): count_elements(key) count_elements(value) count_elements(data) return freq_dict"},{"question":"# Question: Social Media Posts Aggregator You have been hired to develop a function that aggregates recent posts from multiple social media platforms. Your function should fetch recent posts from both the Twitter and Facebook APIs for a given hashtag. It must handle cases where no valid API keys are provided, or the APIs return invalid data. Function Signature: ```python def fetch_social_media_posts(hashtag: str) -> dict: Fetches and aggregates recent posts from Twitter and Facebook for the given hashtag. Args: hashtag (str): The hashtag for which to retrieve recent posts. Do not include the \'#\' character in the hashtag string. Returns: dict: A dictionary containing recent posts from all accessible APIs. Keys are the API names (\\"Twitter\\", \\"Facebook\\") and values are the corresponding JSON responses. Raises: ValueError: If no API keys are provided or if no valid data is returned from any API. ``` Input & Output Formats: - **Input**: A string representing the hashtag (without the \'#\' character). - **Output**: A dictionary containing recent posts from available APIs with the API names as keys. Constraints: - You must use the `requests` library to make API calls. - If no valid API keys or responses are provided, raise a `ValueError` with the message \\"No API keys provided or valid data returned.\\" - Assume the provided helper constants and base URLs: ```python TWITTER_API_KEY = \\"\\" FACEBOOK_API_KEY = \\"\\" TWITTER_URL_BASE = \\"https://api.twitter.com/2/tweets/search/recent\\" FACEBOOK_URL_BASE = \\"https://graph.facebook.com/v11.0/ig_hashtag_search\\" ``` Sample Usage: ```python # Assuming valid API keys are set in the constants result = fetch_social_media_posts(\\"coding\\") print(result) # Expected output format: # { # \\"Twitter\\": {...}, # \\"Facebook\\": {...} # } ``` **Notes**: Both Twitter and Facebook APIs return JSON responses, but the structure might differ. Your implementation should handle these differences appropriately while aggregating the data.","solution":"import requests # Constants (you need to provide valid API keys here for real requests) TWITTER_API_KEY = \\"YOUR_TWITTER_API_KEY\\" FACEBOOK_API_KEY = \\"YOUR_FACEBOOK_API_KEY\\" TWITTER_URL_BASE = \\"https://api.twitter.com/2/tweets/search/recent\\" FACEBOOK_URL_BASE = \\"https://graph.facebook.com/v11.0/ig_hashtag_search\\" def fetch_social_media_posts(hashtag: str) -> dict: headers = { \\"Twitter\\": {\\"Authorization\\": f\\"Bearer {TWITTER_API_KEY}\\"}, \\"Facebook\\": {\\"Authorization\\": f\\"Bearer {FACEBOOK_API_KEY}\\"} } twitter_url = f\\"{TWITTER_URL_BASE}?query=%23{hashtag}\\" facebook_url = f\\"{FACEBOOK_URL_BASE}?user_id=me&q={hashtag}\\" results = {} # Twitter Posts if TWITTER_API_KEY: response = requests.get(twitter_url, headers=headers[\'Twitter\']) if response.status_code == 200: results[\'Twitter\'] = response.json() # Facebook Posts if FACEBOOK_API_KEY: response = requests.get(facebook_url, headers=headers[\'Facebook\']) if response.status_code == 200: results[\'Facebook\'] = response.json() if not results: raise ValueError(\\"No API keys provided or valid data returned.\\") return results"},{"question":"# Scenario and Context You are contributing to a large system that processes various types of datasets. A common task is to manage large collections of objects, and developers often need utility functions to handle these efficiently. One such utility is a class that maintains a subset of elements in sorted order from a larger collection. # Task Description Write a class named `SortedSubset` that takes a list of integers during initialization and keeps iteratively the largest `k` elements in sorted order during multiple additions of new elements. Additionally, include a method to retrieve the current sorted subset efficiently. # Class Signature ```python class SortedSubset: def __init__(self, original_list: List[int], k: int): pass def add(self, value: int): pass def get_sorted_subset(self) -> List[int]: pass ``` # Input and Output - **Inputs**: - `original_list` (List[int]): The initial list of integers. - `k` (int): The number of largest elements to maintain in sorted order. - `value` (int): The new value to be added to the list. - **Output**: - The method `get_sorted_subset` returns a List of integers representing the sorted subset of the largest `k` elements. # Constraints - The list provided in initialization can have up to 10^5 elements. - The value of `k` will be less than or equal to the length of `original_list`. - Each call to `add` will supply a new integer within the range of typical 32-bit integer values. # Examples ```python >>> subset = SortedSubset([10, 20, 30, 40, 50], 3) >>> subset.add(60) >>> subset.get_sorted_subset() [40, 50, 60] >>> subset.add(25) >>> subset.get_sorted_subset() [40, 50, 60] >>> subset.add(45) >>> subset.get_sorted_subset() [45, 50, 60] >>> subset = SortedSubset([5, 1, 6, 2, 8, 3], 4) >>> subset.get_sorted_subset() [3, 5, 6, 8] >>> subset.add(4) >>> subset.get_sorted_subset() [4, 5, 6, 8] ```","solution":"from typing import List import heapq class SortedSubset: def __init__(self, original_list: List[int], k: int): self.k = k self.min_heap = heapq.nlargest(k, original_list)[-k:] heapq.heapify(self.min_heap) def add(self, value: int): if len(self.min_heap) < self.k: heapq.heappush(self.min_heap, value) elif value > self.min_heap[0]: heapq.heapreplace(self.min_heap, value) def get_sorted_subset(self) -> List[int]: return sorted(self.min_heap)"},{"question":"# Coding Question: Longest Substring with At Most Two Distinct Characters Scenario: You have been tasked with analyzing strings to determine the longest substring that contains at most two distinct characters. This feature is part of a text processing system that highlights significant parts of texts based on character diversity. Problem Statement: Write a function `longest_substring_two_distinct(s)` that takes in one parameter: - `s`: A string representing the input text. The function should return an integer representing the length of the longest substring that contains at most two distinct characters. Input: - `s` is a string with `0 <= len(s) <= 10000`. Output: - The function should return an integer representing the length of the longest substring which contains at most two distinct characters. Constraints: - If `s` is an empty string, the function should return `0`. - The input string can consist of lowercase and uppercase English letters. Examples: ```python def longest_substring_two_distinct(s): >>> longest_substring_two_distinct(\\"eceba\\") 3 >>> longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> longest_substring_two_distinct(\\"aaa\\") 3 >>> longest_substring_two_distinct(\\"\\") 0 if not s: return 0 left = 0 max_len = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len ```","solution":"def longest_substring_two_distinct(s): Finds the length of the longest substring that contains at most two distinct characters. Parameters: s (str): Input string Returns: int: Length of the longest substring with at most two distinct characters. if not s: return 0 left = 0 max_len = 0 char_map = {} for right in range(len(s)): char_map[s[right]] = char_map.get(s[right], 0) + 1 while len(char_map) > 2: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"# Task Implement a function to calculate the \\"Water Trap\\" problem. This involves finding the amount of water that can be trapped between blocks after it rains given an array of integers representing the elevation map where the width of each bar is 1. # Requirements: - **Input**: `heights` - a list of non-negative integers representing the height of bars. - **Output**: An integer representing the total units of water trapped after it rains. # Constraints: - The input list will have a length between 1 and (10^5). - The height values in the list will be between 0 and (10^4). # Function Signature: ```python def trap(height: List[int]) -> int: pass ``` # Example: ```python # Example 1 heights = [0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2] # Expected output: 8 # Example 2 heights = [4, 2, 0, 3, 2, 5] # Expected output: 9 ``` # Implementation Notes: 1. You can use a two-pointer approach, dynamic programming, or any other efficient algorithm to solve this problem. 2. Make sure your solution is optimized to handle the upper limit of the input size within acceptable performance constraints. # Test Cases: You should include test cases in your implementation to verify the correctness of your function. The function should pass provided example test cases as well as additional edge cases.","solution":"from typing import List def trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"# Scenario: You are developing a weather dashboard for a travel application. One of the core features is to display the current weather condition of a given city using the OpenWeatherMap API. # Task: Implement a Python function `get_weather(city_name)` that retrieves the current weather information for the specified city from the OpenWeatherMap API and returns it as a dictionary containing the temperature, weather description, and city name. # Function Specification: Input: - `city_name` (string): The name of the city for which the weather information is to be fetched. Output: - A dictionary with the following keys: * `\'temperature\'`: The current temperature in Celsius as a float. * `\'description\'`: A brief description of the weather as a string. * `\'city\'`: The name of the city as a string. Constraints: - Use the OpenWeatherMap API endpoint: `https://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={YOUR_API_KEY}&units=metric`. - You must replace `{YOUR_API_KEY}` with an actual API key obtained from OpenWeatherMap. - Handle errors such as invalid city name, API key errors, network issues, and time-outs appropriately. - Ensure the function responds within 3 seconds. # Example: ```python # Example usage result = get_weather(\\"London\\") print(result) ``` Expected Output: ```python { \'temperature\': 15.0, \'description\': \\"clear sky\\", \'city\': \\"London\\" } ```","solution":"import requests def get_weather(city_name): Fetches current weather information for the specified city from OpenWeatherMap API. Args: city_name (string): The name of the city for which the weather information is to be fetched. Returns: dict: A dictionary with keys \'temperature\', \'description\', and \'city\'. API_KEY = \'YOUR_API_KEY\' # Replace with your actual API key url = f\\"https://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={API_KEY}&units=metric\\" try: response = requests.get(url, timeout=3) response.raise_for_status() # Raise HTTPError for bad responses data = response.json() weather_info = { \'temperature\': data[\'main\'][\'temp\'], \'description\': data[\'weather\'][0][\'description\'], \'city\': data[\'name\'] } return weather_info except requests.exceptions.HTTPError as http_err: print(f\\"HTTP error occurred: {http_err}\\") return None except requests.exceptions.RequestException as req_err: print(f\\"Request error occurred: {req_err}\\") return None"},{"question":"# Problem: Majority Element in Array You are tasked with implementing a function that finds the majority element in an array of integers. The majority element is the element that appears more than ⌊n / 2⌋ times, where `n` is the length of the array. This task requires understanding of array manipulation, hashing, and efficient counting mechanisms. Function Signature ```python def find_majority_element(nums: List[int]) -> int: Finds the majority element in the array. Args: nums (List[int]): List of integers. Returns: int: The majority element or -1 if no majority element exists. pass ``` Input: * **nums (List[int])**: A list of integers, where `1 <= len(nums) <= 10^5` and each integer `-10^9 <= nums[i] <= 10^9`. Output: * Returns the majority element if it exists, otherwise returns -1. Constraints: * Assume the array always has a majority element for general cases unless specified otherwise. * The algorithm should have a time complexity of O(n) and space complexity of O(1) beyond the input list storage. Context: Imagine you are analyzing survey data, where each element of the array represents a particular response. Your task is to identify the most common response, which is crucial for understanding overall trends and making informed decisions. Examples: ```python >>> find_majority_element([3, 2, 3]) 3 >>> find_majority_element([2, 2, 1, 1, 1, 2, 2]) 2 >>> find_majority_element([1, 1, 2, 2, 2, 1, 1]) -1 ``` Notes: * If no majority element exists in the array, the function should return -1. * You may make use of the Boyer-Moore Voting Algorithm for efficient counting and detection.","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Finds the majority element in the array. Args: nums (List[int]): List of integers. Returns: int: The majority element or -1 if no majority element exists. candidate = None count = 0 for num in nums: if count == 0: candidate = num count += 1 if num == candidate else -1 # Verify if candidate is actually the majority element if nums.count(candidate) > len(nums) // 2: return candidate return -1"},{"question":"# **Question 2: Matrix Transposition and Summation** You are given two 2D matrices of integers, and you need to develop two functionalities: 1. **Transpose a matrix**: Implement a function `transpose_matrix(matrix)` that takes a 2D matrix as input and returns its transpose. 2. **Sum of two matrices**: Implement a function `sum_of_matrices(matrix1, matrix2)` that takes two 2D matrices of the same dimension and returns their element-wise sum. Constraints 1. The input matrices will be non-empty and contain integers. 2. Both matrices passed to `sum_of_matrices` will have the same number of rows and columns. Input 1. For the transpose function: - `matrix`: A 2D matrix of integers. 2. For the sum function: - `matrix1`: A 2D matrix of integers. - `matrix2`: A 2D matrix of integers of the same dimension as `matrix1`. Output 1. For the transpose function: - Returns a 2D matrix representing the transpose of the input matrix. 2. For the sum function: - Returns a 2D matrix representing the element-wise sum of the two input matrices. # Example 1. **Using the transpose function:** ```python matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(transpose_matrix(matrix)) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] matrix = [[1, 2], [3, 4], [5, 6]] print(transpose_matrix(matrix)) # Output: [[1, 3, 5], [2, 4, 6]] ``` 2. **Using the sum function:** ```python matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8, 9], [10, 11, 12]] print(sum_of_matrices(matrix1, matrix2)) # Output: [[8, 10, 12], [14, 16, 18]] matrix1 = [[-1, 0], [1, 2]] matrix2 = [[1, -1], [1, 1]] print(sum_of_matrices(matrix1, matrix2)) # Output: [[0, -1], [2, 3]] ``` # Requirements * Implement the `transpose_matrix` function. * Implement the `sum_of_matrices` function. * Ensure proper handling of edge cases. * Maintain efficient time and space complexity. Here\'s a brief implementation sample to give you an understanding: ```python def transpose_matrix(matrix): return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def sum_of_matrices(matrix1, matrix2): return [[matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))] ```","solution":"def transpose_matrix(matrix): Returns the transpose of the input 2D matrix. return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))] def sum_of_matrices(matrix1, matrix2): Returns the element-wise sum of two matrices of the same dimensions. return [[matrix1[i][j] + matrix2[i][j] for j in range(len(matrix1[0]))] for i in range(len(matrix1))]"},{"question":"# Warehouse Robot Path Counting A warehouse uses a grid robot to navigate through storage locations. The robot starts at the top-left corner (0, 0) of an m x n grid and moves either right or down to reach the bottom-right corner (m-1, n-1). Implement an algorithm to count the number of unique paths the robot can take to reach its destination. Requirements 1. Implement `count_robot_paths(m: int, n: int) -> int`, which returns the number of unique paths from the top-left to the bottom-right corner of the grid. 2. Consider edge cases where the grid dimension is 1x1 and larger grids. # Input - Two integers `m` and `n` representing the dimensions of the grid (1 ≤ m, n ≤ 100). # Output - An integer representing the number of unique paths. # Constraints - Efficiently compute the result using dynamic programming due to potential large size of grid. - Clearly define and handle edge cases. Example ```python assert count_robot_paths(1, 1) == 1 # Only one path (the start is also the end) assert count_robot_paths(2, 2) == 2 # Two possible paths: right-down and down-right assert count_robot_paths(3, 3) == 6 # Six possible unique paths ``` Write code to: - Calculate the number of possible unique paths for a grid of dimensions `m x n`. - Use a dynamic programming approach to ensure efficiency and avoid over-constrained recursion depths.","solution":"def count_robot_paths(m, n): Returns the number of unique paths in a m x n grid where the robot can only move right or down. if m == 1 and n == 1: return 1 dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Real-Time Weather Data Aggregator Context: Developing a real-time weather data aggregator helps in consolidating data from different weather stations in a consistent format. The key challenge is ensuring that the data is up-to-date, consolidated accurately, and able to handle the variability in data formats and availability. Task: You are required to implement a function that aggregates weather data from multiple stations. Each station returns a dictionary containing temperature, humidity, and an optional wind speed. Your function should consolidate these dictionaries, compute the average of each parameter, and gracefully handle any missing data. Requirements: 1. **Input**: A list of dictionaries, where each dictionary represents data from a single weather station with keys `temperature`, `humidity`, and optionally `wind_speed`. 2. **Output**: A dictionary with the averaged values of `temperature`, `humidity`, and `wind_speed`. Input and Output Constraints: * Each dictionary will have integer values for `temperature` and `humidity`. * `wind_speed` is optional and, if present, will be an integer. * There will be at least one dictionary in the input list. Implementation: Your solution should: 1. Iterate through the list of dictionaries, extracting the values for `temperature`, `humidity`, and `wind_speed`. 2. Compute the average values of `temperature` and `humidity`. 3. Compute the average value of `wind_speed` only if it is present in at least one dictionary. 4. Return a dictionary with the averaged values. If no `wind_speed` data is present, omit `wind_speed` from the output. Function Signature: ```python def aggregate_weather_data(stations: list) -> dict: pass ``` Example: ```python >>> stations = [ {\'temperature\': 22, \'humidity\': 65, \'wind_speed\': 10}, {\'temperature\': 24, \'humidity\': 60}, {\'temperature\': 23, \'humidity\': 55, \'wind_speed\': 5}, ] >>> aggregate_weather_data(stations) {\'temperature\': 23.0, \'humidity\': 60.0, \'wind_speed\': 7.5} >>> stations = [ {\'temperature\': 20, \'humidity\': 70}, {\'temperature\': 25, \'humidity\': 60}, ] >>> aggregate_weather_data(stations) {\'temperature\': 22.5, \'humidity\': 65.0} ```","solution":"def aggregate_weather_data(stations: list) -> dict: Aggregates weather data from multiple stations, computing the averages for temperature, humidity, and optionally wind speed. :param stations: List of dictionaries, each containing weather data from one station. :return: A dictionary containing the averaged weather data. total_temperature = 0 total_humidity = 0 total_wind_speed = 0 count_wind_speed = 0 station_count = len(stations) for station in stations: total_temperature += station[\'temperature\'] total_humidity += station[\'humidity\'] if \'wind_speed\' in station: total_wind_speed += station[\'wind_speed\'] count_wind_speed += 1 average_temperature = total_temperature / station_count average_humidity = total_humidity / station_count result = { \'temperature\': average_temperature, \'humidity\': average_humidity } if count_wind_speed > 0: average_wind_speed = total_wind_speed / count_wind_speed result[\'wind_speed\'] = average_wind_speed return result"},{"question":"# Problem Statement You have been assigned to simulate a pebble game played on a 2-dimensional grid. The game board is represented as an (n times n) grid (where (n) is an odd number), and you need to determine if all pebbles can be moved towards the center of the board by following a given set of movement rules: 1. A pebble at position ((i, j)) can move to ((i\', j\')) if either: - ((i\', j\') = (i + dx, j + dy)) - ((i\', j\') = (i - dx, j - dy)) 2. After moving, a pebble cannot reside outside the boundaries of the grid. Write a function that, given the initial positions of the pebbles and the directions for movement, determines if all pebbles can be moved to the center, i.e., position ((n // 2, n // 2)). # Function Signature ```python def can_move_all_pebbles(n: int, pebbles: List[Tuple[int, int]], dx: int, dy: int) -> bool: ``` # Input - (n) (integer): The size of the grid (an odd integer where (3 leq n leq 99)). - `pebbles` (list of tuples): Each tuple ((i, j)) represents the initial position of a pebble ((0 leq i, j < n)). - (dx) (integer): The horizontal direction for pebble\'s movement. - (dy) (integer): The vertical direction for pebble\'s movement. # Output - Returns a boolean value (`True` or `False`): - `True` if all pebbles can be moved to the center following the movement rules. - `False` if it\'s not possible for all pebbles to reach the center. # Constraints - (n) will be an odd integer where (3 leq n leq 99). - The list `pebbles` will have at most (n times n) (i.e., all cells may initially contain pebbles). - The movement directions `dx` and `dy` will be non-zero integers such that (|dx|, |dy| leq n//2). # Example ```python assert can_move_all_pebbles(5, [(0, 0), (4, 4)], 1, 1) == True # both pebbles can move to the center (2, 2) assert can_move_all_pebbles(5, [(0, 0), (4, 3)], 1, 2) == False # the pebble in (4, 3) cannot reach the center ``` # Explanation Given the grid size (n), the initial positions of the pebbles, and the movement directions ((dx, dy)), you need to: 1. Verify that (0 leq i, j < n) for all pebbles. 2. Check if each pebble, following the rules of movement, can reach the center ((n // 2, n // 2)). # Extended Scenario Consider you want to simulate multiple rounds of this game with varying sizes and movement rules. Think about how you\'d design a generalized function or structure to handle various scenarios efficiently.","solution":"def can_move_all_pebbles(n, pebbles, dx, dy): Determine if all pebbles can move to the center of the board. Parameters: - n: int, size of the n x n grid. - pebbles: List of tuples, each representing the initial positions of the pebbles. - dx: int, horizontal direction for pebble\'s movement. - dy: int, vertical direction for pebble\'s movement. Returns: - bool: True if all pebbles can move to the center, False otherwise. center = (n // 2, n // 2) def can_reach_center(x, y): # Calculate offsets from the center offset_x = abs(center[0] - x) offset_y = abs(center[1] - y) # Check if these offsets are multiples of dx and dy respectively return (offset_x % dx == 0) and (offset_y % dy == 0) # Iterate through each pebble to check if it can reach the center for x, y in pebbles: if not can_reach_center(x, y): return False return True"},{"question":"# Scenario You are developing a messaging application that includes a feature for sending and receiving Morse code messages. To facilitate this, you need to implement encoding and decoding functions that handle the conversion between text and Morse code. # Task 1. **Implement `text_to_morse` function** - Input: A string `text`. - Output: A string representing the Morse code version of `text`. - Constraints: - Handle both uppercase and lowercase input by converting it to uppercase internally. - Throw a `ValueError` if the input contains unsupported characters (i.e., anything other than letters and digits). 2. **Implement `morse_to_text` function** - Input: A string `morse_code`. - Output: A string representing the decoded text of `morse_code`. - Constraints: - Ensure the input is a valid Morse code string (dot `.` for a shorter signal, dash `-` for a longer signal, single space ` ` between parts of the same letter, and triple space ` ` between letters). - Throw a `ValueError` for invalid Morse code sequences. # Requirements - Encode and decode conform to International Morse Code standards. - Your implementation should match the given doctest examples. - Consider efficient and clean string handling within the constraints of the challenge. # Function Specifications # `text_to_morse(text: str) -> str` - **Input**: A string. - **Output**: A string. # `morse_to_text(morse_code: str) -> str` - **Input**: A string. - **Output**: A string. # Morse Code Mapping ``` A: .- B: -... C: -.-. D: -.. E: . F: ..-. G: --. H: .... I: .. J: .--- K: -.- L: .-.. M: -- N: -. O: --- P: .--. Q: --.- R: .-. S: ... T: - U: ..- V: ...- W: .-- X: -..- Y: -.-- Z: --.. 0: ----- 1: .---- 2: ..--- 3: ...-- 4: ....- 5: ..... 6: -.... 7: --... 8: ---.. 9: ----. ``` # Example Usage ```python # Text to Morse Code Example text = \\"HELLO WORLD\\" morse_code = text_to_morse(text) print(morse_code) # \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" # Morse Code to Text Example morse_code = \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" decoded_text = morse_to_text(morse_code) print(decoded_text) # \\"HELLO WORLD\\" ``` # Additional Considerations - Ensure robustness to handle a variety of valid and invalid inputs. - Be consistent with the Morse code spacing conventions. - Aim for optimized and elegant code solutions. # Solution Template ```python # Morse code conversion dictionary MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } def text_to_morse(text: str) -> str: # Implement your solution here pass def morse_to_text(morse_code: str) -> str: # Implement your solution here pass # Example Usage if __name__ == \\"__main__\\": text = \\"HELLO WORLD\\" morse_code = text_to_morse(text) print(morse_code) # Expected: \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" morse_code = \\".... . .-.. .-.. --- .-- --- .-. .-.. -..\\" decoded_text = morse_to_text(morse_code) print(decoded_text) # Expected: \\"HELLO WORLD\\" ```","solution":"# Morse code conversion dictionary MORSE_CODE_DICT = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } # Reverse Morse code dictionary MORSE_CODE_REVERSE_DICT = {v: k for k, v in MORSE_CODE_DICT.items()} def text_to_morse(text: str) -> str: Converts text to Morse code. Raises ValueError for unsupported characters. text = text.upper() morse_code = [] try: for char in text: if char == \' \': morse_code.append(\' \') else: morse_code.append(MORSE_CODE_DICT[char]) except KeyError: raise ValueError(\\"Input contains unsupported characters.\\") # Combine the list to form a string return \' \'.join(morse_code).replace(\' \', \' \') def morse_to_text(morse_code: str) -> str: Converts Morse code to text. Raises ValueError for invalid Morse code sequences. morse_code = morse_code.split(\' \') # Split by triple space to get words decoded_text = [] try: for word in morse_code: letters = word.split(\' \') decoded_text.append(\'\'.join(MORSE_CODE_REVERSE_DICT[letter] for letter in letters)) except KeyError: raise ValueError(\\"Invalid Morse code sequence.\\") return \' \'.join(decoded_text)"},{"question":"# Question: File System Navigation and Directory Size Calculation You are tasked with creating a function that navigates a given directory and calculates the total size of files within it, including all its subdirectories. The function should handle symbolic links properly and avoid infinite loops caused by cyclical links. Additionally, the function must be capable of handling exceptions such as permission errors gracefully. **Task** 1. Develop the `calculate_directory_size` function to traverse a directory recursively. 2. Implement symbolic link handling to avoid traversing them more than once. 3. Ensure the function properly handles any encountered exceptions and logs them appropriately. # Requirements **Function Signature** ```python import os # You may use this library for file system operations import logging # You may use this library for logging def calculate_directory_size(directory: str) -> int: pass # Your implementation here ``` **Input** - `directory` (str): The path to the directory for which the total size needs to be calculated. **Output** - Returns an integer representing the total size of all files within the directory in bytes. **Constraints** - Recursively calculate the size of all files in the directory, including subdirectories. - Handle symbolic links to prevent traversing them more than once, avoiding potential infinite loops. - Log all exceptions such as permission errors without interrupting the execution of the function. **Performance** - Ensure the function can handle large directories with many files and nested subdirectories efficiently. # Example ```python # Assuming your function implementation is complete total_size = calculate_directory_size(\\"/path/to/directory\\") print(total_size) ``` # Note - Use proper logging to record exceptions and for troubleshooting purposes. - Consider edge cases such as empty directories and directories with inaccessible files.","solution":"import os import logging logging.basicConfig(level=logging.ERROR) def calculate_directory_size(directory: str) -> int: total_size = 0 visited_dirs = set() def handle_directory(dir_path): nonlocal total_size if dir_path in visited_dirs: return visited_dirs.add(dir_path) try: with os.scandir(dir_path) as it: for entry in it: try: if entry.is_symlink(): continue if entry.is_file(): total_size += entry.stat().st_size elif entry.is_dir(): handle_directory(entry.path) except (OSError, PermissionError) as e: logging.error(f\\"Error accessing {entry.path}: {e}\\") except (OSError, PermissionError) as e: logging.error(f\\"Error accessing {dir_path}: {e}\\") handle_directory(directory) return total_size"},{"question":"# Problem Statement Given a dictionary (hashmap) where keys are words and values are their frequencies of occurrence in a given text, write a function to identify the top `k` most frequent words. If two words have the same frequency, the function should return them in alphabetical order. # Input Format 1. A dictionary where keys are words (strings) and values are integers representing frequencies. ( left | text{keys} right | leq 10^5 ) 2. An integer `k` (1 ≤ k ≤ the number of unique words in the dictionary) # Output Format - A list of the top `k` most frequent words. The list should be sorted by the frequency in descending order, and words with the same frequency should be in alphabetical order. # Constraints * The words will contain only lowercase letters (a-z). * The frequencies will be positive integers. # Performance Requirements * Aim for an efficient solution, ideally with a time complexity better than (O(n log n)), where `n` is the number of words in the dictionary. # Examples 1. **Input**: ``` word_freq = {\\"hello\\": 2, \\"world\\": 5, \\"apple\\": 5, \\"banana\\": 3} k = 2 ``` **Output**: ``` [\\"apple\\", \\"world\\"] ``` 2. **Input**: ``` word_freq = {\\"coding\\": 1, \\"is\\": 3, \\"fun\\": 2} k = 1 ``` **Output**: ``` [\\"is\\"] ``` 3. **Input**: ``` word_freq = {\\"a\\": 1, \\"b\\": 1, \\"c\\": 1} k = 3 ``` **Output**: ``` [\\"a\\", \\"b\\", \\"c\\"] ``` # Function Signature ```python def top_k_frequent_words(word_freq: dict[str, int], k: int) -> list[str]: # Your code here ``` # Notes - Ensure your implementation sorts the words with the same frequency alphabetically. - Handle edge cases, such as the dictionary being empty and `k` being larger than the number of words in the dictionary.","solution":"def top_k_frequent_words(word_freq, k): Returns the top k most frequent words from the given word frequency dictionary. Words with the same frequency are sorted in alphabetical order. # Sort words by frequency (descending) and then alphabetically sorted_words = sorted(word_freq.items(), key=lambda item: (-item[1], item[0])) # Extract only the words, not the frequencies top_k_words = [word for word, freq in sorted_words[:k]] return top_k_words"},{"question":"# Question: Sum of Digits of Prime Factors Objective You need to write a function that calculates the sum of the digits of all the prime factors of a given positive integer. The function should handle edge cases efficiently and provide accurate results. Function Signature ```python def sum_of_digits_prime_factors(num: int) -> int: Returns the sum of the digits of all prime factors of the given number. Parameters: num (int): The positive integer number to calculate the prime factors\' digit sum. Returns: int: The sum of the digits of all prime factors of num. ``` Input - **num**: A positive integer number to be evaluated. Output - Returns the sum of the digits of all prime factors of `num`. Constraints - The function should return 0 for non-positive integers or non-integer inputs. - Ensure that the function efficiently handles larger integers. - No external libraries should be used for factorization or digit summation. Example Usage ```python print(sum_of_digits_prime_factors(28)) # Output: 4 (Prime factors: 2, 2, 7 -> Digits: 2+2+7=11) print(sum_of_digits_prime_factors(100)) # Output: 2 (Prime factors: 2, 2, 5, 5 -> Digits: 2+2+5+5=14) print(sum_of_digits_prime_factors(210)) # Output: 8 (Prime factors: 2, 3, 5, 7 -> Digits: 2+3+5+7=17) print(sum_of_digits_prime_factors(-15)) # Output: 0 (Invalid input) print(sum_of_digits_prime_factors(1)) # Output: 0 (No prime factors) ``` Explanation For the number 28: - Prime factors of 28 are 2, 2, and 7. - Sum of the digits of these prime factors: 2 + 2 + 7 = 11. Tips 1. First, find the prime factors of the given number. 2. Sum up the digits of each of these prime factors. 3. Ensure to handle invalid and special edge cases (non-positive numbers, non-integers, and 1 which has no prime factors). 4. Think about prime factorization techniques and how to efficiently sum digits of numbers.","solution":"def sum_of_digits_prime_factors(num: int) -> int: Returns the sum of the digits of all prime factors of the given number. Parameters: num (int): The positive integer number to calculate the prime factors\' digit sum. Returns: int: The sum of the digits of all prime factors of num. if not isinstance(num, int) or num <= 1: return 0 def prime_factors(n): i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: n //= i factors.append(i) if n > 1: factors.append(n) return factors def sum_of_digits(n): return sum(int(d) for d in str(n)) factors = prime_factors(num) return sum(sum_of_digits(factor) for factor in factors)"},{"question":"# Coding Assessment Question **Context**: You\'ve been tasked to work on a project involving sentiment analysis using Natural Language Processing (NLP). Your goal is to train a model that classifies movie reviews into positive or negative sentiments. **Objective**: Implement a function `sentiment_model` that utilizes the `TfidfVectorizer` and `LogisticRegression` from sklearn to create a pipeline. The function should train the model on the training dataset, and then output the classification report on the test dataset. **Function Signature**: ```python def sentiment_model(train_texts: list, train_labels: list, test_texts: list, test_labels: list) -> str: Parameters: - train_texts: list, List containing the training texts/reviews. - train_labels: list, List containing the labels for the training texts. - test_texts: list, List containing the test texts/reviews. - test_labels: list, List containing the labels for the test texts. Returns: - str: Classification report as a string ``` **Input**: * `train_texts`: A list of strings where each string represents a movie review in the training set. * `train_labels`: A list of labels corresponding to the training reviews (0 for negative, 1 for positive). * `test_texts`: A list of strings where each string represents a movie review in the testing set. * `test_labels`: A list of labels corresponding to the testing reviews (0 for negative, 1 for positive). **Output**: * The function should return the classification report from sklearn as a string. **Constraints**: * Use sklearn\'s `TfidfVectorizer` to transform the text data. * Utilize the `LogisticRegression` for model training. * Ensure the pipeline includes a transformation step and a logistic regression step. * Return a classification report that includes precision, recall, f1-score, and accuracy. **Additional Information**: Assume the input texts are preprocessed and do not require further cleaning. Use the TfidfVectorizer to convert texts into TF-IDF representations. Train the Logistic Regression model on the training set and evaluate on the test set. **Example**: ```python from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.pipeline import make_pipeline from sklearn.metrics import classification_report def sentiment_model(train_texts: list, train_labels: list, test_texts: list, test_labels: list) -> str: pipeline = make_pipeline(TfidfVectorizer(), LogisticRegression()) pipeline.fit(train_texts, train_labels) predicted_labels = pipeline.predict(test_texts) report = classification_report(test_labels, predicted_labels) return report # Example usage train_texts = [\\"I loved this movie!\\", \\"This movie was terrible.\\", \\"Fantastic film\\", \\"Not good\\", \\"I would watch it again\\", \\"Poor performance\\", \\"Amazing storyline\\", \\"Boring plot\\"] train_labels = [1, 0, 1, 0, 1, 0, 1, 0] test_texts = [\\"Great movie!\\", \\"I did not enjoy it\\", \\"It was a waste of time\\", \\"I would recommend it\\"] test_labels = [1, 0, 0, 1] report = sentiment_model(train_texts, train_labels, test_texts, test_labels) print(report) ``` **Note**: The function should be able to run independently and provide a clear classification report. Verify the effectiveness of the model by checking the precision, recall, and f1-score in the provided report.","solution":"from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.linear_model import LogisticRegression from sklearn.pipeline import make_pipeline from sklearn.metrics import classification_report def sentiment_model(train_texts: list, train_labels: list, test_texts: list, test_labels: list) -> str: Parameters: - train_texts: list, List containing the training texts/reviews. - train_labels: list, List containing the labels for the training texts. - test_texts: list, List containing the test texts/reviews. - test_labels: list, List containing the labels for the test texts. Returns: - str: Classification report as a string # Create a pipeline with TfidfVectorizer and LogisticRegression pipeline = make_pipeline(TfidfVectorizer(), LogisticRegression()) # Fit the model with the training data pipeline.fit(train_texts, train_labels) # Predict labels for the test data predicted_labels = pipeline.predict(test_texts) # Generate the classification report report = classification_report(test_labels, predicted_labels) return report"},{"question":"# Coding Assessment Question: Maze Path Finder Introduction In this problem, you are tasked with finding a path through a maze from a given starting point to a target point. The maze is represented as a 2D grid of characters, where: - \'S\' denotes the starting point. - \'E\' denotes the target point (end). - \'.\' represents open paths you can move through. - \'#\' represents walls that you cannot pass through. You should find the shortest path from \'S\' to \'E\' using Breadth-First Search (BFS). Task Implement the function `find_path(maze: List[List[str]]) -> List[Tuple[int, int]]` that finds and returns the shortest path from \'S\' to \'E\'. If there is no valid path, return an empty list. Function Signature ```python def find_path(maze: List[List[str]]) -> List[Tuple[int, int]]: pass ``` Input * `maze`: A list of lists representing the 2D grid maze. Each element in the list is a string that can be \'S\', \'E\', \'.\', or \'#\'. Output * Return a list of tuples representing the path from \'S\' to \'E\'. Each tuple should be (row_index, column_index). If the path does not exist, return an empty list. Constraints * The maze will have at least 1 row and 1 column and at most 100 rows and 100 columns. * There will be exactly one \'S\' and one \'E\' in the grid. Example ```python maze1 = [ [\'S\', \'.\', \'.\', \'#\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'#\', \'.\', \'.\', \'.\', \'#\', \'#\', \'.\'], [\'.\', \'#\', \'.\', \'.\', \'.\', \'#\', \'.\', \'.\', \'.\', \'.\'], [\'.\', \'#\', \'#\', \'#\', \'.\', \'#\', \'.\', \'#\', \'#\', \'.\'], [\'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'.\', \'E\'] ] print(find_path(maze1)) # Expected output: [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), (4, 7), (4, 8), (4, 9)] maze2 = [ [\'S\', \'#\', \'#\'], [\'.\', \'#\', \'#\'], [\'.\', \'#\', \'#\'], [\'.\', \'.\', \'E\'], ] print(find_path(maze2)) # Expected output: [(0, 0), (1, 0), (2, 0), (3, 0), (3, 1), (3, 2)] maze3 = [ [\'S\', \'#\', \'E\'] ] print(find_path(maze3)) # Expected output: [] maze4 = [ [\'S\', \'.\', \'.\'], [\'#\', \'#\', \'.\'], [\'.\', \'.\', \'E\'] ] print(find_path(maze4)) # Expected output: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] ``` Guidelines * Use Breadth-First Search (BFS) to find the shortest path. * Track visited cells to avoid processing them more than once. * Keep track of the path taken to reconstruct the route from \'S\' to \'E\'. * Ensure your solution is efficient and follows the constraints.","solution":"from collections import deque from typing import List, Tuple def find_path(maze: List[List[str]]) -> List[Tuple[int, int]]: rows, cols = len(maze), len(maze[0]) start, end = None, None # Find the starting and ending point for r in range(rows): for c in range(cols): if maze[r][c] == \'S\': start = (r, c) elif maze[r][c] == \'E\': end = (r, c) # Edge case: if starting or ending point is not found if not start or not end: return [] # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start, [start])]) visited = set([start]) while queue: (current, path) = queue.popleft() if current == end: return path for direction in directions: nr, nc = current[0] + direction[0], current[1] + direction[1] if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] != \'#\' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append(((nr, nc), path + [(nr, nc)])) return []"},{"question":"Unique Identifier Generation Task # Objective You are tasked with implementing a function to generate unique identifiers based on given data and specific constraints. The goal is to ensure the identifiers are unique and meet the required characteristics. # Problem Statement Write a function `generate_unique_id(data: list[str], length: int) -> list[str]` that generates a unique identifier for each string in the input list, where each identifier is of a specified length. # Implementation Details 1. **Input**: - A list of strings (`data`) for which unique identifiers need to be generated. - An integer (`length`) indicating the required length of each identifier. 2. **Output**: - A list of unique identifiers corresponding to the input strings, each with the specified length. # Function Signature ```python def generate_unique_id(data: list[str], length: int) -> list[str]: pass ``` # Constraints 1. Each input string will contain only alphanumeric characters (both uppercase and lowercase). 2. The length of each identifier must be exactly the specified `length`. 3. Identifiers should be formed by concatenating the first few characters of the input string (case-insensitive), and appending additional characters if necessary to ensure uniqueness and meet the required length. 4. If the input string is shorter than the specified length, pad the identifier with additional characters to reach the required length. 5. All identifiers within the output list must be unique. # Example ```python example1 = [\'apple\', \'banana\', \'cherry\'] length1 = 5 example2 = [\'dog\', \'deer\', \'deal\'] length2 = 4 assert generate_unique_id(example1, length1) == [\'apple\', \'banan\', \'cherr\'] assert generate_unique_id(example2, length2) == [\'dog1\', \'deer\', \'deal\'] ``` # Description The function `generate_unique_id` should ensure that for each string in `data`, a unique identifier of the specified `length` is created. Follow these steps: 1. Extract the first few characters from each string to start forming the identifier. 2. Ensure identifiers are case-insensitive. 3. If necessary, append additional characters to guarantee each identifier is unique and meets the required length. 4. Handle edge cases where input strings may have overlapping prefix sequences resulting in potential conflicts. # Notes - Consider using a set to keep track of already used identifiers for ensuring uniqueness. - Handle cases where the input strings can have overlapping prefixes or be shorter than the required length. - Implement additional logic to manage conflicts, such as appending numerical suffixes or other characters to differentiate identifiers. Ensure that your implementation passes all given test cases and performs efficiently for larger lists.","solution":"def generate_unique_id(data: list[str], length: int) -> list[str]: Generate unique identifiers for each string in the input list. Each identifier must be of the specified length. Parameters: data (list of str): The input list of strings. length (int): The required length for each identifier. Returns: list of str: The list of unique identifiers. def pad_or_trim(s, length): If the string is shorter than the required length, pad it with additional characters. If the string is longer, trim it to the required length. s = (s + \\"0\\" * length)[:length] return s unique_ids = set() result = [] for entry in data: base_id = pad_or_trim(entry.lower(), length) new_id = base_id counter = 1 while new_id in unique_ids: # Generate a new identifier with a suffix if there\'s a conflict suffix = str(counter) suffix_length = len(suffix) new_id = base_id[:length - suffix_length] + suffix counter += 1 unique_ids.add(new_id) result.append(new_id) return result"},{"question":"# Question: Valid Parentheses with Stars Implement a function that determines whether a string containing the characters `(`, `)`, and `*` is valid. In this context, a string is valid if: 1. `(` and `)` must be correctly paired. 2. `*` can be treated as a single `(`, a single `)`, or an empty string. Your function should return a boolean indicating the validity of the string. Function Signature: ```python def checkValidString(s: str) -> bool: pass ``` # Constraints: - The input string will be comprised of `(`, `)`, and `*`. - The length of the input string will not exceed 100. # Example: ```python print(checkValidString(\\"()\\")) # Output: True print(checkValidString(\\"(*)\\")) # Output: True print(checkValidString(\\"(*))\\")) # Output: True print(checkValidString(\\"(()*)\\")) # Output: True print(checkValidString(\\"*)\\")) # Output: True print(checkValidString(\\"(*\\") # Output: True print(checkValidString(\\")\\")) # Output: False print(checkValidString(\\")(\\")) # Output: False ``` # Explanation: - The input \\"()\\" is valid since it only contains correctly paired parentheses. - The input \\"(*)\\" can be interpreted as \\"()\\" or \\"()\\" or \\"()\\" making it valid. - The input \\"(*))\\" can be interpreted as \\"()\\" making it valid. - The input \\"(*)()\\" can be interpreted as \\"()\\" making it valid. - The input \\"*)\\" can be interpreted as \\"\\" making it valid. - The input \\"(*\\" can be interpreted as \\"\\" making it valid. - The input \\")\\" is invalid because there is no matching open parenthesis. - The input \\")(\\" is invalid because the order is incorrect.","solution":"def checkValidString(s: str) -> bool: low = high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': if low > 0: low -= 1 high -= 1 elif char == \'*\': if low > 0: low -= 1 high += 1 if high < 0: return False return low == 0"},{"question":"# Question: Implementing Gradient Descent for Linear Regression In this task, you will implement and utilize gradient descent to optimize a linear regression model. Understanding gradient descent and linear regression is fundamental for various machine learning and data science applications. Objectives: 1. Implement the following functions for gradient descent: 1. **Compute Cost**: Calculate the mean squared error for a given set of predictions. 2. **Gradient Descent Step**: Perform a single step of gradient descent to update the model parameters. 3. **Train Model**: Train the linear regression model using gradient descent for a specified number of iterations. Function Specifications: **Compute Cost** ```python def compute_cost(X: np.ndarray, y: np.ndarray, theta: np.ndarray) -> float: Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features) - y: True labels of shape (n_samples,) - theta: Model parameters of shape (n_features,) Returns: - float: The mean squared error cost ``` **Gradient Descent Step** ```python def gradient_descent_step(X: np.ndarray, y: np.ndarray, theta: np.ndarray, alpha: float) -> np.ndarray: Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features) - y: True labels of shape (n_samples,) - theta: Current model parameters of shape (n_features,) - alpha: Learning rate Returns: - np.ndarray: Updated model parameters of shape (n_features,) ``` **Train Model** ```python def train_model(X: np.ndarray, y: np.ndarray, theta: np.ndarray, alpha: float, num_iters: int) -> np.ndarray: Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features) - y: True labels of shape (n_samples,) - theta: Initial model parameters of shape (n_features,) - alpha: Learning rate - num_iters: Number of gradient descent iterations Returns: - np.ndarray: Final model parameters of shape (n_features,) ``` Constraints: 1. Ensure the input arrays (`X` and `y`) are numpy arrays. 2. Handle mismatched lengths or shapes of input arrays using appropriate error messages. 3. Implement the gradient descent algorithm efficiently using vectorized numpy operations. Example Usage: ```python X = np.array([[1, 1], [1, 2], [1, 3], [1, 4]]) y = np.array([2, 2.5, 3.5, 4]) theta = np.array([0.0, 0.0]) alpha = 0.01 num_iters = 1000 final_theta = train_model(X, y, theta, alpha, num_iters) print(final_theta) # Output: array close to [1.0, 0.75] cost = compute_cost(X, y, final_theta) print(cost) # Output: value close to 0.0625 ``` You need to write these functions from scratch. You are encouraged to run the provided example to validate your implementation. Good luck!","solution":"import numpy as np def compute_cost(X: np.ndarray, y: np.ndarray, theta: np.ndarray) -> float: Compute the cost (mean squared error) for linear regression. Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features). - y: True labels of shape (n_samples,). - theta: Model parameters of shape (n_features,). Returns: - float: The mean squared error cost. m = y.size predictions = X.dot(theta) sqrErrors = (predictions - y) ** 2 return (1 / (2 * m)) * np.sum(sqrErrors) def gradient_descent_step(X: np.ndarray, y: np.ndarray, theta: np.ndarray, alpha: float) -> np.ndarray: Perform one step of gradient descent. Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features). - y: True labels of shape (n_samples,). - theta: Current model parameters of shape (n_features,). - alpha: Learning rate. Returns: - np.ndarray: Updated model parameters of shape (n_features,). m = y.size predictions = X.dot(theta) errors = predictions - y gradient = (1 / m) * X.T.dot(errors) theta = theta - alpha * gradient return theta def train_model(X: np.ndarray, y: np.ndarray, theta: np.ndarray, alpha: float, num_iters: int) -> np.ndarray: Train the linear regression model using gradient descent. Parameters: - X: Feature matrix (including the intercept term) of shape (n_samples, n_features). - y: True labels of shape (n_samples,). - theta: Initial model parameters of shape (n_features,). - alpha: Learning rate. - num_iters: Number of gradient descent iterations. Returns: - np.ndarray: Final model parameters of shape (n_features,). for i in range(num_iters): theta = gradient_descent_step(X, y, theta, alpha) return theta"},{"question":"Sentence Anagram Helper # Scenario For this challenge, you need to develop a helper system that can identify anagrams within a list of sentences. An anagram is a rearrangement of the letters in a word or phrase to form a different word or phrase, using all the original letters exactly once. Two sentences are considered anagrams if they can be rearranged to match one another while ignoring spaces and punctuation. # Function to Implement You need to write a function, `find_anagram_sentences`, which will accept a list of sentences and return a dictionary where the keys are the sorted versions of the sentences and the values are lists of sentences that are anagrams of each other. # Function Signature ```python def find_anagram_sentences(sentences: list) -> dict: pass ``` # Input - A list of strings representing sentences. (1 ≤ len(sentences) ≤ 500, 1 ≤ len(sentence) ≤ 200) # Output - A dictionary where the keys are sorted strings of characters (excluding spaces and punctuation) and the values are lists of sentences that are anagrams of each other. # Constraints - Each sentence may contain spaces, punctuation, and both uppercase and lowercase letters. - The function should ignore punctuation, spaces, and letter case during the comparison to determine anagrams. - Sentences should be grouped under a sorted characters\' key with no spaces or punctuation. # Example ```python find_anagram_sentences([\\"listen\\", \\"silent\\", \\"enlist\\", \\"Rat!\\", \\"Tar\\", \\"Elvis\\", \\"Lives\\", \\"Dog?\\", \\"God!\\"]) ``` Output: ```python { \'eilnst\': [\'listen\', \'silent\', \'enlist\'], \'art\': [\'Rat!\', \'Tar\'], \'eilsv\': [\'Elvis\', \'Lives\'], \'dgo\': [\'Dog?\', \'God!\'] } ``` # Notes - Ensure the function can handle variations in punctuation and case sensitivity efficiently. - If no anagrams are found, the function should return an empty dictionary. - Optimize the function for performance to handle the upper constraints comfortably.","solution":"import re from collections import defaultdict def find_anagram_sentences(sentences): def clean_sentence(sentence): # Remove spaces and punctuation, convert to lowercase, then sort the characters return \'\'.join(sorted(re.sub(r\'[^a-zA-Z]\', \'\', sentence).lower())) anagram_dict = defaultdict(list) for sentence in sentences: cleaned_sentence = clean_sentence(sentence) anagram_dict[cleaned_sentence].append(sentence) return dict(anagram_dict)"},{"question":"# Problem Statement You are given a list of integers where all elements appear twice except for one, which appears exactly once. Your task is to implement a function that finds the single unique element in the list. The solution should have a linear runtime complexity and use constant extra space. # Function Signature ```python def find_unique_element(nums: list[int]) -> int: Finds the unique element in a list where every other element appears twice. Args: - nums (list[int]): A list of integers where exactly one element appears once and all others appear twice. Returns: - int: The unique element in the list. ``` # Input - A list `nums` of integers where the size of the list `n` will be in the range `[1, 10^5]`. - Each integer in the list will be in the range `[-10^9, 10^9]`. - Exactly one element appears once, and all other elements appear twice. # Output - An integer representing the unique element in the list. # Constraints - The solution must have a linear runtime complexity, O(n). - The solution must use constant space, O(1). # Example ```python nums = [4, 1, 2, 1, 2] assert find_unique_element(nums) == 4 nums = [2, 2, 3, 4, 4] assert find_unique_element(nums) == 3 ``` # Requirements 1. You must implement the `find_unique_element` function. 2. Your implementation should make use of XOR operation or any other method that maintains O(n) time and O(1) space complexity.","solution":"def find_unique_element(nums: list[int]) -> int: result = 0 for num in nums: result ^= num return result"},{"question":"# Problem Statement You are given the roots of a polynomial equation, and your task is to construct and evaluate the polynomial at a specific value. # Function Signature ```python def evaluate_polynomial(roots: List[float], x: float) -> float: Evaluates the polynomial with given roots at a specific value of x. Parameters: roots (List[float]): A list of roots of the polynomial. x (float): The value at which the polynomial will be evaluated. Returns: float: The value of the polynomial at x. ``` # Requirements - The function should construct the polynomial using the roots provided. - Evaluate the polynomial at the given value `x` and return the result. - If `roots` is empty, return 1, as there is no polynomial to construct. # Example ```python print(evaluate_polynomial([1, 2, 3], 4)) # Example output should be 24 print(evaluate_polynomial([], 3)) # Example output should be 1 print(evaluate_polynomial([-1, 0, 1], 2)) # Example output should be 6 ``` # Constraints - The length of `roots` list will be at most 100. - Each element of `roots` will satisfy -10^3 <= root <= 10^3. - The value of `x` will satisfy -10^3 <= x <= 10^3. # Hints - Recall that if the roots of a polynomial P(x) are r1, r2, r3,..., rn, then it can be written as P(x) = (x - r1)(x - r2)(x - r3)...(x - rn). - To evaluate the polynomial at a particular value of `x`, substitute `x` into this product form of the polynomial.","solution":"from typing import List def evaluate_polynomial(roots: List[float], x: float) -> float: Evaluates the polynomial with given roots at a specific value of x. Parameters: roots (List[float]): A list of roots of the polynomial. x (float): The value at which the polynomial will be evaluated. Returns: float: The value of the polynomial at x. if not roots: return 1 result = 1 for root in roots: result *= (x - root) return result"},{"question":"# Coding Assessment Question **Context**: You have been assigned the task of implementing a data structure that simulates a stack but with an additional capability – to return the median of all elements currently in the stack. Stacks are common in both theoretical and practical applications due to their Last-In-First-Out (LIFO) property. This question extends the basic stack operations to include median retrieval, which is essential in maintaining historical data statistics. **Class Specification**: Define a class `MedianStack` with the following methods: 1. `__init__(self)`: Initializes an empty stack. 2. `push(self, val: int)`: Pushes an integer `val` onto the stack. 3. `pop(self) -> int`: Removes the integer on the top of the stack and returns it. If the stack is empty, returns `None`. 4. `find_median(self) -> float`: Returns the median of the current elements in the stack. If the stack is empty, returns `None`. **Constraints**: * All elements pushed to the stack are integers in the range `-10^6` to `10^6`. * Operations will be called in any order, and the number of operations will not exceed 10^5. * Functions should run efficiently to handle large numbers of operations. **Example**: ```python # initialize the stack s = MedianStack() # Example 1: Basic Operations s.push(3) s.push(1) print(s.find_median()) # Output: 2.0 (median of [3, 1]) s.push(4) print(s.find_median()) # Output: 3.0 (median of [3, 1, 4]) s.pop() print(s.find_median()) # Output: 2.0 (median of [3, 1]) # Example 2: Handling Edge Cases s = MedianStack() print(s.find_median()) # Output: None (stack is empty) s.push(-5) s.push(-5) print(s.find_median()) # Output: -5.0 (median of [-5, -5]) s.pop() print(s.find_median()) # Output: -5.0 (median of [-5]) ``` # Instructions: 1. Implement the `MedianStack` class with the described methods. 2. Ensure your solution efficiently handles up to 10^5 operations. 3. Carefully manage edge cases, including when the stack is empty.","solution":"import bisect class MedianStack: def __init__(self): Initializes an empty stack and an empty list to store elements. self.stack = [] self.sorted_elements = [] def push(self, val: int): Pushes an integer val onto the stack and maintains the sorted list. self.stack.append(val) bisect.insort(self.sorted_elements, val) def pop(self) -> int: Removes the integer on the top of the stack and returns it. If the stack is empty, returns None. if not self.stack: return None val = self.stack.pop() index = bisect.bisect_left(self.sorted_elements, val) del self.sorted_elements[index] return val def find_median(self) -> float: Returns the median of the current elements in the stack. If the stack is empty, returns None. n = len(self.sorted_elements) if n == 0: return None if n % 2 == 1: return float(self.sorted_elements[n // 2]) else: return (self.sorted_elements[n // 2 - 1] + self.sorted_elements[n // 2]) / 2.0"},{"question":"Problem Statement You are given a string `s` containing lowercase English letters and a list of words `words` consisting of lowercase English letters. Your task is to determine which words from `words` can be formed by deleting some characters of the string `s` without reordering the remaining characters. Implement the following function: ```python def find_words(s: str, words: List[str]) -> List[str]: Given a string s and a list of words, determine which words from \'words\' can be formed by deleting some characters of the string s without reordering the remaining characters. Returns the list of such words. ``` # Input 1. `s`: A string of lowercase English letters (1 <= len(s) <= 10^5). 2. `words`: A list of strings, where each string consists of lowercase English letters (1 <= len(words[i]) <= 10^4 for each `words[i]` and 1 <= len(words) <= 500). # Output - Returns a list of strings from `words` that can be formed by deleting some characters of `s`. # Constraints 1. Each word in the list `words` should be a valid word that can be formed by deleting some characters from the string `s` without reordering the remaining characters. # Examples ```python assert find_words(\\"abcppple\\", [\\"apple\\", \\"applec\\", \\"ace\\", \\"pple\\"]) == [\\"apple\\", \\"ace\\", \\"pple\\"] assert find_words(\\"helloo\\", [\\"hel\\", \\"halo\\", \\"ho\\"]) == [\\"hel\\", \\"ho\\"] assert find_words(\\"abcdef\\", [\\"abc\\", \\"def\\", \\"abcd\\"]) == [\\"abc\\", \\"def\\", \\"abcd\\"] ``` # Explanation In example 1: - \\"apple\\" can be formed by deleting characters \'b\' and the second \'p\' from \\"abcppple\\". - \\"ace\\" can be formed by deleting \'b\', \'c\', \'p\' and \'p\' from \\"abcppple\\". - \\"pple\\" can be formed by deleting \'a\', \'b\', \'c\', and the first \'p\' from \\"abcppple\\". - \\"applec\\" cannot be formed as it requires an additional \'c\' which is not in \\"abcppple\\". In example 2: - \\"hel\\" can be formed by deleting the two \'o\'s from \\"helloo\\". - \\"ho\\" can be formed by deleting \'e\', \'l\', \'l\', and \'o\' from \\"helloo\\". - \\"halo\\" cannot be formed as it requires an \'a\' which is not in \\"helloo\\".","solution":"from typing import List def find_words(s: str, words: List[str]) -> List[str]: def is_subsequence(x, y): it = iter(y) return all(c in it for c in x) result = [] for word in words: if is_subsequence(word, s): result.append(word) return result"},{"question":"# Problem Statement You are tasked with implementing a function that calculates the intersection of two lists. The result should be a list containing elements that are common to both input lists, without duplicates, and sorted in ascending order. The function should use efficient data structures and algorithms to ensure optimal performance. # Function Signature ```python def intersection_of_lists(list1: List[int], list2: List[int]) -> List[int]: pass ``` # Input/Output Requirements * **Input**: - `list1` (List[int]): A list of integers. - `list2` (List[int]): Another list of integers. * **Output**: - Returns a list of integers that are present in both `list1` and `list2`, sorted in ascending order and without duplicates. # Constraints - Each list will have a length of at most 10^5. - Each integer in the lists will be within the range -10^9 to 10^9. # Performance Requirements - The function should have a time complexity of O(n log n) where n is the maximum length of the input lists. - The space complexity should not exceed O(n). # Scenario Imagine you are developing a feature for a social media platform that suggests mutual friends to users. For this feature, you need a tool to determine common friends between two users efficiently, ensuring that there are no duplicates and the results are sorted for easy display. # Example ```python >>> intersection_of_lists([5, 1, 3, 7, 9], [3, 5, 8, 6, 7]) [3, 5, 7] >>> intersection_of_lists([1, 2, 3], [4, 5, 6]) [] >>> intersection_of_lists([-1, 0, 1], [1, -1, 2, 0]) [-1, 0, 1] ``` # Solution Requirements - Implement the `intersection_of_lists` function following the above specifications. - Ensure the solution efficiently handles large input sizes and edge cases. - Use appropriate data structures to achieve the required performance.","solution":"from typing import List def intersection_of_lists(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of unique integers that are present in both input lists. set1 = set(list1) set2 = set(list2) # Find the intersection of both sets intersection = set1 & set2 # Return the sorted list return sorted(intersection)"},{"question":"**Problem Statement**: You are tasked with implementing a function that finds the longest subarray consisting of any single element from a given list of integers. A \\"subarray\\" is a contiguous sequence of elements within an array. # Function Signature: ```python def longest_uniform_subarray(arr: list[int]) -> tuple[int, list[int]]: ``` # Input: * `arr` (list of int): The list of integers. # Output: * Returns a tuple containing two elements: * The first element is an integer representing the length of the longest subarray. * The second element is the longest subarray itself. # Constraints: * The input list will be non-empty and each element will fit within the standard 32-bit integer range. * The length of the list will be between 1 and 1000 inclusive. # Examples: ```python assert longest_uniform_subarray([1, 1, 2, 2, 2, 3]) == (3, [2, 2, 2]) assert longest_uniform_subarray([4, 4, 4, 4]) == (4, [4, 4, 4, 4]) assert longest_uniform_subarray([1, 2, 3, 4, 5]) == (1, [1]) assert longest_uniform_subarray([7, 7, 1, 2, 2, 7, 7, 7]) == (3, [7, 7, 7]) assert longest_uniform_subarray([1]) == (1, [1]) ``` # Scenario/Context: You are developing an analysis tool that processes large data sets and identifies patterns within them. One use case is to find segments of repeated values, which can be useful in identifying trends, compressing data, or detecting anomalies in time-series data. Please ensure your function handles different edge cases such as uniform and non-uniform arrays, as well as arrays with only one element. For example: ```python try: longest_uniform_subarray([1, 1, 2, 2, 1, 1]) except ValueError as e: print(e) # should not raise an error ```","solution":"def longest_uniform_subarray(arr: list[int]) -> tuple[int, list[int]]: if not arr: return (0, []) max_length = 1 current_length = 1 max_element = arr[0] current_element = arr[0] for i in range(1, len(arr)): if arr[i] == current_element: current_length += 1 else: if current_length > max_length: max_length = current_length max_element = current_element current_element = arr[i] current_length = 1 if current_length > max_length: max_length = current_length max_element = current_element return (max_length, [max_element] * max_length)"},{"question":"# Fibonacci Custom Sequence Implement a function `custom_fibonacci` that generates a sequence of numbers similar to the Fibonacci sequence, but with custom starting values and a specified length. # Function Signature ```python def custom_fibonacci(first: int, second: int, n: int) -> list: ``` # Input * `first` (int): The first number in the sequence. * `second` (int): The second number in the sequence. * `n` (int): The total number of terms in the sequence. Must be a positive integer. # Output * `list`: A list of integers representing the custom Fibonacci sequence with `n` terms. # Constraints * `n` must be a positive integer greater than or equal to 1. * If `n` is 1, return a list with a single element, `first`. # Errors * If `n` is less than 1, raise a `ValueError` with the message \\"The length of the sequence must be a positive integer\\". # Examples ```python >>> custom_fibonacci(0, 1, 5) [0, 1, 1, 2, 3] >>> custom_fibonacci(2, 3, 6) [2, 3, 5, 8, 13, 21] >>> custom_fibonacci(5, 5, 4) [5, 5, 10, 15] >>> custom_fibonacci(1, 1, 1) [1] >>> custom_fibonacci(-1, 1, 7) [-1, 1, 0, 1, 1, 2, 3] >>> custom_fibonacci(1, 2, 0) Traceback (most recent call last): ... ValueError: The length of the sequence must be a positive integer ``` # Notes When implementing this function: * The function should generate the sequence based on the logic: `next_term = previous_term + second_previous_term`. * Ensure that the sequence is generated correctly for various values of `first`, `second`, and `n`. * Validate the input `n` to be a positive integer and handle any exceptions as specified above.","solution":"def custom_fibonacci(first: int, second: int, n: int) -> list: Generates a custom Fibonacci sequence with the given starting values and length. if n < 1: raise ValueError(\\"The length of the sequence must be a positive integer\\") if n == 1: return [first] sequence = [first, second] for i in range(2, n): next_term = sequence[-1] + sequence[-2] sequence.append(next_term) return sequence"},{"question":"# Scenario You are given a grid of integers where each cell in the grid represents some value. You need to answer multiple queries about the maximal sum of values for sub-grids within the given grid. # Problem Statement Your task is to implement two functions: 1. `precompute_prefix_sums(grid: list[list[int]]) -> list[list[int]]`: This function takes a 2D list of integers as input and returns the precomputed prefix sums table for the grid. 2. `query_max_sum(prefix_sums: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int]) -> int`: This function takes the prefix sums table and a sub-grid defined by its top-left and bottom-right corners, and returns the sum of the values in that sub-grid. # Input and Output Formats **Function 1: `precompute_prefix_sums`** - **Input**: - `grid` (list of list of integers): A 2D list representing the grid. - **Output**: - `prefix_sums` (list of list of integers): A 2D list with the same dimensions as `grid`, representing the precomputed prefix sums. **Function 2: `query_max_sum`** - **Input**: - `prefix_sums` (list of list of integers): The precomputed prefix sums table. - `top_left` (tuple of integers): A tuple specifying the (row, column) of the top-left corner of the sub-grid. - `bottom_right` (tuple of integers): A tuple specifying the (row, column) of the bottom-right corner of the sub-grid. - **Output**: - An integer representing the sum of the values within the specified sub-grid. # Constraints - The number of rows and columns in the grid, ( m ) and ( n ) respectively, are such that ( 1 leq m, n leq 500 ). - The values of elements in the grid can be any integers within the range of what can be represented by 32-bit signed integers. - ( 0 leq text{top_left}[0] leq text{bottom_right}[0] < m ). - ( 0 leq text{top_left}[1] leq text{bottom_right}[1] < n ). # Performance Requirements - The function `precompute_prefix_sums` should have a time complexity of ( O(mn) ) and space complexity of ( O(mn) ). - The function `query_max_sum` should have a time complexity of ( O(1) ). # Example ```python grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] prefix_sums = precompute_prefix_sums(grid) query_max_sum(prefix_sums, (0, 0), (2, 2)) # should return 45 query_max_sum(prefix_sums, (1, 1), (2, 2)) # should return 28 ``` # Explanation For the given grid, the precomputed prefix sums table handles sum queries over sub-grids efficiently. When asked for the sum of values between indices (0, 0) and (2, 2), the algorithm efficiently returns the sum `45`. For the sub-grid defined by (1, 1) to (2, 2), it returns `28`.","solution":"def precompute_prefix_sums(grid): Precompute prefix sums for a given 2D grid. Params: grid (list of list of int): 2D list representing the grid. Returns: list of list of int: 2D list representing the precomputed prefix sums. if not grid or not grid[0]: return [] rows = len(grid) cols = len(grid[0]) prefix_sums = [[0] * cols for _ in range(rows)] prefix_sums[0][0] = grid[0][0] for i in range(1, rows): prefix_sums[i][0] = prefix_sums[i-1][0] + grid[i][0] for j in range(1, cols): prefix_sums[0][j] = prefix_sums[0][j-1] + grid[0][j] for i in range(1, rows): for j in range(1, cols): prefix_sums[i][j] = grid[i][j] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] return prefix_sums def query_max_sum(prefix_sums, top_left, bottom_right): Compute the sum of values within the sub-grid defined by top-left and bottom-right corners. Params: prefix_sums (list of list of int): The precomputed prefix sums table. top_left (tuple of int, int): (row, column) of the top-left corner of sub-grid. bottom_right (tuple of int, int): (row, column) of the bottom-right corner of sub-grid. Returns: int: The sum of the values in the specified sub-grid. top_x, top_y = top_left bottom_x, bottom_y = bottom_right total = prefix_sums[bottom_x][bottom_y] if top_x > 0: total -= prefix_sums[top_x - 1][bottom_y] if top_y > 0: total -= prefix_sums[bottom_x][top_y - 1] if top_x > 0 and top_y > 0: total += prefix_sums[top_x - 1][top_y - 1] return total"},{"question":"Problem Statement You are given a list of integers, and you need to perform two operations on this list: 1. `sum_of_squares`: Calculate the sum of squares of all the integers in the list. 2. `nth_largest`: Find the n-th largest unique integer in the list. If there are fewer unique integers than `n`, return `None`. You must implement both functions with the following specifications: # Function Signature ```python def sum_of_squares(lst: list[int]) -> int: # Your implementation here def nth_largest(lst: list[int], n: int) -> int: # Your implementation here ``` # Input - `lst`: A list of integers, which can include both positive and negative numbers, and may contain duplicates. You may assume that the list is not extremely large (typical input size <= 10^5). - `n`: A positive integer representing the rank of the largest unique integer to find in the list. # Output - `sum_of_squares(lst)`: Returns the sum of squares of all the integers in the list. - `nth_largest(lst, n)`: Returns the n-th largest unique integer in the list. If there are fewer unique integers than `n`, return `None`. # Constraints - The list is non-empty. - The value of `n` is guaranteed to be a positive integer. # Performance Requirements - The `sum_of_squares` function should run in O(n) time. - The `nth_largest` function should run in O(n log n) time, considering the necessity of sorting unique elements. # Example ```python >>> sum_of_squares([1, 2, 3]) 14 >>> sum_of_squares([-1, -2, -3]) 14 >>> nth_largest([1, 2, 3, 2, 1, 4], 2) 3 >>> nth_largest([1, 2, 3, 2, 1, 4], 4) 1 >>> nth_largest([1, 2, 3, 2, 1, 4], 5) None ``` # Additional Information For both functions, consider edge cases such as lists with all positive numbers, all negative numbers, and duplicate values. Ensure that the functions handle these cases efficiently.","solution":"from typing import List, Optional def sum_of_squares(lst: List[int]) -> int: Returns the sum of squares of all the integers in the list. return sum(x**2 for x in lst) def nth_largest(lst: List[int], n: int) -> Optional[int]: Returns the n-th largest unique integer in the list. If there are fewer unique integers than `n`, return `None`. unique_vals = sorted(set(lst), reverse=True) if len(unique_vals) < n: return None return unique_vals[n-1]"},{"question":"# Coding Assessment Question **Objective:** Write a function that checks whether a given string can be rearranged to form a palindrome. The function should efficiently determine the possibility by considering character frequencies. **Function Signature:** ```python def can_form_palindrome(s: str) -> bool: pass ``` **Input/Output Format:** - Input: A single string `s` consisting of lowercase letters. - Output: Return `True` if the string can be rearranged to form a palindrome, otherwise `False`. **Constraints:** - The length of `s` will be in the range [1, 10^5]. **Example:** ```python assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True assert can_form_palindrome(\\"hello\\") == False assert can_form_palindrome(\\"racecar\\") == True assert can_form_palindrome(\\"aabb\\") == True ``` **Performance Requirements:** - The solution must handle large strings efficiently, both in terms of time and space complexity. **Scenario:** You are a software engineer working on a text analysis tool for a large-scale project. One of the features requires checking if certain strings can be rearranged into palindromes. This is part of a text processing pipeline that will run on extensive datasets, so the solution needs to be optimized for performance.","solution":"def can_form_palindrome(s: str) -> bool: This function checks if a given string can be rearranged to form a palindrome. A string can be rearranged to form a palindrome if at most one character has an odd frequency. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Track the number of characters with odd frequencies odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # If more than one character has an odd frequency, it cannot form a palindrome if odd_count > 1: return False return True"},{"question":"# Coding Assessment Question: Reverse Words in a Sentence Objective: Implement a function that reverses the order of words in a given sentence. Detailed Requirements: 1. **Function Signature**: `def reverse_words(sentence: str) -> str:` 2. **Input**: A single string, `sentence`, which consists of alphabetic characters (a-z, A-Z) and spaces. 3. **Output**: A string where the order of words in the input sentence is reversed. 4. **Constraints**: - The input string must consist of alphabetic characters and spaces only. If it contains any other characters, raise a `ValueError` with the message \\"Sentence must only contain alphabetic characters and spaces.\\" - Words are separated by single spaces, and there may be leading or trailing spaces in the input, which should be ignored in the output. - Ensure the original capitalization of words is maintained. - Keep time complexity within O(n) to handle larger sentences efficiently. Performance: - Achieve a time complexity of O(n) and a space complexity of O(n). Example: ```python assert reverse_words(\'Hello world\') == \'world Hello\' assert reverse_words(\' Open AI is awesome \') == \'awesome is AI Open\' assert reverse_words(\'Python \') == \'Python\' assert reverse_words(\' This is a test \') == \'test a is This\' # For invalid inputs try: reverse_words(\'Hello World!\') except ValueError as e: assert str(e) == \\"Sentence must only contain alphabetic characters and spaces\\" ``` Scenario: Develop a function that can be used in text manipulation tools where reversing the order of words is a common task. This functionality can be useful for various applications like language learning tools, text scrambling games, or simply reversing user input for interesting effects.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. If the sentence contains non-alphabetic characters (excluding spaces), raises a ValueError. Parameters: sentence (str): The input sentence to be reversed. Returns: str: Sentence with reversed word order. # Check for invalid characters if not all(char.isalpha() or char.isspace() for char in sentence): raise ValueError(\\"Sentence must only contain alphabetic characters and spaces\\") # Split the sentence into words, ignoring leading/trailing spaces words = sentence.strip().split() # Reverse the order of words and join them back into a string reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence"},{"question":"# Coding Assessment Question Context A permutation of a string is another string that contains the same characters, only the order of characters can be different. For example, \\"abcd\\" and \\"dabc\\" are permutations of each other. Given a string, your task is to determine the total number of distinct permutations of the string that are also valid English words. Task Write a function `count_valid_word_permutations(s: str) -> int` that returns the number of distinct permutations of the input string (s) that are valid English words. You are provided with a list of valid English words. Input * A string (s) where (1 leq text{len}(s) leq 10). * A list of valid words. Output * An integer representing the total number of distinct permutations of (s) that are valid English words. Constraints * The function should consider only unique permutations. * The valid words list is global, meaning it should not be passed as an argument to the function. * The implementation should not generate all permutations explicitly due to potential computational inefficiency. Example ```python VALID_WORDS = [\\"cat\\", \\"act\\", \\"tac\\", \\"dog\\", \\"god\\", \\"odg\\"] def count_valid_word_permutations(s: str) -> int: # Implementation here pass # Example Usage print(count_valid_word_permutations(\\"cat\\")) # Output: 3 print(count_valid_word_permutations(\\"dog\\")) # Output: 3 ``` # Requirements * Use efficient techniques to generate and check permutations. * Utilize Python built-in libraries effectively to manage permutations. * Ensure the function is optimized for the given constraints.","solution":"from itertools import permutations VALID_WORDS = [\\"cat\\", \\"act\\", \\"tac\\", \\"dog\\", \\"god\\", \\"odg\\"] def count_valid_word_permutations(s: str) -> int: Returns the number of distinct permutations of the string `s` that are also valid English words. # Generate unique permutations of the string unique_permutations = set(\'\'.join(p) for p in permutations(s)) # Count the number of valid words in the unique permutations valid_permutations_count = sum(1 for p in unique_permutations if p in VALID_WORDS) return valid_permutations_count"},{"question":"# Image Segmentation Using K-Means Clustering You have been provided with an image represented as a 3D numpy array. Your task is to perform image segmentation using K-Means clustering. The goal is to segment the image into distinct regions (clusters) based on pixel colors. Use the K-Means algorithm to partition the image pixels into a specified number of clusters and then reconstruct a simplified version of the image where each pixel is replaced by the mean color of its respective cluster. **Function Signature**: ```python def segment_image( image: np.ndarray, num_clusters: int, max_iterations: int = 300 ) -> np.ndarray: ``` **Input**: - `image`: A 3D numpy array of shape `(height, width, 3)` representing the image in RGB format. - `num_clusters`: An integer representing the number of clusters to segment the image into. - `max_iterations`: An integer representing the maximum number of iterations the K-Means algorithm will run. Default is 300. **Output**: - A 3D numpy array of shape `(height, width, 3)` representing the segmented image, where each pixel\'s color is replaced by the mean color of the cluster it belongs to. **Constraints**: - Assume the input image array is valid and its dimensions are non-zero. - Ensure `num_clusters` is a positive integer less than or equal to the total number of pixels in the image. - Optimize the clustering process to handle images with a large number of pixels efficiently. **Example** ```python import numpy as np from sklearn.cluster import KMeans def segment_image(image: np.ndarray, num_clusters: int, max_iterations: int = 300) -> np.ndarray: height, width, _ = image.shape image_reshaped = image.reshape(-1, 3) kmeans = KMeans(n_clusters=num_clusters, max_iter=max_iterations, random_state=42) kmeans.fit(image_reshaped) clustered = kmeans.cluster_centers_[kmeans.labels_] segmented_image = clustered.reshape(height, width, 3).astype(np.uint8) return segmented_image # Example usage image = np.array([ [[255, 0, 0], [0, 255, 0], [0, 0, 255]], [[255, 255, 0], [0, 255, 255], [255, 0, 255]] ]) num_clusters = 2 segmented_image = segment_image(image, num_clusters) print(segmented_image) ``` Write your code for the `segment_image` function following the specifications listed above. Ensure the clustering is accurate and the segmented image correctly represents the simplified version based on the cluster means.","solution":"import numpy as np from sklearn.cluster import KMeans def segment_image(image: np.ndarray, num_clusters: int, max_iterations: int = 300) -> np.ndarray: Segments the image into distinct regions (clusters) based on pixel colors using K-Means clustering. Args: image (np.ndarray): A 3D numpy array of shape (height, width, 3) representing the image in RGB format. num_clusters (int): The number of clusters to segment the image into. max_iterations (int): The maximum number of iterations the K-Means algorithm will run. Default is 300. Returns: np.ndarray: A 3D numpy array of shape (height, width, 3) representing the segmented image. height, width, _ = image.shape # Reshape the image to a 2D array of pixels image_reshaped = image.reshape(-1, 3) # Apply K-Means clustering kmeans = KMeans(n_clusters=num_clusters, max_iter=max_iterations, random_state=42) kmeans.fit(image_reshaped) # Replace each pixel by the mean color of its respective cluster clustered = kmeans.cluster_centers_[kmeans.labels_] segmented_image = clustered.reshape(height, width, 3).astype(np.uint8) return segmented_image"},{"question":"# Matrix Rotator Scenario You are building a component for an image processing toolkit. One of the features involves rotating an image represented as a 2D matrix by 90 degrees clockwise. Task Write a function `rotate_matrix` that takes a 2D list (matrix) and rotates it 90 degrees clockwise. Function Definition ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: ``` Input - A 2D list of integers representing the matrix. - Example: ```python [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` Output - A 2D list of integers representing the rotated matrix. - Example: ```python [[7, 4, 1], [8, 5, 2], [9, 6, 3]] ``` Constraints - The input matrix will be a square matrix with dimensions ranging from 1x1 to 100x100. - All elements of the matrix are integers between -1000 and 1000. Validation Scenarios To validate your solution, it should pass these examples: ```python assert rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_matrix([[1]]) == [[1]] assert rotate_matrix([[1, 2], [3, 4]]) == [[3, 1], [4, 2]] ``` Special Cases - The function should handle an empty matrix input: ```python assert rotate_matrix([]) == [] ```","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: if len(matrix) == 0: return matrix n = len(matrix) # Perform in-place rotation for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp return matrix"},{"question":"# Scenario You are developing a software module for a weather simulation system that calculates the average temperature for a given period from a series of daily temperature measurements. The module also needs to identify the highest and lowest temperatures recorded during the period. This functionality is crucial for understanding temperature trends and anomalies. # Objective Implement a function that calculates the average, highest, and lowest temperatures from a list of daily temperature readings and returns a dictionary containing these values. # Function Signature ```python def temperature_stats(temperatures: List[float]) -> dict: pass ``` # Input * `temperatures`: A list of floating-point numbers representing daily temperature readings. # Output * A dictionary with keys `average`, `highest`, and `lowest`, and corresponding values as the calculated average temperature, the highest temperature, and the lowest temperature in the input list. # Constraints * The list `temperatures` will have at least one temperature reading. * The list can have up to 1,000 temperature readings. * The temperatures can include negative values (e.g., representing degrees below freezing). # Requirements * Calculate the average temperature accurately to at least two decimal places. * Identify the highest and lowest recorded temperatures correctly. # Example ```python assert temperature_stats([72.5, 75.0, 78.5, 80.0, 79.0]) == { \'average\': 77.0, \'highest\': 80.0, \'lowest\': 72.5 } assert temperature_stats([-10.0, 0.0, 5.5, -3.5, 2.0]) == { \'average\': -1.2, \'highest\': 5.5, \'lowest\': -10.0 } assert temperature_stats([100.0, 100.0, 100.0]) == { \'average\': 100.0, \'highest\': 100.0, \'lowest\': 100.0 } ```","solution":"from typing import List def temperature_stats(temperatures: List[float]) -> dict: Returns the average, highest, and lowest temperature from a list of daily temperatures. highest = max(temperatures) lowest = min(temperatures) average = round(sum(temperatures) / len(temperatures), 2) return { \'average\': average, \'highest\': highest, \'lowest\': lowest }"},{"question":"# File Processing and Data Extraction You are required to implement a class `LogParser` that processes a structured log file and extracts meaningful information from it. The log file contains multiple entries, each with a timestamp, log level, and a message, formatted as follows: ``` [YYYY-MM-DD HH:MM:SS] [LOG LEVEL] Message ``` Your task consists of two parts: Part 1: Implement LogParser Class Implement the `LogParser` class with the following methods: 1. `__init__(self, filepath: str)`: Initialize the parser by loading the log file from the given `filepath`. 2. `parse_log(self) -> list[dict]`: Parse the log file and return a list of dictionaries, each containing `timestamp`, `log_level`, and `message` for each log entry. Part 2: Add Filtering Functionality Extend the class to include methods to filter logs based on log level and time range: 1. `filter_by_log_level(self, level: str) -> list[dict]`: Return all log entries with the specified log level. 2. `filter_by_time_range(self, start: str, end: str) -> list[dict]`: Return all log entries within the start and end timestamps (inclusive). # Input and Output Formats Input * `filepath`: A string representing the path to the log file. * `level`: A string representing the desired log level (e.g., \\"INFO\\", \\"ERROR\\"). * `start`, `end`: Strings representing the start and end timestamps in the format \\"YYYY-MM-DD HH:MM:SS\\". Output * `parse_log()`: A list of dictionaries, each containing `timestamp`, `log_level`, and `message`. * `filter_by_log_level(level)`: A list of dictionaries filtered by log level. * `filter_by_time_range(start, end)`: A list of dictionaries filtered by the specified time range. # Constraints 1. The log file contains valid log entries as described in the format. 2. The `filepath`, `level`, `start`, and `end` are valid strings. 3. Log levels are \\"DEBUG\\", \\"INFO\\", \\"WARNING\\", \\"ERROR\\", \\"CRITICAL\\". 4. The time range for filtering is within bounds of the log file entries. # Examples ```python parser = LogParser(\\"path/to/logfile.log\\") parsed_logs = parser.parse_log() print(parsed_logs) # Example Log Entry Dictionary # { # \\"timestamp\\": \\"2023-01-01 12:00:00\\", # \\"log_level\\": \\"ERROR\\", # \\"message\\": \\"An error occurred\\" # } filtered_by_level = parser.filter_by_log_level(\\"ERROR\\") print(filtered_by_level) filtered_by_time = parser.filter_by_time_range(\\"2023-01-01 12:00:00\\", \\"2023-01-02 12:00:00\\") print(filtered_by_time) ``` # Notes * Ensure proper handling of date-time parsing and comparisons. * Validate your implementation against various log file structures and edge cases. * The `parse_log` method should read and process the file efficiently, especially for large files.","solution":"import re from datetime import datetime class LogParser: def __init__(self, filepath: str): self.filepath = filepath self.logs = self.parse_log() def parse_log(self) -> list: logs = [] pattern = re.compile(r\'[(.*?)]s[(.*?)]s(.*)\') with open(self.filepath, \'r\') as file: for line in file: match = pattern.match(line) if match: timestamp = match.group(1) log_level = match.group(2) message = match.group(3) logs.append({ \\"timestamp\\": timestamp, \\"log_level\\": log_level, \\"message\\": message }) return logs def filter_by_log_level(self, level: str) -> list: return [log for log in self.logs if log[\\"log_level\\"].upper() == level.upper()] def filter_by_time_range(self, start: str, end: str) -> list: start = datetime.strptime(start, \\"%Y-%m-%d %H:%M:%S\\") end = datetime.strptime(end, \\"%Y-%m-%d %H:%M:%S\\") return [log for log in self.logs if start <= datetime.strptime(log[\\"timestamp\\"], \\"%Y-%m-%d %H:%M:%S\\") <= end]"},{"question":"# Problem Statement Given an array of integers and a target sum, write a function `find_triplet_sum(arr: List[int], target: int) -> Tuple[int, int, int]` that finds a triplet in the array whose sum is equal to the target sum. Return the triplet as a tuple of three integers. If no such triplet exists, return an empty tuple. # Input: - `arr` (List[int]): A list of integers. - `target` (int): The target sum to be achieved by the sum of three distinct integers in the array. # Output: - Return a tuple of three integers whose sum equals the target. If no such triplet is found, return an empty tuple. # Constraints: - The length of `arr` is at least 3. - The elements in `arr` range from `-10^6` to `10^6`. - There can be multiple triplets with the same sum. Any one valid triplet is acceptable. # Notes: - The function should handle the case where there are no such triplets gracefully. - The function should try to minimize the time complexity to be efficient on large inputs. # Example: ```python from typing import List, Tuple def find_triplet_sum(arr: List[int], target: int) -> Tuple[int, int, int]: # Implementation here # Test cases print(find_triplet_sum([1, 4, 45, 6, 10, 8], 22)) # Output: (4, 10, 8) or any other valid triplet print(find_triplet_sum([1, 2, 3, 4, 5], 9)) # Output: (1, 3, 5) or any other valid triplet print(find_triplet_sum([1, 2, 3, 4], 12)) # Output: () as no triplet gives the sum 12 ```","solution":"from typing import List, Tuple def find_triplet_sum(arr: List[int], target: int) -> Tuple[int, int, int]: arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return (arr[i], arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return ()"},{"question":"# Problem Statement Write a function that removes duplicate contiguous characters from a given string and returns the result. Consecutive repetitions of characters should be reduced to a single character. If the input string is empty or contains non-alphabetic characters, your function should raise a `ValueError`. Function Signature ```python def remove_duplicates(orig_string: str) -> str: ``` Input * **orig_string (str)**: A string containing alphabetic characters, e.g., \\"aabbcc\\", \\"aabbccaa\\". Output * **(str)**: A string with contiguous duplicates removed, e.g., \\"abc\\", \\"abca\\". Constraints * `orig_string` may be empty or contain non-alphabetic characters, in which case your function should raise a `ValueError`. Performance Requirements * The function should run in linear time relative to the length of the input string. Examples ```python >>> remove_duplicates(\\"aabbcc\\") \'abc\' >>> remove_duplicates(\\"aabbccaa\\") \'abca\' >>> remove_duplicates(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> remove_duplicates(\\"123abc\\") Traceback (most recent call last): ... ValueError: Non-alphabetic value was passed to the function ``` Context This function can be useful in data cleaning processes where removal of redundant consecutive characters is required, such as in text normalization or log file processing. Ensure your solution correctly handles all specified edge cases and passes the provided examples.","solution":"def remove_duplicates(orig_string: str) -> str: if not orig_string: raise ValueError(\\"Empty string was passed to the function\\") if not orig_string.isalpha(): raise ValueError(\\"Non-alphabetic value was passed to the function\\") result = [] prev_char = None for char in orig_string: if char != prev_char: result.append(char) prev_char = char return \'\'.join(result)"},{"question":"# Problem Statement You are part of a software team working on a financial application. One of your tasks is to implement a function that evaluates whether a given string is a valid representation of a floating-point number, as it might be encountered in CSV data imports. Valid representations include numbers with optional leading and trailing spaces, an optional leading \'+\' or \'-\' sign, and a decimal point. Scientific notation (e.g., \\"1.2e10\\") is also valid. Note that comma-separated values (e.g., \\"1,000.55\\") are not considered valid for this function. # Function Signature ```python def is_valid_float(input_str: str) -> bool: pass ``` # Input - `input_str` (str): A string representing a potential floating-point number. # Output - A boolean value (bool): - `True` if the `input_str` is a valid representation of a floating-point number. - `False` otherwise. # Constraints - The input string can be empty, have leading, trailing, or internal spaces. - The function should ignore leading and trailing spaces. - An empty string or a string that does not represent a number should return `False`. # Examples ```python >>> is_valid_float(\\" 3.14 \\") True >>> is_valid_float(\\"+123.45\\") True >>> is_valid_float(\\" -.4e-2\\") True >>> is_valid_float(\\" \\") False >>> is_valid_float(\\"1,000.55\\") False >>> is_valid_float(\\"3..14\\") False ``` # Error Handling - If the input string is empty or represents a non-valid float, the function should return `False`. # Notes - Scientific notation (e.g., \\"1.23e+10\\" or \\"-4.56e-2\\") should be considered valid. - Whitespaces should be ignored if they exist at the boundaries but not between digits and decimal points. - The function should not convert a valid string into a float, but only check its validity. Implement the `is_valid_float` function following the guidelines and constraints stated above.","solution":"def is_valid_float(input_str: str) -> bool: Checks whether the input string is a valid representation of a floating-point number. input_str = input_str.strip() if not input_str: return False try: float(input_str) return True except ValueError: return False"},{"question":"# Document Validation Assessment **Context**: Many applications require accurate validation of documents based on predefined rules. One common example is validating textual representations of structured documents such as CSV (Comma-Separated Values) files. Proper validation involves checking the structure, the content type of each field, and ensuring mandatory fields are present. **Task**: Implement the `validate_document` function that, given a CSV string and a dictionary of validation rules, validates whether the document adheres to those rules. Input * `document`: A string representing the CSV content. Each line is a record, and fields in each record are separated by commas. The first line contains the header with field names. * `rules`: A dictionary where the keys are the field names, and the values are another dictionary with keys: * `type`: A string representing the type of data expected in the field (`\\"int\\"`, `\\"float\\"`, or `\\"str\\"`). * `mandatory`: A boolean indicating whether the field is required. Output * Return a boolean: `True` if the document is valid according to the rules, `False` otherwise. Constraints * The `document` string will always contain at least one line (the header). * The `rules` dictionary will always contain all the field names from the header. * Each field in the document must comply with its defined rule in `rules`. Example ```python document = name,age,grade Alice,30,85.5 Bob,25,90.0 Clara,35, rules = { \\"name\\": {\\"type\\": \\"str\\", \\"mandatory\\": True}, \\"age\\": {\\"type\\": \\"int\\", \\"mandatory\\": True}, \\"grade\\": {\\"type\\": \\"float\\", \\"mandatory\\": False} } output = validate_document(document, rules) print(output) # Expected output: True ``` In this example, the first line (header) matches the field names, and each subsequent line matches the types and mandatory status of the fields as per `rules`. Instruction Fill in the `validate_document` function: ```python def validate_document(document, rules): # Your implementation goes here pass ``` Validation Requirements 1. Ensure each field has the correct data type: * `int`: Integer numbers, without decimal places. * `float`: Decimal numbers. * `str`: Alphabetic strings. 2. Verify that all mandatory fields are present and non-empty. 3. Skip any records that fail validation and return `False`. **Guidelines** - Parse the CSV string accurately: handle multiple lines and split values correctly. - Use robust error handling to manage poor input data gracefully. - Optimize for performance to handle large documents efficiently.","solution":"def validate_document(document, rules): Validate the CSV document based on the provided rules. Parameters: document (str): The CSV string representation. rules (dict): A dictionary containing validation rules for each field. Returns: bool: True if the document is valid according to the rules, False otherwise. lines = document.strip().split(\\"n\\") headers = lines[0].split(\\",\\") # Map header index with field name header_indices = {header: idx for idx, header in enumerate(headers)} def validate_value(value, rule): if rule[\\"mandatory\\"] and value == \\"\\": return False if value == \\"\\": return True if rule[\\"type\\"] == \\"int\\": return value.isdigit() elif rule[\\"type\\"] == \\"float\\": try: float(value) return True except ValueError: return False elif rule[\\"type\\"] == \\"str\\": return isinstance(value, str) return False for line in lines[1:]: fields = line.split(\\",\\") if len(fields) != len(headers): return False for header in headers: if not validate_value(fields[header_indices[header]], rules[header]): return False return True"},{"question":"# Coding Question: Array Rotation Checker **Problem Statement:** You are given two integer arrays, `arr1` and `arr2`. Both arrays are non-empty and of the same length. The goal is to determine if `arr2` could be a rotation of `arr1`. An array `arr2` is a rotation of `arr1` if `arr2` can be obtained by shifting the elements of `arr1` in a circular manner. For example, `arr2` can be a rotation of `arr1` by: - Shifting elements to the right: e.g., `[1, 2, 3, 4]` rotated to `[4, 1, 2, 3]` by 1 position, or `[3, 4, 1, 2]` by 2 positions. - Shifting elements to the left: e.g., `[1, 2, 3, 4]` rotated to `[2, 3, 4, 1]` by 1 position, or `[3, 4, 1, 2]` by 2 positions. **Input:** - **Two lists of integers, `arr1` and `arr2`** **Output:** - **A boolean indicating if `arr2` is a rotation of `arr1`** **Example:** ```python arr1 = [1, 2, 3, 4, 5] arr2 = [3, 4, 5, 1, 2] # Output: True arr1 = [1, 2, 3, 4, 5] arr2 = [4, 5, 1, 2, 3] # Output: True arr1 = [1, 2, 3, 4, 5] arr2 = [5, 4, 3, 2, 1] # Output: False arr1 = [1, 2, 3, 4, 5] arr2 = [2, 3, 4, 5, 6] # Output: False ``` **Constraints:** - The length of both arrays is between 1 and (10^5). - The array elements are integers within the range (-10^9) and (10^9). **Function Signature:** ```python def is_rotation(arr1: List[int], arr2: List[int]) -> bool: pass ``` **Solution Approach:** 1. Check if the two arrays have the same length, return `False` otherwise. 2. Concatenate `arr1` with itself to cover all possible rotations. 3. Check if `arr2` is a subarray within this doubled `arr1`. **Example Execution:** ```python >>> is_rotation([1, 2, 3, 4, 5], [3, 4, 5, 1, 2]) True >>> is_rotation([1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) False ```","solution":"def is_rotation(arr1, arr2): Checks if arr2 is a rotation of arr1. if len(arr1) != len(arr2): return False doubled_arr1 = arr1 + arr1 for i in range(len(arr1)): if doubled_arr1[i:i + len(arr2)] == arr2: return True return False"},{"question":"# Problem Statement **Scenario**: In a mysterious kingdom, there exists a very special string called the \\"Royal Pins\\". The Royal Pins follow a specific pattern that determines their worth. Each string has a specific sequence of characters and a specific set of rules to transform those characters into a numeric code. This numeric code is then used to determine the string\'s worth. The transformation rules must be consistently applied to unlock its true potential. # Task Implement function `transform_royal_pins(pin: str) -> int` which takes a string `pin` consisting of lowercase letters and transforms it into a numeric code according to the following rules: 1. Each letter from \'a\' to \'z\' represents a number from 1 to 26 (\'a\' -> 1, \'b\' -> 2, ..., \'z\' -> 26). 2. The numeric code is calculated by summing the values of individual characters in the string and then multiplying by the length of the string. If the input string is empty or contains invalid characters, the function should return 0. # Function Signature ```python def transform_royal_pins(pin: str) -> int: Args: pin (str): The input string representing the Royal Pin. Returns: int: The numeric code of the Royal Pin, or 0 if invalid input. ``` # Constraints * The input string `pin` will have a length of at most 1000 characters. * The input string `pin` will contain only lowercase alphabets. # Example ```python # Example 1 assert transform_royal_pins(\\"abc\\") == 18 # Explanation: (1 + 2 + 3) * 3 = 18 # Example 2 assert transform_royal_pins(\\"xyz\\") == 225 # Explanation: (24 + 25 + 26) * 3 = 225 # Example 3 assert transform_royal_pins(\\"\\") == 0 # Explanation: Empty string, hence returns 0 # Example 4 assert transform_royal_pins(\\"a1b2\\") == 0 # Explanation: Invalid characters present, hence returns 0 ``` # Explanation In the examples: - **Example 1**: The string \\"abc\\" translates to the values [1, 2, 3]. The sum of these values is 6, and since the length of the string is 3, the final numeric code is 6 * 3 = 18. - **Example 2**: The string \\"xyz\\" translates to the values [24, 25, 26]. The sum of these values is 75, and since the length of the string is 3, the final numeric code is 75 * 3 = 225. - **Example 3**: An empty string results in a numeric code of 0. - **Example 4**: The presence of any invalid character in the string results in a numeric code of 0.","solution":"def transform_royal_pins(pin: str) -> int: Transforms the input string of pins into its numeric code by summing the values of individual characters and multiplying by the length of the string. Returns 0 if the input string is empty or contains invalid characters. Args: pin (str): The input string representing the Royal Pin. Returns: int: The numeric code of the Royal Pin, or 0 if invalid input. if not pin.isalpha() or not pin.islower(): return 0 total_value = sum(ord(char) - ord(\'a\') + 1 for char in pin) return total_value * len(pin)"},{"question":"# Scenario You are working on a monitoring system for a hospital where each room contains sensors that generate log data about patient activities. To efficiently process and monitor the data, you need to implement a system that processes logs from multiple rooms, merges them in chronological order, and returns the most recent k logs. # Problem Statement Write a function to merge logs from multiple rooms in chronological order and return the most recent k logs. Each log entry contains a timestamp and a message. # Function Signature ```python def get_recent_logs(logs: List[List[Tuple[int, str]]], k: int) -> List[Tuple[int, str]]: pass ``` # Input - `logs`: A list of lists, where each sublist contains tuples representing log entries from one room. Each tuple consists of an integer timestamp and a string message. - `k`: An integer representing the number of most recent logs to return. # Output - A list of tuples containing the most recent k logs merged from all the rooms, sorted in descending order of timestamps. Each tuple should contain an integer timestamp and a string message. # Constraints - The total number of logs across all rooms will not exceed 10^4. - Each timestamp will be a non-negative integer. - 1 <= k <= Total number of logs. # Example ```python logs = [ [(1, \\"Patient A entered room 1\\"), (3, \\"Patient B entered room 1\\")], [(2, \\"Patient C entered room 2\\"), (4, \\"Patient D entered room 2\\")], [(1, \\"Patient E entered room 3\\"), (5, \\"Patient F entered room 3\\")] ] k = 3 print(get_recent_logs(logs, k)) # Expected Output: [(5, \\"Patient F entered room 3\\"), (4, \\"Patient D entered room 2\\"), (3, \\"Patient B entered room 1\\")] ``` # Notes - Ensure your solution efficiently handles the merging and sorting to accommodate the worst-case scenario of the maximum number of logs. - Consider edge cases where logs might have the same timestamps but originated from different rooms. - Provide clear and readable code comments where necessary to explain the logic used.","solution":"from heapq import merge from typing import List, Tuple def get_recent_logs(logs: List[List[Tuple[int, str]]], k: int) -> List[Tuple[int, str]]: Merges logs from multiple rooms in chronological order and returns the most recent k logs. :param logs: A list of lists, where each sublist contains tuples representing log entries from one room. Each tuple consists of an integer timestamp and a string message. :param k: An integer representing the number of most recent logs to return. :return: A list of tuples containing the most recent k logs merged from all the rooms, sorted in descending order of timestamps. # Merge all logs into a single sorted list merged_logs = list(merge(*logs, key=lambda x: x[0])) # Get the most recent k logs (sorted by timestamp in descending order) recent_logs = sorted(merged_logs, key=lambda x: x[0], reverse=True)[:k] return recent_logs"},{"question":"**Array Pair Sum Check** You need to determine if there are two distinct numbers in a given list that add up to a specified target sum. 1. **Pair Check**: Iterate through the list and check if any two distinct numbers sum up to the target value. # Input: - An integer list of numbers `arr` (e.g., [2, 7, 11, 15]). - An integer `target` which represents the target sum. # Output: - A boolean value: `True` if such a pair exists, `False` otherwise. # Function Signature: ```python def has_pair_with_sum(arr: list, target: int) -> bool: pass ``` # Example: ```python arr = [2, 7, 11, 15] target = 9 print(has_pair_with_sum(arr, target)) # Output should be True arr = [3, 2, 4] target = 6 print(has_pair_with_sum(arr, target)) # Output should be True arr = [1, 2, 3, 4, 5] target = 10 print(has_pair_with_sum(arr, target)) # Output should be False ``` # Constraints: - The input list may contain up to 10,000 integers. - Each element in the list is a positive integer. - The same element cannot be used twice to form a pair. # Performance Requirements: - The function should achieve a time complexity of O(n) to efficiently handle lists of up to 10,000 integers. **Hint**: Consider using a set to keep track of the complements (target - current number) while iterating through the list.","solution":"def has_pair_with_sum(arr: list, target: int) -> bool: Determines if there are two distinct numbers in `arr` that add up to `target`. Parameters: arr (list): List of integers. target (int): Target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for number in arr: if target - number in seen: return True seen.add(number) return False"},{"question":"# Problem Statement You need to manipulate an array of integers representing stock prices on different days to find the maximum profit that could be achieved by making at most two transactions. A transaction consists of buying and then selling the stock on different days. Note that the second transaction must be started after the first one is completed (i.e., you cannot engage in multiple overlapping stock purchases/sales). # Function Specifications You need to implement the following function: ```python def max_profit_with_two_transactions(prices: List[int]) -> int: Calculates the maximum profit with at most two buy-sell transactions. Parameters: prices (List[int]): A list of integers representing stock prices on different days. Returns: int: The maximum profit possible with at most two transactions. pass ``` # Input The function `max_profit_with_two_transactions` takes a single parameter: * `prices (0 <= len(prices) <= 100000)`: A list of integers where each integer represents the price of a stock on a given day. All integers are non-negative. # Output The function should return an integer: * The maximum profit obtained from at most two transactions. If no transactions can be made, return 0. # Example Example 1: ```python print(max_profit_with_two_transactions([3,3,5,0,0,3,1,4])) # Output: 6 ``` (Explanation: Buy on day 4 (price=0) and sell on day 6 (price=3), profit=3-0=3. Then buy on day 7 (price=1) and sell on day 8 (price=4), profit=4-1=3. Total profit is 3+3=6.) Example 2: ```python print(max_profit_with_two_transactions([1,2,3,4,5])) # Output: 4 ``` (Explanation: Buy on day 1 (price=1) and sell on day 5 (price=5), profit=5-1=4. No second transaction is needed.) Example 3: ```python print(max_profit_with_two_transactions([7,6,4,3,1])) # Output: 0 ``` (Explanation: In this case, no transaction is possible for any profit.) # Constraints * The solution must be efficient and capable of handling the upper limit of input size. * Be sure to handle edge cases, such as when `prices` is an empty list. # Commentary The underlying task involves dynamic programming to calculate the maximum profit for one transaction and then reusing that information to calculate the maximum profit with two transactions. Consider separating the problem into manageable subproblems for clarity and efficiency.","solution":"from typing import List def max_profit_with_two_transactions(prices: List[int]) -> int: if not prices: return 0 n = len(prices) # Initialize profits arrays profit_one_txn = [0] * n profit_two_txn = [0] * n # Calculate maximum profit achievable until each day with at most one transaction min_price = prices[0] for i in range(1, n): min_price = min(min_price, prices[i]) profit_one_txn[i] = max(profit_one_txn[i - 1], prices[i] - min_price) # Calculate maximum profit achievable from each day to the end with at most one transaction max_price = prices[-1] for i in range(n - 2, -1, -1): max_price = max(max_price, prices[i]) profit_two_txn[i] = max(profit_two_txn[i + 1], max_price - prices[i]) # Combine the two transactions\' profits max_profit = 0 for i in range(n): max_profit = max(max_profit, profit_one_txn[i] + profit_two_txn[i]) return max_profit"},{"question":"# Question: Sorting Integers with Custom Comparator You are required to implement a custom sorting function for a list of integers. Your task is to sort the integers based on the sum of their digits. In case of a tie (i.e., two integers have the same sum of digits), the integers should be sorted by their natural order. Function Signature: ```python def custom_sort(arr: List[int]) -> List[int]: pass ``` Input: - `arr`: A list of integers that need to be sorted. Output: - A list of integers sorted based on the criteria described. Constraints: - The length of `arr` will be in the range `[1, 10^5]`. - Each integer in `arr` will be in the range `[-10^6, 10^6]`. # Example: ```python assert custom_sort([56, 74, 35, 213, 92, 110]) == [110, 35, 213, 56, 74, 92] assert custom_sort([6, 21, 30, 111, 100]) == [6, 21, 30, 100, 111] # Explanation: # In the first example, the sum of digits for each number is: # 56 -> 5+6=11 # 74 -> 7+4=11 # 35 -> 3+5=8 # 213 -> 2+1+3=6 # 92 -> 9+2=11 # 110 -> 1+1+0=2 # Sorting by digit sums: [110, 213, 35, 56, 74, 92] # In the second example, the sum of digits for each number is: # 6 -> 6 # 21 -> 2+1=3 # 30 -> 3+0=3 # 111 -> 1+1+1=3 # 100 -> 1+0+0=1 # Sorting by digit sums: [100, 21, 30, 111, 6] ``` **Note**: Your implementation should be efficient, given the constraints. Aim to minimize the time complexity wherever possible.","solution":"from typing import List def digit_sum(n: int) -> int: return sum(int(d) for d in str(abs(n))) def custom_sort(arr: List[int]) -> List[int]: return sorted(arr, key=lambda x: (digit_sum(x), x))"},{"question":"# Collatz Sequence Calculator The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined as follows: start with any positive integer `n`. Then each term is obtained from the previous term as follows: - If the previous term is even, the next term is one half of the previous term. - If the previous term is odd, the next term is 3 times the previous term plus 1. The conjecture is that no matter what value of `n`, the sequence will eventually reach the number 1. 1. Implement a function `generate_collatz_sequence` that generates the Collatz sequence for a given number `n`. 2. Implement a function `collatz_steps_to_one` that determines the number of steps required to reach the number 1 in the Collatz sequence starting from `n`. Input and Output Formats 1. **Function `generate_collatz_sequence(n: int) -> list`**: - **Input**: An integer `n` where `n > 0`. - **Output**: A list of integers representing the Collatz sequence starting from `n`. 2. **Function `collatz_steps_to_one(n: int) -> int`**: - **Input**: An integer `n` where `n > 0`. - **Output**: An integer representing the number of steps required to reach 1. Constraints - `n` will be an integer such that `1 <= n <= 10^6`. Example ```python assert generate_collatz_sequence(6) == [6, 3, 10, 5, 16, 8, 4, 2, 1] assert collatz_steps_to_one(6) == 8 # Steps: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 assert generate_collatz_sequence(1) == [1] assert collatz_steps_to_one(1) == 0 # Already at 1, so 0 steps. ``` Write these functions and ensure that the constraints and edge cases are properly handled.","solution":"def generate_collatz_sequence(n): Generates the Collatz sequence for a given number n. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence def collatz_steps_to_one(n): Determines the number of steps required to reach the number 1 in the Collatz sequence starting from n. steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"# Array Permutations Problem Statement: You are tasked with generating all possible permutations of a given list of integers. Detailed Description: A permutation is a rearrangement of the elements of a list into a different sequence or order. Given a list of distinct integers, produce all possible permutations of the list. Function Signature: ```python def generate_permutations(nums: list[int]) -> list[list[int]]: # Your code here ``` Input/Output: * **Input**: * `nums` (list[int]): A list of distinct integers. * **Output**: * A list of lists, where each inner list is a unique permutation of the input list. Constraints: * All integers in the input list are unique. * The length of the input list will be between 0 and 8 inclusive. Example: ```python print(generate_permutations([1, 2, 3])) # Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] print(generate_permutations([])) # Output: [[]] print(generate_permutations([5])) # Output: [[5]] ``` Implementation Notes: * Your implementation should explore all possible arrangements using backtracking. * The approach should efficiently handle the constraints, especially given the factorial growth of permutations. * Include examples and edge cases in docstrings and comments to illustrate the function\'s expected behavior.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generate all permutations of a given list of distinct integers. Args: nums: A list of distinct integers. Returns: A list of lists, where each inner list is a unique permutation of nums. def backtrack(first=0): # if all integers are used up if first == n: output.append(nums[:]) for i in range(first, n): # place i-th integer first # in the current permutation nums[first], nums[i] = nums[i], nums[first] # use next integers to complete the permutations backtrack(first + 1) # backtrack nums[first], nums[i] = nums[i], nums[first] n = len(nums) output = [] backtrack() return output"},{"question":"# Challenge: Optimal Path in a Matrix Background You are given a matrix of integers where each cell represents the cost to step on that cell. You start from the top-left corner of the matrix and must reach the bottom-right corner. However, you can only move either right or down at any point in time. Objective Implement a function `optimal_path(matrix: List[List[int]]) -> int` that calculates the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix. Input * A 2D list `matrix` of integers where `1 <= len(matrix), len(matrix[0]) <= 100` and `0 <= matrix[i][j] <= 100`. Output * An integer representing the minimum cost to reach the bottom-right cell from the top-left cell. Constraints * You can only move right or down from any cell. Algorithm Hints * Use dynamic programming to keep track of the minimum cost to reach each cell. * Create a 2D list `dp` where `dp[i][j]` holds the minimum cost to reach cell `(i, j)`. Example ```python >>> matrix = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> optimal_path(matrix) 7 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6] ... ] >>> optimal_path(matrix) 12 ``` Note To fill `dp`, follow these steps: 1. Initialize `dp[0][0]` with `matrix[0][0]`. 2. Fill the first row and the first column. 3. For the rest of the cells, consider the minimum cost to get to the current cell from the cell above or the cell to the left. The formula for filling `dp[i][j]` is: `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])` for all `i` and `j` greater than zero.","solution":"def optimal_path(matrix): Calculate the minimum cost to travel from the top-left corner to the bottom-right corner of the matrix. Only right and down movements are allowed. :param matrix: List[List[int]] - 2D list representing the grid costs :return: int - Minimum cost to reach bottom-right corner from top-left corner rows = len(matrix) cols = len(matrix[0]) # Create a DP table filled with zeroes dp = [[0] * cols for _ in range(rows)] # Initialize the top-left cell with the starting cell\'s cost dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill in the rest of the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) # The bottom-right cell contains the minimum cost to reach it from the top-left corner return dp[rows-1][cols-1]"},{"question":"# Context: Sorting algorithms are fundamental in computer science, commonly used for organizing data. In this exercise, you\'ll implement a specific type of sorting method to transform an array into a nearly sorted array by performing a minimal number of adjacent swaps. # Task: Write a function `minimum_bribes(queue)` that takes a list of integers representing a queue of people with distinct numbers, where each person can bribe the person directly ahead of them to swap positions. The task is to determine the minimum number of swaps needed to sort the queue in ascending order, assuming each person can bribe at most twice. # Input: - `queue`: a list of integers representing the initial state of the queue. # Output: - An integer representing the minimum number of swaps needed to sort the queue, or return `-1` if it\'s not possible to sort the queue under the given constraints. # Constraints: - The length of `queue` will be between 1 and 100, inclusive. - The integers in `queue` will be unique and range from 1 to 100, inclusive. # Example: ```python queue = [2, 1, 5, 3, 4] assert minimum_bribes(queue) == 3 queue = [2, 5, 1, 3, 4] assert minimum_bribes(queue) == -1 ``` # Performance Requirements: - The function should efficiently handle the input constraints without excessive memory usage or time delays.","solution":"def minimum_bribes(queue): Determine the minimum number of swaps needed to sort the queue, or return -1 if not possible under the given constraints (each person can bribe at most twice). n = len(queue) total_bribes = 0 for i in range(n): # If any position has moved more than 2 spots, it\'s too chaotic if queue[i] - (i + 1) > 2: return -1 # Check each person\'s position and count the number of bribes for i in range(n): for j in range(max(0, queue[i] - 2), i): if queue[j] > queue[i]: total_bribes += 1 return total_bribes"},{"question":"# Coding Assessment Question Context You\'re working on a system that processes requests based on a priority rule. Each request has a priority level, and requests should be processed in descending order of their priority levels. If two requests have the same priority level, they should be processed based on the order they appear in the input list. Task Write a function `process_requests(requests: List[Tuple[int, str]]) -> List[str]` that takes a list of tuples, where each tuple contains an integer representing the priority level and a string representing the request. Your function should return a list of strings representing the request in the order they should be processed. Input * `requests`, a list of tuples where each tuple contains: * An integer (priority), where 1 ≤ priority ≤ 1000. * A string (request), where 1 ≤ length of request ≤ 100. Output * A list of strings representing the requests in the order they should be processed. # Sample Input 1 ```python requests = [(5, \'Request1\'), (10, \'Request2\'), (5, \'Request3\')] ``` # Sample Output 1 ```python [\'Request2\', \'Request1\', \'Request3\'] ``` # Explanation 1. \'Request2\' has the highest priority (10). 2. \'Request1\' and \'Request3\' have the same priority (5), but \'Request1\' appears before \'Request3\' in the input list. # Constraints * Handle up to 100,000 requests efficiently. * The result should maintain stability in sorting for requests with the same priority level, meaning their relative order from the input should be preserved. # Edge Cases * When all requests have the same priority. * When there is only one request. * Large variations in the number of requests and their priority levels. Function Signature ```python from typing import List, Tuple def process_requests(requests: List[Tuple[int, str]]) -> List[str]: pass # Implement the function to process requests based on the given criteria. ```","solution":"from typing import List, Tuple def process_requests(requests: List[Tuple[int, str]]) -> List[str]: Processes requests based on priority and their original order. Returns the requests sorted based on the priority in descending order. # Sort the requests first by priority in descending order. The original order of elements with the same priority is preserved. sorted_requests = sorted(requests, key=lambda x: -x[0]) # Extracting the request strings in the processed order. processed_order = [req[1] for req in sorted_requests] return processed_order"},{"question":"# Question: Implement Heap Sort You are tasked with implementing the Heap Sort algorithm. The algorithm should sort an array of integers in non-decreasing order using a max-heap. # Implementation Details: - **Function Signature**: `def heap_sort(arr: list[int]) -> list[int]:` - **Input**: - `arr`: A list of integers to be sorted. - **Output**: - A new list containing the elements from `arr` sorted in non-decreasing order. - **Constraints**: - The array can contain up to (10^5) elements. - You can assume the elements are in the range of (-10^9) to (10^9). # Requirements: 1. Implement the heap sort algorithm. 2. Make sure the function works efficiently within the given constraints. 3. Handle all possible edge cases appropriately. # Example: ```python def heap_sort(arr: list[int]) -> list[int]: pass # Example Test Cases assert heap_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert heap_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] assert heap_sort([10, 22, 1, 2, 3, 9, 15, 23]) == [1, 2, 3, 9, 10, 15, 22, 23] assert heap_sort([100]) == [100] assert heap_sort([]) == [] ```","solution":"def heapify(arr, n, i): largest = i # Initialize largest as root l = 2 * i + 1 # left = 2*i + 1 r = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if l < n and arr[i] < arr[l]: largest = l # See if right child of root exists and is greater than root if r < n and arr[largest] < arr[r]: largest = r # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr): n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"# Problem Statement Write a function to compute the Fibonacci numbers using dynamic programming to improve performance. The function needs to handle both small and large inputs efficiently. # Requirements * The function should be named `fibonacci` and take a single integer input `n` representing the position in the Fibonacci sequence. * The function should return an integer, which is the `n`-th Fibonacci number. * Validate the input to ensure `n` is a non-negative integer. If it is not, raise appropriate exceptions: * **TypeError**: If `n` is not an integer. * **ValueError**: If `n` is negative. # Constraints * Your solution should be optimized for performance using dynamic programming. * The input integer `n` will be within the range of 0 to 10,000. # Example Usage ```python >>> fibonacci(10) 55 >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(20) 6765 >>> fibonacci(\\"ten\\") Traceback (most recent call last): ... TypeError: Undefined for non-integers >>> fibonacci(-3) Traceback (most recent call last): ... ValueError: Undefined for negative numbers ``` # Notes * The Fibonacci sequence is defined as: * `F(0) = 0` * `F(1) = 1` * `F(n) = F(n-1) + F(n-2)` for `n >= 2` * Dynamic programming involves storing the results of subproblems (here, the previously computed Fibonacci numbers) to avoid redundant calculations. * Ensure the solution is efficient both in terms of time and space complexity. * Handle edge cases, such as very small values of `n` (0 and 1), as specified above.","solution":"def fibonacci(n): Returns the n-th Fibonacci number. Args: n : int : The position in the Fibonacci sequence. Returns: int : The n-th Fibonacci number. Raises: TypeError : If n is not an integer. ValueError : If n is a negative integer. if not isinstance(n, int): raise TypeError(\\"Undefined for non-integers\\") if n < 0: raise ValueError(\\"Undefined for negative numbers\\") if n == 0: return 0 if n == 1: return 1 fib = [0, 1] for i in range(2, n + 1): fib.append(fib[-1] + fib[-2]) return fib[n]"},{"question":"# Coding Question: Generate Lexicographically Smallest String after Swaps Context Given a string and a list of pairs of indices in the string, you can swap the characters at these indices. The task is to determine the lexicographically smallest string that can be obtained by performing any number of swaps among the given pairs of indices. Problem Statement You are tasked with writing two functions: 1. **union_find_initialize(n: int) -> UnionFind**: Initializes and returns a union-find data structure for `n` elements. 2. **smallest_string_after_swaps(s: str, pairs: List[Tuple[int, int]]) -> str**: Returns the lexicographically smallest string that can be obtained by swapping the characters based on the given list of pairs. Input/Output Formats - **Function 1: `union_find_initialize(n: int) -> UnionFind`** - **Input**: A single integer `n` representing the number of elements. - **Output**: An initialized union-find data structure. - **Constraints**: `1 ≤ n ≤ 10^5` - **Function 2: `smallest_string_after_swaps(s: str, pairs: List[Tuple[int, int]]) -> str`** - **Input**: A string `s` of length `n`, and a list of pairs of integers. - **Output**: The lexicographically smallest string that can be derived after swaps. - **Constraints**: - `1 ≤ len(s) ≤ 10^5` - `0 ≤ pairs[i][0], pairs[i][1] < len(s)` - Each pair `(i, j)` is unique and `i != j`. Detailed Requirements - **Union-Find Data Structure**: - The union-find structure should support union and find operations efficiently. - It should be used to group connected indices in the string. - **Swapping Mechanism**: - After initializing groups using the union-find data structure, sort characters of each group and reconstruct the string. - Ensure the final string is lexicographically smallest within given constraints. Example ```python >>> union_find_initialize(5) <UnionFind object> >>> smallest_string_after_swaps(\\"dcab\\", [(0, 3), (1, 2)]) \\"bacd\\" >>> smallest_string_after_swaps(\\"dcab\\", [(0, 3), (1, 2), (0, 2)]) \\"abcd\\" ``` Performance Goal - Ensure the solution is efficient with respect to both time and space, especially for large sizes of inputs. - Expected to handle up to `10^5` elements and swaps efficiently.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, n: int): self.parent = list(range(n)) self.rank = [1] * n def find(self, p: int) -> int: if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) # Path compression return self.parent[p] def union(self, p: int, q: int) -> None: rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def union_find_initialize(n: int) -> UnionFind: return UnionFind(n) def smallest_string_after_swaps(s: str, pairs: List[Tuple[int, int]]) -> str: n = len(s) uf = union_find_initialize(n) for x, y in pairs: uf.union(x, y) # Group all characters by their root parent from collections import defaultdict groups = defaultdict(list) for i in range(n): root = uf.find(i) groups[root].append(s[i]) # Sort characters in each group for group in groups.values(): group.sort() # Build the result string res = [] index_count = {i: 0 for i in range(n)} for i in range(n): root = uf.find(i) res.append(groups[root][index_count[root]]) index_count[root] += 1 return \'\'.join(res)"},{"question":"# Coding Assessment Question Scenario You are developing a navigation system for a delivery drone company. The drone needs to deliver packages to various locations on a grid. Each grid point represents a possible delivery location. The drone moves only either right or down at any point in time starting from the top-left corner of the grid (0, 0) to the bottom-right corner (m, n). Your task is to calculate the total number of distinct paths the drone can take to reach the destination. Function Definition Write a function `count_paths(m: int, n: int) -> int` that takes two integers `m` and `n` representing the dimensions of the grid and returns the number of distinct paths the drone can take to travel from the top-left corner to the bottom-right corner. Input * `m` (int): Number of rows of the grid (1 ≤ m ≤ 100). * `n` (int): Number of columns of the grid (1 ≤ n ≤ 100). Output * (int): The total number of distinct paths the drone can take from the top-left corner to the bottom-right corner. Example ```python >>> count_paths(3, 2) 3 >>> count_paths(7, 3) 28 ``` Constraints * The drone can only move to the right or down at any point in time. * You need to compute the number of paths efficiently using dynamic programming. Performance Requirements Your solution should handle the upper limits of the grid dimensions within a reasonable time frame considering the constraints (up to 100x100 grid). Edge Cases to Consider * If either m or n is 1, there should be exactly one distinct path (either all moves right or all moves down). * Large grid dimensions should be computed efficiently within reasonable time and space complexity.","solution":"def count_paths(m, n): Returns the number of distinct paths a drone can take from the top-left corner to the bottom-right corner in an m by n grid. # Create a 2D dp array with all elements initialized to 1 dp = [[1] * n for _ in range(m)] # Fill dp array using the relation dp[i][j] = dp[i-1][j] + dp[i][j-1] for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"Problem Statement: You are given a list of integers and you need to find the length of the longest consecutive subsequence in this list. Write a function `longest_consecutive_subsequence(nums: List[int]) -> int` that performs this task. Function Signature: ```python def longest_consecutive_subsequence(nums: List[int]) -> int: ... ``` Input: * A list of integers `nums` where `0 <= len(nums) <= 10^5` and each integer `-10^9 <= nums[i] <= 10^9`. Output: * An integer representing the length of the longest consecutive subsequence. Constraints: * The length of the input list and the range of integers ensure that the solution must handle potentially large inputs efficiently. * Duplicate elements in the list should be considered only once in a sequence. Example Usage: ```python print(longest_consecutive_subsequence([100, 4, 200, 1, 3, 2])) # Output: 4 print(longest_consecutive_subsequence([9, 1, 3, 2, 5, 4])) # Output: 5 print(longest_consecutive_subsequence([])) # Output: 0 print(longest_consecutive_subsequence([1, 2, 0, 1])) # Output: 3 ``` Scenario: Imagine you are working with a dataset of users\' activity logs, each represented by a unique integer timestamp. To analyze user behavior, it is often useful to identify the longest continuous period of activity. Given the list of activity timestamps, your task is to compute the longest period where user activity was continuous. Your task is to implement an efficient function to find the length of the longest consecutive subsequence in these logs. Notes: - Ensure the function is optimized for performance given the input constraints. - Consider edge cases such as an empty list or lists with all duplicates. - Utilize appropriate data structures to achieve the desired time complexity.","solution":"from typing import List def longest_consecutive_subsequence(nums: List[int]) -> int: if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: # this ensures that we start a new sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Scenario You\'re working on a data visualization tool that supports rendering 2D plots. A crucial feature of this tool is to create a heatmap based on a given set of data points. Each data point contributes to the heatmap with an influence that decreases with distance. # Task Given a list of data points and their respective intensities, implement the `generate_heatmap` function that produces a heatmap using Gaussian smoothing. The Gaussian influence is characterized by a kernel size and a standard deviation. # Function Signature ```python def generate_heatmap(data_points: List[Tuple[int, int, float]], width: int, height: int, k_size: int, sigma: float) -> List[List[float]]: pass ``` # Input * `data_points`: A list of tuples where each tuple contains the x-coordinate, y-coordinate, and intensity of a data point. * `width`: An integer representing the width of the heatmap. * `height`: An integer representing the height of the heatmap. * `k_size`: An odd integer representing the size of the Gaussian kernel. * `sigma`: A float representing the standard deviation of the Gaussian kernel. # Output * Returns a 2D list of floats representing the heatmap, where each value corresponds to the combined influence of all data points. # Constraints * `data_points` will contain at least one data point and at most 10,000 data points. * `width` and `height` will be between 10 and 1000 inclusive. * `k_size` will be a positive odd integer (3, 5, 7, ...). * `sigma` will be a positive float. # Example ```python data_points = [ (5, 5, 10), (15, 15, 20), (25, 25, 30), ] width = 30 height = 30 k_size = 3 sigma = 1.0 result = generate_heatmap(data_points, width, height, k_size, sigma) ``` # Notes * Use zero-padding for edges to handle boundary conditions. * Ensure the Gaussian kernel is properly normalized to maintain correct intensity levels. * Consider computational efficiency when implementing the convolution to handle larger heatmaps and a significant number of data points effectively.","solution":"import math from typing import List, Tuple def gaussian_kernel(k_size: int, sigma: float) -> List[List[float]]: Generates a Gaussian kernel given the size and standard deviation. kernel = [[0.0] * k_size for _ in range(k_size)] mean = k_size // 2 sum_val = 0.0 for x in range(k_size): for y in range(k_size): kernel[x][y] = math.exp(-0.5 * ((x - mean) ** 2 + (y - mean) ** 2) / sigma ** 2) sum_val += kernel[x][y] # Normalize the kernel for x in range(k_size): for y in range(k_size): kernel[x][y] /= sum_val return kernel def generate_heatmap(data_points: List[Tuple[int, int, float]], width: int, height: int, k_size: int, sigma: float) -> List[List[float]]: Generates a heatmap using Gaussian smoothing based on given data points. # Initialize heatmap with zeros heatmap = [[0.0] * width for _ in range(height)] # Generate Gaussian kernel kernel = gaussian_kernel(k_size, sigma) mean = k_size // 2 # Apply each data point with its intensity for x, y, intensity in data_points: for dx in range(-mean, mean + 1): for dy in range(-mean, mean + 1): if 0 <= x + dx < width and 0 <= y + dy < height: heatmap[y + dy][x + dx] += intensity * kernel[mean + dy][mean + dx] return heatmap"},{"question":"# Question: Implement the Caesar Cipher Implement a class `CaesarCipher` that can encode and decode messages using the Caesar cipher technique. The Caesar cipher shifts each letter in the message by a fixed number of positions down the alphabet. Your implementation should adhere to the following specifications: Class: `CaesarCipher` Methods: 1. **`encode(self, message: str, shift: int) -> str`**: * Input: A message (str) to be encoded and an integer shift indicating the number of positions each letter should be shifted. * Output: The encoded message (str). * Example: `CaesarCipher().encode(\'hello\', 3)` should return `\'khoor\'`. 2. **`decode(self, message: str, shift: int) -> str`**: * Input: A message (str) to be decoded and an integer shift indicating the number of positions each letter should be shifted back. * Output: The decoded message (str). * Example: `CaesarCipher().decode(\'khoor\', 3)` should return `\'hello\'`. Constraints: * The message will contain only lowercase and uppercase letters and spaces. * Spaces should remain unchanged in the encoding and decoding process. * The shift will be a positive integer. ```python class CaesarCipher: def __init__(self) -> None: self.alphabet = \'abcdefghijklmnopqrstuvwxyz\' def encode(self, message: str, shift: int) -> str: result = [] for char in message: if char.isalpha(): is_upper = char.isupper() base = \'A\' if is_upper else \'a\' shifted_char = chr((ord(char) - ord(base) + shift) % 26 + ord(base)) result.append(shifted_char) else: result.append(char) return \'\'.join(result) def decode(self, message: str, shift: int) -> str: return self.encode(message, -shift) # Example Usage: # cipher = CaesarCipher() # encoded_message = cipher.encode(\\"hello\\", 3) # decoded_message = cipher.decode(encoded_message, 3) # print(f\\"Encoded: {encoded_message}, Decoded: {decoded_message}\\") ``` The `CaesarCipher` class provides methods to encode and decode messages using a specified shift value. It only modifies alphabetical characters while preserving spaces. The `encode` method shifts characters forward by the specified shift value, and the `decode` method shifts characters back by the same amount.","solution":"class CaesarCipher: def __init__(self) -> None: self.alphabet = \'abcdefghijklmnopqrstuvwxyz\' def encode(self, message: str, shift: int) -> str: result = [] for char in message: if char.isalpha(): is_upper = char.isupper() base = \'A\' if is_upper else \'a\' shifted_char = chr((ord(char) - ord(base) + shift) % 26 + ord(base)) result.append(shifted_char) else: result.append(char) return \'\'.join(result) def decode(self, message: str, shift: int) -> str: return self.encode(message, -shift) # Example Usage: # cipher = CaesarCipher() # encoded_message = cipher.encode(\\"hello\\", 3) # decoded_message = cipher.decode(encoded_message, 3) # print(f\\"Encoded: {encoded_message}, Decoded: {decoded_message}\\")"},{"question":"# Coding Assessment Question **Context**: You are working on a software application that requires customized data processing for a logistical company. The company needs to organize and manage parcels they ship and receive, keeping track of various attributes of each parcel. # Task Your task is to implement a data structure that effectively stores parcel information and supports specific operations as requested by the logistics team. **Specifications**: 1. Implement the class `ParcelManager` with the following methods: - `add_parcel(parcel_id, destination, weight, priority)`: * Parameters: - `parcel_id`: Unique identifier for the parcel (integer). - `destination`: Destination city for the parcel (string). - `weight`: Weight of the parcel in kilograms (float). - `priority`: Priority level for shipping (integer from 1 to 3, where 1 is highest priority). - `remove_parcel(parcel_id)`: * Parameters: - `parcel_id`: Unique identifier for the parcel to be removed (integer). - `get_heaviest_parcel()`: * Returns: A tuple `(parcel_id, destination, weight, priority)` of the heaviest parcel. - `get_highest_priority_parcel()`: * Returns: A tuple `(parcel_id, destination, weight, priority)` of the highest priority parcel. If multiple parcels have the same priority, return the heaviest one among them. **Example**: ```python # Example usage pm = ParcelManager() pm.add_parcel(101, \\"New York\\", 10.5, 2) pm.add_parcel(102, \\"Los Angeles\\", 8.0, 1) pm.add_parcel(103, \\"Chicago\\", 12.2, 3) print(pm.get_heaviest_parcel()) # Expected output: (103, \\"Chicago\\", 12.2, 3) print(pm.get_highest_priority_parcel()) # Expected output: (102, \\"Los Angeles\\", 8.0, 1) pm.remove_parcel(102) print(pm.get_highest_priority_parcel()) # Expected output: (101, \\"New York\\", 10.5, 2) ``` **Notes**: - You may assume that parcel IDs are unique. - When a parcel is removed, subsequent method calls should no longer consider it. - Edge cases like trying to retrieve data from an empty ParcelManager should be managed gracefully.","solution":"class ParcelManager: def __init__(self): self.parcels = {} def add_parcel(self, parcel_id, destination, weight, priority): self.parcels[parcel_id] = { \'destination\': destination, \'weight\': weight, \'priority\': priority } def remove_parcel(self, parcel_id): if parcel_id in self.parcels: del self.parcels[parcel_id] def get_heaviest_parcel(self): if not self.parcels: return None heaviest_parcel = max(self.parcels.items(), key=lambda item: item[1][\'weight\']) return (heaviest_parcel[0], heaviest_parcel[1][\'destination\'], heaviest_parcel[1][\'weight\'], heaviest_parcel[1][\'priority\']) def get_highest_priority_parcel(self): if not self.parcels: return None prioritized_parcel = max( self.parcels.items(), key=lambda item: (-item[1][\'priority\'], item[1][\'weight\']) ) return (prioritized_parcel[0], prioritized_parcel[1][\'destination\'], prioritized_parcel[1][\'weight\'], prioritized_parcel[1][\'priority\'])"},{"question":"# Context: You are tasked with developing an ebook management system. One of the features is to allow users to search and retrieve specific passages from a large collection of ebook texts. # Task: Implement a function `find_passages_with_keywords` that searches for all passages containing a specified set of keywords in a book. # Requirements: Input: - `text`: A large string of text representing the entire content of an ebook. - `keywords`: A list of strings, where each string is a keyword to search for. Output: - A list of strings where each string is a passage containing all specified keywords. A passage is defined as a segment of text ending with a period, exclamation mark, or question mark. Constraints: - The text may contain up to (10^6) characters. - The number of keywords will not exceed 100. - Each keyword is a sequence of alphanumeric characters and has a length between 1 and 20. - The search should be case-insensitive. Example: ```python text = \\"This is an example ebook. It contains various passages. Some passages contain important keywords. Search for these keywords in the relevant passages.\\" keywords = [\\"keywords\\", \\"passages\\"] find_passages_with_keywords(text, keywords) # Output: [\\"Some passages contain important keywords.\\"] ``` # Explanation: The function should return passages that include all keywords specified. In this example, only one passage contains both keywords \\"keywords\\" and \\"passages\\". # Note: - Ensure the function performs efficiently even with the maximum constraints. - Account for different punctuation and cases when searching for keywords. - Test the function with varied placement of keywords to ensure robustness.","solution":"def find_passages_with_keywords(text, keywords): import re # Convert text to lowercase for case-insensitive search text = text.lower() # Convert keywords to lowercase keywords = [keyword.lower() for keyword in keywords] # Split the text into passages using regex to consider ., !, or ? as delimiters passages = re.split(r\'(?<=[.!?])s+\', text) # Function to check if a passage contains all keywords def contains_all_keywords(passage): return all(keyword in passage for keyword in keywords) # Filter passages to include only those which contain all keywords result = [passage for passage in passages if contains_all_keywords(passage)] return result"},{"question":"# Temperature Conversion Utility Problem Description You are required to implement a utility that handles temperature conversions between Celsius, Fahrenheit, and Kelvin. The relationships between these temperature scales are given by the following formulas: - ( text{Celsius to Fahrenheit: } F = C times frac{9}{5} + 32 ) - ( text{Fahrenheit to Celsius: } C = (F - 32) times frac{5}{9} ) - ( text{Celsius to Kelvin: } K = C + 273.15 ) - ( text{Kelvin to Celsius: } C = K - 273.15 ) Task Requirements Implement the function `convert_temperature(value: float, from_scale: str, to_scale: str) -> float` that takes: - `value`: a float representing the temperature. - `from_scale`: a string representing the current scale of the temperature (\'C\' for Celsius, \'F\' for Fahrenheit, \'K\' for Kelvin). - `to_scale`: a string representing the desired scale of the temperature (\'C\' for Celsius, \'F\' for Fahrenheit, \'K\' for Kelvin). The function must convert the temperature from the specified `from_scale` to the specified `to_scale` and return the converted temperature value as a float. Input and Output - **Input**: A float value representing temperature, a string for the current scale, and a string for the target scale. Both scales are one of \'C\', \'F\', or \'K\'. - **Output**: A float value representing the converted temperature in the target scale. Constraints - Only valid scale strings \'C\', \'F\', \'K\' are accepted. If an invalid scale is given, raise a `ValueError` with the message: - `\\"Invalid scale: only \'C\', \'F\', \'K\' are allowed\\"` - Temperatures in Kelvin must not be negative. If a negative Kelvin value is given, raise a `ValueError` with the message: - `\\"Temperature in Kelvin cannot be negative\\"` Example ```python >>> convert_temperature(100, \'C\', \'F\') 212.0 >>> convert_temperature(32, \'F\', \'C\') 0.0 >>> convert_temperature(300, \'K\', \'C\') 26.850000000000023 >>> convert_temperature(0, \'C\', \'K\') 273.15 ```","solution":"def convert_temperature(value, from_scale, to_scale): if from_scale not in (\'C\', \'F\', \'K\'): raise ValueError(\\"Invalid scale: only \'C\', \'F\', \'K\' are allowed\\") if to_scale not in (\'C\', \'F\', \'K\'): raise ValueError(\\"Invalid scale: only \'C\', \'F\', \'K\' are allowed\\") if from_scale == \'K\' and value < 0: raise ValueError(\\"Temperature in Kelvin cannot be negative\\") # Convert from `from_scale` to Celsius if from_scale == \'C\': celsius = value elif from_scale == \'F\': celsius = (value - 32) * 5.0 / 9.0 elif from_scale == \'K\': celsius = value - 273.15 # Convert from Celsius to `to_scale` if to_scale == \'C\': return celsius elif to_scale == \'F\': return celsius * 9.0 / 5.0 + 32 elif to_scale == \'K\': return celsius + 273.15"},{"question":"# Question: Calculate the Maximum Subarray Sum Modulo (m) Background Given an array of positive integers, the maximum subarray sum modulo (m) problem requires you to find the maximum possible value of the sum of any subarray, modulo (m). A subarray is a contiguous part of an array. For example, consider the array ([3, 3, 9, 9, 5]) and (m = 7): - Subarray ([3, 3]) has sum (6), and (6%7 = 6) - Subarray ([9, 9]) has sum (18), and (18%7 = 4) - The maximum subarray sum modulo (7) is (6). Task Write a function that computes the maximum subarray sum modulo (m). Function Signature ```python def max_subarray_sum_modulo(arr: List[int], m: int) -> int: Args: arr (List[int]): A list of integers representing the array. m (int): A positive integer representing the modulus value. Returns: int: The maximum subarray sum modulo m. ``` Constraints * (1 leq text{len(arr)} leq 100000) * (1 leq text{arr[i]} leq 10^9) * (1 leq m leq 10^9) Input * `arr`: A list of positive integers. * `m`: A positive integer representing the modulus value. Output An integer representing the maximum subarray sum modulo (m). Example ```python assert max_subarray_sum_modulo([3, 3, 9, 9, 5], 7) == 6 assert max_subarray_sum_modulo([1, 2, 3], 2) == 1 assert max_subarray_sum_modulo([10, 20, 30, 40], 15) == 10 ``` Edge Cases to Consider 1. Single element arrays. 2. Very large arrays and modulus values. 3. Handling possible overflows or large numbers efficiently. Your task is to implement the `max_subarray_sum_modulo` function to solve the problem efficiently and correctly.","solution":"def max_subarray_sum_modulo(arr, m): import bisect # This will hold the sum of all prefixes prefix_sums = [] current_sum = 0 max_mod_sum = 0 for number in arr: current_sum = (current_sum + number) % m max_mod_sum = max(max_mod_sum, current_sum) # Find the place where current_sum would fit in prefix_sums pos = bisect.bisect_right(prefix_sums, current_sum) if pos < len(prefix_sums): mod_sum = (current_sum - prefix_sums[pos] + m) % m max_mod_sum = max(max_mod_sum, mod_sum) bisect.insort(prefix_sums, current_sum) return max_mod_sum"},{"question":"# Question: Design a Class for a Simple Expression Evaluator Background Implementing a basic expression evaluator involves parsing a string and computing its arithmetic results based on operators and precedence rules. Task Design a class `SimpleEvaluator` that can evaluate arithmetic expressions containing the operators `+`, `-`, `*`, `/` and parentheses `(`, `)`. The class should handle standard precedence rules and evaluate the expression correctly. Function Signature ```python class SimpleEvaluator: def evaluate(self, expression: str) -> float: pass ``` Expected Input and Output 1. **Input**: * A string representing an arithmetic expression. 2. **Output**: * A float representing the evaluated result of the arithmetic expression. Constraints * The input expression will only contain non-negative numbers and the operators `+`, `-`, `*`, `/`. * Parentheses will be used only to indicate desired precedence and will be properly matched. * Division by zero should be handled gracefully, returning `\\"Error: Division by zero\\"`. * The input string will be a valid arithmetic expression. Example 1. **Input**: ```python expr = \\"3 + 5 * 2\\" evaluator = SimpleEvaluator() result = evaluator.evaluate(expr) ``` **Output**: ```python 13.0 ``` 2. **Input**: ```python expr = \\"(1 + 2) * 3 - 4 / 2\\" evaluator = SimpleEvaluator() result = evaluator.evaluate(expr) ``` **Output**: ```python 7.0 ``` 3. **Input**: ```python expr = \\"10 / (5 - 5)\\" evaluator = SimpleEvaluator() result = evaluator.evaluate(expr) ``` **Output**: ```python \\"Error: Division by zero\\" ``` Notes * Implement the standard operator precedence where `*` and `/` have higher precedence than `+` and `-`. * Use parentheses to override the default precedence. * Ensure the parsing and evaluation handle nested parentheses correctly. * Provide thorough unit testing to validate the evaluation under various conditions including edge cases like empty parentheses or expressions with no operators. Good luck!","solution":"class SimpleEvaluator: def evaluate(self, expression: str) -> float: try: # helper function to handle calculation def calc(op, second, first): if op == \'+\': return first + second elif op == \'-\': return first - second elif op == \'*\': return first * second elif op == \'/\': if second == 0: raise ZeroDivisionError(\\"division by zero\\") return first / second def precedence(op): if op in (\'+\', \'-\'): return 1 if op in (\'*\', \'/\'): return 2 return 0 # function to process operators and numbers using two stack method def apply_ops(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(calc(operator, right, left)) operators = [] values = [] i = 0 while i < len(expression): if expression[i] == \' \': i += 1 continue if expression[i] == \'(\': operators.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and (expression[i].isdigit() or expression[i] == \'.\'): if expression[i] == \'.\': i += 1 factor = 0.1 while i < len(expression) and expression[i].isdigit(): val += factor * int(expression[i]) factor /= 10 i += 1 else: val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == \')\': while len(operators) != 0 and operators[-1] != \'(\': apply_ops(operators, values) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(expression[i])): apply_ops(operators, values) operators.append(expression[i]) i += 1 while len(operators) != 0: apply_ops(operators, values) return values[-1] except ZeroDivisionError: return \\"Error: Division by zero\\""},{"question":"# Sort and Remove Duplicates Given a list of strings, write a function that sorts the list in lexicographical order and removes any duplicate strings. The function should return the sorted list without duplicates. Function Signature: ```python def sort_and_unique(strings: list[str]) -> list[str]: pass ``` Input * `strings` (List[str]): A list of strings (0 <= len(strings) <= 1000), each having a max length of 100 characters. Output * A list of strings, sorted in lexicographical order and without duplicates. Constraints 1. The result should be a list of unique strings. 2. The strings should be sorted in lexicographical order. Example ```python # Example 1 assert sort_and_unique([\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"]) == [\\"apple\\", \\"banana\\", \\"cherry\\"] # Example 2 assert sort_and_unique([\\"dog\\", \\"cat\\", \\"elephant\\", \\"dog\\", \\"bat\\", \\"cat\\"]) == [\\"bat\\", \\"cat\\", \\"dog\\", \\"elephant\\"] # Example 3 assert sort_and_unique([]) == [] # Example 4 assert sort_and_unique([\\"a\\", \\"A\\", \\"a\\"]) == [\\"A\\", \\"a\\"] ``` # Explanation: * For the input sequence `[\\"apple\\", \\"banana\\", \\"apple\\", \\"cherry\\"]`, removing duplicates and sorting results in `[\\"apple\\", \\"banana\\", \\"cherry\\"]`. * For the input sequence `[\\"dog\\", \\"cat\\", \\"elephant\\", \\"dog\\", \\"bat\\", \\"cat\\"]`, removing duplicates and sorting results in `[\\"bat\\", \\"cat\\", \\"dog\\", \\"elephant\\"]`. Implementation Steps 1. Convert the list of strings to a set to remove duplicates. 2. Convert the set back to a list and sort it in lexicographical order. 3. Return the sorted list of unique strings.","solution":"def sort_and_unique(strings: list[str]) -> list[str]: This function takes a list of strings, removes duplicates and returns a sorted list of unique strings. unique_strings = list(set(strings)) unique_strings.sort() return unique_strings"},{"question":"# Matrix Rotation with Boundary Constraints Update Context You are tasked with creating a utility for rotating submatrices within a larger matrix. This utility will help in various data manipulation scenarios where specific regions of a matrix need to be processed separately. Task Write a function that rotates a specified submatrix (given by its top-left and bottom-right coordinates) within a larger n x n matrix by 90 degrees clockwise. The submatrix and matrix are both represented as 2D arrays. Function Signature ```python def rotate_submatrix( matrix: list[list[int]], top_left: tuple[int, int], bottom_right: tuple[int, int] ) -> list[list[int]]: ... ``` Input - `matrix` (list of list of int): The n x n matrix containing integers. - `top_left` (tuple of two int): Coordinates of the top-left corner of the submatrix as (row, col). - `bottom_right` (tuple of two int): Coordinates of the bottom-right corner of the submatrix as (row, col). Output - The function should return the modified n x n matrix after rotating the specified submatrix. Constraints - Assume the coordinates are valid and the submatrix falls within the bounds of the larger matrix. - The submatrix to be rotated is at least a 2x2 matrix. - The original matrix and all values are integers. Example ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] top_left = (1, 1) bottom_right = (2, 2) modified_matrix = rotate_submatrix(matrix, top_left, bottom_right) ``` After the function call, `modified_matrix` would be: ```python [ [1, 2, 3, 4], [5, 10, 6, 8], [9, 11, 7, 12], [13, 14, 15, 16] ] ``` The submatrix: ``` 6 7 10 11 ``` is rotated to: ``` 10 6 11 7 ```","solution":"def rotate_submatrix(matrix, top_left, bottom_right): Rotates the submatrix defined by top_left and bottom_right coordinates by 90 degrees clockwise. :param matrix: List of lists representing the n x n matrix. :param top_left: Tuple[int, int] representing the top left coordinates of the submatrix. :param bottom_right: Tuple[int, int] representing the bottom right coordinates of the submatrix. :return: The modified n x n matrix after rotating the specified submatrix. r1, c1 = top_left r2, c2 = bottom_right # Extract the submatrix submatrix = [row[c1:c2+1] for row in matrix[r1:r2+1]] # Transpose and reverse rows to achieve 90 degree rotation rotated_submatrix = [list(row) for row in zip(*submatrix[::-1])] # Place the rotated submatrix back into the original matrix for i in range(len(rotated_submatrix)): matrix[r1 + i][c1:c2+1] = rotated_submatrix[i] return matrix"},{"question":"# Problem Statement Implement a function that receives a list of possibly nested dictionaries and flattens it into a single level dictionary. The keys of the flattened dictionary should be created by concatenating the nested keys, separated by dots. # Function Signature ```python def flatten_dict(data: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: ``` # Functionality Description - The function should accept the following parameters: * `data` (dict): A dictionary that may contain nested dictionaries. * `parent_key` (str): A string used to track the concatenation of keys in the recursive calls, initially an empty string. * `sep` (str): A separator string, defaulting to a dot (\'.\'), used to join the keys. - The function should return a new dictionary where the nested keys are concatenated into a single level, separated by the specified separator. # Constraints 1. The `data` parameter must be a dictionary. 2. The `sep` parameter must be a string of length 1. # Error Handling 1. Raise a `ValueError` if `data` is not a dictionary. 2. Raise a `ValueError` if `sep` is not a string of length 1. # Performance Requirements - Your function should be able to handle dictionaries with a deep nesting of up to 1000 levels efficiently. # Example Usage ```python >>> flatten_dict({\'a\': 1, \'b\': {\'c\': 2, \'d\': {\'e\': 3}}}) {\'a\': 1, \'b.c\': 2, \'b.d.e\': 3} >>> flatten_dict({\'a\': {\'b\': {\'c\': {\'d\': 1}}}}) {\'a.b.c.d\': 1} >>> flatten_dict({\'a\': 1, \'b\': {\'c\': 2, \'d\': {\'e\': 3}}}, sep=\'_\') {\'a\': 1, \'b_c\': 2, \'b_d_e\': 3} >>> flatten_dict(\'not a dict\') Traceback (most recent call last): ... ValueError: Expected dictionary as input, found <class \'str\'> >>> flatten_dict({\'a\': 1}, sep=\'**\') Traceback (most recent call last): ... ValueError: Separator must be a single character string. ``` In addition, ensure that the function raises appropriate exceptions on incorrect argument types and values.","solution":"def flatten_dict(data: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: if not isinstance(data, dict): raise ValueError(f\\"Expected dictionary as input, found {type(data).__name__}\\") if not isinstance(sep, str) or len(sep) != 1: raise ValueError(\\"Separator must be a single character string.\\") def _flatten_dict_inner(d, parent_key, sep): items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(_flatten_dict_inner(v, new_key, sep).items()) else: items.append((new_key, v)) return dict(items) return _flatten_dict_inner(data, parent_key, sep)"},{"question":"# Problem: Optimized Sorting of Custom Objects Context: In your software project, you need to handle and organize a list of custom objects effectively. Each object represents a task with specific attributes, and sorting these tasks becomes crucial for prioritized execution. Your task is to implement a solution that sorts these tasks based on multiple criteria. Task: 1. Implement a function that takes a list of Task objects and returns a sorted list according to the specified criteria. 2. Each Task object has attributes: `priority`, `completion_time`, and `name`. 3. The sorting criteria are as follows: - Primary sorting by `priority` in descending order. - Secondary sorting by `completion_time` in ascending order. - If both `priority` and `completion_time` are identical, sort by `name` in ascending order. Requirements: * The function should efficiently sort the tasks to ensure quick access during operations. * Properly handle cases where task attributes are not correctly assigned. Function Signature: ```python class Task: def __init__(self, name: str, priority: int, completion_time: int): self.name = name self.priority = priority self.completion_time = completion_time def sort_tasks(tasks: List[Task]) -> List[Task]: pass ``` Input: * `tasks` - A list of `Task` objects. Output: * A sorted list of `Task` objects based on the specified criteria. Constraints: * The maximum number of `Task` objects in the list does not exceed 1000. * Task attributes follow these constraints: - `priority` is an integer in the range (1, 10). - `completion_time` is a non-negative integer (0 ≤ completion_time ≤ 1000). - `name` is a string of lowercase English letters with length not exceeding 50. Examples: 1. Given the following task list: ```python tasks = [ Task(\\"task1\\", 2, 100), Task(\\"task2\\", 1, 200), Task(\\"task3\\", 2, 50), Task(\\"task4\\", 3, 150) ] ``` The result should be: ```python [ Task(\\"task4\\", 3, 150), Task(\\"task3\\", 2, 50), Task(\\"task1\\", 2, 100), Task(\\"task2\\", 1, 200) ] ``` 2. Given the following task list with identical priorities and completion times: ```python tasks = [ Task(\\"taskA\\", 1, 100), Task(\\"taskB\\", 1, 100), Task(\\"taskC\\", 1, 100) ] ``` The result should be: ```python [ Task(\\"taskA\\", 1, 100), Task(\\"taskB\\", 1, 100), Task(\\"taskC\\", 1, 100) ] ```","solution":"class Task: def __init__(self, name: str, priority: int, completion_time: int): self.name = name self.priority = priority self.completion_time = completion_time def sort_tasks(tasks): Sorts tasks based on multiple criteria: - Primary sorting by `priority` in descending order. - Secondary sorting by `completion_time` in ascending order. - If both `priority` and `completion_time` are identical, sort by `name` in ascending order. sorted_tasks = sorted(tasks, key=lambda task: (-task.priority, task.completion_time, task.name)) return sorted_tasks"},{"question":"# Coding Assessment Question: Optimizing Memory Allocation with Buddy System **Scenario**: You are developing a memory management module for an operating system, specifically focusing on the Buddy System for dynamic memory allocation. The Buddy System splits memory into partitions to reduce fragmentation, allowing blocks of memory to be divided and joined back together as processes request and release memory. **Objective**: You need to implement a `BuddySystemAllocator` class with methods to allocate and deallocate memory blocks based on the Buddy System. You will also write helper functions for splitting and merging memory blocks accordingly. Input: - `total_memory`: An integer representing the total memory size available for allocation. - `min_block_size`: An integer representing the smallest possible block size allowed for allocation. The `BuddySystemAllocator` class will have methods for: - Allocating memory blocks. - Deallocating memory blocks. - Displaying the current status of memory blocks. Output: - For the allocate method: A string indicating success or failure (`\\"Allocated\\"` or `\\"Failed\\"`). - For the deallocate method: A string indicating success or failure (`\\"Deallocated\\"` or `\\"Invalid address\\"`). - For the display method: A list showing the sizes and statuses (allocated or free) of all memory blocks. ```python class BuddySystemAllocator: def __init__(self, total_memory: int, min_block_size: int) -> None: self.total_memory = total_memory self.min_block_size = min_block_size self.memory_blocks = [(total_memory, False)] # (Block size, allocated) def allocate(self, size: int) -> str: Allocates a memory block of at least `size` bytes. Returns \\"Allocated\\" if successful, otherwise \\"Failed\\". # Placeholder: Implement allocation logic using the buddy system here. pass def deallocate(self, address: int) -> str: Deallocates the memory block at the given `address`. Returns \\"Deallocated\\" if successful, otherwise \\"Invalid address\\". # Placeholder: Implement deallocation and merging logic here. pass def display(self) -> list[tuple[int, bool]]: Displays the current status of memory blocks, showing their sizes and allocation statuses. Returns a list of tuples containing block size and allocation status. return self.memory_blocks def _split_block(self, block_size: int) -> None: Helper function to split a block into two buddies of half the original size. # Placeholder: Implement block splitting logic here. pass def _merge_buddies(self) -> None: Helper function to merge free buddy blocks back into larger blocks. # Placeholder: Implement buddy merging logic here. pass # Example usage: if __name__ == \\"__main__\\": allocator = BuddySystemAllocator(total_memory=1024, min_block_size=32) # Initializes 1KB of memory with minimum 32B block size. print(allocator.allocate(256)) # Expected output: \\"Allocated\\" print(allocator.display()) # Expected output: An updated view of memory blocks. print(allocator.allocate(128)) # Expected output: \\"Allocated\\" print(allocator.display()) # Expected output: An updated view of memory blocks. print(allocator.deallocate(256)) # Expected output: \\"Deallocated\\" print(allocator.display()) # Expected output: An updated view of memory blocks. print(allocator.allocate(1024)) # Expected output: \\"Failed\\" ``` Constraints: 1. The `total_memory` is guaranteed to be a power of two. 2. The `min_block_size` will be a power of two and `min_block_size` ≤ `total_memory`. 3. The address used in deallocation is a simplified abstract address representing the block size that was requested initially. Requirements: - Correctly implement `allocate`, `deallocate`, `display`, `_split_block`, and `_merge_buddies` methods based on the Buddy System algorithm. - Ensure that memory allocation and deallocation handle edge cases, like requests larger than available memory or invalid deallocation addresses. - Guarantee efficient memory usage and demonstrate correctness through the provided examples. **Note**: This question assesses your understanding of memory management techniques, specifically the Buddy System, and your ability to implement allocation and deallocation algorithms robustly.","solution":"class BuddySystemAllocator: def __init__(self, total_memory: int, min_block_size: int) -> None: self.total_memory = total_memory self.min_block_size = min_block_size self.memory_blocks = [(total_memory, False)] # (Block size, allocated) self.allocated_blocks = {} def allocate(self, size: int) -> str: # Find the smallest block that can accommodate the requested size for i, (block_size, allocated) in enumerate(self.memory_blocks): if not allocated and block_size >= size: required_size = max(size, self.min_block_size) while block_size > required_size: block_size //= 2 self.memory_blocks[i] = (block_size, False) self.memory_blocks.insert(i + 1, (block_size, False)) self.memory_blocks[i] = (block_size, True) self.allocated_blocks[block_size] = True return \\"Allocated\\" return \\"Failed\\" def deallocate(self, address: int) -> str: if address in self.allocated_blocks: size = address for i, (block_size, allocated) in enumerate(self.memory_blocks): if allocated and block_size == size: self.memory_blocks[i] = (block_size, False) del self.allocated_blocks[address] self._merge_buddies() return \\"Deallocated\\" return \\"Invalid address\\" def display(self) -> list[tuple[int, bool]]: return self.memory_blocks def _split_block(self, block_size: int) -> None: for i, (size, allocated) in enumerate(self.memory_blocks): if not allocated and size == block_size: half_size = block_size // 2 self.memory_blocks[i] = (half_size, False) self.memory_blocks.insert(i + 1, (half_size, False)) break def _merge_buddies(self) -> None: merged = True while merged: merged = False i = 0 while i < len(self.memory_blocks) - 1: current_block_size, current_allocated = self.memory_blocks[i] next_block_size, next_allocated = self.memory_blocks[i + 1] if (not current_allocated and not next_allocated and current_block_size == next_block_size): self.memory_blocks[i] = (current_block_size * 2, False) del self.memory_blocks[i + 1] merged = True else: i += 1"},{"question":"# Coding Assessment Question **Objective:** Implement a function to simulate placing orders for a food delivery service and optimize the delivery sequence based on shortest delivery time. Problem Statement You are working on a back-end system for a food delivery service. The system needs to simulate order placement and optimize the delivery route for the driver to minimize delivery time. Write a function `optimize_delivery` that takes the following inputs: - `orders`: (list) A list of dictionaries, each representing an order with the following keys: - `order_id`: (str) A unique identifier for the order. - `restaurant_location`: (tuple) Coordinates of the restaurant as a tuple `(x, y)`. - `delivery_location`: (tuple) Coordinates of the delivery address as a tuple `(x, y)`. - `current_driver_location`: (tuple) The current coordinates of the delivery driver as a tuple `(x, y)`. The function should return a list of order IDs representing the optimized sequence in which the driver should deliver the orders to achieve the shortest total delivery distance. Constraints - The number of orders will not exceed 50. - All coordinates are integers and can range from -100 to 100. - There will be at least one order in the input list. Expected Input and Output ```python def optimize_delivery( orders: list, current_driver_location: tuple ) -> list: # your implementation here # Example usage: orders = [ {\\"order_id\\": \\"order1\\", \\"restaurant_location\\": (2, 3), \\"delivery_location\\": (5, 5)}, {\\"order_id\\": \\"order2\\", \\"restaurant_location\\": (1, -1), \\"delivery_location\\": (3, 4)}, {\\"order_id\\": \\"order3\\", \\"restaurant_location\\": (4, 4), \\"delivery_location\\": (-1, -1)}, ] current_driver_location = (0, 0) optimized_sequence = optimize_delivery(orders, current_driver_location) ``` * `Input`: * `orders`: A list of orders with details on restaurant and delivery locations. * `current_driver_location`: The current location of the driver. * `Output`: A list of order IDs in the optimized delivery sequence: * `[\\"order1\\", \\"order2\\", \\"order3\\"]` Notes 1. The sequence should minimize the total delivery distance, considering both the restaurant and delivery locations for each order. 2. Assume the driver must first go to the restaurant location to pick up the order and then go to the delivery location. 3. The distance can be calculated using the Manhattan distance formula: `distance = |x2 - x1| + |y2 - y1|`. 4. Handle edge cases where all orders are equidistant or very close to each other. 5. Ensure code readability and provide meaningful comments.","solution":"def optimize_delivery(orders, current_driver_location): This function optimizes delivery route based on shortest distance. Parameters: orders (list): A list of dictionaries, each representing an order with keys: \'order_id\' (str): A unique identifier for the order. \'restaurant_location\' (tuple): Coordinates of the restaurant as a tuple (x, y). \'delivery_location\' (tuple): Coordinates of the delivery address as a tuple (x, y). current_driver_location (tuple): The current coordinates of the delivery driver as a tuple (x, y). Returns: list: A list of order IDs representing the optimized sequence for delivery. from itertools import permutations def manhattan_distance(coord1, coord2): return abs(coord1[0] - coord2[0]) + abs(coord1[1] - coord2[1]) def total_distance(order_sequence, start_location): total_dist = 0 current_location = start_location for order in order_sequence: total_dist += manhattan_distance(current_location, order[\'restaurant_location\']) current_location = order[\'restaurant_location\'] total_dist += manhattan_distance(current_location, order[\'delivery_location\']) current_location = order[\'delivery_location\'] return total_dist min_distance = float(\'inf\') best_sequence = None for perm in permutations(orders): dist = total_distance(perm, current_driver_location) if dist < min_distance: min_distance = dist best_sequence = perm return [order[\'order_id\'] for order in best_sequence]"},{"question":"# Coding Assessment Question Scenario You are working on a file management system that needs a function to organize files into folders based on their extensions. This utility is crucial for maintaining an organized file structure in a large-scale project with numerous files of various types. Task Implement a function `organize_files(files: List[str]) -> Dict[str, List[str]]` following the signature: ```python def organize_files(files: List[str]) -> Dict[str, List[str]]: pass ``` Your implementation should group file names by their extensions. The extension is defined as the substring after the last period (`.`) in the file name. If a file does not have an extension, it should be grouped under the key \\"no_extension\\". Constraints * Each file name in the list `files` will be a non-empty string. * The file names may contain multiple periods. * Grouping should be case-insensitive, but the original case should be preserved in the output. * You may assume that there will be no duplicates in the list of file names. Input/Output Format * **Input**: A list of strings `files`. * **Output**: A dictionary where the keys are extensions (or \\"no_extension\\") and the values are lists of files that belong to those extensions. Edge cases to consider * Files with no extension * Files with multiple periods (`.`) in the name * Case sensitivity in extensions (e.g., `.TXT`, `.txt` should be considered the same) Examples ```python organize_files([\'document.txt\', \'report.pdf\', \'image.jpeg\', \'archive.tar.gz\', \'README\', \'setup.py\']) # -> {\'txt\': [\'document.txt\'], \'pdf\': [\'report.pdf\'], \'jpeg\': [\'image.jpeg\'], \'gz\': [\'archive.tar.gz\'], \'no_extension\': [\'README\'], \'py\': [\'setup.py\']} organize_files([\'a.TXT\', \'b.txt\', \'c.TxT\']) # -> {\'txt\': [\'a.TXT\', \'b.txt\', \'c.TxT\']} organize_files([\'file1\', \'file2.\']) # -> {\'no_extension\': [\'file1\'], \'no_extension\': [\'file2.\']} organize_files([]) # -> {} ``` Implementation Develop your solution considering case insensitivity for extensions and ensuring proper grouping, along with handling edge cases for files without extensions.","solution":"from typing import List, Dict def organize_files(files: List[str]) -> Dict[str, List[str]]: organized_files = {} for file in files: file_parts = file.rsplit(\'.\', 1) if len(file_parts) == 1 or file_parts[1] == \'\': ext = \'no_extension\' else: ext = file_parts[1].lower() if ext not in organized_files: organized_files[ext] = [] organized_files[ext].append(file) return organized_files"},{"question":"# Coding Assessment Question **Context:** You are given an implementation of a Trie (prefix tree) in Python. A Trie supports operations like inserting words, searching for words, and checking whether any word starts with a given prefix. **Task:** **Implement a function, `list_words_with_prefix(trie, prefix)`,**, that retrieves all words stored in the Trie that start with the given `prefix`. The function should return the list of words in lexicographical order. **Input & Output**: - **trie**: An instance of the `Trie` class. - **prefix**: The prefix string to search for (string). **Requirements**: - Implement the function such that it efficiently traverses the Trie and collects the appropriate words. - Ensure that the function handles edge cases like: - The prefix not matching any word in the Trie. - An empty trie. - An empty prefix (which should return all words in the Trie). **Example**: ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def list_words_with_prefix(trie, prefix): # Implement your function here result = [] node = trie.root for char in prefix: if char not in node.children: return result node = node.children[char] def dfs(current_node, current_prefix): if current_node.is_end_of_word: result.append(current_prefix) for char in sorted(current_node.children): dfs(current_node.children[char], current_prefix + char) dfs(node, prefix) return result # Testing the function trie = Trie() words = [\\"apple\\", \\"app\\", \\"application\\", \\"apply\\", \\"apt\\", \\"cat\\", \\"catalog\\", \\"catch\\"] for word in words: trie.insert(word) print(list_words_with_prefix(trie, \\"app\\")) # Output: [\\"app\\", \\"apple\\", \\"application\\", \\"apply\\"] print(list_words_with_prefix(trie, \\"cat\\")) # Output: [\\"cat\\", \\"catalog\\", \\"catch\\"] print(list_words_with_prefix(trie, \\"do\\")) # Output: [] ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix): node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def list_words_with_prefix(trie, prefix): result = [] node = trie.root for char in prefix: if char not in node.children: return result node = node.children[char] def dfs(current_node, current_prefix): if current_node.is_end_of_word: result.append(current_prefix) for char in sorted(current_node.children): dfs(current_node.children[char], current_prefix + char) dfs(node, prefix) return result"},{"question":"New Coding Assessment Question You are required to enhance and optimize a URL shortener service to handle a high volume of requests while minimizing latency and ensuring accuracy in URL management. # Task Create a class `UrlShortener` that: 1. Generates a unique short URL for any given input URL. 2. Stores the mapping of the original URL to the shortened URL. 3. Retrieves the original URL when provided the shortened URL. 4. Ensures thread safety to handle concurrent requests efficiently. 5. Implements an in-memory storage solution for URL mapping. # Constraints - The short URL should be as concise as possible (e.g., 7 characters long). - Your class should handle at least 1 million URLs efficiently. - Use a hash function to generate the unique short URLs. - Prevent collisions effectively. - The solutions should be optimized for both memory usage and retrieval time. # Class Structure ```python class UrlShortener: def __init__(self): Initializes the URL shortener with an empty storage. pass def shorten_url(self, original_url: str) -> str: Generates and returns a unique short URL for the given original URL. :param original_url: Original URL to be shortened. :return: A unique short URL. pass def retrieve_url(self, short_url: str) -> str: Retrieves the original URL corresponding to the given short URL. :param short_url: The shortened URL. :return: The original URL. pass ``` # Additional Information - Implementations should use thread-safe structures or mechanisms to manage concurrent access. - Ensure performance optimizations to handle high-frequency usage effectively. - The in-memory storage can be a dictionary, and you may use libraries such as `hashlib` for URL hashing. # Example ```python url_shortener = UrlShortener() short_url = url_shortener.shorten_url(\\"https://www.example.com\\") print(short_url) original_url = url_shortener.retrieve_url(short_url) print(original_url) ``` *Output*: ``` \\"random_short_url\\" \\"https://www.example.com\\" ``` **Note**: The specific value of `random_short_url` will vary based on the hashing algorithm and implementation. # Implementation Notes - Use `hashlib` or a similar library to create a hash of the original URL. - Ensure that the generated short URL is unique and handle any potential collisions. - Make sure the class can handle concurrent operations without data inconsistencies. By following these guidelines, your solution should be capable of efficiently storing and retrieving URLs with minimal latency and maximum reliability.","solution":"import hashlib import threading class UrlShortener: def __init__(self): Initializes the URL shortener with an empty storage. self.url_mapping = {} self.lock = threading.Lock() def shorten_url(self, original_url: str) -> str: Generates and returns a unique short URL for the given original URL. :param original_url: Original URL to be shortened. :return: A unique short URL. with self.lock: short_url = hashlib.md5(original_url.encode()).hexdigest()[:7] self.url_mapping[short_url] = original_url return short_url def retrieve_url(self, short_url: str) -> str: Retrieves the original URL corresponding to the given short URL. :param short_url: The shortened URL. :return: The original URL. with self.lock: return self.url_mapping.get(short_url)"},{"question":"# Question: Implement a Prefix-to-Infix Expression Converter and Evaluator Background Prefix notation, also known as Polish notation, is a mathematical notation in which operators precede their operands. Given its unambiguous nature, it is widely used in computer science. Conversely, infix notation is the common arithmetic format where operators are placed between operands. Task Your task is to implement and extend the `prefix_to_infix` function by adding the ability to convert a prefix expression to its corresponding infix expression, and subsequently evaluate the infix expression to yield the result. Requirements - The function `prefix_to_infix` must convert a valid prefix expression to an infix expression. - You must write a new function `evaluate_infix` that evaluates the infix expression returned by `prefix_to_infix`. # Function Specifications `prefix_to_infix(expression: str) -> str` - **Input**: `expression` (str) - A string representing a valid prefix expression composed of integers and operators (`+`, `-`, `*`, `/`). - **Output**: Returns the equivalent infix expression as a string. - **Constraints**: - The input string will be a valid prefix expression with space-separated tokens. `evaluate_infix(expression: str) -> float` - **Input**: `expression` (str) - A string representing a valid infix expression composed of integers, operators (`+`, `-`, `*`, `/`), and parentheses to denote precedence. - **Output**: Returns the result of the infix expression as a float. - **Constraints**: - The input string will be a valid infix expression. - Division by zero should be handled. # Example Usage ```python print(prefix_to_infix(\\"+ 5 * 2 3\\")) # \\"(5 + (2 * 3))\\" print(evaluate_infix(\\"(5 + (2 * 3))\\")) # 11.0 print(prefix_to_infix(\\"- * / 15 - 7 + 1 1 3 + 2 + 1 1\\")) # \\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\" print(evaluate_infix(\\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\")) # 5.0 ``` # Notes 1. The `prefix_to_infix` function must properly handle operator precedence using parentheses in the infix expression. 2. The `evaluate_infix` function should ensure division by zero is appropriately managed. 3. Be mindful of performance implications and optimize where possible, especially regarding the evaluation function.","solution":"def prefix_to_infix(expression: str) -> str: def helper(stack): token = stack.pop() if token in \\"+-*/\\": operand1 = helper(stack) operand2 = helper(stack) return f\\"({operand1} {token} {operand2})\\" else: return token tokens = expression.split() stack = tokens[::-1] return helper(stack) def evaluate_infix(expression: str) -> float: try: return eval(expression) except ZeroDivisionError: return float(\'inf\') # Example Usage print(prefix_to_infix(\\"+ 5 * 2 3\\")) # \\"(5 + (2 * 3))\\" print(evaluate_infix(\\"(5 + (2 * 3))\\")) # 11.0 print(prefix_to_infix(\\"- * / 15 - 7 + 1 1 3 + 2 + 1 1\\")) # \\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\" print(evaluate_infix(\\"(((15 / (7 - (1 + 1))) * 3) - (2 + (1 + 1)))\\")) # 5.0"},{"question":"# Coding Assessment Question Given a floor of dimensions `m x n` which contains tiles, each tile can either be clean (represented by `0`) or dirty (represented by `1`), implement a function `min_steps_to_clean(floor: List[List[int]]) -> int` that calculates the minimum number of steps needed to completely clean all dirty tiles. In one step, you can clean a single dirty tile, and any tiles adjacent to it (sharing an edge) will also become clean. Input * `floor`: A 2D list of integers where each entry is either `0` or `1` representing a clean or dirty tile respectively (1 ≤ m, n ≤ 1000). Output * An integer representing the minimum number of steps required to clean all dirty tiles. Constraints * You can only clean tiles directly connected vertically or horizontally to the tile you clean initially. * Cleaning one tile can affect multiple adjacent tiles, so group as many tiles together in each step to minimize the number of steps. Example Input 1: ```python floor = [ [0, 1, 0, 0, 1], [1, 1, 0, 1, 1], [0, 1, 1, 0, 0] ] ``` Output 1: ```python 2 ``` Input 2: ```python floor = [ [1, 0, 0], [0, 1, 1], [0, 1, 0] ] ``` Output 2: ```python 2 ``` Explanation * In the first example, you can clean all connected dirty tiles in one group on the left side of the floor in the first step, then clean the remaining connected tiles on the right side in the second step. * In the second example, you clean the bottom cluster of tiles in one step and the top-left isolated dirty tile in another step. Performance Requirements * Your solution should efficiently handle the input size constraints and be able to process floors with up to 1,000,000 tiles in a reasonable amount of time. Notes * Assume that the input is always valid and contains at least one `1` if there is any dirty tile. * Clearly explain your thought process and code implementation in comments. Use DFS or BFS to group and clean tiles effectively.","solution":"from typing import List def min_steps_to_clean(floor: List[List[int]]) -> int: Returns the minimum number of steps required to clean all dirty tiles in the floor. def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < m and 0 <= ny < n and floor[nx][ny] == 1: floor[nx][ny] = 0 stack.append((nx, ny)) m, n = len(floor), len(floor[0]) steps = 0 for i in range(m): for j in range(n): if floor[i][j] == 1: steps += 1 dfs(i, j) return steps"},{"question":"# String Manipulation: Reverse Words in a String Problem Statement Write a function that takes a string as input and returns the string with the words in reversed order. Words are defined as sequences of non-space characters. The input string contains only alphanumeric characters and spaces. There should be no leading or trailing spaces in the output, and words should be separated by a single space. Function Signature ```python def reverse_words(s: str) -> str: pass ``` Input - A string `s` containing alphanumeric characters and spaces. Output - A string with the words in reversed order. Example ```python # Example 1 reverse_words(\\"hello world\\") -> \\"world hello\\" # Example 2 reverse_words(\\"the sky is blue\\") -> \\"blue is sky the\\" # Example 3 reverse_words(\\" a good example \\") -> \\"example good a\\" # Example 4 reverse_words(\\"python\\") -> \\"python\\" ``` Constraints - The function should handle multiple spaces between words like a single space. - The returned string should not contain leading or trailing spaces. - Try to solve the problem using O(1) additional space (in-place modifications). Additional Information - Assume the input string `s` is always in valid format according to the constraints. - Consider edge cases such as empty strings or strings with only spaces.","solution":"def reverse_words(s: str) -> str: Reverses the words in the input string s. # Step 1: Split the string by spaces to get the words words = s.split() # Step 2: Reverse the list of words reversed_words = words[::-1] # Step 3: Join the reversed words with a single space reversed_string = \' \'.join(reversed_words) return reversed_string"},{"question":"In a software development project, you need to simulate a caching mechanism to optimize data retrieval. The cache follows the Least Recently Used (LRU) policy, which removes the least recently accessed item when the cache reaches its capacity. Implement a class `LRUCache` to manage the cache. # Task Write a Python class `LRUCache` that simulates a cache with the following methods: 1. `__init__(self, capacity: int)`: Initializes the LRU cache with a given capacity. 2. `get(self, key: int) -> int`: Returns the value associated with the key if the key exists in the cache; otherwise, returns -1. 3. `put(self, key: int, value: int) -> None`: Inserts the key-value pair into the cache. If the key is already present, update its value. If the cache exceeds the capacity, evict the least recently used item. # Input * `capacity`: The maximum number of items the cache can hold, given as an integer between 1 and 3000, inclusive. * `key`: An integer key used for accessing values in the cache. * `value`: An integer value associated with the key used in the cache. # Output * The `get` method returns the value if the key is found in the cache; otherwise, it returns -1. * The `put` method does not return a value but modifies the state of the cache accordingly. # Constraints * You must use an efficient solution with both `get` and `put` operations having an average time complexity of O(1). # Examples ```python # Example Usage cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Output: -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Output: -1 (not found) print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ``` # Explanation of Examples 1. **Initialization and Put Operations**: The cache is initialized with a capacity of 2. Inserting the keys 1 and 2 updates the cache state. 2. **Get Operations**: Accessing key 1 will return its value (1), indicating it\'s still in the cache. 3. **Eviction Upon New Entry**: Inserting key 3 evicts key 2 (least recently used), so accessing key 2 returns -1. 4. **Further Evictions and Access**: Inserting key 4 evicts key 1. Accessing keys 1, 3, and 4 returns -1, 3, and 4 respectively. **Note**: The `capacity` value will always be positive, and all `keys` and `values` are guaranteed to be integers.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key not in self.cache: return -1 self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Scenario You are working on a project where you need to analyze specific properties of strings input by the user. The goal is to identify the longest substring within a given string that does not contain any repeating characters. # Problem Statement Write a Python function `longest_unique_substring(s: str) -> int` that takes a string `s` (1 ≤ len(s) ≤ 10^5) as input and returns the length of the longest substring without any repeating characters. # Constraints - The input string `s` consists only of printable ASCII characters. - The algorithm should efficiently handle long strings by making sure to have a time complexity of O(n), where n is the length of the string. # Input - A string `s`. # Output - An integer representing the length of the longest substring without any repeating characters. # Example ```python assert longest_unique_substring(\\"abcabcbb\\") == 3 assert longest_unique_substring(\\"bbbbb\\") == 1 assert longest_unique_substring(\\"pwwkew\\") == 3 assert longest_unique_substring(\\"a\\") == 1 assert longest_unique_substring(\\"\\") == 0 ``` # Performance Requirements - The solution should use an efficient technique such as a sliding window or two-pointer approach to ensure the time complexity is optimal. # Function Signature ```python def longest_unique_substring(s: str) -> int: # Your code here ```","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. n = len(s) if n == 0: return 0 longest = 0 left = 0 char_map = {} for right in range(n): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right longest = max(longest, right - left + 1) return longest"},{"question":"# Problem Statement You are given an integer array `nums` of size `n-1`. The array contains integers from 1 to `n`, where `n` is the size of the array plus one, with one number missing. Your task is to find the missing number in the array. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: pass ``` # Input * `nums`: A list of integers containing `n-1` elements, where each element is unique and within the range from 1 to `n`. # Output * An integer representing the missing number in the range from 1 to `n`. # Constraints * The length of `nums` is `n-1` where `1 <= n <= 10^5`. # Performance Requirements * Your solution should run in O(n) time complexity and use O(1) extra space complexity. # Example ```python >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 4, 6]) 5 >>> find_missing_number([1]) 2 ``` # Notes * The list `nums` will not contain the number `n` and will have all other numbers from 1 to `n-1`. * The output should be the number missing from the array.","solution":"def find_missing_number(nums): Returns the missing number from the array containing integers 1 to n with one missing number. n = len(nums) + 1 total_sum = n * (n + 1) // 2 actual_sum = sum(nums) return total_sum - actual_sum"},{"question":"**Scenario**: You are developing a file management system that allows users to create, delete, and move files within a directory structure. A crucial feature of the system is the ability to determine the most recently accessed file within a directory. You need to implement this feature using a doubly linked list, where each node represents a file and contains information about the file name and the timestamp of the last access. The doubly linked list allows for efficient insertion, deletion, and access operations. **Objective**: Using the `DoublyLinkedList` data structure provided below, implement the `most_recently_accessed` function, which should return the name of the most recently accessed file. # Function Signature ```python def most_recently_accessed(dll: DoublyLinkedList) -> str: pass ``` # Input - A `DoublyLinkedList` where each node contains a `file_name` (string) and a `last_accessed` (timestamp). # Output - The `file_name` (string) of the most recently accessed file. # Constraints - If the list is empty, the function should return `None`. # Example Usage ```python >>> from datetime import datetime >>> dll = DoublyLinkedList() >>> dll.append(\'file1.txt\', datetime(2023, 4, 5, 17, 23)) >>> dll.append(\'file2.txt\', datetime(2023, 4, 6, 18, 15)) >>> dll.append(\'file3.txt\', datetime(2023, 4, 7, 19, 45)) >>> most_recently_accessed(dll) \'file3.txt\' >>> dll.remove(\'file3.txt\') >>> most_recently_accessed(dll) \'file2.txt\' >>> dll.append(\'file4.txt\', datetime(2023, 4, 8, 20, 30)) >>> most_recently_accessed(dll) \'file4.txt\' >>> dll.clear() >>> most_recently_accessed(dll) None ``` # Additional Notes - Ensure the function efficiently handles retrieval of the most recently accessed file using the properties of the doubly linked list. - The function should handle edge cases such as an empty list or multiple files with the same timestamp. - The implementation of other `DoublyLinkedList` methods (`append`, `remove`, `clear`, etc.) is assumed to be correct and available.","solution":"class Node: def __init__(self, file_name, last_accessed): self.file_name = file_name self.last_accessed = last_accessed self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, file_name, last_accessed): new_node = Node(file_name, last_accessed) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove(self, file_name): current = self.head while current: if current.file_name == file_name: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev break current = current.next def clear(self): self.head = self.tail = None def most_recently_accessed(dll: DoublyLinkedList) -> str: if not dll.head: return None current = dll.head most_recent_file = current.file_name most_recent_time = current.last_accessed while current: if current.last_accessed > most_recent_time: most_recent_file = current.file_name most_recent_time = current.last_accessed current = current.next return most_recent_file"},{"question":"# Array Non-Dominant Value **Problem Statement:** You are given a list of integers, and your task is to find the first element that is not the most frequent (non-dominant) in the list. If all elements are equally frequent, return the first element. Write a function `find_non_dominant` which takes a list of integers and returns the first non-dominant value from the list. If the input list is empty, return `None`. **Function Signature:** ```python def find_non_dominant(arr: List[int]) -> int: pass ``` **Input:** - `arr` (List[int]): A list of integers. **Output:** - (int): The first non-dominant value in the list, or `None` if the list is empty. **Constraints:** - The input list will contain integers in the range `-10^6` to `10^6`. - The length of the input list will be in the range `0` to `10^6`. **Examples:** ```python >>> find_non_dominant([3, 1, 2, 2, 3, 3]) 1 >>> find_non_dominant([1, 1, 2, 2, 3]) 3 >>> find_non_dominant([1, 1, 1, 1, 1]) 1 >>> find_non_dominant([2, 2, 2, 3, 3, 4, 4]) 3 >>> find_non_dominant([]) None >>> find_non_dominant([7]) 7 ``` **Technical Notes:** 1. Employ a dictionary or Counter from the `collections` module to track the frequency of each element. 2. Ensure the function returns the first occurrence of a non-dominant element by iterating through the original list. 3. Handling edge cases such as an empty list or a list with equal frequency elements inherently.","solution":"from typing import List from collections import Counter def find_non_dominant(arr: List[int]) -> int: if not arr: return None # Count the frequencies of elements in the list frequency = Counter(arr) # Find the maximum frequency max_freq = max(frequency.values()) # Iterate through the list and return the first element that is not the most frequent for num in arr: if frequency[num] != max_freq: return num return arr[0]"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a feature for a chat application that requires analyzing text messages to extract important details. Specifically, you need to identify and extract dates from user messages, which can help in scheduling and reminders. **Task**: Implement a function `extract_dates` that receives a list of messages and returns a list of dates found within those messages. The dates must be returned in the `YYYY-MM-DD` format. **Function Signature**: ```python def extract_dates(messages: list) -> list: Extracts dates from a list of messages and returns them in the YYYY-MM-DD format. Args: messages (list): List of strings where each string is a user message. Returns: list: List of strings where each string is a date in the format YYYY-MM-DD. ``` **Example**: ```python messages = [ \\"Our meeting is scheduled for 2023-09-14.\\", \\"Can we reschedule the 15th of August, 2022 meeting?\\", \\"Let\'s catch up on 2021-12-01.\\" ] dates = extract_dates(messages) print(dates) # Output: [\'2023-09-14\', \'2022-08-15\', \'2021-12-01\'] ``` **Constraints**: 1. Your function must: - Handle multiple date formats, e.g., `YYYY-MM-DD`, `DDth of Month, YYYY`. - Return dates in the specified `YYYY-MM-DD` format regardless of the input format. - Catch and appropriately handle any format variations and edge cases. 2. Assume the messages can be a mix of date formats and other text. **Performance Boundaries**: - Ensure that your function can efficiently process up to 1000 messages without significant performance degradation. **Additional Notes**: - You can use libraries like `re` (regular expressions) for parsing and extracting dates. - Consider dates appearing in messages in different contexts and structures. - Properly comment and structure your code for readability and maintainability.","solution":"import re from datetime import datetime def extract_dates(messages: list) -> list: Extracts dates from a list of messages and returns them in the YYYY-MM-DD format. Args: messages (list): List of strings where each string is a user message. Returns: list: List of strings where each string is a date in the format YYYY-MM-DD. # List to store extracted dates extracted_dates = [] # Regex patterns for different date formats date_patterns = [ r\'(d{4}-d{2}-d{2})\', # YYYY-MM-DD r\'(d{1,2})(?:st|nd|rd|th)? of (w+), (d{4})\' # DDth of Month, YYYY ] # Month mapping for textual month recognition months = { \'January\': \'01\', \'February\': \'02\', \'March\': \'03\', \'April\': \'04\', \'May\': \'05\', \'June\': \'06\', \'July\': \'07\', \'August\': \'08\', \'September\': \'09\', \'October\': \'10\', \'November\': \'11\', \'December\': \'12\' } # Helper function to convert month name to number def month_to_num(month): return months.get(month, None) for message in messages: for pattern in date_patterns: matches = re.findall(pattern, message) if pattern == date_patterns[0]: # YYYY-MM-DD for match in matches: try: # Validate and append the date datetime.strptime(match, \\"%Y-%m-%d\\") extracted_dates.append(match) except ValueError: # Invalid date string continue elif pattern == date_patterns[1]: # DDth of Month, YYYY for day, month, year in matches: day = int(day) month_num = month_to_num(month) if month_num: date_str = f\\"{year}-{month_num}-{day:02}\\" try: # Validate and append the date datetime.strptime(date_str, \\"%Y-%m-%d\\") extracted_dates.append(date_str) except ValueError: # Invalid date string continue return extracted_dates"},{"question":"# Coding Assessment Question Context You are working as a developer at a company that builds educational software. Your current project involves creating tools for processing and managing lists of student scores. A recent requirement is to calculate the average score, but with a twist. The average should be calculated after removing the highest and lowest scores from the list to avoid outliers affecting the result. Task Write a Python function `average_score` that performs the following operations: 1. Remove the highest and lowest scores from the list. 2. Calculate the average of the remaining scores. 3. If there are fewer than 3 scores in the input list, return 0. Function Signature ```python def average_score(scores: list) -> float: ``` Input * `scores` (a list of integers): A list of student scores. Output * A float representing the average of the remaining scores after removing the highest and lowest score. * Return 0 if the list has fewer than 3 scores. Constraints 1. Each score will be an integer in the range `[0, 100]`. 2. The input list will have at most `1000` scores. Example ```python # Example scores = [90, 80, 70, 60, 50] print(average_score(scores)) # Output: 70.0 scores = [50, 50, 50, 50] print(average_score(scores)) # Output: 50.0 scores = [100] print(average_score(scores)) # Output: 0 scores = [] print(average_score(scores)) # Output: 0 ``` Notes * Ensure you handle any edge cases such as lists with fewer than 3 scores appropriately. * The average should be a float value. * Ensure the function handles duplicate highest or lowest scores correctly.","solution":"def average_score(scores: list) -> float: if len(scores) < 3: return 0.0 scores_sorted = sorted(scores) trimmed_scores = scores_sorted[1:-1] # Remove the lowest and highest scores average = sum(trimmed_scores) / len(trimmed_scores) return average"},{"question":"# Largest Square in a Grid You are given a grid of characters consisting of \'.\' and \'#\'. Your task is to implement a method that finds the size of the largest square that can be formed using \'.\' characters in the grid. Function to Implement Implement a method, `largest_square_in_grid()`, that determines the size of the largest square of \'.\' characters in the given grid. Input - A list of strings, `grid`, where each string represents a row in the grid and each character is either \'.\' or \'#\'. Output - An integer representing the side length of the largest square that can be formed using \'.\' characters. Constraints - `1 <= len(grid) <= 300` (number of rows) - `1 <= len(grid[i]) <= 300` (length of each row) Example ```python grid = [ \\"..\\", \\"..\\", \\"\\", \\"\\" ] # The largest square of \'.\' characters has a side length of 2. result = largest_square_in_grid(grid) print(result) # Output: 2 grid = [ \\".....\\", \\".....\\", \\".....\\", \\".#.\\", \\".#.\\" ] # The largest square of \'.\' characters has a side length of 3. result = largest_square_in_grid(grid) print(result) # Output: 3 grid = [ \\"#\\", \\"#\\", \\"#\\" ] # No square of \'.\' characters can be formed. result = largest_square_in_grid(grid) print(result) # Output: 0 ``` Note - Ensure the function handles edge cases like all rows being the same character or no \'.\' characters present. - Consider using dynamic programming or other efficient techniques due to the potential size of the grid. # Solution Outline - Use a dynamic programming (DP) table to keep track of the largest square that can be formed ending at each cell. - DP[i][j] represents the size of the largest square whose bottom-right corner is at grid[i][j]. - If grid[i][j] is \'.\', then DP[i][j] = min(DP[i-1][j], DP[i][j-1], DP[i-1][j-1]) + 1, otherwise DP[i][j] = 0. - Iterate through the grid to fill the DP table and keep track of the maximum value found in the table.","solution":"def largest_square_in_grid(grid): if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) dp = [[0] * (cols + 1) for _ in range(rows + 1)] max_side = 0 for i in range(1, rows + 1): for j in range(1, cols + 1): if grid[i - 1][j - 1] == \'.\': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"# Coding Question **Find Missing Number in Sequence** Given a list of unique integers ranging from `0` to `n` (inclusive) with exactly one number missing, implement a function that finds and returns the missing number. **Function Signature**: ```python def find_missing_number(nums: List[int]) -> int: Find and return the missing number in a list of unique numbers ranging from 0 to n. Parameters: - nums (List[int]): A list of unique integers from 0 to n with one number missing. Returns: - int: The missing number in the range. Example: >>> find_missing_number([3, 0, 1]) 2 >>> find_missing_number([0, 1]) 2 >>> find_missing_number([9,6,4,2,3,5,7,0,1]) 8 ``` # Constraints * `1 <= len(nums) <= 10^5` * The input list `nums` will contain unique integers ranging from `0` to `n`, where `n` is the length of the list. # Input and Output * **Input**: A list of unique integers `nums` from `0` to `n` with one number missing. * **Output**: An integer that represents the missing number from the range. # Evaluation Criteria * Correctness: The function must accurately identify the missing number in the sequence. * Efficiency: The solution should handle the upper bounds of input size effectively. * Readability: The code should be well-structured and easy to read.","solution":"def find_missing_number(nums): Find and return the missing number in a list of unique numbers ranging from 0 to n. Parameters: - nums (List[int]): A list of unique integers from 0 to n with one number missing. Returns: - int: The missing number in the range. n = len(nums) expected_sum = n * (n + 1) / 2 actual_sum = sum(nums) return int(expected_sum - actual_sum)"},{"question":"# Problem Statement Create a command-line application in Python that simulates a simple to-do list manager. The application should be able to handle multiple users and their to-do lists. The key functionalities should include adding, removing, and listing tasks, as well as marking tasks as completed. Each user should have their own separate list of tasks. # Functional Requirements: 1. **Class Definitions**: - **User**: - Attributes: - `username` (str): The username of the user. - `tasks` (list): A list of tasks for the user. - Methods: - `add_task(task_str: str) -> None`: Adds a task to the user\'s list. - `remove_task(task_str: str) -> None`: Removes a task from the user\'s list. Raise a ValueError if the task does not exist. - `list_tasks() -> list`: Returns a list of all tasks with their completion status. - `complete_task(task_str: str) -> None`: Marks a task as completed. Raise a ValueError if the task does not exist. - Constraints: - Task descriptions are case-sensitive. - **ToDoManager**: - Attributes: - `users` (dict): A dictionary mapping usernames to User objects. - Methods: - `add_user(username: str) -> None`: Adds a new user. Raise a ValueError if the user already exists. - `get_user(username: str) -> User`: Retrieves a user object. Raise a ValueError if the user does not exist. - `list_users() -> list`: Returns a list of all usernames. - `delete_user(username: str) -> None`: Removes a user. Raise a ValueError if the user does not exist. # Implementation Details - Ensure separation of concerns: the `User` class should manage individual user tasks, while the `ToDoManager` class handles multiple users. - Handle all possible edge cases and ensure to manage errors appropriately by raising exceptions where necessary. - Ensure tasks added to users are case-sensitive and unique. - A task should be represented as a dictionary with `description` (str) and `completed` (bool) keys. Here is an initial structure for the classes: ```python class User: def __init__(self, username: str): self.username = username self.tasks = [] def add_task(self, task_str: str) -> None: # Your code here pass def remove_task(self, task_str: str) -> None: # Your code here pass def list_tasks(self) -> list: # Your code here pass def complete_task(self, task_str: str) -> None: # Your code here pass class ToDoManager: def __init__(self): self.users = {} def add_user(self, username: str) -> None: # Your code here pass def get_user(self, username: str) -> User: # Your code here pass def list_users(self) -> list: # Your code here pass def delete_user(self, username: str) -> None: # Your code here pass ``` # Example Usage ```python manager = ToDoManager() manager.add_user(\\"alice\\") alice = manager.get_user(\\"alice\\") alice.add_task(\\"Buy groceries\\") alice.add_task(\\"Read a book\\") alice.complete_task(\\"Buy groceries\\") print(alice.list_tasks()) # Output: [{\'description\': \'Buy groceries\', \'completed\': True}, {\'description\': \'Read a book\', \'completed\': False}] manager.add_user(\\"bob\\") bob = manager.get_user(\\"bob\\") bob.add_task(\\"Go jogging\\") bob.add_task(\\"Write code\\") print(manager.list_users()) # Output: [\'alice\', \'bob\'] print(bob.list_tasks()) # Output: [{\'description\': \'Go jogging\', \'completed\': False}, {\'description\': \'Write code\', \'completed\': False}] manager.delete_user(\\"alice\\") print(manager.list_users()) # Output: [\'bob\'] ``` # Note - You may use Python’s standard library modules if needed. - Ensure that appropriate error handling is implemented to manage invalid inputs or operations.","solution":"class TaskNotFoundError(Exception): pass class UserAlreadyExistsError(Exception): pass class UserNotFoundError(Exception): pass class User: def __init__(self, username: str): self.username = username self.tasks = [] def add_task(self, task_str: str) -> None: self.tasks.append({\'description\': task_str, \'completed\': False}) def remove_task(self, task_str: str) -> None: for task in self.tasks: if task[\'description\'] == task_str: self.tasks.remove(task) return raise TaskNotFoundError(f\\"Task \'{task_str}\' not found\\") def list_tasks(self) -> list: return self.tasks def complete_task(self, task_str: str) -> None: for task in self.tasks: if task[\'description\'] == task_str: task[\'completed\'] = True return raise TaskNotFoundError(f\\"Task \'{task_str}\' not found\\") class ToDoManager: def __init__(self): self.users = {} def add_user(self, username: str) -> None: if username in self.users: raise UserAlreadyExistsError(f\\"User \'{username}\' already exists\\") self.users[username] = User(username) def get_user(self, username: str) -> User: if username not in self.users: raise UserNotFoundError(f\\"User \'{username}\' not found\\") return self.users[username] def list_users(self) -> list: return list(self.users.keys()) def delete_user(self, username: str) -> None: if username not in self.users: raise UserNotFoundError(f\\"User \'{username}\' not found\\") del self.users[username]"},{"question":"# Problem Statement You have been tasked with developing a system to help a bookstore manage its inventory. The bookstore keeps track of the number of copies of each book available in stock. Occasionally, it needs to restock books, sell them to customers, and generate reports on the current inventory. Your task is to implement a class called `BookstoreInventory` that keeps track of the inventory of books by their title. The class should support the following operations: 1. **Add Books**: Add a specified number of copies of a book to the inventory. 2. **Sell Books**: Sell a specified number of copies of a book from the inventory. 3. **Get Inventory**: Retrieve the current inventory of a specific book. 4. **Generate Report**: Generate a report of the entire inventory sorted by book titles in alphabetical order. # Class Definition Implement the class `BookstoreInventory` with the following methods: # `BookstoreInventory` Class Methods ```python class BookstoreInventory: def __init__(self): # Initializes an empty inventory pass def add_books(self, title: str, count: int): # Adds \'count\' number of copies of the book with the title \'title\' to the inventory pass def sell_books(self, title: str, count: int): # Sells \'count\' number of copies of the book with the title \'title\' from the inventory pass def get_inventory(self, title: str) -> int: # Returns the current number of copies of the book with the title \'title\' in the inventory pass def generate_report(self) -> str: # Returns a string representing the inventory report sorted by book titles in alphabetical order, # where each line contains the book title and its count, separated by a colon. # e.g., \\"Book A: 5nBook B: 2nBook C: 10\\" pass ``` # Example Usage ```python inventory = BookstoreInventory() # Adding books inventory.add_books(\\"Harry Potter\\", 10) inventory.add_books(\\"The Hobbit\\", 5) inventory.add_books(\\"1984\\", 8) # Selling books inventory.sell_books(\\"Harry Potter\\", 3) inventory.sell_books(\\"The Hobbit\\", 1) # Getting inventory of a specific book print(inventory.get_inventory(\\"Harry Potter\\")) # Output: 7 # Generate a report of the entire inventory print(inventory.generate_report()) # Output: # 1984: 8 # Harry Potter: 7 # The Hobbit: 4 ``` # Constraints & Considerations - Ensure that the inventory cannot have a negative count for any book. - If an attempt is made to sell more copies than available, sell only the available copies without throwing an error. - Handle books with titles that include spaces, punctuation, and other special characters correctly. - Consider efficiency in terms of both time and space, as the bookstore could have hundreds or thousands of different book titles.","solution":"class BookstoreInventory: def __init__(self): self.inventory = {} def add_books(self, title: str, count: int): if title in self.inventory: self.inventory [title] += count else: self.inventory[title] = count def sell_books(self, title: str, count: int): if title in self.inventory: self.inventory[title] = max(self.inventory[title] - count, 0) def get_inventory(self, title: str) -> int: return self.inventory.get(title, 0) def generate_report(self) -> str: report = [] for title in sorted(self.inventory): report.append(f\\"{title}: {self.inventory[title]}\\") return \\"n\\".join(report)"},{"question":"# Product Inventory Management System You are tasked with developing a product inventory management system for an online store. The system should be capable of adding products, updating stock levels, and generating sales reports. Your task is to implement a class `InventoryManagement` which includes methods to: 1. **Add Product**: Add new products to the inventory with details such as product ID, name, price, and initial stock. 2. **Update Stock**: Update the stock level for a specific product. 3. **Generate Sales Report**: Generate a sales report that summarizes the sales, including total revenue and remaining stock levels for all products. # Requirements 1. Implement the class `InventoryManagement` with the following methods: * **`__init__(self)`**: * Initialize the class with an empty dictionary to store product details. * **`add_product(self, product_id: str, name: str, price: float, stock: int)`**: * Add a new product to the inventory with the given details. * Ensure product ID is unique. * **`update_stock(self, product_id: str, sold: int)`**: * Deduct the sold quantity from the product\'s stock. * Ensure the stock does not go negative. * **`generate_report(self) -> dict`**: * Generate a report containing total revenue and stock level for each product. * The report should be a dictionary where the TOTAL_REVENUE is a key with the total sales revenue as its value and the remaining stock levels are listed for each product. 2. Consider edge cases and error handling, including invalid product IDs and sales that exceed current stock levels. # Constraints * Each product has a unique identifier (product ID). * The price of the product should be a positive value. * The initial stock level and sold quantity should be non-negative integers. # Example Usage ```python inventory = InventoryManagement() # Add products to the inventory inventory.add_product(\\"001\\", \\"Laptop\\", 1500.00, 10) inventory.add_product(\\"002\\", \\"Smartphone\\", 800.00, 20) # Update stock after sales inventory.update_stock(\\"001\\", 2) # Sold 2 laptops inventory.update_stock(\\"002\\", 5) # Sold 5 smartphones # Generate sales report report = inventory.generate_report() print(report) # Expected Output: # {\'TOTAL_REVENUE\': 11000.00, \'001\': {\'name\': \'Laptop\', \'stock\': 8}, \'002\': {\'name\': \'Smartphone\', \'stock\': 15}} ``` # Expected Input & Output * **Input**: * `add_product(\\"001\\", \\"Laptop\\", 1500.00, 10)` -> Adds a laptop to the inventory. * `update_stock(\\"001\\", 2)` -> Updates the stock level of the laptop. * `generate_report()` -> Generates a sales report. * **Output**: Dictionary representing the sales report including total revenue and stock levels. Implement the `InventoryManagement` class as specified and ensure thorough testing for various scenarios.","solution":"class InventoryManagement: def __init__(self): self.products = {} self.total_revenue = 0.0 def add_product(self, product_id: str, name: str, price: float, stock: int): if product_id in self.products: raise ValueError(f\\"Product ID {product_id} already exists.\\") if price <= 0: raise ValueError(\\"Price should be a positive value.\\") if stock < 0: raise ValueError(\\"Initial stock should be a non-negative integer.\\") self.products[product_id] = { \\"name\\": name, \\"price\\": price, \\"stock\\": stock } def update_stock(self, product_id: str, sold: int): if product_id not in self.products: raise ValueError(f\\"Product ID {product_id} does not exist.\\") if sold < 0: raise ValueError(\\"Sold quantity should be a non-negative integer.\\") if self.products[product_id][\'stock\'] < sold: raise ValueError(\\"Sold quantity exceeds the stock level.\\") product = self.products[product_id] product[\'stock\'] -= sold self.total_revenue += product[\'price\'] * sold def generate_report(self) -> dict: report = { \\"TOTAL_REVENUE\\": self.total_revenue } for product_id, details in self.products.items(): report[product_id] = { \\"name\\": details[\\"name\\"], \\"stock\\": details[\\"stock\\"] } return report"},{"question":"# Binary Search Tree Paths Sum # Problem Context You are tasked with creating a function that calculates the sum of all paths from the root to the leaves in a binary search tree (BST). Each path sum is defined as the sum of all node values from the root to a leaf node. You need to implement a function that traverses the tree to compute these path sums and returns the total sum. # Task Implement the `bst_paths_sum` function that takes one parameter: * `root`: A `TreeNode` representing the root of the binary search tree. The `TreeNode` class is defined as follows: ```python class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right ``` Your task is to traverse the tree from the root to each leaf node, compute the sum of each path, and return the total sum of all these paths. # Input and Output * **Input**: - `root`: The root node of the binary search tree. * **Output**: - An integer representing the total sum of all root-to-leaf paths. # Constraints - The tree will have at least one node and no more than 10^5 nodes. - Node values are integers within the range of [-10^4, 10^4]. # Sample Function Signature ```python def bst_paths_sum(root: TreeNode) -> int: ``` # Example Consider the following tree: ``` 1 / 2 3 / 4 5 6 ``` ```python >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> bst_paths_sum(root) 44 # Explanation: The paths are [1, 2, 4], [1, 2, 5], and [1, 3, 6] # Their sums are: 1+2+4=7, 1+2+5=8, and 1+3+6=10 # Total sum = 7+8+10 = 25 ``` # Additional Requirements 1. Efficiently handle the tree traversal to ensure performance is optimal for large trees. 2. Consider edge cases, such as trees with only one node or trees that are highly unbalanced.","solution":"class TreeNode: def __init__(self, val: int = 0, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.val = val self.left = left self.right = right def bst_paths_sum(root: TreeNode) -> int: def dfs(node, current_sum): if not node: return 0 current_sum += node.val if not node.left and not node.right: return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"# Matrix Diagonal Sum **Background**: You are working with square matrices (2D lists) and need to perform various operations on them. One such operation is calculating the sum of the elements along both diagonals of the matrix. **Objective**: Implement the functionality to: 1. Calculate the sum of the main diagonal elements. 2. Calculate the sum of the secondary diagonal elements. 3. Calculate the sum of both diagonals, ensuring not to double count the center element (if it exists in an odd-sized matrix). # Requirements 1. **main_diagonal_sum(matrix)**: This function should return the sum of the main diagonal (from the top left to the bottom right). 2. **secondary_diagonal_sum(matrix)**: This function should return the sum of the secondary diagonal (from the top right to the bottom left). 3. **total_diagonal_sum(matrix)**: This function should return the sum of both diagonals. **Function Signatures**: ```python def main_diagonal_sum(matrix): pass def secondary_diagonal_sum(matrix): pass def total_diagonal_sum(matrix): pass ``` # Input and Output **Main Diagonal Sum** * **Input**: A square matrix `matrix` (2D list of integers). * **Output**: An integer representing the sum of the main diagonal elements. **Secondary Diagonal Sum** * **Input**: A square matrix `matrix` (2D list of integers). * **Output**: An integer representing the sum of the secondary diagonal elements. **Total Diagonal Sum** * **Input**: A square matrix `matrix` (2D list of integers). * **Output**: An integer representing the sum of both diagonals. # Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> main_diagonal_sum(matrix) 15 # because 1 + 5 + 9 = 15 >>> secondary_diagonal_sum(matrix) 15 # because 3 + 5 + 7 = 15 >>> total_diagonal_sum(matrix) 25 # because (1 + 5 + 9) + (3 + 5 + 7) - 5 = 25 ``` Complete the implementation of the three functions to meet these requirements. **Note**: The main diagonal of a square matrix `n x n` consists of the elements `matrix[i][i]` for `i` in the range `0` to `n-1`. The secondary diagonal of a square matrix `n x n` consists of the elements `matrix[i][n-i-1]` for `i` in the range `0` to `n-1`.","solution":"def main_diagonal_sum(matrix): Returns the sum of the main diagonal (from the top left to the bottom right). return sum(matrix[i][i] for i in range(len(matrix))) def secondary_diagonal_sum(matrix): Returns the sum of the secondary diagonal (from the top right to the bottom left). n = len(matrix) return sum(matrix[i][n-i-1] for i in range(n)) def total_diagonal_sum(matrix): Returns the sum of both diagonals, ensuring not to double count the center element if it exists in an odd-sized matrix. main_sum = main_diagonal_sum(matrix) secondary_sum = secondary_diagonal_sum(matrix) # For an odd-sized matrix, subtract the double-counted center element n = len(matrix) if n % 2 == 1: return main_sum + secondary_sum - matrix[n//2][n//2] else: return main_sum + secondary_sum"},{"question":"# Scenario You are given a string consisting of lower-case alphabets and spaces. Your goal is to determine how many words can be formed with the given string, where a word is defined as a contiguous sequence of non-space characters. Pay particular attention to edge cases, such as strings with leading, trailing, or multiple spaces between words. # Problem Statement Write a function `count_words` that takes a single input string and returns the number of words in that string. A word is defined as a sequence of non-space characters separated by one or more spaces. # Input Format A single input string `s`. # Output Format An integer representing the number of words in the input string. # Constraints * The input string\'s length will not exceed 10^6 characters. * The string contains only lower-case alphabets and spaces. # Function Signature ```python def count_words(s: str) -> int: # implementation here ``` # Examples Example 1 **Input**: ```python \\"hello world\\" ``` **Output**: ```python 2 ``` **Explanation**: There are two words, \\"hello\\" and \\"world\\". Example 2 **Input**: ```python \\" multiple spaces here \\" ``` **Output**: ```python 3 ``` **Explanation**: Ignoring leading, trailing, and multiple spaces between, there are three words, \\"multiple\\", \\"spaces\\", and \\"here\\". # Implementation Notes * Consider how to split the string efficiently, without additional spaces affecting the count. * Edge cases like empty strings or strings with only spaces should be handled.","solution":"def count_words(s: str) -> int: Returns the number of words in the input string s, where words are defined as sequences of contiguous non-space characters. if not s.strip(): # If the string is empty or contains only spaces return 0 return len(s.split())"},{"question":"# Question: You have been assigned to develop a feature that calculates the smallest missing positive integer from a given list `nums` of integers. Your task is to implement a function that returns this smallest positive integer that does not occur in the array. Function Signature ```python def first_missing_positive(nums: List[int]) -> int: pass ``` # Input: - A list of integers `nums` (1 ≤ len(nums) ≤ 10^5), where each element `nums[i]` (-10^9 ≤ nums[i] ≤ 10^9). # Output: - An integer representing the smallest missing positive integer. # Constraints: - The list can contain duplicates and negative numbers as well. - The implementation should efficiently handle the provided range and constraints. # Performance Requirements: - The solution should execute within linear time complexity, O(n). # Examples: - `first_missing_positive([3, 4, -1, 1]) -> 2` - `first_missing_positive([1, 2, 0]) -> 3` - `first_missing_positive([7, 8, 9, 11, 12]) -> 1` - `first_missing_positive([-1, -2, -3, -4, 0]) -> 1` # Additional Context: The problem can be approached by using an in-place hash mechanism to mark the presence of numbers within the array. A hint to solve this might involve swapping elements to their correct positions and then identifying the position where the correct number is missing.","solution":"from typing import List def first_missing_positive(nums: List[int]) -> int: Returns the smallest missing positive integer from the list nums. n = len(nums) # First mark all the non-relevant numbers (negative and too large) for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index as a hash key and the sign of the number as a presence detector for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # The first positive index + 1 is our answer for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"# Problem Statement You are tasked with implementing an API client that interacts with a public weather API to retrieve historical weather data. The API provides weather information for a specific location and date. # Task Write a function `fetch_historical_weather` that takes in a city name and a date range (start and end dates in \\"YYYY-MM-DD\\" format). Your function should return a list of weather data for each day within the specified date range, where each day\'s data is represented by a dictionary containing the date, temperature, and weather description. # Input * `city` (str): The name of the city to retrieve weather data for. * `start_date` (str): The start date of the date range in \\"YYYY-MM-DD\\" format. * `end_date` (str): The end date of the date range in \\"YYYY-MM-DD\\" format. # Output * List of dictionaries, where each dictionary contains: * `date` (str): The date in \\"YYYY-MM-DD\\" format. * `temperature` (float): The average temperature of the day. * `description` (str): The weather description of the day. # Constraints * The date range (from `start_date` to `end_date` inclusive) should not exceed 10 days. * Both `start_date` and `end_date` are valid dates in \\"YYYY-MM-DD\\" format. * Handle API rate limits and network errors gracefully. # Performance Requirements * The solution should handle up to 10 days of weather data efficiently. * Properly handle missing or unexpected API responses. # Example Function Signature ```python import requests def fetch_historical_weather(city: str, start_date: str, end_date: str) -> list: weather_data = [] api_key = \'your_api_key\' # Replace with your actual API key base_url = \'http://api.weatherapi.com/v1/history.json\' current_date = start_date while current_date <= end_date: # Form the URL for the current date url = f\'{base_url}?key={api_key}&q={city}&dt={current_date}\' # Fetch and parse the JSON content response = requests.get(url, timeout=10) response.raise_for_status() # Ensure the request succeeded data = response.json() # Extract the weather data if \'forecast\' in data and \'forecastday\' in data[\'forecast\'] and data[\'forecast\'][\'forecastday\']: day_data = data[\'forecast\'][\'forecastday\'][0][\'day\'] date = data[\'forecast\'][\'forecastday\'][0][\'date\'] temperature = day_data[\'avgtemp_c\'] description = day_data[\'condition\'][\'text\'] weather_data.append({\'date\': date, \'temperature\': temperature, \'description\': description}) # Move to the next date current_date = (datetime.datetime.strptime(current_date, \\"%Y-%m-%d\\") + datetime.timedelta(days=1)).strftime(\\"%Y-%m-%d\\") return weather_data ``` # Example Usage ```python weather = fetch_historical_weather(\'London\', \'2023-09-01\', \'2023-09-05\') for day in weather: print(day) ``` **Remember**: Your solution should be able to handle network errors gracefully, and should parse the weather data correctly even if some expected API fields are missing. Please replace the placeholder API key (`your_api_key`) with a valid one to make actual API requests.","solution":"import requests from datetime import datetime, timedelta def fetch_historical_weather(city: str, start_date: str, end_date: str) -> list: weather_data = [] api_key = \'your_api_key\' # Replace with your actual API key base_url = \'https://api.weatherapi.com/v1/history.json\' current_date = start_date while current_date <= end_date: # Form the URL for the current date url = f\'{base_url}?key={api_key}&q={city}&dt={current_date}\' # Fetch and parse the JSON content try: response = requests.get(url, timeout=10) response.raise_for_status() # Ensure the request succeeded data = response.json() except requests.RequestException as e: print(f\\"Network error occurred: {e}\\") break # Exit the loop in case of a network error # Extract the weather data if \'forecast\' in data and \'forecastday\' in data[\'forecast\'] and data[\'forecast\'][\'forecastday\']: day_data = data[\'forecast\'][\'forecastday\'][0][\'day\'] date = data[\'forecast\'][\'forecastday\'][0][\'date\'] temperature = day_data[\'avgtemp_c\'] description = day_data[\'condition\'][\'text\'] weather_data.append({\'date\': date, \'temperature\': temperature, \'description\': description}) # Move to the next date current_date = (datetime.strptime(current_date, \\"%Y-%m-%d\\") + timedelta(days=1)).strftime(\\"%Y-%m-%d\\") return weather_data"},{"question":"# Question You are required to implement a simplified version of an in-memory key-value store that supports basic operations like setting a key-value pair, retrieving a value by key, and deleting an entry by key. Additionally, your implementation should support a transaction feature that allows a set of operations to be committed atomically. # Function Requirements set_key * **Input**: A string `key` and a string `value`. * **Output**: None. Sets the `value` for the given `key`. get_value * **Input**: A string `key`. * **Output**: The value associated with the `key` if it exists, otherwise `None`. delete_key * **Input**: A string `key`. * **Output**: None. Deletes the `key` if it exists. begin_transaction * **Input**: None. * **Output**: None. Starts a new transaction. commit_transaction * **Input**: None. * **Output**: None. Commits all operations performed since the last `begin_transaction` and ends the transaction. rollback_transaction * **Input**: None. * **Output**: None. Rolls back all operations performed since the last `begin_transaction` and ends the transaction. # Constraints * Each key is a string of length at most 256 characters. * Each value is a string of length at most 1024 characters. * Transactions can be nested, and a rollback should undo only the operations performed within the current transaction scope. # Example ```python # Initialize the key-value store kv_store = KeyValueStore() # Set a key-value pair kv_store.set_key(\\"name\\", \\"Alice\\") print(kv_store.get_value(\\"name\\")) # Output: \\"Alice\\" # Start a new transaction kv_store.begin_transaction() # Set a new key-value pair within the transaction kv_store.set_key(\\"name\\", \\"Bob\\") print(kv_store.get_value(\\"name\\")) # Output: \\"Bob\\" # Rollback the transaction kv_store.rollback_transaction() print(kv_store.get_value(\\"name\\")) # Output: \\"Alice\\" # Start another transaction kv_store.begin_transaction() # Delete the key in the transaction kv_store.delete_key(\\"name\\") print(kv_store.get_value(\\"name\\")) # Output: None # Commit the transaction kv_store.commit_transaction() print(kv_store.get_value(\\"name\\")) # Output: None ``` Notes: * Ensure that operations within a transaction do not affect the main data store until the transaction is committed. * Handle scenarios of nested transactions carefully, where a commit or rollback affects only the immediate transaction scope.","solution":"class KeyValueStore: def __init__(self): self.store = {} self.transactions = [] def set_key(self, key, value): if self.transactions: self.transactions[-1][key] = value else: self.store[key] = value def get_value(self, key): if self.transactions: for transaction in reversed(self.transactions): if key in transaction: return transaction[key] return self.store.get(key) def delete_key(self, key): if self.transactions: self.transactions[-1][key] = None elif key in self.store: del self.store[key] def begin_transaction(self): self.transactions.append({}) def commit_transaction(self): if self.transactions: transaction = self.transactions.pop() for key, value in transaction.items(): if value is None: if key in self.store: del self.store[key] else: self.store[key] = value def rollback_transaction(self): if self.transactions: self.transactions.pop()"},{"question":"# Coding Assessment Question Context You are building a utility function to manage a list of products for an online store. Each product has a name, price, and category. Your task is to create a function that can filter and sort these products based on specified criteria. Task Create a function `filter_and_sort_products(products: List[Dict[str, Union[str, float]]], category: Optional[str] = None, min_price: Optional[float] = None, max_price: Optional[float] = None, sort_key: str = \\"price\\", ascending: bool = True) -> List[Dict[str, Union[str, float]]]` which: 1. Filters products based on the specified category, minimum price, and maximum price. 2. Sorts the filtered products based on the specified sort_key, either ascending or descending. Requirements 1. Implement the function `filter_and_sort_products(products: List[Dict[str, Union[str, float]]], category: Optional[str] = None, min_price: Optional[float] = None, max_price: Optional[float] = None, sort_key: str = \\"price\\", ascending: bool = True) -> List[Dict[str, Union[str, float]]]`. 2. The function should return a list of dictionaries, each representing a product. 3. Handle cases where no products match the filter criteria. 4. Validate that the sort_key is a valid attribute of a product (either `\'name\'`, `\'price\'`, or `\'category\'`). Input and Output * **Input**: A list `products` containing dictionaries with the keys `\'name\'`, `\'price\'`, and `\'category\'`. Optional filters like `category`, `min_price`, and `max_price`. The parameter `sort_key` is one of the keys (`\'name\'`, `\'price\'`, or `\'category\'`). A boolean `ascending` that determines the sort order. * **Output**: A filtered and sorted list of products. Constraints * `products` will contain at most 1000 items. * `price` will be a positive float. * `name` and `category` will be non-empty strings. * Assume valid input for filters and sort parameters. Example: ```python products = [ {\\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Smartphone\\", \\"price\\": 499.99, \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Coffee Maker\\", \\"price\\": 24.99, \\"category\\": \\"Home Appliances\\"}, {\\"name\\": \\"Blender\\", \\"price\\": 19.99, \\"category\\": \\"Home Appliances\\"}, ] # Filter products in the category \\"Electronics\\" with a price between 100 and 1000, sorted by name in ascending order filtered_products = filter_and_sort_products(products, category=\\"Electronics\\", min_price=100, max_price=1000, sort_key=\\"name\\", ascending=True) # Expected output [ {\\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"category\\": \\"Electronics\\"}, {\\"name\\": \\"Smartphone\\", \\"price\\": 499.99, \\"category\\": \\"Electronics\\"} ] print(filtered_products) ```","solution":"from typing import List, Dict, Union, Optional def filter_and_sort_products(products: List[Dict[str, Union[str, float]]], category: Optional[str] = None, min_price: Optional[float] = None, max_price: Optional[float] = None, sort_key: str = \\"price\\", ascending: bool = True) -> List[Dict[str, Union[str, float]]]: Filters and sorts the products based on specified criteria. Args: products (List[Dict[str, Union[str, float]]]): List of products. category (Optional[str]): Filter by category. min_price (Optional[float]): Minimum price inclusive. max_price (Optional[float]): Maximum price inclusive. sort_key (str): Key to sort by, one of \'name\', \'price\', or \'category\'. ascending (bool): Whether to sort in ascending order. Returns: List[Dict[str, Union[str, float]]]: Filtered and sorted list of products. # Validate sort_key if sort_key not in {\\"name\\", \\"price\\", \\"category\\"}: raise ValueError(\\"sort_key must be one of \'name\', \'price\', or \'category\'\\") # Filter products based on category, min_price, and max_price filtered_products = [ product for product in products if (category is None or product[\\"category\\"] == category) and (min_price is None or product[\\"price\\"] >= min_price) and (max_price is None or product[\\"price\\"] <= max_price) ] # Sort filtered products based on sort_key and order filtered_products.sort(key=lambda x: x[sort_key], reverse=not ascending) return filtered_products"},{"question":"# Scenario You are a software developer working on a spreadsheet application. Your task is to write a function that validates and reformats user-provided dates into a standard format. # Problem Statement Implement the function `reformat_date(date: str) -> str` that takes a date in the format \\"Day Month Year\\" and returns the date in the format \\"YYYY-MM-DD\\". The function must be able to parse the month written in one of the following abbreviated forms: \\"Jan\\", \\"Feb\\", \\"Mar\\", \\"Apr\\", \\"May\\", \\"Jun\\", \\"Jul\\", \\"Aug\\", \\"Sep\\", \\"Oct\\", \\"Nov\\", \\"Dec\\". # Function Signature ```python def reformat_date(date: str) -> str: pass ``` # Input * `date`: A string in the format \\"Day Month Year\\" where: * `Day` is a one or two-digit number (1-31) * `Month` is a three-letter abbreviation of a month (e.g., \\"Jan\\", \\"Feb\\") * `Year` is a four-digit number (e.g., 2021) # Output * A string representing the reformatted date in the format \\"YYYY-MM-DD\\". # Constraints * The day will be represented as a positive integer without leading zeros. * The input will always contain a valid date with correct combinations of day, month, and year. # Examples ```python >>> reformat_date(\\"4 Jul 2021\\") \\"2021-07-04\\" >>> reformat_date(\\"12 Sep 1995\\") \\"1995-09-12\\" >>> reformat_date(\\"2 Jan 2000\\") \\"2000-01-02\\" ``` # Notes 1. The function should correctly handle leading zeros for days and months in the output format. 2. You may assume the input will always follow the specified pattern of \\"Day Month Year\\". 3. Each month must be correctly converted from its abbreviated form to its two-digit number format (e.g., \\"Jan\\" to \\"01\\", \\"Feb\\" to \\"02\\").","solution":"def reformat_date(date: str) -> str: Reformat a date from \\"Day Month Year\\" to \\"YYYY-MM-DD\\". month_mapping = { \\"Jan\\": \\"01\\", \\"Feb\\": \\"02\\", \\"Mar\\": \\"03\\", \\"Apr\\": \\"04\\", \\"May\\": \\"05\\", \\"Jun\\": \\"06\\", \\"Jul\\": \\"07\\", \\"Aug\\": \\"08\\", \\"Sep\\": \\"09\\", \\"Oct\\": \\"10\\", \\"Nov\\": \\"11\\", \\"Dec\\": \\"12\\" } day, month, year = date.split() day = day.zfill(2) month = month_mapping[month] return f\\"{year}-{month}-{day}\\""},{"question":"# Binary Tree Level Order Traversal Develop an algorithm that performs a level order traversal on a binary tree. Your algorithm should process nodes level by level from top to bottom and return the result as a list of lists where each sublist contains the values of the nodes at that specific level. **Problem**: Given the root of a binary tree, write a function `levelOrderTraversal` that returns the level order traversal of its nodes\' values. Each level of the tree shall be represented as a separate list within the main list. **Function Signature**: ```python def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: ``` **Input**: - `root`: A TreeNode representing the root of the binary tree. `TreeNode` is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` **Output**: - A list of lists, where each sublist contains the values of the nodes at the corresponding level. **Example**: ```python >>> class TreeNode: ... def __init__(self, val=0, left=None, right=None): ... self.val = val ... self.left = left ... self.right = right >>> def build_tree_from_list(lst): ... if not lst: ... return None ... root = TreeNode(lst[0]) ... queue = [root] ... idx = 1 ... while idx < len(lst): ... node = queue.pop(0) ... if lst[idx] is not None: ... node.left = TreeNode(lst[idx]) ... queue.append(node.left) ... if idx + 1 < len(lst) and lst[idx + 1] is not None: ... node.right = TreeNode(lst[idx + 1]) ... queue.append(node.right) ... idx += 2 ... return root >>> tree = build_tree_from_list([3, 9, 20, None, None, 15, 7]) >>> levelOrderTraversal(tree) [[3], [9, 20], [15, 7]] >>> tree = build_tree_from_list([1, 2, 3, 4, 5]) >>> levelOrderTraversal(tree) [[1], [2, 3], [4, 5]] ``` **Constraints**: - The number of nodes in the tree is in the range `[0, 2000]`. - `-1000 <= Node.val <= 1000`. Ensure your function efficiently handles edge cases, such as an empty tree, and properly reflects the hierarchical structure of the binary tree in terms of levels.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] from collections import deque queue = deque([root]) result = [] while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Assessment Question: Context You are developing a navigation application that provides real-time route optimization for delivery drivers. Part of this task requires calculating the shortest path from one location to another within a city. The city is represented as a graph where intersections are nodes and roads are weighted edges based on travel time. Task Implement a function `find_shortest_path(city_map: dict[int, list[tuple[int, int]]], start: int, destination: int) -> list[int]` that finds the shortest path from the `start` intersection to the `destination` intersection using Dijkstra\'s algorithm. Constraints * The graph is represented as an adjacency list `city_map`, where keys are intersection IDs (`int`) and values are lists of tuples (`list[tuple[int, int]]`). Each tuple consists of an adjacent intersection and the travel time to it. * Assume all travel times are non-negative integers. * The total number of intersections is up to (10^4). * If there\'s no path from `start` to `destination`, return an empty list. Input & Output Format * Input: * `city_map` — a dictionary representing the graph of the city. * `start` — an integer representing the starting intersection. * `destination` — an integer representing the destination intersection. * Output: A list of intersection IDs representing the shortest path from `start` to `destination`, inclusive. Examples: * Input: `city_map = {0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: []}, start = 0, destination = 3` * Output: `[0, 2, 1, 3]` * Input: `city_map = {0: [(1, 10)], 1: [(2, 1)], 2: []}, start = 0, destination = 2` * Output: `[0, 1, 2]` * Input: `city_map = {0: [(1, 1)], 1: [(2, 1)], 2: [], 3: [(1, 1)]}, start = 0, destination = 3` * Output: `[]` Performance Requirements * The implementation should handle large graphs efficiently. * Aim for a time complexity of (O(V log V + E)), where (V) is the number of intersections and (E) is the number of roads.","solution":"import heapq def find_shortest_path(city_map, start, destination): Finds the shortest path from the start intersection to the destination intersection using Dijkstra\'s algorithm. Parameters: - city_map : dict[int, list[tuple[int, int]]] : a dictionary representing the graph of the city. - start : int : the starting intersection. - destination : int : the destination intersection. Returns: - list[int] : A list of intersections representing the shortest path from start to destination. # Priority queue for Dijkstra\'s algorithm priority_queue = [(0, start)] # Dict to store the shortest path to each node shortest_path = {start: (0, [])} while priority_queue: current_distance, current_intersection = heapq.heappop(priority_queue) # If we reached the destination if current_intersection == destination: return shortest_path[current_intersection][1] + [destination] for neighbor, travel_time in city_map.get(current_intersection, []): distance = current_distance + travel_time # If a shorter path to the neighbor is found if neighbor not in shortest_path or distance < shortest_path[neighbor][0]: shortest_path[neighbor] = (distance, shortest_path[current_intersection][1] + [current_intersection]) heapq.heappush(priority_queue, (distance, neighbor)) # If there is no path to the destination return []"},{"question":"# Digital Root Calculator A digital root is the recursive sum of all the digits in a number. Given `n`, the digital root is obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute a new sum of digits. The process continues until a single-digit number is achieved. Implement the function `digital_root(n: int) -> int` that calculates the digital root of a given non-negative integer. # Function Signature ```python def digital_root(n: int) -> int: pass ``` # Input * `n`: A non-negative integer for which you need to find the digital root. # Output * Returns the digital root of the given number. # Constraints * The function should raise a `ValueError` if the input number is not an integer. * The function should return `0` if the input number is `0`. * The implementation should handle large values efficiently without recursion depth issues. # Example ```python assert digital_root(0) == 0 assert digital_root(16) == 7 assert digital_root(942) == 6 assert digital_root(132189) == 6 assert digital_root(493193) == 2 assert digital_root(-1) == ValueError(\'n must be a non-negative integer\') assert digital_root(\\"Hello\\") == ValueError(\'n must be an integer\') ``` # Notes 1. You are not allowed to use any imported libraries for this implementation. 2. Pay special attention to handle the edge cases like zero and non-integer types.","solution":"def digital_root(n): if not isinstance(n, int): raise ValueError(\'n must be an integer\') if n < 0: raise ValueError(\'n must be a non-negative integer\') if n == 0: return 0 while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"# Problem Statement Write a function `can_reach_end` to determine if it is possible to reach the last index of a list of non-negative integers, where each integer represents the maximum jump length at that position. Each jump can be at most the value of the integer at that position, and you can only move to the right. The function should return `True` if you can reach the last index and `False` otherwise. # Function Signature ```python def can_reach_end(jump_list: list[int]) -> bool: ``` # Input * `jump_list`: a list of non-negative integers where (1 ≤ len(jump_list) ≤ 10^5) # Output * `True` if you can reach the last index, otherwise `False`. # Constraints * Performance: The solution must run efficiently within the given constraints. * The input list will have at least one element. # Example ```python >>> can_reach_end([2, 3, 1, 1, 4]) True >>> can_reach_end([3, 2, 1, 0, 4]) False ``` # Hints * Maintain a variable to track the furthest position that can be reached. * Iterate through the list and update the furthest reachable position. * If at any index, the current position is greater than the furthest reachable position, return `False`. # Testing * You should test your function with cases where: * The maximum jump length is always sufficient to reach the end. * The values in the list are such that it is not possible to reach the end. * The list length is very large with varying jump lengths. # Edge Cases * The input list has one element. * The input list has very large values or all zeros except the first element, like [0, 0, ..., 0].","solution":"def can_reach_end(jump_list): Determines if you can reach the last index of the given list. :param jump_list: List[int], a list of non-negative integers where each integer represents the maximum jump length at that position. :return: bool, True if you can reach the last index, otherwise False. max_reachable = 0 for i, jump in enumerate(jump_list): if i > max_reachable: return False max_reachable = max(max_reachable, i + jump) return True"},{"question":"# Question: Validate and Format License Plates You are tasked with creating a program that validates and formats vehicle license plates according to specific rules. Your program should include the following functionalities: 1. **Validate a license plate** to ensure it meets the required format. 2. **Format a list of license plates** by ensuring they are in uppercase and have hyphens where appropriate. Functional Requirements: - **Function 1**: `validate_license_plate(plate: str) -> bool` - `plate`: A string representing the license plate to be validated. - Returns `True` if the license plate is valid, otherwise `False`. - A valid license plate: 1. Consists of exactly 7 or 8 characters. 2. Contains only alphanumeric characters (letters A-Z and digits 0-9). 3. Has no special characters or spaces. - **Function 2**: `format_license_plates(plates: list) -> list` - `plates`: A list of strings, each representing a license plate. - Returns a list of formatted license plates where each plate: 1. Is in uppercase. 2. Has hyphens inserted after every 3rd character (for 7 character plates) or after the 4th character followed by a hyphen after every 2 characters (for 8 character plates). Input and Output - **Input**: - The `validate_license_plate` function takes a single license plate string as input. - The `format_license_plates` function takes a list of license plates as input. - **Output**: - `validate_license_plate` returns a boolean indicating if the license plate is valid. - `format_license_plates` returns a list of strings representing the formatted license plates. Constraints: - Your implementation should handle corner cases like mixed case inputs and invalid characters. - Ensure the functions are efficient and handle lists containing up to 1000 license plates. Example ```python valid = validate_license_plate(\\"ABC1234\\") # Expected output: True invalid = validate_license_plate(\\"AB!C123\\") # Expected output: False plates = [\\"abc1234\\", \\"xyz78901\\"] formatted = format_license_plates(plates) # Expected output: [\\"ABC-1234\\", \\"XYZ7-89-01\\"] ``` Write the function implementations for `validate_license_plate(plate: str)` and `format_license_plates(plates: list)`.","solution":"def validate_license_plate(plate: str) -> bool: Validates if a license plate meets the following criteria: - Consists of exactly 7 or 8 characters. - Contains only alphanumeric characters (letters A-Z and digits 0-9). - No special characters or spaces. Args: plate (str): License plate string to be validated. Returns: bool: True if the license plate is valid, False otherwise. if len(plate) not in [7, 8]: return False if not plate.isalnum(): return False return True def format_license_plates(plates: list) -> list: Formats a list of license plates by ensuring they are in uppercase and have appropriate hyphens. Args: plates (list): List of license plate strings. Returns: list: List of formatted license plate strings. formatted_plates = [] for plate in plates: plate = plate.upper() if len(plate) == 7: formatted_plate = f\\"{plate[:3]}-{plate[3:]}\\" elif len(plate) == 8: formatted_plate = f\\"{plate[:4]}-{plate[4:6]}-{plate[6:]}\\" else: formatted_plate = plate # just in case to avoid errors formatted_plates.append(formatted_plate) return formatted_plates"},{"question":"# Context: In image processing and computer graphics, it is often necessary to rotate or reflect an image to achieve the desired orientation. A common task is rotating a **N x N** matrix representation of an image by 90 degrees in a clockwise direction. Given an implementation of this operation, the transformed matrix can be obtained efficiently. # Problem Statement: Write a function `rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]` that takes as input a list of lists representing an **N x N** matrix and returns the matrix rotated by 90 degrees clockwise. The function should also validate the input to ensure it is a square matrix, raising a `ValueError` if the input is not valid. Input and Output Formats: * **Input**: A single argument `matrix` which is a list of lists containing integers. * **Output**: A new list of lists containing the integers of the input matrix rotated by 90 degrees clockwise. Constraints and Limitations: * The matrix provided will contain integers. * The input matrix will be a valid **N x N** matrix where N ≥ 1. Example: ```python >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1]]) [[1]] >>> rotate_matrix_90_clockwise([[1, 2], [3]]) Traceback (most recent call last): ... ValueError: Input must be an N x N matrix ``` # Performance Requirements: * The solution should ideally run in O(N^2) time complexity, where N is the dimension of the matrix. # Additional Context: * You should aim to achieve the transformation in-place if possible, but returning a new matrix in the desired orientation is also acceptable.","solution":"def rotate_matrix_90_clockwise(matrix): if not matrix or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"Input must be an N x N matrix\\") n = len(matrix) # Generate new matrix of same size filled with zeros rotated_matrix = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix"},{"question":"# Coding Assessment Question Scenario You are working on a system that deals with streaming stock prices for various companies. Because of the volume of data, you need to efficiently query the highest and lowest stock prices within certain time windows. Task Write a function that processes a sequence of timestamps and stock prices, and then performs queries to find the maximum and minimum stock prices within specified time intervals. Function Signature ```python def stock_price_operations(operations: List[Tuple[str, Union[int, Tuple[int, int]]]], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Processes a sequence of stock price operations and returns results of queries. :param operations: A list of tuples where each tuple represents an operation. - \\"record\\", (timestamp, price): Records the stock price at the given timestamp. :param queries: A list of tuples representing queries. Each query is a tuple (start_time, end_time) representing the time interval. :return: A list of tuples containing the maximum and minimum stock prices for each query. ``` Constraints 1. Timestamps are integers representing seconds since the epoch and are unique for each stock price. 2. Prices are integer values and may range from negative to positive values. 3. The `operations` list will contain up to (10^5) operations. 4. The `queries` list will contain up to (10^5) queries. Example Given the following operations and queries: ```python operations = [ (\\"record\\", (1, 100)), (\\"record\\", (2, 200)), (\\"record\\", (3, 50)), (\\"record\\", (5, 300)), (\\"record\\", (6, 400)) ] queries = [ (1, 3), (2, 5), (1, 6) ] ``` The function should return: `[(200, 50), (300, 50), (400, 50)]` because: - For query (1, 3), the highest price is 200 and the lowest price is 50. - For query (2, 5), the highest price is 300 and the lowest price is 50. - For query (1, 6), the highest price is 400 and the lowest price is 50.","solution":"from typing import List, Tuple, Union def stock_price_operations(operations: List[Tuple[str, Union[int, Tuple[int, int]]]], queries: List[Tuple[int, int]]) -> List[Tuple[int, int]]: import bisect timestamps = [] prices = [] timestamp_to_price = {} # Process the operations to record the prices for operation in operations: if operation[0] == \\"record\\": timestamp, price = operation[1] timestamps.append(timestamp) prices.append(price) timestamp_to_price[timestamp] = price # Sort the timestamps timestamps.sort() # Prepare the sorted prices based on sorted timestamps sorted_prices = [timestamp_to_price[timestamp] for timestamp in timestamps] # Function to find the max and min in a range def find_max_min(start_time, end_time): # Find the start and end indices start_index = bisect.bisect_left(timestamps, start_time) end_index = bisect.bisect_right(timestamps, end_time) - 1 if start_index <= end_index: relevant_prices = sorted_prices[start_index:end_index+1] return max(relevant_prices), min(relevant_prices) else: return None, None # Process each query to get the result result = [] for query in queries: start_time, end_time = query max_price, min_price = find_max_min(start_time, end_time) if max_price is not None and min_price is not None: result.append((max_price, min_price)) else: result.append((None, None)) return result"},{"question":"# Problem Statement You are given a list of integers representing an amount of cash and a target amount that you want to get by using the least number of bills from the list. Write a function that returns the number of bills needed to reach the target amount using a Dynamic Programming approach. If it is not possible to reach the target amount using the given bills, return -1. # Function Signature ```python def min_bills(bills: List[int], target: int) -> int: pass ``` # Input * `bills`: A list of integers representing the available bill denominations. * `target`: An integer representing the desired target amount. # Output * An integer representing the minimum number of bills needed to reach the target amount, or -1 if the target cannot be reached. # Constraints * All bill denominations are positive integers. * The target amount is a non-negative integer. * It is guaranteed that the length of `bills` is at least 1 and does not exceed 100. * The target amount will not exceed 10,000. # Performance Requirements * Your algorithm should aim for a time complexity of O(N * T) where N is the number of different bill denominations and T is the target amount. # Example ```python bills = [1, 3, 4, 5] target = 7 print(min_bills(bills, target)) # Expected Output: 2, since the bills 3 and 4 add up to 7 ``` # Notes * Ensure to handle cases where the list is empty or the target is zero by returning an appropriate result. * Consider also edge cases where no combination of bills can produce the exact target value.","solution":"from typing import List def min_bills(bills: List[int], target: int) -> int: # Initialize a list to store the minimum number of bills needed for each amount up to target dp = [float(\'inf\')] * (target + 1) dp[0] = 0 # 0 bills are needed to make up the target amount of 0 # Process each amount from 1 to target for amount in range(1, target + 1): for bill in bills: if amount - bill >= 0: dp[amount] = min(dp[amount], dp[amount - bill] + 1) return dp[target] if dp[target] != float(\'inf\') else -1"},{"question":"# Sum of Unique Prime Factors Write a function to calculate the sum of all unique prime factors of a given integer. A prime factor is defined as a prime number that divides a given number exactly, without leaving a remainder. # Function Signature ```python def sum_of_unique_prime_factors(n: int) -> int: pass ``` # Input - `n` (int): The integer for which you need to find the sum of unique prime factors. - Constraints: (2 leq n leq 10^6) # Output - Returns an integer representing the sum of all unique prime factors of `n`. # Examples ```python # Example 1 n = 28 # Prime factors are 2 and 7 # Sum = 2 + 7 = 9 assert sum_of_unique_prime_factors(28) == 9 # Example 2 n = 44 # Prime factors are 2 and 11 # Sum = 2 + 11 = 13 assert sum_of_unique_prime_factors(44) == 13 # Example 3 n = 97 # Prime factor is 97 (since 97 is a prime number) # Sum = 97 assert sum_of_unique_prime_factors(97) == 97 ``` # Implementation Requirements 1. Ensure the function performs efficiently within the input constraints. 2. Consider edge cases such as very large prime numbers and composite numbers with multiple prime factors. 3. A prime number is defined as a number greater than 1 that has no divisors other than 1 and itself. # Notes - You might find it helpful to use the Sieve of Eratosthenes or another algorithm to generate prime numbers up to a certain limit. - Remember to only sum each prime factor once, even if it appears multiple times in the factorization of `n`.","solution":"def sum_of_unique_prime_factors(n: int) -> int: def prime_factors(num): factors = set() # Check for number of 2s in the factorization while num % 2 == 0: factors.add(2) num = num // 2 # Now check for odd factors for i in range(3, int(num**0.5) + 1, 2): while num % i == 0: factors.add(i) num = num // i # This condition is to check if num is a prime # number greater than 2 if num > 2: factors.add(num) return factors return sum(prime_factors(n))"},{"question":"# Fibonacci Twist - Summing Odd Values You have been tasked with writing a function that modifies the Fibonacci sequence. Instead of just generating the sequence, this function will calculate the sum of all odd-valued terms in the Fibonacci sequence up to and including the first term that exceeds a given limit. Objective: Write a function to generate Fibonacci numbers starting from 1, 1 and continue until a term exceeds the specified limit. The function should then compute and return the sum of all odd values in this sequence. # Input Format: A single integer `limit`, which defines the upper bound for generating Fibonacci numbers. # Output Format: An integer representing the sum of all odd-valued Fibonacci numbers that are less than or equal to the given limit. # Constraints: - `limit` is a positive integer (2 <= limit <= 10^6). # Performance Requirements: - The function should efficiently handle large values of `limit`. # Function Signature: ```python def sum_odd_fibonacci(limit: int) -> int: ``` # Example: ```python # Example 1 input: limit = 10 output: 10 Explanation: The Fibonacci sequence up to 10 is [1, 1, 2, 3, 5, 8, 13], and the odd values are [1, 1, 3, 5]. Their sum is 1 + 1 + 3 + 5 = 10. # Example 2 input: limit = 100 output: 188 Explanation: The Fibonacci sequence up to 100 includes [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144], and the odd values are [1, 1, 3, 5, 13, 21, 55, 89]. Their sum is 1 + 1 + 3 + 5 + 13 + 21 + 55 + 89 = 188. ``` # Notes: - You should handle edge cases, such as invalid inputs gracefully, by raising appropriate exceptions. - Ensure the performance of your implementation meets the required constraints. # Challenge: Write the implementation of the `sum_odd_fibonacci` function as per the description above.","solution":"def sum_odd_fibonacci(limit: int) -> int: if limit < 2: raise ValueError(\\"Limit must be at least 2\\") a, b = 1, 1 odd_sum = 0 while a <= limit: if a % 2 != 0: odd_sum += a a, b = b, a + b return odd_sum"},{"question":"# Problem Statement You are required to write a function called `count_unique_pairs` that receives a list of integers and an integer `k`, and returns the number of unique pairs `(i, j)` from the list such that `i < j` and the absolute difference between `list[i]` and `list[j]` is exactly `k`. The function should also handle edge cases and protect against invalid inputs. # Function Signature ```python def count_unique_pairs(nums: List[int], k: int) -> int: ``` # Input - **`nums`** (List[int]): A list of integers. Length of the list `1 <= len(nums) <= 10^5`. - **`k`** (int): An integer representing the absolute difference condition. `0 <= k <= 10^6`. # Output - **int**: The number of unique pairs `(i, j)` satisfying the condition. # Constraints - The input list will contain integers. - The value of `k` will be a non-negative integer. - The solution should work efficiently even for large lengths and values within the provided constraints. # Examples 1. `count_unique_pairs([1, 5, 3, 4, 2], 2)` should return `3`. 2. `count_unique_pairs([1, 2, 3, 4, 5], 1)` should return `4`. 3. `count_unique_pairs([1, 2, 3, 4, 5], 10)` should return `0`. 4. `count_unique_pairs([1, 1, 1, 1, 1], 0)` should return `10`. # Notes - Handle invalid inputs such as non-integer values in the list or in `k` by raising appropriate exceptions (e.g., `TypeError` for non-integer types). - Consider edge cases such as empty lists or lists with a single element. - The function should not count the same pair twice; `(i, j)` should be counted only once where `i < j`. # Tips - Use efficient algorithms to handle large inputs and optimize searching for pairs. - Ensure the function runs within acceptable performance limits for the upper bounds.","solution":"from typing import List def count_unique_pairs(nums: List[int], k: int) -> int: This function counts the number of unique pairs (i, j) in the list such that i < j and the absolute difference between nums[i] and nums[j] is exactly k. if not isinstance(nums, list) or not all(isinstance(x, int) for x in nums): raise TypeError(\\"nums must be a list of integers\\") if not isinstance(k, int): raise TypeError(\\"k must be an integer\\") if k < 0: raise ValueError(\\"k must be a non-negative integer\\") num_set = set(nums) count = 0 if k == 0: # When k is 0, we need to count pairs of identical numbers for num in num_set: occurrences = nums.count(num) if occurrences > 1: count += (occurrences * (occurrences - 1)) // 2 else: # When k is positive, we need to find pairs with difference k for num in num_set: if num + k in num_set: count += 1 return count"},{"question":"# Coding Assessment Question Scenario You are developing a game involving a grid of cells, each of which can be either alive or dead. The game follows a specific set of rules to determine the next state of each cell based on the current state of its neighbors. This is the well-known \\"Game of Life.\\" Task Write a function `game_of_life(grid)` that takes a 2D list of integers as input representing the current state of the game grid, and returns a new 2D list of integers representing the next state of the grid. In the grid, `1` represents a live cell and `0` represents a dead cell. The next state of each cell is determined by the following rules: 1. Any live cell with fewer than two live neighbors dies, as if by underpopulation. 2. Any live cell with two or three live neighbors lives on to the next generation. 3. Any live cell with more than three live neighbors dies, as if by overpopulation. 4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Input * `grid`: A list of lists of integers where each list represents a row in a grid, and each integer is a cell in that row. The cells have values of either `1` (alive) or `0` (dead). Output * A list of lists of integers representing the next state of the grid. Constraints * The grid will always be rectangular. * The grid dimensions will be between 1x1 and 100x100 inclusive. Example Input ```python grid = [ [0, 1, 0], [0, 0, 1], [1, 1, 1], [0, 0, 0] ] ``` Example Output ```python [ [0, 0, 0], [1, 0, 1], [0, 1, 1], [0, 1, 0] ] ``` This output corresponds to the next state of the game based on the rules of the Game of Life. Additional Instructions The function should handle boundary cells properly, ensuring they are updated according to the same rules while considering their neighbors within the grid\'s limits. Hint To verify the correctness of your solution, it might be helpful to create a helper function to count the live neighbors of a cell and another function to update the state of a single cell based on its neighbors.","solution":"def game_of_life(grid): Returns the next state of the Game of Life grid. Parameters: grid (list of list of int): The current state of the game grid. Returns: list of list of int: The next state of the game grid. def count_live_neighbors(x, y): rows = len(grid) cols = len(grid[0]) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] live_neighbors = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1: live_neighbors += 1 return live_neighbors rows = len(grid) cols = len(grid[0]) next_state = [[0] * cols for _ in range(rows)] for i in range(rows): for j in range(cols): live_neighbors = count_live_neighbors(i, j) if grid[i][j] == 1: if live_neighbors < 2 or live_neighbors > 3: next_state[i][j] = 0 else: next_state[i][j] = 1 else: if live_neighbors == 3: next_state[i][j] = 1 return next_state"},{"question":"# Question: Simple Guided Navigation As a software developer, you are tasked with creating a system to move a robot in a 2D grid environment following specific instructions. The robot starts at a given position and moves according to a sequence of direction instructions. You need to implement functions for both determining the final location and calculating the total distance traveled. Function 1: `get_final_position` Implement a function `get_final_position` that takes in the following parameters: * `start_x` (int): x-coordinate of the starting position. * `start_y` (int): y-coordinate of the starting position. * `instructions` (list of tuples): each tuple contains two elements - a direction (`str`), and a distance (`int`). The directions can be one of the following: \'N\', \'S\', \'E\', or \'W\' (representing North, South, East, and West respectively). The function should return a tuple of integers `(final_x, final_y)` representing the final position of the robot. Function 2: `total_distance_traveled` Implement a function `total_distance_traveled` that takes in the following parameter: * `instructions` (list of tuples): each tuple contains two elements - a direction (`str`), and a distance (`int`). The function should return an integer representing the total distance traveled by the robot. # Constraints * All `start_x` and `start_y` input values must be integers. * `instructions` must be a list of tuples where each tuple contains a direction (one of \'N\', \'S\', \'E\', \'W\') and a positive integer distance. * Ensure to handle edge cases, such as an empty instructions list. # Examples ```python # Calculate final position print(get_final_position(0, 0, [(\'N\', 1), (\'E\', 3), (\'S\', 2), (\'W\', 1)])) # (2, -1) # Calculate total distance traveled print(total_distance_traveled([(\'N\', 1), (\'E\', 3), (\'S\', 2), (\'W\', 1)])) # 7 ``` # Requirements Your functions should: 1. Handle invalid data types by raising a `TypeError`. 2. Handle invalid direction inputs by raising a `ValueError`. 3. Ensure correctness and robustness for a wide range of input values. Start coding these functions ensuring that all the provided examples and edge cases are handled effectively. Good luck!","solution":"def get_final_position(start_x, start_y, instructions): Returns the final position (x, y) after following the given instructions. Parameters: - start_x (int): Starting x-coordinate. - start_y (int): Starting y-coordinate. - instructions (list of tuples): Each tuple contains a direction (\'N\', \'S\', \'E\', \'W\') and a distance (positive int). Returns: - tuple: (final_x, final_y) if not isinstance(start_x, int) or not isinstance(start_y, int): raise TypeError(\\"start_x and start_y must be integers\\") if not all(isinstance(instr, tuple) and len(instr) == 2 and isinstance(instr[0], str) and isinstance(instr[1], int) and instr[1] > 0 for instr in instructions): raise TypeError(\\"Each instruction must be a tuple containing a direction (str) and a positive distance (int)\\") x, y = start_x, start_y for direction, distance in instructions: if direction == \'N\': y += distance elif direction == \'S\': y -= distance elif direction == \'E\': x += distance elif direction == \'W\': x -= distance else: raise ValueError(\\"Invalid direction. Directions must be one of \'N\', \'S\', \'E\', \'W\'.\\") return (x, y) def total_distance_traveled(instructions): Returns the total distance traveled based on the given instructions. Parameters: - instructions (list of tuples): Each tuple contains a direction (\'N\', \'S\', \'E\', \'W\') and a distance (positive int). Returns: - int: Total distance traveled. if not all(isinstance(instr, tuple) and len(instr) == 2 and isinstance(instr[0], str) and isinstance(instr[1], int) and instr[1] > 0 for instr in instructions): raise TypeError(\\"Each instruction must be a tuple containing a direction (str) and a positive distance (int)\\") total_distance = 0 for direction, distance in instructions: if direction not in [\'N\', \'S\', \'E\', \'W\']: raise ValueError(\\"Invalid direction. Directions must be one of \'N\', \'S\', \'E\', \'W\'.\\") total_distance += distance return total_distance"},{"question":"# Coding Assessment Question Context: You are tasked with developing a function that organizes a list of integers into clusters. A cluster is defined as a sequence of consecutive integers. The challenge involves sorting the list of integers, identifying the clusters, and then grouping them accordingly. Task: 1. Implement a function `find_clusters(numbers: list[int]) -> list[list[int]]` that takes a list of unsorted integers and returns a list of clusters. Each cluster should be a sorted list of consecutive integers from the input list. 2. Write a function `largest_cluster(clusters: list[list[int]]) -> list[int]` that returns the largest cluster from the list of clusters found by `find_clusters`. Constraints: * The list of integers, `numbers`, can have up to 100,000 elements. * The integers in `numbers` can be both positive and negative. * Each integer in `numbers` is unique. * Optimize your solution to handle large inputs efficiently. Example Input and Output: ```python >>> find_clusters([100, 4, 200, 1, 3, 2]) [[1, 2, 3, 4], [100], [200]] >>> find_clusters([-10, -8, -9, 5, 3, 4]) [[-10, -9, -8], [3, 4, 5]] >>> largest_cluster([[1, 2, 3], [3, 4, 5, 6, 7], [10]]) [3, 4, 5, 6, 7] >>> largest_cluster([[7], [8, 9]]) [8, 9] ``` Notes: * Ensure the `find_clusters` function returns clusters in the order of their first element\'s appearance in the input list. * Optimize your code to minimize the time complexity, even with the largest input sizes. * Handle edge cases such as an empty input list or a single-element list efficiently.","solution":"def find_clusters(numbers: list[int]) -> list[list[int]]: if not numbers: return [] numbers.sort() clusters = [] cluster = [numbers[0]] for i in range(1, len(numbers)): if numbers[i] == numbers[i - 1] + 1: cluster.append(numbers[i]) else: clusters.append(cluster) cluster = [numbers[i]] clusters.append(cluster) return clusters def largest_cluster(clusters: list[list[int]]) -> list[int]: if not clusters: return [] return max(clusters, key=len)"},{"question":"# List Duplicate Removal and Preservation Order Problem Statement You are given a list of integers which may contain duplicates. Your task is to write a function that removes duplicate elements while preserving the order of the first occurrences of each element. Functional Specification 1. **Function Name**: `remove_duplicates_preserve_order` 2. **Input**: A list of integers `lst`. 3. **Output**: A new list with duplicates removed, preserving the order of the first occurrences of each element. Constraints 1. The function should run efficiently even for large input lists containing up to 10^6 elements. 2. The input list may contain negative and positive integers, including zero. 3. Do not use any external libraries like `pandas`. Examples ```python >>> remove_duplicates_preserve_order([4, 5, 6, 4, 2, 5, 3, 6, 2]) [4, 5, 6, 2, 3] >>> remove_duplicates_preserve_order([1, 2, 2, 3, 4, 4, 4, 5]) [1, 2, 3, 4, 5] >>> remove_duplicates_preserve_order([7, 8, 5, 5, 8, 7, 5]) [7, 8, 5] >>> remove_duplicates_preserve_order([10, 20, 10, 30, 40, 50, 50, 40]) [10, 20, 30, 40, 50] >>> remove_duplicates_preserve_order([]) [] ``` Implementation Write a function that meets the above specifications and ensures that all test cases pass. ```python def remove_duplicates_preserve_order(lst): Returns a new list with duplicates removed, preserving the order of the first occurrences. Args: lst: List of integers which may include duplicates. Returns: A new list with duplicates removed and order preserved. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def remove_duplicates_preserve_order(lst): Returns a new list with duplicates removed, preserving the order of the first occurrences. Args: lst: List of integers which may include duplicates. Returns: A new list with duplicates removed and order preserved. seen = set() result = [] for item in lst: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Design a Custom Data Structure for Efficient Log Storage You are tasked with designing a custom data structure to efficiently store and query log data entries. This data structure must support the following operations: - Insertion of log entries with timestamp and message. - Querying to retrieve all log messages within a specified time range. Each log entry consists of: - `timestamp`: An integer representing the time the log entry was made. - `message`: A string containing the log message. Instructions 1. Implement a class `LogStorage` with the following methods: * `insert(timestamp: int, message: str) -> None`: Stores a log entry. * `query(start: int, end: int) -> List[str]`: Retrieves all log messages with timestamps in the range [start, end] (inclusive). 2. Use a suitable in-memory data structure to support efficient range queries. Expected Input and Output * **Input**: * `insert`: Takes an integer timestamp and a string message. * `query`: Takes two integers, start and end timestamps, representing the time range. * **Output**: * `insert`: No return value. * `query`: Returns a list of strings representing log messages within the specified time range. Example ```python # Example usage of LogStorage log_storage = LogStorage() log_storage.insert(1, \\"Log entry 1\\") log_storage.insert(2, \\"Log entry 2\\") log_storage.insert(10, \\"Log entry 10\\") messages = log_storage.query(1, 5) print(messages) # Output: [\\"Log entry 1\\", \\"Log entry 2\\"] messages = log_storage.query(2, 10) print(messages) # Output: [\\"Log entry 2\\", \\"Log entry 10\\"] ``` You are expected to design and implement the `LogStorage` class with the required methods, ensuring that both insertion and query operations are efficient in terms of time complexity. Focus on optimizing the performance for large datasets. Performance Requirements * Ensure your class can efficiently handle up to 1,000,000 log entries. * Query operations must be optimized to handle large time ranges and return results in a reasonable time frame.","solution":"from typing import List from collections import defaultdict class LogStorage: def __init__(self): self.logs = defaultdict(list) def insert(self, timestamp: int, message: str) -> None: Stores a log entry with the given timestamp and message. self.logs[timestamp].append(message) def query(self, start: int, end: int) -> List[str]: Retrieves all log messages with timestamps in the range [start, end] (inclusive). result = [] for timestamp in range(start, end + 1): if timestamp in self.logs: result.extend(self.logs[timestamp]) return result"},{"question":"Coding Assessment Question [Additional to Existing Set] Scenario You have been tasked with implementing a basic search engine for a small document management system. This system consists of multiple text documents, and you need to be able to search for occurrences of a specific keyword within those documents. Your task is to write a function that, given a list of documents and a keyword, returns a list of document indices where the keyword appears. Task Implement a function to search for occurrences of a keyword within a list of documents. The function should return a list of indices of the documents that contain the keyword. The keyword search should be case-insensitive. Function Signature ```python def search_documents(documents: List[str], keyword: str) -> List[int]: Search for occurrences of a keyword within a list of documents. :param documents: List of strings, where each string represents a document. :param keyword: The keyword to search for. :return: List of integers representing the indices of the documents that contain the keyword. ``` Inputs and Outputs * **Input Format**: * `documents`: List of strings where each string represents a document. * `keyword`: String representing the keyword to search for. * **Output Format**: * Return a list of integers representing the indices of the documents that contain the keyword. Constraints * At least one document will always be present in the list. * The keyword will be a non-empty string. * The search should be case-insensitive. * The keyword can appear in any part of the document (i.e., substring match). Example ```python # Example usage of the function documents = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\", \\"Python is a high-level, general-purpose programming language.\\", \\"The lazy dog sleeps in the sun.\\", \\"To be or not to be, that is the question.\\" ] keyword = \\"lazy\\" print(search_documents(documents, keyword)) # Output: [0, 3] keyword = \\"PYTHON\\" print(search_documents(documents, keyword)) # Output: [2] ``` Evaluation Criteria: 1. **Correctness**: The implementation should correctly identify all documents containing the keyword. 2. **Efficiency**: The function should work efficiently even with a large number of documents. 3. **Case-Insensitivity**: The search should correctly handle case-insensitivity. 4. **Code Quality**: The code should be clean, well-commented, and follow good practices. Implementation ```python from typing import List def search_documents(documents: List[str], keyword: str) -> List[int]: Search for occurrences of a keyword within a list of documents. :param documents: List of strings, where each string represents a document. :param keyword: The keyword to search for. :return: List of integers representing the indices of the documents that contain the keyword. result = [] lowercase_keyword = keyword.lower() for index, document in enumerate(documents): if lowercase_keyword in document.lower(): result.append(index) return result # Example usage if __name__ == \\"__main__\\": documents = [ \\"The quick brown fox jumps over the lazy dog.\\", \\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\\", \\"Python is a high-level, general-purpose programming language.\\", \\"The lazy dog sleeps in the sun.\\", \\"To be or not to be, that is the question.\\" ] keyword = \\"lazy\\" print(search_documents(documents, keyword)) # Output: [0, 3] keyword = \\"PYTHON\\" print(search_documents(documents, keyword)) # Output: [2] ```","solution":"from typing import List def search_documents(documents: List[str], keyword: str) -> List[int]: Search for occurrences of a keyword within a list of documents. :param documents: List of strings, where each string represents a document. :param keyword: The keyword to search for. :return: List of integers representing the indices of the documents that contain the keyword. result = [] lowercase_keyword = keyword.lower() for index, document in enumerate(documents): if lowercase_keyword in document.lower(): result.append(index) return result"},{"question":"Question: Implement the Breadth-First Search (BFS) Algorithm to Find the Shortest Path in an Unweighted Graph **Problem Statement**: You are given a simple, undirected, unweighted graph represented as an adjacency list `graph` where `graph[i]` contains a list of all vertices that are adjacent to vertex `i`. Additionally, you are provided with two vertices, `start` and `end`. Your task is to implement the Breadth-First Search (BFS) algorithm to find the shortest path (in terms of the number of edges) from the `start` vertex to the `end` vertex. If there is no path between the start and end vertices, return an empty list. # Function Signature ```python def bfs_shortest_path(graph: List[List[int]], start: int, end: int) -> List[int]: ``` # Input - `graph`: A list of lists of integers representing the adjacency list of the undirected, unweighted graph. `graph[i]` is a list of vertices connected to vertex `i`. - `start`: An integer representing the starting vertex. - `end`: An integer representing the ending vertex. # Output - Returns a list of integers representing the vertices in the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints - The graph will have at most 1000 vertices. - Vertices are numbered from `0` to `number_of_vertices - 1`. - The graph is connected, but there might not be a specific path between `start` and `end`. # Example ```python graph = [ [1, 2], [0, 3, 4], [0], [1, 5], [1], [3] ] start = 0 end = 5 result = bfs_shortest_path(graph, start, end) print(result) # Output should be [0, 1, 3, 5] ``` # Note - Assume that the input graph is well-formed and valid. - Return the vertices in the path including the start and end vertices. If multiple shortest paths exist, any one of them can be returned. - Consider edge cases such as no connection between the `start` and `end` vertices, or `start` and `end` being the same vertex.","solution":"from collections import deque from typing import List def bfs_shortest_path(graph: List[List[int]], start: int, end: int) -> List[int]: Finds the shortest path from start vertex to end vertex in an unweighted graph using BFS. if start == end: return [start] # Queue for BFS which stores (current_node, path_taken) queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() if current_node in visited: continue visited.add(current_node) for neighbor in graph[current_node]: if neighbor == end: return path + [end] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return []"},{"question":"**Problem Statement:** You are given an unsorted list of integers and an integer `k`. Implement a function that returns the kth smallest integer in the list. If `k` is greater than the number of elements in the list, return None. # Function Signature ```python def kth_smallest_element(lst: list[int], k: int) -> int: pass ``` # Input & Output Formats * **Input**: * `lst`: A list of integers, which can be empty or have up to 1000 elements. * `k`: An integer (1 <= k <= 1000). * **Output**: * Return the kth smallest integer in the list. # Constraints * The length of the list `lst` will not exceed 1000. * The list can contain both positive and negative integers. # Performance Requirements * Optimize your solution to handle the upper constraints effectively. * Aim for a solution with an average-case time complexity of O(n log n) or better. # Examples ```python assert kth_smallest_element([7, 10, 4, 3, 20, 15], 3) == 7 assert kth_smallest_element([7, 10, 4, 3, 20, 15], 4) == 10 assert kth_smallest_element([1, 2, 3, 4, 5], 1) == 1 assert kth_smallest_element([5, 4, 3, 2, 1], 5) == 5 assert kth_smallest_element([5, 6, 5, 6, 5], 4) == 6 assert kth_smallest_element([], 1) == None assert kth_smallest_element([2, -1, 0, -6, 3, -2], 2) == -2 assert kth_smallest_element([10, 20, 30], 5) == None ``` **Notes**: * Your function should handle edge cases gracefully, including empty lists and cases where `k` exceeds the number of integers in the list. * You may use built-in Python functions and libraries if they help optimize your solution.","solution":"def kth_smallest_element(lst: list[int], k: int) -> int: Return the kth smallest integer in the list. If k is greater than the number of elements in the list, return None. if k > len(lst): return None lst.sort() return lst[k-1]"},{"question":"# Scenario: You have been hired to work on a mathematical library for performing matrix operations. One of the tasks is to implement a function that transposes a given 2D matrix. The transpose of a matrix is obtained by swapping rows with columns. # Function Specification **Function name**: `transpose_matrix` **Input**: - `matrix` (List[List[int]]): A 2D list representing the matrix to be transposed, containing at least one row and one column. **Output**: - (List[List[int]]): A 2D list representing the transposed matrix. **Constraints**: - The input matrix will always be non-empty. - Each sub-list (row) within the matrix will have the same number of elements as the other rows. - The function should handle matrices of various sizes, including non-square matrices. - Performance should be efficient and appropriate for typical matrix operations. **Examples**: ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` # Task: Complete the implementation of the `transpose_matrix` function to correctly transpose the given 2D matrix.","solution":"def transpose_matrix(matrix): Transposes the given 2D matrix. Args: matrix (List[List[int]]): The input 2D list representing the matrix to be transposed. Returns: List[List[int]]: A 2D list representing the transposed matrix. # Using list comprehension to transpose the matrix return [list(row) for row in zip(*matrix)]"},{"question":"# Pascal\'s Triangle and Row Calculation Challenge Context You are developing mathematical utilities for combinatorial problems. One such utility involves generating Pascal\'s Triangle and extracting specific rows to aid in various calculations. Objective Write two functions: 1. `generate_pascals_triangle(rows: int) -> list`: This function generates Pascal\'s Triangle up to the specified number of rows. 2. `get_pascals_triangle_row(row_index: int) -> list`: This function returns a specific row from Pascal\'s Triangle. Detailed Requirements 1. **Function 1: generate_pascals_triangle** * **Input**: An integer value representing the number of rows. * **Output**: A list of lists, where each inner list represents a row of Pascal\'s Triangle. * **Constraints**: - The input should be a non-negative integer. - Raise a `ValueError` for invalid input (negative integers or non-integer types). * **Description**: - The function should return the complete Pascal\'s Triangle up to the specified number of rows. 2. **Function 2: get_pascals_triangle_row** * **Input**: An integer value representing the row index. * **Output**: A list containing the elements of the specified row in Pascal\'s Triangle. * **Constraints**: - The row index should be a non-negative integer. - Raise a `ValueError` for invalid input (negative integers or non-integer types). * **Description**: - The function retrieves and returns the specific row from Pascal\'s Triangle based on the given row index. - The first row (row_index 0) is `[1]`. Example Usage ```python # Generating Pascal\'s Triangle print(generate_pascals_triangle(5)) # Output: # [[1], # [1, 1], # [1, 2, 1], # [1, 3, 3, 1], # [1, 4, 6, 4, 1]] # Getting a specific row in Pascal\'s Triangle print(get_pascals_triangle_row(3)) # [1, 3, 3, 1] print(get_pascals_triangle_row(0)) # [1] ``` Constraints * Ensure the functions handle edge cases such as negative integers, non-integer types, and invalid row indices. * The implementation must be efficient and accurate, ensuring that larger values are handled gracefully. * The solution should be self-contained without any additional libraries. Good luck!","solution":"def generate_pascals_triangle(rows): if not isinstance(rows, int) or rows < 0: raise ValueError(\\"Input must be a non-negative integer.\\") triangle = [] for row_num in range(rows): row = [1] * (row_num + 1) for j in range(1, row_num): row[j] = triangle[row_num - 1][j - 1] + triangle[row_num - 1][j] triangle.append(row) return triangle def get_pascals_triangle_row(row_index): if not isinstance(row_index, int) or row_index < 0: raise ValueError(\\"Row index must be a non-negative integer.\\") row = [1] if row_index == 0: return row for k in range(1, row_index + 1): row.append(row[k - 1] * (row_index - k + 1) // k) return row"},{"question":"# Problem Statement You are given a dataset of user activity logs, each log entry contains a user ID, activity type, and a timestamp. Your task is to implement a system that processes these logs to generate a summary report. 1. **LogProcessor**: This class should read the log entries from a file, parse them, and store the logs efficiently. 2. **ActivitySummary**: This class should generate a summary that shows the total count of each activity type for each user. # Constraints - The dataset file size is large, and may exceed available memory. - Each log entry follows the format: `user_id,activity_type,timestampn` - Assume logs are spread over multiple files if needed. # Function Signatures For LogProcessor Class ```python def __init__(self, file_list: List[str]): Initialize with a list of file names containing log entries. def parse_entry(self, entry: str) -> tuple: Parse a single log entry into (user_id, activity_type, timestamp). def process_logs(self): Read log entries from files, parse them, and store the parsed logs. def get_logs(self) -> List[tuple]: Retrieve the list of all stored log entries. ``` For ActivitySummary Class ```python def __init__(self, logs: List[tuple]): Initialize with a list of parsed log entries. def generate_summary(self) -> dict: Generate a summary report with the total count of each activity type for each user. def print_summary(self, summary: dict): Print the summary report in a readable format. ``` # Example Usage - **Input Files**: `log1.txt`, `log2.txt` - **Output Format**: ``` user_id1: activity_type1: count1 activity_type2: count2 user_id2: activity_type1: count1 activity_type2: count2 ``` Example Log Entry ``` 123,login,2021-09-01T10:00:00Z 124,click,2021-09-01T10:01:00Z 123,logout,2021-09-01T10:10:00Z ``` Example Summary ```python { \\"123\\": { \\"login\\": 1, \\"logout\\": 1 }, \\"124\\": { \\"click\\": 1 } } ``` ```python from typing import List, Dict, Tuple # Example usage log_processor = LogProcessor([\\"log1.txt\\", \\"log2.txt\\"]) log_processor.process_logs() logs = log_processor.get_logs() activity_summary = ActivitySummary(logs) summary = activity_summary.generate_summary() activity_summary.print_summary(summary) ``` Implement the required classes and methods to process the log entries from files, store them, and generate a summary report showing the count of each activity type per user.","solution":"from typing import List, Dict, Tuple import os class LogProcessor: def __init__(self, file_list: List[str]): self.file_list = file_list self.logs = [] def parse_entry(self, entry: str) -> tuple: user_id, activity_type, timestamp = entry.strip().split(\',\') return (user_id, activity_type, timestamp) def process_logs(self): for file_name in self.file_list: with open(file_name, \'r\') as file: for line in file: parsed_entry = self.parse_entry(line) self.logs.append(parsed_entry) def get_logs(self) -> List[tuple]: return self.logs class ActivitySummary: def __init__(self, logs: List[tuple]): self.logs = logs def generate_summary(self) -> Dict[str, Dict[str, int]]: summary = {} for user_id, activity_type, timestamp in self.logs: if user_id not in summary: summary[user_id] = {} if activity_type not in summary[user_id]: summary[user_id][activity_type] = 0 summary[user_id][activity_type] += 1 return summary def print_summary(self, summary: Dict[str, Dict[str, int]]): for user_id, activities in summary.items(): print(f\\"{user_id}:\\") for activity_type, count in activities.items(): print(f\\" {activity_type}: {count}\\") # Example usage (to be run in an environment where \\"log1.txt\\" and \\"log2.txt\\" exist) # log_processor = LogProcessor([\\"log1.txt\\", \\"log2.txt\\"]) # log_processor.process_logs() # logs = log_processor.get_logs() # activity_summary = ActivitySummary(logs) # summary = activity_summary.generate_summary() # activity_summary.print_summary(summary)"},{"question":"# Scenario You are developing a feature for a text-processing application that requires the ability to find and extract all the unique words from a block of text whilst preserving their original order of appearance. Words are defined as sequences of alphanumeric characters separated by non-alphanumeric characters. # Task Implement a function `extract_unique_words` that identifies and returns all unique words from the given text in the order they appear. # Function Signature ```python def extract_unique_words(text: str) -> List[str]: ``` # Input * `text`: A string that contains a block of text. # Output * Returns a list of unique words in the order they first appear in the text. # Constraints * The function should handle input strings up to a length of (10^6) characters efficiently. * The comparison for uniqueness should be case-insensitive, but the output should contain words in their original case from the input. # Example ```python >>> extract_unique_words(\\"Hello world! World, hello!\\") [\\"Hello\\", \\"world\\"] >>> extract_unique_words(\\"This is a test. This test is only a test.\\") [\\"This\\", \\"is\\", \\"a\\", \\"test\\", \\"only\\"] ``` # Performance Requirements * The solution should run within reasonable time limits for the input size constraint. # Edge Cases * Ensure your function handles upper and lower case words correctly (case-insensitive comparison). * Handle various non-alphanumeric characters properly (treat them as word separators).","solution":"from typing import List def extract_unique_words(text: str) -> List[str]: Identifies and returns all unique words from the given text in the order they appear. import re words = re.findall(r\'bw+b\', text) seen = set() unique_words = [] for word in words: lower_word = word.lower() if lower_word not in seen: seen.add(lower_word) unique_words.append(word) return unique_words"},{"question":"# Coding Question: Validate and Normalize Email Addresses Context: You are developing an email utility for a user management system. As a part of this task, you need to create a function that validates an email address and standardizes it to a common format. The standardized format involves converting the email address to lowercase and removing any leading or trailing whitespace. Objective: - Write a function `validate_and_normalize_email(email: str) -> Optional[str]` that: - Validates the email address using a regular expression to ensure it conforms to a standard email format. - If the email is invalid, return None. - If the email is valid, return the normalized version which should be: - In lowercase. - Without leading or trailing whitespace. Input and Output: - **Input**: A single string `email` representing an email address (e.g., \\" Example@Domain.COM \\"). - **Output**: An optional string. If the email is valid, return the normalized email; otherwise, return None. Constraints and Limitations: - The email should match the pattern `^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+`. - Assume no email addresses will contain international characters. - Remove leading and trailing spaces before validating the email address. Examples: ```python >>> validate_and_normalize_email(\\" Example@Domain.COM \\") \'example@domain.com\' >>> validate_and_normalize_email(\\"invalid-email.com\\") None >>> validate_and_normalize_email(\\"user+mailbox@domain.com\\") \'user+mailbox@domain.com\' >>> validate_and_normalize_email(\\"VALID_USER@TEST.org \\") \'valid_user@test.org\' ``` Function Signature: ```python from typing import Optional def validate_and_normalize_email(email: str) -> Optional[str]: pass ```","solution":"import re from typing import Optional def validate_and_normalize_email(email: str) -> Optional[str]: Validates and normalizes an email address. Arguments: email -- input email address string Returns: A normalized email string if valid, otherwise None. # Define the regular expression for validating an email email_regex = r\'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\' # Trim leading and trailing whitespace and convert to lowercase email = email.strip().lower() # Validate the email if re.match(email_regex, email): return email else: return None"},{"question":"# Problem Statement You are asked to design a function that determines the area of a triangle given its three side lengths using Heron\'s formula. Heron\'s formula states that the area of a triangle can be calculated as: [ A = sqrt{s(s-a)(s-b)(s-c)} ] where ( s ) is the semi-perimeter of the triangle: [ s = frac{a + b + c}{2} ] and ( a ), ( b ), and ( c ) are the lengths of the sides of the triangle. # Requirements 1. **Function Name**: `calculate_triangle_area` 2. **Input**: - A single list `sides` containing three positive floating-point numbers representing the lengths of the sides of the triangle. - Example: `[3.0, 4.0, 5.0]` 3. **Output**: - A single tuple: (\\"Triangle area\\", calculated_area) - Example: `(\\"Triangle area\\", 6.0)` # Constraints - All side lengths ( a ), ( b ), and ( c ) are positive numbers greater than zero. - The provided side lengths must satisfy the triangle inequality theorem: - ( a + b > c ) - ( a + c > b ) - ( b + c > a ) - If any side length is zero or negative, raise a `ValueError` with the message: - \\"Side lengths must be positive\\" - If the side lengths do not satisfy the triangle inequality theorem, raise a `ValueError` with the message: - \\"Invalid side lengths for a triangle\\" # Example ```python Input: [3.0, 4.0, 5.0] Output: (\\"Triangle area\\", 6.0) Input: [1.0, 1.0, 2.0] Error: ValueError: Invalid side lengths for a triangle Input: [0, 4.0, 5.0] Error: ValueError: Side lengths must be positive ``` # Your Task Write the function `calculate_triangle_area` that reads a list with the side lengths, validates them, calculates the area using Heron\'s formula, and returns the result in the expected format.","solution":"import math def calculate_triangle_area(sides): Calculates the area of a triangle using Heron\'s formula. Args: sides (list): A list of three positive floating-point numbers representing the lengths of the sides of the triangle. Returns: tuple: A tuple containing the string \\"Triangle area\\" and the calculated area. Raises: ValueError: If any side length is non-positive or if the side lengths do not satisfy the triangle inequality theorem. if any(side <= 0 for side in sides): raise ValueError(\\"Side lengths must be positive\\") a, b, c = sides if not (a + b > c and a + c > b and b + c > a): raise ValueError(\\"Invalid side lengths for a triangle\\") s = (a + b + c) / 2 area = math.sqrt(s * (s - a) * (s - b) * (s - c)) return (\\"Triangle area\\", area)"},{"question":"You need to write a function to verify if a given string is a valid Huffman encoded string based on a provided binary Huffman tree. # Input: - A string `encoded_string` consisting of `0`s and `1`s. - A dictionary `huffman_tree` where keys are characters and values are their corresponding binary codes. # Output: - A boolean `True` if the `encoded_string` is a valid encoded string according to the `huffman_tree`, `False` otherwise. # Function Signature: ```python def is_valid_huffman_encoding(encoded_string: str, huffman_tree: dict) -> bool: pass ``` # Example: ```python >>> huffman_tree = {\'A\': \'0\', \'B\': \'10\', \'C\': \'110\', \'D\': \'111\'} >>> is_valid_huffman_encoding(\'01101110\', huffman_tree) True >>> is_valid_huffman_encoding(\'01101111\', huffman_tree) False >>> is_valid_huffman_encoding(\'011011\', huffman_tree) False ``` # Constraints: - The `encoded_string` is non-empty and consists only of binary digits `0` and `1`. - The `huffman_tree` is a dictionary where: - Each key is a single character string (A-Z or a-z). - Each value is a non-empty string of binary digits that represents the Huffman encoding of the key character. - No two characters in the `huffman_tree` will have the same encoding. # Context: Huffman encoding is a widely used algorithm for data compression. It assigns a variable-length binary code to characters, with shorter codes assigned to more frequently occurring characters. Verifying the validity of a Huffman encoded string ensures that the string can be accurately decoded using the provided Huffman tree. This requires checking that the encoded string can be broken down into valid Huffman codes without any discrepancies. Use an efficient algorithm to iterate through the `encoded_string`, trying to match substrings with values from the `huffman_tree` to ensure the string can be completely and uniquely decoded.","solution":"def is_valid_huffman_encoding(encoded_string: str, huffman_tree: dict) -> bool: Returns True if the encoded_string can be decoded using the provided huffman_tree, otherwise returns False. # Create a reverse lookup dictionary for easy matching of encodings to characters reverse_huffman_tree = {v: k for k, v in huffman_tree.items()} i = 0 length = len(encoded_string) while i < length: match_found = False for code in reverse_huffman_tree: if encoded_string.startswith(code, i): i += len(code) match_found = True break if not match_found: return False return i == length"},{"question":"# Coding Assessment Question Context You are working on a financial application that processes transactions based on a batch system. A transaction record indicates if a transaction was successful or failed. To analyze the performance of this system, you need to implement a function that processes the transaction records, calculates the success and failure rates, and identifies the most common reasons for failure. Task Implement a function named `analyze_transactions` that accepts a list of transaction records. Each record is a dictionary with keys `id`, `status`, and `reason`. The `status` can be `\\"success\\"` or `\\"failure\\"` and `reason` is a string describing the reason for failure (or an empty string if the status is `\\"success\\"`). The function should return a dictionary with three key-value pairs: the success rate as a percentage, the failure rate as a percentage, and the most common reason for failure. The success and failure rates should be returned as floats rounded to two decimal places. Function Signature ```python def analyze_transactions(transactions: list[dict[str, str]]) -> dict[str, float | str]: pass ``` Input * `transactions` (list of dictionaries): A list where each element is a dictionary with the following keys: - `id` (str): The transaction ID. - `status` (str): The status of the transaction (`\\"success\\"` or `\\"failure\\"`). - `reason` (str): The reason for failure (empty string if the status is `\\"success\\"`). Output * A dictionary with the following key-value pairs: - `\\"success_rate\\"` (float): The success rate as a percentage, rounded to two decimal places. - `\\"failure_rate\\"` (float): The failure rate as a percentage, rounded to two decimal places. - `\\"most_common_failure_reason\\"` (str): The most common reason for failure (empty string if there are no failures). Constraints * The input list will have at least one record. * If there are no failures, `\\"most_common_failure_reason\\"` should be an empty string. Examples ```python >>> transactions = [ {\\"id\\": \\"txn001\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, {\\"id\\": \\"txn002\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Network Error\\"}, {\\"id\\": \\"txn003\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Insufficient Funds\\"}, {\\"id\\": \\"txn004\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, {\\"id\\": \\"txn005\\", \\"status\\": \\"failure\\", \\"reason\\": \\"Network Error\\"} ] >>> analyze_transactions(transactions) {\'success_rate\': 40.0, \'failure_rate\': 60.0, \'most_common_failure_reason\': \'Network Error\'} >>> transactions = [ {\\"id\\": \\"txn001\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, {\\"id\\": \\"txn002\\", \\"status\\": \\"success\\", \\"reason\\": \\"\\"}, ] >>> analyze_transactions(transactions) {\'success_rate\': 100.0, \'failure_rate\': 0.0, \'most_common_failure_reason\': \'\'} ``` Additional Notes * Ensure accuracy in calculating the percentages. * Handle the case where there are no failures gracefully. * Efficiently count and identify the most common failure reason.","solution":"def analyze_transactions(transactions): total_transactions = len(transactions) successful_transactions = sum(1 for txn in transactions if txn[\\"status\\"] == \\"success\\") failed_transactions = total_transactions - successful_transactions success_rate = (successful_transactions / total_transactions) * 100 failure_rate = (failed_transactions / total_transactions) * 100 # Count occurrences of each failure reason failure_reasons = {} for txn in transactions: if txn[\\"status\\"] == \\"failure\\": reason = txn[\\"reason\\"] if reason in failure_reasons: failure_reasons[reason] += 1 else: failure_reasons[reason] = 1 if failure_reasons: most_common_failure_reason = max(failure_reasons, key=failure_reasons.get) else: most_common_failure_reason = \\"\\" # Return the results in a dictionary return { \\"success_rate\\": round(success_rate, 2), \\"failure_rate\\": round(failure_rate, 2), \\"most_common_failure_reason\\": most_common_failure_reason }"},{"question":"# Problem Context You are tasked with implementing a method to balance a list of integers for an array-shifting game. The goal is to determine the minimum number of shifts needed to make every element of the list equal. The only allowed operation is to shift elements cyclically. # Task Implement a function `minimum_shifts_to_equal_elements(nums: list[int]) -> int` that determines the minimum number of shifts needed to make every element of the list equal. If it is not possible to make all elements equal by shifting, return -1. # Requirements * **Input**: * `nums`: A list of integers of length ( n ) (1 ≤ ( n ) ≤ 1000), where each element is an integer (1 ≤ element ≤ 1000). * **Output**: An integer representing the minimum number of shifts needed to make all elements of the list equal, or -1 if it is not possible. * **Constraints**: * The list must contain at least one element. * If it is not possible to make all elements equal by shifting, return -1. # Examples ```python >>> minimum_shifts_to_equal_elements([1, 2, 3, 4]) -1 >>> minimum_shifts_to_equal_elements([1, 1, 1, 1]) 0 >>> minimum_shifts_to_equal_elements([2, 2, 3, 2, 2]) -1 >>> minimum_shifts_to_equal_elements([5, 5, 5, 2, 5]) 2 >>> minimum_shifts_to_equal_elements([7]) 0 >>> minimum_shifts_to_equal_elements([4, 5, 4, 5, 4, 5]) -1 ``` **Tip**: Focus on detecting if the elements can be made equal through any possible cyclic shift combination and seek the minimum shift count required for this transformation.","solution":"def minimum_shifts_to_equal_elements(nums): Returns the minimum number of shifts needed to make every element of the list equal by cyclically shifting the array. If it is not possible, returns -1. if len(nums) == 1: return 0 target = nums[0] shifts_needed = float(\'inf\') for i in range(len(nums)): shifted = nums[i:] + nums[:i] if all(x == target for x in shifted): shifts_needed = min(shifts_needed, i) target = nums[(i + 1) % len(nums)] return shifts_needed if shifts_needed != float(\'inf\') else -1"},{"question":"# Problem Statement You need to implement a function that calculates the longest sequence of contiguous unique characters in a given string. The function should be able to handle strings with both uppercase and lowercase letters, digits, and special characters. This functionality is useful in various areas, such as analyzing text for patterns or ensuring uniqueness constraints in user inputs. # Requirements Function Signature ```python def longest_unique_substring(input_str: str) -> str: ``` Functionality Description - The function should accept one parameter: * `input_str` (str): The input string for which the longest contiguous unique characters sequence should be found. - The function should return the longest contiguous unique characters sequence as a string. # Constraints 1. The `input_str` must be a non-empty string. 2. The input string may contain any printable ASCII character. # Error Handling 1. Raise a `ValueError` if `input_str` is not a string. # Performance Requirements - Implement the function such that it operates with linear time complexity, O(n), where n is the length of `input_str`. - Ensure the function uses O(n) additional space. # Example Usage ```python >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" >>> longest_unique_substring(\\"dvdf\\") \\"vdf\\" >>> longest_unique_substring(\\"aA1!aA1!\\") \\"aA1!\\" ``` In addition, ensure that the function properly raises exceptions on incorrect argument types: ```python >>> longest_unique_substring(12345) Traceback (most recent call last): ... ValueError: Expected string as input, found <class \'int\'> ```","solution":"def longest_unique_substring(input_str: str) -> str: if not isinstance(input_str, str): raise ValueError(f\\"Expected string as input, found {type(input_str)}\\") last_seen = {} start = 0 max_length = 0 max_start = 0 for i, char in enumerate(input_str): if char in last_seen and last_seen[char] >= start: start = last_seen[char] + 1 last_seen[char] = i if i - start + 1 > max_length: max_length = i - start + 1 max_start = start return input_str[max_start:max_start + max_length]"},{"question":"# Question Problem Statement: You are required to create a Python function that calculates the factorial of a given non-negative integer using both iterative and recursive methods. Write a Python function `factorial(n: int, method: str) -> int` that computes the factorial based on the given method. The `method` parameter will be a string, either `\'iterative\'` or `\'recursive\'`. The factorial of a non-negative integer (n) is the product of all positive integers less than or equal to (n). It is denoted by (n!) and defined by: [ n! = begin{cases} 1 & text{if } n = 0 n times (n-1) times cdots times 2 times 1 & text{if } n > 0 end{cases} ] Requirements: * **Input Format**: - A single non-negative integer `n`, where ( 0 leq n leq 12 ). - A string `method`, which can be either `\'iterative\'` or `\'recursive\'`. * **Output Format**: - A single integer, representing the factorial of `n`. Example: ``` Input: 5, \'iterative\' Output: 120 Input: 5, \'recursive\' Output: 120 Input: 0, \'iterative\' Output: 1 Input: 0, \'recursive\' Output: 1 ``` Constraints: * 0 ≤ `n` ≤ 12 * `method` will always be either `\'iterative\'` or `\'recursive\'`. Additional Notes: 1. Implement error handling to manage invalid method inputs (return -1 in such cases). 2. Compare the results of both methods for consistency. 3. Handle the base case for factorial computation carefully, specifically factorial of 0 which is 1. Testing: 1. Validate your implementation on: - Basic cases: factorial(5) - Edge cases: factorial(0), factorial(12) 2. Ensure the results are the same for both `\'iterative\'` and `\'recursive\'` methods.","solution":"def factorial(n: int, method: str) -> int: Compute the factorial of a given non-negative integer `n` using the specified method. Parameters: n (int): Non-negative integer for which the factorial is to be computed. method (str): Method to use for computation, either \'iterative\' or \'recursive\'. Returns: int: Factorial of the given number `n`. If the method input is invalid, return -1. if method == \'iterative\': return iterative_factorial(n) elif method == \'recursive\': return recursive_factorial(n) else: return -1 def iterative_factorial(n: int) -> int: result = 1 for i in range(1, n + 1): result *= i return result def recursive_factorial(n: int) -> int: if n == 0: return 1 return n * recursive_factorial(n - 1)"},{"question":"# Question **Binary Subarrays with Target Sum** Given an array `arr` of binary digits (0s and 1s) and an integer `target`, write a function `count_subarrays_with_sum(arr: List[int], target: int) -> int` that returns the number of contiguous subarrays that sum up to the given `target`. Input * A list of integers `arr` containing only 0s and 1s (1 ≤ len(arr) ≤ 10^5). * An integer `target` (0 ≤ target ≤ len(arr)). Output * Return an integer representing the number of contiguous subarrays whose sum is equal to `target`. Constraints * Your solution should efficiently handle the upper bound of `len(arr)`. Examples ```python >>> count_subarrays_with_sum([1, 0, 1, 0, 1], 2) 4 >>> count_subarrays_with_sum([1, 0, 1, 1, 0, 1, 1], 3) 5 ``` # Scenario Consider this scenario: You are developing a feature for analyzing network packets, where each packet can either be considered active (1) or inactive (0). You need to count the number of consecutive active period sequences that match a given number of active packets to detect potential patterns in network traffic. Requirements * Your implementation should efficiently count the subarrays with the specified sum, even for large inputs. * Ensure that the algorithm handles edge cases, such as empty arrays or targets that are zero, correctly. Performance * Aim for a solution with optimized time complexity, possibly leveraging the sliding window technique or hashing for efficient counting.","solution":"from typing import List def count_subarrays_with_sum(arr: List[int], target: int) -> int: Returns the number of contiguous subarrays within `arr` that sum up to the specified `target`. prefix_sum = 0 count = 0 sum_frequency = {0: 1} # To account for sum starting from index 0 for num in arr: prefix_sum += num if prefix_sum - target in sum_frequency: count += sum_frequency[prefix_sum - target] if prefix_sum in sum_frequency: sum_frequency[prefix_sum] += 1 else: sum_frequency[prefix_sum] = 1 return count"},{"question":"# Question: Implement Circular Array Rotation Context You are developing a feature for a data-processing software that involves rotating elements within an array. You have to write a function that simulates a circular rotation of the array elements. Requirements 1. **Function: Rotate Array** ```python def rotate_array(arr: list, k: int) -> list: Take in a list of integers and an integer k. \'arr\' is the list to be rotated. \'k\' is the number of times the array is rotated to the right. Return the array after k rotations. Example: >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] ``` Constraints - `arr` may be empty or non-empty. - `k` is a non-negative integer. - The function should handle cases where `k` is greater than the length of the array by effectively reducing `k` modulo the array length. Performance Requirements - The implementation should be efficient, ideally with a time complexity of O(n), where n is the length of the array. Edge Cases - Handle the case where the array is empty. - Ensure the function works when `k` is zero or when `k` is a multiple of the array length. Write the code that meets these requirements and test it with the provided examples.","solution":"def rotate_array(arr: list, k: int) -> list: Rotate the array arr by k positions to the right. Parameters: arr (list): List of integers to rotate. k (int): Number of positions to rotate the array. Returns: list: The rotated array. if len(arr) == 0: return arr k = k % len(arr) # normalize k to avoid useless rotations return arr[-k:] + arr[:-k]"},{"question":"# Sum of Prime Numbers Context Prime numbers have significant importance in various fields, such as cryptography, number theory, and algorithm design. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. This question explores summing prime numbers within a given range. Problem Statement Write a function `sum_of_primes(m: int, n: int) -> int` that computes the sum of all prime numbers between two given integers `m` and `n`, inclusive. Requirements 1. The function should efficiently determine whether numbers within a specified range are prime. 2. It should sum all the prime numbers within this range. 3. Consider optimization techniques to handle the primality test and summation efficiently. Input and Output - **Input**: Two integers `m` and `n` (1 <= m <= n <= 10^6). - **Output**: An integer representing the sum of all prime numbers between `m` and `n` inclusive. Constraints 1. The function should handle a wide range of inputs efficiently, focusing on time and space optimization. 2. Edge cases where `m` and `n` are close together or very large should be handled gracefully. 3. Ensure that the function uses efficient algorithms to test for prime numbers, such as the Sieve of Eratosthenes for precomputation. Performance Requirements The algorithm should ideally run in O(n log log n) time complexity using sieve algorithms and should use O(n) space. # Example ```python def sum_of_primes(m: int, n: int) -> int: # Your code here # Test cases print(sum_of_primes(1, 10)) # Output: 17 (2 + 3 + 5 + 7) print(sum_of_primes(10, 20)) # Output: 60 (11 + 13 + 17 + 19) print(sum_of_primes(5, 5)) # Output: 5 print(sum_of_primes(20, 30)) # Output: 52 (23 + 29) print(sum_of_primes(1, 100)) # Output: 1060 ``` Explanation - For `m = 1` and `n = 10`, the prime numbers in this range are [2, 3, 5, 7], and their sum is 17. - For `m = 10` and `n = 20`, the prime numbers in this range are [11, 13, 17, 19], and their sum is 60. - For `m = 5` and `n = 5`, the only prime in this range is 5, so the sum is 5. - Handle other cases similarly ensuring the primality test and summation logic are optimal and correct.","solution":"import math def sum_of_primes(m: int, n: int) -> int: Returns the sum of all prime numbers between m and n inclusive. if n < 2: return 0 if m < 2: m = 2 sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(2, int(math.sqrt(n)) + 1): if sieve[start]: for multiple in range(start * start, n + 1, start): sieve[multiple] = False return sum(i for i in range(m, n + 1) if sieve[i])"},{"question":"# Matrix Transposition in Place You are required to implement a function that transposes a given square matrix **in place**. Transposing a matrix involves swapping its rows and columns. The function should be efficient in terms of space complexity, relying only on constant extra memory. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> None: Transpose a given square matrix in place. :param matrix: A list of lists representing a square matrix (n x n) of integers. :return: None. The matrix is modified in place. # Your code here ``` # Input * `matrix`: A list of lists where each inner list represents a row of the matrix. Each element of the matrix is an integer. - The matrix is guaranteed to be square (n x n). # Output * The function does not return anything. The given matrix is modified in place. # Constraints * The input matrix will always be square, i.e., the number of rows and columns are equal. * The input matrix will contain integers within the range of [-10^9, 10^9]. # Additional Requirements * You should ensure the function modifies the matrix in place and does not use any extra memory apart from a few variables for temporary storage during swapping. # Example 1. **Input**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` **Output**: ```python matrix = [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ] ``` 2. **Input**: ```python matrix = [ [1, 0], [1, 2] ] ``` **Output**: ```python matrix = [ [1, 1], [0, 2] ] ``` # Implementation Note * Use double nested loops to iterate through the matrix elements and swap them appropriately for transposition. * Ensure that the transposition process does not need additional data structures beyond a few variables for temporary storage during the swaps. ```python def transpose_matrix(matrix: List[List[int]]) -> None: n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] ```","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> None: Transpose a given square matrix in place. :param matrix: A list of lists representing a square matrix (n x n) of integers. :return: None. The matrix is modified in place. n = len(matrix) for i in range(n): for j in range(i + 1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"# Coding Assessment Question You are tasked with enhancing a program that analyzes weather data obtained from a public API. The current implementation retrieves current weather conditions, but it now needs to support fetching weather forecasts for a given city over a specified duration. Task: 1. Implement a function `get_weather_forecast(api_key: str, city: str, days: int) -> dict` that: - Fetches daily weather forecast data for a given city for the specified number of days. - Returns a dictionary where the key is the date and the value is another dictionary containing weather details (temperature, humidity, and description). 2. Refactor the `get_current_weather` function to handle potential errors such as missing data, incorrect API responses, or network issues. Expected Input and Output: * `get_weather_forecast`: - **Input**: `api_key`: str, `city`: str, `days`: int. - **Output**: A dictionary where keys are dates (YYYY-MM-DD) and values are dictionaries with \'temperature\', \'humidity\', and \'description\'. * `get_current_weather`: - **Input**: `api_key`: str, `city`: str. - **Output**: A dictionary containing current weather data (\'temperature\', \'humidity\', \'description\'), or an error message in case of failure. Constraints: - All strings will be non-empty and properly formatted. - The API key will be a valid string. - The city name will be valid and correspond to a real location. - The number of days will range from 1 to 7. Performance Requirements: - Ensure that API requests are performed efficiently. - Include proper error handling for network errors and unexpected API responses. Hints: - Use Python\'s `requests` library to interact with the weather API. - Handle possible exceptions and ensure JSON responses are parsed correctly. Implement the following: ```python import requests def get_weather_forecast(api_key: str, city: str, days: int) -> dict: Fetch daily weather forecast data for a given city for the specified number of days. url = f\\"http://api.weatherapi.com/v1/forecast.json\\" params = { \\"key\\": api_key, \\"q\\": city, \\"days\\": days, } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"forecast\\"][\\"forecastday\\"] forecast = {} for day in data: date = day[\\"date\\"] forecast[date] = { \\"temperature\\": day[\\"day\\"][\\"avgtemp_c\\"], \\"humidity\\": day[\\"day\\"][\\"avghumidity\\"], \\"description\\": day[\\"day\\"][\\"condition\\"][\\"text\\"], } return forecast except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return {} def get_current_weather(api_key: str, city: str) -> dict: Fetch current weather data for a given city. url = f\\"http://api.weatherapi.com/v1/current.json\\" params = { \\"key\\": api_key, \\"q\\": city, } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"current\\"] return { \\"temperature\\": data[\\"temp_c\\"], \\"humidity\\": data[\\"humidity\\"], \\"description\\": data[\\"condition\\"][\\"text\\"], } except requests.RequestException as e: return {\\"error\\": str(e)} ```","solution":"import requests def get_weather_forecast(api_key: str, city: str, days: int) -> dict: Fetch daily weather forecast data for a given city for the specified number of days. url = f\\"http://api.weatherapi.com/v1/forecast.json\\" params = { \\"key\\": api_key, \\"q\\": city, \\"days\\": days, } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"forecast\\"][\\"forecastday\\"] forecast = {} for day in data: date = day[\\"date\\"] forecast[date] = { \\"temperature\\": day[\\"day\\"][\\"avgtemp_c\\"], \\"humidity\\": day[\\"day\\"][\\"avghumidity\\"], \\"description\\": day[\\"day\\"][\\"condition\\"][\\"text\\"], } return forecast except requests.RequestException as e: print(f\\"An error occurred: {e}\\") return {} def get_current_weather(api_key: str, city: str) -> dict: Fetch current weather data for a given city. url = f\\"http://api.weatherapi.com/v1/current.json\\" params = { \\"key\\": api_key, \\"q\\": city, } try: response = requests.get(url, params=params, timeout=10) response.raise_for_status() data = response.json()[\\"current\\"] return { \\"temperature\\": data[\\"temp_c\\"], \\"humidity\\": data[\\"humidity\\"], \\"description\\": data[\\"condition\\"][\\"text\\"], } except requests.RequestException as e: return {\\"error\\": str(e)}"},{"question":"# Problem Statement You are given an array of integers `arr`. Your task is to find the length of the longest subarray that contains no more than two distinct integers. Implement a function `longest_subarray_with_two_distinct(arr: List[int]) -> int` that returns this length. # Input - A list of integers `arr` (1 ≤ len(arr) ≤ 10**5, 0 ≤ arr[i] ≤ 10**9). # Output - An integer representing the length of the longest subarray with at most two distinct integers. # Example ```python >>> longest_subarray_with_two_distinct([1, 2, 1, 2, 3]) 4 >>> longest_subarray_with_two_distinct([4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_two_distinct([1, 2, 3, 2, 2]) 5 ``` # Constraints - The length of the input list can be as large as 100,000. - The values in the array are non-negative integers and can be very large. # Notes - Ensure that your implementation is efficient and operates within acceptable time limits for large arrays. - Consider using sliding window or two pointer techniques to solve the problem in linear time.","solution":"from typing import List from collections import defaultdict def longest_subarray_with_two_distinct(arr: List[int]) -> int: Returns the length of the longest subarray with at most two distinct integers. if not arr: return 0 start = 0 max_length = 0 char_count = defaultdict(int) for end in range(len(arr)): char_count[arr[end]] += 1 while len(char_count) > 2: char_count[arr[start]] -= 1 if char_count[arr[start]] == 0: del char_count[arr[start]] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"# Task: Implement a Comprehensive Reverse String Function with Options Given the basic task of reversing a string, your objective is to implement an enhanced function with additional features and error handling. Specifically: 1. **Input Validation**: Ensure the input is a string. If the input is not a string, raise a TypeError with the message \\"Invalid input: Input must be a string\\". 2. **Case Sensitivity Option**: Add a parameter `case_sensitive` that, when set to False, should make the function ignore the case of letters when reversing the string and return the result in lowercase. The default value should be True. 3. **Palindrome Check Option**: Add another parameter `check_palindrome` that, when set to True, should make the function return an additional boolean value indicating whether the original string is a palindrome (same forwards and backwards). The default value should be False. # Function Signature ```python def reverse_string(input_string, case_sensitive=True, check_palindrome=False): Reverse the given string with additional features and error handling. :param input_string: str: The string to be reversed :param case_sensitive: bool: If False, the function should ignore case and return result in lowercase :param check_palindrome: bool: If True, the function should also return whether the input is a palindrome :return: str or tuple of (str, bool): The reversed string, and optionally a boolean palindrome indicator >>> reverse_string(\\"Hello\\") \\"olleH\\" >>> reverse_string(\\"AbBa\\", case_sensitive=False) \\"abba\\" >>> reverse_string(\\"Madam\\", check_palindrome=True) (\\"madaM\\", False) >>> reverse_string(\\"Redder\\", check_palindrome=True) (\\"reddeR\\", True) >>> reverse_string(123) Traceback (most recent call last): ... TypeError: Invalid input: Input must be a string # Your implementation here ``` # Constraints 1. The primary input should be a string. 2. The function should raise a TypeError for non-string inputs. 3. If `case_sensitive` is False, return the reversed string in lowercase. 4. If `check_palindrome` is True, return a tuple where the first element is the reversed string and the second element is a boolean indicating if the original string is a palindrome. # Example Usages - `reverse_string(\\"Hello\\")` should return `\\"olleH\\"`. - `reverse_string(\\"AbBa\\", case_sensitive=False)` should return `\\"abba\\"`. - `reverse_string(\\"Madam\\", check_palindrome=True)` should return `(\\"madaM\\", False)`. - `reverse_string(\\"Redder\\", check_palindrome=True)` should return `(\\"reddeR\\", True)`. - `reverse_string(123)` should raise `TypeError: Invalid input: Input must be a string`.","solution":"def reverse_string(input_string, case_sensitive=True, check_palindrome=False): Reverse the given string with additional features and error handling. :param input_string: str: The string to be reversed :param case_sensitive: bool: If False, the function should ignore case and return result in lowercase :param check_palindrome: bool: If True, the function should also return whether the input is a palindrome :return: str or tuple of (str, bool): The reversed string, and optionally a boolean palindrome indicator :raises TypeError: If the input is not a string if not isinstance(input_string, str): raise TypeError(\\"Invalid input: Input must be a string\\") reversed_string = input_string[::-1] if not case_sensitive: reversed_string = reversed_string.lower() input_string = input_string.lower() if check_palindrome: is_palindrome = (input_string == reversed_string) return reversed_string, is_palindrome return reversed_string"},{"question":"# Task: Reverse Words in a String Problem Statement: Write a function `reverse_words` that takes a string `s` and returns the string with the words reversed. Words are defined as sequences of characters separated by spaces. The function should handle multiple spaces and preserve them in their original position. Input: - A string `s` Output: - A string with the words reversed. Examples: ``` assert reverse_words(\\"Hello World\\") == \\"World Hello\\" assert reverse_words(\\" Python is awesome \\") == \\" awesome is Python \\" assert reverse_words(\\"a b c\\") == \\"c b a\\" assert reverse_words(\\"\\") == \\"\\" assert reverse_words(\\" \\") == \\" \\" ``` Constraints: - The input string may contain letters, digits, and special characters. - The input string may have leading, trailing, and multiple spaces between words. - The length of the input string will not exceed 10^4 characters. Requirements: - Your implementation should handle cases with multiple spaces intact. - Performance should be optimized for length constraints. Optimization: - Aim for linear time complexity O(n) where `n` is the length of the string. - Minimize space usage while ensuring clarity and correctness. Sample Function Signature: ```python def reverse_words(s: str) -> str: pass ```","solution":"def reverse_words(s: str) -> str: This function takes a string s and returns the string with the words reversed. Words are defined as sequences of characters separated by spaces. words = s.split() reversed_words = words[::-1] reversed_string = \' \'.join(reversed_words) # Handle multiple spaces by splitting and then joining on spaces # Generate the final result which preserves the original spacing result = \'\' word_index = 0 i = 0 while i < len(s): if s[i].isspace(): result += s[i] else: if word_index < len(reversed_words): result += reversed_words[word_index] word_index += 1 while i < len(s) and not s[i].isspace(): i += 1 i -= 1 # decrement i to offset the final increment after the inner while loop i += 1 return result"},{"question":"# Coding Assessment Question **Problem Statement:** You are provided with a simple graph implementation in Python, including methods for adding vertices and edges. Your task is to extend the given implementation by adding functionality to determine whether a path exists between two given vertices using Depth-First Search (DFS) and to find the shortest path using Breadth-First Search (BFS). Requirements: 1. **Path Existence**: Implement a function `path_exists` which uses DFS to determine whether a path exists between two given vertices in the graph. 2. **Shortest Path**: Implement a function `shortest_path` which uses BFS to find the shortest path between two given vertices. Return the path as a list of vertices. Input: - A list of tuples representing the edges of the graph, where each tuple contains two vertices. - Two integers representing the source and destination vertices. Output: - A boolean value indicating whether a path exists between the source and destination vertices. - A list of vertices representing the shortest path from the source to the destination (if a path exists). If no path is found, return an empty list. Constraints: - The graph will have at most 10^3 vertices and 10^4 edges. - The vertices are represented by integers. Function Signature: ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int) -> None: ... def path_exists(graph: Graph, start: int, end: int) -> bool: ... def shortest_path(graph: Graph, start: int, end: int) -> list[int]: ... # Example Usage: # graph = Graph() # edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] # for u, v in edges: # graph.add_edge(u, v) # exists = path_exists(graph, 1, 3) # path = shortest_path(graph, 1, 3) # print(exists) # Output: True # print(path) # Output: [1, 2, 3] ``` --- **Example:** ```python class Graph: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int) -> None: if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def path_exists(graph: Graph, start: int, end: int) -> bool: visited = set() def dfs(vertex: int) -> bool: if vertex == end: return True visited.add(vertex) for neighbor in graph.graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start) def shortest_path(graph: Graph, start: int, end: int) -> list[int]: from collections import deque queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() for neighbor in graph.graph.get(current, []): if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # Test graph = Graph() edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] for u, v in edges: graph.add_edge(u, v) exists = path_exists(graph, 1, 3) path = shortest_path(graph, 1, 3) print(exists) # Output: True print(path) # Output: [1, 2, 3] ``` Implement the `path_exists` method to use DFS for determining the existence of a path and the `shortest_path` method to use BFS for finding the shortest path. This exercise will test your understanding of graph traversal techniques and algorithms.","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, u: int, v: int) -> None: if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def path_exists(graph: Graph, start: int, end: int) -> bool: visited = set() def dfs(vertex: int) -> bool: if vertex == end: return True visited.add(vertex) for neighbor in graph.graph.get(vertex, []): if neighbor not in visited: if dfs(neighbor): return True return False return dfs(start) def shortest_path(graph: Graph, start: int, end: int) -> list[int]: from collections import deque queue = deque([(start, [start])]) visited = set([start]) while queue: current, path = queue.popleft() for neighbor in graph.graph.get(current, []): if neighbor == end: return path + [end] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Problem Statement **Weighted Path Sum in a Grid** You are given a 2D grid of integers where each cell contains a positive integer representing the weight to enter that cell. Your task is to write a function `calculate_weighted_path_sum(grid: List[List[int]]) -> int` that finds the minimum sum of weights to travel from the top-left corner of the grid to the bottom-right corner. You can only move right or down at each step. # Constraints: - The grid will be a non-empty 2D list of positive integers. - The grid dimensions are at most 100x100. Input - `grid` (List[List[int]]): A 2D list where each element is a positive integer representing the weight. Output - `int`: The minimum sum of weights needed to travel from the top-left to bottom-right. # Example ```python from typing import List def calculate_weighted_path_sum(grid: List[List[int]]) -> int: # Implementation here… grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(calculate_weighted_path_sum(grid)) # Output: 7 ``` *Explanation*: The path that gives this minimal result is 1 → 3 → 1 → 1 → 1 which sums to 7. # Notes - Use a dynamic programming approach to solve the problem efficiently. - Consider edge cases such as grids with a single row or column.","solution":"from typing import List def calculate_weighted_path_sum(grid: List[List[int]]) -> int: # Check for an empty grid input if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0] * cols for _ in range(rows)] # Initialize the first cell dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) # The bottom-right cell contains the result return dp[rows-1][cols-1]"},{"question":"# Scenario You have been assigned to develop a feature for an online bookstore. Customers often search for books by their titles, and you need to implement a function that helps find book titles based on a search query. The system should handle partial matches and be case-insensitive to provide a seamless user experience. # Task Implement the function `search_books`, which filters a list of book titles to find all titles that contain a given search query as a substring, ignoring case. # Requirements 1. **Function Signature**: ```python def search_books(titles: list[str], query: str) -> list[str]: pass ``` 2. **Parameters**: - `titles` (list of str): The list of book titles. - `query` (str): The search query to match within the book titles. 3. **Returns**: - (list of str): A list of book titles that contain the search query, case-insensitively. 4. **Constraints**: - The search should be case-insensitive. - If no titles match the query, return an empty list. - The input list of titles and the query will always be non-empty. # Examples ```python >>> search_books([\\"The Great Gatsby\\", \\"Catching Fire\\", \\"To Kill a Mockingbird\\", \\"Great Expectations\\"], \\"great\\") [\\"The Great Gatsby\\", \\"Great Expectations\\"] >>> search_books([\\"The Great Gatsby\\", \\"Catching Fire\\", \\"To Kill a Mockingbird\\", \\"Great Expectations\\"], \\"FIRE\\") [\\"Catching Fire\\"] >>> search_books([\\"Pride and Prejudice\\", \\"War and Peace\\", \\"1984\\", \\"Brave New World\\"], \\"and\\") [\\"Pride and Prejudice\\", \\"War and Peace\\"] ``` # Additional Notes: Consider edge cases such as: - Query that matches the entire title. - Titles with special characters or numbers. - Case-insensitivity should be maintained throughout the search.","solution":"def search_books(titles: list[str], query: str) -> list[str]: Function to search for book titles containing the query string, ignoring case. Parameters: titles (list of str): The list of book titles. query (str): The search query to match within the book titles. Returns: list of str: A list of book titles that contain the search query, case-insensitively. lower_query = query.lower() result = [title for title in titles if lower_query in title.lower()] return result"},{"question":"# Coding Assessment Question Imagine you are developing a feature for a note-taking application where users can organize their notes in a hierarchical manner using nested tags. # Question **Problem Statement:** Write a function `generate_note_hierarchy(notes: List[Dict[str, Any]], root_tag: str) -> Dict[str, Any]` that constructs a nested tag hierarchy starting from the given `root_tag`. Each note has a `tags` field containing a list of tags describing the structure of the note e.g., `[\\"Work\\", \\"Project\\", \\"Task\\"]`. **Input:** - `notes` (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a note and contains the fields `id` (int or str), `content` (str), and `tags` (List[str]). - `root_tag` (str): The starting tag to build the hierarchy from. **Output:** - A dictionary where each key is a tag and its value is either the list of note IDs that have the exact path of tags, or another dictionary representing the nested tags. **Constraints:** - The hierarchy should be built only for notes that contain the `root_tag` or its descendants in their tags list. - You must handle the case where multiple notes share the same tag path. **Additional Context:** - For hierarchical visualization, consider the following tags hierarchy: - Work - Project 1 - Task A - Task B - Project 2 - Task C - Personal - Home - Grocery - Hobbies - Guitar - Yoga # Example ```python def generate_note_hierarchy(notes: List[Dict[str, Any]], root_tag: str) -> Dict[str, Any]: pass # Your implementation here # Example usage: notes = [ {\'id\': 1, \'content\': \'Complete the project proposal.\', \'tags\': [\'Work\', \'Project 1\', \'Task A\']}, {\'id\': 2, \'content\': \'Buy groceries.\', \'tags\': [\'Personal\', \'Home\', \'Grocery\']}, {\'id\': 3, \'content\': \'Work on yoga poses.\', \'tags\': [\'Personal\', \'Hobbies\', \'Yoga\']}, {\'id\': 4, \'content\': \'Finish Task B.\', \'tags\': [\'Work\', \'Project 1\', \'Task B\']}, {\'id\': 5, \'content\': \'Organize notes.\', \'tags\': [\'Work\', \'Project 2\', \'Task C\']} ] print(generate_note_hierarchy(notes, \'Work\')) ``` # Expected Hierarchy Output ```python { \'Project 1\': { \'Task A\': [1], \'Task B\': [4] }, \'Project 2\': { \'Task C\': [5] } } ``` Make sure your implementation is efficient, handles different edge cases (such as missing tags, empty notes list), and provides clear documentation.","solution":"def generate_note_hierarchy(notes, root_tag): Constructs a nested tag hierarchy starting from the root_tag. Args: notes (List[Dict[str, Any]]): A list of dictionaries where each dictionary represents a note. root_tag (str): The starting tag to build the hierarchy from. Returns: Dict[str, Any]: A dictionary representing the hierarchy of tags starting from the root_tag. def insert_into_hierarchy(hierarchy, path, note_id): Helper function to insert note into the hierarchy given its path. for tag in path: if tag not in hierarchy: hierarchy[tag] = {} hierarchy = hierarchy[tag] if \'_notes\' not in hierarchy: hierarchy[\'_notes\'] = [] hierarchy[\'_notes\'].append(note_id) filtered_notes = [note for note in notes if root_tag in note[\'tags\']] root_index = None for note in filtered_notes: if root_tag in note[\'tags\']: root_index = note[\'tags\'].index(root_tag) break if root_index is None: return {} hierarchy = {} for note in filtered_notes: path = note[\'tags\'][root_index + 1 :] insert_into_hierarchy(hierarchy, path, note[\'id\']) return hierarchy"},{"question":"# Problem Statement Create a `CircularQueue` class to implement a circular queue data structure. The queue should support the following operations efficiently: * `enqueue(item)`: Adds an item to the back of the queue. * `dequeue()`: Removes and returns the item from the front of the queue. Raises an `IndexError` if the queue is empty. * `is_empty()`: Returns `True` if the queue is empty, `False` otherwise. * `is_full()`: Returns `True` if the queue is full, `False` otherwise. * `peek()`: Returns the item from the front of the queue without removing it. Raises an `IndexError` if the queue is empty. * `clear()`: Empties the queue. # Input/Output Format * The `CircularQueue` class should take a single integer input `max_size` during instantiation indicating the maximum number of elements that the queue can hold. * Operations include `enqueue(item: T) -> None`, `dequeue() -> T`, `is_empty() -> bool`, `is_full() -> bool`, `peek() -> T`, and `clear() -> None`. # Constraints * You may assume that the item enqueued into the queue will always be valid and can be any type. * You must handle the scenario where `dequeue` or `peek` operations are called on an empty queue by raising an appropriate exception. * The queue must not accept new items if it is full; this can be checked using `is_full()` method. # Example Usage ```python queue = CircularQueue(3) queue.enqueue(1) queue.enqueue(2) print(queue.peek()) # Output: 1 print(queue.dequeue()) # Output: 1 print(queue.is_full()) # Output: False queue.enqueue(3) queue.enqueue(4) print(queue.is_full()) # Output: True print(queue.dequeue()) # Output: 2 queue.clear() # Clears the queue print(queue.is_empty()) # Output: True ```","solution":"class CircularQueue: def __init__(self, max_size): self.max_size = max_size self.queue = [None] * max_size self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, item): if self.is_full(): raise IndexError(\\"Queue is full.\\") self.queue[self.tail] = item self.tail = (self.tail + 1) % self.max_size self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty.\\") item = self.queue[self.head] self.queue[self.head] = None self.head = (self.head + 1) % self.max_size self.size -= 1 return item def is_empty(self): return self.size == 0 def is_full(self): return self.size == self.max_size def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty.\\") return self.queue[self.head] def clear(self): self.queue = [None] * self.max_size self.head = 0 self.tail = 0 self.size = 0"},{"question":"# Intermediate Coding Challenge: Enhance the Grid-Based Game Simulation Background You are working on a simulation for a grid-based game where entities known as `Players` move around and interact with each other. Each `Player` has a position on the grid as well as attributes such as `health` and `energy`. Currently, the simulation updates the game state in a series of discrete time steps. Movement and interactions between `Players` are processed in a manner that does not scale well with the number of `Players`, leading to O(N^2) time complexity for each update. Task Your goal is to enhance the efficiency of the game state update process while ensuring the correctness of the simulation. Specifically, you need to implement the following improvements: 1. Optimize the movement and interaction calculations using spatial partitioning such as a grid or quadtree to reduce redundant computations. 2. Ensure interactions between `Players`, such as combat or healing, are processed efficiently within local neighborhoods. Requirements 1. Implement spatial partitioning to optimize the update process for `Players` on the grid. 2. Adjust the `Player` class and game state update logic to utilize the spatial partitioning for efficient interaction handling. Inputs and Outputs - The input to your simulation will be a list of `Player` instances, each with attributes like position, health, and energy. - Output the updated positions, health, and energy of the `Players` after each time step. Constraints - You can assume the grid size to be in the range of 10x10 to 1,000x1,000 cells. - The number of `Players` will range from 10 to 10,000. - Time steps will be handled in a discrete manner, typically 1 second per step. Instructions 1. Refactor the `Player` class to include methods for interacting with other `Players`. 2. Develop a spatial partitioning system, such as a quadtree or a uniform grid, to efficiently manage the locations and interactions of `Players`. 3. Modify the game state update logic to utilize the spatial partitioning for efficient movement and interaction processing. Example The provided code includes a basic `Player` class and functions for initializing and running the game simulation. Ensure your solution integrates seamlessly with this setup, enhancing the performance without altering the game dynamics. ```python # Example Player class definition class Player: def __init__(self, id, x, y, health, energy): self.id = id self.x = x self.y = y self.health = health self.energy = energy def move(self, direction): # Implement movement logic pass def interact(self, other): # Implement interaction logic pass # Example grid setup and game state update function def setup_grid(grid_size, players): grid = [[[] for _ in range(grid_size)] for _ in range(grid_size)] for player in players: grid[player.x][player.y].append(player) return grid def update_game_state(grid, players): for player in players: # Process the player\'s move and interactions pass return grid # Ensure your implementation works within this general structure ``` Make sure to provide clear and efficient solutions that enhance the performance of the grid-based game simulation while maintaining the integrity of the gameplay.","solution":"class Player: def __init__(self, id, x, y, health, energy): self.id = id self.x = x self.y = y self.health = health self.energy = energy def move(self, dx, dy): self.x += dx self.y += dy def interact(self, other): # Example interaction logic (combat) if self.health > 0 and other.health > 0: damage = min(self.energy, other.health) other.health -= damage self.energy -= damage class GameGrid: def __init__(self, grid_size): self.grid_size = grid_size self.grid = [[[] for _ in range(grid_size)] for _ in range(grid_size)] def add_player(self, player): self.grid[player.x][player.y].append(player) def move_player(self, player, dx, dy): self.grid[player.x][player.y].remove(player) player.move(dx, dy) if player.x < 0: player.x = 0 elif player.x >= self.grid_size: player.x = self.grid_size - 1 if player.y < 0: player.y = 0 elif player.y >= self.grid_size: player.y = self.grid_size - 1 self.grid[player.x][player.y].append(player) def get_neighbors(self, x, y, radius=1): neighbors = [] for i in range(max(0, x - radius), min(self.grid_size, x + radius + 1)): for j in range(max(0, y - radius), min(self.grid_size, y + radius + 1)): if self.grid[i][j]: neighbors.extend(self.grid[i][j]) return neighbors def update_game_state(self, players): for player in players: # Example: moving the players randomly (for testing purposes) self.move_player(player, dx=1, dy=1) # Interaction for player in players: neighbors = self.get_neighbors(player.x, player.y) for neighbor in neighbors: if neighbor != player: player.interact(neighbor) return self.grid"},{"question":"# Problem Statement: You are tasked with developing a utility service for managing power consumption in a household. Each household appliance consumes a certain amount of power and runs for a specific duration. Your goal is to schedule the appliances in a way that minimizes the maximum power consumption at any given time, given that only a single appliance can be powered on at a time. # Requirements: 1. **Input**: * A list of appliances, each described by a tuple: (name, power, duration). * The total available time slot in which all appliances need to be scheduled. 2. **Output**: * A list of scheduled appliances\' names in the order they should be run to minimize the maximum power consumption. * The maximum power consumption reached during this optimal schedule. # Constraints: * The list of appliances will have a length between 1 to 100. * The power and the duration of each appliance will be between 1 and 100. * The total available time slot will be between the sum of all durations and twice that value. # Instructions: 1. Implement an `Appliance` class to encapsulate the attributes and behaviors of an appliance. 2. Create a function `build_appliances` that takes lists of names, powers, and durations, and returns a list of `Appliance` objects. 3. Define a function `minimize_max_power`, which schedules the appliances to minimize the maximum power consumption. * This function should accept the list of `Appliance` objects and the total available time slot, and return the scheduled appliances and the maximum power consumption. 4. Write test cases to verify the implementation. # Function Signatures: ```python class Appliance: def __init__(self, name, power, duration): pass def build_appliances(names, powers, durations): pass def minimize_max_power(appliances, total_time): pass ``` # Example: ```python if __name__ == \\"__main__\\": names = [\\"heater\\", \\"oven\\", \\"washer\\", \\"dryer\\"] powers = [5, 8, 6, 7] durations = [2, 3, 1, 4] total_time = 10 appliances = build_appliances(names, powers, durations) schedule, max_power = minimize_max_power(appliances, total_time) print(schedule) # [\\"washer\\", \\"heater\\", \\"oven\\", \\"dryer\\"] print(max_power) # 8 ```","solution":"class Appliance: def __init__(self, name, power, duration): self.name = name self.power = power self.duration = duration def build_appliances(names, powers, durations): return [Appliance(name, power, duration) for name, power, duration in zip(names, powers, durations)] def minimize_max_power(appliances, total_time): # Sort the appliances based on their duration then power. sorted_appliances = sorted(appliances, key=lambda a: (a.duration, a.power)) schedule = [appliance.name for appliance in sorted_appliances] max_power = max(appliance.power for appliance in sorted_appliances) return schedule, max_power"},{"question":"**Problem Description**: You are tasked with writing a function that simulates a basic inventory management system for a store. The store handles various types of items, each identified by a unique identifier. The system should be capable of adding items, checking the availability of specific items, and removing items when they are sold. **Function Specification**: Implement the class `InventoryManager`, which should have the following methods: 1. `__init__()`: Initializes an empty inventory. 2. `add_item(item_id: int, quantity: int) -> None`: Adds a specified quantity of an item to the inventory. If the item already exists, it should increase the quantity. 3. `remove_item(item_id: int, quantity: int) -> bool`: Removes a specified quantity of an item from the inventory. If the item does not exist or there is insufficient quantity, the operation should fail and return `False`. Otherwise, it should return `True`. 4. `check_availability(item_id: int) -> int`: Returns the quantity of the specified item available in the inventory. If the item does not exist, it should return `0`. **Constraints**: * Item IDs (`item_id`) will be positive integers. * Quantities (`quantity`) will be non-negative integers. * No two items will have the same ID. **Example Usage**: ```python inventory = InventoryManager() inventory.add_item(101, 5) inventory.add_item(102, 3) print(inventory.check_availability(101)) # Output: 5 print(inventory.check_availability(103)) # Output: 0 result = inventory.remove_item(101, 2) print(result) # Output: True print(inventory.check_availability(101)) # Output: 3 result = inventory.remove_item(102, 5) print(result) # Output: False print(inventory.check_availability(102)) # Output: 3 ``` **Class Signature**: ```python class InventoryManager: def __init__(self): # Implement the constructor pass def add_item(self, item_id: int, quantity: int) -> None: # Implement this method pass def remove_item(self, item_id: int, quantity: int) -> bool: # Implement this method pass def check_availability(self, item_id: int) -> int: # Implement this method pass ``` **Notes**: * Make sure to handle the edge cases where the item ID does not exist or the inventory is empty. * Optimize for quick lookup and update operations. * Assume inventory is initially empty upon instantiation of the `InventoryManager` class.","solution":"class InventoryManager: def __init__(self): self.inventory = {} def add_item(self, item_id: int, quantity: int) -> None: if item_id in self.inventory: self.inventory[item_id] += quantity else: self.inventory[item_id] = quantity def remove_item(self, item_id: int, quantity: int) -> bool: if item_id not in self.inventory: return False if self.inventory[item_id] < quantity: return False self.inventory[item_id] -= quantity if self.inventory[item_id] == 0: del self.inventory[item_id] return True def check_availability(self, item_id: int) -> int: return self.inventory.get(item_id, 0)"},{"question":"# Circular Array Rotation # Problem Statement You are given an array of integers and a series of rotation operations. Each rotation operation moves the elements of the array to the right by one position, with the last element wrapping around to the first position. After performing all the rotation operations, return the array in its final state. Implement the `CircularArrayRotation` class with the following methods: - `__init__(self, array: List[int])`: Initializes the array with the given list of integers. - `rotate(self, times: int)`: Rotates the array to the right by the specified number of times. - `get_array(self) -> List[int]`: Returns the current state of the array. Input - A list of integers `array` representing the initial state of the array. - Multiple integers `times` representing the number of times to perform the rotation operation. Output - Returns the array in its final state after all rotations are performed. # Example ```python arr = CircularArrayRotation([1, 2, 3, 4, 5]) arr.rotate(2) # After 2 rotations: [4, 5, 1, 2, 3] assert arr.get_array() == [4, 5, 1, 2, 3] arr.rotate(3) # After 3 more rotations: [1, 2, 3, 4, 5] assert arr.get_array() == [1, 2, 3, 4, 5] arr.rotate(10) # After 10 more rotations: [1, 2, 3, 4, 5] (because 10 rotations is equivalent to a full cycle) assert arr.get_array() == [1, 2, 3, 4, 5] ``` You need to complete the class `CircularArrayRotation` as per the specified requirements: ```python class CircularArrayRotation: def __init__(self, array: List[int]): # Store the initial array self.array = array def rotate(self, times: int): # Rotate the array to the right by `times` positions n = len(self.array) times = times % n # Reduce the number of rotations using modulo self.array = self.array[-times:] + self.array[:-times] def get_array(self) -> List[int]: # Return the current state of the array return self.array ``` # Constraints - `1 <= len(array) <= 10^5` - `-10^9 <= array[i] <= 10^9` - `0 <= times <= 10^9` # Notes - Optimize the rotation to efficiently handle very large `times` by reducing it modulo the array length. - Ensure your solution handles edge cases appropriately, such as when `times` is a multiple of the array length.","solution":"from typing import List class CircularArrayRotation: def __init__(self, array: List[int]): # Store the initial array self.array = array def rotate(self, times: int): # Rotate the array to the right by `times` positions n = len(self.array) if n == 0: return times = times % n # Reduce the number of rotations using modulo self.array = self.array[-times:] + self.array[:-times] def get_array(self) -> List[int]: # Return the current state of the array return self.array"},{"question":"# Maximal Independent Set Context: You are given an undirected graph represented as an adjacency matrix. The task is to find a maximal independent set (MIS) of this graph. An independent set is a set of vertices such that no two vertices in the set are adjacent. A maximal independent set is an independent set that is not a subset of any other independent set. Task: Write a function `maximal_independent_set(adjacency_matrix)` that takes an adjacency matrix representing an undirected graph and returns a list of nodes representing the maximal independent set. Input: * A 2D list `adjacency_matrix` (2 <= len(adjacency_matrix) <= 1000) where `adjacency_matrix[i][j]` is 1 if there is an edge between nodes `i` and `j`, and 0 otherwise. Output: * A list of integers representing the nodes in the maximal independent set. Constraints: * The given graph is undirected, meaning `adjacency_matrix[i][j] == adjacency_matrix[j][i]`. * There are no self-loops in the graph, meaning `adjacency_matrix[i][i] == 0` for all `i`. Example: ```python adjacency_matrix = [ [0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0] ] result = maximal_independent_set(adjacency_matrix) expected = [0, 2, 4] ``` # Notes: * The output maximal independent set is not necessarily unique. Different valid sets could be returned depending on the order of consideration of the nodes. * Ensure your implementation can handle large inputs within reasonable time and space limits.","solution":"def maximal_independent_set(adjacency_matrix): Function to find a maximal independent set in an undirected graph represented by an adjacency matrix. n = len(adjacency_matrix) visited = [False] * n independent_set = [] for i in range(n): if not visited[i]: # Include this node in the independent set independent_set.append(i) # Mark all its neighbors as visited for j in range(n): if adjacency_matrix[i][j] == 1: visited[j] = True return independent_set"},{"question":"# Problem Description Write a function `partition_list` that takes in a list of integers and a pivot integer. The function should partition the list into two sublists: one containing all elements less than the pivot, and the other containing all elements greater than or equal to the pivot. The function should return a tuple of the two lists. # Input * `input_list` (list): A list of integers. * `pivot` (int): An integer to partition the list. # Output * The function should return a tuple containing two lists: - The first list should contain all the integers from `input_list` that are less than the `pivot`. - The second list should contain all the integers from `input_list` that are greater than or equal to the `pivot`. # Constraints * The input list can be empty. * The pivot can be any integer (positive, negative, or zero). * The elements in the input list can be in any order. # Example ```python >>> partition_list([3, 8, 1, 5, 6, 2], 5) ([3, 1, 2], [8, 5, 6]) >>> partition_list([10, 20, 30, 40], 25) ([10, 20], [30, 40]) >>> partition_list([-10, -20, 0, 10, 20], 0) ([-10, -20], [0, 10, 20]) >>> partition_list([], 10) ([], []) ``` # Requirements * Implement the function `partition_list` that meets the specifications. * Ensure the code passes all edge cases and efficiently handles the constraints.","solution":"def partition_list(input_list, pivot): Partitions the input list into two lists based on the pivot. :param input_list: List of integers to be partitioned :param pivot: The pivot integer used for partitioning :return: A tuple containing two lists: first list with elements less than the pivot, second list with elements greater than or equal to the pivot less_than_pivot = [] greater_or_equal_pivot = [] for item in input_list: if item < pivot: less_than_pivot.append(item) else: greater_or_equal_pivot.append(item) return less_than_pivot, greater_or_equal_pivot"},{"question":"# Binary Search Tree Implementation **Context**: A Binary Search Tree (BST) is a data structure used for storing sorted data that allows for efficient insertion, deletion, and lookup operations. Each node in a BST has at most two children, typically referred to as the left and right children. For any node, all elements in its left subtree are less and all elements in its right subtree are greater. **Problem Statement**: Implement a Binary Search Tree with capabilities to insert elements, search for an element, and find the in-order traversal of the tree. **Class to Implement**: ```python class BinarySearchTree: def __init__(self): pass def insert(self, value: int) -> None: pass def search(self, value: int) -> bool: pass def in_order_traversal(self) -> list: pass ``` # Requirements: 1. **Class Attributes**: The class should maintain the structure of the BST. * `root`: The root node of the BST. 2. **Methods**: * `__init__()`: Initialize an empty BST. * `insert(value: int)`: Insert a value into the BST. * `search(value: int)`: Search for a value in the BST, returning `True` if found and `False` otherwise. * `in_order_traversal()`: Return a list of elements in the BST by performing an in-order traversal. 3. **Nodes**: Implement a helper class for the nodes of the BST. ```python class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None ``` 4. **Constraints**: * Assume the values to be inserted are unique. * Handle insertions and searches efficiently. * Ensure the in-order traversal outputs a sorted list of elements. 5. **Performance**: * Insert, search, and traversal operations should aim for optimal time complexity. * Handle an unbalanced tree structure gracefully. 6. **Edge Cases**: * Operations on an empty tree. * Insertion of elements resulting in an unbalanced tree. * Searching for a non-existing element. 7. **Coding Guidelines**: * Ensure the code is clean, with meaningful variable names. * Document your code with comments explaining the logic. * Handle potential exceptions within the class methods. **Example**: Your class should be able to perform operations as follows: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.search(4)) # Output: True print(bst.search(10)) # Output: False print(bst.in_order_traversal()) # Output: [2, 3, 4, 5, 6, 7, 8] ``` Implement the Binary Search Tree class to achieve the above functionality and test it thoroughly with different scenarios to ensure its correctness and efficiency.","solution":"class Node: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = Node(value) else: self._insert_recursively(self.root, value) def _insert_recursively(self, current: Node, value: int) -> None: if value < current.value: if current.left is None: current.left = Node(value) else: self._insert_recursively(current.left, value) else: if current.right is None: current.right = Node(value) else: self._insert_recursively(current.right, value) def search(self, value: int) -> bool: return self._search_recursively(self.root, value) def _search_recursively(self, current: Node, value: int) -> bool: if current is None: return False if current.value == value: return True elif value < current.value: return self._search_recursively(current.left, value) else: return self._search_recursively(current.right, value) def in_order_traversal(self) -> list: elements = [] self._in_order_traversal_recursively(self.root, elements) return elements def _in_order_traversal_recursively(self, current: Node, elements: list) -> None: if current is not None: self._in_order_traversal_recursively(current.left, elements) elements.append(current.value) self._in_order_traversal_recursively(current.right, elements)"},{"question":"# Question: Implement an Iterative and Recursive Solution to Reverse a String You are developing a text manipulation library and need to implement a utility to reverse a string. Your task is to create two functions: one that performs the reversal using an **iterative approach** and another that achieves the same result using a **recursive approach**. Function Signatures 1. `def reverse_string_iterative(s: str) -> str` 2. `def reverse_string_recursive(s: str) -> str` Requirements * The iterative function should use a loop to reverse the string. * The recursive function should reverse the string by successively manipulating divided parts of the string. * Both functions should handle empty strings and single-character strings correctly. Input * `s`: A string that needs to be reversed. Example: `\\"hello\\"` Output * Return the reversed string. Examples ```python # Iterative Examples assert reverse_string_iterative(\\"hello\\") == \\"olleh\\" assert reverse_string_iterative(\\"Python\\") == \\"nohtyP\\" assert reverse_string_iterative(\\"A\\") == \\"A\\" assert reverse_string_iterative(\\"\\") == \\"\\" # Recursive Examples assert reverse_string_recursive(\\"hello\\") == \\"olleh\\" assert reverse_string_recursive(\\"Python\\") == \\"nohtyP\\" assert reverse_string_recursive(\\"A\\") == \\"A\\" assert reverse_string_recursive(\\"\\") == \\"\\" ``` Constraints * Performance should be O(n) for both functions. * Space complexity should respect the nature of the iterative or recursive approach. * Ensure that your implementations handle edge cases, providing adequate test cases for validation. Hints * For the iterative approach, consider using a loop that swaps characters from both ends towards the center. * For the recursive approach, think about how you can reduce the problem size with each recursive call. Your task is to provide implementations of both functions, ensuring they conform to the given requirements.","solution":"def reverse_string_iterative(s: str) -> str: Reverses a string using an iterative approach. return s[::-1] def reverse_string_recursive(s: str) -> str: Reverses a string using a recursive approach. if len(s) <= 1: return s return s[-1] + reverse_string_recursive(s[:-1])"},{"question":"# Data Analysis and Visualization Task You are tasked with creating a function that analyzes and visualizes weather data from a local CSV file. The CSV file contains daily weather data with the following columns: \\"Date\\", \\"Temperature\\", \\"Precipitation\\", and \\"Wind Speed\\". You need to write a function named `analyze_weather_data` that performs the following operations: 1. **Read Weather Data**: Load the weather data from a specified CSV file. 2. **Calculate Averages**: Compute the average temperature, total precipitation, and average wind speed for the period covered by the CSV file. 3. **Generate Plot**: Create a time-series line plot of the temperature over time, with appropriate labels and titles. # Function Signature ```python def analyze_weather_data(csv_file: str, output_image: str) -> dict: Analyzes weather data and generates a time-series plot of temperature. Parameters: - csv_file (str): The path to the input CSV file containing weather data. - output_image (str): The path where the output plot image will be saved. Returns: - dict: A dictionary with keys \\"average_temperature\\", \\"total_precipitation\\", and \\"average_wind_speed\\". ``` # Requirements 1. **Load the CSV File**: - Read the CSV file into a pandas DataFrame. 2. **Calculate Averages and Totals**: - Compute the average temperature, total precipitation, and average wind speed. 3. **Generate Time-Series Plot**: - Create a line plot of the temperature over time. - Label the x-axis as \\"Date\\" and the y-axis as \\"Temperature\\". - Title the plot \\"Daily Temperature Over Time\\". - Save the plot as an image file in the specified location. # Constraints - Ensure the CSV file exists and is correctly formatted. - Handle missing values gracefully, e.g., by ignoring rows with missing data in calculations. - Use appropriate visualization libraries, such as matplotlib, to generate the plot. # Example ```python output = analyze_weather_data(\\"weather_data.csv\\", \\"temperature_plot.png\\") print(output) # Expected output: # { # \\"average_temperature\\": 23.5, # \\"total_precipitation\\": 45.2, # \\"average_wind_speed\\": 5.8 # } ``` # Notes - You may assume the \\"Date\\" column in the CSV file is in the format \\"YYYY-MM-DD\\". - Ensure proper formatting and error handling for robustness.","solution":"import pandas as pd import matplotlib.pyplot as plt def analyze_weather_data(csv_file: str, output_image: str) -> dict: Analyzes weather data and generates a time-series plot of temperature. Parameters: - csv_file (str): The path to the input CSV file containing weather data. - output_image (str): The path where the output plot image will be saved. Returns: - dict: A dictionary with keys \\"average_temperature\\", \\"total_precipitation\\", and \\"average_wind_speed\\". # Load the CSV file into a pandas DataFrame weather_data = pd.read_csv(csv_file) # Calculate average temperature, total precipitation, and average wind speed average_temperature = weather_data[\'Temperature\'].mean() total_precipitation = weather_data[\'Precipitation\'].sum() average_wind_speed = weather_data[\'Wind Speed\'].mean() # Generate a time-series line plot of temperature over time plt.figure(figsize=(10, 5)) plt.plot(weather_data[\'Date\'], weather_data[\'Temperature\'], marker=\'o\') plt.xlabel(\'Date\') plt.ylabel(\'Temperature\') plt.title(\'Daily Temperature Over Time\') plt.xticks(rotation=45) plt.tight_layout() plt.savefig(output_image) plt.close() return { \\"average_temperature\\": average_temperature, \\"total_precipitation\\": total_precipitation, \\"average_wind_speed\\": average_wind_speed }"},{"question":"# Task Scheduler Function Write a function in Python called `task_scheduler` that takes the following parameters: 1. `tasks` (List[str]): A list of tasks represented as single-character strings. 2. `n` (int): A non-negative integer representing the cooldown period intervals required between the same tasks. The function should return the least number of intervals needed to execute all tasks. Each task takes one interval to execute. # Constraints: * The length of `tasks` will be in the range [1, 10000]. * The value of `n` will be in the range [0, 100]. # Inputs: * `tasks`: A list of tasks, where each task is a single uppercase English letter. * `n`: A non-negative integer representing the cooldown period. # Outputs: * An integer representing the least number of intervals needed to execute all tasks. # Example: ```python print(task_scheduler([\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"], 2)) ``` Should return `8` because a possible scheduling sequence could be `A -> B -> idle -> A -> B -> idle -> A -> B`. # Hints: * You might want to use a max-heap (priority queue) to keep track of the most frequent tasks. * Use a queue to track cooldown periods for tasks. * Consider edge cases where no idle intervals are needed. ```python from collections import Counter import heapq def task_scheduler(tasks, n): task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 queue = [] while max_heap or queue: time += 1 if max_heap: count = heapq.heappop(max_heap) + 1 if count: queue.append((count, time + n)) if queue and queue[0][1] == time: heapq.heappush(max_heap, queue.pop(0)[0]) return time print(task_scheduler([\\"A\\", \\"A\\", \\"A\\", \\"B\\", \\"B\\", \\"B\\"], 2)) # Output should be 8 ```","solution":"from collections import Counter import heapq def task_scheduler(tasks, n): task_counts = Counter(tasks) max_heap = [-count for count in task_counts.values()] heapq.heapify(max_heap) time = 0 queue = [] while max_heap or queue: time += 1 if max_heap: count = heapq.heappop(max_heap) + 1 if count: queue.append((count, time + n)) if queue and queue[0][1] == time: heapq.heappush(max_heap, queue.pop(0)[0]) return time"},{"question":"# Prime Number Operations Scenario You are developing a set of utilities for working with prime numbers in a numerical analysis library. The utility set should help determine prime status, generate lists of primes, and find prime factors of numbers. Your task is to implement three main functions to achieve this: 1. Prime Check 2. Prime List Generation 3. Prime Factorization Input and Output Requirements You need to implement the following functions: 1. **`is_prime(n: int) -> bool`**: * **Input**: An integer `n` (greater than 1). * **Output**: `True` if `n` is a prime number; otherwise, `False`. 2. **`generate_primes(limit: int) -> list[int]`**: * **Input**: An integer `limit` (greater than 1). * **Output**: A list of all prime numbers less than or equal to `limit`. 3. **`prime_factors(n: int) -> list[int]`**: * **Input**: An integer `n` (greater than 1). * **Output**: A list of prime factors of `n`. Each function must validate that the input is an integer greater than 1. If the argument does not meet this criterion, appropriate exceptions should be thrown. Ensure the functions are optimized for readability and performance. Example Usage and Expected Results ```python assert is_prime(7) == True assert is_prime(4) == False assert generate_primes(10) == [2, 3, 5, 7] assert generate_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert prime_factors(28) == [2, 2, 7] assert prime_factors(84) == [2, 2, 3, 7] ``` Constraints * `2 <= n` * `2 <= limit` * Ensure efficient handling of large numbers, both in terms of time and space complexity. This assessment tests your ability to implement algorithms related to prime numbers, including checking prime status, generating lists of primes, and decomposing numbers into prime factors.","solution":"from math import isqrt def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") if n <= 3: return n > 1 if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes(limit: int) -> list[int]: Returns a list of all prime numbers less than or equal to limit. if limit <= 1: raise ValueError(\\"Limit must be greater than 1.\\") primes = [] sieve = [True] * (limit + 1) for num in range(2, limit + 1): if sieve[num]: primes.append(num) for multiple in range(num * num, limit + 1, num): sieve[multiple] = False return primes def prime_factors(n: int) -> list[int]: Returns a list of prime factors of n. if n <= 1: raise ValueError(\\"Input must be greater than 1.\\") factors = [] while n % 2 == 0: factors.append(2) n //= 2 for i in range(3, isqrt(n) + 1, 2): while n % i == 0: factors.append(i) n //= i if n > 2: factors.append(n) return factors"},{"question":"**Linked List Cyclic Check and Length Calculation** You are given the head node of a singly linked list. Write two functions to determine if the linked list contains a cycle and, if it does, calculate the length of the cycle. Implement the functions as described below: Function Definitions: 1. **`has_cycle(head: ListNode) -> bool`** - **Input**: head: ListNode - **Output**: Boolean value indicating whether the linked list contains a cycle. 2. **`cycle_length(head: ListNode) -> int`** - **Input**: head: ListNode - **Output**: Integer representing the length of the cycle if it exists. Return 0 if the list has no cycle. Constraints: - The number of nodes in the linked list is in the range [0, 10^4]. - Each node has a unique integer value. Example: Given the linked list with nodes: ``` 1 -> 2 -> 3 -> 4 -> 5 ^ | |_________| ``` 1. **Cycle Check**: `has_cycle(head)` would return `True` 2. **Cycle Length**: `cycle_length(head)` would return `3` Given another linked list with nodes: ``` 1 -> 2 -> 3 -> 4 -> 5 ``` 1. **Cycle Check**: `has_cycle(head)` would return `False` 2. **Cycle Length**: `cycle_length(head)` would return `0` Use the provided `ListNode` class for list construction: ```python from typing import Optional class ListNode: def __init__(self, x: int): self.val = x self.next = None ``` Implement the given functions considering edge cases and optimizing for the constraints provided.","solution":"from typing import Optional class ListNode: def __init__(self, x: int): self.val = x self.next = None def has_cycle(head: ListNode) -> bool: Detect if there is a cycle in the linked list. if not head: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def cycle_length(head: ListNode) -> int: Calculate the length of the cycle in the linked list. Return 0 if no cycle exists. if not head: return 0 slow = head fast = head # Detect if a cycle exists while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected, now calculate the length of the cycle length = 0 current = slow while True: current = current.next length += 1 if current == slow: return length return 0"},{"question":"# Coding Question Problem Statement You are tasked with writing a function `max_segment_sum` that finds the maximum sum of a contiguous subarray within a given array of integers. The function should be efficient and optimized for performance in terms of both time and space complexity. Input - A list of integers `arr` of length `n` (-10^5 <= arr[i] <= 10^5, 1 <= n <= 10^6), where `arr[i]` represents the elements of the array. Output - An integer representing the maximum sum of a contiguous subarray. Constraints - Your solution should be optimized for large arrays in terms of both time and space complexity. Performance Requirement - The runtime complexity of your solution should not exceed O(n). Examples 1. `max_segment_sum([-2,1,-3,4,-1,2,1,-5,4])` should return `6` (subarray: [4, -1, 2, 1]). 2. `max_segment_sum([1])` should return `1`. 3. `max_segment_sum([5,4,-1,7,8])` should return `23`. 4. `max_segment_sum([-1, -2, -3, -4])` should return `-1`. Function Signature ```python def max_segment_sum(arr: list) -> int: Returns the maximum sum of a contiguous subarray. pass ``` Additional Notes - Consider using Kadane\'s Algorithm to achieve the required performance.","solution":"def max_segment_sum(arr: list) -> int: Returns the maximum sum of a contiguous subarray. if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Designing a File Integrity Checker You are tasked with creating a file integrity checker tool that ensures the contents of files in a directory match their expected hashes. The tool should generate and verify hashes using the SHA-256 algorithm. Implement the following two functions: 1. **generate_file_hash**: This function should compute the SHA-256 hash of a given file and return it. * **Input**: A string representing the path to the file. * **Output**: A string representing the SHA-256 hash of the file. * **Constraints**: - Handle any errors related to file operations, such as file not found or read errors. - Ensure the function correctly reads large files without loading them entirely into memory. 2. **verify_files**: This function should compare the hashes of files in a directory against their expected values. The expected hashes will be provided in a dictionary where keys are file paths and values are the corresponding expected hashes. * **Input**: A dictionary where each key is a string representing the path to a file and each value is a string representing the expected SHA-256 hash. * **Output**: A dictionary where keys are file paths that failed verification and values are tuples containing the expected hash and the computed hash. * **Constraints**: - The function must handle directory traversal and verify each file specified in the input dictionary. - Only files that fail verification should be included in the output dictionary. # Example ```python # Example usage if __name__ == \\"__main__\\": # Assume we have the following files and their expected hashes expected_hashes = { \\"path/to/file1.txt\\": \\"5d41402abc4b2a76b9719d911017c592\\", \\"path/to/file2.txt\\": \\"5d41402abc4b2a76b9719d911017c592\\" } # Generate file hashes file1_hash = generate_file_hash(\\"path/to/file1.txt\\") file2_hash = generate_file_hash(\\"path/to/file2.txt\\") # Verify files failed_verifications = verify_files(expected_hashes) for file, (expected, actual) in failed_verifications.items(): print(f\\"File: {file} - Expected: {expected}, Actual: {actual}\\") ``` # Notes - Ensure robust error handling and consider edge cases such as missing or corrupt files. - For testing purposes, simulate different scenarios with varying file sizes and structures. - Performance considerations: handle large directories and files efficiently without excessive memory usage.","solution":"import hashlib import os def generate_file_hash(file_path): Computes the SHA-256 hash of a given file. Args: - file_path (str): Path to the file Returns: - str: SHA-256 hash of the file try: sha256 = hashlib.sha256() with open(file_path, \'rb\') as f: for chunk in iter(lambda: f.read(4096), b\'\'): sha256.update(chunk) return sha256.hexdigest() except (IOError, FileNotFoundError) as e: raise ValueError(f\\"Error reading file {file_path}: {e}\\") def verify_files(expected_hashes): Compares the hashes of files against their expected values. Args: - expected_hashes (dict): A dictionary with file paths as keys and their expected SHA-256 hashes as values Returns: - dict: A dictionary with file paths that failed verification as keys, and tuples of the form (expected_hash, computed_hash) as values failed_verifications = {} for file_path, expected_hash in expected_hashes.items(): try: actual_hash = generate_file_hash(file_path) if actual_hash != expected_hash: failed_verifications[file_path] = (expected_hash, actual_hash) except ValueError as e: print(e) failed_verifications[file_path] = (expected_hash, None) return failed_verifications"},{"question":"Task Create an additional question for a coding assessment that aligns with the existing set in terms of style, complexity, and scope. # Coding Assessment Question Context A rotated list, also known as a circular list, is an array that has been \\"rotated\\" from some initial sorted state. The list maintains its order and just appears to start from a different place. Task Implement a function `count_rotations` that computes the number of rotations applied to a given sorted list. Function Signature ```python def count_rotations(arr: List[int]) -> int: ``` Input - `arr` (List[int]): A non-negative list of integers that has been rotated. The list can be empty. Output - An integer representing the number of rotations applied to the given list. Example - Input: `arr = [4, 5, 1, 2, 3]` - Output: `2` - Explanation: The original sorted list `[1, 2, 3, 4, 5]` has been rotated 2 times to the right. - Input: `arr = [7, 9, 11, 15, 1, 3]` - Output: `4` - Explanation: The original sorted list `[1, 3, 7, 9, 11, 15]` has been rotated 4 times to the right. - Input: `arr = []` - Output: `0` - Explanation: An empty array has not been rotated. Constraints - Ensure the function handles the edge case of an empty list. - The list can contain duplicates. - The function should run efficiently within the given constraints. # Requirements * **Edge Cases**: Ensure that the function correctly handles an array with no rotations, an empty array, and single-element arrays. * **Performance**: The function should be efficient for longer arrays and handle rotations sensibly. Write a well-tested function to determine the number of rotations in a rotated sorted array. Make sure your implementation is robust and handles all edge cases.","solution":"from typing import List def count_rotations(arr: List[int]) -> int: Returns the number of rotations applied to a given sorted list. if not arr: return 0 n = len(arr) low, high = 0, n - 1 while low <= high: if arr[low] <= arr[high]: return low # the smallest element is at the start mid = (low + high) // 2 next_ = (mid + 1) % n prev = (mid - 1 + n) % n # Check if the mid element is the smallest element if arr[mid] <= arr[next_] and arr[mid] <= arr[prev]: return mid # Decide which half to continue with if arr[mid] <= arr[high]: high = mid - 1 elif arr[mid] >= arr[low]: low = mid + 1 return 0"},{"question":"# Question: Binary Search Tree (BST) Path Sum Calculation You are required to implement a class, `BinarySearchTree`, that represents a binary search tree. The class should allow inserting nodes, checking for a specific value, and calculating the sum of all node values along the path from the root to a given node. Your task: 1. Define the `TreeNode` data structure to represent each node in the BST. 2. Implement the `BinarySearchTree` class with the following functionalities: 1. **Initialization**: - `__init__(self)`: Initialize an empty BST. 2. **Insert Node**: - `insert(self, value: int) -> None`: Insert a node with the given value into the BST. 3. **Check for Value**: - `contains(self, value: int) -> bool`: Check if a node with the given value exists in the BST. 4. **Path Sum**: - `path_sum(self, value: int) -> int`: Calculate and return the sum of all node values along the path from the root to the node with the given value. If the node does not exist, raise a `ValueError`. Requirements: - Name of the class: `BinarySearchTree` - Ensure each method handles invalid input or cases gracefully. - The `path_sum` method should properly navigate the tree and sum the values along the path. Example Scenarios & Edge Cases: 1. **Edge Cases**: * Insertion of duplicate values (should be ignored). * Calculation of path sum when the node does not exist. * Ensuring that the BST properties (left child < parent < right child) are upheld during insertion. 2. **Example Usage**: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) print(bst.contains(7)) # Expected: True print(bst.contains(1)) # Expected: False print(bst.path_sum(7)) # Expected: 22 (10 + 5 + 7) print(bst.path_sum(3)) # Expected: 18 (10 + 5 + 3) try: print(bst.path_sum(11)) # Should raise ValueError except ValueError as e: print(e) # Expected: Node with value 11 does not exist in the tree. ``` Implement the class with all necessary methods and ensure it handles the provided examples and edge cases properly. --- This new question aligns with the existing set by maintaining a similar complexity level, covering fundamental BST operations, and posing a practical implementation challenge.","solution":"class TreeNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) elif value > node.value: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) # Ignore duplicates def contains(self, value: int) -> bool: return self._contains_recursive(self.root, value) def _contains_recursive(self, node, value): if node is None: return False if node.value == value: return True elif value < node.value: return self._contains_recursive(node.left, value) else: return self._contains_recursive(node.right, value) def path_sum(self, value: int) -> int: path = [] if not self._path_sum_recursive(self.root, value, path): raise ValueError(f\\"Node with value {value} does not exist in the tree.\\") return sum(path) def _path_sum_recursive(self, node, value, path): if node is None: return False path.append(node.value) if node.value == value: return True elif value < node.value: if self._path_sum_recursive(node.left, value, path): return True elif value > node.value: if self._path_sum_recursive(node.right, value, path): return True path.pop() # Backtrack if not found return False"},{"question":"# Problem Statement Your task is to develop a class `StringManipulation` that encapsulates various string processing functions. The class should implement methods that leverage the core algorithms described below. Make sure to handle all possible edge cases and errors appropriately. # Method Specifications: 1. **is_anagram(s1: str, s2: str) -> bool**: - Determines if two strings are anagrams of each other. - **Input**: Two strings `s1` and `s2`. - **Output**: A boolean value: `True` if `s1` and `s2` are anagrams, otherwise `False`. 2. **longest_palindromic_substring(s: str) -> str**: - Finds the longest palindromic substring within a given string. - **Input**: A single string `s`. - **Output**: A string representing the longest palindromic substring in `s`. 3. **count_vowels(s: str) -> int**: - Counts the number of vowels in a given string. - **Input**: A single string `s`. - **Output**: An integer representing the count of vowels in `s`. 4. **reverse_words(s: str) -> str**: - Reverses the order of words in a given string. - **Input**: A single string `s`. - **Output**: A string with the words in reverse order. - **Constraints**: Words are separated by single spaces, and there are no leading or trailing spaces. # Implementation Details - The class should handle edge cases such as empty strings, strings with only whitespace, and strings with special characters appropriately. - Use efficient algorithms to ensure that the methods perform well on larger input strings. - You may use internal or helper functions if needed, but they should be encapsulated within the class. - Ensure to handle invalid inputs where necessary, such as strings that do not meet the basic criteria. Here is an initial structure of the class for reference: ```python class StringManipulation: def is_anagram(self, s1: str, s2: str) -> bool: # Your code here pass def longest_palindromic_substring(self, s: str) -> str: # Your code here pass def count_vowels(self, s: str) -> int: # Your code here pass def reverse_words(self, s: str) -> str: # Your code here pass ``` **Note** - Maintain the provided method signatures. - Use Python\'s standard libraries for any auxiliary operations if needed. - For any invalid inputs, raise an appropriate exception. # Example Usage ```python sm = StringManipulation() print(sm.is_anagram(\\"listen\\", \\"silent\\")) # Output: True print(sm.longest_palindromic_substring(\\"babad\\")) # Output: \\"bab\\" or \\"aba\\" print(sm.count_vowels(\\"hello world\\")) # Output: 3 print(sm.reverse_words(\\"hello world\\")) # Output: \\"world hello\\" ```","solution":"class StringManipulation: def is_anagram(self, s1: str, s2: str) -> bool: Determines if two strings are anagrams of each other. return sorted(s1) == sorted(s2) def longest_palindromic_substring(self, s: str) -> str: Finds the longest palindromic substring within a given string. n = len(s) if n == 0: return \\"\\" def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(n): # Odd length palindromes tmp = expand_around_center(i, i) if len(tmp) > len(longest): longest = tmp # Even length palindromes tmp = expand_around_center(i, i + 1) if len(tmp) > len(longest): longest = tmp return longest def count_vowels(self, s: str) -> int: Counts the number of vowels in a given string. vowels = set(\\"aeiouAEIOU\\") return sum(1 for char in s if char in vowels) def reverse_words(self, s: str) -> str: Reverses the order of words in a given string. return \' \'.join(reversed(s.split()))"},{"question":"# Problem Statement: You are required to write a function that accepts a string consisting of lowercase letters and returns the first non-repeating character in it. If all characters are repeating, return an underscore (\'_\'). **Function Signature**: ```python def first_non_repeating_char(s: str) -> str: pass ``` # Input: - A string `s` (0 <= len(s) <= 10^5) consisting of lowercase English letters. # Output: - A single character which is the first non-repeating character in the string. # Constraints: - The function should traverse the string efficiently, ideally in linear time. - Take advantage of Python\'s data structures to keep track of character counts. # Example: ```python >>> first_non_repeating_char(\\"swiss\\") \'w\' >>> first_non_repeating_char(\\"programming\\") \'p\' >>> first_non_repeating_char(\\"aabbcc\\") \'_\' ``` # Description: Write a function `first_non_repeating_char` that takes a string `s` and returns the first character that does not repeat in the string. If all characters in the string are repeating, the function should return \'_\'. The function should be efficient, ideally having a linear time complexity with respect to the length of the string, and utilize appropriate data structures to track character occurrences.","solution":"def first_non_repeating_char(s: str) -> str: Returns the first non-repeating character in the string s. If all characters are repeating, returns \'_\'. from collections import Counter # Count the occurrence of each character in the string char_count = Counter(s) # Traverse the string in order and return first character with count of 1 for char in s: if char_count[char] == 1: return char # If no non-repeating character is found, return \'_\' return \'_\'"},{"question":"# 2D Matrix Rotation Objective: Design a Python function to rotate a 2D matrix by 90 degrees clockwise, evaluating understanding of matrix manipulation and in-place algorithm efficiency. Problem Description: You are tasked with writing a function `rotate_matrix(matrix: list[list[int]]) -> list[list[int]]` that takes a square 2D matrix (n x n) and rotates it 90 degrees clockwise. The rotation should be done in place if possible, optimizing your space complexity. Input: - `matrix`: A list of lists of integers representing the 2D matrix. The matrix size is `n x n`, where `n` is the number of rows and columns. Output: - The rotated 2D matrix as a list of lists of integers. Constraints: - The matrix will have a size of at least `2 x 2` and at most `50 x 50`. - Rotations should be achieved with minimal space complexity overhead. Requirements: 1. Implement the rotation in place to enhance space efficiency. 2. Handle edge cases where the matrix dimensions are at the smallest (2x2) or largest (50x50). 3. Provide detailed comments and documentation for the function. 4. Ensure that the function executes within a reasonable time frame for large matrices. Example Usage: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix(matrix) print(rotated_matrix) ``` Expected Output: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Implementation Strategy: 1. Transpose the matrix (convert rows to columns). 2. Reverse each row to achieve a 90-degree rotation. 3. Handle the rotation in place if possible. 4. Ensure code documentation is thorough and captures all edge cases. ```python def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotate the given n x n 2D matrix 90 degrees clockwise in place. :param matrix: List of lists representing the 2D matrix. :return: The rotated 2D matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix ``` Implement the function ensuring it passes all edge cases, such as minimum and maximum matrix sizes, and include appropriate comments for clarity.","solution":"def rotate_matrix(matrix: list[list[int]]) -> list[list[int]]: Rotates the given n x n 2D matrix 90 degrees clockwise in place. :param matrix: List of lists representing the 2D matrix. :return: The rotated 2D matrix. n = len(matrix) # Transpose the matrix (convert rows to columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to complete the rotation for i in range(n): matrix[i].reverse() return matrix"},{"question":"Implement a basic Expression Evaluator for arithmetic expressions involving addition, subtraction, multiplication, and division of integers. The input will be a string containing a valid arithmetic expression, and your task is to evaluate and return the result. # Implementation Details Implement the function `evaluate_expression(expression: str) -> int` that supports the following operations: 1. Parsing and evaluating the given string arithmetic expression which may contain: - Addition (`+`) - Subtraction (`-`) - Multiplication (`*`) - Division (`/`) 2. The expression may contain parentheses to indicate precedence. 3. The function should handle integer arithmetic only. 4. Division should be integer division. # Constraints - The input string will always be a valid arithmetic expression. - The input string can contain spaces, which must be ignored. - Division by zero is guaranteed to not occur in the input. - The maximum length of the expression will not exceed 1000 characters. # Example ```python assert evaluate_expression(\\"3 + 5 * 2\\") == 13 assert evaluate_expression(\\"(1 + 2) * (3 + 4)\\") == 21 assert evaluate_expression(\\"4 + 18 / (9 - 3)\\") == 7 assert evaluate_expression(\\"10 - 2 * 5 + 3\\") == 3 assert evaluate_expression(\\"20 / 4 / 2 + 1\\") == 3 ``` # Notes - You can use helper functions to handle different parts of the parsing and evaluation process. - Ensure proper handling of operator precedence and parentheses. - Efficiently parsing and evaluating the expression is crucial for performance. This problem tests your understanding of expression evaluation using infix notation, operator precedence, and handling of integer arithmetic in a programming environment.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a basic arithmetic expression with integers and returns the result. Supports +, -, *, / operators and parentheses. Spaces in the expression are ignored. def operate(a, b, operator): if operator == \'+\': return a + b elif operator == \'-\': return a - b elif operator == \'*\': return a * b elif operator == \'/\': return a // b def precedence(operator): if operator in (\'+\', \'-\'): return 1 elif operator in (\'*\', \'/\'): return 2 return 0 def apply_operator(operators, values): operator = operators.pop() right = values.pop() left = values.pop() values.append(operate(left, right, operator)) def evaluate(tokens): values = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == \' \': i += 1 continue if tokens[i] == \'(\': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while i < len(tokens) and tokens[i].isdigit(): val = val * 10 + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == \')\': while operators and operators[-1] != \'(\': apply_operator(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(tokens[i])): apply_operator(operators, values) operators.append(tokens[i]) i += 1 while operators: apply_operator(operators, values) return values[-1] return evaluate(expression)"},{"question":"# Problem Statement You are given a list of strings where each string represents a different word. Each word contains lowercase letters and has a length of at least 1 and at most 20. Your task is to implement a function `find_longest_string_without_repeating_characters` that finds the longest word in the list that does not contain any repeating characters. If there are multiple words with the same maximum length, return the one which appears first in the list. If no such word exists, return an empty string. **Function Signature:** ```python def find_longest_string_without_repeating_characters(words: List[str]) -> str: pass ``` **Input:** * `words`: A list of words (0 <= len(words) <= 10^4). **Output:** * A string which is the longest word in the list that does not contain any repeating characters, or an empty string if no such word exists. **Constraints:** - Each word contains only lowercase English letters. - Length of each word is between 1 and 20. **Example:** ```python assert find_longest_string_without_repeating_characters([\\"abc\\", \\"deefg\\", \\"abcdefgh\\", \\"aabbcc\\"]) == \\"abcdefgh\\" assert find_longest_string_without_repeating_characters([\\"a\\", \\"b\\", \\"ab\\", \\"aa\\", \\"aba\\"]) == \\"ab\\" assert find_longest_string_without_repeating_characters([\\"aa\\", \\"bb\\", \\"cc\\"]) == \\"\\" assert find_longest_string_without_repeating_characters([]) == \\"\\" assert find_longest_string_without_repeating_characters([\\"qwerty\\", \\"asdfgh\\", \\"zxcvbn\\"]) == \\"qwerty\\" ``` **Explanation**: The function iterates through the list of words, checking each word to see if it contains any repeating characters. It keeps track of the longest such word found during the iteration. If no word without repeating characters is found, the function returns an empty string. The solution should handle edge cases such as empty lists and words of varying lengths efficiently.","solution":"from typing import List def find_longest_string_without_repeating_characters(words: List[str]) -> str: def has_unique_characters(word: str) -> bool: return len(set(word)) == len(word) longest_word = \\"\\" for word in words: if has_unique_characters(word): if len(word) > len(longest_word): longest_word = word return longest_word"},{"question":"# Coding Assessment Question Problem Description You are required to create a function that mimics the behavior of a basic stack data structure with an additional feature to return the minimum element in the stack efficiently. Write a class `MinStack` that supports the following operations: - `push(x)` -- Push element x onto stack. - `pop()` -- Removes the element on top of the stack. - `top()` -- Get the top element. - `get_min()` -- Retrieve the minimum element in the stack. Requirements 1. Implement the class `MinStack`: - The `push` method should add an element to the stack. - The `pop` method should remove the element on the top of the stack. - The `top` method should return the top element of the stack. - The `get_min` method should return the current minimum element in the stack. 2. The stack should support the operations in constant time and space complexity should be minimized for `get_min`. Input Format - Multiple method calls will be made on an instance of `MinStack` including `push`, `pop`, `top`, and `get_min` with appropriate parameters. Output Format - The `top` and `get_min` methods should return their respective results. Example ```python min_stack = MinStack() min_stack.push(-2) min_stack.push(0) min_stack.push(-3) print(min_stack.get_min()) # Returns: -3 min_stack.pop() print(min_stack.top()) # Returns: 0 print(min_stack.get_min()) # Returns: -2 ``` Additional Notes - It is guaranteed that `get_min` will be called only on non-empty stacks. - Ensure that your implementation is efficient and meets the constant time complexity requirement for the operations.","solution":"class MinStack: def __init__(self): Initialize your data structure here. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Push element x onto stack. self.stack.append(x) # If min_stack is empty or the new element is smaller than or equal to the current minimum if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on top of the stack. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Get the top element. if self.stack: return self.stack[-1] return None # Or raise an exception if the stack is empty def get_min(self) -> int: Retrieve the minimum element in the stack. if self.min_stack: return self.min_stack[-1] return None # Or raise an exception if the stack is empty"},{"question":"**Problem Statement:** You are given a string composed of lowercase English letters. Your task is to implement the `anagram_indices` function to find all starting indices in the string where an anagram of a given pattern `p` appears. The function should return a list of starting indices of the anagrams of the pattern within the given string `s`. # Function Signature: ```python def anagram_indices(s: str, p: str) -> list[int]: pass ``` # Input: * A string `s` of length `N` where `1 <= N <= 10^5`, composed of lowercase English letters. * A string `p` of length `M` where `1 <= M <= 10^5`, composed of lowercase English letters. # Output: * A list of integers representing the starting indices of all anagrams of `p` in `s`. # Constraints: * Your solution should aim for `O(N + M)` time complexity, and use `O(1)` additional space beyond the output list. * Handle edge cases like when `M > N`. # Sample Input: ```python s = \\"cbaebabacd\\" p = \\"abc\\" ``` # Sample Output: ```python [0, 6] ``` # Sample Input: ```python s = \\"abab\\" p = \\"ab\\" ``` # Sample Output: ```python [0, 1, 2] ``` # Detailed Requirements: 1. **Frequency Count:** * Build a frequency count table for the characters in `p`. * Use a sliding window technique to maintain a frequency count table of characters in the current window of `s`. 2. **Sliding Window:** * Slide the window over `s` and adjust the frequency table accordingly. * For each position of the window, compare the frequency count table with that of `p`. 3. **Comparison:** * If at any window position the frequency table matches that of `p`, record the starting index of that window. 4. **Edge Cases:** * If `p` is longer than `s`, return an empty list. * Handle cases with non-overlapping and overlapping anagrams efficiently. Implement the function `anagram_indices` accordingly.","solution":"from collections import Counter def anagram_indices(s: str, p: str) -> list[int]: if len(p) > len(s): return [] p_count = Counter(p) window_count = Counter(s[:len(p)]) result = [] for i in range(len(s) - len(p) + 1): if i == 0: if window_count == p_count: result.append(i) else: start_char = s[i - 1] end_char = s[i + len(p) - 1] window_count[end_char] += 1 if window_count[start_char] == 1: del window_count[start_char] else: window_count[start_char] -= 1 if window_count == p_count: result.append(i) return result"},{"question":"# Unique String Combinations **Overview**: A combination of letters is considered unique if it doesn\'t repeat any character and uses all characters in the given string. Given a string, generate all possible unique combinations. **Task**: Write a function `generate_unique_combinations(s: str) -> List[str]` that returns a list of all possible unique combinations of the characters in the input string `s`. **Function Signature**: ```python def generate_unique_combinations(s: str) -> List[str]: ``` **Input**: - `s` (string): Input string where all characters are unique. **Output**: - List of strings: A list containing all unique combinations of the characters in the input string. **Example**: ```python >>> generate_unique_combinations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] ``` **Constraints**: - `1 <= len(s) <= 9` - The string `s` contains only unique characters, no duplicates. **Requirements**: 1. Your function should include proper validation to handle invalid input and raise appropriate errors. 2. The solution should generate combinations efficiently and handle strings containing up to 9 characters. **Hints**: - You can use backtracking to generate all combinations. - Python\'s itertools library might be useful in generating permutations. **Scenario/Context**: Imagine you are working on a project that involves generating all possible orders for a set of items represented by unique characters. Your task is to implement the function that efficiently lists all possible unique combinations of these items.","solution":"from itertools import permutations from typing import List def generate_unique_combinations(s: str) -> List[str]: Returns all unique combinations of characters in the input string s. if len(s) < 1 or len(s) > 9: raise ValueError(\\"Input string must have a length between 1 and 9 inclusive.\\") return [\'\'.join(p) for p in permutations(s)]"},{"question":"# Coding Challenge: Merge Intervals and Interval Intersection Context: You are tasked with implementing functions to handle operations on intervals often used in computational geometry and calendar applications. These functions should manage merging overlapping intervals and finding the intersection between two sets of intervals. # Function 1: Merge Intervals **Description**: Write a function, `merge_intervals(intervals: List[List[int]]) -> List[List[int]]`, that takes a list of intervals and merges all overlapping intervals. - **Input**: A list of intervals where each interval is a list of two integers `[start, end]`. - `0 ≤ start ≤ end ≤ 10^6` - **Output**: A list of merged intervals. - **Constraints**: - Merge overlapping intervals into a single interval. - Ensure the result is sorted by the start time of each interval. # Function 2: Interval Intersection **Description**: Write a function, `interval_intersection(A: List[List[int]], B: List[List[int]]) -> List[List[int]]`, that takes two lists of intervals `A` and `B`, and returns a list of their intersections. - **Input**: Two lists of intervals `A` and `B`, where each interval is a list of two integers `[start, end]`. - `0 ≤ start ≤ end ≤ 10^6` - **Output**: A list of intervals representing the intersection between intervals from `A` and `B`. - **Constraints**: - Ensure the result is sorted by the start time of each interval. - Handle cases where there are no intersections gracefully. ```python from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges a list of intervals and returns a list of the merged intervals. pass # Implement the function def interval_intersection(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Finds the intersection of two lists of intervals and returns a list of the intersected intervals. pass # Implement the function # Example Usage: # merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) -> [[1, 6], [8, 10], [15, 18]] # interval_intersection([[1, 3], [5, 9]], [[2, 5], [7, 10]]) -> [[2, 3], [5, 5], [7, 9]] ``` Notes: 1. Ensure your solutions are optimized for the given constraints. 2. Your functions should include necessary input validation and handle edge cases appropriately.","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges a list of intervals and returns a list of the merged intervals. if not intervals: return [] intervals.sort(key=lambda x: x[0]) merged_intervals = [intervals[0]] for current in intervals[1:]: last_merged = merged_intervals[-1] if current[0] <= last_merged[1]: last_merged[1] = max(last_merged[1], current[1]) else: merged_intervals.append(current) return merged_intervals def interval_intersection(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: Finds the intersection of two lists of intervals and returns a list of the intersected intervals. intersections = [] i, j = 0, 0 while i < len(A) and j < len(B): a_start, a_end = A[i] b_start, b_end = B[j] if a_start <= b_end and b_start <= a_end: start = max(a_start, b_start) end = min(a_end, b_end) intersections.append([start, end]) if a_end < b_end: i += 1 else: j += 1 return intersections"},{"question":"# Question Scenario: As part of a software development team, you are tasked with handling a sequence of operations on a dynamic array. This dynamic array should support adding an element to the end, removing the last element, fetching the last element, and checking its current size. Given this requirement, you decide to implement a custom stack data structure using a list to support these stack-like operations efficiently. Task: Implement the following class and methods: 1. **class DynamicArrayStack**: - Represents the stack with methods to `push`, `pop`, `peek`, and `size`. 2. **push(self, value: int) -> None**: - Adds the `value` to the top of the stack. 3. **pop(self) -> Optional[int]**: - Removes and returns the top element of the stack. If the stack is empty, return `None`. 4. **peek(self) -> Optional[int]**: - Returns the top element of the stack without removing it. If the stack is empty, return `None`. 5. **size(self) -> int**: - Returns the number of elements in the stack. Class Definitions: ```python class DynamicArrayStack: def __init__(self): pass def push(self, value: int) -> None: pass def pop(self) -> Optional[int]: pass def peek(self) -> Optional[int]: pass def size(self) -> int: pass ``` Constraints: - Assume all values to be pushed are integers. - Stack operations (`push`, `pop`, `peek`, `size`) should ideally run in O(1) time. Example: ```python stack = DynamicArrayStack() stack.push(10) stack.push(20) assert stack.peek() == 20 assert stack.size() == 2 assert stack.pop() == 20 assert stack.size() == 1 assert stack.peek() == 10 assert stack.pop() == 10 assert stack.size() == 0 assert stack.pop() is None ``` Performance Requirements: - Ensure all stack operations are performed efficiently, with constant time complexity wherever applicable. [End of Questions]","solution":"class DynamicArrayStack: def __init__(self): self.stack = [] def push(self, value: int) -> None: self.stack.append(value) def pop(self) -> int: if self.stack: return self.stack.pop() return None def peek(self) -> int: if self.stack: return self.stack[-1] return None def size(self) -> int: return len(self.stack)"},{"question":"# Problem Statement: Implement a function that simulates a dynamic user login system for an application, where users register with a unique username and password, and then attempt to log in. Your function should handle registration, login, and track invalid login attempts. # Requirements 1. Implement a class `UserSystem` that supports user registration (with username and password) and login functionality. 2. The class should have the following methods: - `register(username: str, password: str) -> bool`: Registers a new user with the given username and password. Returns `True` if the registration is successful, `False` if the username already exists. - `login(username: str, password: str) -> bool`: Returns `True` if login is successful, `False` if login fails. It also keeps track of failed login attempts. - `get_failed_login_attempts(username: str) -> int`: Returns the number of failed login attempts for the given username. Here is an example of how the class should be used: ```python user_system = UserSystem() print(user_system.register(\\"user1\\", \\"password123\\")) # True print(user_system.register(\\"user1\\", \\"password456\\")) # False print(user_system.login(\\"user1\\", \\"password123\\")) # True print(user_system.login(\\"user1\\", \\"wrongpassword\\")) # False print(user_system.get_failed_login_attempts(\\"user1\\")) # 1 print(user_system.login(\\"user1\\", \\"password123\\")) # True print(user_system.get_failed_login_attempts(\\"user1\\")) # 1 print(user_system.login(\\"unknown\\", \\"password\\")) # False print(user_system.get_failed_login_attempts(\\"unknown\\")) # 1 (even though \\"unknown\\" isn\'t registered) ``` # Constraints: - `username` and `password` are non-empty strings. - Passwords should be case-sensitive. - Track login attempts for registered users and unregistered usernames. - Ensure thread-safety for multi-threaded environments (optional but recommended for advanced implementations). # Input: - `register(username: str, password: str) -> bool` - `login(username: str, password: str) -> bool` - `get_failed_login_attempts(username: str) -> int` # Output: - `register` returns `True` or `False` - `login` returns `True` or `False` - `get_failed_login_attempts` returns an integer # Example: ```python user_system = UserSystem() print(user_system.register(\\"user1\\", \\"password123\\")) # True print(user_system.register(\\"user1\\", \\"password456\\")) # False print(user_system.login(\\"user1\\", \\"password123\\")) # True print(user_system.login(\\"user1\\", \\"wrongpassword\\")) # False print(user_system.get_failed_login_attempts(\\"user1\\")) # 1 print(user_system.login(\\"user1\\", \\"password123\\")) # True print(user_system.get_failed_login_attempts(\\"user1\\")) # 1 print(user_system.login(\\"unknown\\", \\"password\\")) # False print(user_system.get_failed_login_attempts(\\"unknown\\")) # 1 ```","solution":"class UserSystem: def __init__(self): self.users = {} self.failed_attempts = {} def register(self, username: str, password: str) -> bool: if username in self.users: return False self.users[username] = password return True def login(self, username: str, password: str) -> bool: if username not in self.users or self.users[username] != password: if username not in self.failed_attempts: self.failed_attempts[username] = 0 self.failed_attempts[username] += 1 return False return True def get_failed_login_attempts(self, username: str) -> int: return self.failed_attempts.get(username, 0)"},{"question":"# Question: Calculate Catalans Number You are required to implement a function that calculates the `n`th Catalan number. Catalan numbers form a sequence of natural numbers that have many applications in combinatorial mathematics, such as counting the number of certain types of lattice paths, binary trees, or valid sequences of parentheses. The `n`th Catalan number can be expressed directly in terms of binomial coefficients: [ C(n) = frac{1}{n+1}binom{2n}{n} ] Where: [ binom{2n}{n} = frac{(2n)!}{n!(n!)} ] Write a function `catalan_number(n: int) -> int` that calculates the `n`th Catalan number using the above formula. **Function Signature:** ```python import math def catalan_number(n: int) -> int: pass ``` **Input:** - `n` (int): A non-negative integer representing the sequence position (0 ≤ n). **Output:** - An integer representing the `n`th Catalan number. **Constraints:** - The input will always satisfy the constraints (0 ≤ n). **Examples:** ```python catalan_number(0) -> 1 catalan_number(3) -> 5 catalan_number(4) -> 14 catalan_number(5) -> 42 ``` **Explanation:** - For `n = 0`, the 0th Catalan number is 1. - For `n = 3`, the 3rd Catalan number is 5. - For `n = 4`, the 4th Catalan number is 14. - For `n = 5`, the 5th Catalan number is 42. Write a function implementing this logic by leveraging the factorial calculation, considering the proper handling of edge cases, performance, and correctness.","solution":"import math def catalan_number(n: int) -> int: Calculate the nth Catalan number using binomial coefficients. Parameters: n (int): The sequence position of the Catalan number to calculate. Returns: int: The nth Catalan number. return math.comb(2 * n, n) // (n + 1)"},{"question":"# Recursive Maze Solver Given a rectangular grid-based maze, your task is to determine if there is a path from a starting point to an ending point using a recursive approach. The maze consists of open spaces and obstacles. # Maze Representation: - The maze is represented by a 2D list of characters. - `\'S\'` represents the starting point. - `\'E\'` represents the ending point. - `\'.\'` represents open spaces where movement is allowed. - `\'#\'` represents obstacles where movement is not allowed. # Movement Rules: - The allowed movements are up, down, left, and right. # Input * The function `can_solve_maze(maze)` will receive a 2D list representing the grid-based maze. # Output * The function should return `True` if there is a path from \'S\' to \'E\'. Otherwise, return `False`. # Constraints * The maze will have dimensions ranging from 2x2 up to 50x50. * There will be exactly one \'S\' and one \'E\' in the maze. * It is guaranteed that the maze\'s perimeter will surround the \'S\' and \'E\' characters. * There will be paths or walls surrounding the \'S\' and \'E\'. # Example ```python def can_solve_maze(maze): # Implement this function pass # Test cases maze1 = [ [\'S\', \'.\', \'#\'], [\'#\', \'.\', \'#\'], [\'#\', \'.\', \'E\'] ] maze2 = [ [\'S\', \'#\', \'#\'], [\'#\', \'.\', \'#\'], [\'#\', \'.\', \'E\'] ] maze3 = [ [\'S\', \'.\', \'.\'], [\'#\', \'#\', \'.\'], [\'#\', \'.\', \'E\'] ] print(can_solve_maze(maze1)) # Output should be True print(can_solve_maze(maze2)) # Output should be False print(can_solve_maze(maze3)) # Output should be True ``` **Explanation**: 1. In the first maze, there is a clear path from \'S\' to \'E\' (down, down, right). 2. In the second maze, there is no valid path from \'S\' to \'E\'. 3. In the third maze, a valid path exists from \'S\' to \'E\' by navigating around the obstacles. Your function should correctly handle various maze layouts and utilize recursion effectively to explore potential paths.","solution":"def can_solve_maze(maze): def find_start(maze): for i in range(len(maze)): for j in range(len(maze[i])): if maze[i][j] == \'S\': return i, j return None def is_in_bound(maze, i, j): return 0 <= i < len(maze) and 0 <= j < len(maze[0]) def dfs(maze, visited, i, j): if not is_in_bound(maze, i, j) or maze[i][j] == \'#\' or visited[i][j]: return False if maze[i][j] == \'E\': return True visited[i][j] = True directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] for di, dj in directions: ni, nj = i + di, j + dj if dfs(maze, visited, ni, nj): return True visited[i][j] = False return False start = find_start(maze) if not start: return False visited = [[False for _ in range(len(maze[0]))] for _ in range(len(maze))] return dfs(maze, visited, start[0], start[1])"},{"question":"# String Compression Algorithm **Problem Statement:** As a software engineer working with data compression algorithms, you need to design an efficient algorithm to compress a string. The compression mechanism is straightforward: it counts consecutive characters and appends the count after each character. If the compressed string length is equal to or greater than the original string, you should return the original string. **Requirements:** 1. Implement a function `compress_string` that takes as input a string (`input_string`). 2. The function should return the compressed version of the string or the original string if the compression does not reduce the length. **Function Signature:** ```python def compress_string(input_string: str) -> str: ... ``` **Input:** - `input_string` : A non-empty string containing only uppercase and lowercase English letters. **Output:** - Compressed string or the original string depending on which is shorter. **Constraints:** - The string length will not exceed 10,000 characters. **Performance Requirements:** 1. The algorithm should run in linear time regarding the length of the string. **Example:** ```python input_string = \\"aabcccccaaa\\" result = compress_string(input_string) print(result) # Expected output: # \\"a2b1c5a3\\" ``` ```python input_string = \\"abcde\\" result = compress_string(input_string) print(result) # Expected output: # \\"abcde\\" ``` **Note:** - Assume all input strings are non-empty and consist of only English uppercase and lowercase letters.","solution":"def compress_string(input_string: str) -> str: if not input_string: return \\"\\" compressed = [] count = 1 current_char = input_string[0] for char in input_string[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Question: Find Longest Subarray with Sum Less Than or Equal to K You are given an array of `n` positive integers and an integer `K`. Write a function to find the length of the longest contiguous subarray that has a sum of elements less than or equal to `K`. # Input * An array of `n` positive integers (1 ≤ n ≤ 10^5, each integer is ≤ 10^4). * An integer `K` (1 ≤ K ≤ 10^9). # Output * Return an integer representing the length of the longest subarray with a sum ≤ `K`. # Constraints * Optimize the solution to run in O(n) time complexity. # Example Input ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] K = 15 ``` Output ```python 5 ``` Input ```python arr = [1, 4, 3, 2, 5, 7] K = 10 ``` Output ```python 4 ``` # Function Signature ```python def find_longest_subarray_length(arr: List[int], K: int) -> int: pass ```","solution":"from typing import List def find_longest_subarray_length(arr: List[int], K: int) -> int: n = len(arr) max_length = 0 current_sum = 0 left = 0 for right in range(n): current_sum += arr[right] while current_sum > K and left <= right: current_sum -= arr[left] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Problem Statement You are given a list of integers and asked to rearrange them so that all occurrences of the same integer appear together while maintaining the relative order of different integers. Write a function `group_identical_integers` that accomplishes this. # Function Signature ```python def group_identical_integers(nums: list[int]) -> list[int]: Given a list of integers, rearrange the list so that all occurrences of the same integer appear together while maintaining the relative order of different integers. Args: - nums (list[int]): list of integers. Returns: - list[int]: list of integers where identical integers are grouped together. Examples: >>> group_identical_integers([4, 2, 1, 2, 1, 4, 1, 4]) [4, 4, 4, 2, 2, 1, 1, 1] >>> group_identical_integers([1]) [1] >>> group_identical_integers([]) [] >>> group_identical_integers([3, 3, 2, 2, 1, 1]) [3, 3, 2, 2, 1, 1] >>> group_identical_integers([6, 5, 6, 6, 5, 7]) [6, 6, 6, 5, 5, 7] pass ``` # Constraints - Your function should handle input lists with up to (10^4) elements. - Elements of the list can be any integer (positive, negative, or zero). - Aim for a solution with linear time complexity (O(N)) and linear space complexity (O(N)). **Note**: Your implementation will be evaluated on both correctness and efficiency. Make sure to handle edge cases such as an empty list or a list with only one element. Using a data structure like a dictionary to keep track of the order of first occurrences of each integer may help maintain the relative order while grouping.","solution":"def group_identical_integers(nums: list[int]) -> list[int]: Given a list of integers, rearrange the list so that all occurrences of the same integer appear together while maintaining the relative order of different integers. Args: - nums (list[int]): list of integers. Returns: - list[int]: list of integers where identical integers are grouped together. Examples: >>> group_identical_integers([4, 2, 1, 2, 1, 4, 1, 4]) [4, 4, 4, 2, 2, 1, 1, 1] >>> group_identical_integers([1]) [1] >>> group_identical_integers([]) [] >>> group_identical_integers([3, 3, 2, 2, 1, 1]) [3, 3, 2, 2, 1, 1] >>> group_identical_integers([6, 5, 6, 6, 5, 7]) [6, 6, 6, 5, 5, 7] from collections import defaultdict # Dictionary to store lists of integers grouped = defaultdict(list) # Ordered list to store the order of first occurrences order = [] for num in nums: if not grouped[num]: # If it\'s the first occurrence of the number, add to the order order.append(num) # Append the number to its corresponding list in grouped grouped[num].append(num) # Final result to concatenate all grouped lists in the order they appeared result = [] for num in order: result.extend(grouped[num]) return result"},{"question":"# Problem Statement You are given a series of timestamps representing the log-in times of users in a system. Each timestamp is a string in the format \\"YYYY-MM-DD HH:MM:SS\\". Your task is to write a function to calculate the total number of full hours between the earliest and the latest timestamps. # Function Signature ```python def calculate_full_hours(timestamps: List[str]) -> int: pass ``` # Input * `timestamps (List[str])`: A list of strings representing the timestamps; each string follows the format \\"YYYY-MM-DD HH:MM:SS\\". # Output * Returns the total number of full hours as an integer. # Constraints * The list of timestamps will contain at least two timestamps. * All timestamps are valid and follow the same format \\"YYYY-MM-DD HH:MM:SS\\". * Timestamps are in the same time zone. # Requirements * Your solution must accurately calculate the number of full hours between the earliest and latest timestamps. * Performance considerations: Ensure that your solution efficiently handles a large list of timestamps. # Example ```python >>> calculate_full_hours([\\"2023-03-18 12:00:00\\", \\"2023-03-18 14:59:59\\", \\"2023-03-18 13:30:00\\"]) 2 >>> calculate_full_hours([\\"2023-03-18 12:00:00\\", \\"2023-03-18 15:59:00\\"]) 3 >>> calculate_full_hours([\\"2023-03-18 12:00:00\\", \\"2023-03-18 12:59:59\\"]) 0 >>> calculate_full_hours([\\"2023-03-18 23:00:00\\", \\"2023-03-19 01:45:00\\", \\"2023-03-19 00:15:00\\"]) 2 ``` # Implementation In this task, you are asked to implement the `calculate_full_hours` function according to the provided specifications and constraints. Ensure that the function accurately calculates the number of full hours and handles all possible edge cases. Efficient processing of large lists should also be considered.","solution":"from typing import List from datetime import datetime def calculate_full_hours(timestamps: List[str]) -> int: Calculate the total number of full hours between the earliest and the latest timestamp. # Parse the timestamps into datetime objects datetime_list = [datetime.strptime(ts, \\"%Y-%m-%d %H:%M:%S\\") for ts in timestamps] # Find the earliest and latest datetime earliest = min(datetime_list) latest = max(datetime_list) # Calculate the difference in total seconds total_seconds = (latest - earliest).total_seconds() # Calculate full hours full_hours = int(total_seconds // 3600) return full_hours"},{"question":"# String Compression Algorithm You are developing a text processing tool that requires compressing a string by using a specific encoding of repeated characters. The goal is to replace consecutive recurring characters with the character followed by the number of its occurrences. However, if the compressed string is not shorter than the original string, the original string should be returned. # Task: Implement the `compress_string` function according to the following specification: 1. **Function `compress_string(text: str) -> str`:** * **Input**: * `text`: A string consisting of lowercase alphabets only (a-z). * **Output**: * A compressed version of the string if the compressed string is shorter, otherwise the original string. # Compression Rules: - For each sequence of consecutive identical characters, replace the sequence with the character followed by the number of occurrences. - If the compressed string is not shorter than the original string, return the original string. - If a character appears only once, it should not be followed by the number `1`. # Examples: ```python # Example usages of compress_string: print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress_string(\\"abcd\\")) # Output: \\"abcd\\" print(compress_string(\\"aabbcc\\")) # Output: \\"aabbcc\\" print(compress_string(\\"zzzzyyyyyyy\\")) # Output: \\"z4y7\\" ``` # Additional Information: Ensure your function handles edge cases such as an empty string, and single character strings. # Constraints: - The input string will have a length in the range [0, 1000]. Implement the function and test with the provided examples to ensure correctness.","solution":"def compress_string(text: str) -> str: Compresses the input string by replacing consecutive identical characters with the character followed by the count of its occurrences. If the compressed string is not shorter, the original string is returned. Parameters: text (str): The string to be compressed. Returns: str: The compressed string or the original if compression is not beneficial. if not text: return text compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(text[i - 1] + (str(count) if count > 1 else \'\')) count = 1 compressed.append(text[-1] + (str(count) if count > 1 else \'\')) compressed_str = \'\'.join(compressed) return compressed_str if len(compressed_str) < len(text) else text"},{"question":"# Restaurant Waitlist Management System You are tasked with developing a simplified waitlist management system for a restaurant. This system will keep track of customers waiting for a table and notify them when a table becomes available. # Requirements 1. **Class Implementation**: Implement a class `Waitlist` with the following methods: * `add_customer(name: str, phone_number: str) -> str`: Adds a customer to the waitlist with their name and phone number. Returns a unique identifier (waitlist ID) for the customer. * `remove_customer(waitlist_id: str) -> bool`: Removes a customer from the waitlist using their waitlist ID. Returns `True` if the customer was successfully removed, otherwise returns `False`. * `notify_customer(waitlist_id: str) -> str`: Simulates notifying a customer that their table is ready using their waitlist ID. Returns a message confirming the notification. 2. **Data Management**: * Use an in-memory data structure to store customer information. * Ensure unique waitlist IDs for each customer. * Implement appropriate error handling for non-existent IDs and invalid data entries. 3. **Testing and Validation**: * Provide a set of test cases to validate your class methods. * Ensure your methods handle edge cases such as duplicate entries, invalid IDs, and empty waitlist. # Scenario Context A busy restaurant maintains a waitlist for customers during peak hours. Customers provide their name and phone number to be added to the waitlist. The restaurant needs to be able to add and remove customers from the waitlist and notify them when a table is ready. # Input and Output * Input: Customer\'s name, phone number, and waitlist ID. * Output: Unique waitlist ID for new entries, confirmation messages, and boolean results for removal. # Constraints * Customer names and phone numbers are strings. * Waitlist IDs are unique strings. * Ensure thread safety for concurrent access (bonus if you implement it). ```python import uuid import logging class Waitlist: def __init__(self): self.customers = {} def add_customer(self, name: str, phone_number: str) -> str: waitlist_id = str(uuid.uuid4()) self.customers[waitlist_id] = { \\"name\\": name, \\"phone_number\\": phone_number } logging.info(f\\"Added customer {name} with waitlist ID {waitlist_id}\\") return waitlist_id def remove_customer(self, waitlist_id: str) -> bool: if waitlist_id in self.customers: del self.customers[waitlist_id] logging.info(f\\"Removed customer with ID {waitlist_id}\\") return True else: logging.warning(f\\"Attempted to remove non-existent ID {waitlist_id}\\") return False def notify_customer(self, waitlist_id: str) -> str: if waitlist_id in self.customers: name = self.customers[waitlist_id][\\"name\\"] message = f\\"Dear {name}, your table is ready!\\" logging.info(f\\"Notified customer {name} with message: \'{message}\'\\") return message else: logging.error(f\\"Attempted to notify non-existent ID {waitlist_id}\\") return f\\"Customer with ID {waitlist_id} not found.\\" if __name__ == \\"__main__\\": # Example usage waitlist = Waitlist() id1 = waitlist.add_customer(\\"Alice\\", \\"1234567890\\") id2 = waitlist.add_customer(\\"Bob\\", \\"0987654321\\") print(waitlist.notify_customer(id1)) # Expected: Notification message print(waitlist.remove_customer(id1)) # Expected: True print(waitlist.notify_customer(id1)) # Expected: Error message: customer not found print(waitlist.remove_customer(id1)) # Expected: False # Example Output: # Added customer Alice with waitlist ID <uuid1> # Added customer Bob with waitlist ID <uuid2> # Dear Alice, your table is ready! # Removed customer with ID <uuid1> # Customer with ID <uuid1> not found. # Attempted to remove non-existent ID <uuid1> ``` In this task, we developed a `Waitlist` class to manage customer waitlists for a restaurant, simulating real-world usage with essential class methods and error handling.","solution":"import uuid class Waitlist: def __init__(self): self.customers = {} def add_customer(self, name: str, phone_number: str) -> str: waitlist_id = str(uuid.uuid4()) self.customers[waitlist_id] = { \\"name\\": name, \\"phone_number\\": phone_number } return waitlist_id def remove_customer(self, waitlist_id: str) -> bool: if waitlist_id in self.customers: del self.customers[waitlist_id] return True return False def notify_customer(self, waitlist_id: str) -> str: if waitlist_id in self.customers: name = self.customers[waitlist_id][\\"name\\"] return f\\"Dear {name}, your table is ready!\\" return f\\"Customer with ID {waitlist_id} not found.\\""},{"question":"# Coding Assessment: Image Pixel Intensity Normalizer Context You are given an image represented as a 2D list of integers where each integer corresponds to the pixel intensity (0-255) in grayscale. Your task is to implement a function to normalize the pixel intensities in the image. Problem Description Implement the function `normalize_image(image: list[list[int]]) -> list[list[float]]` that adjusts the pixel intensities of the given image to the range [0.0, 1.0]. The normalization is done using the minimum and maximum pixel intensity values in the image. The formula for normalization is: [ text{normalized_pixel} = frac{text{pixel} - text{min_intensity}}{text{max_intensity} - text{min_intensity}} ] Input - `image` is a 2D list of integers. Output - A 2D list of floats, where each float represents the normalized pixel intensity. Constraints - Validate that the input list contains at least one pixel (non-empty). - Validate that all pixel intensities are within the range [0, 255]. - Ensure the size of the output image matches the input image. - If all pixel intensities are the same, return an image with all pixel intensities set to 0.5. Examples ```python >>> normalize_image([[0, 128, 255], [64, 192, 32]]) [[0.0, 0.5019607843137255, 1.0], [0.25098039215686274, 0.7529411764705882, 0.12549019607843137]] >>> normalize_image([[128, 128], [128, 128]]) [[0.5, 0.5], [0.5, 0.5]] >>> normalize_image([[0, 0, 0], [0, 0, 0]]) [[0.5, 0.5, 0.5], [0.5, 0.5, 0.5]] >>> normalize_image([[255]]) [[0.5]] ```","solution":"def normalize_image(image: list[list[int]]) -> list[list[float]]: Normalize the pixel intensities of the given image to the range [0.0, 1.0]. if not image or not image[0]: raise ValueError(\\"The image must contain at least one pixel.\\") # Flatten the image to find the min and max intensities flat_image = [pixel for row in image for pixel in row] min_intensity = min(flat_image) max_intensity = max(flat_image) if max_intensity > 255 or min_intensity < 0: raise ValueError(\\"Pixel intensities must be in the range 0-255.\\") if min_intensity == max_intensity: # If all pixel intensities are the same, return 0.5 for all pixels return [[0.5 for _ in row] for row in image] # Apply normalization formula normalized_image = [ [(pixel - min_intensity) / (max_intensity - min_intensity) for pixel in row] for row in image ] return normalized_image"},{"question":"# Coding Assessment Question Context In the world of competitive programming, sorting puzzles are common. One interesting variant involves sorting an array using custom rules. Task Implement a function `sort_by_custom_rule` that takes an array of positive integers and sorts it according to the following custom rules: 1. All even numbers come before all odd numbers. 2. Even numbers are sorted in ascending order. 3. Odd numbers are sorted in descending order. Function Signature ```python def sort_by_custom_rule(arr: List[int]) -> List[int]: ``` Input - `arr` (list of integers): An array of positive integers where `1 <= len(arr) <= 1000` and `1 <= arr[i] <= 1000`. Output - A sorted list of integers based on the above custom rules. Example - Input: `arr = [4, 1, 3, 2, 7, 8, 5]` - Output: `[2, 4, 8, 7, 5, 3, 1]` - Explanation: - Even numbers sorted in ascending order: `[2, 4, 8]` - Odd numbers sorted in descending order: `[7, 5, 3, 1]` - Combined result: `[2, 4, 8, 7, 5, 3, 1]` Constraints - The function should be optimized to handle the given constraints efficiently. Requirements * **Edge Cases**: Handle cases where the array has all even or all odd numbers. * **Performance**: Ensure the function is efficient and runs within acceptable time constraints for the given input size. Write a well-tested function to sort the array following the custom rules. Ensure your implementation handles all possible edge cases correctly.","solution":"from typing import List def sort_by_custom_rule(arr: List[int]) -> List[int]: Sorts the array according to custom rules: 1. All even numbers come before all odd numbers. 2. Even numbers are sorted in ascending order. 3. Odd numbers are sorted in descending order. evens = sorted([x for x in arr if x % 2 == 0]) odds = sorted([x for x in arr if x % 2 != 0], reverse=True) return evens + odds"},{"question":"# DNA Sequence Complementary Strand # Context: In molecular biology, DNA sequences are composed of nucleotides represented by the letters \'A\', \'T\', \'C\', and \'G\'. \'A\' pairs with \'T\' and \'C\' pairs with \'G\'. Given a DNA sequence, it is often necessary to find its complementary strand which is formed by replacing each nucleotide with its complement. # Task: Your task is to implement a function `find_complementary_strand(dna_sequence: str) -> str` in Python. # Function Signature: ```python def find_complementary_strand(dna_sequence: str) -> str: ``` # Input: * `dna_sequence` (str): A string representing the sequence of nucleotides. # Output: * A string representing the complementary DNA strand. # Constraints: * The input DNA sequence will only contain characters \'A\', \'T\', \'C\', and \'G\'. * The sequence will have a length between 1 and 1000 characters. # Examples: ```python >>> find_complementary_strand(\\"ATCG\\") \\"TAGC\\" >>> find_complementary_strand(\\"GGCTA\\") \\"CCGAT\\" >>> find_complementary_strand(\\"TAACG\\") \\"ATTGC\\" >>> find_complementary_strand(\\"C\\") \\"G\\" ``` # Notes: 1. If the input sequence contains any character other than \'A\', \'T\', \'C\', or \'G\', the function should raise a `ValueError` with the message: ``` ValueError: Invalid nucleotide \'{nucleotide}\' found in the sequence. ``` 2. Keep your solution efficient to handle the maximum constraint of 1000 characters. Good luck!","solution":"def find_complementary_strand(dna_sequence: str) -> str: Given a DNA sequence, returns the complementary DNA strand. Args: dna_sequence (str): A string representing the sequence of nucleotides. Returns: str: A string representing the complementary DNA strand. Raises: ValueError: If the dna_sequence contains invalid nucleotide. complement = {\'A\': \'T\', \'T\': \'A\', \'C\': \'G\', \'G\': \'C\'} try: return \'\'.join(complement[nucleotide] for nucleotide in dna_sequence) except KeyError as e: raise ValueError(f\\"Invalid nucleotide \'{e.args[0]}\' found in the sequence.\\")"},{"question":"# Problem Statement: You are given a string containing digits from \'0\' to \'9\'. Your task is to find the largest number that can be formed by rearranging the digits of the given string. The resultant number should not contain leading zeros unless the number itself is zero. # Task: Implement the `largest_number` function which takes a string of digits and returns the largest possible number that can be formed by rearranging the digits without leading zeros. # Function Signature: ```python def largest_number(s: str) -> str: ``` # Input: - A string `s` containing digits ((1 leq |s| leq 10^6)). # Output: - A string representing the largest number that can be formed by rearranging the digits of `s`. # Example: ```python assert largest_number(\\"429\\") == \\"942\\" assert largest_number(\\"459850\\") == \\"985540\\" assert largest_number(\\"0\\") == \\"0\\" assert largest_number(\\"0000021\\") == \\"2100000\\" ``` # Constraints: - Ensure that the function handles edge cases such as strings with leading zeros, single-digit strings, and very large strings efficiently. - The function should have a time complexity of O(n log n) where n is the length of the string. # Implementation Note: - Use sorting to rearrange the digits in descending order. - Consider handling edge cases where the entire result would be a zero, like when the input is \\"0000\\".","solution":"def largest_number(s: str) -> str: Return the largest number that can be formed by rearranging the digits of the given string. if set(s) == {\'0\'}: # if the input string consists only of \'0\'s return \'0\' return \'\'.join(sorted(s, reverse=True))"},{"question":"# Question: Efficient Longest Common Subsequence (LCS) Calculation Given two strings `s1` and `s2`, implement a function `efficient_lcs(s1, s2)` to find the length of their longest common subsequence using a memory-optimized approach. Your goal is to achieve a solution with an improved space complexity compared to the standard dynamic programming approach, which typically uses O(n*m) space. # Input/Output Input * `s1`: a string (1 <= len(s1) <= 10^4) * `s2`: a string (1 <= len(s2) <= 10^4) Output * Returns an integer indicating the length of the longest common subsequence between `s1` and `s2`. # Constraints * Both strings consist of only lowercase English letters. * Special attention should be given to the space complexity of your solution. # Example ```python assert efficient_lcs(\\"abcde\\", \\"ace\\") == 3 assert efficient_lcs(\\"abc\\", \\"def\\") == 0 assert efficient_lcs(\\"abcdefg\\", \\"bdf\\") == 3 ``` # Notes 1. Although the time complexity of the resulting optimized approach should still be O(n*m), your implementation should aim to reduce the space complexity to O(min(n, m)). 2. Consider utilizing only two rows (or columns) to store the current and previous states during the computation. Implement the function: ```python def efficient_lcs(s1, s2): pass ```","solution":"def efficient_lcs(s1, s2): Return the length of the longest common subsequence of s1 and s2 using memory-optimized approach. if len(s1) < len(s2): s1, s2 = s2, s1 # Ensure that s1 is the longer string m, n = len(s1), len(s2) # Initialize two arrays to store the current and previous rows previous = [0] * (n + 1) current = [0] * (n + 1) for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: current[j] = previous[j - 1] + 1 else: current[j] = max(previous[j], current[j - 1]) # Swap the references of previous and current previous, current = current, previous return previous[n]"},{"question":"# Task Write a function `dist_count_subarrays_with_sum` that efficiently counts the number of distinct subarrays of a given array `arr` that sum up to a target value `k`. # Description A subarray is a contiguous part of an array. A distinct subarray is a subarray that appears at least once in the array with the target sum `k`. # Function Signature ```python def dist_count_subarrays_with_sum(arr: List[int], k: int) -> int: ``` # Input * `arr` (1 <= len(arr) <= 10000): A list of integers, which can be positive, negative, or zero. * `k` (|k| <= 10^9): An integer representing the target sum. # Output * Returns an integer representing the number of distinct subarrays that sum up to the target value `k`. # Constraints * The length of the input array `arr` is at most 10000. * Each element in the array lies in the range of (-10^6) to (10^6). # Example ```python assert dist_count_subarrays_with_sum([1, 1, 1], 2) == 2 # Explanation: The subarrays [1, 1] and [1, 1] both sum up to 2. assert dist_count_subarrays_with_sum([1, 2, 3], 3) == 2 # Explanation: The subarrays [1, 2] and [3] both sum up to 3. assert dist_count_subarrays_with_sum([1, -1, 0], 0) == 3 # Explanation: The subarrays [1, -1], [1, -1, 0], and [0] all sum up to 0. assert dist_count_subarrays_with_sum([-1, -1, 1, 2, 3], 3) == 2 # Explanation: The subarrays [1, 2] and [3] both sum up to 3. ``` # Additional Information * This problem can be solved using a sliding window technique combined with hash maps to keep track of the sum of subarrays efficiently. # Hint To achieve optimal performance, use a hash map to store the cumulative sums up to the current index, and check for the necessary cumulative sum to achieve the target sum `k`.","solution":"from typing import List def dist_count_subarrays_with_sum(arr: List[int], k: int) -> int: # Dictionary to store the cumulative sum and its frequency cumulative_sum_frequency = {} cumulative_sum_frequency[0] = 1 cumulative_sum = 0 count = 0 for num in arr: cumulative_sum += num desired_sum = cumulative_sum - k if desired_sum in cumulative_sum_frequency: count += cumulative_sum_frequency[desired_sum] if cumulative_sum in cumulative_sum_frequency: cumulative_sum_frequency[cumulative_sum] += 1 else: cumulative_sum_frequency[cumulative_sum] = 1 return count"},{"question":"# Combination Sum Problem You are developing a financial planning application where users need to determine possible combinations of different payment amounts that sum up to a target value. Given an array of distinct integers representing payment amounts and a target integer, you must write a function to return all the unique combinations of the payment amounts that sum up to the target value. Each payment amount may be used multiple times. Write a function **find_combinations(payment_options: list[int], target_amount: int) -> list[list[int]]** that finds all unique combinations in the `payment_options` array where the chosen numbers sum up to the `target_amount`. # Input - `payment_options`: A list of distinct integers representing available payment amounts. - `target_amount`: An integer representing the target sum of the payment combinations. # Output - A list of lists, where each inner list represents a unique combination of the payment amounts that sum up to `target_amount`. # Example Usage ```python print(find_combinations([2, 3, 6, 7], 7)) # Output: [[2, 2, 3], [7]] print(find_combinations([2, 3, 5], 8)) # Output: [[2, 2, 2, 2], [2, 3, 3], [3, 5]] print(find_combinations([2], 1)) # Output: [] ``` # Constraints 1. You must use only the given payment amounts, and each payment amount can be used multiple times within a combination. 2. All numbers (including `target_amount`) will be positive integers. 3. The order of the combinations in the output does not matter. # Debugging Constraints 1. Ensure correct handling of edge cases, such as: - No combination can sum up to the target value. - `target_amount` is smaller than the smallest payment option. - Only one combination sums up to the target amount. 2. Optimize for both space and time complexity wherever feasible. # Note 1. You may assume that there are no duplicate payment amounts in the input list. 2. Consider using backtracking to explore all possible combinations effectively.","solution":"def find_combinations(payment_options, target_amount): def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(payment_options)): backtrack(i, target - payment_options[i], path + [payment_options[i]]) result = [] backtrack(0, target_amount, []) return result"},{"question":"# Context A communications company needs to analyze and stabilize the data transmission over their network. Data packets transmitted over the network may occasionally be delayed or duplicated. They want to clean the data by identifying original packets and detecting duplicates. # Problem Statement Write a function `filter_packets(packets: List[int]) -> List[int]` that receives a list of packet IDs as input and returns a list of unique packet IDs in the order they first appear. # Function Signature ```python def filter_packets(packets: List[int]) -> List[int]: pass ``` # Input 1. `packets` - a list of integers, representing packet IDs, which may contain duplicates. # Output * A list of integers, representing the filtered packet IDs (with duplicates removed and original order preserved). # Examples 1. `filter_packets([1, 2, 2, 3, 1, 4])` should return `[1, 2, 3, 4]`. 2. `filter_packets([5, 5, 5, 5, 5])` should return `[5]`. 3. `filter_packets([10, 20, 20, 30, 10])` should return `[10, 20, 30]`. 4. `filter_packets([])` should return `[]`. # Constraints * The length of `packets` list will be between 0 and 10^6. * Each element in `packets` will be a non-negative integer (0 ≤ packets[i] ≤ 10^6). # Notes * Your solution should be optimized to handle large lists as specified in the constraints. * Consider edge cases like an empty packet list or packet lists with all unique elements.","solution":"def filter_packets(packets): Returns a list of unique packet IDs in the order they first appear. Parameters: packets (List[int]): The list of packet IDs which may contain duplicates. Returns: List[int]: The filtered list of packet IDs with duplicates removed. seen = set() result = [] for packet in packets: if packet not in seen: seen.add(packet) result.append(packet) return result"},{"question":"Coding Task: Implement LRU Cache System A common requirement in web applications is to manage the caching of expensive-to-fetch data for quick access. One widely used caching strategy is the Least Recently Used (LRU) policy. Your task is to implement an LRU cache system. # Objective Design a class `LRUCache` that simulates the functionality of a Least Recently Used cache. The class should support the following operations: - `get(key)`: Retrieve the value associated with the key if present in the cache, otherwise return -1. - `put(key, value)`: Insert or update the value associated with the key and mark the key as recently used. If the cache exceeds its capacity, invalidate the least recently used item. # Details Input * For the `put` method: An integer `key` and an associated `value`. * For the `get` method: An integer `key`. Output * For the `get` method: The value associated with the key if present, or `-1` if not present. Example ```python # Initialize cache with capacity of 2 lru_cache = LRUCache(2) # Perform cache operations lru_cache.put(1, 1) lru_cache.put(2, 2) print(lru_cache.get(1)) # Expected Output: 1 (key 1 is recently used) lru_cache.put(3, 3) # evicts key 2 print(lru_cache.get(2)) # Expected Output: -1 (key 2 was evicted) lru_cache.put(4, 4) # evicts key 1 print(lru_cache.get(1)) # Expected Output: -1 (key 1 was evicted) print(lru_cache.get(3)) # Expected Output: 3 print(lru_cache.get(4)) # Expected Output: 4 ``` # Constraints * The number of `put` and `get` calls will be in the range [1, 10^5]. * All keys and values will be positive integers. # Performance Requirements * Both `put` and `get` operations must run in O(1) time. # Notes * You may use any data structures that ensure the given operations run in the required time complexity such as dictionaries and doubly-linked lists. * The LRU Cache should handle invalidation accurately by managing key usage statistics implicitly. ```python class LRUCache: def __init__(self, capacity: int): # Initialize the LRU cache with a given capacity pass def get(self, key: int) -> int: # Retrieve item from cache pass def put(self, key: int, value: int) -> None: # Add/Update item in cache pass # Test cases to verify correctness of the implementation def test_lru_cache(): lru = LRUCache(2) # Initial state tests assert lru.get(1) == -1 # Cache operations lru.put(1, 1) lru.put(2, 2) assert lru.get(1) == 1 lru.put(3, 3) # Evict key 2 assert lru.get(2) == -1 # Key 2 should be evicted lru.put(4, 4) # Evict key 1 assert lru.get(1) == -1 # Key 1 should be evicted assert lru.get(3) == 3 assert lru.get(4) == 4 # Execute test cases test_lru_cache() ``` # Challenge * Explore optimization opportunities to minimize memory consumption while maintaining O(1) time complexity for `put` and `get` operations. Good luck!","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node): prev_node = node.prev next_node = node.next prev_node.next = next_node next_node.prev = prev_node def _add(self, node): prev_node = self.tail.prev prev_node.next = node self.tail.prev = node node.prev = prev_node node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"Problem Statement You will implement a class that represents a basic file system with directory structure and file operations. The file system allows directories to contain other directories and files. Each file is represented by its name and content, and directories primarily by their name. You are required to implement operations to create files, create directories, and read file contents. # Function Signature ```python class FileSystem: def __init__(self): pass def mkdir(self, path: str) -> None: pass def add_content_to_file(self, file_path: str, content: str) -> None: pass def read_content_from_file(self, file_path: str) -> str: pass ``` # Requirements 1. **Class Initialization**: * Initialize an empty file system with only the root directory. 2. **File System Methods**: * `mkdir(path: str) -> None`: This method creates a new directory at the specified path. The newly created directory is nested within its parent directory. * `add_content_to_file(file_path: str, content: str) -> None`: This method either creates a new file at the specified path with the given content, or appends content to an existing file. * `read_content_from_file(file_path: str) -> str`: This method returns the content of the file at the specified path. 3. **Paths and Files**: * Paths are given as strings and should represent the nested directory structure. * For example, `/dir1/dir2/file1` represents `file1` inside `dir2`, which is inside `dir1`. * All paths start from the root directory `/`. # Example ```python fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.add_content_to_file(\\"/a/b/c/d\\", \\"hello\\") fs.add_content_to_file(\\"/a/b/c/d\\", \\" world\\") content = fs.read_content_from_file(\\"/a/b/c/d\\") # Expect: # content = \\"hello world\\" ``` # Constraints * All path strings are non-empty and contain only lowercase alphabets and forward slashes `/`. * `mkdir` will be called at most 10^4 times. * `add_content_to_file` and `read_content_from_file` will be called at most 10^4 times. * The length of content added to a file will not exceed 10^4 characters at a time.","solution":"class FileSystem: def __init__(self): self.root = {} def mkdir(self, path: str) -> None: parts = path.split(\'/\') node = self.root for part in parts: if not part: continue if part not in node: node[part] = {} node = node[part] def add_content_to_file(self, file_path: str, content: str) -> None: parts = file_path.split(\'/\') *dirs, file_name = parts node = self.root for part in dirs: if not part: continue if part not in node: node[part] = {} node = node[part] if file_name not in node: node[file_name] = \\"\\" node[file_name] += content def read_content_from_file(self, file_path: str) -> str: parts = file_path.split(\'/\') *dirs, file_name = parts node = self.root for part in dirs: if not part: continue node = node[part] return node[file_name]"},{"question":"# Programming Assessment Question Context Sorting algorithms are fundamental in computer science. While many sophisticated sorting algorithms exist, insertion sort provides an excellent opportunity to understand basic concepts and get acquainted with algorithmic problem-solving. Your task is to implement an insertion sort with a twist to reinforce these concepts. Task **Objective:** Write a function that performs an insertion sort on a given list but only sorts a specified sub-section of the list, starting from a given index until the end of the list. # Requirements * **Function Signature**: ```python def partial_insertion_sort(sequence: list, start_index: int) -> list: ``` * **Inputs**: - `sequence`: A list of integers that needs partial sorting. - `start_index`: An integer indicating the index from where the sort should start. * **Output**: - Returns a new list where elements from `start_index` to the end are sorted, and elements before `start_index` remain unchanged. # Constraints * The list can be of any length, including 0. * The `start_index` will be a non-negative integer and at most equal to the length of the list minus one. * You cannot use built-in sorting functions. # Example Scenarios 1. **Example 1**: ```python partial_insertion_sort([4, 3, 2, 1], 1) # Returns: [4, 1, 2, 3] ``` (Explanation: The sort starts from index 1, the resulting sublist [3, 2, 1] is sorted to [1, 2, 3], and the prefix is preserved.) 2. **Example 2**: ```python partial_insertion_sort([5, 1, 3, 2, 4], 2) # Returns: [5, 1, 2, 3, 4] ``` (Explanation: The sort starts from index 2, the resulting sublist [3, 2, 4] is sorted to [2, 3, 4], and the prefix is preserved.) 3. **Example 3**: ```python partial_insertion_sort([1, 5, 4, 3, 2], 0) # Returns: [1, 2, 3, 4, 5] ``` (Explanation: The sort starts from index 0, so the entire list is sorted.) 4. **Example 4**: ```python partial_insertion_sort([], 0) # Returns: [] ``` (Explanation: The list is empty, so nothing needs to be sorted.) # Additional Requirements * Your implementation should handle edge cases such as an empty list and a start index at the end of the list. * It should focus on efficiency and correctness for performing the partial sort. ---","solution":"def partial_insertion_sort(sequence: list, start_index: int) -> list: Performs a partial insertion sort on the input sequence starting from the specified index. :param sequence: List of integers to be partially sorted. :param start_index: Index from where the sorting should start. :return: New list with specified sub-section sorted. if start_index >= len(sequence): return sequence # If start_index is out of range, return the list as is. # Separate the part of the list that needs sorting sortable_part = sequence[start_index: ] sorted_part = sequence[:start_index] # Apply insertion sort on the part that needs to be sorted for i in range(1, len(sortable_part)): key = sortable_part[i] j = i - 1 while j >= 0 and key < sortable_part[j]: sortable_part[j + 1] = sortable_part[j] j -= 1 sortable_part[j + 1] = key # Combine the unchanged part and the sorted part return sorted_part + sortable_part"},{"question":"# Context: You are building a tool to process customer orders for an online store. One of the key features is to prioritize order processing based on delivery distance. The locations of customers are represented in a 3-dimensional coordinate system (x, y, z), and the store is located at the origin (0, 0, 0). # Problem Statement: Write a function `process_orders` that takes a list of customer locations and returns a list of locations sorted by their distance from the store, in ascending order. For orders that are equidistant from the store, maintain the order in which they appear in the input list. # Specifications: - **Input**: - `locations`: List of tuples, where each tuple contains three floating-point numbers representing the coordinates of a customer\'s location (x, y, z). - **Output**: - List of tuples representing the customer locations, sorted by their distance from the store (origin). # Function Signature: ```python def process_orders(locations: list[tuple[float, float, float]]) -> list[tuple[float, float, float]]: pass ``` # Constraints: - The list `locations` can be empty. - The coordinates (x, y, z) will always be floating-point numbers. # Example: ```python orders = [ (2.0, 3.0, 5.0), (1.0, 0.0, 2.0), (3.0, 4.0, 1.0), (0.0, 0.0, 0.0) ] result = process_orders(orders) print(result) # Expected Output: [(0.0, 0.0, 0.0), (1.0, 0.0, 2.0), (3.0, 4.0, 1.0), (2.0, 3.0, 5.0)] ```","solution":"from typing import List, Tuple def process_orders(locations: List[Tuple[float, float, float]]) -> List[Tuple[float, float, float]]: Sorts customer locations based on their distance from the store (located at the origin) in ascending order. def distance_from_origin(coordinates: Tuple[float, float, float]) -> float: x, y, z = coordinates return x**2 + y**2 + z**2 return sorted(locations, key=distance_from_origin)"},{"question":"# Matrix Path Count You are working on a pathfinding feature for a game, where an enemy needs to move from the top-left corner of a grid to the bottom-right corner. The enemy can only move right or down at each step. Given a grid defined by its dimensions `m` and `n`, you need to determine the number of distinct paths the enemy can take to reach the destination. Problem Requirements 1. Create a class `MatrixPathCounter` that supports: - Calculating the number of distinct paths from the top-left to the bottom-right of an `m x n` grid using dynamic programming. Input and Output Formats * **Initialization**: - Input: `m`, an integer for the number of rows; `n`, an integer for the number of columns. - Example: `m = 3, n = 3` * **Methods**: - Method: `count_paths()` - Output: Returns an integer representing the number of distinct paths. - Constraint: `1 <= m, n <= 100` - Example: Given a 3x3 grid, `count_paths()` should return `6`. Implementation Requirements 1. Use dynamic programming to calculate the number of distinct paths. 2. Ensure the solution runs efficiently within the given constraints. 3. Handle invalid inputs appropriately, ensuring the grid has positive dimensions. ```python class MatrixPathCounter: def __init__(self, m, n): # Initialize the matrix dimensions and a table to store the number of paths # Implement the constructor def count_paths(self): # Calculate the number of distinct paths using dynamic programming # Implement the count_paths method # Example usage: # mpc = MatrixPathCounter(3, 3) # print(mpc.count_paths()) # Output should be 6 ``` **Note**: Ensure your implementation correctly handles the dynamic programming table to efficiently count paths without any built-in library functions for the path counting operations.","solution":"class MatrixPathCounter: def __init__(self, m, n): Initialize the matrix dimensions and a table to store the number of paths. self.m = m self.n = n self.dp = [[0] * n for _ in range(m)] def count_paths(self): Calculate the number of distinct paths using dynamic programming. # If either dimension is less than 1, there are no paths if self.m <= 0 or self.n <= 0: return 0 # Initialize the dynamic programming table for i in range(self.m): for j in range(self.n): if i == 0 or j == 0: self.dp[i][j] = 1 # Only one way to reach any cell in the first row or column else: self.dp[i][j] = self.dp[i - 1][j] + self.dp[i][j - 1] return self.dp[self.m - 1][self.n - 1]"},{"question":"# Coding Assessment Question: Implement the Longest Consecutive Sequence Algorithm Context You are working on analyzing user activity logs and need to find periods of continuous activity. Specifically, you need to find the longest streak of consecutive days a user was active based on their login dates. Task Write a function `longest_consecutive(nums: List[int]) -> int` that takes a list of integers representing the days a user logged in and returns the length of the longest consecutive sequence. Input * `nums`: A list of integers representing days of the year when a user logged in. Output * An integer representing the length of the longest consecutive sequence of login days. Constraints * The input list will have length between 0 and 10^5. * Each integer in the list will be between 1 and 365. Examples ```python # Example 1 input: [100, 4, 200, 1, 3, 2] output: 4 # Example 2 input: [1, 2, 0, 1] output: 3 # Example 3 input: [7, 8, 9, 4, 5, 6] output: 6 # Example 4 input: [] output: 0 ``` Performance Requirements * The function should aim for O(n) time complexity. Guidance * Consider the use of a set for fast look-up to check for consecutive days. * Initialize a set with all elements of the input list. * Iterate through the list, and for each element, check if it\'s the start of a sequence. * Count the length of sequences by extending through consecutive elements. * Optimize space complexity by using the set for primary operations and calculations.","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive sequence of integers in the list nums. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: # Check if it is the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem Statement Write a function that rotates a given list to the right by `k` steps, where `k` is a non-negative integer. This means that the elements at the end of the list will wrap around to the beginning. The function should handle various input types correctly and raise appropriate exceptions when necessary. # Function Signature ```python def rotate_list(nums: list, k: int) -> list: pass ``` # Input * `nums`: a list of integers. * `k`: a non-negative integer indicating the number of steps to rotate the list to the right. # Output * A list representing the rotated result. # Constraints * The list `nums` must consist of integers. * The integer `k` must be non-negative. * Handle invalid inputs by raising the appropriate exceptions: * Raise `ValueError` if `k` is negative. * Raise `TypeError` if `nums` is not a list or `k` is not an integer. * Raise `ValueError` if any element within `nums` is not an integer. # Example ```python assert rotate_list([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert rotate_list([0, 12, 45, 78], 3) == [12, 45, 78, 0] assert rotate_list([99, 15, 25], 1) == [25, 99, 15] assert rotate_list([], 3) == [] assert rotate_list([5], 5) == [5] assert rotate_list([4, 3, 2], 0) == [4, 3, 2] ``` # Edge Cases * `rotate_list([1, 2, 3], -1)` should raise `ValueError`. * `rotate_list([1, 2, \'3\'], 2)` should raise `ValueError`. * `rotate_list(\'123\', 3)` should raise `TypeError`.","solution":"def rotate_list(nums: list, k: int) -> list: # Validate input types if not isinstance(nums, list): raise TypeError(\\"nums must be a list of integers\\") if not isinstance(k, int): raise TypeError(\\"k must be an integer\\") # Check if k is non-negative if k < 0: raise ValueError(\\"k must be a non-negative integer\\") # Check if all elements in nums are integers if not all(isinstance(x, int) for x in nums): raise ValueError(\\"All elements in nums must be integers\\") # Handle the rotation n = len(nums) if n == 0: return nums # Return the empty list as is k = k % n # In case k is larger than the list length return nums[-k:] + nums[:-k]"},{"question":"# Unique Character Counter with Constraints Problem Statement Write a function `unique_char_count(s: str, max_length: int) -> int` that returns the number of unique characters in the input string `s` considering only the first `max_length` characters of the string. If `s` is shorter than `max_length`, consider the entire string. Input - A string `s` (0 ≤ len(s) ≤ 1000). - An integer `max_length` (1 ≤ max_length ≤ 1000). Output - An integer representing the number of unique characters in the considered prefix of the string. Constraints - The solution should run in linear time with respect to the length of the string `s`. Example ```python >>> unique_char_count(\\"programming\\", 5) 4 >>> unique_char_count(\\"leetcode\\", 8) 6 >>> unique_char_count(\\"hello\\", 10) 4 ``` Explanation For `s = \\"programming\\"` and `max_length = 5`, the considered prefix is \\"progr\\", which has 4 unique characters: {\'p\', \'r\', \'o\', \'g\'}. For `s = \\"leetcode\\"` and `max_length = 8`, all 8 characters of \\"leetcode\\" are considered, and it has 6 unique characters: {\'l\', \'e\', \'t\', \'c\', \'o\', \'d\'}. For `s = \\"hello\\"` and `max_length = 10`, since the string is shorter than `max_length`, the entire string \\"hello\\" is considered, having 4 unique characters: {\'h\', \'e\', \'l\', \'o\'}.","solution":"def unique_char_count(s: str, max_length: int) -> int: Returns the number of unique characters in the first `max_length` characters of the string `s`. If the length of `s` is less than `max_length`, consider the entire string. considered_length = min(len(s), max_length) considered_prefix = s[:considered_length] unique_characters = set(considered_prefix) return len(unique_characters)"},{"question":"# Problem Statement: You are provided with a text manipulation tool that compresses or decompresses strings using a simple run-length encoding (RLE) technique. Your task is to complete and optimize this tool to handle edge cases and improve its performance on large inputs. # Requirements: 1. **Implement the `compress` function** that takes a string and returns its RLE compressed form. 2. **Implement the `decompress` function** that takes an RLE compressed string and returns the original uncompressed string. 3. **Optimize the `compress` and `decompress` functions** to handle the following edge cases and to be efficient with very large inputs: - Strings with repeated characters. - Strings with single characters. - Empty strings. # Function Signatures: ```python def compress(text: str) -> str: def decompress(text: str) -> str: ``` # Input: For `compress`: - **Text**: A string containing words or characters. For `decompress`: - **Text**: A string in RLE compressed form. # Output: For `compress`: - Returns the RLE compressed string. For `decompress`: - Returns the original uncompressed string. # Constraints: - The input string length will not exceed 10,000 characters. # Examples: ```python # Compression assert compress(\\"aaaabbbcca\\") == \\"4a3b2ca\\" assert compress(\\"aabbcc\\") == \\"2a2b2c\\" assert compress(\\"abcd\\") == \\"abcd\\" assert compress(\\"\\") == \\"\\" # Decompression assert decompress(\\"4a3b2ca\\") == \\"aaaabbbcca\\" assert decompress(\\"2a2b2c\\") == \\"aabbcc\\" assert decompress(\\"abcd\\") == \\"abcd\\" assert decompress(\\"\\") == \\"\\" ``` # Notes: - Ensure your solution is efficient and properly handles the edge cases where there are no repeats or the string is empty. - Do not alter the function signatures. - You may add helper functions if needed but ensure they follow the required logic and constraints.","solution":"def compress(text: str) -> str: if not text: return \\"\\" compressed = [] count = 1 for i in range(1, len(text)): if text[i] == text[i - 1]: count += 1 else: compressed.append(f\\"{count if count > 1 else \'\'}{text[i - 1]}\\") count = 1 compressed.append(f\\"{count if count > 1 else \'\'}{text[-1]}\\") return \'\'.join(compressed) def decompress(text: str) -> str: if not text: return \\"\\" decompressed = [] i = 0 while i < len(text): if text[i].isdigit(): num = 0 while i < len(text) and text[i].isdigit(): num = num * 10 + int(text[i]) i += 1 if i < len(text): decompressed.append(text[i] * num) else: decompressed.append(text[i]) i += 1 return \'\'.join(decompressed)"},{"question":"**Question:** You have been given a string `s` containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. Determine if the input string is valid. An input string is valid if: 1. Open brackets are closed by the same type of brackets. 2. Open brackets are closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type. Your task is to implement a function `is_valid_brackets` that checks if the input string `s` is valid according to the given conditions. # Task: Implement the function `is_valid_brackets` that determines the validity of the string `s`. # Input: - **s (str)**: A string containing just the characters `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. The string length will be in the range `[1, 10^4]`. # Output: - **Return Type**: Boolean - **Description**: Return `True` if the input string is valid, otherwise return `False`. # Constraints and Notes: - You may assume that the input string does not contain any other characters apart from `\'(\'`, `\')\'`, `\'{\'`, `\'}\'`, `\'[\'`, and `\']\'`. - Efficiently handle the checking process in such a way that the solution operates within a reasonable time complexity. # Example: Example 1: ```python s = \\"()\\" assert is_valid_brackets(s) == True ``` Example 2: ```python s = \\"()[]{}\\" assert is_valid_brackets(s) == True ``` Example 3: ```python s = \\"(]\\" assert is_valid_brackets(s) == False ``` Example 4: ```python s = \\"([)]\\" assert is_valid_brackets(s) == False ``` Example 5: ```python s = \\"{[]}\\" assert is_valid_brackets(s) == True ``` # Implementation ```python def is_valid_brackets(s: str) -> bool: stack = [] bracket_map = {\\")\\": \\"(\\", \\"}\\": \\"{\\", \\"]\\": \\"[\\"} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack if __name__ == \\"__main__\\": s = \\"{[]}\\" print(is_valid_brackets(s)) # Expects True s = \\"(]\\" print(is_valid_brackets(s)) # Expects False ```","solution":"def is_valid_brackets(s: str) -> bool: Returns True if the string contains valid pairs of brackets, False otherwise. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Coding Assessment Question You are developing a function for an imaginary e-commerce platform that needs to calculate the discount on a product based on a given discount rate. Your task is to create a function that computes the discounted price of the product accurately, considering different scenarios, including zero or negative values for the base price and the discount rate. # Task Write a function `calculate_discounted_price` that takes two parameters: - `original_price` (float): The original price of the product. - `discount_rate` (float): The discount rate as a decimal (e.g., 0.20 for 20%). The function should return the final price of the product after applying the discount rate. Ensure your function accounts for various edge cases, such as zero or negative values for `original_price` and `discount_rate`. Function Signature ```python def calculate_discounted_price(original_price: float, discount_rate: float) -> float: ``` Input/Output Formats - The input consists of: - `original_price`: A float representing the original price of the product. - `discount_rate`: A float representing the discount rate as a decimal. - The output is: - A float representing the final price after applying the discount. Constraints - -1000.0 ≤ `original_price` ≤ 100000.0 - -1.0 ≤ `discount_rate` ≤ 1.0 Performance Requirements - The calculation must be performed in constant time, O(1). - The function should handle floating-point precision correctly. # Example ```python >>> calculate_discounted_price(200, 0.20) 160.0 >>> calculate_discounted_price(99.99, 0.10) 89.991 >>> calculate_discounted_price(150, 0) 150.0 >>> calculate_discounted_price(0, 0.10) 0.0 >>> calculate_discounted_price(-50, 0.20) -40.0 >>> calculate_discounted_price(100, -0.20) 120.0 ```","solution":"def calculate_discounted_price(original_price: float, discount_rate: float) -> float: Calculates the final price after applying the discount rate to the original price. Parameters: original_price (float): The original price of the product. discount_rate (float): The discount rate as a decimal (e.g., 0.20 for 20%). Returns: float: The final price after discount. return original_price * (1 - discount_rate)"},{"question":"# Programming Assessment: LinkedIn Connection Analyzer You are tasked with extending an existing class `LinkedInUser` to add methods for analyzing and visualizing LinkedIn connections within a network graph. Scenario Your company wishes to enhance a LinkedIn connection analyzer tool by incorporating methods for identifying mutual connections between users and visualizing the connection graph. This will provide insights into common connections and network strength. # Task Details: 1. **Function Implementation**: - **Method 1**: Implement an `identify_mutual_connections` method within the `LinkedInUser` class that takes another `LinkedInUser` instance and returns a list of mutual connections. - **Method 2**: Implement a `visualize_connections` method that generates a network graph of the user\'s connections using a library like `networkx` and renders it using `matplotlib`. 2. **Expected Input and Output**: - **identify_mutual_connections**: - Input: another `LinkedInUser` instance - Output: list of mutual connections (List[str]) - **visualize_connections**: - Input: None - Output: a rendered network graph displayed using `matplotlib`. 3. **Constraints and Limitations**: - Ensure the `identify_mutual_connections` method accurately identifies mutual connections between the user and another user. - Ensure the graph generated by the `visualize_connections` method is clear and easy to interpret. 4. **Performance Requirements**: - Efficiently identify mutual connections, even for users with large networks. - Generate the network graph with optimal performance. # Method Signatures: ```python class LinkedInUser: ... def identify_mutual_connections(self, other_user: \'LinkedInUser\') -> List[str]: pass def visualize_connections(self) -> None: pass ... ``` # Notes: - Utilize Python’s `networkx` library for graph representation. - Utilize Python’s `matplotlib` library for graph rendering. - Ensure that the class and methods are thoroughly tested. # Example: ```python # Example usage of the identify_mutual_connections method user1 = LinkedInUser(\\"alice\\") user2 = LinkedInUser(\\"bob\\") mutual_connections = user1.identify_mutual_connections(user2) print(f\\"Mutual connections between {user1.username} and {user2.username}: {mutual_connections}\\") # Example usage of the visualize_connections method user1.visualize_connections() ``` Complete the methods and ensure they work as described.","solution":"import networkx as nx import matplotlib.pyplot as plt class LinkedInUser: def __init__(self, username, connections=None): self.username = username self.connections = connections if connections else [] def add_connection(self, other_user): self.connections.append(other_user) def identify_mutual_connections(self, other_user): Identifies mutual connections between self and other_user. :param other_user: LinkedInUser instance :return: List of mutual connections (List[str]) return list(set(self.connections) & set(other_user.connections)) def visualize_connections(self): Visualizes the user\'s connections using networkx and renders it using matplotlib. graph = nx.Graph() graph.add_node(self.username) for connection in self.connections: graph.add_edge(self.username, connection) pos = nx.spring_layout(graph) nx.draw(graph, pos, with_labels=True, node_color=\'lightblue\', node_size=3000, font_size=10, font_weight=\'bold\') plt.show()"},{"question":"# Duplicate Element Finder Scenario You are working on optimizing database operations, and a crucial part of your task involves identifying duplicate entries efficiently. In this scenario, you need to create a function that finds the first duplicate number in a list of integers. Problem Statement Write a function `find_first_duplicate` that takes a list of integers `numbers` as input and returns the first duplicate number encountered. If there are no duplicates, the function should return `None`. Input and Output * **Input**: A list of integers `numbers` where the integers are in the range `1` to `n` (inclusive) for a list of length `n`. * **Output**: An integer representing the first duplicate number encountered, or `None` if no duplicates are present. Constraints: * The function must handle lists with lengths up to 10^5. * Each integer in the list can appear at most twice. Example: ```python >>> find_first_duplicate([2, 1, 3, 5, 3, 2]) 3 >>> find_first_duplicate([1, 2, 3, 4, 5]) None >>> find_first_duplicate([3, 3, 4, 4, 5, 5]) 3 >>> find_first_duplicate([10, 20, 10, 30, 40, 20]) 10 >>> find_first_duplicate([7, 8, 9, 7, 8, 9]) 7 ``` Requirements: * Write the function to handle the input list efficiently, aiming for a time complexity close to O(n). * Use a suitable data structure to keep track of visited numbers to ensure efficient lookup. * The function should gracefully handle empty lists and other edge cases. Notes: * The function must be self-contained and not depend on any external modules other than basic Python libraries. * Consider different strategies for maintaining and querying duplicates to ensure optimal performance.","solution":"def find_first_duplicate(numbers): Finds the first duplicate number in the list of integers. If no duplicates are found, returns None. seen = set() for number in numbers: if number in seen: return number seen.add(number) return None"},{"question":"# Cyclic Rotation of an Array You are required to implement a function that performs a cyclic rotation on an array of integers. Given the following sequence of operations, the goal is to rotate the elements of the array to the right by a given number of steps. Scenario Imagine you are developing a feature for an image processing application where a certain filter effect requires manipulating pixel data arranged in a 1-dimensional array by cyclically shifting the pixel values. Your task is to write a function that, given an array of integers and a rotation count, rotates the array elements to the right by the provided number of steps. # Functional Requirements - **Function Name**: `cyclic_rotation` - **Input**: * `nums`: A list of integers representing pixel values. * `k`: An integer representing the number of steps to rotate the array to the right. - **Output**: * Returns the rotated list of integers after performing the cyclic shift. # Example ```python # Input: nums = [1, 2, 3, 4, 5] k = 2 # Output: rotated = [4, 5, 1, 2, 3] # Explanation: The array [1, 2, 3, 4, 5] is rotated 2 steps to the right to become [4, 5, 1, 2, 3]. ``` # Implementation Constraints 1. **Rotation Mechanics**: Optimize the rotation algorithm to handle large arrays efficiently. 2. **Edge Cases**: Account for cases where `k` is greater than the length of the array or where the array is empty. 3. **Performance**: Ensure the solution is optimized for both time complexity and space complexity. # Additional Information - **Assumptions**: * The input list `nums` may contain positive, negative integers, and zero. * The integer `k` is non-negative. * Clear and concise explanation of the rotation process is required. - **Constraints**: * Do not use in-built rotation functions. Ensure the code is clean, well-documented, and handles various edge cases gracefully.","solution":"def cyclic_rotation(nums, k): Rotates the elements of the array nums to the right by k steps. Parameters: nums (list of int): The list of integers to be rotated. k (int): The number of steps to rotate the array to the right. Returns: list of int: The rotated list of integers. if not nums: return [] n = len(nums) k = k % n # In case k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"**Coding Question: Matrix Transposition** You are given a 2D matrix (a list of lists) containing integers. Your task is to implement a function that transposes the given matrix. Transposing a matrix means converting its rows into columns and vice versa. # Function Signature ```python def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: pass ``` # Inputs - `matrix` (list of lists of ints): A 2D array of integers representing the matrix. The matrix can be of varying dimensions but is guaranteed to have consistent row lengths (i.e., every row has the same number of columns). # Output - Returns a new 2D list of integers representing the transposed matrix. # Example ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` # Constraints - The number of rows (m) and columns (n) will each range from 1 to 100. - The matrix will be well-formed, i.e., each row will have the same number of columns. # Requirements - You are expected to implement an efficient solution that correctly handles the transposition of the matrix. - Ensure your solution handles edge cases where the matrix may be a single row or single column and varying valid dimensions (m x n). # Notes - Be careful to create a new matrix rather than modifying the original matrix directly. - Make sure to consider the placement of elements when switching rows to columns to ensure accuracy. - Your implementation must meet a time and space complexity of O(m*n), where \'m\' is the number of rows and \'n\' is the number of columns.","solution":"def transpose_matrix(matrix: list[list[int]]) -> list[list[int]]: Transposes the given 2D matrix. Args: matrix (list of lists of ints): The matrix to be transposed. Returns: list of lists of ints: The transposed matrix. return list(map(list, zip(*matrix)))"},{"question":"# Scenario You are developing a text processing application that needs to sanitize and analyze various text inputs. One important functionality is to detect palindromes after removing all non-alphanumeric characters and converting the string to lowercase. # Problem Statement Implement a Python function called `is_sanitized_palindrome` that determines if a given string is a palindrome after sanitizing it. # Function Signature ```python def is_sanitized_palindrome(s: str) -> bool: ``` # Inputs * `s`: A string containing any characters, including spaces, punctuation, and symbols. # Outputs * A boolean value `True` if the sanitized string is a palindrome, `False` otherwise. # Constraints * Only alphanumeric characters should be considered while checking for palindromes. * Characters are case-insensitive, meaning that \\"A\\" and \\"a\\" are considered the same. * An empty string is considered a valid palindrome. # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Example ```python assert is_sanitized_palindrome(\\"A man, a plan, a canal, Panama\\") == True assert is_sanitized_palindrome(\\"racecar\\") == True assert is_sanitized_palindrome(\\"Hello, World!\\") == False assert is_sanitized_palindrome(\\" \\") == True ``` Implement the `is_sanitized_palindrome` function to meet the given requirements and optimize for performance. Ensure proper handling of different character types and edge cases. Write clear and maintainable code.","solution":"def is_sanitized_palindrome(s: str) -> bool: Determines if a given string is a palindrome after sanitizing it. Args: s (str): The input string containing any characters. Returns: bool: True if the sanitized string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lowercase sanitized = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the sanitized string is a palindrome return sanitized == sanitized[::-1]"},{"question":"# Unique Anagram Identifier **Problem Statement**: You are required to implement a function `is_unique_anagram_identifier(word_list: List[str]) -> List[bool]` that determines for each word in the input list if it is the unique combination of letters among its anagrams in the list. An anagram of a word is any other word that can be formed by rearranging the letters of the original word. **Input and Output**: - **Input**: A list of `n` words where each word contains only lowercase alphabetical characters. - **Output**: A list of booleans, where the boolean value at each index indicates whether the corresponding word in the input list is unique among its anagrams. **Constraints**: - 1 <= n <= 1000 - 1 <= len(word) <= 100 **Examples**: ```python from typing import List def is_unique_anagram_identifier(word_list: List[str]) -> List[bool]: # Your implementation here print(is_unique_anagram_identifier([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"goolge\\"])) # [False, False, False, False, False, False] print(is_unique_anagram_identifier([\\"rat\\", \\"tar\\", \\"art\\", \\"car\\"])) # [False, False, False, True] print(is_unique_anagram_identifier([\\"abcd\\", \\"abc\\", \\"bac\\", \\"dabc\\", \\"abcdef\\", \\"bcdeaf\\"])) # [False, True, True, False, False, False] print(is_unique_anagram_identifier([\\"hello\\", \\"world\\", \\"python\\"])) # [True, True, True] print(is_unique_anagram_identifier([\\"a\\", \\"b\\", \\"a\\", \\"a\\"])) # [False, True, False, False] ``` **Guidelines**: 1. For each word in the list, generate a sorted character string which serves as a unique identifier for its anagrams. 2. Use these identifiers to determine if a word has any anagram in the list. 3. Construct a boolean list indicating if each word is unique among its anagrams in the list. 4. Handle edge cases, such as lists with a single word or duplicate words. The function should return: - A list of booleans where `True` indicates the word is unique among its anagrams, and `False` indicates there are other words in the list that are anagrams of this word.","solution":"from typing import List def is_unique_anagram_identifier(word_list: List[str]) -> List[bool]: anagram_map = {} result = [True] * len(word_list) for idx, word in enumerate(word_list): sorted_word = \'\'.join(sorted(word)) if sorted_word in anagram_map: for linked_idx in anagram_map[sorted_word]: result[linked_idx] = False result[idx] = False anagram_map[sorted_word].append(idx) else: anagram_map[sorted_word] = [idx] return result"},{"question":"New Additional Question # Scenario: You are developing a feature for an e-commerce platform that will allow users to search for products. Each product is represented as a dictionary with keys `id`, `name`, and `price`. For better user experience, search results should be grouped by the first letter of the product name and sorted within each group alphabetically by name. # Task: Write a function `group_and_sort_products` that takes a list of product dictionaries and returns a dictionary. The keys of the resulting dictionary should be the starting letters of product names, and the values should be lists of products (dictionaries) that start with that letter, sorted alphabetically by their name. # Expected Function: ```python def group_and_sort_products(products: list) -> dict: ``` # Input Format: - A list of dictionaries `products` with length `n` where `0 <= n <= 10^5`. - Each dictionary has the structure: `{\\"id\\": int, \\"name\\": str, \\"price\\": float}`. # Output Format: - A dictionary where keys are single letter strings and values are lists of product dictionaries sorted by name. # Constraints: - The grouping should be case insensitive (e.g., \'a\' and \'A\' are treated the same). - The sorting within each group should be in ascending order by the product name. - The function should handle empty input gracefully and return an empty dictionary if no products are provided. # Example: ```python >>> products = [ ... {\\"id\\": 1, \\"name\\": \\"apple\\", \\"price\\": 0.99}, ... {\\"id\\": 2, \\"name\\": \\"banana\\", \\"price\\": 0.59}, ... {\\"id\\": 3, \\"name\\": \\"cherry\\", \\"price\\": 2.99}, ... {\\"id\\": 4, \\"name\\": \\"avocado\\", \\"price\\": 1.49}, ... ] >>> group_and_sort_products(products) { \'a\': [ {\\"id\\": 1, \\"name\\": \\"apple\\", \\"price\\": 0.99}, {\\"id\\": 4, \\"name\\": \\"avocado\\", \\"price\\": 1.49} ], \'b\': [ {\\"id\\": 2, \\"name\\": \\"banana\\", \\"price\\": 0.59} ], \'c\': [ {\\"id\\": 3, \\"name\\": \\"cherry\\", \\"price\\": 2.99} ] } ``` # Notes: 1. Your implementation should handle edge cases, such as products with identical names or missing price information. 2. The order of the keys in the returned dictionary does not matter, but the lists of products should be consistently sorted.","solution":"from collections import defaultdict def group_and_sort_products(products: list) -> dict: Groups and sorts the given products by the first letter of their name. Args: products (list): List of product dictionaries with keys \'id\', \'name\', and \'price\'. Returns: dict: Dictionary where keys are the starting letter of the product name and values are lists of products sorted by name. grouped_products = defaultdict(list) for product in products: # Group products by the first letter (case insensitive) first_letter = product[\'name\'][0].lower() grouped_products[first_letter].append(product) # Sort products within each group by name for letter in grouped_products: grouped_products[letter].sort(key=lambda x: x[\'name\'].lower()) return dict(grouped_products)"},{"question":"# Coding Assessment Question You are tasked with implementing a utility that encrypts and decrypts messages using a simplified version of the Caesar cipher. The cipher shifts characters in the alphabet by a specified number of positions. Your goal is to enable robust encryption and decryption of messages under various scenarios. # Requirements 1. Implement a class `CaesarCipher` with the following methods: - `__init__(self, shift: int)`: Initializes the cipher with a specified shift. - `encrypt(self, message: str) -> str`: Encrypts the message by shifting characters based on the initialized shift value. - `decrypt(self, encrypted_message: str) -> str`: Decrypts the message by reversing the shift applied during encryption. 2. The cipher should only shift alphabetical characters (both uppercase and lowercase) and preserve the case of each letter. Non-alphabetical characters should remain unchanged. 3. The implemented methods should handle the following scenarios: - Circular shifting where the end of the alphabet wraps around (e.g., \'z\' shifted by 1 becomes \'a\'). - Both positive and negative shift values. - Mixed case sensitivity (both uppercase and lowercase letters). # Example Usage ```python cipher = CaesarCipher(3) encrypted_message = cipher.encrypt(\\"Hello, World!\\") print(encrypted_message) # Should output: \\"Khoor, Zruog!\\" decrypted_message = cipher.decrypt(encrypted_message) print(decrypted_message) # Should output: \\"Hello, World!\\" ``` # Constraints - The shift value will be an integer between -25 and 25 (inclusive). - The input message will be a string of length between 1 and 1000. - The input string will include both uppercase and lowercase letters as well as non-alphabetical characters. **Note**: Focus on efficiency and correctness in implementing the class methods. Ensure your solution is well-structured and easy to understand.","solution":"class CaesarCipher: def __init__(self, shift: int): self.shift = shift % 26 # Normalize the shift value def encrypt(self, message: str) -> str: return self._transform(message, self.shift) def decrypt(self, encrypted_message: str) -> str: return self._transform(encrypted_message, -self.shift) def _transform(self, message: str, shift: int) -> str: result = [] for char in message: if char.isalpha(): is_upper = char.isupper() base = ord(\'A\') if is_upper else ord(\'a\') new_char = chr((ord(char) - base + shift) % 26 + base) result.append(new_char) else: result.append(char) return \'\'.join(result)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with implementing a logistics optimization algorithm for a delivery truck. The goal is to minimize the total distance traveled while delivering packages to several destinations. The destinations will be represented by coordinates on a Cartesian plane. You need to implement the function `optimize_delivery_route` which finds the shortest possible route starting and ending at the depot. The route should be calculated using a variation of the Nearest Neighbor Algorithm (NNA), optimized to occasionally consider the second nearest neighbor to avoid local optima. Function Signature ```python def optimize_delivery_route( destinations: list[tuple[int, int]] ) -> tuple[list[int], float]: pass ``` Input - `destinations (list[tuple[int, int]])`: A list of tuples where each tuple represents the 2D coordinates of a delivery destination. The first tuple corresponds to the depot. Output - Returns a tuple containing: - A list of integers representing the indices of the destinations in the order they are visited, starting and ending at the depot. - A float representing the total distance of this route. Constraints - All coordinate values will be valid and positive. - The number of destinations will be at least 2 and up to 10^4. - The distance between two destinations is defined as the Euclidean distance. Requirements - **Route Optimization**: Implement the Nearest Neighbor Algorithm with an optimization that occasionally checks the second nearest neighbor. - **Performance Optimization**: Ensure that the algorithm efficiently computes the total distance and handles a large number of destinations. Example ```python destinations = [ (0, 0), # Depot (2, 3), (5, 8), (6, 2), (8, 6), (1, 7), ] result = optimize_delivery_route(destinations) print(f\\"Optimal Route: {result[0]}\\") print(f\\"Total Distance: {result[1]}\\") ``` Expected Output: ``` Optimal Route: [0, 1, 5, 2, 4, 3, 0] Total Distance: Approximately 27.58 ``` --- Notes 1. Ensure to handle edge cases where the input list is empty or contains very few destinations. 2. Precompute distances where necessary to avoid redundant calculations. 3. Utilize an optimized version of the Nearest Neighbor Algorithm by incorporating a probabilistic factor that occasionally considers the second nearest neighbor to prevent getting trapped in local optima. ---","solution":"import math def calculate_distance(point1, point2): return math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2) def optimize_delivery_route(destinations): if not destinations: return ([], 0.0) n = len(destinations) visited = [False] * n route = [0] total_distance = 0.0 current_index = 0 visited[0] = True for _ in range(1, n): closest_distance = float(\'inf\') second_closest_distance = float(\'inf\') closest_index = -1 second_closest_index = -1 for i in range(n): if not visited[i]: distance = calculate_distance(destinations[current_index], destinations[i]) if distance < closest_distance: second_closest_distance = closest_distance second_closest_index = closest_index closest_distance = distance closest_index = i elif distance < second_closest_distance: second_closest_distance = distance second_closest_index = i # Incorporate a probabilistic factor to occasionally use the second closest neighbor if second_closest_index != -1: if closest_distance == 0 or (second_closest_distance / closest_distance) < 1.1: chosen_index = second_closest_index chosen_distance = second_closest_distance else: chosen_index = closest_index chosen_distance = closest_distance else: chosen_index = closest_index chosen_distance = closest_distance visited[chosen_index] = True route.append(chosen_index) total_distance += chosen_distance current_index = chosen_index # Return to the depot total_distance += calculate_distance(destinations[current_index], destinations[0]) route.append(0) return (route, total_distance)"},{"question":"# Question **Sum of Multiples** Write a function `sum_of_multiples(limit: int, factors: List[int]) -> int` that finds the sum of all the multiples of a list of numbers up to but not including a given limit. # Input - `limit` (integer): the upper limit, a positive integer `limit >= 1`. - `factors` (list of integers): a list of integers where each integer `factor >= 1`. # Output - An integer representing the sum of all unique multiples of the given factors below the limit. # Constraints - Your solution should efficiently handle cases where `limit` is a large number, up to `10^6`. - Consider edge cases with the smallest possible inputs. # Example ```python def sum_of_multiples(limit: int, factors: List[int]) -> int: # Your implementation here. # Example Usage print(sum_of_multiples(10, [3, 5])) # Expected output: 23 print(sum_of_multiples(20, [7, 13, 17])) # Expected output: 51 print(sum_of_multiples(1000, [3, 5])) # Expected output: 233168 ``` # Explanation * For the first example, the multiples of 3 or 5 below 10 are: 3, 5, 6, 9. Their sum is 23. * For the second example, the multiples of 7, 13, or 17 below 20 are: 7, 14, 13, 17. Their sum is 51. * The function should take into account unique multiples and avoid double-counting values that are multiples of more than one factor.","solution":"from typing import List def sum_of_multiples(limit: int, factors: List[int]) -> int: Finds the sum of all unique multiples of a list of numbers up to but not including a given limit. Args: limit (int): The upper limit, a positive integer limit >= 1. factors (List[int]): A list of integers where each integer factor >= 1. Returns: int: The sum of all unique multiples of the given factors below the limit. multiples_set = set() for factor in factors: if factor >= limit: continue multiples_set.update(range(factor, limit, factor)) return sum(multiples_set)"},{"question":"Coding Assessment Question # Scenario An important task in computer science involves manipulating strings and their specific characters. One common problem is to determine the position of certain characters within a string. This skill is valuable for tasks ranging from text parsing to data manipulation. In particular, finding the nth occurrence of a substring within a string can be a common challenge. # Problem Design a function `find_nth_occurrence(substring: str, string: str, n: int) -> int` that locates the nth occurrence of a given substring within a larger string and returns the index of the start of the nth occurrence. If the nth occurrence does not exist, the function should return -1. 1. The input `substring` is the substring you are searching for within `string`. 2. The input `string` is the larger string in which to search. 3. The input `n` is the occurrence number you are interested in. Example ```python def find_nth_occurrence(substring: str, string: str, n: int) -> int: pass # Examples print(find_nth_occurrence(\\"test\\", \\"this is a test test test\\", 1)) # 10 (First occurrence of \\"test\\") print(find_nth_occurrence(\\"test\\", \\"this is a test test test\\", 2)) # 15 (Second occurrence of \\"test\\") print(find_nth_occurrence(\\"test\\", \\"this is a test test test\\", 3)) # 20 (Third occurrence of \\"test\\") print(find_nth_occurrence(\\"test\\", \\"this is a test test test\\", 4)) # -1 (Fourth occurrence does not exist) print(find_nth_occurrence(\\"a\\", \\"banana\\", 2)) # 3 (Second occurrence of \\"a\\") print(find_nth_occurrence(\\"a\\", \\"banana\\", 3)) # 5 (Third occurrence of \\"a\\") ``` # Constraints * The search is case sensitive. * If `substring` is an empty string, the function should always return -1. * If `n` is less than or equal to 0, the function should return -1. * The indices returned should be based on zero-indexing. # Function Signature ```python def find_nth_occurrence(substring: str, string: str, n: int) -> int: pass ``` # Considerations 1. **Efficiency**: Optimize your function to handle longer strings and multiple occurrences efficiently. 2. **Robustness**: Ensure your function handles edge cases such as overlapping occurrences. 3. **Validation**: Include validation to handle scenarios where `n` is too large relative to the number of occurrences available.","solution":"def find_nth_occurrence(substring: str, string: str, n: int) -> int: if not substring or n <= 0: return -1 index = -1 for _ in range(n): index = string.find(substring, index + 1) if index == -1: return -1 return index"},{"question":"# Problem Statement Create a program that generates the famous Fibonacci sequence using dynamic programming to optimize the calculation. The function should accept an integer value `n` and return the first `n` numbers in the Fibonacci sequence. Implement the following function: 1. `generate_fibonacci(n: int) -> List[int]` Function Definition * **`generate_fibonacci`**: * **Input**: * `n` (int): The number of terms in the Fibonacci sequence to generate. * **Output**: * `List[int]`: The first `n` numbers in the Fibonacci sequence. Constraints * `n` should be a non-negative integer. Error Handling * If `n` is not a non-negative integer, raise a `ValueError` with the message: `\\"generate_fibonacci() requires a non-negative integer for n\\"`. Examples * `generate_fibonacci(0)` should return `[]`. * `generate_fibonacci(1)` should return `[0]`. * `generate_fibonacci(5)` should return `[0, 1, 1, 2, 3]`. * `generate_fibonacci(10)` should return `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]`. * `generate_fibonacci(\\"five\\")` should raise a `ValueError`.","solution":"from typing import List def generate_fibonacci(n: int) -> List[int]: Generates the first n numbers in the Fibonacci sequence. :param n: Integer value representing the number of terms in the Fibonacci sequence to generate. :return: List of the first n numbers in the Fibonacci sequence. :raises ValueError: If n is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"generate_fibonacci() requires a non-negative integer for n\\") if n == 0: return [] if n == 1: return [0] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"# Question: Validate and Normalize Email Addresses You are tasked with writing two functions to: 1. **Validate** and **normalize** a given email address string. 2. **Normalize** a list of email addresses by removing duplicates and maintaining valid ones only. Function 1 Requirements: `validate_and_normalize_email` Your function needs to: - Accept a string `email`, representing an email address. - Validate if the input string is a well-formed email address. - Normalize the email by converting the local part (before `@`) to lowercase and removing any dots (.) if it is a Gmail address. - If valid, return the normalized email address. - If invalid, return `None`. # Input: - `email` (str): A string representing the email address. # Output: - (str or None): The normalized email if the input is valid, otherwise `None`. # Constraints: - The `email` string contains only valid email characters. # Example: ```python assert validate_and_normalize_email(\\"User.name@gmail.com\\") == \\"username@gmail.com\\" assert validate_and_normalize_email(\\"invalid_email@@example.com\\") is None ``` Function 2 Requirements: `normalize_emails` Your function needs to: - Accept a list `emails`, containing multiple email address strings. - Normalize each email address using the first function. - Remove duplicates and any invalid emails. - Return a list of unique, normalized, and valid email addresses. # Input: - `emails` (List[str]): A list of email address strings. # Output: - (List[str]): A list of unique, normalized, and valid email addresses. # Example: ```python assert normalize_emails([\\"User.name@gmail.com\\", \\"username@gmail.com\\", \\"valid.email@example.com\\", \\"invalid_email@@example.com\\"]) == [\\"username@gmail.com\\", \\"valid.email@example.com\\"] ``` # Solution Skeleton Here is a skeleton code for you to complete: ```python import re def validate_and_normalize_email(email: str) -> str: # Regex pattern for validating email email_pattern = r\'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\' if not re.match(email_pattern, email): return None local, domain = email.split(\'@\') if domain == \\"gmail.com\\": local = local.replace(\'.\', \'\').lower() else: local = local.lower() return f\\"{local}@{domain}\\" def normalize_emails(emails: list) -> list: normalized_set = set() result = [] for email in emails: normalized_email = validate_and_normalize_email(email) if normalized_email and normalized_email not in normalized_set: normalized_set.add(normalized_email) result.append(normalized_email) return result # Test your implementation if __name__ == \\"__main__\\": assert validate_and_normalize_email(\\"User.name@gmail.com\\") == \\"username@gmail.com\\" assert validate_and_normalize_email(\\"invalid_email@@example.com\\") is None assert normalize_emails([\\"User.name@gmail.com\\", \\"username@gmail.com\\", \\"valid.email@example.com\\", \\"invalid_email@@example.com\\"]) == [\\"username@gmail.com\\", \\"valid.email@example.com\\"] ```","solution":"import re def validate_and_normalize_email(email: str) -> str: # Regex pattern for validating email email_pattern = r\'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+\' if not re.match(email_pattern, email): return None local, domain = email.split(\'@\') if domain.lower() == \\"gmail.com\\": local = local.replace(\'.\', \'\').lower() else: local = local.lower() return f\\"{local}@{domain.lower()}\\" def normalize_emails(emails: list) -> list: normalized_set = set() result = [] for email in emails: normalized_email = validate_and_normalize_email(email) if normalized_email and normalized_email not in normalized_set: normalized_set.add(normalized_email) result.append(normalized_email) return result"},{"question":"# **Problem Statement:** You are tasked with designing a simple scheduling system that helps in managing the meeting schedules within a company. The system should avoid conflicts and allow for adding, removing, and checking meeting times. # **Function Specification:** 1. **`add_meeting(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool`** * **Input**: `schedule` (a dictionary where the keys are days of the week and the values are lists of tuples representing the start and end times of meetings), `day` (a string indicating the day of the week), `start` (an integer representing the start time in 24-hour format), `end` (an integer representing the end time in 24-hour format). * **Output**: A boolean value indicating whether the meeting was successfully added. Example: ```python >>> add_meeting({\'Monday\': [(9, 10)], \'Tuesday\': []}, \'Monday\', 10, 11) True ``` 2. **`remove_meeting(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool`** * **Input**: `schedule` (a dictionary where the keys are days of the week and the values are lists of tuples representing the start and end times of meetings), `day` (a string indicating the day of the week), `start` (an integer representing the start time in 24-hour format), `end` (an integer representing the end time in 24-hour format). * **Output**: A boolean value indicating whether the meeting was successfully removed. Example: ```python >>> remove_meeting({\'Monday\': [(9, 10), (10, 11)], \'Tuesday\': []}, \'Monday\', 10, 11) True ``` 3. **`check_meeting_conflict(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool`** * **Input**: `schedule` (a dictionary where the keys are days of the week and the values are lists of tuples representing the start and end times of meetings), `day` (a string indicating the day of the week), `start` (an integer representing the start time in 24-hour format), `end` (an integer representing the end time in 24-hour format). * **Output**: A boolean value indicating whether the new meeting conflicts with any existing meetings. Example: ```python >>> check_meeting_conflict({\'Monday\': [(9, 10)], \'Tuesday\': []}, \'Monday\', 9, 11) True ``` # **Implementation Notes:** * The `schedule` dictionary will have keys as days of the week (e.g., \\"Monday\\", \\"Tuesday\\",...) and the values will be lists of tuples containing start and end times. * The `start` and `end` times are given in a 24-hour format (e.g., 9 for 09:00 or 14 for 14:00). * For the `add_meeting`, `remove_meeting`, and `check_meeting_conflict` functions, ensure that they handle the time overlap efficiently and return consistent results regardless of day differences. # **Constraints:** * Meetings can start and end within the range of 0 to 23 (inclusive). * The input will be well-formed; no need to handle invalid inputs. # **Performance Requirements:** * Adding and removing meetings should be efficient, ideally in O(n) time complexity. * Checking for meeting conflicts should also be efficient and run within acceptable time limits for the given constraints. Good luck!","solution":"def add_meeting(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool: Adds a meeting to the schedule if there is no conflict. schedule: dictionary with days as keys and meeting time intervals as values day: day of the week start: start time of the meeting end: end time of the meeting Returns True if the meeting was added successfully, False if there was a conflict. if check_meeting_conflict(schedule, day, start, end): return False if day not in schedule: schedule[day] = [] schedule[day].append((start, end)) return True def remove_meeting(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool: Removes a meeting from the schedule if it exists. schedule: dictionary with days as keys and meeting time intervals as values day: day of the week start: start time of the meeting end: end time of the meeting Returns True if the meeting was removed successfully, False if the meeting was not found. if day in schedule and (start, end) in schedule[day]: schedule[day].remove((start, end)) return True return False def check_meeting_conflict(schedule: dict[str, list[tuple[int, int]]], day: str, start: int, end: int) -> bool: Checks if a meeting conflicts with existing meetings in the schedule. schedule: dictionary with days as keys and meeting time intervals as values day: day of the week start: start time of the meeting end: end time of the meeting Returns True if there is a conflict, False otherwise. if day not in schedule: return False for s, e in schedule[day]: if max(s, start) < min(e, end): # Overlap condition return True return False"},{"question":"# Maximum Subarray Sum with a Twist Problem Statement Given an array of integers `arr` and an integer `k`, your task is to find the maximum sum of any contiguous subarray of length exactly `k`. If the array length is less than `k`, return -1. # Input * An integer array `arr` (1 ≤ length(arr) ≤ 3000, -1000 ≤ arr[i] ≤ 1000) * An integer `k` (1 ≤ k ≤ 3000) # Output * Return an integer representing the maximum sum of any contiguous subarray of length exactly `k`. If no such subarray exists, return -1. # Constraints * The solution must run efficiently for all inputs within the constraints. # Examples ```python # Example 1 Input: arr = [1, 2, 3, 4, 5], k = 2 Output: 9 Explanation: The subarray [4, 5] has the maximum sum of 9. # Example 2 Input: arr = [5, 4, -1, 7, 8], k = 3 Output: 14 Explanation: The subarray [7, 8, -1] has the maximum sum of 14. # Example 3 Input: arr = [5, 4], k = 3 Output: -1 Explanation: No subarray of length 3 exists. ``` # Task Write a function `max_subarray_sum_with_exact_k(arr: list, k: int) -> int` that implements the above requirements. # Implementation ```python def max_subarray_sum_with_exact_k(arr: list, k: int) -> int: n = len(arr) if n < k: return -1 max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) return max_sum ```","solution":"def max_subarray_sum_with_exact_k(arr: list, k: int) -> int: n = len(arr) if n < k: return -1 max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, n): current_sum += arr[i] - arr[i-k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Longest Uniform Substring Context You are given a string `s` consisting of lowercase English letters. You need to find the longest substring where every character is the same. Task Write a function `longest_uniform_substring(s: str) -> str` to identify the longest contiguous substring where every character is identical. Function Signature ```python def longest_uniform_substring(s: str) -> str: ``` Input * `s`: A string consisting of lowercase English letters (1 ≤ len(s) ≤ 10^6). Output * Returns the longest contiguous substring where all characters are the same. If there are multiple substrings of the same maximum length, return the first one. Constraints * Your solution should have a time complexity of O(n). * Your solution should use O(1) additional space. Examples ```python >>> longest_uniform_substring(\\"aaabbccccd\\") \\"cccc\\" >>> longest_uniform_substring(\\"aabbbcc\\") \\"bbb\\" >>> longest_uniform_substring(\\"abcd\\") \\"a\\" ``` Notes Be mindful of edge cases such as: * Strings with no repeating characters (e.g., \\"abcd\\"). * Strings consisting of a single repeated character (e.g., \\"aaaaaa\\").","solution":"def longest_uniform_substring(s: str) -> str: Find the longest contiguous substring where every character is the same. Parameters: s (str): A string consisting of lowercase English letters. Returns: str: The longest uniform substring. if not s: return \\"\\" max_length = 1 current_length = 1 max_substr = s[0] for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length max_substr = s[i-1] * current_length current_length = 1 # Final check in case the longest substring is at the end if current_length > max_length: max_substr = s[-1] * current_length return max_substr"},{"question":"# Problem Statement You are required to implement a string transformation algorithm that efficiently transforms a given string into a target string with the fewest number of operations. The allowed operations are: 1. Insert a character. 2. Delete a character. 3. Replace a character. # Requirements 1. **Input**: - `source` : A string representing the initial text. - `target` : A string representing the desired text. 2. **Output**: - An integer representing the minimum number of operations required to transform the `source` string into the `target` string. # Constraints - The length of `source` and `target` will be between 1 and 1000. - The strings `source` and `target` will contain only lowercase English letters (a-z). # Example ```python # Sample inputs source = \\"kitten\\" target = \\"sitting\\" # Minimum operations to transform \\"kitten\\" into \\"sitting\\" result = min_operations(source, target) print(f\\"Minimum operations to transform \'{source}\' into \'{target}\': {result}\\") # Expected output: 3 # Explanation: # kitten -> sitten -> sittin -> sitting ``` # Instructions: 1. Implement the function `min_operations(source, target)` that calculates the minimum number of operations required to transform `source` into `target`. 2. Use dynamic programming to ensure your solution is efficient and handles the upper bound constraints effectively. 3. Ensure that the function runs with a time complexity of O(m*n), where `m` is the length of the `source` string and `n` is the length of the `target` string. ```python def min_operations(source, target): # Lengths of the source and target strings m, n = len(source), len(target) # Create a 2D array to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column of the 2D array for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j # Fill the 2D array with the minimum operations for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n] # Example usage source = \\"kitten\\" target = \\"sitting\\" result = min_operations(source, target) print(f\\"Minimum operations to transform \'{source}\' into \'{target}\': {result}\\") ```","solution":"def min_operations(source, target): Calculate the minimum number of operations required to transform source string into target string. Args: source (str): The initial string. target (str): The desired string. Returns: int: The minimum number of operations. # Lengths of the source and target strings m, n = len(source), len(target) # Create a 2D array to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the first row and column of the 2D array for i in range(1, m + 1): dp[i][0] = i for j in range(1, n + 1): dp[0][j] = j # Fill the 2D array with the minimum operations for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 return dp[m][n]"},{"question":"# Dynamic Programming: Minimum Path Sum in Grid Given an `m x n` grid filled with non-negative numbers, find a path from the top left to the bottom right that minimizes the sum of the numbers along its path. You can only move either down or right at any point in time. Problem Statement Design and implement a function: `min_path_sum(grid)`: Computes the minimum sum of a path from the top-left to the bottom-right of the provided grid. # Function Definition: - **`min_path_sum(grid)`**: - **Input**: A 2D list `grid` of non-negative integers. - **Output**: An integer which is the minimum sum of the path from the top-left to the bottom-right. - **Constraints**: - 1 <= grid.length, grid[0].length <= 200 - 0 <= grid[i][j] <= 100 Example: ```python grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] result = min_path_sum(grid) print(f\\"Minimum Path Sum: {result}\\") ``` Expected Output: - Minimum Path Sum: 7 # Additional Requirements: - Optimize your implementation to handle the given constraints. - Handle edge cases such as very small grids (1x1). Ensure your solution works efficiently by leveraging dynamic programming to store intermediate results. This way, the algorithm avoids recalculating the minimum path sum for overlapping subproblems. This question assesses your understanding of dynamic programming and your ability to apply it to grid-based problems.","solution":"def min_path_sum(grid): Computes the minimum sum of a path from the top-left to the bottom-right of the provided grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize the DP table with the same dimensions as grid. dp = [[0] * n for _ in range(m)] # Initialize the starting point. dp[0][0] = grid[0][0] # Fill the first row. for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column. for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remainder of the grid. for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum path sum. return dp[m-1][n-1]"},{"question":"# Problem Statement Write a function to determine if a robot reaches its starting position after a sequence of moves on a 2D grid. The robot starts at the origin `(0,0)` and has a sequence of movements specified by a string. Each character in the string corresponds to a move as follows: - \'U\' for up - \'D\' for down - \'L\' for left - \'R\' for right Your task is to determine whether, after completing all moves, the robot returns to the starting position `(0, 0)`. # Requirements * Write a function `is_back_at_origin` that takes a single parameter: 1. A string `moves` consisting of characters \'U\', \'D\', \'L\', and \'R\'. * The function should return a boolean value: * `True` if the robot returns to the origin after all moves. * `False` otherwise. # Constraints * The length of `moves` can be up to 1000. # Input ```python is_back_at_origin(moves: str) -> bool ``` # Output A boolean value `True` if the robot returns to the origin, and `False` otherwise. # Example ```python moves = \\"UDLR\\" result = is_back_at_origin(moves) print(result) # Output should be True since each move cancels the previous one ``` # Notes * Make sure to handle edge cases such as an empty string which should return `True` since no moves implies the robot hasn\'t left the origin. * You may assume all characters in the input string are valid (\'U\', \'D\', \'L\', \'R\').","solution":"def is_back_at_origin(moves: str) -> bool: Determine if the robot returns to the origin after completing the moves. Parameters: - moves: str - sequence of moves consisting of \'U\', \'D\', \'L\', \'R\' Returns: - bool - True if the robot returns to the origin, False otherwise x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Matrix Zigzag Traversal As a computer scientist, you might need to traverse matrices in various orders for different algorithms. One common traversal is the zigzag order, where the matrix is traversed in a zigzag pattern from the top-left corner to the bottom-right corner. # Problem Statement You need to write a function `zigzag_traversal(matrix: List[List[int]]) -> List[int]` that returns a list of integers representing the elements of the given matrix in zigzag order. # Constraints * The input `matrix` is a 2D list of integers. * The number of rows (m) and columns (n) of the matrix can range from 1 to 100. * Each element in the matrix can be any integer between -10^4 and 10^4. # Input - `matrix`: A list of lists of integers representing the matrix. # Output A list of integers representing the matrix elements in zigzag order. # Examples ```python def zigzag_traversal(matrix: List[List[int]]) -> List[int]: pass if __name__ == \\"__main__\\": # Example Test Cases print(zigzag_traversal([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ])) # Expected [1, 2, 3, 6, 5, 4, 7, 8, 9] print(zigzag_traversal([ [1, 2], [3, 4] ])) # Expected [1, 2, 4, 3] print(zigzag_traversal([ [1] ])) # Expected [1] print(zigzag_traversal([ [1], [2], [3] ])) # Expected [1, 2, 3] ``` # Additional Information * Think about handling edge cases such as single row or single column matrices. * Consider iterating over the matrix while keeping track of the direction of traversal. # Hint * Try to visualize the zigzag pattern by dividing matrix traversal into segments where the direction alternates.","solution":"from typing import List def zigzag_traversal(matrix: List[List[int]]) -> List[int]: Traverse the given matrix in zigzag order and return the result as a list. if not matrix: return [] result = [] rows = len(matrix) cols = len(matrix[0]) for row in range(rows): if row % 2 == 0: # Left to right for col in range(cols): result.append(matrix[row][col]) else: # Right to left for col in range(cols - 1, -1, -1): result.append(matrix[row][col]) return result"},{"question":"# Coding Question: Quadratic Equation Solver You need to write a Python function that finds the roots of a quadratic equation of the form `ax^2 + bx + c = 0`. Function Signature ```python def solve_quadratic(a: int, b: int, c: int) -> tuple: pass ``` Input - `a` (int): Coefficient of ( x^2 ), non-zero integer. - `b` (int): Coefficient of ( x ), integer. - `c` (int): Constant term, integer. Output - A tuple containing the real roots of the equation. If the equation has: - Two distinct real roots: return the roots in ascending order. - One real root (a repeated root): return a tuple with the root repeated. - No real roots: return the tuple `()`. Constraints - Account for precision errors while comparing floating-point numbers. - Handle both positive and negative values for the coefficients. - Assume that the coefficients are within the permissible range of integers in Python. Example ```python print(solve_quadratic(1, -3, 2)) # Output: (1.0, 2.0) print(solve_quadratic(1, 2, 1)) # Output: (-1.0, -1.0) print(solve_quadratic(1, 0, 1)) # Output: () print(solve_quadratic(2, 4, 2)) # Output: (-1.0, -1.0) ``` Notes - Utilize the quadratic formula ( x = frac{-b ± sqrt{b^2 - 4ac}}{2a} ). - Handle the discriminant value ( b^2 - 4ac ) to determine the nature of the roots. - Ensure the return tuple follows the constraints for different cases without fail. Implement your function below: ```python import math def solve_quadratic(a: int, b: int, c: int) -> tuple: discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2)) elif discriminant == 0: root = -b / (2*a) return (root, root) else: return () ```","solution":"import math def solve_quadratic(a: int, b: int, c: int) -> tuple: discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b + math.sqrt(discriminant)) / (2*a) root2 = (-b - math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2)) elif discriminant == 0: root = -b / (2*a) return (root, root) else: return ()"},{"question":"# Problem Statement You are given a rectangular grid of dimensions `n x m` filled with a mix of 0s and 1s. Your task is to find the largest rectangular sub-grid consisting entirely of 1s. Implement a function `largest_ones_rectangle(grid: List[List[int]]) -> int`. The function should return the area of the largest rectangle filled solely with 1s. # Input: * A grid `grid` represented by a list of lists of integers, where each integer is either 0 or 1. # Output: * Return an integer representing the area of the largest rectangle filled entirely with 1s. # Constraints: * The dimensions `n` and `m` of the grid will be between 1 and 100 inclusive. * The grid will always contain at least one element. # Example: ```python def test_largest_ones_rectangle(): assert largest_ones_rectangle([[1, 0, 1, 0, 0], [1, 0, 1, 1, 1], [1, 1, 1, 1, 1], [1, 0, 0, 1, 0]]) == 6 assert largest_ones_rectangle([[0, 1], [1, 1]]) == 2 assert largest_ones_rectangle([[0]]) == 0 assert largest_ones_rectangle([[1, 1], [1, 1]]) == 4 test_largest_ones_rectangle() ``` # Performance Considerations: * Ensure that the solution efficiently finds the largest rectangle, potentially by utilizing dynamic programming or other optimization techniques. * Consider the time complexity to handle the upper constraints effectively.","solution":"from typing import List def largest_histogram_area(heights: List[int]) -> int: Helper function to find the largest rectangle area in a histogram. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def largest_ones_rectangle(grid: List[List[int]]) -> int: Finds the largest rectangular sub-grid consisting entirely of 1s. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) max_area = 0 # Initialize histogram heights for each column heights = [0] * m for row in range(n): for col in range(m): if grid[row][col] == 0: heights[col] = 0 else: heights[col] += 1 # Calculate the maximum area in this row\'s histogram representation max_area = max(max_area, largest_histogram_area(heights)) return max_area"},{"question":"# Problem Statement You are tasked with creating a feature for a company\'s messaging application that supports group chats. Your job is to implement a function that finds the user who is the most active in a specific chat group. The activity of a user is measured by the number of messages they have sent in the group. # Function Signature ```python def find_most_active_user(messages: List[Tuple[int, int]]) -> int: :param messages: A list of tuples where each tuple contains (user_id, group_id), representing a message sent by user with id `user_id` in the group with id `group_id`. :return: The user_id of the user who sent the most messages in the specified group. Example: >>> messages = [(1, 101), (2, 101), (1, 101), (3, 102), (2, 101), (3, 102), (2, 101)] >>> group_id = 101 >>> result = find_most_active_user(messages, group_id) >>> result 2 def find_most_active_user_in_group(messages: List[Tuple[int, int]], group_id: int) -> int: message_counts = {} for user_id, g_id in messages: if g_id == group_id: if user_id in message_counts: message_counts[user_id] += 1 else: message_counts[user_id] = 1 most_active_user = max(message_counts, key=message_counts.get) return most_active_user ``` # Input * `messages`: A list of tuples, where each tuple `(user_id, group_id)` represents a message sent by the user with id `user_id` in the group with id `group_id`. * `group_id`: An integer representing the group of interest. # Output * The `user_id` of the user who sent the most messages in the specified group. If the group has no messages, your function should return `None`. # Constraints * Each `user_id` and `group_id` is a positive integer. * The length of the `messages` list is at most 100,000. # Example Given `messages = [(1, 101), (2, 101), (1, 101), (3, 102), (2, 101), (3, 102), (2, 101)]` and `group_id = 101`, the function should return: ``` 2 ``` # Detailed Description 1. Initialize an empty dictionary `message_counts` to keep track of the number of messages sent by each user in the specified group. 2. Iterate through each message tuple in the `messages` list and update the count only if the message\'s group_id matches the input group_id. 3. Determine the user who sent the most messages by finding the maximum value in the `message_counts` dictionary. 4. Return the `user_id` corresponding to the highest count.","solution":"from typing import List, Tuple def find_most_active_user(messages: List[Tuple[int, int]], group_id: int) -> int: Returns the user_id of the user who sent the most messages in the specified group. :param messages: A list of tuples where each tuple contains (user_id, group_id) :param group_id: An integer representing the group of interest :return: The user_id of the user who sent the most messages in the specified group. If no messages exist for the specified group, return None. message_counts = {} for user_id, g_id in messages: if g_id == group_id: if user_id in message_counts: message_counts[user_id] += 1 else: message_counts[user_id] = 1 if not message_counts: return None most_active_user = max(message_counts, key=message_counts.get) return most_active_user"},{"question":"# Scenario A financial application requires the ability to track and manage transactions. To enhance application performance and maintain transaction history, you decide to implement a custom data structure that supports efficient insertion, retrieval, and deletion of transactions. Each transaction can be uniquely identified by an ID and includes details such as the amount and a timestamp. # Task 1. **Implement `Transaction` class** - Each `Transaction` object should have the following properties: - `transaction_id`: A unique string identifier. - `amount`: A float representing the transaction amount. - `timestamp`: An integer representing the transaction timestamp. 2. **Implement `TransactionLog` class** - The `TransactionLog` class should support the following methods: - `add_transaction(transaction: Transaction) -> None`: Adds a new transaction to the log. - `get_transaction(transaction_id: str) -> Optional[Transaction]`: Retrieves a transaction by its ID. Returns `None` if the ID does not exist. - `delete_transaction(transaction_id: str) -> bool`: Deletes a transaction by its ID. Returns `True` if the transaction was deleted, `False` otherwise. # Requirements - Ensure the `Transaction` and `TransactionLog` classes function correctly as described. - Use appropriate data structures to optimize for fast access and modification. - Handle potential errors and edge cases gracefully. # Class Specifications # `Transaction` - **Attributes**: - `transaction_id` (str): Unique identifier for the transaction. - `amount` (float): Amount of the transaction. - `timestamp` (int): Timestamp representing the time of the transaction. # `TransactionLog` - **Methods**: - `add_transaction(transaction: Transaction) -> None` - `get_transaction(transaction_id: str) -> Optional[Transaction]` - `delete_transaction(transaction_id: str) -> bool` # Example Usage ```python # Create transactions t1 = Transaction(transaction_id=\\"12345\\", amount=150.0, timestamp=1625472000) t2 = Transaction(transaction_id=\\"67890\\", amount=75.5, timestamp=1625478000) # Create a transaction log log = TransactionLog() # Add transactions log.add_transaction(t1) log.add_transaction(t2) # Retrieve a transaction retrieved = log.get_transaction(\\"12345\\") print(retrieved.transaction_id) # Output: \\"12345\\" # Delete a transaction is_deleted = log.delete_transaction(\\"67890\\") print(is_deleted) # Output: True # Attempt to retrieve a deleted transaction retrieved = log.get_transaction(\\"67890\\") print(retrieved) # Output: None ``` # Additional Considerations - Ensure the `TransactionLog` efficiently handles a large number of transactions. - Validate transaction data integrity before adding it to the log. - Aim for clear and reusable code implementation.","solution":"from typing import Optional class Transaction: def __init__(self, transaction_id: str, amount: float, timestamp: int): self.transaction_id = transaction_id self.amount = amount self.timestamp = timestamp class TransactionLog: def __init__(self): self.transactions = {} def add_transaction(self, transaction: Transaction) -> None: self.transactions[transaction.transaction_id] = transaction def get_transaction(self, transaction_id: str) -> Optional[Transaction]: return self.transactions.get(transaction_id) def delete_transaction(self, transaction_id: str) -> bool: if transaction_id in self.transactions: del self.transactions[transaction_id] return True return False"},{"question":"# Sudoku Solver: Unique Solution Validator A Sudoku puzzle is a 9x9 grid composed of 9 subgrids, each 3x3, that need to be filled with numbers from 1 to 9. Each row, column, and subgrid must contain all the numbers from 1 to 9 without repetition. A valid Sudoku puzzle has only one unique solution. Your task is to implement a function that validates whether a given partially filled Sudoku board has at least one valid solution. If it’s possible to solve the Sudoku puzzle to fit these constraints, return `True`, otherwise return `False`. Function Signature: ```python def is_solvable(sudoku_board: List[List[int]]) -> bool: # Your code here ``` Requirements: 1. **Solver Function**: - Create a function `is_solvable(sudoku_board: List[List[int]]) -> bool` that verifies if the Sudoku puzzle has at least one possible solution. - Utilize backtracking or other problem-solving techniques to determine the solvability. - Ensure the function handles edge cases like empty grids or nearly complete grids efficiently. Constraints: - The input `sudoku_board` will be a 9x9 grid with integers ranging from 0 to 9. Here, `0` represents an empty cell that needs to be filled. - There will be at least one empty cell (represented by `0`) in the input grid. - The function should return `True` if at least one solution exists, otherwise `False`. Input/Output Examples: ```python from typing import List assert is_solvable([ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ]) == True assert is_solvable([ [5, 1, 6, 8, 4, 9, 7, 3, 2], [3, 0, 7, 6, 0, 0, 5, 0, 0], [8, 0, 9, 7, 0, 0, 0, 6, 0], [1, 3, 5, 0, 6, 0, 9, 0, 7], [4, 7, 2, 5, 9, 1, 0, 0, 6], [9, 6, 8, 3, 7, 0, 0, 0, 0], [2, 5, 3, 1, 8, 6, 0, 7, 4], [6, 8, 4, 2, 0, 7, 0, 5, 0], [7, 0, 1, 0, 5, 0, 0, 0, 0] ]) == False ``` Note: - Your solution should be efficient while ensuring correctness. - Ensure you validate the input to handle cases where the input grid does not meet the initial conditions.","solution":"from typing import List def is_solvable(sudoku_board: List[List[int]]) -> bool: def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = 0 return False return True return solve(sudoku_board)"},{"question":"# Coding Assessment Question Objective: Implement a function `min_window_substring(s: str, t: str) -> str` that returns the minimum window substring of `s` which contains all the characters in `t`. Function Specification: * **Input**: - `s`: A string representing the source string. - `t`: A string representing the target string to be found as a subsequence within `s`. * **Output**: - A string representing the minimum window substring of `s` that contains all the characters in `t`. - If no such substring exists, return an empty string `\\"\\"`. * **Constraints**: - `1 <= len(s), len(t) <= 1000` - Both strings `s` and `t` will consist of lowercase English letters. * **Performance Requirements**: - Optimally aim for a solution with a time complexity of `O(n)` where `n` is the length of the source string `s`. Example: ```python >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"a\\", \\"a\\") \\"a\\" >>> min_window_substring(\\"a\\", \\"aa\\") \\"\\" ``` Scenario: You are tasked with developing a search functionality within a text editor. One specific feature allows users to highlight the smallest part of a document that contains all specified keyword characters. Your function should efficiently determine this minimal substring to enhance document navigation and editing capabilities.","solution":"def min_window_substring(s: str, t: str) -> str: from collections import Counter if not t or not s: return \\"\\" dict_t = Counter(t) required = len(dict_t) left, right = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while right < len(s): character = s[right] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while left <= right and formed == required: character = s[left] if right - left + 1 < ans[0]: ans = (right - left + 1, left, right) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 left += 1 right += 1 return \\"\\" if ans[0] == float(\\"inf\\") else s[ans[1]: ans[2] + 1]"},{"question":"# Coding Assessment Question Context: You are working on a coding challenge that involves optimizing search algorithms in large datasets. Your task is to implement a specialized search function that can handle a combination of exact and partial matches efficiently. Given an array of strings where each string represents a data entry, your job is to write a function that searches for records in the dataset based on specific criteria. Task: 1. Implement a function `build_index(data: list[str]) -> dict[str, list[int]]` that creates an index of the dataset. The dictionary keys should be the substrings and the values should be lists of indices where these substrings appear in the dataset. 2. Write a function `search_records(query: str, index: dict[str, list[int]], data: list[str]) -> list[str]` that returns all records from the dataset which match the query string. If the query string contains an asterisk `*`, it should be treated as a wildcard that matches any sequence of characters. Constraints: * The input dataset, `data`, can contain up to 100,000 strings. * Each string in `data` has a length between 1 and 1000 characters. * The query string, `query`, will have a maximum length of 100 characters. * Wildcards in the query string will be represented by asterisk `*` and can appear at any position. Example Input and Output: ```python >>> data = [\\"apple\\", \\"application\\", \\"appreciate\\", \\"banana\\", \\"bandana\\", \\"canary\\"] >>> index = build_index(data) >>> search_records(\\"app*\\", index, data) [\\"apple\\", \\"application\\", \\"appreciate\\"] >>> search_records(\\"*ana\\", index, data) [\\"banana\\", \\"bandana\\"] >>> search_records(\\"can*\\", index, data) [\\"canary\\"] ``` Notes: * Ensure to handle edge cases such as empty dataset. * Optimize your code to minimize both time and space complexity, especially for large datasets. * Ensure the wildcard matching is implemented efficiently and handles multiple wildcards within the query string. * Consider edge cases such as the presence of multiple asterisks in the query string. The goal is to create an efficient search system that can quickly retrieve relevant records from large datasets based on partial and exact match queries.","solution":"import re def build_index(data): Build an index for the dataset where keys are substrings and values are the list of indices where these substrings appear in the dataset. index = {} for i, record in enumerate(data): for start in range(len(record)): for end in range(start + 1, len(record) + 1): substring = record[start:end] if substring not in index: index[substring] = [] index[substring].append(i) return index def search_records(query, index, data): Search for records in the dataset which match the query string. Handles wildcard \'*\' as any sequence of characters. if \'*\' in query: # Convert wildcard query to a regex pattern regex_pattern = re.compile(\'^\' + re.escape(query).replace(\'*\', \'.*\') + \'\') return [record for record in data if regex_pattern.match(record)] elif query in index: return [data[i] for i in index[query]] else: return []"},{"question":"# Temperature Conversion Program Write a function `convert_temperature` that takes a temperature value and its scale (Celsius, Fahrenheit, or Kelvin) and converts it to the other two scales. # Function Signature ```python def convert_temperature(value: float, scale: str) -> dict: ``` # Input * `value` (float): The temperature value to be converted. Can be any real number. * `scale` (str): The scale of the input temperature. Must be one of the following (\'C\', \'F\', \'K\') representing Celsius, Fahrenheit, and Kelvin respectively. # Output * `dict`: A dictionary containing the converted temperatures in the other two scales, with keys \'C\', \'F\', and \'K\'. # Constraints * The `scale` must be one of (\'C\', \'F\', \'K\'). If an invalid scale is provided, raise a `ValueError` with the message \\"Invalid scale: scale must be \'C\', \'F\', or \'K\'\\". # Examples ```python >>> convert_temperature(0, \'C\') {\'F\': 32.0, \'K\': 273.15} >>> convert_temperature(32, \'F\') {\'C\': 0.0, \'K\': 273.15} >>> convert_temperature(273.15, \'K\') {\'C\': 0.0, \'F\': 32.0} >>> convert_temperature(100, \'C\') {\'F\': 212.0, \'K\': 373.15} >>> convert_temperature(212, \'F\') {\'C\': 100.0, \'K\': 373.15} >>> convert_temperature(373.15, \'K\') {\'C\': 100.0, \'F\': 212.0} >>> convert_temperature(25, \'X\') Traceback (most recent call last): ... ValueError: Invalid scale: scale must be \'C\', \'F\', or \'K\' ``` # Notes 1. Use the following formulas for the conversions: * Celsius to Fahrenheit: ( F = C times frac{9}{5} + 32 ) * Celsius to Kelvin: ( K = C + 273.15 ) * Fahrenheit to Celsius: ( C = (F - 32) times frac{5}{9} ) * Fahrenheit to Kelvin: First convert to Celsius, then to Kelvin. * Kelvin to Celsius: ( C = K - 273.15 ) * Kelvin to Fahrenheit: First convert to Celsius, then to Fahrenheit. 2. Ensure that the inputs are valid and handle any exceptions as specified above. 3. The returned dictionary should include all three temperature scales, with the original value excluded.","solution":"def convert_temperature(value: float, scale: str) -> dict: Convert the given temperature `value` from the `scale` to the other two scales. Parameters: value (float): The temperature to be converted. scale (str): The scale of the input temperature (\'C\', \'F\', or \'K\'). Returns: dict: A dictionary with keys \'C\', \'F\', \'K\' containing the converted temperatures. if scale not in (\'C\', \'F\', \'K\'): raise ValueError(\\"Invalid scale: scale must be \'C\', \'F\', or \'K\'\\") if scale == \'C\': F = value * 9/5 + 32 K = value + 273.15 return {\'F\': F, \'K\': K} elif scale == \'F\': C = (value - 32) * 5/9 K = C + 273.15 return {\'C\': C, \'K\': K} elif scale == \'K\': C = value - 273.15 F = C * 9/5 + 32 return {\'C\': C, \'F\': F}"},{"question":"# Task You are given an array of integers `arr` and an integer `k`. Your goal is to implement a function that finds all the distinct elements that appear at least `k` times in the array. # Function Signature ```python def find_elements_with_frequency(arr: list, k: int) -> list: pass ``` # Input * `arr` (list): A list of integers. * `k` (int): The minimum frequency threshold. # Output * Returns a list containing the distinct elements that appear at least `k` times in the array, sorted in ascending order. If no such elements exist, return an empty list. # Constraints * The length of the array `arr` is between 1 and 10^5. * The integers in `arr` range from -10^6 to 10^6. * `k` is a positive integer. # Example ```python arr = [1, 2, 3, 1, 2, 1, 4, 5, 6, 2, 2, 2, 3, 3] k = 3 assert find_elements_with_frequency(arr, k) == [1, 2, 3] arr = [5, 5, 5, 5, 5, 5] k = 2 assert find_elements_with_frequency(arr, k) == [5] arr = [1, 2, 3, 4, 5] k = 2 assert find_elements_with_frequency(arr, k) == [] ``` # Notes 1. The function should handle edge cases gracefully, such as when `k` is larger than the length of the array. 2. Consider using data structures that optimize the frequency counting process to improve performance for large arrays.","solution":"def find_elements_with_frequency(arr, k): from collections import Counter # Count the frequency of each element in the array freq_counter = Counter(arr) # Filter the elements that have frequency >= k and sort them result = [elem for elem, count in freq_counter.items() if count >= k] return sorted(result)"},{"question":"# Coding Assessment Question Context Imagine you are working on a software application that manages parking for a large complex. The application should be able to efficiently find and reserve available parking spots based on the preferences of the user, such as preferring spots closer to their destination. Task Implement a function `find_parking_spot(parking_lot: List[List[int]], start_row: int, start_col: int) -> Tuple[int, int]` that finds the closest available parking spot to a given starting point (`start_row`, `start_col`). Parking spots are represented as a 2D grid where `1` indicates an occupied spot and `0` indicates an available spot. Implementation * Your function should: - Ensure `parking_lot` is a non-empty list of lists containing only integers `0` or `1`. - Ensure `start_row` and `start_col` are valid indices within the grid. - Return a tuple representing the coordinates of the closest available parking spot (`row`, `col`). If multiple spots are equidistant, return any one of them. - Use Breadth-First Search (BFS) to find the shortest path to an available spot. Constraints - The grid can have up to `1000 x 1000` dimensions. - `0 <= start_row < len(parking_lot)` - `0 <= start_col < len(parking_lot[0])` Input/Output Format - Input: A 2D list of integers `parking_lot`, and two integers `start_row` and `start_col`. - Output: A tuple representing the coordinates of the closest available parking spot. Example ```python def find_parking_spot(parking_lot: List[List[int]], start_row: int, start_col: int) -> Tuple[int, int]: # Your implementation here # Example usage: print(find_parking_spot([[1, 0, 1], [1, 1, 0], [0, 1, 1]], 1, 1)) # Output: (0, 1) or (2, 0) or (1, 2) print(find_parking_spot([[1, 1, 1], [1, 0, 1], [1, 1, 1]], 0, 0)) # Output: (1, 1) ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"from collections import deque from typing import List, Tuple def find_parking_spot(parking_lot: List[List[int]], start_row: int, start_col: int) -> Tuple[int, int]: Finds the closest available parking spot to a given starting point in a parking lot represented as a 2D grid. if parking_lot[start_row][start_col] == 0: return (start_row, start_col) rows = len(parking_lot) cols = len(parking_lot[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(start_row, start_col)]) visited.add((start_row, start_col)) while queue: row, col = queue.popleft() for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited: if parking_lot[new_row][new_col] == 0: return (new_row, new_col) queue.append((new_row, new_col)) visited.add((new_row, new_col)) return -1, -1 # In case there is no available spot, which should not happen under valid constraints"},{"question":"# Sequential Palindrome Checker **Problem Statement**: You need to create a function that checks whether a given sequence (string or list) is a palindrome. A sequence is considered a palindrome if it reads the same forwards and backwards. **Function Signature**: ```python def is_palindrome(sequence: str | list) -> bool: pass ``` # Input Description: * **sequence**: A non-empty alphanumeric string or list containing at least one element. # Output Description: * Returns a boolean `True` if the sequence is a palindrome, `False` otherwise. # Constraints: * The sequence length can range from 1 to 10^5. * The input sequence can include alphabetic characters (both cases), numerical digits, or a mixture of both in the case of strings. * The list elements can be of any data type which supports equality comparison. # Examples: ```python assert is_palindrome(\\"racecar\\") == True assert is_palindrome(\\"hello\\") == False assert is_palindrome([1, 2, 3, 2, 1]) == True assert is_palindrome([1, 2, 3, 4]) == False assert is_palindrome(\\"A man, a plan, a canal, Panama\\".lower().replace(\\" \\", \\"\\").replace(\\",\\", \\"\\")) == True ``` # Scenario: You are building a feature for a text processing tool that includes various utility functions such as phrase classification and data validation, where palindrome checks play a significant role. This function could be used in areas such as natural language processing, database management, and data analysis. **Implementation Advice**: 1. **Normalization**: For string inputs, consider lowercasing and removing non-alphanumeric characters if needed. 2. **Efficiency**: Optimize to minimize lookups, potentially halving operation count with two-pointer technique. 3. **Generality**: Ensure compatibility with any sequence type supporting equality operations. 4. **Edge Cases**: Handle single-element and empty sequences gracefully.","solution":"def is_palindrome(sequence: str | list) -> bool: Checks if the given sequence (string or list) is a palindrome. Args: sequence (str | list): The sequence to check. Returns: bool: True if the sequence is a palindrome, False otherwise. return sequence == sequence[::-1]"},{"question":"# Question: Implement a Circular Buffer in Python Scenario You are tasked with implementing a circular buffer for a data acquisition system. A circular buffer (also known as a ring buffer) is a fixed-size buffer that wraps around upon reaching the end, overwriting the oldest data with new data. This is useful in applications where data continuously flows in and you only need the most recent data points. Task 1. Implement a class `CircularBuffer` that simulates a circular buffer. The class should include methods to: - Insert an item into the buffer. - Retrieve all items in the buffer in order. - Check if the buffer is full. - Analyze the performance of the circular buffer. 2. Your `CircularBuffer` class should include the following methods: - `insert(item: Any) -> None`: Adds an item to the buffer. - `get_all_items() -> List[Any]`: Returns all items currently stored in the buffer, ordered from the oldest to the newest. - `is_full() -> bool`: Returns `True` if the buffer is full, else `False`. Input and Output Formats - **Input**: - Items to be inserted: list of any type. - Buffer size: an integer that specifies the capacity of the buffer. - **Output**: - The `get_all_items()` method should return a list of all items in the buffer. - The `insert` method should return `None`. - The `is_full` method should return a boolean. Constraints: - The buffer size must be a positive integer. - The buffer should handle at least 1,000,000 items efficiently. - The buffer should implement O(1) time complexity for `insert` and `is_full` operations. Performance Requirements: - The `insert` method should handle inserting items efficiently. - Ensure your buffer can handle frequent inserts without significant performance degradation. Implementation Hints: - Utilize modular arithmetic to manage the buffer index wrap around. - Use an internal list to store buffer items. Requirements: - Thoroughly test your implementation with edge cases. - Include documentation and comments to explain your logic and decisions. ```python from typing import Any, List class CircularBuffer: def __init__(self, size: int): if size <= 0: raise ValueError(\\"Buffer size must be a positive integer\\") self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.full = False def insert(self, item: Any) -> None: self.buffer[self.end] = item self.end = (self.end + 1) % self.size if self.full: self.start = (self.start + 1) % self.size elif self.end == self.start: self.full = True def get_all_items(self) -> List[Any]: if not self.full and self.end == self.start: return [] if self.full: if self.end == self.start: return self.buffer[self.start:] + self.buffer[:self.start] else: raise RuntimeError(\\"Buffer state inconsistent\\") return self.buffer[self.start:self.end] def is_full(self) -> bool: return self.full # Sample usage: # buffer = CircularBuffer(5) # buffer.insert(1) # buffer.insert(2) # buffer.insert(3) # print(buffer.get_all_items()) # Output: [1, 2, 3] # buffer.insert(4) # buffer.insert(5) # buffer.insert(6) # Overwrites 1 # print(buffer.get_all_items()) # Output: [2, 3, 4, 5, 6] # print(buffer.is_full()) # Output: True ```","solution":"from typing import Any, List class CircularBuffer: def __init__(self, size: int): if size <= 0: raise ValueError(\\"Buffer size must be a positive integer\\") self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.full = False def insert(self, item: Any) -> None: self.buffer[self.end] = item self.end = (self.end + 1) % self.size if self.full: self.start = (self.start + 1) % self.size elif self.end == self.start: self.full = True def get_all_items(self) -> List[Any]: if not self.full and self.end == self.start: return [] if self.full: return self.buffer[self.start:] + self.buffer[:self.end] return self.buffer[self.start:self.end] def is_full(self) -> bool: return self.full"},{"question":"# Problem Statement Implement functions to perform matrix operations for checking if a given matrix is symmetric and computing the power of a symmetric matrix raised to a given integer exponent. These operations are commonly used in various domains like physics, statistics, and engineering for tasks involving symmetric matrices. # Function Definitions 1. `is_symmetric(matrix: np.ndarray) -> bool` - **Input**: A square matrix represented as a 2D numpy array. - **Output**: `True` if the matrix is symmetric (i.e., equal to its transpose), `False` otherwise. 2. `matrix_power(matrix: np.ndarray, exponent: int) -> np.ndarray` - **Input**: - `matrix`: A symmetric, square matrix represented as a 2D numpy array. - `exponent`: An integer representing the power to which the matrix should be raised. - **Output**: The resulting matrix after raising the input matrix to the given exponent. - **Constraints**: - Ensure the matrix is symmetric before performing calculations. - The exponent should be a non-negative integer. # Example ```python import numpy as np matrix = np.array([ [2, 1, 0], [1, 2, 1], [0, 1, 2] ]) exponent = 3 assert is_symmetric(matrix) == True assert (matrix_power(matrix, exponent) == np.array([ [14, 16, 10], [16, 22, 16], [10, 16, 14] ])).all() ``` # Note - The `is_symmetric` function should efficiently check if the matrix is symmetric. - The `matrix_power` should handle the power operation using matrix multiplication. - Take care to test the functions with edge cases, such as identity matrices, zero matrices, and matrix powers of zero.","solution":"import numpy as np def is_symmetric(matrix: np.ndarray) -> bool: Check if the given matrix is symmetric. Parameters: matrix (np.ndarray): A square matrix Returns: bool: True if the matrix is symmetric, False otherwise return np.array_equal(matrix, matrix.T) def matrix_power(matrix: np.ndarray, exponent: int) -> np.ndarray: Compute the power of a symmetric matrix raised to a given integer exponent. Parameters: matrix (np.ndarray): A symmetric square matrix exponent (int): The integer power Returns: np.ndarray: The resulting matrix after raising the input matrix to the given exponent Raises: ValueError: If the matrix is not symmetric or if the exponent is negative if not is_symmetric(matrix): raise ValueError(\\"The matrix is not symmetric\\") if exponent < 0: raise ValueError(\\"Exponent must be a non-negative integer\\") return np.linalg.matrix_power(matrix, exponent)"},{"question":"# Problem Statement You are given a dictionary where keys are unique strings and values are lists of integers. Your task is to implement a function that merges all the lists in the dictionary into a single list, sorts this combined list in ascending order, and removes all duplicates. # Requirements Implement the function `merge_and_sort_lists(data: dict) -> list` such that: 1. The function accepts a dictionary where keys are strings and values are lists of integers. 2. It returns a sorted list of unique integers from merging all the lists in the dictionary. 3. If the input is not a dictionary, the function should raise a `TypeError` with a message. # Input Format - `data`: A dictionary where the keys are unique strings, and values are lists of integers. # Output Format - A sorted list of unique integers. # Constraints - You may assume all elements in the lists are integers within the range [-10^6, 10^6]. - The total number of integers in the merged list will not exceed 10^5. # Example 1. Example 1: - Input: `data = {\\"a\\": [1, 3, 5, 7], \\"b\\": [3, 6, 9], \\"c\\": [2, 4, 6, 8]}` - Output: `[1, 2, 3, 4, 5, 6, 7, 8, 9]` 2. Example 2: - Input: `data = {\\"x\\": [10, 20, 30], \\"y\\": [5, 25, 35], \\"z\\": [20, 30, 40]}` - Output: `[5, 10, 20, 25, 30, 35, 40]` 3. Example 3: - Input: `data = {\\"key1\\": [100], \\"key2\\": [100, 200]}` - Output: `[100, 200]` # Edge Cases - The dictionary is empty. - One or more of the lists are empty. - Non-dictionary input types. - Duplicate elements across multiple lists. ```python def merge_and_sort_lists(data: dict) -> list: :param data: a dictionary where keys are strings and values are lists of integers :return: a sorted list of unique integers from merging all lists in the dictionary Raises: TypeError: If the input is not a dictionary. if not isinstance(data, dict): raise TypeError(\\"The input value is not a dictionary\\") merged_set = set() for key, value in data.items(): if not isinstance(value, list): raise TypeError(f\\"The value associated with key \'{key}\' is not a list\\") merged_set.update(value) return sorted(merged_set) # Test the function with edge cases and various inputs to ensure robustness and correctness. ```","solution":"def merge_and_sort_lists(data: dict) -> list: :param data: a dictionary where keys are strings and values are lists of integers :return: a sorted list of unique integers from merging all lists in the dictionary Raises: TypeError: If the input is not a dictionary. if not isinstance(data, dict): raise TypeError(\\"The input value is not a dictionary\\") merged_set = set() for key, value in data.items(): if not isinstance(value, list): raise TypeError(f\\"The value associated with key \'{key}\' is not a list\\") merged_set.update(value) return sorted(merged_set)"},{"question":"# Coding Assessment Question # Scenario As part of an analytics project, you need to compute the normalized histogram of a given grayscale image. This histogram is essential for understanding the distribution of pixel intensities and is a fundamental step in many image processing tasks, such as contrast adjustment and thresholding. # Task Implement a function `normalized_histogram` that calculates the histogram of pixel intensities for an image and normalizes it so that the sum of all histogram values equals 1. The histogram should have 256 bins, corresponding to pixel values ranging from 0 to 255. # Function Signature ```python def normalized_histogram(img: np.ndarray) -> np.ndarray: ``` # Input * `img` (numpy.ndarray): A 2D grayscale image with values in the range of 0 to 255. # Output * `hist` (numpy.ndarray): A 1D array of length 256 containing the normalized histogram values. Each value represents the proportion of pixels in the corresponding intensity bin. # Constraints 1. The `img` will always be a 2D numpy array. 2. The pixel values in `img` will always be integers within the range 0 to 255. 3. You may assume that the maximum dimensions of the image are 1024x1024. # Example ```python import numpy as np # Sample input image img = np.array([ [ 0, 50, 100], [150, 200, 250], [ 0, 100, 200] ]) # Expected output: histogram with normalized values result = normalized_histogram(img) print(result) # Output should sum to 1 ``` # Requirements 1. Your function should be efficient and handle large images within the given constraints. 2. Ensure that the sum of the normalized histogram values is exactly 1. 3. Consider edge cases such as images with a single intensity value. # Performance Considerations * Aim for an efficient implementation that minimizes excessive computation. * Ensure proper handling of images of varying sizes by using numpy functions where possible for optimal performance.","solution":"import numpy as np def normalized_histogram(img: np.ndarray) -> np.ndarray: Compute the normalized histogram of the input grayscale image. Parameters: img (numpy.ndarray): A 2D grayscale image with values in the range 0 to 255. Returns: numpy.ndarray: A 1D array of length 256 containing the normalized histogram values. # Compute the histogram of the image with 256 bins hist, _ = np.histogram(img, bins=256, range=(0, 256)) # Normalize the histogram so that the sum equals 1 hist = hist / hist.sum() return hist"},{"question":"# Problem Statement Design an Order Management System Overview You are tasked with designing a simple order management system for an e-commerce application. The system should be able to handle basic operations related to orders such as creating an order, updating its status, and retrieving information about the order. You will need to implement an `OrderManagement` class to manage these operations. Task Implement the `OrderManagement` class with the following functionalities: 1. **Create Order**: Add a new order to the system. 2. **Update Order Status**: Update the status of an existing order. 3. **Query Order**: Retrieve information about a specific order by its ID. 4. **List Orders by Status**: List all orders that match a specific status. Requirements 1. **Initialization**: Initialize the `OrderManagement` class with an empty list of orders. 2. **Create Order Function**: Implement the `create_order` method to add a new order to the system. Each order should have a unique ID, customer name, and status (e.g., \\"Pending\\", \\"Shipped\\", \\"Delivered\\"). 3. **Update Order Status Function**: Implement the `update_order_status` method to update the status of an existing order. 4. **Query Order Function**: Implement the `get_order_by_id` method to retrieve the details of a specific order by its ID. 5. **List Orders Function**: Implement the `list_orders_by_status` method to list all orders with a specific status. Input - **Initialization**: ```python OrderManagement() # Initializes an empty order list ``` - **Order Data**: ```python order_id: int # Unique identifier for each order customer_name: str # Name of the customer status: str # Status of the order ``` Output - The `OrderManagement` class should be able to: 1. Create new orders using the `create_order` method. 2. Update an existing order\'s status using the `update_order_status` method. 3. Retrieve details of an order using the `get_order_by_id` method. 4. List all orders with a specific status using the `list_orders_by_status` method. Constraints 1. The `order_id` should be unique for each order. 2. The `status` can be any string but will generally be one of \\"Pending\\", \\"Shipped\\", or \\"Delivered\\". 3. The `customer_name` will be a non-empty string. Example ```python # Initialize the OrderManagement system order_management = OrderManagement() # Create several orders order_id1 = order_management.create_order(\\"Alice\\", \\"Pending\\") order_id2 = order_management.create_order(\\"Bob\\", \\"Pending\\") order_id3 = order_management.create_order(\\"Charlie\\", \\"Shipped\\") # Update order status order_management.update_order_status(order_id1, \\"Shipped\\") # Query order by ID order_details = order_management.get_order_by_id(order_id1) print(order_details) # Expected output: {\'id\': 1, \'customer_name\': \'Alice\', \'status\': \'Shipped\'} # List all orders with status \'Pending\' pending_orders = order_management.list_orders_by_status(\\"Pending\\") print(pending_orders) # Expected output: [{\'id\': 2, \'customer_name\': \'Bob\', \'status\': \'Pending\'}] ``` **Note**: Ensure that your implementation handles multiple orders and correctly updates and retrieves order details as specified.","solution":"class OrderManagement: def __init__(self): self.orders = [] self.next_id = 1 def create_order(self, customer_name, status): Creates a new order and assigns a unique order ID. :param customer_name: Name of the customer :param status: Initial status of the order :return: The unique ID of the created order order = { \'id\': self.next_id, \'customer_name\': customer_name, \'status\': status } self.orders.append(order) self.next_id += 1 return order[\'id\'] def update_order_status(self, order_id, status): Updates the status of an existing order by order ID. :param order_id: The unique ID of the order :param status: The new status of the order :return: True if the update was successful, False otherwise for order in self.orders: if order[\'id\'] == order_id: order[\'status\'] = status return True return False def get_order_by_id(self, order_id): Retrieves the details of a specific order by its ID. :param order_id: The unique ID of the order :return: A dictionary containing order details if found, None otherwise for order in self.orders: if order[\'id\'] == order_id: return order return None def list_orders_by_status(self, status): Lists all orders matching a specific status. :param status: The status to filter orders by :return: A list of orders with the specified status return [order for order in self.orders if order[\'status\'] == status]"},{"question":"# Problem Statement You are given the task of creating a simple text editor application that supports basic operations such as inserting characters, deleting the last character, and printing the current state of the text. You are required to maintain the history of operations so that you can undo the previous operation. # Task 1. Implement the `TextEditor` class that uses a stack to maintain the history of operations. 2. Include methods to perform the following operations: - `append(char: str) -> None`: Appends a character to the end of the text. - `delete() -> None`: Deletes the last character of the text. - `print_text() -> str`: Returns the current state of the text. - `undo() -> None`: Undoes the last operation (either append or delete). # Requirements - Implement the `TextEditor` class with the specified methods. - Use a stack to keep track of the history of operations for the undo functionality. - Ensure all operations work correctly and handle edge cases, such as undoing with an empty history or deleting from an empty text. # Example Cases Here are some cases demonstrating the expected behavior of your text editor: ```python editor = TextEditor() editor.append(\'h\') editor.append(\'e\') editor.append(\'l\') editor.append(\'l\') editor.append(\'o\') assert editor.print_text() == \'hello\' editor.delete() assert editor.print_text() == \'hell\' editor.delete() editor.undo() assert editor.print_text() == \'hell\' editor.undo() assert editor.print_text() == \'hello\' editor.delete() editor.delete() editor.delete() editor.delete() editor.delete() assert editor.print_text() == \'\' editor.undo() assert editor.print_text() == \'h\' ``` # Expected Function Signatures ```python class TextEditor: def __init__(self) -> None: ... def append(self, char: str) -> None: ... def delete(self) -> None: ... def print_text(self) -> str: ... def undo(self) -> None: ... ``` # Constraints - The text will only contain lowercase English letters. - Ensure that undo operations only affect the last applied operation. - Focus on maintaining simplicity and efficiency of the code.","solution":"class TextEditor: def __init__(self) -> None: self.text = [] self.history = [] def append(self, char: str) -> None: self.text.append(char) self.history.append((\'append\', char)) def delete(self) -> None: if self.text: removed_char = self.text.pop() self.history.append((\'delete\', removed_char)) def print_text(self) -> str: return \'\'.join(self.text) def undo(self) -> None: if not self.history: return operation, char = self.history.pop() if operation == \'append\': self.text.pop() elif operation == \'delete\': self.text.append(char)"},{"question":"# Matrix Rotation Challenge **Context**: Rotating a matrix is a common problem in computer science, relevant in various fields such as graphics processing, gaming, and image manipulation. Matrix rotation can be performed in-place or by using extra space, and different rotation angles (90, 180, 270 degrees) present unique challenges. You are given a function to rotate a square matrix by 90 degrees clockwise: 1. `rotate_matrix_90(matrix: List[List[int]]) -> List[List[int]]` # Task Your task is to implement a new function that rotates an n x n matrix by 270 degrees clockwise. Your solution will be evaluated based on correctness, efficiency, and handling edge cases effectively. # Specification * **Function Name**: `rotate_matrix_270` * **Input**: - `matrix` (List[List[int]]): a 2D list representing an n x n matrix of integers * **Output**: - Returns `List[List[int]]`: the matrix rotated by 270 degrees clockwise. # Constraints - The input matrix `matrix` will be an n x n matrix where 2 <= n <= 1000. - Your solution should handle large matrices efficiently. - Your implementation should aim to minimize extra space usage if possible. # Examples ```python >>> rotate_matrix_270([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [3, 6, 9], [2, 5, 8], [1, 4, 7] ] >>> rotate_matrix_270([ ... [1, 2], ... [3, 4] ... ]) [ [2, 4], [1, 3] ] >>> rotate_matrix_270([ ... [1, 0], ... [0, 1] ... ]) [ [0, 1], [1, 0] ] ``` # Additional Requirement Include a brief paragraph in your solution describing why your approach is efficient in terms of time and space complexity. # Bonuses 1. **Runtime Efficiency**: Provide an analysis of the time complexity of your implementation compared to other possible approaches. 2. **Memory Efficiency**: Discuss any strategies used to minimize memory overhead in your implementation.","solution":"from typing import List def rotate_matrix_270(matrix: List[List[int]]) -> List[List[int]]: Rotates an n x n matrix by 270 degrees clockwise. Args: - matrix (List[List[int]]): a 2D list representing an n x n matrix of integers Returns: - List[List[int]]: the matrix rotated by 270 degrees clockwise. # The result matrix, initially filled with zeros n = len(matrix) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): result[n - 1 - j][i] = matrix[i][j] return result # Explanation # The approach involves creating an output matrix of the same size as the input matrix. # For each cell in the input matrix, its new position in the output matrix is calculated. # Specifically, to rotate 270 degrees clockwise: # - element (i, j) in the input matrix becomes element (n-1-j, i) in the output matrix. # This ensures that the rotation is performed correctly. # Efficiency: # - Time Complexity: O(n*n), where n is the dimension of the matrix. We have to visit each element once. # - Space Complexity: O(n*n) for the result matrix. This is the smallest space complexity possible # for an approach that generates a new matrix rather than modifying in-place."},{"question":"# Question: Optimizing Matrix Chain Multiplication Matrix chain multiplication is a classic optimization problem. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices together. The efficiency is determined by minimizing the number of scalar multiplications. Function to Implement ```python def matrix_chain_order(d: list) -> int: Compute the minimum number of scalar multiplications needed to multiply a chain of matrices. Arguments: d: list -- a list of integers where the i-th matrix has dimension d[i-1] x d[i]. Returns: int -- the minimum number of scalar multiplications required. Example: >>> matrix_chain_order([1, 2, 3, 4]) 18 >>> matrix_chain_order([10, 20, 30, 40, 30]) 30000 >>> matrix_chain_order([40, 20, 30, 10, 30]) 26000 # Your implementation here ``` Input * `d`: list of integers of length n+1 where each of the n matrices has compatible dimensions `d[i-1] x d[i]` (2 ≤ length ≤ 100) Output * An integer representing the minimum number of scalar multiplications needed. Example Explanation * For `matrix_chain_order([1, 2, 3, 4])`: There are 3 matrices of dimensions 1x2, 2x3, and 3x4. - Multiplying matrices A1 and A2 costs 1*2*3 = 6. - Multiplying the result with A3 costs 1*3*4 = 12. - Total = 6 + 12 = 18. Performance * The function should efficiently handle inputs up to the specified constraints. Special Instructions * Use dynamic programming to optimize the matrix chain multiplication process. * Ensure to correctly manage and update the dynamic programming table/memoization structure to achieve optimal time complexity.","solution":"def matrix_chain_order(d): n = len(d) - 1 m = [[0 for _ in range(n)] for _ in range(n)] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + d[i] * d[k + 1] * d[j + 1] if q < m[i][j]: m[i][j] = q return m[0][n - 1]"},{"question":"# Question: Optimized Search in a Matrix Context You are tasked with designing a function that efficiently searches for a target value within a row-wise and column-wise sorted 2D matrix. This problem will test your understanding of search algorithms and how to optimize them for special data structures, such as matrices with ordered properties. Requirements 1. **Function Definition**: - Create a function `search_matrix` that takes in a 2D matrix and a target value. - The matrix is sorted in ascending order both row-wise and column-wise. 2. **Search Optimization**: - Implement an optimized search algorithm to locate the target value. - Avoid using simple linear search or brute-force methods. Implementation Details - **Input Format**: - `matrix`: A list of lists where each sublist represents a row in the matrix, elements are integers. - `target`: An integer value to search for in the matrix. - **Output Format**: - Return `True` if the target is found in the matrix, otherwise return `False`. - **Constraints**: - The number of rows (`m`) and columns (`n`) in the matrix can be up to 300. - Aim for a time complexity better than O(m*n). Function Signature ```python def search_matrix(matrix: List[List[int]], target: int) -> bool: pass # Implement the optimized search algorithm. # Example Usage: # matrix = [ # [1, 4, 7, 11, 15], # [2, 5, 8, 12, 19], # [3, 6, 9, 16, 22], # [10, 13, 14, 17, 24], # [18, 21, 23, 26, 30] # ] # target = 5 # result = search_matrix(matrix, target) => True # target = 20 # result = search_matrix(matrix, target) => False ``` Performance Requirements - Use a strategy that leverages the sorted properties of the matrix for efficient searching, such as binary search or different traversal methods. - Ensure that the search completes in a reasonable time frame even for the largest allowed matrices.","solution":"def search_matrix(matrix, target): Searches for the target value in a row-wise and column-wise sorted 2D matrix. Returns True if the target is found, else returns False. if not matrix: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: current_value = matrix[row][col] if current_value == target: return True elif current_value > target: col -= 1 # Move left else: row += 1 # Move down return False"},{"question":"# Problem Statement: Pascal\'s Triangle Sum You are working on a feature that involves calculating specific sums from Pascal\'s Triangle. Pascal\'s Triangle is a triangular array of numbers where the value at a given position is the sum of the two numbers directly above it from the previous row. The triangle starts with a single `1` at the top. **Objective:** Implement a function, `pascal_row_sum`, that takes an integer `n` and returns the sum of all elements in the `n`th row of Pascal\'s Triangle. Note that the rows are zero-indexed. # Function: pascal_row_sum **Input:** - `n: int` - An integer representing the row number in Pascal\'s Triangle. **Output:** - `sum_nth_row: int` - The sum of all elements in the `n`th row. # Constraints: 1. (0 leq n leq 20) 2. The function should be optimally implemented to run efficiently for the given input range. # Example: ```python def pascal_row_sum(n: int) -> int: # Your implementation here pass # Test cases: assert pascal_row_sum(0) == 1 # [1] assert pascal_row_sum(1) == 2 # [1, 1] assert pascal_row_sum(2) == 4 # [1, 2, 1] assert pascal_row_sum(3) == 8 # [1, 3, 3, 1] assert pascal_row_sum(4) == 16 # [1, 4, 6, 4, 1] assert pascal_row_sum(5) == 32 # [1, 5, 10, 10, 5, 1] ``` # Hint: - There is a mathematical relationship to consider that can significantly simplify the implementation. Your task is to efficiently compute the sum using the properties of Pascal\'s Triangle. Ensure the solution is optimized to handle the maximum input size within the given constraints. **Good Luck!**","solution":"def pascal_row_sum(n: int) -> int: Returns the sum of all elements in the nth row of Pascal\'s Triangle. The sum of the elements of the nth row of Pascal\'s Triangle is 2^n. return 2 ** n"},{"question":"# Context In this assessment, you are required to implement a function that operates on a series of nested lists and calculates specific values based on nested structures. Your understanding of recursion, nested data manipulation, and algorithm efficiency will be crucial. # Problem Statement Design a function `sum_nested_lists` that computes the sum of all integer elements in a nested list structure. A nested list can contain integers, other lists, or a combination thereof. # Function Signature ```python def sum_nested_lists(nested_list: list) -> int: ``` # Input * A list `nested_list`, which can contain integers and/or other lists nested at any level. # Output * An integer representing the sum of all the integer elements in the nested list. # Constraints * You must use a recursive approach. * The input list can be deeply nested and contain any integer values (negative, positive, or zero). * The overall number of elements (including nested elements) will not exceed 1000. # Example ```python # Example 1 nested_list = [1, [2, 3], [4, [5, 6]], 7] print(sum_nested_lists(nested_list)) # Output: 28 # Example 2 nested_list = [[1, -1], [2, [3, 4]], -5] print(sum_nested_lists(nested_list)) # Output: 4 # Example 3 nested_list = [1, [2, [3, [4]]]] print(sum_nested_lists(nested_list)) # Output: 10 ``` # Hints * Think about how you can traverse and sum elements in each nested level of the list. * Consider both the base case (when an element is an integer) and the recursive case (when an element is a list).","solution":"def sum_nested_lists(nested_list: list) -> int: Returns the sum of all integer elements in a nested list structure. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_lists(element) else: total += element return total"},{"question":"# Coding Challenge **Context**: You are developing a system to track books in a library. Each book has a unique identifier, a title, an author, and a genre. Your task is to implement a library system allowing the addition, removal, and retrieval of books based on certain criteria. Function Signature: ```python class Library: def __init__(self): pass def add_book(self, book_id: int, title: str, author: str, genre: str) -> None: pass def remove_book(self, book_id: int) -> bool: pass def find_books_by_author(self, author: str) -> List[Dict[str, str]]: pass def find_books_by_genre(self, genre: str) -> List[Dict[str, str]]: pass ``` Parameters: - `book_id` (in `add_book` and `remove_book`): an integer representing the unique identifier of the book. - `title` (in `add_book`): a string representing the title of the book. - `author` (in `add_book` and `find_books_by_author`): a string representing the author of the book. - `genre` (in `add_book` and `find_books_by_genre`): a string representing the genre of the book. Output: - `add_book`: returns `None`. - `remove_book`: returns `True` if the book was successfully removed, `False` if the book was not found. - `find_books_by_author`: returns a list of dictionaries where each dictionary contains information (`book_id`, `title`, `author`, `genre`) about books written by the specified author. - `find_books_by_genre`: returns a list of dictionaries where each dictionary contains information (`book_id`, `title`, `author`, `genre`) about books of the specified genre. Constraints: * The `book_id` will be a unique positive integer. * Titles, authors, and genres are non-empty strings with a maximum length of 255 characters. * Efficiently handle a library with up to 1,000,000 books. Instructions: 1. Implement the class constructor `__init__` to initialize the library. 2. Implement the `add_book` method to add a new book to the library. 3. Implement the `remove_book` method to remove a book based on its `book_id`. 4. Implement the `find_books_by_author` method to retrieve a list of books by a specified author. 5. Implement the `find_books_by_genre` method to retrieve a list of books in a specified genre. Example: ```python library = Library() library.add_book(1, \'1984\', \'George Orwell\', \'Dystopian\') library.add_book(2, \'Brave New World\', \'Aldous Huxley\', \'Dystopian\') library.add_book(3, \'To Kill a Mockingbird\', \'Harper Lee\', \'Fiction\') print(library.find_books_by_author(\'George Orwell\')) print(library.find_books_by_genre(\'Dystopian\')) print(library.remove_book(2)) print(library.find_books_by_genre(\'Dystopian\')) ``` Expected Output: ``` [{\'book_id\': 1, \'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\'}] [{\'book_id\': 1, \'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\'}, {\'book_id\': 2, \'title\': \'Brave New World\', \'author\': \'Aldous Huxley\', \'genre\': \'Dystopian\'}] True [{\'book_id\': 1, \'title\': \'1984\', \'author\': \'George Orwell\', \'genre\': \'Dystopian\'}] ``` Note: This problem is designed to assess your ability to handle data structures and implement object-oriented programming concepts effectively.","solution":"from typing import List, Dict class Library: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str, genre: str) -> None: self.books[book_id] = { \'title\': title, \'author\': author, \'genre\': genre } def remove_book(self, book_id: int) -> bool: if book_id in self.books: del self.books[book_id] return True return False def find_books_by_author(self, author: str) -> List[Dict[str, str]]: return [dict({\'book_id\': book_id}, **info) for book_id, info in self.books.items() if info[\'author\'] == author] def find_books_by_genre(self, genre: str) -> List[Dict[str, str]]: return [dict({\'book_id\': book_id}, **info) for book_id, info in self.books.items() if info[\'genre\'] == genre]"},{"question":"# Lukasiewicz\'s Polish Notation Evaluation In this problem, you are required to write a function to evaluate an expression written in Lukasiewicz\'s Polish notation (also known as Reverse Polish Notation, RPN). This notation eliminates the need for parentheses by placing operators after their operands. Function Signature ```python def evaluate_rpn(expression: List[str]) -> int: ``` Parameters - `expression` (List[str]): A list of strings representing the RPN expression, where each string is either an integer or an operator (`\'+\', \'-\', \'*\', \'/\'`). Returns - `int`: The result of evaluating the RPN expression. Constraints - The expression will be a valid RPN expression. - Division should truncate towards zero (behave like integer division in Python). Example ```python assert evaluate_rpn([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) == 9 assert evaluate_rpn([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) == 6 assert evaluate_rpn([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) == 22 ``` Edge Cases - Ensure your function handles division by both positive and negative numbers correctly. - Handle cases where the expression only contains a single number, returning that number directly. **Your task** is to implement the `evaluate_rpn` function while ensuring it can handle a variety of valid RPN expressions and produces the correct results.","solution":"from typing import List def evaluate_rpn(expression: List[str]) -> int: stack = [] for token in expression: if token in \\"+-*/\\": op2 = stack.pop() op1 = stack.pop() if token == \'+\': stack.append(op1 + op2) elif token == \'-\': stack.append(op1 - op2) elif token == \'*\': stack.append(op1 * op2) elif token == \'/\': # Perform integer division that truncates toward zero stack.append(int(op1 / op2)) else: stack.append(int(token)) return stack[0]"},{"question":"# Coding Assessment Question Scenario You are developing a geometric library for graphic applications, which requires a function to determine if a point lies within a given circle. This is crucial for functionalities such as collision detection, region-based queries, and graphical manipulations. Task Implement a Python function to check if a point lies within or on the boundary of a circle in 2D space. Function Signature ```python def is_point_in_circle(circle_center: Tuple[float, float], radius: float, point: Tuple[float, float]) -> bool: ``` Input - `circle_center`: A tuple of two floats representing the coordinates (x, y) of the circle\'s center. - `radius`: A float representing the radius of the circle. - `point`: A tuple of two floats representing the coordinates (x, y) of the point to check. Output - A boolean value indicating whether the point lies within or on the boundary of the circle. Constraints - The coordinates of the circle center and the point will be real numbers. - The radius will be a non-negative real number. - The coordinates and radius can range from -10^6 to 10^6. Example ```python assert is_point_in_circle((0, 0), 5, (3, 4)) == True # point on the boundary assert is_point_in_circle((0, 0), 5, (1, 1)) == True # point inside the circle assert is_point_in_circle((0, 0), 5, (6, 0)) == False # point outside the circle assert is_point_in_circle((2, 2), 0, (2, 2)) == True # point at the center with zero radius ``` Note Ensure to handle the precision issues and edge cases appropriately. Describe your methodology and assumptions clearly in your implementation.","solution":"from typing import Tuple def is_point_in_circle(circle_center: Tuple[float, float], radius: float, point: Tuple[float, float]) -> bool: Determines if a point lies within or on the boundary of a circle in 2D space. :param circle_center: Coordinates (x, y) of the circle\'s center. :param radius: The radius of the circle. :param point: Coordinates (x, y) of the point to check. :return: True if the point is within or on the boundary of the circle, otherwise False. cx, cy = circle_center px, py = point distance_squared = (px - cx) ** 2 + (py - cy) ** 2 return distance_squared <= radius ** 2"},{"question":"Problem Statement: You need to create a Python function that reads employee data from a CSV file, processes it to calculate their total monthly compensation, and saves the resulting data back to another CSV file. The employee data includes base salary, bonus, and allowances. The output file should contain the employee\'s name and their total monthly compensation. # Function Signature: ```python def process_employee_compensation(input_filename: str, output_filename: str) -> None: Processes employee data to calculate total monthly compensation and saves it to another CSV file. Parameters: input_filename (str): Name of the input CSV file containing employee data. output_filename (str): Name of the output CSV file to save processed employee data. Raises: IOError: If there is an error reading from or writing to the file. ``` # Input: - `input_filename`: A string representing the name of the input CSV file. The file contains the following columns: \'Name\', \'Base Salary\', \'Bonus\', \'Allowances\'. - `output_filename`: A string representing the name of the output CSV file. # Output: - None (Results should be written to the specified output file). # Example Contents: **Input CSV (`employees.csv`)** ``` Name,Base Salary,Bonus,Allowances John Doe,5000,500,300 Jane Smith,6000,600,400 Jim Brown,4500,450,250 ``` **Output CSV (`processed_employees.csv`)** ``` Name,Total Monthly Compensation John Doe,5800 Jane Smith,7000 Jim Brown,5200 ``` # Constraints: 1. **Error Handling**: Handle errors such as missing input file, permission issues, and ensure that the input file is properly formatted. 2. **Calculation**: The total monthly compensation is a sum of Base Salary, Bonus, and Allowances. 3. **Performance**: Optimize file reading and writing to handle large datasets efficiently. 4. **CSV Formatting**: Ensure the output file is in proper CSV format with appropriate headers. # Notes: * Use Python\'s built-in `csv` module for handling CSV files. * Ensure the function is thoroughly commented and documents the logic, especially for error handling. * Make sure to handle edge cases, such as missing or malformed data in the input CSV file. # Example Invocation: ```python # Process the employee compensation data process_employee_compensation(\'employees.csv\', \'processed_employees.csv\') ```","solution":"import csv def process_employee_compensation(input_filename: str, output_filename: str) -> None: Processes employee data to calculate total monthly compensation and saves it to another CSV file. Parameters: input_filename (str): Name of the input CSV file containing employee data. output_filename (str): Name of the output CSV file to save processed employee data. Raises: IOError: If there is an error reading from or writing to the file. try: with open(input_filename, mode=\'r\', newline=\'\') as infile: reader = csv.DictReader(infile) fieldnames = [\'Name\', \'Total Monthly Compensation\'] # Create list of processed data processed_data = [] for row in reader: name = row[\'Name\'] base_salary = float(row[\'Base Salary\']) bonus = float(row[\'Bonus\']) allowances = float(row[\'Allowances\']) total_compensation = base_salary + bonus + allowances processed_data.append({ \'Name\': name, \'Total Monthly Compensation\': total_compensation }) with open(output_filename, mode=\'w\', newline=\'\') as outfile: writer = csv.DictWriter(outfile, fieldnames=fieldnames) writer.writeheader() writer.writerows(processed_data) except KeyError as e: raise ValueError(\\"Missing or malformed data in input CSV file\\") from e except IOError as e: raise IOError(\\"Error reading from or writing to the file\\") from e # Example Invocation # process_employee_compensation(\'employees.csv\', \'processed_employees.csv\')"},{"question":"# Scenario You are contributing to a geographical mapping project that involves plotting the shortest path between landmarks on a map represented by a graph. The landmarks are represented as nodes and the roads between them as weighted edges. The goal is to implement an algorithm to determine the shortest path from a source landmark to a destination landmark. # Problem Statement Write a function `find_shortest_path` that uses Dijkstra\'s algorithm to compute the shortest path between two nodes in a weighted graph. # Function Signature ```python def find_shortest_path(graph: Dict[Any, Dict[Any, float]], start: Any, end: Any) -> Tuple[float, List[Any]]: Parameters: 1. graph (Dict[Any, Dict[Any, float]]): The weighted graph where keys are nodes and values are dictionaries of neighboring nodes and their corresponding edge weights. 2. start (Any): The starting node for the path. 3. end (Any): The destination node for the path. Returns: Tuple[float, List[Any]]: A tuple containing the total weight of the shortest path and the list of nodes representing this path. Raises: ValueError: If \'start\' or \'end\' are not present in the graph or if no path exists between them. ``` # Input * `graph` is a dictionary of dictionaries where each key is a node and each value is another dictionary of neighboring nodes with their associated edge weights. * `start` is the starting node. * `end` is the destination node. # Output * A tuple containing: - The total weight of the shortest path. - A list of nodes representing the shortest path from `start` to `end`. # Constraints * Ensure `start` and `end` nodes are present in the graph. * The graph is connected and all edge weights are non-negative. # Examples ```python graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } # Example 1 result = find_shortest_path(graph, \'A\', \'D\') print(result) # Expected output: (4.0, [\'A\', \'B\', \'C\', \'D\']) # Example 2 result = find_shortest_path(graph, \'A\', \'C\') print(result) # Expected output: (3.0, [\'A\', \'B\', \'C\']) # Edge Case 1 try: result = find_shortest_path(graph, \'A\', \'E\') except ValueError as e: print(e) # Expected: Start or end node not present in the graph. # Edge Case 2 try: result = find_shortest_path(graph, \'A\', \'A\') except ValueError as e: print(e) # Expected: Start is the same as end, no valid path. ``` # Additional Notes You should raise appropriate exceptions for invalid inputs according to the constraints described. Ensure that the implementation correctly handles scenarios where no path exists between the specified nodes.","solution":"import heapq from typing import Dict, Any, Tuple, List def find_shortest_path(graph: Dict[Any, Dict[Any, float]], start: Any, end: Any) -> Tuple[float, List[Any]]: Uses Dijkstra\'s algorithm to find the shortest path in a weighted graph between start and end nodes. Parameters: 1. graph (Dict[Any, Dict[Any, float]]): The weighted graph where keys are nodes and values are dictionaries of neighboring nodes and their corresponding edge weights. 2. start (Any): The starting node for the path. 3. end (Any): The destination node for the path. Returns: Tuple[float, List[Any]]: A tuple containing the total weight of the shortest path and the list of nodes representing this path. Raises: ValueError: If \'start\' or \'end\' are not present in the graph or if no path exists between them. if start not in graph or end not in graph: raise ValueError(\\"Start or end node not present in the graph.\\") if start == end: return 0.0, [start] # Priority queue to store (distance, node, path) pq = [(0, start, [start])] visited = set() while pq: current_distance, current_node, current_path = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) # If we have reached the end node, return the distance and path if current_node == end: return current_distance, current_path for neighbor, weight in graph[current_node].items(): if neighbor not in visited: new_distance = current_distance + weight new_path = current_path + [neighbor] heapq.heappush(pq, (new_distance, neighbor, new_path)) raise ValueError(\\"No path exists between the start and end nodes.\\")"},{"question":"# Coding Assessment Question: Context: Large datasets often need to be processed in parallel to expedite completion times, particularly when the dataset is composed of independent tasks, such as image processing. Python\'s `multiprocessing` library enables the execution of code across multiple cores. Task: Write a Python function called `parallel_image_processing` that takes a list of image file paths, applies a simple image processing operation to each image (e.g., resizing), and saves the processed images to a specified output directory. Use multiprocessing to parallelize the processing tasks. Function Signature: ```python def parallel_image_processing(image_paths: List[str], output_dir: str, size: Tuple[int, int]) -> None: ``` Inputs: * **image_paths**: A list of strings representing the file paths of the images to be processed. * **output_dir**: A string representing the directory path where the processed images will be saved. * **size**: A tuple of two integers representing the dimensions (width, height) to resize the images. Outputs: * This function should not return anything. It should save the resized images in the specified output directory, retaining the original image filenames. Constraints: * **Image Processing**: Use the Python Imaging Library (PIL) or `Pillow` for image operations. * **Multiprocessing**: Implement parallel processing using Python\'s `multiprocessing` library. * **Handle Exceptions**: Ensure to handle various exceptions including file not found errors, image processing errors, and file I/O errors. Example: ```python parallel_image_processing([\\"path/to/image1.jpg\\", \\"path/to/image2.png\\"], \\"resized_images\\", (100, 100)) ``` After running the function, you should find the images resized to 100x100 pixels saved in the `resized_images` directory, with their original filenames preserved.","solution":"import os from PIL import Image from multiprocessing import Pool from typing import List, Tuple def process_image(args): image_path, output_dir, size = args try: with Image.open(image_path) as img: img = img.resize(size) img.save(os.path.join(output_dir, os.path.basename(image_path))) except Exception as e: print(f\\"Error processing {image_path}: {e}\\") def parallel_image_processing(image_paths: List[str], output_dir: str, size: Tuple[int, int]) -> None: if not os.path.exists(output_dir): os.makedirs(output_dir) # Create a list of arguments for each image args = [(image_path, output_dir, size) for image_path in image_paths] # Use multiprocessing to process images in parallel with Pool() as pool: pool.map(process_image, args)"},{"question":"# Coding Assessment Question Context You have been tasked with developing a performance logging decorator in Python. The decorator needs to log the execution time of functions, the number of calls made, and handle errors gracefully by logging the exceptions without terminating the program. Task Your assignment is to create a decorator that meets the following requirements: 1. **Execution Time Logging**: Log the execution time of each function call. 2. **Call Count**: Maintain and log the number of times each function is called. 3. **Error Handling**: Log any exceptions raised by the function and allow the program to continue running. 4. **Contextual Information**: Allow for an optional contextual message to be added to the log for easier traceability. Function Signature ```python import time import logging from functools import wraps def performance_logger(context: str = \\"\\"): Decorator for logging performance metrics of function calls. Parameters: context (str): Optional message to be added to logs for context. Decorates: A function whose performance metrics need to be logged. ``` Implementation Details - Use the `logging` module for logging messages. - Calculate execution time using `time.time()` for simplicity. - Ensure that the call count and other relevant metrics are updated and logged appropriately. - Handle exceptions by logging the error message and continuing the execution. Example Usage ```python # Example function that simulates some processing @performance_logger(\\"Processing Task\\") def some_function(x): if x == 0: raise ValueError(\\"Invalid value for x\\") time.sleep(x) return x * 2 # Call the example function with valid and invalid inputs try: print(some_function(2)) except Exception as e: print(f\\"Error occurred: {e}\\") try: print(some_function(0)) except Exception as e: print(f\\"Error occurred: {e}\\") ``` **Expected Output**: The logs should capture the call count, execution time, contextual information, and any errors raised by `some_function`. The program should print the results or error messages without terminating abruptly. Good luck!","solution":"import time import logging from functools import wraps # Configure logging logging.basicConfig(level=logging.INFO, format=\'%(asctime)s - %(levelname)s - %(message)s\') def performance_logger(context: str = \\"\\"): Decorator for logging performance metrics of function calls. Parameters: context (str): Optional message to be added to logs for context. Decorates: A function whose performance metrics need to be logged. def decorator(func): call_count = 0 @wraps(func) def wrapper(*args, **kwargs): nonlocal call_count call_count += 1 start_time = time.time() try: result = func(*args, **kwargs) execution_time = time.time() - start_time logging.info(f\\"{context} - Function \'{func.__name__}\' executed in {execution_time:.4f} seconds.\\") logging.info(f\\"{context} - Function \'{func.__name__}\' called {call_count} times.\\") return result except Exception as e: logging.error(f\\"{context} - An error occurred in function \'{func.__name__}\': {e}\\") logging.info(f\\"{context} - Function \'{func.__name__}\' called {call_count} times.\\") # Propagate the exception raise return wrapper return decorator"},{"question":"# Analyzing Time Complexities of Sorting Algorithms You are working as a software engineer tasked with analyzing the performance of different sorting algorithms under various conditions. Specifically, you need to compare the time complexities of two sorting algorithms: Bubble Sort and Merge Sort. **Task**: 1. Implement functions to perform Bubble Sort and Merge Sort: - `def bubble_sort(arr: list) -> list:` - `def merge_sort(arr: list) -> list:` 2. Additionally, write a function that compares the average number of operations (comparisons and swaps for Bubble Sort, comparisons and merges for Merge Sort) required for sorting lists of varying sizes and levels of disorder: - `def compare_sorting_algorithms(max_size: int, step: int) -> dict:` 3. Ensure your functions handle edge cases such as empty lists and lists with a single element. **Function Signatures**: ```python def bubble_sort(arr: list) -> list: # your implementation here def merge_sort(arr: list) -> list: # your implementation here def compare_sorting_algorithms(max_size: int, step: int) -> dict: # your implementation here ``` # Expected Input and Output: * **Input Format**: - `arr`: A list of numerical values `[float]` or `[int]` for sorting. - `max_size`: An integer specifying the maximum size of lists to be tested. - `step`: An integer specifying the step size to increment the list lengths for testing. * **Output Format**: - A dictionary containing the average number of operations required for both sorting algorithms for each list size increment. # Constraints and Assumptions: - The list can be empty, contain a single value, or have elements in any order. - `max_size` and `step` will always be positive integers. # Example Usage: ```python # Bubble Sort Example: assert bubble_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert bubble_sort([4, 3, 2, 1]) == [1, 2, 3, 4] # Merge Sort Example: assert merge_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert merge_sort([4, 3, 2, 1]) == [1, 2, 3, 4] # Comparison Example: assert compare_sorting_algorithms(100, 20) == { 20: {\'Bubble Sort\': avg_ops_bubble_20, \'Merge Sort\': avg_ops_merge_20}, 40: {\'Bubble Sort\': avg_ops_bubble_40, \'Merge Sort\': avg_ops_merge_40}, ... 100: {\'Bubble Sort\': avg_ops_bubble_100, \'Merge Sort\': avg_ops_merge_100} } ``` # Notes: - Bubble Sort is generally less efficient, especially for larger lists, due to its average and worst-case time complexity of O(n^2). - Merge Sort, with its average and worst-case time complexity of O(n log n), should perform more efficiently for bigger lists. - Ensure you count and report the number of operations for each algorithm properly. - Your comparison function should systematically increase the list size from `step` to `max_size`, generating random lists for each size and computing the average operations over multiple runs to account for variability.","solution":"def bubble_sort(arr: list) -> list: Performs bubble sort on the input list and returns the sorted list. n = len(arr) for i in range(n): swapped = False for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swapped = True if not swapped: break return arr def merge_sort(arr: list) -> list: Performs merge sort on the input list and returns the sorted list. if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 return arr import random def compare_sorting_algorithms(max_size: int, step: int) -> dict: Compares the average number of operations required for bubble sort and merge sort. results = {} for size in range(step, max_size + 1, step): total_operations_bubble = 0 total_operations_merge = 0 num_trials = 10 for _ in range(num_trials): arr = [random.randint(0, 1000) for _ in range(size)] # Bubble Sort bubble_ops = 0 arr_bubble = arr.copy() n = len(arr_bubble) for i in range(n): swapped = False for j in range(0, n - i - 1): bubble_ops += 1 # Counting comparisons if arr_bubble[j] > arr_bubble[j + 1]: arr_bubble[j], arr_bubble[j + 1] = arr_bubble[j + 1], arr_bubble[j] swapped = True bubble_ops += 1 # Counting swaps if not swapped: break total_operations_bubble += bubble_ops # Merge Sort merge_ops = [0] def merge_sort_ops(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort_ops(left_half) merge_sort_ops(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): merge_ops[0] += 1 # Counting comparisons if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 merge_sort_ops(arr.copy()) total_operations_merge += merge_ops[0] avg_operations_bubble = total_operations_bubble // num_trials avg_operations_merge = total_operations_merge // num_trials results[size] = { \'Bubble Sort\': avg_operations_bubble, \'Merge Sort\': avg_operations_merge } return results"},{"question":"# Question Description You are given a list of strings where each string represents a mathematical expression involving integers and the four basic arithmetic operations: addition, subtraction, multiplication, and division. Implement a function to evaluate these expressions and return the results. Ensure that your implementation handles operator precedence and parentheses correctly. Function Signature ```python def evaluate_expressions(expressions: list) -> list: ... ``` Input - `expressions`: A list of strings, where each string is a mathematical expression. Output - `results`: A list of integers or floats corresponding to the evaluation of each expression. Constraints - Each expression may contain up to 100 characters. - The expressions will be mathematically valid and contain only integers and the operators +, -, *, /, and parentheses. - Division should be treated as floating-point division. Example ```python expressions = [\\"3 + 5\\", \\"10 - 2 * (5 / 2)\\", \\"(1 + 2) * (3 / 4)\\"] results = evaluate_expressions(expressions) print(results) # Expected Output: [8, 6.0, 2.25] ``` Performance Requirements Your solution should be efficient and handle the input size and constraints within a reasonable time, ensuring correct handling of operator precedence and parenthesized expressions. Implement this with an algorithm that takes into account all precedence rules and correctly interprets nested operations.","solution":"def evaluate_expressions(expressions: list) -> list: This function evaluates a list of mathematical expressions and returns their results. results = [] for expr in expressions: results.append(eval(expr)) return results"},{"question":"# Find the Lowest Common Ancestor in a Binary Tree Problem Statement You are provided with a Binary Tree data structure implemented with nodes holding integer values. Your task is to implement a method that finds the Lowest Common Ancestor (LCA) of two given nodes in the Binary Tree. The LCA is defined as the lowest node in the tree that has both nodes as descendants (where we allow a node to be a descendant of itself). Requirements Implement the following method in the `BinaryTree` class: ```python def find_lca(self, root: TreeNode, p: int, q: int) -> TreeNode: Find the Lowest Common Ancestor (LCA) of two given nodes in the binary tree. Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: TreeNode: The LCA of the given nodes. Example: >>> bt = BinaryTree() >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> bt.find_lca(root, 5, 1).val 3 >>> bt.find_lca(root, 5, 4).val 5 ``` Your implementation must: - Traverse the binary tree to locate the two nodes with values `p` and `q`. - Determine and return the node that is the lowest common ancestor. Input and Output - **Input**: Binary tree nodes to construct the tree, and integer values `p` and `q` representing the nodes for which the LCA needs to be found. - **Output**: The `TreeNode` that is the lowest common ancestor of nodes `p` and `q`. Constraints - The given tree will have at most 10^4 nodes. - The values `p` and `q` are guaranteed to be present in the tree. Performance Requirements - Optimize the traversal to ensure efficient search for the two nodes and the LCA, considering time complexity and recursion limits. Example ```python >>> bt = BinaryTree() >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> print(bt.find_lca(root, 5, 1).val) # Output: 3 >>> print(bt.find_lca(root, 5, 4).val) # Output: 5 ``` # Note - Ensure to handle the case where one of the nodes `p` or `q` is the ancestor of the other.","solution":"class TreeNode: Definition for a binary tree node. def __init__(self, x): self.val = x self.left = None self.right = None class BinaryTree: def find_lca(self, root: TreeNode, p: int, q: int) -> TreeNode: Find the Lowest Common Ancestor (LCA) of two given nodes in the binary tree, represented by their values. Args: root (TreeNode): The root node of the binary tree. p (int): The value of the first node. q (int): The value of the second node. Returns: TreeNode: The LCA of the given nodes. if not root: return None if root.val == p or root.val == q: return root left_lca = self.find_lca(root.left, p, q) right_lca = self.find_lca(root.right, p, q) if left_lca and right_lca: return root return left_lca if left_lca else right_lca"},{"question":"# Question: Improved Sorting Algorithm Context You are tasked with implementing an enhanced version of the Merge Sort algorithm that is optimized for partially sorted arrays. This enhanced version, known as TimSort, merges the best practices from Merge Sort and Insertion Sort to maintain high performance even on nearly sorted data. In this implementation, you will identify small runs (sub-arrays) and use Insertion Sort to sort these runs before merging them using the standard Merge Sort procedure. Task Implement the following functions within a Python class `TimSort`: 1. `insertion_sort(self, arr, left, right)`: - Sort the segment of the array using Insertion Sort. - Input: - `arr`: 1D list of integers. - `left`: Integer, starting index of the segment. - `right`: Integer, ending index of the segment. - Output: Sorted segment of the array within the given range. 2. `merge(self, arr, left, mid, right)`: - Merge two sorted sub-arrays into a single sorted sub-array. - Input: - `arr`: 1D list of integers. - `left`: Integer, starting index of the first sorted sub-array. - `mid`: Integer, ending index (exclusive) of the first sorted sub-array. - `right`: Integer, ending index of the second sorted sub-array. - Output: A merged and sorted array within the given range. 3. `tim_sort(self, arr, run_size)`: - Perform TimSort on the input array. - Input: - `arr`: 1D list of integers. - `run_size`: Integer, size of runs to be used for Insertion Sort. - Output: Sorted array. Constraints - You must use Insertion Sort for runs of size ≤ `run_size` before merging. - Assume the input list contains no duplicate values. - Your solution should handle typical edge cases of unsorted and sorted arrays of various lengths. # Solution Outline ```python class TimSort: def insertion_sort(self, arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge(self, arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid left_arr = arr[left:mid + 1] right_arr = arr[mid + 1:right + 1] i, j, k = 0, 0, left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 while i < n1: arr[k] = left_arr[i] i += 1 k += 1 while j < n2: arr[k] = right_arr[j] j += 1 k += 1 return arr def tim_sort(self, arr, run_size): n = len(arr) for start in range(0, n, run_size): end = min(start + run_size - 1, n - 1) self.insertion_sort(arr, start, end) size = run_size while size < n: for left in range(0, n, 2 * size): mid = min(n - 1, left + size - 1) right = min((left + 2 * size - 1), (n - 1)) if mid < right: self.merge(arr, left, mid, right) size = 2 * size return arr # Sample usage: tim_sorter = TimSort() sorted_array = tim_sorter.tim_sort([5, 2, 9, 1, 5, 6], 32) print(sorted_array) # [1, 2, 5, 5, 6, 9] ```","solution":"class TimSort: def insertion_sort(self, arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def merge(self, arr, left, mid, right): n1 = mid - left + 1 n2 = right - mid left_arr = arr[left:mid + 1] right_arr = arr[mid + 1:right + 1] i, j, k = 0, 0, left while i < n1 and j < n2: if left_arr[i] <= right_arr[j]: arr[k] = left_arr[i] i += 1 else: arr[k] = right_arr[j] j += 1 k += 1 while i < n1: arr[k] = left_arr[i] i += 1 k += 1 while j < n2: arr[k] = right_arr[j] j += 1 k += 1 return arr def tim_sort(self, arr, run_size): n = len(arr) for start in range(0, n, run_size): end = min(start + run_size - 1, n - 1) self.insertion_sort(arr, start, end) size = run_size while size < n: for left in range(0, n, 2 * size): mid = min(n - 1, left + size - 1) right = min((left + 2 * size - 1), (n - 1)) if mid < right: self.merge(arr, left, mid, right) size = 2 * size return arr"},{"question":"# Scenario You are developing a system that models the behavior of a queue with prioirty elements. You need to design a `PriorityQueue` class that supports basic queue operations with an added layer of complexity: elements have priorities, and dequeue operation should always remove the element with the highest priority first. # Task Implement the `PriorityQueue` class with the following methods: - `enqueue(element: Any, priority: int) -> None`: Adds an element to the queue with the specified priority. - `dequeue() -> Any`: Removes and returns the element with the highest priority. If multiple elements have the same priority, the one that was enqueued first should be dequeued first. - `peek() -> Any`: Returns the element with the highest priority without removing it from the queue. - `is_empty() -> bool`: Returns `True` if the queue is empty, `False` otherwise. # Function Signature Your implementation should include the following methods: ```python class PriorityQueue: def __init__(self): Initializes an empty priority queue. pass def enqueue(self, element: Any, priority: int) -> None: Adds an element to the queue with the given priority. Args: element (Any): The element to add. priority (int): The priority of the element. pass def dequeue(self) -> Any: Removes and returns the element with the highest priority. If multiple elements have the same priority, the element that was enqueued first is dequeued first. Returns: Any: The element with the highest priority. pass def peek(self) -> Any: Returns the element with the highest priority without removing it from the queue. Returns: Any: The element with the highest priority. pass def is_empty(self) -> bool: Checks if the priority queue is empty. Returns: bool: `True` if the queue is empty, `False` otherwise. pass ``` # Example Usage ```python pq = PriorityQueue() pq.enqueue(\\"task1\\", 1) pq.enqueue(\\"task2\\", 2) pq.enqueue(\\"task3\\", 1) print(pq.peek()) # Expected output: \\"task2\\" print(pq.dequeue()) # Expected output: \\"task2\\" print(pq.dequeue()) # Expected output: \\"task1\\" print(pq.is_empty()) # Expected output: False print(pq.dequeue()) # Expected output: \\"task3\\" print(pq.is_empty()) # Expected output: True ``` # Constraints * The methods should have an average time complexity of O(log N) for enqueue and dequeue operations, where N is the number of elements in the queue. * You can assume that the `priority` values are integers, and there can be negative priorities as well. * You must ensure that the queue follows FIFO order when elements have the same priority. * Elements can be of any data type (string, number, object, etc.). # Note You may use any data structure suitable for implementing the priority queue with the required average time complexity, such as a heap in combination with a secondary data structure to ensure FIFO ordering within the same priority level.","solution":"import heapq class PriorityQueue: def __init__(self): Initializes an empty priority queue. self.counter = 0 # A counter to keep track of order of insertion self.pq = [] # The priority queue implemented as a heap def enqueue(self, element, priority): Adds an element to the queue with the given priority. Args: element (Any): The element to add. priority (int): The priority of the element. # Use a tuple with (-priority) to simulate a max-heap, and use counter to maintain FIFO order for the same priority heapq.heappush(self.pq, (-priority, self.counter, element)) self.counter += 1 def dequeue(self): Removes and returns the element with the highest priority. If multiple elements have the same priority, the element that was enqueued first is dequeued first. Returns: Any: The element with the highest priority. if self.is_empty(): raise IndexError(\\"Cannot dequeue from an empty queue\\") return heapq.heappop(self.pq)[2] def peek(self): Returns the element with the highest priority without removing it from the queue. Returns: Any: The element with the highest priority. if self.is_empty(): raise IndexError(\\"Cannot peek into an empty queue\\") return self.pq[0][2] def is_empty(self): Checks if the priority queue is empty. Returns: bool: `True` if the queue is empty, `False` otherwise. return len(self.pq) == 0"},{"question":"# Customer Satisfaction Analysis for E-commerce You are tasked with implementing a system to analyze customer satisfaction based on review scores of purchased products on an e-commerce platform. Each review includes customer ID, product ID, and a satisfaction score on a scale from 1 to 5. # Objective Implement a function `satisfaction_analysis` that calculates the satisfaction rating for each product as the average satisfaction score, considering only reviews with a customer satisfaction score greater than 2. # Input - `reviews`: List of reviews, where each review is represented by a list `[customer_id, product_id, satisfaction_score]`. # Output A list of products along with their respective average satisfaction rating, sorted by product ID in ascending order. If a product has no reviews with a satisfaction score greater than 2, continue to the next available product. # Constraints - The number of reviews, n, will be between 1 and 10^4. - `customer_id` and `product_id` will be positive integers. - `satisfaction_score` will be an integer between 1 and 5 inclusive. # Example ```python reviews = [ [1, 101, 3], [2, 102, 5], [3, 101, 2], [4, 103, 4], [5, 102, 1], [6, 101, 4], [7, 104, 5], [8, 104, 3], [9, 103, 1] ] satisfaction_analysis(reviews) ``` Expected Output: ``` [ [101, 3.5], [102, 5.0], [103, 4.0], [104, 4.0] ] ``` Note how the output includes only the products with reviews having satisfaction scores greater than 2, calculating the average satisfaction rating accordingly, and sorted by product ID.","solution":"def satisfaction_analysis(reviews): from collections import defaultdict # Dictionary to store total satisfaction and count of valid reviews per product product_ratings = defaultdict(lambda: [0, 0]) for review in reviews: customer_id, product_id, satisfaction_score = review if satisfaction_score > 2: product_ratings[product_id][0] += satisfaction_score product_ratings[product_id][1] += 1 result = [] for product_id in sorted(product_ratings): total_score, count = product_ratings[product_id] if count > 0: average_score = total_score / count result.append([product_id, round(average_score, 1)]) return result"},{"question":"# Context You are developing a scheduling system that helps to manage and track tasks. Each task has a priority level, which is crucial for determining the order of execution. To efficiently handle task priorities, you need to implement a priority queue using a heap data structure. # Problem Statement Write a class `TaskScheduler` with the following methods: 1. `add_task(priority: int, task_name: str) -> None` 2. `pop_task() -> str` 3. `peek_task() -> str` 4. `is_empty() -> bool` Method Descriptions: * **add_task**: Adds a new task with a given priority to the scheduler. * **pop_task**: Removes and returns the name of the highest priority task. * **peek_task**: Returns the name of the highest priority task without removing it. * **is_empty**: Checks if there are no tasks in the scheduler. Task Description: * Each task is represented by a string `task_name`. * Task priorities are integers, where a lower value indicates a higher priority. Input and Output Formats: * **Input**: - `priority`: An integer representing the task\'s priority. - `task_name`: A string representing the task\'s name. * **Output**: The outputs vary based on the methods as described above. Constraints: 1. The tasks names are unique strings. 2. The priority is a non-negative integer. Example Usage: ```python scheduler = TaskScheduler() scheduler.add_task(2, \\"Task A\\") scheduler.add_task(1, \\"Task B\\") scheduler.add_task(3, \\"Task C\\") print(scheduler.peek_task()) # Output: \\"Task B\\" print(scheduler.pop_task()) # Output: \\"Task B\\" print(scheduler.pop_task()) # Output: \\"Task A\\" print(scheduler.is_empty()) # Output: False print(scheduler.pop_task()) # Output: \\"Task C\\" print(scheduler.is_empty()) # Output: True ``` # Performance Requirement The methods should efficiently handle the task priorities, ensuring that both adding a task and removing the highest priority task operate in logarithmic time, O(log n). Design a robust and efficient solution that adheres to the specified performance requirements and accurately manages the priority queue. Good luck!","solution":"import heapq class TaskScheduler: def __init__(self): # Initialize an empty list to create the heap self.heap = [] # Dictionary to store the task names and their priorities self.task_map = {} def add_task(self, priority: int, task_name: str) -> None: Adds a new task with a given priority to the scheduler. heapq.heappush(self.heap, (priority, task_name)) self.task_map[task_name] = priority def pop_task(self) -> str: Removes and returns the name of the highest priority task. if self.is_empty(): raise IndexError(\\"Pop from an empty TaskScheduler\\") priority, task_name = heapq.heappop(self.heap) del self.task_map[task_name] return task_name def peek_task(self) -> str: Returns the name of the highest priority task without removing it. if self.is_empty(): raise IndexError(\\"Peek from an empty TaskScheduler\\") priority, task_name = self.heap[0] return task_name def is_empty(self) -> bool: Checks if there are no tasks in the scheduler. return len(self.heap) == 0"},{"question":"# Coding Assessment Question Context You have been tasked with implementing a simple command-line todo list application. The application\'s requirements are to add tasks, mark them as completed, and list all tasks with their statuses. The interface should be user-friendly and resilient to user errors. Task Your task is to implement the core functionality of the todo list application. Specifically, you need to address the following features: 1. **Add Task**: Implement a function to add a new task to the todo list. 2. **Mark Task as Completed**: Implement a function to mark a specified task as completed. 3. **List Tasks**: Implement a function to list all the tasks with their completion statuses. 4. **User Input Handling**: Ensure that the application gracefully handles invalid inputs for task actions. Function Signature Your application should include these three functions: ```python def add_task(task: str): Adds a new task to the todo list. Parameters: task (str): The task description. def mark_task_completed(task_id: int): Marks a specified task as completed. Parameters: task_id (int): The id of the task to mark as completed. def list_tasks(): Lists all tasks with their statuses. ``` Command-Line Interface Additionally, you should implement a simple command-line interface that allows the user to interact with the application. The interface should support the following commands: - `add [task_description]`: Adds a new task. - `complete [task_id]`: Marks the specified task as completed. - `list`: Lists all tasks. Constraints * Task ids should start from 1 and increment sequentially. * Tasks should be stored in memory (no need for persistent storage). * Invalid commands or arguments should produce an appropriate error message. Example Interaction ``` > add Buy groceries Task added with id 1. > add Finish homework Task added with id 2. > list 1. [ ] Buy groceries 2. [ ] Finish homework > complete 2 Task 2 marked as completed. > list 1. [ ] Buy groceries 2. [x] Finish homework > complete 3 Error: Task id 3 does not exist. ``` **Expected Outcome**: The application should correctly add tasks, mark them as completed, and list them with their statuses. It should also handle invalid task ids with appropriate error messages. Good luck!","solution":"tasks = [] def add_task(task: str): Adds a new task to the todo list. Parameters: task (str): The task description. new_task = {\'id\': len(tasks) + 1, \'description\': task, \'completed\': False} tasks.append(new_task) return new_task[\'id\'] def mark_task_completed(task_id: int): Marks a specified task as completed. Parameters: task_id (int): The id of the task to mark as completed. for task in tasks: if task[\'id\'] == task_id: task[\'completed\'] = True return f\\"Task {task_id} marked as completed.\\" return f\\"Error: Task id {task_id} does not exist.\\" def list_tasks(): Lists all tasks with their statuses. return tasks"},{"question":"# Binary Tree Right Side View Given the root of a binary tree, imagine you are standing on the right side of it, return an array of the values of the nodes you can see ordered from top to bottom. Function Signature: ```python def rightSideView(root: TreeNode) -> List[int]: ``` Input: - `root`: The root node of the binary tree. Each node of the tree has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output: - A list of integers representing the values of the nodes you can see from the right side. Constraints: - The number of nodes in the tree is in the range `[0, 100]`. - `-100 <= node.val <= 100` Example: ```python # Example of TreeNode class for reference class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example binary tree: # 1 # / # 2 3 # # 5 4 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) root.right.right = TreeNode(4) print(rightSideView(root)) # Output: [1, 3, 4] ``` Explanation: In the example binary tree, the node values visible from the right side are: 1, 3, and 4.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(result): result.append(node.val) if node.right: queue.append((node.right, level + 1)) if node.left: queue.append((node.left, level + 1)) return result"},{"question":"# Implement a Stack with Minimum Retrieval Your task is to design and implement a stack that, in addition to the usual push and pop operations, also supports a `get_min` operation that retrieves the minimum element in the stack in constant time. # Function Signature ```python class MinStack: def __init__(self): # Initializes an empty stack pass def push(self, x: int) -> None: # Pushes the element x onto the stack pass def pop(self) -> None: # Removes the element on the top of the stack pass def top(self) -> int: # Retrieves the element on the top of the stack pass def get_min(self) -> int: # Retrieves the minimum element in the stack pass ``` # Constraints - You must achieve `get_min` in O(1) time. - All methods must operate in O(1) time. - No external libraries are allowed (e.g., no importing `collections`). - You cannot directly use built-in data structures like `list` for stack operations. # Example ```python stack = MinStack() stack.push(3) stack.push(5) assert stack.get_min() == 3 stack.push(2) stack.push(1) assert stack.get_min() == 1 stack.pop() assert stack.get_min() == 2 stack.pop() assert stack.top() == 5 assert stack.get_min() == 3 ``` # Additional Notes - Use auxiliary data structures as needed to maintain constant time complexity for `get_min`. - Ensure efficient memory usage so that the space complexity remains manageable for large inputs.","solution":"class MinStack: def __init__(self): Initializes an empty stack and an auxiliary stack to keep track of minimums. self.stack = [] self.min_stack = [] def push(self, x: int) -> None: Pushes the element x onto the stack. Also, updates the minimum stack if needed. self.stack.append(x) if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) def pop(self) -> None: Removes the element on the top of the stack. Also, updates the minimum stack if needed. if self.stack: top_element = self.stack.pop() if top_element == self.min_stack[-1]: self.min_stack.pop() def top(self) -> int: Retrieves the element on the top of the stack without removing it. if self.stack: return self.stack[-1] def get_min(self) -> int: Retrieves the minimum element in the stack without removing it. if self.min_stack: return self.min_stack[-1]"},{"question":"Currency Conversion Application # Context You are developing a financial application that helps users convert amounts of money between different currencies. To add more functionality to your application, you need to implement a function that not only converts the amounts based on the given exchange rates but also handles some potential issues like unsupported currencies or invalid input types. # Task Implement a function `extended_currency_conversion` that can: 1. Perform currency conversion based on given exchange rates. 2. Extend the list of supported currencies to include `USD`, `EUR`, `JPY`, `GBP`, `AUD`, and `CAD`. 3. Handle both uppercase and lowercase currency codes. 4. Provide a user-friendly error message for unsupported currencies. 5. Return the converted amount rounded to two decimal places. # Function Signature ```python def extended_currency_conversion(amount: float, from_currency: str, to_currency: str, exchange_rates: dict) -> float: pass ``` # Inputs and Outputs - **Input**: - `amount`: A floating-point number representing the amount of money in `from_currency`. - `from_currency`: A string specifying the currency to convert from. - `to_currency`: A string specifying the currency to convert to. - `exchange_rates`: A dictionary where keys are currency codes (strings) and values are the respective conversion rates to USD (as a float). - **Output**: - A floating-point number representing the converted amount in the `to_currency` currency, rounded to two decimal places. # Constraints - `amount` is a non-negative floating-point number. - `from_currency` and `to_currency` will be non-empty strings. - The function should handle currency codes in a case-insensitive manner. - Exchange rates should be provided for all supported currencies. # Example Usage ```python exchange_rates = { \\"USD\\": 1.0, \\"EUR\\": 0.85, \\"JPY\\": 110.0, \\"GBP\\": 0.75, \\"AUD\\": 1.3, \\"CAD\\": 1.25 } assert extended_currency_conversion(100, \\"USD\\", \\"EUR\\", exchange_rates) == 85.0 assert extended_currency_conversion(200, \\"JPY\\", \\"USD\\", exchange_rates) == 1.82 assert extended_currency_conversion(50, \\"AUD\\", \\"GBP\\", exchange_rates) == 28.85 assert extended_currency_conversion(100, \\"usd\\", \\"eur\\", exchange_rates) == 85.0 # Test for unsupported currency try: extended_currency_conversion(100, \\"INR\\", \\"USD\\", exchange_rates) except ValueError as e: assert str(e) == \\"Invalid `from_currency` unit: \'INR\'. Supported currencies are: USD, EUR, JPY, GBP, AUD, CAD\\" ``` # Supported Currencies - USD (United States Dollar) - EUR (Euro) - JPY (Japanese Yen) - GBP (British Pound) - AUD (Australian Dollar) - CAD (Canadian Dollar) # Notes 1. Ensure that the currency codes are handled case-insensitively for user convenience. 2. Implement proper validation to check the validity of the currency codes provided in the dictionary. 3. Ensure accurate conversion based on the given exchange rates, considering USD as the base currency.","solution":"def extended_currency_conversion(amount: float, from_currency: str, to_currency: str, exchange_rates: dict) -> float: Converts the given amount from one currency to another based on the provided exchange rates. Handles various edge cases such as case-insensitive currency codes and unsupported currencies. Args: - amount (float): The amount of money in the from_currency. - from_currency (str): The currency code to convert from. - to_currency (str): The currency code to convert to. - exchange_rates (dict): A dictionary where the keys are currency codes and the values are their respective exchange rates to USD. Returns: - float: The converted amount in the to_currency, rounded to two decimal places. Raises: - ValueError: If either the from_currency or to_currency is not supported. supported_currencies = {\\"usd\\", \\"eur\\", \\"jpy\\", \\"gbp\\", \\"aud\\", \\"cad\\"} # Normalize currency codes to lowercase from_currency = from_currency.lower() to_currency = to_currency.lower() # Check if both currencies are supported if from_currency not in supported_currencies: raise ValueError(f\\"Invalid `from_currency` unit: \'{from_currency.upper()}\'. Supported currencies are: USD, EUR, JPY, GBP, AUD, CAD\\") if to_currency not in supported_currencies: raise ValueError(f\\"Invalid `to_currency` unit: \'{to_currency.upper()}\'. Supported currencies are: USD, EUR, JPY, GBP, AUD, CAD\\") # Convert from `from_currency` to USD amount_in_usd = amount / exchange_rates[from_currency.upper()] # Convert from USD to `to_currency` converted_amount = amount_in_usd * exchange_rates[to_currency.upper()] # Return the converted amount rounded to two decimal places return round(converted_amount, 2)"},{"question":"# Vectors Dot Product Calculation Problem You are given two vectors represented as lists of integers. You need to calculate the dot product of these two vectors. Implement the function `dot_product` according to the provided specifications. Function Signature ```python def dot_product(vector1: list[int], vector2: list[int]) -> int: ``` Input - `vector1` (list[int]): A list of integers representing the first vector. - `vector2` (list[int]): A list of integers representing the second vector. Output - Returns an integer that represents the dot product of the two vectors. Constraints - If the lengths of `vector1` and `vector2` are not equal, raise a `ValueError` with the message \\"Vectors must be of the same length\\". - Each vector must contain only integers. Examples ```python # Example 1 assert dot_product([1, 2, 3], [4, 5, 6]) == 32 # Example 2 assert dot_product([0, 1, 2], [0, 1, 2]) == 5 # Example 3 assert dot_product([-1, 2, -3], [4, -5, 6]) == -32 # Example 4 assert dot_product([1, 1, 1], [1, 1, 1]) == 3 # Example 5 try: dot_product([1, 2], [1, 2, 3]) except ValueError as e: assert str(e) == \\"Vectors must be of the same length\\" ``` Detailed Explanation 1. **Validation**: - Check whether the lengths of `vector1` and `vector2` are equal. - Ensure that both vectors contain only integers. 2. **Calculation**: - Compute the dot product using the formula: (text{dot product} = sum_{i=0}^{n-1} (v1[i] times v2[i])) where (n) is the length of the vectors. 3. **Return**: - Return the computed dot product value. Provide a robust implementation of the function `dot_product` following these guidelines and ensuring that all edge cases are handled correctly.","solution":"def dot_product(vector1, vector2): Calculates the dot product of two vectors represented as lists of integers. Arguments: vector1 -- list of integers, the first vector vector2 -- list of integers, the second vector Returns: An integer that is the dot product of the two vectors. Raises: ValueError if the two vectors do not have the same length. if len(vector1) != len(vector2): raise ValueError(\\"Vectors must be of the same length\\") return sum(v1 * v2 for v1, v2 in zip(vector1, vector2))"},{"question":"# Efficient String Matching Using KMP Algorithm You are required to implement the Knuth-Morris-Pratt (KMP) string matching algorithm. The KMP algorithm searches for occurrences of a \\"pattern\\" string within a \\"text\\" string efficiently by avoiding redundant comparisons. Function Specifications: 1. Implement the function `computeLPSArray(pattern: str) -> List[int]`. * **Input**: * `pattern`: A string representing the pattern to search for. * **Output**: * Returns a list of integers representing the Longest Prefix Suffix (LPS) array for the given pattern. 2. Implement the function `KMPSearch(text: str, pattern: str) -> List[int]`. * **Input**: * `text`: A string representing the text where the pattern is to be searched. * `pattern`: A string representing the pattern to search for. * **Output**: * Returns a list of integers representing the start indices of all occurrences of the pattern in the text. Example: ```python text = \\"ababcababcababcab\\" pattern = \\"ababc\\" lps_array = computeLPSArray(pattern) result = KMPSearch(text, pattern) # Output print(\\"LPS Array:\\") print(lps_array) print(\\"Pattern found at indices:\\") print(result) # Expected Output: # LPS Array: # [0, 0, 1, 2, 0] # Pattern found at indices: # [0, 5, 10] ``` Constraints: * 1 ≤ length of text ≤ 10000 * 1 ≤ length of pattern ≤ 1000 Notes: * Ensure the implementation is efficient to handle the constraints. * Handle edge cases like an empty text or pattern properly. * Test the implementation with various cases including overlapping patterns and patterns at the beginning or end of the text.","solution":"from typing import List def computeLPSArray(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array for the given pattern. length = 0 # Length of the previous longest prefix suffix lps = [0] * len(pattern) i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def KMPSearch(text: str, pattern: str) -> List[int]: Searches for occurrences of the pattern string within the text string using the KMP algorithm. if not text or not pattern: return [] lps = computeLPSArray(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Longest Zigzag Subsequence Scenario In computer science, especially in the area of dynamic programming, finding specific patterns within sequences is a typical problem. One such pattern is the \\"zigzag\\" sequence, where the differences between consecutive elements alternate between positive and negative. Task Write a function `longest_zigzag_subsequence(sequence: List[int]) -> int` that calculates the length of the longest zigzag subsequence in the given list of integers. Specifications **Function Signature** ```python def longest_zigzag_subsequence(sequence: List[int]) -> int: pass ``` **Input** - `sequence` (List[int]): A list of integers representing the sequence. **Output** - (int): The length of the longest zigzag subsequence. **Constraints** - The length of the sequence is between 1 and 10^4. - The elements of the sequence are integers between -10^6 and 10^6. **Performance Requirements** - Solution should complete efficiently for the given constraints. Examples ```python >>> longest_zigzag_subsequence([1, 7, 4, 9, 2, 5]) 6 >>> longest_zigzag_subsequence([1, 4, 7, 2, 5]) 4 >>> longest_zigzag_subsequence([1, 7, 4, 9, 9]) 4 >>> longest_zigzag_subsequence([44]) 1 ``` **Implementation Notes** - A sequence is considered a zigzag sequence if the differences between successive elements strictly alternate between positive and negative. - If only one element is in the sequence, the longest zigzag subsequence is the sequence itself. Good luck! Ensure your solution is optimal and handles all edge cases.","solution":"from typing import List def longest_zigzag_subsequence(sequence: List[int]) -> int: if not sequence: return 0 if len(sequence) == 1: return 1 up, down = 1, 1 for i in range(1, len(sequence)): if sequence[i] > sequence[i - 1]: up = down + 1 elif sequence[i] < sequence[i - 1]: down = up + 1 return max(up, down)"},{"question":"# Programming Question **Scenario** You are working on an application that requires frequent conversion between different temperature scales for scientific data analysis. The three common temperature scales are Celsius (°C), Fahrenheit (°F), and Kelvin (K). **Problem Statement** Implement a function `convert_temperature` that converts a temperature value from one scale to another using the following conversion formulas: - From Celsius to Fahrenheit: ( F = frac{9}{5}C + 32 ) - From Celsius to Kelvin: ( K = C + 273.15 ) - From Fahrenheit to Celsius: ( C = frac{5}{9}(F - 32) ) - From Fahrenheit to Kelvin: ( K = frac{5}{9}(F - 32) + 273.15 ) - From Kelvin to Celsius: ( C = K - 273.15 ) - From Kelvin to Fahrenheit: ( F = frac{9}{5}(K - 273.15) + 32 ) **Function Signature** ```python def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: pass ``` **Input** - `value` (float): The temperature value to convert. - `from_scale` (str): The original scale of the temperature value, which can be \\"Celsius\\", \\"Fahrenheit\\", or \\"Kelvin\\". - `to_scale` (str): The target scale to convert the temperature value into, which can be \\"Celsius\\", \\"Fahrenheit\\", or \\"Kelvin\\". **Output** - (float): The converted temperature value in the target scale. **Constraints** - The inputs `from_scale` and `to_scale` are always valid and among \\"Celsius\\", \\"Fahrenheit\\", and \\"Kelvin\\". - The function should be case-insensitive for the scale inputs. **Examples** ```python # Example 1 # Convert 25 degrees Celsius to Fahrenheit print(convert_temperature(25, \'Celsius\', \'Fahrenheit\')) # Output: 77.0 # Example 2 # Convert 0 degrees Fahrenheit to Kelvin print(convert_temperature(0, \'Fahrenheit\', \'Kelvin\')) # Output: 255.3722222222222 # Example 3 # Convert 373.15 Kelvin to Celsius print(convert_temperature(373.15, \'Kelvin\', \'Celsius\')) # Output: 100.0 # Example 4 # Convert 100 degrees Fahrenheit to Celsius print(convert_temperature(100, \'Fahrenheit\', \'Celsius\')) # Output: 37.77777777777778 ``` **Notes** - Make sure the conversion correctly handles mixed-case inputs (e.g., \\"celsius\\", \\"FAHRENHEIT\\"). - Consider using helper functions for the conversion formulas to maintain the clarity of your code.","solution":"def convert_temperature(value: float, from_scale: str, to_scale: str) -> float: Converts a temperature value from one scale to another. Args: value (float): The temperature value to convert. from_scale (str): The original scale of the temperature value. to_scale (str): The target scale to convert the temperature value into. Returns: float: The converted temperature value in the target scale. from_scale = from_scale.lower() to_scale = to_scale.lower() if from_scale == to_scale: return value # Convert from the origin scale to Celsius if from_scale == \'celsius\': temp_celsius = value elif from_scale == \'fahrenheit\': temp_celsius = (value - 32) * 5 / 9 elif from_scale == \'kelvin\': temp_celsius = value - 273.15 # Convert from Celsius to the target scale if to_scale == \'celsius\': return temp_celsius elif to_scale == \'fahrenheit\': return temp_celsius * 9 / 5 + 32 elif to_scale == \'kelvin\': return temp_celsius + 273.15"},{"question":"# Celebrity Identification You are tasked with creating an algorithm to identify a celebrity in a party scenario. A celebrity is someone who is known by everyone but knows no one at the party. You need to implement the following functions: 1. `knows(a: int, b: int) -> bool`: This is a helper function provided to you. It returns a boolean value indicating whether person `a` knows person `b`. 2. `find_celebrity(n: int) -> int`: This function should use the `knows` function to identify the celebrity and return their index. Input and Output Formats **`knows` function:** * Input: Two integers `a` and `b`, where `0 <= a, b < n`. * Output: Boolean value indicating if `a` knows `b`. **`find_celebrity` function:** * Input: Integer `n` representing the number of people at the party. * Output: Integer representing the index of the celebrity. If no celebrity is found, return `-1`. Constraints * The input value `n` should be a non-negative integer. * It is guaranteed that one of the functions is pre-defined for you to test your functions: ```python def knows(a: int, b: int) -> bool: party = [ # Example party adjacency matrix [False, True, False], [False, False, False], [True, True, False] ] return party[a][b] ``` Examples ```python >>> knows(0, 1) True >>> knows(2, 1) True >>> find_celebrity(3) 1 # Explanation: # 0 knows 1 # 2 knows 1 # 1 knows no one >>> find_celebrity(2) -1 # Explanation: No celebrity found as both people know each other or no one knows each other. >>> find_celebrity(0) -1 # Explanation: No people at the party, hence no celebrity. >>> find_celebrity(1) 0 # Explanation: Only one person at the party, they are a celebrity by definition. ``` You need to handle invalid inputs by raising appropriate exceptions similar to the original implementation.","solution":"# Helper function provided def knows(a: int, b: int, party) -> bool: This function is provided to indicate if person `a` knows person `b`. The `party` parameter is a 2D array (adjacency matrix) indicating who knows whom. return party[a][b] def find_celebrity(n: int, party) -> int: Finds and returns the index of the celebrity at the party. If there is no celebrity, returns -1. if n == 0: return -1 # Step 1: Find a candidate who could be the celebrity candidate = 0 for i in range(1, n): if knows(candidate, i, party): candidate = i # Step 2: Verify the candidate for i in range(n): if i != candidate: if knows(candidate, i, party) or not knows(i, candidate, party): return -1 return candidate"},{"question":"# Context You are building an application to help users manage their to-do lists. A key requirement is the ability to merge multiple to-do lists together while ensuring that duplicate tasks are removed. # Task Write a Python function that takes two lists of to-do items and returns a single list with all unique tasks. Each task is represented as a dictionary with two keys: `\\"task\\"` and `\\"priority\\"`. The function should also handle edge cases where one or both lists are empty. # Function Signature ```python def merge_todos(list1: list, list2: list) -> list: ``` # Requirements - Your function should return a list of unique tasks. - Each task in the output list should be a dictionary with keys `\\"task\\"` and `\\"priority\\"`, where: - `\\"task\\"`: A string representing the name of the task. - `\\"priority\\"`: An integer representing the priority of the task (1 being the highest priority). - If there are duplicate tasks (i.e., tasks with the same name), the one with the higher priority should be kept in the output list. - Both lists may contain tasks with varying priorities. # Constraints - The priority values will be integers. - The task names are case-sensitive and should be treated as unique based on exact string matching. - The output list should maintain the order of tasks based on their first appearance in the input lists, while ensuring no duplicates. # Example Usage ```python list1 = [ {\\"task\\": \\"buy groceries\\", \\"priority\\": 2}, {\\"task\\": \\"clean house\\", \\"priority\\": 3}, {\\"task\\": \\"pay bills\\", \\"priority\\": 1}, ] list2 = [ {\\"task\\": \\"clean house\\", \\"priority\\": 1}, {\\"task\\": \\"write report\\", \\"priority\\": 2}, {\\"task\\": \\"exercise\\", \\"priority\\": 1}, ] result = merge_todos(list1, list2) for todo in result: print(f\\"{todo[\'task\']} (priority: {todo[\'priority\']})\\") ``` # Expected Output ``` buy groceries (priority: 2) clean house (priority: 1) pay bills (priority: 1) write report (priority: 2) exercise (priority: 1) ``` # Notes - Consider using a dictionary to track the tasks and their highest priority. - Ensure the function handles both lists being empty, returning an empty list in such cases.","solution":"def merge_todos(list1: list, list2: list) -> list: task_dict = {} # Merge both lists combined_lists = list1 + list2 # Process each task for task in combined_lists: task_name = task[\\"task\\"] task_priority = task[\\"priority\\"] if task_name not in task_dict or task_dict[task_name][\\"priority\\"] > task_priority: task_dict[task_name] = task # Maintain order based on the first appearance in the combined lists unique_tasks = [] seen = set() for task in combined_lists: task_name = task[\\"task\\"] if task_name not in seen: seen.add(task_name) unique_tasks.append(task_dict[task_name]) return unique_tasks"},{"question":"# Problem Statement You are given a task to process and analyze time-series data. The data is provided as a Pandas DataFrame, where each column represents a different feature over time. You need to implement a function that performs a specified set of preprocessing steps and feature extraction techniques on the input data for further analysis. # Task Write a Python function called `process_time_series` that implements the following steps: 1. **Normalization**: Normalize each feature (column) in the DataFrame to have a mean of 0 and a standard deviation of 1. 2. **Rolling Window**: Apply a rolling window operation that calculates the mean and standard deviation over a specified window size for each feature. 3. **Feature Aggregation**: Aggregate the features by calculating their mean, standard deviation, minimum, and maximum over the entire time series. 4. **Lag Features**: Create additional features by introducing lagging for each feature up to a specified number of lags. # Function Signature ```python def process_time_series( data: pd.DataFrame, window_size: int, num_lags: int ) -> pd.DataFrame: pass ``` # Input * `data` (pd.DataFrame): A Pandas DataFrame where each column represents a time-series feature. * `window_size` (int): The size of the rolling window. It must be a positive integer. * `num_lags` (int): The number of lag features to introduce. It must be a non-negative integer. # Output * Returns a new Pandas DataFrame containing the normalized and processed features including rolling statistics and lag features. # Constraints * The input DataFrame `data` contains one or more columns. * The `window_size` is a positive integer and should be less than or equal to the number of rows in the DataFrame. * The `num_lags` is a non-negative integer and should not exceed the number of rows in the DataFrame. # Example ```python >>> import pandas as pd >>> data = { ... \'feature1\': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], ... \'feature2\': [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ... } >>> df = pd.DataFrame(data) >>> processed_df = process_time_series(df, window_size=3, num_lags=2) >>> processed_df feature1_normalized feature2_normalized feature1_rolling_mean ... (other generated features) 0 -1.486 1.486 NaN ... 1 -1.156 1.156 NaN ... 2 -0.825 0.825 2.000 ... 3 -0.495 0.495 3.000 ... 4 -0.165 0.165 4.000 ... 5 0.165 -0.165 5.000 ... 6 0.495 -0.495 6.000 ... 7 0.825 -0.825 7.000 ... 8 1.156 -1.156 8.000 ... 9 1.486 -1.486 9.000 ... ``` You should handle potential edge cases such as an empty DataFrame or small window size gracefully. Leverage Pandas\' built-in functions for efficient and vectorized operations where possible.","solution":"import pandas as pd def normalize(df): return (df - df.mean()) / df.std() def process_time_series(data: pd.DataFrame, window_size: int, num_lags: int) -> pd.DataFrame: if data.empty: return pd.DataFrame() # Step 1: Normalization normalized_data = normalize(data) # Step 2: Rolling Window Mean and Std Dev rolling_mean = normalized_data.rolling(window=window_size).mean().add_suffix(\'_rolling_mean\') rolling_std = normalized_data.rolling(window=window_size).std().add_suffix(\'_rolling_std\') # Step 3: Feature Aggregation feature_agg = pd.DataFrame() for col in normalized_data.columns: feature_agg[f\'{col}_mean\'] = [normalized_data[col].mean()] feature_agg[f\'{col}_std\'] = [normalized_data[col].std()] feature_agg[f\'{col}_min\'] = [normalized_data[col].min()] feature_agg[f\'{col}_max\'] = [normalized_data[col].max()] # Step 4: Lag Features lag_features = pd.DataFrame() for i in range(1, num_lags + 1): lagged = normalized_data.shift(i).add_suffix(f\'_lag{i}\') lag_features = pd.concat([lag_features, lagged], axis=1) # Combine all features into a single DataFrame result = pd.concat([normalized_data.add_suffix(\'_normalized\'), rolling_mean, rolling_std, lag_features], axis=1) # Add aggregated features as a constant row repeated to match original data length feature_agg = pd.concat([feature_agg] * len(data)).reset_index(drop=True) result = pd.concat([result, feature_agg], axis=1) return result"},{"question":"# Problem Statement You are tasked with creating a simple validator for an integer based on specific rules. The rules require that an integer is considered valid if: 1. It is a multiple of 3. 2. It is a multiple of 5. 3. It ends with the digit 7. Write a function to determine if a given integer meets any of the above rules. The function should return `True` if the integer is valid, otherwise `False`. # Function Signature ```python def is_valid_integer(value: int) -> bool: Determines if an integer is valid based on predefined rules. :param value: The integer to be validated. :return: True if the integer is valid, False otherwise. ``` # Input - An integer `value`: - Constraint: -10^6 <= value <= 10^6 # Output - A boolean value: `True` if the integer meets any of the validation rules, `False` otherwise. # Example ```python assert is_valid_integer(15) == True # 15 is a multiple of 3 and 5. assert is_valid_integer(7) == True # 7 ends with the digit 7. assert is_valid_integer(21) == True # 21 is a multiple of 3. assert is_valid_integer(20) == True # 20 is a multiple of 5. assert is_valid_integer(19) == False # 19 does not meet any of the validation rules. assert is_valid_integer(-27) == True # -27 is a multiple of 3 and ends with the digit 7. ``` # Additional Instructions - Ensure your implementation considers both positive and negative integers. - Aim to optimize for clarity and efficiency.","solution":"def is_valid_integer(value: int) -> bool: Determines if an integer is valid based on predefined rules. :param value: The integer to be validated. :return: True if the integer is valid, False otherwise. return value % 3 == 0 or value % 5 == 0 or abs(value) % 10 == 7"},{"question":"# Coding Assessment Question Problem Statement You need to implement a function to calculate the minimum number of steps required to transform a given string `start` into another string `end` by either adding or replacing characters. You can only perform these operations one character at a time and only at the end of the string. Function Specifications - **Function Name**: `min_steps_to_transform` - **Input Parameters**: 1. `start` (string): The initial string. 2. `end` (string): The target string to transform into. Must not be shorter than `start`. - **Output**: - Returns an integer representing the minimum number of steps to transform the `start` string into the `end` string. - **Error Handling**: - Raise a `ValueError` if `end` is shorter than `start`. - Raise a `TypeError` if either `start` or `end` are not string values. Example Usage ```python >>> min_steps_to_transform(\\"abc\\", \\"abcdef\\") 3 >>> min_steps_to_transform(\\"hello\\", \\"hello world\\") 6 >>> min_steps_to_transform(\\"abc\\", \\"ab\\") Traceback (most recent call last): ... ValueError: \'end\' string must not be shorter than \'start\' string. >>> min_steps_to_transform(123, \\"abc\\") Traceback (most recent call last): ... TypeError: Both \'start\' and \'end\' must be strings. >>> min_steps_to_transform(\\"abc\\", \\"abc\\") 0 ``` Constraints - Both strings will consist of only printable ASCII characters (no special or escape sequences). Solution Template ```python def min_steps_to_transform(start: str, end: str) -> int: Calculate the minimum number of steps to transform start string into end string. :param start: Initial string :param end: Target string :return: Minimum number of steps to transform start into end if not isinstance(start, str) or not isinstance(end, str): raise TypeError(\\"Both \'start\' and \'end\' must be strings.\\") if len(end) < len(start): raise ValueError(\\"\'end\' string must not be shorter than \'start\' string.\\") steps = len(end) - len(start) equivalent_length = min(len(start), len(end)) for i in range(equivalent_length): if start[i] != end[i]: steps += 1 return steps ``` This question complements existing problems by requiring string manipulation and attention to detail around transformations and constraints. The error checking ensures robustness, matching the complexity seen in the other assessments.","solution":"def min_steps_to_transform(start: str, end: str) -> int: Calculate the minimum number of steps to transform start string into end string. :param start: Initial string :param end: Target string :return: Minimum number of steps to transform start into end if not isinstance(start, str) or not isinstance(end, str): raise TypeError(\\"Both \'start\' and \'end\' must be strings.\\") if len(end) < len(start): raise ValueError(\\"\'end\' string must not be shorter than \'start\' string.\\") steps = len(end) - len(start) equivalent_length = min(len(start), len(end)) for i in range(equivalent_length): if start[i] != end[i]: steps += 1 return steps"},{"question":"# Find the Distinct Letters in a Sorted List of Words **Scenario**: You are given a list of words and your task is to find all the distinct letters present in these words. The result should be a list of these distinct letters sorted in alphabetical order. Task: Implement the function `find_sorted_distinct_letters(words: List[str]) -> List[str]`. Given a list of strings `words`, the function should return a sorted list of characters that are present across all the words without duplicates. Input: - `words` : A list of strings where each string consists of lowercase English letters. Output: - A list of unique characters sorted in alphabetical order. Constraints: - All words will be non-empty and will only contain lowercase English letters. - You can assume the length of the list `words` will be between 1 and 1000. - The total number of characters in all the words combined will not exceed 100,000. Examples: - When the `words` is `[\\"apple\\", \\"banana\\", \\"cherry\\"]`, the function should return `[\'a\', \'b\', \'c\', \'e\', \'h\', \'l\', \'n\', \'p\', \'r\', \'y\']`. - When the `words` is `[\\"flower\\", \\"flow\\", \\"flight\\"]`, the function should return `[\'f\', \'g\', \'h\', \'i\', \'l\', \'o\', \'r\', \'t\', \'w\']`. # Performance requirements: - The function must handle large lists and should avoid unnecessary recomputation. - The solution should ensure efficient operations on set and list data structures to meet the constraints. # Notes: - Consider edge cases where all characters are distinct or all words are identical. - Make use of Python\'s set operations to ensure uniqueness and ease of merging character sets from multiple words. Example code snippet to be implemented: ```python from typing import List def find_sorted_distinct_letters(words: List[str]) -> List[str]: Return a sorted list of distinct letters present in the given list of words. # Your implementation here ```","solution":"from typing import List def find_sorted_distinct_letters(words: List[str]) -> List[str]: Return a sorted list of distinct letters present in the given list of words. # Combine sets of characters from all words to get distinct characters distinct_letters = set() for word in words: distinct_letters.update(word) # Convert the set to a sorted list and return return sorted(distinct_letters)"},{"question":"# Problem Statement You are a software engineer for a logistics company that needs to optimize truck loading. Your task is to design a software module that determines the maximum value of items that can be placed in a truck given its weight capacity. You are provided a list of items, each with a specific weight and value, as well as the truck\'s maximum weight capacity. Implement the classic knapsack problem algorithm to solve this. # Function Signature ```python def knapsack(max_weight: int, items: list[tuple[int, int]]) -> int: pass ``` # Input - `max_weight`: An integer representing the maximum weight capacity of the truck. - `items`: A list of tuples where each tuple represents an item, with the first element being the item\'s weight (a non-negative integer) and the second element being the item\'s value (a non-negative integer). # Output - Return an integer representing the maximum value that can be carried in the truck. # Constraints - `0 <= max_weight <= 10^4` - `0 <= len(items) <= 100` - Each element in `items` has non-negative integer weights and values. # Example - Input: `50, [(10, 60), (20, 100), (30, 120)]` - Output: `220` # Scenario Consider a scenario where a fleet manager needs to determine the optimal way to pack delivery trucks with high-value packages under specific weight constraints. This solution will allow efficient use of truck space and maximize the value of items delivered in each load. # Performance Requirements - The solution should operate in O(n * max_weight) time complexity, where `n` is the number of items. # Requirements - Do not use in-built Python functions that explicitly solve the problem. - Handle all edge cases, including cases where no items can be placed in the truck. - Ensure to raise a `ValueError` for any invalid input such as negative weights or values.","solution":"def knapsack(max_weight: int, items: list[tuple[int, int]]) -> int: Determine the maximum value of items that can be placed in a truck given its weight capacity. Parameters: max_weight (int): The maximum weight capacity of the truck. items (list of tuples): Each tuple contains (weight of the item, value of the item). Returns: int: The maximum value that can be carried in the truck. if max_weight < 0: raise ValueError(\\"max_weight must be a non-negative integer\\") for weight, value in items: if weight < 0 or value < 0: raise ValueError(\\"Item weights and values must be non-negative integers\\") dp = [0] * (max_weight + 1) for weight, value in items: for w in range(max_weight, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[max_weight]"},{"question":"# Scenario: As a software developer, you are tasked with building an inventory management system for a warehouse. A crucial feature of this system is to compute the total value of all items in the inventory based on their individual quantity and price. # Problem Statement: Write a function `calculate_inventory_value` that takes in a list of dictionaries, each representing an item with its quantity and price, and returns the total value of the inventory. # Input: * `items` (List[Dict[str, Union[float, int]]]): A list of dictionaries, where each dictionary contains: - `quantity` (int): The quantity of the item. It should be a non-negative integer. - `price_per_unit` (float): The price per unit of the item. It should be a non-negative float value. # Output: * `total_value` (float): The total value of all items in the inventory. # Constraints: * Each dictionary will have the keys `quantity` and `price_per_unit`. * If any item has invalid input (e.g., negative values for quantity or price), skip that item in the computation. # Performance Requirements: * The function should operate in O(n) time complexity, where n is the number of items in the inventory. * Ensure to handle any exceptions gracefully and skip invalid items. # Function Signature: ```python def calculate_inventory_value(items: List[Dict[str, Union[float, int]]]) -> float: pass ``` # Examples: ```python calculate_inventory_value([{\\"quantity\\": 10, \\"price_per_unit\\": 5.0}, {\\"quantity\\": 2, \\"price_per_unit\\": 3.5}]) # Expected Output: 57.0 calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": 2.0}, {\\"quantity\\": -1, \\"price_per_unit\\": 2.5}]) # Expected Output: 10.0 calculate_inventory_value([{\\"quantity\\": 0, \\"price_per_unit\\": 10.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 0.0}]) # Expected Output: 0.0 calculate_inventory_value([{\\"quantity\\": 5, \\"price_per_unit\\": -3.0}, {\\"quantity\\": 3, \\"price_per_unit\\": 3.0}]) # Expected Output: 9.0 ``` # Notes: * The function should ensure any invalid items with negative values are ignored in the calculation. * Do not use any external libraries for the calculations. * The function should return a float representing the total inventory value.","solution":"from typing import List, Dict, Union def calculate_inventory_value(items: List[Dict[str, Union[float, int]]]) -> float: total_value = 0.0 for item in items: quantity = item.get(\'quantity\', -1) price_per_unit = item.get(\'price_per_unit\', -1.0) if isinstance(quantity, int) and quantity >= 0 and isinstance(price_per_unit, (int, float)) and price_per_unit >= 0: total_value += quantity * price_per_unit return total_value"},{"question":"# Optimize Pathfinding in a Grid You are assigned the task of programming an efficient pathfinding algorithm in a grid-like environment. Use the A* search algorithm, which combines features of uniform cost search and heuristic search. Requirements 1. **Grid Representation**: - A 2D list represents the grid where `0` represents a passable cell and `1` represents an obstacle. 2. **A* Search Algorithm**: - Implement the `a_star` function that takes the grid, start position, and target position as inputs and returns the shortest path as a list of coordinates. - The heuristic should use the Manhattan distance. - Consider the edge cases where start or target positions are within obstacles or entirely unreachable. Function Signature ```python def a_star(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` Input and Output Formats - **A* Search**: - **Input**: `grid` (List of List of int), `start` (Tuple of two ints), `target` (Tuple of two ints) - **Output**: List of Tuples of two ints representing the path from start to target Example: ```python grid = [ [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) print(a_star(grid, start, target)) # Output: [(0, 0), (1, 0), (2, 1), (3, 2), (3, 3)] ``` Constraints - Grid dimensions do not exceed 100x100 cells. - Start and target positions are within grid bounds. - Path should be generated efficiently within reasonable time complexity. Performance Requirements - The algorithm should run in O(N log N) where N is the number of nodes in the grid. Example Usage ```python grid = [ [0, 1, 0, 0], [0, 0, 0, 0], [0, 1, 0, 1], [0, 0, 0, 0] ] start = (0, 0) target = (3, 3) print(a_star(grid, start, target)) # Output: [(0, 0), (1, 0), (1, 1), (2, 2), (3, 3)] ``` Implement the A* algorithm considering the given inputs and constraints. Always validate inputs and handle edge cases gracefully.","solution":"from typing import List, Tuple import heapq def a_star(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> List[Tuple[int, int]]: def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def neighbors(node): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = [] for d in directions: neighbor = (node[0] + d[0], node[1] + d[1]) if 0 <= neighbor[0] < len(grid) and 0 <= neighbor[1] < len(grid[0]) and grid[neighbor[0]][neighbor[1]] == 0: result.append(neighbor) return result open_set = [] heapq.heappush(open_set, (0, start)) came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, target)} while open_set: _, current = heapq.heappop(open_set) if current == target: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in neighbors(current): tentative_g_score = g_score[current] + 1 if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, target) if neighbor not in (n for _, n in open_set): heapq.heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Coding Challenge: Optimized Prefix Sum Array Context You are working on a project that requires frequent queries on the sum of elements within a subarray of a large list. To efficiently handle these queries, you decide to implement a **Prefix Sum Array**. Task Write a class `PrefixSum` that efficiently computes the sum of any subarray. The class should include the following methods: - **`__init__(self, nums: List[int])`**: Initializes the prefix sum array given a list of integers. - **`sumRange(self, left: int, right: int) -> int`**: Returns the sum of elements between indices `left` and `right` (inclusive). Method Signatures ```python class PrefixSum: def __init__(self, nums: List[int]): pass def sumRange(self, left: int, right: int) -> int: pass ``` Input * `nums` (List[int]): A list of integers. * `left` (int): The starting index of the subarray. * `right` (int): The ending index of the subarray. Output * Returns the sum of elements from `nums[left]` to `nums[right]`. Constraints * `1 <= len(nums) <= 10^5` * `-10^4 <= nums[i] <= 10^4` * `0 <= left <= right < len(nums)` * Multiple calls to `sumRange` will be made. Performance * Initialization of the prefix sum array should have a time complexity of O(n). * Each call to `sumRange` should have a time complexity of O(1). Example ```python nums = [1, 2, 3, 4, 5] prefix_sum = PrefixSum(nums) print(prefix_sum.sumRange(1, 3)) # Output: 9 print(prefix_sum.sumRange(0, 4)) # Output: 15 ``` Notes * The prefix sum array allows you to answer each sum query in constant time after an initial linear time precomputation. * Consider how you will account for the sum when the left index is 0.","solution":"from typing import List class PrefixSum: def __init__(self, nums: List[int]): self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def sumRange(self, left: int, right: int) -> int: return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"Problem Statement Given a list of integers, you need to create a function that shifts the elements of the list to the right by a given number of times. The shift operation means moving the last element of the list to the beginning while sliding all other elements one position to the right. # Function Signature ```python def shift_right(nums: list, k: int) -> list: pass ``` # Input * `nums` (list): A list of integers where 1 ≤ len(nums) ≤ 1000. * `k` (int): A non-negative integer (0 ≤ k ≤ 1000) representing the number of times the list should be shifted. # Output * (list): The modified list after shifting the elements to the right `k` times. # Constraints * The elements of the list can be positive, negative, or zero. * If `k` is zero, the original list should be returned. # Performance Requirements * Time Complexity should be O(n), where n is the length of the list `nums`. * Space Complexity should be O(1) in terms of auxiliary space (not counting the space required for input/output). # Examples 1. shift_right([1, 2, 3, 4, 5], 0) * Output: `[1, 2, 3, 4, 5]` 2. shift_right([1, 2, 3, 4, 5], 1) * Output: `[5, 1, 2, 3, 4]` 3. shift_right([1, 2, 3, 4, 5], 3) * Output: `[3, 4, 5, 1, 2]` 4. shift_right([1, 2, 3], 4) * Output: `[3, 1, 2]` 5. shift_right([5, -2, 0, 9], 2) * Output: `[0, 9, 5, -2]` # Instructions * Implement the function `shift_right` that meets the above requirements. * Write efficient and clean code. * Do not use any external libraries or functions not built into the language.","solution":"def shift_right(nums: list, k: int) -> list: Shifts the elements of the list to the right by k positions. Parameters: nums (list): A list of integers. k (int): The number of times the list should be shifted to the right. Returns: list: The modified list after shifting the elements to the right k times. # If list is empty or k is 0, no shift is needed if not nums or k == 0: return nums # Use modulo to avoid unnecessary rotations k %= len(nums) # Shift the list to the right by k positions return nums[-k:] + nums[:-k]"},{"question":"# Problem: Longest Increasing Subsequence As a software engineer, you are tasked with implementing an algorithm to find the length of the longest increasing subsequence in a given list of integers. This problem is critical for several real-world applications such as analyzing stock prices or biological sequence comparison. Instructions: 1. **Function Name**: `longest_increasing_subsequence` 2. **Input**: * **sequence** (List[int]): A list of integers. 3. **Output**: * An integer representing the length of the longest increasing subsequence. 4. **Constraints**: * The elements in the input list are not necessarily unique. * The input list can be empty, and in that case, the function should return 0. 5. **Performance Requirement**: * The function should have a time complexity of O(n log n), where n is the length of the input list. * You may assume the input list can contain up to 10^5 elements. You are required to implement the function using dynamic programming along with binary search for efficient performance. ```python from bisect import bisect_left def longest_increasing_subsequence(sequence: list[int]) -> int: if not sequence: return 0 sub = [] for num in sequence: i = bisect_left(sub, num) if i < len(sub): sub[i] = num else: sub.append(num) return len(sub) if __name__ == \\"__main__\\": seq = [10, 9, 2, 5, 3, 7, 101, 18] print(\\"Length of Longest Increasing Subsequence:\\", longest_increasing_subsequence(seq)) # Output should be 4 ``` Scenario: You are developing this function for a large-scale data analysis application where finding patterns and trends is crucial. Ensuring the function runs efficiently on large datasets is key to maintaining overall system performance. **Deliverable**: Provide your complete implementation of the `longest_increasing_subsequence` function. Ensure that your code handles various edge cases, such as an empty input list or sequences with only decreasing or constant values.","solution":"from bisect import bisect_left def longest_increasing_subsequence(sequence: list[int]) -> int: if not sequence: return 0 sub = [] for num in sequence: i = bisect_left(sub, num) if i < len(sub): sub[i] = num else: sub.append(num) return len(sub)"},{"question":"# String Compression Algorithm Design a function that takes a string as input and returns a compressed version of the string, encoded by representing consecutive identical characters by the character followed by the count of repetitions. If the compressed string is not shorter than the original string, the function should return the original string. Function Signature ```python def compress_string(s: str) -> str: pass ``` Input - `s (str)`: A string consisting of alphanumeric characters. Output - `str`: A compressed version of the input string if it results in a shorter length; otherwise, the original string. Constraints - The input string will only contain alphanumeric characters and will have a length of at most 100. Example ```python s1 = \\"aaabbccccdaaa\\" assert compress_string(s1) == \\"a3b2c4d1a3\\" s2 = \\"abcd\\" assert compress_string(s2) == \\"abcd\\" s3 = \\"aabbcc\\" assert compress_string(s3) == \\"aabbcc\\" ``` Explanation 1. The function iterates through the string and counts consecutive identical characters. 2. It constructs the compressed string in the format where a character is followed by its count. 3. It compares the length of the compressed string with the original string. 4. The function returns the compressed string only if it is shorter than the original string; otherwise, it returns the original string. Notes - Ensure the function handles edge cases, such as empty strings or strings with no consecutive repeated characters. - The function should work efficiently within the given constraint of maximum length. - Consider using a loop and a temporary variable to keep track of the current character and its count for compression.","solution":"def compress_string(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Context You are working with a custom implementation of a Min-Heap data structure using an array. The current implementation supports basic heap functionalities but lacks a method to efficiently merge two Min-Heaps while maintaining the heap property. # Task Extend the provided `MinHeap` class to include a method that merges another given Min-Heap into the current Min-Heap. # Requirements 1. Implement the `merge(heap)` method to incorporate all elements from the given `heap` into the current Min-Heap. 2. Ensure that the resulting Min-Heap maintains the heap property. 3. Optimize for time and space efficiency during the merge process. # Input/Output - The `merge(heap)` method takes another instance of the `MinHeap` class and merges it into the current Min-Heap. - The merged Min-Heap should still be a valid Min-Heap after the merge. - You may assume that the `MinHeap` class has methods for inserting elements, extracting the minimum element, and checking the current size of the heap. # Example ```python class MinHeap: def __init__(self): self.heap = [] def insert(self, item): # Implementation of insert to maintain heap property def extract_min(self): # Implementation of extract_min to remove and return the minimum element def size(self): return len(self.heap) def merge(self, heap): # Implementation of merge method # Usage heap1 = MinHeap() heap1.insert(1) heap1.insert(3) heap1.insert(5) heap2 = MinHeap() heap2.insert(2) heap2.insert(4) heap1.merge(heap2) print(heap1.extract_min()) # Output: 1 print(heap1.extract_min()) # Output: 2 print(heap1.extract_min()) # Output: 3 print(heap1.extract_min()) # Output: 4 print(heap1.extract_min()) # Output: 5 ``` # Notes * Focus on efficient insertion and maintenance of the heap structure during the merge. * Consider edge cases such as merging with an empty heap or merging two heaps of significantly different sizes.","solution":"class MinHeap: def __init__(self): self.heap = [] def _parent(self, index): return (index - 1) // 2 def _left_child(self, index): return 2 * index + 1 def _right_child(self, index): return 2 * index + 2 def _heapify_up(self, index): while index > 0: parent = self._parent(index) if self.heap[index] < self.heap[parent]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] index = parent else: break def _heapify_down(self, index): size = len(self.heap) while self._left_child(index) < size: smallest = self._left_child(index) if self._right_child(index) < size and self.heap[self._right_child(index)] < self.heap[smallest]: smallest = self._right_child(index) if self.heap[index] <= self.heap[smallest]: break self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] index = smallest def insert(self, item): self.heap.append(item) self._heapify_up(len(self.heap) - 1) def extract_min(self): if not self.heap: raise IndexError(\\"Extract from an empty heap\\") min_item = self.heap[0] self.heap[0] = self.heap[-1] self.heap.pop() self._heapify_down(0) return min_item def size(self): return len(self.heap) def merge(self, heap): for item in heap.heap: self.insert(item)"},{"question":"# Course Registration System You\'re tasked with developing part of a course registration system for a university. Specifically, you need to design a system that handles adding students to courses, checking for course conflicts, and ensuring no student is overloaded with courses. # Platform Details: - A student is uniquely identified by a `student_id`. - A course is uniquely identified by a `course_id` and spans a specific time slot represented as `(start_time, end_time)` in a 24-hour format. - Each student can enroll in a maximum of `max_courses`. # Functional Requirements: 1. **Registering a student for a course**: You need to check if the student isn\'t already registered for the course, if the course timing conflicts with any existing courses the student is registered for, and that the student will not exceed the maximum allowed courses. 2. **Checking for conflicts**: Ensure that a student doesn’t enroll in courses whose time slots overlap. # Function Definitions: Implement the following functions: 1. **`register_student`**: ```python def register_student(student_id: int, course_id: int, start_time: float, end_time: float) -> bool: Registers a student in a course after performing conflict checks. :param student_id: Unique identifier for a student. :param course_id: Unique identifier for a course. :param start_time: Start time of the course. :param end_time: End time of the course. :return: True if the registration is successful, False otherwise. pass ``` 2. **`is_conflict`**: ```python def is_conflict(student_id: int, start_time: float, end_time: float) -> bool: Checks if the given time slot conflicts with the student\'s existing courses. :param student_id: Unique identifier for a student. :param start_time: Start time of the prospective course. :param end_time: End time of the prospective course. :return: True if there is a conflict, False otherwise. pass ``` # Requirements: 1. **Performance**: * Time complexity of registering a student should scale efficiently with the number of courses. * Handle checking conflicts in constant or logarithmic time where possible. 2. **Edge Cases**: * Handle scenarios with maximum or zero students and courses. * Handle students already registered for the course. * Handle students trying to register for overlapping courses. # Input and Output: * **Input**: * The `register_student` function will take a `student_id`, `course_id`, and the course’s `start_time` and `end_time`. * The `is_conflict` function will take a `student_id`, and the course’s `start_time` and `end_time`. * **Output**: * The `register_student` function should return `True` if registration is successful and `False` otherwise. * The `is_conflict` function should return `True` if there is a conflict and `False` otherwise. # Example: ```python # Register student 123 for course 456 from 9:00 to 10:30 result1 = register_student(123, 456, 9.00, 10.30) # Register the same student for another course within a conflicting time result2 = register_student(123, 789, 10.00, 11.00) # Check for a conflict for the same student conflict = is_conflict(123, 10.00, 11.00) print(result1) # Expected: True (successful registration) print(result2) # Expected: False (time conflict) print(conflict) # Expected: True (there is a time conflict) ``` # Data Structures: - Use a dictionary to store the student records, where the key is `student_id` and the value is a list of tuples representing the courses (`course_id, start_time, end_time`). - Additional dictionaries can be used to track course registrations for further optimization.","solution":"from collections import defaultdict class CourseRegistrationSystem: def __init__(self, max_courses=5): self.student_courses = defaultdict(list) self.max_courses = max_courses def register_student(self, student_id: int, course_id: int, start_time: float, end_time: float) -> bool: Registers a student in a course after performing conflict checks. :param student_id: Unique identifier for a student. :param course_id: Unique identifier for a course. :param start_time: Start time of the course. :param end_time: End time of the course. :return: True if the registration is successful, False otherwise. if any(course_id == r[0] for r in self.student_courses[student_id]): return False # Already registered for this course if self.is_conflict(student_id, start_time, end_time): return False # Time conflict with existing courses if len(self.student_courses[student_id]) >= self.max_courses: return False # Exceeds maximum course limit self.student_courses[student_id].append((course_id, start_time, end_time)) return True def is_conflict(self, student_id: int, start_time: float, end_time: float) -> bool: Checks if the given time slot conflicts with the student\'s existing courses. :param student_id: Unique identifier for a student. :param start_time: Start time of the prospective course. :param end_time: End time of the prospective course. :return: True if there is a conflict, False otherwise. # Check for overlap with already registered courses for _, s, e in self.student_courses[student_id]: if not (end_time <= s or start_time >= e): return True return False"},{"question":"# Coding Assessment Question You are developing a web application that processes and analyzes text data. As part of the text processing pipeline, one of the tasks is to implement a custom tokenizer that breaks down a given text into individual tokens based on specific criteria. The tokenizer should: 1. Split the text into tokens by spaces and punctuation marks (.,!?). 2. Convert all characters to lowercase. 3. Remove any tokens that are purely numeric. 4. Remove empty tokens. Task Write a Python function `custom_tokenizer` that takes a string and returns a list of tokens based on the above criteria. Example ```python def custom_tokenizer(text): # Implement custom tokenizer here pass # Example usage: input_text = \\"Hello, World! It\'s 2023. Can you tokenize this text?\\" output_tokens = custom_tokenizer(input_text) print(output_tokens) # Expected: [\'hello\', \'world\', \'it\', \'s\', \'can\', \'you\', \'tokenize\', \'this\', \'text\'] ``` Constraints - You must not use any external libraries except for Python\'s standard library. - The implementation should be efficient enough to handle input text with up to 10^6 characters. Performance Requirement - The function should execute in linear time relative to the size of the input text.","solution":"import string def custom_tokenizer(text): Custom tokenizer that splits text into tokens, converts to lowercase, removes purely numeric tokens and empty tokens. # Punctuation characters to be used as delimiters delimiters = string.punctuation + \' \' # Replace punctuation characters with space for delimiter in delimiters: text = text.replace(delimiter, \' \') # Convert all characters to lowercase text = text.lower() # Split text into tokens by spaces tokens = text.split() # Remove purely numeric tokens and empty tokens tokens = [token for token in tokens if not token.isnumeric()] return tokens"},{"question":"# Coding Assessment Question: Scenario: You are developing a video game in which characters can collect various power-ups scattered throughout different levels. Each power-up has a rarity, influencing its likelihood of appearing. You want to determine the average number of collected power-ups of each rarity after a player completes a specified number of levels. The rarities are ranked from common to legendary, with common being the most frequent and legendary being the least frequent. Your task is to implement a function that will calculate this average based on the distribution of power-ups and their rarities across the levels. # Function Signature: ```python def average_powerups_per_rarity(levels: int, powerups_per_level: int, rarities_distribution: List[Tuple[int, float]]) -> List[float]: pass ``` # Input: * `levels` (int): The number of levels the player completes. * `powerups_per_level` (int): The number of power-ups available in each level. * `rarities_distribution` (List[Tuple[int, float]]): A list of tuples where each tuple contains two values: * The first value `int` represents the rarity level (with lower integers being more common). * The second value `float` represents the probability of encountering a power-up of this rarity in a single level. # Output: * A list of floats where each element represents the average number of power-ups collected for each rarity, in the same order as provided in the input list. Each float should be formatted to six decimal places. # Example: ```python assert average_powerups_per_rarity(10, 5, [(0, 0.6), (1, 0.3), (2, 0.1)]) == [30.000000, 15.000000, 5.000000] ``` # Constraints: * `1 <= levels <= 1000` * `1 <= powerups_per_level <= 50` * `1 <= len(rarities_distribution) <= 10` * `0 <= probability <= 1` for each rarity * The sum of probabilities for all rarities in a single list will always be 1. # Performance Requirements: * Ensure your solution can efficiently handle up to 1000 levels and a combined total of up to 50000 power-ups with varying rarities. Implementation: Write the function `average_powerups_per_rarity` that calculates and returns the average number of collected power-ups for each rarity to six decimal places based on the given number of levels, power-ups per level, and rarities distribution.","solution":"from typing import List, Tuple def average_powerups_per_rarity(levels: int, powerups_per_level: int, rarities_distribution: List[Tuple[int, float]]) -> List[float]: result = [] total_powerups = levels * powerups_per_level for rarity, probability in rarities_distribution: average_count = total_powerups * probability result.append(round(average_count, 6)) return result"},{"question":"# Coding Question Context One fundamental concept in physics is the kinematic equation for uniformly accelerated motion, which describes the position of an object moving with constant acceleration. The equation is expressed as follows: [ s = ut + frac{1}{2}at^2 ] where: - ( s ) is the displacement of the object. - ( u ) is the initial velocity of the object. - ( a ) is the constant acceleration. - ( t ) is the time duration of the motion. Given three of these parameters, you can compute the fourth one. Tasks 1. Implement a function `compute_displacement` to calculate the displacement of an object given the initial velocity, acceleration, and time. 2. Implement a function `compute_initial_velocity` to calculate the initial velocity given the displacement, acceleration, and time. 3. Implement a function `compute_time` to calculate the time duration of the motion given the displacement, initial velocity, and acceleration. # Function Signatures ```python def compute_displacement(initial_velocity: float, acceleration: float, time: float) -> float: # your code here def compute_initial_velocity(displacement: float, acceleration: float, time: float) -> float: # your code here def compute_time(displacement: float, initial_velocity: float, acceleration: float) -> float: # your code here ``` # Requirements - If the time duration (( t )) is zero, raise a `ValueError` with the message: \\"Invalid input. Time duration must be non-zero.\\" - The function should handle both positive and negative values for initial velocity, acceleration, and displacement, as these can occur in different kinematic scenarios. # Constraints - Values provided for time, initial velocity, acceleration, and displacement must follow realistic physical constraints. - Ensure your functions handle edge cases appropriately and provide correct exception handling as specified. # Example Usage ```python # Test cases for displacement computation compute_displacement(10, 2, 5) # should return 75.0 # Test cases for initial velocity computation compute_initial_velocity(75, 2, 5) # should return 10.0 # Test cases for time computation compute_time(75, 10, 2) # should return 5.0 ``` Ensure your functions correctly handle edge cases and provide accurate results according to the kinematic equation.","solution":"def compute_displacement(initial_velocity: float, acceleration: float, time: float) -> float: if time == 0: raise ValueError(\\"Invalid input. Time duration must be non-zero.\\") return initial_velocity * time + 0.5 * acceleration * time**2 def compute_initial_velocity(displacement: float, acceleration: float, time: float) -> float: if time == 0: raise ValueError(\\"Invalid input. Time duration must be non-zero.\\") return (displacement - 0.5 * acceleration * time**2) / time def compute_time(displacement: float, initial_velocity: float, acceleration: float) -> float: if acceleration == 0: raise ValueError(\\"Invalid input. Acceleration must be non-zero.\\") discriminant = initial_velocity**2 + 2 * acceleration * displacement if discriminant < 0: raise ValueError(\\"Invalid input. No real time solution.\\") t1 = (-initial_velocity + discriminant**0.5) / acceleration t2 = (-initial_velocity - discriminant**0.5) / acceleration if t1 >= 0 and t2 >= 0: return min(t1, t2) elif t1 >= 0: return t1 elif t2 >= 0: return t2 else: raise ValueError(\\"Invalid input. No positive time solution.\\")"},{"question":"# Coding Assessment Question: Implementing a Basic Binary Search Tree **Scenario:** You\'re working on a project that requires efficient data retrieval and insertion. A Binary Search Tree (BST) is a good fit for this purpose due to its average-case time complexities for insertion, deletion, and lookup being logarithmic in nature. You are tasked with creating a BST from scratch with basic functionalities. **Problem Statement:** Write a `BinarySearchTree` class that supports insertion of values, searching for values, and finding the minimum value in the tree. **Class Definition:** ```python class BinarySearchTree: def __init__(self): self.root = None class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key: int): Insert a new node with the given key in the BST. :param key: An integer key to insert into the BST. if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return self.Node(key) else: if root.val < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def search(self, key: int) -> bool: Search for a node with the given key in the BST. :param key: An integer key to search for in the BST. :return: True if found, False otherwise. return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if root.val < key: return self._search(root.right, key) return self._search(root.left, key) def find_minimum(self) -> int: Find the minimum value in the BST. :return: The minimum integer value in the BST. current = self.root while current.left is not None: current = current.left return current.val ``` **Constraints:** - The key values will be valid integers. - All function signatures must remain unchanged. **Examples:** ```python # Create a BST bst = BinarySearchTree() # Insert values bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(1) # Search for values assert bst.search(3) == True assert bst.search(6) == False # Find minimum value assert bst.find_minimum() == 1 ``` **Note:** - This is a basic implementation meant to test the fundamental understanding of BSTs. - Make sure to handle edge cases like searching in an empty tree or inserting duplicate values (you can assume no duplicates will be inserted in this challenge). - Your implementation should cover standard BST operations and be efficient in terms of time complexity.","solution":"class BinarySearchTree: def __init__(self): self.root = None class Node: def __init__(self, key): self.left = None self.right = None self.val = key def insert(self, key: int): Insert a new node with the given key in the BST. :param key: An integer key to insert into the BST. if self.root is None: self.root = self.Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if root is None: return self.Node(key) else: if root.val < key: root.right = self._insert(root.right, key) else: root.left = self._insert(root.left, key) return root def search(self, key: int) -> bool: Search for a node with the given key in the BST. :param key: An integer key to search for in the BST. :return: True if found, False otherwise. return self._search(self.root, key) def _search(self, root, key): if root is None or root.val == key: return root is not None if root.val < key: return self._search(root.right, key) return self._search(root.left, key) def find_minimum(self) -> int: Find the minimum value in the BST. :return: The minimum integer value in the BST. current = self.root if current is None: raise ValueError(\\"The tree is empty\\") while current.left is not None: current = current.left return current.val"},{"question":"# Context You are building a system to resolve domain names through a simplified DNS server simulation. Each domain may have multiple associated IP addresses. # Description Implement a function that resolves a list of domain names into their corresponding IP addresses based on a pre-defined mapping. Return the results in the same order as the input list. # Function Signature ```python def resolve_domains(domains: List[str], dns_map: Dict[str, List[str]]) -> List[List[str]]: pass ``` # Input * `domains` (List[str]): A list of domain names to resolve. Each domain name is a non-empty string. * `dns_map` (Dict[str, List[str]]): A dictionary where each key is a domain name and each value is a list of associated IP addresses. # Output * `results` (List[List[str]]): A list of lists. Each sublist contains the resolved IP addresses for the corresponding domain in the input list. # Constraints * If a domain name does not exist in the DNS map, return an empty list for that domain\'s IP addresses. * Assume all domain names and IP addresses in the input are valid and properly formatted. * The input list `domains` can contain between 1 and 1000 domain names. * Each list of IP addresses in the `dns_map` can contain between 1 and 10 IP addresses. # Example ```python domains = [\\"example.com\\", \\"nonexistent.org\\", \\"anotherexample.com\\"] dns_map = { \\"example.com\\": [\\"93.184.216.34\\"], \\"anotherexample.com\\": [\\"192.0.2.1\\", \\"192.0.2.2\\"] } result = resolve_domains(domains, dns_map) # `result` should be [[\\"93.184.216.34\\"], [], [\\"192.0.2.1\\", \\"192.0.2.2\\"]] ``` # Notes * The order of the IP addresses for a domain in the output should follow their order in the `dns_map`. * Ensure efficient lookups for resolving domain names even with the maximum constraints.","solution":"from typing import List, Dict def resolve_domains(domains: List[str], dns_map: Dict[str, List[str]]) -> List[List[str]]: Resolves a list of domain names into their corresponding IP addresses based on a pre-defined mapping. :param domains: List of domain names to resolve. :param dns_map: Dictionary where each key is a domain name and each value is a list of associated IP addresses. :return: A list of lists where each list contains the resolved IP addresses for the corresponding domain. return [dns_map.get(domain, []) for domain in domains]"},{"question":"# Heap Sort Algorithm Implementation Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to create a sorted array. The algorithm partitions the input array into a sorted and an unsorted region and iteratively shrinks the unsorted region by extracting the largest element and moving it to the sorted region. # Objective: Implement the Heap Sort algorithm to sort an array of integers in ascending order. # Context: Imagine you are developing a sorting module that requires an efficient and reliable sorting algorithm. Given an unsorted array, your task is to implement the Heap Sort algorithm to sort the array. # Function Signature: ```python def heap_sort(arr: List[int]) -> List[int]: pass ``` # Input: - `arr`: A list of integers (List[int]). # Output: - Returns a new list of integers sorted in ascending order. # Constraints: - You must implement the Heap Sort algorithm. - Heapify the input list during the process. - The input list can contain up to 10^4 integers. - Integers in the list can range from -10^5 to 10^5. # Performance Requirements: - The sorting operation must run in O(n log n) time complexity. - Minimize the use of additional memory (use in-place modifications where applicable). # Scenario: ```python # Example test cases: print(heap_sort([10, 7, 15, 4, 2, 9])) # [2, 4, 7, 9, 10, 15] print(heap_sort([20, -10, 0, 5, 8, 1])) # [-10, 0, 1, 5, 8, 20] ``` # Hints: 1. Implement helper functions to heapify a subtree and to build a max-heap. 2. Remember to repeatedly extract the maximum element and move it to the end of the array.","solution":"from typing import List def heapify(arr: List[int], n: int, i: int): largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[largest] < arr[left]: largest = left # See if right child of root exists and is greater than the largest so far if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) def heap_sort(arr: List[int]) -> List[int]: n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) return arr"},{"question":"# Binary Tree Path Sum **Scenario**: You are working with a binary tree data structure and are tasked with finding paths within the tree that sum to a given value. The purpose is to write a function that identifies all paths from the root node to any leaf node where the sum of the node values equals a target sum. **Requirements**: 1. **Function to Find Paths**: Write a function `find_paths(root: Optional[TreeNode], target_sum: int) -> List[List[int]]`: - **Input**: - `root`: The root node of the binary tree (or `None` if the tree is empty). - `target_sum`: An integer `target_sum` representing the sum you want to find along any path from root to leaf. - **Output**: A list of lists, where each inner list contains the node values of a path that adds up to `target_sum`. 2. **TreeNode Class**: Define a class `TreeNode` to represent nodes in the binary tree: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 3. **Handling Edge Cases**: Ensure the solution properly handles: - An empty tree (where `root` is `None`). - The presence of negative values in the tree. - Multiple valid paths that sum to the target value. - No valid paths that sum to the target value. 4. **Performance Constraints**: Ensure the solution can handle large binary trees with up to 10,000 nodes. **Example**: Given the following binary tree represented in Python: ```python root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) ``` And a `target_sum` of 22, the function `find_paths(root, 22)` should return: ``` [ [5, 4, 11, 2], [5, 8, 4, 5] ] ``` Explanation: - The first path `5 -> 4 -> 11 -> 2` has a sum of 22. - The second path `5 -> 8 -> 4 -> 5` has a sum of 22. - No other paths sum to the target value 22.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_paths(root: Optional[TreeNode], target_sum: int) -> List[List[int]]: def helper(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target_sum: paths.append(list(current_path)) else: helper(node.left, current_path, current_sum) helper(node.right, current_path, current_sum) current_path.pop() paths = [] helper(root, [], 0) return paths"},{"question":"# Implement a Function to Remove Consecutive Duplicates Write a function called `remove_consecutive_duplicates` that takes a linked list and removes all consecutive duplicate elements. The order of the remaining elements should not be changed. # Function Signature ```python def remove_consecutive_duplicates(linked_list: LinkedList) -> None: ``` # Parameters and Constraints - `linked_list` is an instance of `LinkedList`. - You cannot use any Python built-in data structures like `list`, `deque` from `collections`, etc. - The function should modify `linked_list` to contain only unique elements from any consecutive duplicates. - The function should run in O(n) time where n is the number of elements in the linked list. # Example ```python ll = LinkedList() ll.add_last(1) ll.add_last(1) ll.add_last(2) ll.add_last(3) ll.add_last(3) ll.add_last(3) ll.add_last(4) ll.add_last(4) ll.add_last(5) remove_consecutive_duplicates(ll) assert len(ll) == 5 assert ll.remove_first() == 1 assert ll.remove_first() == 2 assert ll.remove_first() == 3 assert ll.remove_first() == 4 assert ll.remove_first() == 5 assert ll.is_empty() ``` # Additional Notes - Ensure that the order of the elements in the linked list remains the same after removal of consecutive duplicates. - Consider edge cases like an empty list or a list with only one element.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None self.tail = None self.size = 0 def add_last(self, value): new_node = Node(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node self.tail = new_node self.size += 1 def remove_first(self): if not self.head: return None value = self.head.value self.head = self.head.next self.size -= 1 if not self.head: self.tail = None return value def is_empty(self): return self.size == 0 def __len__(self): return self.size def to_list(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result def remove_consecutive_duplicates(linked_list: LinkedList) -> None: if linked_list.is_empty() or linked_list.head.next is None: return current = linked_list.head while current and current.next: if current.value == current.next.value: current.next = current.next.next linked_list.size -= 1 else: current = current.next if current and current.next is None: linked_list.tail = current"},{"question":"New Question # Question: Validate Subsequence in List Background A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, `[3, 4, 7]` is a subsequence of `[1, 2, 3, 4, 5, 6, 7]`, but `[3, 7, 4]` is not, because the order is changed. Task Your task is to implement a function that checks if a sequence is a subsequence of another sequence. The function should validate various data integrity conditions and provide meaningful output in invalid scenarios. # Function Signature ```python def is_valid_subsequence( main_seq: list[int] | tuple[int], sub_seq: list[int] | tuple[int] ) -> bool: Determines if a subsequence is valid within another sequence. Parameters: - main_seq (list[int] | tuple[int]): A sequence of integers. - sub_seq (list[int] | tuple[int]): A sequence of integers which is to be checked as a subsequence. Returns: - bool: True if sub_seq is a valid subsequence of main_seq, False otherwise. ``` # Input Constraints - `main_seq` and `sub_seq` must both be either lists or tuples of integers. - If `sub_seq` is larger than `main_seq`, the function should return `False`. - If `main_seq` or `sub_seq` is empty, the function should return `False`. - If mixed types are provided (e.g., `main_seq` is a list and `sub_seq` is a tuple), raise a `TypeError`. # Output - Return `True` if `sub_seq` is a valid subsequence of `main_seq`. - Return `False` otherwise. - If the inputs are invalid, raise a `TypeError` with an appropriate message. # Examples ```python # Subsequence is valid main_seq = [5, 1, 22, 25, 6, -1, 8, 10] sub_seq = [1, 6, -1, 10] print(is_valid_subsequence(main_seq, sub_seq)) # Expected output: True # Subsequence is not valid sub_seq = [1, 6, -1, 11] print(is_valid_subsequence(main_seq, sub_seq)) # Expected output: False # Main sequence is empty main_seq = [] sub_seq = [1, 6, -1, 10] print(is_valid_subsequence(main_seq, sub_seq)) # Expected output: False # Subsequence is empty main_seq = [5, 1, 22, 25, 6, -1, 8, 10] sub_seq = [] print(is_valid_subsequence(main_seq, sub_seq)) # Expected output: False # Subsequence is larger than main sequence main_seq = [5, 1, 22, 25] sub_seq = [5, 1, 22, 25, 6] print(is_valid_subsequence(main_seq, sub_seq)) # Expected output: False # Mixed types: Should raise TypeError main_seq = [5, 1, 22, 25, 6, -1, 8, 10] sub_seq = (1, 6, -1, 10) print(is_valid_subsequence(main_seq, sub_seq)) # Expected outcome: TypeError ```","solution":"def is_valid_subsequence(main_seq, sub_seq): Determines if a subsequence is valid within another sequence. Parameters: - main_seq (list[int] | tuple[int]): A sequence of integers. - sub_seq (list[int] | tuple[int]): A sequence of integers which is to be checked as a subsequence. Returns: - bool: True if sub_seq is a valid subsequence of main_seq, False otherwise. if not isinstance(main_seq, (list, tuple)) or not isinstance(sub_seq, (list, tuple)): raise TypeError(\\"Both main_seq and sub_seq must be of type list or tuple.\\") if len(main_seq) == 0 or len(sub_seq) == 0: return False if len(sub_seq) > len(main_seq): return False if type(main_seq) != type(sub_seq): raise TypeError(\\"Both main_seq and sub_seq must be of the same type.\\") main_index = 0 sub_index = 0 while main_index < len(main_seq) and sub_index < len(sub_seq): if main_seq[main_index] == sub_seq[sub_index]: sub_index += 1 main_index += 1 return sub_index == len(sub_seq)"},{"question":"# Query Depth Calculation in a Binary Tree Given a binary tree, write a function `depth_of_query(root, node)` which calculates and returns the depth of a given node in the binary tree. The depth of the root node is 0. If the node does not exist in the tree, the function should return -1. Function Signature ```python def depth_of_query(root: Optional[TreeNode], node: int) -> int: ``` # Definitions and Assumptions - `TreeNode` is a class representing a node in the binary tree with the following structure: ```python class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right ``` - `root`: A `TreeNode` which is the root of the binary tree. - `node (int)`: An integer representing the value of the node we need to find the depth of. # Constraints - The binary tree can have up to 10,000 nodes. - Node values are unique. - The tree structure and node values must be managed efficiently to perform depths queries in a reasonable time frame. # Output - `int`: The depth of the given node, or -1 if the node does not exist in the tree. # Example Given a binary tree: ``` 3 / 9 20 / 15 7 ``` ```python root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(depth_of_query(root, 7)) # Output: 2 print(depth_of_query(root, 10)) # Output: -1 print(depth_of_query(root, 3)) # Output: 0 ``` Note: Provide an efficient implementation that traverses the tree properly considering the constraints on the number of nodes. # Analysis Guidelines - Implement a breadth-first search (BFS) or depth-first search (DFS) to traverse the binary tree. - Take care to handle edge cases where the node does not exist. - Ensure the function is optimized for performance with the given constraints.","solution":"from typing import Optional class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def depth_of_query(root: Optional[TreeNode], node: int) -> int: Returns the depth of the given node in the binary tree. If the node does not exist, return -1. if not root: return -1 def dfs(current, depth): if not current: return -1 if current.value == node: return depth left_depth = dfs(current.left, depth + 1) if left_depth != -1: return left_depth return dfs(current.right, depth + 1) return dfs(root, 0)"},{"question":"Problem Statement A prominent educational platform requires an efficient method to rank the performance of its students based on a series of test scores. You need to implement a Python class that can dynamically calculate and store the ranking of students as new scores are added. # Function Signature: ```python class StudentRanking: def __init__(self) -> None: # Initialization code def add_score(self, student_id: int, score: int) -> None: Add a new score for a student. Args: student_id (int): The identifier of the student. score (int): The test score to be added. def get_ranking(self) -> list: Get the current ranking of students. Returns: list: A list of tuples containing student_id and the total score, sorted by total score in descending order. ``` # Input - `add_score` method: - `student_id (int)`: A unique identifier for each student. - `score (int)`: An integer value representing the score that the student has received. This will always be a non-negative integer. - `get_ranking` method: - No input arguments. # Output - `add_score` method: - It does not return any value. - `get_ranking` method: - A list of tuples, where each tuple contains two integers: (student_id, total_score). The list should be sorted by `total_score` in descending order. If two students have the same total score, they should be listed in ascending order of their `student_id`. # Constraints - The number of students will not exceed 1000. - Each student will have at most 100 scores. - The score value will always be non-negative. # Example ```python # Creating an instance of the StudentRanking class ranking = StudentRanking() # Adding scores for students ranking.add_score(1, 100) ranking.add_score(2, 150) ranking.add_score(1, 50) ranking.add_score(3, 200) # Getting the current ranking of students print(ranking.get_ranking()) # Output: [(3, 200), (2, 150), (1, 150)] # Adding another score for a student ranking.add_score(2, 100) # Getting the updated ranking of students print(ranking.get_ranking()) # Output: [(2, 250), (3, 200), (1, 150)] ``` # Additional Notes - Make sure your implementation efficiently recalculates and updates ranks as new scores are added. - Consider using appropriate data structures to manage and retrieve the rankings quickly.","solution":"class StudentRanking: def __init__(self) -> None: self.scores = {} def add_score(self, student_id: int, score: int) -> None: if student_id in self.scores: self.scores[student_id] += score else: self.scores[student_id] = score def get_ranking(self) -> list: return sorted(self.scores.items(), key=lambda x: (-x[1], x[0]))"},{"question":"# Scenario You are tasked with building a custom lightweight logging system for an application. The application requires logging messages at different levels (INFO, WARNING, ERROR) and should be able to filter logged messages based on the current logging level setting. Each log message should be timestamped. # Task Implement a class `Logger` that manages logging messages at different levels and can filter messages based on the current logging level. The class should support logging `INFO`, `WARNING`, and `ERROR` messages. # Class Definition ```python class Logger: def __init__(self, level: str = \\"INFO\\"): Initializes the Logger with a specified logging level (\\"INFO\\", \\"WARNING\\", \\"ERROR\\"). def log_info(self, message: str): Logs an informational message with the level INFO. def log_warning(self, message: str): Logs a warning message with the level WARNING. def log_error(self, message: str): Logs an error message with the level ERROR. def set_level(self, level: str): Sets the logging level (INFO, WARNING, ERROR). def get_logs(self): Returns a list of all logged messages that meet or exceed the current logging level, each prefixed with its level and timestamp. ``` # Input - Various method calls as described above. # Output - The `get_logs` method returns a list of strings, each representing a logged message that meets or exceeds the current logging level. Each message should be formatted to include the level and timestamp. # Constraints - Logged messages will be processed in the order they are received. - The logging level can only be \\"INFO\\", \\"WARNING\\", or \\"ERROR\\". - Timestamps should be in the format `YYYY-MM-DD HH:MM:SS`. # Example ```python import time logger = Logger() logger.log_info(\\"Application started\\") time.sleep(1) logger.log_warning(\\"Low disk space\\") time.sleep(1) logger.log_error(\\"Unhandled exception\\") time.sleep(1) # Set logging level to WARNING logger.set_level(\\"WARNING\\") logger.log_info(\\"User login success\\") time.sleep(1) logs = logger.get_logs() # Assuming the current date is 2023-10-29 assert logs == [ \\"2023-10-29 12:00:00 [INFO] Application started\\", \\"2023-10-29 12:00:01 [WARNING] Low disk space\\", \\"2023-10-29 12:00:02 [ERROR] Unhandled exception\\", \\"2023-10-29 12:00:03 [WARNING] Low disk space\\", \\"2023-10-29 12:00:04 [ERROR] Unhandled exception\\" ] ``` # Notes - Use the `datetime` module to generate timestamps. - Ensure proper error handling for invalid logging levels. - Do not use any external libraries for logging functionality. - Assume the `time` module for sleep calls in examples to induce real time differences. This question ensures the candidate demonstrates the ability to work with classes, method encapsulation, and timestamp management, while also handling string operations and list manipulations in Python.","solution":"from datetime import datetime class Logger: def __init__(self, level: str = \\"INFO\\"): self.level = level self.logs = [] self.levels = {\\"INFO\\": 1, \\"WARNING\\": 2, \\"ERROR\\": 3} def log_info(self, message: str): self._log(\\"INFO\\", message) def log_warning(self, message: str): self._log(\\"WARNING\\", message) def log_error(self, message: str): self._log(\\"ERROR\\", message) def set_level(self, level: str): if level in self.levels: self.level = level else: raise ValueError(\\"Invalid logging level\\") def get_logs(self): current_level_num = self.levels[self.level] filtered_logs = [log for log in self.logs if self.levels[log[\'level\']] >= current_level_num] return [self._format_log(log) for log in filtered_logs] def _log(self, level: str, message: str): timestamp = datetime.now().strftime(\\"%Y-%m-%d %H:%M:%S\\") self.logs.append({\\"level\\": level, \\"message\\": message, \\"timestamp\\": timestamp}) def _format_log(self, log): return f\\"{log[\'timestamp\']} [{log[\'level\']}] {log[\'message\']}\\""},{"question":"# Scenario A logistics company needs to implement an efficient routing algorithm for its delivery trucks. The algorithm should find the shortest path between a set of delivery points to ensure timely deliveries. The company uses a grid map where each cell represents a location, and trucks can move up, down, left, or right, but not diagonally. Some cells are obstacles, and trucks cannot move through them. # Task Implement the Breadth-First Search (BFS) algorithm to find the shortest path from a starting point to a destination on the grid. If no path exists, return an empty list. Write the solution using an iterative approach. # Input - A 2D list `grid` representing the map, where `0` is a passable cell and `1` is an obstacle. - A tuple `start` representing the starting cell\'s coordinates. - A tuple `destination` representing the destination cell\'s coordinates. # Output - A list of tuples representing the path from `start` to `destination`. Each tuple is a cell\'s coordinates. If no path exists, return an empty list. # Function Signature ```python from typing import List, Tuple def shortest_path_bfs(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]: pass ``` # Example ```python # Examples grid = [ [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) destination = (4, 4) print(shortest_path_bfs(grid, start, destination)) # Output: [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 3), (2, 4), (3, 4), (4, 4)] start = (0, 0) destination = (3, 3) print(shortest_path_bfs(grid, start, destination)) # Output: [] grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] start = (0, 0) destination = (2, 2) print(shortest_path_bfs(grid, start, destination)) # Output: [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] # Complex example grid = [[0] * 50 for _ in range(50)] grid[25][25] = 1 start = (0, 0) destination = (49, 49) print(shortest_path_bfs(grid, start, destination)) # Output: Path exists in large grid example ``` # Constraints - `grid` can be up to 100x100 cells. - The function must efficiently handle edge cases and large grid sizes. - Maintain clarity in BFS implementation to ensure code readability and correctness.","solution":"from typing import List, Tuple from collections import deque def shortest_path_bfs(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> List[Tuple[int, int]]: rows, cols = len(grid), len(grid[0]) adj_directions = [(-1,0), (1,0), (0,-1), (0,1)] # up, down, left, right if grid[start[0]][start[1]] == 1 or grid[destination[0]][destination[1]] == 1: return [] q = deque([(start, [start])]) visited = set() visited.add(start) while q: (current, path) = q.popleft() if current == destination: return path for d in adj_directions: new_row, new_col = current[0] + d[0], current[1] + d[1] if 0 <= new_row < rows and 0 <= new_col < cols and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: new_path = path + [(new_row, new_col)] q.append(((new_row, new_col), new_path)) visited.add((new_row, new_col)) return []"},{"question":"# Problem Statement You are given a matrix of integers where each row is sorted in ascending order and you need to find the k-th smallest element in the matrix. Implement the `kth_smallest_in_matrix` function using a min-heap to achieve this. Function Signature ```python def kth_smallest_in_matrix(matrix: list, k: int) -> int: pass ``` Input * `matrix` (list of list of int): A matrix where each row is sorted in ascending order, 0 < len(matrix), len(matrix[0]) <= 300. * `k` (int): The rank (1 ≤ k ≤ len(matrix) * len(matrix[0])) indicating the k-th smallest element to find. Output * `int`: The k-th smallest element in the matrix. Constraints * Ensure that the function handles matrices of varying sizes efficiently. * Utilize a min-heap to find the k-th smallest element. Performance Requirements * The solution should run in approximately O(n log k) time complexity, where n is the total number of elements in the matrix. * Space complexity should be O(k). Scenario Consider a matrix of student exam scores from different classes where each row represents scores from one class in ascending order. Using your function, you should be able to efficiently determine the k-th smallest score combined from all the classes. Example ```python # Example 1 matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] k = 8 # Explanation: The sorted list of all elements is [1, 5, 9, 10, 11, 12, 13, 13, 15], and the 8th smallest element is 13. assert kth_smallest_in_matrix(matrix, k) == 13 # Example 2 matrix = [ [1, 2], [1, 3] ] k = 2 # Explanation: The sorted list of all elements is [1, 1, 2, 3], and the 2nd smallest element is 1. assert kth_smallest_in_matrix(matrix, k) == 1 ``` Notes * You may utilize Python\'s `heapq` library to simplify the implementation of the min-heap. * Ensure the solution handles edge cases such as matrices with a single row, a single column, or only one element.","solution":"import heapq def kth_smallest_in_matrix(matrix: list, k: int) -> int: Returns the k-th smallest element in a matrix where each row is sorted in ascending order. n = len(matrix) min_heap = [] # Initialize the heap with the first element of each row for r in range(min(n, k)): # We only need to consider at most `k` rows heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Pop and push the smallest elements from the heap, k times for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Question: Implement Custom Sorting and Filtering Functionality for a List of Objects Context: In many real-world applications, you need to handle a collection of objects with specific attributes. This exercise tests your ability to implement advanced sorting and filtering mechanisms for a list of objects based on multiple criteria. Task: Develop a `CustomObjectList` class that provides advanced functionalities to manage a list of objects. Each object in the list will have the following attributes: `name` (str), `value` (int), and `category` (str). Requirements: 1. **Multi-Criteria Sorting**: Implement a method `multi_sort(keys: List[str], descending: bool=False) -> List[CustomObject]` that sorts the list of objects based on one or more attribute keys. - `keys` is a list of attribute names (`name`, `value`, or `category`) to sort by, in order of priority. - `descending` is a boolean flag to sort in descending order. 2. **Filtering by Attribute**: Implement a method `filter_by_attribute(attribute: str, value: Union[int, str]) -> List[CustomObject]` that filters the list based on a single attribute and its value. - The method should return a list of objects where the specified attribute matches the provided value. 3. **Composite Filtering**: Implement a method `composite_filter(criteria: Dict[str, Union[int, str]]) -> List[CustomObject]` that filters the list based on multiple criteria. - `criteria` is a dictionary where keys are attribute names and values are the required values for filtering. - The method should return a list of objects matching all specified criteria. Implementations: - Define a `CustomObject` class with the aforementioned attributes. - Update the `CustomObjectList` class to include your new methods. - Add doctests or unit tests to validate the functionality of the new methods. - Ensure the methods handle edge cases, such as empty lists or non-existing attributes/values, gracefully. Constraints: - The `keys` list for `multi_sort` should contain valid attribute names. - The `attribute` for `filter_by_attribute` should be a valid attribute name. - The `criteria` dictionary for `composite_filter` should contain valid attribute names and corresponding values. Here is the starter skeleton for your classes: ```python from typing import List, Dict, Union class CustomObject: def __init__(self, name: str, value: int, category: str): self.name = name self.value = value self.category = category def __repr__(self): return f\\"CustomObject(name=\'{self.name}\', value={self.value}, category=\'{self.category}\')\\" class CustomObjectList: def __init__(self, objects: List[CustomObject] = []): self.objects = objects def multi_sort(self, keys: List[str], descending: bool=False) -> List[CustomObject]: Sort the list of objects based on multiple criteria. Args: keys: List of attribute names to sort by. descending: Boolean flag for sorting order. Returns: Sorted list of CustomObject instances. Example: >>> obj1 = CustomObject(\\"A\\", 10, \\"X\\") >>> obj2 = CustomObject(\\"B\\", 15, \\"Y\\") >>> obj3 = CustomObject(\\"C\\", 10, \\"Z\\") >>> obj_list = CustomObjectList([obj1, obj2, obj3]) >>> obj_list.multi_sort([\\"value\\", \\"name\\"], descending=True) [CustomObject(name=\'B\', value=15, category=\'Y\'), CustomObject(name=\'C\', value=10, category=\'Z\'), CustomObject(name=\'A\', value=10, category=\'X\')] pass def filter_by_attribute(self, attribute: str, value: Union[int, str]) -> List[CustomObject]: Filter the list based on a single attribute and its value. Args: attribute: The attribute name to filter by. value: The value to match for the specified attribute. Returns: Filtered list of CustomObject instances. Example: >>> obj1 = CustomObject(\\"A\\", 10, \\"X\\") >>> obj2 = CustomObject(\\"B\\", 15, \\"Y\\") >>> obj3 = CustomObject(\\"C\\", 10, \\"Z\\") >>> obj_list = CustomObjectList([obj1, obj2, obj3]) >>> obj_list.filter_by_attribute(\\"value\\", 10) [CustomObject(name=\'A\', value=10, category=\'X\'), CustomObject(name=\'C\', value=10, category=\'Z\')] pass def composite_filter(self, criteria: Dict[str, Union[int, str]]) -> List[CustomObject]: Filter the list based on multiple criteria. Args: criteria: Dictionary of attribute names and values to filter by. Returns: Filtered list of CustomObject instances matching all criteria. Example: >>> obj1 = CustomObject(\\"A\\", 10, \\"X\\") >>> obj2 = CustomObject(\\"B\\", 15, \\"Y\\") >>> obj3 = CustomObject(\\"C\\", 10, \\"Z\\") >>> obj_list = CustomObjectList([obj1, obj2, obj3]) >>> obj_list.composite_filter({\\"value\\": 10, \\"category\\": \\"X\\"}) [CustomObject(name=\'A\', value=10, category=\'X\')] pass ``` Input and Output Format: - The `multi_sort` method takes a list of attribute names and an optional boolean flag; it returns a sorted list of `CustomObject` instances. - The `filter_by_attribute` method takes an attribute name and a value; it returns a filtered list of `CustomObject` instances. - The `composite_filter` method takes a criteria dictionary; it returns a filtered list of `CustomObject` instances. Constraints: - Your solution should maintain the computational efficiency of sorting and filtering operations. - The extended functionalities should be demonstrable with appropriate unit tests or doctests. Good luck!","solution":"from typing import List, Dict, Union class CustomObject: def __init__(self, name: str, value: int, category: str): self.name = name self.value = value self.category = category def __repr__(self): return f\\"CustomObject(name=\'{self.name}\', value={self.value}, category=\'{self.category}\')\\" class CustomObjectList: def __init__(self, objects: List[CustomObject] = []): self.objects = objects def multi_sort(self, keys: List[str], descending: bool=False) -> List[CustomObject]: Sort the list of objects based on multiple criteria. Args: keys: List of attribute names to sort by. descending: Boolean flag for sorting order. Returns: Sorted list of CustomObject instances. try: sorted_objects = sorted(self.objects, key=lambda obj: tuple(getattr(obj, key) for key in keys), reverse=descending) return sorted_objects except AttributeError: raise ValueError(\\"One or more provided keys are not attributes of CustomObject.\\") def filter_by_attribute(self, attribute: str, value: Union[int, str]) -> List[CustomObject]: Filter the list based on a single attribute and its value. Args: attribute: The attribute name to filter by. value: The value to match for the specified attribute. Returns: Filtered list of CustomObject instances. return [obj for obj in self.objects if getattr(obj, attribute) == value] def composite_filter(self, criteria: Dict[str, Union[int, str]]) -> List[CustomObject]: Filter the list based on multiple criteria. Args: criteria: Dictionary of attribute names and values to filter by. Returns: Filtered list of CustomObject instances matching all criteria. filtered_objects = self.objects for attribute, value in criteria.items(): filtered_objects = [obj for obj in filtered_objects if getattr(obj, attribute) == value] return filtered_objects"},{"question":"# Question: Calculating Most Frequent Words Given a large body of text, you need to determine the most frequently occurring words. Implement a function that processes the text and returns a list of the top N most frequent words along with their counts, ordered from the most to the least frequent. # Requirements: 1. Implement a function `most_frequent_words(text: str, top_n: int) -> List[Tuple[str, int]]` that accepts: - `text`: A string containing the text to be analyzed. - `top_n`: An integer representing the number of top most frequent words to return. 2. Your function should return a list of tuples, where each tuple contains a word and its count, ordered from the most to the least frequent. # Input: - A string `text` containing a mix of letters, numbers, spaces, and punctuation. - An integer `top_n` specifying the number of top frequent words to return. # Output: - A list of tuples, each consisting of a word (string) and its frequency count (integer). # Constraints: - The input text can be up to 1,000,000 characters in length. - Only consider words consisting of alphabetic characters. - The words should be case-insensitive (e.g., \\"Word\\" and \\"word\\" should be treated as the same word). - Punctuation should be ignored. - Handle the case where the text contains fewer than `top_n` unique words by returning the available words. # Example: ```python assert most_frequent_words(\\"Hello World! Hello everyone. Welcome to the world of programming.\\", 2) == [(\\"hello\\", 2), (\\"world\\", 2)] assert most_frequent_words(\\"A cat and a dog.\\", 3) == [(\\"a\\", 2), (\\"cat\\", 1), (\\"and\\", 1)] assert most_frequent_words(\\"To be, or not to be, that is the question.\\", 5) == [(\\"to\\", 2), (\\"be\\", 2), (\\"or\\", 1), (\\"not\\", 1), (\\"that\\", 1)] ``` # Notes: - Utilize helper functions to handle text normalization and word extraction. - Consider edge cases like an empty string, all punctuation strings, and strings with mixed case. - Aim for efficient processing to handle large input sizes within a reasonable time frame.","solution":"from collections import Counter import re from typing import List, Tuple def most_frequent_words(text: str, top_n: int) -> List[Tuple[str, int]]: # Normalize the text to lowercase and use regex to remove punctuations normalized_text = re.sub(r\'[^a-zs]\', \'\', text.lower()) # Extract words from the normalized text words = normalized_text.split() # Count the frequency of each word word_counts = Counter(words) # Get the top_n most common words most_common = word_counts.most_common(top_n) return most_common"},{"question":"# Scenario You are responsible for implementing a function that reads a large text file and counts the occurrence of each word. The function `count_words_in_file` is designed to read a file and return a dictionary where the keys are words, and the values are their respective counts. Performance is a critical factor since the text file can be very large. # Task Write a function `test_count_words_in_file` which performs the following actions: * Creates a temporary text file with predetermined content for testing purposes. * Verifies that `count_words_in_file` returns the correct word counts for the given test file. # Expected Input and Output * **Input**: `filename` (string path to the text file). * **Output**: The test function should contain assertions that ensure `count_words_in_file` returns a dictionary with the correct word counts based on the test file content. # Constraints * You must use the `tmpdir` fixture from the `pytest` library to create a temporary file. * Assume `count_words_in_file` is defined elsewhere and reads a file to produce the desired dictionary output. Example ```python def count_words_in_file(filename): word_counts = {} with open(filename, \'r\') as file: for line in file: words = line.split() for word in words: word = word.lower().strip(\'.,!?\') if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts # Your task is to complete the test function `test_count_words_in_file`. ``` # Example Test Case ```python def test_count_words_in_file(tmpdir): # Create a temporary text file test_file = tmpdir.join(\\"test.txt\\") test_content = \\"Hello world!nHello again, world.\\" test_file.write(test_content) # Expected word counts expected_counts = { \\"hello\\": 2, \\"world\\": 2, \\"again\\": 1, } # Call the function and assert the output result = count_words_in_file(test_file.strpath) assert result == expected_counts ``` Your solution should ensure that the `count_words_in_file` function correctly processes the text file and returns the expected word counts.","solution":"def count_words_in_file(filename): Reads a large text file and counts the occurrence of each word. Returns a dictionary with words as keys and their counts as values. word_counts = {} with open(filename, \'r\') as file: for line in file: words = line.split() for word in words: # Normalize the word by converting to lowercase and stripping punctuation word = word.lower().strip(\'.,!?\') if word in word_counts: word_counts[word] += 1 else: word_counts[word] = 1 return word_counts"},{"question":"# Question: Implement a Simple Linear Regression Model from Scratch Your task is to implement a simple linear regression model using the least squares method. The goal is to fit a line to a given set of data points (`x`, `y`) that minimizes the mean squared error. Specifically: 1. **Implement a function `fit_linear_regression`** that calculates the slope (m) and the intercept (b) of the best-fitting line. 2. **Implement a function `predict`** that takes an array of x values and returns the predicted y values based on the calculated slope and intercept. **Function Signature**: ```python def fit_linear_regression(x: list[float], y: list[float]) -> tuple[float, float]: pass def predict(x: list[float], slope: float, intercept: float) -> list[float]: pass ``` **Input**: - `x`: List of x values (independent variable). - `y`: List of y values (dependent variable). **Output**: - `fit_linear_regression` returns a tuple containing the slope and intercept of the best-fitting line. - `predict` returns a list of predicted y values for the given x values based on the calculated slope and intercept. **Constraints**: - Ensure that `x` and `y` are of the same length and contain at least two points. - Handle edge cases such as vertical lines (where all x values are the same) and identical data points. Example: ```python # Fit the model x_values = [1, 2, 3, 4, 5] y_values = [2, 4, 5, 4, 5] slope, intercept = fit_linear_regression(x_values, y_values) # Predict new values x_test = [6, 7, 8] y_predicted = predict(x_test, slope, intercept) print(f\\"Slope: {slope}, Intercept: {intercept}\\") print(f\\"Predicted values: {y_predicted}\\") ``` # Detailed Requirements: Function: fit_linear_regression - **Goal**: Calculate the slope `m` and the intercept `b` of the best-fitting line using the least squares method. - **Steps**: - Calculate the mean of x (`mean_x`) and y (`mean_y`). - Calculate the sum of the product of the differences between each x and `mean_x` and each y and `mean_y`. - Calculate the sum of the square of the differences between each x and `mean_x`. - Determine the slope `m` using these sums. - Calculate the intercept `b` using the formula `b = mean_y - m * mean_x`. Function: predict - **Goal**: Use the calculated slope `m` and intercept `b` to predict y values for given x values. - **Steps**: - For each x value in the input list, calculate the corresponding y value using the formula `y = m * x + b`. Given the provided data, ensure your implementation accurately fits the linear regression model and makes correct predictions.","solution":"def fit_linear_regression(x, y): Calculate the slope and intercept for the best-fitting line using the least squares method. Args: x (list of float): Independent variable y (list of float): Dependent variable Returns: tuple: slope and intercept of the best-fitting line if len(x) != len(y) or len(x) < 2: raise ValueError(\\"The input lists must have the same length and contain at least two elements.\\") n = len(x) mean_x = sum(x) / n mean_y = sum(y) / n numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n)) denominator = sum((x[i] - mean_x) ** 2 for i in range(n)) if denominator == 0: raise ValueError(\\"All x values are identical, vertical line cannot be fitted.\\") slope = numerator / denominator intercept = mean_y - slope * mean_x return slope, intercept def predict(x, slope, intercept): Predicts y values for the given x values based on the slope and intercept of the fitted line. Args: x (list of float): Independent variable slope (float): Slope of the fitted line intercept (float): Intercept of the fitted line Returns: list of float: Predicted y values return [slope * xi + intercept for xi in x]"},{"question":"# Key-Value Store with Expiry You are tasked with implementing a key-value store that supports an expiry feature. The key-value store should be able to set and get keys with an associated time-to-live (TTL), ensuring that any operation going beyond the TTL will not retrieve expired data. Additionally, you need to implement a cleanup feature to remove expired keys from the system. **Requirements**: 1. Implement a function to set a key with a value and a TTL. 2. Implement a function to get the value of a key if it has not expired. 3. Implement a function to manually trigger the removal of expired keys. 4. Ensure that the system accurately tracks and invalidates expired keys. # Objectives: - **Function**: `set_key(key: str, value: int, ttl: int)` - **Input**: - `key`: String, the key to be stored. - `value`: Integer, the value to be associated with the key. - `ttl`: Integer, the time-to-live in seconds from the current time. - **Output**: None. - **Function**: `get_key(key: str) -> Optional[int]` - **Input**: - `key`: String, the key to retrieve the value for. - **Output**: Returns the value associated with the key if it has not expired, otherwise returns `None`. - **Function**: `cleanup()` - **Input**: None - **Output**: Removes all expired keys from the store. Constraints: - Ensure that the `ttl` is a positive integer. - Efficiently manage the expiry of keys to avoid performance degradation over time. - Consider edge cases where keys may be accessed precisely at the moment of expiration. # Example Scenario: 1. Set keys using: ```python set_key(\\"session_1\\", 12345, 10) set_key(\\"session_2\\", 54321, 5) ``` 2. Wait for 6 seconds and then get the values of the keys: ```python value1 = get_key(\\"session_1\\") # Should return 12345 as it has not yet expired. value2 = get_key(\\"session_2\\") # Should return None as it has expired. ``` 3. Manually trigger the cleanup of expired keys: ```python cleanup() ``` 4. Verify that expired keys are removed and non-expired keys remain intact. # Guidelines: - Thoroughly document implementation details and possible edge cases. - Comment on the efficiency and performance considerations for large numbers of keys with varying TTLs. Are you ready to build a robust and performant key-value store with an integrated expiry system?","solution":"import time from typing import Optional, Dict class KeyValueStore: def __init__(self): self.store: Dict[str, Dict[str, int]] = {} def set_key(self, key: str, value: int, ttl: int) -> None: if ttl <= 0: raise ValueError(\\"TTL must be a positive integer\\") expiration_time = int(time.time()) + ttl self.store[key] = {\'value\': value, \'expires_at\': expiration_time} def get_key(self, key: str) -> Optional[int]: current_time = int(time.time()) if key in self.store: if self.store[key][\'expires_at\'] > current_time: return self.store[key][\'value\'] else: del self.store[key] return None def cleanup(self) -> None: current_time = int(time.time()) keys_to_delete = [key for key, data in self.store.items() if data[\'expires_at\'] <= current_time] for key in keys_to_delete: del self.store[key]"},{"question":"# Randomized Quicksort Implementation In this exercise, you are required to implement the Quicksort algorithm with an added twist: instead of always picking the last element or the first element as the pivot, you will randomly select the pivot element for each partition step. This randomized approach helps ensure better performance on average, especially against sequences that might otherwise cause worst-case behavior in standard Quicksort. Your task is to implement a function that sorts an array of integers using the randomized Quicksort algorithm. # Requirements * Implement the function `randomized_quicksort(arr: List[int]) -> List[int]` * **Input**: - `arr`: A list of integers that needs to be sorted. * **Output**: - A new list of integers sorted in non-decreasing order. # Constraints 1. The length of the input list will not exceed 10^5. 2. Each integer in the list will be between -10^9 and 10^9. 3. You may use Python\'s built-in random module to select pivots. # Example ```python randomized_quicksort([3,6,8,10,1,2,1]) ``` Output: `[1, 1, 2, 3, 6, 8, 10]` # Performance Requirement Ensure your implementation runs efficiently on large lists. Ideally, the sorting should have an average-case time complexity of (O(n log n)). # Implementation Guide 1. **Random Pivot Selection**: Modify the partition function to pick a random element as the pivot. 2. **Quicksort Logic**: Implement the major steps of the Quicksort algorithm, ensuring that the array is partitioned around the randomly selected pivot. 3. **Recursive Sort**: Recursively apply the same logic to the sublists created by the partition process. Make sure to test your code with diverse datasets to verify its correctness and performance. Happy coding!","solution":"import random from typing import List def randomized_quicksort(arr: List[int]) -> List[int]: Sorts an array of integers using the randomized Quicksort algorithm. def partition(low: int, high: int) -> int: pivot_index = random.randint(low, high) arr[high], arr[pivot_index] = arr[pivot_index], arr[high] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quicksort(low: int, high: int): if low < high: pi = partition(low, high) quicksort(low, pi - 1) quicksort(pi + 1, high) quicksort(0, len(arr) - 1) return arr"},{"question":"# Scenario You are developing a simple spell checker tool. To do this, you need to compare a given list of words with a predefined dictionary. The words that do not match any word in the dictionary should be marked as misspelled. # Task Write a function: 1. `spell_checker(dictionary: list, words: list) -> list` - This function should take a list of words as the dictionary and another list of words to be checked. It should return a list containing words that are not in the dictionary. # Constraints * The dictionary list and the list of words to be checked will only contain lowercase alphabetic characters (a-z). * The dictionary list will contain unique words. * The words list may contain duplicate words. # Input and Output Formats * **Spell Checker Function**: * Input: A list of words `dictionary` and a list of words `words`. * Output: A list containing the words that are misspelled. # Example ```python >>> spell_checker([\'apple\', \'banana\', \'orange\'], [\'apple\', \'aple\', \'mango\', \'banana\']) [\'aple\', \'mango\'] >>> spell_checker([\'quick\', \'brown\', \'fox\'], [\'quick\', \'quik\', \'broun\', \'fox\']) [\'quik\', \'broun\'] ``` # Edge Cases 1. Checking with an empty dictionary: ```python >>> spell_checker([], [\'apple\', \'banana\']) [\'apple\', \'banana\'] ``` 2. Checking with an empty list of words: ```python >>> spell_checker([\'apple\', \'banana\'], []) [] ``` 3. All words are correct: ```python >>> spell_checker([\'apple\', \'banana\', \'orange\'], [\'apple\', \'banana\']) [] ``` Ensure your function handles these scenarios correctly.","solution":"def spell_checker(dictionary, words): Compares a list of words with a predefined dictionary and returns a list of words that are misspelled. Args: dictionary (list): A list of words that form the dictionary. words (list): A list of words to be checked against the dictionary. Returns: list: A list of words that are not in the dictionary. dictionary_set = set(dictionary) misspelled_words = [word for word in words if word not in dictionary_set] return misspelled_words"},{"question":"# Scenario You are working on a file management system where you need to handle logs of user activity. The system logs user login and logout times to keep track of user sessions. Each session is represented by a pair of integers where the first integer is the login time and the second integer is the logout time. The log is guaranteed to be sorted by login times. Given these user sessions, your task is to find the maximum number of users that were simultaneously active on the system at any given time. # Task Write a function `max_simultaneous_users` that takes a list of tuples (each tuple representing a session) and returns an integer representing the maximum number of users active at the same time. # Function Signature ```python def max_simultaneous_users(sessions: list[tuple[int, int]]) -> int: ``` # Input * `sessions` - a list of tuples, where each tuple (a, b) represents a session: * a is the integer representing the login time. * b is the integer representing the logout time. * Constraints: * The number of sessions will be between 1 and 10^5. * 0 ≤ a < b ≤ 10^6. (0 <= login time < logout time <= 1,000,000) # Output * An integer representing the maximum number of users simultaneously active at any given time. # Example ```python assert max_simultaneous_users([(1, 5), (2, 6), (3, 7), (4, 8)]) == 4 assert max_simultaneous_users([(1, 3), (2, 5), (4, 6)]) == 2 assert max_simultaneous_users([(10, 15), (20, 25), (30, 35)]) == 1 ```","solution":"def max_simultaneous_users(sessions: list[tuple[int, int]]) -> int: events = [] for start, end in sessions: events.append((start, \'login\')) events.append((end, \'logout\')) events.sort() max_users = 0 current_users = 0 for time, event in events: if event == \'login\': current_users += 1 max_users = max(max_users, current_users) else: current_users -= 1 return max_users"},{"question":"# Coding Assessment: Create a Todo List with Priority Management Objective You are required to write Python functions to manage a todo list with item prioritization. Your solution should allow adding, removing, listing todo items, and prioritizing them. Requirements 1. **Function 1: `add_todo_item(todo_list: list, task: str, priority: int) -> list`** - Input: - A list representing the current state of the todo list. - A string representing the task description. - An integer representing the task priority (1 is the highest priority, and higher numbers are lower priorities). - Output: - The updated todo list with the new task added. - Constraints: - The task description should be a non-empty string. - The priority should be a positive integer. - Task descriptions should be unique in the todo list. 2. **Function 2: `remove_todo_item(todo_list: list, task: str) -> list`** - Input: - A list representing the current state of the todo list. - A string representing the task description to be removed. - Output: - The updated todo list with the specified task removed. - Constraints: - The task should exist in the todo list; if not, return the todo list unmodified. 3. **Function 3: `list_todo_items(todo_list: list) -> list`** - Input: - A list representing the current state of the todo list. - Output: - A list of todo items sorted by priority (highest priority first). Each item is represented as a tuple (task, priority). Example ```python >>> todo_list = [] >>> todo_list = add_todo_item(todo_list, \\"Finish project report\\", 2) >>> todo_list = add_todo_item(todo_list, \\"Buy groceries\\", 1) >>> todo_list = add_todo_item(todo_list, \\"Clean the house\\", 3) >>> print(list_todo_items(todo_list)) [(\'Buy groceries\', 1), (\'Finish project report\', 2), (\'Clean the house\', 3)] >>> todo_list = remove_todo_item(todo_list, \\"Buy groceries\\") >>> print(list_todo_items(todo_list)) [(\'Finish project report\', 2), (\'Clean the house\', 3)] ``` Notes 1. Ensure that the todo list maintains uniqueness of task descriptions. 2. Handle edge cases such as removing an item not present in the list gracefully. 3. Ensure that the list is always returned sorted by priority when listing items. Constraints - Task descriptions are case-sensitive. - Priorities are strictly positive integers with 1 being the highest priority.","solution":"def add_todo_item(todo_list, task, priority): Adds a new task to the todo list with the specified priority. :param todo_list: List of current todo items, each represented as a tuple (task, priority). :param task: String description of the new task. :param priority: Integer priority of the new task (1 is highest priority). :return: Updated list of todo items. if task and isinstance(task, str) and isinstance(priority, int) and priority > 0: for t, _ in todo_list: if t == task: return todo_list # Task already exists, do not add duplicate todo_list.append((task, priority)) return todo_list def remove_todo_item(todo_list, task): Removes a task from the todo list. :param todo_list: List of current todo items, each represented as a tuple (task, priority). :param task: String description of the task to be removed. :return: Updated list of todo items. for i, (t, _) in enumerate(todo_list): if t == task: del todo_list[i] break return todo_list def list_todo_items(todo_list): Lists the todo items sorted by priority (highest priority first). :param todo_list: List of current todo items, each represented as a tuple (task, priority). :return: List of todo items sorted by priority. return sorted(todo_list, key=lambda x: x[1])"},{"question":"# Question Scenario: You are an aspiring data scientist working on a project that involves processing large datasets of numerical data. Your task is to implement an algorithm to compute the mode(s) of a given list of integers. The mode is the number that appears most frequently in a dataset. If multiple numbers have the same highest frequency, all such numbers should be returned. Task: Write a Python function `find_modes` that takes a list of integers and returns a list of the mode(s) of the given integers. Ensure your implementation efficiently handles the provided constraints and edge cases. Function Signature: ```python def find_modes(numbers: list[int]) -> list[int]: ``` Input: - A list of integers `numbers` (0 <= len(numbers) <= 10^5). Output: - A list of integers representing the mode(s) of the input list. Constraints: - Aim for a solution with a time complexity of (O(n)) and a space complexity of (O(n)). - The input list can be empty, in which case the output should be an empty list. Performance Requirements: - The implemented solution should handle edge cases such as empty lists, lists with all unique elements, and lists with multiple modes efficiently. Example Usage: ```python >>> find_modes([1, 2, 3, 2, 4, 1, 1]) [1] >>> find_modes([4, 4, 2, 2, 3, 3]) [4, 2, 3] >>> find_modes([7, 7, 7, 7]) [7] >>> find_modes([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_modes([]) [] ```","solution":"def find_modes(numbers: list[int]) -> list[int]: Returns the mode(s) of the given list of integers. if not numbers: return [] from collections import Counter count = Counter(numbers) max_frequency = max(count.values()) return [num for num, freq in count.items() if freq == max_frequency]"},{"question":"# Coding Assessment Question: Context: In many scenarios, dealing with permutations can be critical, especially in areas like cryptography, search algorithms, and even gaming. One interesting challenge is to find specific permutations of characters and compute related properties. Given this, your task is to implement functions to handle character permutations, compute lexicographic ranks, and extract permutations based on specific criteria. Problem Statement: Write a Python function that, given a string `s` and an integer `k`, returns the `k`-th permutation of the string `s` in lexicographic order. If `k` is greater than the number of permutations, return an empty string. ```python def kth_permutation(s: str, k: int) -> str: Find the k-th permutation of the string s in lexicographic order. Args: s (str): A string of unique characters. k (int): The 1-based index of the permutation to retrieve. Returns: str: The k-th permutation of the string in lexicographic order, or an empty string if k is out of range. Examples: >>> kth_permutation(\\"abc\\", 1) \'abc\' >>> kth_permutation(\\"abc\\", 6) \'cba\' >>> kth_permutation(\\"abc\\", 7) \'\' # Implement your code here... ``` Constraints: - The string `s` will contain unique characters only. - The length of `s` will be between 1 and 9, inclusive. - `k` will always be greater than or equal to 1. Expected output: - The solution must return the `k`-th permutation in lexicographic order for a given string `s`. If `k` exceeds the permutation count for `s`, return an empty string. Example: For `s = \\"abc\\"` and `k = 3`, the permutations in lexicographic order are `[\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\']`, and the function should return `\'bac\'`. Evaluation Criteria: Your solution will be evaluated based on: 1. Correctness: The function should accurately compute the `k`-th permutation. 2. Efficiency: The function should be able to handle the upper limits of input sizes effectively. 3. Coding Style: Use clear and descriptive variable names, and ensure the code is readable and well-documented.","solution":"import math def kth_permutation(s: str, k: int) -> str: Find the k-th permutation of the string s in lexicographic order. Args: s (str): A string of unique characters. k (int): The 1-based index of the permutation to retrieve. Returns: str: The k-th permutation of the string in lexicographic order, or an empty string if k is out of range. n = len(s) permutations_count = math.factorial(n) if k > permutations_count: return \\"\\" characters = sorted(s) k -= 1 # Convert to zero-based index result = [] for i in range(n): factorial = math.factorial(n - 1 - i) index = k // factorial result.append(characters.pop(index)) k %= factorial return \'\'.join(result)"},{"question":"Coding Assessment Question # Context: Imagine you are working on a scheduling system for a conference where multiple sessions are to be held. Each session has a start time and an end time. You are tasked with scheduling the maximum number of non-overlapping sessions. # Problem: Given a list of sessions with their start and end times, you must determine the maximum number of non-overlapping sessions that can be scheduled. You need to implement an algorithm that makes optimal use of available time slots to maximize the number of sessions. # Function Signature: ```python def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: ``` Input: - **sessions**: A list of tuples, where each tuple contains two integers representing the start and end times of a session. Output: - An integer representing the maximum number of non-overlapping sessions that can be scheduled. Constraints: - `1 ≤ len(sessions) ≤ 1000` - `0 ≤ start_time < end_time ≤ 10^5` # Example: ```python # Input sessions = [(1, 4), (2, 5), (3, 6), (7, 8), (8, 9)] # Output 3 ``` # Guidelines: * Implement a greedy algorithm that selects sessions based on their end times. * Sort the sessions by their end times and iterate through them, selecting sessions that do not overlap with the previously selected sessions. # Note: Ensure the implementation is efficient and handles different edge cases, such as: * Sessions with overlapping times. * Sessions that start and end at the same time as other sessions.","solution":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: Determines the maximum number of non-overlapping sessions that can be scheduled. Parameters: sessions (List[Tuple[int, int]]): A list of tuples where each tuple contains the start and end time of a session. Returns: int: The maximum number of non-overlapping sessions. if not sessions: return 0 # Sort the sessions by their end times sessions.sort(key=lambda x: x[1]) max_sessions = 0 last_end_time = 0 for start, end in sessions: if start >= last_end_time: max_sessions += 1 last_end_time = end return max_sessions"},{"question":"# Coding Assessment Question Implement a Python function called `anagram_checker` that determines whether two given strings are anagrams of each other. Two strings are anagrams if they contain the same characters, but possibly in a different order. Requirements: 1. **Input Format**: The function should accept two string arguments. 2. **Output Format**: The function should return a boolean value - `True` if the strings are anagrams, and `False` otherwise. 3. **Edge Cases**: Your implementation should handle special cases, such as empty strings, strings of different lengths, and strings with special characters. 4. **Performance Consideration**: The function should be efficient enough to handle strings of up to 100,000 characters. Constraints: * You are not allowed to use any external libraries for sorting or other preprocessing (e.g., `collections.Counter`). * The function should be case insensitive, treating uppercase and lowercase letters as equivalent. * Ignore spaces and punctuation during comparison. Context: You are working in a text analysis firm where detecting anagrams can help in identifying plagiarized content. Ensuring an efficient and correct implementation can assist in effective text matching and analysis. Here is a function skeleton to get you started: ```python def anagram_checker(str1: str, str2: str) -> bool: def clean_string(s: str) -> str: # Normalize the string: remove spaces, punctuation and convert to lowercase. cleaned = \'\'.join(filter(str.isalnum, s)).lower() return cleaned # Clean both input strings clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) # Return whether the sorted versions of the cleaned strings match return sorted(clean_str1) == sorted(clean_str2) # Example usage print(anagram_checker(\'Listen\', \'Silent\')) # Expected output: True print(anagram_checker(\'Hello\', \'Olelh\')) # Expected output: True print(anagram_checker(\'Astronomer\', \'Moon starer\')) # Expected output: True print(anagram_checker(\'A gentleman\', \'Elegant man\')) # Expected output: True print(anagram_checker(\'The eyes\', \'They see\')) # Expected output: True print(anagram_checker(\'Word\', \'World\')) # Expected output: False ``` Testing Ensure your implementation handles normal cases, edge cases, and large inputs efficiently: ```python def test_anagram_checker(): assert anagram_checker(\'abcd\', \'dcba\') == True assert anagram_checker(\'a\', \'a\') == True assert anagram_checker(\'a\', \'b\') == False assert anagram_checker(\'\', \'\') == True assert anagram_checker(\'z\'*100000, \'z\'*100000) == True assert anagram_checker(\'The eyes\', \'They see\') == True assert anagram_checker(\'a\'*100000 + \'b\', \'a\'*100000) == False assert anagram_checker(\'abc!\', \'cab\') == True assert anagram_checker(\'Astronomer\', \'Moon starer\') == True test_anagram_checker() ```","solution":"def anagram_checker(str1: str, str2: str) -> bool: def clean_string(s: str) -> str: # Normalize the string: remove spaces, punctuation and convert to lowercase. cleaned = \'\'.join(filter(str.isalnum, s)).lower() return cleaned # Clean both input strings clean_str1 = clean_string(str1) clean_str2 = clean_string(str2) # Return whether the sorted versions of the cleaned strings match return sorted(clean_str1) == sorted(clean_str2)"},{"question":"# Coding Question: Calculate the Number of Trailing Zeroes in Factorial Context: Bob is working on a combinatorial project and frequently needs to determine the number of trailing zeroes in large factorials. Analyzing the number of trailing zeroes helps in comprehending the division of factorials. For instance, 5! (120) has one trailing zero. Task: Write a function `count_trailing_zeros_in_factorial(n: int) -> int` that computes the number of trailing zeroes in the factorial of a given non-negative integer `n`. If the input is not an integer or is negative, the function should raise a `TypeError`. Input and Output Format: * **Input**: A single non-negative integer `n`. * Constraints: * `0 <= n <= 10^9` * **Output**: An integer representing the number of trailing zeroes in `n!`. Example Cases: ```python >>> count_trailing_zeros_in_factorial(5) 1 >>> count_trailing_zeros_in_factorial(0) 0 >>> count_trailing_zeros_in_factorial(25) 6 >>> count_trailing_zeros_in_factorial(10) 2 >>> count_trailing_zeros_in_factorial(-3) Traceback (most recent call last): ... TypeError: Input value must be a non-negative \'int\' type ``` Constraints: * You should not calculate the factorial itself, as it would be computationally expensive for large `n`. * Handle up to the largest value within the constraint efficiently. Performance Requirements: * The solution should run in O(log n) time complexity. Good luck and ensure your code passes the provided example cases!","solution":"def count_trailing_zeros_in_factorial(n): This function takes a non-negative integer n and returns the number of trailing zeroes in the factorial of n. If n is not a non-negative integer an error is raised. if not isinstance(n, int) or n < 0: raise TypeError(\\"Input value must be a non-negative \'int\' type\\") count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count"},{"question":"# Question: Optimize a Hash Table Implementation Scenario A hash table is a data structure used to implement an associative array, a structure that can map keys to values. Efficient hashing ensures average-case constant time complexity for most operations like insertion, deletion, and lookup. You are provided with a basic implementation of a hash table, but it lacks optimization, particularly in handling collisions and dynamic resizing, which can result in suboptimal performance. Your task is to enhance this hash table such that it can handle collision resolution efficiently and dynamically resize to maintain good performance. Function Implementation Your task is to implement an optimized version of the `HashTable` class with the following methods: - `insert(key: str, value: Any) -> None`: Inserts a key-value pair into the hash table. - `delete(key: str) -> bool`: Deletes the key-value pair associated with the given key. Returns `True` if the key was found and deleted, otherwise `False`. - `search(key: str) -> Optional[Any]`: Returns the value associated with the given key if it exists, otherwise `None`. Consider using a collision resolution technique like separate chaining or open addressing. Also, implement dynamic resizing (rehashing) when the load factor crosses a threshold. Function Signature ```python class HashTable: def __init__(self, initial_capacity: int = 8): self.size = 0 self.capacity = initial_capacity self.table = [[] for _ in range(self.capacity)] def hash_function(self, key: str) -> int: # A simple yet effective hash function return sum(ord(char) for char in key) % self.capacity def insert(self, key: str, value: Any) -> None: # Implement insertion logic with collision handling and resizing pass def delete(self, key: str) -> bool: # Implement deletion logic pass def search(self, key: str) -> Optional[Any]: # Implement lookup logic pass def _resize(self): # Implement dynamic resizing (rehashing) logic pass ``` Input - `initial_capacity`: The initial capacity of the hash table. - `key`: A string representing the key. - `value`: Any data type representing the value associated with the key. Output - `insert`: None (inserts a key-value pair into the hash table). - `delete`: A boolean indicating if the key was successfully deleted. - `search`: The value associated with the given key if it exists, otherwise `None`. Constraints - The hash table should dynamically resize when the load factor (size/capacity) exceeds 0.75. - The size of the hash table should increase by doubling the capacity during resizing. - Maintain average-case constant time complexity for insertions, deletions, and searches. Example ```python hash_table = HashTable() hash_table.insert(\\"apple\\", 10) hash_table.insert(\\"banana\\", 20) hash_table.insert(\\"grape\\", 30) print(hash_table.search(\\"apple\\")) # Output: 10 print(hash_table.delete(\\"banana\\")) # Output: True print(hash_table.search(\\"banana\\")) # Output: None ``` # Considerations - Ensure your hash function evenly distributes keys to maintain optimal performance. - Handle key collisions efficiently without sacrificing performance. - Implement dynamic resizing to maintain an optimal load factor. - Ensure the correct handling of keys with common prefixes or similar hash values.","solution":"from typing import Any, Optional class HashTable: def __init__(self, initial_capacity: int = 8): self.size = 0 self.capacity = initial_capacity self.table = [[] for _ in range(self.capacity)] def hash_function(self, key: str) -> int: return sum(ord(char) for char in key) % self.capacity def insert(self, key: str, value: Any) -> None: if self.size / self.capacity > 0.75: self._resize() index = self.hash_function(key) for i, (k, v) in enumerate(self.table[index]): if k == key: self.table[index][i] = (key, value) return self.table[index].append((key, value)) self.size += 1 def delete(self, key: str) -> bool: index = self.hash_function(key) for i, (k, v) in enumerate(self.table[index]): if k == key: del self.table[index][i] self.size -= 1 return True return False def search(self, key: str) -> Optional[Any]: index = self.hash_function(key) for k, v in self.table[index]: if k == key: return v return None def _resize(self) -> None: old_table = self.table self.capacity *= 2 self.table = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_table: for k, v in bucket: self.insert(k, v)"},{"question":"# Pathfinding Algorithm Coding Challenge You are asked to implement a function to find the shortest path in a grid using the A* (A-star) algorithm. The input will be a 2D list representing a grid where 0s are walkable areas and 1s are obstacles. Your goal is to navigate from the top-left corner to the bottom-right corner in the shortest path avoiding obstacles. Function Signature: ```python def a_star_pathfinding(grid: List[List[int]]) -> List[Tuple[int, int]]: pass ``` # Input - `grid`: A 2D list of integers containing only 0s and 1s, where 0 represents a walkable cell, and 1 represents an obstacle. - The dimensions of the grid will be in the range [1, 1000] x [1, 1000]. # Output - Returns a list of tuples, where each tuple is a pair of integers (row, column) representing the coordinates of the cells in the shortest path from the top-left to the bottom-right. Return an empty list if there is no valid path. # Constraints - The start point (0,0) and the endpoint (n-1,m-1) will always be walkable (i.e., grid[0][0] == 0 and grid[n-1][m-1] == 0). - Diagonal movement is not allowed; you can only move up, down, left, or right. # Scenario Given a grid representing a maze, you need to compute the shortest path from the starting point to the destination, avoiding any obstacles in the least number of moves using the A* algorithm. The computed path should be optimal and should handle large inputs efficiently. # Example ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] print(a_star_pathfinding(grid)) # Expected output: [(0,0), (1,0), (2,0), (2,1), (2,2), (3,2), (4,2), (4,3), (4,4)] ``` # Considerations * Implement the A* algorithm efficiently to handle the maximum input constraints. * Think about the heuristic function, such as Manhattan distance, to guide the search. * Ensure your solution handles edge cases such as completely blocked grids where no path is possible.","solution":"from typing import List, Tuple import heapq def a_star_pathfinding(grid: List[List[int]]) -> List[Tuple[int, int]]: def heuristic(a: Tuple[int, int], b: Tuple[int, int]) -> int: return abs(a[0] - b[0]) + abs(a[1] - b[1]) def get_neighbors(pos: Tuple[int, int]) -> List[Tuple[int, int]]: neighbors = [] for d in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_pos = (pos[0] + d[0], pos[1] + d[1]) if 0 <= new_pos[0] < len(grid) and 0 <= new_pos[1] < len(grid[0]) and grid[new_pos[0]][new_pos[1]] == 0: neighbors.append(new_pos) return neighbors start = (0, 0) goal = (len(grid) - 1, len(grid[0]) - 1) open_set = [] heapq.heappush(open_set, (0 + heuristic(start, goal), 0, start)) came_from = {} g_score = {start: 0} while open_set: current_f, current_g, current = heapq.heappop(open_set) if current == goal: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in get_neighbors(current): tentative_g_score = current_g + 1 if neighbor not in g_score or tentative_g_score < g_score[neighbor]: came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score = tentative_g_score + heuristic(neighbor, goal) heapq.heappush(open_set, (f_score, tentative_g_score, neighbor)) return []"},{"question":"# Interleaving Strings **Overview**: Interleaving of two strings s1 and s2 is a process of creating a new string s3 that contains all the characters of s1 and s2 in a way that: - The relative order of the characters in s1 and s2 is preserved in s3. - It is possible to create s3 by interleaving characters of s1 and s2. **Task**: Write a function `is_interleaved(s1: str, s2: str, s3: str) -> bool` that returns a boolean indicating if `s3` is an interleaving of `s1` and `s2`. **Function Signature**: ```python def is_interleaved(s1: str, s2: str, s3: str) -> bool: ``` **Input**: - `s1` (string): The first input string. - `s2` (string): The second input string. - `s3` (string): The target string to verify if it can be formed by interleaving `s1` and `s2`. **Output**: - Boolean: `True` if `s3` is an interleaving of `s1` and `s2`. `False` otherwise. **Example**: ```python >>> is_interleaved(\\"aab\\", \\"axy\\", \\"aaxaby\\") True >>> is_interleaved(\\"aab\\", \\"axy\\", \\"abaaxy\\") False ``` **Constraints**: - All input strings `s1`, `s2`, and `s3` will only contain lowercase English letters. - `0 <= len(s1), len(s2) <= 100` - `0 <= len(s3) <= 200` **Requirements**: 1. Ensure that the function properly verifies interleaving by preserving the order of characters in both s1 and s2. 2. Consider edge cases where any of the input strings could be empty. **Scenario/Context**: Suppose you are developing a text processing application that sometimes needs to verify if a target draft text can be formed by interleaving two other texts. Your task is to implement this verification mechanism.","solution":"def is_interleaved(s1: str, s2: str, s3: str) -> bool: if len(s1) + len(s2) != len(s3): return False dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)] dp[0][0] = True for i in range(1, len(s1) + 1): dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1] for j in range(1, len(s2) + 1): dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1] for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1]) return dp[len(s1)][len(s2)]"},{"question":"# Scenario: You are tasked with developing a banking system that tracks the balance of multiple accounts and allows for transactions between these accounts. The system needs to handle frequent deposits, withdrawals, and balance inquiries efficiently. Each account is identified by a unique account number. # Task: Implement a class to support the following operations: 1. **deposit(account_id: int, amount: int)**: Deposit the specified amount into the account with the given account_id. 2. **withdraw(account_id: int, amount: int) -> bool**: Withdraw the specified amount from the account with the given account_id. If the account has insufficient funds, the operation should fail and return `False`. 3. **balance(account_id: int) -> int**: Return the current balance of the account with the given account_id. # Constraints: - `0 <= account_id < N`, where `N` is the number of accounts. - `0 <= amount <= 10^9` - The system should maintain account balances efficiently, especially for large numbers of transactions and accounts. # Function Signature: ```python class BankingSystem: def __init__(self, number_of_accounts: int) -> None: ... def deposit(self, account_id: int, amount: int) -> None: ... def withdraw(self, account_id: int, amount: int) -> bool: ... def balance(self, account_id: int) -> int: ... # Example Usage: # bank_system = BankingSystem(3) # bank_system.deposit(0, 100) # bank_system.deposit(1, 200) # print(bank_system.balance(0)) # Output: 100 # print(bank_system.withdraw(1, 50)) # Output: True # print(bank_system.balance(1)) # Output: 150 # print(bank_system.withdraw(2, 10)) # Output: False ``` # Notes: - Ensure that the solution efficiently handles deposits, withdrawals, and balance inquiries. - Implement appropriate exception handling for invalid operations. - Maintain accurate and up-to-date account balances throughout all operations.","solution":"class BankingSystem: def __init__(self, number_of_accounts: int) -> None: self.accounts = [0] * number_of_accounts def deposit(self, account_id: int, amount: int) -> None: if 0 <= account_id < len(self.accounts): self.accounts[account_id] += amount def withdraw(self, account_id: int, amount: int) -> bool: if 0 <= account_id < len(self.accounts): if self.accounts[account_id] >= amount: self.accounts[account_id] -= amount return True else: return False return False def balance(self, account_id: int) -> int: if 0 <= account_id < len(self.accounts): return self.accounts[account_id] return -1 # An invalid account_id should return an invalid balance"},{"question":"Sorting Nearly Sorted Array In your data structures and algorithms class, you have encountered various sorting algorithms. One of the interesting problems in this domain is efficiently sorting a nearly sorted (or K-sorted) array, where each element is at most K positions away from its target position. Given a nearly sorted array, the goal is to sort this array in linearithmic time if possible. Write a Python function `sort_k_sorted_array(arr, k)` that: 1. Takes a list `arr` of n integers that is K-sorted. 2. Takes an integer `k` indicating the maximum displacement from the sorted position. 3. Returns a new list of integers representing the sorted array. 4. The method should adhere to O(n log k) time complexity and utilize O(k) space complexity. Input - A list of integers `arr` of length `n` (1 ≤ n ≤ 10^5), where each element is no more than `k` positions away from its sorted position. - An integer `k` (0 ≤ k < n). Output - A list of integers representing the sorted array. Example ```python # Example input arr = [3, 2, 1, 5, 4, 7, 6, 8] k = 3 # Example output [1, 2, 3, 4, 5, 6, 7, 8] ``` Constraints - The input list length is at least 1. - The value of `k` is non-negative and less than the length of the list. - The input integers are not necessarily distinct. Implementation Notes Consider using a min heap to efficiently manage and retrieve the smallest elements. You can insert the first `k+1` elements into the min heap and then proceed refining the heap for the remaining elements while building the sorted array. Provide clear and efficient heap operations to ensure the time complexity requirements are met. Example Output ```python # Example input and output arr = [3, 2, 1, 5, 4, 7, 6, 8] k = 3 print(sort_k_sorted_array(arr, k)) # Output: [1, 2, 3, 4, 5, 6, 7, 8] ```","solution":"import heapq def sort_k_sorted_array(arr, k): Sort a k-sorted array. :param arr: List[int] - the k-sorted array. :param k: int - the maximum displacement from the sorted position. :return: List[int] - the fully sorted array. n = len(arr) if n == 1 or k == 0: return arr # Create a min heap for the first k+1 elements min_heap = arr[:k+1] heapq.heapify(min_heap) result = [] # Iterate over the array from k+1 to end for i in range(k+1, n): # Extract the smallest element from the heap and append it to result result.append(heapq.heappop(min_heap)) # Add the next element from the list to the heap heapq.heappush(min_heap, arr[i]) # Extract the remaining elements from the heap and add them to result while min_heap: result.append(heapq.heappop(min_heap)) return result"},{"question":"# Question You are asked to implement a simulation of a simple caching mechanism that supports the Least Recently Used (LRU) strategy. The cache should allow for setting and retrieving key-value pairs, and ensure that the least recently used items are evicted first when the cache reaches its capacity. Task Write a class named `LRUCache` that implements the following methods: - `__init__(self, capacity: int)`: Initializes the LRU cache with a given capacity. - `get(self, key: int) -> int`: Returns the value of the key if it exists in the cache; otherwise, returns `-1`. - `put(self, key: int, value: int) -> None`: Updates or inserts the value of the key. If the cache exceeds its capacity, it should evict the least recently used item. Input - `capacity` (int): The maximum number of items that the cache can hold. - `key` (int): An integer representing the key of an item. - `value` (int): An integer representing the value associated with a key. Output The `get` method returns the value associated with the key or `-1` if the key does not exist in the cache. The `put` method does not return anything. Constraints - All keys and values are positive integers. - The cache\'s capacity is a positive integer. # Example ```python # Initialize a new LRU cache with capacity 2 cache = LRUCache(2) # Add a key-value pair (1, 1) to the cache cache.put(1, 1) # Add a key-value pair (2, 2) to the cache cache.put(2, 2) # Retrieve the value associated with key 1, which is 1 print(cache.get(1)) # Output: 1 # Add a new key-value pair (3, 3); this will evict key 2 cache.put(3, 3) # Attempt to retrieve the value associated with key 2, which should now be -1 (not found) print(cache.get(2)) # Output: -1 # Add a new key-value pair (4, 4); this will evict key 1 cache.put(4, 4) # Retrieve the value associated with key 1, which should now be -1 (not found) print(cache.get(1)) # Output: -1 # Retrieve the value associated with key 3, which is 3 print(cache.get(3)) # Output: 3 # Retrieve the value associated with key 4, which is 4 print(cache.get(4)) # Output: 4 ```","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.order = [] def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the accessed key to the front (most recently used) self.order.remove(key) self.order.insert(0, key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: # Update the value and move the key to the front self.cache[key] = value self.order.remove(key) self.order.insert(0, key) else: # If the cache is at capacity, remove the least recently used item if len(self.cache) >= self.capacity: lru_key = self.order.pop() del self.cache[lru_key] # Insert the new key and value self.cache[key] = value self.order.insert(0, key)"},{"question":"# Context You need to create a simplified version of a basic text editor that can accept text, undo operations, and return the current state of the text. # Task Implement a `TextEditor` class. The `TextEditor` class should manage an internal state of text with the ability to perform operations such as appending new text, undoing the last change, and fetching the current text. # Requirements 1. **Constructor**: `TextEditor(initial_text=\\"\\")` initializes the text editor with an optional initial text. 2. **Methods**: * `append(self, text)`: Appends the given text to the current text. * `undo(self)`: Reverts the last change made to the text. * `get_text(self)`: Returns the current state of the text as a string. 3. **Constraints**: - The text editor must handle multiple undo operations. - It should correctly maintain and display the text state after several operations. # Example ```python # Example with basic operations te = TextEditor(\\"Hello\\") te.append(\\" World\\") assert te.get_text() == \\"Hello World\\" # Performing an undo operation te.undo() assert te.get_text() == \\"Hello\\" # Multiple operations te.append(\\",\\") te.append(\\" how are you?\\") assert te.get_text() == \\"Hello, how are you?\\" # Multiple undo operations te.undo() te.undo() assert te.get_text() == \\"Hello\\" ```","solution":"class TextEditor: def __init__(self, initial_text=\\"\\"): self.text = initial_text self.history = [initial_text] def append(self, text): self.text += text self.history.append(self.text) def undo(self): if len(self.history) > 1: self.history.pop() self.text = self.history[-1] elif len(self.history) == 1: self.text = self.history[0] def get_text(self): return self.text"},{"question":"# Coding Question: Advanced k-th Largest Finder Imagine you are enhancing a data processing feature for an analytics platform. Your task is to efficiently find the k-th largest value from a 2D matrix of integers. Given the potential size of the data, your solution needs to be optimized to handle large datasets efficiently. # Requirements: 1. Implement the `optimized_kth_largest(matrix: list[list[int]], k: int) -> int` function. 2. The function must efficiently find and return the k-th largest value of the provided matrix. 3. Direct sorting of the entire matrix is not allowed (i.e., you cannot simply flatten and sort the matrix). 4. The matrix is guaranteed to have at least one row and one column and contains only integers. 5. Aim for an optimal solution given the constraints. 6. The value of k is guaranteed to be valid (1 ≤ k ≤ total number of elements in the matrix). # Input: * `matrix`: A 2D list of integers representing the matrix. * `k`: An integer representing the k-th largest element to find. # Output: * An integer representing the k-th largest value of the matrix. # Constraints: * The matrix is non-empty and contains only integer values. * Rows and columns of the matrix may not necessarily be of equal length. # Performance Requirements: * Your solution should significantly outperform the O(N log N) approach for very large matrices. # Function Signature: ```python def optimized_kth_largest(matrix: list[list[int]], k: int) -> int: pass ``` # Example: ```python matrix = [ [1, 3, 5], [2, 6, 9], [3, 6, 9] ] assert optimized_kth_largest(matrix, 1) == 9 # Expected 1st Largest assert optimized_kth_largest(matrix, 3) == 6 # Expected 3rd Largest matrix = [ [1, 2, 3], [4, 5, 6] ] assert optimized_kth_largest(matrix, 2) == 5 # Expected 2nd Largest matrix = [ [1, 10, 20], [2, 12, 30], [10, 15, 20] ] assert optimized_kth_largest(matrix, 4) == 15 # Expected 4th Largest ``` # Additional Notes: * Thoroughly test your function with diverse cases, including large matrices and those with varying row lengths. * Efficient handling of space and time complexity will be crucial for grading.","solution":"import heapq def optimized_kth_largest(matrix: list[list[int]], k: int) -> int: Efficiently finds the k-th largest value in a 2D matrix. Parameters: matrix (list[list[int]]): 2D list of integers representing the matrix. k (int): An integer representing the k-th largest element to find. Returns: int: The k-th largest element in the matrix. min_heap = [] for row in matrix: for val in row: if len(min_heap) < k: heapq.heappush(min_heap, val) else: if val > min_heap[0]: heapq.heapreplace(min_heap, val) return min_heap[0]"},{"question":"# Task You are tasked with creating a function that processes a sequence of events and calculates the most frequently occurring event. # Input and Output * **Function Signature**: ```python def most_frequent_event(events: List[str]) -> str: ``` * **Input**: * A list of strings `events`, where each string represents an event name. * **Output**: * A string that represents the name of the most frequently occurring event in the list. If there are multiple events with the same highest frequency, return any one of them. # Constraints 1. The length of the `events` list, `n`, can be up to 10^5. 2. Each event name is a non-empty string with a maximum length of 50 characters. 3. The input list `events` will contain at least one event. # Example Your function should return the event name with the highest frequency: ```python most_frequent_event([\\"login\\", \\"view_item\\", \\"purchase\\", \\"view_item\\", \\"login\\", \\"login\\"]) # returns \\"login\\" most_frequent_event([\\"signup\\", \\"login\\", \\"logout\\", \\"signup\\", \\"login\\"]) # returns either \\"signup\\" or \\"login\\" ``` # Expectations * Your solution should efficiently compute the frequency of each event. * Use suitable data structures to handle events and their frequencies for optimal performance. # Performance Requirements * The solution should be capable of processing up to 100,000 events in a very short time, ensuring that the counting and comparison operations are efficient. # Assumptions * The input list `events` is guaranteed to include at least one event, ensuring that the output is always defined.","solution":"from typing import List def most_frequent_event(events: List[str]) -> str: Returns the most frequently occurring event from the list of events. Parameters: events (List[str]): A list of strings where each string is an event name. Returns: str: The event name with the highest frequency. from collections import Counter # Count the frequency of each event event_counts = Counter(events) # Find the event with the highest frequency most_frequent = event_counts.most_common(1)[0][0] return most_frequent"},{"question":"# **Coding Assessment Question** **String Operations and Transformations** In this task, you will extend and test functionalities for a `StringProcessor` class. The objective is to showcase your understanding of string manipulation and transformation by completing the methods as specified below. **Task** 1. **Longest Palindromic Substring**: Implement a method `longest_palindrome` to find and return the longest palindromic substring in the given string. ```python def longest_palindrome(self, s: str) -> str: Return the longest palindromic substring in s. >>> sp = StringProcessor() >>> sp.longest_palindrome(\\"babad\\") \'bab\' >>> sp.longest_palindrome(\\"cbbd\\") \'bb\' >>> sp.longest_palindrome(\\"a\\") \'a\' >>> sp.longest_palindrome(\\"\\") \'\' # Implement the method here ``` 2. **String Compression**: Implement a method `compress` to compress the given string using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". If the \\"compressed\\" string would not become smaller than the original string, the method should return the input string. ```python def compress(self, s: str) -> str: Compress the string using counts of repeated characters and return the compressed string. Return the original string if compression does not reduce the size. >>> sp = StringProcessor() >>> sp.compress(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> sp.compress(\\"abcdef\\") \'abcdef\' >>> sp.compress(\\"aabbcc\\") \'aabbcc\' >>> sp.compress(\\"\\") \'\' # Implement the method here ``` 3. **Anagram Groups**: Implement a method `group_anagrams` to group a list of strings into anagram groups. Each group should contain words that are anagrams of each other. ```python def group_anagrams(self, strs: List[str]) -> List[List[str]]: Group anagrams from the list of strings and return a list of lists. >>> sp = StringProcessor() >>> sp.group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'eat\', \'tea\', \'ate\'], [\'tan\', \'nat\'], [\'bat\']] >>> sp.group_anagrams([\\"\\"]) [[\'\']] >>> sp.group_anagrams([\\"a\\"]) [[\'a\']] >>> sp.group_anagrams([\\"ab\\", \\"ba\\", \\"abc\\", \\"cba\\", \\"bca\\"]) [[\'ab\', \'ba\'], [\'abc\', \'cba\', \'bca\']] # Implement the method here ``` **Function Signature** ```python class StringProcessor: def longest_palindrome(self, s: str) -> str: # Implement here pass def compress(self, s: str) -> str: # Implement here pass def group_anagrams(self, strs: List[str]) -> List[List[str]]: # Implement here pass ``` **Input and Output Formats** * The `longest_palindrome` method should return a string representing the longest palindromic substring in the given input string. * The `compress` method should return a compressed string or the original string if the compression doesn\'t reduce the size. * The `group_anagrams` method should return a list of lists, where each inner list contains strings that are anagrams of each other. **Constraints/Limitations** * Inputs are strings containing lowercase English letters. * Ensure handling of empty strings and lists appropriately. * The `longest_palindrome` method should efficiently handle strings of length up to 1000.","solution":"from typing import List class StringProcessor: def longest_palindrome(self, s: str) -> str: Return the longest palindromic substring in s. if not s: return \\"\\" n = len(s) longest = \\"\\" def extend_around_center(left: int, right: int): nonlocal longest while left >= 0 and right < n and s[left] == s[right]: substring = s[left:right+1] if len(substring) > len(longest): longest = substring left -= 1 right += 1 for i in range(n): extend_around_center(i, i) extend_around_center(i, i+1) return longest def compress(self, s: str) -> str: Compress the string using counts of repeated characters and return the compressed string. Return the original string if compression does not reduce the size. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(f\\"{s[i-1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s def group_anagrams(self, strs: List[str]) -> List[List[str]]: Group anagrams from the list of strings and return a list of lists. anagrams = {} for s in strs: key = tuple(sorted(s)) if key not in anagrams: anagrams[key] = [] anagrams[key].append(s) return list(anagrams.values())"},{"question":"# **Coding Assessment Question** **String Manipulation and Analysis** In this task, you will implement and test functionalities for handling and analyzing strings. The objective is to demonstrate your ability to manipulate strings and extract meaningful patterns from them by completing the methods as specified below. **Task** 1. **Longest Palindromic Substring**: Implement a method `longest_palindromic_substring` to return the longest substring of a given string that is a palindrome. ```python def longest_palindromic_substring(self, s: str) -> str: Return the longest palindromic substring in the given string. >>> s = \\"babad\\" >>> StringHandler().longest_palindromic_substring(s) \'bab\' >>> s = \\"cbbd\\" >>> StringHandler().longest_palindromic_substring(s) \'bb\' >>> s = \\"a\\" >>> StringHandler().longest_palindromic_substring(s) \'a\' >>> s = \\"\\" >>> StringHandler().longest_palindromic_substring(s) \'\' # Implement the method here ``` 2. **Anagram Check**: Implement a method `are_anagrams` to check if two strings are anagrams of each other. An anagram is a word or phrase formed by rearranging the letters of another, typically using all the original letters exactly once. ```python def are_anagrams(self, s1: str, s2: str) -> bool: Check if two strings are anagrams of each other. >>> s1, s2 = \\"listen\\", \\"silent\\" >>> StringHandler().are_anagrams(s1, s2) True >>> s1, s2 = \\"triangle\\", \\"integral\\" >>> StringHandler().are_anagrams(s1, s2) True >>> s1, s2 = \\"apple\\", \\"pale\\" >>> StringHandler().are_anagrams(s1, s2) False >>> s1, s2 = \\"\\", \\"\\" >>> StringHandler().are_anagrams(s1, s2) True # Implement the method here ``` 3. **String Compression**: Implement a method `compress_string` to perform basic string compression using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would be compressed to \\"a2b1c5a3\\". If the \\"compressed\\" string would not become smaller than the original string, your method should return the original string. Capital letters should be considered separately from lowercase letters. ```python def compress_string(self, s: str) -> str: Perform basic string compression using the counts of repeated characters. >>> s = \\"aabcccccaaa\\" >>> StringHandler().compress_string(s) \'a2b1c5a3\' >>> s = \\"abcdef\\" >>> StringHandler().compress_string(s) \'abcdef\' >>> s = \\"a\\" >>> StringHandler().compress_string(s) \'a\' >>> s = \\"\\" >>> StringHandler().compress_string(s) \'\' # Implement the method here ``` **Function Signature** ```python class StringHandler: # Existing methods def longest_palindromic_substring(self, s: str) -> str: # Implement here pass def are_anagrams(self, s1: str, s2: str) -> bool: # Implement here pass def compress_string(self, s: str) -> str: # Implement here pass ``` **Input and Output Formats** * The `longest_palindromic_substring` method returns the longest palindromic substring of the input string. * The `are_anagrams` method returns a boolean indicating whether the two input strings are anagrams. * The `compress_string` method returns a compressed string representation or the original string if compression doesn\'t reduce its size. **Constraints/Limitations** * Input strings may contain lower and upper case alphabets. * Inputs are plain text strings with arbitrary length. * Ensure handling of edge cases, such as empty inputs and single-character strings.","solution":"class StringHandler: def longest_palindromic_substring(self, s: str) -> str: if not s: return \\"\\" n = len(s) dp = [[False] * n for _ in range(n)] longest_palindrome_start = 0 max_length = 1 for i in range(n): dp[i][i] = True for start in range(n - 1, -1, -1): for end in range(start + 1, n): if s[start] == s[end]: if end - start == 1 or dp[start + 1][end - 1]: dp[start][end] = True if end - start + 1 > max_length: longest_palindrome_start = start max_length = end - start + 1 return s[longest_palindrome_start:longest_palindrome_start + max_length] def are_anagrams(self, s1: str, s2: str) -> bool: return sorted(s1) == sorted(s2) def compress_string(self, s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Problem Statement You need to design a system for tracking and evaluating the performance of a series of tasks executed by different users. Given a log of task executions with timestamps, user IDs, and task attributes, you will determine the number of distinct tasks completed by each user within a specified time frame. # Task: Write a function `task_summary(log: List[Dict[str, Union[str, int]]], start_time: str, end_time: str) -> Dict[str, int]:` that takes a list of dictionaries representing the task execution logs, a start time, and an end time. The function should return a dictionary where the keys are user IDs, and the values are the number of distinct tasks each user completed between the start and end times. # Input * `log`: a list of dictionaries, each containing: - `\'user_id\'`: a string representing the user\'s ID. - `\'task_id\'`: a string representing the task\'s ID. - `\'timestamp\'`: a string representing the time the task was completed in the format \'YYYY-MM-DD HH:MM:SS\'. * `start_time`: a string representing the start of the time frame in the format \'YYYY-MM-DD HH:MM:SS\'. * `end_time`: a string representing the end of the time frame in the format \'YYYY-MM-DD HH:MM:SS\'. # Output * A dictionary where each key is a user ID and the value is an integer representing the number of distinct tasks that user completed in the specified time frame. # Constraints * The function should handle edge cases such as no logs, empty logs, or invalid timestamps. * The function should ignore any logs that fall outside the specified time frame. * The function should assume all times are in the same timezone and correctly formatted. # Example Input ```python log = [ {\'user_id\': \'user1\', \'task_id\': \'task1\', \'timestamp\': \'2023-01-01 10:00:00\'}, {\'user_id\': \'user2\', \'task_id\': \'task2\', \'timestamp\': \'2023-01-01 11:00:00\'}, {\'user_id\': \'user1\', \'task_id\': \'task3\', \'timestamp\': \'2023-01-01 12:00:00\'}, {\'user_id\': \'user1\', \'task_id\': \'task1\', \'timestamp\': \'2023-01-01 13:00:00\'}, {\'user_id\': \'user2\', \'task_id\': \'task3\', \'timestamp\': \'2023-01-01 14:00:00\'}, ] start_time = \'2023-01-01 10:00:00\' end_time = \'2023-01-01 12:00:00\' ``` Output ```python {\'user1\': 2, \'user2\': 1} ``` Input ```python log = [] start_time = \'2023-01-01 00:00:00\' end_time = \'2023-01-02 00:00:00\' ``` Output ```python {} ``` # Implementation Notes - Use Python\'s datetime library for parsing and comparing timestamps. - Ensure that the function handles large log inputs efficiently. - Maintain readability and proper documentation within your code. # Function Signature ```python from typing import List, Dict, Union def task_summary(log: List[Dict[str, Union[str, int]]], start_time: str, end_time: str) -> Dict[str, int]: pass ```","solution":"from typing import List, Dict, Union from datetime import datetime def task_summary(log: List[Dict[str, Union[str, int]]], start_time: str, end_time: str) -> Dict[str, int]: This function takes in a list of task execution logs, a start time, and an end time. It returns a dictionary where the keys are user IDs and the values are the number of distinct tasks each user completed between the start and end times. start_dt = datetime.strptime(start_time, \'%Y-%m-%d %H:%M:%S\') end_dt = datetime.strptime(end_time, \'%Y-%m-%d %H:%M:%S\') user_tasks = {} for entry in log: user_id = entry[\'user_id\'] task_id = entry[\'task_id\'] timestamp = datetime.strptime(entry[\'timestamp\'], \'%Y-%m-%d %H:%M:%S\') if start_dt <= timestamp <= end_dt: if user_id not in user_tasks: user_tasks[user_id] = set() user_tasks[user_id].add(task_id) return {user: len(tasks) for user, tasks in user_tasks.items()}"},{"question":"# Problem Statement Write a function `find_highest_frequency_word` that takes a string of text and returns the word that appears most frequently. In case of a tie (i.e., more than one word with the same highest frequency), return the word that comes first lexicographically (alphabetically). Consider a word to be any sequence of characters separated by spaces, and ignore any leading or trailing punctuation from each word. # Function Signature ```python def find_highest_frequency_word(text: str) -> str: ``` # Input * `text`: A string consisting of words separated by spaces. The length of the text will not exceed 10^5 characters. # Output * Return a string representing the word with the highest frequency. In the case of a tie, return the word that comes first in alphabetical order. # Constraints 1. All words are case-insensitive, so treat \\"Word\\" and \\"word\\" as the same word. 2. The input string might contain punctuation. Consider only alphabetic characters and ignore hyphens, apostrophes, and other punctuations. 3. Words can be separated by multiple spaces. # Example ```python text = \\"apple! bear bear. apple, bear. Mango mango mango! apple\\" print(find_highest_frequency_word(text)) # Output: \\"apple\\" text = \\"dog cat! dog. cat? elephant, cat elephant elephant. dog!\\" print(find_highest_frequency_word(text)) # Output: \\"cat\\" text = \\"it\'s a tie tie-break!\\" print(find_highest_frequency_word(text)) # Output: \\"a\\" ``` # Additional Notes - Ensure to handle edge cases like empty strings or strings with no valid words. - Consider using a dictionary or a Counter from the collections module to track word frequencies. - Utilize regular expressions for cleaning up and standardizing the text input.","solution":"import re from collections import Counter def find_highest_frequency_word(text: str) -> str: Finds the word with the highest frequency in the given text. If there\'s a tie, returns the word that comes first lexicographically. # Normalize case and remove punctuation text = text.lower() text = re.sub(r\'[^a-zs]\', \'\', text) # Split the text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Find the word with the highest frequency max_frequency = max(word_counts.values(), default=0) candidates = [word for word, count in word_counts.items() if count == max_frequency] # Return the lexicographically smallest word return min(candidates) if candidates else \\"\\""},{"question":"# Matrix Transposition and Increment Modulo Background Matrix manipulation often involves various operations like transposition, which is useful in numerous fields such as computer graphics, machine learning, and scientific computations. By transposing a matrix, rows become columns and vice versa. Additionally, element-wise operations such as incrementing each element are also common. Objective Implement a function to perform the transposition of an integer matrix and then increment each element by a specific value modulo a given number. Problem Statement Write a function `transpose_and_increment` that takes a 2D list representing an integer matrix, an integer increment value, and an integer modulus. The function should return a new matrix which is the transposition of the input matrix with each element incremented by the given increment value and taken modulo the specified modulus. Function Signature ```python def transpose_and_increment(matrix: List[List[int]], increment: int, modulus: int) -> List[List[int]]: pass ``` Input * `matrix`: A list of lists where each inner list represents a row of the matrix. All rows have the same length. * `increment`: An integer to be added to each element of the matrix after transposition. * `modulus`: An integer specifying the modulus for the result of each incremented element. Output The function returns a 2D list representing the transposed matrix with each element incremented by `increment` and taken modulo `modulus`. Constraints * The input matrix will have at least one row and one column (minimum size 1x1). * The elements of the matrix, increment, and modulus will be integers. Increment and modulus values will be non-negative, with modulus > 0. Requirements * Perform the transposition first: convert rows into columns and vice versa. * After transposition, increment each element by the specified `increment` value. * Take each result modulo the given `modulus`. Example ```python matrix = [ [1, 2, 3], [4, 5, 6] ] increment = 7 modulus = 10 result = transpose_and_increment(matrix, increment, modulus) # Expected Output: # [ # [8, 1], # [9, 2], # [0, 3] # ] ``` In this example: 1. The transposed matrix would be: ``` [ [1, 4], [2, 5], [3, 6] ] ``` 2. Increment each element by 7: ``` [ [8, 11], [9, 12], [10, 13] ] ``` 3. Apply the modulus operation with 10: ``` [ [8, 1], [9, 2], [0, 3] ] ```","solution":"from typing import List def transpose_and_increment(matrix: List[List[int]], increment: int, modulus: int) -> List[List[int]]: # First, transpose the matrix transposed_matrix = list(map(list, zip(*matrix))) # Increment each element and apply modulus result_matrix = [ [(element + increment) % modulus for element in row] for row in transposed_matrix ] return result_matrix"},{"question":"# Coding Challenge: Longest Common Substring **Context**: You are required to find the longest common substring between two input strings. This problem is fundamental in areas such as bioinformatics for DNA sequence analysis and text comparison tools. **Problem Statement**: Write a function, `longest_common_substring`, that takes two strings as input and returns the longest substring that appears in both strings. If there are multiple substrings of the same maximum length, return any one of them. **Function Signature**: ```python def longest_common_substring(s1: str, s2: str) -> str: ``` **Input**: - `s1`: A string containing only alphabetic characters (both uppercase and lowercase). The length of the string is at least 1 and at most 10^3. - `s2`: A string containing only alphabetic characters (both uppercase and lowercase). The length of the string is at least 1 and at most 10^3. **Output**: - A string representing the longest common substring found in both input strings. If no common substring exists, return an empty string. **Constraints**: - The function should be efficient in both time and space complexity, with an emphasis on clarity and performance. - The function should handle cases sensitively, i.e., \'A\' is different from \'a\'. **Examples**: ```python print(longest_common_substring(\\"ABABC\\", \\"BABC\\")) # Output: \\"BABC\\" print(longest_common_substring(\\"abcdef\\", \\"zbcdf\\")) # Output: \\"bcd\\" print(longest_common_substring(\\"abcdef\\", \\"ghijkl\\")) # Output: \\"\\" print(longest_common_substring(\\"ABC\\", \\"abc\\")) # Output: \\"\\" print(longest_common_substring(\\"ABAB\\", \\"BABA\\")) # Output: \\"BAB\\" or \\"ABA\\" ``` **Hints**: 1. Consider using a dynamic programming approach to create a matrix that keeps track of the lengths of common substrings ending at various indices. 2. Ensure that the solution checks both uppercase and lowercase characters properly. **Edge Cases**: 1. The inputs \\"abc\\" and \\"ABC\\" should return an empty string since character cases do not match. 2. The strings \\"a\\" and \\"A\\" should return an empty string. 3. Identical strings should return the whole string itself as the longest common substring. **Testing Your Function**: Make sure your implementation can handle strings of various lengths and character cases, correctly identifying the longest common substring or returning an empty string where appropriate.","solution":"def longest_common_substring(s1: str, s2: str) -> str: Finds the longest common substring between two strings. m, n = len(s1), len(s2) # Create a matrix to hold the lengths of the longest common suffixes lcsuff = [[0] * (n + 1) for _ in range(m + 1)] longest = 0 end_index = 0 # ending index of the longest common substring # Build the lcsuff matrix in bottom-up fashion for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: lcsuff[i][j] = 0 elif s1[i - 1] == s2[j - 1]: lcsuff[i][j] = lcsuff[i - 1][j - 1] + 1 if lcsuff[i][j] > longest: longest = lcsuff[i][j] end_index = i else: lcsuff[i][j] = 0 # If no common substring exists, return an empty string if longest == 0: return \\"\\" # The longest common substring is from index end_index-longest to end_index in s1 return s1[end_index - longest:end_index]"},{"question":"# Question: Generating Combinations of Binary Strings You are tasked with generating all possible combinations of binary strings of a given length. Each binary string should contain only 0s and 1s. Function Signature ```python def generate_binary_strings(length: int) -> list: ``` Input - `length`: an integer representing the length of the binary strings to be generated. Output - A list containing all possible binary strings of the specified length. Each string should be of type `str`. Constraints - The `length` will be between 1 and 10, inclusive. Example ```python >>> generate_binary_strings(2) [\'00\', \'01\', \'10\', \'11\'] >>> generate_binary_strings(1) [\'0\', \'1\'] >>> generate_binary_strings(3) [\'000\', \'001\', \'010\', \'011\', \'100\', \'101\', \'110\', \'111\'] ``` Performance Requirements - Ensure the function runs efficiently for all inputs within the specified constraints. - Aim for clarity and simplicity in the logic for generating binary strings. # Additional Guidelines - No input validation required as it is guaranteed that `length` will be within the specified range. - Consider using a recursive or iterative approach to generate the binary strings. - Provide meaningful comments where necessary to explain your logic.","solution":"def generate_binary_strings(length: int) -> list: Generate all possible combinations of binary strings of a given length. :param length: Length of the binary strings to be generated :return: A list containing all possible binary strings of the specified length def generate(current, remaining_length): if remaining_length == 0: return [current] else: with_zero = generate(current + \\"0\\", remaining_length - 1) with_one = generate(current + \\"1\\", remaining_length - 1) return with_zero + with_one return generate(\\"\\", length)"},{"question":"# Problem Statement You are given an integer array `nums` and an integer `target`. Your task is to write a function `two_sum` that finds two distinct elements in the array whose sum equals `target`. If such a pair exists, return their indices in the form of a list `[index1, index2]` (index1 should be less than index2). If no such pair exists, return an empty list. # Function Signature ```python def two_sum(nums: list[int], target: int) -> list[int]: pass ``` # Input - `nums`: A list of integers `nums` (0 <= len(nums) <= 10^4), and each integer in nums is within the range -10^9 to 10^9. - `target`: An integer `target` within the range -2 * 10^9 to 2 * 10^9. # Output - A list of two integers `[index1, index2]`, where `index1 < index2` and `nums[index1] + nums[index2] == target`. If no such pair exists, return an empty list. # Examples ```python assert two_sum([2, 7, 11, 15], 9) == [0, 1] assert two_sum([3, 2, 4], 6) == [1, 2] assert two_sum([3, 3], 6) == [0, 1] assert two_sum([1, 2, 3, 4, 5], 10) == [] assert two_sum([], 5) == [] ``` # Constraints - Ensure your solution is efficient and handles possible edge cases such as negative numbers or an empty list. - The solution should avoid using external libraries and should focus on core Python capabilities to illustrate understanding of basic algorithms and data structures. # Notes - Consider the time complexity of your solution since the input size can be large. - Think about using hash maps (dictionaries) to optimize the solution and avoid nested loops.","solution":"def two_sum(nums: list[int], target: int) -> list[int]: Finds two distinct elements in the array whose sum equals target. Parameters: nums (list[int]): The input list of integers. target (int): The target sum. Returns: list[int]: Indices of the two numbers such that they add up to target. Returns an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return [] # Example test cases print(two_sum([2, 7, 11, 15], 9)) # Output: [0, 1] print(two_sum([3, 2, 4], 6)) # Output: [1, 2] print(two_sum([3, 3], 6)) # Output: [0, 1] print(two_sum([1, 2, 3, 4, 5], 10)) # Output: [] print(two_sum([], 5)) # Output: []"},{"question":"# Question: Check and Generate ISBN Number Context A publisher needs a software tool to verify and generate valid International Standard Book Numbers (ISBN). The ISBN-10 format is used for books published before 2007 and consists of 9 digits, followed by a check digit. The check digit is calculated using a specific formula to ensure the validity of the ISBN. Task Write a function `validate_and_generate_isbn` that: 1. Takes a string `isbn_number` which is either a 9-digit string (indicating the core of the ISBN) or a 10-digit string (indicating a complete ISBN including check digit). 2. Determines if the provided ISBN number is valid when it includes the check digit, or generates the correct check digit if only 9 digits are provided. The function must: - First validate the input based on length and character restrictions. - If the input is a 10-digit ISBN, validate that the check digit is correct. - If the input is a 9-digit core, compute the check digit and form a valid 10-digit ISBN. - Return a dictionary with key `status` indicating \\"Valid\\" or \\"Invalid\\", and `isbn` indicating the correct/validated ISBN. Input - `isbn_number`: A string of length 9 or 10 consisting only of digits or \'X\' as the last character (for the check digit). Output - A dictionary with keys: - `status`: \\"Valid\\" or \\"Invalid\\" based on the check. - `isbn`: The 10-digit ISBN string which is validated or generated. Performance Requirements - Time Complexity: O(1) (constant time complexity). - Space Complexity: O(1), excluding storage for the input string. Constraints - The 10th character must be a digit or \'X\'. - The use of \'X\' in the string is only valid in the 10th position representing a check digit of 10. - The 9-digit core must consist only of numeric characters. Formulas - For a given ISBN-10 `d1d2d3...d10`, where `d10` can be \'X\': [ text{Check digit} = (1*d1 + 2*d2 + 3*d3 + ... + 10*d10) % 11 ] Examples - For the input `\\"030640615\\"`, the expected output is `{\'status\': \'Valid\', \'isbn\': \'0306406152\'}`. - For the input `\\"0306406152\\"`, the expected output is `{\'status\': \'Valid\', \'isbn\': \'0306406152\'}`. - For the input `\\"030640615X\\"`, the expected output is `{\'status\': \'Invalid\', \'isbn\': \'Invalid\'}`. Implementation You must define the below function: ```python def validate_and_generate_isbn(isbn_number: str) -> dict: # Your code here ``` With the provided guidelines, compose a solution that adheres to the given format and requirements.","solution":"def validate_and_generate_isbn(isbn_number: str) -> dict: if not (len(isbn_number) == 9 or len(isbn_number) == 10): return {\'status\': \'Invalid\', \'isbn\': \'Invalid\'} if len(isbn_number) == 9 and not isbn_number.isdigit(): return {\'status\': \'Invalid\', \'isbn\': \'Invalid\'} if len(isbn_number) == 10: if not isbn_number[:-1].isdigit() or (isbn_number[-1] not in \'0123456789X\'): return {\'status\': \'Invalid\', \'isbn\': \'Invalid\'} def calculate_check_digit(isbn_core): total = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_core)) check_digit = total % 11 return \'X\' if check_digit == 10 else str(check_digit) if len(isbn_number) == 9: check_digit = calculate_check_digit(isbn_number) return {\'status\': \'Valid\', \'isbn\': isbn_number + check_digit} if len(isbn_number) == 10: isbn_core = isbn_number[:-1] provided_check_digit = isbn_number[-1] calculated_check_digit = calculate_check_digit(isbn_core) if provided_check_digit == calculated_check_digit: return {\'status\': \'Valid\', \'isbn\': isbn_number} else: return {\'status\': \'Invalid\', \'isbn\': \'Invalid\'}"},{"question":"# Reorganize Linked List by Odd Even Position Objective: Implement a function that reorganizes a singly linked list by separating nodes positioned at odd indices from those at even indices, then concatenates the even list at the end of the odd list. Context: Linked list manipulations are common in various applications to optimize data organization and access patterns. By rearranging nodes based on their positions, we can explore efficient data reconfiguration techniques. Problem Statement: Given a singly linked list, write a function `reorganize_odd_even` that modifies the list such that all nodes at odd indices come before all nodes at even indices (0-based indexing). The relative ordering among the nodes at odd indices and the nodes at even indices should remain the same as in the original list. Function Signature: ```python def reorganize_odd_even(head: ListNode | None) -> ListNode | None: ``` Input: - `head`: A ListNode representing the head of the singly linked list. Each ListNode has `val` and `next` attributes. Output: - The head of the modified linked list after reordering. Constraints: - The number of nodes in the linked list is in the range [0, 10^4]. - `ListNode.val` can be any integer value. Example: ```python # Example linked list: 1 -> 2 -> 3 -> 4 -> 5 -> None n1 = ListNode(1) n2 = ListNode(2) n3 = ListNode(3) n4 = ListNode(4) n5 = ListNode(5) n1.next = n2 n2.next = n3 n3.next = n4 n4.next = n5 reorganized_head = reorganize_odd_even(n1) # Output should be: 1 -> 3 -> 5 -> 2 -> 4 -> None # Function to print linked list for checking result def print_list(head: ListNode | None) -> None: while head: print(head.val, end=\\" -> \\") head = head.next print(\\"None\\") print_list(reorganized_head) # Output: 1 -> 3 -> 5 -> 2 -> 4 -> None ``` Note: - The input list can be of any length, including 0. - Ensure that all edge cases, such as an empty list and a single element list, are tested for correct behavior. - The solution should reorganize the list in-place without using extra memory for storing nodes. Consider implementing the method efficiently to handle a large number of nodes within permissible operation limits.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorganize_odd_even(head: ListNode | None) -> ListNode | None: if not head or not head.next: return head odd = head even = head.next even_head = even # To connect the end of odd list with the start of even list while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head"},{"question":"# Smallest Missing Positive Integer **Context**: You are tasked with creating a system to identify gaps in sequential data, which is important for data integrity and consistency check tasks. Specifically, you need to find the smallest positive integer missing from an unsorted array of integers. **Objective**: Implement the function `smallest_missing_positive` that finds the smallest missing positive integer from a given list of integers. # Requirements 1. **Input**: - An array `nums` of `n` integers where `0 ≤ n ≤ 10^5`. - The integers can be positive, negative, or zero. 2. **Output**: - An integer representing the smallest positive integer that does not appear in the array. 3. **Constraints**: - The solution must have a time complexity of O(n). - The solution must use constant extra space, O(1). # Function Signature ```python from typing import List def smallest_missing_positive(nums: List[int]) -> int: pass ``` # Example ```python assert smallest_missing_positive([1, 2, 0]) == 3 assert smallest_missing_positive([3, 4, -1, 1]) == 2 assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 assert smallest_missing_positive([]) == 1 assert smallest_missing_positive([1, 1, 1, 1]) == 2 ``` # Implementation Notes - Modify the input array in place to use the index of each element as a hash to record the presence of positive integers. - Iterate multiple times over the array to move elements to their correct positions and to find the missing positive integer without using additional space. - Handle cases with mixed positive, negative, and zero values effectively, ensuring constant space usage.","solution":"from typing import List def smallest_missing_positive(nums: List[int]) -> int: n = len(nums) # Step 1: Mark nums with negative numbers, 0, and numbers larger than n as n+1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark the presence of numbers for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first missing positive number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"# Merge Sort for Custom Data Types Scenario: You are required to implement the Merge Sort algorithm with additional capabilities to handle custom data types and complex sorting criteria provided by user-defined comparator functions. Your implementation should be able to: 1. **Sort Custom Objects**: Sort a list of objects based on various attributes. 2. **Comparator Function**: Use an optional comparator function to dictate the sorting logic. 3. **Stability**: Keep the sort stable, i.e., maintain the relative order of records with equal keys. 4. **Non-Modifying**: Ensure the original input list is not modified and return a new sorted list. Task: Implement the function `custom_merge_sort` with the following signature: ```python from typing import Callable, List, Optional, TypeVar T = TypeVar(\'T\') def custom_merge_sort(collection: List[T], comparator: Optional[Callable[[T, T], bool]] = None) -> List[T] ``` * **Parameters**: - `collection`: A list of objects to be sorted. - `comparator`: An optional custom comparator function that takes two objects and returns True if the first object should come before the second based on custom sorting logic. If not provided, the default sorting logic based on the natural order should be used (similar to `__lt__`). * **Returns**: - A new sorted list based on the given comparator function or natural order. * **Constraints**: - The provided list can contain up to (10^5) objects. - The objects must be comparable either through their natural ordering or via the provided comparator function. * **Example**: ```python class Person: def __init__(self, name: str, age: int): self.name = name self.age = age def __lt__(self, other: \'Person\') -> bool: return self.age < other.age people = [Person(\\"Alice\\", 30), Person(\\"Bob\\", 25), Person(\\"Charlie\\", 35)] custom_merge_sort(people) # Returns: [Person(\\"Bob\\", 25), Person(\\"Alice\\", 30), Person(\\"Charlie\\", 35)] custom_merge_sort(people, comparator=lambda x, y: x.name < y.name) # Returns: [Person(\\"Alice\\", 30), Person(\\"Bob\\", 25), Person(\\"Charlie\\", 35)] ``` Note: - The merge sort algorithm should be implemented recursively or iteratively to accomplish the sorting. - Consider edge cases and validate your implementation with various test cases, including lists with duplicates, empty lists, and lists containing a single element.","solution":"from typing import Callable, List, Optional, TypeVar T = TypeVar(\'T\') def custom_merge_sort(collection: List[T], comparator: Optional[Callable[[T, T], bool]] = None) -> List[T]: if len(collection) <= 1: return collection[:] def merge(left: List[T], right: List[T]) -> List[T]: result = [] i = j = 0 while i < len(left) and j < len(right): if comparator: if comparator(left[i], right[j]): result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 else: if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result mid = len(collection) // 2 left_sorted = custom_merge_sort(collection[:mid], comparator) right_sorted = custom_merge_sort(collection[mid:], comparator) return merge(left_sorted, right_sorted)"},{"question":"# Maze Pathfinding with Backtracking **Objective**: Implement a Maze Pathfinding algorithm using backtracking to find a path from the start position to the end position in a given maze. **Description**: You are required to write a function, `find_path`, which takes a two-dimensional list representing a maze and two tuples representing the start and end positions. The function should return a list of tuples indicating the path from start to end, if a path exists, or an empty list if no path exists. **Function Signature**: ```python def find_path(maze: list, start: tuple, end: tuple) -> list: ``` # Input Format: - A two-dimensional list of integers, where each element is either 0 (walkable path) or 1 (blockage). - Two tuples representing the coordinates of the start and end positions, e.g., `(0, 0)` and `(3, 3)`. # Output Format: - A list of tuples representing the path from the start position to the end position, including both. If no path exists, return an empty list. # Constraints: - The start and end positions will always be within the bounds of the maze. - The start and end positions will always be walkable (i.e., contain a 0). - The function should explore paths in a depth-first manner. - Ensure that the solution avoids infinite loops and handles backtracking efficiently. # Performance Requirements: - The algorithm should effectively navigate the maze using backtracking, considering it operates within the constraints of a potentially large maze (up to 1000x1000 in size). - Aim for an efficient depth-first search that minimizes redundant checks and revisits. # Example: ```python # Example 1 maze1 = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start1 = (0, 0) end1 = (4, 4) assert find_path(maze1, start1, end1) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] # Example 2 maze2 = [ [0, 1, 1], [0, 1, 1], [0, 0, 0] ] start2 = (0, 0) end2 = (2, 2) assert find_path(maze2, start2, end2) == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] # Example 3 maze3 = [ [0, 1, 0], [0, 1, 0], [0, 1, 0] ] start3 = (0, 0) end3 = (2, 2) assert find_path(maze3, start3, end3) == [] ``` # Additional Context: You may assume that the maze is represented by a grid of integers where 0 denotes a walkable cell and 1 denotes a blockage. The start position is always a walkable cell, as is the end position. Consider edge cases where the path is blocked early, such as islands of 0s surrounded by 1s. Efficiently handle memory usage and recursion depth to avoid stack overflow for large mazes. This question tests understanding of depth-first search, backtracking, pathfinding in grids, and handling recursive function constraints.","solution":"def find_path(maze, start, end): Finds a path from start to end in the maze using backtracking. Parameters: maze (list): A 2D list representing the maze where 0 is walkable and 1 is a blockage. start (tuple): The starting position in the maze. end (tuple): The ending position in the maze. Returns: list of tuples: The path from start to end including both, or an empty list if no path exists. if not maze or not start or not end: return [] rows, cols = len(maze), len(maze[0]) path = [] def is_valid_move(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 def backtrack(x, y): if (x, y) == end: path.append((x, y)) return True if is_valid_move(x, y): maze[x][y] = -1 # mark as visited path.append((x, y)) # Explore all four possible directions: right, down, left, up if backtrack(x + 1, y) or backtrack(x, y + 1) or backtrack(x - 1, y) or backtrack(x, y - 1): return True path.pop() maze[x][y] = 0 # unmark as visited return False if backtrack(start[0], start[1]): return path return []"},{"question":"Rotate 2D Matrix You have been provided with a function that rotates a given `n x n` 2D matrix 90 degrees clockwise. Your task is to implement the following functionalities: 1. **Rotate Clockwise**: Modify or implement the `rotate_clockwise` function which takes an `n x n` matrix as input and returns a new matrix that is rotated 90 degrees clockwise. 2. **Rotate Counterclockwise**: Implement a function `rotate_counterclockwise` which takes an `n x n` matrix as input and returns a new matrix that is rotated 90 degrees counterclockwise. 3. **Validate Matrix**: Implement a function `validate_matrix` that ensures the matrix is valid (i.e., it must be square and contain only integers). # Input and Output Formats: **Function 1: Rotate Clockwise** * Input: A 2D list representing the matrix to be rotated (e.g., `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`). * Output: A 2D list representing the rotated matrix (e.g., `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]`). **Function 2: Rotate Counterclockwise** * Input: A 2D list representing the matrix to be rotated (e.g., `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`). * Output: A 2D list representing the rotated matrix (e.g., `[[3, 6, 9], [2, 5, 8], [1, 4, 7]]`). **Function 3: Validate Matrix** * Input: A 2D list representing a matrix (e.g., `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]`). * Output: A boolean indicating whether the matrix is valid (`True` for valid, `False` for invalid). # Constraints: * The input matrix for any function can have dimensions from `1x1` up to `100x100`. * Each element of the matrix is an integer. * The `validate_matrix` function must ensure the matrix is square (i.e., number of rows is equal to the number of columns) and only consists of integers. # Performance Requirements: * Your solution should handle matrix rotations efficiently for matrices up to `100x100`. # Implementation: Implement the following Python functions: ```python def rotate_clockwise(matrix: list) -> list: # Implement the function as described def rotate_counterclockwise(matrix: list) -> list: # Implement the function as described def validate_matrix(matrix: list) -> bool: # Implement the function as described ``` # Example: ```python assert rotate_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] assert rotate_counterclockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[3, 6, 9], [2, 5, 8], [1, 4, 7]] assert validate_matrix([[1, 2], [3, 4]]) == True assert validate_matrix([[1, 2, 3], [4, 5, 6]]) == False assert validate_matrix([[1, 2], [3, \'a\']]) == False ```","solution":"def rotate_clockwise(matrix: list) -> list: Rotates the input n x n matrix 90 degrees clockwise. n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(matrix: list) -> list: Rotates the input n x n matrix 90 degrees counterclockwise. n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def validate_matrix(matrix: list) -> bool: Validates that the input matrix is an n x n matrix and contains only integers. n = len(matrix) for row in matrix: if len(row) != n: return False for element in row: if not isinstance(element, int): return False return True"},{"question":"# Binary Tree Level Order Traversal You have been provided with a basic binary tree structure. Your task is to implement a level order traversal (also known as breadth-first traversal) of the binary tree. The output should be a list of lists, where each sublist represents the nodes at that level of the tree from left to right. Task 1. Implement a method to perform level order traversal on a binary tree. 2. Ensure the method handles various edge cases, such as an empty tree. Input and Output * **Input**: A `TreeNode` instance representing the root of the binary tree. * **Output**: A list of lists with integers, where each sublist represents the nodes at that level in the tree. Constraints 1. The nodes of the binary tree contain integer values. 2. Handle large trees efficiently, ensuring the level order traversal executes in a reasonable time frame. 3. Ensure the solution is robust against varying tree structures (balanced, unbalanced, etc.). Performance Requirements * The execution should handle trees with up to 10,000 nodes efficiently. Example Scenario Consider a scenario where you want to traverse the following binary tree: ``` 3 / 9 20 / 15 7 ``` The level order traversal for this tree should be: ``` [[3], [9, 20], [15, 7]] ``` Implementation Complete the function `level_order_traversal` in the `BinaryTree` class. You can use a queue to facilitate the level order traversal process. ```python from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root=None): self.root = root def level_order_traversal(self) -> List[List[int]]: if not self.root: return [] levels = [] queue = deque([self.root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) levels.append(current_level) return levels # Example usage: # root = TreeNode(3) # root.left = TreeNode(9) # root.right = TreeNode(20, TreeNode(15), TreeNode(7)) # tree = BinaryTree(root) # print(tree.level_order_traversal()) # Output: [[3], [9, 20], [15, 7]] ```","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: Optional[TreeNode] = None): self.root = root def level_order_traversal(self) -> List[List[int]]: if not self.root: return [] levels = [] queue = deque([self.root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) levels.append(current_level) return levels"},{"question":"# Problem Statement Context: You have been assigned the task of creating a program that can transform a given sentence into a simple cipher text by shifting each letter by a fixed number of positions in the alphabet. Instructions: 1. **Modify the `caesar_cipher` function**: - This function should take a string `sentence` and an integer `shift`. - The function should shift each letter in the `sentence` by the `shift` value. The shift value can be positive or negative. - Non-letter characters should remain unchanged. - Ensure that the function properly wraps around the alphabet (i.e., shifting \'z\' by 1 should result in \'a\' and shifting \'a\' by -1 should result in \'z\'). 2. **Implement a new function `caesar_decipher`**: - This function should decrypt a given cipher text back into the original sentence. - Input: A string `cipher_text` and the integer `shift` value used to encrypt it. - Output: The decrypted original string. Specifications: - **Function Signatures**: ```python def caesar_cipher(sentence: str, shift: int) -> str: ... def caesar_decipher(cipher_text: str, shift: int) -> str: ... ``` - **Input/Output Examples**: ```python >>> caesar_cipher(\\"hello world\\", 3) \'khoor zruog\' >>> caesar_cipher(\\"abc xyz\\", 2) \'cde zab\' >>> caesar_cipher(\\"Hello, World!\\", 5) \'Mjqqt, Btwqi!\' >>> caesar_decipher(\\"khoor zruog\\", 3) \'hello world\' >>> caesar_decipher(\\"cde zab\\", 2) \'abc xyz\' >>> caesar_decipher(\\"Mjqqt, Btwqi!\\", 5) \'Hello, World!\' ``` - **Constraints**: - `sentence` and `cipher_text` are strings containing English letters (both uppercase and lowercase), spaces, and punctuation marks. - `shift` is an integer which can be positive or negative. - **Performance Requirements**: - Ensure the implementation efficiently handles the letter shifting operations. - Aim for O(n) time complexity, where `n` is the length of the sentence or cipher_text being processed.","solution":"def caesar_cipher(sentence: str, shift: int) -> str: def shift_char(c, shift): if c.isalpha(): start = ord(\'A\') if c.isupper() else ord(\'a\') return chr((ord(c) - start + shift) % 26 + start) return c return \'\'.join(shift_char(c, shift) for c in sentence) def caesar_decipher(cipher_text: str, shift: int) -> str: return caesar_cipher(cipher_text, -shift)"},{"question":"# Problem Statement You are required to implement a function that solves a common problem in competitive programming: finding the k-th smallest element in an unsorted list. Your solution should demonstrate good understanding of selection algorithms and efficient handling of large data sets. # K-th Smallest Element # Objective: Implement a function `kth_smallest_element(data: list, k: int) -> int` that finds the k-th smallest element in a given list of integers. Ensure your implementation is efficient and handles all specified constraints. # Requirements: 1. **Input**: * A list `data` of integers with size `n (1 <= n <= 10^5)`. * An integer `k (1 <= k <= n)`, representing the 1-based position of the element to find. 2. **Output**: * The k-th smallest element in the list. 3. **Constraints**: * Your implementation should not modify the original list. * Aim for an expected time complexity of O(n). 4. **Edge cases**: * Handle cases where n = 1 or k = 1 appropriately. # Function Signature: ```python def kth_smallest_element(data: list, k: int) -> int: pass ``` # Example: ```python # Example 1: data = [7, 10, 4, 3, 20, 15] k = 3 # Output: 7 (The 3rd smallest element is 7) # Example 2: data = [7, 10, 4, 3, 20, 15] k = 4 # Output: 10 (The 4th smallest element is 10) # Example 3: data = [1] k = 1 # Output: 1 (The only element is 1) # Example 4: data = [5, 2, 8, 6, 3] k = 2 # Output: 3 (The 2nd smallest element is 3) ``` # Notes: 1. Your function should be able to process lists up to the maximum constraint size efficiently. 2. Consider using a selection algorithm like Quickselect to achieve the desired time complexity.","solution":"import random def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quickselect(arr, low, high, k): if low == high: return arr[low] pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pi = partition(arr, low, high) if k == pi: return arr[k] elif k < pi: return quickselect(arr, low, pi - 1, k) else: return quickselect(arr, pi + 1, high, k) def kth_smallest_element(data: list, k: int) -> int: This function finds the k-th smallest element in the given list `data`. It uses the Quickselect algorithm to achieve an average case time complexity of O(n). # Copy the original list to avoid modifying it data_copy = list(data) return quickselect(data_copy, 0, len(data_copy) - 1, k - 1)"},{"question":"# Question: Implement a Modified K-Means Clustering Algorithm **Context**: The K-Means clustering algorithm is used to partition a dataset into K distinct, non-overlapping subsets (clusters). This problem introduces a modification of K-Means where instead of specifying the number of clusters (K) beforehand, the algorithm dynamically decides K based on a given maximum allowable distance (threshold) from a point to the centroid of its assigned cluster. **Task**: You are required to implement a function `dynamic_k_means` that dynamically determines the number of clusters while ensuring that the distance between any point and the centroid of its assigned cluster does not exceed a given threshold. **Function Signature and Inputs**: ```python import numpy as np from typing import Tuple, List def dynamic_k_means( data_points: np.ndarray, distance_threshold: float, max_iterations: int = 100, ) -> Tuple[int, List[np.ndarray], np.ndarray]: ... ``` **Input Description**: * `data_points`: A 2D numpy array (NxM) where N is the number of data points and M is the number of features. * `distance_threshold`: A float representing the maximum allowable distance from a point to the centroid of its assigned cluster. * `max_iterations`: An optional integer indicating the maximum number of iterations. **Output Description**: * Return a tuple containing: - The number of clusters (int), - A list of numpy arrays, where each numpy array contains the indices of data points belonging to one cluster, - A 2D numpy array (KxM), where each row represents the centroid of a cluster. **Constraints**: - Ensure the algorithm converges within the specified number of iterations. - Assume the `data_points` will have at least one point. - Perform all computations using double precision. - The initial centroids can be chosen randomly from the data points. **Additional Notes**: - Handle edge cases where no clusters can be formed within the given threshold. - Implement a helper function to calculate the Euclidean distance between points if necessary. - You may make use of numpy operations to optimize the performance of your implementation. **Example**: ```python data_points = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]) distance_threshold = 3.0 num_clusters, clusters, centroids = dynamic_k_means(data_points, distance_threshold) print(num_clusters) # Example output: 3 print(clusters) # Example output: [array([0, 1, 4]), array([2, 3]), array([5])] print(centroids) # Example output: array([[1.16666667, 1.46666667], # [6.5, 8.0], # [9.0, 11.0]]) ```","solution":"import numpy as np from typing import Tuple, List def euclidean_distance(point1: np.ndarray, point2: np.ndarray) -> float: return np.linalg.norm(point1 - point2) def dynamic_k_means( data_points: np.ndarray, distance_threshold: float, max_iterations: int = 100, ) -> Tuple[int, List[np.ndarray], np.ndarray]: # Step 1: Initialize the first centroid randomly from the data points. n_points, n_features = data_points.shape centroids = [data_points[np.random.choice(range(n_points))]] for _ in range(max_iterations): clusters = [[] for _ in range(len(centroids))] new_centroids = [] # Step 2: Assign each point to the nearest centroid. for idx, point in enumerate(data_points): distances = [euclidean_distance(point, centroid) for centroid in centroids] min_dist = min(distances) if min_dist <= distance_threshold: clusters[distances.index(min_dist)].append(idx) else: # If no existing centroid meets the distance threshold, create a new cluster. centroids.append(point) clusters.append([idx]) # Step 3: Compute new centroids for each cluster. for cluster in clusters: if cluster: # Avoid empty clusters. cluster_points = data_points[cluster] new_centroids.append(np.mean(cluster_points, axis=0)) # Step 4: Check for convergence. if np.array_equal(centroids, new_centroids): break centroids = new_centroids return len(centroids), [np.array(cluster) for cluster in clusters], np.array(centroids)"},{"question":"# Question: Implement a Circular Buffer Class You are required to implement a Python class that represents a circular buffer (or ring buffer). A circular buffer is a fixed-size data structure that operates in a FIFO (First In, First Out) manner, where the end of the buffer wraps around to the beginning when it is full. Requirements: 1. Implement a class named `CircularBuffer`. 2. Add an `__init__` method that initializes the buffer with a given size and sets the appropriate pointers for insertion and extraction. 3. Implement a method `write(value: int) -> None` that inserts a value into the buffer. If the buffer is full, it should overwrite the oldest data. 4. Implement a method `read() -> int` that retrieves and removes the oldest value from the buffer. If the buffer is empty, it should raise an exception. 5. Handle edge cases such as reading from an empty buffer and writing into a full buffer gracefully. Input: * For `write`: a single integer `value` to insert into the buffer. * For `read`: no input is required. Output: * For `write`: nothing to return (implicit `None`). * For `read`: returns an integer which is the oldest value in the buffer. Constraints: * The buffer size will be a positive integer. * The values written to the buffer will be integers. Example: ```python >>> buffer = CircularBuffer(3) >>> buffer.write(1) >>> buffer.write(2) >>> buffer.write(3) >>> buffer.read() 1 >>> buffer.write(4) >>> buffer.read() 2 >>> buffer.read() 3 >>> buffer.read() Traceback (most recent call last): ... IndexError: Buffer is empty ``` Your implementation should efficiently manage the circular nature of the buffer and handle the operations of reading and writing correctly.","solution":"class CircularBuffer: def __init__(self, size: int): self.size = size self.buffer = [None] * size self.start = 0 self.end = 0 self.count = 0 def write(self, value: int) -> None: self.buffer[self.end] = value if self.count == self.size: self.start = (self.start + 1) % self.size else: self.count += 1 self.end = (self.end + 1) % self.size def read(self) -> int: if self.count == 0: raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.start] self.buffer[self.start] = None self.start = (self.start + 1) % self.size self.count -= 1 return value"},{"question":"# Coding Question: Island Perimeter Calculation Scenario You are working on a geographical information system that models a series of islands within a grid. Each cell in the grid is either water or land. Your task is to implement a function `calculate_island_perimeter` that calculates the perimeter of the island defined by land cells within the grid. Task Implement the function `calculate_island_perimeter` in Python that computes the perimeter of the island based on the specified parameters. Function Signature ```python def calculate_island_perimeter(grid: List[List[int]]) -> int: ``` Parameters * `grid` (List[List[int]]): A 2D list where each element is either 0 (water) or 1 (land). Returns * `int`: The perimeter of the island formed by the land cells in the grid. Constraints * The grid is completely surrounded by water. * There is exactly one island (i.e., one or more connected land cells). * The grid dimensions are at most 100 x 100. Example ```python # Example 1 grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ] result = calculate_island_perimeter(grid) # Output: 16 # Example 2 grid = [ [1] ] result = calculate_island_perimeter(grid) # Output: 4 # Example 3 grid = [ [1, 0] ] result = calculate_island_perimeter(grid) # Output: 4 ``` Explanation To calculate the perimeter: 1. Initialize the perimeter count to 0. 2. Iterate through each cell in the grid. 3. For each land cell: - Add 4 to the perimeter for each land cell. - Subtract 2 for each edge shared with another land cell. Make sure to correctly handle edges and boundaries of the grid.","solution":"def calculate_island_perimeter(grid): Returns the perimeter of the island defined by land cells in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: perimeter += 4 if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"# Coding Question Context You are given a dictionary of word synonyms. Each key in the dictionary is a word, and the corresponding value is a list of synonyms for that word. Your task is to implement a function that finds the shortest transformation sequence from a start word to an end word, where each intermediate word must be a synonym of the previous word. Problem Statement Implement a function `shortest_synonym_transformation` that takes a dictionary of synonyms, a start word, and an end word as input and returns the shortest sequence of words (as a list) transforming the start word to the end word using the synonyms provided. If no such sequence exists, return an empty list. ```python def shortest_synonym_transformation(synonyms, start, end): Finds the shortest sequence of words transforming the start word to the end word using a provided dictionary of synonyms. Parameters: synonyms (dict): The dictionary where each key is a word and the value is a list of synonyms. start (str): The starting word. end (str): The target word. Returns: List[str]: The shortest transformation sequence, or an empty list if no sequence exists. pass ``` # Constraints 1. The dictionary is non-empty and contains valid synonyms. 2. The start and end words exist within the synonym dictionary. 3. The transformation sequence must be valid, with each word being a synonym of the previous one. Example ```python synonyms = { \\"hit\\": [\\"hot\\", \\"hat\\"], \\"hot\\": [\\"dot\\", \\"lot\\"], \\"dot\\": [\\"dog\\"], \\"dog\\": [\\"cog\\", \\"dot\\"], \\"lot\\": [\\"log\\"], \\"log\\": [\\"cog\\"] } start = \\"hit\\" end = \\"cog\\" result = shortest_synonym_transformation(synonyms, start, end) # A possible output sequence might be [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"] assert result == [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] or result == [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"] ``` # Performance Requirements Your solution should efficiently compute the shortest transformation sequence using appropriate algorithms and data structures. Consider an optimal solution in terms of time and space complexity for searching through the synonym relationships, possibly around O(V + E) where V is the number of words and E is the number of synonym relationships in the graph.","solution":"from collections import deque def shortest_synonym_transformation(synonyms, start, end): if start == end: return [start] queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for synonym in synonyms.get(current_word, []): if synonym == end: return path + [synonym] if synonym not in visited: visited.add(synonym) queue.append((synonym, path + [synonym])) return [] # Example usage: synonyms = { \\"hit\\": [\\"hot\\", \\"hat\\"], \\"hot\\": [\\"dot\\", \\"lot\\"], \\"dot\\": [\\"dog\\"], \\"dog\\": [\\"cog\\", \\"dot\\"], \\"lot\\": [\\"log\\"], \\"log\\": [\\"cog\\"] } start = \\"hit\\" end = \\"cog\\" result = shortest_synonym_transformation(synonyms, start, end) print(result) # Example Output: [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] or [\\"hit\\", \\"hot\\", \\"lot\\", \\"log\\", \\"cog\\"]"},{"question":"# Context You participated in a coding challenge where you encountered a problem involving prime factorization. The task evaluates your ability to implement efficient algorithms to determine the prime factors of a given number and perform arithmetic operations on these factors. # Problem Statement Write a Python function called `smallest_multiple` that takes an integer `n` as input and returns the smallest positive number that is evenly divisible by all numbers from 1 to `n`. # Input - An integer `n` where `1 <= n <= 40`. # Output - An integer representing the smallest number that is evenly divisible by all numbers from 1 to `n`. # Function Signature ```python def smallest_multiple(n: int) -> int: pass ``` # Constraints - The value of `n` will be within the range where the product of primes and their powers remains computable without overflowing typical integer limits in Python. - Handle edge cases where `n` is very small (e.g., 1, 2). # Example ```python assert smallest_multiple(10) == 2520 # Smallest multiple of all numbers from 1 to 10 assert smallest_multiple(5) == 60 # Smallest multiple of all numbers from 1 to 5 assert smallest_multiple(1) == 1 # Smallest multiple of all numbers from 1 to 1 assert smallest_multiple(20) == 232792560 # Efficient handling of higher values ``` # Guidelines 1. Write a function that calculates the Least Common Multiple (LCM) of numbers from 1 to `n`. 2. Utilize the relationship between LCM and Greatest Common Divisor (GCD) to optimize the calculation. 3. Carefully handle the multiplication of large numbers to avoid overflow issues. 4. Return the smallest number that is evenly divisible by all numbers from 1 to `n`. Your function will be tested on various input values, including edge cases and relatively large values within the given constraints, so ensure your implementation is both correct and efficient.","solution":"import math def lcm(a, b): Returns the least common multiple of a and b. return abs(a*b) // math.gcd(a, b) def smallest_multiple(n: int) -> int: Returns the smallest positive number that is evenly divisible by all numbers from 1 to n. smallest_mult = 1 for i in range(1, n+1): smallest_mult = lcm(smallest_mult, i) return smallest_mult"},{"question":"Task: Course Scheduling You are tasked with developing a function that determines whether all courses in a given list can be completed based on their prerequisite courses. A course that has a prerequisite cannot be taken until the prerequisite course is completed. The function should return `True` if it is possible to complete all courses; otherwise, return `False`. # Function Signature ```python def can_finish_courses(num_courses: int, prerequisites: list[tuple[int, int]]) -> bool: ``` # Input * `num_courses` (int): An integer representing the total number of courses. Courses are labeled from `0` to `num_courses-1`. * `prerequisites` (List[Tuple[int, int]]): A list of pairs `(a, b)` representing that course `a` has `b` as a prerequisite. # Output * Returns `True` if all courses can be completed; otherwise, `False`. # Examples Example 1: ```python num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2)] print(can_finish_courses(num_courses, prerequisites)) # Output: True ``` Example 2: ```python num_courses = 4 prerequisites = [(1, 0), (2, 1), (3, 2), (1, 3)] print(can_finish_courses(num_courses, prerequisites)) # Output: False ``` # Constraints * `1 <= num_courses <= 20` * `0 <= len(prerequisites) <= (num_courses * (num_courses - 1)) / 2` * Prerequisites are defined as tuples where `0 <= a, b < num_courses`. # Notes You should use a graph-based approach to solve this problem, typically leveraging topological sorting or cycle detection algorithms. The constraints ensure that the algorithms will run efficiently within given limits. Any optimizations or alternative methods should be well-documented.","solution":"def can_finish_courses(num_courses: int, prerequisites: list[tuple[int, int]]) -> bool: from collections import defaultdict, deque def is_cyclic(graph, course, visited, rec_stack): visited[course] = True rec_stack[course] = True for neighbor in graph[course]: if not visited[neighbor]: if is_cyclic(graph, neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[course] = False return False # Create an adjacency list to represent the graph graph = defaultdict(list) for course, prereq in prerequisites: graph[prereq].append(course) visited = [False] * num_courses rec_stack = [False] * num_courses for course in range(num_courses): if not visited[course]: if is_cyclic(graph, course, visited, rec_stack): return False return True"},{"question":"# Coding Assessment Question You are developing a data analysis tool that requires computing various statistical measures. One of the tasks involves processing a dataset of integer values to calculate the median effectively, even if new data points are inserted incrementally. **Task**: Implement a `MedianFinder` class with the following methods: 1. `add_num(num: int) -> None`: Adds a number into the data structure. 2. `find_median() -> float`: Returns the median of all elements so far. The median is the middle value of a dataset. If the dataset has an even number of elements, the median is the average of the two middle elements. Class Signature ```python class MedianFinder: def __init__(self): pass def add_num(self, num: int) -> None: pass def find_median(self) -> float: pass ``` Constraints * The number of elements inserted using `add_num` can range from 1 to `10^6`. * All integer inputs for `num` will be between `-10^6` and `10^6`. * The `find_median` method will be called at least once for each test case. Performance Requirements * Both methods must operate efficiently to handle the upper limit of constraints. # Example Example Input ```python # Create a new MedianFinder instance median_finder = MedianFinder() # Adding numbers median_finder.add_num(1) median_finder.add_num(3) median_finder.add_num(6) median_finder.add_num(7) median_finder.add_num(10) median_finder.add_num(12) # Finding the median print(median_finder.find_median()) # Output: 6.5 ``` Explanation After adding the numbers `[1, 3, 6, 7, 10, 12]`, the sorted order is `[1, 3, 6, 7, 10, 12]`, and the median is `(6 + 7) / 2 = 6.5`. Your task is to implement the `MedianFinder` class considering edge cases, performance constraints, and efficiency as described.","solution":"import heapq class MedianFinder: def __init__(self): # max heap to store the lower half elements self.lower_half = [] # min heap to store the upper half elements self.upper_half = [] def add_num(self, num: int) -> None: # Add to max heap (as negative to act like a max heap) heapq.heappush(self.lower_half, -num) # Make sure the largest number in lower_half is smaller than the smallest number in upper_half if self.lower_half and self.upper_half and (-self.lower_half[0] > self.upper_half[0]): heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) # Balance the heaps, so that lower_half can have at most one more element than upper_half if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) if len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Problem Statement You are given a list of unique integers and an integer `k`. Your task is to compute the maximum product of `k` distinct integers selected from the given list. # Task Implement a function `max_product_of_k_elements` that takes a list of integers `nums` and an integer `k` as input, and outputs the maximum product of any `k` distinct integers from the list. # Input * A list of unique integers `nums` (1 ≤ len(nums) ≤ 100, -1000 ≤ nums[i] ≤ 1000). * An integer `k` (1 ≤ k ≤ len(nums)). # Output * An integer which is the maximum product of `k` distinct integers from the list. # Example ```python def max_product_of_k_elements(nums: List[int], k: int) -> int: pass # Example nums = [1, 2, 3, 4, 5] k = 3 print(max_product_of_k_elements(nums, k)) # Expected Output: 60 (i.e., 3 * 4 * 5) nums = [-10, -10, 5, 2] k = 3 print(max_product_of_k_elements(nums, k)) # Expected Output: 500 (i.e., -10 * -10 * 5) nums = [1, 3, 5, 7] k = 4 print(max_product_of_k_elements(nums, k)) # Expected Output: 105 (i.e., 1 * 3 * 5 * 7) ``` # Constraints: * The function should handle the product of any combination of integers in the given list. * Consider performance and optimization for edge cases, especially when dealing with negative numbers. * Avoid floating-point precision issues by using integer arithmetic where possible. # Notes: * Ensure the function correctly computes the product of the largest possible `k` integers from the list. * Special consideration should be given to lists containing both positive and negative numbers, as the largest product may involve negative numbers.","solution":"from itertools import combinations from typing import List def max_product_of_k_elements(nums: List[int], k: int) -> int: Computes the maximum product of k distinct integers from the list nums. # Generate all possible combinations of k elements from nums all_combinations = combinations(nums, k) # Initialize the maximum product to be the smallest possible integer value max_product = float(\'-inf\') # Iterate over each combination and calculate the product for combo in all_combinations: product = 1 for number in combo: product *= number # Update max_product if the current product is greater if product > max_product: max_product = product return max_product"},{"question":"Problem Statement You are tasked with designing a function that finds the shortest path in a weighted directed graph. The graph is represented as an adjacency list, where each node has a list of tuples. Each tuple consists of a neighboring node and the weight of the edge to that node. # Function to Implement ```python def shortest_path(graph, start_node, end_node): Find the shortest path in a weighted directed graph. @param graph: Dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight). @param start_node: The node to start the path from. @param end_node: The node to end the path at. @return: A tuple containing the total cost of the shortest path and the path itself as a list of nodes. If there is no path from start_node to end_node, return (float(\'inf\'), []). # Your code here pass ``` # Input and Output Formats Input - `graph`: A dictionary where the keys are nodes and the values are lists of tuples representing the neighboring nodes and edge weights. - `start_node`: The starting node for finding the shortest path. - `end_node`: The ending node for finding the shortest path. Output - A tuple containing: 1. The total cost of the shortest path from `start_node` to `end_node`. 2. The shortest path itself as a list of nodes. If there is no path from `start_node` to `end_node`, return `(float(\'inf\'), [])`. # Constraints - The graph is a directed weighted graph with non-negative edge weights. - All nodes are unique. - The number of nodes and edges in the graph will be between 1 and 1000. # Example ```python # Example Input: graph = { \'A\': [(\'B\', 2), (\'C\', 5)], \'B\': [(\'C\', 1), (\'D\', 4)], \'C\': [(\'D\', 2)], \'D\': [] } start_node = \'A\' end_node = \'D\' # Example Output: # (5, [\'A\', \'B\', \'C\', \'D\']) # The shortest path from node \'A\' to node \'D\' has a total cost of 5 and the path is [\'A\', \'B\', \'C\', \'D\']. ``` # Notes - You can assume that the graph does not have any negative weight cycles. - If there are multiple paths with the same minimum cost, return any one of them. - Use a standard shortest path algorithm like Dijkstra’s algorithm to solve this problem.","solution":"import heapq def shortest_path(graph, start_node, end_node): Find the shortest path in a weighted directed graph. @param graph: Dictionary representing the adjacency list of the graph. Each key is a node, and the value is a list of tuples (neighbor, weight). @param start_node: The node to start the path from. @param end_node: The node to end the path at. @return: A tuple containing the total cost of the shortest path and the path itself as a list of nodes. If there is no path from start_node to end_node, return (float(\'inf\'), []). # Priority queue to keep track of nodes to explore pq = [(0, start_node, [])] # Dictionary to store the best cost to reach each node min_cost = {start_node: 0} while pq: current_cost, current_node, path = heapq.heappop(pq) # If we\'ve reached the end_node, return the result if current_node == end_node: return (current_cost, path + [current_node]) # Continue to its neighbors for neighbor, weight in graph.get(current_node, []): total_cost = current_cost + weight if neighbor not in min_cost or total_cost < min_cost[neighbor]: min_cost[neighbor] = total_cost heapq.heappush(pq, (total_cost, neighbor, path + [current_node])) # If there\'s no path from start_node to end_node return (float(\'inf\'), [])"},{"question":"Palindrome Check for a Product of Numbers **Objective**: Write a function to determine if the product of two given positive integers is a palindrome. **Scenario**: In computational mathematics, it is often useful to check certain properties of numbers formed by arithmetic operations on given inputs. Given two integers `a` and `b`, you need to check if the product of these numbers is a palindrome. # Function Signature ```python def is_palindromic_product(a: int, b: int) -> bool: This function returns True if the product of `a` and `b` is a palindrome, otherwise False. Parameters: a (int): A positive integer. b (int): A positive integer. Returns: bool: True if the product of `a` and `b` is a palindrome, otherwise False. pass ``` # Input - `a` (integer): A positive integer (1 ≤ a ≤ 100,000). - `b` (integer): A positive integer (1 ≤ b ≤ 100,000). # Output - Returns a boolean: `True` if the product of `a` and `b` is a palindrome, `False` otherwise. # Constraints - A palindrome is a number that reads the same backward as forward (e.g., 121, 12321). - The multiplication of (a) and (b) could result in large numbers; handle them appropriately. # Example ```python >>> is_palindromic_product(11, 11) True >>> is_palindromic_product(123, 321) False >>> is_palindromic_product(111, 121) True >>> is_palindromic_product(10, 90) False ``` # Notes 1. Handle the conversion to string efficiently to check if the product is a palindrome. 2. The function should handle the upper limit inputs quickly and efficiently. **Write your solution below:** ```python def is_palindromic_product(a: int, b: int) -> bool: product = a * b string_product = str(product) return string_product == string_product[::-1] ```","solution":"def is_palindromic_product(a: int, b: int) -> bool: This function returns True if the product of `a` and `b` is a palindrome, otherwise False. Parameters: a (int): A positive integer. b (int): A positive integer. Returns: bool: True if the product of `a` and `b` is a palindrome, otherwise False. product = a * b string_product = str(product) return string_product == string_product[::-1]"},{"question":"# Problem Statement You are given a list of integers representing the scores of different players in a game. Your task is to determine the highest unique score among them. If there is no unique score, return `-1`. # Function Signature ```python def highest_unique_score(scores: List[int]) -> int: ``` # Input A list `scores` of integers: * `0 ≤ len(scores) ≤ 1000` * `0 ≤ scores[i] ≤ 1000`, representing individual scores of players. # Output * Return an integer representing the highest unique score. If no unique score exists, return `-1`. # Example ```python assert highest_unique_score([4, 10, 5, 4, 2, 10]) == 5 assert highest_unique_score([1, 1, 2, 2, 3, 3]) == -1 ``` # Constraints * The solution should efficiently handle both the time complexity for larger inputs and consider edge cases such as empty lists. # Note Use a frequency counter to determine the uniqueness of each score. # Hints * Use the `collections.Counter` class to count the occurrences of each score. * Identify unique scores by filtering counts equal to one. * Use the `max` function to find the highest score among the unique ones.","solution":"from typing import List from collections import Counter def highest_unique_score(scores: List[int]) -> int: Returns the highest unique score from the list of scores. If there is no unique score, return -1. score_count = Counter(scores) unique_scores = [score for score, count in score_count.items() if count == 1] if not unique_scores: return -1 return max(unique_scores)"},{"question":"# Scenario You are working on developing a library management system for a large institution. Your task is to create a function that manages book loans, ensuring no book is loaned out when it is already borrowed by another user. Additionally, you need to incorporate error handling for invalid user or book IDs, and ensure the system can handle multiple users borrowing and returning books concurrently. # Task Implement a class `Library` with methods to handle book loans and returns. Your class needs to: 1. Maintain a record of books and their availability status. 2. Allow users to borrow books if they are available. 3. Allow users to return books they have borrowed. 4. Handle error cases such as non-existent book IDs or user IDs. 5. Manage concurrent book borrow and return operations. # Class Structure ```python class Library: def __init__(self): # Your implementation here def add_book(self, book_id: str) -> None: # Add a new book to the library def register_user(self, user_id: str) -> None: # Register a new user in the library system def borrow_book(self, user_id: str, book_id: str) -> str: # Allow a registered user to borrow a book, ensuring its availability def return_book(self, user_id: str, book_id: str) -> str: # Allow a registered user to return a borrowed book ``` # Explanation 1. **add_book(book_id)**: Adds a book to the library\'s collection using a unique book identifier. 2. **register_user(user_id)**: Registers a user in the system using a unique user identifier. 3. **borrow_book(user_id, book_id)**: Allows a registered user to borrow a book if it’s available. Returns a message indicating success or the nature of the failure. 4. **return_book(user_id, book_id)**: Allows a registered user to return a book they have borrowed. Returns a message indicating success or the nature of the failure. # Constraints - You can assume book IDs and user IDs are unique strings. - Handle at most 10,000 concurrent book loans. - Ensure thread safety for concurrent operations. # Example ```python library = Library() library.add_book(\\"book1\\") library.register_user(\\"user1\\") print(library.borrow_book(\\"user1\\", \\"book1\\")) # Should print a success message print(library.borrow_book(\\"user1\\", \\"book1\\")) # Should print an error message indicating the book is already borrowed print(library.return_book(\\"user1\\", \\"book1\\")) # Should print a success message print(library.return_book(\\"user1\\", \\"book1\\")) # Should print an error message indicating the book is not borrowed ``` # Notes - Consider using synchronization mechanisms such as threading locks to handle concurrent operations. - Ensure your solution is optimized for performance and scalability. - Use appropriate exception handling to manage invalid operations.","solution":"import threading class Library: def __init__(self): self.books = {} self.users = set() self.lock = threading.Lock() def add_book(self, book_id: str) -> None: with self.lock: if book_id not in self.books: self.books[book_id] = None # None means book is available def register_user(self, user_id: str) -> None: with self.lock: self.users.add(user_id) def borrow_book(self, user_id: str, book_id: str) -> str: with self.lock: if user_id not in self.users: return \\"User ID does not exist\\" if book_id not in self.books: return \\"Book ID does not exist\\" if self.books[book_id] is not None: return \\"Book is already borrowed\\" self.books[book_id] = user_id return \\"Book borrowed successfully\\" def return_book(self, user_id: str, book_id: str) -> str: with self.lock: if user_id not in self.users: return \\"User ID does not exist\\" if book_id not in self.books: return \\"Book ID does not exist\\" if self.books[book_id] != user_id: return \\"Book not borrowed by user\\" self.books[book_id] = None return \\"Book returned successfully\\""},{"question":"# Question You have been given the task to implement several data structure manipulation functions that involve linked lists. These functions should include operations such as reversing, detecting cycles, and merging sorted lists. Below is the detailed description of the functions you need to implement. 1. **Reverse Linked List**: Write a function `reverse_linked_list(head: ListNode) -> ListNode` that reverses a linked list. 2. **Detect Cycle**: Write a function `detect_cycle(head: ListNode) -> bool` that detects if there is a cycle in a linked list. 3. **Merge Sorted Lists**: Write a function `merge_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode` that merges two sorted linked lists into one sorted linked list. 4. **Remove Duplicates**: Write a function `remove_duplicates(head: ListNode) -> ListNode` that removes duplicate values from a sorted linked list. 5. **Find Middle Node**: Write a function `find_middle_node(head: ListNode) -> ListNode` that finds the middle node of a linked list. Ensure your functions handle edge cases and are optimized for performance where possible. Below are the constraints and expected inputs/outputs for each function: 1. **Reverse Linked List**: - **Input**: `head` (a ListNode representing the head of the linked list). - **Output**: The head of the reversed linked list. 2. **Detect Cycle**: - **Input**: `head` (a ListNode representing the head of the linked list). - **Output**: `True` if there is a cycle, `False` otherwise. 3. **Merge Sorted Lists**: - **Input**: `l1` (a ListNode representing the head of the first sorted linked list), `l2` (a ListNode representing the head of the second sorted linked list). - **Output**: The head of the merged sorted linked list. 4. **Remove Duplicates**: - **Input**: `head` (a ListNode representing the head of the sorted linked list). - **Output**: The head of the linked list with duplicates removed. 5. **Find Middle Node**: - **Input**: `head` (a ListNode representing the head of the linked list). - **Output**: The middle node of the linked list. In case of an even number of nodes, return the second middle node. You need to define the `ListNode` class as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Provide complete implementations of these functions with proper error handling, taking care of edge cases, performance optimizations, and ensuring correct results for different input scenarios.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def detect_cycle(head): slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False def merge_sorted_lists(l1, l2): dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next current.next = l1 if l1 else l2 return dummy.next def remove_duplicates(head): current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head def find_middle_node(head): slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"question":"**Meeting Room Scheduling** You are given an array of meeting time intervals consisting of start and end times `[[s1, e1], [s2, e2], ...]` (si < ei). Your task is to determine if a person could attend all meetings. # Input - An array of meeting intervals `intervals` where each interval is a list containing two integers `[start, end]`. # Output - A boolean value `True` if a person could attend all meetings, or `False` otherwise. # Constraints - The input array will contain between 1 and 1000 intervals. - The start and end times of the intervals are integers between 0 and 10^6. # Example ```python intervals = [[0, 30], [5, 10], [15, 20]] def can_attend_meetings(intervals: list) -> bool: # Your code here if __name__ == \\"__main__\\": print(can_attend_meetings(intervals)) # Output: False ``` ```python intervals = [[7, 10], [2, 4]] def can_attend_meetings(intervals: list) -> bool: # Your code here if __name__ == \\"__main__\\": print(can_attend_meetings(intervals)) # Output: True ``` Write the function `can_attend_meetings` such that passing the above examples returns the correct boolean value indicating whether a person can attend all the given meetings without any overlapping times.","solution":"def can_attend_meetings(intervals): Determine if a person could attend all meetings without overlapping. Args: intervals (list of list of int): List of meeting time intervals where each interval is [start, end]. Returns: bool: True if a person could attend all meetings, False otherwise. # Sort the intervals based on the start time intervals.sort(key=lambda x: x[0]) # Compare the end time of the current meeting with the start time of the next meeting for i in range(len(intervals) - 1): if intervals[i][1] > intervals[i + 1][0]: return False return True"},{"question":"Implement a function **is_palindrome_permutation(input_string: str) -> bool** that determines if any permutation of the input string can form a palindrome. Parameters: - **input_string** (str): A string consisting of lower or uppercase alphabetic characters only and can include spaces. Returns: - A boolean indicating whether any permutation of the input string can form a palindrome. Constraints: 1. `1 <= len(input_string) <= 1000` 2. Only consider alphabetic characters and ignore spaces. 3. The string is not case-sensitive (e.g., \\"Tact Coa\\" should be treated as \\"tactcoa\\"). Example: ```python print(is_palindrome_permutation(\\"Tact Coa\\")) ``` Expected Output: ```yaml True ``` # Explanation: - A string can be permuted to form a palindrome if the number of characters with odd counts is at most one. - In the example, \\"Tact Coa\\" can be rearranged to form \\"tacocat\\" or \\"atcocta\\", both of which are palindromes. # Guidelines: 1. Normalize the input string by removing spaces and converting to lowercase. 2. Count the frequency of each character in the normalized string. 3. Check if at most one character has an odd count. 4. Ensure efficient processing to meet the constraints.","solution":"def is_palindrome_permutation(input_string: str) -> bool: Determines if any permutation of the input string can form a palindrome. Parameters: input_string (str): A string consisting of lower or uppercase alphabetic characters only and can include spaces. Returns: bool: True if any permutation of the input string can form a palindrome, False otherwise. # Normalize the string: remove spaces and convert to lowercase normalized_str = \'\'.join(char.lower() for char in input_string if char.isalpha()) # Count the frequency of each character char_count = {} for char in normalized_str: char_count[char] = char_count.get(char, 0) + 1 # Check the number of characters that have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # A string can be permuted to form a palindrome if the number of characters # with odd counts does not exceed one return odd_count <= 1"},{"question":"# Problem Statement You are tasked with implementing a spell checker. Given a list of known words and a list of words from a document, create a function that identifies which words in the document are misspelled based on the known words list. The function should return a list of misspelled words in the order they appear in the document. # Function Signature ```python def spell_checker(known_words: List[str], document_words: List[str]) -> List[str]: pass ``` # Parameters - **`known_words`** (List[str]): A list of strings representing the words that are considered correctly spelled. All words are in lowercase. - **`document_words`** (List[str]): A list of strings representing the words in the document to be checked. All words are in lowercase. # Output - Returns a list of misspelled words in the order they appear in the document. # Constraints - The length of `known_words` will not exceed 10^5. - The length of `document_words` will not exceed 10^5. - Words consist only of lowercase English letters. - Each word\'s length will be between 1 and 20 characters inclusive. # Example ```python known_words = [\\"apple\\", \\"banana\\", \\"orange\\"] document_words = [\\"apple\\", \\"applle\\", \\"bannana\\", \\"orange\\", \\"orang\\", \\"banana\\"] spell_checker(known_words, document_words) ``` Output: ```python [\\"applle\\", \\"bannana\\", \\"orang\\"] ``` # Performance Requirements - The function should efficiently handle the input size constraints. - Aim for a solution with a time complexity of O(n), where n is the number of words in `document_words`. # Implementation Notes - Consider using a set for the `known_words` to achieve optimal lookup times. - Ensure that the function correctly handles edge cases such as an empty `document_words` list.","solution":"def spell_checker(known_words, document_words): Identifies misspelled words in the document based on the known words list. Parameters: known_words (List[str]): A list of correctly spelled words. document_words (List[str]): A list of words to check in the document. Returns: List[str]: A list of misspelled words in the order they appear in the document. known_set = set(known_words) misspelled_words = [word for word in document_words if word not in known_set] return misspelled_words"},{"question":"# Question Overview You are provided with three sorting algorithms: Bubble Sort, Selection Sort, and Insertion Sort. Each of these algorithms sorts an array of integers in ascending order. Your task is to implement Merge Sort, another popular sorting algorithm, and compare its performance with the provided algorithms. # Problem Statement **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - A list of integers `arr` (1 ≤ len(arr) ≤ 10^5, -10^6 ≤ arr[i] ≤ 10^6). **Output**: - A new list of integers sorted in ascending order. # Constraints - The function must implement the Merge Sort algorithm. - Merge Sort should have a time complexity of (O(n log n)). - Ensure that the solution handles large inputs efficiently. # Hints - Merge Sort is a divide-and-conquer algorithm. Consider writing helper functions for dividing the list and merging the sorted halves. - Recursively split the list into halves, then merge the sorted halves back together. # Additional Requirements - Include meaningful comments in your code explaining each step. - Ensure your solution passes the following test cases: ```python assert merge_sort([]) == [] assert merge_sort([5]) == [5] assert merge_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert merge_sort([10, -1, 2, 5, 0, 6, 4, -5]) == [-5, -1, 0, 2, 4, 5, 6, 10] assert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert merge_sort([5, 4, 1, 2, 3, 7, 6, -3, 0, -1, 1000000, -1000000]) == [-1000000, -3, -1, 0, 1, 2, 3, 4, 5, 6, 7, 1000000] ``` # Performance Testing - Your solution should efficiently handle inputs of up to `10^5` elements within a reasonable time frame.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: # Merge two sorted lists merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 # if there are remaining elements in left or right merged.extend(left[i:]) merged.extend(right[j:]) return merged mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Scenario As a part-time job, you have been asked to create an automated scheduling application for a local gym. One of the core functionalities required is to decide which trainer should be assigned to a customer based on the times they are available. # Objective Implement a function `assign_trainer` that matches a customer with a trainer based on their availability. # Function Signature ```python def assign_trainer(customer_slots: List[str], trainer_slots: List[str]) -> str: Match a customer with a trainer based on their availability. :param customer_slots: A list of time slots the customer is available (in \\"HH:MM-HH:MM\\" format). :param trainer_slots: A list of time slots the trainer is available (in \\"HH:MM-HH:MM\\" format). :return: The matching time slot (in \\"HH:MM-HH:MM\\" format) if there is a common slot. Return \\"No Slot Available\\" if there is no common slot. ``` # Input 1. `customer_slots`: A list of strings representing the available time slots of the customer, formatted as \\"HH:MM-HH:MM\\". 2. `trainer_slots`: A list of strings representing the available time slots of the trainer, formatted as \\"HH:MM-HH:MM\\". # Output - A string representing the first available matching time slot in \\"HH:MM-HH:MM\\" format if there is a common available time slot between the customer and the trainer. - Return \\"No Slot Available\\" if there is no common time slot between the customer and the trainer. # Constraints - The time slots will be in valid 24-hour time format (\\"HH:MM-HH:MM\\"). - The function should be implemented to address exact overlapping slots only. # Examples ```python assert assign_trainer([\\"09:00-10:00\\", \\"11:00-12:00\\"], [\\"10:00-11:00\\", \\"11:00-12:00\\"]) == \\"11:00-12:00\\" assert assign_trainer([\\"08:00-09:00\\", \\"10:00-11:00\\"], [\\"11:00-12:00\\", \\"12:00-13:00\\"]) == \\"No Slot Available\\" assert assign_trainer([\\"15:00-16:00\\"], [\\"15:00-16:00\\"]) == \\"15:00-16:00\\" assert assign_trainer([\\"08:30-09:30\\", \\"10:00-11:00\\"], [\\"08:30-09:30\\", \\"11:00-12:00\\"]) == \\"08:30-09:30\\" assert assign_trainer([\\"09:15-10:15\\"], [\\"10:00-11:00\\"]) == \\"No Slot Available\\" ```","solution":"from typing import List def assign_trainer(customer_slots: List[str], trainer_slots: List[str]) -> str: Match a customer with a trainer based on their availability. :param customer_slots: A list of time slots the customer is available (in \\"HH:MM-HH:MM\\" format). :param trainer_slots: A list of time slots the trainer is available (in \\"HH:MM-HH:MM\\" format). :return: The matching time slot (in \\"HH:MM-HH:MM\\" format) if there is a common slot. Return \\"No Slot Available\\" if there is no common slot. customer_set = set(customer_slots) trainer_set = set(trainer_slots) common_slots = customer_set.intersection(trainer_set) if common_slots: return sorted(common_slots)[0] else: return \\"No Slot Available\\""},{"question":"# Problem Statement: You are given the task of processing and aggregating sales data for a chain of stores. Each store provides daily sales data for a specific product. Your objective is to implement a function that aggregates these data points to provide both daily total sales across all stores and a cumulative total of sales up to each day. # Requirements: 1. Implement a method `aggregate_sales` that takes in the following parameters: - `daily_sales`: A list of dictionaries where each dictionary represents the sales data for all stores on a given day. Each dictionary\'s keys are the store names, and the values are the sales amounts for that day. 2. The function should return a tuple of two lists: - The first list contains the daily total sales across all stores. - The second list contains the cumulative total of sales up to each day. # Constraints: - The input list `daily_sales` is non-empty and all dictionaries contain non-negative integers for sales amounts. - All dictionaries in the list have the same keys corresponding to the store names. # Example: ```python daily_sales = [ {\\"StoreA\\": 100, \\"StoreB\\": 150, \\"StoreC\\": 200}, {\\"StoreA\\": 110, \\"StoreB\\": 160, \\"StoreC\\": 210}, {\\"StoreA\\": 120, \\"StoreB\\": 170, \\"StoreC\\": 220} ] result = aggregate_sales(daily_sales) print(result) # Output: ([450, 480, 510], [450, 930, 1440]) ``` # Function Signature: ```python def aggregate_sales(daily_sales: list[dict[str, int]]) -> tuple[list[int], list[int]]: pass ``` # Note: - Ensure the function is tested with various input scenarios to guarantee correctness. - Consider edge cases such as data with all zeros or a single store\'s sales only. - Implement the solution efficiently, avoiding unnecessary computations or data structures.","solution":"def aggregate_sales(daily_sales: list[dict[str, int]]) -> tuple[list[int], list[int]]: Aggregates daily sales data to provide both daily total sales across all stores and a cumulative total of sales up to each day. Parameters: daily_sales (list[dict[str, int]]): A list of dictionaries where each dictionary represents the sales data for all stores on a given day. Returns: tuple[list[int], list[int]]: A tuple of two lists: - The first list contains the daily total sales across all stores. - The second list contains the cumulative total of sales up to each day. daily_totals = [sum(day.values()) for day in daily_sales] cumulative_totals = [] cum_sum = 0 for total in daily_totals: cum_sum += total cumulative_totals.append(cum_sum) return (daily_totals, cumulative_totals)"},{"question":"# Problem Statement You are required to implement a function that checks if a given string is a valid palindrome considering only alphanumeric characters and ignoring cases, while also supporting the exclamation mark `!` as a palindrome-breaking character. If the exclamation mark is present in the string, it should return `False` immediately. # Function Signature ```python def is_strict_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome considering only alphanumeric characters and ignoring cases, while treating `!` as a palindrome-breaking character. Parameters: s (str): The input string to check. Returns: bool: `True` if the string is a valid palindrome, `False` otherwise. ``` # Input - A string `s`. # Output - Return `True` if the string is a valid palindrome, `False` otherwise. # Constraints - The input string `s` can contain letters, digits, spaces, and punctuation including the exclamation mark `!`. # Examples ```python is_strict_palindrome(\\"A man, a plan, a canal: Panama\\") # True is_strict_palindrome(\\"race a car\\") # False is_strict_palindrome(\\"No lemon, no melon\\") # True is_strict_palindrome(\\"Was it a car or a cat I saw?\\") # True is_strict_palindrome(\\"! level\\") # False is_strict_palindrome(\\"hello!\\") # False ``` # Additional Notes - Consider using Python\'s `str.isalnum()` method to filter out non-alphanumeric characters. - The function should convert all characters to the same case (e.g., lowercase) before making its comparisons. - The presence of any exclamation mark `!` in the string should result in an immediate return of `False`.","solution":"def is_strict_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome considering only alphanumeric characters and ignoring cases, while treating `!` as a palindrome-breaking character. Parameters: s (str): The input string to check. Returns: bool: `True` if the string is a valid palindrome, `False` otherwise. # If \'!\' is in the string, return False immediately if \'!\' in s: return False # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered string is a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"# Problem Statement You are tasked with implementing a function that returns all possible k-combinations of a given list of numbers. A k-combination is a subset of k distinct elements from the list, without regard to the order of the elements. # Function Signature ```python def k_combinations(nums: list, k: int) -> list: Generates all k-combinations of the given list of numbers. Parameters: nums (list): The list of distinct integers. k (int): The number of elements in each combination. Returns: list: A list of lists where each inner list is a k-combination of the given numbers. ``` # Input - `nums` (list of integers): A list of distinct integers (1 ≤ len(nums) ≤ 20). - `k` (integer): The number of elements in each combination (0 ≤ k ≤ len(nums)). # Output - A list of lists, where each inner list represents a possible k-combination of the given numbers. # Constraints 1. `nums` will always contain unique integers. 2. `k` will always be a non-negative integer such that 0 ≤ k ≤ len(nums). # Performance requirements - Your solution should handle the combinatorial nature efficiently, leveraging recursion or iteration as needed. # Example ```python assert k_combinations([1, 2, 3], 2) == [[1, 2], [1, 3], [2, 3]] assert k_combinations([1, 2, 3, 4], 1) == [[1], [2], [3], [4]] assert k_combinations([1, 2, 3], 3) == [[1, 2, 3]] assert k_combinations([1, 2, 3], 0) == [[]] assert k_combinations([], 0) == [[]] ``` # Additional Notes - Consider utilizing combinatorial generation methods or libraries, like itertools in Python, if necessary. - Be mindful of edge cases where k is 0 (resulting in the empty combination) or equal to the length of the list.","solution":"from itertools import combinations def k_combinations(nums: list, k: int) -> list: Generates all k-combinations of the given list of numbers. Parameters: nums (list): The list of distinct integers. k (int): The number of elements in each combination. Returns: list: A list of lists where each inner list is a k-combination of the given numbers. return [list(comb) for comb in combinations(nums, k)]"},{"question":"# Coding Assessment Question Context In a warehouse, products are loaded onto pallets that are then transported by forklifts. Each pallet has a weight, and each forklift can carry a maximum weight. The challenge is to load the heaviest possible combination of pallets onto a forklift without exceeding its weight limit. This is a common problem in logistics and supply chain management. Task Write a function `max_pallet_weight` that, given a list of pallet weights and the maximum weight a forklift can carry, finds the heaviest possible combination of pallet weights that does not exceed the forklift\'s weight limit. # Function Signature ```python def max_pallet_weight(pallet_weights: List[int], max_weight: int) -> int: Finds the maximum weight of pallets that can be loaded onto a forklift without exceeding the weight limit. Args: pallet_weights: List of integers representing the weights of the pallets. max_weight: An integer representing the maximum weight the forklift can carry. Returns: int: The maximum weight that can be loaded onto the forklift without exceeding the weight limit. ``` # Input and Output Format - **Input**: - `pallet_weights`: A list of integers where each integer represents the weight of a pallet. - `max_weight`: An integer representing the maximum weight the forklift can carry. - **Output**: An integer representing the heaviest possible combination of pallet weights that does not exceed the forklift\'s maximum weight. # Constraints - Assume `1 <= len(pallet_weights) <= 10^3`. - Each pallet weight is a positive integer and does not exceed the forklift\'s maximum weight. - `1 <= max_weight <= 10^6`. # Example ```python pallet_weights = [3, 7, 2, 9, 5] max_weight = 10 max_load = max_pallet_weight(pallet_weights, max_weight) print(max_load) # Expected output: 10 (As the best combination is [3, 7] or [5, 5]) ``` # Notes - You can use dynamic programming to solve this problem efficiently. - Make sure to consider edge cases such as when no pallet can be loaded due to all being heavier than the weight limit. Hints 1. Use a dynamic programming approach similar to the knapsack problem where you populate a table of possible load weights. 2. Base conditions include the case when no pallets are selected and the forklift\'s load weight is zero. 3. Iteratively build up the solution by considering each pallet and the incremental weights up to the maximum allowed.","solution":"from typing import List def max_pallet_weight(pallet_weights: List[int], max_weight: int) -> int: Finds the maximum weight of pallets that can be loaded onto a forklift without exceeding the weight limit. Args: pallet_weights: List of integers representing the weights of the pallets. max_weight: An integer representing the maximum weight the forklift can carry. Returns: int: The maximum weight that can be loaded onto the forklift without exceeding the weight limit. dp = [0] * (max_weight + 1) for weight in pallet_weights: for current_weight in range(max_weight, weight - 1, -1): dp[current_weight] = max(dp[current_weight], dp[current_weight - weight] + weight) return dp[max_weight]"},{"question":"# Context You are developing a simulation for a supermarket self-service checkout system. The system has a queue of customers, each with a list of products they wish to purchase. Implement a mechanism to simulate the checkout process, ensuring that each customer is processed in the order they arrive. Each product has a price, and each customer has a budget. # Task You need to implement the `Supermarket` class that manages customers and their purchases. Your implementation should keep track of the total revenue collected. # Requirements 1. **Constructor**: `Supermarket()` initializes the supermarket with an empty queue and zero revenue. 2. **Methods**: * `add_customer(self, customer)`: Adds a customer to the queue. Each customer is represented by a dictionary with keys `name` (string), `budget` (float), and `cart` (list of tuples with product names and prices). * `process_next_customer(self)`: Processes the next customer in the queue. Deducts the total cost of their cart from their budget if they can afford it. If they can\'t, skip to the next customer. Increase the total revenue by the total cost of the purchases they successfully make. * `get_revenue(self)`: Returns the total revenue collected by the supermarket. # Example ```python # Initialize supermarket sm = Supermarket() # Customers with their carts and budgets customer1 = {\'name\': \'Alice\', \'budget\': 20.0, \'cart\': [(\'apple\', 2), (\'banana\', 1.5)]} customer2 = {\'name\': \'Bob\', \'budget\': 10.0, \'cart\': [(\'milk\', 3), (\'bread\', 2.5), (\'banana\', 1.5)]} # Adding customers to the queue sm.add_customer(customer1) sm.add_customer(customer2) # Processing customers sm.process_next_customer() # Alice\'s cart costs 3.5, she can afford it sm.process_next_customer() # Bob\'s cart costs 7.0, he can afford it # Getting total revenue assert sm.get_revenue() == 3.5 + 7.0 ``` # Notes - Ensure that customers are processed in the order they are added to the queue. - Ensure that the budget deduction and revenue calculation are accurate. - Handle edge cases such as the processing of customers with an empty cart, customers who can\'t afford any items in their cart, and ensuring no customer is processed more than once.","solution":"class Supermarket: def __init__(self): Initializes the supermarket with an empty queue and zero revenue. self.queue = [] self.revenue = 0.0 def add_customer(self, customer): Adds a customer to the queue. Parameters: customer: dict - A dictionary with keys \'name\' (string), \'budget\' (float), and \'cart\' (list of tuples with product names and prices). self.queue.append(customer) def process_next_customer(self): Processes the next customer in the queue. Deducts the total cost of their cart from their budget if they can afford it. If they can\'t, skip to the next customer. Increase the total revenue by the total cost of the purchases they successfully make. if self.queue: customer = self.queue.pop(0) cart_total = sum(price for product, price in customer[\'cart\']) if customer[\'budget\'] >= cart_total: customer[\'budget\'] -= cart_total self.revenue += cart_total def get_revenue(self): Returns the total revenue collected by the supermarket. return self.revenue"},{"question":"# Coding Question You are working on a robotics project where you need to implement a function to navigate a robot on a grid. The function should calculate the minimum number of moves required for the robot to reach the goal from its starting position. The robot is only allowed to move up, down, left, or right one unit per move. **Function: `min_moves_to_goal`** ```python def min_moves_to_goal(start: tuple, goal: tuple) -> int: Takes the starting position and goal position of the robot as tuples of coordinates (x, y) and returns the minimum number of moves required for the robot to reach the goal. Examples: >>> min_moves_to_goal((0, 0), (3, 3)) 6 >>> min_moves_to_goal((1, 2), (4, 6)) 7 >>> min_moves_to_goal((5, 5), (5, 5)) 0 >>> min_moves_to_goal((-1, -1), (2, 3)) 7 pass # your code here ``` **Explanation:** - The robot is positioned on a 2D grid and receives the starting and goal positions as input. - Positions are given as tuples containing x and y coordinates, e.g., `(x, y)`. - The robot can move one unit up, down, left, or right per move. - The function should compute the minimum number of moves required for the robot to reach the goal position from the starting position. - Ensure the function handles cases where the start and goal positions are the same, and returns 0 in such scenarios. # Example Scenario: You have developed a simple robot for warehouse automation. The robot needs to navigate from its starting position to a specific location to pick up an item. You need to calculate the minimum number of moves required for the robot to reach the item. **Sample Input:** ```plaintext Enter the starting position (x, y): (2, 3) Enter the goal position (x, y): (5, 7) ``` **Sample Output:** ```plaintext Minimum moves: 7 ``` # Constraints * The coordinates can be any integer values, positive or negative. * The function should handle cases where the start equals the goal efficiently. * Ensure the function runs efficiently for larger distances between start and goal.","solution":"def min_moves_to_goal(start: tuple, goal: tuple) -> int: Takes the starting position and goal position of the robot as tuples of coordinates (x, y) and returns the minimum number of moves required for the robot to reach the goal. # Extract coordinates x1, y1 = start x2, y2 = goal # Calculate the difference in x and y direction dx = abs(x2 - x1) dy = abs(y2 - y1) # The minimum moves required is the sum of differences in both directions return dx + dy"},{"question":"# Sum of Distinct Elements # Problem Description You are given an unsorted array of integers. Your task is to find the sum of all distinct elements in the array. # Function Signature ```python def sum_of_distinct_elements(arr: list) -> int: pass ``` # Input - `arr` (List[int]): The unsorted array of integers (0 ≤ len(arr) ≤ 10^5, elements are in the range of -10^6 to 10^6). # Output - (int): The sum of all distinct elements in the array. # Constraints 1. The input array length can be from 0 to 100,000. 2. The elements of the array can range from -10^6 to 10^6. 3. If the array is empty, the sum should be 0. # Example ```python assert sum_of_distinct_elements([2, 4, 5, 7, 5, 4, 7, 2, 8]) == 8 assert sum_of_distinct_elements([1, 2, 3, 4, 5]) == 15 assert sum_of_distinct_elements([1, -1, 1, -1, 0]) == 0 assert sum_of_distinct_elements([]) == 0 ``` # Instructions 1. Your implementation should efficiently handle large inputs. 2. Avoid unnecessary duplication or sorting steps that might increase the complexity beyond O(n). 3. Consider edge cases such as the empty array, arrays with all elements the same, and arrays with negative and positive numbers. # Tips 1. Using a set data structure can help filter out duplicate elements from the array effectively. 2. Pay attention to how Python\'s built-in functions can simplify your approach.","solution":"def sum_of_distinct_elements(arr: list) -> int: Returns the sum of all distinct elements in the array. return sum(set(arr))"},{"question":"# Circular Buffer Design You are tasked with creating a circular buffer data structure for a concurrent producer-consumer system to efficiently manage tasks. The buffer should support standard operations such as adding and removing elements, and handle concurrency controls to ensure thread-safety. **Task**: Implement the following class: 1. **CircularBuffer**: - **Methods**: 1. **__init__(self, size: int)**: - **Input**: `size` (int) - Capacity of the buffer. - Initializes the buffer with the given capacity. 2. **add(self, item: Any)**: - **Input**: `item` (Any) - Item to be added to the buffer. - Adds an item to the buffer. - Raises an exception if the buffer is full. 3. **remove(self) -> Any**: - **Output**: Returns the item removed from the buffer. - Removes and returns an item from the buffer. - Raises an exception if the buffer is empty. 4. **is_empty(self) -> bool**: - **Output**: Returns `True` if the buffer is empty, `False` otherwise. 5. **is_full(self) -> bool**: - **Output**: Returns `True` if the buffer is full, `False` otherwise. # Requirements: - Ensure the buffer efficiently manages the items in a circular manner. - Implement thread-safety mechanisms to handle simultaneous add and remove operations. - Provide appropriate error messages when attempting to add to a full buffer or remove from an empty one. - The buffer size shall not exceed 1000 items. # Constraints: - The items managed by the buffer can be any data type. **Examples**: ```python # Initialize a circular buffer with a size of 3 >>> buffer = CircularBuffer(3) # Add elements to the buffer >>> buffer.add(1) >>> buffer.add(2) >>> buffer.add(3) # Check if the buffer is full >>> buffer.is_full() True # Attempt to add another element (should raise an exception) >>> buffer.add(4) Exception: Buffer is full # Remove elements from the buffer >>> buffer.remove() 1 >>> buffer.remove() 2 # Check if the buffer is empty >>> buffer.is_empty() False # Remove the last element >>> buffer.remove() 3 # Check if the buffer is empty now >>> buffer.is_empty() True # Attempt to remove an element from an empty buffer (should raise an exception) >>> buffer.remove() Exception: Buffer is empty ```","solution":"import threading class CircularBuffer: def __init__(self, size: int): if size > 1000: raise ValueError(\\"Buffer size cannot exceed 1000\\") self.size = size self.buffer = [None] * size self.head = 0 self.tail = 0 self.count = 0 self.lock = threading.Lock() def add(self, item): with self.lock: if self.is_full(): raise Exception(\\"Buffer is full\\") self.buffer[self.tail] = item self.tail = (self.tail + 1) % self.size self.count += 1 def remove(self): with self.lock: if self.is_empty(): raise Exception(\\"Buffer is empty\\") item = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.size self.count -= 1 return item def is_empty(self) -> bool: return self.count == 0 def is_full(self) -> bool: return self.count == self.size"},{"question":"# Coding Challenge: Calculating the Volume of a Cylinder In this challenge, you are required to write a function to compute the volume of a cylinder. The volume ( V ) of a cylinder is given by the formula ( V = pi r^2 h ), where ( r ) is the radius of the cylinder\'s base and ( h ) is the height of the cylinder. # Function Specification: ```python def cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylinder. The volume V of a cylinder of radius r and height h is πr²h. Args: radius (float): The radius of the cylinder\'s base. height (float): The height of the cylinder. Returns: float: The volume of the cylinder. ``` # Constraints 1. The radius of the cylinder\'s base (`radius`) will be a non-negative float. 2. The height of the cylinder (`height`) will be a non-negative float. # Input * `radius`: a floating-point number representing the radius of the cylinder\'s base in meters. * `height`: a floating-point number representing the height of the cylinder in meters. # Output * Return the volume of the cylinder as a float. # Example ```python >>> cylinder_volume(3, 5) 141.3716694115407 >>> cylinder_volume(0, 10) 0.0 >>> cylinder_volume(7, 0) 0.0 >>> cylinder_volume(2.5, 10) 196.34954084936207 >>> cylinder_volume(4, 4.5) 226.195 ``` # Additional Considerations Think about edge cases such as: * What happens if radius or height is zero? * Make sure to use a precise value of ( pi ) for accurate calculations. * Ensure your function handles a wide range of float values without loss of precision. Implement comprehensive error handling for invalid inputs to make your function robust and reliable.","solution":"import math def cylinder_volume(radius: float, height: float) -> float: Calculate the volume of a cylinder. The volume V of a cylinder of radius r and height h is πr²h. Args: radius (float): The radius of the cylinder\'s base. height (float): The height of the cylinder. Returns: float: The volume of the cylinder. return math.pi * (radius ** 2) * height"},{"question":"# Longest Path in a Directed Acyclic Graph Objective Implement the following function to find the longest path in a Directed Acyclic Graph (DAG) represented as an adjacency list: ```python from typing import List, Tuple def find_longest_path(n: int, edges: List[Tuple[int, int]]) -> List[int]: Finds the longest path in a Directed Acyclic Graph (DAG). Parameters: n (int): The number of nodes in the graph. edges (List[Tuple[int, int]]): A list of tuples where each tuple (u, v) represents an edge from node u to node v. Returns: List[int]: A list of nodes representing the longest path from any starting node, with the nodes listed in order of occurrence. pass ``` Input Format * An integer `n` representing the number of nodes in the graph. * A list of tuples `edges` where each tuple `(u, v)` represents a directed edge from node `u` to node `v`. Output Format * A list of integers representing the nodes in the longest path, listed in the order of occurrence. Constraints * The graph will be a valid Directed Acyclic Graph (DAG) with nodes numbered from `0` to `n-1`. * There will be at least one node in the graph (`n >= 1`). Example ```python n = 6 edges = [(0, 1), (1, 2), (2, 3), (3, 4), (1, 5)] print(find_longest_path(n, edges)) # Expected output: [0, 1, 2, 3, 4] ``` Notes * Consider using topological sorting as a part of your solution. * Ensure that your implementation efficiently handles the given constraints. * Your solution should handle edge cases such as graphs with single nodes or no edges correctly.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_longest_path(n: int, edges: List[Tuple[int, int]]) -> List[int]: # Step 1: Create the adjacency list representation of the graph graph = defaultdict(list) in_degree = [0] * n for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Step 2: Perform topological sort using Kahn\'s algorithm topo_order = [] queue = deque([i for i in range(n) if in_degree[i] == 0]) # This will store the longest path distances from the start node dist = [-1] * n parent = [-1] * n # This will store the parent node to help reconstruct the path while queue: node = queue.popleft() topo_order.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Step 3: Find the longest path using the topological order # Initialize distances for nodes with no incoming edges for node in topo_order: if dist[node] == -1: dist[node] = 0 for node in topo_order: for neighbor in graph[node]: if dist[neighbor] < dist[node] + 1: dist[neighbor] = dist[node] + 1 parent[neighbor] = node # Find the endpoint of the longest path max_dist = max(dist) end_node = dist.index(max_dist) # Reconstruct the longest path path = [] while end_node != -1: path.append(end_node) end_node = parent[end_node] return path[::-1]"},{"question":"# Coding Problem: Detecting and Counting Palindromic Words Background A palindrome is a word, phrase, number, or other sequences of characters that reads the same backward as forward (ignoring spaces, punctuation, and capitalization). For example, \\"racecar\\" and \\"Radar\\" are palindromic words. For this task, you need to write a function that processes a file containing a list of words and counts how many of these words are palindromic. Task Given a file containing an arbitrary number of words, determine how many of these words are palindromes. Requirements Write a function that: 1. Reads the words from a file called `palindromes.txt`, where each word is on a new line. 2. Ignores case when determining if a word is a palindrome (e.g., \\"Radar\\" should be considered a palindrome). 3. Calculates the number of palindromic words in the file. The function should be designed as follows: **Function Signature:** ```python def count_palindromic_words(file_path: str) -> int: pass ``` Input: - `file_path` (str): Path to the `palindromes.txt` file. Output: - Returns the count of palindromic words (int). Constraints: - Assume the file contains valid alphabetic words. - Consider the characters only (ignore spaces if any), but typically, it will be single words. Example Here\'s an example to illustrate the problem requirements. Given `palindromes.txt` containing: ``` radAR apple Level banana mom run ``` The palindromic words in this file are \\"radAR\\", \\"Level\\", and \\"mom\\". The function should return `3`, as there are three palindromic words in the file. Note: Pay attention to case sensitivity and ensure to handle file exceptions properly.","solution":"def count_palindromic_words(file_path: str) -> int: def is_palindrome(word: str) -> bool: Helper function to check if a word is a palindrome. word = word.lower() return word == word[::-1] palindromic_count = 0 try: with open(file_path, \'r\') as file: for word in file: word = word.strip() if is_palindrome(word): palindromic_count += 1 except FileNotFoundError: print(f\\"The file at {file_path} was not found.\\") return 0 return palindromic_count"},{"question":"# Unique Elements Counter **Objective**: Implement a function to count unique elements in a list while preserving the original order of appearance and displaying elements\' counts. **Scenario**: In a data normalization process, it\'s necessary to count the occurrences of each unique element in a list while maintaining the order in which they first appear. This helps in transforming raw data into a structured summary format for further processing. **Requirements**: - Define a function `count_unique_elements(data: list) -> list` that: - Takes a list of elements as input. - Returns a list of tuples, where each tuple contains a unique element and its corresponding count in the input list. - Maintains the original order of first appearance of each unique element. - Handle empty input lists by returning an empty list. - Ensure the solution works efficiently with input lists containing up to 10^5 elements. **Function Signature**: ```python def count_unique_elements(data: list) -> list: pass ``` **Constraints**: - The input list is a list of elements which can include integers, strings, or a mix of both. - The elements in the input list are immutable and hashable. **Examples**: 1. `count_unique_elements([1, 2, 2, 3, 1, 4, 4, 4])` - Should return: ```python [(1, 2), (2, 2), (3, 1), (4, 3)] ``` 2. `count_unique_elements([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"citrus\\"])` - Should return: ```python [(\\"apple\\", 3), (\\"banana\\", 2), (\\"citrus\\", 1)] ``` 3. `count_unique_elements([1, \\"a\\", 1, \\"b\\", \\"a\\", 1])` - Should return: ```python [(1, 3), (\\"a\\", 2), (\\"b\\", 1)] ``` 4. `count_unique_elements([])` - Should return: ```python [] ```","solution":"def count_unique_elements(data): Returns a list of tuples, where each tuple contains a unique element and its corresponding count in the input list. Maintains the original order of first appearance of each unique element. from collections import defaultdict element_count = defaultdict(int) order_of_appearance = [] for element in data: if element not in element_count: order_of_appearance.append(element) element_count[element] += 1 result = [(element, element_count[element]) for element in order_of_appearance] return result"},{"question":"# Book Catalogue Search System You are tasked with developing a book search utility that helps in finding books from a catalogue based on specific search criteria. The system should allow users to search by title, author, and/or publication year. Function Signature ```python def search_books(catalogue: List[Dict[str, Union[str, int]]], title: str = \\"\\", author: str = \\"\\", publication_year: int = None) -> List[Dict[str, Union[str, int]]]: pass ``` # Instructions 1. **Functionality**: Implement a function `search_books` which, given a `catalogue`, a `title`, an `author`, and/or `publication_year`, searches for books in the catalogue that match the provided criteria. 2. **Catalogue Structure**: Each book in the catalogue is represented as a dictionary with the following structure: - `\'title\'`: Title of the book (string) - `\'author\'`: Author of the book (string) - `\'publication_year\'`: Year the book was published (integer) 3. **Search Criteria**: The function should: - Handle partial matches for `title` and `author`. The search should be case-insensitive. - Be able to filter results by `publication_year` if provided. - Return all books that match all non-empty criteria. # Expected Input and Output * **Input**: - `catalogue`: a list of dictionaries, where each dictionary represents a book. - `title`: a string representing the (partial) title of the book. - `author`: a string representing the (partial) author name. - `publication_year`: an integer representing the publication year of the book. * **Output**: - A list of dictionaries representing the books that match the search criteria. If no criteria are provided, return the entire catalogue. # Constraints 1. The catalogue may contain multiple books with similar titles, authors, or publication years. 2. If all search parameters are empty or none, the function should return the entire catalogue. 3. Partial matches should ignore case differences. # Example ```python catalogue = [ {\'title\': \'The Hobbit\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1937}, {\'title\': \'The Lord of the Rings\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1954}, {\'title\': \'Harry Potter and the Philosopher\'s Stone\', \'author\': \'J.K. Rowling\', \'publication_year\': 1997}, {\'title\': \'Harry Potter and the Chamber of Secrets\', \'author\': \'J.K. Rowling\', \'publication_year\': 1998}, ] # Search by title >>> search_books(catalogue, title=\'harry potter\') [ {\'title\': \'Harry Potter and the Philosopher\'s Stone\', \'author\': \'J.K. Rowling\', \'publication_year\': 1997}, {\'title\': \'Harry Potter and the Chamber of Secrets\', \'author\': \'J.K. Rowling\', \'publication_year\': 1998}, ] # Search by author >>> search_books(catalogue, author=\'tolkien\') [ {\'title\': \'The Hobbit\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1937}, {\'title\': \'The Lord of the Rings\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1954}, ] # Search by publication year >>> search_books(catalogue, publication_year=1997) [ {\'title\': \'Harry Potter and the Philosopher\'s Stone\', \'author\': \'J.K. Rowling\', \'publication_year\': 1997}, ] # Search by multiple criteria >>> search_books(catalogue, title=\'harry\', author=\'rowling\', publication_year=1998) [ {\'title\': \'Harry Potter and the Chamber of Secrets\', \'author\': \'J.K. Rowling\', \'publication_year\': 1998}, ] # No criteria >>> search_books(catalogue) [ {\'title\': \'The Hobbit\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1937}, {\'title\': \'The Lord of the Rings\', \'author\': \'J.R.R. Tolkien\', \'publication_year\': 1954}, {\'title\': \'Harry Potter and the Philosopher\'s Stone\', \'author\': \'J.K. Rowling\', \'publication_year\': 1997}, {\'title\': \'Harry Potter and the Chamber of Secrets\', \'author\': \'J.K. Rowling\', \'publication_year\': 1998}, ] ``` # Note Ensure the function handles different combinations of input criteria effectively and returns accurate results.","solution":"from typing import List, Dict, Union def search_books(catalogue: List[Dict[str, Union[str, int]]], title: str = \\"\\", author: str = \\"\\", publication_year: int = None) -> List[Dict[str, Union[str, int]]]: def match(book, title, author, publication_year): if title and title.lower() not in book[\'title\'].lower(): return False if author and author.lower() not in book[\'author\'].lower(): return False if publication_year and book[\'publication_year\'] != publication_year: return False return True return [book for book in catalogue if match(book, title, author, publication_year)]"},{"question":"# Problem Statement Write a function named `largest_divisible_subset` that finds the largest subset of a given list of integers where every pair (x, y) of elements in the subset satisfies either x % y == 0 or y % x == 0. # Function Signature ```python def largest_divisible_subset(nums: List[int]) -> List[int]: pass ``` # Input - `nums`: A list of integers (0 < |nums| ≤ 1000, 1 ≤ nums[i] ≤ 10^9) # Output - A list representing the largest divisible subset where every pair of elements (x, y) satisfies either x % y == 0 or y % x == 0. If there are multiple solutions, return any of them. # Examples ```python >>> largest_divisible_subset([1, 2, 3]) [1, 2] or [1, 3] >>> largest_divisible_subset([1, 2, 4, 8]) [1, 2, 4, 8] >>> largest_divisible_subset([3, 4, 16, 8]) [4, 8, 16] or [3] or [3, 8] >>> largest_divisible_subset([4, 8, 10, 240]) [4, 8, 240] or [10, 240] ``` # Explanation In the first example, [1, 2] and [1, 3] are both acceptable solutions because every pair of elements in each solution satisfies the given condition. In the second example, the entire list [1, 2, 4, 8] satisfies the condition since each number is divisible by the previous number. In the third example, possible subsets are [4, 8, 16], or simply [3]. In the fourth example, [4, 8, 240] works since each pair in the subset divisible. # Constraints - The input list may contain large numbers up to 10^9. - The list size will not exceed 1000 elements. - The solution must perform efficiently within these constraints.","solution":"def largest_divisible_subset(nums): if not nums: return [] nums.sort() n = len(nums) dp = [1] * n prev = [-1] * n max_size = 0 max_index = -1 for i in range(n): for j in range(i): if nums[i] % nums[j] == 0 and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 prev[i] = j if dp[i] > max_size: max_size = dp[i] max_index = i result = [] while max_index >= 0: result.append(nums[max_index]) max_index = prev[max_index] return result[::-1]"},{"question":"# Problem Statement You are tasked with implementing a custom made string search function to mimic the behavior of Python\'s built-in `str.find` method. The function should locate the lowest index of the substring within a given string. # Requirements: - Implement the function `custom_find(string: str, substring: str) -> int`. - The function needs to return the lowest index in `string` where substring `substring` is found. - If the substring is not found, return `-1`. - The function should not use Python’s built-in `find` method or any library-specific search methods. # Expected Input and Output: - **Input**: - `string` (str): The main string in which to search. - `substring` (str): The substring to search for within the main string. Constraints: - ( 0 leq text{len(string)} leq 10^5 ) - ( 0 leq text{len(substring)} leq 10^4 ) # Example Usage: ```python def custom_find(string: str, substring: str) -> int: ... # Examples: custom_find(\\"hello world\\", \\"world\\") -> 6 custom_find(\\"hello world\\", \\"cat\\") -> -1 custom_find(\\"test_string\\", \\"test\\") -> 0 custom_find(\\"repeated repeated word\\", \\"repeated\\") -> 0 custom_find(\\"abcdef\\", \\"efg\\") -> -1 ``` # Notes: - Ensure that the function correctly handles edge cases. - Aim for a computational time complexity that is efficient for the given constraints. An optimal solution would prevent unnecessary checks by stopping early, once the substring is matched or confirmed as not present.","solution":"def custom_find(string: str, substring: str) -> int: Returns the lowest index in `string` where substring `substring` is found. If the substring is not found, returns -1. len_string = len(string) len_substring = len(substring) if len_substring == 0: return 0 # Based on Python specification for an empty substring. if len_substring > len_string: return -1 for i in range(len_string - len_substring + 1): if string[i:i+len_substring] == substring: return i return -1"},{"question":"# Coding Assessment Question: You are developing a software that generates a minimal time table for a set of tasks. Each task has a duration and a list of other tasks that need to be completed before it starts (i.e., a dependency list). Your objective is to compute the earliest possible start time for each task given these constraints, assuming all tasks start at time 0. Function Signature: ```python def compute_start_times(num_tasks: int, durations: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: Compute the earliest start times for a set of tasks given their durations and dependencies. Args: num_tasks (int): The number of tasks. durations (List[int]): A list representing the duration of each task. dependencies (List[Tuple[int, int]]): A list of tuples where each tuple (a, b) indicates that task a must be completed before task b can start. Returns: List[int]: A list of start times where the ith element represents the earliest start time of task i. ``` Input: - An integer `num_tasks` representing the number of tasks (1 ≤ num_tasks ≤ 1000). - A list `durations` of length `num_tasks` where `durations[i]` is the duration of the i-th task (0 ≤ durations[i] ≤ 1000). - A list of pairs `dependencies` where each pair (a, b) indicates that task `a` must be completed before task `b` can start. Output: - A list of integers representing the earliest start time for each task. Example: ```python >>> compute_start_times(3, [3, 2, 1], [(0, 1), (1, 2)]) [0, 3, 5] >>> compute_start_times(4, [4, 3, 2, 1], [(0, 1), (1, 2), (2, 3)]) [0, 4, 7, 9] >>> compute_start_times(5, [5, 3, 7, 2, 1], [(0, 1), (1, 2), (1, 3), (3, 4)]) [0, 5, 8, 8, 10] ``` Constraints: 1. The function must handle up to 1000 tasks efficiently. 2. The input guarantees no circular dependency exists. 3. If there are no dependencies, a task can start at time 0. Additional Notes: - You may use Python\'s built-in data structures and sorting algorithms. - Avoid using external libraries for the core logic. - Ensure the function efficiently computes the start times while respecting the dependencies. Your task is to implement the function `compute_start_times` to achieve the described functionality and adhere to the given constraints.","solution":"from typing import List, Tuple from collections import defaultdict, deque def compute_start_times(num_tasks: int, durations: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: # Initialize the in-degree and adjacency list in_degree = [0] * num_tasks adj_list = defaultdict(list) # Build the graph for u, v in dependencies: adj_list[u].append(v) in_degree[v] += 1 # Queue for tasks that have no dependencies queue = deque() start_times = [0] * num_tasks # Initially add all tasks with no dependencies (in-degree 0) for i in range(num_tasks): if in_degree[i] == 0: queue.append(i) while queue: current = queue.popleft() current_end_time = start_times[current] + durations[current] for neighbor in adj_list[current]: start_times[neighbor] = max(start_times[neighbor], current_end_time) in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return start_times"},{"question":"# Problem Statement You are tasked with writing a function `find_middle_element` that finds and returns the middle element of a list. If the list has an even number of elements, return the average of the two middle elements. Assume the list will contain only numerical values (integers or floats). # Function Signature ```python def find_middle_element(lst: List[Union[int, float]]) -> Union[int, float, None]: ``` # Input - `lst`: A list of numerical values. The list can be empty. # Output - The middle element of the list if it contains an odd number of elements. - The average of the two middle elements if the list contains an even number of elements. - `None` if the list is empty. # Constraints - The list will only contain integers or floats or be empty. - List size will not exceed 10^4. # Example Input ```python [7] [1, 2, 3, 4] [] [5, 10, 100] [0.5, 1.5, 2.5, 3.5, 4.5, 5.5] ``` Output ```python 7 2.5 None 10 3.0 ``` # Additional Requirements - Handle edge cases, such as an empty list or lists with very small or very large numerical values. - Ensure that the function works in linear time O(n) for list length n. - Consider and handle potential input types (integers and floats) effectively.","solution":"from typing import List, Union def find_middle_element(lst: List[Union[int, float]]) -> Union[int, float, None]: Finds and returns the middle element of a list. If the list has an even number of elements, return the average of the two middle elements. Returns None if the list is empty. # Getting the length of the list length = len(lst) # Return None if the list is empty if length == 0: return None # Finding the middle index middle_index = length // 2 # If length is odd, return the middle element if length % 2 != 0: return lst[middle_index] else: # If length is even, return the average of the two middle elements return (lst[middle_index - 1] + lst[middle_index]) / 2"},{"question":"# Problem Statement You are given a list of integers. You need to determine whether the list can be split into two sublists such that the sum of the elements in both sublists is equal. Return True if this is possible, otherwise, return False. # Function Signature ```python def can_partition(nums: List[int]) -> bool: pass ``` # Input * A list of integers `nums` (1 <= len(nums) <= 200, -100 <= nums[i] <= 100): The list of integers to be partitioned. # Output * A boolean value: True if the list can be partitioned into two sublists with equal sum, otherwise False. # Example ```python >>> can_partition([1, 5, 11, 5]) True # Can be partitioned into [1, 5, 5] and [11] >>> can_partition([1, 2, 3, 5]) False # Cannot be partitioned into two sublists with equal sum >>> can_partition([1, 1, 3, 4, 7]) True # Can be partitioned into [1, 1, 3, 4] and [7] ``` # Constraints * The length of the list will always be within the given range. * The integers can be both positive and negative. * Use dynamic programming or other efficient methods to solve this where possible. # Note Consider edge cases such as: * An empty list or list with one element always returns False. * Lists where the total sum is odd cannot be partitioned into two equal sublists.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: # If the list has less than 2 elements, we cannot partition into two sublists. if len(nums) < 2: return False total_sum = sum(nums) # If the total sum is odd, we cannot split the list into two equal subsets. if total_sum % 2 != 0: return False target = total_sum // 2 # Use a set to keep track of possible sums that can be formed with subsets. possible_sums = set([0]) for num in nums: next_possible_sums = set() for s in possible_sums: next_possible_sums.add(s + num) next_possible_sums.add(s) possible_sums = next_possible_sums if target in possible_sums: return True return False"},{"question":"**Context:** As a software developer, you are required to process and manage a company’s transaction records. Part of your task involves identifying anomalies in the transaction amounts based on a dynamic threshold. **Objective:** Write a program that analyzes a list of transaction amounts to determine which transactions are suspicious based on a provided threshold value. Your solution should compare each transaction against the threshold and flag those that exceed the threshold value. **Task:** Create a function `find_suspicious_transactions(transactions: list[float], threshold: float) -> list[bool]` that takes a list of transaction amounts and a threshold value and returns a list of boolean values. Each boolean value should indicate whether the corresponding transaction amount is suspicious (i.e., exceeds the threshold value). # Expected Input and Output: * **Input**: - `transactions`: A list of floating-point numbers (each representing a transaction amount). - `threshold`: A floating-point number representing the threshold value. * **Output**: - A list of boolean values, where each value corresponds to whether its respective transaction amount is suspicious (`True` for suspicious, `False` otherwise). # Constraints: - The list of transactions will have up to 100,000 elements. - Each transaction amount will be a floating-point number up to 1,000,000. - Threshold value will be within the range of the transaction amounts. **Example:** ```python transactions = [100.50, 2000.00, 15000.75, 750.00, 50.00] threshold = 1000.00 assert find_suspicious_transactions(transactions, threshold) == [False, True, True, False, False] ``` Note: Ensure that your implementation is efficient in processing and can handle the maximum constraints without significant performance degradation.","solution":"def find_suspicious_transactions(transactions: list[float], threshold: float) -> list[bool]: Determines which transactions are suspicious based on a threshold value. Parameters: transactions (list[float]): A list of transaction amounts. threshold (float): The threshold value to compare the transactions against. Returns: list[bool]: A list of boolean values indicating whether each transaction is suspicious. return [transaction > threshold for transaction in transactions]"},{"question":"# Coding Assessment Question Objective Implement a function that finds the intersection of multiple lists and returns their common elements in sorted order. Function Signature ```python def find_common_elements(*lists: List[int]) -> List[int]: pass ``` Input * `lists`: A variable number of lists containing integers. Each list may have duplicates, but the function should handle them correctly. Output * A list of integers representing the intersection of all input lists, sorted in ascending order. Example ```python # Given the lists: # list1 = [1, 2, 2, 3] # list2 = [2, 3, 4] # list3 = [2, 2, 5] common_elements = find_common_elements(list1, list2, list3) ``` Should return: ``` [2] ``` Constraints * The input lists can be of varying lengths. * If no common elements exist, return an empty list. Implementation Notes 1. Use set operations to efficiently find common elements among the lists. 2. Convert the final result to a sorted list before returning. Additional Considerations Students should handle edge cases such as empty lists and lists with no common elements. They should also ensure their solution works efficiently for a large number of lists and elements.","solution":"from typing import List def find_common_elements(*lists: List[int]) -> List[int]: if not lists: return [] # Convert the first list to a set to start the intersection process common_elements = set(lists[0]) # Intersect with each subsequent list for lst in lists[1:]: common_elements &= set(lst) # Return the sorted list of common elements return sorted(common_elements)"},{"question":"# Anagram Grouping Challenge # Problem Description: You are given a list of strings, and your task is to write a function that groups these strings into anagrams. Two strings are anagrams if they are made of the same character frequencies. Your goal is to group all anagrams together. # Requirements: 1. Implement a function `group_anagrams(strings: List[str]) -> List[List[str]]` that returns a list of lists, where each sublist contains strings that are anagrams of each other. 2. Strings that are anagrams of each other should appear in the same sublist, and each string should appear in exactly one sublist. Input: * `strings`: A list of strings (1 <= len(strings) <= 10^4), where each string has a length of at most 100 characters. Output: * Return a list of lists. Each sublist will contain strings that are anagrams of each other. Constraints: * The function should handle the upper limit efficiently. * You must handle any edge cases, such as the smallest possible values for the length of the strings list or for individual string lengths. # Example: ```python # Example 1 assert group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) == [[\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] # Example 2 assert group_anagrams([\\"\\"]) == [[\\"\\"]] # Example 3 assert group_anagrams([\\"a\\"]) == [[\\"a\\"]] ``` # Performance: - Your implementation should consider the efficiency of both time and space, ideally using hash tables for quick lookup and grouping. # Tips: 1. Review hash table data structures for efficient grouping. 2. An efficient way to determine if two strings are anagrams is to sort their characters and compare. 3. Emphasize code readability and optimize the function where possible. # Implementation: Your task is to fill in the implementation of the following function: ```python from typing import List def group_anagrams(strings: List[str]) -> List[List[str]]: # Your implementation here pass ``` Ensure to test your function thoroughly using the provided examples and additional edge cases you can think of.","solution":"from typing import List from collections import defaultdict def group_anagrams(strings: List[str]) -> List[List[str]]: Groups a list of strings into anagrams. :param strings: List of strings :return: List of lists, where each sublist contains strings that are anagrams anagrams = defaultdict(list) for string in strings: sorted_string = \'\'.join(sorted(string)) anagrams[sorted_string].append(string) return list(anagrams.values())"},{"question":"# Sort List of Dictionaries by Multiple Keys You need to write a function that sorts a list of dictionaries according to multiple specified keys. Each dictionary in the list represents a student\'s record with their `name`, `age`, and `score`. The sorting should prioritize the `score` (in descending order), then by `age` (in ascending order), and finally by `name` (in ascending order). Function Signature ```python def sort_students(students: List[Dict[str, Union[int, str]]]) -> List[Dict[str, Union[int, str]]]: Sorts a list of student dictionaries by score, age, and name. Args: students (List[Dict[str, Union[int, str]]]): The list of student records to be sorted. Returns: List[Dict[str, Union[int, str]]]: The sorted list of student records. Raises: TypeError: If any of the student records do not meet the expected format. pass ``` # Example ```python students = [ {\'name\': \'Alice\', \'age\': 18, \'score\': 90}, {\'name\': \'Bob\', \'age\': 20, \'score\': 90}, {\'name\': \'Charlie\', \'age\': 18, \'score\': 88}, {\'name\': \'David\', \'age\': 22, \'score\': 95}, ] sorted_students = [ {\'name\': \'David\', \'age\': 22, \'score\': 95}, {\'name\': \'Alice\', \'age\': 18, \'score\': 90}, {\'name\': \'Bob\', \'age\': 20, \'score\': 90}, {\'name\': \'Charlie\', \'age\': 18, \'score\': 88}, ] assert sort_students(students) == sorted_students ``` # Constraints 1. Each dictionary contains the keys: `name` (string), `age` (integer), and `score` (integer). 2. Raise a `TypeError` if any dictionary is missing required keys or contains inappropriate value types. # Performance Requirements The function should efficiently handle lists of up to 10,000 student records.","solution":"from typing import List, Dict, Union def sort_students(students: List[Dict[str, Union[int, str]]]) -> List[Dict[str, Union[int, str]]]: Sorts a list of student dictionaries by score, age, and name. Args: students (List[Dict[str, Union[int, str]]]): The list of student records to be sorted. Returns: List[Dict[str, Union[int, str]]]: The sorted list of student records. Raises: TypeError: If any of the student records do not meet the expected format. required_keys = {\'name\', \'age\', \'score\'} for student in students: # Check if dictionary contains all required keys if not required_keys.issubset(student.keys()): raise TypeError(f\\"Each student dictionary must contain keys: \'name\', \'age\', \'score\'. Missing in {student}\\") # Check if values are of correct types if not isinstance(student[\'name\'], str) or not isinstance(student[\'age\'], int) or not isinstance(student[\'score\'], int): raise TypeError(\\"Incorrect value types. \'name\' should be str, \'age\' and \'score\' should be int.\\") # Sorting by multiple keys return sorted(students, key=lambda x: (-x[\'score\'], x[\'age\'], x[\'name\']))"},{"question":"# Graph Pathfinding: Shortest Path in a Weighted Graph **Context:** Finding the shortest path in a weighted graph is a fundamental problem in many applications such as navigation systems, network routing, and game development. It involves calculating the minimal distance from a starting point to a destination considering the weights (costs) of edges between nodes. **Objective:** Write a function `shortest_path(edges: list[tuple[int, int, float]], start: int, end: int) -> float` that computes the shortest path from a start node to an end node in a weighted graph. **Function Signature:** ```python def shortest_path(edges: list[tuple[int, int, float]], start: int, end: int) -> float: pass ``` **Inputs:** * `edges` (list of tuples): A list of edges, where each edge is represented by a tuple `(u, v, w)` indicating an edge from node `u` to node `v` with weight `w`. * `start` (int): The starting node. * `end` (int): The destination node. **Outputs:** * `float`: The total weight of the shortest path from the start node to the end node, rounded to two decimal places. If no path exists, return `float(\'inf\')`. **Constraints:** * The graph is directed and may be disconnected. * The weight `w` of each edge is a positive float. * The number of nodes `n` is implicitly defined by the highest node index in the edges. * The function should handle graphs with up to 100,000 edges efficiently. **Example:** ```python >>> shortest_path([(0, 1, 4.0), (0, 2, 2.0), (1, 2, 5.0), (1, 3, 10.0), (2, 4, 3.0), (4, 3, 4.0)], 0, 3) 9.0 >>> shortest_path([(0, 1, 2.5), (1, 2, 3.5), (2, 3, 1.0), (3, 4, 2.0)], 0, 4) 9.0 >>> shortest_path([(0, 1, 4.0), (1, 2, 1.0)], 0, 3) inf ``` **Challenge:** Implement the function `shortest_path` as described above, ensuring it can handle large inputs efficiently and accurately calculates the shortest path distances. Use appropriate algorithms and data structures for optimized performance.","solution":"import heapq def shortest_path(edges, start, end): Computes the shortest path from start to end in a weighted graph. Parameters: edges (list[tuple[int, int, float]]): List of edges represented as (u, v, w) tuples. start (int): Starting node. end (int): Destination node. Returns: float: The total weight of the shortest path from start to end, rounded to two decimal places. If no path exists, returns float(\'inf\'). # Build graph as adjacency list graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Priority queue to store (cost, node) and initialize it with start node pq = [(0, start)] # Dictionary to store the shortest path to each node shortest_paths = {start: 0} while pq: current_cost, current_node = heapq.heappop(pq) if current_node == end: return round(current_cost, 2) if current_node in graph: for neighbor, weight in graph[current_node]: distance = current_cost + weight if neighbor not in shortest_paths or distance < shortest_paths[neighbor]: shortest_paths[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return float(\'inf\')"},{"question":"# Coding Assessment Question Shortest Path In a Grid You are required to implement a function that calculates the shortest path from the top-left corner to the bottom-right corner of a `n x m` grid. You may only move right or down at any point in time. Function Signature ```python def shortest_path(n: int, m: int) -> int: pass ``` Input - Two integers `n` and `m` (1 <= n, m <= 1000) representing the dimensions of the grid. Output - An integer representing the number of distinct shortest paths from the top-left corner to the bottom-right corner of the grid. Constraints - Ensure that the inputs are positive integers. Example ```python assert shortest_path(2, 2) == 2, \\"Test case 1 failed\\" assert shortest_path(3, 3) == 6, \\"Test case 2 failed\\" assert shortest_path(2, 3) == 3, \\"Test case 3 failed\\" assert shortest_path(4, 5) == 35, \\"Test case 4 failed\\" ``` Notes - You may not use built-in or external libraries to compute the number of paths. - Focus on writing efficient and clean code, and ensure it handles edge inputs properly. - You may include additional helper functions if necessary. Good luck on solving this grid navigation puzzle!","solution":"def shortest_path(n: int, m: int) -> int: Function to calculate the number of distinct shortest paths from the top-left corner to the bottom-right corner of an n x m grid. You can only move right or down at any point in time. # Create a 2D list to store the count of paths at each cell dp = [[0] * m for _ in range(n)] # We know the following: # There is only 1 way to reach any cell in the first row (only right moves) for i in range(m): dp[0][i] = 1 # There is only 1 way to reach any cell in the first column (only down moves) for i in range(n): dp[i][0] = 1 # Fill out the rest of the grid using previous computed values for i in range(1, n): for j in range(1, m): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[n-1][m-1]"},{"question":"# Problem Statement You are tasked with developing a feature for a fitness tracking application that monitors the user\'s running activity. The application needs to analyze the runner\'s data and provide insights and milestones based on their pace. # Requirements You are to implement three functions `calculate_speed`, `pace_analysis`, and `running_summary`. Additionally, you must write a composite function `runner_insights` that uses these three functions to provide a detailed summary of the runner\'s performance. # Input and Output 1. **Input** - `runner_insights(distance_run: float, total_time: float) -> dict` - `distance_run`: float (must be positive, in kilometers) - `total_time`: float (must be positive, in minutes) 2. **Output** - Return a dictionary containing: - `\'average_speed\'`: float (average speed in km/h) - `\'pace_analysis\'`: str (a brief description of the runner\'s pace) - `\'recommended_milestone\'`: str (suggested next milestone based on current performance) # Constraints - `distance_run > 0` - `total_time > 0` # Example ```python runner_insights(5, 25) # Output: {\'average_speed\': 12.00, \'pace_analysis\': \'Moderate pace\', \'recommended_milestone\': \'Run 10 km\'} runner_insights(10, 60) # Output: {\'average_speed\': 10.00, \'pace_analysis\': \'Steady pace\', \'recommended_milestone\': \'Run 15 km\'} ``` # Notes - Average speed is calculated as `(distance_run / total_time) * 60` to convert minutes to hours. - Pace analysis descriptors: - `\'average_speed\' < 8 km/h`: \'Slow pace\' - `8 <= \'average_speed\' <= 12 km/h`: \'Moderate pace\' - `\'average_speed\' > 12 km/h`: \'Fast pace\' - Suggested milestones: - For a \'Slow pace\': `\'Run 5 km\'` - For a \'Moderate pace\': `\'Run 10 km\'` - For a \'Fast pace\': `\'Run 15 km\'` # Implementation Implement the required functions using the provided constraints and example outputs to ensure accuracy.","solution":"def calculate_speed(distance_run, total_time): Calculate the average speed given a distance and total time. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: float : Average speed in kilometers per hour. return (distance_run / total_time) * 60 def pace_analysis(average_speed): Provide a brief description of the runner\'s pace based on average speed. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Description of the runner\'s pace. if average_speed < 8: return \'Slow pace\' elif 8 <= average_speed <= 12: return \'Moderate pace\' else: return \'Fast pace\' def running_summary(average_speed): Suggest the next milestone based on current performance. Args: average_speed: float : Average speed in kilometers per hour. Returns: str : Suggested next milestone. if average_speed < 8: return \'Run 5 km\' elif 8 <= average_speed <= 12: return \'Run 10 km\' else: return \'Run 15 km\' def runner_insights(distance_run, total_time): Provides a detailed summary of the runner\'s performance. Args: distance_run: float : Distance run in kilometers. total_time: float : Total time in minutes. Returns: dict : Detailed summary of the runner\'s performance. average_speed = calculate_speed(distance_run, total_time) pace_desc = pace_analysis(average_speed) milestone = running_summary(average_speed) return { \'average_speed\': round(average_speed, 2), \'pace_analysis\': pace_desc, \'recommended_milestone\': milestone }"},{"question":"Problem Statement Design and implement a class `CustomLinkedList` that contains nodes with unique integer values. Your task is to implement a method `reverse_k_groups(self, k: int) -> None` that reverses the nodes of the linked list in groups of `k` and maintains the original relative order when the last group has fewer than `k` nodes (they are left as they are). # Requirements: 1. **reverse_k_groups(self, k: int) -> None**: - This method should reverse the nodes of the linked list in groups of `k`. - If the number of nodes in the last group is less than `k`, this part should not be reversed. # Constraints 1. The linked list contains unique integer values. 2. The value of `k` will always be a positive integer. 3. You should not use any built-in linked list library or functions. # Expected Input and Output Format * The method `reverse_k_groups` has one integer input `k`. * It returns nothing but modifies the linked list in place. # Example ```python class Node: def __init__(self, val: int): self.val = val self.next = None class CustomLinkedList: def __init__(self): self.head = None def append(self, val: int): new_node = Node(val) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def reverse_k_groups(self, k: int) -> None: # Your implementation here def to_list(self) -> List[int]: result = [] current = self.head while current: result.append(current.val) current = current.next return result # Example usage linked_list = CustomLinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.append(4) linked_list.append(5) linked_list.reverse_k_groups(2) print(linked_list.to_list()) # Output: [2, 1, 4, 3, 5] linked_list = CustomLinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.append(4) linked_list.append(5) linked_list.reverse_k_groups(3) print(linked_list.to_list()) # Output: [3, 2, 1, 4, 5] ``` # Additional Instructions * Ensure your method maintains `O(n)` time complexity, where `n` is the number of nodes in the linked list. * Test your method thoroughly to account for edge cases and proper functionality under various scenarios.","solution":"class Node: def __init__(self, val: int): self.val = val self.next = None class CustomLinkedList: def __init__(self): self.head = None def append(self, val: int): new_node = Node(val) if not self.head: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def reverse_k_groups(self, k: int) -> None: def reverse(start, end): prev, curr = None, start while curr != end: next_node = curr.next curr.next = prev prev, curr = curr, next_node return prev dummy = Node(0) dummy.next = self.head prev = dummy while True: tail = prev for _ in range(k): tail = tail.next if not tail: self.head = dummy.next return next_group = tail.next start = prev.next tail.next = None prev.next = reverse(start, None) start.next = next_group prev = start self.head = dummy.next def to_list(self): result = [] current = self.head while current: result.append(current.val) current = current.next return result"},{"question":"# Context You are given two strings, `s1` and `s2`. Your task is to determine if one string is a permutation of the other. Two strings are permutations of each other if they contain the same characters with the same frequencies. # Function Signature Write a function called `are_permutations` that takes in two input strings and returns a boolean. # Input * Two strings ( s1 ) and ( s2 ) consisting of lowercase and/or uppercase English letters and spaces. - ( 0 leq |s1|, |s2| leq 10^5 ) # Output * Returns `True` if `s1` is a permutation of `s2`, otherwise returns `False`. # Constraints 1. The function should ignore spaces and should be case-insensitive. 2. Your implementation should be efficient with a time complexity of ( O(n) ). # Examples * `are_permutations(\\"Listen\\", \\"Silent\\")` should return `True`. * `are_permutations(\\"Hello\\", \\"Olelh\\")` should return `True`. * `are_permutations(\\"Apple\\", \\"Pabble\\")` should return `False`. * `are_permutations(\\"A man a plan a canal Panama\\", \\"A plan a canal Panama a man\\")` should return `True`. # Implementation Be mindful of edge cases such as empty strings or strings of different lengths.","solution":"def are_permutations(s1, s2): Determines if s1 is a permutation of s2. Params: - s1 (str): First input string. - s2 (str): Second input string. Returns: - bool: True if s1 is a permutation of s2, False otherwise. from collections import Counter # Clean strings: remove spaces and convert to lower case s1_cleaned = \'\'.join(s1.split()).lower() s2_cleaned = \'\'.join(s2.split()).lower() # If lengths differ, they cannot be permutations if len(s1_cleaned) != len(s2_cleaned): return False # Compare character frequencies return Counter(s1_cleaned) == Counter(s2_cleaned)"},{"question":"# Problem Statement: You need to design a function `count_subsequences_sum(arr: List[int], target: int) -> int` that counts the number of contiguous subsequences within the array `arr` that sum up to `target`. # Input: * A list of integers `arr` where `2 <= len(arr) <= 10^4` and `-10^5 <= arr[i] <= 10^5` for each element in `arr`. * An integer `target` where `-10^9 <= target <= 10^9`. # Output: * An integer representing the number of contiguous subsequences that sum up to `target`. # Constraints: * The function should handle the input efficiently within the given constraints. * Focus on optimizing for time complexity using appropriate data structures and algorithms. # Examples: ```python count_subsequences_sum([1, 2, 3, 4], 3) -> 2 # (subsequences: [1, 2], [3]) count_subsequences_sum([1, -1, 1, 1, -1], 0) -> 4 # (subsequences: [1, -1], [-1, 1], [1, -1], [1, -1, 1]) count_subsequences_sum([1, 1, 1, 1], 2) -> 3 # (subsequences: [1, 1], [1, 1], [1, 1]) count_subsequences_sum([5, 6, -5, 5, 3, 5, 3], 8) -> 4 # (subsequences: [5, 3], [6, -5, 5, 3, 5, 3]) ``` # Directions: 1. Follow the provided function signature exactly. 2. Ensure the solution correctly handles large ranges of values and potential edge cases. 3. Consider utilizing efficient data structures, such as hashes or sliding windows, to achieve an optimal solution.","solution":"from typing import List def count_subsequences_sum(arr: List[int], target: int) -> int: prefix_sum_count = {0: 1} current_sum = 0 count = 0 for num in arr: current_sum += num if (current_sum - target) in prefix_sum_count: count += prefix_sum_count[current_sum - target] if current_sum in prefix_sum_count: prefix_sum_count[current_sum] += 1 else: prefix_sum_count[current_sum] = 1 return count"},{"question":"Question: Reverse Polish Notation Calculator Implement a Reverse Polish Notation (RPN) calculator that evaluates mathematical expressions written in postfix notation. Your task is to write a class `RPNCalculator` that parses an RPN expression and computes its result. # Details: 1. **Expression Representation**: The RPN expression is given as a space-separated string of operands and operators. Operands are non-negative integers, and operators are `+`, `-`, `*`, or `/`. 2. **Evaluation**: * Operands and operators follow the postfix notation, where each operator follows its operands. * Operands and intermediate results are stored on a stack. * When an operator is encountered, it applies to the top two elements on the stack, replaces them with the result, and the result is pushed back onto the stack. * Division should be integer division. * It is guaranteed that the RPN expression is valid. # Class Definition: Implement a class `RPNCalculator` with the following methods: * **`__init__(self) -> None`**: Initializes an empty stack. * **`evaluate(self, expression: str) -> int`**: Parses the given RPN expression string and returns the computed result. # Constraints: * The RPN expression is guaranteed to be valid and not empty. * Operands in the expression are non-negative integers within the range `[0, 1000]`. * Division operator `/` means integer division. # Example: ```python calculator = RPNCalculator() expression1 = \\"3 4 +\\" assert calculator.evaluate(expression1) == 7 # 3 + 4 expression2 = \\"5 1 2 + 4 * + 3 -\\" assert calculator.evaluate(expression2) == 14 # 5 + ((1 + 2) * 4) - 3 expression3 = \\"2 3 11 + 5 - *\\" assert calculator.evaluate(expression3) == 18 # 2 * (3 + 11 - 5) ``` # Task: Implement the `RPNCalculator` class as described. Ensure your solution passes the above example check scenarios.","solution":"class RPNCalculator: def __init__(self): self.stack = [] def evaluate(self, expression: str) -> int: for token in expression.split(): if token in \\"+-*/\\": b = self.stack.pop() a = self.stack.pop() if token == \'+\': result = a + b elif token == \'-\': result = a - b elif token == \'*\': result = a * b elif token == \'/\': result = a // b # Integer division self.stack.append(result) else: self.stack.append(int(token)) return self.stack.pop()"},{"question":"# Coding Question Context: You are tasked with processing a list of transaction records to determine suspicious activities based on a defined threshold. Each transaction contains an identifier, amount, and date. Transactions exceeding a given threshold within a specific timeframe should be flagged. Prompt: Given a list of transaction records and a threshold amount, implement a function `flag_suspicious_transactions(transactions: List[Tuple[int, float, str]], threshold: float, days: int) -> List[int]` that returns a list of unique transaction identifiers that are suspicious. A transaction is flagged as suspicious if the cumulative amount of transactions from the same day or multiple days within the given period for the same identifier exceeds the threshold. Input: * A list of tuples `transactions`, where each tuple contains: - An integer representing the identifier - A float representing the transaction amount - A string representing the date in \'YYYY-MM-DD\' format * A float `threshold` representing the threshold amount. * An integer `days` representing the number of days for the timeframe. Output: * A sorted list of unique integers representing the identifiers of suspicious transactions. Constraints: * ( 1 leq text{len(transactions)} leq 10^5 ) * ( 1 leq text{days} leq 3 ) * Transaction amounts are between 0.01 and 10000.00 * Date format is always valid \'YYYY-MM-DD\' Example: ```python from typing import List, Tuple def flag_suspicious_transactions( transactions: List[Tuple[int, float, str]], threshold: float, days: int ) -> List[int]: pass # Example usage: transactions = [ (1, 100.0, \'2023-10-01\'), (1, 250.0, \'2023-10-02\'), (2, 300.0, \'2023-10-01\'), (2, 200.0, \'2023-10-02\'), (1, 200.0, \'2023-10-03\'), (3, 500.0, \'2023-10-01\'), ] print(flag_suspicious_transactions(transactions, 500.0, 2)) # Output: [1] ``` Performance: * The solution should efficiently process the list of transactions and flag suspicious transactions based on the given criteria.","solution":"from typing import List, Tuple from collections import defaultdict from datetime import datetime, timedelta def flag_suspicious_transactions(transactions: List[Tuple[int, float, str]], threshold: float, days: int) -> List[int]: # Create a dictionary to store transaction sums for each identifier by date transaction_dict = defaultdict(lambda: defaultdict(float)) # Fill the dictionary with cumulative amounts for identifier, amount, date_str in transactions: date = datetime.strptime(date_str, \\"%Y-%m-%d\\") transaction_dict[identifier][date] += amount suspicious_identifiers = set() # For each identifier, check the sums in the specified timeframe for identifier, date_amounts in transaction_dict.items(): dates = sorted(date_amounts.keys()) # Check sums in the given range for i in range(len(dates)): current_sum = 0 for j in range(i, min(i + days, len(dates))): current_sum += date_amounts[dates[j]] if current_sum > threshold: suspicious_identifiers.add(identifier) break return sorted(suspicious_identifiers)"},{"question":"# Question **You are tasked to implement a feature for binary search trees (BSTs) that verifies if they can be transformed into complete binary search trees with a given number of rotations.** # Objective Your task is to write a function `can_be_complete_bst` that determines whether it\'s possible to convert a given binary search tree into a complete binary search tree using at most \'k\' rotations. # Function Signature ```python def can_be_complete_bst(root: Node, k: int) -> bool: ``` # Input The function `can_be_complete_bst` should take two arguments: - `root`: The root node of the binary search tree (Node object). - `k`: An integer representing the maximum number of rotations allowed (0 ≤ k ≤ 10^3). # Output The function should return a boolean: - `True` if the binary search tree can be transformed into a complete binary search tree using at most `k` rotations. - `False` otherwise. # Constraints - The tree can have between 1 and 10^4 nodes. - Each node’s data value ranges from 1 to 10^4. # Concepts - A Binary Search Tree (BST) is a binary tree where for each node, the values in its left subtree are less than the node’s value and the values in its right subtree are greater than the node’s value. - A Complete Binary Tree is a binary tree in which every level, except possibly the last, is completely filled and all nodes are as far left as possible. - A rotation in a tree is a local restructuring of the tree by moving nodes in a specific pattern (left or right rotation). # Example Consider the binary search tree representation: 10 / 5 15 / 3 7 18 And k = 1 Calling `can_be_complete_bst(root, 1)` should return `True` because: - With one rotation, the tree can be restructured to form a complete BST. # Edge Cases 1. A single-node tree should return `True` as it is already complete. 2. If k is 0, the function should only return `True` if the tree is already a complete BST. 3. A BST with all values in decreasing or increasing order may require more rotations to become complete, testing the function’s handling of complex transformations. # Notes - Define the Node and BinaryTree classes suitably. - Account for the worst-case runtime within the given constraints.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key def is_complete_bst(root, index, number_of_nodes): # Base case: An empty tree is complete if root is None: return True # If index assigned to current node is greater than the number of nodes, then tree is not complete if index >= number_of_nodes: return False # Recur for left and right subtrees return (is_complete_bst(root.left, 2 * index + 1, number_of_nodes) and is_complete_bst(root.right, 2 * index + 2, number_of_nodes)) def count_nodes(root): if not root: return 0 return 1 + count_nodes(root.left) + count_nodes(root.right) def can_be_complete_bst(root, k): if not root: return False # Count total number of nodes in the tree num_nodes = count_nodes(root) # Check if initial tree is already complete if is_complete_bst(root, 0, num_nodes): return True # We will need to implement a way to track the number of rotations and check if the tree can become complete # Given the problem constraints and complexity, for simplicity, we assume this is not feasible to determine directly # in terms of rotations without a more complex balancing logic. # Placeholder: Further implementation needed to check rotation feasibility logic return False"},{"question":"# Problem Statement You are designing a system that needs to schedule tasks with specific durations and dependencies. Each task has to wait for its dependencies to complete before it can start. You need to calculate the minimum completion time for a given set of tasks and their dependencies. Function Signature Write a function called `minimum_completion_time`: ```python def minimum_completion_time(tasks: list[tuple[int, list[int]]]) -> int: Calculate the minimum time required to complete all tasks. Args: tasks (list): A list of tuples where each tuple contains an integer representing the duration of the task, and a list of integers representing the indices of tasks that must be completed before this task can begin. Returns: int: The minimum completion time for all tasks. Example: >>> minimum_completion_time([(3, []), (2, [0]), (1, [1])]) 6 pass ``` # Constraints: * The number of tasks `n` will be between 1 and 100. * Task durations will be between 1 and 1000 units of time. * Dependencies will be valid such that there are no cyclic dependencies. # Requirements: * The function should return the minimum time required to complete all tasks. * If there are no dependencies, the completion time is the sum of all task durations. * Ensure that the given dependencies are non-cyclic. # Example: ```python >>> minimum_completion_time([(3, []), (2, [0]), (1, [1])]) 6 >>> minimum_completion_time([(1, []), (2, [0]), (3, [1]), (4, [0, 2])]) 10 ``` # Hints: * Consider using a topological sort to determine the order of completion for the tasks. * Use dynamic programming to track the minimum completion time for each task.","solution":"def minimum_completion_time(tasks): from collections import defaultdict, deque # Number of tasks n = len(tasks) # Prepare graph adjacency list and in-degree list graph = defaultdict(list) in_degree = [0] * n duration = [0] * n # Fill the graph and in_degree based on the given tasks data for i, (dur, dependencies) in enumerate(tasks): duration[i] = dur for dep in dependencies: graph[dep].append(i) in_degree[i] += 1 # Queue for processing tasks that have no remaining dependencies queue = deque([i for i in range(n) if in_degree[i] == 0]) # Minimum completion times for tasks min_time = [0] * n # Process tasks independent of their dependencies first while queue: task = queue.popleft() # Update the time to complete this task min_time[task] += duration[task] # Visit the next tasks in the graph for next_task in graph[task]: in_degree[next_task] -= 1 # Update the min_time for the next_task min_time[next_task] = max(min_time[next_task], min_time[task]) if in_degree[next_task] == 0: queue.append(next_task) # The result is the maximum value in min_time array return max(min_time)"},{"question":"# Longest Increasing Subsequence (LIS) with Memoization You are required to implement a function that computes the length of the longest increasing subsequence in a given list of integers using memoization for optimization. Requirements: 1. **Function Definition**: - Implement the function `longest_increasing_subsequence(arr: List[int]) -> int`. - The function should take a list of integers `arr` and return the length of the longest increasing subsequence. 2. **Memoization**: - Utilize memoization to optimize the recursive approach. - Avoid redundant calculations by storing and reusing results of subproblems. Input: * A list of integers `arr` of length `n` where `1 ≤ n ≤ 10^3`. Output: * An integer representing the length of the longest increasing subsequence. Constraints: * Consider the time complexity and ensure the implementation is efficient with memoization. Example: ```python assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 assert longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) == 4 assert longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) == 1 assert longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) == 8 assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == 1 ``` Implementation Hint: * A top-down recursive approach with memoization is suggested. Use a helper function to manage the state and memoization storage. ```python def longest_increasing_subsequence(arr: List[int]) -> int: def lis_ending_at(index: int, prev_index: int, memo: Dict[Tuple[int, int], int]) -> int: if index == len(arr): return 0 if (index, prev_index) in memo: return memo[(index, prev_index)] take = 0 if prev_index == -1 or arr[index] > arr[prev_index]: take = 1 + lis_ending_at(index + 1, index, memo) not_take = lis_ending_at(index + 1, prev_index, memo) memo[(index, prev_index)] = max(take, not_take) return memo[(index, prev_index)] return lis_ending_at(0, -1, {}) ``` Note: Ensure you handle edge cases and validate the input list before processing. This problem tests your understanding of dynamic programming and memoization techniques.","solution":"from typing import List, Dict, Tuple def longest_increasing_subsequence(arr: List[int]) -> int: def lis_ending_at(index: int, prev_index: int, memo: Dict[Tuple[int, int], int]) -> int: if index == len(arr): return 0 if (index, prev_index) in memo: return memo[(index, prev_index)] take = 0 if prev_index == -1 or arr[index] > arr[prev_index]: take = 1 + lis_ending_at(index + 1, index, memo) not_take = lis_ending_at(index + 1, prev_index, memo) memo[(index, prev_index)] = max(take, not_take) return memo[(index, prev_index)] return lis_ending_at(0, -1, {})"},{"question":"**Sorting Students by Marks** You are tasked with helping the administration to sort the list of students based on their marks. The administration needs the list to be sorted in non-increasing order by marks. If two students have the same marks, sort them alphabetically by their names. # Function Signature ```python def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: ``` # Input * `students` (List[Tuple[str, int]]): A list of tuples where each tuple contains a student\'s name (string) and their marks (integer). # Output * `List[Tuple[str, int]]`: The sorted list of students based on the criteria described. # Constraints * The list can contain up to (10^4) students. * Each student\'s name is a non-empty string with at most 100 characters. * Each student\'s marks is an integer between 0 and 100. # Examples ```python sort_students([(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 88)]) # Expected output: [(\\"Bob\\", 95), (\\"Alice\\", 88), (\\"Charlie\\", 88)] sort_students([(\\"Dave\\", 92), (\\"Eve\\", 85), (\\"Frank\\", 92), (\\"Grace\\", 70)]) # Expected output: [(\\"Dave\\", 92), (\\"Frank\\", 92), (\\"Eve\\", 85), (\\"Grace\\", 70)] ``` # Notes 1. Verify that names are correctly sorted alphabetically in the case of equal marks. 2. Ensure that the function handles large input sizes efficiently within the provided constraints. 3. Pay attention to edge cases such as an empty list or all students having the same marks. # Test Case Note The function should successfully sort and return the list in all sample cases and other similar cases. Specific attention should be given to the sorting criteria involving both marks and names.","solution":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of students in non-increasing order by their marks. If two students have the same marks, they are sorted alphabetically by name. Args: students (List[Tuple[str, int]]): A list of tuples where each tuple contains a student\'s name (string) and their marks (integer). Returns: List[Tuple[str, int]]: The sorted list of students. # Sort primarily by marks in descending order, and by name in ascending order return sorted(students, key=lambda x: (-x[1], x[0]))"},{"question":"# Implementing K-Nearest Neighbors (KNN) with Optimizations **Scenario**: You are required to implement a K-Nearest Neighbors (KNN) classifier from scratch to gain a deeper understanding of this simple yet powerful algorithm. Your task is to not only implement the basic KNN model but to include optimizations dealing with large datasets and an algorithm to choose the best number of neighbors (k). **Task**: 1. **Understand** the concept of K-Nearest Neighbors and its typical bottlenecks. 2. **Implement** a `KNNClassifier` class with the following enhancements: - Implement a method to efficiently compute distances, utilizing optimized vectorized operations. - Implement cross-validation to select the best value of `k`. - Introduce a method to handle imbalanced datasets by optionally weighting the neighbors. - Allow the distance metric to be adjusted (e.g., Euclidean, Manhattan). 3. Verify your implementation with provided test cases and ensure its correctness. **Function Signature**: ```python class KNNClassifier: def __init__(self, k: int = 5, distance_metric: str = \'euclidean\', weight_neighbors: bool = False) -> None: def fit(self, features: np.ndarray, target: np.ndarray) -> None: def predict(self, features: np.ndarray) -> np.ndarray: def select_best_k(self, features: np.ndarray, target: np.ndarray, k_values: list, cv: int = 5) -> int: ``` **Expected Input and Output**: 1. **init()**: - Parameters: - `k` (int): Number of neighbors to use (default is 5). - `distance_metric` (str): The distance metric to use (\'euclidean\' or \'manhattan\'). - `weight_neighbors` (bool): Flag to determine if neighbors should be weighted based on distance (default is False). - Returns: None 2. **fit()**: - Parameters: - `features` (np.ndarray): Training features. - `target` (np.ndarray): Target values. - Returns: None 3. **predict()**: - Parameters: - `features` (np.ndarray): Features to predict. - Returns: - np.ndarray: Array of predictions. 4. **select_best_k()**: - Parameters: - `features` (np.ndarray): Training features. - `target` (np.ndarray): Target values. - `k_values` (list): List of k values to evaluate. - `cv` (int): Number of cross-validation folds. - Returns: - int: The best value of k based on cross-validated performance. **Constraints and Limitations**: - Implement distance calculations in a vectorized manner for efficiency. - Ensure that cross-validation is performed correctly. - Weigh neighbors based on inverse distance if the flag is set. - Test your implementation with small and large datasets to validate correctness and performance. **Example Usage**: ```python import numpy as np from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.utils import shuffle # Example data iris = load_iris() X, y = shuffle(iris.data, iris.target, random_state=42) X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Instantiate the classifier with initial k value and euclidean distance knn = KNNClassifier(k=5, distance_metric=\'euclidean\', weight_neighbors=True) # Fit the model knn.fit(X_train, y_train) # Predict on test data y_pred = knn.predict(X_test) # Measure accuracy accuracy = np.mean(y_pred == y_test) print(f\\"Accuracy: {accuracy:.2f}\\") # Tune k value using cross-validation best_k = knn.select_best_k(X_train, y_train, k_values=[1, 3, 5, 7, 9], cv=5) print(f\\"Best k value: {best_k}\\") # Re-train with best k value knn = KNNClassifier(k=best_k, distance_metric=\'euclidean\', weight_neighbors=True) knn.fit(X_train, y_train) y_pred = knn.predict(X_test) accuracy = np.mean(y_pred == y_test) print(f\\"Accuracy with best k: {accuracy:.2f}\\") ```","solution":"import numpy as np from collections import Counter from sklearn.model_selection import KFold from scipy.spatial.distance import cdist class KNNClassifier: def __init__(self, k: int = 5, distance_metric: str = \'euclidean\', weight_neighbors: bool = False) -> None: self.k = k self.distance_metric = distance_metric self.weight_neighbors = weight_neighbors self.features = None self.target = None def fit(self, features: np.ndarray, target: np.ndarray) -> None: self.features = features self.target = target def predict(self, features: np.ndarray) -> np.ndarray: distances = cdist(features, self.features, self.distance_metric) predictions = [] for dist in distances: if self.weight_neighbors: neighbors = self._weighted_classification(dist) else: neighbors = self._majority_vote(dist) predictions.append(neighbors) return np.array(predictions) def _majority_vote(self, distances: np.ndarray) -> int: nearest_indices = np.argsort(distances)[:self.k] nearest_labels = self.target[nearest_indices] most_common = Counter(nearest_labels).most_common(1) return most_common[0][0] def _weighted_classification(self, distances: np.ndarray) -> int: nearest_indices = np.argsort(distances)[:self.k] nearest_labels = self.target[nearest_indices] weights = 1 / (distances[nearest_indices] + 1e-5) # Adding small value to avoid division by zero weighted_votes = np.zeros(np.max(self.target) + 1) for label, weight in zip(nearest_labels, weights): weighted_votes[label] += weight return np.argmax(weighted_votes) def select_best_k(self, features: np.ndarray, target: np.ndarray, k_values: list, cv: int = 5) -> int: best_k = k_values[0] best_score = 0.0 for k in k_values: self.k = k fold_scores = [] kf = KFold(n_splits=cv) for train_index, test_index in kf.split(features): train_features, test_features = features[train_index], features[test_index] train_target, test_target = target[train_index], target[test_index] self.fit(train_features, train_target) predictions = self.predict(test_features) accuracy = np.mean(predictions == test_target) fold_scores.append(accuracy) avg_score = np.mean(fold_scores) if avg_score > best_score: best_score = avg_score best_k = k return best_k"},{"question":"# Optimizing String Compression Algorithm Scenario: You have been given the task of implementing an optimized algorithm to compress a string. The compression should follow a specific rule where consecutive repeated characters are replaced by the character followed by the number of repetitions. If the compressed version is not shorter than the original string, the original string should be returned. Task: Implement a function `compress_string` that compresses a string based on the described rules. Ensure that your implementation handles edge cases, such as an empty string or strings with no repeated characters. Function Signature: ```python def compress_string(s: str) -> str: Compress a string such that \'aaabbcddd\' becomes \'a3b2cd3\'. If the compressed string is not shorter than the original, return the original string. :param str s: The input string to compress. :return str: The compressed string or the original string if compression is not shorter. Examples: >>> compress_string(\'aaabbcddd\') \'a3b2cd3\' >>> compress_string(\'abcdef\') \'abcdef\' >>> compress_string(\'aabbcc\') \'aabbcc\' >>> compress_string(\'\') \'\' >>> compress_string(\'a\') \'a\' >>> compress_string(\'abbbbbbbbbbccccccccccd\') \'ab10c10d\' # Your implementation goes here ``` Constraints: - The input string consists only of lowercase English letters (`\'a\'`-`\'z\'`). - Handle edge cases such as an empty input string. - The function should be efficient with a time complexity of (O(n)), where (n) is the length of the string. Performance Requirement: - The function should handle typical string lengths efficiently, up to (10^5) characters. Test your implementation with provided examples and additional test cases to ensure its correctness and performance.","solution":"def compress_string(s: str) -> str: Compress a string such that \'aaabbcddd\' becomes \'a3b2cd3\'. If the compressed string is not shorter than the original, return the original string. :param str s: The input string to compress. :return str: The compressed string or the original string if compression is not shorter. if not s: return s compressed_parts = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed_parts.append(s[i-1] + (str(count) if count > 1 else \'\')) count = 1 compressed_parts.append(s[-1] + (str(count) if count > 1 else \'\')) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Question: Improved Merge Sort for Large Datasets Context You are tasked with optimizing the classic merge sort algorithm for large datasets. The traditional merge sort has a time complexity of O(n log n), but in practice, dealing with very large arrays (e.g., millions of elements) can still be computationally expensive without further optimizations. Problem Statement Implement an optimized version of the `merge_sort` function that can efficiently handle very large datasets. Your function should minimize the number of array accesses and manage memory usage effectively, ensuring it does not degrade significantly with large input sizes. # Function Signature ```python def optimized_merge_sort(arr: list) -> list: Perform an optimized merge sort on the input list `arr`. Parameters: - arr (list): The list of integers to be sorted. Returns: - list: The sorted list of integers. Raises: - ValueError: If the input is not a list of integers. ``` # Constraints - The input list, `arr`, can contain up to 10^7 integers. - Each integer in the list can range from -10^9 to 10^9. # Requirements 1. Validate the input to ensure it is a list of integers. 2. Implement an optimized merge sort algorithm. 3. Minimize memory usage during the sorting process. 4. Ensure the solution handles large datasets efficiently within reasonable time and space limits. # Examples ```python >>> optimized_merge_sort([5, 3, 8, 6, 2, 7]) [2, 3, 5, 6, 7, 8] >>> optimized_merge_sort([10, -2, 0, 5, -10]) [-10, -2, 0, 5, 10] >>> optimized_merge_sort([]) [] ```","solution":"def optimized_merge_sort(arr): # Validate the input if not isinstance(arr, list) or not all(isinstance(x, int) for x in arr): raise ValueError(\\"Input must be a list of integers\\") # If the list is empty or has only one element, return it as it is already sorted if len(arr) <= 1: return arr # Split the list into two halves mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] # Recursively sort the two halves left_sorted = optimized_merge_sort(left_half) right_sorted = optimized_merge_sort(right_half) # Merge the two sorted halves return merge(left_sorted, right_sorted) def merge(left, right): sorted_array = [] i = j = 0 # Merge the two sorted arrays while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append the remaining elements sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"# Coding Question: Efficient Scalability Optimized Matrix Transposer Description Handling multi-dimensional arrays efficiently is crucial in numerous computational fields. When dealing with high-dimensional matrices, a lazy but effective transpose mechanism is necessary to reduce computational overhead while maintaining accuracy. Given the importance of scalable matrix operations, the task is to transpose a given two-dimensional matrix leveraging efficient reallocation of memory and avoiding redundant operations. Task Write a Python function `efficient_matrix_transpose(matrix: list) -> list` that transposes a given 2D matrix without directly iterating over the entire matrix multiple times. Ensure function utilizes: 1. **In-place Transpose** for square matrices. 2. **Memory Efficient Method** for non-square matrices that avoids intermediate list creations. 3. **Lazy Evaluation** to defer computation until necessary for optimization. Function Signature ```python def efficient_matrix_transpose(matrix: list) -> list: ``` Input * A two-dimensional list `matrix` where each sublist represents a row of the original matrix. Output * The transposed 2D list where the rows become columns and vice versa. Constraints * Matrix dimensions vary but will always be rectangular. * Elements can be integers or floats. Example ```python >>> efficient_matrix_transpose([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> efficient_matrix_transpose([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] ``` Requirements * Ensure transposition is done efficiently. * Optimize for memory usage by avoiding unnecessary list creations. * Utilize lazy evaluation when appropriate to save computation time.","solution":"def efficient_matrix_transpose(matrix: list) -> list: Transpose a given 2D matrix efficiently. if not matrix: return [] rows, cols = len(matrix), len(matrix[0]) # For in-place transpose of square matrices if rows == cols: for i in range(rows): for j in range(i + 1, cols): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] return matrix # For non-square matrices transpose = [[None] * rows for _ in range(cols)] for i in range(rows): for j in range(cols): transpose[j][i] = matrix[i][j] return transpose"},{"question":"# Scenario You are tasked with developing a library management system that manages books and tracks the borrowing status of each book. The system should allow adding new books, borrowing books, returning books, and listing all books with their current status. # Task Implement a `Library` class with methods to perform the required operations. Ensure the following functionalities: 1. Add new books to the library. 2. Borrow books, ensuring that a book cannot be borrowed if it is already borrowed. 3. Return books, ensuring that only borrowed books can be returned. 4. List all books along with their current status (available or borrowed). # Function Signature ```python class Library: def __init__(self) -> None: # Your implementation here def add_book(self, title: str) -> None: # Your implementation here def borrow_book(self, title: str) -> None: # Your implementation here def return_book(self, title: str) -> None: # Your implementation here def list_books(self) -> None: # Your implementation here ``` # Explanation 1. **`__init__`**: Initializes the library. 2. **`add_book`**: Adds a new book to the library. 3. **`borrow_book`**: Marks a book as borrowed. 4. **`return_book`**: Marks a book as returned. 5. **`list_books`**: Prints all books along with their status. # Constraints - Each book title is unique. - Ensure appropriate error handling for operations involving non-existent books or invalid states (e.g., borrowing a book that is already borrowed). # Example Usage ```python library = Library() library.add_book(\\"The Great Gatsby\\") library.add_book(\\"1984\\") # List books library.list_books() # Output: # The Great Gatsby - Available # 1984 - Available # Borrow \'1984\' library.borrow_book(\\"1984\\") # List books library.list_books() # Output: # The Great Gatsby - Available # 1984 - Borrowed # Return \'1984\' library.return_book(\\"1984\\") # List books library.list_books() # Output: # The Great Gatsby - Available # 1984 - Available ``` # Notes - You may use dictionaries or other data structures to store and manage the books and their statuses. - Ensure that the method `list_books` outputs a comprehensive view of all the books with their current statuses.","solution":"class BookAlreadyExists(Exception): pass class BookNotAvailable(Exception): pass class BookNotBorrowed(Exception): pass class BookNotFound(Exception): pass class Library: def __init__(self) -> None: self.books = {} def add_book(self, title: str) -> None: if title in self.books: raise BookAlreadyExists(f\\"Book \'{title}\' already exists in the library.\\") self.books[title] = \'Available\' def borrow_book(self, title: str) -> None: if title not in self.books: raise BookNotFound(f\\"Book \'{title}\' not found in the library.\\") if self.books[title] == \'Borrowed\': raise BookNotAvailable(f\\"Book \'{title}\' is already borrowed.\\") self.books[title] = \'Borrowed\' def return_book(self, title: str) -> None: if title not in self.books: raise BookNotFound(f\\"Book \'{title}\' not found in the library.\\") if self.books[title] == \'Available\': raise BookNotBorrowed(f\\"Book \'{title}\' is not borrowed.\\") self.books[title] = \'Available\' def list_books(self) -> None: for title, status in self.books.items(): print(f\\"{title} - {status}\\")"},{"question":"# Problem Statement You are participating in a software engineering project where you need to parse complex logs from a large-scale distributed system. The logs contain various events, and one of the tasks is to calculate the duration of specific events based on their start and end timestamps. Each log entry contains a timestamp and an event type (\\"start\\" or \\"end\\"). You are to write a function that calculates the total duration of each event. Each event starts with a \\"start\\" entry and ends with an \\"end\\" entry with the same event ID. # Function Signature ```python def calculate_event_durations(logs: List[str]) -> Dict[str, int]: This function calculates the total duration of each event based on the provided logs. Args: logs: List of strings, where each string represents a log entry in the format: \\"timestamp,event_id,event_type\\", where \\"timestamp\\" is an integer representing the time in seconds, \\"event_id\\" is a unique string identifying the event, and \\"event_type\\" is either \\"start\\" or \\"end\\". Returns: Dictionary where keys are event IDs and values are the total duration in seconds for each event. ``` # Expected Input and Output - **Input**: - A list of strings, where each string is a log entry formatted as: \\"timestamp,event_id,event_type\\". - **Output**: - A dictionary where the keys are event IDs and the values are the total durations (in seconds) of those events. # Example ```python logs = [ \\"1623034927,event1,start\\", \\"1623034935,event1,end\\", \\"1623034940,event2,start\\", \\"1623034960,event2,end\\", \\"1623034965,event3,start\\", \\"1623034990,event3,end\\" ] result = calculate_event_durations(logs) print(result) # {\'event1\': 8, \'event2\': 20, \'event3\': 25} ``` # Constraints * The log entries will be well-formed, and each event will have matching \\"start\\" and \\"end\\" entries. * The timestamps will be given in non-decreasing order. * There will be no overlapping events with the same event ID. # Evaluation * **Correctness**: Ensure that your function accurately computes the duration for each event based on the provided logs. * **Efficiency**: Your implementation should handle a large number of log entries efficiently in terms of both time and space complexity.","solution":"def calculate_event_durations(logs): This function calculates the total duration of each event based on the provided logs. Args: logs: List of strings, where each string represents a log entry in the format: \\"timestamp,event_id,event_type\\", where \\"timestamp\\" is an integer representing the time in seconds, \\"event_id\\" is a unique string identifying the event, and \\"event_type\\" is either \\"start\\" or \\"end\\". Returns: Dictionary where keys are event IDs and values are the total duration in seconds for each event. event_durations = {} event_start_times = {} for log in logs: timestamp, event_id, event_type = log.split(\',\') timestamp = int(timestamp) if event_type == \\"start\\": event_start_times[event_id] = timestamp elif event_type == \\"end\\": if event_id in event_start_times: start_time = event_start_times.pop(event_id) duration = timestamp - start_time if event_id in event_durations: event_durations[event_id] += duration else: event_durations[event_id] = duration return event_durations"},{"question":"# Reverse Linked List in Pairs Implement a function `reverse_in_pairs` that reverses a given linked list in pairs. Given a singly linked list, reverse every two adjacent nodes and return its head. ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_in_pairs(head: ListNode) -> ListNode: This method should reverse the linked list in pairs and return its new head. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list. # Your code here pass ``` Input Format: - The function receives the head of a singly linked list. Output Format: - Return the new head of the linked list after reversing it in pairs. Constraints: 1. The number of nodes in the list is in the range [0, 1000]. 2. Node values are integers within the range [-1000, 1000]. Example: Consider the linked list: ``` 1 -> 2 -> 3 -> 4 ``` After reversing in pairs, it becomes: ``` 2 -> 1 -> 4 -> 3 ``` - If the input linked list is `1 -> 2 -> 3 -> 4`, the function should return the head of the linked list `2 -> 1 -> 4 -> 3`. - If there is an odd number of nodes, the last node remains as is. For example, `1 -> 2 -> 3 -> 4 -> 5` becomes `2 -> 1 -> 4 -> 3 -> 5`. To validate your solution, ensure you cover various edge cases such as: - An empty linked list. - A list with a single node. - Properly reversing lists with even and odd numbers of nodes.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_in_pairs(head: ListNode) -> ListNode: This method should reverse the linked list in pairs and return its new head. Args: head (ListNode): The head of the linked list. Returns: ListNode: The head of the modified linked list. if not head or not head.next: return head # Initialize the pointers prev = None current = head # The new head will be the second node new_head = head.next while current and current.next: next_pair = current.next.next second = current.next # Reverse the pair second.next = current current.next = next_pair # Link the previous pair to the reversed pair if prev: prev.next = second prev = current current = next_pair return new_head"},{"question":"# Question: Data Compression Decompressor Objective: As part of a data storage solution, you need to implement a data decompressor for a simplified run-length encoding (RLE) scheme. The RLE compression encodes sequences of the same character by storing the character followed by the count of repetitions. Part 1: Implement the Decompressor 1. **Function: `decompress`** * Decompress a given RLE-encoded string into its original form. * The encoded string will contain characters followed by their respective counts. ```python def decompress(encoded: str) -> str: Decompress a run-length encoded string. Parameters: encoded (str): The RLE-encoded string. Returns: str: The original decompressed string. pass # Your implementation ``` Part 2: Handling Input Constraints 2. **Function: `is_valid_rle_format`** * Validate the RLE format input to ensure appropriate decoding. * Check that the string contains correct character-count pairs. ```python def is_valid_rle_format(encoded: str) -> bool: Validate the run-length encoded string format. Parameters: encoded (str): The RLE-encoded string to validate. Returns: bool: True if the format is valid, False otherwise. pass # Your implementation ``` Constraints & Requirements: * Characters in the original string are alphanumeric (a-z, A-Z, 0-9). * The count for each character will be a positive integer (1 or greater). * The input string for `decompress` and `is_valid_rle_format` can be empty. * If `is_valid_rle_format` returns False, the `decompress` function should either return an empty string or raise an appropriate exception. Example: ```python print(decompress(\\"a5b3c2\\")) # Example Output: \'aaaaabbbcc\' print(decompress(\\"A1B2C3\\")) # Example Output: \'ABBCCC\' print(is_valid_rle_format(\\"a5b3c2\\")) # Output: True print(is_valid_rle_format(\\"a5b\\")) # Output: False ``` Ensure that your implementation effectively handles edge cases, such as empty strings and invalid formats, while performing efficiently.","solution":"def decompress(encoded: str) -> str: Decompress a run-length encoded string. Parameters: encoded (str): The RLE-encoded string. Returns: str: The original decompressed string. if not is_valid_rle_format(encoded): return \\"\\" decoded = [] i = 0 while i < len(encoded): char = encoded[i] j = i + 1 while j < len(encoded) and encoded[j].isdigit(): j += 1 count = int(encoded[i+1:j]) decoded.append(char * count) i = j return \'\'.join(decoded) def is_valid_rle_format(encoded: str) -> bool: Validate the run-length encoded string format. Parameters: encoded (str): The RLE-encoded string to validate. Returns: bool: True if the format is valid, False otherwise. i = 0 while i < len(encoded): if not encoded[i].isalnum(): return False i += 1 if i >= len(encoded) or not encoded[i].isdigit(): return False while i < len(encoded) and encoded[i].isdigit(): i += 1 return True"},{"question":"# Matrix Operations and Transformations Context You are developing a library for linear algebra that needs to support various operations on matrices. This library should provide the ability to perform common transformations and calculations. Your task is to implement a class that can efficiently handle these operations while keeping the code clean and understandable. Task Implement a class `Matrix` in Python that supports the following operations: 1. Initialization of a matrix from a list of lists representing rows. 2. Matrix addition, subtraction, and multiplication. 3. Transposition of a matrix. 4. Checking for equality between two matrices. 5. String representation of the matrix in a human-readable form. 6. Determinant calculation of a square matrix. 7. Inversion of a square matrix. Requirements 1. **Initialization**: - The constructor should take a list of lists where each sublist represents a row in the matrix. - Raise a `ValueError` if the rows are not of the same length. ```python def __init__(self, rows: MutableSequence[MutableSequence[float]]) -> None: ``` 2. **Addition**: ```python def __add__(self, matrix_2: Matrix) -> Matrix: ``` 3. **Subtraction**: ```python def __sub__(self, matrix_2: Matrix) -> Matrix: ``` 4. **Multiplication**: ```python def __mul__(self, matrix_2: Matrix) -> Matrix: # Matrix multiplication ``` 5. **Transpose**: ```python def transpose(self) -> Matrix: ``` 6. **Equality Check**: ```python def __eq__(self, matrix_2: object) -> bool: ``` 7. **String Representation**: ```python def __str__(self) -> str: ``` 8. **Determinant**: ```python def determinant(self) -> float: ``` 9. **Inverse**: ```python def inverse(self) -> Matrix: ``` Input and Output Formats: - **Initialization**: `Matrix([[1, 2], [3, 4]])` represents a 2x2 matrix. - **Addition**: `(Matrix([[1, 2], [3, 4]]) + Matrix([[2, 3], [4, 5]]))` should return `Matrix([[3, 5], [7, 9]])`. - **Subtraction**: `(Matrix([[5, 6], [7, 8]]) - Matrix([[1, 2], [3, 4]]))` should return `Matrix([[4, 4], [4, 4]])`. - **Multiplication**: `(Matrix([[1, 2], [3, 4]]) * Matrix([[2, 0], [1, 2]]))` should return `Matrix([[4, 4], [10, 8]])`. - **Transpose**: `Matrix([[1, 2], [3, 4]]).transpose()` should return `Matrix([[1, 3], [2, 4]])`. - **Equality Check**: `Matrix([[1, 2], [3, 4]]) == Matrix([[1, 2], [3, 4]])` should return `True`. - **Determinant**: `Matrix([[1, 2], [3, 4]]).determinant()` should return `-2`. - **Inverse**: `Matrix([[1, 2], [3, 4]]).inverse()` should return `Matrix([[-2, 1], [1.5, -0.5]])`. Constraints: - Ensure your implementation is efficient and can handle matrices up to 100 times 100 within reasonable limits. - The provided matrices will always be valid for the operations. - The operations should handle matrices with floating point numbers accurately. Example: ```python m1 = Matrix([[1, 2], [3, 4]]) m2 = Matrix([[2, 0], [1, 2]]) print(m1 + m2) # Should display [[3, 2], [4, 6]] print(m1 * m2) # Should display [[4, 4], [10, 8]] print(m1.determinant()) # Should return -2 print(m1.inverse()) # Should display [[-2, 1], [1.5, -0.5]] ```","solution":"import copy class Matrix: def __init__(self, rows): self.validate_matrix(rows) self.rows = rows self.n_rows = len(rows) self.n_cols = len(rows[0]) @staticmethod def validate_matrix(rows): if len(rows) == 0 or len(rows[0]) == 0: raise ValueError(\\"Matrix cannot be empty\\") row_length = len(rows[0]) if any(len(row) != row_length for row in rows): raise ValueError(\\"All rows must have the same length\\") def __add__(self, other): if self.n_rows != other.n_rows or self.n_cols != other.n_cols: raise ValueError(\\"Matrices must have the same dimensions for addition\\") result = [[self.rows[i][j] + other.rows[i][j] for j in range(self.n_cols)] for i in range(self.n_rows)] return Matrix(result) def __sub__(self, other): if self.n_rows != other.n_rows or self.n_cols != other.n_cols: raise ValueError(\\"Matrices must have the same dimensions for subtraction\\") result = [[self.rows[i][j] - other.rows[i][j] for j in range(self.n_cols)] for i in range(self.n_rows)] return Matrix(result) def __mul__(self, other): if self.n_cols != other.n_rows: raise ValueError(\\"Number of columns of the first matrix must equal number of rows of the second matrix\\") result = [[sum(self.rows[i][k] * other.rows[k][j] for k in range(self.n_cols)) for j in range(other.n_cols)] for i in range(self.n_rows)] return Matrix(result) def transpose(self): result = [[self.rows[j][i] for j in range(self.n_rows)] for i in range(self.n_cols)] return Matrix(result) def __eq__(self, other): if self.n_rows != other.n_rows or self.n_cols != other.n_cols: return False return all(self.rows[i][j] == other.rows[i][j] for i in range(self.n_rows) for j in range(self.n_cols)) def __str__(self): return \'n\'.join([\' \'.join(map(str, row)) for row in self.rows]) def determinant(self): if self.n_rows != self.n_cols: raise ValueError(\\"Determinant is only defined for square matrices\\") return self._determinant_recursive(self.rows) def _determinant_recursive(self, matrix): if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] return sum(((-1) ** col) * matrix[0][col] * self._determinant_recursive(self._minor(matrix, 0, col)) for col in range(len(matrix))) def _minor(self, matrix, row, col): return [row[:col] + row[col + 1:] for row in (matrix[:row] + matrix[row + 1:])] def inverse(self): if self.n_rows != self.n_cols: raise ValueError(\\"Inverse is only defined for square matrices\\") det = self.determinant() if det == 0: raise ValueError(\\"Matrix is singular and cannot be inverted\\") cofactor_matrix = [[((-1) ** (i + j)) * self._determinant_recursive(self._minor(self.rows, i, j)) for j in range(self.n_cols)] for i in range(self.n_rows)] cofactor_matrix = Matrix(cofactor_matrix).transpose().rows inverse_matrix = [[cofactor_matrix[i][j] / det for j in range(self.n_cols)] for i in range(self.n_rows)] return Matrix(inverse_matrix)"},{"question":"# Route Finder in a Directed Graph Context You are tasked with developing a route-finding functionality in a directed graph where nodes represent cities and edges represent one-way roads between these cities. Your objective is to determine if there is a path from a starting city to a destination city using Depth-First Search (DFS). Problem Statement Write a function `is_path_exist(graph: Dict[str, List[str]], start: str, end: str) -> bool` that takes in a directed graph, a starting city, and a destination city. This function should return a boolean indicating whether there is a path from the start city to the end city using DFS. Input * `graph`: A dictionary where keys are city names (strings) and values are lists of city names (strings) representing destinations directly reachable from the key city. * `start`: A string representing the starting city. * `end`: A string representing the destination city. Output * A boolean value: `True` if there is a path from `start` to `end`, otherwise `False`. Constraints * The number of cities (nodes) in the graph will be between 1 and 10^5. * The number of roads (edges) in the graph will be between 1 and 2*10^5. * All city names are unique and consist of alphanumeric characters. Performance Requirements * The algorithm should efficiently find a path using DFS, potentially leveraging a recursive or iterative approach. Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [\\"C\\"], \\"E\\": [\\"D\\"] } start = \\"A\\" end = \\"E\\" # Output: True graph = { \\"A\\": [\\"B\\", \\"D\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"D\\"], \\"D\\": [] } start = \\"D\\" end = \\"A\\" # Output: False ``` Notes * Ensure your implementation handles all relevant edge cases such as cycles within the graph and graphs with no edges. * Consider using helper functions to make your solution modular. * Verify the correctness of your implementation with a variety of test cases to ensure robustness.","solution":"def dfs(graph, current, end, visited): if current == end: return True visited.add(current) for neighbor in graph.get(current, []): if neighbor not in visited: if dfs(graph, neighbor, end, visited): return True return False def is_path_exist(graph, start, end): Determines if there is a path from start city to end city using DFS. Parameters: graph (dict): Dictionary representing the directed graph. start (str): Starting city. end (str): Destination city. Returns: bool: True if there is a path, else False. visited = set() return dfs(graph, start, end, visited)"},{"question":"# Coding Assessment Question Context You are developing a customer information management system for an e-commerce platform. One of the key features is recording and verifying email addresses to ensure they are in a valid format and associated with known domains. # Objective Implement the required functions to parse, validate, and manage email addresses for customer accounts within the system. # Problem Statement 1. **Function: `parse_email(input_str)`** - **Description**: Extract the username and domain from a given email address string. - **Input**: A string representing an email address. - **Output**: A tuple containing the username and the domain. - **Constraints**: Ensure the input follows a typical email format (username@domain). - **Error Handling**: Handle invalid email formats. 2. **Function: `validate_email(email)`** - **Description**: Validate an email address to check if it follows the appropriate format and is associated with known domains. - **Input**: A string representing an email address. - **Output**: A boolean indicating whether the email is valid. - **Constraints**: Ensure the email address format is correct and the domain is in a predefined list of known domains (e.g., [\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"]). 3. **Function: `normalize_email(email)`** - **Description**: Process and normalize an email address to a standard format. - **Input**: A string representing an email address. - **Output**: A string of the email address in lowercase and without any leading or trailing whitespaces. - **Error Handling**: Handle non-string or malformed input and raise appropriate errors. # Example ```python KNOWN_DOMAINS = [\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"] def parse_email(input_str): # [Write your code here] def validate_email(email): # [Write your code here] def normalize_email(email): # [Write your code here] # Example Usage: assert parse_email(\\"username@gmail.com\\") == (\\"username\\", \\"gmail.com\\") assert parse_email(\\" user.name@domain.co.uk \\") == (\\"user.name\\", \\"domain.co.uk\\") assert validate_email(\\"username@gmail.com\\") == True assert validate_email(\\"user.domain@unknown.org\\") == False assert normalize_email(\\" USER@GMAIL.COM \\") == \\"user@gmail.com\\" try: parse_email(\\"not-an-email\\") except ValueError: pass # Expected ```","solution":"KNOWN_DOMAINS = [\\"gmail.com\\", \\"yahoo.com\\", \\"outlook.com\\"] def parse_email(input_str): Extracts the username and domain from an email address. input_str = input_str.strip() if \\"@\\" not in input_str: raise ValueError(\\"Invalid email format: missing \'@\'\\") username, domain = input_str.split(\'@\', 1) if not username or not domain: raise ValueError(\\"Invalid email format: missing username or domain\\") return username, domain def validate_email(email): Validates the email address format and checks if the domain is known. try: username, domain = parse_email(email) except ValueError: return False return domain in KNOWN_DOMAINS def normalize_email(email): Normalizes the email address to a standard format (lowercase and trimmed). if not isinstance(email, str): raise TypeError(\\"Email address must be a string\\") email = email.strip().lower() try: username, domain = parse_email(email) except ValueError: raise ValueError(\\"Invalid email format\\") return f\\"{username}@{domain}\\""},{"question":"# Problem Statement You are tasked with implementing a text editor\'s basic functionalities using a doubly linked list data structure. The text editor should support fundamental operations for manipulating strings. Tasks: 1. **Implement \'insert\' function** Create a method `insert(index: int, text: str) -> None` to add a substring into the text after a specific position index. 2. **Implement \'delete\' function** Create a method `delete(index: int, length: int) -> None` to remove a substring of given length starting from a specific position index. 3. **Implement \'find_replace\' function** Add a method `find_replace(old: str, new: str) -> int` to search and replace all occurrences of a substring `old` with a new substring `new`. The method should return the number of replacements made. # Constraints: - The `insert` method should not alter the text order and should correctly insert the text at the specified index. - The `delete` method should handle text truncation properly without removing additional characters. - The `find_replace` method should traverse the text from left to right, replacing non-overlapping occurrences of the substring. - Ensure text manipulation within a doubly linked list maintains O(1) space complexity for operations if any. # Function Signatures ```python def insert(self, index: int, text: str) -> None: pass def delete(self, index: int, length: int) -> None: pass def find_replace(self, old: str, new: str) -> int: pass ``` # Example - **Before Insert** ```python editor = TextEditorDoublyLinkedList() editor.insert(0, \\"hello world\\") ``` - **After Insert** ```python editor.insert(6, \\"beautiful \\") # The text should be \\"hello beautiful world\\" ``` - **Before Delete** ```python editor.delete(0, 6) # The text should be \\"beautiful world\\" ``` - **Find and Replace** ```python replacements = editor.find_replace(\\"beautiful\\", \\"amazing\\") # After this operation # The text should be \\"amazing world\\" # And `replacements` should be 1 ``` **Note**: The provided `TextEditorDoublyLinkedList` class and `Node` class shall be used and modified according to the task requirements.","solution":"class Node: def __init__(self, char=None, prev=None, next=None): self.char = char self.prev = prev self.next = next class TextEditorDoublyLinkedList: def __init__(self): self.head = Node() # dummy head self.tail = Node() # dummy tail self.head.next = self.tail self.tail.prev = self.head self.size = 0 def insert(self, index: int, text: str) -> None: if index < 0 or index > self.size: raise IndexError(\'Index out of bounds\') current = self.head for _ in range(index): current = current.next for char in text: new_node = Node(char) next_node = current.next current.next = new_node new_node.prev = current new_node.next = next_node next_node.prev = new_node current = new_node self.size += 1 def delete(self, index: int, length: int) -> None: if index < 0 or index >= self.size or length < 0: raise IndexError(\'Index out of bounds\') current = self.head.next for _ in range(index): current = current.next for _ in range(length): if current == self.tail: break prev_node = current.prev next_node = current.next prev_node.next = next_node next_node.prev = prev_node current = next_node self.size -= 1 def find_replace(self, old: str, new: str) -> int: current = self.head.next text = \\"\\" while current != self.tail: text += current.char current = current.next count_replacements = text.count(old) replaced_text = text.replace(old, new) # Clear current list self.head.next = self.tail self.tail.prev = self.head self.size = 0 # Rebuild new list with replaced text for char in replaced_text: self.insert(self.size, char) return count_replacements def to_string(self) -> str: result = [] current = self.head.next while current != self.tail: result.append(current.char) current = current.next return \'\'.join(result)"},{"question":"# Assessment Question **Q2**: Write a function `find_missing_numbers` that takes a sorted list of distinct integers and returns a list of missing integers in the range from the smallest to the largest number in the list. ```python def find_missing_numbers(nums: list[int]) -> list[int]: Find the missing numbers in a sorted list of distinct integers that should be present in the range from the smallest to the largest number in the list. Args: nums (list[int]): A sorted list of distinct integers. Returns: list[int]: A list of the missing integers in the range. Example: >>> find_missing_numbers([1, 2, 4, 6]) [3, 5] >>> find_missing_numbers([3, 7, 8, 10]) [4, 5, 6, 9] pass ``` **Constraints and Notes**: - The input list `nums` will always be sorted in ascending order and contain only distinct integers. - Your function should handle and correctly process lists containing negative integers. - Aim for an efficient solution with respect to time complexity. **Expected Input and Output**: ```python assert find_missing_numbers([1, 2, 4, 6]) == [3,5] assert find_missing_numbers([3, 7, 8, 10]) == [4, 5, 6, 9] assert find_missing_numbers([-3, -1, 0, 1, 3]) == [-2, 2] assert find_missing_numbers([5, 6, 9, 11]) == [7, 8, 10] ```","solution":"def find_missing_numbers(nums: list[int]) -> list[int]: Find the missing numbers in a sorted list of distinct integers that should be present in the range from the smallest to the largest number in the list. Args: nums (list[int]): A sorted list of distinct integers. Returns: list[int]: A list of the missing integers in the range. Example: >>> find_missing_numbers([1, 2, 4, 6]) [3, 5] >>> find_missing_numbers([3, 7, 8, 10]) [4, 5, 6, 9] if not nums: return [] return [i for i in range(nums[0], nums[-1] + 1) if i not in nums]"},{"question":"# Problem Description You are tasked to perform some basic image processing using the Python Imaging Library (PIL). Write a program that accepts an image file, converts it to grayscale, resizes it to a specified dimension, and then saves it under a new file name. The new file should be saved in the same directory as the original image. # Function Specification Write a function `process_image(file_path: str, new_size: tuple, new_file_name: str) -> None` which takes in the file path of an image, a tuple representing the new size, and a string for the new file name. The function should not return anything but should save the processed image in the same directory as the original image. Input - `file_path` (str): A string representing the path to the original image file. - `new_size` (tuple): A tuple representing the new dimensions `(width, height)` of the image. - `new_file_name` (str): A string representing the new file name for the processed image. Output - None Constraints - The function should handle different image formats (e.g., JPEG, PNG, BMP). - Ensure that the new file name is unique to avoid overwriting existing files. - Handle exceptions that might occur during file operations or image processing. # Example ```python from PIL import Image def process_image(file_path: str, new_size: tuple, new_file_name: str) -> None: # Open the original image file with Image.open(file_path) as img: # Convert the image to grayscale grayscale_img = img.convert(\'L\') # Resize the image resized_img = grayscale_img.resize(new_size) # Save the new image under the new file name in the same directory resized_img.save(new_file_name) # Example usage file_path = \'sample.jpg\' new_size = (100, 100) new_file_name = \'sample_processed.jpg\' process_image(file_path, new_size, new_file_name) ``` # Requirements - Handle edge cases where the file might not be found or cannot be opened. - Ensure that the resizing and conversion maintain the image quality as much as possible. - Consider extending functionality to handle images with different aspect ratios.","solution":"from PIL import Image import os def process_image(file_path: str, new_size: tuple, new_file_name: str) -> None: try: # Open the original image file with Image.open(file_path) as img: # Convert the image to grayscale grayscale_img = img.convert(\'L\') # Resize the image resized_img = grayscale_img.resize(new_size) # Create the full path for the new file directory = os.path.dirname(file_path) new_file_path = os.path.join(directory, new_file_name) # Save the new image under the new file name in the same directory resized_img.save(new_file_path) except FileNotFoundError: print(f\\"The file at {file_path} was not found.\\") except Exception as e: print(f\\"An error occurred: {e}\\")"},{"question":"# Problem Statement You are working on a text processing library that manipulates document structures and extracts specific data. Your task is to extend the `DocumentProcessor` class with the following functionalities: 1. Count the occurrences of each word in the document. 2. Find all unique words in the document. 3. Identify the longest sentence in the document based on word count. # Task Requirements 1. Implement three new methods in the `DocumentProcessor` class: * `word_frequencies(self) -> dict[str, int]`: Returns a dictionary where the keys are words and the values are their respective frequencies in the document. * `unique_words(self) -> set[str]`: Returns a set of all unique words found in the document. * `longest_sentence(self) -> str`: Returns the longest sentence in the document based on word count. If multiple sentences have the same length, return the first one. # Input - The document is a string consisting of sentences separated by punctuation marks (., !, ?). - Words are separated by whitespace and can contain alphanumeric characters (a-z, A-Z, 0-9). - Sentences are delimited by a period (.), exclamation mark (!), or question mark (?). # Output - For `word_frequencies`, return a dictionary. - For `unique_words`, return a set. - For `longest_sentence`, return a string. # Constraints 1. The document has a maximum length of `10^6` characters. 2. Words will have a maximum length of `100` characters. 3. Sentences will not be nested. # Example ```python document = Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum dignissim quam nonidunt auctor. Sed euismod varius lacus, sit amet ullamcorper nibh. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam non urna et justo vehicula varius. processor = DocumentProcessor(document) # Example usage: print(processor.word_frequencies()) # Output: {\'Lorem\': 2, \'ipsum\': 2, \'dolor\': 2, \'sit\': 2, \'amet\': 2, \'consectetur\': 2, \'adipiscing\': 2, \'elit\': 2, \'Vestibulum\': 1, ...} print(processor.unique_words()) # Output: {\'Vestibulum\', \'Nullam\', \'non\', \'vehicula\', \'auctor\', \'urnan\', \'varius\', \'justo\', \'quam\', \'Sed\', ...} print(processor.longest_sentence()) # Output: \'Sed euismod varius lacus, sit amet ullamcorper nibh.\' ``` Implement the methods in such a way that they are efficient and handle the constraints mentioned.","solution":"import re from collections import defaultdict class DocumentProcessor: def __init__(self, document: str): self.document = document def word_frequencies(self) -> dict[str, int]: word_counts = defaultdict(int) # Extract all words words = re.findall(r\'bw+b\', self.document.lower()) for word in words: word_counts[word] += 1 return dict(word_counts) def unique_words(self) -> set[str]: # Extract all words and convert to a set words = re.findall(r\'bw+b\', self.document.lower()) return set(words) def longest_sentence(self) -> str: # Split document into sentences sentences = re.split(r\'(?<=[.!?]) +\', self.document) # Find the longest sentence based on word count longest = max(sentences, key=lambda s: len(re.findall(r\'bw+b\', s)), default=\\"\\") return longest"},{"question":"# Problem Statement: Imagine you are developing a file system where each file is represented as a binary tree node. Each node (file) can either be a directory or an actual file that contains data. You need to implement a functionality that calculates the total size of a given directory. The challenge is to perform the following tasks: 1. **Directory/File Representation**: Define a class structure to represent directories and files in the file system. 2. **Calculate Directory Size**: Implement a recursive function to traverse the directory tree and compute the total size of all files in a given directory. # Function Signature: ```python class FileSystemNode: def __init__(self, name: str, is_directory: bool, size: int = 0): pass def add_child(self, child: \'FileSystemNode\') -> None: pass def calculate_directory_size(node: FileSystemNode) -> int: pass ``` # Input: * An object of class `FileSystemNode` representing the root of the file system or a subdirectory. * Each node in the file system is characterized by: - `name`: The name of the file or directory. - `is_directory`: A boolean indicating whether the node is a directory or a file. - `size`: The size of the file (only relevant if `is_directory` is `False`). # Output: * Return the total size of the directory represented by the given `node`. The total size is the sum of sizes of all files (recursively) contained within that directory and its subdirectories. # Constraints: * Ensure the solution handles large and deeply nested directory structures efficiently. * Optimize both time and space complexity for large file systems. # Example: ```python # File system structure: # root/ # |- dir1/ # |- file1 (size = 100) # |- file2 (size = 200) # |- dir2/ # |- file3 (size = 300) # |- subdir1/ # |- file4 (size = 400) root = FileSystemNode(\\"root\\", True) dir1 = FileSystemNode(\\"dir1\\", True) file1 = FileSystemNode(\\"file1\\", False, 100) file2 = FileSystemNode(\\"file2\\", False, 200) dir1.add_child(file1) dir1.add_child(file2) root.add_child(dir1) dir2 = FileSystemNode(\\"dir2\\", True) file3 = FileSystemNode(\\"file3\\", False, 300) subdir1 = FileSystemNode(\\"subdir1\\", True) file4 = FileSystemNode(\\"file4\\", False, 400) subdir1.add_child(file4) dir2.add_child(file3) dir2.add_child(subdir1) root.add_child(dir2) assert calculate_directory_size(root) == 1000 assert calculate_directory_size(dir1) == 300 assert calculate_directory_size(dir2) == 700 assert calculate_directory_size(subdir1) == 400 ``` # Note: Be sure to define the `FileSystemNode` class with appropriate methods to add children nodes and store their relevant information. The `calculate_directory_size` function should traverse the directory tree recursively to sum up the sizes of all files contained within the provided directory node. Handle edge cases such as empty directories gracefully.","solution":"class FileSystemNode: def __init__(self, name: str, is_directory: bool, size: int = 0): self.name = name self.is_directory = is_directory self.size = size self.children = [] def add_child(self, child: \'FileSystemNode\') -> None: if self.is_directory: self.children.append(child) def calculate_directory_size(node: FileSystemNode) -> int: if not node.is_directory: return node.size total_size = 0 for child in node.children: total_size += calculate_directory_size(child) return total_size"},{"question":"Coding Problem: Detect Cycle in a Directed Graph # Problem Statement You are tasked with determining whether a given directed graph contains a cycle. You will implement a function `has_cycle(graph)` that takes a directed graph as an adjacency list and returns `True` if the graph contains a cycle, and `False` otherwise. # Input - `graph`: A dictionary representing the graph, where keys are node names and values are lists of nodes that are directly reachable from the key node. For example: ```python { \'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [\'C\'] } ``` # Output - A boolean value (`True` or `False`) indicating whether the graph contains a cycle. # Constraints - Each node name is a unique string. - The graph may be disconnected. # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\'], \'C\': [\'A\'], \'D\': [\'C\'] } print(has_cycle(graph)) # Output: True graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [], \'D\': [] } print(has_cycle(graph)) # Output: False ``` # Implementation Details 1. Use Depth-First Search (DFS) to explore each node. 2. Maintain a set to keep track of the recursion stack (nodes currently being explored) and another set to keep track of visited nodes. 3. During DFS, if you revisit a node that is already in the recursion stack, a cycle is detected. 4. If the DFS completes without detecting any cycles, return `False`. # Solution Outline ```python def has_cycle(graph): def dfs(node, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited.add(node) rec_stack.add(node) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True # Remove the vertex from recursion stack rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False ``` This question aligns with the given example in terms of style, length, difficulty, topic alignment, and uniqueness, ensuring consistency and quality.","solution":"def has_cycle(graph): def dfs(node, visited, rec_stack): # Mark the current node as visited and add it to the recursion stack visited.add(node) rec_stack.add(node) # Recur for all the vertices adjacent to this vertex for neighbor in graph.get(node, []): if neighbor not in visited: if dfs(neighbor, visited, rec_stack): return True elif neighbor in rec_stack: return True # Remove the vertex from recursion stack rec_stack.remove(node) return False visited = set() rec_stack = set() for node in graph: if node not in visited: if dfs(node, visited, rec_stack): return True return False"},{"question":"# Coding Assessment Question Scenario You are provided a list of integers representing number of visitors to a website per day over a given period. Your task is to identify the longest subarray where the number of visitors is monotonically increasing. Problem Statement Write a function `longest_increasing_visitor_subarray(visitors: List[int]) -> List[int]` that finds and returns the longest subarray where each element is greater than the previous one. If there are multiple subarrays of the same maximum length, return the first one encountered. Input - `visitors`: A list of integers where each element represents the number of visitors on a given day. Output - The function should return a list of integers representing the longest subarray where the number of visitors is monotonically increasing. Constraints - 1 <= len(visitors) <= 10^5 - Visitors count will be non-negative integers. Example ```python def longest_increasing_visitor_subarray(visitors: list[int]) -> list[int]: Returns the longest subarray with monotonically increasing visitor counts >>> visitors = [10, 15, 12, 18, 20, 25, 23, 30, 35] >>> longest_increasing_visitor_subarray(visitors) [12, 18, 20, 25] >>> visitors = [5, 6, 3, 5, 7, 8, 10] >>> longest_increasing_visitor_subarray(visitors) [3, 5, 7, 8, 10] >>> visitors = [20, 19, 18, 21, 22, 21, 23] >>> longest_increasing_visitor_subarray(visitors) [18, 21, 22] if not visitors: return [] max_len = 0 max_len_start_index = 0 current_len = 1 start_index = 0 for i in range(1, len(visitors)): if visitors[i] > visitors[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_len_start_index = start_index current_len = 1 start_index = i if current_len > max_len: max_len = current_len max_len_start_index = start_index return visitors[max_len_start_index:max_len_start_index + max_len] if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` You are required to ensure your solution handles edge cases appropriately and performs efficiently within the given constraints.","solution":"def longest_increasing_visitor_subarray(visitors): Returns the longest subarray with monotonically increasing visitor counts. Parameters: visitors (list of int): A list of integers representing the number of visitors. Returns: list of int: The longest subarray with monotonically increasing visitor counts. if not visitors: return [] max_len = 0 max_len_start_index = 0 current_len = 1 start_index = 0 for i in range(1, len(visitors)): if visitors[i] > visitors[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_len_start_index = start_index current_len = 1 start_index = i if current_len > max_len: max_len = current_len max_len_start_index = start_index return visitors[max_len_start_index:max_len_start_index + max_len]"},{"question":"# Coding Question Context: In graph theory, the shortest path between two nodes in an unweighted graph can be efficiently found using Breadth-First Search (BFS). Given an unweighted, undirected graph and a starting node, you are required to find the shortest distance from the starting node to all other nodes using BFS. Prompt: Implement a function `bfs_shortest_path(graph: Dict[int, List[int]], start: int) -> Dict[int, int]` that takes in a graph represented as an adjacency list and a starting node, and returns a dictionary where the keys are the nodes of the graph and the values are the shortest distance from the starting node to that particular node. If a node is not reachable from the starting node, its distance should be represented as -1. Input: * A dictionary `graph` representing an unweighted, undirected graph where keys are node identifiers and values are lists of adjacent nodes. * An integer `start` representing the starting node. Output: * A dictionary where keys are nodes and values are the shortest distance from the start node to that node. Constraints: * The graph may contain up to ( 10^4 ) nodes. * The graph does not necessarily have to be connected. * The node identifiers are unique positive integers. Example: ```python def bfs_shortest_path(graph: Dict[int, List[int]], start: int) -> Dict[int, int]: pass # Example usage: graph = { 1: [2, 3], 2: [1, 4], 3: [1], 4: [2, 5], 5: [4] } print(bfs_shortest_path(graph, 1)) # Output: {1: 0, 2: 1, 3: 1, 4: 2, 5: 3} print(bfs_shortest_path(graph, 6)) # Output: {6: -1, 1: -1, 2: -1, 3: -1, 4: -1, 5: -1} ``` Performance: * Ensure that your implementation of BFS operates within ( O(V + E) ) time complexity, where ( V ) is the number of vertices and ( E ) is the number of edges in the graph.","solution":"from collections import deque from typing import Dict, List def bfs_shortest_path(graph: Dict[int, List[int]], start: int) -> Dict[int, int]: Returns the shortest distance from the starting node to all other nodes. If a node is not reachable from the starting node, its distance is represented as -1. # Initialize all distances as -1 distances = {node: -1 for node in graph} # Set the distance of the start node to 0 distances[start] = 0 # Initialize BFS queue queue = deque([start]) while queue: current_node = queue.popleft() current_distance = distances[current_node] for neighbor in graph[current_node]: if distances[neighbor] == -1: # If the neighbor hasn\'t been visited distances[neighbor] = current_distance + 1 queue.append(neighbor) return distances"},{"question":"# Coding Task: Finding the Missing Number You are working on a project that analyzes sequences of numbers. One common problem you encounter is a list of numbers from 1 to ( n ) where exactly one number is missing. Your task is to identify the missing number. This is a classic coding problem that tests your understanding of basic algorithmic concepts. # Problem Description Write a function `find_missing_number` that takes a list of integers representing a sequence from 1 to ( n ) with one missing number, and returns the missing number. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: ``` # Input * `nums`: A list of integers, length ( n-1 ), which contains all the integers from 1 to ( n ) except one missing number. # Output * Returns the missing integer from the sequence. # Constraints * The length of `nums` is ( n-1 ), where ( 1 leq n leq 10^6 ). * Each number in `nums` is a unique integer between 1 and ( n ). * The input list can contain both small numbers and large numbers up to ( n ). # Performance Requirements Your solution should work efficiently even for the largest values of ( n ). # Examples ```python # Example 1 nums = [1, 2, 4, 5, 6] print(find_missing_number(nums)) # Output: 3 # Example 2 nums = [3, 7, 1, 2, 8, 4, 5] print(find_missing_number(nums)) # Output: 6 # Example 3 nums = [2, 3, 4, 5, 6, 7, 8, 9, 10] print(find_missing_number(nums)) # Output: 1 # Example 4 nums = [1] print(find_missing_number(nums)) # Output: 2 ``` # Instructions 1. Read the problem description and examples carefully. 2. Implement the `find_missing_number` function. 3. Ensure your solution is efficient and meets the performance requirements. # Note You can utilize arithmetic series properties or other efficient algorithms to find the missing number without iterating through the list multiple times.","solution":"def find_missing_number(nums: list[int]) -> int: Finds the missing number in a list containing the integers from 1 to n with exactly one number missing. n = len(nums) + 1 # Because one number is missing, so original list length should be n expected_sum = n * (n + 1) // 2 # Sum of the first n natural numbers actual_sum = sum(nums) # Sum of given numbers return expected_sum - actual_sum"},{"question":"Inventory Management System Context You are tasked with developing an inventory management system for a small retail store. The core functionality includes adding new items, removing existing items, updating item quantities, and checking the current stock levels. Task 1. Implement a function, `add_item(inventory: dict, item: str, quantity: int) -> dict` that adds a new item to the inventory or updates the quantity of an existing item. 2. Implement a function, `remove_item(inventory: dict, item: str) -> dict` that removes an item from the inventory. 3. Implement a function, `update_quantity(inventory: dict, item: str, quantity: int) -> dict` that updates the quantity of an existing item in the inventory. 4. Implement a function, `check_stock(inventory: dict, item: str) -> int` that checks the current stock level of an item. Specifications 1. You have four functions to implement: ```python def add_item(inventory: dict, item: str, quantity: int) -> dict: Add a new item or update the quantity of an existing item in the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to add or update. quantity: The quantity of the item. Returns: dict: Updated inventory with the new item or updated quantity. Raises: ValueError: If the item quantity is invalid (negative). def remove_item(inventory: dict, item: str) -> dict: Remove an item from the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to remove. Returns: dict: Updated inventory without the removed item. Raises: KeyError: If the item is not found in the inventory. def update_quantity(inventory: dict, item: str, quantity: int) -> dict: Update the quantity of an existing item in the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to update. quantity: The new quantity of the item. Returns: dict: Updated inventory with the new item quantity. Raises: KeyError: If the item is not found in the inventory. ValueError: If the item quantity is invalid (negative). def check_stock(inventory: dict, item: str) -> int: Check the current stock level of an item. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to check. Returns: int: The current quantity of the item in stock. Raises: KeyError: If the item is not found in the inventory. ``` Input and Output Formats * **Input**: * `inventory` - A dictionary with item names as keys and quantities as values. * `item` - A string representing the item name. * `quantity` - An integer representing the item quantity. * **Output**: * For `add_item`, `remove_item`, and `update_quantity`: Return the updated inventory dictionary. * For `check_stock`: Return the current stock level of the specified item as an integer. Constraints * Item names are case-sensitive strings and must be unique within the inventory. * Item quantities are non-negative integers. Examples ```python # Sample inventory inventory = { \\"apples\\": 10, \\"oranges\\": 5 } # Add a new item assert add_item(inventory, \\"bananas\\", 3) == {\\"apples\\": 10, \\"oranges\\": 5, \\"bananas\\": 3} # Update quantity of an existing item assert add_item(inventory, \\"apples\\", 5) == {\\"apples\\": 15, \\"oranges\\": 5, \\"bananas\\": 3} # Remove an item assert remove_item(inventory, \\"oranges\\") == {\\"apples\\": 15, \\"bananas\\": 3} # Update quantity of an existing item assert update_quantity(inventory, \\"bananas\\", 4) == {\\"apples\\": 15, \\"bananas\\": 4} # Check stock level assert check_stock(inventory, \\"apples\\") == 15 ```","solution":"def add_item(inventory: dict, item: str, quantity: int) -> dict: Add a new item or update the quantity of an existing item in the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to add or update. quantity: The quantity of the item. Returns: dict: Updated inventory with the new item or updated quantity. Raises: ValueError: If the item quantity is invalid (negative). if quantity < 0: raise ValueError(\\"Item quantity cannot be negative\\") if item in inventory: inventory[item] += quantity else: inventory[item] = quantity return inventory def remove_item(inventory: dict, item: str) -> dict: Remove an item from the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to remove. Returns: dict: Updated inventory without the removed item. Raises: KeyError: If the item is not found in the inventory. if item not in inventory: raise KeyError(f\\"Item \'{item}\' not found in inventory\\") del inventory[item] return inventory def update_quantity(inventory: dict, item: str, quantity: int) -> dict: Update the quantity of an existing item in the inventory. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to update. quantity: The new quantity of the item. Returns: dict: Updated inventory with the new item quantity. Raises: KeyError: If the item is not found in the inventory. ValueError: If the item quantity is invalid (negative). if quantity < 0: raise ValueError(\\"Item quantity cannot be negative\\") if item not in inventory: raise KeyError(f\\"Item \'{item}\' not found in inventory\\") inventory[item] = quantity return inventory def check_stock(inventory: dict, item: str) -> int: Check the current stock level of an item. Args: inventory: A dictionary with item names as keys and quantities as values. item: The name of the item to check. Returns: int: The current quantity of the item in stock. Raises: KeyError: If the item is not found in the inventory. if item not in inventory: raise KeyError(f\\"Item \'{item}\' not found in inventory\\") return inventory[item]"},{"question":"# Counting Words in a Sentence You are tasked with implementing a function that counts the frequency of each word in a given sentence. The function should return a dictionary where the keys are words and the values are their respective counts. The core of this task is to ensure that you properly split the words, handle punctuation, and normalize the words for case insensitivity. Function Signature ```python def word_count(sentence: str) -> dict: pass ``` Requirements 1. The function should accept a string representing a sentence and return a dictionary with word counts. 2. Ignore punctuation (i.e., commas, periods, exclamation marks, etc.). 3. Consider words identical regardless of case (e.g., \\"Word\\" and \\"word\\" should be counted together). 4. Handle edge cases: - An empty string. - A string with only punctuation. - A string with multiple spaces between words. - A string with mixed case words. 5. Use the Python `re` library to handle punctuation and splitting. Constraints * Only use standard Python libraries. Example Usage Here are some examples of expected input and output: ```python assert word_count(\\"Hello world!\\") == {\\"hello\\": 1, \\"world\\": 1} assert word_count(\\"This is a test. A simple test!\\") == {\\"this\\": 1, \\"is\\": 1, \\"a\\": 2, \\"test\\": 2, \\"simple\\": 1} assert word_count(\\"Python, python. PYTHON!\\") == {\\"python\\": 3} assert word_count(\\"\\") == {} assert word_count(\\"...,,!\\") == {} assert word_count(\\" Mixed CASE words.\\") == {\\"mixed\\": 1, \\"case\\": 1, \\"words\\": 1} ``` Test your implementation rigorously to cover all edge cases. Explain in comments how each test case validates a specific aspect of the algorithm.","solution":"import re from collections import defaultdict def word_count(sentence: str) -> dict: Returns the frequency count of each word in the input sentence. Words are considered case-insensitive and punctuation is ignored. # Use regular expressions to remove punctuation cleaned_sentence = re.sub(r\'[^ws]\', \'\', sentence) # Split the sentence into words and convert to lower case words = cleaned_sentence.lower().split() # Count the frequency of each word word_counts = defaultdict(int) for word in words: word_counts[word] += 1 return dict(word_counts)"},{"question":"**Problem Statement:** You are given a linked list where each node contains an integer value. Your goal is to determine whether this linked list forms a palindrome. A linked list is considered a palindrome if the sequence of values read the same forward and backward. **Function Signature:** ```python def is_palindrome(head: ListNode) -> bool: pass ``` # Input: - `head`: The head node of the linked list of type `ListNode`. # Output: - Returns `True` if the linked list is a palindrome, otherwise returns `False`. # Constraints: - The number of nodes in the linked list will be between `1` and `10^5`. - Node values can be between `-10^9` and `10^9`. # Example: ```python # Given the linked list: # 1 -> 2 -> 3 -> 2 -> 1 # # The output should be: # is_palindrome(head) -> True ``` # Implementation Details: - Implement a helper function to find the middle of the linked list. - Consider using a two-pointer technique to minimize space complexity. - Ensure the function gracefully handles edge cases such as empty linked lists or single-node lists. # Testing: Ensure your implementation passes the given examples and apply different test cases to validate your code. # Definition of ListNode: A `ListNode` class with attributes: `val`, and `next` will be provided.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_palindrome(head: ListNode) -> bool: if not head or not head.next: return True # Helper function to reverse a linked list def reverse_list(head): prev = None curr = head while curr: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev # Find middle of the linked list using the tortoise and hare method slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the linked list second_half_start = reverse_list(slow) first_half_start = head # Now compare the first half and the reversed second half result = True first, second = first_half_start, second_half_start while result and second: if first.val != second.val: result = False first = first.next second = second.next # Restore the list (optional) reverse_list(second_half_start) return result"},{"question":"# Rotate Matrix by 90 Degrees Given an N x N matrix, your task is to rotate the matrix by 90 degrees clockwise in-place. Implement the `rotate_matrix` function to perform the rotation. # Function Signature ```python def rotate_matrix(matrix: List[List[int]]) -> None: ``` # Parameters * `matrix` (List[List[int]]): A 2D list representing the NxN matrix to be rotated. # Returns * `None`: The function returns nothing as the rotation is to be done in-place. # Constraints * The value of `n` (the size of the matrix) is between 1 and 20, inclusive. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) print(matrix) ``` This should output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Explanation - The matrix is rotated 90 degrees clockwise. - The first row becomes the last column, the second row becomes the second-to-last column, and the last row becomes the first column. # Note - Ensure the rotation is done in-place, modifying the input matrix directly. - Consider swapping elements layer by layer, starting from the outermost layer and moving inward.","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix by 90 degrees clockwise in-place. n = len(matrix) # First, we transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Second, we reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Maximum Contiguous Subarray Sum and Indices You are required to write a function that computes the maximum sum of a contiguous subarray within a one-dimensional numeric array and also returns the indices representing the starting and ending positions of this subarray. Objective: Implement the `max_contiguous_subarray_sum` function to calculate and return: 1. The maximum sum of any contiguous subarray. 2. The starting and ending indices of the subarray that provides this maximum sum. # Input Format: - A list of integers `arr`. # Output Format: A dictionary with: - `\'max_sum\'`: An integer representing the maximum sum. - `\'start_index\'`: An integer representing the starting index of the subarray. - `\'end_index\'`: An integer representing the ending index of the subarray. # Constraints: - The length of the array is between 1 and 10^5. - Each element of the array is an integer within the range of [-10^4, 10^4]. # Performance Requirements: - The function should be optimized to run in linear time, i.e., O(n). # Function Signature: ```python def max_contiguous_subarray_sum(arr: list) -> dict: ``` # Example: ```python # Example 1 input: arr = [-2, -3, 4, -1, -2, 1, 5, -3] output: {\'max_sum\': 7, \'start_index\': 2, \'end_index\': 6} # Example 2 input: arr = [1] output: {\'max_sum\': 1, \'start_index\': 0, \'end_index\': 0} ``` # Notes: - You should handle edge cases, such as single-element arrays, appropriately. - Consider both positive and negative integers within the array. - Ensure that the function meets the required performance constraints. # Challenge: Write the implementation of the `max_contiguous_subarray_sum` function as per the description above.","solution":"def max_contiguous_subarray_sum(arr): Finds the maximum sum of a contiguous subarray and the indices of that subarray. Parameters: arr (list): List of integers. Returns: dict: Dictionary containing \'max_sum\', \'start_index\', and \'end_index\'. max_sum = arr[0] current_sum = arr[0] start_index = 0 end_index = 0 temp_start = 0 for i in range(1, len(arr)): if current_sum + arr[i] < arr[i]: current_sum = arr[i] temp_start = i else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i return { \'max_sum\': max_sum, \'start_index\': start_index, \'end_index\': end_index, }"},{"question":"# Multithreaded Summation You are tasked with creating a utility that computes the sum of a list of integers using multiple threads. The function should divide the list into equal parts, assign each part to a different thread, compute their sums concurrently, and then combine the results. # Function Signature ```python def parallel_sum(numbers: list[int], num_threads: int) -> int: ... ``` # Input Descriptions - `numbers` (list of int): A list of integers to sum up (e.g., `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`). - `num_threads` (int): The number of threads to use for summing. The list should be divided as evenly as possible among these threads. # Output Description The function should return the total sum of the integers in the list. # Constraints 1. If `num_threads` is greater than the length of `numbers`, the function should use only as many threads as there are numbers. 2. Ensure thread safety when updating shared resources. 3. Handle any possible exceptions that might occur due to thread execution. # Example ```python # Sum the list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] using 3 threads result = parallel_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) print(result) ``` # Expected Result: ```python 55 ``` # Additional Information You may use Python\'s `threading` module to implement the multi-threaded functionality. Ensure that the list is divided as evenly as possible among the threads and that the results from individual threads are combined correctly to produce the final sum. Consider potential performance gains with threading for large inputs, and test the function for edge cases like empty lists and single-element lists.","solution":"import threading def parallel_sum(numbers: list[int], num_threads: int) -> int: if not numbers: return 0 n = len(numbers) if num_threads > n: num_threads = n sums = [0] * num_threads threads = [] def worker(start, end, index): part_sum = sum(numbers[start:end]) sums[index] = part_sum chunk_size = (n + num_threads - 1) // num_threads for i in range(num_threads): start = i * chunk_size end = min(start + chunk_size, n) thread = threading.Thread(target=worker, args=(start, end, i)) thread.start() threads.append(thread) for thread in threads: thread.join() return sum(sums)"},{"question":"# Topological Sort **Objective:** Create a function that implements the topological sort algorithm to order the vertices of a directed acyclic graph (DAG). **Function Signature:** ```python def topological_sort(vertices: int, edges: list) -> list: ``` **Input:** * `vertices`: An integer representing the number of vertices in the graph. * `edges`: A list of tuples where each tuple represents a directed edge between two vertices in the graph. Each tuple is of the form `(u, v)` indicating a directed edge from vertex `u` to vertex `v`. **Output:** * The function should return a list of vertices ordered in a topological manner. **Constraints:** * The input list of edges may be empty or contain up to 10^5 edges. * The number of vertices `vertices` is between 1 and 10^3. * The graph must be a DAG (Directed Acyclic Graph). **Requirements:** * The algorithm must run in O(V + E) time complexity where V is the number of vertices and E is the number of edges. * The function should return any valid topological ordering of the vertices. **Scenario:** Consider you are managing project tasks where certain tasks depend on the completion of others. You can use this function to determine a correct order to complete the tasks. **Example:** ```python # Given vertices vertices = 6 # Given edges edges = [ (5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1) ] # Calling the function topological_order = topological_sort(vertices, edges) print(topological_order) # Should print a valid topological order, e.g., [5, 4, 2, 3, 1, 0] ``` # Additional Information: The vertex numbers are zero-based and can be assumed to be integer values from `0` to `vertices-1`. There can be multiple valid topological orderings for a given graph, your function should return one of them.","solution":"from collections import defaultdict, deque def topological_sort(vertices: int, edges: list) -> list: # Initialize the graph graph = defaultdict(list) in_degree = [0] * vertices # Build the graph and calculate in-degree of each vertex for u, v in edges: graph[u].append(v) in_degree[v] += 1 # Initialize the queue with all vertices having in-degree 0 queue = deque([v for v in range(vertices) if in_degree[v] == 0]) topo_order = [] while queue: vertex = queue.popleft() topo_order.append(vertex) # Reduce the in-degree of neighboring vertices and # add them to the queue if their in-degree becomes 0 for neighbor in graph[vertex]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topological sort is possible the topological order should cover all vertices if len(topo_order) == vertices: return topo_order else: # Graph has cycles, hence topological sort is not possible return []"},{"question":"# Coding Assessment Question Problem Statement You are given a matrix of integers where each row and each column is sorted in ascending order. Your task is to implement a function to find the k-th smallest element in this matrix. Assume k is always a valid integer that falls within the range of elements in the matrix. Objective 1. Write a function `find_kth_smallest_element` that takes a matrix and an integer `k` as inputs, and returns the k-th smallest element in the matrix. 2. Handle edge cases effectively, such as empty matrix, and ensure the function is optimized for both time and space. Implementation Details Extend the provided class with the following function: ```python def find_kth_smallest_element(matrix: List[List[int]], k: int) -> int: ``` - **Input**: - `matrix`: A list of lists, where each sublist represents a row in the matrix, which is sorted in ascending order. - `k`: The position (1-based index) of the desired element when the matrix is considered in a flat, sorted order. - **Output**: - Returns the k-th smallest element (type `int`). Constraints 1. Assume each row and column is sorted in ascending order. 2. The matrix has at least one row and one column. 3. `1 <= k <= m*n` where `m` is the number of rows and `n` is the number of columns in the matrix. Performance Requirements - The solution should run in O(k * log(min(m, n))) time complexity, where `m` is the number of rows and `n` is the number of columns. Example ```python # Example usage: matrix = [ [1, 5, 9], [10, 11, 13], [12, 13, 15] ] # This should return 13 (the elements in sorted order are [1, 5, 9, 10, 11, 12, 13, 13, 15]) kth_element = find_kth_smallest_element(matrix, 8) print(kth_element) # Output: 13 # This should return 1 (the smallest element) kth_element = find_kth_smallest_element(matrix, 1) print(kth_element) # Output: 1 ``` Notes - Assume the input matrix is always non-empty and sorted according to the problem statement. - You may use additional helper functions if needed to maintain clear and efficient code.","solution":"from typing import List import heapq def find_kth_smallest_element(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a sorted matrix. :param matrix: List of lists where each row and each column is sorted in ascending order :param k: The position (1-based index) of the desired element when matrix is considered in a flat, sorted order :return: The k-th smallest element in the matrix n = len(matrix) # Min-heap of (element, row, col) min_heap = [(matrix[0][0], 0, 0)] visited = set((0, 0)) while k > 0: element, r, c = heapq.heappop(min_heap) k -= 1 if k == 0: return element # Move to the next element in the row if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1)) # Move to the next element in the column if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c))"},{"question":"# Coding Assessment Question Scenario You are given an unsorted array of integers and a target sum. Your goal is to determine if there are three distinct elements in the array that add up to the given target sum. This is a common problem that requires array manipulation and understanding of algorithm optimization techniques. Objective Implement the function `find_triplet_with_sum(arr: List[int], target: int) -> bool`. The function should return `True` if there are three distinct elements in the array whose sum is equal to the target sum, otherwise, it should return `False`. Input * `arr` (List[int]): An unsorted list of integers. * `target` (int): The target sum to be achieved by the sum of three distinct elements. Output * `bool`: `True` if such a triplet exists, `False` otherwise. Constraints * 0 ≤ len(arr) ≤ 10^4 * -10^6 ≤ arr[i] ≤ 10^6 * -10^6 ≤ target ≤ 10^6 Example ```python find_triplet_with_sum([12, 3, 4, 1, 6, 9], 24) # Output: True (The triplet is 12, 3, and 9) find_triplet_with_sum([1, 2, 3, 4, 5], 10) # Output: True (The triplet is 2, 3, and 5) find_triplet_with_sum([1, 2, 3, 4, 5], 20) # Output: False find_triplet_with_sum([1, 2], 3) # Output: False (Not enough elements to form a triplet) ``` Performance Requirement * The function should be implemented with at least O(n^2) time complexity using appropriate optimization techniques. For instance, employing sorting followed by a two-pointer approach can help in achieving this complexity.","solution":"from typing import List def find_triplet_with_sum(arr: List[int], target: int) -> bool: arr.sort() n = len(arr) for i in range(n - 2): l, r = i + 1, n - 1 while (l < r): current_sum = arr[i] + arr[l] + arr[r] if current_sum == target: return True elif current_sum < target: l += 1 else: r -= 1 return False"},{"question":"# Coding Assessment Question Context You are developing a module for handling date and time calculations as part of a software package for scheduling and calendar management. Your current task involves normalizing a given time duration to ensure it doesn\'t exceed conventional boundaries (e.g., an hour cannot have more than 59 minutes). Problem Statement Implement a Python function named `normalize_duration(hours: int, minutes: int) -> Tuple[int, int]` that takes two integers representing hours and minutes, and returns a normalized duration such that no number of minutes exceeds 59. Requirements 1. **Input Format**: - The function will receive two integers `hours` and `minutes`. 2. **Output Format**: - The function should return a tuple `(normalized_hours, normalized_minutes)` where: - `normalized_hours` is the corrected number of hours. - `normalized_minutes` is the corrected number of minutes, ensuring it is in the range [0, 59]. 3. **Constraints**: - Both input integers can be positive, zero, or negative. - The output should properly account for any negative or excessive values in the `minutes`. 4. **Performance**: - The function should run in constant time, O(1). 5. **Scenario**: - Validate the function with several test cases to confirm the normalization process. Example Usage ```python >>> normalize_duration(5, 75) (6, 15) >>> normalize_duration(2, -30) (1, 30) >>> normalize_duration(-1, 120) (1, 0) >>> normalize_duration(0, -300) (-5, 0) ``` Implementation Guidelines Ensure that the normalized duration correctly reflects conventional time calculations by adjusting the hours and minutes values appropriately.","solution":"def normalize_duration(hours, minutes): Normalizes the duration by ensuring that minutes do not exceed 59 and adjusts hours accordingly. Args: hours (int): The initial hours. minutes (int): The initial minutes. Returns: Tuple[int, int]: A tuple containing normalized hours and minutes. total_minutes = hours * 60 + minutes normalized_hours = total_minutes // 60 normalized_minutes = total_minutes % 60 return (normalized_hours, normalized_minutes)"},{"question":"# Array Element Left Rotation Given an array of integers, perform a specified number of left rotations on the array. This problem will test your understanding of array manipulation and indexing. Function Signature ```python def rotate_left(arr: list, rotations: int) -> list: ``` Input and Output Formats * **Input**: * A list of integers `arr`. * An integer `rotations` representing the number of left rotations to be performed on the array. * **Output**: * A list of integers which is the result of performing the specified number of left rotations on the input array. Constraints * `1 ≤ len(arr) ≤ 10^5` * `0 ≤ rotations ≤ 10^5` * `-10^9 ≤ arr[i] ≤ 10^9` Example ```python # Example 1 assert rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] # Example 2 assert rotate_left([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] # Example 3 assert rotate_left([1, 2, 3, 4, 5], 7) == [3, 4, 5, 1, 2] # Example 4 assert rotate_left([10, 20, 30], 0) == [10, 20, 30] # Example 5 assert rotate_left([-1, -2, -3, -4], 2) == [-3, -4, -1, -2] ``` Explanation 1. For the array `[1, 2, 3, 4, 5]` with `2` left rotations, the result is `[3, 4, 5, 1, 2]`. 2. For the array `[1, 2, 3, 4, 5]` with `5` left rotations, the array remains the same. 3. For the array `[1, 2, 3, 4, 5]` with `7` left rotations (equivalent to 2 rotations since 7 mod 5 is 2), the result is `[3, 4, 5, 1, 2]`. 4. For the array `[10, 20, 30]` with `0` left rotations, the original array is returned. 5. For the array `[-1, -2, -3, -4]` with `2` left rotations, the result is `[-3, -4, -1, -2]`. Instructions 1. Implement the function according to the provided signature. 2. Make sure to handle cases where the number of rotations is greater than the length of the array by using modulus operations. 3. Consider edge cases such as empty arrays or arrays where the number of rotations is zero.","solution":"def rotate_left(arr: list, rotations: int) -> list: Rotates the array to the left by the specified number of rotations. Parameters: arr (list): List of integers. rotations (int): Number of rotations to perform. Returns: list: The array after performing the left rotations. n = len(arr) if n == 0 or rotations == 0 or rotations % n == 0: return arr rotations = rotations % n return arr[rotations:] + arr[:rotations] # Example usage: # print(rotate_left([1, 2, 3, 4, 5], 2)) # Output: [3, 4, 5, 1, 2] # print(rotate_left([1, 2, 3, 4, 5], 5)) # Output: [1, 2, 3, 4, 5] # print(rotate_left([1, 2, 3, 4, 5], 7)) # Output: [3, 4, 5, 1, 2] # print(rotate_left([10, 20, 30], 0)) # Output: [10, 20, 30] # print(rotate_left([-1, -2, -3, -4], 2)) # Output: [-3, -4, -1, -2]"},{"question":"# Coding Assessment Question: Dynamic Price Calculator for Online Shopping Cart Objective Your task is to develop an online shopping cart system that dynamically computes the price of items, including discounts and tax calculations, upon adding items to the cart. Requirements 1. **Cart Management**: Implement a class to manage the shopping cart. It should support adding and removing items, viewing the cart, and clearing the cart. 2. **Dynamic Pricing**: Calculate the total price of items dynamically, taking into account quantity, individual item prices, discounts, and taxes. 3. **Discount and Tax Calculation**: Include a mechanism to apply discounts to specific items or the entire cart, and calculate sales tax based on a predefined tax rate. 4. **Error Handling**: Handle edge cases such as invalid item entries, negative prices, and quantity adjustments. Input/Output Formats - **Input**: - Item details as input containing item name, item price, and optional quantity. - Optional discount rates for specific items or the entire cart. - Tax rate percentage to be applied to the total cart value. - **Output**: - A summary of the cart with item-wise and overall totals. - Final price after applying discounts and tax. Performance Requirements - Efficiently handle dynamic updates and calculations as items are added or modified in the cart. Implementation Steps 1. Create a `ShoppingCart` class with methods to add, remove items, view the cart, and clear the cart. 2. Implement dynamic price calculation that updates the total price including discounts and sales tax each time an item is added or removed. 3. Ensure to apply item-specific discounts and overall cart discounts before calculating the sales tax. 4. Validate input entries to manage errors gracefully. Scenario Consider an online shopping platform where users add items to their cart, and the system needs to instantly reflect the updated price inclusive of applicable discounts and taxes. ```python class ShoppingCart: def __init__(self): self.items = {} # stores item name as key and a tuple of price, quantity self.cart_discount = 0 self.tax_rate = 0 def add_item(self, item_name, price, quantity=1, discount=0): if item_name in self.items: self.items[item_name] = ( price, self.items[item_name][1] + quantity, discount ) else: self.items[item_name] = (price, quantity, discount) self._calculate_totals() def remove_item(self, item_name): if item_name in self.items: del self.items[item_name] self._calculate_totals() def view_cart(self): cart_summary = {\\"items\\": self.items, \\"total\\": self._get_cart_total()} return cart_summary def clear_cart(self): self.items = {} self._calculate_totals() def set_cart_discount(self, discount): self.cart_discount = discount self._calculate_totals() def set_tax_rate(self, tax_rate): self.tax_rate = tax_rate self._calculate_totals() def _calculate_totals(self): self.sub_total = sum( (price - (price * discount / 100)) * quantity for price, quantity, discount in self.items.values() ) self.total_after_cart_discount = self.sub_total - (self.sub_total * self.cart_discount / 100) self.final_total = self.total_after_cart_discount + (self.total_after_cart_discount * self.tax_rate / 100) def _get_cart_total(self): return { \\"sub_total\\": self.sub_total, \\"total_after_cart_discount\\": self.total_after_cart_discount, \\"final_total\\": self.final_total, } # Example usage: cart = ShoppingCart() cart.add_item(\\"Laptop\\", 1000, 1, 10) # 10% discount on this item cart.add_item(\\"Mouse\\", 50, 2) cart.set_cart_discount(5) # 5% discount on the entire cart cart.set_tax_rate(8) # 8% sales tax cart_summary = cart.view_cart() print(cart_summary) ``` **Note**: Ensure the implementation handles the case of applying item-specific discounts first and then any overall cart discounts followed by sales tax calculations. Add appropriate validation and exception handling to ensure robust functionality in production systems.","solution":"class ShoppingCart: def __init__(self): self.items = {} # stores item name as key and a tuple of price, quantity, discount self.cart_discount = 0 self.tax_rate = 0 def add_item(self, item_name, price, quantity=1, discount=0): if item_name in self.items: old_price, old_quantity, old_discount = self.items[item_name] self.items[item_name] = ( price, old_quantity + quantity, discount ) else: self.items[item_name] = (price, quantity, discount) self._calculate_totals() def remove_item(self, item_name): if item_name in self.items: del self.items[item_name] self._calculate_totals() def view_cart(self): cart_summary = { \\"items\\": self.items, \\"totals\\": self._get_cart_totals() } return cart_summary def clear_cart(self): self.items = {} self._calculate_totals() def set_cart_discount(self, discount): if discount < 0 or discount > 100: raise ValueError(\\"Discount must be between 0 and 100\\") self.cart_discount = discount self._calculate_totals() def set_tax_rate(self, tax_rate): if tax_rate < 0 or tax_rate > 100: raise ValueError(\\"Tax rate must be between 0 and 100\\") self.tax_rate = tax_rate self._calculate_totals() def _calculate_totals(self): self.sub_total = sum( (price - (price * discount / 100)) * quantity for price, quantity, discount in self.items.values() ) self.total_after_cart_discount = self.sub_total - (self.sub_total * self.cart_discount / 100) self.final_total = self.total_after_cart_discount + (self.total_after_cart_discount * self.tax_rate / 100) def _get_cart_totals(self): return { \\"sub_total\\": self.sub_total, \\"total_after_cart_discount\\": self.total_after_cart_discount, \\"final_total\\": self.final_total, }"},{"question":"# Task: Implement a Basic Arithmetic Expression Evaluator Your task is to build a function that evaluates a simple arithmetic expression consisting of non-negative integers and the operators `+` and `*`. The function should adhere to the standard operator precedence rules where `*` has higher precedence over `+`. Specifically: 1. Evaluate the arithmetic expression correctly according to the precedence of operators. 2. Ensure that the input expression is a valid string containing non-negative integers and the operators `+` and `*`. If the input is not a valid expression, raise a `ValueError` with the message \\"Invalid expression\\". 3. Handle spaces and empty inputs gracefully, ignoring extraneous whitespace characters. # Function Signature ```python def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression containing non-negative integers and operators + and *. :param expression: str : The arithmetic expression to evaluate :return: int: The result of the arithmetic evaluation >>> evaluate_expression(\\"3+5*2\\") 13 >>> evaluate_expression(\\"10 + 2 * 3\\") 16 >>> evaluate_expression(\\"10 + 2 *\\") Traceback (most recent call last): ... ValueError: Invalid expression >>> evaluate_expression(\\" 3 + 4 * 2 \\") 11 >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Invalid expression # Your implementation here ``` # Constraints 1. The input expression can include integers (0-9, or larger numbers without leading zeros), `+` (addition), and `*` (multiplication). 2. The function must adhere to standard operator precedence, where `*` has higher precedence than `+`. 3. The input string should be a valid arithmetic expression. If the input is invalid, raise a `ValueError` with the message \\"Invalid expression\\". 4. Extraneous whitespace characters should be ignored. 5. Empty input strings should be considered invalid. # Example Usages - `evaluate_expression(\\"3+5*2\\")` should return `13`. - `evaluate_expression(\\"10 + 2 * 3\\")` should return `16`. - `evaluate_expression(\\"3 + 4 * 2 \\")` should return `11`. - `evaluate_expression(\\"10 + 2 *\\")` should raise `ValueError: Invalid expression`. - `evaluate_expression(\\"\\")` should raise `ValueError: Invalid expression`.","solution":"import re def evaluate_expression(expression: str) -> int: Evaluate the arithmetic expression containing non-negative integers and operators + and *. :param expression: str : The arithmetic expression to evaluate :return: int: The result of the arithmetic evaluation if not expression: raise ValueError(\\"Invalid expression\\") # Remove all spaces expression = expression.replace(\\" \\", \\"\\") if not re.fullmatch(r\'(d+[+*])*?d+\', expression): raise ValueError(\\"Invalid expression\\") # Split the expression into terms by \'+\' while preserving operators terms = re.split(r\'(+)\', expression) # Transform each term by evaluating multiplications first result_terms = [] for term in terms: if \'*\' in term: factors = map(int, term.split(\'*\')) product = 1 for factor in factors: product *= factor result_terms.append(str(product)) else: result_terms.append(term) # Now evaluate the remaining addition result_expression = \'\'.join(result_terms) return eval(result_expression)"},{"question":"# Coding Assessment Question: Intersecting Dictionaries **Context**: In programming, it\'s common to work with dictionaries to store and manipulate data. Sometimes, you may need to find the common elements between two dictionaries -- that is, the keys that are present in both dictionaries alongside their corresponding values when they match. Your task is to implement a function that returns a new dictionary containing only these intersecting key-value pairs. **Requirements**: 1. Implement the function `intersect_dictionaries(dict1: dict, dict2: dict) -> dict`: * The function should take two dictionaries as input and return a dictionary consisting of the intersecting key-value pairs. * A key-value pair is in the result if the key is present in both dictionaries and the corresponding values are the same. 2. Ensure that your function handles edge cases and provides correct results for: * Empty dictionaries. * Dictionaries with non-overlapping keys. * Dictionaries with overlapping keys but differing values. 3. Your implementation should have: * **Time Complexity**: O(n), where n is the number of keys in the smaller of the two dictionaries. * **Space Complexity**: O(n), where n is the number of intersecting key-value pairs. 4. Validate your function with the following assertions: ```python assert intersect_dictionaries({\\"a\\": 1, \\"b\\": 2, \\"c\\": 3}, {\\"b\\": 2, \\"c\\": 4, \\"d\\": 5}) == {\\"b\\": 2} assert intersect_dictionaries({\\"x\\": 9, \\"y\\": 8}, {\\"y\\": 8, \\"x\\": 9}) == {\\"x\\": 9, \\"y\\": 8} assert intersect_dictionaries({\\"name\\": \\"Alice\\", \\"age\\": 30}, {\\"name\\": \\"Alice\\", \\"location\\": \\"Wonderland\\"}) == {\\"name\\": \\"Alice\\"} assert intersect_dictionaries({}, {\\"key\\": 1}) == {} assert intersect_dictionaries({\\"status\\": \\"active\\"}, {\\"status\\": \\"inactive\\"}) == {} ``` **Function Signature**: ```python def intersect_dictionaries(dict1: dict, dict2: dict) -> dict: pass ```","solution":"def intersect_dictionaries(dict1: dict, dict2: dict) -> dict: Returns a dictionary containing key-value pairs that are present in both input dictionaries with the same values. return {k: v for k, v in dict1.items() if k in dict2 and dict2[k] == v}"},{"question":"**Context**: You are developing a task scheduler that is capable of managing multiple tasks with their respective priority levels. Your scheduler should execute higher-priority tasks first and ensure that all tasks are completed in an efficient manner. **Objective**: Implement a priority task scheduler using a max-heap or priority queue to manage tasks based on their priority levels. **Requirements**: 1. **Class Definition**: ```python class TaskScheduler: def __init__(self) -> None: ... def add_task(self, task_id: int, priority: int) -> None: ... def get_next_task(self) -> int: ... ``` 2. **Functionality**: * The `TaskScheduler` class should use a maximum heap to manage tasks. * The `add_task` method should add a task with a specific priority to the scheduler. * The `get_next_task` method should return the task with the highest priority and remove it from the scheduler. # Input and Output Formats * **Input**: * `add_task`: * `task_id` (int): The identifier for the task. * `priority` (int): The priority level of the task. * `get_next_task`: * No parameters * **Output**: * `add_task`: None (the method should add the task to the scheduler) * `get_next_task`: Returns the `task_id` (int) of the next task to be executed. # Constraints 1. Task identifiers (`task_id`) are unique integers. 2. Priority levels are integers where larger numbers indicate higher priority. 3. The scheduler must efficiently handle adding and retrieving tasks. # Example 1. Create an instance of `TaskScheduler` and manage a few tasks: ```python scheduler = TaskScheduler() scheduler.add_task(1, 5) scheduler.add_task(2, 10) scheduler.add_task(3, 3) next_task = scheduler.get_next_task() # Expected: 2 (highest priority) print(next_task) # Output: 2 next_task = scheduler.get_next_task() # Expected: 1 print(next_task) # Output: 1 next_task = scheduler.get_next_task() # Expected: 3 print(next_task) # Output: 3 ``` Note: The scheduler should return tasks in the order of their priority, higher priority first.","solution":"import heapq class TaskScheduler: def __init__(self) -> None: self.heap = [] def add_task(self, task_id: int, priority: int) -> None: # Use negative priority because heapq is a min-heap by default heapq.heappush(self.heap, (-priority, task_id)) def get_next_task(self) -> int: if not self.heap: raise IndexError(\\"get_next_task() called on empty scheduler\\") return heapq.heappop(self.heap)[1]"},{"question":"# Problem Description You are given a list of tasks that must be performed in a specific order due to dependencies between them. Each task can only be started after all the tasks it depends on are completed. This problem can be visualized as finding a valid topological ordering of a directed acyclic graph (DAG). # Your Task Implement the topological sorting algorithm to determine a valid order in which the tasks can be completed given their dependencies. You can use Kahn’s algorithm or Depth-First Search (DFS) based approach for this. # Input Your function will take one parameter: 1. `tasks` (a dictionary): Each key represents a task (node) and its value is a list of tasks that must be completed before the key task (edges). # Output Your function should return a list of tasks in a valid topological order. # Constraints * The graph has no cycles (it is a valid DAG). * The graph will have at most 2000 tasks. * Each task\'s name is a string of length at most 10 characters. # Example ```python tasks = { \\"A\\": [], \\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\", \\"C\\"], \\"E\\": [\\"D\\"], \\"F\\": [\\"D\\"], } ``` * Expected Output: `[\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"E\\", \\"F\\"]` or `[\\"A\\", \\"C\\", \\"B\\", \\"D\\", \\"E\\", \\"F\\"]` # Function Signature ```python from typing import List, Dict def topological_sort(tasks: Dict[str, List[str]]) -> List[str]: pass # You might include the following example usage if __name__ == \\"__main__\\": tasks = { \\"A\\": [], \\"B\\": [\\"A\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\", \\"C\\"], \\"E\\": [\\"D\\"], \\"F\\": [\\"D\\"], } print(topological_sort(tasks)) # Should return a valid topological order, e.g., [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ```","solution":"from typing import List, Dict from collections import deque, defaultdict def topological_sort(tasks: Dict[str, List[str]]) -> List[str]: indegree = {task: 0 for task in tasks} graph = defaultdict(list) # Build the graph and calculate in-degrees for task, dependencies in tasks.items(): for dependency in dependencies: graph[dependency].append(task) indegree[task] += 1 # Queue for nodes with no incoming edges queue = deque([task for task in tasks if indegree[task] == 0]) topological_order = [] while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(topological_order) == len(tasks): return topological_order else: return [] # This case won\'t be hit as per the problem constraints"},{"question":"# Coding Challenge Context/Scenario You are tasked with creating a function that processes a list of integers and returns a list of the same integers sorted in ascending order but without using the built-in Python functions for sorting. This exercise is to test your ability to implement a basic sorting algorithm from scratch. Function Signature Create a function `custom_sort`: ```python def custom_sort(nums: list[int]) -> list[int]: Given a list of integers, return a new list with the integers sorted in ascending order. The implementation should not use Python\'s built-in sorting functions. ``` Expected Input and Output Formats * **Input**: - `nums (list[int])`: A list of integers [(-10^6 <= nums[i] <= 10^6) for all i ]. * **Output**: - `list[int]`: A new list of integers sorted in ascending order. Constraints and Limitations - Implement the sorting algorithm from scratch, without using Python\'s built-in `sort` or `sorted` functions. - You may use algorithms like Bubble Sort, Insertion Sort, or Selection Sort. Performance Requirements - The function\'s time complexity can be O(n^2) due to the constraints of using simple sorting algorithms. Example ```python >>> custom_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> custom_sort([10, -1, 0, 4, -5]) [-5, -1, 0, 4, 10] >>> custom_sort([]) [] >>> custom_sort([1]) [1] ```","solution":"def custom_sort(nums: list[int]) -> list[int]: Given a list of integers, return a new list with the integers sorted in ascending order. The implementation uses Bubble Sort algorithm from scratch. n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] return nums"},{"question":"# Number Cruncher You are tasked with implementing a function to evaluate and simplify a list of arithmetic commands. Each command manipulates an internal integer counter starting at zero. Problem Statement Implement a function `process_commands` to evaluate a list of commands and return the final value of the counter. 1. **process_commands(commands: List[str]) -> int**: - **Input**: - `commands`: A list of strings where each string is an arithmetic command. The command can be one of the following: - \\"add x\\" : Adds `x` (an integer) to the counter. - \\"subtract y\\" : Subtracts `y` (an integer) from the counter. - \\"multiply z\\" : Multiplies the counter by `z` (an integer). - \\"divide w\\" : Divides the counter by `w` (an integer) using integer division. - **Output**: Returns the final value of the counter as an integer. Constraints * Each command is a valid operation. * The counter can be manipulated to any integer within the typical 32-bit signed integer range. * Dividing by zero is not allowed and should be handled accordingly (e.g., ignoring the command or throwing an error). Example ```python assert process_commands([\'add 10\', \'multiply 2\', \'subtract 5\', \'divide 3\']) == 5 assert process_commands([\'add 8\', \'multiply 0\', \'subtract 10\', \'add 5\']) == -5 ``` Function Definition ```python def process_commands(commands: List[str]) -> int: pass ``` # Requirements - Use an appropriate algorithm to implement the function. - Ensure your function handles edge cases as specified in the analysis. - Efficiency is key; aim for processing each command in O(1) time complexity.","solution":"from typing import List def process_commands(commands: List[str]) -> int: counter = 0 for command in commands: parts = command.split() operation = parts[0] value = int(parts[1]) if operation == \\"add\\": counter += value elif operation == \\"subtract\\": counter -= value elif operation == \\"multiply\\": counter *= value elif operation == \\"divide\\": if value != 0: counter //= value return counter"},{"question":"# Temperature Conversion **Problem Statement:** Write a function `convert_temperature` that converts a given temperature from one unit to another. The available units for conversion are \\"Celsius\\", \\"Fahrenheit\\", and \\"Kelvin\\". Your task is to implement this function so that it correctly performs the conversion and returns the resulting temperature rounded to two decimal places. **Function Signature:** ```python def convert_temperature(temp: float, unit_from: str, unit_to: str) -> float: pass ``` **Input:** - `temp` (float): The temperature value to be converted. - `unit_from` (str): The unit of the input temperature value. - `unit_to` (str): The unit to which the temperature value should be converted. **Output:** - (float): The temperature value after conversion, rounded to two decimal places. **Constraints:** - The input temperature will be a float. - The unit strings `unit_from` and `unit_to` are guaranteed to be one of the valid units: \\"Celsius\\", \\"Fahrenheit\\", \\"Kelvin\\". **Examples:** ```python >>> convert_temperature(0, \\"Celsius\\", \\"Fahrenheit\\") 32.0 >>> convert_temperature(0, \\"Celsius\\", \\"Kelvin\\") 273.15 >>> convert_temperature(32, \\"Fahrenheit\\", \\"Celsius\\") 0.0 >>> convert_temperature(32, \\"Fahrenheit\\", \\"Kelvin\\") 273.15 >>> convert_temperature(273.15, \\"Kelvin\\", \\"Celsius\\") 0.0 >>> convert_temperature(273.15, \\"Kelvin\\", \\"Fahrenheit\\") 32.0 >>> convert_temperature(100, \\"Celsius\\", \\"Fahrenheit\\") 212.0 >>> convert_temperature(100, \\"Celsius\\", \\"Kelvin\\") 373.15 >>> convert_temperature(212, \\"Fahrenheit\\", \\"Celsius\\") 100.0 >>> convert_temperature(212, \\"Fahrenheit\\", \\"Kelvin\\") 373.15 >>> convert_temperature(373.15, \\"Kelvin\\", \\"Celsius\\") 100.0 >>> convert_temperature(373.15, \\"Kelvin\\", \\"Fahrenheit\\") 212.0 ``` **Conversion Formulas:** 1. Celsius to Fahrenheit: (C × 9/5) + 32 = F 2. Fahrenheit to Celsius: (F − 32) × 5/9 = C 3. Celsius to Kelvin: C + 273.15 = K 4. Kelvin to Celsius: K - 273.15 = C 5. Fahrenheit to Kelvin: (F − 32) × 5/9 + 273.15 = K 6. Kelvin to Fahrenheit: (K − 273.15) × 9/5 + 32 = F **Technical Notes:** 1. The function should use the above formulas to perform the conversions. 2. Ensure to handle invalid input units by returning a `ValueError` with a message specifying the invalid units and the valid units.","solution":"def convert_temperature(temp: float, unit_from: str, unit_to: str) -> float: Converts the temperature from one unit to another and returns the converted temperature. Parameters: temp (float): The temperature value to be converted. unit_from (str): The unit of the temperature to convert from. unit_to (str): The unit of the temperature to convert to. Returns: float: The converted temperature rounded to two decimal places. if unit_from == unit_to: return round(temp, 2) if unit_from == \\"Celsius\\": if unit_to == \\"Fahrenheit\\": return round((temp * 9/5) + 32, 2) elif unit_to == \\"Kelvin\\": return round(temp + 273.15, 2) if unit_from == \\"Fahrenheit\\": if unit_to == \\"Celsius\\": return round((temp - 32) * 5/9, 2) elif unit_to == \\"Kelvin\\": return round((temp - 32) * 5/9 + 273.15, 2) if unit_from == \\"Kelvin\\": if unit_to == \\"Celsius\\": return round(temp - 273.15, 2) elif unit_to == \\"Fahrenheit\\": return round((temp - 273.15) * 9/5 + 32, 2) raise ValueError(f\\"Invalid unit conversion from {unit_from} to {unit_to}. Valid units are \'Celsius\', \'Fahrenheit\', \'Kelvin\'.\\")"},{"question":"**Context**: You are developing a program that simulates a simplified version of an online bookstore. One of the features is to determine if a customer\'s book purchase qualifies for a bulk discount. A bulk discount is applied if the customer buys a specified number of unique books from a predefined list. **Task**: Write a function `qualifies_for_discount(purchase: List[str], required_books: List[str], min_unique_books: int) -> bool` that checks if the customer\'s purchase qualifies for a bulk discount. **Function Specifications**: * **Input**: - `purchase`: A list of strings (List[str]), representing the titles of books purchased by the customer. - `required_books`: A list of strings (List[str]), representing the titles of books that qualify for the bulk discount. - `min_unique_books`: An integer representing the minimum number of unique books from the `required_books` list that must be purchased to qualify for the discount. * **Output**: - Returns a boolean value: `True` if the purchase qualifies for the bulk discount, `False` otherwise. **Constraints**: * The titles in the purchase list and the required_books list are non-empty strings. * The purchase list, required_books list, and min_unique_books are non-negative. * The required_books list does not contain duplicate titles. **Examples**: ```python >>> qualifies_for_discount([\\"Book A\\", \\"Book B\\", \\"Book C\\"], [\\"Book A\\", \\"Book B\\", \\"Book C\\", \\"Book D\\"], 3) True >>> qualifies_for_discount([\\"Book A\\", \\"Book B\\", \\"Book C\\"], [\\"Book A\\", \\"Book B\\", \\"Book D\\"], 3) False >>> qualifies_for_discount([\\"Book A\\", \\"Book B\\", \\"Book B\\"], [\\"Book A\\", \\"Book B\\", \\"Book C\\"], 2) True >>> qualifies_for_discount([\\"Book A\\", \\"Book A\\"], [\\"Book A\\", \\"Book B\\"], 2) False ``` **Additional Considerations**: * Your implementation should handle edge cases, such as when the purchase list contains no books or when `min_unique_books` is greater than the length of the `required_books` list. * Consider handling performance for large inputs efficiently.","solution":"def qualifies_for_discount(purchase, required_books, min_unique_books): Determines if a purchase qualifies for a bulk discount based on the number of unique books bought from a list of required books. Parameters: purchase (List[str]): List of book titles purchased. required_books (List[str]): List of book titles that qualify for the discount. min_unique_books (int): Minimum number of unique qualifying books required for the discount. Returns: bool: True if the purchase qualifies for the bulk discount, False otherwise. unique_books_purchased = set(book for book in purchase if book in required_books) return len(unique_books_purchased) >= min_unique_books"},{"question":"# Problem Statement You are tasked with implementing a custom HashMap `CustomHashMap` that efficiently supports the following operations: 1. **Insertion**: Insert a (key, value) pair into the map. If the key already exists, update its value. 2. **Deletion**: Remove the key (and its corresponding value) from the map. 3. **Query Value**: Retrieve the value associated with a given key. 4. **Contains Key**: Check if the map contains a specific key. 5. **Get Keys by Value**: Retrieve a list of all keys that have the given value. Your implementation should strive for efficient operations in terms of both time and space complexity. # Function Signatures ```python class CustomHashMap: def __init__(self) -> None: Initializes the empty data structure. def insert(self, key: int, value: int) -> None: Inserts the (key, value) pair into the HashMap. def delete(self, key: int) -> None: Removes the key (and its corresponding value) from the HashMap if the key exists. def query_value(self, key: int) -> int: Returns the value associated with the key. Returns -1 if the key does not exist. def contains_key(self, key: int) -> bool: Returns True if the HashMap contains the given key, False otherwise. def get_keys_by_value(self, value: int) -> list[int]: Returns a list of keys that have the given value. The list can be in any order. ``` # Input Constraints - Keys and values are integers between `-10^9` and `10^9`. - Keys are unique within the HashMap. - You may assume that none of the input functions will be called with invalid parameters. # Example Usage ```python # Initialize the data structure chm = CustomHashMap() # Insert key-value pairs into the HashMap chm.insert(1, 100) chm.insert(2, 200) chm.insert(3, 100) # Query the value associated with key 1 print(chm.query_value(1)) # Output: 100 # Check if key 2 exists print(chm.contains_key(2)) # Output: True # Retrieve keys associated with the value 100 print(chm.get_keys_by_value(100)) # Output: [1, 3] # Remove key 2 from the HashMap chm.delete(2) # Query the value associated with key 2 (after deletion) print(chm.query_value(2)) # Output: -1 ``` # Constraints - You must efficiently handle operations even if the map holds up to `10^5` entries. - Consider edge cases, such as querying a non-existent key or deleting a key already deleted. - The list returned by `get_keys_by_value` for a value that has no associated keys should be empty.","solution":"class CustomHashMap: def __init__(self) -> None: Initializes the empty data structure. self._map = {} self._value_to_keys = {} def insert(self, key: int, value: int) -> None: Inserts the (key, value) pair into the HashMap. if key in self._map: old_value = self._map[key] if old_value != value: self._value_to_keys[old_value].remove(key) if not self._value_to_keys[old_value]: del self._value_to_keys[old_value] self._map[key] = value if value not in self._value_to_keys: self._value_to_keys[value] = set() self._value_to_keys[value].add(key) def delete(self, key: int) -> None: Removes the key (and its corresponding value) from the HashMap if the key exists. if key in self._map: value = self._map[key] self._value_to_keys[value].remove(key) if not self._value_to_keys[value]: del self._value_to_keys[value] del self._map[key] def query_value(self, key: int) -> int: Returns the value associated with the key. Returns -1 if the key does not exist. return self._map.get(key, -1) def contains_key(self, key: int) -> bool: Returns True if the HashMap contains the given key, False otherwise. return key in self._map def get_keys_by_value(self, value: int) -> list[int]: Returns a list of keys that have the given value. The list can be in any order. if value in self._value_to_keys: return list(self._value_to_keys[value]) return []"},{"question":"You are tasked with writing a Python function that simulates a parity generator. The function will take a list of binary values (0s and 1s) and return the parity bit. The parity bit is 0 if the number of 1s in the list is even, and 1 if the number of 1s is odd. If the list contains elements other than 0 or 1, a `ValueError` should be raised. # Function Signature ```python def parity_generator(bits: list) -> int: Implement a parity generator. :param bits: A list of binary values (0 or 1). :return: The parity bit (0 if the number of 1s is even, 1 if the number of 1s is odd). Examples: >>> parity_generator([0, 1, 0, 1]) 0 >>> parity_generator([1, 1, 0, 0, 1]) 1 >>> parity_generator([1, 1, 1]) 1 >>> parity_generator([0, 0, 0]) 0 >>> parity_generator([1, 0, 2]) Traceback (most recent call last): ... ValueError: All elements in the list must be 0 or 1 >>> parity_generator([0, 1, -1]) Traceback (most recent call last): ... ValueError: All elements in the list must be 0 or 1 ``` # Constraints 1. The elements in the list `bits` must be 0 or 1 only. 2. If any element in the list is not 0 or 1, raise a `ValueError`. # Task Implement the `parity_generator` function to correctly calculate and return the parity bit based on the provided binary list, with proper error handling for invalid elements.","solution":"def parity_generator(bits: list) -> int: Implement a parity generator. :param bits: A list of binary values (0 or 1). :return: The parity bit (0 if the number of 1s is even, 1 if the number of 1s is odd). for bit in bits: if bit not in [0, 1]: raise ValueError(\\"All elements in the list must be 0 or 1\\") count_ones = bits.count(1) return 1 if count_ones % 2 != 0 else 0"},{"question":"# Find Duplicates in a List Scenario You are given a list of integers, and you need to identify all the duplicate elements in it. The result should include each element that appears more than once, and it should not contain any duplicates itself. Objective Write a function `find_duplicates` in Python that takes a list of integers and returns a list of integers representing the duplicate elements found in the input list. Function Signature ```python def find_duplicates(nums: list[int]) -> list[int]: ``` Input: 1. `nums`: A list of integers which may contain duplicates. Output: A list of integers representing the duplicate elements found in `nums`. Constraints: * The length of `nums` is at least 1. * All integers in the list are within the range `-10^5` to `10^5`. Requirements: 1. If no duplicates are found, return an empty list. 2. The output list must not contain any duplicates. 3. The relative order of duplicate elements in the output list should be the same as their first occurrence in the input list. Examples: ```python # Examples print(find_duplicates([1, 2, 3, 2, 4, 3, 5, 3, 2])) # Output: [2, 3] print(find_duplicates([10, 20, 10, 30, 40, 50, 30, 60, 70, 80, 90, 50])) # Output: [10, 30, 50] print(find_duplicates([1, 1, 1, 1, 1, 1, 1, 1, 1, 1])) # Output: [1] print(find_duplicates([5, 6, 7, 8, 9])) # Output: [] print(find_duplicates([1, -1, 2, -2, 3, -3, -1, 2, -2])) # Output: [-1, 2, -2] ``` Use appropriate methods and data structures to ensure your solution is efficient and handles large inputs effectively. Note: Your solution should minimize the use of unnecessary space and aim for optimal time complexity. Ensure that your implementation can handle the edge cases gracefully.","solution":"from collections import Counter def find_duplicates(nums: list[int]) -> list[int]: Takes a list of integers and returns a list of duplicates found in the input list. The output list should not contain any duplicates itself and should maintain the relative order of their first occurrence in the input list. count = Counter(nums) duplicates = [num for num in count if count[num] > 1] return duplicates"},{"question":"# Problem: You are tasked with creating a function that takes a list of integers and returns a list of the products of all elements except the one at the current index. # Objective: Implement the function `product_except_self(nums: List[int]) -> List[int]` that takes a list of integers as input and returns a list such that each element at index `i` is the product of all the numbers in the original array except the one at `i`. # Function Signature: ```python def product_except_self(nums: List[int]) -> List[int]: ``` # Input: - `nums`: A list of integers, where the length of `nums` (1 <= len(nums) <= 1000) and each integer (1 <= nums[i] <= 10). # Output: - A list of integers where each integer is the product of all elements in the input list except the one at the corresponding index. # Example: ```python nums = [1, 2, 3, 4] output = product_except_self(nums) # Expected output: [24, 12, 8, 6] nums = [2, 3, 4, 5] output = product_except_self(nums) # Expected output: [60, 40, 30, 24] ``` # Constraints: - You must solve it in O(n) time complexity. - You cannot use division operation. # Guidance: In your function: 1. You can utilize two arrays to keep track of the cumulative products from the left and the right. 2. Compute the cumulative product for each element from the left and store it in a list. 3. Compute the cumulative product for each element from the right and store it in another list. 4. Finally, multiply the elements from both the lists to get the desired array of products. 5. Return the resulting list.","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: length = len(nums) answer = [0] * length # Step 1: Create an array with the products of all elements to the left of each index left_products = [1] * length for i in range(1, length): left_products[i] = left_products[i - 1] * nums[i - 1] # Step 2: Create an array with the products of all elements to the right of each index right_products = [1] * length for i in range(length - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] # Step 3: Multiply the left and right products for each index for i in range(length): answer[i] = left_products[i] * right_products[i] return answer"},{"question":"You are tasked with building a movie recommendation system that suggests movies based on their rating and genre. For simplicity, you\'ll be given a list of movies, each with its title, genre, and average rating on a scale from 1 to 10. You need to create a function that can filter and return movies of a specific genre with a rating equal to or higher than a given threshold. **Function Specification**: You need to implement the function `filter_movies_by_genre_and_rating` that filters movies based on the specified genre and minimum rating. *Input Parameters*: - `movies` (list of tuples): A list of movies, where each movie is represented by a tuple containing three elements: 1. `title` (str): The title of the movie. 2. `genre` (str): The genre of the movie. 3. `rating` (float): The average rating of the movie. - `genre` (str): The genre that you want to filter the movies by. - `min_rating` (float): The minimum rating threshold for the movies. *Output*: - A list of movie titles (strings) that belong to the specified genre and have a rating equal to or higher than the specified minimum rating. The titles should be sorted in descending order of their ratings. *Constraints*: 1. `movies` list will contain at least one movie. 2. Each movie tuple will have non-empty strings for title and genre, and a rating between 1 and 10 (inclusive). 3. `min_rating` will be a float between 1 and 10 (inclusive). *Example*: ```python >>> movies = [ (\\"The Matrix\\", \\"Sci-Fi\\", 8.7), (\\"Inception\\", \\"Sci-Fi\\", 8.8), (\\"Interstellar\\", \\"Sci-Fi\\", 8.6), (\\"Gladiator\\", \\"Action\\", 8.5), (\\"The Dark Knight\\", \\"Action\\", 9.0), (\\"Pulp Fiction\\", \\"Crime\\", 8.9) ] >>> genre = \\"Sci-Fi\\" >>> min_rating = 8.7 >>> filter_movies_by_genre_and_rating(movies, genre, min_rating) [\'Inception\', \'The Matrix\'] >>> genre = \\"Action\\" >>> min_rating = 8.0 >>> filter_movies_by_genre_and_rating(movies, genre, min_rating) [\'The Dark Knight\', \'Gladiator\'] >>> genre = \\"Crime\\" >>> min_rating = 5.0 >>> filter_movies_by_genre_and_rating(movies, genre, min_rating) [\'Pulp Fiction\'] ``` *Error Handling*: - Raise a `ValueError` if the `min_rating` is not between 1 and 10 (inclusive). Implement the function `filter_movies_by_genre_and_rating` to fulfill the above requirements.","solution":"def filter_movies_by_genre_and_rating(movies, genre, min_rating): Filters movies based on the specified genre and minimum rating. Parameters: - movies (list of tuples): A list of movies, where each movie is represented by a tuple containing (title, genre, rating). - genre (str): The genre to filter the movies by. - min_rating (float): The minimum rating threshold. Returns: - list: A list of movie titles that match the specified genre and have a rating equal to or higher than the specified minimum rating, sorted in descending order of rating. if not (1 <= min_rating <= 10): raise ValueError(\\"min_rating must be between 1 and 10 inclusive.\\") filtered_movies = [movie for movie in movies if movie[1] == genre and movie[2] >= min_rating] filtered_movies.sort(key=lambda x: x[2], reverse=True) return [movie[0] for movie in filtered_movies]"},{"question":"# Coding Challenge: Optimize a File System Path Context You are developing an application that involves manipulations of file system paths. To ensure smooth operation, it is required to optimize the paths by resolving relative elements and removing redundancy. Task Implement a function to simplify a given file system path. Your task is to convert paths with unnecessary elements (like \\".\\" and \\"..\\") into their simplified form. Specifications - **Function Signature**: `def simplify_path(path: str) -> str` - **Input**: `path` - A string representing the path to be simplified. - **Output**: Returns the simplified path as a string. # Description - The input path is a string beginning with a \\"/\\". - The path may contain \\".\\" (current directory), \\"..\\" (parent directory), or extraneous slashes. - Consequently, the returned simplified path must also begin with a \\"/\\" and must not contain extraneous slashes or dot references beyond what\'s necessary. Rules: 1. A single dot (\\"./\\") refers to the current directory and can be ignored. 2. A double dot (\\"../\\") refers to the parent directory and can remove the last directory from the stack. 3. Multiple consecutive slashes (\\"///\\") should be treated as a single slash (\\"/\\"). # Example Usage ```python print(simplify_path(\\"/home/\\")) # Output: \\"/home\\" print(simplify_path(\\"/../\\")) # Output: \\"/\\" print(simplify_path(\\"/home//foo/\\")) # Output: \\"/home/foo\\" print(simplify_path(\\"/a/./b/../../c/\\")) # Output: \\"/c\\" print(simplify_path(\\"/a/b/c/.\\")) # Output: \\"/a/b/c\\" ``` # Constraints 1. The input path will be a non-empty string. 2. The path will not contain any non-standard characters (ASCII only). 3. You should not use any additional data structures beyond the necessary stack to maintain and process the path components. # Additional Considerations - Ensure your function handles edge cases, such as paths that result in going beyond the root directory. - The runtime complexity should efficiently handle long paths with multiple elements, ensuring linear time complexity. ```python def simplify_path(path: str) -> str: stack = [] components = path.split(\'/\') for component in components: if component == \\"..\\": if stack: stack.pop() elif component and component != \\".\\": stack.append(component) return \\"/\\" + \\"/\\".join(stack) ``` # Explanation - The function starts by splitting the input path based on the \'/\' delimiter. - It uses a stack to keep track of the legitimate directory names. - For every component: - Ignore empty components or single dots. - For \\"..\\", pop the last element from the stack if it exists. - Otherwise, push the current component to the stack. - Finally, join all components in the stack with \\"/\\" to generate the simplified path.","solution":"def simplify_path(path: str) -> str: stack = [] components = path.split(\'/\') for component in components: if component == \\"..\\": if stack: stack.pop() elif component and component != \\".\\": stack.append(component) return \\"/\\" + \\"/\\".join(stack)"},{"question":"# Context In the realm of computational geometry, it\'s important to understand fundamental geometric algorithms. One such algorithm is the Convex Hull algorithm which finds the smallest convex polygon that can contain a set of points on a plane. # Task Your task is to implement the Convex Hull algorithm using the Graham scan method. The algorithm should be efficient and capable of handling multiple points in a 2D plane. # Function Implementation 1. Implement a function `graham_scan(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]` that computes the convex hull of a set of 2D points. 2. Ensure the function returns a list of points that form the vertices of the convex hull in counterclockwise order starting from the vertex with the lowest y-coordinate (sorted by x-coordinate if there is a tie). # Function Specification and Implementation Requirements * **Function: graham_scan** * **Input**: A list of tuples where each tuple represents a point on a 2D plane in the form `(x, y)`. * **Output**: A list of tuples representing the vertices of the convex hull in counterclockwise order. # Constraints and Limitations * The input list will contain at least 3 points. * The function should be efficient with a time complexity of O(n log n), where n is the number of points. * Handle edge cases such as collinear points in the input set. * The points in the convex hull should not contain duplicate points. # Example ```python points = [(0,0), (1,1), (2,2), (2,0), (1,2)] convex_hull = graham_scan(points) assert convex_hull == [(0, 0), (2, 0), (2, 2), (1, 2)] ``` The function `graham_scan` should accurately compute the convex hull for a given set of points.","solution":"from typing import List, Tuple def graham_scan(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Step 1: Find the point with the lowest y-coordinate (pivot point) pivot = min(points, key=lambda p: (p[1], p[0])) # Step 2: Sort points based on the polar angle with pivot def polar_angle(p): import math y_span, x_span = p[1] - pivot[1], p[0] - pivot[0] return math.atan2(y_span, x_span) sorted_points = sorted(points, key=lambda p: (polar_angle(p), (pivot[0] - p[0]) ** 2 + (pivot[1] - p[1]) ** 2)) # Step 3: Handle collinear points by keeping the farthest one if there are duplicate angles filtered_points = [sorted_points[0]] for p in sorted_points[1:]: while len(filtered_points) > 1 and polar_angle(filtered_points[-1]) == polar_angle(p) and (pivot[0] - filtered_points[-1][0]) ** 2 + (pivot[1] - filtered_points[-1][1]) ** 2 < (pivot[0] - p[0]) ** 2 + (pivot[1] - p[1]) ** 2: filtered_points.pop() filtered_points.append(p) # Step 4: Process points to construct convex hull hull = [] for p in filtered_points: while len(hull) > 1 and cross_product(hull[-2], hull[-1], p) <= 0: hull.pop() hull.append(p) return hull def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])"},{"question":"Check if Two Strings Are Anagrams # Problem Statement Two strings are considered anagrams if they can be rearranged to form each other by reordering their characters. Write a function to determine if two input strings are anagrams of each other. # Function Signature ```python def are_anagrams(s1: str, s2: str) -> bool: ``` # Input * `s1` (string): A lowercase string. Constraints: 1 ≤ `len(s1)` ≤ 100. * `s2` (string): A lowercase string. Constraints: 1 ≤ `len(s2)` ≤ 100. # Output * Returns a boolean value `True` if `s1` and `s2` are anagrams, `False` otherwise. # Example ```python >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"triangle\\", \\"integral\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False ``` # Constraints - The input strings will consist only of lowercase English letters. - The length of each string will be between 1 and 100 characters. # Performance Requirements - The solution should run in O(n) time, where n is the length of the longer string. - Space complexity should be O(1) if using constant extra space or O(n) if using additional data structures like dictionaries or lists. # Detailed Requirements 1. Ensure the function handles simple cases with short strings accurately. 2. Verify the function correctly identifies anagrams when the characters are the same in different orders. 3. Use sorting or frequency counting to compare the counts of each character in both strings. 4. Document and test the function with various edge cases, including completely dissimilar strings, identical strings, and strings of different lengths.","solution":"def are_anagrams(s1: str, s2: str) -> bool: Determine if two strings are anagrams of each other. Parameters: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if both strings are anagrams, False otherwise. if len(s1) != len(s2): return False # Frequency dictionary to count occurrences of each character char_count = {} for char in s1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in s2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"# Challenging Coding Assessment Question Context String manipulation and text processing are essential skills in programming, with applications ranging from data munging to user interface development. One frequent operation is to analyze strings for repeated patterns and substrings. Task Implement a function `longest_repeated_substring(s: str) -> str` that identifies and returns the longest substring that appears at least twice in the input string. If there are multiple substrings of the same maximum length, return the one that appears first. Input and Output Formats: ```python def longest_repeated_substring(s: str) -> str: pass # Example usage: print(longest_repeated_substring(\\"banana\\")) # Output: \\"ana\\" print(longest_repeated_substring(\\"abcdabc\\")) # Output: \\"abc\\" print(longest_repeated_substring(\\"abcdef\\")) # Output: \\"\\" ``` Constraints: * `1 <= len(s) <= 10^5` * The input string `s` consists of lowercase English letters only. Requirements: 1. **Efficient Substring Search:** Implement an efficient method to locate repeated substrings, potentially using suffix arrays, binary search or other advanced techniques. 2. **Handling Edge Cases:** Ensure the function handles cases where no repeated substrings exist by returning an empty string. 3. **Complexity Consideration:** Aim for a time complexity of `O(n^2)` or better, where `n` is the length of the input string. Performance Goals: * Optimize the function to handle large input sizes efficiently, ensuring it operates within reasonable time limits for the maximum constraints. * Focus on clear and concise code to make maintenance and further optimizations easier. Implement the `longest_repeated_substring` function, ensuring it meets the above specifications and performs well for various input cases, particularly for long strings and large datasets.","solution":"def build_suffix_array(s): suffixes = [(s[i:], i) for i in range(len(s))] suffixes.sort() suffix_array = [suffix[1] for suffix in suffixes] return suffix_array def build_lcp_array(s, suffix_array): n = len(s) rank = [0] * n for i, suffix in enumerate(suffix_array): rank[suffix] = i lcp = [0] * n h = 0 for i in range(n): if rank[i] > 0: j = suffix_array[rank[i] - 1] while i + h < n and j + h < n and s[i + h] == s[j + h]: h += 1 lcp[rank[i]] = h if h > 0: h -= 1 return lcp def longest_repeated_substring(s): if not s: return \\"\\" suffix_array = build_suffix_array(s) lcp_array = build_lcp_array(s, suffix_array) max_lcp = 0 index = 0 for i in range(1, len(s)): if lcp_array[i] > max_lcp: max_lcp = lcp_array[i] index = suffix_array[i] return s[index:index + max_lcp]"},{"question":"# Problem Statement Write a function that finds the first non-repeating character in a given string. If all characters repeat, return an underscore (\'_\'). **Input Format**: - A string `s` consisting of lower case English letters. **Output Format**: - Return a single character that is the first non-repeating character, or an underscore if there is no such character. **Constraints**: 1. The length of the string will be between 1 and 10^5. Write your function: ```python def first_non_repeating_character(s: str) -> str: pass ``` **Example**: ```python >>> first_non_repeating_character(\\"leetcode\\") \\"l\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"_\\" >>> first_non_repeating_character(\\"aabbccd\\") \\"d\\" ```","solution":"def first_non_repeating_character(s: str) -> str: Finds the first non-repeating character in a given string. If all characters repeat, returns an underscore (\'_\'). :param s: A string consisting of lowercase English letters. :return: The first non-repeating character or an underscore. from collections import Counter # Count the frequency of each character in the string counter = Counter(s) # Iterate through the string and return the first character with a count of 1 for char in s: if counter[char] == 1: return char # If no non-repeating character is found, return \'_\' return \'_\'"},{"question":"# Question: Implementing a Queue Using Stacks You are tasked with implementing a queue using two stacks. The queue should support the following operations: `enqueue` (adding an element to the end of the queue) and `dequeue` (removing the front element from the queue). Function Signatures ```python class QueueUsingStacks: def __init__(self): pass def enqueue(self, value: int) -> None: pass def dequeue(self) -> int: pass ``` Methods * `__init__()` - Initializes the data structure. * `enqueue(value: int) -> None` - Adds an element to the end of the queue. * `dequeue() -> int` - Removes and returns the front element of the queue. If the queue is empty, return `-1`. Constraints * The values to be enqueued are integers. * Multiple calls to both `enqueue` and `dequeue` functions will be made. * You must use only the two stacks to implement the queue. * The maximum number of elements in the queue will not exceed (10^4). Example ```python # Example 1: queue = QueueUsingStacks() queue.enqueue(1) queue.enqueue(2) print(queue.dequeue()) # Output: 1 print(queue.dequeue()) # Output: 2 print(queue.dequeue()) # Output: -1 # Queue is empty # Example 2: queue = QueueUsingStacks() queue.enqueue(10) queue.enqueue(20) queue.enqueue(30) print(queue.dequeue()) # Output: 10 queue.enqueue(40) print(queue.dequeue()) # Output: 20 print(queue.dequeue()) # Output: 30 print(queue.dequeue()) # Output: 40 print(queue.dequeue()) # Output: -1 # Queue is empty ```","solution":"class QueueUsingStacks: def __init__(self): self.stack1 = [] self.stack2 = [] def enqueue(self, value: int) -> None: self.stack1.append(value) def dequeue(self) -> int: if not self.stack2: while self.stack1: self.stack2.append(self.stack1.pop()) if not self.stack2: return -1 return self.stack2.pop()"},{"question":"# Find the Longest Common Subsequence Context You are part of a software development team building a text comparison tool. One of the features is to find similar segments between two texts to highlight commonalities. A key aspect of this feature is to identify the longest common subsequence (LCS) between two strings, which will help in understanding the degree of similarity. Task Write a Python function that takes two strings and returns the length of their longest common subsequence (LCS). A subsequence is a sequence that appears in the same relative order but not necessarily consecutively. Input The function `longest_common_subsequence` takes two arguments: - `text1` (str): The first string. - `text2` (str): The second string. Output The function should return an integer representing the length of the longest common subsequence between the two input strings. Constraints - The length of `text1` and `text2` will be between 1 and 1000. - Both strings will consist of lowercase English letters. Example ```python # Given strings text1 = \\"abcde\\" text2 = \\"ace\\" # Expected output # 3 (The longest common subsequence is \\"ace\\") length = longest_common_subsequence(text1, text2) print(length) # should print: 3 ``` Solution Template Here\'s a template to get you started: ```python def longest_common_subsequence(text1: str, text2: str) -> int: m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] # Test cases: if __name__ == \\"__main__\\": test_cases = [ (\\"abcde\\", \\"ace\\"), # LCS length 3 (\\"abc\\", \\"abc\\"), # LCS length 3 (\\"abc\\", \\"def\\"), # LCS length 0 ] for text1, text2 in test_cases: print(longest_common_subsequence(text1, text2)) ```","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence of text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Restaurant Order System **Scenario**: As a software developer for a restaurant, you have been given the task to create a system for managing and validating customer orders. Each order in the system is represented by a unique identifier and a list of items included in the order. Your task is to implement functionalities to validate and correct orders based on the total number of items allowed and verify that the identifiers follow a specific pattern. **Requirements**: 1. Write a function `generate_valid_order(order_id: str, items: list) -> dict` that takes a string representing an order ID and a list of items. Ensure the order ID follows the pattern where it starts with \\"ORD\\" followed by exactly 5 digits (e.g., \\"ORD12345\\"). Additionally, limit the number of items to a maximum of 10. Return a dictionary representing the valid order including the corrected order ID and an adjusted list of items if necessary. 2. Write a function `correct_order(order: dict) -> dict` that takes a dictionary with an order ID and a list of items. This function should verify if the order ID and items list comply with the specified constraints. Return the corrected order if it\'s invalid; otherwise, return the original order. **Function Signatures**: ```python def generate_valid_order(order_id: str, items: list) -> dict: pass def correct_order(order: dict) -> dict: pass ``` **Input/Output**: * `generate_valid_order`: * **Input**: * A string `order_id` (an identifier for the order). * A list of strings `items` (a list representing the items in the order). * **Output**: * A dictionary representing the valid order: `{\'order_id\': str, \'items\': list}`. * `correct_order`: * **Input**: * A dictionary `order` with keys: * \'order_id\': a string representing the order ID. * \'items\': a list of strings representing the items. * **Output**: * A dictionary representing the corrected order if the original was invalid; otherwise, return the original order. **Constraints**: * The input to `generate_valid_order` and `correct_order` will always be provided as per the specified data types. * The order ID must follow the pattern \\"ORD\\" followed by exactly 5 digits. * The list of items should not exceed 10 items. * Do not use any external libraries other than built-in ones. * Ensure the functions handle edge cases and raise appropriate errors if the input format is invalid. **Example**: ```python >>> generate_valid_order(\\"ORD123\\", [\\"pizza\\", \\"burger\\", \\"coke\\", \\"fries\\"]) {\'order_id\': \'ORD00123\', \'items\': [\'pizza\', \'burger\', \'coke\', \'fries\']} >>> generate_valid_order(\\"ORD67890\\", [\\"pizza\\", \\"burger\\", \\"coke\\", \\"fries\\", \\"salad\\", \\"ice cream\\", \\"soda\\", \\"sandwich\\", \\"pasta\\", \\"soup\\", \\"cake\\"]) {\'order_id\': \'ORD67890\', \'items\': [\'pizza\', \'burger\', \'coke\', \'fries\', \'salad\', \'ice cream\', \'soda\', \'sandwich\', \'pasta\', \'soup\']} >>> correct_order({\'order_id\': \'ORD123\', \'items\': [\\"pizza\\", \\"burger\\"]}) {\'order_id\': \'ORD00123\', \'items\': [\\"pizza\\", \\"burger\\"]} >>> correct_order({\'order_id\': \'ORD67890\', \'items\': [\\"pizza\\", \\"burger\\", \\"coke\\", \\"fries\\", \\"salad\\", \\"ice cream\\", \\"soda\\", \\"sandwich\\", \\"pasta\\", \\"soup\\", \\"cake\\"]}) {\'order_id\': \'ORD67890\', \'items\': [\'pizza\', \'burger\', \'coke\', \'fries\', \'salad\', \'ice cream\', \'soda\', \'sandwich\', \'pasta\', \'soup\']} ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments.","solution":"import re def generate_valid_order(order_id: str, items: list) -> dict: # Ensure order ID follows the correct pattern if not re.match(r\'^ORDd{5}\', order_id): # Pad with zeros if necessary order_id = f\\"ORD{int(order_id[3:]):05d}\\" if order_id.startswith(\\"ORD\\") else f\\"ORD{int(order_id):05d}\\" # Limit items to a maximum of 10 items = items[:10] return {\'order_id\': order_id, \'items\': items} def correct_order(order: dict) -> dict: order_id = order.get(\'order_id\', \'\') items = order.get(\'items\', []) # Validate and correct the order ID and items corrected_order = generate_valid_order(order_id, items) return corrected_order"},{"question":"# Coding Assessment Question: Compare String Versions You are given two version numbers version1 and version2 in string format. Your task is to write a function to compare the two version numbers. If version1 > version2, return 1; if version1 < version2, return -1; otherwise, return 0. The version strings are non-empty and only contain digits and the `.` character. The `.` character does not represent a decimal point and is used to separate number sequences. For instance, `\\"3.2.1\\"` is valid whereas `\\"3..\\"`, `\\"3..1\\"`, and `\\"3.-1\\"` are not valid versions. The version strings do not have leading zeros, such as `\\"01\\"`, and each numeric section in the version string fits into an integer. Write a function to compare these version numbers. Function Signature ```python def compare_version(version1: str, version2: str) -> int: pass ``` # Input * `version1`: A string representing the first version number. * `version2`: A string representing the second version number. # Output * Returns an integer: * `1` if `version1 > version2` * `-1` if `version1 < version2` * `0` if `version1 == version2` # Example ```python version1 = \\"1.0.1\\" version2 = \\"1.0.0\\" # Output: 1 version1 = \\"1.0.0\\" version2 = \\"1.0\\" # Output: 0 version1 = \\"0.1\\" version2 = \\"1.1\\" # Output: -1 version1 = \\"1.2.3\\" version2 = \\"1.2.3.0\\" # Output: 0 ``` # Constraints * Each version string `version1` and `version2` must be a non-empty string containing only digits and `.` characters (1 ≤ len(version1), len(version2) ≤ 500). * Each numeric section in the version strings fits into a positive integer (i.e., no leading zeros, no negative numbers). # Requirements 1. The function should handle version numbers with different lengths. 2. Ensure that the function works efficiently even for large inputs. 3. Consider edge cases such as empty parts, trailing zeros, and different version string lengths. Implement the function `compare_version` that compares the two given version numbers according to the constraints and requirements.","solution":"def compare_version(version1: str, version2: str) -> int: Compares two version numbers version1 and version2. :param version1: A string representing the first version number. :param version2: A string representing the second version number. :returns: 1 if version1 > version2, -1 if version1 < version2, and 0 if they are equal. v1_parts = list(map(int, version1.split(\'.\'))) v2_parts = list(map(int, version2.split(\'.\'))) # Adding extra zeros to make lengths of both lists equal max_length = max(len(v1_parts), len(v2_parts)) v1_parts.extend([0] * (max_length - len(v1_parts))) v2_parts.extend([0] * (max_length - len(v2_parts))) for i in range(max_length): if v1_parts[i] > v2_parts[i]: return 1 elif v1_parts[i] < v2_parts[i]: return -1 return 0"},{"question":"# Problem Statement Implement a function `string_interleave` that merges two input strings by alternating their characters. If one string is longer than the other, append the remaining characters of the longer string at the end of the result. # Requirements 1. **Function Signature**: ```python def string_interleave(s1: str, s2: str) -> str: ``` 2. **Inputs**: * `s1` (str): The first input string. * `s2` (str): The second input string. 3. **Outputs**: * Returns a single string which is the interleaved result of `s1` and `s2`. 4. **Constraints**: * Both `s1` and `s2` can be empty strings. * The strings can contain any printable ASCII characters. # Example Usage ```python >>> string_interleave(\\"abc\\", \\"123\\") \'a1b2c3\' >>> string_interleave(\\"ab\\", \\"123\\") \'a1b23\' >>> string_interleave(\\"abcd\\", \\"12\\") \'a1b2cd\' >>> string_interleave(\\"\\", \\"xyz\\") \'xyz\' >>> string_interleave(\\"hello\\", \\"\\") \'hello\' ``` # Additional Notes - Ensure that edge cases, such as when one or both input strings are empty, are handled correctly. - Consider the performance for very long input strings. - The function should maintain the original order of characters in both strings.","solution":"def string_interleave(s1: str, s2: str) -> str: Merges two strings by alternating their characters. If one string is longer than the other, append the remaining characters of the longer string at the end of the result. Args: s1 (str): The first input string. s2 (str): The second input string. Returns: str: The interleaved result of s1 and s2. result = [] len1, len2 = len(s1), len(s2) min_len = min(len1, len2) for i in range(min_len): result.append(s1[i]) result.append(s2[i]) # Append remaining part of the longer string if len1 > len2: result.append(s1[min_len:]) elif len2 > len1: result.append(s2[min_len:]) return \'\'.join(result)"},{"question":"# Spiral Matrix Generation Challenge Scenario Given two integers `m` and `n`, create an `m` x `n` matrix filled with elements from 1 to `m*n` in a spiral order. Your task is to implement a function that generates the matrix in a spiral pattern starting from the top-left corner and winding inwards. Function Signature ```python def generate_spiral_matrix(m: int, n: int) -> list: Given two integers m and n, returns an m x n matrix filled with elements from 1 to m*n in spiral order. Parameters: m (int): Number of rows in the matrix. n (int): Number of columns in the matrix. Returns: list: An m x n matrix filled in spiral order. Example: >>> generate_spiral_matrix(3, 4) [[1, 2, 3, 4], [10, 11, 12, 5], [9, 8, 7, 6]] Constraints: * Both m and n are positive integers. ``` Requirements 1. The function should validate that both `m` and `n` are positive integers. Raise a `TypeError` with the message \\"m and n must be positive integers\\" if this condition is not met. 2. Follow the spiral order logic to fill the matrix with sequential numbers starting from 1. 3. Ensure the solution efficiently fills the matrix within reasonable limits based on input constraints. 4. The function should handle edge cases where `m` or `n` equals 1. Constraints * You must not use any external libraries for matrix operations. * The function should handle various dimensions of the matrix gracefully, including simple cases like 1x1, 1xN, and Mx1.","solution":"def generate_spiral_matrix(m: int, n: int) -> list: if not isinstance(m, int) or not isinstance(n, int) or m <= 0 or n <= 0: raise TypeError(\\"m and n must be positive integers\\") # Initialize an empty matrix matrix = [[0] * n for _ in range(m)] # Define the initial boundaries top, bottom, left, right = 0, m - 1, 0, n - 1 current_value = 1 while top <= bottom and left <= right: # Traverse from left to right on the top row for col in range(left, right + 1): matrix[top][col] = current_value current_value += 1 top += 1 # Traverse from top to bottom on the right column for row in range(top, bottom + 1): matrix[row][right] = current_value current_value += 1 right -= 1 if top <= bottom: # Traverse from right to left on the bottom row for col in range(right, left - 1, -1): matrix[bottom][col] = current_value current_value += 1 bottom -= 1 if left <= right: # Traverse from bottom to top on the left column for row in range(bottom, top - 1, -1): matrix[row][left] = current_value current_value += 1 left += 1 return matrix"},{"question":"# Question **Problem Statement**: You are provided with a basic implementation of a frequency counter for words in a string. However, the task for you is to extend this functionality to identify the k most frequent words from a text. **Objective**: 1. Write a function called `count_word_frequencies(text: str) -> dict` that takes a string `text` and returns a dictionary where keys are words and values are their respective frequencies. - Words are case-insensitive, and punctuation should be ignored. 2. Write a function called `k_most_frequent_words(text: str, k: int) -> list` that takes a string `text` and an integer `k`, and returns a list of the k most frequent words in the text. - If there are less than `k` unique words in the text, return all the words sorted by frequency and then alphabetically. **Constraints**: - You can assume `text` will be non-empty and will only contain alphabetic characters and punctuation marks (no digits or special characters other than punctuation). - You can assume `1 <= k <= len(unique words in text)`. **Input**: - A string `text` for both functions. - An integer `k` for the `k_most_frequent_words` function. **Output**: - A dictionary for the `count_word_frequencies` function. - A list of strings for the `k_most_frequent_words` function. **Examples**: 1. `count_word_frequencies(\\"Hello, hello! How are you? You are welcome.\\")` should return `{\'hello\': 2, \'how\': 1, \'are\': 2, \'you\': 2, \'welcome\': 1}`. 2. `k_most_frequent_words(\\"Hello, hello! How are you? You are welcome.\\", 3)` should return `[\'are\', \'hello\', \'you\']`. - Because \\"are\\", \\"hello\\", and \\"you\\" each appear 2 times. 3. `k_most_frequent_words(\\"To be or not to be, that is the question.\\", 2)` should return `[\'be\', \'to\']`. - Because \\"be\\" and \\"to\\" each appear 2 times, and should be sorted alphabetically for the result. This will test your abilities in string manipulation, dictionary operations, and frequency counting. Your solution should handle edge cases and ensure correct punctuation handling.","solution":"from collections import Counter import string def count_word_frequencies(text: str) -> dict: Returns a dictionary where keys are words and values are their respective frequencies. Words are case-insensitive, and punctuation is ignored. # Remove punctuation and make the text lowercase translator = str.maketrans(string.punctuation, \' \'*len(string.punctuation)) cleaned_text = text.translate(translator).lower() # Split the text into words and count frequencies words = cleaned_text.split() word_count = Counter(words) return dict(word_count) def k_most_frequent_words(text: str, k: int) -> list: Returns a list of the k most frequent words in the text. If there are less than k unique words, it returns all the words sorted by frequency and then alphabetically. # Get the word frequencies using the previous function word_count = count_word_frequencies(text) # Sort words first by frequency (desc) and then alphabetically (asc) sorted_words = sorted(word_count.items(), key=lambda x: (-x[1], x[0])) # Extract the top k words most_frequent_words = [word for word, count in sorted_words[:k]] return most_frequent_words"},{"question":"# Question You are given a case where you need to implement a function to flatten a deeply nested list of integers into a flat list. A nested list is a list that may contain integers or other nested lists, where the depth of nesting may vary. Implement the function `flatten_list(nested_list: list) -> list[int]` that flattens a nested list of integers into a single list of integers. # Function Signature ```python def flatten_list(nested_list: list) -> list[int]: ``` # Input * `nested_list`: A potentially deeply nested list of integers. # Output * Returns a list of integers that reflects all the integers from the nested list in a flattened structure. # Constraints 1. `nested_list` can contain integers and other nested lists of integers. 2. The resultant flattened list should preserve the order of appearance of integers. 3. The depth of the nested list is arbitrary and unknown beforehand. # Example ```python print(flatten_list([1, [2, [3, 4], 5], 6, [[7], 8], 9])) # Expected Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(flatten_list([1, [2, [3]], 4])) # Expected Output: [1, 2, 3, 4] print(flatten_list([[[[1]]], 2, [[3]], [4, [5]], 6])) # Expected Output: [1, 2, 3, 4, 5, 6] ``` # Notes * You may use recursion or iterative methods to solve the problem. * Ensure that your implementation can handle varying levels of nesting efficiently. * You can write additional helper functions to modularize your solution if needed.","solution":"def flatten_list(nested_list: list) -> list: Flattens a deeply nested list of integers into a flat list. Parameters: nested_list (list): A potentially deeply nested list of integers. Returns: list: A flattened list of integers. flattened_list = [] def flatten(nested): for element in nested: if isinstance(element, list): flatten(element) else: flattened_list.append(element) flatten(nested_list) return flattened_list"},{"question":"# Password Strength Checker Create a password strength checker that assesses the strength of a given password based on multiple criteria. Your implementation should include functions to validate different aspects of a password and a final function to bring all checks together and print informative error messages if the password is weak. Function Signatures: 1. `def has_min_length(password: str) -> bool` 2. `def has_uppercase(password: str) -> bool` 3. `def has_digit(password: str) -> bool` 4. `def has_special_char(password: str) -> bool` 5. `def password_strength_checker(password: str) -> bool` Description: - `has_min_length(password: str)`: This function accepts a string representing a password and returns True if the password is at least 8 characters long, otherwise returns False. - `has_uppercase(password: str)`: This function accepts a string representing a password and returns True if the password contains at least one uppercase letter, otherwise returns False. - `has_digit(password: str)`: This function accepts a string representing a password and returns True if the password contains at least one digit, otherwise returns False. - `has_special_char(password: str)`: This function accepts a string representing a password and returns True if the password contains at least one special character (defined as any character other than alphanumeric characters), otherwise returns False. - `password_strength_checker(password: str)`: This function accepts a string representing a password and: - Prints error messages for weak passwords based on the conditions above. - Returns True if the password is strong based on all criteria, otherwise returns False. Example: ```python >>> password_strength_checker(\'Aa1abcd\') Aa1abcd is a strong password. True >>> password_strength_checker(\'a1abcd\') a1abcd is a weak password because it does not contain an uppercase letter. False >>> password_strength_checker(\'Aabcdef\') Aabcdef is a weak password because it does not contain a digit. False >>> password_strength_checker(\'Aa1bcdef\') Aa1bcdef is a weak password because it does not contain a special character. False >>> password_strength_checker(\'Aa1abc\') Aa1abc is a weak password because it does not have a minimum length of 8 characters. False ```","solution":"def has_min_length(password: str) -> bool: return len(password) >= 8 def has_uppercase(password: str) -> bool: return any(char.isupper() for char in password) def has_digit(password: str) -> bool: return any(char.isdigit() for char in password) def has_special_char(password: str) -> bool: return any(not char.isalnum() for char in password) def password_strength_checker(password: str) -> bool: errors = [] if not has_min_length(password): errors.append(\\"does not have a minimum length of 8 characters\\") if not has_uppercase(password): errors.append(\\"does not contain an uppercase letter\\") if not has_digit(password): errors.append(\\"does not contain a digit\\") if not has_special_char(password): errors.append(\\"does not contain a special character\\") if errors: print(f\\"{password} is a weak password because it {\' and \'.join(errors)}.\\") return False else: print(f\\"{password} is a strong password.\\") return True"},{"question":"**Context**: In data processing, filtering specific information from a stream of data is a common task. Imagine you\'re given a stream of integers and you need to filter out the duplicates, maintaining the order of their first occurrence. **Task**: Write a function `unique_integers(stream)` that filters out duplicates from a stream of integers while preserving the order of their first occurrence. The function should: - Take a list of integers `stream` as input. - Return a new list of integers containing only the unique elements from `stream`, in the order they first appeared. **Constraints**: - The input list `stream` may contain up to `10^5` integers. - Each integer in `stream` is in the range `-10^9` to `10^9`. **Examples**: ```python >>> unique_integers([1, 2, 3, 2, 1, 4, 5]) [1, 2, 3, 4, 5] >>> unique_integers([7, 7, 7, 7, 7]) [7] >>> unique_integers([10, 20, 10, 30, 20]) [10, 20, 30] >>> unique_integers([5, -1, 4, -1, 5, 6]) [5, -1, 4, 6] ``` **Hint**: Consider using a set to keep track of seen elements and efficiently determine if an element is a duplicate.","solution":"def unique_integers(stream): Returns a list of unique integers in the order of their first occurrence. Parameters: stream (list): A list of integers. Returns: list: A list of unique integers from the input stream. seen = set() unique_list = [] for number in stream: if number not in seen: seen.add(number) unique_list.append(number) return unique_list"},{"question":"# Coding Assessment Question: **Problem Description:** You are given an integer array `nums` and an integer `k`. Your task is to find the number of subarrays whose sum is divisible by `k`. A subarray is a contiguous part of an array. For example, given `nums = [3, 1, 2, 4, 1]`, the subarray `[1, 2, 4]` is a valid subarray but `[1, 4]` is not as the elements are not contiguous. **Function Signature:** ```python def subarrays_divisible_by_k(nums: List[int], k: int) -> int: pass ``` **Input:** * A list of integers `nums` (1 ≤ len(nums) ≤ 30000, -10000 ≤ nums[i] ≤ 10000) * An integer `k` (1 ≤ k ≤ 1000) **Output:** * An integer which is the number of subarrays whose sum is divisible by `k`. **Example:** ``` Input: [4, 5, 0, -2, -3, 1], k = 5 Output: 7 Input: [5], k = 9 Output: 0 Input: [3, 1, 4, 1, 2], k = 3 Output: 4 ``` **Explanation:** In the first example: * The subarrays with sums divisible by 5 are: `[5]`, `[5, 0]`, `[4, 5, 0]`, `[0]`, `[5, 0, -2, -3, 1]`, `[0, -2, -3, 1]`, and `[-2, -3, 1]`. * There are 7 such subarrays, so the output is `7`. **Constraints:** * Ensure that the solution is efficient to handle the upper limits of the input size. Consider using the prefix sum technique with a hashmap to achieve optimal performance. Good luck!","solution":"from typing import List def subarrays_divisible_by_k(nums: List[int], k: int) -> int: Returns the number of subarrays whose sum is divisible by k. count = 0 prefix_sum = 0 prefix_count = {0: 1} # To handle cases where prefix_sum % k == 0 directly for num in nums: prefix_sum += num remainder = prefix_sum % k # Handle Python\'s negative remainder result if remainder < 0: remainder += k if remainder in prefix_count: count += prefix_count[remainder] prefix_count[remainder] += 1 else: prefix_count[remainder] = 1 return count"},{"question":"# Problem Statement: You are given a list of integers representing the heights of buildings along a street where each building is of unit width. Your goal is to compute the amount of rainwater that can be trapped between these buildings after a heavy downpour. Implement a function `trap_rainwater(heights: list) -> int` that calculates the total units of water that can be trapped. # Input: - A list of integers `heights` containing the heights of buildings. * The length of the list will be at least 1 and at most (10^5). * Each height is a non-negative integer less than (10^5). # Output: - An integer representing the total units of trapped rainwater. # Constraints: - Optimize the solution to work in linear time and use only constant extra space if possible. # Example: ```python assert trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 assert trap_rainwater([4, 2, 0, 3, 2, 5]) == 9 assert trap_rainwater([1, 1, 1, 1, 1]) == 0 ``` # Notes: * For each position, the water level is determined by the height of the tallest building to the left and the right minus the height of the current building. * Consider using two pointers or a precomputed array of left and right maximum heights for this problem.","solution":"def trap_rainwater(heights): Calculates the total units of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the rainwater trapped total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water"},{"question":"# API Rate Limiting Handler Suppose you are building a client for a third-party API service. The API enforces rate limiting with the following rules: - You can make up to 5 requests per minute. - If the limit is exceeded, you must wait for 60 seconds before making further requests. Your task is to write a function that handles this rate limiting while making API requests. The function should: 1. Accept a URL (str) and a payload (dict) as input. 2. Make a POST request to the API with the given payload. 3. Handle rate limiting by keeping track of the request count and resetting it every minute. 4. Retry the request after 60 seconds if the limit is reached. Use the `time` library to manage delays and `requests` library for making HTTP requests. The function signature should be: ```python def api_request_with_rate_limiting(url: str, payload: dict) -> dict: Makes a POST request to the given URL with the payload, respecting the API rate limiting rules. ``` Input: The function takes the following inputs: - url (str): The URL of the API endpoint. - payload (dict): The payload to be sent in the POST request. Output: The function returns: - response (dict): The JSON response from the API as a dictionary. Constraints: - Your code should gracefully handle potential exceptions. - Ensure the rate limiting rules are strictly adhered to. - Use of global variables is allowed to keep track of the request count and time. Example: Given the setup of rate limited API services, an example usage could be: ```python url = \\"https://api.example.com/data\\" payload = {\\"key\\": \\"value\\"} response = api_request_with_rate_limiting(url, payload) print(response) ``` A pseudo-code outline to get you started: ```python import time import requests import json # Global variables to keep track of request count and reset time request_count = 0 reset_time = time.time() def api_request_with_rate_limiting(url: str, payload: dict) -> dict: global request_count, reset_time current_time = time.time() # Check if the limit needs to be reset if current_time - reset_time >= 60: request_count = 0 reset_time = current_time # If limit is reached, wait if request_count >= 5: time.sleep(60 - (current_time - reset_time)) request_count = 0 reset_time = time.time() # Make the POST request try: response = requests.post(url, json=payload, timeout=10) response.raise_for_status() request_count += 1 return response.json() except requests.RequestException as e: # Return error message if request fails return {\\"error\\": str(e)} # Example usage url = \\"https://api.example.com/data\\" payload = {\\"key\\": \\"value\\"} response = api_request_with_rate_limiting(url, payload) print(response) ``` Ensure you thoroughly test the function for different conditions, such as: - Making multiple requests within the rate limit. - Exceeding the rate limit and waiting. - Handling network errors and API errors.","solution":"import time import requests # Global variables to keep track of request count and reset time request_count = 0 reset_time = time.time() def api_request_with_rate_limiting(url: str, payload: dict) -> dict: global request_count, reset_time current_time = time.time() # Check if the limit needs to be reset if current_time - reset_time >= 60: request_count = 0 reset_time = current_time # If limit is reached, wait if request_count >= 5: time_to_wait = 60 - (current_time - reset_time) time.sleep(max(0, time_to_wait)) request_count = 0 reset_time = time.time() # Make the POST request try: response = requests.post(url, json=payload, timeout=10) response.raise_for_status() request_count += 1 return response.json() except requests.RequestException as e: # Return error message if request fails return {\\"error\\": str(e)}"},{"question":"# Question: Valid IP Address Types You are tasked with implementing a function that classifies an IP address as one of the following types: \'IPv4\', \'IPv6\', or \'Neither\'. An IPv4 address is classified by the format `a.b.c.d`, where `a`, `b`, `c`, and `d` are integers between 0 and 255 (inclusive). An IPv6 address is classified by the format `x:x:x:x:x:x:x:x`, where each `x` is a hexadecimal number up to four digits long, and hexadecimal numbers can include digits (0-9) and letters (a-f or A-F). Function Specifications: 1. **Function Name**: `classify_ip_address` 2. **Functionality**: Based on the input string, classify the IP address as \'IPv4\', \'IPv6\', or \'Neither\'. 3. **Input**: - `ip_address` (str): The IP address to be classified, which could be either an IPv4 or IPv6 address. 4. **Output**: Returns the type of the IP address (\'IPv4\', \'IPv6\', or \'Neither\'). Example: ```python # IPv4 address print(classify_ip_address(\\"192.168.1.1\\")) # Output: \\"IPv4\\" # IPv6 address print(classify_ip_address(\\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\")) # Output: \\"IPv6\\" # Neither type print(classify_ip_address(\\"256.256.256.256\\")) # Output: \\"Neither\\" ``` Detailed Requirements: - **IPv4**: Ensure that exactly four decimal numbers are present, separated by dots (`.`), and each number is between 0 and 255 (inclusive). - **IPv6**: Ensure that exactly eight groups of hexadecimal numbers are present, separated by colons (`:`), and each group is between 1 and 4 hexadecimal digits. - For each type, guarantee the function checks edge cases and formats strictly. - Write adequate tests to validate your implementation, including edge and erroneous cases. Hint: Utilize appropriate parsing libraries or functions as needed to simplify validation.","solution":"def classify_ip_address(ip_address): def is_valid_ipv4(s): parts = s.split(\\".\\") if len(parts) != 4: return False for part in parts: if not part.isdigit() or not 0 <= int(part) <= 255 or (part[0] == \'0\' and len(part) > 1): return False return True def is_valid_ipv6(s): parts = s.split(\\":\\") if len(parts) != 8: return False valid_chars = \\"0123456789abcdefABCDEF\\" for part in parts: if not 1 <= len(part) <= 4 or not all(c in valid_chars for c in part): return False return True if is_valid_ipv4(ip_address): return \\"IPv4\\" elif is_valid_ipv6(ip_address): return \\"IPv6\\" else: return \\"Neither\\" # Example usages: # print(classify_ip_address(\\"192.168.1.1\\")) # Output: \\"IPv4\\" # print(classify_ip_address(\\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\\")) # Output: \\"IPv6\\" # print(classify_ip_address(\\"256.256.256.256\\")) # Output: \\"Neither\\""},{"question":"**Objective**: To test your understanding of data manipulation, particularly array operations, and assessing computational efficiency through basic algorithm implementation. **Array Operations Challenge**: Implement a class `ArrayManipulator` that provides functions to manage and manipulate an array of integers. The class should be able to perform the following operations: 1. **rotate_array**: Write a method `rotate_array` which takes in two parameters: `arr` (a list of integers) and `n` (an integer). This method should rotate the array `n` positions to the right. If `n` is not provided or is zero, the array should remain unchanged. Return the rotated array. Handle negative values of `n` by rotating the array to the left. 2. **find_max_subarray_sum**: Write a method `find_max_subarray_sum` which accepts `arr` (a list of integers). This method should return the maximum sum of a contiguous subarray using the Kadane\'s algorithm. 3. **merge_two_sorted_arrays**: Write a method `merge_two_sorted_arrays` which takes in two parameters `arr1` and `arr2` (both lists of integers sorted in non-decreasing order). The method should merge these two sorted arrays into a single sorted array and return the result. 4. **find_missing_element**: Write a method `find_missing_element` which accepts two parameters `arr1` and `arr2` (both lists of integers where array `arr2` is `arr1` with one element removed and possibly shuffled). Return the missing element from `arr2`. # Example ```python # Example usage manipulator = ArrayManipulator() print(manipulator.rotate_array([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(manipulator.find_max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 print(manipulator.merge_two_sorted_arrays([1, 3, 5], [2, 4, 6])) # Output: [1, 2, 3, 4, 5, 6] print(manipulator.find_missing_element([4, 3, 6, 7], [7, 6, 3])) # Output: 4 ``` # Constraints: - Length of `arr` in `rotate_array` and `find_max_subarray_sum` should not exceed 10^6 elements. - Length of `arr1` and `arr2` in `merge_two_sorted_arrays` and `find_missing_element` should not exceed 10^6 elements combined. - Array elements are integers and can be positive or negative in `rotate_array` and `find_max_subarray_sum`. - The missing element in `find_missing_element` will always be present in `arr1`. # Specifications - Ensure your methods handle edge cases such as empty arrays or very large arrays. - Optimize for both time and space complexity where applicable. - Develop a simple `__main__` method to demonstrate the usage of your class and its methods.","solution":"class ArrayManipulator: def rotate_array(self, arr, n=0): if not arr: return arr n = n % len(arr) return arr[-n:] + arr[:-n] def find_max_subarray_sum(self, arr): if not arr: return 0 max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def merge_two_sorted_arrays(self, arr1, arr2): merged = [] i = j = 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 merged.extend(arr1[i:]) merged.extend(arr2[j:]) return merged def find_missing_element(self, arr1, arr2): return sum(arr1) - sum(arr2)"},{"question":"# Coding Assessment Question: Longest Consecutive Subsequence Length **Scenario**: You are working on optimizing algorithms and want to measure the performance of various approaches to sequence analysis. One of the common problems in this context is finding the length of the longest consecutive subsequence in a list of integers. **Objective**: Write a function called `longest_consecutive_subsequence_length` that accepts a 1-dimensional list of integers and returns the length of the longest consecutive elements sequence. **Function Signature**: ```python def longest_consecutive_subsequence_length(nums: List[int]) -> int: pass ``` **Input**: - `nums` (List[int]): A list of integers. **Output**: - `int`: The length of the longest consecutive elements subsequence. **Constraints**: - The input list can contain between 0 and (10^6) elements. - List elements can range between (-10^6) and (10^6). **Performance Requirements**: - The implementation should be efficient with a time complexity better than O(n log n). **Example**: ```python nums = [100, 4, 200, 1, 3, 2] print(longest_consecutive_subsequence_length(nums)) # Expected output: 4 # The longest consecutive subsequence is [1, 2, 3, 4] nums = [1, 2, 0, 1] print(longest_consecutive_subsequence_length(nums)) # Expected output: 3 # The longest consecutive subsequence is [0, 1, 2] nums = [] print(longest_consecutive_subsequence_length(nums)) # Expected output: 0 # There is no subsequence in an empty list ``` **Additional Notes**: - You might find it useful to use a set to quickly determine the existence of elements. - Consider edge cases such as lists with duplicate elements or a single element.","solution":"from typing import List def longest_consecutive_subsequence_length(nums: List[int]) -> int: if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: if num - 1 not in nums_set: # Only consider starting point of a sequence current_num = num current_streak = 1 while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Scheduling Timed Events You are going to implement a scheduler that tracks a list of events and determines if any two events overlap or not. Rules: 1. Each event is represented as a tuple `(start, end)` where `start` and `end` are integers denoting the start and end time of the event. 2. An event `(s1, e1)` overlaps with another event `(s2, e2)` if `s1 < e2` and `s2 < e1`. Your task is to implement a function `events_overlap(events: List[Tuple[int, int]]) -> bool` that checks if any two events in the list overlap. # Input: - `events`: A list of tuples where each tuple represents an event with start and end time. # Output: - The function should return a boolean value `True` if any two events overlap, otherwise `False`. Constraints: * The input list will have at most 10^4 events. * Each event\'s start and end time will be integers between 0 and 10^9 inclusively. * An event\'s start time is always less than its end time. # Example: ```python events = [ (1, 5), (6, 10), (11, 15) ] print(events_overlap(events)) ``` Output: ```python False ``` # Example: ```python events = [ (1, 5), (4, 10), (11, 15) ] print(events_overlap(events)) ``` Output: ```python True ``` # Note: - Pay attention to the possibility of many events and the need to check each pair efficiently. - Consider sorting events by start time to simplify overlap checking. Implement your solution in a function called `events_overlap`.","solution":"def events_overlap(events): Determines if any two events in the list overlap. Args: events (list of tuple(int, int)): A list of events represented as (start, end). Returns: bool: True if any two events overlap, False otherwise. # Sort events by their start time events.sort(key=lambda x: x[0]) for i in range(1, len(events)): # An event overlaps with the previous one if its start time is less than the end time of the previous one if events[i][0] < events[i-1][1]: return True return False"},{"question":"# Question You are developing a simple game that involves moving a character around a grid. The grid is represented by a 2D list where each element is either an empty space (\'.\') or an obstacle (\'#\'). The character starts at the top-left corner of the grid (position (0, 0)) and can move up, down, left, or right, but cannot move into obstacles or out of the grid boundaries. # Task Write a Python function `move_character(grid, moves)` that accepts two parameters: - `grid`: a 2D list representing the game grid. - `moves`: a string containing a sequence of moves where \'U\' stands for up, \'D\' for down, \'L\' for left, and \'R\' for right. The function should return the final position of the character as a tuple `(row, col)` after performing all the moves. Requirements: - The character cannot move into a cell with an obstacle (\'#\'). - If a move would take the character outside the grid\'s boundaries, it should be ignored. - The function should process the moves in order and update the character’s position accordingly. Input: - A 2D list `grid` with dimensions `m x n` (`1 <= m, n <= 100`) containing \'.\' and \'#\'. - A string `moves` with length `1 <= len(moves) <= 1000` containing only the characters \'U\', \'D\', \'L\', \'R\'. Output: - A tuple `(row, col)` representing the final position of the character. Example: ```python grid = [ [\'.\', \'.\', \'.\', \'.\'], [\'.\', \'#\', \'.\', \'.\'], [\'.\', \'.\', \'.\', \'.\'], [\'.\', \'.\', \'#\', \'.\'] ] moves = \\"DDRRU\\" print(move_character(grid, moves)) # Output: (1, 2) ``` # Constraints: - Assume that the grid and moves will always be valid according to the given specifications. - The initial position (0, 0) is always an empty space (\'.\'). - The function must handle both the grid boundaries and obstacle constraints correctly. # Solution ```python def move_character(grid, moves): # Starting position row, col = 0, 0 rows, cols = len(grid), len(grid[0]) move_dict = { \'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1) } for move in moves: new_row = row + move_dict[move][0] new_col = col + move_dict[move][1] # Check if new position is within grid bounds and not an obstacle if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][0] != \'#\': row, col = new_row, new_col return (row, col) ```","solution":"def move_character(grid, moves): # Starting position row, col = 0, 0 rows, cols = len(grid), len(grid[0]) move_dict = { \'U\': (-1, 0), \'D\': (1, 0), \'L\': (0, -1), \'R\': (0, 1) } for move in moves: new_row = row + move_dict[move][0] new_col = col + move_dict[move][1] # Check if new position is within grid bounds and not an obstacle if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] != \'#\': row, col = new_row, new_col return (row, col)"},{"question":"# Coding Task: Implement Dijkstra\'s Algorithm with Edge Weights Background You are provided with an implementation of Dijkstra\'s algorithm for finding the shortest path in a graph with edge weights. Your task is to modify this function to handle graphs where weights can be zero or positive, ensuring that it accurately finds the shortest path from a start node to all other nodes in the graph. Function Signature ```python def dijkstra_with_weights(graph, start): Implementation of Dijkstra\'s algorithm with edge weights handling. graph : Dictionary where keys are node identifiers, and values are lists of tuples representing connected nodes and the respective edge weights. start : Node identifier representing the starting node. Returns a dictionary where each key is a node and its value is the least cost to reach that node from the start node. >>> g = { >>> \'A\': [(\'B\', 1), (\'C\', 4)], >>> \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], >>> \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], >>> \'D\': [(\'B\', 5), (\'C\', 1)] >>> } >>> dijkstra_with_weights(g, \'A\') {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} # Example output showing the least cost path from \'A\' to all other nodes ``` Input 1. **graph**: A dictionary representing the graph where keys are node identifiers, and values are lists of tuples. Each tuple indicates a connected node and the weight of the edge between them. 2. **start**: A node identifier representing the starting node. Output * Returns a dictionary where each key is a node and its value is the least cost to reach that node from the start node. Constraints * The graph is guaranteed to be connected and contains between 1 to 1000 nodes. * Edge weights are non-negative integers and can be zero. * The graph does not contain negative weight cycles. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], \'D\': [(\'B\', 5), (\'C\', 1)] } start = \'A\' print(dijkstra_with_weights(graph, start)) # Output = {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} # The dictionary shows the minimum cost to reach each node from the start node \'A\' ```","solution":"import heapq def dijkstra_with_weights(graph, start): Implementation of Dijkstra\'s algorithm with edge weights handling. graph : Dictionary where keys are node identifiers, and values are lists of tuples representing connected nodes and the respective edge weights. start : Node identifier representing the starting node. Returns a dictionary where each key is a node and its value is the least cost to reach that node from the start node. >>> g = { >>> \'A\': [(\'B\', 1), (\'C\', 4)], >>> \'B\': [(\'A\', 1), (\'C\', 2), (\'D\', 5)], >>> \'C\': [(\'A\', 4), (\'B\', 2), (\'D\', 1)], >>> \'D\': [(\'B\', 5), (\'C\', 1)] >>> } >>> dijkstra_with_weights(g, \'A\') {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} # Example output showing the least cost path from \'A\' to all other nodes # Initialize distances from start to all nodes as infinity, except start node itself which is zero distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue to store the nodes to explore; initialized with the start node priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # If the popped node distance is greater than the recorded distance, skip it if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # If the newly calculated distance is less than the recorded one, update and push to queue if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Challenge: Counting Common Elements in Two Lists In this challenge, you need to write a function that counts the number of common elements between two lists of integers. # Function Specification: ```python def count_common_elements(list1: List[int], list2: List[int]) -> int: Count the number of common elements between two lists. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: int: The count of common elements in both lists. ``` # Constraints 1. Both `list1` and `list2` will contain integers. They can be empty. 2. Elements in `list1` and `list2` may be positive, negative, or zero. 3. Each list does not necessarily contain unique elements; duplicates are possible. # Input * `list1`: A list of integers. * `list2`: A list of integers. # Output * Return an integer representing the number of common elements between `list1` and `list2`. # Example ```python >>> count_common_elements([1, 2, 3, 4], [3, 4, 5, 6]) 2 >>> count_common_elements([10, 20, 30], [40, 50, 60]) 0 >>> count_common_elements([1, 1, 2, 2], [2, 2, 3, 3]) 1 >>> count_common_elements([], [1, 2]) 0 >>> count_common_elements([1, 2, 3], []) 0 ``` # Additional Considerations Consider edge cases such as: * What happens if one or both lists are empty? * How to handle lists with duplicate numbers. * Ensuring the function is efficient for large lists.","solution":"from typing import List def count_common_elements(list1: List[int], list2: List[int]) -> int: Count the number of common elements between two lists. Args: list1 (List[int]): The first list of integers. list2 (List[int]): The second list of integers. Returns: int: The count of common elements in both lists. # Convert lists to sets to find unique elements set1 = set(list1) set2 = set(list2) # Find the intersection of the two sets common_elements = set1 & set2 # Return the number of common elements return len(common_elements)"},{"question":"# Game Score Tracker Using Binary Search Trees You are working on developing a game that involves tracking player scores in real-time. To efficiently manage and query scores, you decide to use a Binary Search Tree (BST). Your task is to implement the following functions to support the scoring system: 1. **Add Score**: Insert a player’s score into the BST. 2. **Remove Score**: Remove a player’s score from the BST. 3. **Find Rank**: Given a score, find the rank of that score in the BST (i.e., how many scores are less than or equal to that score). 4. **Find K-th Highest Score**: Fetch the k-th highest score from the BST. # Requirements BST Structure: Define a BST node with the following attributes: - `score`: an integer representing the player’s score. - `left`: a reference to the left child node. - `right`: a reference to the right child node. - `size`: the size of the subtree rooted at this node (including the node itself). Functions: 1. **`insert(score: int) -> None`**: Insert a player’s score into the BST. 2. **`remove(score: int) -> bool`**: Remove a player’s score from the BST. Return `True` if the score was successfully removed, otherwise return `False`. 3. **`get_rank(score: int) -> int`**: Return the rank of the given score. 4. **`find_kth_highest(k: int) -> int`**: Return the k-th highest score in the BST. # Constraints 1. Scores are unique positive integers. 2. The number of scores will not exceed 10^5. 3. For find functions, valid inputs are assumed. # Example ```python bst = ScoreTree() bst.insert(50) bst.insert(30) bst.insert(70) bst.insert(20) bst.insert(40) bst.insert(60) bst.insert(80) bst.get_rank(50) # Output: 4 (There are 3 scores less than or equal to 50) bst.find_kth_highest(3) # Output: 60 (Third highest score) bst.remove(70) # Output: True bst.get_rank(60) # Output: 2 (After removing 70, there are 1 score less than 60) bst.remove(100) # Output: False (100 does not exist in the tree) ``` # Implementation Guide 1. **Inserting a Node**: - Traverse the tree to find the correct spot and insert the new node. - Update the size attribute of nodes along the path back to the root. 2. **Removing a Node**: - Locate the node to be removed. - Adjust pointers to bypass the node and update sizes accordingly. 3. **Finding Rank**: - Use the size attributes to count nodes in subtrees to determine rank efficiently. 4. **K-th Highest Score**: - Traverse the tree using sizes to locate the k-th highest score. Your implementation should maintain balance and efficiency of the binary search tree to ensure all operations are optimized for performance. Happy coding!","solution":"class TreeNode: def __init__(self, score): self.score = score self.left = None self.right = None self.size = 1 class ScoreTree: def __init__(self): self.root = None def _insert(self, node, score): if not node: return TreeNode(score) if score < node.score: node.left = self._insert(node.left, score) else: node.right = self._insert(node.right, score) node.size = 1 + (node.left.size if node.left else 0) + (node.right.size if node.right else 0) return node def insert(self, score): self.root = self._insert(self.root, score) def _find_min(self, node): while node.left: node = node.left return node def _remove(self, node, score): if not node: return node, False if score < node.score: node.left, removed = self._remove(node.left, score) elif score > node.score: node.right, removed = self._remove(node.right, score) else: removed = True if not node.left: return node.right, removed if not node.right: return node.left, removed min_larger_node = self._find_min(node.right) node.score = min_larger_node.score node.right, _ = self._remove(node.right, min_larger_node.score) if node: node.size = 1 + (node.left.size if node.left else 0) + (node.right.size if node.right else 0) return node, removed def remove(self, score): self.root, removed = self._remove(self.root, score) return removed def _get_rank(self, node, score): if not node: return 0 elif score < node.score: return self._get_rank(node.left, score) elif score > node.score: left_size = node.left.size if node.left else 0 return 1 + left_size + self._get_rank(node.right, score) else: left_size = node.left.size if node.left else 0 return 1 + left_size def get_rank(self, score): return self._get_rank(self.root, score) def _find_kth_highest(self, node, k): if not node: return None # Number of nodes in the right subtree + the node itself right_size = node.right.size if node.right else 0 if right_size + 1 == k: return node.score elif right_size >= k: return self._find_kth_highest(node.right, k) else: return self._find_kth_highest(node.left, k - right_size - 1) def find_kth_highest(self, k): return self._find_kth_highest(self.root, k)"},{"question":"**Context**: In a coding competition, participants have to solve a variety of problems within a limited amount of time. One common task is to process strings efficiently. **Task**: Write a function `longest_balanced_substring(s)` that finds the length of the longest balanced substring in the given string `s`. A balanced substring has an equal number of opening and closing parentheses. The function should: - Take a string `s` as input, where `1 <= len(s) <= 10^5`. - Return an integer representing the length of the longest balanced substring. **Constraints**: - The input string `s` consists only of the characters \'(\' and \')\'. - The function should have efficient time and space complexity to handle the upper bounds. **Examples**: ```python >>> longest_balanced_substring(\\"(()\\") 2 >>> longest_balanced_substring(\\")()())\\") 4 >>> longest_balanced_substring(\\"()()\\") 4 >>> longest_balanced_substring(\\"()(()))\\") 6 ``` **Hint**: Consider using a stack to keep track of indices of unmatched parentheses, and another approach can be to use dynamic programming. You may assume the input to the function is always such that `1 <= len(s) <= 10^5`.","solution":"def longest_balanced_substring(s): Finds the length of the longest balanced substring in the given string s. A balanced substring has an equal number of opening and closing parentheses. max_len = 0 stack = [-1] # Initial index to handle base case for i, char in enumerate(s): if char == \'(\': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_len = max(max_len, i - stack[-1]) return max_len"},{"question":"# Question: Implement a Parallelized K-Means Clustering Algorithm You are tasked with writing a function to implement a parallelized version of the K-Means Clustering algorithm. This exercise will test your understanding of clustering algorithms, parallel computing, and optimization techniques for performance improvement. Your function should leverage multi-threading or multi-processing to distribute the workload across multiple CPU cores. # Function Signature: ```python def parallelized_k_means(data: np.ndarray, k: int, max_iterations: int, tolerance: float) -> tuple[np.ndarray, np.ndarray]: pass ``` # Input: 1. `data` (np.ndarray): An array of shape (n_samples, n_features) representing the dataset. 2. `k` (int): The number of clusters to form. 3. `max_iterations` (int): The maximum number of iterations the algorithm should run. 4. `tolerance` (float): The threshold for convergence. If the change in centroids is smaller than this value, the algorithm terminates. # Output: 1. `centroids` (np.ndarray): An array of shape (k, n_features) representing the final cluster centroids. 2. `labels` (np.ndarray): An array of shape (n_samples,) where each element is the index of the nearest centroid for the corresponding sample in the dataset. # Constraints: 1. `k` should be a positive integer less than the number of samples in the dataset. 2. `max_iterations` should be a positive integer. 3. `tolerance` should be a non-negative float. # Example Usage: ```python import numpy as np data = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0]]) centroids, labels = parallelized_k_means(data, k=2, max_iterations=100, tolerance=0.01) print(\\"Centroids:\\", centroids) print(\\"Labels:\\", labels) ``` # Performance Requirements: 1. The function should efficiently utilize available CPU cores to speed up the computation. 2. Ensure the implementation scales well with larger datasets. # Notes: * Use of libraries such as NumPy and threading or multiprocessing in Python is encouraged. * Carefully handle edge cases such as empty clusters. * Ensure the algorithm can handle datasets with a large number of features and samples. # Task: * Implement the parallelized K-Means Clustering algorithm. * Use appropriate techniques to parallelize the centroid assignment and update steps. * Perform necessary checks and exception handling to ensure robustness. * Test the function on various datasets to verify its correctness and performance improvements.","solution":"import numpy as np import threading from multiprocessing import Pool def initialize_centroids(data, k): indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def assign_clusters(data, centroids): distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) return np.argmin(distances, axis=1) def update_centroids(data, labels, k): new_centroids = np.array([data[labels == i].mean(axis=0) for i in range(k)]) return new_centroids def parallelized_k_means(data: np.ndarray, k: int, max_iterations: int, tolerance: float) -> tuple[np.ndarray, np.ndarray]: centroids = initialize_centroids(data, k) labels = np.zeros(data.shape[0]) for _ in range(max_iterations): labels = assign_clusters(data, centroids) new_centroids = update_centroids(data, labels, k) if np.all(np.linalg.norm(new_centroids - centroids, axis=1) < tolerance): break centroids = new_centroids return centroids, labels"},{"question":"# Problem Statement Create a function `add_large_numbers` that takes two non-negative integers represented as strings and returns their sum, also as a string. This function should handle very large integers that might not fit into standard numerical data types. Function Signature ```python def add_large_numbers(num1: str, num2: str) -> str: ``` # Input * `num1`: A string representing a non-negative integer. The length of `num1` will be between 1 and 10,000 digits. * `num2`: A string representing another non-negative integer. The length of `num2` will be between 1 and 10,000 digits. # Output * Returns a string representing the sum of the two integers. # Constraints * The input strings will not have leading zeros unless the string represents the number zero itself. * The function must handle inputs efficiently, even for the upper limit of the input size. # Performance Requirements * The function should operate in O(n) time complexity where n is the maximum length of the input strings. # Examples ```python assert add_large_numbers(\'12345678901234567890\', \'98765432109876543210\') == \'111111111011111111100\' assert add_large_numbers(\'999999999999999999999999999999\', \'1\') == \'1000000000000000000000000000000\' assert add_large_numbers(\'0\', \'0\') == \'0\' assert add_large_numbers(\'123\', \'456\') == \'579\' ``` # Description The examples provided illustrate typical uses where the numbers are given as strings, and these numbers might be very large such that conventional integer data types cannot accommodate them. This function should correctly compute the sum as another string, accurately handling the addition of very large integers. # Edge Cases * Both input numbers being the string \\"0\\". * One number being significantly longer than the other. * Large inputs with up to 10,000 digits.","solution":"def add_large_numbers(num1: str, num2: str) -> str: Returns the sum of two non-negative integers represented as strings. The function ensures to handle very large integers that might not fit into standard numerical data types. # Initialize pointers for both strings starting from the end i, j = len(num1) - 1, len(num2) - 1 carry = 0 result = [] # Iterate while there are digits left in either number or there\'s a carry while i >= 0 or j >= 0 or carry: digit1 = int(num1[i]) if i >= 0 else 0 digit2 = int(num2[j]) if j >= 0 else 0 # Sum the digits along with the carry total = digit1 + digit2 + carry carry = total // 10 # Update carry for next iteration result.append(total % 10) # Store the single digit result # Move to the next digits i -= 1 j -= 1 # Convert the result list to a string and reverse it since we added digits in reverse order return \'\'.join(map(str, result[::-1]))"},{"question":"# Number Doubling in an Array Background You are developing a feature for an educational app that doubles every number in a given array. The task involves processing a list of integers, doubling each value, and returning the resulting list. Task Write a function `double_numbers` that accepts an array of integers as input and returns a new array where each element is twice the value of the corresponding element in the input array. Function Signature ```python def double_numbers(arr: list) -> list: pass ``` Input * `arr` (list of integers): The array of integers to be processed. The length of `arr` will be between 1 and 10^5 and each integer will be in the range of -10^9 to 10^9. Output * Return a new list with each integer in the input list doubled. Constraints * The function should handle a large range of input sizes efficiently. * Negative numbers should be doubled accordingly. Example ```python >>> double_numbers([1, 2, 3, 4]) [2, 4, 6, 8] >>> double_numbers([-1, -2, -3, -4]) [-2, -4, -6, -8] >>> double_numbers([0, 1000000000, -999999999]) [0, 2000000000, -1999999998] ``` Implement the function and test it with various edge cases such as very large arrays and a mix of positive, negative, and zero values.","solution":"def double_numbers(arr: list) -> list: Returns a new list with each integer in the input list doubled. return [x * 2 for x in arr]"},{"question":"# Sum of Squares of Unique Numbers # Problem Statement You are required to implement a function `sum_of_squares` to calculate the sum of the squares of unique numbers from a given list of integers. The function should eliminate any duplicate values before performing the sum of squares calculation. # Function Signature ```python def sum_of_squares(numbers: list) -> int: pass ``` # Input * A single list `numbers` containing integers, where each integer can be between `-10^3` and `10^3` inclusive. # Output * Return an integer representing the sum of the squares of the unique numbers from the input list. * If the list is empty, return `0`. # Constraints * The function should handle a list containing any number of elements, including zero elements. * Input should be validated and appropriate exceptions should be raised for invalid inputs (`ValueError` for non-list inputs or list elements that are not integers). # Examples ```python >>> sum_of_squares([1, 2, 2, 3]) 14 >>> sum_of_squares([-1, -2, -2, 3, 0, 3]) 14 >>> sum_of_squares([4, 4, 4]) 16 >>> sum_of_squares([]) 0 >>> sum_of_squares([5, -5, 5, -5]) 50 >>> sum_of_squares(\'Numbers\') Traceback (most recent call last): ... ValueError: Input must be a list of integers >>> sum_of_squares([1, 2, \'three\']) Traceback (most recent call last): ... ValueError: List elements must be integers ``` # Explanation Consider the list of numbers: * `[1, 2, 2, 3]` after removing duplicates becomes `[1, 2, 3]` -> sum of squares is `1^2 + 2^2 + 3^2 = 14` * `[-1, -2, -2, 3, 0, 3]` after removing duplicates becomes `[-1, -2, 3, 0]` -> sum of squares is `(-1)^2 + (-2)^2 + 3^2 + 0^2 = 14` * `[4, 4, 4]` after removing duplicates becomes `[4]` -> sum of squares is `4^2 = 16` * `[]` results in `0` since the list is empty # Implementation Notes * Validate input to check if it is a list and if all elements are integers. Raise `ValueError` for invalid inputs. * Use a set to remove duplicate elements from the list. * Calculate and return the sum of the squares of the unique numbers.","solution":"def sum_of_squares(numbers: list) -> int: Returns the sum of the squares of unique numbers from a given list of integers. if not isinstance(numbers, list): raise ValueError(\\"Input must be a list of integers\\") seen = set() for num in numbers: if not isinstance(num, int): raise ValueError(\\"List elements must be integers\\") seen.add(num) return sum(num ** 2 for num in seen)"},{"question":"# Objective Develop a function that recursively calculates the power of a number using exponentiation by squaring. # Background The operation of raising a base `x` to the power `n` can be optimized using a method known as exponentiation by squaring. The algorithm works as follows: - If `n` is 0, then ( x^n = 1 ) - If `n` is negative, convert the problem to ( frac{1}{x^{-n}} ) - If `n` is positive: - If `n` is even, ( x^n = (x^{n/2})^2 ) - If `n` is odd, ( x^n = x cdot x^{n-1} ) # Function Signature ```python def power(x: float, n: int) -> float: pass ``` # Input - `x` (float): The base number. - `n` (int): The exponent to which the base is raised. # Output - A float representing the value of `x` raised to the power `n`. # Constraints - If `n` is negative, handle it appropriately. - If `x` is 0 and `n` is 0, raise a `ValueError` with the message \\"`0^0 is undefined`\\". - Ensure that the function handles large values of `n` efficiently. # Example ```python >>> power(2, 10) 1024.0 >>> power(5, -2) 0.04 >>> power(2, 0) 1.0 ``` # Note - Use recursion and avoid using built-in power functions or operators. - Focus on efficient handling of the exponentiation by leveraging the properties of exponents. # Testing Test your function with multiple edge cases and typical inputs to ensure accuracy and performance.","solution":"def power(x: float, n: int) -> float: Recursively calculates the power of x raised to n using exponentiation by squaring. if x == 0 and n == 0: raise ValueError(\\"0^0 is undefined\\") if n == 0: return 1 if n < 0: return 1 / power(x, -n) if n % 2 == 0: half_power = power(x, n // 2) return half_power * half_power else: return x * power(x, n - 1)"},{"question":"# Problem Statement You are tasked with developing a function for a weather application that analyzes temperature data over a specified period. Given a list of daily temperatures, your goal is to determine the first day on which the temperature will be warmer after today. Your function should return a list where, for each day in the input list, the value is the number of days until a warmer temperature is reached. If there is no future day that is warmer, the value should be 0. # Function Signature ```python def daily_temperatures(temperatures: List[int]) -> List[int]: pass ``` # Input * A list of integers `temperatures` where `1 <= len(temperatures) <= 10^5` and each `0 <= temperatures[i] <= 100`. # Output * A list of integers where each element is the number of days until a warmer temperature for that day. If no such day exists for a day, return 0 for that day. # Constraints * The function should handle large inputs efficiently, preferably with a time complexity of O(n). # Examples ```python >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([60, 50, 40, 30]) [0, 0, 0, 0] ``` # Notes 1. The function can be designed using a stack to keep track of the indices of the temperatures and to calculate the next warmer day in an efficient manner. 2. Aim for a linear time complexity solution that efficiently scans through the list.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Returns a list where each element represents the number of days until a warmer temperature. If there is no future warmer day, the value is 0 for that day. n = len(temperatures) answer = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: j = stack.pop() answer[j] = i - j stack.append(i) return answer"},{"question":"# Coding Assessment Question Background In many practical scenarios, efficient string manipulation is crucial, particularly when dealing with constraints on memory and processing time. One common problem is to modify a string following specific rules without using extra space and while preserving the order of characters as much as possible. Problem Statement You are required to implement a function that reverses the words in a given string `s` without using any additional space for another data structure. The words are defined as sequences of non-space characters separated by spaces. The reversed string should also have the words separated by a single space, and there should be no leading or trailing spaces. The function should be named `reverse_words_in_place(s: str) -> str`. Input * A string `s` with length `1 ≤ len(s) ≤ 1000`. Output * The modified string with words reversed. Constraints * Do not use extra space for another string or data structure (i.e., perform all operations in place). * The words must retain their original order, but the characters within each word should be reversed. * The output should not contain any leading or trailing spaces. Example ```python >>> reverse_words_in_place(\\"the sky is blue\\") \\"eht yks si eulb\\" >>> reverse_words_in_place(\\" hello world \\") \\"olleh dlrow\\" >>> reverse_words_in_place(\\"a good example\\") \\"a doog elpmaxe\\" ``` Hints * Consider how you can manipulate the string in place. * You can start by reversing the entire string, and then reverse the characters of each word individually.","solution":"def reverse_words_in_place(s: str) -> str: Reverses the characters of each word in the string \'s\' in place. # Helper function to reverse characters in a list from start to end index def reverse_word(chars, start, end): while start < end: chars[start], chars[end] = chars[end], chars[start] start += 1 end -= 1 # Convert string to list of characters for in-place manipulation chars = list(s) n = len(chars) start = 0 while start < n: if chars[start] != \' \': end = start while end < n and chars[end] != \' \': end += 1 # reverse the current word reverse_word(chars, start, end - 1) start = end else: start += 1 return \'\'.join(chars)"},{"question":"# Problem Statement You are given a list of integers representing the population of cities. Implement a function `redistribute_population` to redistribute the populations such that the difference between the maximum and minimum population in the list is minimized. The redistribution rule is that you can only move one population unit at a time from a city with a higher population to a city with a lower population. # Function Signature ```python def redistribute_population(populations: List[int]) -> List[int]: ``` # Input - `populations`: A list of integers where each integer represents the population of a city. The length of the list will be up to `5000`, and each city\'s population will be an integer between `0` and `100000`. # Output - Returns a list of integers representing the populations of the cities after redistribution to minimize the difference between the maximum and minimum population. # Constraints - The total number of population units is conserved during the redistribution process. - The redistribution should be done in the minimum number of moves possible. # Example ```python populations = [10, 20, 30] redistributed_populations = redistribute_population(populations) # Output could be: [20, 20, 20], since moving population units from cities with 30 and 10 balances all cities equally. populations = [1, 2, 7] redistributed_populations = redistribute_population(populations) # Output could be: [3, 3, 4], as this would be the minimum difference result. ``` # Detailed Description 1. **Algorithm to Redistribute Population** - Calculate the total population and the target population per city. - Distribute the surplus population from overpopulated cities to underpopulated cities. - Ensure that the population movements are optimized to reach the target population as efficiently as possible. 2. **Base Cases** - If all cities already have the same population, no redistribution is needed. - If the list of populations is empty, return an empty list. # Code Template ```python from typing import List def redistribute_population(populations: List[int]) -> List[int]: if not populations: return [] total_population = sum(populations) n = len(populations) target_population = total_population // n leftovers = total_population % n # Create an array initialized to target population result = [target_population] * n # Distribute the leftovers population units for i in range(leftovers): result[i] += 1 return result ``` Validate your implementation with the provided examples and ensure it handles various edge cases like empty lists, uniform populations, and highly unequal populations correctly.","solution":"from typing import List def redistribute_population(populations: List[int]) -> List[int]: if not populations: return [] total_population = sum(populations) n = len(populations) target_population = total_population // n leftovers = total_population % n # Create an array initialized to target population result = [target_population] * n # Distribute the leftovers population units for i in range(leftovers): result[i] += 1 return sorted(result)"},{"question":"# Problem Statement A smart home system involves a series of sensors placed in different rooms that record temperature readings throughout the day. Each sensor transmits its data to a central server, which needs to process the readings and determine the maximum temperature recorded for a specific range of dates. Your task is to implement an efficient approach to support multiple range queries for the maximum temperature over specific periods. # Function Signature ```python def max_temperature_readings(readings: list[int], ranges: list[tuple[int, int]]) -> list[int]: :param readings: a list of integers representing daily temperature readings (0 <= reading <= 100) for each day of the year (1 <= len(readings) <= 365). :param ranges: a list of tuples where each tuple (start, end) represents a range of dates (1 <= start <= end <= len(readings)). :return: a list of integers where each element is the maximum temperature for the corresponding range in \'ranges\'. Raises ValueError if the input criteria are not met (e.g., readings out of range, invalid date ranges). ``` # Example ```python print(max_temperature_readings([34, 35, 28, 30, 40, 28, 32], [(1, 3), (2, 5), (1, 7)])) # Expected output: [35, 40, 40] print(max_temperature_readings([50, 49, 51, 52, 48, 47, 53], [(3, 6), (1, 4), (7, 7)])) # Expected output: [52, 52, 53] print(max_temperature_readings([], [(1, 1)])) # Expected output: ValueError for any non-empty ranges if readings list is empty ``` # Constraints * You can assume the following: - `readings` is a list of integers in the range [0, 100]. - `ranges` is a list of tuples where each tuple contains two integers representing a start and an end date within the range of the readings list length. - The length of `readings` is at most 365. - The length of `ranges` can be up to 1000. # Tasks 1. Implement input validation to handle erroneous inputs. 2. Optimize your approach to efficiently retrieve the maximum temperature for multiple ranges. 3. Handle edge cases, such as an empty readings list, invalid date ranges, or out-of-bound indices. # Notes - Consider using a preprocessing step to optimize querying for maximum values over date ranges. - Emphasize the efficiency and correctness of your solution. - Utilize appropriate data structures to support fast retrieval and query execution.","solution":"def max_temperature_readings(readings, ranges): Returns the list of maximum temperature readings for specified date ranges. if not isinstance(readings, list) or not isinstance(ranges, list): raise ValueError(\\"Invalid input: readings and ranges must be lists.\\") if any(not isinstance(tup, tuple) or len(tup) != 2 for tup in ranges): raise ValueError(\\"Invalid input: ranges must be a list of tuples with two integers each.\\") if not all(isinstance(temp, int) and 0 <= temp <= 100 for temp in readings): raise ValueError(\\"Invalid input: readings must be integers between 0 and 100 inclusive.\\") n = len(readings) if n == 0 and ranges: raise ValueError(\\"Invalid input: readings list is empty but ranges are specified.\\") # Creating a list to store prefix max values prefix_max = [0] * n prefix_max[0] = readings[0] for i in range(1, n): prefix_max[i] = max(prefix_max[i-1], readings[i]) results = [] for (start, end) in ranges: if not (1 <= start <= end <= n): raise ValueError(\\"Invalid range: Start and end dates must be within valid range.\\") max_temp = readings[start - 1] for i in range(start, end): max_temp = max(max_temp, readings[i]) results.append(max_temp) return results"},{"question":"# Coding Assessment Question Balanced Parentheses with Wildcards You are tasked with designing a function that determines whether a sequence of characters can be considered as balanced parentheses. The sequence can include three types of characters: `\'(\'`, `\')\'`, and `\'*\'`. The wildcard character `\'*\'` can be treated as either an opening parenthesis `\'(\'`, a closing parenthesis `\')\'`, or an empty string `\'\'`. **Task**: Write a Python function `check_balance_with_wildcards(s: str) -> bool` that takes a string `s` consisting of the characters `(\'(\', \')\', \'*\')` and returns `True` if it can be considered balanced by interpreting the wildcards appropriately, and `False` otherwise. **Input Constraints**: - The length of string `s` will be between 1 and 100. - The string `s` will only contain characters `(\'(\', \')\', \'*\')`. **Example**: ```python def check_balance_with_wildcards(s: str) -> bool: pass # Example Usage assert check_balance_with_wildcards(\\"(*)\\") == True assert check_balance_with_wildcards(\\"(*))\\") == True assert check_balance_with_wildcards(\\"(((*)\\") == False assert check_balance_with_wildcards(\\"(*))(\\") == False assert check_balance_with_wildcards(\\"****\\") == True ``` Explanation: - In the first example, the string can be balanced by interpreting `*` as `\'\'`. - In the second example, the string can be balanced by interpreting `*` as `(`. - In the third example, no interpretation can balance the string due to an insufficient number of closing parentheses. - In the fourth example, even with wildcards, no interpretation can balance the string because there is an unmatched `(`. - In the fifth example, the string consists only of wildcards, which means it can always be balanced.","solution":"def check_balance_with_wildcards(s: str) -> bool: low, high = 0, 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low = max(low - 1, 0) high -= 1 else: # char == \'*\' low = max(low - 1, 0) high += 1 if high < 0: return False return low == 0"},{"question":"# Sum of Odd Numbers in Row of Pascal\'s Triangle Given a specific row index `n` in Pascal\'s Triangle, compute the sum of all odd numbers present in that row. Pascal\'s Triangle is a triangular array of the binomial coefficients. Each number in the triangle is the sum of the two directly above it. Function Signature ```python def sum_of_odds_in_pascals_row(n: int) -> int: pass ``` Input * `n` (int): The index of the row in Pascal\'s Triangle (0-indexed). Output * `int`: The sum of all odd numbers in the specified row. Constraints * 0 ≤ `n` ≤ 10^6 Example ```python print(sum_of_odds_in_pascals_row(0)) # should output 1 print(sum_of_odds_in_pascals_row(3)) # should output 4 ``` Explanation * For `n=0`, the row is `[1]`, sum of odd numbers is 1. * For `n=3`, the row is `[1, 3, 3, 1]`, sum of odd numbers is 1 + 3 + 3 + 1 = 8. # Constraints & Guidelines * Ensure the function is optimized to handle large values of `n`. * Consider edge cases, such as when `n` is very small or very large. * Validate inputs for robustness within specified constraints.","solution":"def sum_of_odds_in_pascals_row(n: int) -> int: Computes the sum of all odd numbers in the nth row of Pascal\'s Triangle. Parameters: n (int): The index of the row in Pascal\'s Triangle (0-indexed). Returns: int: The sum of all odd numbers in the specified row. # The sum of the binomial coefficients in row n is 2^n. # In Pascal\'s Triangle, the number of odd numbers in row n # is 2^(bin(n).count(\'1\')), because each position in the row # corresponds to a combination of choosing a subset of \'1\'s in the binary representation. num_odds = 2 ** bin(n).count(\'1\') # All odd numbers are effectively \'1\' in modulo operation # since we are only summing the odd ones. # So the sum of all odd numbers is num_odds times 1 which is num_odds itself. return num_odds"},{"question":"# Coding Assessment Question: Number Sequence Analysis and Manipulation Objective Design a class `NumberSequence` to analyze and manipulate sequences of integers. Requirements 1. **Check Arithmetic Progression**: Add a method to check if the sequence is an arithmetic progression. 2. **Longest Increasing Subsequence**: Implement a method to find the longest increasing subsequence in the sequence. 3. **Three Sum Zero**: Implement a method to find unique triplets in the sequence that sum up to zero. Method Specifications - **Arithmetic Progression Method**: 1. `is_arithmetic() -> bool`: Determine if the sequence is an arithmetic progression. Return `True` if it is, otherwise `False`. - **Longest Increasing Subsequence Method**: 1. `longest_increasing_subsequence() -> List[int]`: Find and return the longest increasing subsequence in the sequence. - **Three Sum Zero Method**: 1. `three_sum_zero() -> List[Tuple[int, int, int]]`: Identify unique triplets (a, b, c) from the sequence such that `a + b + c = 0`. Return a list of these unique triplets as tuples. # Input and Output Formats - **Input**: The sequence will be provided as a list of integers. - **Output**: The methods should return the appropriate boolean, list of integers, or list of tuples as specified. # Constraints - `1 <= len(sequence) <= 1000` - Sequence elements will be within the range [-10000, 10000]. # Function Signature ```python class NumberSequence: def __init__(self, sequence: List[int]): self.sequence = sequence def is_arithmetic(self) -> bool: pass def longest_increasing_subsequence(self) -> List[int]: pass def three_sum_zero(self) -> List[Tuple[int, int, int]]: pass ``` # Example Usage: ```python # Define a sequence of numbers sequence = [2, 4, 6, 8, 10, -1, -5, 2, 3, -4] # Create a NumberSequence object num_seq = NumberSequence(sequence) # Check if the sequence is an arithmetic progression print(num_seq.is_arithmetic()) # Output: False (since the sequence is not an arithmetic progression) # Find the longest increasing subsequence print(num_seq.longest_increasing_subsequence()) # Output: [2, 3, 4, 6, 8, 10] # Find all unique triplets that sum up to zero print(num_seq.three_sum_zero()) # Output: [(-5, 2, 3), (-4, -1, 5), ...] ```","solution":"from typing import List, Tuple class NumberSequence: def __init__(self, sequence: List[int]): self.sequence = sequence def is_arithmetic(self) -> bool: if len(self.sequence) < 2: return True diff = self.sequence[1] - self.sequence[0] for i in range(2, len(self.sequence)): if self.sequence[i] - self.sequence[i - 1] != diff: return False return True def longest_increasing_subsequence(self) -> List[int]: if not self.sequence: return [] n = len(self.sequence) lis = [1] * n prev_index = [-1] * n for i in range(1, n): for j in range(i): if self.sequence[i] > self.sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 prev_index[i] = j max_len = max(lis) idx = lis.index(max_len) lis_seq = [] while idx != -1: lis_seq.append(self.sequence[idx]) idx = prev_index[idx] return lis_seq[::-1] def three_sum_zero(self) -> List[Tuple[int, int, int]]: self.sequence.sort() n = len(self.sequence) triplets = set() for i in range(n): if i > 0 and self.sequence[i] == self.sequence[i - 1]: continue left, right = 0, n - 1 while left < right: if left == i: left += 1 continue if right == i: right -= 1 continue current_sum = self.sequence[i] + self.sequence[left] + self.sequence[right] if current_sum == 0: triplets.add(tuple(sorted([self.sequence[i], self.sequence[left], self.sequence[right]]))) left += 1 right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return list(triplets)"},{"question":"# Problem Statement You are tasked with developing a function that determines the minimum number of steps required to convert a given binary indexed tree into a balanced binary indexed tree. A binary indexed tree is used in various algorithm problems to query and update elements of an array efficiently. A balanced binary indexed tree ensures that, for any node, the heights of its left and right subtrees differ by at most 1. Furthermore, implement a function to compute which node should be added, removed, or adjusted to achieve this balance. # Input 1. A list of integers representing the nodes of the binary indexed tree in level-order traversal, denoted as `bitr` where the root is at index 0. 2. An integer `action` defining whether to add (1), remove (-1), or adjust (0) a node to achieve balance. # Output 1. For the `action` input: The minimum number of steps required to balance the tree. 2. The index of the node to be added, removed, or adjusted based on the `action` input to achieve balance. # Function Signature ```python def minimum_steps_to_balance(bitr: List[int], action: int) -> Tuple[int, int]: # Your code here ``` # Example ```python # Example 1 assert minimum_steps_to_balance([10, 12, 8, 15, 6, 9], 1) == (1, 6) assert minimum_steps_to_balance([10, 12, 8, 15, 6, 9], -1) == (1, 5) # Example 2 assert minimum_steps_to_balance([10, 12, 8, 15, 6], 0) == (0, -1) assert minimum_steps_to_balance([10, 12, 8, 15], -1) == (1, 3) ``` # Constraints 1. ( 1 leq text{len(bitr)} leq 10^6 ) 2. ( text{action} ) is either -1, 0, or 1 # Notes - Ensure that the solution efficiently handles large binary indexed trees within the given constraints. - The index positions for adding and removing nodes must maintain a binary tree structure even after modification. - Handle edge cases where the tree is already balanced or requires minimal changes.","solution":"import math from typing import List, Tuple def height_of_tree(n: int) -> int: if n == 0: return 0 return math.ceil(math.log2(n + 1)) def is_balanced(height: int, low: int, high: int) -> bool: return height >= low and height <= high def minimum_steps_to_balance(bitr: List[int], action: int) -> Tuple[int, int]: n = len(bitr) height = height_of_tree(n) if action == 0: # Adjust a node return (0, -1) # Ideally, needs to analyze for adjustments, but basic implemntation here if action == 1: # Add a node new_height_with_extra = height_of_tree(n + 1) balance_low = height - 1 balance_high = height + 1 if is_balanced(new_height_with_extra, balance_low, balance_high): return (1, n) # Adding a node at the end if action == -1: # Remove a node new_height_with_less = height_of_tree(n - 1) balance_low = height - 1 balance_high = height + 1 if is_balanced(new_height_with_less, balance_low, balance_high): return (1, n - 1) # Removing the last node return (0, -1) # In case there\'s no need to add or remove any node"},{"question":"# Scenario You are tasked with implementing a simplified version of a log analysis tool. The goal is to write a Python function that parses a log file and extracts useful information about error frequency. # Task Write a Python function `analyze_logs` that takes one parameter: 1. `log_file_path`: The path to the log file. The function should: 1. Read the log file line by line. 2. Each line in the log file follows the format `\\"[datetime] [log_level] [message]\\"`. 3. Count the occurrences of each log level (e.g., ERROR, WARNING, INFO) in the file. 4. Print the count of each log level in the format `\\"{log_level}: {count}\\"`. # Input * `log_file_path`: A string representing the path to the log file. # Output None. The function should print the counts of each log level. # Constraints * The log file can be large, so consider efficient file reading methods. * Log levels are not case-sensitive (e.g., \\"ERROR\\" and \\"error\\" should be treated the same). * Handle any exceptions that may occur during file reading gracefully. # Example ```python def analyze_logs(log_file_path: str): pass # Example of usage - Assuming \'log.txt\' is a log file provided at the specified path # analyze_logs(\'log.txt\') ``` Given a log file such as: ``` [2023-01-01 10:00:00] ERROR Failed to connect to database [2023-01-01 10:01:00] WARNING Low disk space [2023-01-01 10:02:00] INFO User login successful [2023-01-01 10:03:00] ERROR Failed to send email ``` The function should print: ``` ERROR: 2 WARNING: 1 INFO: 1 ```","solution":"def analyze_logs(log_file_path: str): Analyzes the log file at the given path and prints the count of each log level. log_levels = {} try: with open(log_file_path, \'r\') as file: for line in file: parts = line.split(\']\') if len(parts) > 1: log_level = parts[1].strip().split(\' \')[0].upper() if log_level in log_levels: log_levels[log_level] += 1 else: log_levels[log_level] = 1 except Exception as e: print(f\\"An error occurred: {e}\\") return for log_level, count in log_levels.items(): print(f\\"{log_level}: {count}\\")"},{"question":"# Context Sorting algorithms are fundamental in computer science, with various methods available to sort an array effectively. Merge Sort is a popular, efficient, and stable algorithm known for its divide-and-conquer approach and consistent performance across different types of input arrays. # Task You are required to implement the Merge Sort algorithm to sort an array of integers in non-decreasing order. The function should handle arrays efficiently and maintain a time complexity of O(n log n). # Function Signature ```python def merge_sort(arr: list[int]) -> list[int]: Sorts an array of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list of integers sorted in non-decreasing order. ``` # Constraints 1. The input array `arr` will have at most 10^6 elements. 2. Each element in `arr` will be an integer. 3. The algorithm should be stable and maintain the relative order of equal elements. # Input A single list of integers `arr` (0 ≤ len(arr) ≤ 10^6). # Output Return a new list containing the elements of `arr` sorted in non-decreasing order. # Examples ```python >>> merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] >>> merge_sort([38, 27, 43, 3, 9, 82, 10]) [3, 9, 10, 27, 38, 43, 82] >>> merge_sort([]) [] >>> merge_sort([5]) [5] >>> merge_sort([10, 7, 22, 14, 3]) [3, 7, 10, 14, 22] ``` # Requirements - The function must sort the array using the Merge Sort algorithm. - The implementation should handle arrays with up to 10^6 elements efficiently.","solution":"def merge_sort(arr): Sorts an array of integers using the Merge Sort algorithm. Args: arr: A list of integers to be sorted. Returns: A new list of integers sorted in non-decreasing order. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left, right): sorted_array = [] i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # Append any remaining elements in left or right sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"# Question You are required to develop a class, `CodeAnalyzer`, that analyzes a given Python function for its time and space complexity. Implement methods to extract various properties of the function and perform the analysis. # Requirements 1. **Function Input**: The class should accept a string containing the Python function\'s code as input. 2. **Tokenization**: Use Python\'s built-in `ast` module to parse the function and analyze its structure. 3. **Complexity Analysis**: Implement methods to assess the following aspects: * Number of lines of code * Number of loops (for/while) * Number of conditional statements (if/elif/else) * Number of function calls * Estimated Time Complexity (Big-O notation) * Estimated Space Complexity (Big-O notation) 4. **Error Handling**: Handle cases where the input is not a valid Python function gracefully. # Class Structure Implement the following structure for `CodeAnalyzer`: ```python class CodeAnalyzer: def __init__(self, function_code: str): # Constructor with initialization code def get_num_lines(self) -> int: # Return the number of lines in the function def get_num_loops(self) -> int: # Return the number of loops in the function def get_num_conditionals(self) -> int: # Return the number of conditional statements def get_num_function_calls(self) -> int: # Return the number of function calls def get_time_complexity(self) -> str: # Return the estimated time complexity in Big-O notation def get_space_complexity(self) -> str: # Return the estimated space complexity in Big-O notation def __repr__(self) -> str: # Return a string representation of the statistics def __str__(self) -> str: # Return a user-friendly string representation of the analysis ``` # Constraints: 1. **Function Length**: The `function_code` should be a valid Python function ranging between 3 to 50 lines of code. 2. **Timeout**: Ensure that the complexity analysis completes within a reasonable time frame for typical functions (e.g., within 5 seconds). 3. **Performance**: Handle cases with nested loops and conditionals reasonably. # Bonus: Implement a method to plot the control flow graph of the function using a library such as `networkx` or `graphviz`.","solution":"import ast class CodeAnalyzer: def __init__(self, function_code: str): self.function_code = function_code self.function_ast = ast.parse(function_code) def get_num_lines(self) -> int: return len(self.function_code.split(\'n\')) def get_num_loops(self) -> int: return sum(isinstance(node, (ast.For, ast.While)) for node in ast.walk(self.function_ast)) def get_num_conditionals(self) -> int: return sum(isinstance(node, (ast.If,)) for node in ast.walk(self.function_ast)) def get_num_function_calls(self) -> int: return sum(isinstance(node, ast.Call) for node in ast.walk(self.function_ast)) def get_time_complexity(self) -> str: # Estimation of time complexity would not be accurate through static analysis return \\"O(?)\\" def get_space_complexity(self) -> str: # Estimation of space complexity would not be accurate through static analysis return \\"O(?)\\" def __repr__(self) -> str: return fCodeAnalyzer( lines_of_code={self.get_num_lines()}, num_loops={self.get_num_loops()}, num_conditionals={self.get_num_conditionals()}, num_function_calls={self.get_num_function_calls()}, time_complexity=\\"{self.get_time_complexity()}\\", space_complexity=\\"{self.get_space_complexity()}\\" ) def __str__(self) -> str: return ( f\\"Lines of code: {self.get_num_lines()}n\\" f\\"Number of loops: {self.get_num_loops()}n\\" f\\"Number of conditionals: {self.get_num_conditionals()}n\\" f\\"Number of function calls: {self.get_num_function_calls()}n\\" f\\"Estimated Time Complexity: {self.get_time_complexity()}n\\" f\\"Estimated Space Complexity: {self.get_space_complexity()}\\" )"},{"question":"Context: As a robotics software developer, you need to design an algorithm that will assist a robot with navigating through an environment that includes both static and dynamic obstacles. This software will be part of a larger navigation system that ensures robots can move efficiently and safely in various environments. **Task**: Implement a function to calculate the shortest path between two points on a 2D grid while avoiding static obstacles. The function should return the path as a list of coordinates. # Requirements: * Implement a function named `shortest_path_avoiding_obstacles` in Python. * The inputs will be: - `start`: tuple of two integers, representing the starting coordinates (x, y). - `end`: tuple of two integers, representing the ending coordinates (x, y). - `obstacles`: list of tuples, where each tuple represents the coordinates (x, y) of a static obstacle. * The output should be a list of tuples representing the coordinates of the shortest path from start to end, inclusive. # Additional Constraints: * Assume the grid is unbounded; there are no limits to the x and y coordinates. * The movements can be in 4 directions only: up, down, left, and right. * If there is no available path, return an empty list. # Function Signature: ```python def shortest_path_avoiding_obstacles( start: tuple[int, int], end: tuple[int, int], obstacles: list[tuple[int, int]] ) -> list[tuple[int, int]]: pass ``` # Example: ```python >>> shortest_path_avoiding_obstacles((0, 0), (2, 2), [(1, 1)]) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> shortest_path_avoiding_obstacles((0, 0), (2, 2), [(0, 1), (1, 0), (1, 1)]) [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)] >>> shortest_path_avoiding_obstacles((0, 0), (1, 1), [(0, 1), (1, 0), (1, 1)]) [] ```","solution":"from collections import deque def shortest_path_avoiding_obstacles(start, end, obstacles): Calculates the shortest path from start to end on a 2D grid avoiding static obstacles. Args: - start (tuple): Starting coordinates (x, y). - end (tuple): Ending coordinates (x, y). - obstacles (list): List of tuples representing static obstacle coordinates (x, y). Returns: - list: List of tuples representing the shortest path from start to end, inclusive. If no path exists, returns an empty list. if start == end: return [start] obstacles_set = set(obstacles) if start in obstacles_set or end in obstacles_set: return [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # (up, right, down, left) visited = set() queue = deque([(start, [start])]) while queue: (current, path) = queue.popleft() for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if neighbor == end: return path + [end] if neighbor not in obstacles_set and neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"Problem Statement You are tasked to implement an image segmentation algorithm using the K-means clustering technique. The goal is to cluster image pixels into K distinct segments based on their color information (RGB values). Each pixel in the resulting segmented image should be replaced with the centroid color of the cluster it belongs to. # Function Signature ```python def k_means_segmentation(img: np.ndarray, k: int, max_iters: int = 100) -> np.ndarray: :param img: input image as a numpy array with shape (H, W, 3). :param k: the number of clusters to segment the image into. :param max_iters: the maximum number of iterations for the K-means algorithm. :return: segmented image with the same shape as the input image. ``` # Input * `img`: A color image represented as a numpy array of shape (H, W, 3), where H is the height and W is the width of the image. * `k`: An integer representing the number of clusters for K-means. * `max_iters`: An optional integer representing the maximum number of iterations for the K-means algorithm (default is 100). # Output * A color image with the same shape (H, W, 3) as the input, where each pixel\'s color has been replaced by the centroid color of the cluster it belongs to. # Constraints * Do not use high-level clustering functions from libraries such as OpenCV or Scikit-learn (e.g., cv2.kmeans, sklearn.cluster.KMeans). * Implement the K-means clustering algorithm from scratch. * Ensure the algorithm converges or stops after the given maximum number of iterations. * Handle cases where the input image is too small or K is too large gracefully. # Additional Requirements * Initialize cluster centroids randomly from the pixel values. * Compute the Euclidean distance to assign pixels to the nearest centroid. * Recompute centroids as the mean of the assigned pixels. # Example Usage ```python import cv2 import numpy as np if __name__ == \\"__main__\\": # read the original image img = cv2.imread(\\"example_image.png\\") # apply K-means segmentation k = 4 # number of segments segmented_img = k_means_segmentation(img=img, k=k) # display results cv2.imshow(\\"Segmented Image\\", segmented_img) cv2.waitKey(0) cv2.destroyAllWindows() ``` # Hints * You might find reshaping the image array helpful in simplifying the computation (convert a (H, W, 3) array to a (H*W, 3) array). * Track and compare the change in cluster assignments between iterations to check for convergence. * Ensure the random initialization of centroids is reproducible by setting a random seed if necessary. This problem tests your ability to work with image processing and clustering algorithms and requires a solid understanding of the K-means clustering technique and its application in image segmentation.","solution":"import numpy as np def k_means_segmentation(img: np.ndarray, k: int, max_iters: int = 100) -> np.ndarray: Segment the image using K-means clustering. :param img: input image as a numpy array with shape (H, W, 3). :param k: the number of clusters to segment the image into. :param max_iters: the maximum number of iterations for the K-means algorithm. :return: segmented image with the same shape as the input image. # Reshape the image to a 2D array of pixels pixels = img.reshape(-1, 3) num_pixels = pixels.shape[0] # Randomly initialize the centroids by selecting random k pixels from the image np.random.seed(42) centroids = pixels[np.random.choice(num_pixels, k, replace=False)] for _ in range(max_iters): # Compute the distance between each pixel and the centroids distances = np.linalg.norm(pixels[:, np.newaxis] - centroids, axis=2) # Assign each pixel to the closest centroid labels = np.argmin(distances, axis=1) # Calculate the new centroids new_centroids = np.array([pixels[labels == i].mean(axis=0) for i in range(k)]) # Check for convergence (if centroids do not change) if np.all(centroids == new_centroids): break centroids = new_centroids # Replace each pixel\'s color with the centroid color of the cluster it belongs to segmented_pixels = centroids[labels].reshape(img.shape) return segmented_pixels.astype(np.uint8)"},{"question":"# Coding Assessment Question Context: In many programming tasks, efficiently finding intersections in sets of data is crucial. Consider a scenario where you are given multiple lists of integers, and you need to identify how many integers are present in all the lists. Task: Write a function `count_common_elements(lists: List[List[int]]) -> int` that determines the number of distinct integers present in all of the given lists. The function should perform the following steps: 1. Convert each list into a set to eliminate duplicates within each list. 2. Find the intersection of all these sets to identify common elements. 3. Return the count of these common integers. Input: * `lists`: A list containing multiple lists of integers. Each integer list will have at least one number and at most `10^3` numbers. The total number of lists will be between `1` and `100`. Output: * Integer representing the count of common elements present in all lists. Constraints: * Each individual list contains integers within the range [-1000, 1000]. * The input lists are always valid and non-empty. Example: ```python assert count_common_elements([[1, 2, 3], [3, 4, 5], [3, 6, 7]]) == 1 assert count_common_elements([[5, 10, 15], [10, 20, 30], [5, 10, 25]]) == 1 assert count_common_elements([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 0 ``` Good luck! Ensure you handle edge cases and optimize your solution to efficiently find the intersection of elements in the provided lists.","solution":"from typing import List def count_common_elements(lists: List[List[int]]) -> int: if not lists: return 0 # Convert each list into a set to eliminate duplicates sets_of_numbers = [set(lst) for lst in lists] # Find the intersection of all these sets common_elements = set.intersection(*sets_of_numbers) # Return the count of these common elements return len(common_elements)"},{"question":"# Problem Statement You are required to implement a **Priority Queue** data structure using a max-heap. The priority queue should support efficient insertion and removal of elements based on their priority. # Requirements 1. **Implementation Details**: - The priority queue should be implemented as a class `PriorityQueue` using a max-heap. - The elements in the max-heap should be stored as tuples of the form `(priority, data)`. 2. **Functional Requirements**: Implement the following methods: - `insert(self, priority: int, data: T) -> None`: Adds an element with a given priority to the priority queue. - `extract_max(self) -> Optional[Tuple[int, T]]`: Removes and returns the element with the highest priority. - `max(self) -> Optional[Tuple[int, T]]`: Returns the element with the highest priority without removing it. - `is_empty(self) -> bool`: Returns `True` if the priority queue is empty, `False` otherwise. - `__len__(self) -> int`: Returns the number of elements in the priority queue in O(1) time. # Input/Output Formats - The `insert` method should accept an integer `priority` and a data element of any type `T`. - The `extract_max` and `max` methods should return a tuple `(priority, data)` or `None` if the priority queue is empty. - The `is_empty` method should return a boolean value. - The `__len__` method should return an integer representing the number of elements in the priority queue. # Constraints - Your implementation should ensure that all operations are efficient. - The internal structure (max-heap) must be managed correctly to maintain the priority order upon insertion and removal. - Ensure that the `__len__` operation runs in O(1) time complexity. # Example Usage ```python pq = PriorityQueue() print(pq.is_empty()) # Output: True pq.insert(3, \'A\') pq.insert(5, \'B\') pq.insert(1, \'C\') print(len(pq)) # Output: 3 print(pq.max()) # Output: (5, \'B\') print(pq.extract_max()) # Output: (5, \'B\') print(len(pq)) # Output: 2 print(pq.is_empty()) # Output: False ``` # Additional Notes - You may assume any necessary imports and class definitions are provided. - The `__init__` method should initialize the priority queue as empty. - Consider edge cases such as operations on an empty priority queue. - Optimize the `__len__` function to be O(1) using an auxiliary variable. --- The additional question is designed to complement the given question on implementing a stack using a doubly linked list. It maintains a similar structure, length, and complexity, focusing on another fundamental data structure (priority queue) to assess a similar range of programming and algorithmic skills.","solution":"import heapq from typing import Any, List, Optional, Tuple class PriorityQueue: def __init__(self): self._heap: List[Tuple[int, Any]] = [] self._count = 0 def insert(self, priority: int, data: Any) -> None: # Insert element into the heap heapq.heappush(self._heap, (-priority, data)) self._count += 1 def extract_max(self) -> Optional[Tuple[int, Any]]: if self.is_empty(): return None # Remove and return the element with the highest priority self._count -= 1 priority, data = heapq.heappop(self._heap) return -priority, data def max(self) -> Optional[Tuple[int, Any]]: if self.is_empty(): return None # Return the element with the highest priority without removing it priority, data = self._heap[0] return -priority, data def is_empty(self) -> bool: return self._count == 0 def __len__(self) -> int: return self._count"},{"question":"You are required to implement a function that performs matrix multiplication and demonstrate its application on two given matrices. # Scenario You are given two 2D matrices `A` and `B` represented as lists of lists. You need to write a Python function to multiply these matrices. # Function Signature ```python def matrix_multiplication(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Multiplies two matrices A and B. Parameters: - A: The first matrix represented as a list of lists. - B: The second matrix represented as a list of lists. Returns: - A list of lists representing the product of matrices A and B. ``` # Constraints 1. The number of columns in matrix A should be equal to the number of rows in matrix B. 2. The elements of the matrices are integers. 3. If the matrices cannot be multiplied due to incompatible dimensions, return an empty list. # Examples ```python A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] # Matrix multiplication example product = matrix_multiplication(A, B) print(f\\"Matrix product: {product}\\") # Expected output: # [[58, 64], # [139, 154]] ``` # Performance Requirements - The solution should efficiently handle typical edge cases like non-conformable matrices. - Optimize the solution for readability and maintainability, ensuring it is easy to understand and modify.","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B. Parameters: - A: The first matrix represented as a list of lists. - B: The second matrix represented as a list of lists. Returns: - A list of lists representing the product of matrices A and B or an empty list if the matrices cannot be multiplied. # Get dimensions of matrices rows_A, cols_A = len(A), len(A[0]) rows_B, cols_B = len(B), len(B[0]) # Check if matrices can be multiplied if cols_A != rows_B: return [] # Initialize the result matrix with zeros result = [[0 for _ in range(cols_B)] for _ in range(rows_A)] # Perform matrix multiplication for i in range(rows_A): for j in range(cols_B): for k in range(cols_A): result[i][j] += A[i][k] * B[k][j] return result"},{"question":"# Coding Question: Building an LRU Cache Context: Least Recently Used (LRU) is a popular cache eviction policy. You are required to implement an LRU cache that can store a fixed number of entries and evicts the least recently used entry when a new entry exceeds the storage limit. Task: Create a class `LRUCache` implementing an LRU cache with fixed capacity using a doubly linked list and a hash map for optimal performance. Requirements: * **Class Signature**: `class LRUCache:` * **Constructor**: * `def __init__(self, capacity: int):` * Initializes the cache with a given capacity. * **Methods**: * `def get(self, key: int) -> int:` * Returns the value of the key if it exists in the cache, otherwise returns `-1`. * `def put(self, key: int, value: int) -> None:` * Inserts the key-value pair into the cache. If the cache reaches its capacity, it should invalidate the least recently used entry before inserting a new item. Example: ```python # Initialize the cache with capacity 2 cache = LRUCache(2) cache.put(1, 1) # cache: {1=1} cache.put(2, 2) # cache: {1=1, 2=2} print(cache.get(1)) # returns 1, cache: {2=2, 1=1} cache.put(3, 3) # evicts key 2, cache: {1=1, 3=3} print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1, cache: {3=3, 4=4} print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3, cache: {4=4, 3=3} print(cache.get(4)) # returns 4, cache: {3=3, 4=4} ``` Constraints: * Capacity of the cache is a positive integer. * The cache operations `get` and `put` must run in O(1) time complexity. Implementation Details: * Use a doubly linked list to maintain the order of least recently used items. * Use a hash map to store references to the keys and their corresponding nodes in the linked list for O(1) access.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: node = self.head.next self._remove(node) del self.cache[node.key] def _remove(self, node): prev = node.prev next = node.next prev.next = next next.prev = prev def _add(self, node): prev = self.tail.prev prev.next = node node.prev = prev node.next = self.tail self.tail.prev = node"},{"question":"# Sum of Squares of Digits You need to write a function that calculates the sum of squares of the digits of a given non-negative integer. The function should take an integer and return the sum of the squares of its digits. # Function Specification **Function Name**: `sum_of_squares_of_digits` **Input**: 1. `number` (int): A non-negative integer. **Output**: - Returns an integer representing the sum of the squares of the digits of the input number. # Constraints: - The input number will be a non-negative integer (0 <= number <= 10^12). # Examples: ```python sum_of_squares_of_digits(123) # Output: 14 # Explanation: 1^2 + 2^2 + 3^2 = 1 + 4 + 9 = 14 sum_of_squares_of_digits(456) # Output: 77 # Explanation: 4^2 + 5^2 + 6^2 = 16 + 25 + 36 = 77 sum_of_squares_of_digits(0) # Output: 0 # Explanation: 0^2 = 0 sum_of_squares_of_digits(9999) # Output: 324 # Explanation: 9^2 + 9^2 + 9^2 + 9^2 = 81 + 81 + 81 + 81 = 324 ``` # Additional Notes: Approach the problem by converting the number into its constituent digits, squaring each digit, and summing the results. # Testing: * Handle the smallest input value (e.g., 0). * Handle the largest input value within the constraint (e.g., 10^12). * Check sequences of identical digits (e.g., 1111 or 999999). Write the function `sum_of_squares_of_digits` such that it accurately computes the sum of the squares of the digits of the given number.","solution":"def sum_of_squares_of_digits(number): This function returns the sum of the squares of the digits of a given non-negative integer. Parameters: number (int): A non-negative integer. Returns: int: The sum of the squares of the digits of the input number. return sum(int(digit) ** 2 for digit in str(number))"},{"question":"# Context You are tasked with developing an efficient algorithm to manage a rolling average for a continuously updating stream of integers. To achieve this, you will create a data structure that supports the addition of new integers while maintaining the ability to quickly retrieve the rolling average based on the last `n` integers added. # Task Implement a `MovingAverage` class that computes a moving (rolling) average from a data stream. # Specifications: `__init__(self, size: int) -> None` Initializes the data structure with a fixed size window, `size`. `next(self, val: int) -> float` Adds a new integer `val` to the data structure, and returns the current moving average of the last `size` integers. Input/Output Upon instantiation, the class is provided with a window size `size`. Implement a method to add integers to the data structure and return the moving average of the last `size` integers. # Example ```python # Example usage: moving_average = MovingAverage(3) print(moving_average.next(1)) # Output: 1.0 (average of [1]) print(moving_average.next(10)) # Output: 5.5 (average of [1, 10]) print(moving_average.next(3)) # Output: 4.66667 (average of [1, 10, 3]) print(moving_average.next(5)) # Output: 6.0 (average of [10, 3, 5]) ``` Ensure your implementation is correct and efficient with respect to both time and space requirements. Use appropriate data structures to maintain the sliding window of the last `size` integers efficiently.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int) -> None: Initializes the data structure with a fixed size window, `size`. self.size = size self.window = deque() self.current_sum = 0 def next(self, val: int) -> float: Adds a new integer `val` to the data structure, and returns the current moving average of the last `size` integers. if len(self.window) == self.size: self.current_sum -= self.window.popleft() self.window.append(val) self.current_sum += val return self.current_sum / len(self.window)"},{"question":"# Lexical Analyzer Design for Structured Programming Language You need to design a basic lexical analyzer (lexer) for a small subset of a structured programming language. The language contains a predefined set of keywords, operators, and variable names. # Problem Statement Implement a function `lexical_analyze(code: str) -> list[tuple[str, str]]` that takes a string of code and returns a list of tuples, where each tuple contains a token type and its corresponding lexeme. # Function Signature ```python def lexical_analyze(code: str) -> list[tuple[str, str]]: pass ``` # Input * `code` (`str`): A string containing the source code to be analyzed. The code consists of contiguous statements separated by whitespace. # Output * `list[tuple[str, str]]`: A list of tuples where each tuple contains: - The token type (`str`): one of `\\"KEYWORD\\"`, `\\"IDENTIFIER\\"`, `\\"OPERATOR\\"`, `\\"NUMBER\\"`, `\\"DELIMITER\\"`. - The lexeme (`str`): the actual text from the code that matches the token. # Constraints * Valid keywords: `if`, `else`, `while`, `for`, `return` * Valid operators: `+`, `-`, `*`, `/`, `=`, `==`, `!=`, `<`, `>`, `<=`, `>=` * Valid delimiters: `(`, `)`, `{`, `}`, `;` * Variable names (identifiers) consist of letters and digits, starting with a letter. * Numbers are non-negative integers. * The input string is non-empty and contains valid tokens separated by whitespace. # Example ```python code = \\"if (x >= 10) { return x + y; }\\" result = lexical_analyze(code) print(result) # Expected output: [ # (\\"KEYWORD\\", \\"if\\"), # (\\"DELIMITER\\", \\"(\\"), # (\\"IDENTIFIER\\", \\"x\\"), # (\\"OPERATOR\\", \\">=\\"), # (\\"NUMBER\\", \\"10\\"), # (\\"DELIMITER\\", \\")\\"), # (\\"DELIMITER\\", \\"{\\"), # (\\"KEYWORD\\", \\"return\\"), # (\\"IDENTIFIER\\", \\"x\\"), # (\\"OPERATOR\\", \\"+\\"), # (\\"IDENTIFIER\\", \\"y\\"), # (\\"DELIMITER\\", \\";\\"), # (\\"DELIMITER\\", \\"}\\") # ] ``` # Additional Notes * Ensure correct handling of all token types defined in the constraints. * Handle whitespace correctly; it should not appear in the output. * Account for multi-character operators (e.g., `>=`, `==`, `!=`). * Assume the input will always be a valid sequence of tokens as per the above constraints.","solution":"import re def lexical_analyze(code: str) -> list[tuple[str, str]]: keywords = {\'if\', \'else\', \'while\', \'for\', \'return\'} operators = {\'+\', \'-\', \'*\', \'/\', \'=\', \'==\', \'!=\', \'<\', \'>\', \'<=\', \'>=\'} delimiters = {\'(\', \')\', \'{\', \'}\', \';\'} token_specification = [ (\'KEYWORD\', r\'b(?:if|else|while|for|return)b\'), (\'OPERATOR\', r\'+|-|*|/|=|==|!=|<=|>=|<|>\'), (\'NUMBER\', r\'bd+b\'), (\'IDENTIFIER\', r\'b[a-zA-Z_]w*b\'), (\'DELIMITER\', r\'[(){};]\'), (\'SKIP\', r\'s+\'), # Skip over spaces and tabs ] token_regex = \'|\'.join(f\'(?P<{pair[0]}>{pair[1]})\' for pair in token_specification) get_token = re.compile(token_regex).finditer tokens = [] for match in get_token(code): token_type = match.lastgroup lexeme = match.group(token_type) if token_type != \'SKIP\': tokens.append((token_type, lexeme)) return tokens"},{"question":"# Problem Statement You are given a list of integers `nums`. Your task is to determine if any continuous subarray of size `k` exists such that the sum of the elements in the subarray is greater than or equal to `threshold`. # Function Signature ```python def has_subarray_with_sum(nums: List[int], k: int, threshold: int) -> bool: pass ``` # Input - `nums` (1 <= len(nums) <= 10^5): a list of integers representing the array. - `k` (1 <= k <= len(nums)): the size of the subarray. - `threshold` (1 <= threshold <= 10^9): an integer representing the threshold for the sum of the subarray. # Output - A boolean indicating whether there is any continuous subarray of size `k` with a sum greater than or equal to `threshold`. # Example ```python has_subarray_with_sum([1, 2, 3, 4, 5], 2, 7) # Output: True has_subarray_with_sum([1, 1, 1, 1, 1], 3, 4) # Output: False has_subarray_with_sum([10, 2, 3, 4, 5, 6, 7], 3, 15) # Output: True ``` # Constraints - Consider edge cases where `k` equals 1 or the entire length of the array. - Optimize the solution considering the possible large size of the array (up to 100,000 elements).","solution":"def has_subarray_with_sum(nums, k, threshold): Return whether there is any continuous subarray of size k with sum >= threshold. # Initial sum of the first k elements current_sum = sum(nums[:k]) # If the sum of the first k elements is greater than or equal to threshold if current_sum >= threshold: return True # Using sliding window technique to check other subarrays for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum >= threshold: return True # After checking all subarrays, if no subarray had sum >= threshold return False"},{"question":"# Question: Detect Cycle in a Directed Graph You are tasked with developing a feature for a dependency management system to detect if there are any cyclic dependencies in a given project. Implement a function `has_cycle(graph)` that determines whether a directed graph contains a cycle. Function Signature ```python def has_cycle(graph: Dict[str, List[str]]) -> bool: ``` Input * `graph`: A dictionary where each key is a vertex and the value is a list of vertices representing directed edges from the key vertex to the destination vertices. Output * Returns a boolean value `True` if there is at least one cycle in the graph, otherwise returns `False`. Constraints * The graph can contain up to 1000 nodes and 3000 edges. * There is no guarantee that the graph is connected. * The graph does not have to include all nodes in the range if there are no connections involving some nodes. Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\"], \\"C\\": [\\"A\\", \\"D\\"], \\"D\\": [] } print(has_cycle(graph)) # Output: True graph2 = { \\"A\\": [\\"B\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"E\\"], \\"D\\": [], \\"E\\": [] } print(has_cycle(graph2)) # Output: False ``` Notes * You may assume that each node name is unique and only consists of uppercase alphabets. * Utilize Depth-First Search (DFS) approach to detect cycles.","solution":"def has_cycle(graph): Returns True if the directed graph has a cycle, False otherwise. :param graph: Dict[str, List[str]] def visit(vertex): if vertex in temp: return True if vertex in perm: return False temp.add(vertex) for neighbor in graph.get(vertex, []): if visit(neighbor): return True temp.remove(vertex) perm.add(vertex) return False temp = set() perm = set() for node in graph: if visit(node): return True return False"},{"question":"Array Element Duplication Checker You are tasked with writing a function that determines whether an array of integers contains any duplicates. The function should be optimized for performance and handle large datasets efficiently. Requirements: 1. Create a function `contains_duplicates` that takes a list of integers as input. 2. The function should return `True` if any value appears at least twice in the array, and `False` if every element is distinct. 3. Implement the function to ensure it has a time complexity of O(n), where n is the number of elements in the list. Input: * A list of integers. Output: * A boolean value (`True` or `False`). Example: Input: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1] ``` Output: ```python True ``` Input: ```python arr = [10, 20, 30, 40, 50] ``` Output: ```python False ``` # Implementation Implement the following function: ```python def contains_duplicates(arr: list[int]) -> bool: Check if the array contains any duplicates. Parameters: arr (list[int]): A list of integers. Returns: bool: True if any integer appears at least twice, otherwise False. seen = set() for num in arr: if num in seen: return True seen.add(num) return False ```","solution":"def contains_duplicates(arr: list[int]) -> bool: Check if the array contains any duplicates. Parameters: arr (list[int]): A list of integers. Returns: bool: True if any integer appears at least twice, otherwise False. seen = set() for num in arr: if num in seen: return True seen.add(num) return False"},{"question":"# Quadratic Equation Solver Write a function that solves a quadratic equation based on the given coefficients. The quadratic equation has the form: [ ax^2 + bx + c = 0 ] Your function should return the real roots of the equation, if any. # Problem Description Using the coefficients provided as input, write a function `quadratic_solver` that calculates the roots of the quadratic equation and returns them as a tuple. # Requirements 1. If the quadratic equation has two real distinct roots, return both roots in a tuple `(root1, root2)` with the smaller root first. 2. If there is one real root (i.e., the discriminant is zero), return the root as a tuple containing one element `(root,)`. 3. If the equation does not have any real roots, return an empty tuple `()`. 4. If the given parameters are invalid (i.e., `a` equals 0), your function should raise a `ValueError` with the message: \\"Coefficient \'a\' must be non-zero\\". # Function Signature ```python def quadratic_solver(a: float, b: float, c: float) -> tuple: ``` # Input * `a` (float): The coefficient of ( x^2 ). * `b` (float): The coefficient of ( x ). * `c` (float): The constant term. # Output * Returns a tuple containing the real roots of the equation. The tuple can contain zero, one, or two elements. # Example ```python def quadratic_solver(a: float, b: float, c: float) -> tuple: >>> quadratic_solver(1, -3, 2) (1.0, 2.0) >>> quadratic_solver(1, 2, 1) (-1.0,) >>> quadratic_solver(1, 0, 1) () >>> quadratic_solver(0, 5, 10) Traceback (most recent call last): ... ValueError: Coefficient \'a\' must be non-zero import math if a == 0: raise ValueError(\\"Coefficient \'a\' must be non-zero\\") discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b - math.sqrt(discriminant)) / (2*a) root2 = (-b + math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2)) elif discriminant == 0: root = -b / (2*a) return (root,) else: return () ``` Make sure to use the provided function signature and return the real roots in the required format.","solution":"import math def quadratic_solver(a: float, b: float, c: float) -> tuple: Solves the quadratic equation ax^2 + bx + c = 0. Parameters: a (float): The coefficient of x^2. b (float): The coefficient of x. c (float): The constant term. Returns: tuple: The real roots of the equation. if a == 0: raise ValueError(\\"Coefficient \'a\' must be non-zero\\") discriminant = b**2 - 4*a*c if discriminant > 0: root1 = (-b - math.sqrt(discriminant)) / (2*a) root2 = (-b + math.sqrt(discriminant)) / (2*a) return (min(root1, root2), max(root1, root2)) elif discriminant == 0: root = -b / (2*a) return (root,) else: return ()"},{"question":"# Coding Question You are tasked to implement a function that simulates the calculation of the day of the week for a given date using Zeller\'s Congruence algorithm. Given a date in the format `YYYY-MM-DD`, your function should return the day of the week for that date. Function Signature ```python def day_of_week(date: str) -> str: pass ``` Input - `date` (str): The input date in the format \\"YYYY-MM-DD\\". Output - (str): The day of the week corresponding to the given date, with the first letter capitalized (e.g., \\"Monday\\", \\"Tuesday\\", etc.). Constraints - The input date will always be a valid date in the Gregorian calendar. - The date will be within the range of \\"1900-01-01\\" to \\"2100-12-31\\". Examples ```python >>> day_of_week(\\"2023-10-13\\") \'Friday\' >>> day_of_week(\\"2000-01-01\\") \'Saturday\' >>> day_of_week(\\"1999-12-31\\") \'Friday\' >>> day_of_week(\\"2030-05-21\\") \'Tuesday\' >>> day_of_week(\\"1900-01-01\\") \'Monday\' ``` Additional Notes - Zeller\'s Congruence is a well-known algorithm to compute the day of the week for any given date. The formula is as follows: ``` h = (q + ((13*(m + 1))/5) + K + (K//4) + (J//4) - 2*J) % 7 ``` where: - `q` is the day of the month - `m` is the month (3 = March, 4 = April, ..., 12 = December; January and February are counted as months 13 and 14 of the previous year) - `K` is the year of the century (i.e., year % 100) - `J` is the zero-based century (i.e., year // 100) - `h` is the day of the week (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday) - Special consideration should be given to dates in January and February, as they are treated as months 13 and 14 of the previous year in the algorithm.","solution":"def day_of_week(date: str) -> str: days_of_week = [ \\"Saturday\\", \\"Sunday\\", \\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\" ] year, month, day = map(int, date.split(\'-\')) if month < 3: # Treat January and February as months 13 and 14 of the previous year month += 12 year -= 1 K = year % 100 J = year // 100 h = (day + (13 * (month + 1)) // 5 + K + K // 4 + J // 4 + 5 * J) % 7 return days_of_week[h]"},{"question":"# Task You are given an array of integers, where each element represents the height of a vertical line drawn at the position of each index. These lines together form a histogram. You need to implement a function that finds the largest rectangle that can be formed by these lines within the histogram. The rectangle can only be formed by adjacent lines and must be fully enclosed by these lines. # Function Signature ```python def largest_rectangle_area(heights: list) -> int: pass ``` # Input * `heights` (list): A list of integers representing the heights of vertical lines in the histogram. # Output * Returns an integer representing the area of the largest rectangle that can be formed within the histogram. # Constraints * All heights are non-negative integers. * The histogram can have up to 100,000 lines. * Heights are between 0 and 100,000. # Example ```python heights = [2, 1, 5, 6, 2, 3] assert largest_rectangle_area(heights) == 10 ``` # Notes 1. The function should handle edge cases gracefully, such as when the histogram is empty or all heights are zero. 2. Think about efficient ways to solve this problem, aiming for an optimal time complexity solution. 3. Consider using a stack to keep track of the positions of the lines as you iterate through the histogram.","solution":"def largest_rectangle_area(heights: list) -> int: stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"# Question: Word Ladder Transformation Context In computational linguistics and natural language processing, a word ladder is a sequence of words where each word differs by only one letter from its predecessor. The goal is to transform a start word into an end word by changing one letter at a time, ensuring each intermediate word appears in a given dictionary of valid words. This problem has applications in AI for understanding transformations and pathfinding in graphs. Your task is to implement a function that finds the shortest transformation sequence from the start word to the end word using a dictionary of allowed words. If there is no such transformation, the function should return 0. Requirements Implement the following function: 1. `word_ladder(begin: str, end: str, word_list: List[str]) -> int`: * Input: - `begin` - The starting word (string). - `end` - The target word (string). - `word_list` - A list of valid words (list of strings). * Output: The length of the shortest transformation sequence, or `0` if no transformation is possible. Constraints - Each word in `word_list` has the same length as `begin` and `end`. - All characters are lowercase English letters. - The length of `word_list` does not exceed `10^4`. - The length of each word does not exceed `10`. Example ```python from collections import deque def word_ladder(begin, end, word_list): word_set = set(word_list) if end not in word_set: return 0 queue = deque([(begin, 1)]) while queue: word, length = queue.popleft() if word == end: return length for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in word_set: queue.append((next_word, length + 1)) word_set.remove(next_word) return 0 # Example usage: begin_word = \\"hit\\" end_word = \\"cog\\" word_list1 = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] word_list2 = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] print(word_ladder(begin_word, end_word, word_list1)) # Output: 5 (\\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\") print(word_ladder(begin_word, end_word, word_list2)) # Output: 0 (No valid transformation) ``` This question focuses on the traversal technique (BFS) in graph theory and string manipulation, consistent with the traversal and problem-solving skills highlighted in the first example. The constraints ensure that the algorithm handles both medium and upper limit cases efficiently.","solution":"from collections import deque from typing import List def word_ladder(begin: str, end: str, word_list: List[str]) -> int: word_set = set(word_list) if end not in word_set: return 0 queue = deque([(begin, 1)]) while queue: word, length = queue.popleft() if word == end: return length for i in range(len(word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = word[:i] + c + word[i+1:] if next_word in word_set: queue.append((next_word, length + 1)) word_set.remove(next_word) return 0"},{"question":"# Question: Convert Binary Search Tree to Sorted Doubly Linked List You are given a binary search tree (BST). Implement a function that converts it into a sorted doubly linked list in place. The nodes in the doubly linked list should follow the same order as an in-order traversal of the BST. Function Signature: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class DoublyListNode: def __init__(self, x): self.val = x self.prev = None self.next = None def bst_to_doubly_linked_list(root: TreeNode) -> DoublyListNode: pass ``` Input: * `root`: A `TreeNode` which is the root of the binary search tree. Output: * Returns the head of the doubly linked list (`DoublyListNode`). Constraints: * Node values are integers. * The BST may be empty. Example: ```python # Helper function to create a sample BST def create_sample_bst(): root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) return root # Example usage root = create_sample_bst() head = bst_to_doubly_linked_list(root) # Verify the conversion assert head.val == 1 assert head.next.val == 2 assert head.next.next.val == 3 assert head.next.next.next.val == 4 assert head.next.next.next.next.val == 5 assert head.next.prev.val == 1 assert head.next.next.prev.val == 2 assert head.next.next.next.prev.val == 3 assert head.next.next.next.next.prev.val == 4 ``` Notes: * Consider both left and right traversal when handling tree nodes. * Ensure that the doubly linked list nodes correctly reference both previous and next nodes. * Evaluate edge cases such as an empty BST or a BST with only one node.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class DoublyListNode: def __init__(self, x): self.val = x self.prev = None self.next = None def bst_to_doubly_linked_list(root: TreeNode) -> DoublyListNode: if root is None: return None def in_order_traversal(node): nonlocal last_node, head if not node: return in_order_traversal(node.left) if last_node: dl_node = DoublyListNode(node.val) last_node.next = dl_node dl_node.prev = last_node last_node = dl_node else: last_node = head = DoublyListNode(node.val) in_order_traversal(node.right) last_node = head = None in_order_traversal(root) return head"},{"question":"# Problem Statement You are working on a data analytics project and need to process a large dataset of numerical values. Your task is to implement a function that calculates the moving average of these values over a specified window size. # Requirements & Constraints 1. **Function Name**: `moving_average` 2. **Input**: A list of integers or floats `data` and a single integer `window_size` (1 <= window_size <= len(data)). 3. **Output**: A list of floats, where each float is the average of the previous `window_size` elements in `data`, including the current element. 4. **Performance**: Your function must run efficiently and handle large datasets (e.g., lists with up to 100,000 elements). 5. **Error Handling**: - Raise `ValueError` if `window_size` is less than 1 or greater than the length of `data`. - Raise `TypeError` if `data` is not a list or if `window_size` is not an integer. # Additional Information You are encouraged to use optimized algorithms and data structures to ensure that your solution is efficient. Avoid recomputing the sum repeatedly to reduce the complexity. # Example Usage ```python def moving_average(data, window_size): # Your implementation goes here # Example inputs and outputs print(moving_average([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)) # Output: [2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0] print(moving_average([10, 20, 30, 40], 2)) # Output: [15.0, 25.0, 35.0] ``` # Hints - Consider using a sliding window approach to avoid recomputing the sum for every element. - Track the current sum of the window and adjust it as you move the window forward. - Think about the edge cases, such as when the window size is equal to the length of the list.","solution":"def moving_average(data, window_size): if not isinstance(data, list): raise TypeError(\\"data must be a list\\") if not isinstance(window_size, int): raise TypeError(\\"window_size must be an integer\\") if window_size < 1 or window_size > len(data): raise ValueError(\\"window_size must be between 1 and the length of data\\") moving_averages = [] window_sum = sum(data[:window_size]) moving_averages.append(window_sum / window_size) for i in range(window_size, len(data)): window_sum += data[i] - data[i - window_size] moving_averages.append(window_sum / window_size) return moving_averages"},{"question":"# Problem Statement You are tasked with designing a memory-efficient file system that includes a method for recognizing palindromic file names. A palindromic file name is a string that reads the same forward and backward. This functionality is vital for organizing and quickly retrieving files with specific naming conventions. Write a function `is_palindromic_filename` that determines whether a given file name is a palindrome. The function should be case-insensitive and ignore any non-alphanumeric characters. # Function Signature ```python def is_palindromic_filename(filename: str) -> bool: ``` # Input * `filename` (str): A string representing the file name to be checked. # Output * Returns a boolean value: `True` if the file name is a palindrome, `False` otherwise. # Constraints * The function must raise a `TypeError` with the message \\"Input must be a string\\" for non-string inputs. * The function must perform the palindrome check in a case-insensitive manner and ignore non-alphanumeric characters. # Examples ```python >>> is_palindromic_filename(\\"redivider\\") True >>> is_palindromic_filename(\\"deified\\") True >>> is_palindromic_filename(\\"hello.txt\\") False >>> is_palindromic_filename(\\"501abccba105\\") True >>> is_palindromic_filename(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindromic_filename(12345) Traceback (most recent call last): ... TypeError: Input must be a string >>> is_palindromic_filename([\\"palindrome\\"]) Traceback (most recent call last): ... TypeError: Input must be a string ``` # Hints * Use string methods to clean and prepare the file name for palindrome checking. * Consider utilizing Python\'s string capabilities to simplify case conversion and character filtering.","solution":"def is_palindromic_filename(filename: str) -> bool: Determines whether a given file name is a palindrome. Args: filename (str): A string representing the file name to be checked. Returns: bool: True if the file name is a palindrome, False otherwise. Raises: TypeError: If the input is not a string. if not isinstance(filename, str): raise TypeError(\\"Input must be a string\\") # Normalize the string by removing non-alphanumeric characters and converting to lowercase normalized_filename = \'\'.join(ch.lower() for ch in filename if ch.isalnum()) # Check if the normalized string is a palindrome return normalized_filename == normalized_filename[::-1]"},{"question":"# Question: Counting Minimum Number of Coin Flips In this problem, you are given a sequence of \'H\' (heads) and \'T\' (tails) representing a row of coins. Your goal is to determine the minimum number of coin flips required to make all the coins show the same side (either all heads or all tails). **Task**: Write a Python function that calculates the minimum number of flips required to achieve this. Input: - A string `coins` consisting of \'H\' and \'T\' characters, where `1 <= len(coins) <= 10^5`. Output: - An integer representing the minimum number of flips required to make all the coins display the same side. Function Signature: ```python def min_flips_to_uniformity(coins: str) -> int: pass ``` Constraints: - The function should efficiently handle large input sizes up to 100,000 characters. - Only one pass through the string is allowed to keep the solution optimal. Example: ```python >>> min_flips_to_uniformity(\\"HHTHTTH\\") 3 >>> min_flips_to_uniformity(\\"HHHH\\") 0 >>> min_flips_to_uniformity(\\"TTTTT\\") 0 >>> min_flips_to_uniformity(\\"HTHTHTHT\\") 4 ``` **Hint**: Count the number of \'H\'s and \'T\'s and use the smaller count to determine the minimum flips.","solution":"def min_flips_to_uniformity(coins: str) -> int: Returns the minimum number of flips required to make all coins show the same side. count_H = coins.count(\'H\') count_T = len(coins) - count_H # Total coins minus heads count gives tails count return min(count_H, count_T)"},{"question":"# Coding Assessment Question Implementation of a K-means Clustering Algorithm with a Silhouette Score Evaluation You need to implement the K-means clustering algorithm and provide an additional method to evaluate the quality of the clustering using the Silhouette score. Task 1. Implement the `fit` method to cluster the given dataset into `k` clusters using the K-means algorithm. 2. Implement the `silhouette_score` method to assess the quality of the clusters. The silhouette score ranges from -1 to 1, where a higher value indicates better clustering. Additional Guidelines - K-means Algorithm: - Randomly initialize centroids. - Assign points to the nearest centroid. - Update centroids by computing the mean of assigned points. - Repeat until convergence or for a fixed number of iterations. Function Signatures and Expected Behavioral Outline ```python class KMeansClustering: def __init__(self, k, max_iterations=300): self.k = k self.max_iterations = max_iterations def fit(self, data): # Implement the K-means clustering algorithm pass def predict(self, data_point): # Predict the closest cluster for a data point pass def silhouette_score(self, data): # Compute the silhouette score of the current clustering pass ``` Input Examples and Output Expectations ```python # Sample input dataset: data = np.array([[1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0], [8.0, 2.0], [10.0, 2.0], [9.0, 3.0]]) # Initialize and fit the K-means clustering model kmeans = KMeansClustering(k=3) kmeans.fit(data) # Predict the cluster for a new data point prediction = kmeans.predict([0.5, 0.5]) print(prediction) # Evaluate the quality of clustering score = kmeans.silhouette_score(data) print(score) ``` - **Constraints**: - The number of clusters `k` should be an integer between 2 and 10. - The input data should be a 2-dimensional numpy array where each row represents a data point. - The maximum number of iterations should be an integer between 100 and 1000. - **Performance Requirements**: - Ensure the algorithm converges within the given maximum number of iterations. - The silhouette score should accurately reflect the quality of the clustering, with values closer to 1 indicating well-clustered data.","solution":"import numpy as np from scipy.spatial import distance class KMeansClustering: def __init__(self, k, max_iterations=300): self.k = k self.max_iterations = max_iterations self.centroids = None self.labels = None def fit(self, data): n_samples, n_features = data.shape # Randomly initialize centroids self.centroids = data[np.random.choice(n_samples, self.k, replace=False)] for _ in range(self.max_iterations): # Assign clusters based on closest centroid distances = np.array([distance.cdist(data, [centroid]) for centroid in self.centroids]) self.labels = np.argmin(distances, axis=0).flatten() # Update centroids new_centroids = np.array([data[self.labels == i].mean(axis=0) for i in range(self.k)]) # Check for convergence (no change in centroids) if np.all(new_centroids == self.centroids): break self.centroids = new_centroids def predict(self, data_point): distances = [distance.euclidean(data_point, centroid) for centroid in self.centroids] return np.argmin(distances) def silhouette_score(self, data): if self.labels is None: raise ValueError(\\"Fit the model before computing the silhouette score.\\") n_samples = data.shape[0] silhouette_scores = np.zeros(n_samples) for i in range(n_samples): same_cluster = data[self.labels == self.labels[i]] other_clusters = data[self.labels != self.labels[i]] if len(same_cluster) > 1: a = np.mean(distance.cdist([data[i]], same_cluster)[0]) # mean distance to own cluster else: a = 0 # If there\'s only one sample in the cluster, a is 0 b = np.min([np.mean(distance.cdist([data[i]], data[self.labels == label])[0]) for label in range(self.k) if label != self.labels[i]]) # min mean distance to other clusters silhouette_scores[i] = (b - a) / max(a, b) return np.mean(silhouette_scores)"},{"question":"You are tasked with creating a functionality to simplify a given file path into its canonical form, similar to how operating systems handle directory navigation. A canonical path is an absolute path that does not contain any unnecessary components such as `\\".\\"`, `\\"..\\"`, or multiple slashes. # Problem Statement Write a function `simplify_path` that takes a string representing a Unix-style file path and returns the simplified canonical path. # Function Signature ```python def simplify_path(path: str) -> str: ``` # Input - `path`: A string representing a Unix-style file path. # Output - A string representing the simplified canonical path. # Constraints - The length of `path` will be in the range `[1, 3000]`. - The `path` will be a non-empty string consisting of English letters, digits, period `\'.\'`, slash `\'/\'`, and/or underscore `\'_\'`. - The `path` will always start with a slash `/`. - Multiple consecutive slashes are considered a single slash. # Examples 1. `simplify_path(\\"/home/\\")` should return `\\"/home\\"`. 2. `simplify_path(\\"/../\\")` should return `\\"/\\"`. 3. `simplify_path(\\"/home//foo/\\")` should return `\\"/home/foo\\"`. 4. `simplify_path(\\"/a/./b/../../c/\\")` should return `\\"/c\\"`. # Notes - `.` represents the current directory and can be ignored. - `..` represents moving up to the parent directory. It should remove the last valid directory from the path unless it\'s already at the root level. - Consecutive slashes should be handled as a single slash. - Ensure to handle edge cases such as paths that attempt to navigate above the root directory. # Hints 1. Use a stack to keep track of the directories in the canonical path. 2. Split the input path by slashes and iterate over each component. 3. Handle special components `\\".\\"` and `\\"..\\"` appropriately to adjust the stack\'s state. 4. Join the stack contents with slashes to form the final canonical path.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style file path into its canonical form. Parameters: path (str): A string representing a Unix-style file path. Returns: str: The simplified canonical path. # Split the path by \'/\' and initialize a stack parts = path.split(\'/\') stack = [] # Iterate over each part for part in parts: if part == \'\' or part == \'.\': # Skip any empty part or current directory symbols continue elif part == \'..\': # Move up a directory (if stack is not empty) if stack: stack.pop() else: # Any valid directory name, push on to the stack stack.append(part) # Join the stack to form the canonical path, starting with a \'/\' return \'/\' + \'/\'.join(stack)"},{"question":"**Problem Description**: You are tasked with implementing a function that determines the number of distinct ways to climb a staircase with `n` steps, given that the climber can take either 1, 2, or 3 steps at a time. Your solution should be efficient and handle larger values of `n`. **Function Signature**: ```python def count_ways_to_climb(n: int) -> int: Returns the number of distinct ways to climb a staircase of `n` steps. :param n: Integer, the number of steps in the staircase :return: Integer, the number of ways to climb the staircase ``` **Input and Output**: - **Input**: An integer `n` (1 ≤ n ≤ 10^4), representing the number of steps in the staircase. - **Output**: An integer that is the number of distinct ways to climb the staircase. **Constraints**: - The function should handle values of `n` up to 10,000. **Example**: ```python assert count_ways_to_climb(3) == 4 assert count_ways_to_climb(4) == 7 assert count_ways_to_climb(10) == 274 ``` **Requirements**: - You should implement a dynamic programming approach to solve the problem. - Aim for an O(n) solution in terms of time complexity. - Minimize memory usage to O(1) if possible. **Scenario**: You are designing a fitness application where users can set climbing goals. The app provides statistics on different strategies for reaching these goals based on varying step sizes. For instance, users might be interested in knowing how many unique ways there are to achieve their daily step goal using different step combinations. **Note**: Ensure your implementation is efficient and can handle the upper limits as described.","solution":"def count_ways_to_climb(n: int) -> int: Returns the number of distinct ways to climb a staircase of `n` steps. :param n: Integer, the number of steps in the staircase :return: Integer, the number of ways to climb the staircase if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Initialize base values for n=0, n=1, and n=2 a, b, c = 1, 1, 2 for i in range(3, n + 1): current = a + b + c a, b, c = b, c, current return c"},{"question":"# Coding Problem: Group Elements by Frequency You are given a list of integers. Your task is to write a function that groups the elements by their frequency in descending order. If two numbers have the same frequency, they should be ordered by their value in ascending order. # Function Signature ```python def group_by_frequency(arr: list[int]) -> list[list[int]]: ... ``` # Input * `arr` - A list of integers. # Output * Returns a list of lists where each sublist contains the elements of the input list grouped in descending order of their frequency. # Constraints * The list can have up to `10^5` elements. * The integers in the list can range from `-10^9` to `10^9`. # Function Behavior * Edge cases like an empty list should return an empty list. # Example ```python >>> group_by_frequency([1, 3, 2, 2, 4, 3, 3, 1]) [[3, 3, 3], [1, 1], [2, 2], [4]] >>> group_by_frequency([4, 4, 4, 1, 2, 2, 3]) [[4, 4, 4], [2, 2], [1], [3]] >>> group_by_frequency([]) [] ``` # Hints * You may use Python\'s `collections.Counter` to get the frequency of each element. * Consider sorting first by frequency and then by the element\'s value as a tie-breaker.","solution":"from collections import Counter def group_by_frequency(arr: list[int]) -> list[list[int]]: Groups elements of the input list by their frequency in descending order. If two numbers have the same frequency, they are ordered by their value in ascending order. if not arr: return [] frequency_count = Counter(arr) grouped_elements = sorted(frequency_count.items(), key=lambda x: (-x[1], x[0])) result = [] for num, freq in grouped_elements: result.append([num] * freq) return result"},{"question":"# Problem Statement You are given a list of strings representing binary numbers. You need to implement a function that finds the longest common prefix (LCP) among these binary strings. If there is no common prefix, the function should return an empty string. # Function Signature ```python def find_longest_common_prefix(binaries: list) -> str: Finds the longest common prefix among a list of binary strings. :param binaries: A list of binary strings. :return: A string representing the longest common prefix. :raises ValueError: If the input list is empty. :raises TypeError: If the input is not a list of binary strings. ``` # Input * `binaries` (list): A list of strings, each representing a binary number. The list must contain only valid binary strings (composed of \'0\'s and \'1\'s). Length of the list ranges from (1) to (1000). # Output * `str`: A string representing the longest common prefix among the input binary strings. # Constraints 1. Each binary string in the input list consists only of \'0\'s and \'1\'s. 2. The length of each binary string ranges from (1) to (1000). 3. The input list is non-empty. 4. If the input list is empty, raise a `ValueError`. 5. If the input is not a list of binary strings, raise a `TypeError`. # Example ```python assert find_longest_common_prefix([\\"110\\", \\"111\\", \\"1101\\", \\"1100\\"]) == \\"11\\" assert find_longest_common_prefix([\\"1010\\", \\"1011\\", \\"1001\\", \\"101\\"]) == \\"10\\" assert find_longest_common_prefix([\\"0\\", \\"1\\"]) == \\"\\" assert find_longest_common_prefix([\\"1110\\", \\"1111\\"]) == \\"111\\" assert find_longest_common_prefix([\\"1000\\", \\"1000\\", \\"1000\\", \\"1000\\"]) == \\"1000\\" assert find_longest_common_prefix([\\"10\\", \\"10\\", \\"\\"]) == \\"\\" ``` # Detailed Requirements & Constraints: * The function should validate the input list: - If the list is empty, raise a `ValueError`. - If the list contains any non-binary strings or non-strings, raise a `TypeError`. # Performance Considerations Your solution should be efficient enough to handle the maximum input constraints in a reasonable timeframe. Specifically, consider minimizing the number of comparisons performed. # Additional Notes The longest common prefix for a single string is the string itself. Ensure your implementation adheres to this convention.","solution":"def find_longest_common_prefix(binaries): Finds the longest common prefix among a list of binary strings. :param binaries: A list of binary strings. :return: A string representing the longest common prefix. :raises ValueError: If the input list is empty. :raises TypeError: If the input is not a list of binary strings. if not binaries: raise ValueError(\\"The input list is empty\\") for binary in binaries: if not isinstance(binary, str) or not all(char in \'01\' for char in binary): raise TypeError(\\"The input list must contain only binary strings\\") if len(binaries) == 1: return binaries[0] # Sort the binary strings binaries.sort() # The longest common prefix of the whole list cannot be longer than # the LCP of the first and last string (because the list is sorted) first = binaries[0] last = binaries[-1] i = 0 while i < len(first) and i < len(last) and first[i] == last[i]: i += 1 return first[:i]"},{"question":"# Complex Number Arithmetic Objective Create a `ComplexNumber` class to handle arithmetic operations on complex numbers. The class should support addition, subtraction, multiplication, and division of complex numbers, along with functionality to convert to polar form and compute the conjugate. Instructions 1. **Class Definition**: Write a class `ComplexNumber` that: - Initializes with real and imaginary parts. - Implements methods for basic arithmetic operations between complex numbers. - Provides methods to convert to polar form and compute the conjugate of the complex number. 2. **Class Methods**: - `__init__(self, real: float, imag: float) -> None`: Constructor to initialize the complex number. - `__add__(self, other: \'ComplexNumber\') -> \'ComplexNumber\'`: Adds two complex numbers. - `__sub__(self, other: \'ComplexNumber\') -> \'ComplexNumber\'`: Subtracts two complex numbers. - `__mul__(self, other: \'ComplexNumber\') -> \'ComplexNumber\'`: Multiplies two complex numbers. - `__truediv__(self, other: \'ComplexNumber\') -> \'ComplexNumber\'`: Divides two complex numbers. - `to_polar(self) -> tuple[float, float]`: Converts the complex number to polar coordinates (returns magnitude and angle in radians). - `conjugate(self) -> \'ComplexNumber\'`: Returns the conjugate of the complex number. 3. **Arithmetic Operations**: - Implement the arithmetic operations considering standard complex number rules. - Ensure division by zero is handled appropriately by raising a `ZeroDivisionError`. # Example Here\'s an example of how your `ComplexNumber` class can be used: ```python c1 = ComplexNumber(3, 4) c2 = ComplexNumber(1, -2) c3 = c1 + c2 c4 = c1 - c2 c5 = c1 * c2 try: c6 = c1 / c2 except ZeroDivisionError: c6 = \\"Division by zero is not allowed\\" polar_form = c1.to_polar() conjugate_c1 = c1.conjugate() print(f\\"c1 + c2 = {c3}\\") print(f\\"c1 - c2 = {c4}\\") print(f\\"c1 * c2 = {c5}\\") print(f\\"c1 / c2 = {c6}\\") print(f\\"c1 in polar form: magnitude = {polar_form[0]}, angle = {polar_form[1]} radians\\") print(f\\"Conjugate of c1: {conjugate_c1}\\") ``` Constraints - Real and imaginary parts can range from `-1000` to `1000`. - Arithmetic operations should handle edge cases such as very small or very large values gracefully. - Ensure the polar conversion and conjugate computation are accurate within an acceptable numerical error range.","solution":"import math class ComplexNumber: def __init__(self, real: float, imag: float) -> None: self.real = real self.imag = imag def __add__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real + other.real, self.imag + other.imag) def __sub__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': return ComplexNumber(self.real - other.real, self.imag - other.imag) def __mul__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': real_part = self.real * other.real - self.imag * other.imag imag_part = self.real * other.imag + self.imag * other.real return ComplexNumber(real_part, imag_part) def __truediv__(self, other: \'ComplexNumber\') -> \'ComplexNumber\': if other.real == 0 and other.imag == 0: raise ZeroDivisionError(\\"division by zero\\") denominator = other.real**2 + other.imag**2 real_part = (self.real * other.real + self.imag * other.imag) / denominator imag_part = (self.imag * other.real - self.real * other.imag) / denominator return ComplexNumber(real_part, imag_part) def to_polar(self) -> tuple[float, float]: magnitude = math.sqrt(self.real**2 + self.imag**2) angle = math.atan2(self.imag, self.real) return magnitude, angle def conjugate(self) -> \'ComplexNumber\': return ComplexNumber(self.real, -self.imag) def __repr__(self): return f\\"ComplexNumber(real={self.real}, imag={self.imag})\\""},{"question":"# Coding Assessment: Matrix Transposition Context Matrix transposition is a fundamental operation in linear algebra where the rows of a given matrix become its columns and vice versa. This operation is useful in various numerical computations and data manipulations. Problem Description Implement the function `transpose_matrix(matrix: list[list[int]]) -> list[list[int]]` that transposes a given 2D matrix. The function should handle matrices of varying dimensions efficiently. Input `matrix` is a list of lists of integers, where each inner list represents a row of the matrix. The number of rows and columns can vary. Output A new matrix represented by a list of lists of integers, where the rows of the input matrix are transformed into columns in the output matrix. Constraints - The input matrix will have at least 1 row and 1 column. - All rows in the input matrix will have the same number of columns. - The function should not modify the input matrix, but return a new transposed matrix. Examples ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[1, 2], [3, 4], [5, 6]]) [[1, 3, 5], [2, 4, 6]] >>> transpose_matrix([[1]]) [[1]] >>> transpose_matrix([[1, 2, 3], [4, 5, 6]]) [[1, 4], [2, 5], [3, 6]] ```","solution":"def transpose_matrix(matrix): Transposes the given 2D matrix. Args: matrix (list of list of int): The input 2D matrix to be transposed. Returns: list of list of int: The transposed matrix. return [list(row) for row in zip(*matrix)]"},{"question":"# Objective: Design a function to convert a given binary tree into a doubly linked list in-place. The doubly linked list should be arranged in the same order as an in-order traversal of the binary tree. # Task: Implement a function that transforms the binary tree into a doubly linked list. Each node in the doubly linked list should contain an additional pointer to its previous and next node, respectively. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyLinkedNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def tree_to_doubly_linked_list(root: TreeNode) -> DoublyLinkedNode: pass ``` # Input Format: * A `TreeNode` object representing the root of the binary tree. # Output Format: * The function should return the head of the doubly linked list (`DoublyLinkedNode`). # Constraints: 1. The number of nodes `n` in the binary tree is such that `0 ≤ n ≤ 10^4`. 2. The value of each node is an integer within the range `-10^5 ≤ val ≤ 10^5`. # Performance Requirements: Your solution should aim for O(n) time complexity and O(h) space complexity, where `n` is the number of nodes and `h` is the height of the tree. # Example: ```python # Given binary tree: # 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(5) root.left.left = TreeNode(1) root.left.right = TreeNode(3) head = tree_to_doubly_linked_list(root) # The output doubly linked list should be: 1 <-> 2 <-> 3 <-> 4 <-> 5 # Print the values of the doubly linked list from head to end: current = head while current: print(current.val, end=\\" <-> \\" if current.next else \\"\\") current = current.next # Output should be: 1 <-> 2 <-> 3 <-> 4 <-> 5 ``` # Additional Notes: - Ensure to handle edge cases such as the tree being empty. - Thoroughly test the conversion to confirm the correct order and structure of the doubly linked list is achieved.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class DoublyLinkedNode: def __init__(self, val=0, prev=None, next=None): self.val = val self.prev = prev self.next = next def tree_to_doubly_linked_list(root: TreeNode) -> DoublyLinkedNode: if not root: return None def inorder_traverse(node): nonlocal last, head if node: # Traverse left subtree inorder_traverse(node.left) # Convert the TreeNode to DoublyLinkedNode dll_node = DoublyLinkedNode(node.val) if last: # Link the previous node with current node in DLL last.next = dll_node dll_node.prev = last else: # This node will be the head in DLL head = dll_node last = dll_node # Update the last node # Traverse right subtree inorder_traverse(node.right) last, head = None, None inorder_traverse(root) return head"},{"question":"# Binary Tree Traversal Assessment **Context**: Binary tree traversal is a fundamental concept in computer science that involves visiting all the nodes in a tree data structure, exactly once, in a specified order. The common types of traversals include Inorder, Preorder, and Postorder traversal. **Task**: Implement the `binary_tree_traversal` function that, given the root node of a binary tree, returns three lists representing the Inorder, Preorder, and Postorder traversal sequences of the tree. Input * `root`: The root node of the binary tree. Output * A tuple of three lists: `(inorder_list, preorder_list, postorder_list)`. Each list contains the node values in the respective traversal order. Constraints * The tree contains between 1 and 10,000 nodes. * Each node has an integer value. * The tree is a plain binary tree (nodes can have left and/or right children or none). Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example tree: # 1 # / # 2 3 # / #4 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) # Expected Output: # Inorder Traversal: [4, 2, 5, 1, 3] # Preorder Traversal: [1, 2, 4, 5, 3] # Postorder Traversal: [4, 5, 2, 3, 1] inorder_list, preorder_list, postorder_list = binary_tree_traversal(root) print(inorder_list) # [4, 2, 5, 1, 3] print(preorder_list) # [1, 2, 4, 5, 3] print(postorder_list) # [4, 5, 2, 3, 1] ``` Instruction Fill in the `binary_tree_traversal` function: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_traversal(root): # Your implementation goes here pass ``` **Guidelines** - Implement traversal functions in a clean, modular manner to keep the code readable. - Ensure your functions handle edge cases such as empty trees or trees with only one node. - Aim for efficient solutions with linear time complexity in terms of the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def binary_tree_traversal(root): def inorder(node): return inorder(node.left) + [node.val] + inorder(node.right) if node else [] def preorder(node): return [node.val] + preorder(node.left) + preorder(node.right) if node else [] def postorder(node): return postorder(node.left) + postorder(node.right) + [node.val] if node else [] return (inorder(root), preorder(root), postorder(root))"},{"question":"# Coding Assessment Question Problem Statement Imagine you are tasked with developing an optimized sorting algorithm called \\"QuickSort++\\" that improves the standard QuickSort algorithm by incorporating two main enhancements: 1. **Median-of-Three Pivot Selection**: Instead of picking the first element as the pivot, select the median of the first, middle, and last elements as the pivot. 2. **Insertion Sort for Small Subarrays**: For subarrays smaller than a certain threshold (e.g., 10 elements), use Insertion Sort instead of recursing. Implement the function `quicksort_plus_plus` which leverages these enhancements to sort an input list of integers. Function Signature ```python def quicksort_plus_plus(array: list[int], threshold: int = 10) -> list[int]: pass ``` Input - `array (list[int])`: A list of integers to be sorted. - `threshold (int)`: The size below which Insertion Sort will be used instead of QuickSort. Default value is 10. Output - Returns a list of integers representing the sorted order of the input list. Constraints - The input list `array` will contain at most 10^5 elements. - All elements in `array` will be integers within the range of -10^9 to 10^9. Example ```python input_array = [3, 6, 8, 10, 1, 2, 1] sorted_array = quicksort_plus_plus(input_array, threshold=5) print(f\\"Sorted Array: {sorted_array}\\") ``` Expected Output: ``` Sorted Array: [1, 1, 2, 3, 6, 8, 10] ``` --- Notes 1. Implement the Median-of-Three Pivot Selection method in the QuickSort algorithm for better pivot choice in reducing unbalanced partitions. 2. Incorporate Insertion Sort for small subarrays to reduce overhead from recursive calls, as insertion sort performs well on small, partially sorted arrays. 3. Ensure the implementation handles edge cases such as an empty list and a list with all identical elements. ---","solution":"def quicksort_plus_plus(array, threshold=10): Enhanced QuickSort algorithm with median-of-three pivot selection and insertion sort for small subarrays. def insertion_sort(arr, left, right): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def median_of_three(arr, low, mid, high): if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] return arr[mid] def quicksort(arr, low, high): if high - low <= threshold: insertion_sort(arr, low, high) else: mid = (low + high) // 2 pivot = median_of_three(arr, low, mid, high) pivot_index = arr.index(pivot, low, high + 1) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] p = partition(arr, low, high) quicksort(arr, low, p - 1) quicksort(arr, p + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 quicksort(array, 0, len(array) - 1) return array"},{"question":"**Problem Statement: Unique Words Count** You are given a large text file that contains multiple lines of text. Your task is to calculate the total number of unique words in the file. A word is defined as a consecutive sequence of alphabetic characters, regardless of the case (e.g., `Word`, `word` and `WORD` are considered the same word). # Detailed Steps: 1. **Read Data**: Read the entire content of the file named `text.txt`. 2. **Normalize Case**: Convert all characters in the text to lower case to ensure case insensitivity. 3. **Extract Words**: Extract words from the text. Words are defined as consecutive sequences of alphabetic characters. 4. **Count Unique Words**: Keep track of all unique words and count the total number of unique words. # Constraints: - The file `text.txt` will be present in the same directory as the script. - The text may include punctuations and other special characters which should be ignored. - Assume the file size allows for processing within a reasonable time frame and memory usage. # Function Signature: ```python def unique_words_count(file_path: str) -> int: Calculate the total number of unique words in the provided file. :param file_path: A string representing the path to the file containing text. :return: The total number of unique words. ``` # Input: - `file_path`: A string representing the relative or absolute path to the `text.txt` file. # Output: - An integer representing the total number of unique words. # Example: Assuming the file `text.txt` contains: ``` Hello, world! This is a test. A simple test. ``` After normalization and word extraction: - Words: `[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"a\\", \\"simple\\", \\"test\\"]` - Unique Words: `[\\"hello\\", \\"world\\", \\"this\\", \\"is\\", \\"a\\", \\"test\\", \\"simple\\"]` Total Unique Words: `7` **So the function should return `7`.** # Implementation: Implement the `unique_words_count` function using the provided guidelines.","solution":"import re def unique_words_count(file_path: str) -> int: Calculate the total number of unique words in the provided file. :param file_path: A string representing the path to the file containing text. :return: The total number of unique words. unique_words = set() with open(file_path, \'r\') as file: for line in file: # Normalize the line to lower case line = line.lower() # Extract words using regular expression to match alphabetic sequences words = re.findall(r\'b[a-z]+b\', line) # Add words to the set of unique words unique_words.update(words) return len(unique_words)"},{"question":"# Sorting and Filtering Students by GPA You are provided with a class `Student` that represents a student with attributes: `name`, `student_id`, and `gpa`. Your task is to implement a class `StudentManager` that can manage a list of students by providing the following functionalities: 1. **Add Students**: * Implement a method `add_student` that accepts a `Student` object and adds it to the student list. 2. **Filter Students by GPA**: * Implement a method `filter_students_by_gpa` that accepts a minimum GPA and returns a list of students having a GPA equal to or higher than the specified minimum GPA. 3. **Sort Students by GPA**: * Implement a method `sort_students_by_gpa` that returns the list of students sorted by GPA in descending order. If two students have the same GPA, they should be sorted by `student_id` in ascending order. **Input**: - For adding a student: A `Student` object. - For filtering by GPA: A float `min_gpa`. - For sorting by GPA: No additional input. **Output**: - For adding a student: No output. - For filtering by GPA: A list of `Student` objects filtered by the specified GPA. - For sorting by GPA: A list of `Student` objects sorted by GPA. **Performance Requirements**: - Ensure the operations are efficient in terms of time complexity. Adding a student should be O(1) on average. - Filtering and sorting operations should not exceed O(n log n) where n is the number of students. **Constraints**: - A student\'s GPA ranges from 0.0 to 4.0. - Student names and IDs are non-empty strings. - Assume no duplicate `student_id`s are added to the list. **Example Usage**: ```python class Student: def __init__(self, name, student_id, gpa): self.name = name self.student_id = student_id self.gpa = gpa def __repr__(self): return f\\"Student(name={self.name}, student_id={self.student_id}, gpa={self.gpa})\\" class StudentManager: def __init__(self): self.students = [] def add_student(self, student): self.students.append(student) def filter_students_by_gpa(self, min_gpa): return [student for student in self.students if student.gpa >= min_gpa] def sort_students_by_gpa(self): return sorted(self.students, key=lambda student: (-student.gpa, student.student_id)) # Example Usage manager = StudentManager() manager.add_student(Student(\\"Alice\\", \\"S001\\", 3.5)) manager.add_student(Student(\\"Bob\\", \\"S002\\", 2.8)) manager.add_student(Student(\\"Charlie\\", \\"S003\\", 3.5)) manager.add_student(Student(\\"Dave\\", \\"S004\\", 3.8)) high_gpa_students = manager.filter_students_by_gpa(3.0) print(high_gpa_students) # Should print students with GPA >= 3.0 sorted_students = manager.sort_students_by_gpa() print(sorted_students) # Should print students sorted by GPA in descending order ``` Write the implementation of the `StudentManager` class with the specified functionalities.","solution":"class Student: def __init__(self, name, student_id, gpa): self.name = name self.student_id = student_id self.gpa = gpa def __repr__(self): return f\\"Student(name={self.name}, student_id={self.student_id}, gpa={self.gpa})\\" class StudentManager: def __init__(self): self.students = [] def add_student(self, student): self.students.append(student) def filter_students_by_gpa(self, min_gpa): return [student for student in self.students if student.gpa >= min_gpa] def sort_students_by_gpa(self): return sorted(self.students, key=lambda student: (-student.gpa, student.student_id))"},{"question":"# Context You are developing a program to find all unique combinations of numbers that sum up to a specific target sum, using a given set of integers. Each number in the input list can be used multiple times in the combination. # Task Implement a function `find_combinations(nums: List[int], target: int) -> List[List[int]]` that returns all unique combinations where the numbers sum to the target. The same number from the input list can be chosen multiple times to form a combination, and the order of the combinations in the output does not matter. # Function Signature ```python def find_combinations(nums: List[int], target: int) -> List[List[int]]: pass ``` # Input - `nums`: A list of distinct integers. - `target`: An integer representing the target sum. # Output - A list of lists, where each list is a unique combination of numbers that add up to the target sum. # Constraints - The input list `nums` will have at most 20 elements. - The integers in `nums` will be unique and positive. - The target integer will be a positive integer. # Performance Requirements - The solution should efficiently produce all unique combinations. # Example Example 1: ```python >>> find_combinations([2,3,6,7], 7) [[7], [2,2,3]] ``` Example 2: ```python >>> find_combinations([2,3,5], 8) [[2,2,2,2], [2,3,3], [3,5]] ``` Example 3: ```python >>> find_combinations([2], 1) [] ``` # Notes - You can use a recursive backtracking approach to explore all potential combinations. - Remember to sort the input list initially to generate combinations in a non-decreasing order, which will help in avoiding duplicates. - Ensure that the solution lists elements in non-decreasing order in the final output.","solution":"from typing import List def find_combinations(nums: List[int], target: int) -> List[List[int]]: nums.sort() result = [] def backtrack(combination, start, remain): if remain == 0: result.append(list(combination)) return for i in range(start, len(nums)): if nums[i] > remain: break combination.append(nums[i]) backtrack(combination, i, remain - nums[i]) combination.pop() backtrack([], 0, target) return result"},{"question":"# Parking Lot System Implementation You are tasked with designing a basic parking lot management system. The parking lot has multiple levels, and each level has a fixed number of spots. The goal is to create a system that allows for parking, leaving, and keeping track of available spots efficiently. Each level has spots for cars and motorbikes, and each spot has a size: small, medium, or large. # Task 1. Implement a `ParkingLot` class that initializes with a number of levels and spots per level. 2. Implement methods to: - Park a vehicle. - Leave a spot. - Get the number of available spots. Class Definition ```python class ParkingLot: def __init__(self, levels: int, spots_per_level: int): Initializes the parking lot with the given number of levels and spots per level. pass def park_vehicle(self, vehicle: str) -> bool: Parks a vehicle in the parking lot. :param vehicle: Type of vehicle (\\"car\\" or \\"motorbike\\") :return: True if the vehicle was parked, False if no spot was available. pass def leave_spot(self, level: int, spot: int) -> bool: Frees up the given spot in the parking lot. :param level: The level where the spot is located. :param spot: The spot number to be vacated. :return: True if the spot was successfully vacated, False if the spot was already empty. pass def available_spots(self) -> int: Returns the total number of available spots in the parking lot. :return: Total available spots. pass ``` Input and Output Specifications: - **Initialization**: The constructor initializes the parking lot with the specified number of levels and spots per level. - **park_vehicle(vehicle: str)**: - **Input**: Type of vehicle (\\"car\\" or \\"motorbike\\"). - **Output**: Boolean indicating if the parking attempt was successful. - **leave_spot(level: int, spot: int)**: - **Input**: Level number and spot number. - **Output**: Boolean indicating if the spot was successfully vacated. - **available_spots()**: - **Output**: The total number of available spots across all levels. Constraints: - Each vehicle can be either a car or a motorbike. - Spot sizes are such that cars require medium or large spots, motorbikes can be parked in small, medium, or large spots. - Assume the constructor parameters are positive integers. # Example 1. Initialization and parking: ```python p_lot = ParkingLot(2, 5) # 2 levels, 5 spots per level print(p_lot.park_vehicle(\\"car\\")) # Return True if a spot is found, otherwise False print(p_lot.park_vehicle(\\"motorbike\\")) # Return True if a spot is found, otherwise False ``` 2. Leaving a spot: ```python print(p_lot.leave_spot(0, 3)) # Vacates spot 3 on level 0, returns True if successful ``` 3. Checking available spots: ```python print(p_lot.available_spots()) # Returns the total available spots ``` # Additional Notes - Ensure `park_vehicle` and `leave_spot` methods handle edge cases like parking or leaving a non-existent spot gracefully. - Consider the efficiency of the methods, especially `available_spots` for real-time tracking. Good luck!","solution":"class ParkingLot: def __init__(self, levels: int, spots_per_level: int): self.levels = levels self.spots_per_level = spots_per_level # Create a matrix to represent parking spots, True indicates available, False indicates occupied self.parking_spots = [[True] * spots_per_level for _ in range(levels)] def park_vehicle(self, vehicle: str) -> bool: Parks a vehicle in the parking lot. :param vehicle: Type of vehicle (\\"car\\" or \\"motorbike\\") :return: True if the vehicle was parked, False if no spot was available. for level in range(self.levels): for spot in range(self.spots_per_level): if self.parking_spots[level][spot]: # Spot available if vehicle == \\"car\\" and (spot % 2 == 0): # Cars can only park in even spots self.parking_spots[level][spot] = False return True elif vehicle == \\"motorbike\\": self.parking_spots[level][spot] = False return True return False def leave_spot(self, level: int, spot: int) -> bool: Frees up the given spot in the parking lot. :param level: The level where the spot is located. :param spot: The spot number to be vacated. :return: True if the spot was successfully vacated, False if the spot was already empty or out of bounds. if 0 <= level < self.levels and 0 <= spot < self.spots_per_level: if not self.parking_spots[level][spot]: # Spot occupied self.parking_spots[level][spot] = True return True return False def available_spots(self) -> int: Returns the total number of available spots in the parking lot. :return: Total available spots. return sum(row.count(True) for row in self.parking_spots)"},{"question":"# Movie Theater Seat Analysis Problem Statement You are managing seat reservations for a movie theater with a single row containing `N` seats. Some of the seats are already reserved, and you need to determine if a group of `M` consecutive seats can be reserved together. Write a function `can_reserve` that takes the following inputs: * `seats`: A list of integers where `seats[i]` is `1` if the `i-th` seat is reserved and `0` if the seat is available. * `M`: An integer representing the number of consecutive seats the group wants to reserve. The function should return a boolean value: `True` if there is a block of `M` consecutive available seats and `False` otherwise. Input Format * `seats`: List of integers, where each integer is either `0` or `1`. * `M`: Integer representing the number of consecutive seats to reserve. Output Format * A boolean value: `True` if the reservation is possible, `False` otherwise. Constraints * 1 <= N <= 1000 * 1 <= M <= 200 * The length of `seats` is `N`. Example ```python def can_reserve(seats, M): # Implementation goes here. # Example usage: seats = [0, 1, 0, 0, 0, 1, 0, 0] M = 3 print(can_reserve(seats, M)) # Output: True M = 4 print(can_reserve(seats, M)) # Output: False ``` **Explanation**: For the given example, there is at least one block of 3 consecutive available seats (starting from index 2). However, there is no block of 4 consecutive available seats. Notes * Consider edge cases, such as when `M` is larger than `N` or when there are no available seats at all.","solution":"def can_reserve(seats, M): Determines if there is a block of M consecutive available seats in a movie theater row. :param seats: List of integers where 1 indicates a reserved seat and 0 indicates an available seat. :param M: Integer representing the number of consecutive seats to reserve. :return: Boolean value, True if there is a block of M consecutive available seats, False otherwise. consecutive_free = 0 # Counter for consecutive available seats for seat in seats: if seat == 0: consecutive_free += 1 if consecutive_free == M: return True else: consecutive_free = 0 # Reset counter if a reserved seat is encountered return False # Return False if no block of M consecutive available seats is found"},{"question":"# Background In an n x n grid, each cell in the grid can either be empty (represented by 0) or contain an obstacle (represented by 1). You need to find a path from the top-left cell (0,0) to the bottom-right cell (n-1,n-1), such that you minimize the sum of obstacles encountered along the path. You can move left, right, up, or down from a cell. # Problem Write a function `min_obstacle_path` that calculates the minimum number of obstacles encountered from the top-left to the bottom-right cell of the grid. # Function Signature ```python def min_obstacle_path(grid: List[List[int]]) -> int: pass ``` # Input * `grid` (List[List[int]]): A 2D list of integers representing the grid (where each element is either 0 or 1). # Output * Returns the minimum number of obstacles encountered along the path from the top-left to the bottom-right cell. # Example ```python min_obstacle_path([[0, 1, 0], [1, 0, 1], [0, 0, 0]]) # Returns 1 min_obstacle_path([[0, 0, 0], [1, 1, 0], [0, 0, 0]]) # Returns 0 ``` # Constraints * The size of the grid `n` will not exceed 100. * The grid contains at least one path from the top-left to the bottom-right cell. # Additional Notes * Use a traversal algorithm like BFS or Dijkstra’s algorithm to find the minimum obstacle path. * Ensure the function efficiently handles the constraints given.","solution":"from typing import List from heapq import heappop, heappush def min_obstacle_path(grid: List[List[int]]) -> int: n = len(grid) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] heap = [(grid[0][0], 0, 0)] visited = [[False] * n for _ in range(n)] visited[0][0] = True while heap: obstacles, x, y = heappop(heap) if x == n - 1 and y == n - 1: return obstacles for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True heappush(heap, (obstacles + grid[nx][ny], nx, ny)) return -1 # This return is just a guard. Should never be hit given the constraints."},{"question":"# Mastermind Game Solver You are tasked with implementing a solver for the classic code-breaking game \\"Mastermind.\\" The goal of the game is for the codebreaker to guess the secret code created by the codemaker. Your solver will attempt to guess the secret code, using feedback provided after each guess. Specifically, you need to: 1. **Implement the `make_guess` function** to generate a new guess based on previous attempts and feedback. 2. **Implement the `provide_feedback` function** to evaluate a guess against the secret code, providing a count of correct colors in the correct position (hits) and correct colors in the wrong position (misses). # Input * `secret_code`: A list of integers representing the secret code (each integer denotes a color). * `past_attempts`: A list of lists, where each inner list is a previous guess (list of integers). * `feedback`: A list of tuples, where each tuple corresponds to the feedback for a past attempt. Each tuple contains two integers: (hits, misses). # Output * For the `make_guess` function: A list of integers representing the new guess. * For the `provide_feedback` function: A tuple with two integers (hits, misses) representing feedback for the guess. # Constraints * Assume there are 6 possible colors, represented by integers 0-5. * The length of the code and guesses is always 4. * The `make_guess` function should use any logical strategy (but not brute force) to improve guesses based on feedback. # Example ```python # Define the secret code secret_code = [0, 1, 2, 3] # Initialize previous attempts and their feedback past_attempts = [[0, 0, 0, 0], [4, 4, 4, 4]] feedback = [(1, 0), (0, 0)] # Make a new guess new_guess = make_guess(past_attempts, feedback) print(new_guess) # Example output: [1, 1, 1, 1] # Provide feedback for the new guess new_feedback = provide_feedback(secret_code, new_guess) print(new_feedback) # Example output: (0, 1) ``` # Notes * Ensure your solution efficiently narrows down possible combinations based on feedback. * The `make_guess` function should be able to handle multiple past attempts and feedback to improve guess accuracy. * The `provide_feedback` function should correctly compute the number of hits and misses between the guess and the secret code.","solution":"def make_guess(past_attempts, feedback): Generates a new guess for the Mastermind game based on past attempts and feedback. import random if not past_attempts: # If no past attempts, return a random guess return [random.randint(0, 5) for _ in range(4)] def is_valid_guess(guess): for past, (hits, misses) in zip(past_attempts, feedback): p_hits, p_misses = provide_feedback(past, guess) if p_hits != hits or p_misses != misses: return False return True guess = [random.randint(0, 5) for _ in range(4)] while not is_valid_guess(guess): guess = [random.randint(0, 5) for _ in range(4)] return guess def provide_feedback(secret_code, guess): Provides feedback for a guess compared to the secret code. hits = 0 misses = 0 secret_code_unused = [] guess_unused = [] for s, g in zip(secret_code, guess): if s == g: hits += 1 else: secret_code_unused.append(s) guess_unused.append(g) for g in guess_unused: if g in secret_code_unused: secret_code_unused.remove(g) misses += 1 return hits, misses"},{"question":"# Problem Statement You are required to work with a binary search tree (BST) and enhance its functionality by implementing additional methods. A BST is a node-based binary tree data structure where each node has at most two children, referred to as the left child and the right child. The left subtree of a node contains only nodes with keys less than the node\'s key, and the right subtree only contains nodes with keys greater than the node\'s key. Tasks 1. **Implement \'insert_balance\' function** Enhance the BinarySearchTree class by adding a method `insert_balance(self, val: int) -> None`. This method should insert a value into the BST and then balance the tree to maintain its optimal height. 2. **Implement \'find_kth_smallest\' function** Add a method `find_kth_smallest(self, k: int) -> int` to the BinarySearchTree class. This function should return the k-th smallest element in the BST. # Constraints - The `insert_balance` method must ensure that the tree remains balanced after each insertion. You can assume that the tree balancing refers to keeping the height difference between left and right subtrees minimal. - The `find_kth_smallest` method should run in O(n) time complexity where \'n\' is the number of nodes in the BST. - The BST will not have duplicate values. # Function Signatures ```python def insert_balance(self, val: int) -> None: pass def find_kth_smallest(self, k: int) -> int: pass ``` # Example - **Insertion and Balancing** ```python bst = BinarySearchTree() bst.insert_balance(10) bst.insert_balance(5) bst.insert_balance(15) bst.insert_balance(3) ``` - **k-th Smallest Element** ```python # Assuming k is 2 in this example print(bst.find_kth_smallest(2)) # Output should be 5 ``` **Note**: The provided BinarySearchTree class and TreeNode class shall be used and modified according to the task requirements. # Class Definitions (Given for context) ```python class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert_balance(self, val: int) -> None: pass def find_kth_smallest(self, k: int) -> int: pass ```","solution":"class TreeNode: def __init__(self, key: int): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert_balance(self, val: int) -> None: def sorted_array_to_bst(nums): if not nums: return None mid = len(nums) // 2 node = TreeNode(nums[mid]) node.left = sorted_array_to_bst(nums[:mid]) node.right = sorted_array_to_bst(nums[mid + 1:]) return node def in_order_traversal(root): return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right) if root else [] if self.root is None: self.root = TreeNode(val) else: elements = in_order_traversal(self.root) + [val] elements.sort() self.root = sorted_array_to_bst(elements) def find_kth_smallest(self, k: int) -> int: def in_order_traversal(root): return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right) if root else [] elements = in_order_traversal(self.root) if k - 1 < 0 or k - 1 >= len(elements): raise IndexError(\\"k is out of the bounds of the number of elements in the BST\\") return elements[k - 1]"},{"question":"# Question: Determine the Frequency of Characters in a String Given a string, write a function to determine the frequency of each character in the string and return the results as a dictionary. The function should count each character, regardless of whether it is an uppercase letter, lowercase letter, number, or special character. # Requirements: 1. Implement a function `char_frequency(s: str) -> Dict[str, int]` that: - Takes a single string `s` as input. - Returns a dictionary where the keys are characters and the values are the counts of each character in the string. # Input: - A string `s` consisting of any mix of letters, numbers, symbols, and spaces. # Output: - A dictionary with characters as keys and their respective frequencies as values. # Constraints: - The input string will have a maximum length of 1,000 characters. - The function should handle both uppercase and lowercase letters separately. # Example: ```python assert char_frequency(\\"Hello World!\\") == {\\"H\\": 1, \\"e\\": 1, \\"l\\": 3, \\"o\\": 2, \\" \\": 1, \\"W\\": 1, \\"r\\": 1, \\"d\\": 1, \\"!\\": 1} assert char_frequency(\\"aabbcc\\") == {\\"a\\": 2, \\"b\\": 2, \\"c\\": 2} assert char_frequency(\\"Python 3.8\\") == {\\"P\\": 1, \\"y\\": 1, \\"t\\": 1, \\"h\\": 1, \\"o\\": 1, \\"n\\": 1, \\" \\": 1, \\"3\\": 1, \\".\\": 1, \\"8\\": 1} assert char_frequency(\\"\\") == {} ``` # Notes: - Ensure the function can handle an empty string input by returning an empty dictionary. - Consider edge cases like strings with repetitive characters, only white spaces, and combinations of different types of characters. - Aim for clarity and efficiency in counting character frequencies.","solution":"from typing import Dict def char_frequency(s: str) -> Dict[str, int]: Returns a dictionary with the frequency of each character in the input string. Args: s (str): The input string. Returns: Dict[str, int]: A dictionary with characters as keys and their frequencies as values. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"Coding Assessment Question # Objective Write a function that traces the shortest path from the top-left to the bottom-right corner of a grid using Dijkstra\'s algorithm. This will test your understanding of graph algorithms and optimization techniques. # Problem Statement You are given an `m x n` grid where each cell contains a non-negative integer representing the cost to step on that cell. Your task is to implement a function `shortest_path` that calculates the minimum cost to travel from the top-left corner (0, 0) to the bottom-right corner (m-1, n-1) using Dijkstra\'s algorithm. # Requirements 1. **Function Signature**: ```python def shortest_path(grid: list[list[int]]) -> int: ``` 2. **Input Format**: - `grid` (list of lists of int): A 2D list representing the grid with non-negative integers, where `grid[i][j]` denotes the cost to step on cell (i, j). 3. **Output Format**: - Returns an integer representing the minimum cost to travel from the top-left to the bottom-right corner of the grid. 4. **Constraints**: - The grid dimensions `m` and `n` will satisfy 2 ≤ m, n ≤ 100. - The cost of each cell `grid[i][j]` will be a non-negative integer (0 ≤ grid[i][j] ≤ 9). 5. **Performance**: - Aim for an efficient algorithm that leverages priority queues (heaps) to manage the frontier in Dijkstra\'s algorithm. # Additional Notes - You can only move to adjacent cells (i.e., from a cell (i, j), you can move to cells (i+1, j), (i-1, j), (i, j+1), or (i, j-1) if they exist within grid boundaries). - Use heapq from Python’s standard library for managing the priority queue efficiently. # Example ```python import heapq grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] def shortest_path(grid): # Your implementation here pass min_cost = shortest_path(grid) print(\\"Minimum Cost:\\", min_cost) # Expected Output: 7 ``` In the example provided, the function `shortest_path` finds the minimum cost path from the top-left corner to the bottom-right corner in the given grid, which has a value of 7. The function should consider the cost of each cell and use Dijkstra\'s algorithm to ensure the path taken minimizes the total cost.","solution":"import heapq def shortest_path(grid: list[list[int]]) -> int: Returns the minimum cost to travel from the top-left to the bottom-right corner of the grid using Dijkstra\'s algorithm. m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] costs = [[float(\'inf\')] * n for _ in range(m)] costs[0][0] = grid[0][0] priority_queue = [(grid[0][0], 0, 0)] while priority_queue: current_cost, x, y = heapq.heappop(priority_queue) if x == m-1 and y == n-1: return current_cost for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_cost = current_cost + grid[nx][ny] if new_cost < costs[nx][ny]: costs[nx][ny] = new_cost heapq.heappush(priority_queue, (new_cost, nx, ny)) return costs[m-1][n-1]"},{"question":"# **K-Nearest Neighbors Implementation for Basic Classification** You are required to implement a basic version of the K-Nearest Neighbors (KNN) algorithm, which is a simple, supervised learning algorithm used for classification and regression. For this task, the KNN algorithm will be used for binary classification. # Task 1. **Implement KNN Algorithm**: Write a function that classifies a given test point based on the majority label of its k-nearest neighbors in the training data. 2. **Euclidean Distance Calculation**: Use Euclidean distance to determine the nearest neighbors. # Function Signature Implement the function with the following signature: ```python def knn_classifier(k: int, train_data: list[list[float]], labels: list[int], test_point: list[float]) -> int: pass ``` # Input - **k**: Integer, representing the number of nearest neighbors to consider. - **train_data**: List of lists, where each sublist represents a feature vector of a training instance. - **labels**: List of integers (`0` or `1`), representing the binary classification labels for the training instances. - **test_point**: List of floats, representing the feature vector of the test instance that needs classification. # Output - Return an integer (`0` or `1`) representing the predicted class for the test_point. # Constraints - `1 <= k <= len(train_data)` - Each feature vector in `train_data` and `test_point` has the same number of features. - Labels are only `0` or `1`. - The training data contains at least one instance of each class. # Example ```python train_data = [ [1.0, 2.1], [1.5, 1.8], [0.0, 0.9], [0.2, 0.7], [1.1, 1.0], [0.9, 1.3], [2.0, 2.2] ] labels = [1, 1, 0, 0, 1, 0, 1] test_point = [1.2, 1.1] k = 3 # Expected Output: 1 print(knn_classifier(k, train_data, labels, test_point)) ``` # Notes - Calculate the distance of the test_point from each instance in train_data using the Euclidean distance formula. - Sort the distances and select the k-nearest neighbors. - Determine the majority label among the k-nearest neighbors and return it as the predicted class for the test_point. - Ensure your solution is efficient and accurate, and validate with additional test cases.","solution":"import math from collections import Counter def euclidean_distance(point1, point2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(point1, point2))) def knn_classifier(k, train_data, labels, test_point): # Calculate distances of the test point from all training data points distances = [] for index, train_point in enumerate(train_data): distance = euclidean_distance(test_point, train_point) distances.append((distance, labels[index])) # Sort distances distances.sort() # Get the labels of the k nearest neighbors k_nearest_labels = [label for _, label in distances[:k]] # Find the majority label label_count = Counter(k_nearest_labels) majority_label = label_count.most_common(1)[0][0] return majority_label"}]'),O={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},F={class:"card-container"},R={key:0,class:"empty-state"},L=["disabled"],N={key:0},P={key:1};function D(s,e,l,m,r,a){const p=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[y,r.searchQuery]]),r.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",R,' No results found for "'+d(r.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",N,"See more"))],8,L)):u("",!0)])}const Y=h(O,[["render",D],["__scopeId","data-v-42f9f6d4"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/48.md","filePath":"library/48.md"}'),j={name:"library/48.md"},U=Object.assign(j,{setup(s){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
