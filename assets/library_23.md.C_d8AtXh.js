import{_,o as r,c as n,a as t,m,t as d,C as g,M as p,U as b,f as u,F as x,p as v,e as y,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function R(s,e,l,h,i,a){return r(),n("div",q,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(d(l.poem.solution),1)])])])}const j=_(k,[["render",R],["__scopeId","data-v-5f151ca3"]]),F=JSON.parse(`[{"question":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a view of the sunset. A building has a view of the sunset if all the buildings to its right are shorter. >>> buildings_with_sunset_view([4, 2, 3, 1]) [0, 2, 3] >>> buildings_with_sunset_view([4, 3, 2, 1]) [0, 1, 2, 3] >>> buildings_with_sunset_view([1, 2, 3, 4]) [3] >>> buildings_with_sunset_view([1]) [0] >>> buildings_with_sunset_view([1, 3, 2, 4, 5]) [4] >>> buildings_with_sunset_view([]) []","solution":"def buildings_with_sunset_view(heights): Returns the indices of the buildings that have a view of the sunset. A building has a view of the sunset if all buildings to its right are shorter. n = len(heights) result = [] if n == 0: return result max_height = heights[-1] result.append(n - 1) for i in range(n - 2, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"class TreeNode: A TreeNode class for a binary tree node with left and right children. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, otherwise False. def check_height(node): if not node: return 0 return check_height(root) != -1","solution":"class TreeNode: A TreeNode class for a binary tree node with left and right children. def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Returns True if the binary tree is balanced, otherwise False. def check_height(node): if not node: return 0 left_height = check_height(node.left) right_height = check_height(node.right) if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_height(root) != -1"},{"question":"def construct_lexicographically_smallest_string(s: str, t: str) -> str: Construct the lexicographically smallest string by transforming s using characters from t. Args: s (str): The original string. t (str): The transformation string. Returns: str: The lexicographically smallest string that can be obtained. Examples: >>> construct_lexicographically_smallest_string(\\"abc\\", \\"xyz\\") 'abc' >>> construct_lexicographically_smallest_string(\\"acb\\", \\"cab\\") 'aab' >>> construct_lexicographically_smallest_string(\\"zzzz\\", \\"aaaa\\") 'aaaa' >>> construct_lexicographically_smallest_string(\\"abcd\\", \\"abdd\\") 'abcd' >>> construct_lexicographically_smallest_string(\\"dcb\\", \\"aba\\") 'aba'","solution":"def construct_lexicographically_smallest_string(s, t): Construct the lexicographically smallest string by transforming s using characters from t. Args: s (str): The original string. t (str): The transformation string. Returns: str: The lexicographically smallest string that can be obtained. result = [] for i in range(len(s)): if s[i] < t[i]: result.append(s[i]) else: result.append(t[i]) return ''.join(result)"},{"question":"def count_increasing_pairs(buildings): Given a list of \`n\` integers, where each integer represents the height of a building, find the number of pairs of buildings \`(i, j)\` such that \`i < j\` and the height of building \`i\` is less than the height of building \`j\`. Return the total number of such pairs. >>> count_increasing_pairs([1, 3, 2]) # (1, 3), (1, 2) 2 >>> count_increasing_pairs([5, 4, 3, 2, 1]) 0 >>> count_increasing_pairs([1, 1, 1, 1]) 0 >>> count_increasing_pairs([1, 2, 3, 4]) # (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) 6 >>> count_increasing_pairs([1, 2, 1, 2, 3]) # (1,2), (1,2), (1,3), (2,3), (1,2), (1,3), (2,3) 7 import unittest class TestCountIncreasingPairs(unittest.TestCase): def test_count_increasing_pairs_with_example_case(self): buildings = [1, 3, 2] self.assertEqual(count_increasing_pairs(buildings), 2) def test_count_increasing_pairs_with_no_pairs(self): buildings = [5, 4, 3, 2, 1] self.assertEqual(count_increasing_pairs(buildings), 0) def test_count_increasing_pairs_with_all_equal_heights(self): buildings = [1, 1, 1, 1] self.assertEqual(count_increasing_pairs(buildings), 0) def test_count_increasing_pairs_with_increasing_heights(self): buildings = [1, 2, 3, 4] self.assertEqual(count_increasing_pairs(buildings), 6) def test_count_increasing_pairs_with_decreasing_and_increasing_heights(self): buildings = [1, 2, 1, 2, 3] self.assertEqual(count_increasing_pairs(buildings), 7) if __name__ == \\"__main__\\": unittest.main()","solution":"def count_increasing_pairs(buildings): This function returns the number of pairs (i, j) where i < j and buildings[i] < buildings[j]. :param buildings: List of integers where each integer represents the height of a building :return: The total number of pairs (i, j) where i < j and buildings[i] < buildings[j] n = len(buildings) count = 0 for i in range(n): for j in range(i + 1, n): if buildings[i] < buildings[j]: count += 1 return count"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Given a sorted integer array nums and an integer target, determine if there exists a pair of elements whose sum is equal to target. Return a list of the indices of the two numbers such that they add up to target. The returned indices must be in ascending order. >>> two_sum([1, 2, 3, 4, 6], 6) [1, 3] >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([-3, -1, 0, 3, 5], 0) [0, 3] >>> two_sum([1, 2, 3, 4, 5, 6], 11) [4, 5] >>> two_sum([1, 2, 3, 9, 10], 19) [3, 4]","solution":"def two_sum(nums, target): Given a sorted array nums and a target, find the indices of two numbers such that they add up to the target. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 # If no solution is found (the problem guarantees exactly one solution, so this line should never be hit) return []"},{"question":"def longest_common_subsequence(a: str, b: str) -> str: Returns the longest common subsequence of binary strings a and b. >>> longest_common_subsequence(\\"1101\\", \\"1011\\") in [\\"101\\", \\"111\\"] >>> longest_common_subsequence(\\"0000\\", \\"1111\\") \\"\\" >>> longest_common_subsequence(\\"1011\\", \\"1011\\") \\"1011\\" >>> longest_common_subsequence(\\"\\", \\"1011\\") \\"\\" >>> longest_common_subsequence(\\"1100\\", \\"\\") \\"\\" >>> longest_common_subsequence(\\"110\\", \\"101100\\") \\"110\\" >>> longest_common_subsequence(\\"101100\\", \\"110\\") \\"110\\"","solution":"def longest_common_subsequence(a, b): Returns the longest common subsequence of binary strings a and b. m, n = len(a), len(b) dp = [[\\"\\"] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + a[i - 1] else: if len(dp[i - 1][j]) > len(dp[i][j - 1]): dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i][j - 1] return dp[m][n]"},{"question":"from typing import List def count_rearranged_strings(arr: List[str], pattern: str) -> int: Returns the number of strings in 'arr' that can be formed by rearranging the characters of 'pattern'. >>> count_rearranged_strings([\\"abc\\", \\"bca\\", \\"cab\\", \\"xyz\\"], \\"abc\\") == 3 >>> count_rearranged_strings([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abc\\") == 1 >>> count_rearranged_strings([], \\"abc\\") == 0 >>> count_rearranged_strings([\\"def\\", \\"ghi\\", \\"jkl\\"], \\"abc\\") == 0 >>> count_rearranged_strings([\\"abc\\", \\"bca\\", \\"cab\\", \\"acb\\"], \\"abc\\") == 4 >>> count_rearranged_strings([\\"abc\\", \\"ab\\", \\"a\\", \\"abcd\\"], \\"abc\\") == 1 >>> count_rearranged_strings([\\"aabb\\", \\"baba\\", \\"abab\\", \\"abcd\\"], \\"abab\\") == 3","solution":"from collections import Counter def count_rearranged_strings(arr, pattern): Returns the number of strings in 'arr' that can be formed by rearranging the characters of 'pattern'. pattern_counter = Counter(pattern) count = 0 for string in arr: if Counter(string) == pattern_counter: count += 1 return count"},{"question":"def countDistinctIslands(grid: List[List[int]]) -> int: Given a 2D binary grid of size m x n, count the number of distinct islands. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical). You can assume all four edges of the grid are surrounded by water. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other. >>> countDistinctIslands([ [1,1,1,0], [1,0,0,0], [1,1,1,0], [0,0,0,0] ]) 1 >>> countDistinctIslands([ [1,1,0,0,0], [1,0,0,1,1], [0,0,0,1,1], [0,1,0,0,0] ]) 3 >>> countDistinctIslands([ [0,0,0,0], [0,0,0,0], [0,0,0,0] ]) 0 >>> countDistinctIslands([ [1,1,0,0,0], [1,1,0,1,1], [0,0,0,1,1], [1,0,0,0,0] ]) 2 >>> countDistinctIslands([ [1,1], [1,1] ]) 1 pass","solution":"def countDistinctIslands(grid): def dfs(x, y, pos, shape): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 shape.append(pos) dfs(x + 1, y, (pos[0] + 1, pos[1]), shape) dfs(x - 1, y, (pos[0] - 1, pos[1]), shape) dfs(x, y + 1, (pos[0], pos[1] + 1), shape) dfs(x, y - 1, (pos[0], pos[1] - 1), shape) shapes = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: shape = [] dfs(i, j, (0, 0), shape) shapes.add(tuple(shape)) return len(shapes)"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix): Rotate the matrix 90 degrees clockwise. >>> rotate_matrix_90_degrees_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees_clockwise([[1, 2, 3], [4, 5, 6]]) [[4, 1], [5, 2], [6, 3]] pass def max_row_sum_after_rotations(matrix): Return the maximum sum of the elements in any row of the matrix after performing any number of 90 degrees clockwise rotations. >>> max_row_sum_after_rotations([[1,2],[3,4]]) == 7 True >>> max_row_sum_after_rotations([[1, 2, 3],[4, 5, 6],[7, 8, 9]]) == 24 True >>> max_row_sum_after_rotations([[5, 6], [7, 8]]) == 15 True >>> max_row_sum_after_rotations([[100]]) == 100 True >>> max_row_sum_after_rotations([[4, 5, 6], [1, 2, 3]]) == 15 True pass","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotate the matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def max_row_sum_after_rotations(matrix): Return the maximum sum of the elements in any row of the matrix after performing any number of 90 degrees clockwise rotations. max_sum = 0 # There are only 4 possible rotations (0, 90, 180, 270 degrees) for _ in range(4): row_sums = [sum(row) for row in matrix] max_sum = max(max_sum, max(row_sums)) matrix = rotate_matrix_90_degrees_clockwise(matrix) return max_sum"},{"question":"def min_moves_to_make_all_chars_same(s: str) -> int: Returns the minimum number of moves required to make all characters in the string the same. :param s: A string consisting of lowercase English letters. :return: Minimum number of moves to make all characters in the string the same. >>> min_moves_to_make_all_chars_same(\\"aaaa\\") 0 >>> min_moves_to_make_all_chars_same(\\"abcd\\") 3 >>> min_moves_to_make_all_chars_same(\\"aabbcc\\") 4 >>> min_moves_to_make_all_chars_same(\\"a\\") 0 >>> min_moves_to_make_all_chars_same(\\"ab\\") 1 >>> min_moves_to_make_all_chars_same(\\"a\\" * 1000 + \\"b\\" * 2000 + \\"c\\" * 3000) 3000","solution":"def min_moves_to_make_all_chars_same(s): Returns the minimum number of moves required to make all characters in the string the same. :param s: A string consisting of lowercase English letters. :return: Minimum number of moves to make all characters in the string the same. # Count the frequency of each character in the string char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the character with the maximum frequency max_freq = max(char_count.values()) # The minimum number of moves required is the length of the string minus the maximum frequency return len(s) - max_freq"},{"question":"def shortest_subsequence_length(s: str) -> int: Returns the length of the shortest subsequence that contains all the distinct characters of the string s. >>> shortest_subsequence_length(\\"abcdef\\") 6 >>> shortest_subsequence_length(\\"aabbcc\\") 3 >>> shortest_subsequence_length(\\"a\\") 1 >>> shortest_subsequence_length(\\"\\") 0 >>> shortest_subsequence_length(\\"abcabc\\") 3 >>> shortest_subsequence_length(\\"thequickbrownfoxjumpsoverthelazydog\\") 26 >>> shortest_subsequence_length(\\"aaaaaaaa\\") 1 >>> shortest_subsequence_length(\\"aabbcc\\") 3","solution":"def shortest_subsequence_length(s): Returns the length of the shortest subsequence that contains all the distinct characters of the string s. # Convert the input string to a set to get all distinct characters distinct_characters = set(s) # The length of the shortest subsequence that contains all distinct characters # is simply the number of distinct characters return len(distinct_characters)"},{"question":"from typing import List def minimum_difference(weights: List[int]) -> int: Returns the minimum absolute difference between the sums of two groups of weights. Each group must contain at least one element. >>> minimum_difference([1, 2, 3, 4, 6]) 0 >>> minimum_difference([2, 3]) 1 >>> minimum_difference([3, 1, 4, 2, 2]) 0 >>> minimum_difference([1, 2, 1, 2, 1]) 1 >>> minimum_difference([1, 6, 11, 5]) 1","solution":"def minimum_difference(weights): Returns the minimum absolute difference between the sums of two groups of weights. Each group must contain at least one element. total_weight = sum(weights) n = len(weights) # Getting the half of the total weight for the knapsack problem target = total_weight // 2 # Initializing dp array dp = [0] * (target + 1) # Knapsack approach to find the best possible sum we can achieve close to target for weight in weights: for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) sum_close_to_half = dp[target] return abs(total_weight - 2 * sum_close_to_half)"},{"question":"def maxProfit(prices: List[int]) -> int: Compute the maximum profit you can achieve by performing at most two transactions. A transaction consists of buying and then selling one share of the stock. :param prices: List[int] - List of daily prices of a stock :return: int - Maximum achievable profit with at most two transactions >>> maxProfit([1, 2, 3, 4, 5]) 4 >>> maxProfit([5, 4, 3, 2, 1]) 0 >>> maxProfit([3, 3, 5, 0, 0, 3, 1, 4]) 6 >>> maxProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]) 13 >>> maxProfit([7]) 0 >>> maxProfit([]) 0","solution":"def maxProfit(prices): Computes the maximum profit with at most two transactions. :param prices: List[int] - List of daily prices of a stock :return: int - Maximum achievable profit with at most two transactions if not prices: return 0 n = len(prices) # Initialize the dp arrays sell1, sell2 = 0, 0 buy1, buy2 = float('-inf'), float('-inf') for price in prices: # Update the states for buy1, sell1, buy2 and sell2 buy1 = max(buy1, -price) # Buy the first stock sell1 = max(sell1, buy1 + price) # Sell the first stock buy2 = max(buy2, sell1 - price) # Buy the second stock sell2 = max(sell2, buy2 + price) # Sell the second stock return sell2"},{"question":"def is_alien_sorted(words, order): Determine if the list of words is sorted lexicographically according to a new order of the alphabet. Args: words (List[str]): List of strings to be checked. order (str): A string representing the new order of the alphabet. Returns: bool: True if words are sorted according to the new order, False otherwise. >>> is_alien_sorted([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") False >>> is_alien_sorted([\\"apple\\", \\"app\\"], \\"abcdefghijklmnopqrstuvwxyz\\") False >>> is_alien_sorted([\\"abcd\\", \\"abce\\", \\"abcf\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"ab\\", \\"abc\\", \\"abz\\"], \\"abczdefghijklmnopqrstuvwxy\\") True >>> is_alien_sorted([], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"single\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"a\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"abcd\\", \\"abcd\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True >>> is_alien_sorted([\\"xyz\\", \\"xyz\\", \\"xyz\\"], \\"abcdefghijklmnopqrstuvwxyz\\") True","solution":"def is_alien_sorted(words, order): Determine if the list of words is sorted lexicographically according to a new order of the alphabet. Args: words (List[str]): List of strings to be checked. order (str): A string representing the new order of the alphabet. Returns: bool: True if words are sorted according to the new order, False otherwise. order_index = {char: index for index, char in enumerate(order)} def is_valid_order(word1, word2): Check if word1 is correctly ordered before word2 based on the alien dictionary order. for char1, char2 in zip(word1, word2): if order_index[char1] < order_index[char2]: return True elif order_index[char1] > order_index[char2]: return False return len(word1) <= len(word2) for i in range(len(words) - 1): if not is_valid_order(words[i], words[i+1]): return False return True"},{"question":"from collections import Counter def is_permutation_of_substring(s: str, p: str) -> bool: Check if \`p\` is a permutation of a substring in \`s\`. >>> is_permutation_of_substring(\\"cbaebabacd\\", \\"abc\\") True >>> is_permutation_of_substring(\\"af\\", \\"be\\") False >>> is_permutation_of_substring(\\"a\\", \\"b\\") False >>> is_permutation_of_substring(\\"eidbaooo\\", \\"aobo\\") True >>> is_permutation_of_substring(\\"\\", \\"\\") True from solution import is_permutation_of_substring def test_permutation_exists(): assert is_permutation_of_substring(\\"cbaebabacd\\", \\"abc\\") == True def test_no_permutation(): assert is_permutation_of_substring(\\"af\\", \\"be\\") == False def test_permutation_at_start(): assert is_permutation_of_substring(\\"abbc\\", \\"bba\\") == True def test_permutation_at_end(): assert is_permutation_of_substring(\\"eidbaooo\\", \\"aobo\\") == True def test_single_letter_no_permutation(): assert is_permutation_of_substring(\\"a\\", \\"b\\") == False def test_single_letter_with_permutation(): assert is_permutation_of_substring(\\"a\\", \\"a\\") == True def test_different_length_strings(): assert is_permutation_of_substring(\\"abcd\\", \\"abcd123\\") == False def test_empty_strings(): assert is_permutation_of_substring(\\"\\", \\"\\") == True def test_s_empty_p_non_empty(): assert is_permutation_of_substring(\\"\\", \\"a\\") == False def test_p_empty_s_non_empty(): assert is_permutation_of_substring(\\"a\\", \\"\\") == True","solution":"def is_permutation_of_substring(s, p): from collections import Counter p_counter = Counter(p) s_len = len(s) p_len = len(p) if p_len > s_len: return False for i in range(s_len - p_len + 1): if Counter(s[i:i+p_len]) == p_counter: return True return False"},{"question":"def distinct_characters_in_substrings(s: str, queries: List[List[int]]) -> List[int]: Return the number of distinct characters in the substring of s for each query. >>> distinct_characters_in_substrings(\\"abca\\", [[0, 2], [1, 3], [2, 3]]) [3, 3, 2] >>> distinct_characters_in_substrings(\\"a\\", [[0, 0]]) [1] >>> distinct_characters_in_substrings(\\"aaaa\\", [[0, 3], [1, 2], [0, 1]]) [1, 1, 1] >>> distinct_characters_in_substrings(\\"abcd\\", [[0, 3], [0, 1], [2, 3]]) [4, 2, 2] >>> distinct_characters_in_substrings(\\"abcabc\\", [[0, 2], [2, 4], [4, 5]]) [3, 3, 2]","solution":"def distinct_characters_in_substrings(s, queries): Returns a list of the number of distinct characters in the substring of s from index l to index r inclusive for each query. :param s: A string of lowercase letters. :param queries: A list of queries, where each query is a list of two integers [l, r]. :return: A list of integers representing the number of distinct characters for each query. result = [] for l, r in queries: substring = s[l:r+1] distinct_chars = set(substring) result.append(len(distinct_chars)) return result"},{"question":"def smallest_multiple_of_2_and_n(n: int) -> int: Given a positive integer \`n\`, return the smallest positive integer that is a multiple of both 2 and \`n\`. >>> smallest_multiple_of_2_and_n(4) == 4 >>> smallest_multiple_of_2_and_n(3) == 6 >>> smallest_multiple_of_2_and_n(1) == 2 >>> smallest_multiple_of_2_and_n(1024) == 1024 >>> smallest_multiple_of_2_and_n(1023) == 2046 >>> smallest_multiple_of_2_and_n(2) == 2","solution":"def smallest_multiple_of_2_and_n(n): Returns the smallest positive integer that is a multiple of both 2 and n. return n if n % 2 == 0 else n * 2"},{"question":"def maximalSquare(grid) -> int: Given a matrix \`grid\` of size \`m x n\` consisting of only \`0\`s and \`1\`s, find the largest square containing only \`1\`s and return its area. >>> maximalSquare([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\",\\"0\\"], ... [\\"1\\",\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"0\\",\\"0\\",\\"1\\",\\"0\\"] ... ]) 4 >>> maximalSquare([ ... [\\"0\\",\\"1\\"], ... [\\"1\\",\\"0\\"] ... ]) 1 >>> maximalSquare([ ... [\\"0\\"] ... ]) 0 >>> maximalSquare([ ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\"] ... ]) 9 >>> maximalSquare([]) 0 >>> maximalSquare([ ... [\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"], ... [\\"0\\",\\"0\\",\\"0\\"] ... ]) 0 >>> maximalSquare([ ... [\\"1\\",\\"0\\",\\"1\\",\\"0\\"], ... [\\"1\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"0\\",\\"1\\",\\"1\\",\\"1\\"], ... [\\"1\\",\\"1\\",\\"0\\",\\"1\\"] ... ]) 4","solution":"def maximalSquare(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * (n + 1) for _ in range(m + 1)] max_side = 0 for i in range(1, m + 1): for j in range(1, n + 1): if grid[i - 1][j - 1] == '1': dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side * max_side"},{"question":"def countUnobstructedBuildings(heights: List[List[int]]) -> int: Returns the count of buildings with an unobstructed view. >>> countUnobstructedBuildings([]) == 0 >>> countUnobstructedBuildings([[]]) == 0 >>> countUnobstructedBuildings([[1]]) == 1 >>> countUnobstructedBuildings([[1, 1], [1, 1]]) == 0 >>> countUnobstructedBuildings([[2, 2, 2], [2, 2, 2], [2, 2, 2]]) == 0 >>> countUnobstructedBuildings([[1, 2], [3, 4]]) == 1 >>> countUnobstructedBuildings([[3, 0], [4, 2]]) == 1 >>> countUnobstructedBuildings([[3, 1, 4], [2, 5, 1], [1, 1, 2]]) == 2 >>> countUnobstructedBuildings([[4, 4, 4], [4, 4, 4], [4, 4, 4]]) == 0 pass","solution":"def countUnobstructedBuildings(heights): Returns the count of buildings with an unobstructed view. if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) unobstructed_count = 0 for i in range(m): for j in range(n): height = heights[i][j] unobstructed = all(heights[i][k] < height for k in range(n) if k != j) and all(heights[k][j] < height for k in range(m) if k != i) if unobstructed: unobstructed_count += 1 return unobstructed_count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head: ListNode) -> ListNode: Detects the starting node of the cycle in a linked list. If no cycle is present, returns None. Uses Floyd's Tortoise and Hare algorithm for cycle detection. >>> # Creating list with cycle: 1 -> 2 -> 3 -> 4 -> 5 -> >>> # ^--------| >>> head = ListNode(1) >>> second = ListNode(2) >>> third = ListNode(3) >>> fourth = ListNode(4) >>> fifth = ListNode(5) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = fifth >>> fifth.next = third >>> detectCycle(head) is third True >>> # Creating list with cycle: 1 -> 2 -> 3 -> 4 -> 5 -> >>> # ^---------------------------| >>> head = ListNode(1) >>> second = ListNode(2) >>> third = ListNode(3) >>> fourth = ListNode(4) >>> fifth = ListNode(5) >>> head.next = second >>> second.next = third >>> third.next = fourth >>> fourth.next = fifth >>> fifth.next = head >>> detectCycle(head) is head True >>> # Creating list: 1 -> 2 -> 3 -> 4 -> 5 >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> head.next.next.next.next = ListNode(5) >>> detectCycle(head) is None True >>> # Creating list: 1 >>> head = ListNode(1) >>> detectCycle(head) is None True >>> # Creating list with cycle: 1 -> >>> # ^--| >>> head = ListNode(1) >>> head.next = head >>> detectCycle(head) is head True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head): Detects the starting node of the cycle in a linked list. If no cycle is present, returns None. Uses Floyd's Tortoise and Hare algorithm for cycle detection. if not head or not head.next: return None slow = head fast = head # Detect cycle using Floyd's Tortoise and Hare algorithm while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If no cycle detected if not fast or not fast.next: return None # Find the start node of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a given arithmetic expression containing parentheses and return the result. The expression can contain '+', '-', '*', '/', '(', ')' and whitespace. The given string is a valid arithmetic expression and no built-in evaluation function like eval() should be used. >>> evaluate_expression(\\"3 + 5\\") 8 >>> evaluate_expression(\\"10 - 2\\") 8 >>> evaluate_expression(\\"4 * 5\\") 20 >>> evaluate_expression(\\"8 / 4\\") 2 >>> evaluate_expression(\\"3 + 5 * 2\\") 13 >>> evaluate_expression(\\"(3 + 5) * 2\\") 16 >>> evaluate_expression(\\"10 - (2 + 3) * 4\\") -10","solution":"def evaluate_expression(expression): def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 def apply_operation(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b if a * b > 0 else -(-a // b) def compute(tokens): values = [] ops = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': ops.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 values.append(val) i -= 1 elif tokens[i] == ')': while ops and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) ops.pop() else: while (ops and precedence(ops[-1]) >= precedence(tokens[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) ops.append(tokens[i]) i += 1 while ops: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_operation(val1, val2, op)) return values[0] return compute(expression)"},{"question":"def longest_subarray_with_k_distinct(nums: List[int], k: int) -> int: Returns the length of the longest contiguous subarray that contains at most \`k\` distinct integers. Args: nums: List of integers. k: Integer, the maximum number of distinct integers allowed in the subarray. Returns: Integer, length of the longest contiguous subarray with at most \`k\` distinct integers. >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3, 3, 4], 2) 4 >>> longest_subarray_with_k_distinct([1], 1) 1 >>> longest_subarray_with_k_distinct([1, 2, 3, 4], 4) 4 >>> longest_subarray_with_k_distinct([1, 1, 1, 1], 1) 4 >>> longest_subarray_with_k_distinct([1, 2, 3, 4, 2], 2) 2 >>> longest_subarray_with_k_distinct([], 2) 0 >>> longest_subarray_with_k_distinct([1, 2, 1, 2, 3, 3, 4], 10) 7 pass","solution":"def longest_subarray_with_k_distinct(nums, k): Returns the length of the longest contiguous subarray that contains at most \`k\` distinct integers. from collections import defaultdict count = defaultdict(int) max_len = 0 left = 0 for right in range(len(nums)): count[nums[right]] += 1 while len(count) > k: count[nums[left]] -= 1 if count[nums[left]] == 0: del count[nums[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List, Tuple def pacific_atlantic(mat: List[List[int]]) -> List[Tuple[int, int]]: Given an \`m x n\` matrix \`mat\` where every cell represents the height of the terrain at that point, return all the points (i.e., coordinates) that can flow water to both the Pacific and Atlantic oceans. >>> pacific_atlantic([ [1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4] ]) [(0, 4), (1, 3), (1, 4), (2, 2), (3, 0), (3, 1), (4, 0)] >>> pacific_atlantic([]) [] >>> pacific_atlantic([[1, 2, 2, 3, 5]]) [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4)] >>> pacific_atlantic([ [1], [2], [2], [3], [5] ]) [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)] >>> pacific_atlantic([ [1, 1], [1, 1] ]) [(0, 0), (0, 1), (1, 0), (1, 1)]","solution":"def pacific_atlantic(mat): if not mat or not mat[0]: return [] def dfs(matrix, visited, i, j): visited.add((i, j)) for x, y in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)): if 0 <= x < len(matrix) and 0 <= y < len(matrix[0]) and (x, y) not in visited and matrix[x][y] >= matrix[i][j]: dfs(matrix, visited, x, y) m, n = len(mat), len(mat[0]) pacific_reachable = set() atlantic_reachable = set() for i in range(m): dfs(mat, pacific_reachable, i, 0) dfs(mat, atlantic_reachable, i, n - 1) for j in range(n): dfs(mat, pacific_reachable, 0, j) dfs(mat, atlantic_reachable, m - 1, j) return list(pacific_reachable & atlantic_reachable)"},{"question":"def search_range(nums: List[int], target: int) -> List[int]: Given a list of integers nums, sorted in non-decreasing order, and an integer target, return the starting and ending position of the target value in the list. If the target is not found, return [-1, -1]. The algorithm should run in O(log n) time. >>> search_range([5, 7, 7, 8, 8, 10], 8) == [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 7) == [1, 2] >>> search_range([5, 7, 7, 8, 8, 10], 6) == [-1, -1] >>> search_range([], 0) == [-1, -1] >>> search_range([1], 1) == [0, 0] >>> search_range([1], 0) == [-1, -1] >>> search_range([2, 2, 2, 2, 2], 2) == [0, 4] >>> search_range(list(range(1000000)), 999999) == [999999, 999999]","solution":"def search_range(nums, target): Searches for the starting and ending positions of the target in the list. :param nums: List of integers sorted in non-decreasing order :param target: Integer value to search for :return: List with starting and ending positions of target or [-1, -1] if not found def find_left_most(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_most(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_most = find_left_most(nums, target) right_most = find_right_most(nums, target) if left_most <= right_most and left_most < len(nums) and nums[left_most] == target: return [left_most, right_most] else: return [-1, -1]"},{"question":"def binary_string_stability(s: str) -> int: Finds the stability of the binary string 's' which is the length of the longest subsequence with an equal number of '0's and '1's. Parameters: s (str): The binary string consisting of '0' and '1'. Returns: int: The length of the longest stable subsequence. >>> binary_string_stability('0000') 0 >>> binary_string_stability('1111') 0 >>> binary_string_stability('0101') 4 >>> binary_string_stability('000111') 6 >>> binary_string_stability('000110') 4 >>> binary_string_stability('111000') 6 >>> binary_string_stability('111010') 4 >>> binary_string_stability('') 0 >>> binary_string_stability('10000') 2 >>> binary_string_stability('1010101010') 10","solution":"def binary_string_stability(s): Finds the stability of the binary string 's' which is the length of the longest subsequence with an equal number of '0's and '1's. Parameters: s (str): The binary string consisting of '0' and '1'. Returns: int: The length of the longest stable subsequence. count_0 = s.count('0') count_1 = s.count('1') return 2 * min(count_0, count_1)"},{"question":"def taskOrder(n: int, dependencies: List[List[int]]) -> List[int]: Returns an order in which to complete the tasks such that all task dependencies are respected. If there are cycle dependencies, returns an empty list. :param n: int - Number of tasks :param dependencies: List[List[int]] - List of dependencies :return: List[int] - Order of task completion >>> taskOrder(4, []) [1, 2, 3, 4] >>> taskOrder(4, [[1, 2], [2, 3], [3, 4]]) [1, 2, 3, 4] >>> taskOrder(3, [[1, 2], [2, 3], [3, 1]]) []","solution":"from collections import defaultdict, deque def taskOrder(n, dependencies): Returns an order in which to complete the tasks such that all task dependencies are respected. If there are cycle dependencies, returns an empty list. :param n: int - Number of tasks :param dependencies: List[List[int]] - List of dependencies :return: List[int] - Order of task completion # Initialize graph and indegree count graph = defaultdict(list) indegree = {i: 0 for i in range(1, n+1)} # Build the graph and populate indegree counts for a, b in dependencies: graph[a].append(b) indegree[b] += 1 # Initialize the queue with tasks having no dependencies queue = deque([node for node in indegree if indegree[node] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If order contains all tasks, return the order. # Otherwise, there is a cycle, and we return an empty list. if len(order) == n: return order else: return []"},{"question":"def min_slicing_operations(nums: List[int]) -> int: Returns the minimum number of slicing operations required to sort nums in non-decreasing order. >>> min_slicing_operations([]) == 0 >>> min_slicing_operations([1]) == 0 >>> min_slicing_operations([1, 2, 3, 4]) == 0 >>> min_slicing_operations([4, 3, 2, 1]) == 1 >>> min_slicing_operations([1, 3, 2, 4]) == 1 >>> min_slicing_operations([2, 1, 3, 4]) == 1 >>> min_slicing_operations([3, 1, 2, 4]) == 2 >>> min_slicing_operations([2, 3, 1, 5, 4]) == 2","solution":"def min_slicing_operations(nums): Returns the minimum number of slicing operations required to sort nums in non-decreasing order. if not nums: return 0 sorted_nums = sorted(nums) n = len(nums) start, end = None, None for i in range(n): if nums[i] != sorted_nums[i]: if start is None: start = i end = i if start is None: return 0 # Already sorted if nums[start:end+1] == sorted_nums[start:end+1][::-1]: return 1 return 2"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: Remove the n-th node from the end of the list and return its head. Given the linked list: 1->2->3->4->5, and n = 2. After removing the 2nd node from the end, the linked list becomes 1->2->3->5. >>> linked_list = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) >>> result = removeNthFromEnd(linked_list, 2) >>> linked_list_to_list(result) [1, 2, 3, 5] def linked_list_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result def test_removeNthFromEnd(): # Prepare list 1->2->3->4->5 node5 = ListNode(5) node4 = ListNode(4, node5) node3 = ListNode(3, node4) node2 = ListNode(2, node3) head = ListNode(1, node2) # Test removing 2nd from end (should return 1->2->3->5) new_head = removeNthFromEnd(head, 2) assert linked_list_to_list(new_head) == [1, 2, 3, 5] def test_removeNthFromEnd_single_element(): # Prepare list 1 head = ListNode(1) # Test removing 1st from end (should return an empty list) new_head = removeNthFromEnd(head, 1) assert linked_list_to_list(new_head) == [] def test_removeNthFromEnd_last_element(): # Prepare list 1->2 node2 = ListNode(2) head = ListNode(1, node2) # Test removing 1st from end (should return 1) new_head = removeNthFromEnd(head, 1) assert linked_list_to_list(new_head) == [1] def test_removeNthFromEnd_first_element(): # Prepare list 1->2->3 node3 = ListNode(3) node2 = ListNode(2, node3) head = ListNode(1, node2) # Test removing 3rd from end (should return 2->3) new_head = removeNthFromEnd(head, 3) assert linked_list_to_list(new_head) == [2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def removeNthFromEnd(head: ListNode, n: int) -> ListNode: # Create a dummy node which acts as a predecessor of the head node dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move first pointer n+1 steps ahead for _ in range(n + 1): first = first.next # Move first to the end, maintaining the gap between first and second while first is not None: first = first.next second = second.next # Now second pointer is just before the node to be removed second.next = second.next.next return dummy.next"},{"question":"def valid_palindrome(s: str) -> bool: Given a string \`s\`, check if it can become a palindrome by removing at most one character. >>> valid_palindrome(\\"racecar\\") True >>> valid_palindrome(\\"abca\\") True >>> valid_palindrome(\\"abc\\") False >>> valid_palindrome(\\"a\\") True >>> valid_palindrome(\\"\\") True","solution":"def valid_palindrome(s): Check if the string can become a palindrome by removing at most one character. def is_palindrome_range(i, j): Check if the substring s[i:j] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Check by removing one character either left or right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return True"},{"question":"def count_unique_triplets(nums: List[int], target: int) -> int: Determine the number of unique triplets in the array that can form the triplet sum closest to the target. If there are multiple triplet sums equally close to the target, return the number of those triplets. Each triplet should be considered only once, even if similar triplets exist in different positions in the array. >>> count_unique_triplets([1, 2, 3, 4, 5], 6) 1 >>> count_unique_triplets([-1, 2, 1, -4], 1) 1 >>> count_unique_triplets([0, 2, 1, -3], 1) 1 >>> count_unique_triplets([1, 1, 1], 5) 1 >>> count_unique_triplets([-3, -2, -5, -8], -10) 1 >>> count_unique_triplets([1, 2, 3, 4, 5], 10) 1","solution":"def count_unique_triplets(nums, target): Determine the number of unique triplets in the array that can form the triplet sum closest to the target. If there are multiple triplet sums equally close to the target, return the number of those triplets. nums.sort() n = len(nums) closest_sum = float('inf') closest_triplets = set() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return len(set([(nums[i], nums[left], nums[right])])) if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum closest_triplets = {(nums[i], nums[left], nums[right])} elif abs(target - current_sum) == abs(target - closest_sum): closest_triplets.add((nums[i], nums[left], nums[right])) if current_sum < target: left += 1 else: right -= 1 return len(closest_triplets)"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Return a list of all the strings in 'words' that match the 'pattern'. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"xyz\\", \\"aab\\", \\"def\\", \\"hikk\\"], \\"zzy\\") [\\"aab\\"] >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mno\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"abb\\", \\"cdd\\", \\"eff\\"], \\"abb\\") [\\"abb\\", \\"cdd\\", \\"eff\\"] >>> find_and_replace_pattern([\\"abcd\\", \\"dcba\\", \\"a\\"], \\"xy\\") []","solution":"def find_and_replace_pattern(words, pattern): def matches(word): if len(word) != len(pattern): return False char_map = {} reverse_char_map = {} for w, p in zip(word, pattern): if w not in char_map: char_map[w] = p if p not in reverse_char_map: reverse_char_map[p] = w if char_map[w] != p or reverse_char_map[p] != w: return False return True return [word for word in words if matches(word)]"},{"question":"def kth_distinct_substring(text: str, k: int) -> str: Returns the k-th distinct substring of \`text\` sorted in lexicographical order. If there are fewer than k distinct substrings, return an empty string. Args: text (str): The input string containing lowercase English letters. k (int): The k-th position of the distinct substring to return. Returns: str: The k-th distinct substring or an empty string if k is out of range. Examples: >>> kth_distinct_substring(\\"abc\\", 1) \\"a\\" >>> kth_distinct_substring(\\"abc\\", 2) \\"ab\\" >>> kth_distinct_substring(\\"abc\\", 3) \\"abc\\" >>> kth_distinct_substring(\\"abc\\", 7) \\"\\" >>> kth_distinct_substring(\\"aaa\\", 2) \\"aa\\" from solution import kth_distinct_substring def test_kth_distinct_substring_basic(): assert kth_distinct_substring(\\"abc\\", 1) == \\"a\\" assert kth_distinct_substring(\\"abc\\", 2) == \\"ab\\" assert kth_distinct_substring(\\"abc\\", 3) == \\"abc\\" assert kth_distinct_substring(\\"abc\\", 4) == \\"b\\" assert kth_distinct_substring(\\"abc\\", 5) == \\"bc\\" assert kth_distinct_substring(\\"abc\\", 6) == \\"c\\" def test_kth_distinct_substring_insufficient_k(): assert kth_distinct_substring(\\"abc\\", 7) == \\"\\" assert kth_distinct_substring(\\"abc\\", 10) == \\"\\" def test_kth_distinct_substring_repeated_chars(): assert kth_distinct_substring(\\"aaa\\", 1) == \\"a\\" assert kth_distinct_substring(\\"aaa\\", 2) == \\"aa\\" assert kth_distinct_substring(\\"aaa\\", 3) == \\"aaa\\" def test_kth_distinct_substring_mixed_chars(): assert kth_distinct_substring(\\"abca\\", 1) == \\"a\\" assert kth_distinct_substring(\\"abca\\", 2) == \\"ab\\" assert kth_distinct_substring(\\"abca\\", 3) == \\"abc\\" assert kth_distinct_substring(\\"abca\\", 4) == \\"abca\\" assert kth_distinct_substring(\\"abca\\", 5) == \\"b\\" assert kth_distinct_substring(\\"abca\\", 6) == \\"bc\\" assert kth_distinct_substring(\\"abca\\", 7) == \\"bca\\" assert kth_distinct_substring(\\"abca\\", 8) == \\"c\\" assert kth_distinct_substring(\\"abca\\", 9) == \\"ca\\" def test_kth_distinct_substring_edge_case_empty_string(): assert kth_distinct_substring(\\"\\", 1) == \\"\\" assert kth_distinct_substring(\\"\\", 10) == \\"\\" def test_kth_distinct_substring_edge_case_single_char(): assert kth_distinct_substring(\\"a\\", 1) == \\"a\\" assert kth_distinct_substring(\\"a\\", 2) == \\"\\"","solution":"def kth_distinct_substring(text, k): Returns the k-th distinct substring sorted in lexicographical order. If there are fewer than k distinct substrings, return an empty string. substrings = set() for i in range(len(text)): for j in range(i + 1, len(text) + 1): substrings.add(text[i:j]) sorted_substrings = sorted(substrings) if k-1 < len(sorted_substrings): return sorted_substrings[k-1] else: return \\"\\""},{"question":"def maxSubarraySum(nums, k): Returns the maximum sum of a subarray of size k. >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSubarraySum([2, 3], 3) 0 >>> maxSubarraySum([5], 1) 5 >>> maxSubarraySum([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) 35 >>> maxSubarraySum([-2, -3, -4, -5], 2) -5","solution":"def maxSubarraySum(nums, k): Returns the maximum sum of a subarray of size k. n = len(nums) if n < k: return 0 max_sum = float('-inf') current_sum = 0 # Compute the sum of the first \`k\` elements for i in range(k): current_sum += nums[i] max_sum = current_sum # Slide the window from start to end in array for i in range(k, n): current_sum += nums[i] - nums[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def trap(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped between the columns after it rains. :param heights: List of integers representing the heights of columns. :return: Integer representing the total trapped water amount. >>> trap([]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([2, 0, 2]) == 2 >>> trap([3, 0, 0, 2, 0, 4]) == 10 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([3, 3, 3, 3, 3]) == 0","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped between the columns after it rains. :param heights: List of integers representing the heights of columns. :return: Integer representing the total trapped water amount. if not heights: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] trapped_water = 0 while left < right: if heights[left] < heights[right]: left += 1 left_max = max(left_max, heights[left]) trapped_water += left_max - heights[left] else: right -= 1 right_max = max(right_max, heights[right]) trapped_water += right_max - heights[right] return trapped_water"},{"question":"def can_rearrange_subarray_sum_k(arr: List[int], k: int) -> bool: Determine if elements of arr can be rearranged such that the sum of every contiguous subarray of length k is the same. :param arr: List[int], list of integers :param k: int, length of the subarrays :return: bool, True if possible, False otherwise >>> can_rearrange_subarray_sum_k([4, 1, 7, 7, 7, 7], 2) == False >>> can_rearrange_subarray_sum_k([2, 1, 3, 3, 2, 3], 3) == False >>> can_rearrange_subarray_sum_k([], 1) == False >>> can_rearrange_subarray_sum_k([1, 2, 3], 4) == False >>> can_rearrange_subarray_sum_k([3, 3, 3], 3) == True >>> can_rearrange_subarray_sum_k([3], 1) == True >>> can_rearrange_subarray_sum_k([1, 2, -1, 2, 1], 2) == False","solution":"def can_rearrange_subarray_sum_k(arr, k): Determine if elements of arr can be rearranged such that the sum of every contiguous subarray of length k is the same. :param arr: List[int], list of integers :param k: int, length of the subarrays :return: bool, True if possible, False otherwise # The length of array n = len(arr) # Early exit: If k is larger than n, it's impossible to have any subarray of length k if k > n: return False # Total sum of all the elements in the array total_sum = sum(arr) # Check if the total sum is divisible by number of subarrays of length k (n // k) our_target_total_sum = total_sum / (n // k) if int(our_target_total_sum) != our_target_total_sum: return False our_target_total_sum = int(our_target_total_sum) # Potentially try converting this to a complete mathematical problem # and solve for party sums. # Sort the array arr.sort() subarray_sum = sum(arr[:k]) # Check if sum of every contiguous subarray of length k is equal to target_sum if subarray_sum != our_target_total_sum: return False sliding_window_sum = subarray_sum for i in range(1, n - k + 1): # Sliding window sum sliding_window_sum = sliding_window_sum - arr[i-1] + arr[i + k - 1] if sliding_window_sum != our_target_total_sum: return False # If all the checks passed, return True return True"},{"question":"def make_nice(nums) -> int: Removes the minimum number of elements from nums to ensure there are no three consecutive integers in the array. >>> make_nice([1, 2, 3]) == 0 >>> make_nice([1, 2, 1, 2, 1, 2]) == 0 >>> make_nice([1, 1, 1, 2, 2, 3]) == 1 >>> make_nice([1, 2, 2, 2, 3, 4]) == 1 >>> make_nice([1, 1, 1, 1, 1, 1]) == 2 >>> make_nice([1, 1, 1, 1, 2, 2, 2]) == 2 >>> make_nice([]) == 0 >>> make_nice([1, 1]) == 0 >>> make_nice([1, 2]) == 0 >>> make_nice([1, 1, 1]) == 1 >>> make_nice([1, 2, 1]) == 0","solution":"def make_nice(nums): Removes the minimum number of elements from nums to ensure there are no three consecutive integers in the array. if len(nums) <= 2: return 0 removals = 0 i = 2 while i < len(nums): if nums[i] == nums[i-1] == nums[i-2]: removals += 1 i += 1 i += 1 return removals"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the binary tree rooted at root. >>> right_side_view(None) [] >>> root = TreeNode(1) >>> right_side_view(root) [1] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> right_side_view(root) [1, 3, 6] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> right_side_view(root) [1, 3, 4]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the right side view of the binary tree rooted at root. if not root: return [] right_view = [] queue = deque([root]) while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None): self.val = val self.left = left self.right = right def min_swaps_binary_tree(root: Optional[TreeNode]) -> int: Determine the minimum number of swaps required so that all nodes' subtrees are in increasing order of their \`val\` starting from the root. Return the minimum number of swaps required. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> min_swaps_binary_tree(root) 0 >>> root = TreeNode(1, TreeNode(3), TreeNode(2)) >>> min_swaps_binary_tree(root) 1 >>> root = TreeNode(1, TreeNode(3, TreeNode(4), TreeNode(0)), TreeNode(2, TreeNode(1), TreeNode(4))) >>> min_swaps_binary_tree(root) 3 >>> min_swaps_binary_tree(None) 0 pass","solution":"def min_swaps_to_sort(arr): Helper function to count the minimum number of swaps required to sort an array. n = len(arr) arrpos = [(val, idx) for idx, val in enumerate(arr)] arrpos.sort() visited = {k: False for k in range(n)} ans = 0 for i in range(n): if visited[i] or arrpos[i][1] == i: continue cycle_size = 0 j = i while not visited[j]: visited[j] = True j = arrpos[j][1] cycle_size += 1 if cycle_size > 0: ans += cycle_size - 1 return ans def level_order_traversal(node): Helper function to get the level order traversal values of a binary tree. from collections import deque if not node: return [] q = deque([node]) result = [] while q: level_size = len(q) current_level = [] for _ in range(level_size): current_node = q.popleft() current_level.append(current_node.val) if current_node.left: q.append(current_node.left) if current_node.right: q.append(current_node.right) result.append(current_level) return result def min_swaps_binary_tree(root): Function to calculate the minimum number of swaps required so that all nodes' subtrees are in increasing order of their \`val\`. levels = level_order_traversal(root) total_swaps = 0 for level in levels: total_swaps += min_swaps_to_sort(level) return total_swaps class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right"},{"question":"from typing import List def shortest_good_subarray(nums: List[int], k: int) -> int: Return the length of the shortest good subarray. If no such subarray exists, return -1. A continuous subarray of 'nums' is defined to be good if its length is at least 'k' and the sum of the subarray is greater than or equal to the sum of any preceding subarray of length 'k'. >>> shortest_good_subarray([1,2,3], 4) == -1 >>> shortest_good_subarray([1,1,1,1], 3) == 3 >>> shortest_good_subarray([1,1,1,2,3,4], 3) == 3 >>> shortest_good_subarray([1,2,3,4,5], 2) == 2 >>> shortest_good_subarray([5,1,2,3,4], 3) == 3 >>> shortest_good_subarray([5, 1, 7, 2, 5], 2) == 2 >>> shortest_good_subarray([3,1,4,1,5,9,2,6], 3) == 3 >>> shortest_good_subarray([1,1,1,1,1,1,1,1,1,1,1], 10) == 10","solution":"def shortest_good_subarray(nums, k): Return the length of the shortest good subarray. If no such subarray exists, return -1. n = len(nums) if n < k: return -1 max_sum_k = sum(nums[:k]) current_sum = max_sum_k min_length = float('inf') for i in range(k, n): current_sum += nums[i] - nums[i - k] if current_sum >= max_sum_k: max_sum_k = current_sum min_length = k current_sum = sum(nums[:k]) for start in range(1, n - k + 1): end = start + k current_sum += nums[end - 1] - nums[start - 1] if current_sum == max_sum_k: min_length = min(min_length, end - start + 1) for end in range(start + k, n): current_sum += nums[end] - nums[end - k] if current_sum >= max_sum_k and (end - start + 1) > k: min_length = min(min_length, end - start + 1) break return min_length if min_length != float('inf') else -1"},{"question":"def visibleBuildings(heights: List[int]) -> List[bool]: This function returns a list of booleans indicating whether the buildings are visible from the left. :param heights: List of integers representing the heights of the buildings. :return: List of booleans indicating visibility of buildings from the left. >>> visibleBuildings([3, 5, 4, 2, 6, 1]) [True, True, False, False, True, False] >>> visibleBuildings([1, 2, 3, 4, 5]) [True, True, True, True, True] >>> visibleBuildings([5, 5, 5, 5, 5]) [True, False, False, False, False] >>> visibleBuildings([10]) [True] >>> visibleBuildings([]) [] >>> visibleBuildings([5, 4, 3, 2, 1]) [True, False, False, False, False]","solution":"def visibleBuildings(heights): This function returns a list of booleans indicating whether the buildings are visible from the left. :param heights: List of integers representing the heights of the buildings. :return: List of booleans indicating visibility of buildings from the left. if not heights: return [] n = len(heights) visible = [False] * n max_height = 0 for i in range(n): if heights[i] > max_height: visible[i] = True max_height = heights[i] return visible"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Calculates the maximum depth of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The maximum depth of the tree. >>> tree = TreeNode(3) >>> tree.left = TreeNode(9) >>> tree.right = TreeNode(20) >>> tree.right.left = TreeNode(15) >>> tree.right.right = TreeNode(7) >>> maxDepth(tree) 3 >>> maxDepth(TreeNode(1)) 1 >>> maxDepth(None) 0 >>> left_skewed = TreeNode(1) >>> left_skewed.left = TreeNode(2) >>> left_skewed.left.left = TreeNode(3) >>> left_skewed.left.left.left = TreeNode(4) >>> maxDepth(left_skewed) 4 >>> right_skewed = TreeNode(1) >>> right_skewed.right = TreeNode(2) >>> right_skewed.right.right = TreeNode(3) >>> right_skewed.right.right.right = TreeNode(4) >>> maxDepth(right_skewed) 4 >>> unbalanced_tree = TreeNode(1) >>> unbalanced_tree.left = TreeNode(2) >>> unbalanced_tree.right = TreeNode(3) >>> unbalanced_tree.left.left = TreeNode(4) >>> unbalanced_tree.left.left.left = TreeNode(5) >>> maxDepth(unbalanced_tree) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def maxDepth(root): Calculates the maximum depth of a binary tree. Args: root (TreeNode): The root node of the binary tree. Returns: int: The maximum depth of the tree. if not root: return 0 left_depth = maxDepth(root.left) right_depth = maxDepth(root.right) return max(left_depth, right_depth) + 1"},{"question":"[Completion Task in Python] def min_steps_to_converge(nums: List[int]) -> int: Given an array of integers \`nums\` representing coordinates on a line, returns the minimum number of steps required for all persons to converge at a single position. >>> min_steps_to_converge([5]) == 0 >>> min_steps_to_converge([3, 3]) == 0 >>> min_steps_to_converge([1, 4]) == 3 >>> min_steps_to_converge([1, 2, 3]) == 2 >>> min_steps_to_converge([1, 2, 3, 4]) == 4 >>> min_steps_to_converge([-1, -2, -3, -4]) == 4 >>> min_steps_to_converge([-1, 0, 1]) == 2 >>> min_steps_to_converge([-1000, 0, 1000]) == 2000","solution":"def min_steps_to_converge(nums): Given an array of integers \`nums\` representing coordinates on a line, returns the minimum number of steps required for all persons to converge at a single position. The optimal meeting point in one dimension is the median of the coordinates. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"from typing import List def max_array_elements(arr1: List[int], arr2: List[int]) -> List[int]: Returns an array where each element is the maximum value between the corresponding elements of arr1 and arr2. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: An array containing the maximum values between arr1 and arr2. Examples: >>> max_array_elements([1, 2, 3], [3, 2, 1]) [3, 2, 3] >>> max_array_elements([-1, -2, -3], [-3, -2, -1]) [-1, -2, -1] >>> max_array_elements([1, -2, 3], [-1, 4, -3]) [1, 4, 3] >>> max_array_elements([1, 1, 1], [1, 1, 1]) [1, 1, 1] >>> max_array_elements([0, -1, 0], [-3, 0, 3]) [0, 0, 3]","solution":"def max_array_elements(arr1, arr2): Returns an array where each element is the maximum value between the corresponding elements of arr1 and arr2. Parameters: arr1 (list of int): The first input array. arr2 (list of int): The second input array. Returns: list of int: An array containing the maximum values between arr1 and arr2. return [max(a, b) for a, b in zip(arr1, arr2)]"},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring('') == 0 >>> longest_unique_substring('abcdef') == 6 >>> longest_unique_substring('aaaa') == 1 >>> longest_unique_substring('abcabcbb') == 3 >>> longest_unique_substring('pwwkew') == 3 >>> longest_unique_substring('a') == 1 >>> longest_unique_substring('abc abc bb') == 4","solution":"def longest_unique_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. Parameters: s (str): The input string. Returns: int: The length of the longest substring with all unique characters. n = len(s) if n == 0: return 0 char_index_map = {} max_len = 0 start = 0 for end in range(n): if s[end] in char_index_map: start = max(start, char_index_map[s[end]] + 1) char_index_map[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLongestConsecutiveSequence(root: TreeNode) -> int: Given a binary tree, returns the length of the longest sequence of consecutive integers (no matter the difference is +1 or -1) present in the path from the root to any leaf. If the tree is empty, return 0. >>> findLongestConsecutiveSequence(None) 0 >>> findLongestConsecutiveSequence(TreeNode(1)) 1 def test_empty_tree(): assert findLongestConsecutiveSequence(None) == 0 def test_single_node(): assert findLongestConsecutiveSequence(TreeNode(1)) == 1 def test_example_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(2) root.right.right = TreeNode(4) root.right.left.left = TreeNode(3) root.right.right.left = TreeNode(5) assert findLongestConsecutiveSequence(root) == 4 def test_equal_nodes(): root = TreeNode(1) root.left = TreeNode(1) root.right = TreeNode(1) root.left.left = TreeNode(1) assert findLongestConsecutiveSequence(root) == 1 def test_linear_consecutive_decrement(): root = TreeNode(5) root.left = TreeNode(4) root.left.left = TreeNode(3) root.left.left.left = TreeNode(2) assert findLongestConsecutiveSequence(root) == 4 def test_linear_consecutive_increment(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert findLongestConsecutiveSequence(root) == 4 def test_no_consecutive(): root = TreeNode(1) root.left = TreeNode(3) root.right = TreeNode(5) root.left.left = TreeNode(7) root.right.right = TreeNode(9) assert findLongestConsecutiveSequence(root) == 1","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def findLongestConsecutiveSequence(root): def dfs(node): if not node: return 0, 0 inc, dec = 1, 1 left_inc, left_dec = dfs(node.left) right_inc, right_dec = dfs(node.right) if node.left: if node.val + 1 == node.left.val: inc = left_inc + 1 elif node.val - 1 == node.left.val: dec = left_dec + 1 if node.right: if node.val + 1 == node.right.val: inc = max(inc, right_inc + 1) elif node.val - 1 == node.right.val: dec = max(dec, right_dec + 1) longest[0] = max(longest[0], inc + dec - 1) return inc, dec longest = [0] dfs(root) return longest[0]"},{"question":"def find_two_items(prices: List[int], budget: int) -> List[int]: Finds two distinct items such that the total cost does not exceed the budget and is as close as possible to the budget. Parameters: prices (list of int): List of prices of items. budget (int): Amount of money available. Returns: list of int: Indices of the two items to buy. If no such pair exists, returns [-1, -1]. # Write your code here from solution import find_two_items def test_exact_budget(): prices = [1, 4, 5, 3] budget = 9 result = find_two_items(prices, budget) assert sorted(result) == sorted([1, 2]) def test_under_budget(): prices = [1, 4, 5, 3] budget = 7 result = find_two_items(prices, budget) assert sorted(result) == sorted([1, 3]) def test_no_pair(): prices = [5, 6, 7, 8] budget = 3 result = find_two_items(prices, budget) assert result == [-1, -1] def test_multiple_pairs(): prices = [1, 1, 3, 5, 9] budget = 6 result = find_two_items(prices, budget) assert (result == [0, 3] or result == [2, 4]) def test_single_item(): prices = [1] budget = 5 result = find_two_items(prices, budget) assert result == [-1, -1] def test_large_budget(): prices = [2, 4, 6, 8, 10] budget = 100 result = find_two_items(prices, budget) assert sorted(result) == sorted([3, 4]) def test_exact_item_cost(): prices = [5, 5] budget = 10 result = find_two_items(prices, budget) assert sorted(result) == sorted([0, 1])","solution":"def find_two_items(prices, budget): Finds two distinct items such that the total cost does not exceed the budget and is as close as possible to the budget. Parameters: prices (list of int): List of prices of items. budget (int): Amount of money available. Returns: list of int: Indices of the two items to buy. If no such pair exists, returns [-1, -1]. best_pair = [-1, -1] best_sum = float('-inf') for i in range(len(prices)): for j in range(i + 1, len(prices)): total = prices[i] + prices[j] if total <= budget and total > best_sum: best_sum = total best_pair = [i, j] return best_pair"},{"question":"def count_non_overlapping_subsequences(events: str) -> int: Returns the maximum number of non-overlapping subsequences of consecutive occurrences of the same event type. Args: events (str): A string of length \`n\` representing the events. Returns: int: The count of non-overlapping subsequences. >>> count_non_overlapping_subsequences(\\"AAABBBCCCABAB\\") 7 >>> count_non_overlapping_subsequences(\\"AAAAA\\") 1 >>> count_non_overlapping_subsequences(\\"ABABAB\\") 6 >>> count_non_overlapping_subsequences(\\"A\\") 1 >>> count_non_overlapping_subsequences(\\"\\") 0","solution":"def count_non_overlapping_subsequences(events): Returns the maximum number of non-overlapping subsequences of consecutive occurrences of the same event type. Args: events (str): A string of length \`n\` representing the events. Returns: int: The count of non-overlapping subsequences. if not events: return 0 count = 1 for i in range(1, len(events)): if events[i] != events[i-1]: count += 1 return count"},{"question":"def longest_path_dag(n: int, edges: List[List[int]], start: int, end: int) -> List[int]: Finds the longest path in a directed acyclic graph (DAG) from start to end. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges in the graph. start (int): Starting node. end (int): Ending node. Returns: List[int]: A list of nodes representing the longest path from start to end. If there is no path, return an empty list. def test_longest_path_dag(): assert longest_path_dag(4, [[0, 1], [1, 2], [2, 3]], 0, 3) == [0, 1, 2, 3] assert longest_path_dag(4, [[0, 1], [1, 2], [1, 3], [2, 3]], 0, 3) == [0, 1, 2, 3] or longest_path_dag(4, [[0, 1], [1, 2], [1, 3], [2, 3]], 0, 3) == [0, 1, 3] assert longest_path_dag(4, [[0, 1], [0, 2], [1, 3], [2, 3]], 0, 3) == [0, 1, 3] or longest_path_dag(4, [[0, 1], [0, 2], [1, 3], [2, 3]], 0, 3) == [0, 2, 3] assert longest_path_dag(4, [[0, 1], [1, 2], [1, 3]], 1, 3) == [1, 3] assert longest_path_dag(4, [[0, 1], [1, 2], [1, 3]], 0, 3) == [0, 1, 3] assert longest_path_dag(4, [[0, 1], [1, 2], [2, 3], [0, 2]], 0, 3) == [0, 1, 2, 3] assert longest_path_dag(5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]], 0, 4) == [0, 1, 3, 4] or longest_path_dag(5, [[0, 1], [0, 2], [1, 3], [2, 3], [3, 4]], 0, 4) == [0, 2, 3, 4] assert longest_path_dag(3, [[0, 1], [0, 2], [1, 2]], 0, 2) == [0, 1, 2] assert longest_path_dag(4, [[0, 1], [1, 2]], 0, 3) == [] assert longest_path_dag(4, [[0, 1], [2, 3]], 0, 2) == [] assert longest_path_dag(5, [[0, 1], [1, 2], [2, 3]], 4, 0) == []","solution":"from collections import defaultdict, deque def longest_path_dag(n, edges, start, end): Finds the longest path in a directed acyclic graph (DAG) from start to end. Parameters: n (int): Number of nodes in the graph. edges (List[List[int]]): List of directed edges in the graph. start (int): Starting node. end (int): Ending node. Returns: List[int]: A list of nodes representing the longest path from start to end. If there is no path, return an empty list. adj_list = defaultdict(list) in_degree = [0] * n distances = [-float('inf')] * n predecessors = [-1] * n for u, v in edges: adj_list[u].append(v) in_degree[v] += 1 distances[start] = 0 queue = deque([u for u in range(n) if in_degree[u] == 0]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if distances[node] + 1 > distances[neighbor]: distances[neighbor] = distances[node] + 1 predecessors[neighbor] = node in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if distances[end] == -float('inf'): return [] path = [] current = end while current != -1: path.append(current) current = predecessors[current] return path[::-1]"},{"question":"def pivot_index(nums: List[int]) -> int: Returns the smallest index i such that the sum of the elements to the left of i is equal to the sum of the elements to the right of i. If no such index exists, returns -1. >>> pivot_index([1, 7, 3, 6, 5, 6]) == 3 >>> pivot_index([1, 2, 3]) == -1 >>> pivot_index([1]) == 0 >>> pivot_index([2, 1, -1, 1, 2, 1, -1, 1, 2]) == 4 >>> pivot_index([0, 0, 0, 0, 0]) == 0 >>> pivot_index([-1, -1, -1, 0, 1, 1]) == 0","solution":"def pivot_index(nums): Returns the smallest index i such that the sum of the elements to the left of i is equal to the sum of the elements to the right of i. If no such index exists, returns -1. total_sum = sum(nums) left_sum = 0 for i, num in enumerate(nums): if left_sum == (total_sum - left_sum - num): return i left_sum += num return -1"},{"question":"def minimal_operations_to_equal_elements(nums: List[int]) -> int: Returns the minimal number of operations required to make all elements equal. >>> minimal_operations_to_equal_elements([]) == -1 >>> minimal_operations_to_equal_elements([5]) == 0 >>> minimal_operations_to_equal_elements([1, 2]) == 1 >>> minimal_operations_to_equal_elements([1, 2, 3, 4]) == 3 >>> minimal_operations_to_equal_elements([10, 20, 30, 40, 50]) == 4 >>> minimal_operations_to_equal_elements(list(range(100))) == 99","solution":"def minimal_operations_to_equal_elements(nums): Returns the minimal number of operations required to make all elements equal. return len(nums) - 1"},{"question":"from collections import deque from typing import List class Node: def __init__(self, val: int, children: List['Node'] = None): self.val = val self.children = children if children is not None else [] def levelOrder(root: Node) -> List[List[int]]: Perform level-order traversal on an n-ary tree and return a list of lists representing the node values at each level. >>> levelOrder(Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])) [[1], [3, 2, 4], [5, 6]] >>> levelOrder(Node(1, [Node(2, [Node(5), Node(6)]), Node(3, [Node(7)]), Node(4, [Node(8), Node(9)])])) [[1], [2, 3, 4], [5, 6, 7, 8, 9]]","solution":"from collections import deque class Node: def __init__(self, val, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root): if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) queue.extend(node.children) result.append(current_level) return result"},{"question":"def countAndSay(n: int) -> str: Generate the n-th term of the count-and-say sequence. The count-and-say sequence is a sequence of digit strings defined by the recursive formula: - countAndSay(1) = \\"1\\" - countAndSay(n) is generated by reading the previous term and counting the number of digits in groups of the same digit. >>> countAndSay(1) \\"1\\" >>> countAndSay(2) \\"11\\" >>> countAndSay(3) \\"21\\" >>> countAndSay(4) \\"1211\\" >>> countAndSay(5) \\"111221\\" >>> countAndSay(6) \\"312211\\" >>> countAndSay(10) \\"13211311123113112211\\" pass","solution":"def countAndSay(n): Generates the n-th term of the count-and-say sequence. def next_number(s): result = [] i = 0 while i < len(s): count = 1 while i + 1 < len(s) and s[i] == s[i + 1]: i += 1 count += 1 result.append(str(count) + s[i]) i += 1 return ''.join(result) current = \\"1\\" for _ in range(1, n): current = next_number(current) return current"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse the nodes of the list k at a time and return its modified list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> k = 2 >>> list_to_array(reverseKGroup(head, k)) [2, 1, 4, 3, 5] >>> head = array_to_list([1, 2, 3, 4, 5, 6, 7, 8]) >>> k = 3 >>> list_to_array(reverseKGroup(head, k)) [3, 2, 1, 6, 5, 4, 7, 8] >>> head = array_to_list([1, 2, 3, 4]) >>> k = 4 >>> list_to_array(reverseKGroup(head, k)) [4, 3, 2, 1] >>> head = array_to_list([1, 2, 3, 4]) >>> k = 1 >>> list_to_array(reverseKGroup(head, k)) [1, 2, 3, 4] >>> head = array_to_list([1, 2, 3, 4, 5]) >>> k = 3 >>> list_to_array(reverseKGroup(head, k)) [3, 2, 1, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: def reverseLinkedList(head, k): prev, curr = None, head while k: next_node = curr.next curr.next = prev prev = curr curr = next_node k -= 1 return prev count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversedHead = reverseLinkedList(head, k) head.next = reverseKGroup(ptr, k) return reversedHead return head"},{"question":"def count_taller_students(heights): Returns an array where the ith element is the number of students in front of the ith student who are taller than heights[i]. :param heights: List of integers representing the heights of students. :return: List of integers representing the number of taller students in front of each student. >>> count_taller_students([]) == [] >>> count_taller_students([150]) == [0] >>> count_taller_students([150, 160]) == [0, 0] >>> count_taller_students([160, 150]) == [0, 1] >>> count_taller_students([160, 160, 160]) == [0, 0, 0] >>> count_taller_students([150, 160, 170, 180]) == [0, 0, 0, 0] >>> count_taller_students([180, 170, 160, 150]) == [0, 1, 2, 3] >>> count_taller_students([170, 160, 180, 150, 175]) == [0, 1, 0, 3, 1]","solution":"def count_taller_students(heights): Returns an array where the ith element is the number of students in front of the ith student who are taller than heights[i]. :param heights: List of integers representing the heights of students. :return: List of integers representing the number of taller students in front of each student. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i): if heights[j] > heights[i]: count += 1 result[i] = count return result"},{"question":"from typing import List, Tuple def shortest_path(mat: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Finds the shortest path in a binary matrix from start to target. Args: - mat (list of list of int): The binary matrix representation of the maze. - start (tuple of int, int): The starting coordinates (row, col). - target (tuple of int, int): The target coordinates (row, col). Returns: - int: The length of the shortest path, or -1 if no path exists. >>> mat = [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(mat, start, target) 4 >>> mat = [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(mat, start, target) -1 >>> mat = [ ... [1, 0, 0], ... [0, 0, 0], ... [0, 1, 0] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(mat, start, target) -1 >>> mat = [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 1, 1] ... ] >>> start = (0, 0) >>> target = (2, 2) >>> shortest_path(mat, start, target) -1 >>> mat = [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 1, 0] ... ] >>> start = (1, 1) >>> target = (1, 1) >>> shortest_path(mat, start, target) 0 >>> mat = [ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (4, 3) >>> shortest_path(mat, start, target) 7 >>> mat = [ ... [0, 0, 0, 0], ... [1, 1, 0, 1], ... [0, 1, 1, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (4, 3) >>> shortest_path(mat, start, target) -1","solution":"from collections import deque def shortest_path(mat, start, target): Finds the shortest path in a binary matrix from start to target. Args: - mat (list of list of int): The binary matrix representation of the maze. - start (tuple of int, int): The starting coordinates (row, col). - target (tuple of int, int): The target coordinates (row, col). Returns: - int: The length of the shortest path, or -1 if no path exists. rows, cols = len(mat), len(mat[0]) sr, sc = start tr, tc = target if mat[sr][sc] == 1 or mat[tr][tc] == 1: return -1 def is_valid(r, c): return 0 <= r < rows and 0 <= c < cols and mat[r][c] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sr, sc, 0)]) # (row, col, distance) visited = set() visited.add((sr, sc)) while queue: r, c, dist = queue.popleft() if (r, c) == (tr, tc): return dist for dr, dc in directions: nr, nc = r + dr, c + dc if is_valid(nr, nc) and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def min_difference(flavors, minSweetness, maxBitterness): Returns the minimum difference between sweetness and bitterness of flavors that meet the condition: sweetness >= minSweetness and bitterness <= maxBitterness. >>> min_difference([[1, 10], [2, 15]], 3, 5) -1 >>> min_difference([[6, 2], [8, 4]], 5, 3) 4 >>> min_difference([[5, 3], [10, 2], [15, 10]], 5, 10) 2 >>> min_difference([[10, 2], [10, 10]], 7, 11) 0 >>> min_difference([[4, 4], [5, 5]], 4, 5) 0 >>> min_difference([[8, 2], [12, 6], [16, 14]], 5, 10) 6 >>> min_difference([], 3, 4) -1 >>> min_difference([[10, 10], [20, 20]], 10, 20) 0","solution":"def min_difference(flavors, minSweetness, maxBitterness): Returns the minimum difference between sweetness and bitterness of flavors that meet the condition: sweetness >= minSweetness and bitterness <= maxBitterness. :param flavors: List[List[int]]: a 2D list of flavors where each flavor is represented as [sweetness, bitterness] :param minSweetness: int: minimum sweetness level a flavor must have :param maxBitterness: int: maximum bitterness level a flavor must not exceed :return: int: minimum difference between sweetness and bitterness that meets the condition, or -1 if no such flavor exists min_diff = float('inf') found_valid = False for sweetness, bitterness in flavors: if sweetness >= minSweetness and bitterness <= maxBitterness: found_valid = True min_diff = min(min_diff, abs(sweetness - bitterness)) return min_diff if found_valid else -1"},{"question":"def findSubsets(nums: List[int]) -> List[List[int]]: Finds and returns all subsets of a given list of integers without duplicates, sorted lexicographically. >>> findSubsets([]) == [[]] >>> findSubsets([1]) == [[], [1]] >>> findSubsets([1, 2]) == [[], [1], [1, 2], [2]] >>> findSubsets([1, 2, 2]) == [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]] >>> findSubsets([2, 2, 2]) == [[], [2], [2, 2], [2, 2, 2]] >>> findSubsets([-1, 0, 1]) == [[], [-1], [-1, 0], [-1, 0, 1], [-1, 1], [0], [0, 1], [1]] >>> findSubsets([1,2,3,4]) == [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4], [1, 2, 4], [1, 3], [1, 3, 4], [1, 4], [2], [2, 3], [2, 3, 4], [2, 4], [3], [3, 4], [4]]","solution":"def findSubsets(nums): Finds and returns all subsets of a given list of integers without duplicates, sorted lexicographically. def backtrack(start, path): res.append(path[:]) for i in range(start, len(nums)): if i > start and nums[i] == nums[i - 1]: continue path.append(nums[i]) backtrack(i + 1, path) path.pop() nums.sort() res = [] backtrack(0, []) return sorted(res)"},{"question":"class HtmlElement: Class to represent an HTML element with a tag name, attributes, and children. Methods: - __init__(self, tag: str) - set_attribute(self, key: str, value: str) - add_child(self, child: 'HtmlElement') - render(self, level: int = 0) -> str def __init__(self, tag: str): Initializes the HtmlElement with the specified tag name. pass def set_attribute(self, key: str, value: str): Sets an attribute for the HTML element. pass def add_child(self, child: 'HtmlElement'): Adds a child HTML element to the current element. pass def render(self, level: int = 0) -> str: Returns a string representation of the HTML element. pass import pytest def test_initialization(): elem = HtmlElement(\\"div\\") assert elem.tag == \\"div\\" assert elem.attributes == {} assert elem.children == [] def test_set_attribute(): elem = HtmlElement(\\"div\\") elem.set_attribute(\\"class\\", \\"container\\") elem.set_attribute(\\"id\\", \\"main\\") assert elem.attributes == {\\"class\\": \\"container\\", \\"id\\": \\"main\\"} def test_add_child(): parent = HtmlElement(\\"div\\") child = HtmlElement(\\"p\\") parent.add_child(child) assert parent.children == [child] def test_render_no_children(): elem = HtmlElement(\\"div\\") elem.set_attribute(\\"class\\", \\"container\\") assert elem.render() == '<div class=\\"container\\">n</div>' def test_render_with_children(): div = HtmlElement(\\"div\\") div.set_attribute(\\"class\\", \\"container\\") p = HtmlElement(\\"p\\") p.set_attribute(\\"style\\", \\"color:red\\") div.add_child(p) expected_output = '<div class=\\"container\\">n <p style=\\"color:red\\">n </p>n</div>' assert div.render() == expected_output def test_render_complex_structure(): div = HtmlElement(\\"div\\") div.set_attribute(\\"class\\", \\"container\\") p1 = HtmlElement(\\"p\\") p1.set_attribute(\\"style\\", \\"color:red\\") p2 = HtmlElement(\\"p\\") p2.set_attribute(\\"style\\", \\"color:blue\\") div.add_child(p1) div.add_child(p2) expected_output = '<div class=\\"container\\">n <p style=\\"color:red\\">n </p>n <p style=\\"color:blue\\">n </p>n</div>' assert div.render() == expected_output","solution":"class HtmlElement: def __init__(self, tag): self.tag = tag self.attributes = {} self.children = [] def set_attribute(self, key, value): self.attributes[key] = value def add_child(self, child): self.children.append(child) def render(self, level=0): indent = \\" \\" * level attrs = [f'{k}=\\"{v}\\"' for k, v in self.attributes.items()] attrs_str = \\" \\".join(attrs) open_tag = f\\"{indent}<{self.tag}\\" + (f\\" {attrs_str}\\" if attrs_str else \\"\\") + \\">\\" close_tag = f\\"{indent}</{self.tag}>\\" children_str = \\"n\\".join(child.render(level+1) for child in self.children) if children_str: return f\\"{open_tag}n{children_str}n{close_tag}\\" else: return f\\"{open_tag}n{close_tag}\\""},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a 0-indexed integer array \`nums\` of length \`n\`, return a new array \`answer\` such that \`answer[i]\` is equal to the product of all the elements of \`nums\` except \`nums[i]\`. You must solve it without using division and in O(n) time complexity. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) [0, 0, 8, 0] >>> product_except_self([-1, -2, -3, -4]) [-24, -12, -8, -6] >>> product_except_self([-1, 2, -3, 4]) [-24, 12, -8, 6] >>> product_except_self([5]) [1] >>> product_except_self([2, 3]) [3, 2] >>> product_except_self([]) [] >>> product_except_self([2, 2, 3, 3]) [18, 18, 12, 12]","solution":"def product_except_self(nums): Given an array nums, returns an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. :param nums: List[int] :returns: List[int] n = len(nums) if n == 0: return [] # Step 1: Initialize the resultant array with 1s answer = [1] * n # Step 2: Calculate the products of elements to the left of each index left_product = 1 for i in range(n): answer[i] = left_product left_product *= nums[i] # Step 3: Calculate the products of elements to the right of each index right_product = 1 for i in range(n-1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Returns indices of two distinct elements in \`nums\` that add up to \`target\`. If no such pair exists, return an empty list. Parameters: nums (List[int]): List of integers. target (int): Target sum of two elements. Returns: List[int]: Indices of the two elements that add up to the target sum. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([2, 7, 11, 15], 10) [] >>> result = two_sum([3, 2, 4], 6) >>> result == [1, 2] or result == [0, 2] True >>> two_sum([-3, 4, 3, 90], 0) [0, 2] >>> two_sum([1], 2) [] >>> two_sum([1000000000, 3, 999999997, 4], 1000000000) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 1, 2], 5) []","solution":"def two_sum(nums, target): Returns indices of two distinct elements in \`nums\` that add up to \`target\`. If no such pair exists, return an empty list. Parameters: nums (list): List of integers. target (int): Target sum of two elements. Returns: list: Indices of the two elements that add up to the target sum. index_map = {} for index, num in enumerate(nums): difference = target - num if difference in index_map: return [index_map[difference], index] index_map[num] = index return []"},{"question":"def can_split_string(s: str) -> bool: Determine if the string can be split into two non-empty parts such that each part contains at least one vowel and the number of vowels in the two parts are equal. >>> can_split_string('aabb') True >>> can_split_string('aeiouaeiou') True >>> can_split_string('bcdfg') False >>> can_split_string('aeioub') False >>> can_split_string('ae') True >>> can_split_string('ea') True >>> can_split_string('u') False >>> can_split_string('b') False >>> can_split_string('baceb') True >>> can_split_string('abzcdzeu') False >>> can_split_string('zazbziz') True","solution":"def can_split_string(s): Determine if the string can be split into two non-empty parts such that each part contains at least one vowel and the number of vowels in the two parts are equal. if len(s) < 2: return False vowels = set('aeiou') total_vowels = sum(1 for char in s if char in vowels) if total_vowels < 2 or total_vowels % 2 != 0: return False left_vowel_count = 0 for i in range(len(s) - 1): if s[i] in vowels: left_vowel_count += 1 if left_vowel_count == total_vowels // 2: return True return False"},{"question":"def find_winning_team(participants: List[List[int]], skills: List[int]) -> List[int]: Find the winning team based on participants' skill levels. :param participants: List of teams. Each team is a list containing 1 or 2 participant IDs. :param skills: List of skill levels of participants. :return: List of participant IDs of the winning team. pass from solution import find_winning_team def test_single_participant_teams(): participants = [[1], [2], [3]] skills = [10, 20, 30] assert find_winning_team(participants, skills) == [3] def test_multiple_teams(): participants = [[1, 2], [3, 4], [5, 6]] skills = [10, 20, 30, 40, 50, 60] assert find_winning_team(participants, skills) == [5, 6] def test_mixed_single_and_double_participant_teams(): participants = [[1], [2, 3], [4, 5], [6]] skills = [10, 20, 15, 25, 35, 5] assert find_winning_team(participants, skills) == [4, 5] def test_multiple_winning_teams_same_score(): participants = [[1, 2], [3, 4], [5, 6]] skills = [10, 20, 20, 10, 15, 15] assert find_winning_team(participants, skills) == [1, 2] def test_no_teams(): participants = [] skills = [10, 20, 30] assert find_winning_team(participants, skills) == [] def test_single_team_with_highest_score(): participants = [[1, 2], [3, 4], [5, 6], [7, 8]] skills = [10, 20, 30, 40, 50, 60, 70, 80] assert find_winning_team(participants, skills) == [7, 8]","solution":"def find_winning_team(participants, skills): Find the winning team based on participants' skill levels. :param participants: List of teams. Each team is a list containing 1 or 2 participant IDs. :param skills: List of skill levels of participants. :return: List of participant IDs of the winning team. if not participants: return [] max_score = -1 winning_team = [] for team in participants: score = sum(skills[participant - 1] for participant in team) if score > max_score: max_score = score winning_team = team return winning_team"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Implement a function that takes an integer array and an integer \`k\` and returns the \`k\`th largest element in the array. Note that it is the \`k\`th largest element in sorted order, not the \`k\`th distinct element. You may assume \`k\` is always valid, 1 ≤ k ≤ array's length. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> find_kth_largest([3, 2, 1, 5, 6, 4], 6) 1 >>> find_kth_largest([3, 2, 1, 5, 6, 4], 1) 6 >>> find_kth_largest([-1, 2, 0], 2) 0 >>> find_kth_largest([2, 2, 2, 2], 3) 2","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the array nums. # Sort the array in descending order nums.sort(reverse=True) # kth largest element is at index k-1 after sorting return nums[k-1]"},{"question":"def removeOccurrences(s: str, part: str) -> str: Removes all occurrences of the substring \`part\` from the string \`s\` iteratively until none remain. Parameters: s (str): The original string. part (str): The substring to be removed from the original string. Returns: str: The final string after all occurrences of \`part\` have been removed. >>> removeOccurrences(\\"daabcbaabcbc\\", \\"abc\\") 'dab' >>> removeOccurrences(\\"hello\\", \\"xyz\\") 'hello' >>> removeOccurrences(\\"aaaa\\", \\"a\\") '' >>> removeOccurrences(\\"abcabcabc\\", \\"abc\\") '' >>> removeOccurrences(\\"aabbcc\\", \\"abc\\") 'aabbcc' >>> removeOccurrences(\\"abcpqrabc\\", \\"abc\\") 'pqr' pass","solution":"def removeOccurrences(s, part): Removes all occurrences of the substring \`part\` from the string \`s\` iteratively until none remain. Parameters: s (str): The original string. part (str): The substring to be removed from the original string. Returns: str: The final string after all occurrences of \`part\` have been removed. while part in s: s = s.replace(part, '', 1) return s"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: TreeNode) -> int: Returns the maximum sum of values starting from the root node and ending at any leaf node. >>> root = TreeNode(5) >>> max_sum_path(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> max_sum_path(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4), TreeNode(5)) >>> root.right = TreeNode(3, TreeNode(6), TreeNode(7)) >>> max_sum_path(root) 11 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(7) >>> root.right = TreeNode(20) >>> root.right.right = TreeNode(30) >>> max_sum_path(root) 60 >>> max_sum_path(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_sum_path(root: TreeNode) -> int: Returns the maximum sum of values starting from the root node and ending at any leaf node. if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_sum_path(root.left) if root.left else 0 right_sum = max_sum_path(root.right) if root.right else 0 return root.val + max(left_sum, right_sum)"},{"question":"def can_partition(nums, x, y): Determines if it is possible to partition the array into two non-empty parts such that one part has sum x and the other part has sum y. Args: nums (list): List of integers. x (int): Desired sum for the first part. y (int): Desired sum for the second part. Returns: bool: True if such a partition exists, otherwise False. pass from solution import can_partition def test_partition_possible(): assert can_partition([1, 2, 3, 4], 3, 7) == True assert can_partition([1, 1, 1, 1, 2, 2], 4, 4) == True def test_partition_not_possible(): assert can_partition([1, 2, 3, 4], 10, 5) == False assert can_partition([1, 1, 1, 1], 2, 3) == False assert can_partition([1, 1, 1, 1], 5, 4) == False def test_partition_empty_and_single_element(): assert can_partition([], 1, 1) == False assert can_partition([1], 1, 0) == False assert can_partition([1], 0, 1) == False def test_partition_with_zero_sums(): assert can_partition([0, 1, 2, 3], 3, 3) == True assert can_partition([0, 0, 0], 0, 0) == True","solution":"def can_partition(nums, x, y): Determines if it is possible to partition the array into two non-empty parts such that one part has sum x and the other part has sum y. Args: nums (list): List of integers. x (int): Desired sum for the first part. y (int): Desired sum for the second part. Returns: bool: True if such a partition exists, otherwise False. n = len(nums) total = sum(nums) if total != x + y: return False current_sum = 0 for i in range(n - 1): # n-1 to ensure two non-empty parts current_sum += nums[i] if current_sum == x: return True return False"},{"question":"def contains_arithmetic_progression(arr: List[int]) -> bool: Determines if there are three indices (i, j, k) with 0 <= i < j < k < len(arr) such that arr[i], arr[j], and arr[k] form an arithmetic progression. :param arr: List of sorted integers. :return: Boolean indicating the existence of such an arithmetic progression. >>> contains_arithmetic_progression([1, 2, 3]) True >>> contains_arithmetic_progression([1, 2, 4, 8]) False >>> contains_arithmetic_progression([1, 3, 5, 7, 9]) True >>> contains_arithmetic_progression([1, 2, 4, 6, 8]) True >>> contains_arithmetic_progression([1]) False >>> contains_arithmetic_progression([1, 2]) False >>> contains_arithmetic_progression([1000000000, 1000000003, 1000000006]) True >>> contains_arithmetic_progression([1, 1, 1, 2, 2, 2]) True","solution":"def contains_arithmetic_progression(arr): Determines if there are three indices (i, j, k) with 0 <= i < j < k < len(arr) such that arr[i], arr[j], and arr[k] form an arithmetic progression. :param arr: List of sorted integers. :return: Boolean indicating the existence of such an arithmetic progression. n = len(arr) if n < 3: return False for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if arr[j] - arr[i] == arr[k] - arr[j]: return True return False"},{"question":"class ProjectManager: A class to keep track of task completion in projects. Each project is composed of multiple tasks, and each task can either be incomplete or complete. def __init__(self, tasks: List[str]): Initializes the ProjectManager with an array of tasks, each represented by a unique identifier (string). def completeTask(self, taskId: str) -> None: Marks the task with the given taskId as complete. If the taskId does not exist, it should be ignored. def allTasksCompleted(self) -> bool: Returns True if all tasks in the project are completed, otherwise returns False. def test_initial_state(): pm = ProjectManager([\\"task1\\", \\"task2\\", \\"task3\\"]) assert not pm.allTasksCompleted(), \\"All tasks should not be completed initially\\" def test_mark_single_task_complete(): pm = ProjectManager([\\"task1\\", \\"task2\\", \\"task3\\"]) pm.completeTask(\\"task1\\") assert not pm.allTasksCompleted(), \\"All tasks should not be completed after completing one task\\" def test_mark_all_tasks_complete(): pm = ProjectManager([\\"task1\\", \\"task2\\", \\"task3\\"]) pm.completeTask(\\"task1\\") pm.completeTask(\\"task2\\") pm.completeTask(\\"task3\\") assert pm.allTasksCompleted(), \\"All tasks should be completed after completing all tasks\\" def test_non_existent_task(): pm = ProjectManager([\\"task1\\", \\"task2\\", \\"task3\\"]) pm.completeTask(\\"task4\\") # task4 does not exist assert not pm.allTasksCompleted(), \\"Completing a non-existent task should not mark all tasks as complete\\" def test_duplicate_task_ids(): pm = ProjectManager([\\"task1\\", \\"task1\\", \\"task2\\"]) pm.completeTask(\\"task1\\") pm.completeTask(\\"task2\\") assert pm.allTasksCompleted(), \\"All tasks should be completed even with duplicate task ids after completing them\\" def test_complete_no_tasks(): pm = ProjectManager([]) assert pm.allTasksCompleted(), \\"All tasks should be completed if there are no tasks\\"","solution":"class ProjectManager: def __init__(self, tasks): Initializes the ProjectManager with an array of tasks, each represented by a unique identifier (string). self.tasks = {task: False for task in tasks} def completeTask(self, taskId): Marks the task with the given taskId as complete. If the taskId does not exist, it should be ignored. if taskId in self.tasks: self.tasks[taskId] = True def allTasksCompleted(self): Returns True if all tasks in the project are completed, otherwise returns False. return all(self.tasks.values())"},{"question":"def numIslands(grid: List[List[str]]) -> int: Given a 2D grid of dimensions \`m x n\` with \`1\` representing land and \`0\` representing water, an island is formed by connecting adjacent lands horizontally or vertically. Consider the diagonals as water. Return the number of islands in the grid. >>> numIslands([ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"1\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ]) == 3 >>> numIslands([ [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"0\\"], [\\"1\\", \\"1\\", \\"0\\", \\"0\\", \\"1\\"], [\\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"1\\"] ]) == 4 >>> numIslands([ [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"], [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"0\\"] ]) == 0 >>> numIslands([ [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"], [\\"1\\", \\"1\\", \\"1\\", \\"1\\", \\"1\\"] ]) == 1 >>> numIslands([]) == 0","solution":"def numIslands(grid): def dfs(grid, i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0': return grid[i][j] = '0' dfs(grid, i - 1, j) dfs(grid, i + 1, j) dfs(grid, i, j - 1) dfs(grid, i, j + 1) if not grid: return 0 count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == '1': count += 1 dfs(grid, i, j) return count"},{"question":"from typing import List def shortest_path_maze(grid: List[List[int]]) -> int: Find the shortest path in the maze from (0, 0) to (m-1, n-1). Parameters: - grid: A list of lists where 0 represents a passable cell and 1 represents an impassable cell. Returns: - The length of the shortest path from (0, 0) to (m-1, n-1). If there is no path, return -1. pass def test_shortest_path_maze_simple(): grid = [ [0, 0, 0], [1, 1, 0], [1, 1, 0] ] assert shortest_path_maze(grid) == 5 def test_no_path(): grid = [ [0, 1, 0], [1, 1, 0], [1, 1, 0] ] assert shortest_path_maze(grid) == -1 def test_only_starting_point(): grid = [ [0] ] assert shortest_path_maze(grid) == 1 def test_no_path_with_large_maze(): grid = [ [0, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 0] ] assert shortest_path_maze(grid) == -1 def test_possible_large_maze(): grid = [ [0, 0, 0, 0, 0], [1, 1, 1, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] assert shortest_path_maze(grid) == 9","solution":"from collections import deque def shortest_path_maze(grid): Find the shortest path in the maze from (0, 0) to (m-1, n-1). Parameters: - grid: A list of lists where 0 represents a passable cell and 1 represents an impassable cell. Returns: - The length of the shortest path from (0, 0) to (m-1, n-1). If there is no path, return -1. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return -1 m, n = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) # store (x, y, distance) grid[0][0] = 1 # mark as visited while queue: x, y, dist = queue.popleft() if x == m-1 and y == n-1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) grid[nx][ny] = 1 # mark as visited return -1"},{"question":"def rearrange_string_k_distance(s: str, k: int) -> str: Constructs a new string by reordering the characters in \`s\` so that no two adjacent characters in the new string are the same and each character appears at least \`k\` positions apart from the same character. If it is not possible, it returns an empty string. Args: s (str): The input string consisting of lowercase letters. k (int): The required minimum distance between same characters. Returns: str: The rearranged string or an empty string if not possible. >>> rearrange_string_k_distance(\\"aabbcc\\", 2) in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\", \\"bcbabc\\"] True >>> rearrange_string_k_distance(\\"aa\\", 2) == \\"\\" True >>> rearrange_string_k_distance(\\"a\\", 2) == \\"a\\" True >>> rearrange_string_k_distance(\\"aabbcc\\", 0) == \\"aabbcc\\" True >>> rearrange_string_k_distance(\\"abcdef\\", 2) == \\"abcdef\\" True","solution":"from collections import Counter, deque import heapq def rearrange_string_k_distance(s, k): Constructs a new string by reordering the characters in \`s\` so that no two adjacent characters in the new string are the same and each character appears at least \`k\` positions apart from the same character. If it is not possible, it returns an empty string. Args: s (str): The input string consisting of lowercase letters. k (int): The required minimum distance between same characters. Returns: str: The rearranged string or an empty string if not possible. if k <= 1: return s counter = Counter(s) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] wait_list = deque() # To keep track of characters which need to wait for k positions while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) # Add this character with updated frequency to wait list wait_list.append((char, freq + 1)) # Increase the freq by 1 (since it is negative in heap) # If wait list has reached k items, we can re-add the front item back to heap if len(wait_list) < k: continue front_char, front_freq = wait_list.popleft() if front_freq < 0: # Still has remaining count heapq.heappush(max_heap, (front_freq, front_char)) return ''.join(result) if len(result) == len(s) else ''"},{"question":"from typing import List def min_subarray_length_to_target(nums: List[int], target: int) -> int: Finds the minimum length of a subarray that can be removed such that the sum of the remaining elements equals the target. Parameters: nums (List[int]): A list of positive integers. target (int): The target sum to be achieved by the remaining elements after removal. Returns: int: The minimum length of the subarray to be removed to achieve the target sum. If no such subarray exists, returns -1. def test_min_subarray_length_to_target(): from solution import min_subarray_length_to_target # Test case 1: Basic case assert min_subarray_length_to_target([1, 2, 3, 4, 5], 11) == 1 # Test case 2: No subarray can be removed to achieve target assert min_subarray_length_to_target([1, 2, 3], 7) == -1 # Test case 3: Complete array needs to be removed assert min_subarray_length_to_target([1, 2, 3, 4, 5], 0) == 5 # Test case 4: Removing middle subarray assert min_subarray_length_to_target([1, 2, 2, 1], 3) == 2 # Test case 5: Removing a single element in larger array assert min_subarray_length_to_target([1, 3, 2, 3, 1], 8) == 1 # Test case 6: Removing first element assert min_subarray_length_to_target([5, 1, 2, 3], 6) == 1 # Test case 7: Removing last element assert min_subarray_length_to_target([1, 2, 3, 4], 6) == 1 print(\\"All test cases pass.\\")","solution":"def min_subarray_length_to_target(nums, target): Finds the minimum length of a subarray that can be removed such that the sum of the remaining elements equals the target. Parameters: nums (List[int]): A list of positive integers. target (int): The target sum to be achieved by the remaining elements after removal. Returns: int: The minimum length of the subarray to be removed to achieve the target sum. If no such subarray exists, returns -1. total_sum = sum(nums) n = len(nums) target_sum = total_sum - target if target_sum < 0: return -1 curr_sum = 0 min_len = float('inf') start = 0 for end in range(n): curr_sum += nums[end] while curr_sum > target_sum and start <= end: curr_sum -= nums[start] start += 1 if curr_sum == target_sum: min_len = min(min_len, end - start + 1) return min_len if min_len != float('inf') else -1"},{"question":"def rotate_matrix_90_degrees_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotate an image represented by a matrix 90 degrees clockwise in-place. >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_degrees_clockwise([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_matrix_90_degrees_clockwise([]) [] pass","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates the input matrix by 90 degrees clockwise in place. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - j - 1][i] matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] matrix[j][n - i - 1] = temp return matrix"},{"question":"def largestRectangleArea(heights) -> int: Given an array of integers \`heights\`, where \`heights[i]\` represents the height of the \`i-th\` building. The function returns the largest possible rectangular billboard area that can be constructed between any two buildings in the \`heights\` array. >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([3]) 3 >>> largestRectangleArea([4, 4, 4, 4]) 16 >>> largestRectangleArea([5, 4, 3, 2, 1]) 9 >>> largestRectangleArea([1, 2, 3, 4, 5]) 9 >>> largestRectangleArea([2, 1, 2]) 3 >>> largestRectangleArea([2] * 1000) 2000 >>> largestRectangleArea([]) 0","solution":"def largestRectangleArea(heights): Given an array of integers \`heights\`, where \`heights[i]\` represents the height of the \`i-th\` building. The function returns the largest possible rectangular billboard area that can be constructed between any two buildings in the \`heights\` array. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def trap(heights: List[int]) -> int: Calculate the amount of water trapped between buildings after a rainstorm. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped water. >>> trap([]) == 0 >>> trap([1]) == 0 >>> trap([1, 2]) == 0 >>> trap([2, 1, 2]) == 1 >>> trap([3, 3, 3]) == 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([4, 2, 0, 3, 2, 5]) == 9 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0","solution":"def trap(heights): Calculates the total amount of trapped water between buildings. Parameters: heights (list of int): List of building heights. Returns: int: Total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Calculate left max for each position left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Calculate right max for each position right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water total_water = 0 for i in range(n): water = min(left_max[i], right_max[i]) - heights[i] if water > 0: total_water += water return total_water"},{"question":"def two_sum_pairs(nums: List[int], target: int) -> List[List[int]]: Given an array of integers \`nums\` and an integer \`target\`, return an array of unique pairs of indices \`[i, j]\` (i != j) from the array such that the sum of the elements at these indices equals the \`target\`. Ensure that the pairs are listed in ascending order of their first index, and each pair \`[i, j]\` is in ascending order (i < j). If no such pairs exist, return an empty array. >>> two_sum_pairs([1, 2, 3, 4, 3], 6) [[1, 3], [2, 4]] >>> two_sum_pairs([1, 2, 3, 4], 8) [] >>> two_sum_pairs([1, 2, 3, 4], 5) [[0, 3], [1, 2]] >>> two_sum_pairs([], 5) [] >>> two_sum_pairs([2, 2, 2, 2], 4) [[0, 1], [0, 2], [0, 3], [1, 2], [1, 3], [2, 3]]","solution":"def two_sum_pairs(nums, target): pairs = [] seen = {} for i, num in enumerate(nums): diff = target - num if diff in seen: for index in seen[diff]: pairs.append([index, i]) if num in seen: seen[num].append(i) else: seen[num] = [i] return sorted(pairs)"},{"question":"[Completion Task in Python] def max_non_decreasing_subsequences(s: str) -> int: Returns the maximum number of non-decreasing subsequences that can be obtained from the given string s. >>> max_non_decreasing_subsequences(\\"\\") == 0 >>> max_non_decreasing_subsequences(\\"a\\") == 1 >>> max_non_decreasing_subsequences(\\"aaaa\\") == 1 >>> max_non_decreasing_subsequences(\\"abc\\") == 1 >>> max_non_decreasing_subsequences(\\"cba\\") == 3 >>> max_non_decreasing_subsequences(\\"abac\\") == 2 >>> max_non_decreasing_subsequences(\\"aabccbd\\") == 2 >>> max_non_decreasing_subsequences(\\"aaabbbccc\\") == 1 >>> max_non_decreasing_subsequences(\\"abcdedcba\\") == 5","solution":"def max_non_decreasing_subsequences(s): Returns the maximum number of non-decreasing subsequences that can be obtained from the given string s. if not s: return 0 max_char = s[0] subsequences_count = 1 for char in s: if char < max_char: subsequences_count += 1 else: max_char = char return subsequences_count"},{"question":"def merge_alternately(nums1: List[int], nums2: List[int]) -> List[int]: Merge two arrays alternately. :param nums1: List of integers :param nums2: List of integers :return: Merged list of integers >>> merge_alternately([1, 3, 5], [2, 4, 6]) [1, 2, 3, 4, 5, 6] >>> merge_alternately([7, 7, 7], [7, 7, 7]) [7, 7, 7, 7, 7, 7] >>> merge_alternately([-1, -3, -5], [-2, -4, -6]) [-1, -2, -3, -4, -5, -6] >>> merge_alternately([0, 0, 0], [0, 0, 0]) [0, 0, 0, 0, 0, 0] >>> merge_alternately([1], [2]) [1, 2]","solution":"def merge_alternately(nums1, nums2): Merge two arrays alternately. :param nums1: List of integers :param nums2: List of integers :return: Merged list of integers merged_array = [] for i in range(len(nums1)): merged_array.append(nums1[i]) merged_array.append(nums2[i]) return merged_array"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest substring that can be rearranged to form a palindrome. >>> longest_palindromic_substring_length('a') 1 >>> longest_palindromic_substring_length('aaaa') 4 >>> longest_palindromic_substring_length('abccba') 6 >>> longest_palindromic_substring_length('aabbc') 5 >>> longest_palindromic_substring_length('abccccdd') 7 >>> longest_palindromic_substring_length('abc') 1 >>> longest_palindromic_substring_length('a' * 500 + 'b' * 500) 1000","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Initialize length of the longest palindromic substring max_length = 0 odd_found = False # Loop through the count of each character for count in char_count.values(): # If the count is even, it can fully contribute to the palindrome length if count % 2 == 0: max_length += count else: # If the count is odd, we can use count - 1 characters to fully contribute max_length += count - 1 odd_found = True # Add one to the length if there was at least one character with an odd frequency if odd_found: max_length += 1 return max_length"},{"question":"def search_matrix(matrix, target): Returns True if the target exists in the sorted matrix, False otherwise. Args: matrix (list of list of int): A 2D matrix of integers. target (int): The integer to search for in the matrix. Returns: bool: True if the target exists in the matrix, False otherwise. pass # Test Cases def test_search_matrix_target_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) assert search_matrix(matrix, 18) def test_search_matrix_target_not_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert not search_matrix(matrix, 20) assert not search_matrix(matrix, 0) def test_search_matrix_empty_matrix(): matrix = [] assert not search_matrix(matrix, 5) def test_search_matrix_single_element_matrix(): matrix = [[5]] assert search_matrix(matrix, 5) assert not search_matrix(matrix, 2) def test_search_matrix_single_row_matrix(): matrix = [[1, 2, 3, 4, 5]] assert search_matrix(matrix, 3) assert not search_matrix(matrix, 6) def test_search_matrix_single_column_matrix(): matrix = [[1], [2], [3], [4], [5]] assert search_matrix(matrix, 4) assert not search_matrix(matrix, 0)","solution":"def search_matrix(matrix, target): Returns True if the target exists in the sorted matrix, False otherwise. Args: matrix (list of list of int): A 2D matrix of integers. target (int): The integer to search for in the matrix. Returns: bool: True if the target exists in the matrix, False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The relative order inside both groups should remain the same as in the input. 1 - based index is used for this problem (i.e., the first node is considered odd, and the second node is even, and so on). >>> head = list_to_linked_list([1,2,3,4,5]) >>> result = oddEvenList(head) >>> linked_list_to_list(result) [1, 3, 5, 2, 4] >>> head = list_to_linked_list([2, 1, 3, 5, 6, 4, 7]) >>> result = oddEvenList(head) >>> linked_list_to_list(result) [2, 3, 6, 7, 1, 5, 4] def linked_list_to_list(head): Helper function to convert a linked list to a Python list for easier comparison in tests. def list_to_linked_list(lst): Helper function to convert a Python list to a linked list for easier setup in tests. import pytest def test_oddEvenList_single_element(): input_list = [1] head = list_to_linked_list(input_list) result = oddEvenList(head) assert linked_list_to_list(result) == [1] def test_oddEvenList_two_elements(): input_list = [1, 2] head = list_to_linked_list(input_list) result = oddEvenList(head) assert linked_list_to_list(result) == [1, 2] def test_oddEvenList_multiple_elements(): input_list = [1, 2, 3, 4, 5] head = list_to_linked_list(input_list) result = oddEvenList(head) expected_list = [1, 3, 5, 2, 4] assert linked_list_to_list(result) == expected_list def test_oddEvenList_non_consecutive(): input_list = [2, 1, 3, 5, 6, 4, 7] head = list_to_linked_list(input_list) result = oddEvenList(head) expected_list = [2, 3, 6, 7, 1, 5, 4] assert linked_list_to_list(result) == expected_list def test_oddEvenList_no_elements(): input_list = [] head = list_to_linked_list(input_list) result = oddEvenList(head) assert linked_list_to_list(result) == []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): Function to reorder a linked list so that all nodes with odd indices come before all nodes with even indices. if not head or not head.next: return head odd = head even = head.next even_head = even while even and even.next: odd.next = even.next odd = odd.next even.next = odd.next even = even.next odd.next = even_head return head def linked_list_to_list(head): Helper function to convert a linked list to a Python list for easier comparison in tests. result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(lst): Helper function to convert a Python list to a linked list for easier setup in tests. if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head"},{"question":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def largest_values_per_level(root): Returns the largest value found at each level of the tree from top to bottom. If the tree is empty, returns an empty list. >>> root = TreeNode(1) >>> root.left = TreeNode(3) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(9) >>> largest_values_per_level(root) [1, 3, 9] >>> root = TreeNode(10) >>> largest_values_per_level(root) [10] >>> root = TreeNode(5) >>> root.left = TreeNode(1) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(7) >>> root.left.right = TreeNode(3) >>> largest_values_per_level(root) [5, 6, 7] >>> largest_values_per_level(None) [] >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(1) >>> root.right.left = TreeNode(1) >>> largest_values_per_level(root) [1, 1, 1]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def largest_values_per_level(root): Returns the largest value found at each level of the tree from top to bottom. If the tree is empty, returns an empty list. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) max_value = float('-inf') for _ in range(level_size): node = queue.popleft() max_value = max(max_value, node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(max_value) return result"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each character in the string \`s\` forward by \`n\` positions in the alphabet. The alphabet is considered circular. Non-alphabet characters remain unchanged. >>> shift_string(\\"abc\\", 2) \\"cde\\" >>> shift_string(\\"xyz\\", 1) \\"yza\\" >>> shift_string(\\"ABC\\", 2) \\"CDE\\" >>> shift_string(\\"XYZ\\", 1) \\"YZA\\" >>> shift_string(\\"aBcXyZ\\", 2) \\"cDeZaB\\" >>> shift_string(\\"a!b?c\\", 2) \\"c!d?e\\" >>> shift_string(\\"X@Y#Z\\", 1) \\"Y@Z#A\\" >>> shift_string(\\"abc\\", 29) \\"def\\" >>> shift_string(\\"xyz\\", 52) \\"xyz\\" >>> shift_string(\\"hello\\", 0) \\"hello\\" >>> shift_string(\\"HELLO\\", 0) \\"HELLO\\" >>> shift_string(\\"\\", 5) \\"\\"","solution":"def shift_string(s, n): Shifts each character in the string \`s\` forward by \`n\` positions in the alphabet. The alphabet is considered circular. Non-alphabet characters remain unchanged. result = [] for char in s: if char.islower(): result.append(chr((ord(char) - ord('a') + n) % 26 + ord('a'))) elif char.isupper(): result.append(chr((ord(char) - ord('A') + n) % 26 + ord('A'))) else: result.append(char) return ''.join(result)"},{"question":"def findLengthOfShortestSubarray(arr: List[int]) -> int: Return the length of the shortest subarray that needs to be removed to make the remaining array sorted in non-decreasing order. >>> findLengthOfShortestSubarray([1,2,3,10,4,2,3,5]) == 3 >>> findLengthOfShortestSubarray([1,2,3,4,5]) == 0 from typing import List def test_example_case(): assert findLengthOfShortestSubarray([1,2,3,10,4,2,3,5]) == 3 def test_already_sorted(): assert findLengthOfShortestSubarray([1,2,3,4,5]) == 0 def test_remove_entire_array(): assert findLengthOfShortestSubarray([5,4,3,2,1]) == 4 def test_remove_end_part(): assert findLengthOfShortestSubarray([1,2,3,10,4,2,2,3,5]) == 3 def test_remove_start_part(): assert findLengthOfShortestSubarray([10,9,8,7,1,2,3,4,5]) == 4 def test_single_element(): assert findLengthOfShortestSubarray([1]) == 0 def test_all_elements_same(): assert findLengthOfShortestSubarray([2,2,2,2,2]) == 0 def test_remove_middle(): assert findLengthOfShortestSubarray([1,2,4,3,5,6]) == 1","solution":"def findLengthOfShortestSubarray(arr): Returns the length of the shortest subarray to remove to make remaining array sorted in non-decreasing order. n = len(arr) # Find the longest non-decreasing prefix left = 0 while left < n-1 and arr[left] <= arr[left+1]: left += 1 # If the array is already non-decreasing if left == n-1: return 0 # Find the longest non-decreasing suffix right = n-1 while right > 0 and arr[right] >= arr[right-1]: right -= 1 # Initial removal candidates res = min(n-left-1, right) # Try to find a better removal by combining prefix and suffix i = 0 j = right while i <= left and j < n: if arr[i] <= arr[j]: res = min(res, j-i-1) i += 1 else: j += 1 return res"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Returns the area of the largest rectangle in the histogram represented by 'heights'. >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([2]) == 2 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([2, 4]) == 4 >>> largest_rectangle_area([2, 1, 0, 1, 2]) == 2 >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([3, 3, 3, 3, 3, 3]) == 18","solution":"def largest_rectangle_area(heights): Returns the area of the largest rectangle in the histogram represented by 'heights'. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def can_distribute_candies(candies: List[int], totalCandies: int) -> bool: Determine if it's possible to allocate the candies according to the given constraints. Each child must have at least as many candies as the child directly before them and altogether no more than \`totalCandies\` candies should be allocated. The minimum number of candies each child can have is \`1\`. Args: candies (List[int]): An array where \`candies[i]\` represents the number of candies that the \`i-th\` child has. totalCandies (int): The total number of candies to distribute. Returns: bool: \`True\` if it is possible to distribute candies to meet the criteria, otherwise \`False\`. >>> can_distribute_candies([1, 2, 2], 6) True >>> can_distribute_candies([1, 0, 2], 5) True >>> can_distribute_candies([1, 2, 2], 4) True >>> can_distribute_candies([1, 2, 2], 3) False >>> can_distribute_candies([1, 0, 2], 3) False >>> can_distribute_candies([2, 2, 1], 3) False >>> can_distribute_candies([5], 1) True >>> can_distribute_candies([5], 2) True >>> can_distribute_candies([1, 1, 1, 1], 4) True >>> can_distribute_candies([1, 2, 2, 1], 8) True >>> can_distribute_candies([1, 2, 3, 4, 5], 15) True >>> can_distribute_candies([1, 2, 3, 4, 5, 6], 21) True","solution":"def can_distribute_candies(candies, totalCandies): n = len(candies) # Allocate a minimum of 1 candy to each child initially distributed = [1] * n # Iterate from left to right to ensure each child has at least as many as the previous child for i in range(1, n): if candies[i] > candies[i-1]: distributed[i] = distributed[i-1] + 1 # Iterate from right to left to ensure each child has at least as many as the next child for i in range(n-2, -1, -1): if candies[i] > candies[i+1]: distributed[i] = max(distributed[i], distributed[i+1] + 1) # Calculate the total number of candies distributed total_distributed = sum(distributed) # Check if the total number of distributed candies is within the limit return total_distributed <= totalCandies"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head: ListNode) -> ListNode: Given the head of a singly linked list, reverse the list, and return the reversed list. >>> head = list_to_linked_list([1, 2, 3, 4, 5]) >>> reversed_head = reverse_linked_list(head) >>> linked_list_to_list(reversed_head) [5, 4, 3, 2, 1] >>> head = list_to_linked_list([1]) >>> reversed_head = reverse_linked_list(head) >>> linked_list_to_list(reversed_head) [1] >>> head = list_to_linked_list([]) >>> reversed_head = reverse_linked_list(head) >>> linked_list_to_list(reversed_head) [] >>> head = list_to_linked_list([1, 2]) >>> reversed_head = reverse_linked_list(head) >>> linked_list_to_list(reversed_head) [2, 1] >>> head = list_to_linked_list([1, 2, 2, 3]) >>> reversed_head = reverse_linked_list(head) >>> linked_list_to_list(reversed_head) [3, 2, 2, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_linked_list(head): prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev"},{"question":"def apply_operations(s: str, operations: List[List[Union[int, str]]]) -> str: Applie a series of operations to a string, each replacing a character at a specific index. Parameters: s (str): The initial string. operations (list): A list of operations, each a list containing an index and a character. Returns: str: The resulting string after applying all operations. pass # Unit Test def test_single_operation(): assert apply_operations(\\"hello\\", [[1, 'a']]) == \\"hallo\\" def test_multiple_operations(): assert apply_operations(\\"hello world\\", [[0, 'H'], [6, 'W'], [10, '!']]) == \\"Hello Worl!\\" def test_no_operations(): assert apply_operations(\\"sample\\", []) == \\"sample\\" def test_replace_entire_string(): assert apply_operations(\\"abcdef\\", [[0, 'x'], [1, 'y'], [2, 'z'], [3, 'u'], [4, 'v'], [5, 'w']]) == \\"xyzuvw\\" def test_overlapping_operations(): assert apply_operations(\\"abcde\\", [[1, 'x'], [1, 'y'], [1, 'z']]) == \\"azcde\\" def test_operations_on_same_index(): assert apply_operations(\\"test\\", [[2, 'x'], [2, 'y'], [2, 'z']]) == \\"tezt\\"","solution":"def apply_operations(s, operations): Applies a series of operations to a string, each replacing a character at a specific index. Parameters: s (str): The initial string. operations (list): A list of operations, each a list containing an index and a character. Returns: str: The resulting string after applying all operations. s = list(s) # Convert string to a list to allow mutation for i, c in operations: s[i] = c # Perform the replacement return ''.join(s) # Convert list back to string and return"},{"question":"def can_partition(arr: List[int]) -> bool: Determines if the array can be partitioned into two non-empty subarrays with equal sum. >>> can_partition([1, 1]) == True >>> can_partition([1, 2, 3, 3, 2, 1]) == True >>> can_partition([1, 2, 3, 4, 5]) == False >>> can_partition([10]) == False","solution":"def can_partition(arr): Determines if the array can be partitioned into two non-empty subarrays with equal sum. :param arr: List[int] - The input array :return: bool - True if such a partition exists, otherwise False total_sum = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return True return False"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression containing digits, plus and minus signs. >>> evaluate_expression(\\"2+3\\") == 5 >>> evaluate_expression(\\"5-2\\") == 3 >>> evaluate_expression(\\"1+2-3\\") == 0 >>> evaluate_expression(\\"10+20-5-5+10\\") == 30 >>> evaluate_expression(\\"42\\") == 42 >>> evaluate_expression(\\"2-3-2\\") == -3","solution":"def evaluate_expression(s): Evaluates a mathematical expression containing digits, plus and minus signs. :param s: str, a mathematical expression :return: int, result of the evaluation total, number, sign = 0, 0, 1 for char in s: if char.isdigit(): number = number * 10 + int(char) elif char == '+': total += sign * number number = 0 sign = 1 elif char == '-': total += sign * number number = 0 sign = -1 total += sign * number return total"},{"question":"def reverse_sentence(s: str) -> str: Returns the sentence with words in reverse order. Parameters: s (str): A string representing a sentence where each word is separated by a single space. Returns: str: The reversed sentence where words appear in reverse order but the words themselves are not reversed. >>> reverse_sentence(\\"hello\\") \\"hello\\" >>> reverse_sentence(\\"hello world\\") \\"world hello\\" >>> reverse_sentence(\\"the quick brown fox\\") \\"fox brown quick the\\" >>> reverse_sentence(\\" hello world \\") \\"world hello\\" >>> reverse_sentence(\\"\\") \\"\\" >>> reverse_sentence(\\" \\") \\"\\" >>> reverse_sentence(\\"one two \\") \\"two one\\"","solution":"def reverse_sentence(s): Returns the sentence with words in reverse order. Parameters: s (str): A string representing a sentence where each word is separated by a single space. Returns: str: The reversed sentence where words appear in reverse order but the words themselves are not reversed. return ' '.join(s.split()[::-1])"},{"question":"def count_non_decreasing_segments(heights: List[int]) -> int: Returns the number of segments where the heights are in non-decreasing order. Parameters: heights (list of int): List representing the heights of plants in the garden. Returns: int: Number of non-decreasing segments. >>> count_non_decreasing_segments([1, 2, 3, 4, 5]) == 1 >>> count_non_decreasing_segments([1, 2, 1, 2, 3, 1]) == 3 >>> count_non_decreasing_segments([5, 4, 3, 2, 1]) == 5 >>> count_non_decreasing_segments([1, 2, 3, 2, 2, 3]) == 2 >>> count_non_decreasing_segments([]) == 0 >>> count_non_decreasing_segments([1]) == 1 >>> count_non_decreasing_segments([2, 2, 2, 2]) == 1 pass","solution":"def count_non_decreasing_segments(heights): Returns the number of segments where the heights are in non-decreasing order. Parameters: heights (list of int): List representing the heights of plants in the garden. Returns: int: Number of non-decreasing segments. if not heights: return 0 n = len(heights) segments_count = 1 # The first element starts the first segment for i in range(1, n): if heights[i] < heights[i - 1]: segments_count += 1 return segments_count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root: TreeNode) -> int: Calculate the sum of all binary numbers formed by each root-to-leaf path in the binary tree modulo 10^9 + 7. Args: root: TreeNode, the root of the binary tree. Returns: int: The sum of binary numbers formed by all root-to-leaf paths modulo 10^9 + 7. >>> tree = TreeNode(1, TreeNode(0, TreeNode(0), TreeNode(1)), TreeNode(1, None, TreeNode(0))) >>> sum_root_to_leaf(tree) 15 >>> tree = TreeNode(1) >>> sum_root_to_leaf(tree) 1 >>> tree = TreeNode(0) >>> sum_root_to_leaf(tree) 0 >>> tree = TreeNode(1, TreeNode(0, TreeNode(1))) >>> sum_root_to_leaf(tree) 5 >>> tree = TreeNode(1, None, TreeNode(0, None, TreeNode(1))) >>> sum_root_to_leaf(tree) 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf(root): MOD = 10**9 + 7 def dfs(node, current_val): if not node: return 0 current_val = (current_val << 1) | node.val if not node.left and not node.right: # if it is a leaf return current_val left_sum = dfs(node.left, current_val) right_sum = dfs(node.right, current_val) return (left_sum + right_sum) % MOD return dfs(root, 0)"},{"question":"def longest_unique_substring(arr: List[int]) -> str: Returns the longest substring of unique letters formed by concatenating elements from \`arr\`. Each integer in \`arr\` ranges from 1 to 26, representing 'a' to 'z'. >>> longest_unique_substring([1, 2, 3, 4, 5]) == \\"abcde\\" >>> longest_unique_substring([1, 2, 1, 3, 2, 4]) == \\"abcd\\" >>> longest_unique_substring([1, 1, 1, 1, 1]) == \\"a\\" >>> longest_unique_substring([]) == \\"\\" >>> longest_unique_substring([3, 1, 2]) == \\"cab\\" >>> longest_unique_substring([1, 2, 3, 4, 1, 5, 6]) == \\"abcdef\\"","solution":"def longest_unique_substring(arr): Returns the longest substring of unique letters formed by concatenating elements from \`arr\`. Each integer in \`arr\` ranges from 1 to 26, representing 'a' to 'z'. seen = set() longest = [] for num in arr: # Convert number to corresponding character char = chr(num + 96) if char not in seen: seen.add(char) longest.append(char) return \\"\\".join(longest)"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved with at most one transaction. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([]) 0 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5, 5, 5, 5, 5]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([9, 7, 5, 3, 1, 10]) 9","solution":"def max_profit(prices): Returns the maximum profit that can be achieved with at most one transaction. If no profit can be made, returns 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def can_form_triangle(arr: List[int]) -> bool: Determines if any three segments in the array can form a non-degenerate triangle. >>> can_form_triangle([2, 3, 4]) True >>> can_form_triangle([1, 2, 3]) False >>> can_form_triangle([5, 1, 1]) False >>> can_form_triangle([10, 15, 30, 25, 5]) True >>> can_form_triangle([5, 5, 5]) True >>> can_form_triangle([7, 10, 5]) True >>> can_form_triangle([7, 10, 3]) False >>> can_form_triangle([]) False >>> can_form_triangle([1]) False >>> can_form_triangle([1, 2]) False","solution":"def can_form_triangle(arr): Determines if any three segments in the array can form a non-degenerate triangle. arr.sort() n = len(arr) for i in range(n - 2): if arr[i] + arr[i + 1] > arr[i + 2]: return True return False"},{"question":"from typing import List def edit_distance(word1: str, word2: str) -> int: Compute the edit distance between two words. len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len1][len2] def spell_checker(dictionary: List[str], word: str) -> str: Given a list of words in a dictionary and a string containing a single word, determine whether the given word is spelled correctly. If the word is not found in the dictionary, identify the closest match by returning the first lexicographically minimal word from the dictionary that has the shortest edit distance to the given word. >>> spell_checker([\\"solution\\", \\"solver\\", \\"testing\\", \\"example\\"], \\"solution\\") 'solution' >>> spell_checker([\\"solution\\", \\"solver\\", \\"testing\\", \\"example\\"], \\"solutin\\") 'solution' >>> spell_checker([\\"Solution\\", \\"solver\\", \\"Testing\\", \\"example\\"], \\"solution\\") 'Solution' >>> spell_checker([\\"apple\\", \\"apricot\\", \\"banana\\", \\"mango\\"], \\"aple\\") 'apple'","solution":"def edit_distance(word1, word2): Compute the edit distance between two words. len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): for j in range(len2 + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[len1][len2] def spell_checker(dictionary, word): Check the spelling of a given word against a dictionary. if word in dictionary: return word min_distance = float('inf') closest_word = None for dict_word in dictionary: current_distance = edit_distance(dict_word, word) if current_distance < min_distance or (current_distance == min_distance and dict_word < closest_word): min_distance = current_distance closest_word = dict_word return closest_word"},{"question":"class VersionedArray: A data structure that simulates a dynamic, resizable array of integers with version control. def __init__(self): Initializes the object. pass def add(self, value: int) -> int: Inserts an integer \`value\` at the end of the array and returns a new version number. >>> va = VersionedArray() >>> version1 = va.add(3) >>> version2 = va.add(5) >>> va.getArrayAtVersion(version1) == [3] >>> va.getArrayAtVersion(version2) == [3, 5] pass def remove(self) -> int: Removes the last element from the array and returns a new version number. If the array is empty, return \`-1\`. >>> va = VersionedArray() >>> va.add(3) >>> va.add(5) >>> version3 = va.remove() >>> va.getArrayAtVersion(version3) == [3] >>> version4 = va.remove() >>> va.getArrayAtVersion(version4) == [] >>> version5 = va.remove() >>> version5 == -1 pass def getArrayAtVersion(self, version: int) -> List[int]: Returns the state of the array at the specified \`version\`. If the version does not exist, return an empty list. >>> va = VersionedArray() >>> version1 = va.add(3) >>> version2 = va.add(5) >>> va.getArrayAtVersion(version1) == [3] >>> va.getArrayAtVersion(version2) == [3, 5] >>> version3 = va.remove() >>> va.getArrayAtVersion(version3) == [3] >>> va.getArrayAtVersion(0) == [] >>> va.getArrayAtVersion(10) == [] pass","solution":"class VersionedArray: def __init__(self): self.versions = [] self.current_array = [] self.version_number = 0 def add(self, value): self.current_array.append(value) self.version_number += 1 self.versions.append(list(self.current_array)) return self.version_number def remove(self): if not self.current_array: return -1 self.current_array.pop() self.version_number += 1 self.versions.append(list(self.current_array)) return self.version_number def getArrayAtVersion(self, version): if 1 <= version <= len(self.versions): return self.versions[version - 1] return []"},{"question":"def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the n x n matrix 90 degrees clockwise in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_matrix(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_matrix(matrix) >>> matrix [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate_matrix(matrix) >>> matrix [[3, 1], [4, 2]] >>> matrix = [ ... [1] ... ] >>> rotate_matrix(matrix) >>> matrix [[1]] >>> matrix = [ ... [1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [11, 12, 13, 14, 15], ... [16, 17, 18, 19, 20], ... [21, 22, 23, 24, 25] ... ] >>> rotate_matrix(matrix) >>> matrix [[21, 16, 11, 6, 1], [22, 17, 12, 7, 2], [23, 18, 13, 8, 3], [24, 19, 14, 9, 4], [25, 20, 15, 10, 5]]","solution":"def rotate_matrix(matrix): Rotates the n x n matrix 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def sort_by_binary_ones(arr): Sorts the array in non-decreasing order based on the number of 1s in the binary representation of each element. If two elements have the same number of 1s, they will appear in the same order as in the original array. Examples: >>> sort_by_binary_ones([3, 7, 8, 6]) [8, 3, 6, 7] >>> sort_by_binary_ones([1, 2, 3]) [1, 2, 3] from solution import sort_by_binary_ones def test_example(): assert sort_by_binary_ones([3, 7, 8, 6]) == [8, 3, 6, 7] def test_all_same_ones(): assert sort_by_binary_ones([3, 5, 9, 6]) == [3, 5, 9, 6] # All have 2 ones def test_different_ones(): assert sort_by_binary_ones([1, 2, 3]) == [1, 2, 3] # 1->1, 2->10, 3->11 def test_large_numbers(): assert sort_by_binary_ones([8, 16, 3, 7]) == [8, 16, 3, 7] # 1, 1, 2, 3 def test_single_element(): assert sort_by_binary_ones([5]) == [5] def test_all_zeros(): assert sort_by_binary_ones([0, 0, 0]) == [0, 0, 0]","solution":"def sort_by_binary_ones(arr): Sorts the array in non-decreasing order based on the number of 1s in the binary representation of each element. If two elements have the same number of 1s, they will appear in the same order as in the original array. return sorted(arr, key=lambda x: (bin(x).count('1'), arr.index(x)))"},{"question":"def can_form_words(s: str, words: List[str]) -> List[bool]: Determine if it is possible to form each word in words from s using distinct characters. >>> can_form_words(\\"abcde\\", [\\"ace\\"]) [True] >>> can_form_words(\\"abcde\\", [\\"ace\\", \\"bce\\"]) [True, True] >>> can_form_words(\\"abcde\\", [\\"aec\\"]) [False] >>> can_form_words(\\"abcde\\", [\\"aec\\", \\"bdc\\"]) [False, False] >>> can_form_words(\\"abcde\\", [\\"ace\\", \\"aec\\"]) [True, False] >>> can_form_words(\\"\\", [\\"a\\", \\"abc\\"]) [False, False] >>> can_form_words(\\"abcde\\", []) [] >>> can_form_words(\\"abcdefg\\", [\\"hi\\", \\"xyz\\"]) [False, False]","solution":"def can_form_words(s, words): def can_form(word, s): it = iter(s) return all(char in it for char in word) return [can_form(word, s) for word in words]"},{"question":"def replace_asterisks(s: str) -> str: Replaces every '*' in the input string \`s\` with a lowercase letter such that no two adjacent characters are the same. >>> replace_asterisks(\\"abcde\\") == \\"abcde\\" >>> replace_asterisks(\\"a*c\\") != 'a' and != 'c' >>> replace_asterisks(\\"a*b*c*d\\") != 'a' and != 'b' and != 'c' and != 'd' >>> replace_asterisks(\\"*a\\") != 'a' >>> replace_asterisks(\\"a*\\") != 'a' >>> replace_asterisks(\\"****\\") ensuring all characters are different","solution":"def replace_asterisks(s): Replaces every '*' in the input string \`s\` with a lowercase letter such that no two adjacent characters are the same. s = list(s) n = len(s) for i in range(n): if s[i] == '*': for c in 'abcdefghijklmnopqrstuvwxyz': if (i > 0 and s[i - 1] == c) or (i < n - 1 and s[i + 1] == c): continue s[i] = c break return ''.join(s)"},{"question":"def max_product(nums: List[int]) -> int: Given an integer array \`nums\`, find a contiguous subarray (containing at least one number) which has the maximum product, and return the product. >>> max_product([2, 3, 4]) 24 >>> max_product([2, 3, -2, 4]) 6 >>> max_product([-2, 0, -1]) 0 >>> max_product([2, -5, -2, -4, 3]) 24 >>> max_product([2, 0, -2]) 2","solution":"def max_product(nums): if not nums: return 0 current_max = current_min = global_max = nums[0] for num in nums[1:]: if num < 0: current_max, current_min = current_min, current_max current_max = max(num, current_max * num) current_min = min(num, current_min * num) global_max = max(global_max, current_max) return global_max"},{"question":"from typing import List def max_non_overlapping_intervals(intervals: List[List[int]]) -> int: Determine the maximum number of non-overlapping interviews that can be scheduled. Args: intervals (List[List[int]]): List of intervals where each interval is represented as [start, end]. Returns: int: Maximum number of non-overlapping intervals. Example: >>> max_non_overlapping_intervals([[1,3], [2,4], [3,5]]) 2 >>> max_non_overlapping_intervals([[1,2], [2,3], [3,4], [4,5]]) 4 >>> max_non_overlapping_intervals([[1,4], [2,5], [3,6]]) 1 >>> max_non_overlapping_intervals([]) 0 >>> max_non_overlapping_intervals([[1,3], [3,5], [4,6], [6,8], [7,9]]) 3","solution":"def maxNonOverlappingIntervals(intervals): Returns the maximum number of non-overlapping intervals. # Sort intervals by end time intervals.sort(key=lambda x: x[1]) count = 0 end_time = float('-inf') for interval in intervals: if interval[0] >= end_time: count += 1 end_time = interval[1] return count"},{"question":"def max_distinct_in_subarray(nums, k): Given an integer array nums and an integer k, return the maximum number of distinct elements in any subarray of length k. If k is larger than the length of the array, return -1. >>> max_distinct_in_subarray([1, 2, 3], 4) == -1 >>> max_distinct_in_subarray([1, 2, 3, 2, 1], 3) == 3 >>> max_distinct_in_subarray([1, 1, 1, 1], 2) == 1 >>> max_distinct_in_subarray([4, 3, 4, 2, 3, 4, 5], 4) == 4 >>> max_distinct_in_subarray([1], 1) == 1 >>> max_distinct_in_subarray([1, 2, 3, 4], 4) == 4 pass","solution":"def max_distinct_in_subarray(nums, k): if k > len(nums): return -1 from collections import defaultdict # Dictionary to count the frequency of elements in the current window count = defaultdict(int) distinct_count = 0 max_distinct = 0 for i in range(k): if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = distinct_count for i in range(k, len(nums)): if count[nums[i - k]] == 1: distinct_count -= 1 count[nums[i - k]] -= 1 if count[nums[i]] == 0: distinct_count += 1 count[nums[i]] += 1 max_distinct = max(max_distinct, distinct_count) return max_distinct"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. >>> head = python_list_to_list([1, 2, 3, 4, 5]) >>> result = list_to_python_list(rotateRight(head, 2)) >>> result == [4, 5, 1, 2, 3] True >>> head = python_list_to_list([0, 1, 2]) >>> result = list_to_python_list(rotateRight(head, 4)) >>> result == [2, 0, 1] True >>> rotateRight(None, 1) == None True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the linked list tail, length = head, 1 while tail.next: tail = tail.next length += 1 # Find the effective number of rotations k = k % length if k == 0: return head # Identify the new tail (length - k)th node new_tail_position = length - k new_tail = head for _ in range(new_tail_position - 1): new_tail = new_tail.next # New head is the next node after new_tail new_head = new_tail.next # Break the list new_tail.next = None # Old tail connects to the original head tail.next = head return new_head"},{"question":"def find_start_end(arr, x): Finds the starting and ending position of x in the array. If x is not found, returns [-1, -1]. >>> find_start_end([1, 2, 3, 2, 1], 2) [1, 3] >>> find_start_end([7, 8, 9, 7], 7) [0, 3] >>> find_start_end([1, 2, 3, 4, 5], 6) [-1, -1] >>> find_start_end([7], 7) [0, 0] >>> find_start_end([7], 5) [-1, -1] >>> find_start_end([5, 5, 5, 5, 5], 5) [0, 4] >>> find_start_end([], 1) [-1, -1] >>> find_start_end([1, 1, 2, 1, 1], 1) [0, 4]","solution":"def find_start_end(arr, x): Finds the starting and ending position of x in the array. If x is not found, returns [-1, -1]. start = -1 end = -1 for i in range(len(arr)): if arr[i] == x: if start == -1: start = i end = i return [start, end]"},{"question":"def rob(nums: List[int]) -> int: Returns the maximum amount of money you can rob without robbing two adjacent houses. >>> rob([]) == 0 >>> rob([5]) == 5 >>> rob([1, 2]) == 2 >>> rob([1, 2, 3, 1]) == 4 >>> rob([2, 7, 9, 3, 1]) == 12 >>> rob([2, 1, 1, 2]) == 4 >>> rob([5, 3, 4, 11, 2]) == 16 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses. if not nums: return 0 elif len(nums) == 1: return nums[0] # Initialize an array to store the maximum money robbed up to each house max_robbed = [0] * len(nums) # The first house's money is the only option if only one house is considered max_robbed[0] = nums[0] # For the second house, choose the maximum between robbing first house or second house max_robbed[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): # For each house, check if robbing this house plus the amount robbed till (i-2) house is greater # than the amount robbed up to the (i-1) house max_robbed[i] = max(max_robbed[i-1], nums[i] + max_robbed[i-2]) return max_robbed[-1]"},{"question":"def count_visible_buildings(arr: List[int]) -> int: Returns the number of visible buildings given an array of building heights. A building is visible if it is not completely shadowed by taller buildings to its left. :param arr: List[int] - heights of the buildings :return: int - the number of visible buildings >>> count_visible_buildings([1, 2, 3, 4]) 4 >>> count_visible_buildings([4, 3, 2, 1]) 1 >>> count_visible_buildings([5, 1, 6, 2, 7, 3]) 3 >>> count_visible_buildings([5]) 1 >>> count_visible_buildings([]) 0 >>> count_visible_buildings([2, 3, 4, 1, 2, 7, 6]) 4","solution":"def count_visible_buildings(arr): Returns the number of visible buildings given an array of building heights. A building is visible if it is not completely shadowed by taller buildings to its left. :param arr: List[int] - heights of the buildings :return: int - the number of visible buildings if not arr: return 0 visible_count = 1 max_height = arr[0] for height in arr[1:]: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def max_books_from_pile(pile: int) -> int: Given a pile of books represented by an integer, return the maximum number of books that can be read consecutively following the rule: read one book the first day, one more than the day before on each subsequent day from the same pile. >>> max_books_from_pile(1) 1 >>> max_books_from_pile(3) 3 >>> max_books_from_pile(6) 6 >>> max_books_from_pile(10) 10 >>> max_books_from_pile(15) 15 >>> max_books_from_pile(21) 21 >>> max_books_from_pile(0) 0 >>> max_books_from_pile(7) 6","solution":"def max_books_from_pile(pile): Given a pile of books represented by a list of integers, return the maximum number of books that can be read consecutively following the rule: read one book the first day, one more than the day before on each subsequent day from the same pile. total_books = 0 day = 1 while total_books + day <= pile: total_books += day day += 1 return total_books"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head: ListNode) -> ListNode: Remove duplicates from a sorted linked list. >>> def create_linked_list(vals): ... if not vals: ... return None ... head = ListNode(vals[0]) ... current = head ... for val in vals[1:]: ... current.next = ListNode(val) ... current = current.next ... return head >>> def linked_list_to_list(head): ... vals = [] ... current = head ... while current: ... vals.append(current.val) ... current = current.next ... return vals >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_list(delete_duplicates(head)) == [1, 2, 3, 4, 5] True >>> head = create_linked_list([1, 1, 2, 3, 3, 4, 4, 5]) >>> linked_list_to_list(delete_duplicates(head)) == [1, 2, 3, 4, 5] True >>> head = create_linked_list([1, 1, 1, 1, 1]) >>> linked_list_to_list(delete_duplicates(head)) == [1] True >>> head = create_linked_list([1, 2, 2, 3, 4, 4, 4, 5, 5]) >>> linked_list_to_list(delete_duplicates(head)) == [1, 2, 3, 4, 5] True >>> head = create_linked_list([]) >>> linked_list_to_list(delete_duplicates(head)) == [] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_duplicates(head: ListNode) -> ListNode: Remove duplicates from a sorted linked list. current = head while current and current.next: if current.val == current.next.val: current.next = current.next.next else: current = current.next return head"},{"question":"from typing import List def construct_sum_subarray(arr: List[int], k: int) -> List[int]: Construct a new array where each element i is the sum of elements from arr[i] to arr[min(i+k-1, len(arr)-1)] in the input array arr. >>> construct_sum_subarray([1, 2, 3, 4, 5], 2) [3, 5, 7, 9, 5] >>> construct_sum_subarray([1, 2, 3, 4, 5], 3) [6, 9, 12, 9, 5] >>> construct_sum_subarray([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> construct_sum_subarray([1, 2, 3, 4, 5], 10) [15, 14, 12, 9, 5] >>> construct_sum_subarray([5], 1) [5] >>> construct_sum_subarray([], 2) [] >>> construct_sum_subarray([-1, -2, -3, -4, -5], 2) [-3, -5, -7, -9, -5]","solution":"def construct_sum_subarray(arr, k): Returns a new array where each element i is the sum of elements from i to min(i+k-1, n-1) in the input array arr. n = len(arr) result = [0] * n for i in range(n): # Calculate the sum of elements from arr[i] to arr[min(i+k-1, n-1)] end = min(i + k, n) result[i] = sum(arr[i:end]) return result"},{"question":"from collections import defaultdict class WordFrequency: A class to track the frequency of each word in a string. >>> wf = WordFrequency(\\"the quick brown fox jumps over the lazy dog\\") >>> wf.getFrequency(\\"the\\") 2 >>> wf.getFrequency(\\"quick\\") 1 >>> wf.getFrequency(\\"dog\\") 1 >>> wf.getFrequency(\\"cat\\") 0 >>> wf.addWord(\\"quick\\") >>> wf.getFrequency(\\"quick\\") 2 >>> wf.addWord(\\"fox\\") >>> wf.getFrequency(\\"fox\\") 2 >>> wf.addWord(\\"jumps\\") >>> wf.getFrequency(\\"jumps\\") 1 def __init__(self, s: str): Initializes the object with the input string \`s\`. pass def addWord(self, word: str) -> None: Adds a word to the string \`s\` and updates the frequency count. pass def getFrequency(self, word: str) -> int: Returns the frequency of the given word in the string \`s\`. pass","solution":"from collections import defaultdict class WordFrequency: def __init__(self, s): Initializes the object with the input string \`s\`. self.freq = defaultdict(int) self.process_string(s) def process_string(self, s): Processes the input string and updates the frequency count of each word. words = s.split() for word in words: self.freq[word] += 1 def addWord(self, word): Adds a word to the string and updates the frequency count. self.freq[word] += 1 def getFrequency(self, word): Returns the frequency of the given word in the string. return self.freq[word]"},{"question":"def max_subarray_of_length_k(nums: List[int], k: int) -> List[int]: Find the contiguous subarray of length exactly k with the maximum sum. If multiple subarrays have the same maximum sum, return the first one. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: List[int] - subarray of length k with the maximum sum >>> max_subarray_of_length_k([1, 2, 3, 4, 5], 3) == [3, 4, 5] >>> max_subarray_of_length_k([1, -2, 3, 4, -5, 6], 2) == [3, 4] >>> max_subarray_of_length_k([-1, -2, -3, -4, -5], 2) == [-1, -2] >>> max_subarray_of_length_k([1, 2, 3, 4, 5], 1) == [5] >>> max_subarray_of_length_k([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] >>> max_subarray_of_length_k([], 1) == [] >>> max_subarray_of_length_k([1, 2, 3], 4) == []","solution":"def max_subarray_of_length_k(nums, k): Find the contiguous subarray of length exactly k with the maximum sum. If multiple subarrays have the same maximum sum, return the first one. :param nums: List[int] - list of integers :param k: int - length of the subarray :return: List[int] - subarray of length k with the maximum sum if len(nums) < k: return [] # Initialize the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) max_start_idx = 0 # Iterate through the array to find the maximum subarray sum for i in range(k, len(nums)): # Slide the window to the right by subtracting the element going out of the window # and adding the next element coming into the window current_sum = current_sum - nums[i - k] + nums[i] if current_sum > max_sum: max_sum = current_sum max_start_idx = i - k + 1 return nums[max_start_idx:max_start_idx + k]"},{"question":"def max_perfect_subsequence_length(s: str) -> int: Returns the maximum length of a perfect subsequence that can be derived from s. A perfect subsequence is a subsequence where all the characters are the same. >>> max_perfect_subsequence_length(\\"abcdef\\") == 1 >>> max_perfect_subsequence_length(\\"aaaaa\\") == 5 >>> max_perfect_subsequence_length(\\"abcabcabcc\\") == 4 >>> max_perfect_subsequence_length(\\"\\") == 0 >>> max_perfect_subsequence_length(\\"z\\") == 1 >>> max_perfect_subsequence_length(\\"aabbcc\\") == 2","solution":"def max_perfect_subsequence_length(s): Returns the maximum length of a perfect subsequence that can be derived from s. A perfect subsequence is a subsequence where all the characters are the same. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # The maximum length of a perfect subsequence is the highest frequency of any character return max(frequency.values()) if frequency else 0"},{"question":"from typing import List def closest_sum_pair(nums: List[int], target: int) -> List[int]: Returns a pair of integers from nums such that their sum is closest to the target. If there are multiple pairs with the same closest sum, any one of them is returned. >>> closest_sum_pair([4, 2, 6, 1, 5], 8) in ([[6, 2], [2, 6]]) True >>> closest_sum_pair([10, 22, 28, 29, 30, 40], 54) in ([[22, 30], [30, 22], [28, 29], [29, 28]]) True >>> closest_sum_pair([1, 2], 3) in ([[1, 2], [2, 1]]) True >>> closest_sum_pair([-1, 2, -3, 4, -5], 0) in ([[-1, 2], [2, -1]]) True >>> closest_sum_pair([10, 20, 30, 40, 50], 70) in ([[20, 50], [50, 20], [30, 40], [40, 30]]) True >>> closest_sum_pair([-10, -20, -30, -40], -25) in ([[-10, -20], [-20, -10]]) True","solution":"def closest_sum_pair(nums, target): Returns a pair of integers from nums such that their sum is closest to the target. If there are multiple pairs with the same closest sum, any one of them is returned. if len(nums) < 2: return [] closest_pair = [] closest_diff = float('inf') for i in range(len(nums)): for j in range(i + 1, len(nums)): current_sum = nums[i] + nums[j] current_diff = abs(current_sum - target) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [nums[i], nums[j]] return closest_pair"},{"question":"def can_partition_k_subsets(nums: List[int], k: int) -> bool: Determine if you can divide the list into k non-empty subsets whose sums are all equal. Args: nums: List of integers to be partitioned. k: Number of subsets to partition into. Returns: True if such a partitioning is possible, otherwise False. Examples: >>> can_partition_k_subsets([4, 3, 2, 3, 5, 2, 1], 4) True >>> can_partition_k_subsets([1, 2, 3, 4], 3) False >>> can_partition_k_subsets([1], 1) True >>> can_partition_k_subsets([0, 0, 0, 0], 2) True >>> can_partition_k_subsets([2, 2, 2, 2, 3, 4, 5], 4) False >>> can_partition_k_subsets([5, 5, 5, 5], 2) True","solution":"def can_partition_k_subsets(nums, k): Determine if the list nums can be partitioned into k non-empty subsets with equal sums. total_sum = sum(nums) if total_sum % k != 0: return False target = total_sum // k nums.sort(reverse=True) used = [False] * len(nums) def backtrack(k, start, current_sum): if k == 0: return True if current_sum == target: return backtrack(k-1, 0, 0) for i in range(start, len(nums)): if not used[i] and current_sum + nums[i] <= target: used[i] = True if backtrack(k, i+1, current_sum + nums[i]): return True used[i] = False return False return backtrack(k, 0, 0)"},{"question":"from typing import List def longest_valid_subsequence(nums: List[int], k: int) -> int: Returns the length of the longest valid subsequence that contains no more than k distinct numbers. >>> longest_valid_subsequence([1, 2, 1, 2, 3], 2) 4 >>> longest_valid_subsequence([1, 2, 3, 4], 3) 3 >>> longest_valid_subsequence([4, 4, 4, 4], 1) 4 >>> longest_valid_subsequence([1, 2, 3, 4], 0) 0 >>> longest_valid_subsequence([1], 1) 1 >>> longest_valid_subsequence([1, 2, 3, 1, 2, 3, 4, 5], 3) 6","solution":"def longest_valid_subsequence(nums, k): Returns the length of the longest valid subsequence that contains no more than k distinct numbers. from collections import defaultdict max_len = 0 current_subseq = [] distinct_count = defaultdict(int) left = 0 for right in range(len(nums)): distinct_count[nums[right]] += 1 current_subseq.append(nums[right]) while len(distinct_count) > k: distinct_count[current_subseq[left]] -= 1 if distinct_count[current_subseq[left]] == 0: del distinct_count[current_subseq[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def rob(nums): Returns the maximum amount of money the robber can rob without triggering the alarm. :param nums: List[int] representing money at each house. :return: int maximum amount of money that can be robbed. from solution import rob def test_empty_list(): assert rob([]) == 0 def test_single_house(): assert rob([5]) == 5 def test_two_houses(): assert rob([1, 2]) == 2 assert rob([2, 1]) == 2 def test_general_case(): assert rob([1, 2, 3, 1]) == 4 assert rob([2, 7, 9, 3, 1]) == 12 assert rob([6, 7, 1, 30, 8, 2, 4]) == 41 def test_alternating_houses(): assert rob([5, 1, 1, 5]) == 10 def test_all_houses_equal(): assert rob([3, 3, 3, 3, 3]) == 9","solution":"def rob(nums): Returns the maximum amount of money the robber can rob without triggering the alarm. :param nums: List[int] representing money at each house. :return: int maximum amount of money that can be robbed. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Initialize dp array dp = [0] * n dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[-1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth_sum(root): Calculate the maximum depth sum observed among all paths in the binary tree. A path is defined as a sequence of nodes starting from the root node and ending at any leaf node. The depth sum of a path is the sum of the values of the nodes multiplied by their respective depths along that path. The depth of the root node is 1, its children are at depth 2, and so on. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum depth sum. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> max_depth_sum(root) 7","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth_sum(root): def helper(node, depth): if not node: return 0 current_sum = node.val * depth if not node.left and not node.right: return current_sum left_sum = helper(node.left, depth + 1) right_sum = helper(node.right, depth + 1) return max(current_sum + left_sum, current_sum + right_sum) return helper(root, 1)"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generate an n x n matrix populated with the first n^2 positive integers in spiral order. Args: n (int): The number of rows and columns of the square matrix. Returns: List[List[int]]: A 2D list representing the n x n matrix in spiral order. Examples: >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generates an n x n matrix populated with the first n^2 positive integers in spiral order. :param n: The number of rows and columns of the square matrix. :return: A 2D list representing the n x n matrix in spiral order. matrix = [[0] * n for _ in range(n)] num = 1 top, bottom = 0, n - 1 left, right = 0, n - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom along the right column for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Traverse from right to left along the bottom row if top <= bottom: for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Traverse from bottom to top along the left column if left <= right: for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"def countCharacters(words: List[str], chars: str) -> int: Determines if each string in \`words\` can be formed using the characters in \`chars\`. Returns the sum of the lengths of all the strings in \`words\` that can be formed. >>> countCharacters([\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"], \\"atach\\") 6 >>> countCharacters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> countCharacters([], \\"abc\\") 0 >>> countCharacters([\\"a\\", \\"b\\", \\"c\\"], \\"\\") 0 >>> countCharacters([\\"hello\\", \\"world\\"], \\"abc\\") 0 >>> countCharacters([\\"a\\", \\"ab\\", \\"abc\\"], \\"abc\\") 6 >>> countCharacters([\\"a\\", \\"aa\\", \\"aaa\\"], \\"a\\") 1","solution":"def countCharacters(words, chars): Determines if each string in \`words\` can be formed using the characters in \`chars\`. Returns the sum of the lengths of all the strings in \`words\` that can be formed. from collections import Counter chars_count = Counter(chars) def can_form(word): word_count = Counter(word) for char, count in word_count.items(): if count > chars_count.get(char, 0): return False return True total_length = 0 for word in words: if can_form(word): total_length += len(word) return total_length"},{"question":"def count_abc_anagrams(s: str) -> int: Determine the number of substrings of \`s\` that are anagrams of the string \\"abc\\". Each substring must contain exactly one 'a', one 'b', and one 'c' with no other characters included. >>> count_abc_anagrams(\\"abcabc\\") == 4 >>> count_abc_anagrams(\\"defg\\") == 0 >>> count_abc_anagrams(\\"abcdeabc\\") == 2 >>> count_abc_anagrams(\\"xyzabcxyz\\") == 1 >>> count_abc_anagrams(\\"\\") == 0 >>> count_abc_anagrams(\\"ab\\") == 0 >>> count_abc_anagrams(\\"aaabbbccc\\") == 0","solution":"def count_abc_anagrams(s): Returns the number of anagram substrings of 'abc' in the given string s. target = {'a': 1, 'b': 1, 'c': 1} count = 0 for i in range(len(s) - 2): substring = s[i:i+3] if len(substring) == 3: if {char: substring.count(char) for char in 'abc'} == target: count += 1 return count"},{"question":"def largest_island(grid: List[List[int]]) -> int: Returns the size of the largest island in the given grid. >>> largest_island([[0,0,1,0], [1,1,1,0], [0,1,0,0], [1,0,0,0]]) == 5 >>> largest_island([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 9 >>> largest_island([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> largest_island([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]) == 1","solution":"def largest_island(grid): Returns the size of the largest island in the given grid. if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # Mark the cell as visited size = 1 # Current cell counts as 1 size += dfs(i + 1, j) # Explore down size += dfs(i - 1, j) # Explore up size += dfs(i, j + 1) # Explore right size += dfs(i, j - 1) # Explore left return size max_size = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_size = max(max_size, dfs(i, j)) return max_size"},{"question":"def sort_array_by_parity(nums): Sorts the array so all even numbers come before all odd numbers, maintaining the relative order of even numbers and odd numbers. Parameters: nums (list): List of integers containing both even and odd numbers Returns: list: Sorted list with all even numbers before odd numbers. >>> sort_array_by_parity([3,1,2,4]) == [2, 4, 3, 1] >>> sort_array_by_parity([0,1,2]) == [0, 2, 1] >>> sort_array_by_parity([4,3,2,1]) == [4, 2, 3, 1] >>> sort_array_by_parity([1,3,5,7]) == [1, 3, 5, 7] >>> sort_array_by_parity([2,4,6,8]) == [2, 4, 6, 8]","solution":"def sort_array_by_parity(nums): Sorts the array so all even numbers come before all odd numbers, maintaining the relative order of even numbers and odd numbers. Parameters: nums (list): List of integers containing both even and odd numbers Returns: list: Sorted list with all even numbers before odd numbers. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 == 1] return evens + odds"},{"question":"from typing import List def findItinerary(tickets: List[List[str]]) -> List[str]: Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. Use all the tickets once and only once. Args: tickets (List[List[str]]): List of airline tickets Returns: List[str]: The itinerary in order Examples: >>> findItinerary([[\\"MUC\\", \\"LHR\\"], [\\"JFK\\", \\"MUC\\"], [\\"SFO\\", \\"SJC\\"], [\\"LHR\\", \\"SFO\\"]]) ['JFK', 'MUC', 'LHR', 'SFO', 'SJC'] >>> findItinerary([[\\"JFK\\", \\"LAX\\"]]) ['JFK', 'LAX']","solution":"from collections import defaultdict, deque def findItinerary(tickets): Finds the itinerary from a list of given airline tickets. Each ticket is a pair [from, to] representing a flight from the 'from' airport to the 'to' airport. :param tickets: List of tickets :return: Itinerary in lexicographical order graph = defaultdict(list) for start, end in sorted(tickets): graph[start].append(end) itinerary = [] stack = ['JFK'] while stack: while graph[stack[-1]]: stack.append(graph[stack[-1]].pop(0)) itinerary.append(stack.pop()) return itinerary[::-1]"},{"question":"from typing import List def group_anagrams(fruits: List[str]) -> List[List[str]]: Group fruit names that are anagrams of each other. Args: fruits (list of str): List of fruit names. Returns: list of list of str: List of grouped anagrams. >>> group_anagrams([\\"ate\\", \\"tea\\", \\"bat\\", \\"tab\\", \\"eat\\", \\"apple\\"]) [['ate', 'tea', 'eat'], ['bat', 'tab'], ['apple']] >>> group_anagrams([]) [] >>> group_anagrams([\\"apple\\"]) [['apple']] >>> group_anagrams([\\"apple\\", \\"banana\\", \\"carrot\\"]) [['apple'], ['banana'], ['carrot']] >>> group_anagrams([\\"ate\\", \\"tea\\", \\"bat\\", \\"tab\\", \\"eat\\", \\"apple\\", \\"elppa\\", \\"carrot\\", \\"torrac\\"]) [['ate', 'tea', 'eat'], ['bat', 'tab'], ['apple', 'elppa'], ['carrot', 'torrac']]","solution":"from collections import defaultdict def group_anagrams(fruits): Group fruit names that are anagrams of each other. Args: fruits (list of str): List of fruit names. Returns: list of list of str: List of grouped anagrams. anagram_map = defaultdict(list) for fruit in fruits: # Sort the characters in the fruit name and use as key sorted_fruit = \\"\\".join(sorted(fruit)) anagram_map[sorted_fruit].append(fruit) return list(anagram_map.values())"},{"question":"def minMeetingRooms(meetings): Calculate the minimum number of meeting rooms required to hold all the meetings. >>> minMeetingRooms([[0, 30], [5, 10], [15, 20]]) 2 >>> minMeetingRooms([[7, 10], [2, 4]]) 1","solution":"import heapq def minMeetingRooms(meetings): if not meetings: return 0 # Sort the meetings by start time meetings.sort(key=lambda x: x[0]) # Use a min-heap to keep track of the end times of meetings min_heap = [] # Add the end time of the first meeting heapq.heappush(min_heap, meetings[0][1]) # Iterate over the remaining meetings for meeting in meetings[1:]: # If the current meeting starts after or when the earliest meeting ends, remove the end time if meeting[0] >= min_heap[0]: heapq.heappop(min_heap) # Add the end time of the current meeting heapq.heappush(min_heap, meeting[1]) return len(min_heap)"},{"question":"def min_unique_colors(nums: List[int], k: int) -> int: Returns the minimum possible number of unique colors after performing at most k swaps. Parameters: nums (list of int): The array of integers representing different colored marbles. k (int): The number of swaps that can be performed. Returns: int: The minimum possible number of unique colors. >>> min_unique_colors([1, 2, 2, 3, 3, 3], 0) == 3 >>> min_unique_colors([1, 1, 1, 2, 2, 3], 1) == 2 >>> min_unique_colors([1, 1, 2, 2, 2, 3, 3, 3], 3) == 2 >>> min_unique_colors([1, 1, 1, 1], 2) == 1 >>> min_unique_colors([1, 2, 3, 4, 5, 6], 3) == 3 >>> min_unique_colors([1, 1, 2, 2, 3, 3], 10) == 1 >>> min_unique_colors([1]*50 + [2]*40 + [3]*10, 80) == 1","solution":"def min_unique_colors(nums, k): Returns the minimum possible number of unique colors after performing at most k swaps. Parameters: nums (list of int): The array of integers representing different colored marbles. k (int): The number of swaps that can be performed. Returns: int: The minimum possible number of unique colors. from collections import Counter # Count the frequency of each color freq_counter = Counter(nums) # If k is 0, no swaps can be performed, so return the number of unique colors if k == 0: return len(freq_counter) # Get the frequency counts sorted in ascending order freq_values = sorted(freq_counter.values()) # Minimize the unique colors starting by removing the least frequent colors for i in range(len(freq_values)): if k <= 0: break # Remove the least frequent color by reducing its count to 0, decreasing k by the count of removed color if freq_values[i] <= k: k -= freq_values[i] else: break # The minimum number of unique colors is the total initial unique colors minus the number of fully removed color groups return len(freq_values) - i"},{"question":"def count_forests(matrix): Given an \`n x n\` matrix where each of the elements is 0 or 1, determine the number of distinct forests. A forest is represented by adjacent 1s (adjacent horizontally or vertically). >>> count_forests([[1, 1, 0], [0, 1, 1], [0, 0, 1]]) 1 >>> count_forests([[1, 0, 1], [0, 1, 0], [1, 0, 1]]) 5 >>> count_forests([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> count_forests([[1, 0, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> count_forests([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> count_forests([]) 0 >>> count_forests([[0]]) 0 >>> count_forests([[1]]) 1","solution":"def count_forests(matrix): if not matrix or not matrix[0]: return 0 def dfs(matrix, visited, i, j): stack = [(i, j)] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while stack: ci, cj = stack.pop() for di, dj in directions: ni, nj = ci + di, cj + dj if 0 <= ni < len(matrix) and 0 <= nj < len(matrix[0]) and not visited[ni][nj] and matrix[ni][nj] == 1: visited[ni][nj] = True stack.append((ni, nj)) rows = len(matrix) cols = len(matrix[0]) visited = [[False] * cols for _ in range(rows)] count = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1 and not visited[i][j]: dfs(matrix, visited, i, j) count += 1 return count"},{"question":"from typing import List def universal_strings(words1: List[str], words2: List[str]) -> List[str]: You are given two arrays \`words1\` and \`words2\`. A string \`b\` is a **universal string** of an array of strings \`words\` if for every string \`a\` in \`words\`, every letter in \`a\` appears in \`b\` at least as many times as it appears in \`a\`. Return an array of strings \`words2\` such that each string in \`words2\` is a **universal string** for \`words1\`. >>> universal_strings([\\"a\\"], [\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) [\\"a\\", \\"ab\\", \\"abc\\"] >>> universal_strings([\\"abc\\"], [\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) [\\"abc\\"] >>> universal_strings([\\"a\\", \\"b\\"], [\\"a\\", \\"b\\", \\"ab\\", \\"abc\\"]) [\\"ab\\", \\"abc\\"]","solution":"from collections import Counter def is_universal(b, words): Helper function to determine if string b is a universal string for the array words. b_counter = Counter(b) for word in words: word_counter = Counter(word) for char, count in word_counter.items(): if b_counter[char] < count: return False return True def universal_strings(words1, words2): Returns an array of strings in words2 that are universal strings for words1. result = [] for b in words2: if is_universal(b, words1): result.append(b) return result"},{"question":"from typing import List class Solution: def __init__(self, s: str, dict: List[str]): Initializes the object with the string and the dictionary of words. Args: s (str): The string to be segmented. dict (List[str]): The dictionary of words. pass def canSegment(self) -> bool: Returns true if \`s\` can be segmented into a sequence of one or more dictionary words, otherwise returns false. Returns: bool: True if \`s\` can be segmented, otherwise false. >>> sol = Solution(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) >>> sol.canSegment() True >>> sol = Solution(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) >>> sol.canSegment() False pass def test_canSegment_case1(): s = \\"applepenapple\\" dict = [\\"apple\\", \\"pen\\"] sol = Solution(s, dict) assert sol.canSegment() == True def test_canSegment_case2(): s = \\"catsandog\\" dict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] sol = Solution(s, dict) assert sol.canSegment() == False def test_canSegment_empty_string(): s = \\"\\" dict = [\\"a\\", \\"b\\", \\"c\\"] sol = Solution(s, dict) assert sol.canSegment() == True def test_canSegment_single_word(): s = \\"apple\\" dict = [\\"apple\\", \\"pen\\"] sol = Solution(s, dict) assert sol.canSegment() == True def test_canSegment_no_valid_segmentation(): s = \\"catsandog\\" dict = [\\"cats\\", \\"sand\\", \\"dogs\\"] sol = Solution(s, dict) assert sol.canSegment() == False def test_canSegment_with_duplicates(): s = \\"appleapplepen\\" dict = [\\"apple\\", \\"pen\\"] sol = Solution(s, dict) assert sol.canSegment() == True","solution":"from typing import List class Solution: def __init__(self, s: str, dict: List[str]): self.s = s self.dict = set(dict) # Use a set for faster lookups self.memo = {} def canSegment(self) -> bool: return self._canSegment(self.s) def _canSegment(self, s: str) -> bool: if not s: return True if s in self.memo: return self.memo[s] for i in range(1, len(s) + 1): prefix = s[:i] if prefix in self.dict and self._canSegment(s[i:]): self.memo[s] = True return True self.memo[s] = False return False"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string \`s\`, find the length of the longest substring without repeating characters. The function should handle both upper-case and lower-case Latin characters and account for their uniqueness separately. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aAaA\\") 2 >>> length_of_longest_substring(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> length_of_longest_substring(\\"abba\\") 2 >>> length_of_longest_substring(\\"tmmzuxt\\") 5 >>> length_of_longest_substring(\\"!@#%^&*()_+\\") 12 >>> length_of_longest_substring(\\"a\\" * 100) 1","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"class EventCounter: A class used to record and count events at specific times. def __init__(self): Initializes the event counter. pass def addEvent(self, t: int) -> None: Records a new event at time t. :param t: Time of the event. pass def countEvents(self, start: int, end: int) -> int: Returns the number of events that occurred in the inclusive range [start, end]. :param start: Start time of the range. :param end: End time of the range. :return: Number of events in the range [start, end]. pass # Unit Tests from solution import EventCounter def test_add_and_count_events(): event_counter = EventCounter() event_counter.addEvent(1) event_counter.addEvent(3) event_counter.addEvent(5) event_counter.addEvent(7) event_counter.addEvent(9) assert event_counter.countEvents(0, 10) == 5 assert event_counter.countEvents(1, 1) == 1 assert event_counter.countEvents(5, 5) == 1 assert event_counter.countEvents(6, 8) == 1 assert event_counter.countEvents(10, 15) == 0 assert event_counter.countEvents(2, 4) == 1 def test_no_events(): event_counter = EventCounter() assert event_counter.countEvents(0, 10) == 0 def test_events_outside_range(): event_counter = EventCounter() event_counter.addEvent(1) event_counter.addEvent(3) assert event_counter.countEvents(4, 10) == 0 def test_events_at_boundaries(): event_counter = EventCounter() event_counter.addEvent(1) event_counter.addEvent(3) event_counter.addEvent(5) assert event_counter.countEvents(1, 3) == 2 assert event_counter.countEvents(1, 5) == 3 assert event_counter.countEvents(3, 5) == 2","solution":"class EventCounter: def __init__(self): Initializes the event counter. self.events = [] def addEvent(self, t): Records a new event at time t. :param t: Time of the event. self.events.append(t) def countEvents(self, start, end): Returns the number of events that occurred in the inclusive range [start, end]. :param start: Start time of the range. :param end: End time of the range. :return: Number of events in the range [start, end]. count = 0 for event in self.events: if start <= event <= end: count += 1 return count"},{"question":"from typing import Optional def rearrangeFlowers(s: str, k: int) -> str: Rearrange the characters in the string s such that no two identical flowers are within k indices of each other. Args: s (str): The string where each character represents a type of flower. k (int): The maximum distance within which the same type of flower should not repeat. Returns: str: The rearranged string or an empty string if the arrangement is not feasible. >>> rearrangeFlowers(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\"] True >>> rearrangeFlowers(\\"aa\\", 2) '' >>> rearrangeFlowers(\\"aaa\\", 0) 'aaa' >>> rearrangeFlowers(\\"aaa\\", 2) '' >>> rearrangeFlowers(\\"abab\\", 2) 'abab' >>> result = rearrangeFlowers(\\"aabbcc\\", 2) >>> set(result) == set(\\"aabbcc\\") and result in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\"] True","solution":"from collections import Counter from heapq import heapify, heappop, heappush def rearrangeFlowers(s, k): if k == 0: return s # Count the frequency of each flower type flower_counts = Counter(s) # Create a max heap based on the frequency of characters max_heap = [(-count, flower) for flower, count in flower_counts.items()] heapify(max_heap) queue = [] result = [] while max_heap: count, flower = heappop(max_heap) result.append(flower) # Appending the flower to the queue with its next valid index queue.append((flower, count + 1)) # Increment count since it's negative if len(queue) >= k: recyclable_flower, recyclable_count = queue.pop(0) if recyclable_count < 0: heappush(max_heap, (recyclable_count, recyclable_flower)) if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def sunset_views(heights: List[int]) -> List[int]: Calculate the indexes of buildings that have a sunset view, assuming the sun sets to the west (to the right). Parameters: heights (List[int]): A list of building heights. Returns: List[int]: The indexes of the buildings that have a sunset view in the order of their appearance. >>> sunset_views([1, 2, 3, 4]) [0, 1, 2, 3] >>> sunset_views([4, 3, 2, 1]) [0] >>> sunset_views([3, 1, 4, 2, 5]) [0, 2, 4] >>> sunset_views([2, 2, 2, 2]) [0] >>> sunset_views([10]) [0] >>> sunset_views([]) [] >>> sunset_views([2, 2, 1, 3, 3]) [0, 3]","solution":"def sunset_views(heights): Returns the indexes of buildings that have a sunset view. Parameters: heights (list of int): A list of building heights. Returns: list of int: The indexes of the buildings that have a sunset view. sunset_buildings = [] max_height = float('-inf') for i in range(len(heights)): if heights[i] > max_height: sunset_buildings.append(i) max_height = max(max_height, heights[i]) return sunset_buildings"},{"question":"def distribute_prizes(scores: List[int]) -> List[int]: Distributes prizes such that each player has a unique prize amount based on their score. Players with higher scores get higher prize amounts starting from 1 for the lowest score. Args: scores (list): List of integer scores of players. Returns: list: List of integer prizes corresponding to each player's score. pass # Unit tests def test_distribute_prizes_with_distinct_scores(): scores = [10, 20, 30] expected = [1, 2, 3] assert distribute_prizes(scores) == expected def test_distribute_prizes_with_duplicate_scores(): scores = [10, 20, 20, 30] expected = [1, 2, 2, 3] assert distribute_prizes(scores) == expected def test_distribute_prizes_with_all_same_scores(): scores = [10, 10, 10] expected = [1, 1, 1] assert distribute_prizes(scores) == expected def test_distribute_prizes_with_reverse_ordered_scores(): scores = [30, 20, 10] expected = [3, 2, 1] assert distribute_prizes(scores) == expected def test_distribute_prizes_with_single_score(): scores = [15] expected = [1] assert distribute_prizes(scores) == expected def test_distribute_prizes_with_random_order(): scores = [50, 30, 40, 30, 20] expected = [4, 2, 3, 2, 1] assert distribute_prizes(scores) == expected","solution":"def distribute_prizes(scores): Distributes prizes such that each player has a unique prize amount based on their score. Players with higher scores get higher prize amounts starting from 1 for the lowest score. Args: scores (list): List of integer scores of players. Returns: list: List of integer prizes corresponding to each player's score. # Get sorted unique scores sorted_unique_scores = sorted(set(scores)) # Create a dictionary with score as key and prize amount as value score_to_prize = {score: index + 1 for index, score in enumerate(sorted_unique_scores)} # Distribute prizes based on the score_to_prize mapping prizes = [score_to_prize[score] for score in scores] return prizes"},{"question":"def earliest_arrival_time(trainTimes): Returns the earliest arrival time at the final station starting from station 0. If it is not possible to reach the final station, returns -1. Examples: >>> earliest_arrival_time([[3], [2], [1], []]) 6 >>> earliest_arrival_time([[5,10], [3,8], [2,6], [1,4], []]) 11 >>> earliest_arrival_time([[], [], [], []]) -1 >>> earliest_arrival_time([[5], [], [2], []]) -1 >>> earliest_arrival_time([[2], [1], []]) 3 >>> earliest_arrival_time([[1, 4], [1, 3], [1, 2], []]) 3 >>> earliest_arrival_time([]) -1","solution":"from queue import PriorityQueue def earliest_arrival_time(trainTimes): Returns the earliest arrival time at the final station starting from station 0. If it is not possible to reach the final station, returns -1. n = len(trainTimes) if n == 0: return -1 pq = PriorityQueue() pq.put((0, 0)) # (time, station) visited = [False] * n while not pq.empty(): current_time, current_station = pq.get() if current_station == n - 1: return current_time if visited[current_station]: continue visited[current_station] = True for departure_time in trainTimes[current_station]: arrival_time = current_time + departure_time pq.put((arrival_time, current_station + 1)) return -1"},{"question":"def longest_subarray_with_sum_leq_x(arr, n, x): Returns the length of the longest contiguous subarray such that the sum of its elements is less than or equal to x. >>> longest_subarray_with_sum_leq_x([1, 2, 3, 4, 5], 5, 9) 3 >>> longest_subarray_with_sum_leq_x([5, 1, 3, 2, 6], 5, 7) 3 >>> longest_subarray_with_sum_leq_x([1, 2, 3, 4, 5], 5, 15) 5 >>> longest_subarray_with_sum_leq_x([5, 6, 7, 8, 9], 5, 4) 0 >>> longest_subarray_with_sum_leq_x([1, 2, 3, 4, 5], 5, 10) 4","solution":"def longest_subarray_with_sum_leq_x(arr, n, x): Returns the length of the longest contiguous subarray with sum <= x. max_length = 0 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: current_sum -= arr[start] start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, arb=None): self.val = val self.left = left self.right = right self.arb = arb def deep_copy_binary_tree(root: Node) -> Node: Perform a deep copy of the given binary tree. Each node contains an integer value, left child, right child, and an arbitrary pointer which may point to any node in the tree. Given the root of the binary tree, return the root of the deep-copied binary tree. >>> n1 = Node(1) >>> n2 = Node(2) >>> n3 = Node(3) >>> n4 = Node(4) >>> n1.left, n1.right = n2, n3 >>> n2.arb = n4 >>> n3.arb = n2 >>> copied_root = deep_copy_binary_tree(n1) >>> copied_root.val == n1.val True >>> copied_root.left.val == n1.left.val True >>> copied_root.right.val == n1.right.val True >>> copied_root.left.arb.val == n1.left.arb.val True >>> copied_root.right.arb.val == n1.right.arb.val True","solution":"class Node: def __init__(self, val=0, left=None, right=None, arb=None): self.val = val self.left = left self.right = right self.arb = arb def deep_copy_binary_tree(root): if not root: return None old_to_new = {} def copy_node(node): if not node: return None if node in old_to_new: return old_to_new[node] copied_node = Node(node.val) old_to_new[node] = copied_node copied_node.left = copy_node(node.left) copied_node.right = copy_node(node.right) copied_node.arb = copy_node(node.arb) return copied_node return copy_node(root)"},{"question":"def all_paths_source_target(graph: List[List[int]], start: int, end: int) -> List[List[int]]: Returns all paths from start node 's' to end node 'd' in the given graph. Each path is represented as a list of nodes. :param graph: List of lists. The graph adjacency list where graph[i] is a list of nodes i connects to. :param start: Integer. The starting node 's'. :param end: Integer. The destination node 'd'. :return: List of lists. All paths from start to end. Example: >>> graph = [[1, 2], [3], [3], []] >>> start = 0 >>> end = 3 >>> all_paths_source_target(graph, start, end) [[0, 1, 3], [0, 2, 3]]","solution":"def all_paths_source_target(graph, start, end): Returns all paths from start node 's' to end node 'd' in the given graph. Each path is represented as a list of nodes. :param graph: List of lists. The graph adjacency list where graph[i] is a list of nodes i connects to. :param start: Integer. The starting node 's'. :param end: Integer. The destination node 'd'. :return: List of lists. All paths from start to end. def dfs(node, path, all_paths): # If the current node is the end, add the path to the results if node == end: all_paths.append(list(path)) return # Explore each neighbor for neighbor in graph[node]: if neighbor not in path: # Ensure no node is repeated in the current path path.append(neighbor) dfs(neighbor, path, all_paths) # Recursively build the path path.pop() # Backtrack all_paths = [] dfs(start, [start], all_paths) return all_paths"},{"question":"def can_finish_courses(graph: List[List[int]]) -> bool: Determines if it's possible to complete all courses given the prerequisite relationships in the graph. >>> can_finish_courses([ ... [0, 1, 0], ... [0, 0, 1], ... [0, 0, 0] ... ]) True >>> can_finish_courses([ ... [0, 1, 0], ... [0, 0, 1], ... [1, 0, 0] ... ]) False >>> can_finish_courses([]) True >>> can_finish_courses([ ... [0] ... ]) True >>> can_finish_courses([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) True >>> can_finish_courses([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [1, 0, 0, 0] ... ]) False >>> can_finish_courses([ ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [0, 0, 0, 1], ... [0, 0, 0, 0] ... ]) True","solution":"def can_finish_courses(graph): Determines if it's possible to complete all courses given the prerequisite relationships in the graph. Parameters: - graph: List[List[int]]: A square matrix representing the graph. Returns: - bool: True if all courses can be completed, False otherwise. def has_cycle(v, visited, rec_stack): # Mark the current node as visited and add it to recursion stack visited[v] = True rec_stack[v] = True # Recur for all vertices adjacent to this vertex for i in range(len(graph[v])): if graph[v][i] == 1: if not visited[i]: if has_cycle(i, visited, rec_stack): return True elif rec_stack[i]: return True # Remove the vertex from recursion stack rec_stack[v] = False return False num_courses = len(graph) visited = [False] * num_courses rec_stack = [False] * num_courses # Check for cycles in the graph for course in range(num_courses): if not visited[course]: if has_cycle(course, visited, rec_stack): return False return True"},{"question":"def longest_substring_max_freq(s: str, k: int) -> int: Returns the length of the longest substring of \`s\` such that the frequency of each character in this substring is at most \`k\`. >>> longest_substring_max_freq(\\"abcdef\\", 1) == 6 >>> longest_substring_max_freq(\\"aaaaaa\\", 1) == 1 >>> longest_substring_max_freq(\\"aaaaaa\\", 2) == 2 >>> longest_substring_max_freq(\\"aaaaaa\\", 6) == 6 >>> longest_substring_max_freq(\\"aabbcc\\", 1) == 2 >>> longest_substring_max_freq(\\"aabbcc\\", 2) == 6 >>> longest_substring_max_freq(\\"abcabc\\", 2) == 6 >>> longest_substring_max_freq(\\"abcdef\\", 2) == 6 >>> longest_substring_max_freq(\\"a\\"*100 + \\"b\\"*100, 10) == 20 >>> longest_substring_max_freq(\\"a\\" * 1000 + \\"b\\" * 1000, 1) == 2 >>> longest_substring_max_freq(\\"a\\" * 1000 + \\"b\\" * 1000, 100) == 200 >>> longest_substring_max_freq(\\"a\\" * 100000, 100000) == 100000 >>> longest_substring_max_freq(\\"\\".join(chr(97 + i % 26) for i in range(100000)), 100000) == 100000","solution":"def longest_substring_max_freq(s, k): Returns the length of the longest substring of \`s\` such that the frequency of each character in this substring is at most \`k\`. from collections import defaultdict n = len(s) # left and right pointers left, right = 0, 0 # dictionary to keep the count of characters in the current window freq = defaultdict(int) # variable to store the result max_length = 0 while right < n: # include the current character in the window freq[s[right]] += 1 # check if the current window is valid while any(count > k for count in freq.values()): freq[s[left]] -= 1 if freq[s[left]] == 0: del freq[s[left]] left += 1 # update the result max_length = max(max_length, right - left + 1) # move the right pointer to the right right += 1 return max_length"},{"question":"def rearrange_string(s: str, k: int) -> str: Rearrange the string such that no two adjacent characters are the same, with each group having length at most k. If rearrangement is not possible, return an empty string. >>> rearrange_string(\\"aabbcc\\", 3) in [\\"abcabc\\", \\"acbacb\\"] >>> rearrange_string(\\"aaabc\\", 3) == \\"\\" >>> rearrange_string(\\"aaadbbcc\\", 2) in [\\"abacabcd\\", \\"abacabad\\"] >>> rearrange_string(\\"aabc\\", 0) == \\"aabc\\" >>> rearrange_string(\\"abc\\", 2) == \\"abc\\" >>> rearrange_string(\\"a\\", 1) == \\"a\\" >>> rearrange_string(\\"\\", 3) == \\"\\" >>> rearrange_string(\\"aabb\\", 3) == \\"\\" >>> rearrange_string(\\"aaa\\", 2) == \\"\\"","solution":"def rearrange_string(s, k): if k == 0: # if k is 0, no need to rearrange return s from collections import Counter, deque import heapq # Count the occurrence of each character counter = Counter(s) max_heap = [(-cnt, char) for char, cnt in counter.items()] heapq.heapify(max_heap) queue = deque() result = [] while max_heap: cnt, char = heapq.heappop(max_heap) result.append(char) queue.append((cnt + 1, char)) # push it to the waiting queue if len(queue) >= k: # wait until the k interval is reached prev_cnt, prev_char = queue.popleft() if -prev_cnt > 0: # reinsert into heap only if there's remaining count heapq.heappush(max_heap, (prev_cnt, prev_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"def can_partition_into_palindrome_subsequences(s: str, k: int) -> bool: Determine if the string s can be broken into k non-overlapping subsequences such that each subsequence is a palindrome. :param s: String to be checked for partitioning. :param k: Number of required palindrome subsequences. :return: True if it is possible to partition into k palindrome subsequences, False otherwise. >>> can_partition_into_palindrome_subsequences(\\"aabb\\", 2) True >>> can_partition_into_palindrome_subsequences(\\"racercar\\", 3) True >>> can_partition_into_palindrome_subsequences(\\"abc\\", 3) True >>> can_partition_into_palindrome_subsequences(\\"aabbc\\", 3) True >>> can_partition_into_palindrome_subsequences(\\"abcda\\", 1) False >>> can_partition_into_palindrome_subsequences(\\"a\\", 2) False >>> can_partition_into_palindrome_subsequences(\\"aaaa\\", 1) True >>> can_partition_into_palindrome_subsequences(\\"aaaa\\", 2) True >>> can_partition_into_palindrome_subsequences(\\"aaaa\\", 4) True >>> can_partition_into_palindrome_subsequences(\\"aaaa\\", 5) False >>> can_partition_into_palindrome_subsequences(\\"abcd\\", 3) False >>> can_partition_into_palindrome_subsequences(\\"abcd\\", 4) True >>> can_partition_into_palindrome_subsequences(\\"abcdda\\", 3) True","solution":"def can_partition_into_palindrome_subsequences(s, k): Determine if the string s can be broken into k non-overlapping subsequences such that each subsequence is a palindrome. :param s: String to be checked for partitioning. :param k: Number of required palindrome subsequences. :return: True if it is possible to partition into k palindrome subsequences, False otherwise. # Helper function to determine if a string is a palindrome def is_palindrome(sub): return sub == sub[::-1] # Length of the given string n = len(s) # Base case if k > n: return False # More subsequences than characters is impossible if k == 1: return is_palindrome(s) # Single subsequence must be the entire string and a palindrome if k == n: return True # Each character can be a palindrome subsequence # For any other general case min_required_palindromes = 0 count = {} for char in s: count[char] = count.get(char, 0) + 1 for value in count.values(): min_required_palindromes += value % 2 return min_required_palindromes <= k"},{"question":"def min_students_in_correct_position(heights: List[int]) -> int: Determine the minimum number of students already in the correct position relative to the heights sorted in non-decreasing order. :param heights: List[int] - the heights of the students :return: int - the minimum number of students already in the correct position >>> min_students_in_correct_position([1, 2, 3, 4]) 4 >>> min_students_in_correct_position([4, 3, 2, 1]) 0 >>> min_students_in_correct_position([1, 3, 2, 4]) 2 >>> min_students_in_correct_position([1, 2, 2, 3, 1]) 2 >>> min_students_in_correct_position([]) 0 >>> min_students_in_correct_position([5]) 1","solution":"def min_students_in_correct_position(heights): Return the minimum number of students that are already in the correct position when the list is sorted in non-decreasing order. :param heights: List[int] - the heights of the students :return: int - the minimum number of students already in the correct position sorted_heights = sorted(heights) count = 0 for i in range(len(heights)): if heights[i] == sorted_heights[i]: count += 1 return count"},{"question":"from typing import List class BusRoutes: A city has several bus routes represented by a 2D array \`routes\`, where each \`routes[i]\` is an array of bus stops that route \`i\` goes through in order. Implement the \`BusRoutes\` class: * \`BusRoutes(List[List[int]] routes)\` Initializes the object with the given bus routes. * \`int numBusesToDestination(int start, int destination)\` Returns the fewest number of buses you need to take to travel from the \`start\` bus stop to the \`destination\` bus stop. If it is not possible to travel from start to destination using the given bus routes, return \`-1\`. Example: >>> routes = [[1, 2, 7], [3, 6, 7]] >>> bus_routes = BusRoutes(routes) >>> bus_routes.numBusesToDestination(1, 7) 1 >>> bus_routes.numBusesToDestination(1, 6) 2 >>> bus_routes.numBusesToDestination(5, 6) -1 >>> bus_routes.numBusesToDestination(1, 1) 0 >>> routes = [ ... [1, 2, 3], ... [2, 8, 10], ... [3, 4, 5], ... [5, 6, 7], ... [8, 11, 12], ... [10, 12, 13]] >>> bus_routes = BusRoutes(routes) >>> bus_routes.numBusesToDestination(1, 12) 3 >>> routes = [] >>> bus_routes = BusRoutes(routes) >>> bus_routes.numBusesToDestination(1, 2) -1 def __init__(self, routes: List[List[int]]): pass def numBusesToDestination(self, start: int, destination: int) -> int: pass","solution":"from collections import deque, defaultdict class BusRoutes: def __init__(self, routes): self.routes = routes self.bus_stop_to_routes = defaultdict(set) for i, route in enumerate(routes): for stop in route: self.bus_stop_to_routes[stop].add(i) def numBusesToDestination(self, start, destination): if start == destination: return 0 visited_stops = set() visited_routes = set() queue = deque([(start, 0)]) # (current stop, buses taken so far) while queue: current_stop, buses_taken = queue.popleft() if current_stop in visited_stops: continue visited_stops.add(current_stop) for route_index in self.bus_stop_to_routes[current_stop]: if route_index in visited_routes: continue visited_routes.add(route_index) for next_stop in self.routes[route_index]: if next_stop == destination: return buses_taken + 1 queue.append((next_stop, buses_taken + 1)) return -1"},{"question":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses needed to make the string valid. >>> min_add_to_make_valid(\\"())\\") == 1 >>> min_add_to_make_valid(\\"(((\\") == 3 >>> min_add_to_make_valid(\\"()\\") == 0 >>> min_add_to_make_valid(\\"(())\\") == 0 >>> min_add_to_make_valid(\\"((()))(()\\") == 1 >>> min_add_to_make_valid(\\"\\") == 0 >>> min_add_to_make_valid(\\"()()((())\\") == 1 >>> min_add_to_make_valid(\\"))))\\") == 4 >>> min_add_to_make_valid(\\")(((\\") == 4","solution":"def min_add_to_make_valid(s: str) -> int: Returns the minimum number of parentheses needed to make the string valid. left_balance = 0 right_balance = 0 for char in s: if char == '(': left_balance += 1 elif char == ')': if left_balance > 0: left_balance -= 1 else: right_balance += 1 return left_balance + right_balance"},{"question":"def is_palindrome_possible(s: str) -> bool: Check if it's possible to replace '*' characters in the string \`s\` to make it a palindrome. :param s: Input string composed of 'a', 'b', and '*' characters. :return: True if it's possible to form a palindrome, False otherwise. Examples: >>> is_palindrome_possible(\\"a*aa\\") True >>> is_palindrome_possible(\\"*\\") True >>> is_palindrome_possible(\\"ab*ba\\") True >>> is_palindrome_possible(\\"ab*ca\\") False >>> is_palindrome_possible(\\"**\\") True >>> is_palindrome_possible(\\"a*b*a\\") True >>> is_palindrome_possible(\\"a*ba\\") True >>> is_palindrome_possible(\\"a*b*b*a\\") True >>> is_palindrome_possible(\\"a*a\\") True >>> is_palindrome_possible(\\"abc\\") False >>> is_palindrome_possible(\\"a*b*b*\\") True","solution":"def is_palindrome_possible(s): Check if it's possible to replace '*' characters in the string \`s\` to make it a palindrome. :param s: Input string composed of 'a', 'b', and '*' characters. :return: True if it's possible to form a palindrome, False otherwise. left = 0 right = len(s) - 1 while left <= right: if s[left] == s[right]: # Both are equal (both can also be '*') left += 1 right -= 1 elif s[left] == '*': # Replace '*' at left with character at right left += 1 right -= 1 elif s[right] == '*': # Replace '*' at right with character at left left += 1 right -= 1 else: # Characters are different and none are '*', cannot form a palindrome return False return True"},{"question":"from typing import List def most_frequent_string(words: List[str]) -> str: Returns the most frequent string in a list of strings. If there are multiple strings with the same highest frequency, returns the lexicographically smallest string among them. Args: words (List[str]): List of strings. Returns: str: Most frequent string or lexicographically smallest string among tied. >>> most_frequent_string([\\"apple\\"]) 'apple' >>> most_frequent_string([\\"apple\\", \\"apple\\", \\"banana\\"]) 'apple' >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) 'apple' >>> most_frequent_string([]) '' >>> most_frequent_string([\\"apple\\", \\"apple\\", \\"apple\\"]) 'apple' >>> most_frequent_string([\\"apple\\", \\"banana\\", \\"apple\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"banana\\", \\"cherry\\", \\"cherry\\"]) 'apple' >>> most_frequent_string([\\"dog\\", \\"cat\\", \\"cat\\", \\"dog\\", \\"dog\\", \\"bat\\", \\"bat\\", \\"bat\\"]) 'bat' # Your code here","solution":"from collections import Counter def most_frequent_string(words): Returns the most frequent string in a list of strings. If there are multiple strings with the same highest frequency, returns the lexicographically smallest string among them. if not words: return \\"\\" word_count = Counter(words) max_count = max(word_count.values()) most_frequent = [word for word, count in word_count.items() if count == max_count] return min(most_frequent)"},{"question":"def min_operations(s: str) -> int: Returns the minimum number of operations required to transform the string into a string in which no two adjacent characters are the same. >>> min_operations('aaaa') == 2 >>> min_operations('bbbb') == 2 >>> min_operations('abab') == 0 >>> min_operations('baba') == 0 >>> min_operations('aaab') == 1 >>> min_operations('baaa') == 1 >>> min_operations('ababab') == 0 >>> min_operations('aabb') == 2 >>> min_operations('a') == 0 >>> min_operations('b') == 0","solution":"def min_operations(s): Returns the minimum number of operations required to transform the string into a string in which no two adjacent characters are the same. # Generate alternating patterns pattern1 = ''.join('a' if i % 2 == 0 else 'b' for i in range(len(s))) pattern2 = ''.join('b' if i % 2 == 0 else 'a' for i in range(len(s))) # Count differences with the original string for each pattern ops1 = sum(1 for i in range(len(s)) if s[i] != pattern1[i]) ops2 = sum(1 for i in range(len(s)) if s[i] != pattern2[i]) # Return the minimum of both counts return min(ops1, ops2)"},{"question":"def three_sum(arr: list[int], k: int) -> bool: Determines if there are three distinct elements in the array whose sum equals k. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([-1, 2, 4, 7], 5) True >>> three_sum([0, 0, 0, 0], 0) True >>> three_sum([0, 1, 2, 3], 0) False >>> three_sum([-5, -4, -3, -2, -1], -10) True >>> three_sum([1, 1], 3) False >>> three_sum([1], 1) False >>> three_sum([], 0) False","solution":"def three_sum(arr, k): Determines if there are three distinct elements in the array whose sum equals k. Args: arr (list of int): The input array containing integers. k (int): The target sum. Returns: bool: True if there are three distinct elements whose sum equals k, False otherwise. arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"from typing import List def findDuplicates(nums: List[int]) -> List[int]: Finds all the elements that appear twice in the array nums. The input array nums contains elements in the range [1, n] where n is the length of the array. Args: nums (list): An array of integers. Returns: list: A list containing all elements that appear twice in nums. >>> findDuplicates([4,3,2,7,8,2,3,1]) [2, 3] >>> findDuplicates([1, 2, 3, 4, 5]) [] # Unit tests def test_findDuplicates_with_duplicates(): assert findDuplicates([4,3,2,7,8,2,3,1]) == [2, 3] def test_findDuplicates_all_unique(): assert findDuplicates([1, 2, 3, 4, 5]) == [] def test_findDuplicates_all_duplicates(): assert findDuplicates([1,1,2,2,3,3,4,4]) == [1, 2, 3, 4] def test_findDuplicates_no_elements(): assert findDuplicates([]) == [] def test_findDuplicates_single_element(): assert findDuplicates([1]) == [] def test_findDuplicates_single_duplicate(): assert findDuplicates([1, 2, 3, 4, 5, 5]) == [5] def test_findDuplicates_large_input(): assert findDuplicates([i for i in range(1, 10001)] + [5000]) == [5000]","solution":"def findDuplicates(nums): Finds all the elements that appear twice in the array nums. The input array nums contains elements in the range [1, n] where n is the length of the array. Args: nums (list): An array of integers. Returns: list: A list containing all elements that appear twice in nums. duplicates = [] for i in range(len(nums)): index = abs(nums[i]) - 1 if nums[index] < 0: duplicates.append(index + 1) nums[index] = -nums[index] return duplicates"},{"question":"from typing import List def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the nums array. :param nums: List[int] - List of integers :param k: int - The k-th position to find the largest element :return: int - The k-th largest element >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([-1, -2, -3, -4, -5], 1) -1 >>> find_kth_largest([-10, -7, -2, -4], 2) -4 >>> find_kth_largest([1, -1, 0, 2, -2], 3) 0","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the nums array. :param nums: List[int] - List of integers :param k: int - The k-th position to find the largest element :return: int - The k-th largest element # Sort the array in descending order nums.sort(reverse=True) # Return the k-th largest element (k-1 because of zero-indexing) return nums[k - 1]"},{"question":"def trap(heights: List[int]) -> int: Calculate the total area of water that can be trapped between the buildings after a rain. >>> trap([4,2,0,3,2,5]) 9 >>> trap([1,1,1,1,1]) 0 >>> trap([]) 0 >>> trap([5]) 0 >>> trap([0]) 0 >>> trap([5,4,3,2,1]) 0 >>> trap([1,2,3,4,5]) 0 >>> trap([3, 0, 2, 0, 4]) 7 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6","solution":"def trap(heights): Calculate the total area of water that can be trapped between the buildings after a rain. :param heights: List[int] - array representing the heights of buildings :return: int - total units of trapped water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def split_string_into_same_char_substrings(s: str) -> list: Determine if a string can be split into continuous substrings of the same character. :param s: Input string :type s: str :return: List of substrings if possible, otherwise an empty list :rtype: list >>> split_string_into_same_char_substrings(\\"aaabbbccc\\") ['aaa', 'bbb', 'ccc'] >>> split_string_into_same_char_substrings(\\"aaaa\\") ['aaaa'] >>> split_string_into_same_char_substrings(\\"ababab\\") ['a', 'b', 'a', 'b', 'a', 'b'] >>> split_string_into_same_char_substrings(\\"\\") [] >>> split_string_into_same_char_substrings(\\"aabbbccccdd\\") ['aa', 'bbb', 'cccc', 'dd'] >>> split_string_into_same_char_substrings(\\"z\\") ['z'] >>> split_string_into_same_char_substrings(\\"xxxxx\\") ['xxxxx']","solution":"def split_string_into_same_char_substrings(s): Determine if a string can be split into continuous substrings of the same character. :param s: Input string :type s: str :return: List of substrings if possible, otherwise an empty list :rtype: list if not s: return [] substrings = [] current_char = s[0] current_substring = current_char for char in s[1:]: if char == current_char: current_substring += char else: substrings.append(current_substring) current_char = char current_substring = char substrings.append(current_substring) return substrings"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> List[int]: Given a binary tree, return the inorder traversal of its nodes' values. Inorder traversal visits the left subtree, followed by the root node, and finally the right subtree. >>> inorder_traversal(None) [] >>> inorder_traversal(TreeNode(1)) [1] >>> inorder_traversal(TreeNode(1, TreeNode(2, TreeNode(3)))) [3, 2, 1] >>> inorder_traversal(TreeNode(1, None, TreeNode(2, None, TreeNode(3)))) [1, 2, 3] >>> inorder_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) [4, 2, 5, 1, 3] >>> inorder_traversal(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5, TreeNode(6), TreeNode(7))), TreeNode(3))) [4, 2, 6, 5, 7, 1, 3]","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root: TreeNode) -> List[int]: result = [] def _inorder(node: TreeNode): if node: _inorder(node.left) result.append(node.val) _inorder(node.right) _inorder(root) return result"},{"question":"from typing import List def min_number_of_steps(n: int, entries: List[int], edges: List[List[int]]) -> int: Given a directed acyclic graph (DAG) with \`n\` nodes, numbered from \`0\` to \`n-1\`, and an array \`entries\` where \`entries[i]\` represents the number of incoming edges (dependencies) to the \`i-th\` node, and a 2D integer array \`edges\` representing the directed edges in the graph, returns the minimum number of steps required to complete all nodes. Multiple nodes with no remaining dependencies can be completed simultaneously in each step. Returns the minimum number of steps needed to finish all tasks, or \`-1\` if there exists a cycle which prevents the completion of all tasks. >>> min_number_of_steps(3, [0, 1, 1], [[0, 1], [0, 2]]) 2 >>> min_number_of_steps(3, [1, 1, 1], [[0, 1], [1, 2], [2, 0]]) -1 >>> min_number_of_steps(1, [0], []) 1 >>> min_number_of_steps(4, [0, 1, 1, 2], [[0, 1], [1, 3], [2, 3], [0, 2]]) 3 >>> min_number_of_steps(5, [0, 0, 1, 1, 2], [[0, 2], [1, 3], [2, 4], [3, 4]]) 3 from collections import deque, defaultdict # Implementation here","solution":"from collections import deque, defaultdict def min_number_of_steps(n, entries, edges): Returns the minimum number of steps required to complete all nodes in the graph, or -1 if there is a cycle. # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) # Initialize a queue with nodes having 0 incoming edges queue = deque([i for i in range(n) if entries[i] == 0]) # Perform BFS steps = 0 processed_nodes = 0 while queue: current_level_size = len(queue) for _ in range(current_level_size): node = queue.popleft() processed_nodes += 1 for neighbor in adj_list[node]: entries[neighbor] -= 1 if entries[neighbor] == 0: queue.append(neighbor) steps += 1 # If all nodes are processed, return steps, else return -1 (cycle exists) return steps if processed_nodes == n else -1"},{"question":"from typing import List def shift_grid(grid: List[List[int]], k: int) -> List[List[int]]: Shifts the elements of the matrix \`k\` times. Args: grid (List[List[int]]): 2D list representing the matrix. k (int): Number of times to shift the matrix. Returns: List[List[int]]: The shifted matrix. >>> shift_grid([[1,2,3], [4,5,6], [7,8,9]], 1) [[9,1,2], [3,4,5], [6,7,8]] >>> shift_grid([[1,2], [3,4]], 5) [[4,1], [2,3]]","solution":"def shift_grid(grid, k): Shifts the elements of the matrix \`k\` times. Args: grid (List[List[int]]): 2D list representing the matrix. k (int): Number of times to shift the matrix. Returns: List[List[int]]: The shifted matrix. if not grid or not grid[0]: return grid m, n = len(grid), len(grid[0]) total = m * n k = k % total if k == 0: return grid flat_list = [cell for row in grid for cell in row] flat_list = flat_list[-k:] + flat_list[:-k] new_grid = [] for i in range(0, total, n): new_grid.append(flat_list[i:i+n]) return new_grid"},{"question":"from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Find the k-th largest element in the array. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"from typing import List def find_kth_largest(arr: List[int], k: int) -> int: Returns the k-th largest element in the array. arr.sort(reverse=True) return arr[k - 1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): TreeNode constructor. :param val: int, the value of the node :param left: TreeNode, the left child of the node :param right: TreeNode, the right child of the node self.val = val self.left = left self.right = right def bst_from_preorder(preorder: List[int]) -> Optional[TreeNode]: Reconstruct a binary search tree (BST) from a given preorder traversal array. :param preorder: List[int], the preorder traversal of the BST :return: TreeNode, the root of the reconstructed BST >>> in_order_traversal(bst_from_preorder([8, 5, 1, 7, 10, 12])) [1, 5, 7, 8, 10, 12] >>> in_order_traversal(bst_from_preorder([1, 2, 3, 4, 5])) [1, 2, 3, 4, 5] >>> in_order_traversal(bst_from_preorder([5, 4, 3, 2, 1])) [1, 2, 3, 4, 5] def in_order_traversal(root: TreeNode) -> List[int]: Helper function for in-order traversal of the BST to verify correctness. :param root: TreeNode, the root of the BST :return: List[int], a list of values obtained from in-order traversal if not root: return [] return in_order_traversal(root.left) + [root.val] + in_order_traversal(root.right)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bst_from_preorder(preorder): Reconstructs a binary search tree (BST) from the given preorder traversal array. :param preorder: List[int], the preorder traversal of the BST :return: TreeNode, the root of the reconstructed BST if not preorder: return None # Helper function to insert a new value in the BST def insert_into_bst(root, val): if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root # Initialize the root of the BST with the first value in preorder traversal root = TreeNode(preorder[0]) for value in preorder[1:]: insert_into_bst(root, value) return root"},{"question":"class Node: def __init__(self, val): self.val = val self.children = [] def diameter_of_n_ary_tree(root): Finds the diameter of an n-ary tree. :param root: Node, root of the n-ary tree :return: int, diameter of the tree pass # Unit Tests def test_empty_tree(): assert diameter_of_n_ary_tree(None) == 0 def test_single_node(): assert diameter_of_n_ary_tree(Node(1)) == 0 def test_linear_tree(): root = Node(1) node1 = Node(2) node2 = Node(3) node3 = Node(4) root.children = [node1] node1.children = [node2] node2.children = [node3] assert diameter_of_n_ary_tree(root) == 3 def test_balanced_tree(): root = Node(1) node1 = Node(2) node2 = Node(3) node3 = Node(4) node4 = Node(5) root.children = [node1, node2] node1.children = [node3, node4] assert diameter_of_n_ary_tree(root) == 3 def test_asymmetric_tree(): root = Node(1) node1 = Node(2) node2 = Node(3) node3 = Node(4) node4 = Node(5) node5 = Node(6) root.children = [node1, node2] node1.children = [node3] node3.children = [node4, node5] assert diameter_of_n_ary_tree(root) == 4","solution":"class Node: def __init__(self, val): self.val = val self.children = [] def diameter_of_n_ary_tree(root): Finds the diameter of an n-ary tree. :param root: Node, root of the n-ary tree :return: int, diameter of the tree def dfs(node): if not node: return 0, 0 # height, diameter max_height = 0 second_max_height = 0 max_diameter = 0 for child in node.children: child_height, child_diameter = dfs(child) if child_height > max_height: second_max_height = max_height max_height = child_height elif child_height > second_max_height: second_max_height = child_height max_diameter = max(max_diameter, child_diameter) current_diameter = max(max_diameter, max_height + second_max_height) return max_height + 1, current_diameter return dfs(root)[1]"},{"question":"def sorted_positions(heights): Given an array of heights, return an array representing the indices of the students after sorting them by their heights in non-decreasing order. Parameters: heights (List[int]): An array of integers representing the heights of students. Returns: List[int]: An array representing the indices of the students in the queue after sorting them by their heights. Example: >>> sorted_positions([5, 2, 9, 1]) [3, 1, 0, 2] >>> sorted_positions([1, 2, 3, 4]) [0, 1, 2, 3] >>> sorted_positions([4, 3, 2, 1]) [3, 2, 1, 0] >>> sorted_positions([4, 2, 4, 1]) [3, 1, 0, 2] >>> sorted_positions([]) [] >>> sorted_positions([1]) [0]","solution":"def sorted_positions(heights): Given an array of heights, return an array representing the indices of the students after sorting them by their heights in non-decreasing order. # Pair the heights with their original indices indexed_heights = list(enumerate(heights)) # Sort based on the heights sorted_indexed_heights = sorted(indexed_heights, key=lambda x: x[1]) # Extract the indices corresponding to the sorted order of heights sorted_positions = [index for index, height in sorted_indexed_heights] return sorted_positions"},{"question":"def max_product(n: int) -> int: Returns the maximum product of lengths of pieces you can achieve by cutting the rope of length n into pieces. >>> max_product(1) == 0 >>> max_product(2) == 1 >>> max_product(8) == 18 >>> max_product(10) == 36 >>> max_product(50) == 86093442 >>> max_product(0) == 0 >>> max_product(3) == 2 >>> max_product(4) == 4 >>> max_product(5) == 6","solution":"def max_product(n): Returns the maximum product of lengths of pieces you can achieve by cutting the rope of length n into pieces. if n <= 1: return 0 # Create a dp list where dp[i] represents the maximum product for rope length i. dp = [0] * (n + 1) dp[1] = 1 for i in range(2, n + 1): for j in range(1, i): dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j])) return dp[n]"},{"question":"def min_steps_with_obstacle_removal(matrix: List[List[int]], k: int) -> int: Return the minimum number of steps required to move from the top-left corner to the bottom-right corner while removing at most k obstacles. If it's not possible to reach the bottom-right corner, return -1. >>> min_steps_with_obstacle_removal([ [0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0] ], 1) == 6 >>> min_steps_with_obstacle_removal([ [0, 0, 0], [0, 0, 0], [0, 0, 0] ], 1) == 4 >>> min_steps_with_obstacle_removal([ [0, 1, 1], [1, 1, 0], [0, 0, 0] ], 2) == 4 >>> min_steps_with_obstacle_removal([ [0, 1, 1], [1, 1, 1], [0, 0, 1] ], 0) == -1 >>> min_steps_with_obstacle_removal([ [0, 1, 1], [1, 1, 0], [0, 0, 1] ], 1) == -1 >>> min_steps_with_obstacle_removal([[0] * 10 for _ in range(10)], 1) == 18","solution":"from collections import deque def min_steps_with_obstacle_removal(matrix, k): rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS Queue, each entry is (row, col, steps, remaining obstacle removals) queue = deque([(0, 0, 0, k)]) visited = set([(0, 0, k)]) while queue: r, c, steps, remaining_k = queue.popleft() if r == rows - 1 and c == cols - 1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: # Check bounds new_remaining_k = remaining_k - matrix[nr][nc] if new_remaining_k >= 0 and (nr, nc, new_remaining_k) not in visited: visited.add((nr, nc, new_remaining_k)) queue.append((nr, nc, steps + 1, new_remaining_k)) return -1 # If no path found"},{"question":"def min_operations_to_sort(nums: List[int]) -> int: You are given a list of non-negative integers 'nums' that are ordered by their lexicographic order as strings. You can perform a sequence of operations where in each operation, you can choose any element and increment it by 1. Return the minimum number of operations required to make 'nums' sorted in non-decreasing order. >>> min_operations_to_sort([1, 2, 3, 4, 5]) 0 >>> min_operations_to_sort([42]) 0 >>> min_operations_to_sort([5, 4, 3, 2, 1]) 10 >>> min_operations_to_sort([3, 1, 2, 5, 4]) 4 >>> min_operations_to_sort([1, 2, 2, 3, 3, 4, 5]) 0","solution":"def min_operations_to_sort(nums): Returns the minimum number of operations required to make nums sorted in non-decreasing order. :param nums: List of non-negative integers ordered lexicographically as strings. :return: int, the minimum number of increment operations needed. operations = 0 for i in range(1, len(nums)): if nums[i] < nums[i-1]: diff = nums[i-1] - nums[i] operations += diff nums[i] = nums[i-1] return operations"},{"question":"def countPeaks(heights: List[int]) -> int: Returns the number of peak buildings in the list of heights. A building is considered a \\"peak\\" if it is taller than both the buildings immediately adjacent to it. Parameters: heights (list of int): List of building heights. Returns: int: The number of peak buildings. pass # Unit tests def test_countPeaks_no_peaks(): assert countPeaks([1, 1, 1, 1]) == 0 assert countPeaks([1, 2]) == 0 assert countPeaks([1]) == 0 assert countPeaks([]) == 0 def test_countPeaks_one_peak(): assert countPeaks([1, 3, 2]) == 1 assert countPeaks([2, 3, 1]) == 1 assert countPeaks([3, 1, 2, 1]) == 1 def test_countPeaks_multiple_peaks(): assert countPeaks([1, 3, 2, 4, 1, 5]) == 2 assert countPeaks([1, 3, 2, 4, 3, 5, 2]) == 3 def test_countPeaks_adjacent_peaks(): assert countPeaks([1, 4, 2, 4, 1]) == 2 assert countPeaks([1, 5, 2, 5, 2, 6, 2]) == 3 def test_countPeaks_plateaus(): assert countPeaks([1, 3, 3, 1]) == 0 assert countPeaks([1, 3, 2, 2, 4, 4, 1, 5]) == 1","solution":"def countPeaks(heights): Returns the number of peak buildings in the list of heights. A building is considered a \\"peak\\" if it is taller than both the buildings immediately adjacent to it. Parameters: heights (list of int): List of building heights. Returns: int: The number of peak buildings. if len(heights) < 3: return 0 peak_count = 0 for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: peak_count += 1 return peak_count"},{"question":"def coin_change(coins, amount): Given a list of non-negative integers coins where coins[i] represents the number of coins of the i-th denomination and another integer amount, return the minimum number of coins that you need to make up that amount. If that amount cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each denomination of coin. >>> coin_change([1, 2, 5], 11) == 3 >>> coin_change([2], 3) == -1 >>> coin_change([1], 0) == 0 >>> coin_change([2, 5], 3) == -1 >>> coin_change([3, 5], 7) == -1 >>> coin_change([1, 2, 5], 100) == 20 >>> coin_change([1, 2, 5], 101) == 21 >>> coin_change([], 10) == -1 >>> coin_change([], 0) == 0","solution":"def coin_change(coins, amount): Returns the minimum number of coins needed to make up the given amount. If the amount cannot be made up by any combination of the coins, returns -1. # Initialize dp array with amount + 1 which signifies amount is not possible with given coins dp = [amount + 1] * (amount + 1) dp[0] = 0 # Loop through each amount up to the given amount for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def maxItems(nums, target): Returns the maximum number of items you can buy without exceeding the target amount. >>> maxItems([1, 2, 3, 4, 5], 10) 4 # 1 + 2 + 3 + 4 = 10 >>> maxItems([10, 20, 30], 100) 3 # 10 + 20 + 30 = 60 >>> maxItems([1, 2, 3], 0) 0 # No items can be bought >>> maxItems([10, 20, 30], 5) 0 # No items can be bought >>> maxItems([1, 2, 2, 3], 5) 3 # 1 + 2 + 2 = 5 >>> maxItems([5, 7, 10, 1, 2], 12) 3 # 1 + 2 + 5 = 8 or other combinations >>> maxItems([1, 2, 5, 7, 8, 10], 18) 4 # 1 + 2 + 5 + 7 = 15 >>> maxItems([4, 4, 4, 4], 8) 2 # 4 + 4 = 8 >>> maxItems([], 10) 0 # No items to buy >>> maxItems([2, 2, 2, 2], 8) 4 # 2 + 2 + 2 + 2 = 8","solution":"def maxItems(nums, target): Returns the maximum number of items whose sum does not exceed the target. # Sort nums in ascending order to consider cheaper items first nums.sort() total_sum = 0 count = 0 for price in nums: if total_sum + price <= target: total_sum += price count += 1 else: break return count"},{"question":"def max_rectangle_area(heights): Given an integer array \`heights\` representing the heights of buildings, find the maximum area of a rectangular plot that can be formed with any set of contiguous buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: The maximum rectangular area that can be formed. >>> max_rectangle_area([5]) 5 >>> max_rectangle_area([1, 5]) 5 >>> max_rectangle_area([5, 1]) 5 >>> max_rectangle_area([4, 4, 4, 4]) 16 >>> max_rectangle_area([2, 4, 2]) 6 >>> max_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> max_rectangle_area([2, 1, 5, 6, 2, 3, 1]) 10 >>> max_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def max_rectangle_area(heights): Given an integer array \`heights\` representing the heights of buildings, find the maximum area of a rectangular plot that can be formed with any set of contiguous buildings. Args: heights (list): List of integers representing the heights of buildings. Returns: int: The maximum rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def check_inclusion(s: str, p: str) -> bool: Check if there is a permutation of the pattern string \`p\` that is a substring of \`s\`. :param s: The input string s :param p: The pattern string p :return: True if a permutation of p is a substring of s, otherwise False >>> check_inclusion(\\"cbaebabacd\\", \\"abc\\") True >>> check_inclusion(\\"af\\", \\"be\\") False >>> check_inclusion(\\"anything\\", \\"\\") True >>> check_inclusion(\\"\\", \\"a\\") False >>> check_inclusion(\\"\\", \\"\\") True >>> check_inclusion(\\"short\\", \\"toolong\\") False >>> check_inclusion(\\"anagram\\", \\"nag\\") True >>> check_inclusion(\\"randomstringabc\\", \\"cab\\") True >>> check_inclusion(\\"a\\", \\"a\\") True >>> check_inclusion(\\"a\\", \\"b\\") False >>> check_inclusion(\\"oidbcaf\\", \\"abc\\") True","solution":"def check_inclusion(s, p): Check if there is a permutation of the pattern string \`p\` that is a substring of \`s\`. :param s: The input string s :param p: The pattern string p :return: True if a permutation of p is a substring of s, otherwise False from collections import Counter len_s, len_p = len(s), len(p) if len_p > len_s: return False p_count = Counter(p) window_count = Counter() for i in range(len_p): window_count[s[i]] += 1 if window_count == p_count: return True for i in range(len_p, len_s): window_count[s[i]] += 1 window_count[s[i - len_p]] -= 1 if window_count[s[i - len_p]] == 0: del window_count[s[i - len_p]] if window_count == p_count: return True return False"},{"question":"from typing import List def min_students_to_remove(heights: List[int]) -> int: Given an array of integers \`heights\` representing the heights of students standing in a line, return the minimum number of students that must be removed so that the remaining students are standing in non-decreasing order of height. >>> min_students_to_remove([4, 3, 2, 6, 1]) 3 >>> min_students_to_remove([1, 2, 3, 4, 5]) 0 >>> min_students_to_remove([5, 4, 3, 2, 1]) 4 >>> min_students_to_remove([]) 0 >>> min_students_to_remove([1]) 0 >>> min_students_to_remove([3, 1, 2, 5, 4]) 2 >>> min_students_to_remove([1, 3, 2, 6, 4, 5]) 2","solution":"def min_students_to_remove(heights): Returns the minimum number of students that must be removed to make the remaining students stand in non-decreasing order of height. if not heights: return 0 n = len(heights) dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) longest_increasing_subsequence = max(dp) return n - longest_increasing_subsequence"},{"question":"def min_incomplete_tasks(tasks: List[int], sessions: int, k: int) -> int: Returns the minimum number of tasks left incomplete after attempting to fit as many tasks as possible into the given sessions. Parameters: tasks (list of int): The array of tasks where tasks[i] is the time required for the (i+1)-th task. sessions (int): The number of sessions available. k (int): The maximum units of time each session can accommodate. Returns: int: The minimum number of tasks left incomplete. >>> min_incomplete_tasks([1, 2, 3, 4], 2, 5) 0 >>> min_incomplete_tasks([4, 4, 4, 4, 4], 3, 5) 2 >>> min_incomplete_tasks([1, 1, 1, 1, 1, 1], 3, 2) 0 >>> min_incomplete_tasks([10, 10, 10], 1, 30) 0 >>> min_incomplete_tasks([5], 1, 5) 0 >>> min_incomplete_tasks([6], 1, 5) 1 >>> min_incomplete_tasks([2, 2, 2], 0, 3) 3","solution":"def min_incomplete_tasks(tasks, sessions, k): Returns the minimum number of tasks left incomplete after attempting to fit as many tasks as possible into the given sessions. Parameters: tasks (list of int): The array of tasks where tasks[i] is the time required for the (i+1)-th task. sessions (int): The number of sessions available. k (int): The maximum units of time each session can accommodate. Returns: int: The minimum number of tasks left incomplete. tasks.sort(reverse=True) completed_tasks = 0 remaining_time = [k] * sessions for task in tasks: for i in range(sessions): if task <= remaining_time[i]: remaining_time[i] -= task completed_tasks += 1 break return len(tasks) - completed_tasks"},{"question":"def sunset_views(heights): Returns the indices of buildings that can see the sunset. >>> sunset_views([4, 2, 3, 1]) [0, 2, 3] >>> sunset_views([]) [] >>> sunset_views([3, 3, 3, 3]) [3] >>> sunset_views([1, 2, 3, 4]) [3] >>> sunset_views([4, 3, 2, 1]) [0, 1, 2, 3] >>> sunset_views([10]) [0] >>> sunset_views([1, 3]) [1] >>> sunset_views([3, 1]) [0, 1]","solution":"def sunset_views(heights): Returns the indices of buildings that can see the sunset. n = len(heights) result = [] max_height = 0 for i in range(n - 1, -1, -1): # Traverse from right to left. if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reversed result to return in order from left to right."},{"question":"from typing import List def maxSquareSubmatrix(mat: List[List[int]], k: int) -> int: Return the maximum size of a square submatrix in \`mat\` that contains at most \`k\` \`0\`s. A square submatrix is a submatrix that has the same number of rows and columns. >>> maxSquareSubmatrix([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 0) 3 >>> maxSquareSubmatrix([[1, 1, 1], [1, 0, 1], [1, 1, 1]], 1) 3 >>> maxSquareSubmatrix([[1, 1, 0], [1, 0, 1], [0, 1, 1]], 1) 2 >>> maxSquareSubmatrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]], 0) 0 >>> maxSquareSubmatrix([[1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0], [0, 1, 1, 1]], 2) 3","solution":"def maxSquareSubmatrix(mat, k): m, n = len(mat), len(mat[0]) def count_zeros(matrix, x1, y1, x2, y2): return sum(matrix[x][y] == 0 for x in range(x1, x2) for y in range(y1, y2)) def can_construct(size): for i in range(m - size + 1): for j in range(n - size + 1): if count_zeros(mat, i, j, i + size, j + size) <= k: return True return False lo, hi = 0, min(m, n) while lo < hi: mid = (hi - lo + 1) // 2 + lo if can_construct(mid): lo = mid else: hi = mid - 1 return lo"},{"question":"class UndirectedGraph: Implement a class \`UndirectedGraph\` that supports the following operations on an undirected graph with no more than \`100\` nodes: * \`void addEdge(int node1, int node2)\`: Adds an edge between \`node1\` and \`node2\`. * \`void removeEdge(int node1, int node2)\`: Removes the edge between \`node1\` and \`node2\` if it exists. * \`boolean hasEdge(int node1, int node2)\`: Returns \`true\` if there is an edge between \`node1\` and \`node2\`, otherwise returns \`false\`. * \`List<Integer> getNeighbors(int node)\`: Returns a list of all the nodes that are directly connected to \`node\`. * \`boolean isConnected(int node1, int node2)\`: Returns \`true\` if there is a path connecting \`node1\` and \`node2\`, otherwise returns \`false\`. Note: - \`addEdge\` and \`removeEdge\` should operate in constant or logarithmic time. - \`getNeighbors\` should return the neighbors of a node sorted in ascending order. - The graph does not allow parallel edges or self-loops. import pytest from solution import UndirectedGraph def test_addEdge(): graph = UndirectedGraph() graph.addEdge(1, 2) assert graph.hasEdge(1, 2) == True assert graph.hasEdge(2, 1) == True def test_removeEdge(): graph = UndirectedGraph() graph.addEdge(1, 2) graph.removeEdge(1, 2) assert graph.hasEdge(1, 2) == False assert graph.hasEdge(2, 1) == False def test_getNeighbors(): graph = UndirectedGraph() graph.addEdge(1, 2) graph.addEdge(1, 3) graph.addEdge(1, 4) assert graph.getNeighbors(1) == [2, 3, 4] def test_isConnected(): graph = UndirectedGraph() graph.addEdge(1, 2) graph.addEdge(2, 3) graph.addEdge(3, 4) assert graph.isConnected(1, 4) == True assert graph.isConnected(1, 5) == False def test_self_loop(): graph = UndirectedGraph() graph.addEdge(1, 1) assert graph.hasEdge(1, 1) == False assert graph.getNeighbors(1) == [] def test_disconnected_graph(): graph = UndirectedGraph() graph.addEdge(1, 2) graph.addEdge(3, 4) assert graph.isConnected(1, 3) == False def test_parallel_edges(): graph = UndirectedGraph() graph.addEdge(1, 2) graph.addEdge(1, 2) assert graph.getNeighbors(1) == [2]","solution":"class UndirectedGraph: def __init__(self): self.adjacency_list = {i: set() for i in range(100)} def addEdge(self, node1, node2): if node1 != node2: self.adjacency_list[node1].add(node2) self.adjacency_list[node2].add(node1) def removeEdge(self, node1, node2): self.adjacency_list[node1].discard(node2) self.adjacency_list[node2].discard(node1) def hasEdge(self, node1, node2): return node2 in self.adjacency_list[node1] def getNeighbors(self, node): return sorted(self.adjacency_list[node]) def isConnected(self, node1, node2): visited = set() return self._dfs(node1, node2, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.adjacency_list[current]: if neighbor not in visited: if self._dfs(neighbor, target, visited): return True return False"},{"question":"from collections import OrderedDict class LRUCache: Design and implement an LRUCache class. The class should support the following operations: get(int key) and put(int key, int value). - get(int key): Retrieve the value of the key if the key exists in the cache, otherwise return -1. - put(int key, int value): Update the value of the key if the key already exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. Implement the LRUCache class: >>> cache = LRUCache(2) >>> cache.put(1, 1) >>> cache.put(2, 2) >>> cache.get(1) # returns 1 1 >>> cache.put(3, 3) # evicts key 2 >>> cache.get(2) # returns -1 (not found) -1 >>> cache.put(4, 4) # evicts key 1 >>> cache.get(1) # returns -1 (not found) -1 >>> cache.get(3) # returns 3 3 >>> cache.get(4) # returns 4 4 def __init__(self, capacity: int): Initialize the LRUCache with a positive size capacity. pass def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. pass def test_lru_cache_initial_capacity(): cache = LRUCache(2) assert cache.capacity == 2 assert not cache.cache def test_get_non_existent_key(): cache = LRUCache(2) assert cache.get(1) == -1 def test_put_and_get_key(): cache = LRUCache(2) cache.put(1, 1) assert cache.get(1) == 1 def test_put_and_update_key(): cache = LRUCache(2) cache.put(1, 1) cache.put(1, 10) assert cache.get(1) == 10 def test_put_eviction(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # This should evict key 1 assert cache.get(1) == -1 assert cache.get(2) == 2 assert cache.get(3) == 3 def test_lru_order(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.get(1) cache.put(3, 3) # This should evict key 2 assert cache.get(2) == -1 assert cache.get(1) == 1 assert cache.get(3) == 3 def test_multiple_evictions(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) # Evict 1 cache.put(4, 4) # Evict 2 assert cache.get(1) == -1 assert cache.get(2) == -1 assert cache.get(3) == 3 assert cache.get(4) == 4","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initialize the LRUCache with a positive size capacity. self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: Return the value of the key if the key exists, otherwise return -1. if key in self.cache: self.cache.move_to_end(key) return self.cache[key] return -1 def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item. if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"def kthSmallest(matrix: List[List[int]], k: int) -> int: Given an \`n x n\` matrix where each of the rows and columns is sorted in ascending order, return the k-th smallest element in the matrix. :param matrix: 2D List of integers representing the matrix :param k: Integer representing the k-th position :return: k-th smallest integer in the matrix >>> kthSmallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kthSmallest([ ... [1, 2], ... [3, 4] ... ], 2) 2 pass def test_kthSmallest(): assert kthSmallest([ [1, 5, 9], [10, 11, 13], [12, 13, 15] ], 8) == 13 def test_kthSmallest_small_matrix(): assert kthSmallest([ [1, 2], [3, 4] ], 2) == 2 def test_kthSmallest_rank_last_element(): assert kthSmallest([ [1, 2], [3, 4] ], 4) == 4 def test_kthSmallest_duplicates(): assert kthSmallest([ [1, 2, 2], [3, 4, 4], [5, 6, 6] ], 5) == 4 def test_kthSmallest_single_element(): assert kthSmallest([ [10] ], 1) == 10","solution":"import heapq def kthSmallest(matrix, k): Function to find the k-th smallest element in a sorted n x n matrix. :param matrix: 2D List of integers representing the matrix :param k: Integer representing the k-th position :return: k-th smallest integer in the matrix # Initialize the min-heap n = len(matrix) min_heap = [] # Populate the heap with the first element of each row for r in range(min(n, k)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Extract-min k-1 times for _ in range(k - 1): element, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def min_insertions_to_palindrome(word: str) -> int: Returns the minimum number of insertions needed to make the word a palindrome. >>> min_insertions_to_palindrome(\\"race\\") 3 >>> min_insertions_to_palindrome(\\"level\\") 0 >>> min_insertions_to_palindrome(\\"madam\\") 0 >>> min_insertions_to_palindrome(\\"a\\") 0 >>> min_insertions_to_palindrome(\\"ab\\") 1 >>> min_insertions_to_palindrome(\\"abcde\\") 4 >>> min_insertions_to_palindrome(\\"abcba\\") 0 >>> min_insertions_to_palindrome(\\"abcb\\") 1","solution":"def min_insertions_to_palindrome(word): Returns the minimum number of insertions needed to make the word a palindrome. n = len(word) # Create a 2D array to store the minimum insertions needed for substrings dp = [[0] * n for _ in range(n)] # Fill the table for length in range(2, n + 1): # length of the substring for i in range(n - length + 1): # starting index of the substring j = i + length - 1 # ending index of the substring if word[i] == word[j]: dp[i][j] = dp[i + 1][j - 1] else: dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1]"},{"question":"from typing import List, Dict, Any def group_students_by_grade(students: List[Dict[str, Any]]) -> Dict[int, List[str]]: Groups students by their grades. :param students: List[Dict[str, Any]] - a list of dictionaries with 'name' and 'grade' keys :return: Dict[int, List[str]] - a dictionary with grades as keys and lists of student names as values >>> students = [ ... {\\"name\\": \\"Alice\\", \\"grade\\": 90}, ... {\\"name\\": \\"Bob\\", \\"grade\\": 85}, ... {\\"name\\": \\"Charlie\\", \\"grade\\": 90}, ... {\\"name\\": \\"David\\", \\"grade\\": 85}, ... {\\"name\\": \\"Eve\\", \\"grade\\": 92} ... ] >>> group_students_by_grade(students) {90: [\\"Alice\\", \\"Charlie\\"], 85: [\\"Bob\\", \\"David\\"], 92: [\\"Eve\\"]} # Your code here # Sample test cases if __name__ == \\"__main__\\": students = [ {\\"name\\": \\"Alice\\", \\"grade\\": 90}, {\\"name\\": \\"Bob\\", \\"grade\\": 85}, {\\"name\\": \\"Charlie\\", \\"grade\\": 90}, {\\"name\\": \\"David\\", \\"grade\\": 85}, {\\"name\\": \\"Eve\\", \\"grade\\": 92} ] expected_output = { 90: [\\"Alice\\", \\"Charlie\\"], 85: [\\"Bob\\", \\"David\\"], 92: [\\"Eve\\"] } assert group_students_by_grade(students) == expected_output students = [] expected_output = {} assert group_students_by_grade(students) == expected_output students = [{\\"name\\": \\"Alice\\", \\"grade\\": 90}] expected_output = {90: [\\"Alice\\"]} assert group_students_by_grade(students) == expected_output students = [ {\\"name\\": \\"Alice\\", \\"grade\\": 90}, {\\"name\\": \\"Bob\\", \\"grade\\": 90}, {\\"name\\": \\"Charlie\\", \\"grade\\": 90} ] expected_output = {90: [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]} assert group_students_by_grade(students) == expected_output students = [ {\\"name\\": \\"Charlie\\", \\"grade\\": 90}, {\\"name\\": \\"Alice\\", \\"grade\\": 90}, {\\"name\\": \\"Bob\\", \\"grade\\": 90} ] expected_output = {90: [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]} assert group_students_by_grade(students) == expected_output","solution":"from collections import defaultdict def group_students_by_grade(students): Groups students by their grades. :param students: List[Dict[str, Any]] - a list of dictionaries with 'name' and 'grade' keys :return: Dict[int, List[str]] - a dictionary with grades as keys and lists of student names as values grouped_students = defaultdict(list) for student in students: name = student['name'] grade = student['grade'] grouped_students[grade].append(name) # Sorting the student names for each grade for grade in grouped_students: grouped_students[grade].sort() return dict(grouped_students)"},{"question":"def can_attend_meetings(intervals: List[List[int]]) -> bool: Determines if a person can attend all meetings without any overlap. :param intervals: List of meeting intervals where each interval is [start, end]. :return: Boolean value, True if there are no overlapping meetings, False otherwise. >>> can_attend_meetings([[0, 30], [35, 40], [45, 50]]) == True >>> can_attend_meetings([[0, 30], [25, 35], [40, 50]]) == False >>> can_attend_meetings([]) == True >>> can_attend_meetings([[10, 20]]) == True >>> can_attend_meetings([[0, 30], [30, 40], [40, 50]]) == True >>> can_attend_meetings([[0, 30], [10, 20], [15, 25]]) == False","solution":"def can_attend_meetings(intervals): Determines if a person can attend all meetings without any overlap. :param intervals: List of meeting intervals where each interval is [start, end]. :return: Boolean value, True if there are no overlapping meetings, False otherwise. # Sort intervals based on the start time intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # Check if the current meeting starts before the previous one ends if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"def longest_substring_with_k_distinct_characters(s: str, k: int) -> str: Given a string \`str\` consisting of lowercase English letters and an integer \`k\`, find the longest substring of \`str\` that contains at most \`k\` distinct characters. If there are multiple substrings with the same maximum length, return the leftmost one. >>> longest_substring_with_k_distinct_characters(\\"araaci\\", 2) == \\"araa\\" >>> longest_substring_with_k_distinct_characters(\\"araaci\\", 1) == \\"aa\\" >>> longest_substring_with_k_distinct_characters(\\"cbbebi\\", 3) == (\\"cbbeb\\" or \\"bbebi\\") >>> longest_substring_with_k_distinct_characters(\\"\\", 2) == \\"\\" >>> longest_substring_with_k_distinct_characters(\\"abc\\", 0) == \\"\\" >>> longest_substring_with_k_distinct_characters(\\"aa\\", 1) == \\"aa\\" >>> longest_substring_with_k_distinct_characters(\\"aabbcc\\", 2) == (\\"aabb\\" or \\"bbcc\\") >>> longest_substring_with_k_distinct_characters(\\"aaaaaaa\\", 1) == \\"aaaaaaa\\" >>> longest_substring_with_k_distinct_characters(\\"abcdefg\\", 10) == \\"abcdefg\\"","solution":"def longest_substring_with_k_distinct_characters(s, k): Returns the longest substring with at most k distinct characters. Parameters: s (str): The input string. k (int): The number of maximum distinct characters. Returns: str: The longest substring with at most k distinct characters. if k == 0 or not s: return \\"\\" # Initialize window pointers and a dictionary to count character frequency left = 0 right = 0 char_count = {} max_length = 0 max_length_start = 0 while right < len(s): # Add the character at the right pointer to the window current_char = s[right] if current_char in char_count: char_count[current_char] += 1 else: char_count[current_char] = 1 # If more than k distinct characters, contract the window from the left while len(char_count) > k: left_char = s[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 # Adjust maximum length and start index of the result current_length = right - left + 1 if current_length > max_length: max_length = current_length max_length_start = left # Expand the window to the right right += 1 return s[max_length_start:max_length_start + max_length]"},{"question":"def can_split_array(arr: List[int]) -> bool: Determines if the array can be split into two subarrays with equal sum. :param arr: List[int] - list of integers :return: bool - True if array can be split as required, otherwise False >>> can_split_array([1, 2, 3, 4, 5, 5]) == True >>> can_split_array([1, 1, 1, 1, 1]) == False >>> can_split_array([1]) == False >>> can_split_array([3, 3]) == True >>> can_split_array([1, 2]) == False >>> can_split_array([0, 0, 0, 0]) == True >>> can_split_array([-1, 1, -3, 2, -2, 3]) == True >>> can_split_array([1, 1, 1, 1, 1, 1, 1, 1, 4, 4]) == True","solution":"def can_split_array(arr): Determines if the array can be split into two subarrays with equal sum. :param arr: List[int] - list of integers :return: bool - True if array can be split as required, otherwise False total_sum = sum(arr) # If the total sum is odd, it cannot be split into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 current_sum = 0 # Iterate through the array and track the running sum for num in arr: current_sum += num # If the running sum equals the target sum, the array can be split if current_sum == target_sum: return True return False"},{"question":"def min_transformations_to_same_string(words: List[str]) -> int: Given a list of strings \`words\`, determine the minimum number of transformations needed to convert all strings to the same string. A transformation involves changing a single character in any string to any other character. Return the minimum number of transformations. Note: If it's impossible to convert all strings to the same string, return -1. >>> min_transformations_to_same_string([\\"cat\\", \\"bat\\", \\"rat\\"]) 2 >>> min_transformations_to_same_string([\\"aaa\\", \\"aab\\", \\"aba\\"]) 2 >>> min_transformations_to_same_string([\\"cat\\"]) 0 >>> min_transformations_to_same_string([]) -1 >>> min_transformations_to_same_string([\\"cat\\", \\"cats\\", \\"bat\\"]) -1 >>> min_transformations_to_same_string([\\"same\\", \\"same\\", \\"same\\"]) 0 >>> min_transformations_to_same_string([\\"ab\\", \\"bb\\", \\"cb\\"]) 2","solution":"def min_transformations_to_same_string(words): from collections import Counter if not words: return -1 n = len(words) word_length = len(words[0]) # Check if all words have the same length for word in words: if len(word) != word_length: return -1 # Min transformations needed to convert each character in position i transformations = [0] * word_length for i in range(word_length): char_count = Counter(word[i] for word in words) max_occurrences = max(char_count.values()) # Min transformations needed = Total words - Max occurrences of the most common character in position i transformations[i] = n - max_occurrences return sum(transformations)"},{"question":"def longest_well_formed_subsequence(s: str, k: int) -> int: Given a string \`s\` consisting of brackets \`(\` and \`)\`, and an integer \`k\`, you can remove \`k\` characters from the string. Return the length of the longest subsequence of \`s\` that is a well-formed bracket sequence. >>> longest_well_formed_subsequence(\\"(()())\\", 0) == 6 >>> longest_well_formed_subsequence(\\"(()))(\\", 1) == 4 >>> longest_well_formed_subsequence(\\")(\\", 1) == 0 >>> longest_well_formed_subsequence(\\"(((()\\", 2) == 2 >>> longest_well_formed_subsequence(\\")((()()\\", 2) == 4 >>> longest_well_formed_subsequence(\\"((((\\", 3) == 0","solution":"def longest_well_formed_subsequence(s, k): Returns the length of the longest subsequence of \`s\` that is well-formed after removing at most \`k\` characters. # Initialize balance variables open_brackets = 0 close_brackets = 0 removable = k # Count unmatched brackets for char in s: if char == '(': open_brackets += 1 elif char == ')': if open_brackets > 0: open_brackets -= 1 else: close_brackets += 1 # Total unmatched characters to possibly remove unmatched_brackets = open_brackets + close_brackets # If we can remove all unmatched brackets if unmatched_brackets <= k: return len(s) - unmatched_brackets # Otherwise, we need to balance remaining removals max_pairs_can_form = (len(s) - unmatched_brackets) // 2 return max_pairs_can_form * 2"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_nodes_sum(root): Returns the sum of values of nodes at the maximum depth in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4), TreeNode(5)) >>> root.right = TreeNode(3, TreeNode(6), TreeNode(7)) >>> find_deepest_nodes_sum(root) 22 >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(3)) >>> find_deepest_nodes_sum(root) 3 >>> root = TreeNode(1, TreeNode(2, right=TreeNode(4)), TreeNode(3, right=TreeNode(5))) >>> find_deepest_nodes_sum(root) 9 >>> find_deepest_nodes_sum(None) 0","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def find_deepest_nodes_sum(root): Returns the sum of values of nodes at the maximum depth in the binary tree. if not root: return 0 from collections import deque max_depth = -1 current_depth = 0 queue = deque([(root, 0)]) level_map = {} while queue: node, depth = queue.popleft() if depth not in level_map: level_map[depth] = [] level_map[depth].append(node.value) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) max_depth = max(max_depth, depth) return sum(level_map[max_depth])"},{"question":"def flatten_directory(directory, parent_path=\\"\\"): Returns a flattened list of folder paths given a directory represented as a nested dictionary. Args: directory (dict): A dictionary representing the directory structure. parent_path (str): The parent path in the directory hierarchy. Returns: list: A flattened list of folder paths. Examples: >>> flatten_directory({\\"root\\": {}}) [\\"root\\"] >>> flatten_directory({\\"root\\": {\\"subdir1\\": {}}}) [\\"root/subdir1\\"] >>> flatten_directory({\\"root\\": {\\"subdir1\\": {\\"subsubdir1\\": {}}, \\"subdir2\\": {}}}) [\\"root/subdir1/subsubdir1\\", \\"root/subdir2\\"] >>> flatten_directory({\\"root\\": {\\"subdir1\\": {\\"subsubdir1\\": {}, \\"subsubdir2\\": {}}, \\"subdir2\\": {\\"subsubdir3\\": {}}}}) [\\"root/subdir1/subsubdir1\\", \\"root/subdir1/subsubdir2\\", \\"root/subdir2/subsubdir3\\"] >>> flatten_directory({}) [] >>> flatten_directory({\\"A\\": {\\"B\\": {}, \\"C\\": {}}}) [\\"A/B\\", \\"A/C\\"]","solution":"def flatten_directory(directory, parent_path=\\"\\"): Returns a flattened list of folder paths. paths = [] for folder, subfolders in directory.items(): current_path = parent_path + \\"/\\" + folder if parent_path else folder if subfolders: paths.extend(flatten_directory(subfolders, current_path)) else: paths.append(current_path) return paths # Example usage: directory = { \\"root\\": { \\"subdir1\\": { \\"subsubdir1\\": {} }, \\"subdir2\\": {} } } print(flatten_directory(directory)) # Output: [\\"root/subdir1/subsubdir1\\", \\"root/subdir2\\"]"},{"question":"def largest_even_frequency_substring(s: str) -> str: Given a string \`s\` containing only lowercase letters, determine the largest substring where every character appears an even number of times. If there are multiple substrings with maximum length, return any one of them. >>> largest_even_frequency_substring(\\"a\\") == \\"\\" >>> largest_even_frequency_substring(\\"ab\\") == \\"\\" >>> largest_even_frequency_substring(\\"aabb\\") == \\"aabb\\" >>> largest_even_frequency_substring(\\"aabbcc\\") in [\\"aabb\\", \\"bbcc\\", \\"aabbcc\\"] >>> largest_even_frequency_substring(\\"abccbaabccba\\") == \\"abccbaabccba\\" >>> largest_even_frequency_substring(\\"abccbaabccba\\") == \\"abccbaabccba\\" >>> largest_even_frequency_substring(\\"abc\\") == \\"\\"","solution":"def largest_even_frequency_substring(s): from collections import defaultdict def get_frequency(s): freq = defaultdict(int) for char in s: freq[char] += 1 return freq def all_even(freq): for count in freq.values(): if count % 2 != 0: return False return True max_len = 0 max_sub = \\"\\" for i in range(len(s)): for j in range(i, len(s)): sub_str = s[i:j + 1] freq = get_frequency(sub_str) if all_even(freq): if len(sub_str) > max_len: max_len = len(sub_str) max_sub = sub_str return max_sub"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head: ListNode) -> ListNode: Reorder the linked list so that all nodes with odd indices are grouped together followed by nodes with even indices. The algorithm should run in O(n) time and use O(1) space. >>> head = list_to_linkedlist([1, 2, 3, 4, 5]) >>> result = oddEvenList(head) >>> linkedlist_to_list(result) [1, 3, 5, 2, 4] >>> head = list_to_linkedlist([2, 1, 3, 5, 6, 4, 7]) >>> result = oddEvenList(head) >>> linkedlist_to_list(result) [2, 3, 6, 7, 1, 5, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def oddEvenList(head): if not head: return head # Initialize pointers for odd and even odd = head even = head.next even_head = even # Save the start of the even list while even and even.next: odd.next = odd.next.next even.next = even.next.next odd = odd.next even = even.next # Link the end of odd list to the head of even list odd.next = even_head return head"},{"question":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to be added to make the string valid. >>> minAddToMakeValid(\\"()\\") 0 >>> minAddToMakeValid(\\"(())\\") 0 >>> minAddToMakeValid(\\"))\\") 2 >>> minAddToMakeValid(\\")))\\") 3 >>> minAddToMakeValid(\\"((\\") 2 >>> minAddToMakeValid(\\"(((\\") 3 >>> minAddToMakeValid(\\"())\\") 1 >>> minAddToMakeValid(\\"()())()\\") 1 >>> minAddToMakeValid(\\"(()(())\\") 1 >>> minAddToMakeValid(\\"\\") 0 # Your implementation here","solution":"def minAddToMakeValid(s: str) -> int: Returns the minimum number of parentheses to be added to make the string s valid. balance = 0 # Keeps track of balance of parentheses add_needed = 0 # Counts the minimum additions needed for char in s: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: add_needed += 1 balance = 0 return add_needed + balance"},{"question":"def is_medium(grid: List[List[int]]) -> bool: Determine if the binary matrix is medium. A binary matrix is medium if each zero in the matrix has at least one adjacent one. >>> is_medium([[1, 1], [1, 1]]) == True >>> is_medium([[1, 0], [1, 1]]) == True >>> is_medium([[0, 0], [0, 0]]) == False >>> is_medium([[1, 0, 1], [1, 1, 1], [0, 1, 0]]) == True >>> is_medium([[1, 0, 1], [0, 0, 0], [1, 0, 1]]) == False >>> is_medium([[0]]) == False >>> is_medium([[1]]) == True","solution":"def is_medium(grid): Determine if the binary matrix is medium. A binary matrix is medium if each zero in the matrix has at least one adjacent one. :param grid: List[List[int]], the m x n binary matrix :return: boolean, True if the matrix is medium, otherwise False rows = len(grid) cols = len(grid[0]) def has_adjacent_one(r, c): if r > 0 and grid[r-1][c] == 1: return True if r < rows - 1 and grid[r+1][c] == 1: return True if c > 0 and grid[r][c-1] == 1: return True if c < cols - 1 and grid[r][c+1] == 1: return True return False for r in range(rows): for c in range(cols): if grid[r][c] == 0: if not has_adjacent_one(r, c): return False return True"},{"question":"class MyHashMap: Design a class called MyHashMap without using any built-in hash table libraries. Implements the following methods: * \`MyHashMap()\` Initializes the \`MyHashMap\` object. * \`void put(int key, int value)\` Inserts a \`(key, value)\` pair into the HashMap. * \`int get(int key)\` Returns the \`value\` to which the specified \`key\` is mapped, or -1 if this map contains no mapping for the \`key\`. * \`void remove(int key)\` Removes the \`key\` and its corresponding \`value\` if the map contains the specified key. def __init__(self): Initialize your data structure here. def put(self, key: int, value: int) -> None: Value will always be non-negative. def get(self, key: int) -> int: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key def remove(self, key: int) -> None: Removes the mapping of the specified value key if this map contains a mapping for the key","solution":"class MyHashMap: def __init__(self): Initialize your data structure here. self.size = 1000 self.map = [[] for _ in range(self.size)] def _hash(self, key: int) -> int: Generate a hash for a given key return key % self.size def put(self, key: int, value: int) -> None: Value will always be non-negative. h = self._hash(key) for i, (k, v) in enumerate(self.map[h]): if k == key: self.map[h][i] = (key, value) return self.map[h].append((key, value)) def get(self, key: int) -> int: Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key h = self._hash(key) for (k, v) in self.map[h]: if k == key: return v return -1 def remove(self, key: int) -> None: Removes the mapping of the specified value key if this map contains a mapping for the key h = self._hash(key) for i, (k, v) in enumerate(self.map[h]): if k == key: del self.map[h][i] return"},{"question":"class ParenthesesValidator: def __init__(self): pass def minAddToMakeValid(self, s: str) -> int: Returns the minimum number of parentheses needed to make the string s a valid parentheses sequence. >>> ParenthesesValidator().minAddToMakeValid(\\"())\\") 1 >>> ParenthesesValidator().minAddToMakeValid(\\"(((\\") 3 # Unit Tests def test_valid_parentheses_sequence(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"()\\") == 0 assert validator.minAddToMakeValid(\\"(())\\") == 0 def test_invalid_parentheses_extra_closing(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"())\\") == 1 def test_invalid_parentheses_all_opening(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"(((\\") == 3 def test_mixed_parentheses(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"(()())(\\") == 1 def test_empty_string(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"\\") == 0 def test_unbalanced_right(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\"))))((\\") == 6 def test_different_unbalanced(): validator = ParenthesesValidator() assert validator.minAddToMakeValid(\\")))(((\\") == 6","solution":"class ParenthesesValidator: def __init__(self): pass def minAddToMakeValid(self, s: str) -> int: # Initialize counters for unbalanced opening and closing parentheses open_count = 0 close_count = 0 # Traverse the string for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 # The total corrections needed is the sum of unbalanced '(' and ')' return open_count + close_count"},{"question":"from typing import List def max_profit(arr: List[int]) -> int: Returns the maximum profit that can be achieved from one transaction of buying and selling stock. If no profit can be achieved, returns 0. >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([5]) == 0 >>> max_profit([]) == 0 >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 2, 6, 1, 3, 4]) == 4 >>> max_profit([2, 1, 4]) == 3 >>> max_profit([1, 2]) == 1 >>> max_profit([5, 3, 6, 8, 5, 9]) == 6","solution":"def max_profit(arr): Returns the maximum profit that can be achieved from one transaction of buying and selling stock. If no profit can be achieved, returns 0. if not arr: return 0 min_price = float('inf') max_profit = 0 for price in arr: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def maximize_min_value(arr: List[int], k: int) -> int: You are given an integer array \`arr\` and an integer \`k\`, representing the maximum number of operations you can perform. In one operation, you can choose any element of the array and increment or decrement it by 1. You need to maximize the minimum value in the array after performing at most \`k\` operations. Write a function that returns this maximum possible minimum value. >>> maximize_min_value([1, 2, 3], 3) 3 >>> maximize_min_value([0, 0, 0], 6) 2 >>> maximize_min_value([1, 3, 6], 5) 4 >>> maximize_min_value([5, 5, 5], 0) 5 >>> maximize_min_value([1, 1, 1, 1], 2) 1","solution":"def maximize_min_value(arr, k): Returns the maximum possible minimum value after at most k operations where each operation increments or decrements an element in the array by 1. def canAchieve(minVal): Helper function to determine if we can achieve a minimum value of minVal with at most k operations. total_operations = 0 for val in arr: if val < minVal: total_operations += (minVal - val) return total_operations <= k low, high = min(arr), max(arr) + k best_min_val = low while low <= high: mid = (low + high) // 2 if canAchieve(mid): best_min_val = mid low = mid + 1 else: high = mid - 1 return best_min_val"},{"question":"def min_operations_to_make_uniform(s: str) -> int: Returns the minimum number of operations required to make all the symbols in the string the same. >>> min_operations_to_make_uniform(\\"++++\\") == 0 >>> min_operations_to_make_uniform(\\"----\\") == 0 >>> min_operations_to_make_uniform(\\"+-+-\\") == 2 >>> min_operations_to_make_uniform(\\"-+-+\\") == 2 >>> min_operations_to_make_uniform(\\"--++\\") == 2 >>> min_operations_to_make_uniform(\\"+++-\\") == 1 >>> min_operations_to_make_uniform(\\"--+-\\") == 1 >>> min_operations_to_make_uniform(\\"\\") == 0 >>> min_operations_to_make_uniform(\\"+\\") == 0 >>> min_operations_to_make_uniform(\\"-\\") == 0 >>> min_operations_to_make_uniform(\\"++++--\\") == 2 >>> min_operations_to_make_uniform(\\"+++---\\") == 3 >>> min_operations_to_make_uniform(\\"++----\\") == 2","solution":"def min_operations_to_make_uniform(s): Returns the minimum number of operations required to make all the symbols in the string the same. count_plus = s.count('+') count_minus = s.count('-') return min(count_plus, count_minus)"},{"question":"def find_buildings_with_scenic_view(heights): Returns the list of indices of buildings that have a scenic view. >>> find_buildings_with_scenic_view([1, 2, 3, 4, 5]) == [4] >>> find_buildings_with_scenic_view([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> find_buildings_with_scenic_view([4, 2, 3, 1]) == [0, 2, 3] >>> find_buildings_with_scenic_view([10]) == [0] >>> find_buildings_with_scenic_view([3, 3, 3, 3, 3]) == [4] >>> find_buildings_with_scenic_view([]) == []","solution":"def find_buildings_with_scenic_view(heights): Returns the list of indices of buildings that have a scenic view. n = len(heights) result = [] max_height = float('-inf') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1] # reverse to get the indices in left to right order"},{"question":"def longest_substring_k_distinct(text: str, k: int) -> int: Given a string \`text\` consisting of lowercase letters and an integer \`k\`, return the length of the longest substring of \`text\` that contains at most \`k\` distinct characters. The algorithm should run in O(n) time complexity, where \`n\` is the length of the \`text\`. >>> longest_substring_k_distinct(\\"\\", 0) 0 >>> longest_substring_k_distinct(\\"abc\\", 0) 0 >>> longest_substring_k_distinct(\\"a\\", 1) 1 >>> longest_substring_k_distinct(\\"aaaa\\", 1) 4 >>> longest_substring_k_distinct(\\"abcd\\", 1) 1 >>> longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> longest_substring_k_distinct(\\"aaabbcc\\", 2) 5 >>> longest_substring_k_distinct(\\"abc\\", 4) 3","solution":"def longest_substring_k_distinct(text, k): Returns the length of the longest substring with at most k distinct characters. n = len(text) if k == 0 or n == 0: return 0 left = 0 right = 0 max_len = 0 char_count = {} while right < n: char = text[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) > k: left_char = text[left] char_count[left_char] -= 1 if char_count[left_char] == 0: del char_count[left_char] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t using swaps of any two characters or reversing any substring. If it's not possible, returns -1. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") == 0 >>> min_operations_to_transform(\\"abc\\", \\"cba\\") == 1 >>> min_operations_to_transform(\\"abc\\", \\"abd\\") == -1 >>> min_operations_to_transform(\\"a\\"*1000, \\"a\\"*1000) == 0 >>> min_operations_to_transform(\\"a\\"*500 + \\"b\\"*500, \\"b\\"*500 + \\"a\\"*500) == 1","solution":"def min_operations_to_transform(s, t): Returns the minimum number of operations required to transform string s into string t using swaps of any two characters or reversing any substring. If it's not possible, returns -1. # Check if both strings have same characters with the same frequency if sorted(s) != sorted(t): return -1 # If strings are already equal if s == t: return 0 return 1"},{"question":"def multiply_strings(num1: str, num2: str) -> str: Multiplies two non-negative integers represented as strings and returns the product as a string. >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\" >>> multiply_strings(\\"2\\", \\"3\\") \\"6\\" >>> multiply_strings(\\"0\\", \\"123\\") \\"0\\" >>> multiply_strings(\\"123\\", \\"0\\") \\"0\\" >>> multiply_strings(\\"0\\", \\"0\\") \\"0\\" >>> multiply_strings(\\"123456789\\", \\"987654321\\") \\"121932631112635269\\" >>> multiply_strings(\\"9999\\", \\"9999\\") \\"99980001\\" >>> multiply_strings(\\"1\\", \\"23456\\") \\"23456\\" >>> multiply_strings(\\"12345\\", \\"1\\") \\"12345\\" >>> multiply_strings(\\"1111\\", \\"1111\\") \\"1234321\\" >>> multiply_strings(\\"22\\", \\"22\\") \\"484\\"","solution":"def multiply_strings(num1, num2): Multiplies two non-negative integers represented as strings and returns the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) product = [0] * (len1 + len2) num1, num2 = num1[::-1], num2[::-1] for i in range(len1): for j in range(len2): product[i + j] += int(num1[i]) * int(num2[j]) product[i + j + 1] += product[i + j] // 10 product[i + j] %= 10 while len(product) > 1 and product[-1] == 0: product.pop() return ''.join(map(str, product[::-1]))"},{"question":"def count_matching_substrings(s: str, pattern: str) -> int: Return the number of substrings in 's' that match the frequency of characters in 'pattern'. >>> count_matching_substrings(\\"cbaebabacd\\", \\"abc\\") 2 >>> count_matching_substrings(\\"abab\\", \\"ab\\") 3 >>> count_matching_substrings(\\"abcdef\\", \\"xyz\\") 0 >>> count_matching_substrings(\\"aaaaa\\", \\"a\\") 5 >>> count_matching_substrings(\\"abcd\\", \\"abcd\\") 1 >>> count_matching_substrings(\\"abcabcabc\\", \\"abc\\") 7 >>> count_matching_substrings(\\"abc\\", \\"abcd\\") 0 from collections import Counter def test_count_matching_substrings_example1(): assert count_matching_substrings(\\"cbaebabacd\\", \\"abc\\") == 2 def test_count_matching_substrings_example2(): assert count_matching_substrings(\\"abab\\", \\"ab\\") == 3 def test_count_matching_substrings_no_match(): assert count_matching_substrings(\\"abcdef\\", \\"xyz\\") == 0 def test_count_matching_substrings_single_character(): assert count_matching_substrings(\\"aaaaa\\", \\"a\\") == 5 def test_count_matching_substrings_entire_string(): assert count_matching_substrings(\\"abcd\\", \\"abcd\\") == 1 def test_count_matching_substrings_overlap(): assert count_matching_substrings(\\"abcabcabc\\", \\"abc\\") == 7 def test_count_matching_substrings_pattern_larger_than_s(): assert count_matching_substrings(\\"abc\\", \\"abcd\\") == 0","solution":"def count_matching_substrings(s, pattern): from collections import Counter len_s = len(s) len_pattern = len(pattern) pattern_counter = Counter(pattern) if len_s < len_pattern: return 0 current_counter = Counter(s[:len_pattern]) matching_count = 0 if current_counter == pattern_counter: matching_count += 1 for i in range(len_pattern, len_s): current_counter[s[i - len_pattern]] -= 1 if current_counter[s[i - len_pattern]] == 0: del current_counter[s[i - len_pattern]] current_counter[s[i]] += 1 if current_counter == pattern_counter: matching_count += 1 return matching_count"},{"question":"def min_window_substring_length(pattern: str, source: str) -> int: Finds the length of the smallest substring in \`source\` that contains all the characters in \`pattern\`. :param pattern: String with distinct lowercase English letters :param source: String with lowercase English letters :return: Length of the smallest substring containing all characters in \`pattern\`, else 0 pass","solution":"from collections import defaultdict def min_window_substring_length(pattern, source): Finds the length of the smallest substring in \`source\` that contains all the characters in \`pattern\`. :param pattern: String with distinct lowercase English letters :param source: String with lowercase English letters :return: Length of the smallest substring containing all characters in \`pattern\`, else 0 if not pattern or not source or len(pattern) > len(source): return 0 dict_pattern = defaultdict(int) for char in pattern: dict_pattern[char] += 1 required = len(dict_pattern) left, right = 0, 0 formed = 0 window_counts = defaultdict(int) min_length = float('inf') ans = (0, 0) while right < len(source): char = source[right] window_counts[char] += 1 if char in dict_pattern and window_counts[char] == dict_pattern[char]: formed += 1 while left <= right and formed == required: char = source[left] if right - left + 1 < min_length: min_length = right - left + 1 ans = (left, right) window_counts[char] -= 1 if char in dict_pattern and window_counts[char] < dict_pattern[char]: formed -= 1 left += 1 right += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Find the minimum path sum in a grid. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6] ... ]) == 12 >>> min_path_sum([ ... [1] ... ]) == 1 >>> min_path_sum([ ... [1, 2, 2] ... ]) == 5 >>> min_path_sum([ ... [1], ... [2], ... [2] ... ]) == 5","solution":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Initialize dp array dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def min_operations_to_palindrome(s: str) -> int: Returns the minimum number of operations required to make the string s a palindrome. Parameters: s (str): The input string consisting of characters 'a' and 'b'. Returns: int: The minimum number of operations to make s a palindrome. >>> min_operations_to_palindrome('a') 0 >>> min_operations_to_palindrome('ab') 1 >>> min_operations_to_palindrome('abcd') 2","solution":"def min_operations_to_palindrome(s): Returns the minimum number of operations required to make the string s a palindrome. Parameters: s (str): The input string consisting of characters 'a' and 'b'. Returns: int: The minimum number of operations to make s a palindrome. # Calculate the length of the string n = len(s) # Initialize the number of operations to 0 operations = 0 # Iterate over the first half of the string for i in range(n // 2): # Compare the character and its corresponding character from the end if s[i] != s[n - 1 - i]: operations += 1 return operations"},{"question":"from typing import List def shortestPath(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner in a given 2D grid where we can only move in cells with '1' and move up, down, left, or right. If no such path exists, returns '-1'. >>> shortestPath([[1, 0, 0], [1, 1, 0], [0, 1, 1]]) 5 >>> shortestPath([[1]]) 1 >>> shortestPath([[0]]) -1 >>> shortestPath([[1, 0, 0], [0, 0, 0], [0, 1, 1]]) -1 >>> shortestPath([[1, 1, 0, 1], [0, 1, 1, 1], [0, 0, 1, 0], [1, 1, 1, 1]]) 7","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner in a given 2D grid where we can only move in cells with '1' and move up, down, left, or right. If no such path exists, returns '-1'. if not grid or grid[0][0] != 1 or grid[-1][-1] != 1: return -1 m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if x == m - 1 and y == n - 1: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 1: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the right side view of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> rightSideView(root) == [1, 3, 4] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(4) >>> rightSideView(root) == [1, 2, 4] >>> rightSideView(None) == []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the right side view of the binary tree. if root is None: return [] from collections import deque queue = deque([(root, 0)]) # (node, level) right_view = {} while queue: node, level = queue.popleft() # Update the most right node at each level right_view[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) # Extract the values in order of levels return [right_view[level] for level in range(len(right_view))]"},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum cost path sum to reach the bottom-right corner of the given grid. :param grid: List of lists, where each sublist represents a row in the grid and each element a cell's cost :return: Integer, minimum cost path sum >>> min_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21 >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([[1, 2, 3, 4]]) == 10 >>> min_path_sum([[1], [2], [3], [4]]) == 10 >>> min_path_sum([[5]]) == 5 >>> min_path_sum([]) == 0 >>> min_path_sum([[1]]) == 1","solution":"def min_path_sum(grid): Returns the minimum cost path sum to reach the bottom-right corner of the given grid. :param grid: List of lists, where each sublist represents a row in the grid and each element a cell's cost :return: Integer, minimum cost path sum if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a new grid to store the minimal cost path sums dp = [[0] * n for _ in range(m)] # Fill the dp grid, starting from the top-left corner dp[0][0] = grid[0][0] # Fill in the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Populate the rest of the dp grid for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[-1][-1]"},{"question":"def buildings_with_clear_view(heights: List[int]) -> List[int]: Returns indices of buildings that have a clear view to the right. >>> buildings_with_clear_view([3, 7, 8, 3, 6, 1]) == [2, 4, 5] >>> buildings_with_clear_view([5]) == [0] >>> buildings_with_clear_view([1, 2, 3, 4, 5]) == [4] >>> buildings_with_clear_view([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> buildings_with_clear_view([5, 5, 5, 5, 5]) == [4] >>> buildings_with_clear_view([1, 3, 2, 4, 2]) == [3, 4] >>> buildings_with_clear_view([]) == []","solution":"def buildings_with_clear_view(heights): Returns indices of buildings that have a clear view to the right. n = len(heights) clear_view_indices = [] max_height_to_right = -1 for i in range(n - 1, -1, -1): if heights[i] > max_height_to_right: clear_view_indices.append(i) max_height_to_right = heights[i] return clear_view_indices[::-1]"},{"question":"def final_element(nums: List[int]) -> int: Perform operations on the list \`nums\` until only one element remains. Each operation involves selecting any two elements, removing them, and adding their sum back to the array. >>> final_element([1, 2, 3, 4]) == 10 >>> final_element([5]) == 5 >>> final_element([5, 9]) == 14 >>> final_element([1000, 2000, 3000, 4000]) == 10000 >>> final_element([1, 1, 1, 1, 1, 1, 1, 1]) == 8 >>> final_element([6, 5, 4, 3, 2, 1]) == 21 >>> final_element([1, 2, 3, 4, 5, 6]) == 21","solution":"def final_element(nums): Perform operations on the list \`nums\` until only one element remains. Each operation involves selecting any two elements, removing them, and adding their sum back to the array. while len(nums) > 1: # Sort the array nums.sort() # Remove the two smallest elements a = nums.pop(0) b = nums.pop(0) # Add their sum back to the array nums.append(a + b) return nums[0]"},{"question":"from typing import List def max_points_on_line(points: List[List[int]]) -> int: Determine the maximum number of points that can all lie on the same straight line. >>> max_points_on_line([[1, 1], [2, 2], [3, 3]]) 3 >>> max_points_on_line([[1, 1], [3, 2], [5, 3], [4, 1], [2, 3], [1, 4]]) 4 >>> max_points_on_line([[1, 1], [2, 2]]) 2 >>> max_points_on_line([[1, 1], [1, 2], [1, 3], [2, 2]]) 3 >>> max_points_on_line([[1, 1], [1, 1], [1, 1]]) 3 >>> max_points_on_line([[i, i] for i in range(100)]) 100 >>> max_points_on_line([]) 0","solution":"def max_points_on_line(points): from collections import defaultdict from fractions import Fraction def gcd(a, b): while b: a, b = b, a % b return a def slope(p1, p2): dx = p2[0] - p1[0] dy = p2[1] - p1[1] if dx == 0: return 'inf' if dy == 0: return '0' divisor = gcd(dx, dy) return (dy // divisor, dx // divisor) n = len(points) if n < 3: return n max_points = 0 for i in range(n): slopes = defaultdict(int) for j in range(n): if i != j: s = slope(points[i], points[j]) slopes[s] += 1 max_points = max(max_points, max(slopes.values(), default=0) + 1) return max_points"},{"question":"class NumberOfClusters: NumberOfClusters class to count and update isolated clusters of '1's in a binary matrix. Args: grid (List[List[int]]): 2D list representing the binary matrix. Methods: countIslands() -> int: Returns the number of isolated clusters of '1's. update(row: int, col: int, val: int): Updates the value at specified position in the grid. Examples: >>> grid = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 1, 1] ] >>> clusters = NumberOfClusters(grid) >>> clusters.countIslands() 2 >>> clusters.update(2, 2, 0) >>> clusters.countIslands() 2 >>> clusters.update(0, 4, 1) >>> clusters.countIslands() 3 def __init__(self, grid): # Initialize the NumberOfClusters object with the grid. pass def countIslands(self): # Implement this method to count the number of isolated clusters of '1's. pass def update(self, row, col, val): # Implement this method to update the value at the specified position in the grid. pass","solution":"class NumberOfClusters: def __init__(self, grid): self.grid = grid self.rows = len(grid) self.cols = len(grid[0]) if self.rows > 0 else 0 def countIslands(self): visited = [[False for _ in range(self.cols)] for _ in range(self.rows)] def dfs(r, c): if r < 0 or c < 0 or r >= self.rows or c >= self.cols or self.grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True dfs(r + 1, c) dfs(r - 1, c) dfs(r, c + 1) dfs(r, c - 1) count = 0 for row in range(self.rows): for col in range(self.cols): if self.grid[row][col] == 1 and not visited[row][col]: dfs(row, col) count += 1 return count def update(self, row, col, val): if row < 0 or col < 0 or row >= self.rows or col >= self.cols: raise ValueError(\\"Invalid grid coordinates\\") self.grid[row][col] = val"},{"question":"def kruskals_mst(n: int, connections: List[List[int]]) -> int: Find the minimum spanning tree (MST) of a connected graph with \`n\` vertices and \`m\` edges. Each edge in the graph has a weight denoted by \`connections[i] = [u, v, w]\` where \`u\` and \`v\` are vertices and \`w\` is the weight of the edge connecting them. Return the total weight of the MST. If there are multiple MSTs with the same total weight, any of them will be considered acceptable. >>> kruskals_mst(4, [[0, 1, 1], [1, 2, 2], [0, 2, 4], [2, 3, 3], [1, 3, 5]]) 6 >>> kruskals_mst(5, [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4]]) 19 >>> kruskals_mst(3, [[0, 1, 2], [1, 2, 3], [0, 2, 1]]) 3 >>> kruskals_mst(4, [[0, 1, 1], [0, 2, 2], [1, 2, 1], [1, 3, 3], [2, 3, 2]]) 4 >>> kruskals_mst(2, [[0, 1, 10]]) 10","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskals_mst(n, connections): connections.sort(key=lambda x: x[2]) # sort the edges by weight parent = [i for i in range(n)] rank = [0] * n mst_weight = 0 edges_used = 0 for u, v, w in connections: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += w edges_used += 1 # If we've already used n-1 edges, we can stop if edges_used == n - 1: break return mst_weight"},{"question":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - List of integers to be rotated. :param k: int - Number of steps to rotate the array. :return: List[int] - The rotated array. >>> rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3], 1) == [3, 1, 2] >>> rotate_array([1, 2, 3], 3) == [1, 2, 3] >>> rotate_array([1, 2, 3], 4) == [3, 1, 2] >>> rotate_array([], 3) == [] >>> rotate_array([1, 2, 3, 4], 0) == [1, 2, 3, 4] >>> rotate_array([1], 4) == [1]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. :param arr: List[int] - List of integers to be rotated. :param k: int - Number of steps to rotate the array. :return: List[int] - The rotated array. n = len(arr) if n == 0: return arr k = k % n # In case k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"def max_items_within_budget(arr, budget): Returns the maximum number of items that can be bought without exceeding the given budget. Parameters: arr (list of int): List of item costs. budget (int): Available budget to spend. Returns: int: Maximum number of items that can be bought. pass # Example Unit Tests def test_max_items_within_budget(): assert max_items_within_budget([10, 20, 30], 50) == 2 assert max_items_within_budget([5, 5, 5, 5, 5], 14) == 2 assert max_items_within_budget([7, 3, 5, 8, 2], 10) == 3 assert max_items_within_budget([1, 1, 1, 1, 1], 3) == 3 assert max_items_within_budget([10, 20, 30], 60) == 3 assert max_items_within_budget([10, 10, 10], 9) == 0 assert max_items_within_budget([1, 2, 3, 4, 5, 6], 0) == 0 assert max_items_within_budget([], 10) == 0 assert max_items_within_budget([2, 4, 6, 8], 15) == 3 assert max_items_within_budget([5, 5, 5], 10) == 2","solution":"def max_items_within_budget(arr, budget): Returns the maximum number of items that can be bought without exceeding the given budget. Parameters: arr (list of int): List of item costs. budget (int): Available budget to spend. Returns: int: Maximum number of items that can be bought. arr.sort() count = 0 current_sum = 0 for cost in arr: if current_sum + cost <= budget: current_sum += cost count += 1 else: break return count"},{"question":"from typing import List def rob(nums: List[int]) -> int: Given a list of \`n\` non-negative integers \`nums\` representing the amount of money of each house, determines the maximum amount of money you can rob tonight without alerting the police. Each house in the neighborhood is put along a street and each house can have security systems connected to its adjacent houses, which means if you rob one house, you cannot rob its immediate neighbor. >>> rob([2, 3, 2]) == 3 >>> rob([1, 2, 3, 1]) == 4 >>> rob([]) == 0 >>> rob([1, 3, 1]) == 3 >>> rob([6, 7, 1, 30, 8, 2, 4]) == 41 from solution import rob def test_rob_single_house(): assert rob([2]) == 2 assert rob([3]) == 3 def test_rob_two_houses(): assert rob([2, 3]) == 3 assert rob([1, 2]) == 2 def test_rob_multiple_houses(): assert rob([2, 3, 2]) == 3 assert rob([1, 2, 3, 1]) == 4 assert rob([1, 2, 3, 4, 5]) == 8 assert rob([1, 7, 9, 4]) == 11 assert rob([6, 7, 1, 30, 8, 2, 4]) == 41 def test_rob_corner_cases(): assert rob([]) == 0 assert rob([0, 0, 0]) == 0 assert rob([1, 3, 1]) == 3 assert rob([0]) == 0 assert rob([0, 1, 2]) == 2","solution":"def rob(nums): Returns the maximum amount of money you can rob tonight without alerting the police. if not nums: return 0 if len(nums) <= 2: return max(nums) def rob_line(houses): prev1, prev2 = 0, 0 for house in houses: new_rob = max(prev1, prev2 + house) prev2 = prev1 prev1 = new_rob return prev1 # Special case for circular houses return max(rob_line(nums[:-1]), rob_line(nums[1:]))"},{"question":"from typing import List def mergeSkyline(buildings: List[List[int]]) -> List[List[int]]: Merge the given buildings into a list of skyline key points. Each building is represented by [x_start, x_end, height]. The function should return the merged skyline as a list of key points. >>> mergeSkyline([[1, 3, 8], [2, 4, 6], [5, 6, 7]]) [[1, 8], [3, 6], [4, 0], [5, 7], [6, 0]] >>> mergeSkyline([[1, 3, 8], [3, 5, 8]]) [[1, 8], [5, 0]]","solution":"from typing import List from heapq import heappop, heappush def mergeSkyline(buildings: List[List[int]]) -> List[List[int]]: The function merges the given buildings into a list of skyline key points. Each building is given as [x_start, x_end, height]. events = [] for x_start, x_end, height in buildings: events.append((x_start, -height)) events.append((x_end, height)) events.sort() result = [] heap = [0] prev_height = 0 for x, height in events: if height < 0: heappush(heap, height) else: heap.remove(-height) heap.sort() current_height = -heap[0] if current_height != prev_height: result.append([x, current_height]) prev_height = current_height return result"},{"question":"def remove_duplicates(s: str) -> str: Removes all duplicate characters from the string and returns the resulting string in the same order as the first occurrence of each character. >>> remove_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_duplicates(\\"aabbcc\\") == \\"abc\\" >>> remove_duplicates(\\"abcabc\\") == \\"abc\\" >>> remove_duplicates(\\"a1b2c3a1b2\\") == \\"a1b2c3\\" >>> remove_duplicates(\\"\\") == \\"\\" >>> remove_duplicates(\\"a\\") == \\"a\\" >>> remove_duplicates(\\"aaaa\\") == \\"a\\" >>> remove_duplicates(\\"!@#!@\\") == \\"!@#\\"","solution":"def remove_duplicates(s): Removes duplicate characters from the string s and returns the resulting string with the first occurrence of each character in the same order as they appeared. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def minMaxSplit(arr, k): Return the minimum possible score of a split by dividing the array into k non-empty contiguous subarrays. Parameters: arr (list): List of positive integers. k (int): Number of non-empty contiguous subarrays. Returns: int: Minimum possible score of the split. >>> minMaxSplit([7,2,5,10,8], 2) 18 >>> minMaxSplit([1, 2, 3, 4, 5], 2) 9 >>> minMaxSplit([1], 1) 1 >>> minMaxSplit([1, 2], 1) 3 >>> minMaxSplit([1, 2], 2) 2 >>> minMaxSplit([1000, 2000, 3000], 3) 3000 >>> minMaxSplit([5, 5, 5, 5], 2) 10 >>> minMaxSplit([5, 5, 5, 5], 4) 5","solution":"def minMaxSplit(arr, k): This function returns the minimum possible score of a split by dividing the array into k non-empty contiguous subarrays. Parameters: arr (list): List of positive integers. k (int): Number of non-empty contiguous subarrays. Returns: int: Minimum possible score of the split. def can_split(max_sum): current_sum = 0 num_subarrays = 1 for num in arr: if current_sum + num > max_sum: num_subarrays += 1 current_sum = num if num_subarrays > k: return False else: current_sum += num return True left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"import random class RandomizedSet: A data structure that supports the following operations on a set of integers: * addElement(int value) - Adds the value to the set. If the value already exists in the set, do nothing. * removeElement(int value) - Removes the value from the set. If the value does not exist in the set, do nothing. * getRandomElement() - Returns a random element from the set. Each element must have the same probability of being returned. If the set is empty, throw an exception or return a specific value indicating that the set is empty. * getSize() - Returns the number of elements in the set. >>> rset = RandomizedSet() >>> rset.addElement(1) >>> rset.addElement(2) >>> rset.getSize() 2 >>> rset.getRandomElement() in [1, 2] True >>> rset.removeElement(1) >>> rset.getSize() 1 >>> rset.removeElement(3) >>> rset.getSize() 1 def __init__(self): pass def addElement(self, value: int) -> None: pass def removeElement(self, value: int) -> None: pass def getRandomElement(self) -> int: pass def getSize(self) -> int: pass import pytest def test_addElement(): rset = RandomizedSet() rset.addElement(1) rset.addElement(2) assert rset.getSize() == 2 rset.addElement(1) # duplicate element assert rset.getSize() == 2 # size should not change assert 1 in rset.list_elements assert 2 in rset.list_elements def test_removeElement(): rset = RandomizedSet() rset.addElement(1) rset.addElement(2) rset.removeElement(1) assert rset.getSize() == 1 assert 1 not in rset.list_elements rset.removeElement(3) # removing non-existent element assert rset.getSize() == 1 # size should not change def test_getRandomElement(): rset = RandomizedSet() rset.addElement(1) rset.addElement(2) element = rset.getRandomElement() assert element in [1, 2] rset.removeElement(1) rset.removeElement(2) with pytest.raises(Exception): rset.getRandomElement() # should raise Exception as set is empty def test_getSize(): rset = RandomizedSet() assert rset.getSize() == 0 rset.addElement(1) rset.addElement(2) assert rset.getSize() == 2 rset.removeElement(2) assert rset.getSize() == 1 if __name__ == \\"__main__\\": pytest.main([__file__])","solution":"import random class RandomizedSet: def __init__(self): self.set_elements = {} self.list_elements = [] def addElement(self, value: int) -> None: if value not in self.set_elements: self.set_elements[value] = len(self.list_elements) self.list_elements.append(value) def removeElement(self, value: int) -> None: if value in self.set_elements: index_to_remove = self.set_elements[value] last_element = self.list_elements[-1] self.list_elements[index_to_remove] = last_element self.set_elements[last_element] = index_to_remove self.list_elements.pop() del self.set_elements[value] def getRandomElement(self) -> int: if not self.list_elements: raise Exception(\\"The set is empty\\") return random.choice(self.list_elements) def getSize(self) -> int: return len(self.set_elements)"},{"question":"def is_valid_permutation(t: str) -> bool: Determines if the string t, which is a permutation of some given string s, has valid and properly nested parentheses. >>> is_valid_permutation(\\"()\\") True >>> is_valid_permutation(\\"[]\\") True >>> is_valid_permutation(\\"{}\\") True >>> is_valid_permutation(\\"(\\") False >>> is_valid_permutation(\\"]\\") False >>> is_valid_permutation(\\"{)\\") False >>> is_valid_permutation(\\"()[]{}\\") True >>> is_valid_permutation(\\"{[()]}\\") True >>> is_valid_permutation(\\"({[]})\\") True >>> is_valid_permutation(\\"(}\\") False >>> is_valid_permutation(\\"{[}]\\") False >>> is_valid_permutation(\\"[{(})]\\") False >>> is_valid_permutation(\\"{[()()()]}\\") True >>> is_valid_permutation(\\"[({})]\\") True >>> is_valid_permutation(\\"{[(])}\\") False >>> is_valid_permutation(\\"[[{{()}}]]\\") True","solution":"def is_valid_permutation(t): Determines if the string t, which is a permutation of some given string s, has valid and properly nested parentheses. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in t: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket.keys(): if stack == [] or matching_bracket[char] != stack.pop(): return False return stack == []"},{"question":"from typing import List def exist(board: List[List[str]], word: str) -> bool: Given a 2D grid of characters \`board\` and a string \`word\`, return \`true\` if \`word\` exists in the grid, and \`false\` otherwise. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> board = [['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']] >>> exist(board, \\"ABCCED\\") True >>> exist(board, \\"SEE\\") True >>> exist(board, \\"ABCB\\") False pass def test_example_case_1(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCCED\\" assert exist(board, word) == True def test_example_case_2(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"SEE\\" assert exist(board, word) == True def test_example_case_3(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"ABCB\\" assert exist(board, word) == False def test_empty_word(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"\\" assert exist(board, word) == True def test_word_not_in_board(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"XYZ\\" assert exist(board, word) == False def test_single_character_word_true(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"A\\" assert exist(board, word) == True def test_single_character_word_false(): board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] word = \\"X\\" assert exist(board, word) == False def test_multiple_starting_points(): board = [ ['A','A','A','A'], ['A','A','A','A'], ['A','A','A','A'] ] word = \\"AAA\\" assert exist(board, word) == True def test_word_longer_than_board(): board = [ ['A','B'], ['C','D'] ] word = \\"ABCDABCD\\" assert exist(board, word) == False","solution":"def exist(board, word): Returns True if the word exists in the board by moving horizontally or vertically. def dfs(board, word, i, j, word_index): if word_index == len(word): return True if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[word_index]: return False temp = board[i][j] board[i][j] = '#' found = (dfs(board, word, i + 1, j, word_index + 1) or dfs(board, word, i - 1, j, word_index + 1) or dfs(board, word, i, j + 1, word_index + 1) or dfs(board, word, i, j - 1, word_index + 1)) board[i][j] = temp return found for i in range(len(board)): for j in range(len(board[0])): if dfs(board, word, i, j, 0): return True return False"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_tree(root): Check if a binary tree is balanced based on the defined path sum condition. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. def test_balanced_tree(): # Example of a balanced tree # 1 # / # 2 3 # Paths: 1->2, 1->3 (both have path sum of 3) root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) assert is_balanced_tree(root) == True def test_unbalanced_tree(): # Example of an unbalanced tree # 1 # / # 2 1 # / # 3 # Paths: 1->2->3 (sum = 6), 1->1 (sum = 2) root = TreeNode(1) root.left = TreeNode(2) root.left.left = TreeNode(3) root.right = TreeNode(1) assert is_balanced_tree(root) == False def test_single_node_tree(): # Single node tree # 1 # Paths: 1 (sum = 1) root = TreeNode(1) assert is_balanced_tree(root) == True def test_empty_tree(): # Empty tree # Paths: None root = None assert is_balanced_tree(root) == True def test_different_values(): # Example of a balanced tree with different values # 5 # / # 3 6 # / # 2 4 # Paths: 5->3->2 (sum = 10), 5->3->4 (sum = 12), 5->6 (sum = 11) # difference between max and min path sums is 2 which is more than 1 root = TreeNode(5) root.left = TreeNode(3) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right = TreeNode(6) assert is_balanced_tree(root) == False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_tree(root): Check if a binary tree is balanced based on the defined path sum condition. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the tree is balanced, False otherwise. def dfs(node): if not node: return (True, 0, float('inf'), float('-inf')) left_balanced, left_sum, left_min_leaf, left_max_leaf = dfs(node.left) right_balanced, right_sum, right_min_leaf, right_max_leaf = dfs(node.right) current_sum = node.value if node.left is None and node.right is None: return (True, current_sum, current_sum, current_sum) current_balanced = (left_balanced and right_balanced and (abs(left_min_leaf - right_min_leaf) <= 1 if node.left and node.right else True) and (abs(left_max_leaf - right_max_leaf) <= 1 if node.left and node.right else True)) min_leaf = min(left_min_leaf, right_min_leaf) max_leaf = max(left_max_leaf, right_max_leaf) return (current_balanced, current_sum, min_leaf, max_leaf) balanced, _, _, _ = dfs(root) return balanced"},{"question":"def four_sum_exists(nums: List[int], target: int) -> bool: Returns True if there exist four distinct indices \`a, b, c, d\` such that \`nums[a] + nums[b] + nums[c] + nums[d]\` is equal to \`target\`, otherwise returns False. >>> four_sum_exists([1, 2, 3, 4, 5], 10) True >>> four_sum_exists([1, 2, 3, 4, 5], 30) False >>> four_sum_exists([], 0) False >>> four_sum_exists([1, 2, 3], 6) False >>> four_sum_exists([1, 0, -1, 0, -2, 2], 0) True >>> four_sum_exists([1, 1, 1, 1], 4) True >>> four_sum_exists([1000000000, 1000000000, 1000000000, 1000000000, 1000000000], 4000000000) True","solution":"def four_sum_exists(nums, target): Returns True if there exist four distinct indices \`a, b, c, d\` such that \`nums[a] + nums[b] + nums[c] + nums[d]\` is equal to \`target\`, otherwise returns False. if len(nums) < 4: return False nums.sort() n = len(nums) for i in range(n - 3): for j in range(i + 1, n - 2): left = j + 1 right = n - 1 while left < right: s = nums[i] + nums[j] + nums[left] + nums[right] if s == target: return True elif s < target: left += 1 else: right -= 1 return False"},{"question":"from typing import List def days_until_warmer(temperatures: List[int]) -> List[int]: Returns an array where each element is the number of days until a warmer temperature. If no warmer temperature is forthcoming, the value is 0. >>> days_until_warmer([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> days_until_warmer([75, 74, 73]) [0, 0, 0] >>> days_until_warmer([70, 70, 70, 70]) [0, 0, 0, 0] >>> days_until_warmer([70]) [0] >>> days_until_warmer([70, 71, 72, 73]) [1, 1, 1, 0] >>> days_until_warmer([71, 69, 72, 65, 75]) [2, 1, 2, 1, 0]","solution":"from typing import List def days_until_warmer(temperatures: List[int]) -> List[int]: Returns an array where each element is the number of days until a warmer temperature. If no warmer temperature is forthcoming, the value is 0. n = len(temperatures) result = [0] * n stack = [] # This will store indices of the \`temperatures\` list for i in range(n): # As long as the stack is not empty and the current temperature # is warmer than the temperature at index of the last element # of the stack (which means there's a warmer temperature on the current day). while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() result[prev_index] = i - prev_index stack.append(i) return result"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diameterOfBinaryTree(root): Returns the length of the diameter of the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> diameterOfBinaryTree(root) 3 >>> root = TreeNode(1) >>> diameterOfBinaryTree(root) 0 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> root.right.right.right.right = TreeNode(5) >>> diameterOfBinaryTree(root) 4 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.left.right.left = TreeNode(6) >>> root.left.right.right = TreeNode(7) >>> diameterOfBinaryTree(root) 4","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def diameterOfBinaryTree(root): Returns the length of the diameter of the binary tree. def depth(node): if not node: return 0 left_depth = depth(node.left) right_depth = depth(node.right) max_depth[0] = max(max_depth[0], left_depth + right_depth) return max(left_depth, right_depth) + 1 max_depth = [0] depth(root) return max_depth[0]"},{"question":"from typing import List def min_increment_for_unique(nums: List[int]) -> int: Given an array of integers \`nums\`, return the minimum number of operations required to make the array elements unique. In one operation, you can increment any element by \`1\`. >>> min_increment_for_unique([1, 2, 3, 4, 5]) == 0 >>> min_increment_for_unique([1, 1, 1, 1, 1]) == 10 >>> min_increment_for_unique([3, 2, 1, 2, 1, 7]) == 6 >>> min_increment_for_unique([]) == 0 >>> min_increment_for_unique([10]) == 0 >>> min_increment_for_unique([-1, -1, -1, -1]) == 6 >>> min_increment_for_unique([1, 100000]) == 0","solution":"def min_increment_for_unique(nums): Given an array of integers \`nums\`, return the minimum number of operations required to make the array elements unique. In one operation, you can increment any element by \`1\`. # Sort the array to bring duplicates next to each other nums.sort() # Initialize the count of increments needed increments = 0 # Iterate over the array to ensure all elements are unique for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment_needed = nums[i - 1] - nums[i] + 1 nums[i] += increment_needed increments += increment_needed return increments"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def count_paths_with_sum(root: TreeNode, targetSum: int) -> int: Returns the number of distinct root-to-leaf paths in which the sum of the values of the nodes on the path is equal to a given target sum. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> count_paths_with_sum(root, 22) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> count_paths_with_sum(root, 5) 0 >>> count_paths_with_sum(root, 3) 2","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum_helper(node, targetSum, current_sum): if node is None: return 0 current_sum += node.val # If it's a leaf node and sum matches the targetSum, count this path if node.left is None and node.right is None: return 1 if current_sum == targetSum else 0 # Recur for left and right subtrees return (path_sum_helper(node.left, targetSum, current_sum) + path_sum_helper(node.right, targetSum, current_sum)) def count_paths_with_sum(root, targetSum): if root is None: return 0 # Count paths from the root paths_from_root = path_sum_helper(root, targetSum, 0) # Try the left and right subtrees as new roots paths_on_left = count_paths_with_sum(root.left, targetSum) paths_on_right = count_paths_with_sum(root.right, targetSum) return paths_from_root + paths_on_left + paths_on_right"},{"question":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root: Optional[TreeNode]) -> List[int]: Returns the right side view of a binary tree. Args: root (TreeNode): root of the binary tree. Returns: List[int]: the right side view of the tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> rightSideView(root) [1, 3, 6] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> rightSideView(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> rightSideView(root) [1, 3, 4] >>> root = None >>> rightSideView(root) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rightSideView(root): Returns the right side view of a binary tree. Args: root (TreeNode): root of the binary tree. Returns: List[int]: the right side view of the tree. if not root: return [] right_view = [] queue = deque([root]) # Initialize a queue for level order traversal while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it's the rightmost element of this level if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def merge_alternately(word1: str, word2: str) -> str: Merges two strings by alternating characters from each original string. Args: word1: First input string. word2: Second input string. Returns: A merged string formed by alternating characters of word1 and word2. >>> merge_alternately(\\"abc\\", \\"xyz\\") 'axbycz' >>> merge_alternately(\\"abcd\\", \\"xy\\") 'axbycd' >>> merge_alternately(\\"ab\\", \\"wxyz\\") 'awbxyz' >>> merge_alternately(\\"\\", \\"xyz\\") 'xyz' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"\\") '' # Your code here","solution":"def merge_alternately(word1, word2): Merges two strings by alternating characters from each original string. Args: word1: First input string. word2: Second input string. Returns: A merged string formed by alternating characters of word1 and word2. merged = [] len1, len2 = len(word1), len(word2) i, j = 0, 0 while i < len1 and j < len2: merged.append(word1[i]) merged.append(word2[j]) i += 1 j += 1 # Append the remaining characters if i < len1: merged.append(word1[i:]) if j < len2: merged.append(word2[j:]) return ''.join(merged)"},{"question":"def find_duplicates(arr: List[int]) -> List[int]: Given an array of integers \`arr\`, find all elements in the array that appear more than once and return an array of these duplicate elements in ascending order. If no such elements exist, return an empty array. >>> find_duplicates([1, 2, 2, 3, 3, 4, 4, 4]) [2, 3, 4] >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([5, 5, 5, 5]) [5] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([-1, -2, -2, -3, -3, -3, -4, -4]) [-4, -3, -2] >>> find_duplicates([-1, 1, 2, -1, 2, -3, 3]) [-1, 2]","solution":"def find_duplicates(arr): Finds all elements in the array that appear more than once and returns an array of these duplicate elements in ascending order. Args: arr (list of int): The input array of integers. Returns: list of int: The list of duplicate elements in ascending order, or an empty list if no duplicates exist. from collections import Counter # Count the frequencies of each element in the array counter = Counter(arr) # Find elements that appear more than once duplicates = [num for num, count in counter.items() if count > 1] # Return the duplicates in ascending order return sorted(duplicates)"},{"question":"def shuffle_string(s: str, indices: List[int]) -> str: Rearrange the characters of the string \`s\` according to the given array \`indices\`, where the character originally at the \`i-th\` position should be moved to \`indices[i]\` in the rearranged string. :param s: String consisting of lowercase alphabets. :param indices: List of integers where indices[i] indicates the new position of the character at i in s. :return: A new string after shuffling. Example: >>> shuffle_string(\\"abc\\", [0, 1, 2]) 'abc' >>> shuffle_string(\\"abc\\", [2, 1, 0]) 'cba'","solution":"def shuffle_string(s, indices): Returns a rearranged string after shuffling the characters according to the given indices. :param s: String consisting of lowercase alphabets. :param indices: List of integers where indices[i] indicates the new position of the character at i in s. :return: A new string after shuffling. shuffled = [''] * len(s) for i, char in enumerate(s): shuffled[indices[i]] = char return ''.join(shuffled)"},{"question":"def max_subarray_length(nums: List[int], target: int) -> int: Returns the length of the longest contiguous subarray that sums to target. If no such subarray exists, returns 0. >>> max_subarray_length([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_length([1, 2, 3], 7) 0 >>> max_subarray_length([5], 5) 1 >>> max_subarray_length([5, 5, 5, 5], 10) 2 >>> max_subarray_length([1], 5) 0 >>> max_subarray_length([-1, -1, 1, 1, 1], 0) 4 >>> long_list = [1] * 10000 >>> max_subarray_length(long_list, 5000) 5000","solution":"def max_subarray_length(nums, target): Returns the length of the longest contiguous subarray that sums to target. If no such subarray exists, returns 0. prefix_sum = {} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum == target: max_length = i + 1 if (current_sum - target) in prefix_sum: max_length = max(max_length, i - prefix_sum[current_sum - target]) if current_sum not in prefix_sum: prefix_sum[current_sum] = i return max_length"},{"question":"class MaxStack: Design a stack that supports push, pop, top, and retrieving the maximum element in constant time. Methods: - push(x: int): Push the element x onto the stack. - pop() -> int: Remove the element on the top of the stack and return it. - top() -> int: Get the element on the top of the stack without removing it. - getMax() -> int: Retrieve the maximum element in the stack without removing it. >>> stack = MaxStack() >>> stack.push(5) >>> stack.getMax() 5 >>> stack.push(1) >>> stack.getMax() 5 >>> stack.push(5) >>> stack.getMax() 5 >>> stack.push(6) >>> stack.getMax() 6 >>> stack.push(3) >>> stack.getMax() 6 >>> stack.top() 3 >>> stack.pop() 3 >>> stack.getMax() 6 >>> stack.pop() 6 >>> stack.getMax() 5 >>> stack.pop() 5 >>> stack.getMax() 5 >>> stack.pop() 1 >>> stack.getMax() 5 >>> stack.pop() 5 def __init__(self): Initialize the MaxStack. def push(self, x: int): Push element x onto the stack. def pop(self): Remove and return the element on the top of the stack. def top(self): Get and return the element on the top of the stack without removing it. def getMax(self): Retrieve and return the maximum element in the stack without removing it.","solution":"class MaxStack: def __init__(self): self.stack = [] self.max_stack = [] def push(self, x: int): self.stack.append(x) if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self): if not self.stack: raise IndexError(\\"pop from empty stack\\") popped = self.stack.pop() if popped == self.max_stack[-1]: self.max_stack.pop() return popped def top(self): if not self.stack: raise IndexError(\\"top from empty stack\\") return self.stack[-1] def getMax(self): if not self.max_stack: raise IndexError(\\"getMax from empty max stack\\") return self.max_stack[-1]"},{"question":"def can_become_anagrams(s1: str, s2: str) -> bool: Determines if two strings can become anagrams by deleting some characters from both. >>> can_become_anagrams(\\"abc\\", \\"cab\\") True >>> can_become_anagrams(\\"aabc\\", \\"bcaa\\") True >>> can_become_anagrams(\\"\\", \\"\\") True >>> can_become_anagrams(\\"aabc\\", \\"ab\\") False >>> can_become_anagrams(\\"abcd\\", \\"efgh\\") False >>> can_become_anagrams(\\"a\\", \\"a\\") True >>> can_become_anagrams(\\"a\\", \\"b\\") False","solution":"def can_become_anagrams(s1, s2): Determines if two strings can become anagrams by deleting some characters from both. Args: s1 (str): First input string. s2 (str): Second input string. Returns: bool: True if the strings can become anagrams, False otherwise. from collections import Counter # Count frequency of each character in both strings count1 = Counter(s1) count2 = Counter(s2) # For each unique character in the union of the strings for char in set(count1.keys()).union(set(count2.keys())): # If the character count does not match in both strings, return False if count1[char] != count2[char]: return False return True"},{"question":"class TaskManager: A simplified version of a multi-user task management system. Methods: - addTask(int taskId, int priority): Adds a new task with the given taskId and priority. - assignUserToTask(int taskId, int userId): Assigns a user with userId to the task with taskId. - getUsersAssignedToTask(int taskId): Returns a list of user IDs assigned to the task with taskId. - getTasksByPriority(int priority): Returns a list of task IDs with the specified priority. >>> tm = TaskManager() >>> tm.addTask(1, 5) >>> tm.tasks[1]['priority'] == 5 True >>> tm.addTask(2, 5) >>> tm.addTask(3, 10) >>> tm.assignUserToTask(1, 100) >>> 100 in tm.tasks[1]['users'] True >>> assert set(tm.getUsersAssignedToTask(1)) == {100} >>> assert tm.getTasksByPriority(5) == [1, 2] >>> assert tm.getTasksByPriority(10) == [3] def __init__(self): # Initialize data structures pass def addTask(self, taskId, priority): # Add a new task with given taskId and priority pass def assignUserToTask(self, taskId, userId): # Assign a user to a task pass def getUsersAssignedToTask(self, taskId): # Get users assigned to a task pass def getTasksByPriority(self, priority): # Get tasks by priority pass","solution":"class TaskManager: def __init__(self): self.tasks = {} self.tasks_by_priority = {} def addTask(self, taskId, priority): if taskId not in self.tasks: self.tasks[taskId] = { 'priority': priority, 'users': set() } if priority not in self.tasks_by_priority: self.tasks_by_priority[priority] = [] self.tasks_by_priority[priority].append(taskId) def assignUserToTask(self, taskId, userId): if taskId in self.tasks and userId not in self.tasks[taskId]['users']: self.tasks[taskId]['users'].add(userId) def getUsersAssignedToTask(self, taskId): if taskId in self.tasks: return list(self.tasks[taskId]['users']) return [] def getTasksByPriority(self, priority): if priority in self.tasks_by_priority: return self.tasks_by_priority[priority] return []"},{"question":"def count_unique_pairs(arr: List[int], target: int) -> int: Returns the number of unique pairs of numbers in the array that sum up to target. >>> count_unique_pairs([1, 3, 2, 2, 4, 5], 5) 2 >>> count_unique_pairs([1, 2, 3], 6) 0 >>> count_unique_pairs([2, 2, 2, 2], 4) 1 >>> count_unique_pairs([1, 2, 3, 7], 10) 1 >>> count_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> count_unique_pairs([10000000, 9999999, 1], 19999999) 1 pass","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of numbers in the array that sum up to target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"def trap(height: List[int]) -> int: Given an array of positive integers representing the height of bars where the width of each bar is 1, return the maximum amount of water that can be trapped after raining. Args: height : List[int] -- an array of positive integers representing the height of bars Returns: int -- the maximum amount of water that can be trapped Examples: >>> trap([]) 0 >>> trap([1, 1, 1, 1]) 0 >>> trap([1, 2, 3, 4, 5]) 0 >>> trap([5, 4, 3, 2, 1]) 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([0, 2, 0]) 0 >>> trap([3, 0, 2, 0, 4]) 7","solution":"def trap(height): Calculates the maximum amount of water that can be trapped after raining. Arguments: height : list[int] -- an array of positive integers representing the height of bars Returns: int -- the maximum amount of water that can be trapped if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def rearrange_string(s: str, k: int) -> str: Determine if the string \`s\` can be rearranged such that no character appears more than once in any \`k\` consecutive positions. >>> rearrange_string(\\"aabbcc\\", 3) \\"abcabc\\" # or another valid rearrangement >>> rearrange_string(\\"aaabc\\", 3) \\"\\" >>> rearrange_string(\\"aaa\\", 0) \\"aaa\\" >>> rearrange_string(\\"aabbcc\\", 0) \\"aabbcc\\" >>> rearrange_string(\\"aaab\\", 2) \\"\\" >>> rearrange_string(\\"abcdefgh\\", 8) \\"abcdefgh\\" >>> rearrange_string(\\"a\\" * 1000 + \\"b\\" * 1000 + \\"c\\" * 1000, 2) \\"ababab...\\" # length 3000 with no consecutive identical characters >>> rearrange_string(\\"\\", 5) \\"\\"","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s, k): if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heappush(max_heap, (-freq, char)) queue = [] result = [] while max_heap: freq, char = heappop(max_heap) freq = -freq result.append(char) queue.append((char, freq - 1)) if len(queue) >= k: front_char, front_freq = queue.pop(0) if front_freq > 0: heappush(max_heap, (-front_freq, front_char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\" # Example usage # s = \\"aabbcc\\", k = 3, Output: \\"abcabc\\" or \\"acabcb\\" print(rearrange_string(\\"aabbcc\\", 3)) # s = \\"aaabc\\", k = 3, Output: \\"\\" print(rearrange_string(\\"aaabc\\", 3))"},{"question":"from bisect import bisect_left, bisect_right def is_majority_element(nums: List[int], target: int) -> bool: Determines if target is a majority element in nums. Parameters: nums (list): A list of integers sorted in non-decreasing order. target (int): The target value to check for majority element status. Returns: bool: True if target is a majority element, False otherwise. Example: >>> is_majority_element([2, 4, 4, 4, 4, 6, 8], 4) True >>> is_majority_element([2, 4, 4, 4, 6, 6, 8, 8, 8], 4) False","solution":"from bisect import bisect_left, bisect_right def is_majority_element(nums, target): Determines if target is a majority element in nums. Parameters: nums (list): A list of integers sorted in non-decreasing order. target (int): The target value to check for majority element status. Returns: bool: True if target is a majority element, False otherwise. n = len(nums) left = bisect_left(nums, target) right = bisect_right(nums, target) return (right - left) > (n // 2)"},{"question":"def longest_contiguous_ones(s: str) -> int: Given a binary string \`s\`, returns the length of the longest contiguous substring of all 1s after performing at most one flip operation (i.e., changing a '0' to a '1' or a '1' to a '0'). >>> longest_contiguous_ones(\\"11111\\") == 5 >>> longest_contiguous_ones(\\"1101101\\") == 5 >>> longest_contiguous_ones(\\"110010111\\") == 5 >>> longest_contiguous_ones(\\"\\") == 0 >>> longest_contiguous_ones(\\"0\\") == 1 >>> longest_contiguous_ones(\\"1\\") == 1 >>> longest_contiguous_ones(\\"10101\\") == 3 >>> longest_contiguous_ones(\\"0000\\") == 1 >>> longest_contiguous_ones(\\"111010111\\") == 5 >>> longest_contiguous_ones(\\"111111\\") == 6","solution":"def longest_contiguous_ones(s): Returns the length of the longest contiguous substring of all 1s after performing at most one flip operation. n = len(s) max_count, zero_count, left = 0, 0, 0 for right in range(n): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_count = max(max_count, right - left + 1) return max_count"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring that contains at most k distinct characters. >>> longest_substring_with_k_distinct(\\"araaci\\", 2) 4 >>> longest_substring_with_k_distinct(\\"araaci\\", 1) 2 >>> longest_substring_with_k_distinct(\\"cbbebi\\", 3) 5 >>> longest_substring_with_k_distinct(\\"abcabcabc\\", 2) 2 >>> longest_substring_with_k_distinct(\\"\\", 3) 0 >>> longest_substring_with_k_distinct(\\"a\\", 0) 0 >>> longest_substring_with_k_distinct(\\"a\\", 1) 1 >>> longest_substring_with_k_distinct(\\"aaaaaa\\", 1) 6 >>> longest_substring_with_k_distinct(\\"bbbb\\", 2) 4 >>> longest_substring_with_k_distinct(\\"a\\" * 10000 + \\"b\\" * 10000 + \\"c\\" * 10000, 2) 20000","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring that contains at most k distinct characters. if k == 0 or not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): if s[right] in char_count: char_count[s[right]] += 1 else: char_count[s[right]] = 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"def longest_consecutive(nums: List[int]) -> int: Given an array of integers nums, return the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([]) 0 >>> longest_consecutive([1]) 1 >>> longest_consecutive([2, 1]) 2 >>> longest_consecutive([1, 10]) 1 >>> longest_consecutive([1, 2, 0, 1, 200, 3]) 4 >>> longest_consecutive([1, 2, 2, 3, 4, 5, 5, 6]) 6 >>> longest_consecutive([-1, -2, -3, 0, 1]) 5 pass","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: # Check if it's the start of a sequence current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def max_cookies(grid): Finds the maximum number of cookies that can be collected from the top-left to the bottom-right of a grid. >>> max_cookies([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_cookies([[1, 2, 5], [3, 2, 1]]) 9 >>> max_cookies([[1, 2], [1, 1]]) 4 >>> max_cookies([]) 0 >>> max_cookies([[5]]) 5 >>> max_cookies([[1, 2, 3]]) 6 >>> max_cookies([[1], [2], [3]]) 6","solution":"def max_cookies(grid): if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = grid[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string \`s\`, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") == 0 >>> length_of_longest_substring(\\"a\\") == 1 >>> length_of_longest_substring(\\"abcdef\\") == 6 >>> length_of_longest_substring(\\"aaaaaa\\") == 1 >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"dvdf\\") == 3 >>> length_of_longest_substring(\\"anviaj\\") == 5 >>> length_of_longest_substring(\\"abccba\\") == 3 >>> length_of_longest_substring(\\"a!@#%^&*()_+\\") == 13 >>> length_of_longest_substring(\\"123123456\\") == 6","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: input string :return: length of the longest substring with all unique characters char_index_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_index_map: left = max(left, char_index_map[s[right]] + 1) char_index_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def evaluate_expression(s: str) -> int: Evaluate a well-formed string mathematical expression containing numbers, addition, subtraction, and parentheses. >>> evaluate_expression(\\"1 + 2\\") 3 >>> evaluate_expression(\\"10 - 3\\") 7 >>> evaluate_expression(\\"5 + 2 - 8\\") -1 >>> evaluate_expression(\\"1 + (2 - 3)\\") 0 >>> evaluate_expression(\\"1 + (2 - (3 + 4))\\") -4 >>> evaluate_expression(\\"(1 + (2 - 3)) - ((4 + 5) - 6)\\") -3 >>> evaluate_expression(\\"10 + (2 + 3 - (4 + 2) + 1)\\") 10 >>> evaluate_expression(\\"((3 + 4) - (1 - 2))\\") 8 >>> evaluate_expression(\\"(1+1)\\") 2 >>> evaluate_expression(\\"(((10)))\\") 10 >>> evaluate_expression(\\" 1 + ( 2 - ( 3 + 4 ) )\\") -4","solution":"def evaluate_expression(s): Evaluate a string mathematical expression containing numbers, +, -, and parentheses. Parameters: s (str): A well-formed mathematical expression Returns: int: The result of evaluating the expression def helper(index): stack = [] num = 0 sign = 1 while index < len(s): char = s[index] if char.isdigit(): num = num * 10 + int(char) elif char in '+-': stack.append(sign * num) num = 0 sign = 1 if char == '+' else -1 elif char == '(': num, index = helper(index + 1) elif char == ')': stack.append(sign * num) return sum(stack), index index += 1 stack.append(sign * num) return sum(stack), index result, _ = helper(0) return result"},{"question":"from typing import List def maxProfitWithinDays(stockPrices: List[int], d: int) -> int: Determine the maximum profit you can achieve with the given constraints. You are allowed to execute exactly one buy and exactly one sell transaction within the given constraints. The buy and sell transactions must be executed on different days, and you must ensure that the stock is sold before or exactly on the dth day from the buying day but not exceed d days. >>> maxProfitWithinDays([7, 1, 5, 3, 6, 4], 3) 5 >>> maxProfitWithinDays([7], 1) 0 >>> maxProfitWithinDays([7, 6, 4, 3, 1], 2) 0 >>> maxProfitWithinDays([1, 2, 3, 4, 5], 1) 1 >>> maxProfitWithinDays([5, 5, 5, 5, 5], 4) 0 >>> maxProfitWithinDays([1, 2, 3, 4, 5], 10) 4 >>> maxProfitWithinDays([7, 2, 5, 3, 6, 4], 1) 3 >>> maxProfitWithinDays([], 5) 0 >>> maxProfitWithinDays([1, 3], 1) 2 pass","solution":"def maxProfitWithinDays(stockPrices, d): n = len(stockPrices) if n < 2: return 0 max_profit = 0 for i in range(n): for j in range(i + 1, min(i + d + 1, n)): profit = stockPrices[j] - stockPrices[i] if profit > max_profit: max_profit = profit return max_profit"},{"question":"def can_form_by_adding_one_char(s1: str, s2: str) -> bool: Given two strings s1 and s2, check if you can make s2 by rearranging the characters of s1 and adding exactly one extra character. >>> can_form_by_adding_one_char(\\"abc\\", \\"abcd\\") True >>> can_form_by_adding_one_char(\\"aabbcc\\", \\"aabbccd\\") True >>> can_form_by_adding_one_char(\\"abc\\", \\"abcdef\\") False >>> can_form_by_adding_one_char(\\"abc\\", \\"abc\\") False >>> can_form_by_adding_one_char(\\"abc\\", \\"abcde\\") False >>> can_form_by_adding_one_char(\\"aabbcc\\", \\"aabbccccc\\") False >>> can_form_by_adding_one_char(\\"aaa\\", \\"aaaa\\") True >>> can_form_by_adding_one_char(\\"zzz\\", \\"yyyy\\") False","solution":"def can_form_by_adding_one_char(s1, s2): Given two strings s1 and s2, check if you can make s2 by rearranging the characters of s1 and adding exactly one extra character. from collections import Counter # Count the characters in both strings count_s1 = Counter(s1) count_s2 = Counter(s2) # Check if s2 has exactly one more character than s1 if len(s1) + 1 != len(s2): return False # Calculate the difference in counts diff = 0 for char in count_s2: if count_s2[char] > count_s1.get(char, 0): diff += count_s2[char] - count_s1.get(char, 0) # If the sum of the differences is exactly one, return True return diff == 1"},{"question":"def minimum_abs_difference(arr): Returns all pairs of elements from a sorted array that have the minimum absolute difference. Parameters: arr (list of int): A sorted list of unique integers in non-decreasing order. Returns: list of list of int: List of pairs with the minimum absolute difference. from solution import minimum_abs_difference def test_example_case(): assert minimum_abs_difference([1, 3, 6, 10, 15]) == [[1, 3]] def test_case_with_multiple_pairs(): assert minimum_abs_difference([1, 2, 3, 4, 5]) == [[1, 2], [2, 3], [3, 4], [4, 5]] def test_case_with_negative_numbers(): assert minimum_abs_difference([-4, -3, -2, 2, 3]) == [[-4, -3], [-3, -2], [2, 3]] def test_case_with_large_difference(): assert minimum_abs_difference([1, 100, 200, 300, 400]) == [[1, 100]] def test_case_with_single_pair(): assert minimum_abs_difference([10, 20]) == [[10, 20]] def test_case_with_one_element(): assert minimum_abs_difference([5]) == [] def test_case_with_empty_array(): assert minimum_abs_difference([]) == []","solution":"def minimum_abs_difference(arr): Returns all pairs of elements from a sorted array that have the minimum absolute difference. Parameters: arr (list of int): A sorted list of unique integers in non-decreasing order. Returns: list of list of int: List of pairs with the minimum absolute difference. min_diff = float('inf') result = [] # Iterate through the array to find the minimum absolute difference for i in range(len(arr) - 1): diff = arr[i+1] - arr[i] if diff < min_diff: min_diff = diff result = [[arr[i], arr[i+1]]] elif diff == min_diff: result.append([arr[i], arr[i+1]]) return result"},{"question":"def find_max_length(nums: List[int]) -> int: Given an array of integers, return the length of the longest contiguous subarray that has an equal number of 1's and -1's. If there are no such subarrays, return 0. The input array only contains 1's and -1's. >>> find_max_length([]) 0 >>> find_max_length([1, 1, 1]) 0 >>> find_max_length([-1, -1, -1]) 0 >>> find_max_length([1, -1]) 2 >>> find_max_length([1, -1, 1, -1, -1, 1]) 6 >>> find_max_length([1, 1, -1, -1, 1, -1, 1, -1]) 8 >>> find_max_length([1, -1, 1, -1, 1, 1, -1, -1, 1, -1]) 10 >>> find_max_length([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) 10","solution":"def find_max_length(nums): Finds the length of the longest contiguous subarray with an equal number of 1's and -1's. :param nums: List[int] :return: int count = 0 max_length = 0 count_map = {0: -1} for i, num in enumerate(nums): if num == 1: count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings of a given string \`s\`. The function should run with a time complexity better than O(n^2), where \`n\` is the length of the string. >>> count_distinct_substrings(\\"a\\") == 1 >>> count_distinct_substrings(\\"aa\\") == 2 >>> count_distinct_substrings(\\"ab\\") == 3","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings of \`s\`. Implemented using a rolling hash and a set to achieve linearithmic time complexity. n = len(s) base = 26 mod = 2**61 - 1 power = [1] * (n + 1) for i in range(1, n + 1): power[i] = (power[i - 1] * base) % mod hashes = set() for length in range(1, n + 1): curr_hash = 0 for i in range(length): curr_hash = (curr_hash * base + (ord(s[i]) - ord('a') + 1)) % mod hashes.add(curr_hash) for i in range(1, n - length + 1): curr_hash = (curr_hash - (ord(s[i - 1]) - ord('a') + 1) * power[length - 1]) % mod curr_hash = (curr_hash * base + (ord(s[i + length - 1]) - ord('a') + 1)) % mod curr_hash = (curr_hash + mod) % mod # ensuring non-negative hash value hashes.add(curr_hash) return len(hashes)"},{"question":"def sum_of_unique_elements(lst: List[int]) -> int: Returns the sum of all unique elements in the list. An element is considered unique if it appears exactly once in the list. >>> sum_of_unique_elements([1, 2, 3, 4, 5]) == 15 >>> sum_of_unique_elements([1, 1, 2, 2, 3, 3]) == 0 >>> sum_of_unique_elements([1, 1, 2, 3, 4, 4, 5]) == 10 >>> sum_of_unique_elements([]) == 0 >>> sum_of_unique_elements([10]) == 10 >>> sum_of_unique_elements([7, 7, 8, 8, 9, 9]) == 0 >>> sum_of_unique_elements([1000000, 2000000, 1000000]) == 2000000","solution":"def sum_of_unique_elements(lst): Returns the sum of all unique elements in the list. An element is considered unique if it appears exactly once in the list. from collections import Counter element_counts = Counter(lst) return sum(element for element, count in element_counts.items() if count == 1)"},{"question":"def max_teams(heights, d): Returns the maximum number of teams that can be formed from the given list of heights where the height difference between students in a team does not exceed d. >>> max_teams([1, 2, 3, 4, 5], 1) == 2 >>> max_teams([1, 3, 5, 7], 1) == 0 >>> max_teams([1, 3, 5, 7], 2) == 2 >>> max_teams([3], 1) == 0 >>> max_teams([], 1) == 0 >>> max_teams([2, 4, 6, 8, 10], 5) == 2 >>> max_teams([1, 2, 2, 3, 3, 4], 1) == 3 >>> max_teams([10, 9, 8, 7, 6, 5], 2) == 3 >>> max_teams([6, 6, 6, 6], 0) == 2 >>> max_teams([1, 10, 20, 30], 1) == 0","solution":"def max_teams(heights, d): Returns the maximum number of teams that can be formed from the given list of heights where the height difference between students in a team does not exceed d. heights.sort() max_teams = 0 i = 0 while i < len(heights) - 1: if heights[i + 1] - heights[i] <= d: max_teams += 1 i += 2 # Both students are used in a team else: i += 1 # Move to the next student return max_teams"},{"question":"def max_indexed_array(nums: List[int]) -> int: Returns the maximum value from the array formed by adding each element to its index. :param nums: List of integers :return: Maximum value from the transformed array >>> max_indexed_array([1, 2, 3, 4, 5]) == 9 >>> max_indexed_array([-1, -2, -3, -4, -5]) == -1 >>> max_indexed_array([-10, 5, -30, 10, 0]) == 13 >>> max_indexed_array([0]) == 0 >>> max_indexed_array([10]) == 10 >>> max_indexed_array([-5]) == -5 >>> max_indexed_array([]) == float('-inf') >>> max_indexed_array([-10, 20, -30, 40, -50]) == 43 >>> max_indexed_array([0, -1, 2, -3, 4, -5]) == 8","solution":"def max_indexed_array(nums): Returns the maximum value from the array formed by adding each element to its index. :param nums: List of integers :return: Maximum value from the transformed array max_value = float('-inf') for i in range(len(nums)): max_value = max(max_value, nums[i] + i) return max_value"},{"question":"from typing import List def count_pairs_with_sum(arr: List[int], k: int) -> int: Return the number of distinct pairs (i, j) where arr[i] + arr[j] == k and i != j. Each pair should be counted only once, regardless of the order of the numbers in the pair. >>> count_pairs_with_sum([1, 1, 2, 2, 3, 3], 4) == 2 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 10) == 0 >>> count_pairs_with_sum([1, 1, 1, 1], 2) == 1 >>> count_pairs_with_sum([0, 2, 4, -2, 6, 8], 6) == 3 >>> count_pairs_with_sum([-1, -1, -2, -2, -3, -3], -4) == 2 >>> count_pairs_with_sum([-1, 1, -2, 2, -3, 3], 0) == 3","solution":"def count_pairs_with_sum(arr, k): Returns the number of distinct pairs (i, j) where arr[i] + arr[j] == k and i != j. Each pair should be counted only once, regardless of the order of the numbers in the pair. seen = set() complements = set() count = 0 for num in arr: complement = k - num if complement in complements: pair = tuple(sorted((num, complement))) if pair not in seen: seen.add(pair) count += 1 complements.add(num) return count"},{"question":"def inorder_traversal(nums): Generates the binary tree T from the nums array and returns its in-order traversal. Args: nums (List[int]): List of unique integers. Returns: List[int]: In-order traversal of the binary tree. pass def test_inorder_traversal_single(): assert inorder_traversal([1]) == [1] def test_inorder_traversal_two(): assert inorder_traversal([1, 2]) == [2, 1] def test_inorder_traversal_three(): assert inorder_traversal([1, 2, 3]) == [2, 1, 3] def test_inorder_traversal_multiple(): assert inorder_traversal([1, 2, 3, 4]) == [4, 2, 1, 3] assert inorder_traversal([1, 2, 3, 4, 5]) == [4, 2, 5, 1, 3] assert inorder_traversal([10, 5, 20, 3, 7]) == [3, 5, 7, 10, 20] def test_inorder_empty(): assert inorder_traversal([]) == []","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_node(root, value): from collections import deque queue = deque([root]) while queue: node = queue.popleft() if node.left is None: node.left = TreeNode(value) break else: queue.append(node.left) if node.right is None: node.right = TreeNode(value) break else: queue.append(node.right) def build_tree(nums): if not nums: return None root = TreeNode(nums[0]) for num in nums[1:]: insert_node(root, num) return root def in_order_traversal(root, result = None): if result is None: result = [] if root is not None: in_order_traversal(root.left, result) result.append(root.value) in_order_traversal(root.right, result) return result def inorder_traversal(nums): Generates the binary tree T from the nums array and returns its in-order traversal. Args: nums (List[int]): List of unique integers. Returns: List[int]: In-order traversal of the binary tree. root = build_tree(nums) return in_order_traversal(root)"},{"question":"from typing import List def find_longest_word(s: str, dictionary: List[str]) -> str: You are given a string \`s\` that consists of only digits and a list of strings \`dictionary\` that contains a collection of non-empty words. Find the word from the dictionary such that after deleting some digits from the string \`s\`, it forms the chosen word. You need to find the longest such word. If there is more than one possible word with the same length, choose the one that comes first in lexicographical order. Return the longest word from the dictionary that can be formed, or an empty string if no valid word can be formed. >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) == \\"apple\\" >>> find_longest_word(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" >>> find_longest_word(\\"xyz\\", [\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"\\" >>> find_longest_word(\\"123\\", [\\"al\\", \\"be\\", \\"ce\\"]) == \\"\\" >>> find_longest_word(\\"a\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"a\\" >>> find_longest_word(\\"b\\", [\\"a\\", \\"b\\", \\"c\\"]) == \\"b\\" >>> find_longest_word(\\"bab\\", [\\"ba\\", \\"ab\\", \\"a\\"]) == \\"ab\\" >>> find_longest_word(\\"abpcplea\\", [\\"ale\\", \\"monkey\\", \\"plea\\"]) == \\"plea\\" >>> find_longest_word(\\"abc\\", []) == \\"\\"","solution":"def find_longest_word(s, dictionary): def is_subsequence(word): it = iter(s) return all(c in it for c in word) longest_word = \\"\\" for word in dictionary: if is_subsequence(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"from collections import deque from typing import List def shortestPath(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left cell to the bottom-right cell that contains only 1s. If no such path exists, return -1. >>> shortestPath([ ... [1, 1], ... [1, 1] ... ]) 3 >>> shortestPath([ ... [1, 0, 1], ... [1, 1, 1], ... [0, 0, 1] ... ]) 5 >>> shortestPath([ ... [1, 0, 0], ... [0, 0, 1], ... [1, 1, 1] ... ]) -1 >>> shortestPath([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) -1 >>> shortestPath([ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) -1 >>> shortestPath([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) -1 >>> shortestPath([ ... [1, 0, 1, 1, 1], ... [1, 1, 0, 0, 1], ... [1, 1, 1, 1, 1], ... [0, 1, 0, 0, 0], ... [1, 1, 1, 1, 1] ... ]) 9 >>> shortestPath([ ... [1, 0, 0, 0, 0], ... [0, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 0], ... [0, 0, 0, 0, 1] ... ]) -1","solution":"from collections import deque def shortestPath(grid): Returns the length of the shortest path from the top-left cell to the bottom-right cell that contains only 1s. If no such path exists, return -1. if not grid or grid[0][0] == 0 or grid[-1][-1] == 0: return -1 rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) # (row, col, path_length) visited = set([(0, 0)]) while queue: row, col, path_length = queue.popleft() if row == rows - 1 and col == cols - 1: return path_length for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1 and (new_row, new_col) not in visited: visited.add((new_row, new_col)) queue.append((new_row, new_col, path_length + 1)) return -1"},{"question":"def find_min_flights(flights, n, source): Function to determine the smallest number of flights required to reach each city from the source city. :param flights: List[List[int]] - list of flights represented as pairs of cities [from, to] :param n: int - number of cities :param source: int - the source city :return: List[int] - a list where the i-th index represents the minimum flights needed to reach city i from the source city pass # Test cases def test_find_min_flights_basic(): flights = [[0, 1], [1, 2], [2, 3]] n = 4 source = 0 assert find_min_flights(flights, n, source) == [0, 1, 2, 3] def test_find_min_flights_with_unreachable_cities(): flights = [[0, 1], [1, 2]] n = 4 source = 0 assert find_min_flights(flights, n, source) == [0, 1, 2, -1] def test_find_min_flights_multiple_paths(): flights = [[0, 1], [1, 2], [0, 2]] n = 3 source = 0 assert find_min_flights(flights, n, source) == [0, 1, 1] def test_find_min_flights_disconnected_graph(): flights = [[1, 2], [2, 3]] n = 5 source = 0 assert find_min_flights(flights, n, source) == [0, -1, -1, -1, -1] def test_find_min_flights_single_city(): flights = [] n = 1 source = 0 assert find_min_flights(flights, n, source) == [0]","solution":"from collections import deque, defaultdict def find_min_flights(flights, n, source): Function to determine the smallest number of flights required to reach each city from the source city. :param flights: List[List[int]] - list of flights represented as pairs of cities [from, to] :param n: int - number of cities :param source: int - the source city :return: List[int] - a list where the i-th index represents the minimum flights needed to reach city i from the source city # Create the graph graph = defaultdict(list) for frm, to in flights: graph[frm].append(to) # Initialize distances with -1 min_flights = [-1] * n min_flights[source] = 0 # BFS to find shortest path queue = deque([source]) while queue: city = queue.popleft() for neighbour in graph[city]: if min_flights[neighbour] == -1: # if the city hasn't been visited yet min_flights[neighbour] = min_flights[city] + 1 queue.append(neighbour) return min_flights"},{"question":"from typing import List def max_strictly_increasing_subarray_length(arr: List[int], x: int) -> int: Finds the maximum length of strictly increasing subarray after replacing each element in one chosen subarray with the minimal value of that subarray. :param arr: List of integers, the array. :param x: integer, a parameter not used in this solution. :return: integer, the maximum length of strictly increasing subarray. ... from solution import max_strictly_increasing_subarray_length def test_max_strictly_increasing_subarray_length_all_increasing(): assert max_strictly_increasing_subarray_length([1, 2, 3, 4, 5], 2) == 5 def test_max_strictly_increasing_subarray_length_all_decreasing(): assert max_strictly_increasing_subarray_length([5, 4, 3, 2, 1], 2) == 1 def test_max_strictly_increasing_subarray_length_mixed(): assert max_strictly_increasing_subarray_length([3, 4, 2, 1, 5], 2) == 2 def test_max_strictly_increasing_subarray_length_one_element(): assert max_strictly_increasing_subarray_length([10], 2) == 1 def test_max_strictly_increasing_subarray_length_two_elements_increasing(): assert max_strictly_increasing_subarray_length([1, 2], 2) == 2 def test_max_strictly_increasing_subarray_length_two_elements_decreasing(): assert max_strictly_increasing_subarray_length([2, 1], 2) == 1 def test_max_strictly_increasing_subarray_length_multiple_subarrays(): assert max_strictly_increasing_subarray_length([1, 2, 1, 2, 3], 2) == 3 def test_max_strictly_increasing_subarray_length_with_constant_subarray(): assert max_strictly_increasing_subarray_length([1, 2, 2, 3, 4], 2) == 3","solution":"def max_strictly_increasing_subarray_length(arr, x): Finds the maximum length of strictly increasing subarray after replacing each element in one chosen subarray with the minimal value of that subarray. :param arr: List of integers, the array. :param x: integer, not used in this solution. :return: integer, the maximum length of strictly increasing subarray. n = len(arr) # Initialize the lengths of the current subarray and the maximum length found current_length = 1 max_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def maxSubarraySum(nums: List[int], k: int) -> int: Returns the maximum sum of any subarray of size k. >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 3) 9 >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 2) 6 >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 1) 5 >>> maxSubarraySum([2, 1, 5, 1, 3, 2], 6) 14 >>> maxSubarraySum([], 3) 0 >>> maxSubarraySum([1, 2], 3) 0 >>> maxSubarraySum([1, 2, 3], 0) 0","solution":"def maxSubarraySum(nums, k): Returns the maximum sum of any subarray of size k. Parameters: nums (List[int]): List of integers k (int): Size of subarray Returns: int: Maximum sum of subarray of size k if not nums or k <= 0 or k > len(nums): return 0 # Compute the sum of the first window max_sum = sum(nums[:k]) current_sum = max_sum # Slide the window across the list while updating sums for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class Solution: def __init__(self, nums): Initializes the object with the number of balloons in each pile. :param nums: List[int] - list of the number of balloons in each pile self.nums = nums def minBursts(self): Returns the minimum number of seconds required to burst all the balloons. :return: int - minimum number of seconds required to burst all balloons pass # Unit tests from solution import Solution def test_single_pile(): solution = Solution([3]) assert solution.minBursts() == 1 def test_multiple_piles(): solution = Solution([3, 1, 4]) assert solution.minBursts() == 3 def test_no_balloons(): solution = Solution([]) assert solution.minBursts() == 0 def test_piles_with_one_balloon_each(): solution = Solution([1, 1, 1, 1]) assert solution.minBursts() == 4 def test_large_number_of_piles(): solution = Solution([1] * 1000) assert solution.minBursts() == 1000 def test_mixed_piles(): solution = Solution([1, 4, 2, 6, 5]) assert solution.minBursts() == 5","solution":"class Solution: def __init__(self, nums): Initializes the object with the number of balloons in each pile. :param nums: List[int] - list of the number of balloons in each pile self.nums = nums def minBursts(self): Returns the minimum number of seconds required to burst all the balloons. :return: int - minimum number of seconds required to burst all balloons # Each pile can be burst in 1 second return len(self.nums)"},{"question":"def longest_consecutive(nums: List[int]) -> int: Finds the length of the longest consecutive elements sequence. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive([]) 0 >>> longest_consecutive([1, 2, 0, 1]) 3 >>> longest_consecutive([5]) 1 >>> longest_consecutive([10, 20]) 1 >>> longest_consecutive([1, 2]) 2 >>> longest_consecutive(list(range(1000000))) 1000000 >>> longest_consecutive([1, 9, 3, 10, 2, 20, 4, 11]) 4","solution":"def longest_consecutive(nums): Finds the length of the longest consecutive elements sequence. Args: nums: List of integers. Returns: Length of the longest consecutive elements sequence. num_set = set(nums) longest_sequence = 0 for num in num_set: if num - 1 not in num_set: # only check starting points current_num = num current_sequence = 1 while current_num + 1 in num_set: current_num += 1 current_sequence += 1 longest_sequence = max(longest_sequence, current_sequence) return longest_sequence"},{"question":"def findWords(board: List[List[str]], words: List[str]) -> List[str]: Given a \`m x n\` board of characters and a list of strings \`words\`, find all the words on the board that are constructed from sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word on the board. Args: board: List[List[str]] -- 2D board of characters words: List[str] -- List of words to be found on the board Returns: List[str] -- List of words found on the board Example: >>> board = [['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v']] >>> words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] >>> findWords(board, words) [\\"oath\\",\\"eat\\"]","solution":"class TrieNode: def __init__(self): self.children = {} self.end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.end_of_word = True def findWords(board, words): def dfs(node, i, j, path, res): if node.end_of_word: res.add(path) node.end_of_word = False # to avoid duplicate entries if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]): return if board[i][j] not in node.children: return char = board[i][j] board[i][j] = \\"#\\" # mark the cell as visited next_node = node.children[char] dfs(next_node, i+1, j, path+char, res) dfs(next_node, i-1, j, path+char, res) dfs(next_node, i, j+1, path+char, res) dfs(next_node, i, j-1, path+char, res) board[i][j] = char # unmark the cell trie = Trie() for word in words: trie.insert(word) res = set() for i in range(len(board)): for j in range(len(board[0])): dfs(trie.root, i, j, \\"\\", res) return list(res)"},{"question":"def decode_string(s: str) -> str: Given a string \`s\`, decode it based on the specified rules. The characters are either lowercase letters, numeric values, or brackets. - Lowercase letters are added to the result as they are. - Numerical values indicate the repetition count of the sequence enclosed in brackets. - Brackets are used to define the sequence to be repeated. For instance: >>> decode_string(\\"3[a]\\") == \\"aaa\\" >>> decode_string(\\"3[a2[bc]]\\") == \\"abcbcabcbcabcbc\\" >>> decode_string(\\"2[abc3[cd]ef]\\") == \\"abccdcdcdefabccdcdcdef\\" >>> decode_string(\\"xyz\\") == \\"xyz\\" >>> decode_string(\\"3[ab]4[c]\\") == \\"abababcccc\\" >>> decode_string(\\"2[a3[b2[c]]]d\\") == \\"abccbccbccabccbccbccd\\"","solution":"def decode_string(s: str) -> str: def decode_segment(segment: str) -> str: stack = [] current_num = 0 current_str = \\"\\" for char in segment: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == '[': stack.append((current_str, current_num)) current_num = 0 current_str = \\"\\" elif char == ']': prev_str, num = stack.pop() current_str = prev_str + current_str * num else: current_str += char return current_str return decode_segment(s)"},{"question":"from typing import List def rotate(image: List[List[int]]) -> None: Given an \`n x n\` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. Example: >>> image = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(image) >>> image [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> image = [ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate(image) >>> image [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]]","solution":"from typing import List def rotate(image: List[List[int]]) -> None: Rotates the matrix (image) by 90 degrees clockwise. Modifies the input matrix in-place. n = len(image) # Transpose the matrix for i in range(n): for j in range(i, n): image[i][j], image[j][i] = image[j][i], image[i][j] # Reverse each row for i in range(n): image[i].reverse()"},{"question":"def most_frequent_kgram(word: str, k: int) -> str: Returns the most frequent k-gram in the given word. If there are multiple with the same frequency, returns the lexicographically smallest one. If \`word\` is shorter than or equal to \`k\`, returns \`word\`. >>> most_frequent_kgram(\\"apple\\", 10) == \\"apple\\" >>> most_frequent_kgram(\\"banana\\", 6) == \\"banana\\" >>> most_frequent_kgram(\\"ababcabababc\\", 2) == \\"ab\\" >>> most_frequent_kgram(\\"aaabbbccc\\", 3) == \\"aaa\\" >>> most_frequent_kgram(\\"a\\", 1) == \\"a\\" >>> most_frequent_kgram(\\"aabacabaa\\", 2) == \\"aa\\" >>> most_frequent_kgram(\\"\\", 2) == \\"\\" >>> most_frequent_kgram(\\"anyword\\", 0) == \\"\\"","solution":"def most_frequent_kgram(word, k): Returns the most frequent k-gram in the given word. If there are multiple with the same frequency, returns the lexicographically smallest one. If \`word\` is shorter than or equal to \`k\`, returns \`word\`. if len(word) <= k: return word kgram_freq = {} # Create a frequency dictionary for all k-grams for i in range(len(word) - k + 1): kgram = word[i:i+k] if kgram in kgram_freq: kgram_freq[kgram] += 1 else: kgram_freq[kgram] = 1 # Find the most frequent k-gram, breaking ties lexicographically most_frequent_kgram = min(sorted(kgram_freq), key=lambda x: (-kgram_freq[x], x)) return most_frequent_kgram"},{"question":"def subset_sum_to_k(arr: List[int], k: int) -> bool: Determines if there exists a subset of the array 'arr' whose sum is equal to 'k'. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: bool: True if a subset with sum 'k' exists, False otherwise. >>> subset_sum_to_k([1, 2, 3, 4, 5], 9) True >>> subset_sum_to_k([3, 34, 4, 12, 5, 2], 30) False >>> subset_sum_to_k([], 0) True","solution":"def subset_sum_to_k(arr, k): Determines if there exists a subset of the array 'arr' whose sum is equal to 'k'. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: bool: True if a subset with sum 'k' exists, False otherwise. n = len(arr) # dp[i][j] will be True if there is a subset of the first i items with a sum equal to j. dp = [[False] * (k + 1) for _ in range(n + 1)] # A sum of 0 can always be achieved with an empty subset for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, k + 1): if j < arr[i-1]: dp[i][j] = dp[i-1][j] else: dp[i][j] = dp[i-1][j] or dp[i-1][j - arr[i-1]] return dp[n][k]"},{"question":"from typing import List def minimize_max_subarray_sum_difference(arr: List[int], m: int) -> int: Given a list of non-negative integers \`arr\` and an integer \`m\`, partition the list into \`m\` non-empty contiguous subarrays such that the difference between the largest sum of any subarray and the smallest sum of any subarray is minimized. Return the minimum difference. >>> minimize_max_subarray_sum_difference([7, 2, 5, 10, 8], 2) 18 >>> minimize_max_subarray_sum_difference([1, 2, 3, 4, 5], 2) 9 >>> minimize_max_subarray_sum_difference([1, 4, 4], 3) 4 >>> minimize_max_subarray_sum_difference([10], 1) 10 >>> minimize_max_subarray_sum_difference([5, 5, 5, 5, 5], 2) 15 >>> minimize_max_subarray_sum_difference([1, 1, 1, 1, 1], 5) 1","solution":"def can_partition(arr, m, max_sum): Helper function to check if the array can be partitioned into m subarrays with the given max_sum or not. current_sum = 0 count = 1 # Starting with one subarray for num in arr: if current_sum + num > max_sum: count += 1 current_sum = num if count > m: return False else: current_sum += num return True def minimize_max_subarray_sum_difference(arr, m): Function to partition the array into m subarrays such that the difference between the largest sum of any subarray and the smallest sum of any subarray is minimized. left = max(arr) right = sum(arr) while left < right: mid = (left + right) // 2 if can_partition(arr, m, mid): right = mid else: left = mid + 1 return left"},{"question":"def min_swaps_to_transform(start: str, goal: str) -> int: Returns the minimum number of swaps required to transform 'start' into 'goal'. If it is impossible, return -1. Examples: >>> min_swaps_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_swaps_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_swaps_to_transform(\\"abcdef\\", \\"fedcba\\") 3 >>> min_swaps_to_transform(\\"abc\\", \\"def\\") -1 >>> min_swaps_to_transform(\\"aabb\\", \\"abab\\") 1 >>> min_swaps_to_transform(\\"aabbcc\\", \\"aabbc\\") -1","solution":"def min_swaps_to_transform(start, goal): Returns the minimum number of swaps required to transform 'start' into 'goal'. If it is impossible, return -1. if sorted(start) != sorted(goal): return -1 def count_swaps(s1, s2): swaps = 0 s1, s2 = list(s1), list(s2) for i in range(len(s1)): if s1[i] != s2[i]: swap_index = s1.index(s2[i], i) s1[i], s1[swap_index] = s1[swap_index], s1[i] swaps += 1 return swaps return count_swaps(start, goal)"},{"question":"def max_jumps(arr: List[int], d: int) -> int: Compute the maximum number of indices you can visit following the jumping rules. >>> max_jumps([6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2) == 4 >>> max_jumps([1], 1) == 1 >>> max_jumps([3, 3, 3, 3, 3], 1) == 1 >>> max_jumps([3, 2, 1, 6, 5, 4], 2) == 3 >>> max_jumps([3, 2, 1, 5, 4], 3) == 4 >>> max_jumps([1, 2, 3, 4, 5], 4) == 5 >>> max_jumps([1, 3, 2, 5, 4], 2) == 3","solution":"def max_jumps(arr, d): def dfs(i, dp): if dp[i] != -1: return dp[i] max_reach = 1 for direction in [-1, 1]: for j in range(1, d + 1): new_index = i + direction * j if new_index < 0 or new_index >= len(arr) or arr[new_index] >= arr[i]: break max_reach = max(max_reach, 1 + dfs(new_index, dp)) dp[i] = max_reach return dp[i] n = len(arr) dp = [-1] * n return max(dfs(i, dp) for i in range(n))"},{"question":"import heapq class BankQueue: def __init__(self): Initializes the queue with no customers. self.queue = [] self.timestamp = 0 def addCustomer(self, id: int, serviceTime: int): Adds a new customer with the given \`id\` and \`serviceTime\` to the queue. Args: id (int): The unique ID of the customer. serviceTime (int): The service time duration for the customer. heapq.heappush(self.queue, (serviceTime, self.timestamp, id)) self.timestamp += 1 def serveNextCustomer(self) -> int: Simulates serving the next customer. Returns the \`id\` of the served customer. If no customers are waiting, returns \`-1\`. Returns: int: The \`id\` of the served customer. if not self.queue: return -1 next_customer = heapq.heappop(self.queue) return next_customer[2] def nextServingTime(self) -> int: Returns the service time of the next customer to be served. If no customers are waiting, returns \`-1\`. Returns: int: The service time of the next customer. if not self.queue: return -1 next_customer = self.queue[0] return next_customer[0] from solution import BankQueue def test_empty_queue(): bq = BankQueue() assert bq.serveNextCustomer() == -1 assert bq.nextServingTime() == -1 def test_single_customer_queue(): bq = BankQueue() bq.addCustomer(1, 10) assert bq.nextServingTime() == 10 assert bq.serveNextCustomer() == 1 assert bq.nextServingTime() == -1 assert bq.serveNextCustomer() == -1 def test_multiple_customers(): bq = BankQueue() bq.addCustomer(1, 10) bq.addCustomer(2, 5) assert bq.nextServingTime() == 5 assert bq.serveNextCustomer() == 2 assert bq.nextServingTime() == 10 assert bq.serveNextCustomer() == 1 assert bq.nextServingTime() == -1 assert bq.serveNextCustomer() == -1 def test_priority_with_same_service_time(): bq = BankQueue() bq.addCustomer(1, 10) bq.addCustomer(2, 10) assert bq.nextServingTime() == 10 assert bq.serveNextCustomer() == 1 # Customer 1 was added first assert bq.nextServingTime() == 10 assert bq.serveNextCustomer() == 2 assert bq.nextServingTime() == -1 assert bq.serveNextCustomer() == -1","solution":"import heapq class BankQueue: def __init__(self): self.queue = [] self.timestamp = 0 def addCustomer(self, id, serviceTime): heapq.heappush(self.queue, (serviceTime, self.timestamp, id)) self.timestamp += 1 def serveNextCustomer(self): if not self.queue: return -1 next_customer = heapq.heappop(self.queue) return next_customer[2] def nextServingTime(self): if not self.queue: return -1 next_customer = self.queue[0] return next_customer[0]"},{"question":"from typing import List def max_length_of_concatenated_keys(words: List[str], k: int) -> int: Returns the length of the longest concatenation of any k keys from the array such that each key in the concatenation has unique characters and no two keys have any common characters. >>> max_length_of_concatenated_keys([\\"abc\\", \\"def\\", \\"ghi\\"], 2) 6 >>> max_length_of_concatenated_keys([\\"abc\\", \\"bcd\\", \\"cde\\"], 2) 0 >>> max_length_of_concatenated_keys([\\"a\\", \\"b\\", \\"c\\", \\"d\\"], 3) 3 >>> max_length_of_concatenated_keys([\\"abcdef\\"], 1) 6 >>> max_length_of_concatenated_keys([], 2) 0 >>> max_length_of_concatenated_keys([\\"abcdef\\", \\"ghijkl\\", \\"mnopqr\\", \\"stuvwx\\", \\"yz\\"], 3) 18","solution":"from itertools import combinations def max_length_of_concatenated_keys(words, k): Returns the length of the longest concatenation of any k keys from the array such that each key in the concatenation has unique characters and no two keys have any common characters. def has_unique_characters(s): Check if all characters in the string are unique. return len(s) == len(set(s)) def can_concatenate(s1, s2): Check if two strings have no common characters. return set(s1).isdisjoint(set(s2)) valid_combinations = [] for word_list in combinations(words, k): concatenated = \\"\\".join(word_list) if all(has_unique_characters(word) for word in word_list): if all(can_concatenate(word_list[i], word_list[j]) for i in range(len(word_list)) for j in range(i + 1, len(word_list))): valid_combinations.append(concatenated) return max(len(combo) for combo in valid_combinations) if valid_combinations else 0"},{"question":"from typing import List def max_soldiers_in_row(grid: List[List[int]]) -> int: Given a matrix of integers \`grid\` representing a battlefield, where \`grid[i][j]\` can be: - \`1\` - representing a soldier of your army, - \`0\` - representing empty land, and - \`-1\` - representing an obstacle. Returns the maximum number of non-adjacent soldiers that can be placed in a single row of the battlefield. >>> max_soldiers_in_row([ [1, 1, 1, 1], [1, 1, 1, 1] ]) 2 >>> max_soldiers_in_row([ [1, 0, 1, 0], [0, -1, 1, 1] ]) 2 >>> max_soldiers_in_row([ [0, 0, 0, 0], [-1, -1, 0, 0] ]) 0 >>> max_soldiers_in_row([ [1, 0, 0, 0] ]) 1 >>> max_soldiers_in_row([ [] ]) 0 >>> max_soldiers_in_row([ [1, -1, 1, 0], [0, 1, -1, 1] ]) 2","solution":"def max_soldiers_in_row(grid): Returns the maximum number of non-adjacent soldiers that can be placed in a single row of the battlefield. max_soldiers = 0 for row in grid: dp = [0] * (len(row) + 1) for i in range(1, len(row) + 1): if row[i - 1] == 1: dp[i] = max(dp[i - 1], (dp[i - 2] + 1 if i - 2 >= 0 else 1)) else: dp[i] = dp[i - 1] max_soldiers = max(max_soldiers, dp[-1]) return max_soldiers"},{"question":"def checkValidString(s: str) -> bool: Return true if s could be a valid string containing only three types of characters: '(', ')', and '*'. A string is considered valid if: - Any left parenthesis '(' must have a matching right parenthesis ')'. - Any right parenthesis ')' must have a matching left parenthesis '('. - Left parenthesis '(' must go before the corresponding right parenthesis ')'. - '*' can be treated as a single right parenthesis ')', a single left parenthesis '(', or an empty string. >>> checkValidString(\\"()\\") == True >>> checkValidString(\\"*\\") == True >>> checkValidString(\\"(*)\\") == True >>> checkValidString(\\"(*))\\") == True >>> checkValidString(\\"((**))\\") == True >>> checkValidString(\\"((()\\") == False >>> checkValidString(\\"())\\") == False >>> checkValidString(\\"\\") == True","solution":"def checkValidString(s): left_min = left_max = 0 for char in s: if char == '(': left_min += 1 left_max += 1 elif char == ')': left_min = max(left_min - 1, 0) left_max -= 1 else: # char == '*' left_min = max(left_min - 1, 0) left_max += 1 if left_max < 0: return False return left_min == 0"},{"question":"def sort_versions(version_list: List[str]) -> List[str]: Sorts a list of version numbers in ascending order. >>> sort_versions([\\"1.0.0\\", \\"1.0.1\\", \\"1.0.2\\"]) == [\\"1.0.0\\", \\"1.0.1\\", \\"1.0.2\\"] >>> sort_versions([\\"2.0.1\\", \\"1.1.5\\", \\"1.10.2\\", \\"1.1.4\\"]) == [\\"1.1.4\\", \\"1.1.5\\", \\"1.10.2\\", \\"2.0.1\\"] >>> sort_versions([\\"2.0.1\\", \\"2.0.0\\", \\"2.1.0\\"]) == [\\"2.0.0\\", \\"2.0.1\\", \\"2.1.0\\"] >>> sort_versions([\\"1.2.3\\", \\"1.2.2\\", \\"1.2.4\\"]) == [\\"1.2.2\\", \\"1.2.3\\", \\"1.2.4\\"] >>> sort_versions([\\"1.2.3\\", \\"1.3.3\\", \\"1.1.3\\"]) == [\\"1.1.3\\", \\"1.2.3\\", \\"1.3.3\\"] >>> sort_versions([\\"1.0.0\\", \\"1.0.1\\", \\"1.0.2\\", \\"1.0.1\\"]) == [\\"1.0.0\\", \\"1.0.1\\", \\"1.0.1\\", \\"1.0.2\\"]","solution":"def sort_versions(version_list): Sorts a list of version numbers in ascending order. Parameters: - version_list (list of str): list of version numbers represented as strings in the format \\"x.y.z\\" Returns: - list of str: sorted list of version numbers return sorted(version_list, key=lambda v: tuple(map(int, v.split('.'))))"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Determine the maximum weight of any path in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, maximum weight of any path >>> root = TreeNode(5) >>> max_path_sum(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> max_path_sum(root) 3 >>> root = TreeNode(-3) >>> max_path_sum(root) -3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> max_path_sum(root) 6 >>> root = TreeNode(-10) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> max_path_sum(root) 42 >>> root = TreeNode(-1) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(-3) >>> max_path_sum(root) -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum weight of any path in the binary tree. :param root: TreeNode, the root of the binary tree :return: int, maximum weight of any path def helper(node): nonlocal max_sum if not node: return 0 left_sum = max(helper(node.left), 0) # max gain if we include left subtree right_sum = max(helper(node.right), 0) # max gain if we include right subtree # max path sum including the current node current_path_sum = node.val + left_sum + right_sum # update global max_sum max_sum = max(max_sum, current_path_sum) # return max gain if we continue the same path including the current node return node.val + max(left_sum, right_sum) max_sum = float('-inf') helper(root) return max_sum"},{"question":"def find_buildings_with_ocean_view(heights: List[int]) -> List[int]: Returns a list of indices representing buildings that can see the ocean. Args: heights (List[int]): List of building heights. Returns: List[int]: List of indices of buildings that can see the ocean. >>> find_buildings_with_ocean_view([10]) [0] >>> find_buildings_with_ocean_view([4, 4, 4, 4]) [0] >>> find_buildings_with_ocean_view([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> find_buildings_with_ocean_view([5, 4, 3, 2, 1]) [0] >>> find_buildings_with_ocean_view([1, 3, 2, 4, 2, 5, 1]) [0, 1, 3, 5] >>> find_buildings_with_ocean_view([1, 2, 2, 2, 3]) [0, 1, 4] >>> find_buildings_with_ocean_view([]) []","solution":"def find_buildings_with_ocean_view(heights): Returns a list of indices representing buildings that can see the ocean. Args: heights (List[int]): List of building heights. Returns: List[int]: List of indices of buildings that can see the ocean. result = [] max_height = 0 for index, height in enumerate(heights): if height > max_height: result.append(index) max_height = height return result"},{"question":"def find_peak_element(arr: List[int]) -> int: Returns the index of any peak element in the array. A peak element is greater than its neighbors. If the element is at the start or end, it only needs to be greater than its single neighbor. Uses a binary search approach to achieve better than O(n) time complexity. Parameters: arr (list): A list of positive integers Returns: int: The index of any peak element >>> find_peak_element([1, 3, 2]) == 1 >>> find_peak_element([10, 5, 3, 2, 1]) == 0 >>> find_peak_element([1, 2, 3, 4, 5]) == 4","solution":"def find_peak_element(arr): Returns the index of any peak element in the array. A peak element is greater than its neighbors. If the element is at the start or end, it only needs to be greater than its single neighbor. Uses a binary search approach to achieve better than O(n) time complexity. Parameters: arr (list): A list of positive integers Returns: int: The index of any peak element left, right = 0, len(arr) - 1 while left < right: mid = (left + right) // 2 if arr[mid] > arr[mid + 1]: right = mid else: left = mid + 1 return left"},{"question":"from typing import List def least_interval(tasks: List[str], n: int) -> int: Returns the least number of intervals needed to complete all tasks with a cooling period of n. >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 2) 8 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'C', 'D'], 2) 7 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B'], 0) 6 >>> least_interval(['A'], 2) 1 >>> least_interval(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'D', 'D', 'E'], 2) 11 pass","solution":"from collections import Counter def least_interval(tasks, n): Returns the least number of intervals needed to complete all tasks with a cooling period of n. task_counts = Counter(tasks) max_task_count = max(task_counts.values()) tasks_with_max_count = list(task_counts.values()).count(max_task_count) min_intervals = (max_task_count - 1) * (n + 1) + tasks_with_max_count return max(min_intervals, len(tasks))"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Find the length of the longest substring that contains exactly k distinct characters. >>> longest_substring_with_k_distinct(\\"abc\\", 0) == -1 >>> longest_substring_with_k_distinct(\\"\\", 1) == -1 >>> longest_substring_with_k_distinct(\\"aabbcc\\", 2) == 4 >>> longest_substring_with_k_distinct(\\"aabbcc\\", 3) == 6 >>> longest_substring_with_k_distinct(\\"a\\", 1) == 1 >>> longest_substring_with_k_distinct(\\"aaaa\\", 1) == 4 >>> longest_substring_with_k_distinct(\\"eceba\\", 2) == 3 >>> longest_substring_with_k_distinct(\\"aaabbaccc\\", 2) == 6 >>> longest_substring_with_k_distinct(\\"aaabbaccc\\", 3) == 9 >>> longest_substring_with_k_distinct(\\"abc\\", 4) == -1 >>> longest_substring_with_k_distinct(\\"aaaa\\", 2) == -1 >>> longest_substring_with_k_distinct(\\"abaccc\\", 1) == 3 >>> longest_substring_with_k_distinct(\\"abaccc\\", 2) == 4 >>> longest_substring_with_k_distinct(\\"abaccc\\", 3) == 6","solution":"def longest_substring_with_k_distinct(s, k): Finds the length of the longest substring that contains exactly k distinct characters. Parameters: s (str): The input string consisting of lowercase English letters. k (int): The number of distinct characters required. Returns: int: The length of the longest substring with exactly k distinct characters, or -1 if there is no such substring. if k == 0: return -1 n = len(s) max_length = -1 char_count = {} left = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == k: max_length = max(max_length, right - left + 1) return max_length"},{"question":"def splitArray(arr: List[int], k: int) -> List[List[int]]: Divide the array into exactly \`k\` non-empty contiguous subarrays such that the maximum sum of all subarrays is minimized. >>> splitArray([7, 2, 5, 10, 8], 2) [[7, 2, 5], [10, 8]] >>> splitArray([1, 2, 3, 4, 5], 2) [[1, 2, 3], [4, 5]]","solution":"def splitArray(arr, k): def canSplit(mid): current_sum = 0 subarrays = 1 for num in arr: if current_sum + num > mid: subarrays += 1 current_sum = num if subarrays > k: return False else: current_sum += num return True def findMinimizedMaxSum(): left, right = max(arr), sum(arr) while left < right: mid = (left + right) // 2 if canSplit(mid): right = mid else: left = mid + 1 return left minimized_max_sum = findMinimizedMaxSum() result = [] current_sum, current_partition = 0, [] for num in arr: if current_sum + num > minimized_max_sum: result.append(current_partition) current_partition = [num] current_sum = num else: current_partition.append(num) current_sum += num if current_partition: result.append(current_partition) return result"},{"question":"def max_satisfied_employees(bags: List[int], preferences: List[List[int]]) -> int: Calculate the maximum number of employees who can receive a gift bag they prefer based on available bags and their preferences. >>> max_satisfied_employees([1, 1, 1], [[0, 1], [1, 2], [0, 2], [2]]) 3 >>> max_satisfied_employees([1, 2], [[0], [1], [0, 1], [1]]) 3 >>> max_satisfied_employees([0, 2, 1], [[0, 1], [1, 2], [0, 2], [2]]) 3 >>> max_satisfied_employees([1, 1], [[0], [0, 1], [0, 1], [1]]) 2 >>> max_satisfied_employees([2, 1, 2], [[2], [0, 2], [1, 2], [0, 1, 2], [1], [2]]) 5 >>> max_satisfied_employees([1], [[0], [0], [0], [0]]) 1 >>> max_satisfied_employees([0, 0, 0], [[0, 1, 2], [1, 2], [0, 2], [2]]) 0","solution":"def max_satisfied_employees(bags, preferences): n = len(preferences) m = len(bags) # Preference to employee list mapping pref_to_emp = [[] for _ in range(m)] for emp, prefs in enumerate(preferences): for bag in prefs: pref_to_emp[bag].append(emp) satisfied = 0 assigned = [False] * n for bag_type, employees in enumerate(pref_to_emp): available_bags = bags[bag_type] for emp in employees: if available_bags > 0 and not assigned[emp]: assigned[emp] = True satisfied += 1 available_bags -= 1 if available_bags == 0: break return satisfied"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root: TreeNode) -> None: Flattens the binary tree into a linked list in-place. For example, given the following tree: 1 / 2 5 / 3 4 6 The flattened tree should look like: 1 2 3 4 5 6 def tree_to_list(root): Helper function to convert the flattened tree to list representation for easy testing. result = [] while root: result.append(root.val) root = root.right return result def test_flatten(): # Test case 1: Example provided in the question root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(5, right=TreeNode(6))) flatten(root) assert tree_to_list(root) == [1, 2, 3, 4, 5, 6] # Test case 2: Single node root = TreeNode(1) flatten(root) assert tree_to_list(root) == [1] # Test case 3: Empty tree root = None flatten(root) assert tree_to_list(root) == [] # Test case 4: Left skewed tree root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) flatten(root) assert tree_to_list(root) == [1, 2, 3, 4] # Test case 5: Right skewed tree root = TreeNode(1, right=TreeNode(2, right=TreeNode(3, right=TreeNode(4)))) flatten(root) assert tree_to_list(root) == [1, 2, 3, 4]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def flatten(root: TreeNode) -> None: Flattens the binary tree into a linked list in-place. # Helper function to perform pre-order traversal and re-link nodes def flatten_tree(node): if not node: return None left_tail = flatten_tree(node.left) right_tail = flatten_tree(node.right) if node.left: if left_tail: left_tail.right = node.right node.right = node.left node.left = None return right_tail or left_tail or node flatten_tree(root)"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in string s. >>> longest_palindromic_subsequence('') == 0 >>> longest_palindromic_subsequence('a') == 1 >>> longest_palindromic_subsequence('aa') == 2 >>> longest_palindromic_subsequence('abc') == 1 >>> longest_palindromic_subsequence('bbbab') == 4 >>> longest_palindromic_subsequence('cbbd') == 2 >>> longest_palindromic_subsequence('agbdba') == 5 >>> longest_palindromic_subsequence('abccba') == 6 >>> longest_palindromic_subsequence('aaabaaa') == 7","solution":"def longest_palindromic_subsequence(s): Returns the length of the longest palindromic subsequence in string s. n = len(s) if n == 0: return 0 # Create a 2D array to store lengths of palindromic subsequences dp = [[0] * n for _ in range(n)] # All substrings of length 1 are palindromes of length 1 for i in range(n): dp[i][i] = 1 # Check for subsequences of length 2 to n for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of the longest palindromic subsequence return dp[0][n - 1]"},{"question":"def longestValidSubstring(s: str, k: int, m: int) -> int: Determine the length of the longest substring that can be formed by deleting at most \`k\` characters from string \`s\` such that every character of the substring appears at least \`m\` times. >>> longestValidSubstring(\\"aaabbbcc\\", 0, 3) 6 >>> longestValidSubstring(\\"ababbc\\", 2, 2) 5 >>> longestValidSubstring(\\"aabbcc\\", 1, 3) 0 >>> longestValidSubstring(\\"aaa\\", 0, 1) 3 >>> longestValidSubstring(\\"aabbcc\\", 0, 3) 0 >>> longestValidSubstring(\\"aaabbbccc\\", 3, 3) 9","solution":"def longestValidSubstring(s, k, m): from collections import Counter def validSubstring(s, m): count = Counter(s) for char in count: if count[char] < m: return False return True n = len(s) max_len = 0 for i in range(n): for j in range(i, n): substr = s[i:j+1] if validSubstring(substr, m): max_len = max(max_len, len(substr)) return max_len"},{"question":"def minPathSum(matrix: List[List[int]]) -> int: Computes the minimum path sum from the top left to bottom right corner of the matrix. You can only move either down or right at any point in time. >>> minPathSum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> minPathSum([[5]]) == 5 >>> minPathSum([]) == 0 >>> minPathSum([[1, 2, 3, 4]]) == 10 >>> minPathSum([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> minPathSum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21","solution":"from typing import List def minPathSum(matrix: List[List[int]]) -> int: Computes the minimum path sum from the top left to bottom right corner of the matrix. if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) # Initialize the dynamic programming table with the same size as the matrix dp = [[0] * cols for _ in range(rows)] # Set the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"import heapq from typing import List def trap_rain_water(height_map: List[List[int]]) -> int: Calculate the amount of water that can be trapped after raining in a 2D grid of non-negative integers. Args: height_map (List[List[int]]): 2D grid representing the height map. Returns: int: The total volume of trapped water. Examples: >>> trap_rain_water([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) 4 >>> trap_rain_water([]) 0 >>> trap_rain_water([[1, 2, 2, 1]]) 0 >>> trap_rain_water([[1], [2], [1]]) 0 >>> trap_rain_water([ ... [3, 3, 3, 3], ... [3, 1, 1, 3], ... [3, 1, 1, 3], ... [3, 3, 3, 3] ... ]) 8 >>> trap_rain_water([ ... [1, 2, 3], ... [4, 3, 2], ... [1, 2, 3] ... ]) 0 >>> trap_rain_water([ ... [12, 13, 1, 12], ... [13, 4, 13, 12], ... [13, 8, 10, 12], ... [12, 13, 12, 12], ... [13, 13, 13, 13] ... ]) 14 pass","solution":"import heapq def trap_rain_water(height_map): if not height_map or not height_map[0]: return 0 m, n = len(height_map), len(height_map[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (height_map[i][0], i, 0)) heapq.heappush(heap, (height_map[i][n-1], i, n-1)) visited[i][0] = True visited[i][n-1] = True for j in range(n): heapq.heappush(heap, (height_map[0][j], 0, j)) heapq.heappush(heap, (height_map[m-1][j], m-1, j)) visited[0][j] = True visited[m-1][j] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: trapped = max(0, height - height_map[nx][ny]) water_trapped += trapped visited[nx][ny] = True heapq.heappush(heap, (max(height, height_map[nx][ny]), nx, ny)) return water_trapped"},{"question":"import typing from typing import List, Tuple def two_sum(arr: List[int], target: int) -> Tuple[int, int]: Given an array of integers \`arr\` and an integer \`target\`, this function returns indices of the two numbers such that they add up to \`target\`. The indices in the returned tuple are sorted in ascending order. You must solve the problem with an algorithm that runs in O(n) time. >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([3, 2, 4], 6) (1, 2) >>> two_sum([3, 3], 6) (0, 1) >>> two_sum([1, 2, 7, 11, 15], 9) (1, 2) >>> two_sum([2, 5, 5, 11], 10) (1, 2)","solution":"def two_sum(arr, target): Returns the indices of the two numbers in the array \`arr\` that add up to the \`target\`. The indices are returned as a tuple in ascending order. # Dictionary to store the number and its corresponding index num_to_index = {} # Iterate through the array for i, num in enumerate(arr): # Calculate the complement complement = target - num # Check if the complement exists in the dictionary if complement in num_to_index: # Return the indices sorted in ascending order return tuple(sorted((num_to_index[complement], i))) # Store the number and its index in the dictionary num_to_index[num] = i # In case no solution exists, though the problem guarantees one return None"},{"question":"def dailyTemperatures(temperatures): Given a list of daily temperatures, returns a list of the number of days until a warmer temperature for each day. If there are no future warmer temperatures, returns 0 for that day. :param temperatures: List[int] - A list of integers representing daily temperatures :return: List[int] - A list of integers representing the number of days to wait for a warmer temperature >>> dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> dailyTemperatures([70, 70, 70, 70]) [0, 0, 0, 0] >>> dailyTemperatures([75, 74, 73, 70]) [0, 0, 0, 0] >>> dailyTemperatures([70, 72, 74, 76, 78]) [1, 1, 1, 1, 0] >>> dailyTemperatures([65]) [0] >>> dailyTemperatures([65, 70]) [1, 0] >>> dailyTemperatures([70, 65]) [0, 0]","solution":"def dailyTemperatures(temperatures): Given a list of daily temperatures, returns a list of the number of days until a warmer temperature for each day. If there are no future warmer temperatures, returns 0 for that day. :param temperatures: List[int] - A list of integers representing daily temperatures :return: List[int] - A list of integers representing the number of days to wait for a warmer temperature n = len(temperatures) result = [0] * n stack = [] for i, temp in enumerate(temperatures): while stack and temperatures[stack[-1]] < temp: prev_day = stack.pop() result[prev_day] = i - prev_day stack.append(i) return result"},{"question":"def split_into_palindromes(s: str, k: int) -> list[str]: Given a string \`s\` and an integer \`k\`, split the string into \`k\` non-empty palindromic substrings. Return a list of \`k\` palindromic substrings if such a split is possible, or an empty list if it is not. A string is a palindrome if it reads the same forward and backward. >>> split_into_palindromes(\\"racecarannakayak\\", 3) [\\"racecar\\", \\"anna\\", \\"kayak\\"] >>> split_into_palindromes(\\"level\\", 1) [\\"level\\"] >>> split_into_palindromes(\\"abcbdd\\", 3) [\\"a\\", \\"bcb\\", \\"dd\\"] >>> split_into_palindromes(\\"abc\\", 4) [] >>> split_into_palindromes(\\"aaa\\", 3) [\\"a\\", \\"a\\", \\"a\\"] >>> split_into_palindromes(\\"\\", 1) [] >>> split_into_palindromes(\\"abc\\", 5) []","solution":"def is_palindrome(s): return s == s[::-1] def split_into_palindromes(s, k): n = len(s) result = [] def backtrack(start, cut): if cut == 0: if start == n: return True return False for end in range(start + 1, n + 1): sub_str = s[start:end] if is_palindrome(sub_str): result.append(sub_str) if backtrack(end, cut - 1): return True result.pop() return False if backtrack(0, k): return result else: return []"},{"question":"from typing import List def min_total_penalty(checkpoints: List[int]) -> int: Returns the minimum total penalty the runner can incur to reach the last checkpoint from the first checkpoint. >>> min_total_penalty([0]) 0 >>> min_total_penalty([0, 10]) 10 >>> min_total_penalty([0, 1, 3, 6, 10]) 10 >>> min_total_penalty([-10, -5, 0, 5, 10]) 20 >>> min_total_penalty([-10, -1, 1, 10]) 20","solution":"def min_total_penalty(checkpoints): Returns the minimum total penalty the runner can incur to reach the last checkpoint from the first checkpoint. n = len(checkpoints) dp = [float('inf')] * n dp[0] = 0 # Starting point, no penalty for i in range(n): for j in range(i + 1, n): dp[j] = min(dp[j], dp[i] + abs(checkpoints[j] - checkpoints[i])) return dp[-1]"},{"question":"def min_wildcards_to_form_subsequence(s: str, t: str) -> int: Insert the minimum number of wildcard characters ('*') into s such that t can be formed as a subsequence from s. Args: s: A string consisting of lowercase English letters. t: A target string which may contain any characters. Returns: The minimum number of wildcard characters that need to be inserted in s or -1 if it’s not possible to form t from s. Tests: >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"\\") 0 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"abcde\\") 0 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"abde\\") 1 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"ae\\") 3 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"f\\") -1 >>> min_wildcards_to_form_subsequence(\\"abc\\", \\"abcd\\") -1 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"ace\\") 2 >>> min_wildcards_to_form_subsequence(\\"abcde\\", \\"acde\\") 1","solution":"def min_wildcards_to_form_subsequence(s, t): Returns the minimum number of wildcard characters ('*') needed to be inserted into s to make t a subsequence of s, or -1 if it’s not possible to form t from s. :param s: Source string consisting of lowercase English letters :param t: Target string :return: Minimum number of wildcard characters to be inserted into s, or -1 if not possible m, n = len(s), len(t) # If t is empty, no wildcards are needed if n == 0: return 0 # Two pointers approach i, j = 0, 0 wildcards_needed = 0 while i < m and j < n: if s[i] == t[j]: j += 1 else: wildcards_needed += 1 i += 1 # If we've traversed through t, check how many characters are left in s if j == n: wildcards_needed += m - i return wildcards_needed else: return -1"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Given an array of integers where each element represents the height of a building, and the width of each building is 1 unit, find the largest rectangular area that can be formed using contiguous buildings. Return the area of the largest rectangle that can be formed. >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([3, 3, 3, 3]) 12 >>> largestRectangleArea([2, 4, 6, 8]) 12 >>> largestRectangleArea([8, 6, 4, 2]) 12 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([]) 0 >>> largestRectangleArea([0, 0, 0, 0]) 0","solution":"def largestRectangleArea(heights): Returns the area of the largest rectangle that can be formed using contiguous buildings. :param heights: List[int], heights[i] is the height of the i-th building. :return: int, the area of the largest rectangle. stack = [] max_area = 0 heights.append(0) # Append a zero to make sure we empty the stack at the end for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * width) stack.append(i) return max_area"},{"question":"def count_students_taller(heights: List[int]) -> List[int]: You are given a list of \`n\` integers representing the heights of students standing in a row. The students are standing in the order of their heights from left to right. Each student wants to know the number of students who are taller than themselves and are standing to their right. Return an integer list where the \`i-th\` element is the number of students taller than the \`i-th\` student and to their right. :param heights: List[int] : A list of integers representing the heights of the students. :return: List[int] : A list of integers as described. >>> count_students_taller([150, 150, 150, 150]) [0, 0, 0, 0] >>> count_students_taller([150, 160, 170, 180]) [3, 2, 1, 0] >>> count_students_taller([180, 170, 160, 150]) [0, 0, 0, 0] >>> count_students_taller([160, 150, 180, 170]) [2, 2, 0, 0] >>> count_students_taller([170, 160, 180, 150, 175]) [2, 2, 0, 1, 0] >>> count_students_taller([160]) [0] >>> count_students_taller([160, 170]) [1, 0] >>> count_students_taller([170, 160]) [0, 0]","solution":"def count_students_taller(heights): Returns a list of integers where the i-th element is the number of students who are taller than the i-th student and are standing to their right. :param heights: List[int] : A list of integers representing the heights of the students. :return: List[int] : A list of integers as described. n = len(heights) result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if heights[j] > heights[i]: count += 1 result[i] = count return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1: TreeNode, root2: TreeNode) -> TreeNode: You are given two non-empty binary trees \`root1\` and \`root2\`. Imagine that when you overlay these two trees, some nodes of \`root2\` might appear on top of the nodes of \`root1\`, and some might be missing. Your task is to merge the two trees into a single binary tree by taking the sum of overlapping nodes of \`root1\` and \`root2\`. If a node is only present in one of the trees, the corresponding node in the merged tree should have the same value as that node. >>> root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2)) >>> root2 = TreeNode(2, TreeNode(1, None, TreeNode(4)), TreeNode(3, None, TreeNode(7))) >>> merged = mergeTrees(root1, root2) >>> expected = TreeNode(3, TreeNode(4, TreeNode(5), TreeNode(4)), TreeNode(5, None, TreeNode(7))) >>> trees_are_equal(merged, expected) True >>> root1 = None >>> root2 = TreeNode(1, TreeNode(3), TreeNode(2)) >>> merged = mergeTrees(root1, root2) >>> trees_are_equal(merged, root2) True >>> root1 = TreeNode(1, TreeNode(3), TreeNode(2)) >>> root2 = None >>> merged = mergeTrees(root1, root2) >>> trees_are_equal(merged, root1) True >>> root1 = None >>> root2 = None >>> merged = mergeTrees(root1, root2) >>> merged is None True def trees_are_equal(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and trees_are_equal(tree1.left, tree2.left) and trees_are_equal(tree1.right, tree2.right))","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def mergeTrees(root1, root2): Merges two binary trees into one by summing overlapping nodes. if not root1 and not root2: return None if not root1: return root2 if not root2: return root1 merged = TreeNode(root1.val + root2.val) merged.left = mergeTrees(root1.left, root2.left) merged.right = mergeTrees(root1.right, root2.right) return merged"},{"question":"def find_min_lcp_sum(s: str, k: int) -> int: This function splits the string s into k non-empty substrings such that the sum of the lengths of the longest common prefixes (LCP) for all pairs of these substrings is minimized. Args: s (str): A string consisting of lowercase alphabets. k (int): The number of non-empty substrings to split the string into. Returns: int: The minimum sum of LCP for all pairs of substrings. Examples: >>> find_min_lcp_sum(\\"abcde\\", 1) 0 >>> find_min_lcp_sum(\\"abcde\\", 5) 0 >>> find_min_lcp_sum(\\"abcde\\", 2) 0 >>> find_min_lcp_sum(\\"aaaa\\", 2) <some_value_less_than_infinity> >>> find_min_lcp_sum(\\"abacadae\\", 3) 0 >>> find_min_lcp_sum(\\"abcabcabc\\", 3) 0","solution":"def find_min_lcp_sum(s, k): This function splits the string s into k non-empty substrings such that the sum of the lengths of the longest common prefixes (LCP) for all pairs of these substrings is minimized. n = len(s) if k == 1: return 0 if k == n: return 0 # Use Dynamic Programming approach to solve this problem dp = [[float('inf')] * (k+1) for _ in range(n+1)] dp[0][0] = 0 for i in range(1, n + 1): for j in range(1, k + 1): for x in range(i): lcp = 0 while lcp < x and lcp < i - x and s[x + lcp] == s[x - (i - x) + lcp]: lcp += 1 dp[i][j] = min(dp[i][j], dp[x][j-1] + lcp) return dp[n][k]"},{"question":"class NestedInteger: def __init__(self, value=None): Initialize with value, or an empty list if no value is provided. pass def isInteger(self): Return True if this NestedInteger holds a single integer, rather than a nested list. pass def add(self, elem): Add a NestedInteger to this NestedInteger list. pass def setInteger(self, value): Set this NestedInteger to hold a single integer. pass def getInteger(self): Return the single integer that this NestedInteger holds, or None if it holds a nested list. pass def getList(self): Return the nested list that this NestedInteger holds, or None if it holds a single integer. pass class MiniParser: def deserialize(self, s: str) -> NestedInteger: Deserialize a string representing a nested list of integers. >>> printNestedInteger(MiniParser().deserialize(\\"123\\")) 123 >>> printNestedInteger(MiniParser().deserialize(\\"[]\\")) [] >>> printNestedInteger(MiniParser().deserialize(\\"[123,[456,[789]]\\")) [123, [456, [789]]] >>> printNestedInteger(MiniParser().deserialize(\\"[1,2,3,4]\\")) [1, 2, 3, 4]","solution":"class NestedInteger: def __init__(self, value=None): Initialize with value, or an empty list if no value is provided. if value is None: self._list = [] self._value = None else: self._list = None self._value = value def isInteger(self): Return True if this NestedInteger holds a single integer, rather than a nested list. return self._value is not None def add(self, elem): Add a NestedInteger to this NestedInteger list. if self._list is not None: self._list.append(elem) else: raise ValueError(\\"This NestedInteger currently holds a single integer\\") def setInteger(self, value): Set this NestedInteger to hold a single integer. self._value = value def getInteger(self): Return the single integer that this NestedInteger holds, or None if it holds a nested list. return self._value def getList(self): Return the nested list that this NestedInteger holds, or None if it holds a single integer. return self._list class MiniParser: def deserialize(self, s: str) -> NestedInteger: Deserialize a string representing a nested list of integers. stack = [] num = '' for char in s: if char == '[': stack.append(NestedInteger()) elif char == ']': if num: stack[-1].add(NestedInteger(int(num))) num = '' if len(stack) > 1: nested = stack.pop() stack[-1].add(nested) elif char == ',': if num: stack[-1].add(NestedInteger(int(num))) num = '' else: num += char if num: return NestedInteger(int(num)) return stack[0] # Providing a helper function to print NestedInteger structure, useful for debugging def printNestedInteger(nested): if nested.isInteger(): return nested.getInteger() else: return [printNestedInteger(elem) for elem in nested.getList()]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all root-to-leaf numbers in the binary tree. >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> sumNumbers(root) 25 >>> root = TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0)) >>> sumNumbers(root) 1026 >>> sumNumbers(None) 0 >>> root = TreeNode(2, TreeNode(3, TreeNode(4))) >>> sumNumbers(root) 234 >>> root = TreeNode(5) >>> sumNumbers(root) 5","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Returns the sum of all root-to-leaf numbers in the binary tree. def dfs(node, current_sum): if not node: return 0 current_sum = current_sum * 10 + node.val if not node.left and not node.right: # if it's a leaf node return current_sum # else traverse both subtrees return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(root, 0)"},{"question":"def count_matching_sentences(quotes: List[str], sentences: List[str]) -> int: This function counts how many sentences match any of the quotes in a case-insensitive manner. :param quotes: List of strings representing famous quotes. :param sentences: List of strings representing sentences to be matched against the quotes. :return: Integer count of sentences matching at least one quote in a case-insensitive manner. >>> count_matching_sentences([\\"To be or not to be\\", \\"A penny for your thoughts\\"], [\\"to Be or Not To Be\\", \\"A Dime for your thoughts\\", \\"A penny for your Thoughts\\", \\"Live and let live\\"]) 2 >>> count_matching_sentences([\\"Stay hungry, stay foolish\\"], [\\"Stay hungry, live better\\"]) 0 >>> count_matching_sentences([\\"The quick brown fox jumps over the lazy dog\\"], [\\"the quick Brown Fox jumps over the lazy Dog\\"]) 1 pass","solution":"def count_matching_sentences(quotes, sentences): This function counts how many sentences match any of the quotes in a case-insensitive manner. :param quotes: List of strings representing famous quotes. :param sentences: List of strings representing sentences to be matched against the quotes. :return: Integer count of sentences matching at least one quote in a case-insensitive manner. quotes_set = set(quote.lower() for quote in quotes) match_count = 0 for sentence in sentences: if sentence.lower() in quotes_set: match_count += 1 return match_count"},{"question":"def final_string_length(s: str) -> int: Given a string \`s\` consisting only of characters 'a' and 'b', repeatedly delete any two adjacent characters if they are different and return the length of the final string after all possible deletions have been made. >>> final_string_length(\\"aaaa\\") == 4 >>> final_string_length(\\"bbbb\\") == 4 >>> final_string_length(\\"abab\\") == 0 >>> final_string_length(\\"baba\\") == 0 >>> final_string_length(\\"aab\\") == 1 >>> final_string_length(\\"baaa\\") == 2 >>> final_string_length(\\"a\\") == 1 >>> final_string_length(\\"b\\") == 1 >>> final_string_length(\\"\\") == 0","solution":"def final_string_length(s): Reduces the string by repeatedly deleting any two adjacent characters if they are different and returns the length of the final string. stack = [] for char in s: if stack and stack[-1] != char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def longest_substring_with_two_distinct(s: str) -> str: Returns the longest substring of s that contains at most 2 distinct characters. If there are multiple longest substrings with the same length, return the one that appears first. >>> longest_substring_with_two_distinct(\\"eceba\\") 'ece' >>> longest_substring_with_two_distinct(\\"ccaabbb\\") 'aabbb'","solution":"def longest_substring_with_two_distinct(s): Returns the longest substring of s that contains at most 2 distinct characters. If there are multiple longest substrings with the same length, return the one that appears first. if len(s) <= 2: return s max_len = 0 max_substr = \\"\\" left = 0 char_map = {} for right, char in enumerate(s): if char in char_map: char_map[char] += 1 else: char_map[char] = 1 while len(char_map) > 2: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_substr = s[left:right + 1] return max_substr"},{"question":"class Node: def __init__(self, value, children=None): self.value = value self.children = children if children is not None else [] def sum_of_leaf_nodes(root): Returns the sum of all leaf node values in a k-ary tree. :param root: The root node of the k-ary tree :return: The sum of all leaf node values >>> sum_of_leaf_nodes(Node(5)) 5 >>> sum_of_leaf_nodes(Node(1, [Node(2), Node(3), Node(4)])) 9 >>> sum_of_leaf_nodes(Node(1, [Node(2), Node(3, [Node(5), Node(6)]), Node(4)])) 17 >>> sum_of_leaf_nodes(Node(1, [ Node(2, [Node(7), Node(8)]), Node(3, [Node(9), Node(10)]), Node(4, [Node(11)]), Node(5, [Node(12), Node(13, [Node(14)])]) ])) 71 >>> sum_of_leaf_nodes(None) 0","solution":"class Node: def __init__(self, value, children=None): self.value = value self.children = children if children is not None else [] def sum_of_leaf_nodes(root): Returns the sum of all leaf node values in a k-ary tree. :param root: The root node of the k-ary tree :return: The sum of all leaf node values def dfs(node): if not node.children: return node.value return sum(dfs(child) for child in node.children) if root is None: return 0 return dfs(root)"},{"question":"def min_value(expression: str) -> int: Return the minimum value that can be obtained by adding parentheses in any order to the expression. >>> min_value(\\"3\\") == 3 >>> min_value(\\"1+2+3\\") == 6 >>> min_value(\\"2*3*4\\") == 24 >>> min_value(\\"2+3*4\\") == 14 >>> min_value(\\"10+2*5\\") == 20 >>> min_value(\\"100+200*300\\") == 60100 >>> min_value(\\"1+2*3+4\\") == 11 >>> min_value(\\"2*3+4*5\\") == 26","solution":"def min_value(expression): def dfs(nums, ops): if not ops: return nums[0] min_val = float('inf') for i in range(len(ops)): left = dfs(nums[:i+1], ops[:i]) right = dfs(nums[i+1:], ops[i+1:]) if ops[i] == '+': current_val = left + right else: current_val = left * right min_val = min(min_val, current_val) return min_val nums, ops = [], [] i = 0 while i < len(expression): if expression[i].isdigit(): num = 0 while i < len(expression) and expression[i].isdigit(): num = num * 10 + int(expression[i]) i += 1 nums.append(num) else: ops.append(expression[i]) i += 1 return dfs(nums, ops)"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Write a function that accepts a list of strings \`words\` and returns a list of lists, where each inner list contains all anagrams from the input list. Each inner list should contain strings that are anagrams of each other, and the inner lists should be in no particular order. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once. >>> group_anagrams([\\"bat\\", \\"tab\\", \\"cat\\", \\"act\\", \\"dog\\", \\"god\\"]) [['bat', 'tab'], ['cat', 'act'], ['dog', 'god']] >>> group_anagrams([\\"\\"]) [[\\"\\"]] >>> group_anagrams([\\"a\\"]) [[\\"a\\"]] >>> group_anagrams([\\"ab\\", \\"ba\\", \\"abc\\", \\"bca\\", \\"cab\\", \\"dab\\"]) [['ab', 'ba'], ['abc', 'bca', 'cab'], ['dab']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"gooogle\\"]) [['listen', 'silent', 'enlist'], ['google'], ['gooogle']]","solution":"from collections import defaultdict def group_anagrams(words): Returns a list of lists, where each inner list contains anagrams from the input list of words. anagrams = defaultdict(list) for word in words: # sort the word and use it as a key sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values())"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determines if the binary tree is height-balanced. >>> isBalanced(None) True >>> isBalanced(TreeNode(1)) True >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> isBalanced(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> isBalanced(root) False >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))), TreeNode(2)) >>> isBalanced(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determines if the binary tree is height-balanced. def check_height(node): if node is None: return 0, True left_height, left_balanced = check_height(node.left) right_height, right_balanced = check_height(node.right) current_height = 1 + max(left_height, right_height) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, balanced _, is_bal = check_height(root) return is_bal"},{"question":"def largest_region(grid: List[List[int]]) -> int: Find the largest area (number of cells) of connected \`1\`s in the grid. >>> largest_region([]) == 0 >>> largest_region([[1]]) == 1 >>> largest_region([[0]]) == 0 >>> largest_region([[1, 1], [1, 1]]) == 4 >>> largest_region([[1, 0], [0, 1]]) == 1 >>> largest_region([[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1]]) == 4 >>> largest_region([[0, 0, 1, 1], [0, 1, 1, 0], [1, 0, 0, 1], [1, 1, 0, 1]]) == 4 pass def test_empty_grid(): assert largest_region([]) == 0 def test_single_cell(): assert largest_region([[1]]) == 1 assert largest_region([[0]]) == 0 def test_grid_all_ones(): grid = [ [1, 1], [1, 1] ] assert largest_region(grid) == 4 def test_grid_no_adjacent_ones(): grid = [ [1, 0], [0, 1] ] assert largest_region(grid) == 1 def test_grid_single_region(): grid = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ] assert largest_region(grid) == 4 def test_grid_multiple_regions(): grid = [ [0, 0, 1, 1], [0, 1, 1, 0], [1, 0, 0, 1], [1, 1, 0, 1] ] assert largest_region(grid) == 4","solution":"def largest_region(grid): def dfs(grid, i, j, visited): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0 or (i, j) in visited: return 0 visited.add((i, j)) size = 1 # count the current cell # explore all four directions (up, down, left, right) size += dfs(grid, i + 1, j, visited) size += dfs(grid, i - 1, j, visited) size += dfs(grid, i, j + 1, visited) size += dfs(grid, i, j - 1, visited) return size if not grid: return 0 max_region_size = 0 visited = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1 and (i, j) not in visited: region_size = dfs(grid, i, j, visited) max_region_size = max(max_region_size, region_size) return max_region_size"},{"question":"def find_single_element(arr: List[int]) -> int: Find the single element in an unsorted array of integers where every element appears twice except for one. Your algorithm should have a linear runtime complexity and not use extra memory. :param arr: List[int], the input list of integers :return: int, the single element that appears only once >>> find_single_element([1, 2, 3, 2, 1]) 3 >>> find_single_element([4, 1, 2, 1, 2]) 4 >>> find_single_element([5, 5, 7, 9, 7]) 9 >>> find_single_element([-1, -1, -2]) -2 >>> find_single_element([-3, -3, -1, -2, -1]) -2 >>> find_single_element([99]) 99 >>> find_single_element([0, 0, 1]) 1","solution":"def find_single_element(arr): Find the single element in an array where every element appears twice except for one. :param arr: List[int], the input list of integers :return: int, the single element that appears only once single_element = 0 for num in arr: single_element ^= num return single_element"},{"question":"def can_rearrange(arr): Determines if it's possible to rearrange the array elements such that the absolute difference between any two consecutive elements is never greater than 1. :param arr: List of integers :return: Boolean indicating if such a rearrangement is possible >>> can_rearrange([]) == True >>> can_rearrange([1]) == True >>> can_rearrange([1, 2, 3, 4, 5]) == True >>> can_rearrange([3, 1, 2, 4, 5]) == True >>> can_rearrange([1, 2, 4, 5]) == False >>> can_rearrange([-1, 0, 1, 2]) == True >>> can_rearrange([1, 3, 4, 6]) == False >>> can_rearrange([1, 2, 2, 3]) == True","solution":"def can_rearrange(arr): Determines if it's possible to rearrange the array elements such that the absolute difference between any two consecutive elements is never greater than 1. :param arr: List of integers :return: Boolean indicating if such a rearrangement is possible if not arr: return True arr.sort() for i in range(len(arr) - 1): if abs(arr[i] - arr[i + 1]) > 1: return False return True"},{"question":"from typing import List def count_unique_subsets(nums: List[int], target: int) -> int: Count the number of unique subsets of \`nums\` that sum to \`target\`. A subset is considered unique if no two subsets contain the exact same combination of scores. Note that the sets should not have any duplicated values within them. >>> count_unique_subsets([1, 2, 3, 4], 5) == 2 >>> count_unique_subsets([1, 1, 2, 2, 3, 3, 4, 4], 5) == 2 >>> count_unique_subsets([1, 2, 3], 7) == 0 >>> count_unique_subsets([5], 5) == 1 >>> count_unique_subsets([1, 2, 3, 4, 6], 6) == 3 pass","solution":"from itertools import combinations def count_unique_subsets(nums, target): Count the number of unique subsets of \`nums\` that sum to \`target\`. nums = list(set(nums)) # Remove any duplicated values within the list count = 0 unique_subsets = set() for r in range(1, len(nums) + 1): for subset in combinations(nums, r): if sum(subset) == target and subset not in unique_subsets: unique_subsets.add(subset) count += 1 return count"},{"question":"def isPath(graph, start, end): Determines if there is a path from start to end in the directed graph such that all nodes in the path have distinct values. :param graph: List of lists representing the adjacency list of the graph :param start: Starting node :param end: Ending node :return: Boolean value indicating if such a path exists pass # Unit tests def test_path_exists(): graph = [ [1, 2], [2], [3], [] ] assert isPath(graph, 0, 3) == True def test_no_path(): graph = [ [1, 2], [2], [], [] ] assert isPath(graph, 0, 3) == False def test_start_is_end(): graph = [ [1, 2], [2], [3], [] ] assert isPath(graph, 0, 0) == True def test_single_node(): graph = [ [] ] assert isPath(graph, 0, 0) == True def test_direct_connection(): graph = [ [1], [2], [3], [] ] assert isPath(graph, 0, 3) == True def test_circle_graph(): graph = [ [1], [2], [0] ] assert isPath(graph, 0, 2) == True def test_disconnected_graph(): graph = [ [1], [], [3], [] ] assert isPath(graph, 0, 3) == False def test_graph_with_multiple_paths(): graph = [ [1, 2], [3], [3], [] ] assert isPath(graph, 0, 3) == True","solution":"def isPath(graph, start, end): Determines if there is a path from start to end in the directed graph such that all nodes in the path have distinct values. :param graph: List of lists representing the adjacency list of the graph :param start: Starting node :param end: Ending node :return: Boolean value indicating if such a path exists def dfs(node, visited): if node == end: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited): return True visited.remove(node) return False return dfs(start, set())"},{"question":"def minSubArrayLen(target: int, nums: List[int]) -> int: Returns the minimum length of a contiguous subarray for which the sum is at least target. If no such subarray exists, return 0. >>> minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) 2 >>> minSubArrayLen(4, [1, 4, 4]) 1 >>> minSubArrayLen(11, [1, 1, 1, 1, 1, 1, 1, 1]) 0 >>> minSubArrayLen(15, [1, 2, 3, 4, 5]) 5 >>> minSubArrayLen(100, [1, 2, 3, 4, 5]) 0 >>> minSubArrayLen(10, []) 0 >>> minSubArrayLen(3, [3]) 1 >>> minSubArrayLen(5, [3]) 0","solution":"def minSubArrayLen(target, nums): Returns the minimum length of a contiguous subarray for which the sum is at least target. If no such subarray exists, return 0. n = len(nums) min_length = float('inf') left = 0 current_sum = 0 for right in range(n): current_sum += nums[right] while current_sum >= target: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"from typing import List def rotateMatrix(matrix: List[List[int]]) -> None: Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to be rotated. Returns: None # Your code here # Unit tests def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_1x1_matrix(): matrix = [ [1] ] expected = [ [1] ] rotateMatrix(matrix) assert matrix == expected def test_rotate_2x2_matrix(): matrix = [ [1, 2], [3, 4] ] expected = [ [3, 1], [4, 2] ] rotateMatrix(matrix) assert matrix == expected","solution":"def rotateMatrix(matrix): Rotates the given n x n matrix 90 degrees clockwise in-place. Args: matrix (list of list of int): The n x n matrix to be rotated. Returns: None n = len(matrix) for layer in range(n // 2): first = layer last = n - 1 - layer for i in range(first, last): offset = i - first # Save the top element top = matrix[first][i] # Move left element to top matrix[first][i] = matrix[last - offset][first] # Move bottom element to left matrix[last - offset][first] = matrix[last][last - offset] # Move right element to bottom matrix[last][last - offset] = matrix[i][last] # Move top element to right matrix[i][last] = top"},{"question":"def max_unblocked_students(heights: list[int], m: int) -> int: Returns the maximum number of students with an unblocked view of the parade after removing at most \`m\` students. Parameters: heights (list[int]): List of heights of students. m (int): Maximum number of students that can be removed. Returns: int: Maximum number of students with an unblocked view. >>> max_unblocked_students([2, 2, 2, 2, 2], 0) == 5 >>> max_unblocked_students([1, 2, 3, 4, 5], 0) == 5 >>> max_unblocked_students([5, 4, 3, 2, 1], 0) == 1 >>> max_unblocked_students([1, 5, 2, 4, 3], 2) == 5 >>> max_unblocked_students([4, 1, 3, 2, 5], 5) == 5","solution":"def max_unblocked_students(heights, m): Returns the maximum number of students with an unblocked view of the parade after removing at most \`m\` students. Parameters: heights (list[int]): List of heights of students. m (int): Maximum number of students that can be removed. Returns: int: Maximum number of students with an unblocked view. n = len(heights) if m >= n - 1: return n dp = [1] * n for i in range(1, n): for j in range(i): if heights[i] >= heights[j]: dp[i] = max(dp[i], dp[j] + 1) max_students = max(dp) if m > 0: max_students = min(n, max_students + m) return max_students"},{"question":"def is_complete_binary_tree(nums): Determine if the binary tree represented by nums is complete. :param nums: List of integers representing the level-order traversal of the binary tree. :return: True if the binary tree is complete, otherwise False. >>> is_complete_binary_tree([]) == True >>> is_complete_binary_tree([1]) == True >>> is_complete_binary_tree([1, 2, 3, 4, 5, 6]) == True >>> is_complete_binary_tree([1, 2, 3, None, 5, 6]) == False >>> is_complete_binary_tree([1, 2, 3, 4, None, 6]) == False >>> is_complete_binary_tree([1, 2, 3, 4, 5, None, 6]) == False","solution":"def is_complete_binary_tree(nums): Determine if the binary tree represented by nums is complete. :param nums: List of integers representing the level-order traversal of the binary tree. :return: True if the binary tree is complete, otherwise False. if not nums: return True n = len(nums) for i in range(n): if nums[i] is None: if any(nums[j] is not None for j in range(i + 1, n)): return False return True"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head: ListNode, left: int, right: int) -> ListNode: Reverse the nodes of the linked list from position \`left\` to \`right\` in one pass. Args: head (ListNode): The head of the linked list. left (int): The starting position. right (int): The ending position. Returns: ListNode: The head of the modified linked list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> left, right = 2, 4 >>> new_head = reverse_between(head, left, right) >>> list_to_array(new_head) == [1, 4, 3, 2, 5] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> left, right = 1, 5 >>> new_head = reverse_between(head, left, right) >>> list_to_array(new_head) == [5, 4, 3, 2, 1] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> left, right = 3, 3 >>> new_head = reverse_between(head, left, right) >>> list_to_array(new_head) == [1, 2, 3, 4, 5] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> left, right = 1, 3 >>> new_head = reverse_between(head, left, right) >>> list_to_array(new_head) == [3, 2, 1, 4, 5] True >>> head = array_to_list([1, 2, 3, 4, 5]) >>> left, right = 3, 5 >>> new_head = reverse_between(head, left, right) >>> list_to_array(new_head) == [1, 2, 5, 4, 3] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_between(head, left, right): if not head or left == right: return head dummy = ListNode(0) dummy.next = head prev = dummy for _ in range(left - 1): prev = prev.next current = prev.next reverse = None for _ in range(right - left + 1): next_node = current.next current.next = reverse reverse = current current = next_node prev.next.next = current prev.next = reverse return dummy.next"},{"question":"def remove_consecutive_repeats(s: str) -> str: Remove the minimum number of characters from the string so that the remaining string does not contain any consecutive repeating characters. Return the resulting string. >>> remove_consecutive_repeats(\\"abcdef\\") == \\"abcdef\\" >>> remove_consecutive_repeats(\\"aaaaaaa\\") == \\"a\\" >>> remove_consecutive_repeats(\\"aabbccdd\\") == \\"abcd\\" >>> remove_consecutive_repeats(\\"aabbcaadde\\") == \\"abcade\\" >>> remove_consecutive_repeats(\\"\\") == \\"\\"","solution":"def remove_consecutive_repeats(s): Remove the minimum number of characters from the string so that the remaining string does not contain any consecutive repeating characters. Return the resulting string. if not s: return \\"\\" result = [s[0]] for i in range(1, len(s)): if s[i] != s[i-1]: result.append(s[i]) return ''.join(result)"},{"question":"def caesar_cipher(s: str, n: int) -> str: Given a string \`s\` and an integer \`n\`, return a new string where each character in \`s\` is shifted \`n\` positions down the alphabet. If shifting a character beyond 'z', it wraps around to the start of the alphabet. The letter transformations should maintain their respective cases without other characters being altered. >>> caesar_cipher(\\"abc\\", 1) \\"bcd\\" >>> caesar_cipher(\\"xyz\\", 3) \\"abc\\" >>> caesar_cipher(\\"ABC\\", 3) \\"DEF\\" >>> caesar_cipher(\\"aBc\\", 1) \\"bCd\\" >>> caesar_cipher(\\"AbC\\", 2) \\"CdE\\" >>> caesar_cipher(\\"abc\\", 26) \\"abc\\" >>> caesar_cipher(\\"abc\\", 52) \\"abc\\" >>> caesar_cipher(\\"abc\\", -1) \\"zab\\" >>> caesar_cipher(\\"ABC\\", -1) \\"ZAB\\" >>> caesar_cipher(\\"hello, world!\\", 5) \\"mjqqt, btwqi!\\" >>> caesar_cipher(\\"\\", 5) \\"\\" >>> caesar_cipher(\\"hello\\", 0) \\"hello\\"","solution":"def caesar_cipher(s, n): Shifts each alphabet character in the string \`s\` by \`n\` positions down the alphabet. Maintains the case of the letters and ignores non-alphabet characters. def shift_char(c, n): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + n) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + n) % 26 + ord('A')) else: return c return ''.join(shift_char(c, n) for c in s)"},{"question":"import pytest from collections import deque, defaultdict from typing import Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_level_sum(root: Optional[TreeNode]) -> int: Determine the smallest level of the binary tree where the sum of values of nodes at that level is the maximum. If there are multiple levels with the same sum, return the smallest level number. The level of the root is 1. >>> root = TreeNode(1) >>> root.left = TreeNode(7) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(7) >>> root.left.right = TreeNode(-8) >>> max_level_sum(root) 2 pass","solution":"from collections import deque, defaultdict class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_level_sum(root): if not root: return 0 level_sum = defaultdict(int) queue = deque([(root, 1)]) while queue: node, level = queue.popleft() level_sum[level] += node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) max_sum = max(level_sum.values()) for level in sorted(level_sum.keys()): if level_sum[level] == max_sum: return level"},{"question":"from typing import List def reorganize_string(s: str) -> str: Reorganizes the string \`s\` so that no two adjacent characters are the same. If it is not possible, returns an empty string. >>> reorganize_string(\\"aab\\") in [\\"aba\\"] True >>> reorganize_string(\\"aaab\\") == \\"\\" True >>> reorganize_string(\\"a\\") == \\"a\\" True >>> reorganize_string(\\"aaabbcc\\") in [\\"abacabc\\", \\"acbacba\\", \\"abacabca\\", \\"acabacb\\"] True >>> reorganize_string(\\"\\") == \\"\\" True >>> reorganize_string(\\"aaaa\\") == \\"\\" True","solution":"from collections import Counter import heapq def reorganize_string(s): Reorganizes the string \`s\` so that no two adjacent characters are the same. If it is not possible, returns an empty string. if not s: return \\"\\" counter = Counter(s) max_heap = [(-count, char) for char, count in counter.items()] heapq.heapify(max_heap) prev_char = \\"\\" prev_count = 0 result = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 reorganized_string = \\"\\".join(result) if len(reorganized_string) != len(s): return \\"\\" return reorganized_string"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_subtree_sum(root): Returns the maximum sum of nodes in any subtree of the given binary tree. >>> root = TreeNode(5) >>> max_subtree_sum(root) 5 >>> root = TreeNode(-3) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(-1) >>> max_subtree_sum(root) -1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> max_subtree_sum(root) 15 # Entire tree sum >>> root = TreeNode(1) >>> root.left = TreeNode(-2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(-1) >>> max_subtree_sum(root) 10 # Subtree with root = 3 >>> root = TreeNode(0) >>> root.left = TreeNode(0) >>> root.right = TreeNode(0) >>> max_subtree_sum(root) 0 >>> root = TreeNode(1000) >>> root.left = TreeNode(2000) >>> root.right = TreeNode(3000) >>> root.right.right = TreeNode(5000) >>> max_subtree_sum(root) 11000 # Entire tree sum","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_subtree_sum(root): Returns the maximum sum of nodes in any subtree of the given binary tree. def helper(node): if not node: return 0, float('-inf') left_sum, left_max_sum = helper(node.left) right_sum, right_max_sum = helper(node.right) current_sum = node.val + left_sum + right_sum current_max_sum = max(left_max_sum, right_max_sum, current_sum) return current_sum, current_max_sum _, max_sum = helper(root) return max_sum"},{"question":"def maxSumWithKElements(nums: List[int], k: int) -> int: Find the maximum sum of a non-empty subarray of nums with at most k elements. >>> maxSumWithKElements([1, 2, 3, 4, 5], 2) 9 >>> maxSumWithKElements([-3, -2, -1, -4], 1) -1 >>> maxSumWithKElements([-3, 1, -2, 4, 5], 3) 9","solution":"def maxSumWithKElements(nums: list[int], k: int) -> int: Finds the maximum sum of a non-empty subarray of nums with at most k elements. n = len(nums) if not nums or k < 1: return 0 max_sum = float('-inf') for i in range(n): current_sum = 0 for j in range(i, min(i + k, n)): current_sum += nums[j] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"class StringQuery: Initialize the object with the string s. Performs preprocessing to efficiently handle multiple queries. >>> sq = StringQuery(\\"abracadabra\\") >>> sq.queryCharCount(0, 10, 'a') 5 >>> sq.queryCharCount(0, 2, 'a') 1 >>> sq.queryCharCount(3, 5, 'a') 2 >>> sq.queryCharCount(0, 10, 'z') 0 >>> sq2 = StringQuery(\\"\\") >>> sq2.queryCharCount(0, 0, 'a') 0 >>> sq3 = StringQuery(\\"aaaaa\\") >>> sq3.queryCharCount(0, 4, 'a') 5 >>> sq4 = StringQuery(\\"bbbbb\\") >>> sq4.queryCharCount(0, 4, 'a') 0 >>> sq5 = StringQuery(\\"abcdefghijklmnopqrstuvwxyz\\") >>> sq5.queryCharCount(0, 25, 'm') 1 >>> sq5.queryCharCount(0, 25, 'z') 1 >>> sq5.queryCharCount(1, 3, 'b') 1 >>> sq5.queryCharCount(1, 3, 'd') 1 >>> sq5.queryCharCount(1, 3, 'a') 0 def __init__(self, s: str): Initialize with the string s. pass def queryCharCount(self, left: int, right: int, target: str) -> int: Return the count of the character target in the substring of s from index left to index right (inclusive). pass","solution":"class StringQuery: def __init__(self, s): Initialize the object with the string s. Precompute frequency of each character at each position. self.s = s self.prefix_counts = {} for char in set(s): self.prefix_counts[char] = [0] * (len(s) + 1) for i, char in enumerate(s): for key in self.prefix_counts: self.prefix_counts[key][i + 1] = self.prefix_counts[key][i] self.prefix_counts[char][i + 1] += 1 def queryCharCount(self, left, right, target): Return the count of the character target in the substring of s from index left to index right (inclusive). if target not in self.prefix_counts: return 0 return self.prefix_counts[target][right + 1] - self.prefix_counts[target][left]"},{"question":"def maxProfit(startTime, endTime, profit): Returns the maximum profit by selecting a subset of non-overlapping tasks. Args: startTime (List[int]): list of start times of tasks. endTime (List[int]): list of end times of tasks. profit (List[int]): list of profits of tasks. Returns: int: the maximum profit Example: >>> maxProfit([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70]) 120 >>> maxProfit([1, 3, 5], [2, 4, 6], [10, 20, 30]) 60 >>> maxProfit([1, 1, 1], [3, 3, 3], [10, 20, 30]) 30 >>> maxProfit([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60]) 150 >>> maxProfit([1], [3], [50]) 50","solution":"def maxProfit(startTime, endTime, profit): Returns the maximum profit by selecting a subset of non-overlapping tasks. n = len(startTime) tasks = sorted(zip(startTime, endTime, profit), key=lambda x: x[1]) # Sorting tasks by end time dp = [0] * (n + 1) end_times = [task[1] for task in tasks] def latestNonConflict(i): lo, hi = 0, i - 1 while lo <= hi: mid = (lo + hi) // 2 if tasks[mid][1] <= tasks[i][0]: if tasks[mid + 1][1] <= tasks[i][0]: lo = mid + 1 else: return mid else: hi = mid - 1 return -1 for i in range(1, n + 1): include_profit = tasks[i - 1][2] l = latestNonConflict(i - 1) if l != -1: include_profit += dp[l + 1] dp[i] = max(dp[i - 1], include_profit) return dp[n]"},{"question":"from typing import List def can_form_circle(words: List[str]) -> bool: Determine if all the strings in the list can form a circle. A circle is formed if the last character of each string matches the first character of the next string in the list. Args: words (List[str]): A list of strings. Returns: bool: Return True if such a circle can be formed, otherwise return False. Examples: >>> can_form_circle([\\"abc\\", \\"cde\\", \\"efa\\", \\"a\\"]) True >>> can_form_circle([\\"abc\\", \\"def\\"]) False","solution":"from collections import defaultdict def can_form_circle(words): Determines if the given list of words can form a circle. Each word's last character must match the first character of the next word, and it should form a cycle. if not words: return False # Create graph structures graph = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int) # Build the graph and track in-degrees and out-degrees for word in words: first, last = word[0], word[-1] graph[first].append(last) out_degree[first] += 1 in_degree[last] += 1 # Check if in-degrees == out-degrees for each character for char in set(in_degree.keys()).union(out_degree.keys()): if in_degree[char] != out_degree[char]: return False # Helper function - Depth First Search def dfs(char, visited): for neighbor in graph[char]: if neighbor not in visited: visited.add(neighbor) dfs(neighbor, visited) # Start DFS from the first character of the first word start_char = words[0][0] visited = set([start_char]) dfs(start_char, visited) # Check if every character in the graph is visited unique_chars = set(in_degree.keys()).union(out_degree.keys()) return visited == unique_chars"},{"question":"def decode_string(s: str) -> str: Decodes the encoded string s according to the rule k[encoded_string]. >>> decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" >>> decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" >>> decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\"","solution":"def decode_string(s): Decodes the encoded string s according to the rule k[encoded_string]. Args: s (str): The encoded string. Returns: str: The decoded string. stack = [] cur_num = 0 cur_string = '' for char in s: if char.isdigit(): cur_num = cur_num * 10 + int(char) elif char == '[': stack.append((cur_string, cur_num)) cur_string = '' cur_num = 0 elif char == ']': prev_string, num = stack.pop() cur_string = prev_string + cur_string * num else: cur_string += char return cur_string"},{"question":"def search_rotated_array(arr: List[int], target: int) -> int: Searches for a target value in a sorted and rotated array. :param arr: List[int] - A list of integers sorted and rotated at an unknown pivot. :param target: int - The target value to find in the list. :return: int - The index of the target value or -1 if not found. >>> search_rotated_array([4,5,6,7,0,1,2], 0) 4 >>> search_rotated_array([4,5,6,7,0,1,2], 4) 0 >>> search_rotated_array([4,5,6,7,0,1,2], 7) 3 >>> search_rotated_array([1], 1) 0 >>> search_rotated_array([3, 1], 1) 1 >>> search_rotated_array([4,5,6,7,0,1,2], 3) -1 >>> search_rotated_array([], 3) -1 >>> search_rotated_array([1], 0) -1 >>> search_rotated_array([3,4,5,6,7,8,9,1,2], 6) 3 >>> search_rotated_array([6,7,8,1,2,3,4,5], 8) 2 >>> search_rotated_array([6,7,8,1,2,3,4,5], 5) 7 >>> search_rotated_array([7,8,9,0,1,2,3,4,5,6], 0) 3","solution":"def search_rotated_array(arr, target): Searches for a target value in a sorted and rotated array. :param arr: List[int] - A list of integers sorted and rotated at an unknown pivot. :param target: int - The target value to find in the list. :return: int - The index of the target value or -1 if not found. if not arr: return -1 left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid # Determine which part is sorted if arr[left] <= arr[mid]: # Left part is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right part is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def count_pairs_with_sum(nums: List[int], target: int) -> int: Returns the number of distinct pairs in nums that add up to the target sum. >>> count_pairs_with_sum([1, 2, 3], 6) == 0 >>> count_pairs_with_sum([1, 2, 3], 4) == 1 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 5) == 2 # (1, 4) and (2, 3) >>> count_pairs_with_sum([1, 1, 2, 3, 4, 5], 6) == 2 # (1, 5) and (2, 4) >>> count_pairs_with_sum([-1, -2, -3, 3, 2, 1], 0) == 3 # (-1, 1), (-2, 2), (-3, 3) >>> count_pairs_with_sum([0, -1, 1, -2, 2], 0) == 2 # (0, 0), (-1, 1), (-2, 2) >>> count_pairs_with_sum([], 3) == 0","solution":"def count_pairs_with_sum(nums, target): Returns the number of distinct pairs in nums that add up to the target sum. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs)"},{"question":"def max_profit(nums): Returns the maximum possible profit by choosing a subarray from the given list of profits on different days. >>> max_profit([3, -2, 5, -1, 6, -3]) == 11 >>> max_profit([1, 2, 3, 4, 5]) == 15 >>> max_profit([-3, -2, -1, -4]) == -1 >>> max_profit([0, -3, 1, 1, 1, -1, 0]) == 3 >>> max_profit([5]) == 5 >>> max_profit([-1, -2]) == -1 >>> max_profit([1, 2]) == 3 >>> max_profit([2, -1]) == 2","solution":"def max_profit(nums): Returns the maximum possible profit by choosing a subarray max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def can_be_split(n: int, dislikes: List[List[int]]) -> bool: Determines if it's possible to split \`n\` employees into two teams such that no pair of employees who do not get along are on the same team. Args: - n (int): The number of employees. - dislikes (List[List[int]]): List of pairs of employees that do not get along. Returns: - bool: True if it is possible to split the employees, False otherwise. >>> can_be_split(4, [[1, 2], [1, 3], [2, 4]]) True >>> can_be_split(3, [[1, 2], [1, 3], [2, 3]]) False >>> can_be_split(5, [[1, 2], [2, 3], [3, 4], [4, 5], [1, 5]]) False >>> can_be_split(5, [[1, 2], [3, 4]]) True >>> can_be_split(3, []) True >>> can_be_split(8, [[1, 2], [3, 4], [5, 6], [7, 8], [1, 7], [2, 8]]) True","solution":"from collections import defaultdict, deque def can_be_split(n, dislikes): Determines if it's possible to split \`n\` employees into two teams such that no pair of employees who do not get along are on the same team. Args: - n (int): The number of employees. - dislikes (List[List[int]]): List of pairs of employees that do not get along. Returns: - bool: True if it is possible to split the employees, False otherwise. def bfs(source): queue = deque([source]) color[source] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in color: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True graph = defaultdict(list) for a, b in dislikes: graph[a].append(b) graph[b].append(a) color = {} for node in range(1, n+1): if node not in color: if not bfs(node): return False return True"},{"question":"from typing import List def find_duplicate(paths: List[str]) -> List[List[str]]: Given a list of strings, where each string represents a file path, return a list of duplicate file paths. Each file path string contains the directory path and the file name with its content in parentheses. A file is a duplicate if it has the same content as another file. The file paths will be in the format \\"root/d1/d2/.../dn filename(content)\\". >>> find_duplicate([ ... \\"root/a 1.txt(abcd) 2.txt(efgh)\\", ... \\"root/c 3.txt(abcd)\\", ... \\"root/c/d 4.txt(efgh)\\", ... \\"root 4.txt(efgh)\\" ... ]) [['root/a/1.txt', 'root/c/3.txt'], ['root/a/2.txt', 'root/c/d/4.txt', 'root/4.txt']] >>> find_duplicate([ ... \\"root/a 1.txt(abcd)\\", ... \\"root/b 2.txt(efgh)\\" ... ]) [] # Your code goes here","solution":"from collections import defaultdict def find_duplicate(paths): Given a list of strings, where each string represents a file path, returns a list of duplicate file paths. Args: - paths (List[str]): List of file path strings. Returns: - List[List[str]]: List of lists of duplicate file paths. content_to_paths = defaultdict(list) for path in paths: parts = path.split() root = parts[0] for file in parts[1:]: name, content = file.split('(') content = content[:-1] # remove the closing parenthesis full_path = f\\"{root}/{name}\\" content_to_paths[content].append(full_path) result = [group for group in content_to_paths.values() if len(group) > 1] return result"},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Find all start indices of p's anagrams in s. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"abcd\\", \\"efg\\") [] >>> find_anagrams(\\"abc\\", \\"cba\\") [0] >>> find_anagrams(\\"aabbcc\\", \\"abc\\") []","solution":"def find_anagrams(s, p): from collections import Counter p_counter = Counter(p) s_counter = Counter(s[:len(p) - 1]) result = [] for i in range(len(p) - 1, len(s)): s_counter[s[i]] += 1 start_index = i - len(p) + 1 if s_counter == p_counter: result.append(start_index) s_counter[s[start_index]] -= 1 if s_counter[s[start_index]] == 0: del s_counter[s[start_index]] return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_sum_covering_levels(root: TreeNode, k: int) -> int: Given a \`root\` of a binary tree, choose \`k\` nodes from the tree such that the sum of their values is minimized and the chosen nodes cover all levels of the tree. >>> root = TreeNode(1) >>> min_sum_covering_levels(root, 1) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> min_sum_covering_levels(root, 2) 3 # select 1 and 2 or 1 and 3 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> min_sum_covering_levels(root, 3) 6 # select 1, 2, and 3 or 1, 2, and 4 >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> min_sum_covering_levels(root, 3) 6 # select 1, 2, and any other node at level 2 >>> root = TreeNode(1) >>> min_sum_covering_levels(root, 2) 1 # selecting more nodes than available doesn't change answer","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def dfs(node, depth, nodes_by_level): if not node: return if depth in nodes_by_level: nodes_by_level[depth].append(node.val) else: nodes_by_level[depth] = [node.val] dfs(node.left, depth + 1, nodes_by_level) dfs(node.right, depth + 1, nodes_by_level) def min_sum_covering_levels(root, k): Return the minimum sum of values of k nodes that cover all levels. if not root: return 0 nodes_by_level = {} dfs(root, 0, nodes_by_level) all_nodes = sorted([node for level in nodes_by_level.values() for node in level]) return sum(all_nodes[:k])"},{"question":"def find_shortest_new_road(n: int, roads: List[List[int]]) -> int: Given a number of cities and existing roads, returns the shortest distance required to build a new road such that all cities are connected. Returns 0 if already connected and -1 if no single new road can connect all cities. >>> find_shortest_new_road(4, [[0, 1, 1], [1, 2, 2], [2, 3, 1], [3, 0, 1]]) == 0 >>> find_shortest_new_road(4, [[0, 1, 1], [2, 3, 2]]) == 1 >>> find_shortest_new_road(4, [[0, 1, 1], [2, 3, 2], [3, 3, 0]]) == 1 >>> find_shortest_new_road(4, [[0, 1, 1]]) == -1 >>> find_shortest_new_road(1, []) == 0","solution":"def find_shortest_new_road(n, roads): Given a number of cities and existing roads, returns the shortest distance required to build a new road such that all cities are connected. Returns 0 if already connected and -1 if no single new road can connect all cities. from heapq import heappop, heappush import itertools # Disjoint Set Union (DSU)/Union-Find structure for detecting connected components class DSU: def __init__(self, n): self.parent = list(range(n)) self.rank = [1] * n def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): xr = self.find(x) yr = self.find(y) if xr == yr: return False if self.rank[xr] < self.rank[yr]: xr, yr = yr, xr self.parent[yr] = xr if self.rank[xr] == self.rank[yr]: self.rank[xr] += 1 return True if n == 1: return 0 dsu = DSU(n) for city1, city2, _ in roads: dsu.union(city1, city2) all_components = {} for city in range(n): root = dsu.find(city) if root not in all_components: all_components[root] = [] all_components[root].append(city) if len(all_components) == 1: return 0 # Calculate shortest distance between different components if len(all_components) > 2: return -1 # Get all nodes that are in each component comp1 = list(all_components.values())[0] comp2 = list(all_components.values())[1] min_distance = float('inf') for u, v in itertools.product(comp1, comp2): min_distance = min(min_distance, abs(u - v)) return min_distance"},{"question":"def max_non_overlapping_events(events: List[List[int]], duration: int) -> int: Returns the maximum number of non-overlapping events that can be attended, without exceeding the given duration, from the provided list of events. Args: events (List[List[int]]): List of events where each event is represented by [start_time, end_time]. duration (int): The maximum total duration that can be attended. Returns: int: The maximum number of non-overlapping events that can be attended. Examples: >>> max_non_overlapping_events([], 10) 0 >>> max_non_overlapping_events([[1, 3]], 3) 1 >>> max_non_overlapping_events([[1, 5]], 3) 0 >>> max_non_overlapping_events([[1, 2], [3, 4], [5, 6]], 7) 3 >>> max_non_overlapping_events([[1, 2], [3, 4], [5, 6]], 5) 2 >>> max_non_overlapping_events([[1, 4], [2, 5], [6, 8]], 7) 2 >>> max_non_overlapping_events([[1, 4], [5, 6], [6, 7]], 6) 2 >>> max_non_overlapping_events([[1, 4], [2, 6], [3, 5]], 5) 1 >>> max_non_overlapping_events([[1, 2], [3, 4], [5, 6]], 5) 2 >>> max_non_overlapping_events([[1, 2], [3, 4], [5, 10]], 15) 3","solution":"def max_non_overlapping_events(events, duration): Returns the maximum number of non-overlapping events that can be attended, without exceeding the given duration, from the provided list of events. Args: events (List[List[int]]): List of events where each event is represented by [start_time, end_time]. duration (int): The maximum total duration that can be attended. Returns: int: The maximum number of non-overlapping events that can be attended. # Sort events by end time to use a greedy approach events.sort(key=lambda x: x[1]) total_duration = 0 count = 0 last_end_time = -1 for start, end in events: event_duration = end - start + 1 if start > last_end_time and total_duration + event_duration <= duration: # Attend this event total_duration += event_duration last_end_time = end count += 1 return count"},{"question":"def sort_by_starting_letter(words: List[str]) -> List[str]: Sort a list of words based on their unique starting letter. Parameters: words (list of str): The list of words to be sorted. Returns: list of str: The sorted list of words. >>> sort_by_starting_letter([\\"b\\", \\"a\\", \\"d\\", \\"c\\"]) [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> sort_by_starting_letter([\\"apple\\", \\"banana\\", \\"apricot\\", \\"blueberry\\", \\"cherry\\"]) [\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\"] >>> sort_by_starting_letter([\\"apple\\", \\"apricot\\", \\"banana\\"]) [\\"apple\\", \\"apricot\\", \\"banana\\"] >>> sort_by_starting_letter([]) [] >>> sort_by_starting_letter([\\"zebra\\", \\"elephant\\", \\"moose\\", \\"ant\\"]) [\\"ant\\", \\"elephant\\", \\"moose\\", \\"zebra\\"] >>> sort_by_starting_letter([\\"car\\", \\"cat\\", \\"dog\\", \\"dove\\"]) [\\"car\\", \\"cat\\", \\"dog\\", \\"dove\\"]","solution":"def sort_by_starting_letter(words): Sort a list of words based on their unique starting letter. Parameters: words (list of str): The list of words to be sorted. Returns: list of str: The sorted list of words. return sorted(words, key=lambda word: word[0])"},{"question":"def min_operations_to_empty_string(s: str) -> int: Determine the minimum number of operations required to make the string empty. Each operation consists of removing all occurrences of a chosen character. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: int: The minimum number of operations required to make the string empty. >>> min_operations_to_empty_string('abcdef') 6 >>> min_operations_to_empty_string('aaaaa') 1 from solution import min_operations_to_empty_string def test_all_unique(): assert min_operations_to_empty_string('abcdef') == 6 def test_single_character(): assert min_operations_to_empty_string('aaaaa') == 1 def test_some_repeated_characters(): assert min_operations_to_empty_string('aabbcc') == 3 def test_mixed_characters(): assert min_operations_to_empty_string('abac') == 3 def test_empty_string(): assert min_operations_to_empty_string('') == 0 def test_one_character_needed_more_removal(): assert min_operations_to_empty_string('abcabc') == 3 def test_long_string_with_repeats(): assert min_operations_to_empty_string('banana') == 3","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations required to make the string empty. Each operation consists of removing all occurrences of a chosen character. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: int: The minimum number of operations required to make the string empty. # Convert the input string to a set of unique characters unique_characters = set(s) # The minimum number of operations is equal to the number of unique characters in the string return len(unique_characters)"},{"question":"def min_operations_to_balance_army(strength: List[int]) -> int: Returns the minimum number of soldiers that need to be either added or removed to make the army balanced. >>> min_operations_to_balance_army([3, 3, 3, 3, 3]) 0 >>> min_operations_to_balance_army([1, 1, 2, 2, 1]) 0 >>> min_operations_to_balance_army([1, 5, 3, 2, 6]) 2 >>> min_operations_to_balance_army([1, 3, 5, 7, 9]) 4 >>> min_operations_to_balance_army([1]) 0 >>> min_operations_to_balance_army([]) 0","solution":"def min_operations_to_balance_army(strength): Returns the minimum number of soldiers that need to be either added or removed to make the army balanced. :param strength: List[int] : A list of integers representing the strength of each soldier :return: int : The minimum number of operations required to balance the army from collections import Counter strength_counter = Counter(strength) max_count = 0 for key in strength_counter: current_count = strength_counter[key] + strength_counter.get(key - 1, 0) + strength_counter.get(key + 1, 0) max_count = max(max_count, current_count) return len(strength) - max_count"},{"question":"def does_subsequence_sum_exist(arr: List[int], x: int) -> bool: Determines if there exists a subsequence in arr such that the sum of its elements equals x. Args: arr (List[int]): The array of integers. x (int): The target sum. Returns: bool: True if such a subsequence exists, False otherwise. >>> does_subsequence_sum_exist([1, 3, 5, 7, 9], 15) True >>> does_subsequence_sum_exist([1, 2, 3], 6) True >>> does_subsequence_sum_exist([4, 12, 5, 9], 21) True >>> does_subsequence_sum_exist([3, 34, 4, 12, 5, 2], 9) True >>> does_subsequence_sum_exist([1, 2, 3], 7) False >>> does_subsequence_sum_exist([4, 5, 6], 2) False >>> does_subsequence_sum_exist([4, 12, 5, 9], 23) False >>> does_subsequence_sum_exist([], 1) False >>> does_subsequence_sum_exist([1], 1) True >>> does_subsequence_sum_exist([2], 1) False >>> does_subsequence_sum_exist([0, 0, 0, 0], 0) True","solution":"def does_subsequence_sum_exist(arr, x): Determines if there exists a subsequence in arr such that the sum of its elements equals x. n = len(arr) dp = [False] * (x + 1) dp[0] = True for num in arr: for j in range(x, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[x]"},{"question":"from typing import List def find_matching_words(wordlist: List[str], typed_word: str) -> List[str]: Find all words in \`wordlist\` that are subsequences of the \`typed_word\`. >>> find_matching_words([\\"apple\\", \\"app\\", \\"apricot\\", \\"banana\\", \\"grape\\"], \\"app\\") [\\"app\\"] >>> find_matching_words([\\"dog\\", \\"cat\\", \\"bat\\"], \\"dcaotg\\") [\\"dog\\", \\"cat\\"] >>> find_matching_words([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_matching_words([\\"cat\\", \\"dog\\", \\"bird\\"], \\"xyz\\") [] >>> find_matching_words([\\"kite\\", \\"light\\", \\"flight\\"], \\"lightkite\\") [\\"kite\\", \\"light\\"]","solution":"def is_subsequence(word, typed_word): Helper function to check if \`word\` is a subsequence of \`typed_word\`. it = iter(typed_word) return all(char in it for char in word) def find_matching_words(wordlist, typed_word): Find all words in \`wordlist\` that are subsequences of the \`typed_word\`. return [word for word in wordlist if is_subsequence(word, typed_word)]"},{"question":"def threeSumTarget(nums: List[int], target: int) -> bool: Determines if there are three distinct elements in nums whose sum is equal to target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: bool: True if such a triplet exists, False otherwise. Examples: >>> threeSumTarget([1, 2, 3, 4, 5], 10) True >>> threeSumTarget([1, -2, 3, 9, -4, 0], 5) True >>> threeSumTarget([1, 2, 3, 4, 5], 50) False >>> threeSumTarget([1, -2, 3, 9, -4, 0], 20) False >>> threeSumTarget([-1, -2, -3, -4, -5], -8) True","solution":"def threeSumTarget(nums, target): Determines if there are three distinct elements in nums whose sum is equal to target. Args: nums (List[int]): List of integers. target (int): Target sum. Returns: bool: True if such a triplet exists, False otherwise. nums.sort() # Sort the array first n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"class Library: def __init__(self): Initializes an empty bookshelf. self.bookshelf = [] def addBook(self, bookId: int, position: int) -> None: Adds the book with the given \`bookId\` at the specified \`position\` in the bookshelf. If the \`position\` is greater than the number of books currently in the bookshelf, the book should be placed at the end. Args: bookId (int): The unique identifier for the book. position (int): The position at which the book should be added. Examples: >>> library = Library() >>> library.addBook(1, 0) >>> library.bookshelf [1] >>> library.addBook(2, 1) >>> library.bookshelf [1, 2] >>> library.addBook(3, 1) >>> library.bookshelf [1, 3, 2] pass def removeBook(self, position: int) -> None: Removes the book at the specified \`position\` in the bookshelf. If the \`position\` is out of range, no action should be taken. Args: position (int): The position from which the book should be removed. Examples: >>> library = Library() >>> library.addBook(1, 0) >>> library.addBook(2, 1) >>> library.addBook(3, 2) >>> library.removeBook(1) >>> library.bookshelf [1, 3] >>> library.removeBook(5) # Out of range >>> library.bookshelf [1, 3] pass def findBooks(self, bookIds: List[int]) -> List[int]: Returns a list containing the positions of the books specified in the \`bookIds\` array. If a book is not found, returns -1 for its position. Args: bookIds (List[int]): A list of book identifiers. Returns: List[int]: A list of positions for the given book IDs, or -1 if a book is not found. Examples: >>> library = Library() >>> library.addBook(1, 0) >>> library.addBook(2, 1) >>> library.addBook(3, 2) >>> library.findBooks([2, 3, 4]) [1, 2, -1] >>> library.findBooks([1, 2, 3]) [0, 1, 2] >>> library.findBooks([5]) [-1] pass def test_addBook(): library = Library() library.addBook(1, 0) library.addBook(2, 1) library.addBook(3, 1) # Should insert 3 at position 1 assert library.bookshelf == [1, 3, 2] def test_removeBook(): library = Library() library.addBook(1, 0) library.addBook(2, 1) library.addBook(3, 2) library.removeBook(1) # Should remove book with id 2 assert library.bookshelf == [1, 3] library.removeBook(5) # Out of range, should do nothing assert library.bookshelf == [1, 3] def test_findBooks(): library = Library() library.addBook(1, 0) library.addBook(2, 1) library.addBook(3, 2) assert library.findBooks([2, 3, 4]) == [1, 2, -1] assert library.findBooks([1, 2, 3]) == [0, 1, 2] assert library.findBooks([5]) == [-1]","solution":"class Library: def __init__(self): self.bookshelf = [] def addBook(self, bookId, position): if position < len(self.bookshelf): self.bookshelf.insert(position, bookId) else: self.bookshelf.append(bookId) def removeBook(self, position): if 0 <= position < len(self.bookshelf): self.bookshelf.pop(position) def findBooks(self, bookIds): result = [] for bookId in bookIds: try: result.append(self.bookshelf.index(bookId)) except ValueError: result.append(-1) return result"},{"question":"def max_subgroups(players: List[str], k: int) -> int: Calculate the maximum number of subgroups with exactly \`k\` different ranks. Args: players: List of strings where each string is in the format \\"name_rank\\". k: Integer, the distinct number of ranks required in each subgroup. Returns: The maximum number of subgroups that can be formed. >>> max_subgroups([\\"john_1\\", \\"jack_2\\", \\"jake_1\\", \\"luke_2\\", \\"paul_3\\", \\"mike_3\\"], 3) 2 >>> max_subgroups([\\"john_1\\", \\"jack_2\\", \\"jake_1\\"], 3) 0 >>> max_subgroups([\\"john_1\\", \\"jack_2\\", \\"jake_3\\", \\"luke_4\\"], 4) 1 >>> max_subgroups([\\"john_1\\", \\"jack_2\\", \\"jake_1\\", \\"luke_2\\", \\"paul_3\\", \\"mike_3\\", \\"peter_3\\"], 3) 2 >>> max_subgroups([\\"a_1\\", \\"b_2\\", \\"c_3\\"], 3) 1 >>> max_subgroups([], 3) 0 >>> max_subgroups([\\"a_1\\", \\"b_2\\", \\"c_1\\", \\"d_2\\", \\"e_3\\"], 4) 0","solution":"from collections import defaultdict def max_subgroups(players, k): Calculate the maximum number of subgroups with exactly \`k\` different ranks. Args: players: List of strings where each string is in the format \\"name_rank\\". k: Integer, the distinct number of ranks required in each subgroup. Returns: The maximum number of subgroups that can be formed. rank_count = defaultdict(int) # Count occurrences of each rank for player in players: rank = player.split('_')[-1] rank_count[rank] += 1 # Find the minimum count among the ranks, as the subgroup is limited by the least frequent rank if len(rank_count) < k: return 0 return min(rank_count.values()) # Example # players = [\\"john_1\\", \\"jack_2\\", \\"jake_1\\", \\"luke_2\\", \\"paul_3\\", \\"mike_3\\"] # k = 3 # Should return 2 since we can form 2 subgroups each with ranks 1, 2, and 3."},{"question":"def max_meetings(meetings): Returns the maximum number of meetings that a person can attend. Parameters: meetings (list of list): A list of [start, end] representing the meeting times. Returns: int: The maximum number of meetings that a person can attend. >>> max_meetings([]) 0 >>> max_meetings([[1, 2], [3, 4], [5, 6]]) 3 >>> max_meetings([[1, 3], [2, 4], [3, 5]]) 2 >>> max_meetings([[1, 4], [2, 3], [3, 5], [7, 8]]) 3 >>> max_meetings([[1, 2], [1, 2], [1, 2]]) 1 >>> max_meetings([[1, 2], [1, 3], [1, 4]]) 1","solution":"def max_meetings(meetings): Returns the maximum number of meetings that a person can attend. Parameters: meetings (list of list): A list of [start, end] representing the meeting times. Returns: int: The maximum number of meetings that a person can attend. if not meetings: return 0 # Sort meetings by end time meetings.sort(key=lambda x: x[1]) # Initialize the count of meetings and the end time of the last selected meeting count = 0 last_end_time = 0 for start, end in meetings: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"from typing import List, Tuple def min_flower_types(nums: List[int], restrictions: List[Tuple[int, int]]) -> int: Determine the minimum number of flower types required such that no two directly connected gardens have the same type of flowers. Args: nums (List[int]): A list of non-negative integers representing the number of flowers in each garden. restrictions (List[Tuple[int, int]]): A list where each pair (x, y) means that garden x is directly connected to garden y and cannot have the same type of flowers. Returns: int: The minimum number of flower types required, or -1 if it is not possible. Examples: >>> min_flower_types([4, 3, 5, 2], []) 2 >>> min_flower_types([3, 2, 4], [[0, 1], [1, 2]]) 2 >>> min_flower_types([3, 2, 4, 5], [[0, 1], [2, 3]]) 2 >>> min_flower_types([3, 2, 4], [[0, 1], [1, 2], [2, 0]]) -1 >>> num_gardens = 1000 >>> gardens = [0] * num_gardens >>> restrictions = [[i, i+1] for i in range(num_gardens-1)] >>> min_flower_types(gardens, restrictions) 2","solution":"def min_flower_types(nums, restrictions): from collections import defaultdict def is_bipartite(graph): color = {} for node in graph: if node not in color: stack = [node] color[node] = 0 while stack: node = stack.pop() for neighbor in graph[node]: if neighbor not in color: stack.append(neighbor) color[neighbor] = color[node] ^ 1 elif color[neighbor] == color[node]: return False return True # Create the graph from restrictions graph = defaultdict(list) for x, y in restrictions: graph[x].append(y) graph[y].append(x) # Check if the graph is bipartite if not is_bipartite(graph): return -1 # If bipartite, at most 2 flower types are required return 2"},{"question":"def get_maximum_gold(grid): Return the maximum amount of gold Alice can collect starting from any cell in the grid. >>> get_maximum_gold([ ... [0, 6, 0], ... [5, 8, 7], ... [0, 9, 0] ... ]) == 24 >>> get_maximum_gold([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> get_maximum_gold([ ... [0, 0, 10], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 10 >>> get_maximum_gold([ ... [1, 2, 0], ... [0, 3, 4], ... [7, 6, 5] ... ]) == 28 >>> get_maximum_gold([ ... [0, 0, 0, 0], ... [0, 0, 5, 0], ... [0, 0, 0, 0] ... ]) == 5 >>> get_maximum_gold([ ... [0] * 10 for _ in range(10) ... ]) == 0","solution":"def get_maximum_gold(grid): def dfs(x, y, visited): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or (x, y) in visited or grid[x][y] == 0: return 0 visited.add((x, y)) max_gold = 0 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: max_gold = max(max_gold, dfs(x + dx, y + dy, visited)) visited.remove((x, y)) return max_gold + grid[x][y] max_gold = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] != 0: max_gold = max(max_gold, dfs(i, j, set())) return max_gold"},{"question":"def height_checker(heights: List[int]) -> int: Given an array of integers heights representing the heights of students standing in a line, rearrange the students such that every student is at least as tall as the one in front of them when looking from left to right. Return the number of students that are not in the same position in the final arrangement as they were before. >>> height_checker([1, 2, 3, 4]) == 0 >>> height_checker([4, 3, 2, 1]) == 4 >>> height_checker([1, 3, 2, 4]) == 2 >>> height_checker([1, 1, 1, 1]) == 0 >>> height_checker([10, 5, 5, 10]) == 2 >>> height_checker([10000, 5000, 5000, 10000]) == 2","solution":"def height_checker(heights): Returns the number of students that are not in the same position in the final arrangement. sorted_heights = sorted(heights) count = 0 for original, sorted_height in zip(heights, sorted_heights): if original != sorted_height: count += 1 return count"},{"question":"from typing import List def largest_number(nums: List[int]) -> str: Arrange a list of non-negative integers such that they form the largest number. Concatenate the numbers in such a way that the resulting string is the largest possible. Args: nums (List[int]): a list of non-negative integers Returns: str: the largest number represented as a string >>> largest_number([10, 2]) == \\"210\\" >>> largest_number([3, 30, 34, 5, 9]) == \\"9534330\\" >>> largest_number([1]) == \\"1\\" >>> largest_number([10]) == \\"10\\" >>> largest_number([0, 0]) == \\"0\\" >>> largest_number([91, 9, 903]) == \\"991903\\" >>> largest_number([432, 43243]) == \\"43243432\\" >>> largest_number([20, 1]) == \\"201\\" >>> largest_number([20, 20, 20]) == \\"202020\\" >>> largest_number([]) == \\"\\"","solution":"from functools import cmp_to_key def largest_number(nums): Arrange a list of non-negative integers such that they form the largest number. Concatenate the numbers in such a way that the resulting string is the largest possible. Args: nums (List[int]): a list of non-negative integers Returns: str: the largest number represented as a string if not nums: return \\"\\" # Convert numbers to strings for easy concatenation nums_str = [str(num) for num in nums] # Comparator to decide the order based on their combination def compare(x, y): return -1 if x + y > y + x else 1 if x + y < y + x else 0 # Sort array with custom comparator nums_str.sort(key=cmp_to_key(compare)) # Edge case: If the largest number is \\"0\\", then all numbers are \\"0\\" if nums_str[0] == \\"0\\": return \\"0\\" # Join sorted list to form the largest number return \\"\\".join(nums_str)"},{"question":"def largestRectangleArea(heights): Determine the largest rectangle that can be formed in a histogram. :param heights: List[int], a list where each element represents the height of a vertical line in a histogram. :return: int, the maximum rectangular area that can be formed. >>> largestRectangleArea([2,1,5,6,2,3]) 10 >>> largestRectangleArea([2,4]) 4 >>> largestRectangleArea([1]) 1 >>> largestRectangleArea([5]) 5 >>> largestRectangleArea([5,5,5,5,5]) 25 >>> largestRectangleArea([1,2,3,4,5]) 9 >>> largestRectangleArea([5,4,3,2,1]) 9 >>> largestRectangleArea([2,1,2]) 3 >>> largestRectangleArea([1,1,1,1,1,2,2,2,2,2]) 10 >>> largestRectangleArea([]) 0","solution":"def largestRectangleArea(heights): Determine the largest rectangle that can be formed in a histogram. :param heights: List[int], a list where each element represents the height of a vertical line in a histogram. :return: int, the maximum rectangular area that can be formed. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def min_ramps(heights: List[int], maxHeightDiff: int) -> int: Return the minimum number of ramps needed to traverse the entire street from the first building to the last building according to the maxHeightDiff constraint. >>> min_ramps([1, 2, 3, 4], 2) 0 >>> min_ramps([1, 5, 3, 4], 2) 1 >>> min_ramps([1, 5, 3, 7, 2], 1) 4 >>> min_ramps([1, 10, 20, 30, 40], 8) 4 >>> min_ramps([1, 2, 3, 4], 0) 3 >>> min_ramps([3, 3, 3, 3], 2) 0 >>> min_ramps([5], 2) 0 >>> min_ramps([2, 4], 4) 0 >>> min_ramps([2, 7], 2) 1","solution":"def min_ramps(heights, maxHeightDiff): Return the minimum number of ramps needed to traverse the entire street from the first building to the last building according to the maxHeightDiff constraint. min_ramps_needed = 0 # Traverse through the array and calculate the number of ramps needed for i in range(len(heights) - 1): if abs(heights[i + 1] - heights[i]) > maxHeightDiff: min_ramps_needed += 1 return min_ramps_needed"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_subtree_at_depth_k(root, queries, k_values): Given a binary tree, find the sum of all node values in the subtree rooted at nodes specified by \`queries\` with depth less than or equal to \`k_values\` from the depth of the respective nodes. >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> queries = [1, 2, 3] >>> k_values = [1, 1, 0] >>> sum_subtree_at_depth_k(root, queries, k_values) [6, 11, 3] >>> root = TreeNode(1) >>> queries = [1] >>> k_values = [1] >>> sum_subtree_at_depth_k(root, queries, k_values) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> queries = [1, 2] >>> k_values = [2, 1] >>> sum_subtree_at_depth_k(root, queries, k_values) [6, 5] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> queries = [10] >>> k_values = [1] >>> sum_subtree_at_depth_k(root, queries, k_values) [0] >>> root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) >>> queries = [2, 3] >>> k_values = [2, 2] >>> sum_subtree_at_depth_k(root, queries, k_values) [11, 16]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_subtree_at_depth_k(root, queries, k_values): def find_node_and_depth(tree, val, depth=0): if not tree: return None, -1 if tree.val == val: return tree, depth left_result = find_node_and_depth(tree.left, val, depth + 1) if left_result[0]: return left_result return find_node_and_depth(tree.right, val, depth + 1) def sum_at_max_depth(tree, max_depth, current_depth=0): if not tree: return 0 if current_depth > max_depth: return 0 return tree.val + sum_at_max_depth(tree.left, max_depth, current_depth + 1) + sum_at_max_depth(tree.right, max_depth, current_depth + 1) results = [] for query, k in zip(queries, k_values): node, depth = find_node_and_depth(root, query) if node is None: results.append(0) else: results.append(sum_at_max_depth(node, depth + k)) return results"},{"question":"def rotate_image(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): The matrix to be rotated. Returns: List[List[int]]: The rotated matrix. Examples: >>> rotate_image([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_image([ ... [5, 1, 9, 11], ... [2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ]) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> rotate_image([ ... [1, 2], ... [3, 4] ... ]) [[3, 1], [4, 2]] >>> rotate_image([ ... [1] ... ]) [[1]] >>> rotate_image([]) []","solution":"def rotate_image(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def character_replacement(s: str, k: int) -> int: Finds the length of the longest substring that contains all repeating letters after performing k replacements. >>> character_replacement(\\"AAAA\\", 0) == 4 >>> character_replacement(\\"BBBBB\\", 1) == 5 >>> character_replacement(\\"AABABBA\\", 1) == 4 >>> character_replacement(\\"ABAB\\", 2) == 4 >>> character_replacement(\\"ABCDE\\", 2) == 3","solution":"def character_replacement(s, k): Finds the length of the longest substring that contains all repeating letters after performing k replacements. max_length = 0 start = 0 max_count = 0 counts = {} for end in range(len(s)): letter = s[end] if letter in counts: counts[letter] += 1 else: counts[letter] = 1 max_count = max(max_count, counts[letter]) if (end - start + 1) - max_count > k: counts[s[start]] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def goodNodes(root: TreeNode) -> int: In a binary tree, we define a \\"good\\" node as a node that is larger than or equal to all the nodes in the path from the root to that node. Given the \`root\` of a binary tree, returns the number of good nodes in the tree. >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.left.left = TreeNode(3) >>> root.right = TreeNode(4) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(5) >>> goodNodes(root) 4 >>> root = TreeNode(1) >>> goodNodes(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(3) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(3) >>> root.right.left = TreeNode(3) >>> root.right.right = TreeNode(3) >>> goodNodes(root) 7 >>> root = TreeNode(3) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(1) >>> goodNodes(root) 1 >>> root = TreeNode(3) >>> root.left = TreeNode(1) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(5) >>> goodNodes(root) 4","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def goodNodes(root): def dfs(node, max_val): if not node: return 0 good = 1 if node.val >= max_val else 0 max_val = max(max_val, node.val) left_good = dfs(node.left, max_val) right_good = dfs(node.right, max_val) return good + left_good + right_good return dfs(root, root.val)"},{"question":"def count_interesting_subarrays(nums: List[int], k: int) -> int: Returns the count of interesting subarrays in nums where the sum of elements in the subarray is divisible by k. >>> count_interesting_subarrays([1, 2, 3], 3) # 3 [3], [1, 2], [1, 2, 3] >>> count_interesting_subarrays([1, 2, 4], 5) # 0 No subarrays are divisible by 5 >>> count_interesting_subarrays([2, 2, 2], 2) # 6 All subarrays are interesting >>> count_interesting_subarrays([-1, 2, 9, -3, 1], 3) # 4 [-1, 2, -1], [2, 9, -3], [9, -3, 1], [-1, 2, 9, -3, 1] >>> count_interesting_subarrays([5, 10, 15, 20, 25], 100) # 0 No subarrays are divisible by 100","solution":"def count_interesting_subarrays(nums, k): Returns the count of interesting subarrays in nums where the sum of elements in the subarray is divisible by k. :param nums: List of integers :param k: Integer :return: Integer count of interesting subarrays count = 0 prefix_sum = 0 prefix_count = {0: 1} # Dict to store the frequency of prefix sums mod k for num in nums: prefix_sum += num mod_value = prefix_sum % k # Adjust mod_value to be positive if mod_value < 0: mod_value += k # Check if there is a prefix sum that gives mod_value if mod_value in prefix_count: count += prefix_count[mod_value] # Increment the frequency of the current mod_value if mod_value in prefix_count: prefix_count[mod_value] += 1 else: prefix_count[mod_value] = 1 return count"},{"question":"def max_tasks_on_time(tasks, deadlines): Determines the maximum number of tasks David can complete without missing any deadlines. :param tasks: List of integers where tasks[i] is the time required for the i-th task. :param deadlines: List of integers where deadlines[i] is the deadline for the i-th task. :return: Maximum number of tasks David can complete on time. from solution import max_tasks_on_time def test_no_tasks(): assert max_tasks_on_time([], []) == 0 def test_single_task_on_time(): assert max_tasks_on_time([1], [2]) == 1 def test_single_task_missed(): assert max_tasks_on_time([3], [2]) == 0 def test_multiple_tasks_all_on_time(): assert max_tasks_on_time([1, 2, 1], [3, 5, 4]) == 3 def test_multiple_tasks_some_on_time(): assert max_tasks_on_time([1, 3, 2, 1], [4, 5, 3, 2]) == 3 def test_overlapping_deadlines(): assert max_tasks_on_time([2, 3, 4], [3, 4, 5]) == 1 def test_with_complex_scenario(): assert max_tasks_on_time([1, 2, 3, 4], [2, 3, 5, 6]) == 2","solution":"def max_tasks_on_time(tasks, deadlines): Determines the maximum number of tasks David can complete without missing any deadlines. :param tasks: List of integers where tasks[i] is the time required for the i-th task. :param deadlines: List of integers where deadlines[i] is the deadline for the i-th task. :return: Maximum number of tasks David can complete on time. # Combine tasks and deadlines into a list of tuples (task_time, deadline) task_with_deadline = list(zip(tasks, deadlines)) # Sort the tasks based on their deadlines in ascending order task_with_deadline.sort(key=lambda x: x[1]) current_time = 0 completed_tasks = 0 # Iterate through the sorted tasks for task_time, deadline in task_with_deadline: # If the current time plus task time does not exceed the deadline if current_time + task_time <= deadline: # David can complete this task current_time += task_time completed_tasks += 1 return completed_tasks"},{"question":"def move_target_to_end(nums, target): Move all occurrences of target to the end of the array while maintaining the relative order of the other elements. Do this in-place using constant extra space. Args: nums (list of int): The list of integers. target (int): The integer to be moved to the end. Returns: list of int: The modified list with all occurrences of target moved to the end. >>> move_target_to_end([1, 2, 3, 4, 5], 6) [1, 2, 3, 4, 5] >>> move_target_to_end([5, 5, 5, 5, 5], 5) [5, 5, 5, 5, 5] >>> move_target_to_end([1, 2, 5, 3, 5, 4], 5) [1, 2, 3, 4, 5, 5] >>> move_target_to_end([0, 1, 0, 2, 3, 0, 4], 0) [1, 2, 3, 4, 0, 0, 0] >>> move_target_to_end([5, 1, 2, 3, 5, 4], 5) [1, 2, 3, 4, 5, 5] >>> move_target_to_end([1, 2, 3, 4, 5, 5], 5) [1, 2, 3, 4, 5, 5] >>> move_target_to_end([], 5) [] >>> move_target_to_end([5], 5) [5] >>> move_target_to_end([1], 5) [1]","solution":"def move_target_to_end(nums, target): Move all occurrences of target to the end of the array while maintaining the relative order of the other elements. Do this in-place using constant extra space. Args: nums (list of int): The list of integers. target (int): The integer to be moved to the end. Returns: list of int: The modified list with all occurrences of target moved to the end. insert_pos = 0 for i in range(len(nums)): if nums[i] != target: nums[insert_pos] = nums[i] insert_pos += 1 while insert_pos < len(nums): nums[insert_pos] = target insert_pos += 1 return nums"},{"question":"def length_of_longest_unique_subarray(nums: List[int]) -> int: Returns the length of the longest continuous subarray that contains only unique elements. >>> length_of_longest_unique_subarray([]) == 0 >>> length_of_longest_unique_subarray([1]) == 1 >>> length_of_longest_unique_subarray([1, 2, 3, 4, 5]) == 5 >>> length_of_longest_unique_subarray([1, 2, 2, 3, 4]) == 3 >>> length_of_longest_unique_subarray([1, 2, 3, 4, 2, 5]) == 4 >>> length_of_longest_unique_subarray([1, 2, 2, 2, 2]) == 2 >>> length_of_longest_unique_subarray(list(range(1000))) == 1000 >>> length_of_longest_unique_subarray([i%10 for i in range(100)]) == 10 >>> length_of_longest_unique_subarray([1, 1, 1, 1]) == 1","solution":"def length_of_longest_unique_subarray(nums): Returns the length of the longest continuous subarray that contains only unique elements. if not nums: return 0 n = len(nums) unique_elements = set() max_length = 0 left = 0 for right in range(n): while nums[right] in unique_elements: unique_elements.remove(nums[left]) left += 1 unique_elements.add(nums[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> List[int]: Search for a target value in a sorted 2D matrix. Args: matrix (List[List[int]]): A 2D list of integers where each row and column is sorted in ascending order. target (int): The target integer to search for. Returns: List[int]: A list containing the row and column indices of the target, or [-1, -1] if not found. Examples: >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) [1, 1] >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) [-1, -1] >>> search_matrix([], 1) [-1, -1] >>> search_matrix([[5]], 5) [0, 0] >>> search_matrix([[5]], 3) [-1, -1] >>> result = search_matrix([ [1, 2, 3], [1, 2, 3], [1, 2, 3] ], 2) assert result == [0, 1] or result == [1, 1] or result == [2, 1]","solution":"def search_matrix(matrix, target): Searches for a target value in a sorted 2D matrix. Args: matrix (List[List[int]]): 2D list of integers where each row and column is sorted. target (int): The target integer to search for. Returns: List[int]: A list containing the row and column indices of the target, or [-1, -1] if not found. if not matrix or not matrix[0]: return [-1, -1] rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return [row, col] elif matrix[row][col] > target: col -= 1 else: row += 1 return [-1, -1]"},{"question":"from typing import List def threeSumClosest(nums: List[int], target: int) -> int: Find three integers in nums such that the sum is closest to target. Return the sum of the three integers. >>> threeSumClosest([1, 1, 1, 0], -100) 2 >>> threeSumClosest([-1, 2, 1, -4], 1) 2 >>> threeSumClosest([0, 0, 0], 1) 0 >>> threeSumClosest([1, 2, 4, 8, 16, 32, 64, 128], 82) 82 >>> threeSumClosest([10, 20, -10, -20, 30, -30, 40], 10) 10","solution":"from typing import List def threeSumClosest(nums: List[int], target: int) -> int: nums.sort() closest_sum = float('inf') for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"def min_subarrays_with_limit(arr: List[int], limit: int) -> int: Returns the minimum number of subarrays such that the sum of each subarray is less than or equal to the given limit. :param arr: List of integers :param limit: Integer, limit that the sum of each subarray should not exceed :return: Integer, minimum number of subarrays >>> min_subarrays_with_limit([3], 5) 1 >>> min_subarrays_with_limit([6], 5) -1 >>> min_subarrays_with_limit([1, 2, 3], 10) 1 >>> min_subarrays_with_limit([5, 6, 7], 4) -1 >>> min_subarrays_with_limit([1, 4, 5, 2, 3], 6) 3 >>> min_subarrays_with_limit([1, 1, 1, 1, 1], 2) 3 >>> min_subarrays_with_limit([], 5) 0 >>> min_subarrays_with_limit([100, 200, 300], 500) 2","solution":"def min_subarrays_with_limit(arr, limit): Returns the minimum number of subarrays such that the sum of each subarray is less than or equal to the given limit. :param arr: List of integers :param limit: Integer, limit that the sum of each subarray should not exceed :return: Integer, minimum number of subarrays if not arr: return 0 count = 1 current_sum = 0 for num in arr: if num > limit: return -1 # if any single element is greater than limit, it's impossible to form valid subarrays if current_sum + num > limit: count += 1 current_sum = num else: current_sum += num return count"},{"question":"def min_moves_to_equal_elements(arr: List[int]) -> int: Given an integer array \`arr\`, determine the minimum number of moves required to make all elements in the array equal. In one move, you can increment or decrement any element of the array by 1. Return the minimum number of moves needed to make all elements the same. >>> min_moves_to_equal_elements([1, 10, 2, 9]) 16 >>> min_moves_to_equal_elements([5, 5, 5, 5]) 0 >>> min_moves_to_equal_elements([1, 2, 3, 4, 5]) 6 >>> min_moves_to_equal_elements([5, 4, 3, 2, 1]) 6 >>> min_moves_to_equal_elements([-1, -10, -2, -9]) 16 >>> min_moves_to_equal_elements([-1, 0, 1]) 2 >>> min_moves_to_equal_elements([100]) 0 >>> min_moves_to_equal_elements([1000000, -1000000]) 2000000","solution":"def min_moves_to_equal_elements(arr): Determines the minimum number of moves required to make all elements in the array equal. In one move, you can increment or decrement any element of the array by 1. arr.sort() median = arr[len(arr) // 2] return sum(abs(x - median) for x in arr)"},{"question":"from typing import List def top_k_frequent(nums: List[int], k: int) -> List[int]: Return the k most frequent elements in nums. >>> top_k_frequent([1], 1) [1] >>> top_k_frequent([1, 2, 3, 4], 2) [1, 2] >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 1, 2, 2, 3, 3], 3) [1, 2, 3] >>> top_k_frequent([4, 1, -1, 2, -1, 2, 3], 2) [-1, 2] >>> top_k_frequent([], 1) []","solution":"from collections import Counter import heapq def top_k_frequent(nums, k): Return the k most frequent elements in nums. if not nums: return [] # Count the frequencies of each element in nums count = Counter(nums) # Use a heap to keep track of the top k frequent elements # heapq.nlargest returns the n largest elements in a list return [item for item, frequency in heapq.nlargest(k, count.items(), key=lambda item: item[1])]"},{"question":"def rearrange_for_max_sum(arr: List[int], m: int) -> List[int]: Rearrange the elements of 'arr' such that the sum of elements in every contiguous subarray of size 'm' is maximized. Parameters: arr (list of int): The input array. m (int): Contiguous subarray size. Returns: list of int: Rearranged array for maximum sum in every subarray of size 'm'. Examples: >>> rearrange_for_max_sum([1, 3, 2, 5, 4], 3) [5, 4, 3, 2, 1] >>> rearrange_for_max_sum([1, 2, 2, 5, 2], 2) [5, 2, 2, 2, 1] >>> rearrange_for_max_sum([10], 1) [10] >>> rearrange_for_max_sum([3, 1], 2) [3, 1] >>> rearrange_for_max_sum([2, 2, 2, 2, 2], 3) [2, 2, 2, 2, 2] >>> rearrange_for_max_sum([5, 4, 3, 2, 1], 2) [5, 4, 3, 2, 1] >>> rearrange_for_max_sum([-1, -3, -2, -5, -4], 3) [-1, -2, -3, -4, -5] >>> rearrange_for_max_sum([3, 1, 2], 4) [3, 2, 1]","solution":"def rearrange_for_max_sum(arr, m): This function rearranges the elements of 'arr' such that the sum of elements in every contiguous subarray of size 'm' is maximized. Parameters: arr (list of int): The input array. m (int): Contiguous subarray size. Returns: list of int: Rearranged array for maximum sum in every subarray of size 'm'. # Sort the array in descending order arr_sorted = sorted(arr, reverse=True) return arr_sorted"},{"question":"def max_subarray_sum(nums, k): Returns the maximum possible sum of a subarray of length k. >>> max_subarray_sum([1, 2, 3, 4, 5], 2) == 9 # [4, 5] >>> max_subarray_sum([1, 2, 3, 4, 5], 3) == 12 # [3, 4, 5] >>> max_subarray_sum([-1, -2, -3, -4, -5], 2) == -3 # [-1, -2] >>> max_subarray_sum([1, 2, 3, 0, -1], 3) == 6 # [1, 2, 3] >>> max_subarray_sum([5, 5, 5, 5, 5], 1) == 5 # [5] >>> max_subarray_sum([1], 1) == 1 # [1] >>> max_subarray_sum([], 1) == 0 # Empty array >>> max_subarray_sum([1, 2, 3], 4) == 0 # k > len(nums)","solution":"def max_subarray_sum(nums, k): Returns the maximum possible sum of a subarray of length k. if len(nums) < k: return 0 # Compute the sum of the first subarray of length k max_sum = current_sum = sum(nums[:k]) # Iterate through the array, updating the sum by sliding the window for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_linked_list(head: ListNode) -> ListNode: Reorders the linked list such that nodes appear in an alternating pattern of high and low values. >>> linked_list_to_list(reorder_linked_list(list_to_linked_list([1]))) == [1] >>> linked_list_to_list(reorder_linked_list(list_to_linked_list([1, 2]))) == [2, 1] >>> linked_list_to_list(reorder_linked_list(list_to_linked_list([1, 3, 2]))) == [3, 1, 2] >>> linked_list_to_list(reorder_linked_list(list_to_linked_list([1, 4, 3, 2]))) == [4, 1, 3, 2] >>> linked_list_to_list(reorder_linked_list(list_to_linked_list([1, 5, 3, 4, 2]))) == [5, 1, 4, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorder_linked_list(head): Reorders the linked list such that nodes appear in an alternating pattern of high and low values. if not head or not head.next: return head # Convert linked list to list of values values = [] current = head while current: values.append(current.val) current = current.next # Sort values values.sort() # Rebuild the list in the specific order high = 0 # Index for the largest values low = len(values) - 1 # Index for the smallest values current = head toggle = False # Start with largest value while high <= low: if toggle: current.val = values[high] high += 1 else: current.val = values[low] low -= 1 toggle = not toggle current = current.next return head"},{"question":"from typing import Dict class ExerciseTracker: def __init__(self): Initializes the ExerciseTracker object. pass def recordActivity(self, activityId: str, userId: str, startTime: int, endTime: int): Records an activity for the given user with the specified activity ID, start time, and end time. pass def getUserTotalExerciseTime(self, userId: str, startTime: int, endTime: int) -> Dict[str, int]: Returns a summary for the given user within the specified time period [startTime, endTime]. The summary should include the total exercise time for each activity performed by the user in minutes. pass from solution import ExerciseTracker def test_single_activity(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 10, 20) result = tracker.getUserTotalExerciseTime(\\"U1\\", 10, 20) assert result == {\\"A1\\": 11} def test_non_overlapping_periods(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 10, 20) result = tracker.getUserTotalExerciseTime(\\"U1\\", 21, 30) assert result == {} def test_overlapping_activities(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 10, 20) tracker.recordActivity(\\"A2\\", \\"U1\\", 15, 25) result = tracker.getUserTotalExerciseTime(\\"U1\\", 10, 25) assert result == {\\"A1\\": 11, \\"A2\\": 11} def test_partial_overlap(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 10, 20) result = tracker.getUserTotalExerciseTime(\\"U1\\", 15, 30) assert result == {\\"A1\\": 6} def test_multiple_users(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 10, 20) tracker.recordActivity(\\"A2\\", \\"U2\\", 10, 20) result = tracker.getUserTotalExerciseTime(\\"U1\\", 10, 20) assert result == {\\"A1\\": 11} result = tracker.getUserTotalExerciseTime(\\"U2\\", 10, 20) assert result == {\\"A2\\": 11} def test_activity_outside_period(): tracker = ExerciseTracker() tracker.recordActivity(\\"A1\\", \\"U1\\", 5, 9) result = tracker.getUserTotalExerciseTime(\\"U1\\", 10, 20) assert result == {}","solution":"from collections import defaultdict from typing import Dict class ExerciseTracker: def __init__(self): self.activities = defaultdict(list) def recordActivity(self, activityId: str, userId: str, startTime: int, endTime: int): self.activities[userId].append((activityId, startTime, endTime)) def getUserTotalExerciseTime(self, userId: str, startTime: int, endTime: int) -> Dict[str, int]: totalTimes = defaultdict(int) user_activities = self.activities.get(userId, []) for activityId, a_startTime, a_endTime in user_activities: # Calculate overlapping time period overlap_start = max(startTime, a_startTime) overlap_end = min(endTime, a_endTime) if overlap_start <= overlap_end: totalTimes[activityId] += (overlap_end - overlap_start + 1) return dict(totalTimes)"},{"question":"def find_pairs_with_sum(arr: list, target: int) -> list: Finds all pairs of distinct indices (i, j) such that arr[i] + arr[j] = target. Parameters: arr (list): List of integers. target (int): Target sum. Returns: list: List of pairs (tuples) where the sum of elements at the indices equals the target. Example usage: >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(1, 3), (2, 4)] >>> find_pairs_with_sum([1, 1, 1, 1], 2) [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]","solution":"def find_pairs_with_sum(arr, target): Finds all pairs of distinct indices (i, j) such that arr[i] + arr[j] = target. Parameters: arr (list): List of integers. target (int): Target sum. Returns: list: List of pairs (tuples) where the sum of elements at the indices equals the target. pairs = [] index_map = {} for i, num in enumerate(arr): complement = target - num if complement in index_map: pairs.extend([(prev_index, i) for prev_index in index_map[complement]]) if num in index_map: index_map[num].append(i) else: index_map[num] = [i] pairs.sort() return pairs"},{"question":"def shortestBridge(grid: List[List[int]]) -> int: Given an \`n x n\` grid where some of the squares are land (1) and some are water (0), return the length of the shortest bridge that connects two islands. An island is defined as a series of 1's connected horizontally, vertically, or diagonally. >>> grid1 = [ ... [0, 1], ... [1, 0] ... ] >>> shortestBridge(grid1) 1 >>> grid2 = [ ... [0, 1, 0], ... [0, 0, 0], ... [0, 0, 1] ... ] >>> shortestBridge(grid2) 2 >>> grid3 = [ ... [1, 1, 1, 1, 1], ... [1, 0, 0, 0, 1], ... [1, 0, 1, 0, 1], ... [1, 0, 0, 0, 1], ... [1, 1, 1, 1, 1] ...] >>> shortestBridge(grid3) 1 >>> grid4 = [ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ...] >>> shortestBridge(grid4) 1 >>> grid5 = [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ...] >>> shortestBridge(grid5) -1 # All are connected, no separate islands to bridge.","solution":"def shortestBridge(grid): import collections def bfs(): BFS to find and mark all the lands of the first island found. queue = collections.deque() found = False # Find first island and mark it with -1 for i in range(len(grid)): if found: break for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j, queue) found = True break return queue def dfs(i, j, queue): DFS to mark a full island starting from (i, j) and add it to queue. if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != 1: return grid[i][j] = -1 queue.append((i, j)) dfs(i + 1, j, queue) dfs(i - 1, j, queue) dfs(i, j + 1, queue) dfs(i, j - 1, queue) queue = bfs() steps = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Expand from the island marked as -1 while queue: for _ in range(len(queue)): x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]): if grid[nx][ny] == 1: return steps if grid[nx][ny] == 0: grid[nx][ny] = -1 queue.append((nx, ny)) steps += 1 return -1 # Placeholder, should never happen if input guarantees two islands."},{"question":"def trap(height: List[int]) -> int: Given a list of non-negative integers height representing the height of each wall section, return the total amount of water trapped between the walls. >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([]) 0 >>> trap([1]) 0 >>> trap([1, 2]) 0 >>> trap([3, 3, 3, 3]) 0 >>> trap([5, 4, 3, 2, 1, 2, 3, 4, 5]) 16 >>> trap([2, 0, 2]) 2 >>> trap([10000, 1, 10000]) 9999 >>> trap([3, 0, 1, 3, 0, 5]) 8","solution":"def trap(height): Given a list of non-negative integers height representing the height of each wall section, return the total amount of water trapped between the walls. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def min_cost_to_make_unique(nums: List[int], cost: List[int]) -> int: You are given a list of integers \`nums\` sorted in non-decreasing order, and you are required to remove some elements to make the remaining elements unique with minimum possible cost. The cost of removing an element is given in another list \`cost\`, where \`cost[i]\` is the cost of removing the element \`nums[i]\`. Return the minimum cost to make all elements in the list unique. >>> min_cost_to_make_unique([1, 2, 3], [3, 2, 1]) == 0 >>> min_cost_to_make_unique([1, 1, 2], [3, 4, 1]) == 4 >>> min_cost_to_make_unique([1, 1, 1, 2, 3, 3], [3, 4, 5, 1, 2, 6]) == 15 >>> min_cost_to_make_unique([1, 1, 1, 1], [5, 10, 3, 8]) == 21 >>> min_cost_to_make_unique([1, 1, 2, 2, 2, 3], [1, 2, 3, 4, 5, 6]) == 11","solution":"def min_cost_to_make_unique(nums, cost): total_cost = 0 n = len(nums) for i in range(1, n): if nums[i] == nums[i - 1]: # Found a duplicate total_cost += cost[i] return total_cost"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> List[int]: Given an integer array nums and an integer k, return the maximum sum of a subarray of size k. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. >>> max_sum_subarray([1, 2, 3, 4, 5], 3) [3, 4, 5] >>> max_sum_subarray([1, 1, 1, 1], 3) [1, 1, 1] >>> max_sum_subarray([1000, -1000, 1000, 1000, -1000, 1000], 2) [1000, 1000] >>> max_sum_subarray([-1, -2, -3, -4], 2) [-1, -2] >>> max_sum_subarray([4, -1, 2, 1, -3, 4], 3) [4, -1, 2] >>> max_sum_subarray([1, 2, 3, 4, 5], 1) [5] >>> max_sum_subarray([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] pass","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a subarray of size k. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. n = len(nums) max_sum = float('-inf') current_sum = sum(nums[:k]) max_sum = current_sum start_index = 0 for i in range(1, n - k + 1): current_sum = current_sum - nums[i-1] + nums[i+k-1] if current_sum > max_sum: max_sum = current_sum start_index = i return nums[start_index:start_index+k]"},{"question":"def max_subarray_len(arr, x): Finds the maximum length of a subarray with sum equal to x. >>> max_subarray_len([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_len([1, 2, 3], 7) 0 >>> max_subarray_len([1, 2, 3, -4, 5], 7) 5 >>> max_subarray_len([1, 1, 1, 1, 1, 1], 3) 3 >>> max_subarray_len([-2, -1, 2, 1], 1) 2 >>> max_subarray_len([5], 5) 1 >>> max_subarray_len([5], 3) 0 >>> max_subarray_len([], 1) 0","solution":"def max_subarray_len(arr, x): Finds the maximum length of a subarray with sum equal to x. If there isn't one, returns 0. sum_map = {} current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if current_sum == x: max_length = i + 1 if (current_sum - x) in sum_map: max_length = max(max_length, i - sum_map[current_sum - x]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"def divide(dividend: int, divisor: int) -> int: Divides dividend by divisor without using multiplication, division or mod operator. Returns the quotient after truncating towards zero. >>> divide(10, 3) 3 >>> divide(-10, 3) -3 >>> divide(10, -3) -3 >>> divide(-10, -3) 3 >>> divide(0, 3) 0 >>> divide(5, 5) 1 >>> divide(2147483647, 1) 2147483647 >>> divide(-2147483648, -1) 2147483647 >>> divide(1, 2) 0 >>> divide(7, -3) -2","solution":"def divide(dividend, divisor): Divides dividend by divisor without using multiplication, division or mod operator. Returns the quotient after truncating towards zero. # Handle special case for overflow MAX_INT = 2**31 - 1 MIN_INT = -2**31 if dividend == MIN_INT and divisor == -1: return MAX_INT # Determine the sign of the result sign = -1 if (dividend < 0) ^ (divisor < 0) else 1 # Work with positive values dividend, divisor = abs(dividend), abs(divisor) quotient = 0 while dividend >= divisor: temp_divisor, num_divisors = divisor, 1 while dividend >= temp_divisor: dividend -= temp_divisor quotient += num_divisors # Double the temporary divisor and the count of divisors for efficiency temp_divisor <<= 1 num_divisors <<= 1 return sign * quotient"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Return the length of the longest palindromic subsequence you can obtain by deleting characters from s. >>> longest_palindromic_subsequence(\\"abba\\") == 4 >>> longest_palindromic_subsequence(\\"aba\\") == 3 >>> longest_palindromic_subsequence(\\"abcba\\") == 5 >>> longest_palindromic_subsequence(\\"ab\\") == 1 >>> longest_palindromic_subsequence(\\"\\") == 0 >>> longest_palindromic_subsequence(\\"a\\") == 1 >>> longest_palindromic_subsequence(\\"aaa\\") == 3 >>> longest_palindromic_subsequence(\\"aabbaa\\") == 6","solution":"def longest_palindromic_subsequence(s): Return the length of the longest palindromic subsequence you can obtain by deleting characters from s. n = len(s) if n == 0: return 0 dp = [[0] * n for _ in range(n)] for i in range(n-1, -1, -1): dp[i][i] = 1 for j in range(i+1, n): if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) return dp[0][n-1]"},{"question":"def trap_rain_water(nums: List[int]) -> int: Returns the total amount of water that can be trapped after it rains. :param nums: List[int] - List of integers where each number represents the height of a building :return: int - Total amount of trapped water >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([3, 3]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([3, 3, 3, 3]) 0 >>> trap_rain_water([4]) 0 >>> trap_rain_water([3, 0, 3]) 3","solution":"def trap_rain_water(nums): Returns the total amount of water that can be trapped after it rains. :param nums: List[int] - List of integers where each number represents the height of a building :return: int - Total amount of trapped water if not nums: return 0 n = len(nums) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = nums[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], nums[i]) # Fill right_max array right_max[n - 1] = nums[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], nums[i]) # Calculate the trapped water total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - nums[i] return total_water"},{"question":"def can_finish_courses(n: int, prerequisites: List[List[int]]) -> bool: Determines if it's possible to finish all courses given the prerequisites. :param n: Number of courses :param prerequisites: List[List[int]] - A list of pairs [a, b] indicating that course a must be taken before course b. :return: bool - True if it is possible to finish all courses, otherwise False. pass from solution import can_finish_courses def test_can_finish_no_prerequisites(): assert can_finish_courses(5, []) == True def test_can_finish_with_simple_prerequisites(): assert can_finish_courses(2, [[1, 0]]) == True def test_cannot_finish_due_to_cycle(): assert can_finish_courses(2, [[1, 0], [0, 1]]) == False def test_can_finish_with_complex_prerequisites(): assert can_finish_courses(4, [[1, 0], [2, 1], [3, 2]]) == True def test_cannot_finish_with_complex_cycle(): assert can_finish_courses(4, [[1, 0], [2, 1], [0, 2]]) == False def test_can_finish_multiple_prerequisites_to_one(): assert can_finish_courses(4, [[1, 0], [2, 0], [3, 1], [3, 2]]) == True def test_cannot_finish_with_disconnected_cycle(): assert can_finish_courses(5, [[1, 0], [2, 1], [4, 3], [3, 4]]) == False","solution":"def can_finish_courses(n, prerequisites): Determines if it's possible to finish all courses given the prerequisites. :param n: Number of courses :param prerequisites: List[List[int]] - A list of pairs [a, b] indicating that course a must be taken before course b. :return: bool - True if it is possible to finish all courses, otherwise False. from collections import defaultdict, deque # Create an adjacency list and in-degree list adj_list = defaultdict(list) in_degree = [0] * n # Build the graph and fill in-degrees for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Queue for nodes with no incoming edges zero_in_degree_queue = deque([i for i in range(n) if in_degree[i] == 0]) # Number of courses that have no prerequisites count = 0 while zero_in_degree_queue: node = zero_in_degree_queue.popleft() count += 1 # Decrease the in-degree for all the neighbors for neighbor in adj_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_in_degree_queue.append(neighbor) # If count of courses with no remaining prerequisites equals number of courses, we can complete all courses return count == n"},{"question":"class AutoSave: The AutoSave class represents an auto-save mechanism for a text editor application. Methods: - __init__(self, n): Initializes the auto-save timer to save the document every \`n\` minutes. - openDocument(self, document: str, t: int): Opens a new document at time \`t\`. If there's already a document open, save it before opening the new one. - saveDocument(self, t: int) -> List[str]: Performs an auto-save at time \`t\`, saving the document and returning a list of versions of the document saved so far. - getMinutesToNextSave(self, t: int) -> int: Returns the number of minutes remaining until the next auto-save, given the current time \`t\`. def __init__(self, n): Initializes the auto-save timer to save the document every \`n\` minutes. Args: n (int): Interval in minutes to perform auto-save operation. pass def openDocument(self, document: str, t: int): Opens a new document at time \`t\`. Saves the current document before opening if there's already a document open. Args: document (str): The new document to be opened. t (int): The current time in minutes. pass def saveDocument(self, t: int) -> List[str]: Performs an auto-save at time \`t\`, saving the document and returning a list of versions of the document saved so far. Args: t (int): The current time in minutes. Returns: List[str]: List of document versions saved so far. pass def getMinutesToNextSave(self, t: int) -> int: Returns the number of minutes remaining until the next auto-save, given the current time \`t\`. Args: t (int): The current time in minutes. Returns: int: Minutes remaining until the next auto-save. pass from typing import List def test_open_document(): auto_save = AutoSave(10) auto_save.openDocument(\\"Document1\\", 0) assert auto_save.current_document == \\"Document1\\" assert auto_save.last_save_time == 0 def test_save_document(): auto_save = AutoSave(10) auto_save.openDocument(\\"Document1\\", 0) assert auto_save.saveDocument(10) == [\\"Document1 (saved at 10 mins)\\"] assert auto_save.saveDocument(15) == [\\"Document1 (saved at 10 mins)\\"] assert auto_save.saveDocument(20) == [\\"Document1 (saved at 10 mins)\\", \\"Document1 (saved at 20 mins)\\"] def test_get_minutes_to_next_save(): auto_save = AutoSave(10) auto_save.openDocument(\\"Document1\\", 0) assert auto_save.getMinutesToNextSave(5) == 5 assert auto_save.getMinutesToNextSave(10) == 10 def test_open_document_saves_current(): auto_save = AutoSave(10) auto_save.openDocument(\\"Document1\\", 0) auto_save.saveDocument(10) auto_save.openDocument(\\"Document2\\", 15) assert auto_save.documents == [\\"Document1 (saved at 10 mins)\\"] auto_save.saveDocument(25) assert auto_save.documents == [\\"Document1 (saved at 10 mins)\\", \\"Document2 (saved at 25 mins)\\"] def test_no_document_to_save(): auto_save = AutoSave(10) assert auto_save.saveDocument(10) == []","solution":"class AutoSave: def __init__(self, n): Initializes the auto-save timer to save the document every \`n\` minutes. Args: n (int): Interval in minutes to perform auto-save operation. self.interval = n self.documents = [] self.current_document = None self.last_save_time = 0 def openDocument(self, document, t): Opens a new document at time \`t\`. Saves the current document before opening if there's already a document open. Args: document (str): The new document to be opened. t (int): The current time in minutes. if self.current_document is not None: self.saveDocument(t) self.current_document = document self.last_save_time = t def saveDocument(self, t): Performs an auto-save at time \`t\`, saving the document and returning a list of versions of the document saved so far. Args: t (int): The current time in minutes. Returns: List[str]: List of document versions saved so far. if self.current_document is not None and (t - self.last_save_time) >= self.interval: self.documents.append(self.current_document + f\\" (saved at {t} mins)\\") self.last_save_time = t return self.documents def getMinutesToNextSave(self, t): Returns the number of minutes remaining until the next auto-save, given the current time \`t\`. Args: t (int): The current time in minutes. Returns: int: Minutes remaining until the next auto-save. elapsed_time = t - self.last_save_time time_to_next_save = self.interval - (elapsed_time % self.interval) return time_to_next_save"},{"question":"def maximum_profit(prices: List[int], fee: int) -> int: Given a list of prices and a transaction fee, this function calculates the maximum profit that can be achieved by buying and selling with the transaction fee applicable. :param prices: List[int], list of product prices on different days :param fee: int, transaction fee for each transaction :return: int, maximum profit >>> maximum_profit([1, 3, 2, 8, 4, 9], 2) 8 >>> maximum_profit([1, 2, 3, 4, 5], 0) 4 >>> maximum_profit([1, 2, 3, 4, 5], 10) 0 >>> maximum_profit([5, 4, 3, 2, 1], 1) 0 >>> maximum_profit([5], 1) 0 >>> maximum_profit([5, 5, 5, 5], 1) 0","solution":"def maximum_profit(prices, fee): Given a list of prices and a transaction fee, this function calculates the maximum profit that can be achieved by buying and selling with the transaction fee applicable. :param prices: List[int], list of product prices on different days :param fee: int, transaction fee for each transaction :return: int, maximum profit n = len(prices) if n == 0: return 0 # Initialize states cash = 0 hold = -prices[0] # Holding the first stock for i in range(1, n): # Transition states cash = max(cash, hold + prices[i] - fee) # Max of selling today or doing nothing hold = max(hold, cash - prices[i]) # Max of buying today or doing nothing return cash"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_full_path(root: TreeNode) -> int: Given the root of a binary tree, return the length of the longest full path in the tree. A full path is a path from the root node to a leaf node that only passes through full nodes. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> longest_full_path(root) 3 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> longest_full_path(root) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longest_full_path(root): def dfs(node): if not node: return 0 if (node.left and not node.right) or (node.right and not node.left): return 0 left_length = dfs(node.left) right_length = dfs(node.right) return 1 + max(left_length, right_length) if not root: return 0 return dfs(root)"},{"question":"def minimize_adjacent_duplicates(s: str) -> str: Removes the minimum number of characters from the given string to ensure that no two adjacent characters are the same. If there are multiple results, returns the lexicographically smallest one. :param s: A string consisting of lowercase English letters. :type s: str :return: A string with minimized adjacent duplicates. :rtype: str >>> minimize_adjacent_duplicates('aaabccddd') == 'abcd' >>> minimize_adjacent_duplicates('') == '' >>> minimize_adjacent_duplicates('a') == 'a' >>> minimize_adjacent_duplicates('aaaaa') == 'a' >>> minimize_adjacent_duplicates('abbbcdddeffg') == 'abcdefg' >>> minimize_adjacent_duplicates('abccba') == 'abcba'","solution":"def minimize_adjacent_duplicates(s): Removes the minimum number of characters from the given string to ensure that no two adjacent characters are the same. If there are multiple results, returns the lexicographically smallest one. :param s: A string consisting of lowercase English letters :type s: str :return: A string with minimized adjacent duplicates :rtype: str stack = [] for char in s: if stack and stack[-1] == char: continue stack.append(char) return ''.join(stack)"},{"question":"def mostFrequentChar(s: str) -> str: Returns the most frequent character in the string 's'. If multiple characters have the highest frequency, returns the lexicographically smallest one. >>> mostFrequentChar(\\"a\\") == \\"a\\" >>> mostFrequentChar(\\"abcdef\\") == \\"a\\" >>> mostFrequentChar(\\"aabbcc\\") == \\"a\\" >>> mostFrequentChar(\\"aabbbc\\") == \\"b\\" >>> mostFrequentChar(\\"thequickbrownfoxjumpsoverthelazydog\\") == \\"o\\" >>> mostFrequentChar(\\"bbaaacc\\") == \\"a\\" >>> try: ... mostFrequentChar(\\"\\") ... except ValueError: ... True ... else: ... False","solution":"def mostFrequentChar(s: str) -> str: Returns the most frequent character in the string 's'. If multiple characters have the highest frequency, returns the lexicographically smallest one. from collections import Counter # Count the frequency of each character freq = Counter(s) # Determine the highest frequency highest_freq = max(freq.values()) # Collect characters with the highest frequency most_frequent_chars = [char for char, count in freq.items() if count == highest_freq] # Return the lexicographically smallest character among the most frequent return min(most_frequent_chars)"},{"question":"def minCostToMeet(points, costPerUnit): Returns the minimum total cost for all cars to meet at a single position. >>> minCostToMeet([1, 2, 3], 1) 2 >>> minCostToMeet([1, 3, 2, 4, 5], 1) 6 >>> minCostToMeet([2, 2, 2], 1) 0 >>> minCostToMeet([1, 2, 3], 10) 20 >>> minCostToMeet([1000, 2000, 3000], 1) 2000 >>> minCostToMeet([-1, -2, -3], 1) 2 >>> minCostToMeet([-10, 0, 10, 20], 1) 40","solution":"def minCostToMeet(points, costPerUnit): Returns the minimum total cost for all cars to meet at a single position. points.sort() median = points[len(points) // 2] total_cost = sum(abs(p - median) * costPerUnit for p in points) return total_cost"},{"question":"def rotate(matrix): Rotates the given n x n 2D matrix clockwise by 90 degrees in place. Parameters: matrix (list[list[int]]): 2D list representing the image with integer values. Returns: list[list[int]]: The rotated matrix. >>> rotate([[1]]) [[1]] >>> rotate([[1, 2], [3, 4]]) [[3, 1], [4, 2]] >>> rotate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate([[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]) [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]] >>> rotate([[5, 1, 9, 11, 7], [2, 4, 8, 10, 6], [13, 3, 6, 7, 8], [15, 14, 12, 16, 4], [22, 19, 17, 21, 2]]) [[22, 15, 13, 2, 5], [19, 14, 3, 4, 1], [17, 12, 6, 8, 9], [21, 16, 7, 10, 11], [2, 4, 8, 6, 7]]","solution":"def rotate(matrix): Rotates the given n x n 2D matrix clockwise by 90 degrees in place. Parameters: matrix (list[list[int]]): 2D list representing the image with integer values. Returns: list[list[int]]: The rotated matrix. n = len(matrix) # Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumOfLeftLeaves(root: TreeNode) -> int: Returns the sum of all left leaves in the given binary tree. pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumOfLeftLeaves(root: TreeNode) -> int: Returns the sum of all left leaves in the given binary tree. if not root: return 0 def is_leaf(node): return node and not node.left and not node.right sum_left_leaves = 0 if root.left and is_leaf(root.left): sum_left_leaves += root.left.val else: sum_left_leaves += sumOfLeftLeaves(root.left) sum_left_leaves += sumOfLeftLeaves(root.right) return sum_left_leaves"},{"question":"from typing import List def combinationSum(arr: List[int], target: int) -> List[List[int]]: Given an array of positive integers \`arr\` and an integer \`target\`, return all unique combinations of \`arr\`'s sums where each number in \`arr\` is used exactly once and the combination adds up to \`target\`. >>> combinationSum([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combinationSum([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] >>> combinationSum([3], 3) [[3]] >>> combinationSum([2, 4, 6, 8], 3) [] >>> combinationSum([], 3) []","solution":"def combinationSum(arr, target): def backtrack(start, target, path, result): if target == 0: result.append(path) return elif target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i-1]: continue backtrack(i+1, target - arr[i], path + [arr[i]], result) arr.sort() result = [] backtrack(0, target, [], result) return result"},{"question":"from typing import List def find_duplicates(nums: List[int]) -> List[int]: Returns a list of integers that appear more than once in the original list. The returned list maintains the same order as they first appeared in the original list without duplicates. >>> find_duplicates([1, 2, 3, 4, 5]) [] >>> find_duplicates([1, 1, 2, 2, 3, 3]) [1, 2, 3] >>> find_duplicates([1, 2, 3, 2, 4, 5, 6, 6]) [2, 6] >>> find_duplicates([1]) [] >>> find_duplicates([]) [] >>> find_duplicates([4, 4, 5, 6, 5, 6, 7, 7]) [4, 5, 6, 7] >>> find_duplicates([1, 2, 3, 1, 2, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9]) [1, 2, 3, 8, 9]","solution":"def find_duplicates(nums): Returns a list of integers that appear more than once in the original list. The returned list maintains the same order as they first appeared in the original list without duplicates. from collections import Counter counts = Counter(nums) seen = set() duplicates = [] for num in nums: if counts[num] > 1 and num not in seen: duplicates.append(num) seen.add(num) return duplicates"},{"question":"from typing import List def min_rooms_to_unlock_all(rooms: List[int]) -> int: Returns the minimum number of rooms you need to enter to unlock all rooms. If it's not possible to unlock all rooms, return -1. >>> min_rooms_to_unlock_all([1, 1, 2]) 3 >>> min_rooms_to_unlock_all([1, 0, 3, 0]) -1 >>> min_rooms_to_unlock_all([0]) 1 >>> min_rooms_to_unlock_all([2, 1, 0, 0]) -1 >>> min_rooms_to_unlock_all([1, 1, 1, 1]) 4 # Implement the function to solve the problem","solution":"from collections import deque def min_rooms_to_unlock_all(rooms): Returns the minimum number of rooms you need to enter to unlock all rooms. If it's not possible to unlock all rooms, return -1. n = len(rooms) visited = [False] * n queue = deque([0]) visited[0] = True rooms_visited = 1 room_count = 0 while queue: current_room = queue.popleft() room_count += 1 for i in range(rooms[current_room]): next_room = (current_room + 1 + i) % n if not visited[next_room]: queue.append(next_room) visited[next_room] = True rooms_visited += 1 return room_count if rooms_visited == n else -1"},{"question":"from collections import deque def min_steps(grid: List[List[int]]) -> int: Return the minimum number of steps required to go from the top-left cell to the bottom-right cell. If it is not possible to reach the bottom-right cell, return -1. >>> min_steps([ [1, 2, 1], [2, 3, 2], [1, 2, 1] ]) 4 >>> min_steps([ [1, 5, 1], [2, 6, 2], [1, 7, 1] ]) -1 >>> min_steps([ [1, 2, 2], [3, 3, 2], [1, 2, 2] ]) 4 >>> min_steps([ [1, 1, 1, 1, 1], [1, 2, 2, 2, 1], [1, 1, 1, 1, 1], [1, 3, 3, 3, 1], [1, 1, 1, 1, 1] ]) 8 >>> min_steps([[5]]) 0","solution":"from collections import deque def min_steps(grid): def is_valid(x, y): return 0 <= x < m and 0 <= y < n m, n = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, column, steps) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m - 1 and y == n - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: if abs(grid[nx][ny] - grid[x][y]) <= 1: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def isSubsequence(s1: str, s2: str) -> bool: Determine whether s2 is a subsequence of s1. >>> isSubsequence(\\"abcde\\", \\"ace\\") == True >>> isSubsequence(\\"abcde\\", \\"aec\\") == False >>> isSubsequence(\\"abcde\\", \\"\\") == True >>> isSubsequence(\\"\\", \\"\\") == True >>> isSubsequence(\\"\\", \\"a\\") == False >>> isSubsequence(\\"abcde\\", \\"abcde\\") == True >>> isSubsequence(\\"abcde\\", \\"a\\") == True >>> isSubsequence(\\"abcde\\", \\"e\\") == True >>> isSubsequence(\\"banana\\", \\"bna\\") == True >>> isSubsequence(\\"banana\\", \\"bb\\") == False >>> isSubsequence(\\"banana\\", \\"naa\\") == True >>> isSubsequence(\\"a\\" * 1000000 + \\"b\\", \\"abb\\") == False >>> isSubsequence(\\"a\\" * 1000000 + \\"b\\", \\"aaaab\\") == True","solution":"def isSubsequence(s1, s2): Determine whether s2 is a subsequence of s1. Args: s1 (str): The string to be checked if it contains s2 as a subsequence. s2 (str): The string which we need to check as subsequence in s1. Returns: bool: True if s2 is a subsequence of s1, False otherwise. if not s2: return True if not s1: return False it = iter(s1) return all(char in it for char in s2)"},{"question":"def find_closest_pair(arr, target): Finds a pair of indices (i, j) such that arr[i] + arr[j] is closest to the target. :param arr: List of integers :param target: Target integer :return: A list of two indices [i, j] in ascending order if found, otherwise an empty list >>> find_closest_pair([1, 3, 4, 7, 10], 15) [2, 4] or [3, 4] >>> find_closest_pair([-1, 2, 1] for index in closest_pair], f\\"Expected pair with sum closest to {target} but got {closest_pair}\\" def test_find_closest_pair_empty_array(): arr = [] target = 5 result = find_closest_pair(arr, target) assert result == [] def test_find_closest_pair_single_element(): arr = [1] target = 5 result = find_closest_pair(arr, target) assert result == [] def test_find_closest_pair_multiple_closest_pairs(): arr = [1, 2, 3, 4] target = 5 result = find_closest_pair(arr, target) assert [arr[index] for index in result] in [[1, 4], [2, 3]], f\\"Expected pair with sum closest to {target} but got {result}\\" def test_find_closest_pair_identical_elements(): arr = [5, 5, 5, 5] target = 10 result = find_closest_pair(arr, target) assert [arr[index] for index in result] == [5, 5] def find_closest_pair(arr, target): Finds a pair of indices (i, j) such that arr[i] + arr[j] is closest to the target. :param arr: List of integers :param target: Target integer :return: A list of two indices [i, j] in ascending order if found, otherwise an empty list # <function implementation here>","solution":"def find_closest_pair(arr, target): Finds a pair of indices (i, j) such that arr[i] + arr[j] is closest to the target. :param arr: List of integers :param target: Target integer :return: A list of two indices [i, j] in ascending order if found, otherwise an empty list if not arr or len(arr) < 2: return [] closest_pair = [] closest_diff = float('inf') for i in range(len(arr) - 1): for j in range(i + 1, len(arr)): current_sum = arr[i] + arr[j] current_diff = abs(target - current_sum) if current_diff < closest_diff: closest_diff = current_diff closest_pair = [i, j] return closest_pair"},{"question":"def max_sum_of_three_subarrays(nums, k): Given a sorted integer array nums and an integer k, return the maximum sum of three non-overlapping subarrays of length k that can be found in nums. The function should also return the three starting indices of these subarrays as a list. In case of multiple answers with the same maximum sum, return the lexicographically smallest list of starting indices. Examples: >>> max_sum_of_three_subarrays([1, 2, 1, 2, 6, 7, 5, 1], 2) (23, [0, 3, 5]) >>> max_sum_of_three_subarrays([4, 3, 10, 9, 8, 2, 1, 0, 5], 1) (27, [2, 3, 4]) >>> max_sum_of_three_subarrays([1, 1, 1, 1, 1, 1, 1, 1, 1], 3) (9, [0, 3, 6]) >>> max_sum_of_three_subarrays([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) (45, [0, 3, 6]) >>> max_sum_of_three_subarrays([3, 3, 3, 3, 3, 3, 3, 3, 3], 3) (27, [0, 3, 6])","solution":"def max_sum_of_three_subarrays(nums, k): Return the maximum sum of three non-overlapping subarrays of length k, and the starting indices of these subarrays. n = len(nums) sum_k = [0] * (n - k + 1) current_sum = sum(nums[:k]) sum_k[0] = current_sum for i in range(1, n - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] sum_k[i] = current_sum left = [0] * len(sum_k) right = [0] * len(sum_k) best_left = 0 best_right = len(sum_k) - 1 for i in range(len(sum_k)): if sum_k[i] > sum_k[best_left]: best_left = i left[i] = best_left for i in range(len(sum_k) - 1, -1, -1): if sum_k[i] >= sum_k[best_right]: best_right = i right[i] = best_right max_sum = 0 result = [0, 0, 0] for j in range(k, len(sum_k) - k): i, l = left[j - k], right[j + k] current_sum = sum_k[i] + sum_k[j] + sum_k[l] if current_sum > max_sum: max_sum = current_sum result = [i, j, l] return max_sum, result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> max_path_sum(root) 15 >>> root = TreeNode(10) >>> root.left = TreeNode(5) >>> root.right = TreeNode(15) >>> max_path_sum(root) 30 >>> root = TreeNode(-10) >>> root.left = TreeNode(-20) >>> root.right = TreeNode(-30) >>> max_path_sum(root) -10 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> max_path_sum(root) 18","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Returns the maximum path sum in the binary tree. def dfs(node): if not node: return (0, float('-inf')) # (path sum, max path sum seen so far) left_sum, left_max = dfs(node.left) right_sum, right_max = dfs(node.right) # Max path sum including current node (path cannot split here) current_sum = max(left_sum + node.val, right_sum + node.val, node.val) # Max path sum for the current subtree subtree_sum = max(left_max, right_max, current_sum, left_sum + node.val + right_sum) return current_sum, subtree_sum return dfs(root)[1]"},{"question":"def searchRange(nums: List[int], target: int) -> List[int]: You are given a list of integers \`nums\` sorted in non-decreasing order and an integer \`target\`. Your task is to find the starting and ending position of the target value in the array. If the target is not found in the array, return \`[-1, -1]\`. The function should have a logarithmic time complexity. Example: >>> searchRange([5,7,7,8,8,10], 8) [3,4] >>> searchRange([5,7,7,8,8,10], 6) [-1,-1] >>> searchRange([], 0) solution = Solution() assert solution.searchRange([5,7,7,8,8,10], 8) == [3,4] assert solution.searchRange([5,7,7,8,8,10], 6) == [-1,-1] assert solution.searchRange([], 0) == [-1,-1] assert solution.searchRange([1,2,3,4,5], 1) == [0,0] assert solution.searchRange([1,2,3,4,5], 5) == [4,4] assert solution.searchRange([1,1,1,1,1,1,1,1], 1) == [0,7] assert solution.searchRange([1], 1) == [0,0] assert solution.searchRange([1], 2) == [-1,-1] assert solution.searchRange([1,2,3,3,3,4,5,5,5,6], 3) == [2,4] assert solution.searchRange([1,2,3,3,3,4,5,5,5,6], 5) == [6,8] assert solution.searchRange([2,3,3,4,5,6,6,7,8], 1) == [-1,-1] assert solution.searchRange([2,3,3,4,5,6,6,7,8], 9) == [-1,-1]","solution":"def searchRange(nums, target): Returns the starting and ending positions of the target in the array. If the target is not found, return [-1, -1]. def find_left_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right_index(nums, target): left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left_index(nums, target) right_index = find_right_index(nums, target) # Check if target is not inside the array. if left_index <= right_index and left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] else: return [-1, -1]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val: int) -> TreeNode: Insert a value into the BST and return the root of the BST. :param root: TreeNode, the root of the BST. :param val: int, the value to be inserted. :return: TreeNode, the root of the BST after insertion. return root # Unit Tests def bst_to_list(root): Helper function to convert BST to list for easier testing if not root: return [] return bst_to_list(root.left) + [root.val] + bst_to_list(root.right) def test_insert_into_empty_bst(): root = None val = 5 new_root = insert_into_bst(root, val) assert bst_to_list(new_root) == [5] def test_insert_into_bst_left(): root = TreeNode(5) val = 3 new_root = insert_into_bst(root, val) assert bst_to_list(new_root) == [3, 5] def test_insert_into_bst_right(): root = TreeNode(5) val = 7 new_root = insert_into_bst(root, val) assert bst_to_list(new_root) == [5, 7] def test_insert_into_bst_complex(): root = TreeNode(5, TreeNode(3), TreeNode(7)) val = 6 new_root = insert_into_bst(root, val) assert bst_to_list(new_root) == [3, 5, 6, 7] def test_insert_into_bst_deep(): root = TreeNode(5, TreeNode(3, TreeNode(2), TreeNode(4)), TreeNode(7, None, TreeNode(8))) val = 1 new_root = insert_into_bst(root, val) assert bst_to_list(new_root) == [1, 2, 3, 4, 5, 7, 8] if __name__ == \\"__main__\\": test_insert_into_empty_bst() test_insert_into_bst_left() test_insert_into_bst_right() test_insert_into_bst_complex() test_insert_into_bst_deep() print(\\"All tests passed.\\")","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, val): Inserts a value into the BST and returns the root of the BST. :param root: TreeNode, the root of the BST. :param val: int, the value to be inserted. :return: TreeNode, the root of the BST after insertion. if root is None: return TreeNode(val) if val < root.val: root.left = insert_into_bst(root.left, val) else: root.right = insert_into_bst(root.right, val) return root"},{"question":"def find_single_element(arr): Returns the element that appears only once in the array where every other element appears twice. Parameters: arr (list of int): The input array of integers. Returns: int: The unique element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element def test_single_unique_element(): assert find_single_element([2, 3, 2, 4, 4]) == 3 assert find_single_element([1, 1, 5, 5, 3]) == 3 assert find_single_element([0, 0, 1]) == 1 def test_unique_element_in_larger_array(): assert find_single_element([4, 1, 2, 1, 2, 4, 5]) == 5 def test_all_elements_but_one_double(): assert find_single_element([7, 2, 3, 4, 3, 2, 4]) == 7 def test_with_negative_numbers(): assert find_single_element([-1, -2, -3, -1, -2]) == -3 def test_large_numbers(): assert find_single_element([999999999, 1, 999999999]) == 1","solution":"def find_single_element(arr): Returns the element that appears only once in the array where every other element appears twice. Parameters: arr (list of int): The input array of integers. Returns: int: The unique element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def numDistinctSubsequences(s: str) -> int: You are given a string \`s\` consisting of lowercase alphabetical characters. Find out the number of distinct subsequences that can be generated from \`s\`. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Return the number of distinct subsequences (modulo 10^9 + 7). >>> numDistinctSubsequences(\\"abc\\") == 7 >>> numDistinctSubsequences(\\"aaa\\") == 3 >>> numDistinctSubsequences(\\"a\\") == 1 >>> numDistinctSubsequences(\\"\\") == 0 >>> numDistinctSubsequences(\\"abac\\") == 13 MOD = 10**9 + 7 n = len(s) # dp[i] = number of distinct subsequences ending at the i-th character dp = [0] * (n + 1) dp[0] = 1 # An empty string has one subsequence - the empty string itself # last[index] will store the last occurrence index of character \`index\` ('a' -> 0, ..., 'z' -> 25) last = [-1] * 26 for i in range(1, n + 1): char_index = ord(s[i - 1]) - ord('a') dp[i] = (2 * dp[i - 1]) % MOD if last[char_index] != -1: dp[i] = (dp[i] - dp[last[char_index]]) % MOD last[char_index] = i - 1 # Subtract 1 to exclude the empty subsequence return (dp[n] - 1) % MOD","solution":"def numDistinctSubsequences(s): MOD = 10**9 + 7 n = len(s) # dp[i] = number of distinct subsequences ending at the i-th character dp = [0] * (n + 1) dp[0] = 1 # An empty string has one subsequence - the empty string itself # last[index] will store the last occurrence index of character \`index\` ('a' -> 0, ..., 'z' -> 25) last = [-1] * 26 for i in range(1, n + 1): char_index = ord(s[i - 1]) - ord('a') dp[i] = (2 * dp[i - 1]) % MOD if last[char_index] != -1: dp[i] = (dp[i] - dp[last[char_index]]) % MOD last[char_index] = i - 1 # Subtract 1 to exclude the empty subsequence return (dp[n] - 1) % MOD"},{"question":"def earliest_subsequence(s: str, k: int) -> str: Returns the lexicographically earliest subsequence of s of length k. >>> earliest_subsequence(\\"abcde\\", 3) \\"abc\\" >>> earliest_subsequence(\\"cbade\\", 2) \\"ad\\" >>> earliest_subsequence(\\"z\\", 1) \\"z\\" >>> earliest_subsequence(\\"abcdef\\", 6) \\"abcdef\\" >>> earliest_subsequence(\\"bcabc\\", 3) \\"abc\\" >>> earliest_subsequence(\\"gfedcba\\", 3) \\"cba\\"","solution":"def earliest_subsequence(s, k): Returns the lexicographically earliest subsequence of s of length k. Parameters: s (str): The input string. k (int): The length of the subsequence to be returned. Returns: str: The lexicographically earliest subsequence of length k. stack = [] to_remove = len(s) - k for char in s: while to_remove > 0 and stack and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) return ''.join(stack[:k])"},{"question":"def explore_lake(grid, visited, i, j, elevation): Helper function to explore the lake and return its size def largest_lake(grid): Returns the size of the largest lake in the given grid. >>> largest_lake([[1, 2, 2, 3], [3, 2, 1, 4], [4, 4, 3, 4]]) 3 >>> largest_lake([[1, 1, 1, 2, 2, 2]]) 3 >>> largest_lake([[3], [3], [4], [4], [4]]) 3 >>> largest_lake([[1,1,1], [1,2,1], [1,1,1]]) 8 >>> largest_lake([]) 0 >>> largest_lake([[1, 2], [3, 4]]) 1","solution":"def explore_lake(grid, visited, i, j, elevation): Helper function to explore the lake and return its size directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] stack = [(i, j)] lake_size = 0 while stack: x, y = stack.pop() if visited[x][y]: continue visited[x][y] = True lake_size += 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == elevation: stack.append((nx, ny)) return lake_size def largest_lake(grid): Returns the size of the largest lake in the given grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False] * cols for _ in range(rows)] max_lake_size = 0 for i in range(rows): for j in range(cols): if not visited[i][j]: lake_size = explore_lake(grid, visited, i, j, grid[i][j]) max_lake_size = max(max_lake_size, lake_size) return max_lake_size"},{"question":"def is_supersequence(s: str, t: str) -> bool: Returns True if \`t\` can be formed by reordering the characters in \`s\` and possibly adding more characters. >>> is_supersequence(\\"abc\\", \\"abc\\") True >>> is_supersequence(\\"abc\\", \\"aebdc\\") True >>> is_supersequence(\\"abc\\", \\"abdef\\") False >>> is_supersequence(\\"aabbc\\", \\"abcabc\\") True >>> is_supersequence(\\"abcd\\", \\"aabbccddeeff\\") True >>> is_supersequence(\\"\\", \\"anything\\") True >>> is_supersequence(\\"something\\", \\"\\") False >>> is_supersequence(\\"\\", \\"\\") True >>> is_supersequence(\\"xyz\\", \\"xy\\") False","solution":"def is_supersequence(s, t): Returns True if \`t\` can be formed by reordering the characters in \`s\` and possibly adding more characters. from collections import Counter counter_s = Counter(s) counter_t = Counter(t) for char in counter_s: if counter_s[char] > counter_t[char]: return False return True"},{"question":"def min_transformations_to_palindrome(s: str) -> int: Returns the minimum number of transformations needed to make the string a palindrome. >>> min_transformations_to_palindrome(\\"a\\") == 0 >>> min_transformations_to_palindrome(\\"aa\\") == 0 >>> min_transformations_to_palindrome(\\"ab\\") == 1 >>> min_transformations_to_palindrome(\\"aba\\") == 0 >>> min_transformations_to_palindrome(\\"abc\\") == 1 >>> min_transformations_to_palindrome(\\"racecar\\") == 0 >>> min_transformations_to_palindrome(\\"abcdef\\") == 3 >>> min_transformations_to_palindrome(\\"abccba\\") == 0 >>> min_transformations_to_palindrome(\\"abccbx\\") == 1","solution":"def min_transformations_to_palindrome(s): Returns the minimum number of transformations needed to make the string a palindrome. n = len(s) count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: count += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): Construct the binary search tree from given pre-order traversal and return its root. A binary search tree is a binary tree where each node has at most two children, which are referred to as the left child and the right child. For any node, all values in its left subtree are less than the node's value, and all values in its right subtree are greater than the node's value. >>> bstFromPreorder([8, 5, 1, 7, 10, 12]) TreeNode(8, left=TreeNode(5, left=TreeNode(1), right=TreeNode(7)), right=TreeNode(10, right=TreeNode(12))) >>> bstFromPreorder([]) None def preorderTraversal(root): Helper function to get the preorder traversal of a tree, used for verification in tests. return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right) if root else [] # Test cases from solution import TreeNode, bstFromPreorder, preorderTraversal def trees_are_equal(t1, t2): if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return t1.val == t2.val and trees_are_equal(t1.left, t2.left) and trees_are_equal(t1.right, t2.right) def test_empty_preorder(): assert bstFromPreorder([]) is None def test_single_element(): bst = bstFromPreorder([10]) assert bst.val == 10 and bst.left is None and bst.right is None def test_multiple_elements(): bst = bstFromPreorder([8, 5, 1, 7, 10, 12]) expected_preorder = [8, 5, 1, 7, 10, 12] assert preorderTraversal(bst) == expected_preorder def test_all_left_children(): bst = bstFromPreorder([10, 5, 4, 3, 2, 1]) expected_preorder = [10, 5, 4, 3, 2, 1] assert preorderTraversal(bst) == expected_preorder def test_all_right_children(): bst = bstFromPreorder([1, 2, 3, 4, 5, 6]) expected_preorder = [1, 2, 3, 4, 5, 6] assert preorderTraversal(bst) == expected_preorder def test_complex_tree(): bst = bstFromPreorder([10, 5, 1, 7, 40, 50]) expected_preorder = [10, 5, 1, 7, 40, 50] assert preorderTraversal(bst) == expected_preorder","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def bstFromPreorder(preorder): if not preorder: return None root = TreeNode(preorder[0]) stack = [root] for value in preorder[1:]: node, child = stack[-1], TreeNode(value) # Adjust the position for the new node in the tree while stack and stack[-1].val < value: node = stack.pop() if node.val < value: node.right = child else: node.left = child stack.append(child) return root def preorderTraversal(root): Helper function to get the preorder traversal of a tree, used for verification in tests. return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right) if root else []"},{"question":"def evaluate_expression(s: str) -> int: Evaluates a mathematical expression string containing integers and the operators +, -, *, and /. The division operator performs integer division that truncates towards zero. >>> evaluate_expression(\\"3+2\\") == 5 >>> evaluate_expression(\\"5-2\\") == 3 >>> evaluate_expression(\\"3+2*2\\") == 7 >>> evaluate_expression(\\"3/2\\") == 1 >>> evaluate_expression(\\"3+5/2\\") == 5 >>> evaluate_expression(\\" 3+5 * 2 \\") == 13 >>> evaluate_expression(\\" 12 / 4 \\") == 3 >>> evaluate_expression(\\"1-5\\") == -4 >>> evaluate_expression(\\"0\\") == 0 >>> evaluate_expression(\\"15-15+15/15*2\\") == 2 >>> evaluate_expression(\\"14 - 3 / 2\\") == 13","solution":"def evaluate_expression(s): Evaluates a mathematical expression string containing integers and the operators +, -, *, and /. The division operator performs integer division that truncates towards zero. # Remove any spaces from the string s = s.replace(\\" \\", \\"\\") # Check if the string is empty if not s: return 0 # Initialize variables current_number = 0 stack = [] operation = \\"+\\" # Iterate over the characters in the string for i, char in enumerate(s): if char.isdigit(): current_number = current_number * 10 + int(char) # If the char is an operator or the end of the string is reached if char in \\"+-*/\\" or i == len(s) - 1: if operation == \\"+\\": stack.append(current_number) elif operation == \\"-\\": stack.append(-current_number) elif operation == \\"*\\": stack.append(stack.pop() * current_number) elif operation == \\"/\\": # Truncate division towards zero stack.append(int(stack.pop() / current_number)) # Reset current number and update operation current_number = 0 operation = char # Sum up all the values in the stack to get the result return sum(stack)"},{"question":"def trapRainWater(arr: List[int]) -> int: Calculate the total water that can be trapped between the bars. :param arr: List[int] - list of integers representing the elevation map. :return: int - total units of trapped water. >>> trapRainWater([]) == 0 >>> trapRainWater([1, 1, 1, 1]) == 0 >>> trapRainWater([1, 2, 3, 4]) == 0 >>> trapRainWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapRainWater([4, 2, 0, 3, 2, 5]) == 9 >>> trapRainWater([4, 3, 2, 1]) == 0 >>> trapRainWater([4, 1, 1, 4]) == 6","solution":"def trapRainWater(arr): Calculate the total water that can be trapped between the bars. :param arr: List[int] - list of integers representing the elevation map. :return: int - total units of trapped water. if not arr: return 0 n = len(arr) left_max = [0] * n right_max = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], arr[i]) right_max[n - 1] = arr[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], arr[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - arr[i] return water_trapped"},{"question":"def get_skyline(buildings: List[List[int]]) -> List[List[int]]: Returns the skyline as a list of key points. Given a list of buildings where each building is represented as [left_i, right_i, height_i], this function merges overlapping buildings and represents the contour in the form of key points. >>> get_skyline([[0, 2, 3]]) [[0, 3], [2, 0]] >>> get_skyline([[0, 1, 3], [2, 3, 4]]) [[0, 3], [1, 0], [2, 4], [3, 0]] >>> get_skyline([[2, 9, 10],[3, 7, 15],[5, 12, 12],[15, 20, 10],[19, 24, 8]]) [[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]] >>> get_skyline([[1, 4, 2], [2, 6, 3], [5, 8, 2]]) [[1, 2], [2, 3], [6, 2], [8, 0]] >>> get_skyline([[0, 5, 5], [2, 6, 3]]) [[0, 5], [5, 3], [6, 0]] # Function implementation goes here","solution":"import heapq def get_skyline(buildings): Returns the skyline as a list of key points. if not buildings: return [] # Create events for all left and right edges events = [] for left, right, height in buildings: events.append((left, -height, right)) # start of the building events.append((right, 0, None)) # end of the building # Sort events: first by x, second by height events.sort() # Priority queue to store living buildings pq = [(0, float('inf'))] # Tuple of negative height and end position skyline = [[0, 0]] for x, negH, right in events: while x >= pq[0][1]: # Remove buildings from the heap that ended before the current x heapq.heappop(pq) if negH != 0: heapq.heappush(pq, (negH, right)) max_height = -pq[0][0] # Current max height if skyline[-1][1] != max_height: skyline.append([x, max_height]) return skyline[1:]"},{"question":"def friendshipStatus(n: int, friendRequests: List[List[int]], initiated: List[bool]) -> List[List[int]]: Returns the final friends list for each student. :param n: Number of students :param friendRequests: List of pairs representing friendship requests :param initiated: List of booleans indicating which requests were initiated :return: List of lists representing each student's friends >>> friendshipStatus(5, [[1, 2], [2, 3], [4, 5]], [True, True, True]) [[2], [1, 3], [2], [5], [4]] >>> friendshipStatus(4, [], []) [[], [], [], []] >>> friendshipStatus(3, [[1, 2], [2, 3]], [True, False]) [[2], [1], []] >>> friendshipStatus(3, [[1, 2], [2, 3]], [False, False]) [[], [], []] >>> friendshipStatus(1, [], []) [[]] >>> friendshipStatus(4, [[1, 2], [2, 3], [1, 2]], [True, True, True]) [[2, 2], [1, 3, 1], [2], []]","solution":"def friendshipStatus(n, friendRequests, initiated): Returns the final friends list for each student. :param n: Number of students :param friendRequests: List of pairs representing friendship requests :param initiated: List of booleans indicating which requests were initiated :return: List of lists representing each student's friends # Initialize list of friends for each student friends = [[] for _ in range(n)] for i, (a, b) in enumerate(friendRequests): if initiated[i]: friends[a - 1].append(b) friends[b - 1].append(a) return friends"},{"question":"def max_courses(costs: List[int], budget: int) -> int: Returns the maximum number of courses that can be taken without exceeding the given budget. >>> max_courses([10, 20, 30], 60) == 3 >>> max_courses([10, 20, 30, 40], 50) == 2 >>> max_courses([50, 60, 70], 40) == 0 >>> max_courses([10, 20, 30], 60) == 3 >>> max_courses([10, 20, 30, 40], 100) == 4 >>> max_courses([10, 20, 30], 0) == 0 >>> max_courses([1, 2, 3, 4], 7) == 3 >>> max_courses([10, 20, 30, 40], 1000) == 4 >>> max_courses([], 100) == 0","solution":"def max_courses(costs, budget): Returns the maximum number of courses that can be taken without exceeding the given budget. costs.sort() total_cost = 0 course_count = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost course_count += 1 else: break return course_count"},{"question":"from typing import List def min_path_sum(grid: List[List[int]]) -> int: Returns the minimum cost path sum to reach the bottom-right cell from the top-left cell. >>> min_path_sum([ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 >>> min_path_sum([[1, 2, 3]]) == 6 >>> min_path_sum([[1], [2], [3]]) == 6 >>> min_path_sum([]) == 0 >>> min_path_sum([[42]]) == 42 >>> min_path_sum([ [1, 2, 3], [4, 5, 6] ]) == 12","solution":"def min_path_sum(grid): Returns the minimum cost path sum to reach the bottom-right cell from the top-left cell. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first row by cumulatively adding the values for col in range(1, cols): grid[0][col] += grid[0][col - 1] # Initialize the first column by cumulatively adding the values for row in range(1, rows): grid[row][0] += grid[row - 1][0] # Update the rest of the grid for row in range(1, rows): for col in range(1, cols): grid[row][col] += min(grid[row - 1][col], grid[row][col - 1]) return grid[rows - 1][cols - 1]"},{"question":"def longest_k_distinct_substring(s: str, k: int) -> int: Given a string s and an integer k, return the length of the longest possible substring with exactly k distinct characters. If not possible, return -1. >>> longest_k_distinct_substring(\\"aabbcc\\", 2) 4 >>> longest_k_distinct_substring(\\"aabbcc\\", 3) 6 >>> longest_k_distinct_substring(\\"aabbc\\", 1) 2 >>> longest_k_distinct_substring(\\"aabbc\\", 4) -1","solution":"def longest_k_distinct_substring(s, k): Given a string s and an integer k, return the length of the longest possible substring with exactly k distinct characters. If it's not possible, return -1. from collections import Counter # Count the frequency of each character in the string. char_count = Counter(s) # If there are fewer distinct characters than k, it's impossible. if len(char_count) < k: return -1 # Extract character frequencies and sort them in descending order. frequencies = sorted(char_count.values(), reverse=True) # Sum up the top k frequencies. max_length = sum(frequencies[:k]) return max_length"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increase_level_order(root): Modify the tree such that its level-order traversal lists the node values in increasing order. Args: root (TreeNode): The root of the binary tree. Returns: TreeNode: The root of the modified binary tree. pass def tree_to_list(root): Helper function to convert a binary tree to a list using level-order traversal. if not root: return [] result, queue = [], deque([root]) while queue: node = queue.popleft() result.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return result def test_increase_level_order(): # Tree: 3 # / # 1 4 # / # 2 root = TreeNode(3) root.left = TreeNode(1) root.left.left = TreeNode(2) root.right = TreeNode(4) modified_root = increase_level_order(root) # Modified Tree: 1 # / # 2 3 # / # 4 assert tree_to_list(modified_root) == [1, 2, 3, 4] def test_empty_tree(): assert increase_level_order(None) == None def test_single_node_tree(): root = TreeNode(1) modified_root = increase_level_order(root) assert tree_to_list(modified_root) == [1] def test_balanced_tree(): # Tree: 4 # / # 2 5 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right = TreeNode(5) modified_root = increase_level_order(root) # Modified Tree: 1 # / # 2 3 # / # 4 5 assert tree_to_list(modified_root) == [1, 2, 3, 4, 5]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def increase_level_order(root): if not root: return None # Step 1: Perform level-order traversal queue = deque([root]) node_values = [] while queue: node = queue.popleft() node_values.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) # Step 2: Sort the values in ascending order node_values.sort() # Step 3: Modify tree values in level-order with sorted values queue = deque([root]) i = 0 while queue: node = queue.popleft() node.val = node_values[i] i += 1 if node.left: queue.append(node.left) if node.right: queue.append(node.right) return root"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotates the given nxn matrix 90 degrees clockwise in place. :param matrix: List[List[int]]: nxn matrix to be rotated :return: matrix after rotating 90 degrees clockwise >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1]]) [[1]]","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given nxn matrix 90 degrees clockwise in place. :param matrix: List[List[int]] : nxn matrix to be rotated :return: matrix after rotating 90 degrees clockwise n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] # left -> top matrix[first][i] = matrix[last - offset][first] # bottom -> left matrix[last - offset][first] = matrix[last][last - offset] # right -> bottom matrix[last][last - offset] = matrix[i][last] # top -> right matrix[i][last] = top return matrix"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Returns a list of strings representing all possible valid IP addresses that can be formed by inserting dots into \`s\`. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"] >>> restore_ip_addresses(\\"010010\\") [\\"0.10.0.10\\", \\"0.100.1.0\\"] >>> restore_ip_addresses(\\"1111111111111\\") [] >>> restore_ip_addresses(\\"123\\") [] >>> restore_ip_addresses(\\"101023\\") [\\"1.0.10.23\\", \\"1.0.102.3\\", \\"10.1.0.23\\", \\"10.10.2.3\\", \\"101.0.2.3\\"]","solution":"def restore_ip_addresses(s): Returns all possible valid IP addresses that can be formed by inserting dots into \`s\`. def is_valid(segment): return len(segment) == 1 or (segment[0] != '0' and int(segment) <= 255) def backtrack(start=0, parts=[]): if start == len(s) and len(parts) == 4: addresses.append(\\".\\".join(parts)) elif len(parts) < 4: for end in range(start + 1, min(start + 4, len(s) + 1)): segment = s[start:end] if is_valid(segment): backtrack(end, parts + [segment]) addresses = [] backtrack() return sorted(addresses)"},{"question":"class IslandCounter: def numIslands(self, grid: List[List[str]]) -> int: Count the number of islands in a given 2D grid. >>> counter = IslandCounter() >>> counter.numIslands([ ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) 1 >>> counter.numIslands([ ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\"] ... ]) 0 >>> counter.numIslands([ ... [\\"1\\", \\"0\\", \\"0\\", \\"1\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\"] ... ]) 4 >>> counter.numIslands([]) 0 >>> counter.numIslands([ ... [\\"1\\", \\"1\\", \\"1\\", \\"0\\"], ... [\\"1\\", \\"1\\", \\"0\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"1\\", \\"0\\"], ... [\\"0\\", \\"0\\", \\"0\\", \\"1\\"] ... ]) 3 pass","solution":"class IslandCounter: def numIslands(self, grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0' or visited[i][j]: return visited[i][j] = True dfs(i + 1, j) dfs(i - 1, j) dfs(i, j + 1) dfs(i, j - 1) num_islands = 0 for i in range(m): for j in range(n): if grid[i][j] == '1' and not visited[i][j]: dfs(i, j) num_islands += 1 return num_islands"},{"question":"def longest_subarray(nums: List[int]) -> int: Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1. >>> longest_subarray([1, 2, 2, 3, 4, 4, 5, 6]) 3 >>> longest_subarray([4, 5, 6, 7, 8]) 2 >>> longest_subarray([1]) 1 >>> longest_subarray([]) 0 >>> longest_subarray([1, 1, 1, 2, 2, 1, 1]) 7 >>> longest_subarray([10, 11, 10, 10, 9, 10]) 6 >>> longest_subarray([1, 3, 5, 7]) 1 >>> longest_subarray([-1, -2, -1, -1, -2, -3]) 5","solution":"def longest_subarray(nums): Returns the length of the longest subarray where the absolute difference between any two elements is less than or equal to 1. if not nums: return 0 max_length = 0 left, right = 0, 0 while right < len(nums): if abs(nums[right] - nums[left]) <= 1: max_length = max(max_length, right - left + 1) else: left = right right += 1 return max_length"},{"question":"def count_divisible_pairs(nums, k): Given an array of integers \`nums\` constructed by rearranging an integer array, return the number of unique pairs \`(i, j)\` such that \`0 <= i < j < nums.length\` and \`nums[i] + nums[j]\` is divisible by a positive integer \`k\`. Ensure you optimize your solution for both time and space complexities. >>> count_divisible_pairs([1, 2, 3], 10) == 0 >>> count_divisible_pairs([1, 3, 2, 6, 1, 2], 3) == 5 >>> count_divisible_pairs([3, 6, 9], 3) == 3 >>> count_divisible_pairs([1, -2, 3, -4], 1) == 6 >>> count_divisible_pairs([5], 5) == 0 >>> count_divisible_pairs([1, 2, 3, 4, 5], 1) == 10","solution":"def count_divisible_pairs(nums, k): Returns the number of unique pairs (i, j) such that 0 <= i < j < len(nums) and nums[i] + nums[j] is divisible by a positive integer k. count = 0 n = len(nums) # Iterate over all pairs (i, j) for i in range(n): for j in range(i + 1, n): if (nums[i] + nums[j]) % k == 0: count += 1 return count"},{"question":"def trap_rainwater(buildings: List[int]) -> int: Determine the total amount of rainwater that can be trapped between the buildings after raining. >>> trap_rainwater([3, 0, 2, 0, 4]) == 7 >>> trap_rainwater([]) == 0 >>> trap_rainwater([1, 2, 3, 4, 5]) == 0 >>> trap_rainwater([5, 4, 3, 2, 1]) == 0 >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rainwater([3, 3, 3, 3]) == 0 >>> trap_rainwater([2, 0, 2]) == 2 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap_rainwater(buildings): if not buildings: return 0 n = len(buildings) left_max = [0] * n right_max = [0] * n left_max[0] = buildings[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], buildings[i]) right_max[n - 1] = buildings[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], buildings[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - buildings[i] return water_trapped"},{"question":"from typing import List def merge_alternately(word1: str, word2: str) -> str: Returns a string that is a combination of the longest possible sequence of alternating characters from word1 and word2. In the case of a tie, characters from word1 precede those from word2. >>> merge_alternately(\\"abc\\", \\"xyz\\") 'axbycz' >>> merge_alternately(\\"abcd\\", \\"xy\\") 'axbyczd' >>> merge_alternately(\\"ab\\", \\"wxyz\\") 'awbxyz' >>> merge_alternately(\\"a\\", \\"w\\") 'aw' >>> merge_alternately(\\"\\", \\"xyz\\") 'xyz' >>> merge_alternately(\\"abc\\", \\"\\") 'abc' >>> merge_alternately(\\"\\", \\"\\") ''","solution":"def mergeAlternately(word1, word2): Returns a string that is a combination of the longest possible sequence of alternating characters from word1 and word2. In the case of a tie, characters from word1 precede those from word2. result = [] len1, len2 = len(word1), len(word2) for i in range(max(len1, len2)): if i < len1: result.append(word1[i]) if i < len2: result.append(word2[i]) return ''.join(result)"},{"question":"def break_string(s: str, brk_idx: List[int]) -> List[str]: Breaks the string s into parts at every index given in brk_idx. Parameters: - s (str): The input string to be broken into parts. - brk_idx (list of int): The list of indices where the string should be broken. Returns: - list of str: List of substrings after breaking the string. >>> break_string(\\"abcdefg\\", [2, 4, 5]) == [\\"ab\\", \\"cd\\", \\"e\\", \\"fg\\"] >>> break_string(\\"abcdefg\\", []) == [\\"abcdefg\\"] >>> break_string(\\"abcdefg\\", [3]) == [\\"abc\\", \\"defg\\"] >>> break_string(\\"abcdefg\\", [0, 2, 4]) == [\\"\\", \\"ab\\", \\"cd\\", \\"efg\\"] >>> break_string(\\"abcdefg\\", [2, 4, 7]) == [\\"ab\\", \\"cd\\", \\"efg\\", \\"\\"] >>> break_string(\\"abcdefg\\", [1, 3, 6]) == [\\"a\\", \\"bc\\", \\"def\\", \\"g\\"] >>> break_string(\\"aabbaa\\", [2, 4, 5]) == [\\"aa\\", \\"bb\\", \\"a\\", \\"a\\"] >>> break_string(\\"abcdef\\", [1, 2, 3, 4, 5]) == [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\"]","solution":"def break_string(s, brk_idx): Breaks the string s into parts at every index given in brk_idx. Parameters: - s (str): The input string to be broken into parts. - brk_idx (list of int): The list of indices where the string should be broken. Returns: - list of str: List of substrings after breaking the string. if not brk_idx: return [s] result = [] previous_index = 0 for index in brk_idx: result.append(s[previous_index:index]) previous_index = index result.append(s[previous_index:]) return result"},{"question":"def max_visible_buildings(heights: List[int]) -> int: Determine the maximum number of buildings visible from the first building in the list. Parameters: heights (List[int]): List of integers representing the heights of the buildings. Returns: int: Maximum number of visible buildings. >>> max_visible_buildings([5]) 1 >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([5, 4, 3, 2, 1]) 1 >>> max_visible_buildings([1, 3, 2, 5, 4, 7]) 4 >>> max_visible_buildings([1, 3, 2, 4, 3, 5]) 4 >>> max_visible_buildings([1, 2, 2, 2, 3]) 3","solution":"def max_visible_buildings(heights): Returns the maximum number of buildings visible from the first building in the list. Parameters: heights (list): List of integers representing the heights of the buildings. Returns: int: Maximum number of visible buildings. if not heights: return 0 max_count = 1 # First building is always visible current_height = heights[0] for height in heights[1:]: if height > current_height: max_count += 1 current_height = height return max_count"},{"question":"def rearrange_array(arr, k): Rearranges the elements in arr such that any two adjacent elements have an absolute difference of at most k. If it's not possible, returns an empty array. Parameters: arr (list of int): The input array to be rearranged. k (int): The maximum allowed absolute difference between adjacent elements. Returns: list of int: A rearranged array that meets the condition, or an empty array if not possible. >>> rearrange_array([1, 3, 5, 8], 3) [1, 3, 5, 8] >>> rearrange_array([5, 1, 8, 3], 3) [1, 3, 5, 8] # or any valid rearrangement >>> rearrange_array([10], 2) [10] >>> rearrange_array([], 5) [] >>> rearrange_array([1, 5, 10], 2) [] >>> rearrange_array([1, 2, 5], 3) [1, 2, 5] # or any valid rearrangement","solution":"def rearrange_array(arr, k): Rearranges the elements in arr such that any two adjacent elements have an absolute difference of at most k. If it's not possible, returns an empty array. Parameters: arr (list of int): The input array to be rearranged. k (int): The maximum allowed absolute difference between adjacent elements. Returns: list of int: A rearranged array that meets the condition, or an empty array if not possible. if not arr: return [] # First, we sort the array arr.sort() # Check from sorted array if we can rearange elements for i in range(1, len(arr)): if abs(arr[i] - arr[i - 1]) > k: return [] return arr"},{"question":"def count_anagrams(words: List[str], targetWord: str) -> int: Returns the count of unique words in the list that are anagrams of the targetWord. Args: words: List of strings targetWord: A string whose anagrams we are checking in the list Returns: int: Count of unique anagrams of targetWord in the list Example: >>> count_anagrams([\\"hello\\", \\"world\\", \\"python\\"], \\"example\\") 0 >>> count_anagrams([\\"listen\\", \\"silent\\", \\"enlist\\"], \\"silent\\") 3 >>> count_anagrams([\\"tar\\", \\"rat\\", \\"art\\", \\"star\\", \\"tars\\"], \\"rat\\") 3 >>> count_anagrams([\\"abc\\", \\"cba\\", \\"bca\\", \\"abc\\", \\"cab\\"], \\"abc\\") 4 >>> count_anagrams([], \\"anyword\\") 0 >>> count_anagrams([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"d\\"], \\"a\\") 1 from collections import Counter # Your code here","solution":"def count_anagrams(words, targetWord): Returns the count of unique words in the list that are anagrams of the targetWord. Args: words: List of strings targetWord: A string whose anagrams we are checking in the list Returns: int: Count of unique anagrams of targetWord in the list from collections import Counter target_counter = Counter(targetWord) anagram_set = set() for word in words: if Counter(word) == target_counter: anagram_set.add(word) return len(anagram_set)"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, return the length of the longest substring that contains at most two distinct characters. If \`s\` is empty, return \`0\`. >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"ab\\") 2 >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") 4 >>> length_of_longest_substring_two_distinct(\\"aaaa\\") 4 >>> length_of_longest_substring_two_distinct(\\"abababa\\") 7 >>> length_of_longest_substring_two_distinct(\\"cdcdccc\\") 7","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. if not s: return 0 left = 0 max_length = 0 char_count = {} for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 current_length = right - left + 1 max_length = max(max_length, current_length) return max_length"},{"question":"from typing import List def findKthSmallestElement(nums: List[int], k: int) -> int: Finds the k-th smallest element in an unsorted array of integers. Args: nums: List[int] - A list of integers. k: int - The position (1-indexed) of the smallest element to find in the sorted order. Returns: int - The k-th smallest element in the array. Raises: ValueError - If k is out of the valid range of the array. >>> findKthSmallestElement([3, 1, 4, 1, 5, 9, 2, 6, 5], 3) 2 >>> findKthSmallestElement([7, 10, 4, 3, 20, 15], 4) 10","solution":"import heapq from typing import List def findKthSmallestElement(nums: List[int], k: int) -> int: Finds the k-th smallest element in the array. if k < 1 or k > len(nums): raise ValueError(\\"k is out of the valid range\\") # Using a heap to find the k-th smallest element min_heap = nums[:] heapq.heapify(min_heap) # Extract the k-th smallest element for _ in range(k - 1): heapq.heappop(min_heap) return heapq.heappop(min_heap)"},{"question":"def rotate_array(nums: List[int], k: int) -> List[int]: Given a circular array of integers \`nums\` of size \`n\`, rotate the array to the right by \`k\` steps, where \`k\` is non-negative. Return the modified array after performing the rotation. A circular array wraps around when the end is reached, so elements shifted off the right end appear at the beginning in the same order. >>> rotate_array([1], 3) [1] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5]","solution":"def rotate_array(nums, k): Rotates the array to the right by k steps. Parameters: nums (list of int): The input circular array to be rotated. k (int): The number of steps to rotate the array. Returns: list of int: The rotated array. n = len(nums) k = k % n # In case k is greater than n return nums[-k:] + nums[:-k] # Rotate the array"},{"question":"def count_even_pairs(nums: List[int]) -> int: Given an array of integers 'nums', return the total number of pairs (i, j) such that nums[i] and nums[j] (i ≠ j) are both even. Since the number of pairs may be large, return the result modulo 10^9 + 7. >>> count_even_pairs([2, 4, 6, 8]) 6 >>> count_even_pairs([1, 2, 3, 4, 5, 6]) 3 >>> count_even_pairs([1, 3, 5, 7]) 0 >>> count_even_pairs([2]) 0 >>> count_even_pairs([10**6, 10**6, 10**6, 10**6]) 6 >>> count_even_pairs([2] * (10**5)) mod_result # Replace mod_result with the expected modulo result pass","solution":"def count_even_pairs(nums): Returns the total number of pairs (i, j) such that nums[i] and nums[j] (i ≠ j) are both even. The result is returned modulo 10^9 + 7. MOD = 10**9 + 7 even_count = sum(1 for num in nums if num % 2 == 0) if even_count < 2: return 0 # Number of ways to pick 2 even numbers from even_count return (even_count * (even_count - 1) // 2) % MOD"},{"question":"def longest_substring_with_n_distinct_chars(s: str, n: int) -> int: Returns the length of the longest substring of \`s\` where the number of distinct characters is exactly \`n\`. If no such substring exists, return \`-1\`. >>> longest_substring_with_n_distinct_chars(\\"abcba\\", 2) 3 >>> longest_substring_with_n_distinct_chars(\\"aaabbb\\", 2) 6 >>> longest_substring_with_n_distinct_chars(\\"aabbcc\\", 3) 6 >>> longest_substring_with_n_distinct_chars(\\"abc\\", 4) -1 >>> longest_substring_with_n_distinct_chars(\\"abc\\", 0) -1 >>> longest_substring_with_n_distinct_chars(\\"\\", 2) -1 >>> longest_substring_with_n_distinct_chars(\\"a\\", 1) 1 >>> longest_substring_with_n_distinct_chars(\\"abcdef\\", 6) 6 >>> longest_substring_with_n_distinct_chars(\\"aaaaaa\\", 1) 6","solution":"def longest_substring_with_n_distinct_chars(s, n): Returns the length of the longest substring of \`s\` where the number of distinct characters is exactly \`n\`. If no such substring exists, return \`-1\`. if n == 0: return -1 if s else 0 max_length = -1 char_count = {} left = 0 for right in range(len(s)): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > n: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 if len(char_count) == n: max_length = max(max_length, right - left + 1) return max_length"},{"question":"def min_adjacent_swaps_to_move_max_at_least_k_places(arr: List[int], k: int) -> int: Returns the minimum number of adjacent swaps required to move the maximum integer in arr at least k places from the start of the array. If it's not possible, return -1. >>> min_adjacent_swaps_to_move_max_at_least_k_places([1, 2, 3, 4, 5], 4) == 0 >>> min_adjacent_swaps_to_move_max_at_least_k_places([5, 1, 2, 3, 4], 4) == 4 >>> min_adjacent_swaps_to_move_max_at_least_k_places([1, 2, 3, 4, 5], 10) == -1 >>> min_adjacent_swaps_to_move_max_at_least_k_places([2, 3, 4, 5, 1], 3) == 0 >>> min_adjacent_swaps_to_move_max_at_least_k_places([5, 4, 3, 2, 1], 2) == 2","solution":"def min_adjacent_swaps_to_move_max_at_least_k_places(arr, k): Returns the minimum number of adjacent swaps required to move the maximum integer in arr at least k places from the start of the array. If it's not possible, return -1. max_val = max(arr) max_index = arr.index(max_val) if max_index >= k: return 0 if k >= len(arr): return -1 swaps_needed = k - max_index return swaps_needed"},{"question":"def has_three_consecutive_increasing(arr: List[int]) -> bool: Returns true if there are three consecutive elements in the array that are strictly increasing, otherwise returns false. >>> has_three_consecutive_increasing([1, 2, 3, 4]) True >>> has_three_consecutive_increasing([1, 2, 3, 1, 2, 3]) True >>> has_three_consecutive_increasing([3, 2, 1, 3, 2, 1]) False >>> has_three_consecutive_increasing([1, 2, 3]) True >>> has_three_consecutive_increasing([1, 2]) False >>> has_three_consecutive_increasing([-3, -2, -1, 0]) True >>> has_three_consecutive_increasing([0, -1, 2, -3, 4, 3, 2, 1, 2, 4, 6]) True >>> has_three_consecutive_increasing([5, 5, 5, 5, 5]) False >>> has_three_consecutive_increasing([1, 3, 5]) True","solution":"def has_three_consecutive_increasing(arr): Returns true if there are three consecutive elements in the array that are strictly increasing, otherwise returns false. for i in range(len(arr) - 2): if arr[i] < arr[i + 1] < arr[i + 2]: return True return False"},{"question":"def largestRectangleArea(heights: List[int]) -> int: Computes the maximum area of a rectangle that can be formed by choosing a subset of buildings. >>> largestRectangleArea([4]) == 4 >>> largestRectangleArea([4, 2]) == 4 >>> largestRectangleArea([2, 4]) == 4 >>> largestRectangleArea([6, 5, 4, 3, 2, 1]) == 12 >>> largestRectangleArea([1, 2, 3, 4, 5, 6]) == 12 >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 >>> largestRectangleArea([4, 4, 4, 4]) == 16","solution":"def largestRectangleArea(heights): Computes the maximum area of a rectangle that can be formed by choosing a subset of buildings. :param heights: List[int] :return: int stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index) max_area = max(max_area, area) return max_area"},{"question":"def next_permutation(nums): Rearrange the array \`nums\` into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement is done in-place with constant extra memory. Parameters: nums (List[int]): The list of integers to rearrange. Returns: List[int]: The rearranged list as the next permutation. Examples: >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] >>> next_permutation([1]) [1] >>> next_permutation([1, 2]) [2, 1] >>> next_permutation([2, 1]) [1, 2] >>> next_permutation([1, 5, 1]) [5, 1, 1] >>> next_permutation([1, 2, 3, 6, 5, 4]) [1, 2, 4, 3, 5, 6]","solution":"def next_permutation(nums): Rearrange the array \`nums\` into the lexicographically next greater permutation of numbers. If such an arrangement is not possible, it must rearrange it to the lowest possible order (i.e., sorted in ascending order). The replacement is done in-place with constant extra memory. Parameters: nums (List[int]): The list of integers to rearrange. Returns: List[int]: The rearranged list as the next permutation. # Find the first decrease from the end i = len(nums) - 2 while i >= 0 and nums[i] >= nums[i + 1]: i -= 1 if i >= 0: # Find the element just larger than the one at i j = len(nums) - 1 while j >= 0 and nums[j] <= nums[i]: j -= 1 # Swap them nums[i], nums[j] = nums[j], nums[i] # Reverse the elements from i+1 to end to get the next smallest lexicographical order nums[i + 1:] = reversed(nums[i + 1:]) return nums"},{"question":"def minMeetingRooms(intervals: List[List[int]]) -> int: Returns the minimum number of meeting rooms required to accommodate all the meetings without conflicts. :param intervals: List of intervals where each interval is a list [start, end]. >>> minMeetingRooms([]) == 0 >>> minMeetingRooms([[1, 4]]) == 1 >>> minMeetingRooms([[1, 2], [3, 4], [5, 6]]) == 1 >>> minMeetingRooms([[1, 4], [2, 6], [3, 5]]) == 3 >>> minMeetingRooms([[1, 4], [2, 5], [6, 8]]) == 2 >>> minMeetingRooms([[1, 4], [2, 3], [3, 5], [7, 8]]) == 2 >>> minMeetingRooms([[0, 30], [5, 10], [15, 20]]) == 2 >>> minMeetingRooms([[1, 10], [2, 6], [6, 8], [8, 10]]) == 2","solution":"def minMeetingRooms(intervals): Returns the minimum number of meeting rooms required to accommodate all the meetings without conflicts. :param intervals: List of intervals where each interval is a list [start, end]. if not intervals: return 0 # Separate start and end times starts = sorted(interval[0] for interval in intervals) ends = sorted(interval[1] for interval in intervals) start_ptr, end_ptr = 0, 0 used_rooms = 0 max_rooms = 0 while start_ptr < len(intervals): # If the meeting starts before or when another meeting ends if starts[start_ptr] < ends[end_ptr]: used_rooms += 1 start_ptr += 1 else: used_rooms -= 1 end_ptr += 1 max_rooms = max(max_rooms, used_rooms) return max_rooms"},{"question":"def select_k_unique_chars(text: str, k: int) -> str: Select a maximum of k characters from text such that each character is unique and their order in the string is preserved. Args: text (str): The input text containing only lowercase English letters. k (int): The maximum number of unique characters to select. Returns: str: The resulting string after selecting up to k unique characters preserving their order from the original string. >>> select_k_unique_chars(\\"abcabc\\", 2) \\"ab\\" >>> select_k_unique_chars(\\"abcabc\\", 3) \\"abc\\" >>> select_k_unique_chars(\\"abcabc\\", 1) \\"a\\" >>> select_k_unique_chars(\\"aaabbbccc\\", 3) \\"abc\\" >>> select_k_unique_chars(\\"bacbacbac\\", 2) \\"ba\\" >>> select_k_unique_chars(\\"abcdef\\", 6) \\"abcdef\\" >>> select_k_unique_chars(\\"aabbcc\\", 5) \\"abc\\"","solution":"def select_k_unique_chars(text, k): Select a maximum of k characters from text such that each character is unique and their order in the string is preserved. unique_chars = set() result = [] for char in text: if char not in unique_chars: if len(unique_chars) < k: unique_chars.add(char) result.append(char) return ''.join(result)"},{"question":"import math def min_operations(m: int, n: int, k: int) -> int: Calculate the minimum number of \`k x k\` matrices required to cover an \`m x n\` grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. k (int): Size of the submatrix. Returns: int: Minimum number of k x k operations required to fully cover the grid. >>> min_operations(4, 4, 2) 4 >>> min_operations(6, 6, 3) 4 >>> min_operations(3, 5, 2) 6 >>> min_operations(8, 5, 3) 6 >>> min_operations(2, 2, 3) 1 >>> min_operations(1, 1, 5) 1 >>> min_operations(10, 10, 1) 100 >>> min_operations(10, 15, 1) 150","solution":"import math def min_operations(m, n, k): Calculate the minimum number of \`k x k\` matrices required to cover an \`m x n\` grid. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. k (int): Size of the submatrix. Returns: int: Minimum number of k x k operations required to fully cover the grid. rows_needed = math.ceil(m / k) cols_needed = math.ceil(n / k) return rows_needed * cols_needed"},{"question":"def findMaxSubarray(arr: List[int]) -> Dict[str, int]: Find the maximum sum of any contiguous subarray with at least one element, including the sum, start and end indices. Args: arr (List[int]): The input array of integers Returns: Dict[str, int]: A dictionary containing 'maxSum', 'start', and 'end' indices Examples: >>> findMaxSubarray([-2,1,-3,4,-1,2,1,-5,4]) {'maxSum': 6, 'start': 3, 'end': 6} >>> findMaxSubarray([-2, -3, -1, -5]) {'maxSum': -1, 'start': 2, 'end': 2} >>> findMaxSubarray([5]) {'maxSum': 5, 'start': 0, 'end': 0} >>> findMaxSubarray([1, 3, 5, 7]) {'maxSum': 16, 'start': 0, 'end': 3} >>> findMaxSubarray([-2, -3, 4, -1, -2, 1, 5, -3]) {'maxSum': 7, 'start': 2, 'end': 6} pass","solution":"def findMaxSubarray(arr): Find the maximum sum of any contiguous subarray with at least one element. Args: arr (list of int): The input array Returns: dict: A dictionary containing 'maxSum', 'start', and 'end' indices # Initialize variables max_sum = float('-inf') current_sum = 0 start = end = temp_start = 0 for i in range(len(arr)): if current_sum <= 0: temp_start = i current_sum = arr[i] else: current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i return {'maxSum': max_sum, 'start': start, 'end': end}"},{"question":"def maxSideLength(mat: List[List[int]], threshold: int) -> int: Find the largest side length of a square subgrid such that the sum of the elements inside the square subgrid is less than or equal to the given threshold. >>> maxSideLength([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 0) 0 >>> maxSideLength([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1) 1 >>> maxSideLength([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 9) 3 >>> maxSideLength([[1, 1, 3], [1, 1, 3], [3, 3, 3]], 6) 2 >>> maxSideLength([[1, 2, 3], [4, 5, 6]], 8) 1 >>> maxSideLength([[1, 2, 3], [4, 5, 6]], 12) 2","solution":"def maxSideLength(mat, threshold): def get_sum(x1, y1, x2, y2, prefix_sum): return prefix_sum[x2 + 1][y2 + 1] - prefix_sum[x1][y2 + 1] - prefix_sum[x2 + 1][y1] + prefix_sum[x1][y1] m, n = len(mat), len(mat[0]) prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix_sum[i + 1][j + 1] = mat[i][j] + prefix_sum[i][j + 1] + prefix_sum[i + 1][j] - prefix_sum[i][j] max_side = 0 for side_len in range(1, min(m, n) + 1): found = False for i in range(m - side_len + 1): for j in range(n - side_len + 1): if get_sum(i, j, i + side_len - 1, j + side_len - 1, prefix_sum) <= threshold: found = True max_side = side_len if not found: break return max_side"},{"question":"from typing import List def maximum_product_of_three(numbers: List[int]) -> int: Returns the maximum product obtained by multiplying any three distinct integers from the list. If there are fewer than three integers in the list, return 0. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of three distinct integers from the list. >>> maximum_product_of_three([]) == 0 >>> maximum_product_of_three([1, 2]) == 0 >>> maximum_product_of_three([1, 2, 3]) == 6 >>> maximum_product_of_three([-10, -10, 5, 2]) == 500 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 >>> maximum_product_of_three([1, 10, 2, 6, 5, 3]) == 300 >>> maximum_product_of_three([7, 8, 9, 10]) == 720 >>> maximum_product_of_three([-7, -8, -9, -10]) == -504 >>> maximum_product_of_three([-4, -3, -2, -1, 60]) == 720","solution":"def maximum_product_of_three(numbers): Returns the maximum product obtained by multiplying any three distinct integers from the list. If there are fewer than three integers in the list, returns 0. Parameters: numbers (list): A list of integers. Returns: int: The maximum product of three distinct integers from the list. if len(numbers) < 3: return 0 numbers.sort() # Finding the product of three largest numbers max_product1 = numbers[-1] * numbers[-2] * numbers[-3] # Finding the product of two smallest numbers and the largest number max_product2 = numbers[0] * numbers[1] * numbers[-1] return max(max_product1, max_product2)"},{"question":"def count_good_strings(words: List[str], chars: str) -> int: Returns the sum of the lengths of all \\"good\\" strings in words that can be formed using the characters in chars without repetition. >>> count_good_strings([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_good_strings([\\"a\\", \\"ab\\", \\"abc\\"], \\"cba\\") 6 >>> count_good_strings([\\"hello\\", \\"world\\"], \\"abc\\") 0 >>> count_good_strings([\\"cat\\", \\"dog\\", \\"god\\", \\"good\\"], \\"odgcat\\") 9 >>> count_good_strings([\\"cat\\", \\"dog\\"], \\"\\") 0 >>> count_good_strings([], \\"abc\\") 0 from solution import count_good_strings def test_count_good_strings_example(): words = [\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"] chars = \\"atach\\" assert count_good_strings(words, chars) == 6 def test_count_good_strings_all_good(): words = [\\"a\\", \\"ab\\", \\"abc\\"] chars = \\"cba\\" assert count_good_strings(words, chars) == 6 def test_count_good_strings_none_good(): words = [\\"hello\\", \\"world\\"] chars = \\"abc\\" assert count_good_strings(words, chars) == 0 def test_count_good_strings_partial_good(): words = [\\"cat\\", \\"dog\\", \\"god\\", \\"good\\"] chars = \\"odgcat\\" assert count_good_strings(words, chars) == 9 def test_count_good_strings_empty_chars(): words = [\\"cat\\", \\"dog\\"] chars = \\"\\" assert count_good_strings(words, chars) == 0 def test_count_good_strings_empty_words(): words = [] chars = \\"abc\\" assert count_good_strings(words, chars) == 0","solution":"def count_good_strings(words, chars): Returns the sum of the lengths of all \\"good\\" strings in words. from collections import Counter char_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > char_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"def shortest_palindrome(s: str) -> str: Construct the shortest possible palindrome by adding characters to the end of the given string. >>> shortest_palindrome(\\"ab\\") 'aba' >>> shortest_palindrome(\\"a\\") 'a' >>> shortest_palindrome(\\"aa\\") 'aa' >>> shortest_palindrome(\\"abc\\") 'abcba' >>> shortest_palindrome(\\"abcd\\") 'abcdcba' >>> shortest_palindrome(\\"race\\") 'racecar' >>> shortest_palindrome(\\"\\") '' >>> shortest_palindrome(\\"radar\\") 'radar' >>> shortest_palindrome(\\"level\\") 'level'","solution":"def shortest_palindrome(s): Constructs the shortest possible palindrome by adding characters to the end of the given string. def is_palindrome(x): return x == x[::-1] if is_palindrome(s): return s for i in range(len(s)): if is_palindrome(s[i:]): return s + s[:i][::-1] return s"},{"question":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted array of arr1 and arr2. If k is larger than the total number of elements in the merged array, return -1. >>> kth_smallest_element([1, 3, 5], [2, 4, 6], 3) 3 >>> kth_smallest_element([1, 2], [3, 4, 5, 6], 5) 5 >>> kth_smallest_element([1, 2], [3, 4, 5, 6], 6) 6 >>> kth_smallest_element([1, 2, 3], [], 2) 2 >>> kth_smallest_element([], [1, 2, 3], 2) 2 >>> kth_smallest_element([1, 3, 5], [2, 4, 6], 7) -1 >>> kth_smallest_element([], [], 1) -1 >>> kth_smallest_element([1], [], 1) 1 >>> kth_smallest_element([], [1], 1) 1 >>> kth_smallest_element([1, 2, 2, 2], [2, 2, 2, 3], 5) 2 >>> kth_smallest_element([1, 1, 1, 1], [1, 1, 1, 1], 8) 1","solution":"def kth_smallest_element(arr1, arr2, k): Returns the k-th smallest element in the merged sorted array of arr1 and arr2. If k is larger than the total number of elements in the merged array, return -1. merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 while i < len(arr1): merged.append(arr1[i]) i += 1 while j < len(arr2): merged.append(arr2[j]) j += 1 if k > len(merged): return -1 return merged[k-1]"},{"question":"def removeKdigits(num: str, k: int) -> str: Remove k digits from the \`num\` to form the smallest possible number. >>> removeKdigits(\\"1234567890\\", 10) == \\"0\\" >>> removeKdigits(\\"12345\\", 0) == \\"12345\\" >>> removeKdigits(\\"1432219\\", 3) == \\"1219\\" >>> removeKdigits(\\"10200\\", 1) == \\"200\\" >>> removeKdigits(\\"10\\", 2) == \\"0\\" >>> removeKdigits(\\"541270936\\", 3) == \\"120936\\" >>> removeKdigits(\\"10001\\", 4) == \\"0\\" >>> removeKdigits(\\"10009\\", 3) == \\"0\\" >>> removeKdigits(\\"4321\\", 2) == \\"21\\" >>> removeKdigits(\\"321\\", 2) == \\"1\\" >>> removeKdigits(\\"0\\", 0) == \\"0\\" >>> removeKdigits(\\"1000000\\", 5) == \\"0\\"","solution":"def removeKdigits(num: str, k: int) -> str: Remove k digits from the \`num\` to form the smallest possible number. stack = [] for digit in num: while k > 0 and stack and stack[-1] > digit: stack.pop() k -= 1 stack.append(digit) # If there are still digits to remove, remove them from the end while k > 0: stack.pop() k -= 1 # Convert list to string and remove leading zeros result = ''.join(stack).lstrip('0') return result if result else \\"0\\""},{"question":"from typing import List, Set def possible_sentences(s: str, wordList: List[List[str]]) -> Set[str]: Generate all possible unique sentences by replacing the words in the string with words from their respective word lists. :param s: Original sentence as a string. :param wordList: List of lists, where each sublist contains words that can be substituted with each other. :return: Set of all possible unique sentences. >>> possible_sentences(\\"hello world\\", [[\\"hello\\", \\"hi\\"], [\\"world\\", \\"earth\\"]]) == {\\"hello world\\", \\"hi world\\", \\"hello earth\\", \\"hi earth\\"} >>> possible_sentences(\\"happy birthday\\", [[\\"happy\\", \\"joyful\\", \\"cheerful\\"], [\\"birthday\\", \\"anniversary\\"]]) == {\\"happy birthday\\", \\"happy anniversary\\", \\"joyful birthday\\", \\"joyful anniversary\\", \\"cheerful birthday\\", \\"cheerful anniversary\\"}","solution":"import itertools def possible_sentences(s, wordList): Generate all possible unique sentences by replacing the words in the string with words from their respective word lists. :param s: Original sentence as a string. :param wordList: List of lists, where each sublist contains words that can be substituted with each other. :return: Set of all possible unique sentences. words = s.split() word_dict = {word: substitutes for word_list in wordList for word in word_list for substitutes in [word_list]} def get_substitutes(word): return word_dict.get(word, [word]) substitute_combinations = [get_substitutes(word) for word in words] all_possible_sentences = [' '.join(sentence) for sentence in itertools.product(*substitute_combinations)] return set(all_possible_sentences)"},{"question":"def count_subarrays_with_even(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays of length \`k\` that have at least one even number. >>> count_subarrays_with_even([1, 2, 3, 4], 2) == 3 >>> count_subarrays_with_even([2, 4, 6, 8], 3) == 2 >>> count_subarrays_with_even([1, 3, 5, 7], 2) == 0 >>> count_subarrays_with_even([1, 2, 3, 4, 5, 6], 3) == 4 >>> count_subarrays_with_even([2, 3, 4], 1) == 2 >>> count_subarrays_with_even([1, 2], 3) == 0","solution":"def count_subarrays_with_even(nums, k): Returns the number of contiguous subarrays of length \`k\` that have at least one even number. if k > len(nums): return 0 count = 0 # Iterate over all possible subarrays of length k for i in range(len(nums) - k + 1): subarray = nums[i:i + k] if any(num % 2 == 0 for num in subarray): count += 1 return count"},{"question":"def find_closest_to_median(positions: List[int], identifiers: List[int]) -> int: Returns the identifier of the position closest to the median of the positions. Parameters: positions (list of int): An array of integers representing positions on a number line. identifiers (list of int): An array of unique integers representing the corresponding identifiers. Returns: int: The identifier of the position closest to the median. from typing import List def test_find_closest_to_median_odd_elements(): assert find_closest_to_median([1, 3, 7, 8, 9], [101, 102, 103, 104, 105]) == 103 def test_find_closest_to_median_even_elements(): assert find_closest_to_median([5, 10, 15, 20], [201, 202, 203, 204]) == 202 def test_find_closest_to_median_two_close_elements(): assert find_closest_to_median([2, 3, 6, 7], [301, 302, 303, 304]) == 302 def test_find_closest_to_median_single_element(): assert find_closest_to_median([0], [401]) == 401 def test_find_closest_to_median_negative_and_positive(): assert find_closest_to_median([-5, -2, 3, 6], [501, 502, 503, 504]) == 502 def test_find_closest_to_median_positive_and_zero(): assert find_closest_to_median([0, 5, 10], [601, 602, 603]) == 602 def test_find_closest_to_median_identical_distances(): # Median between 5 and 6 is 5.5, both 5 and 6 equally close assert find_closest_to_median([2, 5, 6, 9], [701, 702, 703, 704]) == 702 def test_find_closest_to_median_larger_array(): positions = [20, 30, 40, 50, 60, 70, 80] identifiers = [801, 802, 803, 804, 805, 806, 807] assert find_closest_to_median(positions, identifiers) == 804","solution":"def find_closest_to_median(positions, identifiers): Returns the identifier of the position closest to the median of the positions. Parameters: positions (list of int): An array of integers representing positions on a number line. identifiers (list of int): An array of unique integers representing the corresponding identifiers. Returns: int: The identifier of the position closest to the median. sorted_positions = sorted(zip(positions, identifiers)) n = len(positions) if n % 2 == 1: median_value = sorted_positions[n // 2][0] else: median_value = (sorted_positions[n // 2][0] + sorted_positions[n // 2 - 1][0]) / 2 closest_position = None closest_identifier = None smallest_diff = float('inf') for pos, iden in sorted_positions: diff = abs(pos - median_value) if diff < smallest_diff or (diff == smallest_diff and (closest_position is None or pos < closest_position)): smallest_diff = diff closest_position = pos closest_identifier = iden return closest_identifier"},{"question":"def single_number(arr): Returns the integer that appears exactly once in the array. All other integers appear exactly three times. >>> single_number([2, 2, 3, 2]) 3 >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99 >>> single_number([30000, 500, 100, 30000, 100, 30000, 100]) 500 >>> single_number([-2, -2, 1, -2]) 1 >>> single_number([5, 5, 5, 9]) 9 >>> single_number([-1, -2, -2, -2]) -1 >>> single_number([0, 0, 0, -5]) -5","solution":"def single_number(arr): Returns the integer that appears exactly once in the array. All other integers appear exactly three times. ones, twos = 0, 0 for num in arr: ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"def longest_valid_substring(s: str) -> int: Returns the length of the longest valid substring ('a' followed by 'b' and 'c') in the given string s. >>> longest_valid_substring(\\"abc\\") 3 >>> longest_valid_substring(\\"abcabc\\") 3 >>> longest_valid_substring(\\"aabbcc\\") 0 >>> longest_valid_substring(\\"abccbaabc\\") 3 >>> longest_valid_substring(\\"aaaa\\") 0 >>> longest_valid_substring(\\"bbbb\\") 0 >>> longest_valid_substring(\\"cccc\\") 0 >>> longest_valid_substring(\\"abcxyzabc\\") 3 >>> longest_valid_substring(\\"abacbabcc\\") 3 >>> longest_valid_substring(\\"aabcabc\\") 3","solution":"def longest_valid_substring(s): Returns the length of the longest valid substring ('a' followed by 'b' and 'c') in the given string s. max_length = 0 current_length = 0 a_count = 0 for char in s: if char == 'a': a_count += 1 current_length = 1 elif char == 'b' and a_count > 0: current_length += 1 elif char == 'c' and a_count > 0 and current_length == 2: current_length += 1 max_length = max(max_length, current_length) a_count -= 1 current_length = 0 # reset for a new potential valid substring else: a_count = 0 current_length = 0 return max_length"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): Initializes the object with the root of the binary tree \`root\`. self.root = root def getRightView(self) -> list: Returns the list of values visible from the right view of the binary tree. >>> root = TreeNode(1, TreeNode(2, right=TreeNode(5)), TreeNode(3, right=TreeNode(4))) >>> tree = BinaryTree(root) >>> tree.getRightView() [1, 3, 4] >>> root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(8))), None) >>> tree = BinaryTree(root) >>> tree.getRightView() [1, 2, 4, 8] >>> root = TreeNode(1, None, TreeNode(3, None, TreeNode(7, None, TreeNode(14)))) >>> tree = BinaryTree(root) >>> tree.getRightView() [1, 3, 7, 14] >>> root = TreeNode(1) >>> tree = BinaryTree(root) >>> tree.getRightView() [1] >>> tree = BinaryTree(None) >>> tree.getRightView() []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def __init__(self, root: TreeNode): self.root = root def getRightView(self) -> list: Returns the list of values visible from the right view of the binary tree. if not self.root: return [] right_view = [] queue = [(self.root, 0)] while queue: current_level_size = len(queue) for i in range(current_level_size): node, level = queue.pop(0) if i == current_level_size - 1: # Last element of the current level right_view.append(node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return right_view"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: Codec for serializing and deserializing a binary tree. def serialize(self, root: TreeNode) -> str: Encodes a tree to a single string. Args: root (TreeNode): The root of the binary tree. Returns: str: The serialized string representation of the tree. Example: >>> codec = BinaryTreeCodec() >>> root = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) >>> codec.serialize(root) '1,2,None,None,3,4,None,None,5,None,None' def deserialize(self, data: str) -> TreeNode: Decodes your encoded data to tree. Args: data (str): The serialized string representation of the tree. Returns: TreeNode: The deserialized binary tree. Example: >>> codec = BinaryTreeCodec() >>> data = '1,2,None,None,3,4,None,None,5,None,None' >>> root = codec.deserialize(data) >>> isinstance(root, TreeNode) True def trees_are_equal(tree1, tree2): if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and trees_are_equal(tree1.left, tree2.left) and trees_are_equal(tree1.right, tree2.right)) def test_empty_tree(): codec = BinaryTreeCodec() tree = None serialized = codec.serialize(tree) deserialized = codec.deserialize(serialized) assert trees_are_equal(tree, deserialized) def test_single_node_tree(): codec = BinaryTreeCodec() tree = TreeNode(1) serialized = codec.serialize(tree) deserialized = codec.deserialize(serialized) assert trees_are_equal(tree, deserialized) def test_full_binary_tree(): codec = BinaryTreeCodec() tree = TreeNode(1, TreeNode(2), TreeNode(3, TreeNode(4), TreeNode(5))) serialized = codec.serialize(tree) deserialized = codec.deserialize(serialized) assert trees_are_equal(tree, deserialized) def test_asymmetric_tree(): codec = BinaryTreeCodec() tree = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) serialized = codec.serialize(tree) deserialized = codec.deserialize(serialized) assert trees_are_equal(tree, deserialized) def test_all_null_tree(): codec = BinaryTreeCodec() tree = TreeNode(1, None, None) serialized = codec.serialize(tree) deserialized = codec.deserialize(serialized) assert trees_are_equal(tree, deserialized)","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeCodec: def serialize(self, root): Encodes a tree to a single string. def preorder(node): if not node: return [\\"None\\"] return [str(node.val)] + preorder(node.left) + preorder(node.right) return ','.join(preorder(root)) def deserialize(self, data): Decodes your encoded data to tree. def build_tree(vals): val = vals.pop(0) if val == \\"None\\": return None node = TreeNode(int(val)) node.left = build_tree(vals) node.right = build_tree(vals) return node vals = data.split(',') root = build_tree(vals) return root"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse every k nodes in the linked list. Args: head: ListNode - The head of the linked list. k: int - The number of nodes to reverse at a time. Returns: ListNode - The head of the modified linked list. Examples: >>> head = array_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_array(reverseKGroup(head, 2)) [2, 1, 4, 3, 5] >>> head = array_to_linked_list([1, 2, 3, 4, 5]) >>> linked_list_to_array(reverseKGroup(head, 3)) [3, 2, 1, 4, 5]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverseLinkedList(head, k): new_head, ptr = None, head while k: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head # Count the number of nodes in the linked list node_count = 0 ptr = head while ptr: node_count += 1 ptr = ptr.next dummy = ListNode(0) dummy.next = head prev = dummy while node_count >= k: # Reverse next k nodes tail = prev.next next_prev = tail for _ in range(k): tail = tail.next new_head = reverseLinkedList(prev.next, k) prev.next = new_head next_prev.next = tail prev = next_prev node_count -= k return dummy.next"},{"question":"from collections import deque from typing import List def shortest_bridge(grid: List[List[int]]) -> int: Find the smallest bridge length needed to connect an island to itself in a given n x n binary grid. Example usage: >>> shortest_bridge([[0, 1], [1, 0]]) 1 >>> shortest_bridge([[0, 1, 0], [0, 0, 0], [0, 0, 1]]) 2 >>> shortest_bridge([[1, 1, 1, 1, 1], [1, 0, 0, 0, 1], [1, 0, 1, 0, 1], [1, 0, 0, 0, 1], [1, 1, 1, 1, 1]]) 1 >>> shortest_bridge([[0, 1, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) 2","solution":"from collections import deque def shortest_bridge(grid): def bfs(queue): visited = set() directions = [(-1,0), (1,0), (0,-1), (0,1)] while queue: x, y, dist = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: if grid[nx][ny] == 1: return dist elif grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) def find_island(): for i in range(n): for j in range(n): if grid[i][j] == 1: return i, j def mark_island(x, y, queue): directions = [(-1,0), (1,0), (0,-1), (0,1)] grid[x][y] = -1 queue.append((x, y, 0)) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1: mark_island(nx, ny, queue) n = len(grid) queue = deque() start_x, start_y = find_island() mark_island(start_x, start_y, queue) return bfs(queue)"},{"question":"def closedIsland(grid): Return the number of closed islands in the given grid. >>> closedIsland([[1,1,1,1], [1,0,0,1], [1,0,0,1], [1,1,1,1]]) == 1 >>> closedIsland([[1,1,1,1,1,1,1,0], [1,0,0,1,0,1,1,0], [1,0,1,1,1,1,1,0], [1,0,0,0,0,1,1,0], [1,1,1,1,1,1,1,0]]) == 2 >>> closedIsland([[0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0]]) == 0 >>> closedIsland([[1,1,1], [1,1,1], [1,1,1]]) == 0 >>> closedIsland([[0,0,0], [0,0,0], [0,0,0]]) == 0","solution":"def closedIsland(grid): def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]): return False if grid[i][j] == 1: return True grid[i][j] = 1 up = dfs(i - 1, j) down = dfs(i + 1, j) left = dfs(i, j - 1) right = dfs(i, j + 1) return up and down and left and right closed_islands = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 0: if dfs(i, j): closed_islands += 1 return closed_islands"},{"question":"def max_sum_divisible_by_k(nums, k): Returns the maximum sum of a non-empty subset of nums such that the sum is divisible by k. >>> max_sum_divisible_by_k([1, 2, 3, 4], 3) 9 >>> max_sum_divisible_by_k([1, 2, 3], 7) 0 >>> max_sum_divisible_by_k([3, 6, 9, 12], 3) 30 >>> max_sum_divisible_by_k([5], 5) 5 >>> max_sum_divisible_by_k([4], 5) 0 >>> max_sum_divisible_by_k([3, -4, 6, -3, 9], 3) 18","solution":"def max_sum_divisible_by_k(nums, k): Returns the maximum sum of a non-empty subset of nums such that the sum is divisible by k. dp = [0] + [-float('inf')] * (k - 1) for num in nums: new_dp = dp[:] for i in range(k): new_dp[(i + num) % k] = max(new_dp[(i + num) % k], dp[i] + num) dp = new_dp return dp[0] if dp[0] != 0 else 0"},{"question":"from collections import deque from typing import Dict, List def findShortestPath(graph: Dict[int, List[int]], source: int, destination: int) -> List[int]: Finds the shortest path in an unweighted graph represented by an adjacency list from a given source node to a destination node. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. source (int): The starting node. destination (int): The target node. Returns: List[int]: The list of nodes representing the shortest path from source to destination, including both source and destination. If no path exists, returns an empty list. >>> findShortestPath({1: [2, 3], 2: [], 3: []}, 1, 2) [1, 2] >>> findShortestPath({1: [2], 2: [3], 4: [5]}, 1, 4) [] >>> findShortestPath({1: [2, 3], 2: [4], 3: [4], 4: []}, 1, 4) [1, 2, 4] or [1, 3, 4] >>> findShortestPath({1: [2], 2: [3]}, 1, 1) [1]","solution":"from collections import deque def findShortestPath(graph, source, destination): Finds the shortest path in an unweighted graph from source to destination. Parameters: graph (Dict[int, List[int]]): The adjacency list of the graph. source (int): The starting node. destination (int): The target node. Returns: List[int]: The list of nodes representing the shortest path from source to destination. If no path exists, returns an empty list. if source == destination: return [source] visited = set() queue = deque([(source, [source])]) while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor == destination: return path + [neighbor] if neighbor not in visited: queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return []"},{"question":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def deep_copy_linked_list(nodeList): Create a deep copy of a linked list with random pointers. Each element in the input list 'nodeList' is a tuple of (value, random_index). Return the deep copy as a list of tuples in the same format. >>> deep_copy_linked_list([]) [] >>> deep_copy_linked_list([(1, None)]) [(1, None)] >>> deep_copy_linked_list([(1, 0)]) [(1, 0)] >>> deep_copy_linked_list([(1, None), (2, None)]) [(1, None), (2, None)] >>> deep_copy_linked_list([(1, 1), (2, 0)]) [(1, 1), (2, 0)] >>> deep_copy_linked_list([(1, 4), (2, 2), (3, 0), (4, None), (5, 3)]) [(1, 4), (2, 2), (3, 0), (4, None), (5, 3)]","solution":"class ListNode: def __init__(self, val=0, next=None, random=None): self.val = val self.next = next self.random = random def deep_copy_linked_list(nodeList): if not nodeList: return [] nodes = [ListNode(val=node[0]) for node in nodeList] for i, node in enumerate(nodes): if i < len(nodes) - 1: node.next = nodes[i + 1] if nodeList[i][1] is not None: node.random = nodes[nodeList[i][1]] copied_nodes = [(node.val, None if node.random is None else nodes.index(node.random)) for node in nodes] return copied_nodes"},{"question":"def find_k_integers(x: int, k: int) -> List[int]: Given two integers x and k, find k positive integers that exist in an array A such that the bitwise AND of all elements of the array A equals x. If such an array cannot be found, return an empty array. >>> find_k_integers(12, 3) == [12, 12, 4294967295] >>> find_k_integers(-1, 3) == [] >>> find_k_integers(12, 0) == [] >>> find_k_integers(0, 3) == [] >>> find_k_integers(15, 2) == [15, 4294967295] >>> find_k_integers(1, 1) == [4294967295] >>> find_k_integers(10, 1) == [4294967295]","solution":"def find_k_integers(x, k): Given x and k, return an array of k positive integers such that the bitwise AND of all elements in the array equals x. If no such array exists, return an empty array. if k > 64 or k <= 0 or x <= 0: return [] # We'll use the fact that x itself can be k times in the array along with 1's # This logic works as x & x & ... & x (k-times) is still x result = [x] * (k - 1) # Adding 1 to the array to keep length k and maintain AND sum as x result.append((1 << 32) - 1) # A very large number as a filler which won't change AND result with x. return result"},{"question":"def find_longest_cycle(arr: List[int]) -> int: Find the length of the longest cycle that can be formed in the array. If no cycle exists, return -1. >>> find_longest_cycle([1, 0]) == 2 >>> find_longest_cycle([0, 1, 2]) == -1 >>> find_longest_cycle([1, 0, 3, 2]) == 2 >>> find_longest_cycle([0]) == -1 >>> find_longest_cycle([1, 2, 3, 4, 0]) == 5 >>> find_longest_cycle([0, 1, 2, 3, 4]) == -1 >>> find_longest_cycle([1, 0, 3, 4, 2]) == 3","solution":"def find_longest_cycle(arr): def find_cycle_length(start, arr, visited): current = start length = 0 while current not in visited: visited.add(current) current = arr[current] length += 1 return length if current == start else 0 max_length = -1 visited = set() for i in range(len(arr)): if i not in visited: cycle_length = find_cycle_length(i, arr, visited) max_length = max(max_length, cycle_length) return max_length if max_length > 1 else -1"},{"question":"from typing import List def permuteUnique(nums: List[int]) -> List[List[int]]: Given a collection of integers that might contain duplicates, return all possible unique permutations. >>> permuteUnique([1, 1, 2]) [[1, 1, 2], [1, 2, 1], [2, 1, 1]] >>> permuteUnique([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> permuteUnique([]) [[]] >>> permuteUnique([1]) [[1]] >>> permuteUnique([2, 2, 2]) [[2, 2, 2]] >>> permuteUnique([1, 2, 2]) [[1, 2, 2], [2, 1, 2], [2, 2, 1]]","solution":"from typing import List def permuteUnique(nums: List[int]) -> List[List[int]]: def backtrack(path, used): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]): continue used[i] = True path.append(nums[i]) backtrack(path, used) path.pop() used[i] = False nums.sort() result = [] backtrack([], [False] * len(nums)) return result"},{"question":"def can_complete_deliveries(startTimes, endTimes, m): Determine if all delivery requests can be completed with the available trucks. :param startTimes: List of integers representing start times of delivery requests in HHMM format. :param endTimes: List of integers representing end times of delivery requests in HHMM format. :param m: Integer representing number of available trucks. :return: Boolean value, True if all deliveries can be completed, False otherwise.","solution":"def can_complete_deliveries(startTimes, endTimes, m): Determine if all delivery requests can be completed with the available trucks. :param startTimes: List of integers representing start times of delivery requests in HHMM format. :param endTimes: List of integers representing end times of delivery requests in HHMM format. :param m: Integer representing number of available trucks. :return: Boolean value, True if all deliveries can be completed, False otherwise. events = [] for start, end in zip(startTimes, endTimes): events.append((start, 'start')) events.append((end, 'end')) # Sort events: by time, then by type ('end' before 'start' if they are the same time) events.sort(key=lambda x: (x[0], x[1] == 'start')) current_trucks_in_use = 0 for event in events: if event[1] == 'start': current_trucks_in_use += 1 if current_trucks_in_use > m: return False else: current_trucks_in_use -= 1 return True"},{"question":"def longest_divisible_subsequence(nums: List[int], k: int) -> int: Returns the length of the longest subsequence such that every element in the subsequence is divisible by k. Parameters: nums (list[int]): List of integers. k (int): The integer which each element in the subsequence must be divisible by. Returns: int: Length of the longest divisible subsequence. pass # Unit Test def test_longest_divisible_subsequence_all_divisible(): assert longest_divisible_subsequence([2, 4, 6, 8], 2) == 4 def test_longest_divisible_subsequence_some_divisible(): assert longest_divisible_subsequence([1, 3, 6, 9, 12], 3) == 4 def test_longest_divisible_subsequence_none_divisible(): assert longest_divisible_subsequence([1, 2, 3, 5, 7], 10) == 0 def test_longest_divisible_subsequence_mixed(): assert longest_divisible_subsequence([10, 20, 33, 40], 10) == 3 def test_longest_divisible_subsequence_empty_list(): assert longest_divisible_subsequence([], 5) == 0 def test_longest_divisible_subsequence_k_is_one(): assert longest_divisible_subsequence([1, 2, 3], 1) == 3 def test_longest_divisible_subsequence_large_numbers(): assert longest_divisible_subsequence([10000, 20000, 30000], 10000) == 3","solution":"def longest_divisible_subsequence(nums, k): Returns the length of the longest subsequence such that every element in the subsequence is divisible by k. Parameters: nums (list[int]): List of integers. k (int): The integer which each element in the subsequence must be divisible by. Returns: int: Length of the longest divisible subsequence. return len([num for num in nums if num % k == 0])"},{"question":"def minBuses(tickets, capacity): Returns the minimum number of buses needed to transport all passengers. Parameters: tickets (list of int): Number of bus tickets each passenger has. capacity (int): Maximum capacity of each bus. Returns: int: Minimum number of buses required. Example: >>> minBuses([1, 2, 1, 4, 3], 3) 4 >>> minBuses([1, 1, 1, 1, 1], 2) 3 >>> minBuses([3, 3, 3], 3) 3 >>> minBuses([2, 2, 2], 6) 1 >>> minBuses([4, 5, 1, 8], 5) 4 >>> minBuses([6], 10) 1 >>> minBuses([10, 10, 10], 10) 3 >>> minBuses([1, 1, 1, 1, 1, 1, 1, 1], 5) 2","solution":"def minBuses(tickets, capacity): Returns the minimum number of buses needed to transport all passengers. Parameters: tickets (list of int): Number of bus tickets each passenger has. capacity (int): Maximum capacity of each bus. Returns: int: Minimum number of buses required. buses = 0 current_capacity = 0 for ticket in tickets: if current_capacity + ticket > capacity: buses += 1 current_capacity = ticket else: current_capacity += ticket if current_capacity > 0: buses += 1 return buses"},{"question":"def calculateViewFactor(arr: list) -> int: Calculates the view factor of buildings from the right-hand side. Args: arr (list of int): A list of integers representing the heights of buildings. Returns: int: The total number of buildings that can be seen from the right-hand side. Examples: >>> calculateViewFactor([3, 7, 8, 3, 6, 1]) 3 >>> calculateViewFactor([1, 2, 3, 4, 5]) 1 >>> calculateViewFactor([5, 4, 3, 2, 1]) 5 >>> calculateViewFactor([4]) 1 >>> calculateViewFactor([5, 5, 5, 5]) 1 >>> calculateViewFactor([]) 0 pass","solution":"def calculateViewFactor(arr): Calculates the view factor of buildings from the right-hand side. Args: arr (list of int): A list of integers representing the heights of buildings. Returns: int: The total number of buildings that can be seen from the right-hand side. if not arr: return 0 view_count = 1 # The rightmost building is always visible max_height = arr[-1] # Traverse the list from the second-last element to the first for height in reversed(arr[:-1]): if height > max_height: view_count += 1 max_height = height return view_count"},{"question":"from collections import defaultdict def max_substrings_with_k_distinct_chars(s: str, k: int) -> int: Finds the maximum number of substrings containing exactly k distinct characters. :param s: a string consisting of lowercase alphabetic characters :param k: an integer representing the number of distinct characters in substrings :return: an integer representing the maximum number of such substrings >>> max_substrings_with_k_distinct_chars(\\"pqpqs\\", 2) 7 >>> max_substrings_with_k_distinct_chars(\\"aaaa\\", 1) 10 >>> max_substrings_with_k_distinct_chars(\\"abcdef\\", 2) 5 >>> max_substrings_with_k_distinct_chars(\\"abcdef\\", 10) 0 >>> max_substrings_with_k_distinct_chars(\\"abcdef\\", 0) 0 >>> max_substrings_with_k_distinct_chars(\\"\\", 2) 0","solution":"def max_substrings_with_k_distinct_chars(s, k): Finds the maximum number of substrings containing exactly k distinct characters. :param s: a string consisting of lowercase alphabetic characters :param k: an integer representing the number of distinct characters in substrings :return: an integer representing the maximum number of such substrings from collections import defaultdict if k > 26 or k == 0: return 0 n = len(s) max_number_of_substrings = 0 for start in range(n): char_count = defaultdict(int) distinct_count = 0 for end in range(start, n): if char_count[s[end]] == 0: distinct_count += 1 char_count[s[end]] += 1 if distinct_count == k: max_number_of_substrings += 1 elif distinct_count > k: break return max_number_of_substrings"},{"question":"def minimum_operations(a: int, b: int) -> int: Returns the minimum number of operations required to convert a into b. Operations include increment, decrement, and double. >>> minimum_operations(5, 5) 0 >>> minimum_operations(5, 6) 1 >>> minimum_operations(5, 4) 1 >>> minimum_operations(5, 10) 1 >>> minimum_operations(4, 6) 2 >>> minimum_operations(2, 10) 3 >>> minimum_operations(5, 14) 3","solution":"from collections import deque def minimum_operations(a, b): Returns the minimum number of operations required to convert a into b. Operations include increment, decrement, and double. # Early return if a is already equal to b if a == b: return 0 queue = deque([(a, 0)]) visited = set([a]) while queue: curr, steps = queue.popleft() if curr == b: return steps # Operation: Increment if curr + 1 not in visited: queue.append((curr + 1, steps + 1)) visited.add(curr + 1) # Operation: Decrement if curr - 1 not in visited: queue.append((curr - 1, steps + 1)) visited.add(curr - 1) # Operation: Double if curr * 2 not in visited: queue.append((curr * 2, steps + 1)) visited.add(curr * 2) return -1 # This will not be reached"},{"question":"from typing import List def maxPairs(arr: List[int]) -> int: Determines the maximum number of pairs of balloons that can be formed where each pair consists of balloons of the same color. Parameters: arr (List[int]): List of integers representing the colors of the balloons. Returns: int: Maximum number of pairs of the same color balloons that can be formed. def test_all_unique(): assert maxPairs([1, 2, 3, 4]) == 0 def test_all_same_color(): assert maxPairs([1, 1, 1, 1, 1, 1]) == 3 def test_mixed_colors(): assert maxPairs([1, 2, 3, 1, 2, 2]) == 2 def test_no_balloons(): assert maxPairs([]) == 0 def test_two_colors_turn_even_pairs(): assert maxPairs([1, 1, 2, 2, 1, 2, 1, 2]) == 4 def test_multiple_pairs_one_color(): assert maxPairs([2, 2, 2, 2, 2, 2, 2, 2]) == 4","solution":"from typing import List from collections import Counter def maxPairs(arr: List[int]) -> int: Determines the maximum number of pairs of balloons that can be formed where each pair consists of balloons of the same color. Parameters: arr (List[int]): List of integers representing the colors of the balloons. Returns: int: Maximum number of pairs of the same color balloons that can be formed. color_counts = Counter(arr) return sum(count // 2 for count in color_counts.values())"},{"question":"def minPathSum(grid): Calculate the minimum path sum from the top-left to the bottom-right corner of the grid. >>> minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minPathSum([[1, 2, 3], [4, 5, 6]]) 12 >>> minPathSum([[1]]) 1 >>> minPathSum([[1, 2], [1, 1]]) 3 >>> minPathSum([[1, 2, 5], [3, 2, 1]]) 6 >>> minPathSum([]) 0 >>> minPathSum([[]]) 0 >>> minPathSum([[1], [2], [3]]) 6 >>> minPathSum([[1, 2, 3]]) 6","solution":"def minPathSum(grid): Calculate the minimum path sum from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) # Initialize the first cell with its own cost for r in range(rows): for c in range(cols): if r == 0 and c == 0: continue elif r == 0: # Only one way to reach cells in the first row (from the left) grid[r][c] += grid[r][c - 1] elif c == 0: # Only one way to reach cells in the first column (from above) grid[r][c] += grid[r - 1][c] else: # Choose the minimum cost between coming from the left or from above grid[r][c] += min(grid[r - 1][c], grid[r][c - 1]) # The bottom-right cell contains the minimum path sum return grid[rows - 1][cols - 1]"},{"question":"def minimum_distance(words: List[str], word1: str, word2: str) -> int: Returns the minimum distance between word1 and word2 in the list of words. Distance is defined as the number of elements between the two words (inclusive). >>> minimum_distance([\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"], \\"a\\", \\"b\\") == 2 >>> minimum_distance([\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"b\\", \\"d\\"], \\"a\\", \\"b\\") == 2 >>> minimum_distance([\\"a\\", \\"b\\", \\"c\\", \\"b\\", \\"a\\"], \\"a\\", \\"c\\") == 3 >>> minimum_distance([\\"quick\\", \\"brown\\", \\"fox\\", \\"jumped\\", \\"over\\"], \\"quick\\", \\"over\\") == 5 >>> minimum_distance([\\"the\\", \\"quick\\", \\"brown\\", \\"the\\", \\"quick\\", \\"fox\\"], \\"quick\\", \\"fox\\") == 2 >>> minimum_distance([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"], \\"cat\\", \\"fox\\") == float('inf') >>> minimum_distance([\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\"], \\"the\\", \\"dog\\") == float('inf') pass","solution":"def minimum_distance(words, word1, word2): Returns the minimum distance between word1 and word2 in the list of words. Distance is defined as the number of elements between the two words (inclusive). pos1, pos2 = -1, -1 min_distance = float('inf') for i, word in enumerate(words): if word == word1: pos1 = i if word == word2: pos2 = i if pos1 != -1 and pos2 != -1: min_distance = min(min_distance, abs(pos2 - pos1) + 1) return min_distance"},{"question":"class FlightManager: A class to manage flight seat reservations. Methods: - reserveSeat(int seatNumber): Reserves a specific seat given by seatNumber. Returns True if the seat is successfully reserved, False otherwise. - cancelReservation(int seatNumber): Cancels an existing reservation for the given seat number. Returns True if the reservation is successfully cancelled, False otherwise. - getAvailableSeats(): Returns a list of all available seat numbers sorted in ascending order. def __init__(self, totalSeats): pass def reserveSeat(self, seatNumber): pass def cancelReservation(self, seatNumber): pass def getAvailableSeats(self): pass Unit Tests def test_reserve_valid_seat(): fm = FlightManager(10) assert fm.reserveSeat(1) == True assert fm.reserveSeat(1) == False def test_reserve_invalid_seat(): fm = FlightManager(10) assert fm.reserveSeat(0) == False assert fm.reserveSeat(11) == False def test_cancel_reservation(): fm = FlightManager(10) fm.reserveSeat(2) assert fm.cancelReservation(2) == True assert fm.cancelReservation(2) == False def test_cancel_invalid_reservation(): fm = FlightManager(10) assert fm.cancelReservation(2) == False def test_get_available_seats_initial_state(): fm = FlightManager(5) assert fm.getAvailableSeats() == [1, 2, 3, 4, 5] def test_get_available_seats_after_reservations(): fm = FlightManager(5) fm.reserveSeat(1) fm.reserveSeat(3) assert fm.getAvailableSeats() == [2, 4, 5] def test_get_available_seats_after_cancellation(): fm = FlightManager(5) fm.reserveSeat(1) fm.reserveSeat(3) fm.cancelReservation(1) assert fm.getAvailableSeats() == [1, 2, 4, 5]","solution":"class FlightManager: def __init__(self, totalSeats): Initializes the FlightManager with the specified number of total seats. self.totalSeats = totalSeats self.reservedSeats = set() def reserveSeat(self, seatNumber): Reserves a specific seat given by seatNumber. Returns True if the seat is successfully reserved, False otherwise. if 1 <= seatNumber <= self.totalSeats and seatNumber not in self.reservedSeats: self.reservedSeats.add(seatNumber) return True return False def cancelReservation(self, seatNumber): Cancels an existing reservation for the given seat number. Returns True if the reservation is successfully cancelled, False otherwise. if 1 <= seatNumber <= self.totalSeats and seatNumber in self.reservedSeats: self.reservedSeats.remove(seatNumber) return True return False def getAvailableSeats(self): Returns a list of all available seat numbers sorted in ascending order. return sorted(set(range(1, self.totalSeats + 1)) - self.reservedSeats)"},{"question":"def capture_regions(board: List[List[str]]) -> List[List[str]]: Capture all the regions surrounded by 'X' on a given 2D grid of characters. Args: board (List[List[str]]): A 2D grid consisting of 'X' and 'O'. Returns: List[List[str]]: The modified grid after capturing surrounded regions. >>> capture_regions([['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X']]) [['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X']] >>> capture_regions([['X', 'X', 'X', 'X'], ... ['X', 'O', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X']]) [['X', 'X', 'X', 'X'], ['X', 'O', 'X', 'X'], ['X', 'O', 'O', 'X'], ['X', 'X', 'O', 'X']] >>> capture_regions([]) [] >>> capture_regions([[]]) [[]] >>> capture_regions([['O', 'X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X', 'O'], ... ['X', 'O', 'O', 'X', 'X'], ... ['O', 'X', 'X', 'O', 'O']]) [['O', 'X', 'X', 'O', 'X'], ['X', 'X', 'X', 'X', 'O'], ['X', 'X', 'X', 'X', 'X'], ['O', 'X', 'X', 'O', 'O']] >>> capture_regions([['O', 'O'], ... ['O', 'O']]) [['O', 'O'], ['O', 'O']]","solution":"def capture_regions(board): Capture all the regions surrounded by 'X' on a given board. if not board or not board[0]: return board m, n = len(board), len(board[0]) def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or board[x][y] != 'O': return board[x][y] = 'E' # mark 'E' to avoid revisiting dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) for i in range(m): if board[i][0] == 'O': dfs(i, 0) if board[i][n - 1] == 'O': dfs(i, n - 1) for j in range(n): if board[0][j] == 'O': dfs(0, j) if board[m - 1][j] == 'O': dfs(m - 1, j) for i in range(m): for j in range(n): if board[i][j] == 'O': board[i][j] = 'X' elif board[i][j] == 'E': board[i][j] = 'O' return board"},{"question":"def longestSubarray(nums: List[int], threshold: int) -> int: Returns the length of the longest subarray such that the sum of its elements is less than or equal to the threshold. >>> longestSubarray([1, 2, 3, 4, 5], 8) == 3 >>> longestSubarray([5, 6, 7], 4) == 0 >>> longestSubarray([1, 1, 1, 1], 5) == 4 >>> longestSubarray([10, 11, 12], 9) == 0 >>> longestSubarray([1, 2, 3, 9], 6) == 3 >>> longestSubarray([5, 6, 1, 2, 3, 8], 6) == 3 >>> longestSubarray([1, 2, 2, 3, 4], 2) == 1 >>> longestSubarray([1, 2, 3, 4, 5], 100) == 5","solution":"def longestSubarray(nums, threshold): Returns the length of the longest subarray such that the sum of its elements is less than or equal to the threshold. max_len = 0 current_sum = 0 start = 0 for end in range(len(nums)): current_sum += nums[end] while current_sum > threshold: current_sum -= nums[start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def final_strengths(arr: List[int]) -> List[int]: Returns the final strengths of the warriors after all possible battles have occurred. >>> final_strengths([5]) [5] >>> final_strengths([5, 3]) [8, 0] >>> final_strengths([3, 5]) [3, 5] >>> final_strengths([5, 4, 3]) [12, 0, 0] >>> final_strengths([3, 4, 5]) [3, 4, 5] >>> final_strengths([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> final_strengths([5, 1, 3, 2, 4]) [15, 0, 0, 0, 0] >>> final_strengths([9, 7, 5, 3, 1]) [25, 0, 0, 0, 0] >>> final_strengths([3, 3, 3]) [3, 3, 3] >>> final_strengths([100, 50, 30, 20, 10]) [210, 0, 0, 0, 0]","solution":"def final_strengths(arr): Returns the final strengths of the warriors after all possible battles have occurred. n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i] += arr[j] arr[j] = 0 return arr"},{"question":"class Fancy: Implement a data structure Fancy that supports the following operations: - append(int val): Adds an integer 'val' to the sequence. - addAll(int inc): Increases all elements in the sequence by an integer 'inc'. - multAll(int m): Multiplies all elements in the sequence by an integer 'm'. - getIndex(int idx): Gets the current value at index 'idx' (0-indexed) of the sequence. The sequence starts empty. The result of getIndex should be returned modulo 10^9 + 7. If the index 'idx' is greater than or equal to the length of the sequence, return -1. >>> fancy = Fancy() >>> fancy.append(2) >>> fancy.addAll(3) >>> fancy.append(7) >>> fancy.multAll(2) >>> fancy.getIndex(0) 10 >>> fancy.addAll(3) >>> fancy.append(10) >>> fancy.multAll(2) >>> fancy.getIndex(0) 26 >>> fancy.getIndex(1) 34 >>> fancy.getIndex(2) 20 >>> fancy.getIndex(3) -1","solution":"class Fancy: def __init__(self): self.values = [] self.additive = 0 self.multiplicative = 1 self.mod = 10**9 + 7 def append(self, val: int) -> None: val = (val - self.additive) * pow(self.multiplicative, self.mod-2, self.mod) % self.mod self.values.append(val) def addAll(self, inc: int) -> None: self.additive = (self.additive + inc) % self.mod def multAll(self, m: int) -> None: self.additive = (self.additive * m) % self.mod self.multiplicative = (self.multiplicative * m) % self.mod def getIndex(self, idx: int) -> int: if idx >= len(self.values): return -1 return (self.values[idx] * self.multiplicative + self.additive) % self.mod"},{"question":"def minimum_cost_to_change(s1: str, s2: str) -> int: Calculate the minimum cost required to change string s1 to string s2. Parameters: s1 (str): The original string. s2 (str): The target string. Returns: int: The minimum cost to change s1 to s2. >>> minimum_cost_to_change(\\"abc\\", \\"abc\\") == 0 >>> minimum_cost_to_change(\\"abc\\", \\"bbc\\") == 1 >>> minimum_cost_to_change(\\"abc\\", \\"cba\\") == 4 >>> minimum_cost_to_change(\\"aaa\\", \\"zzz\\") == 75 # Each 'a' to 'z' costs 25 (3 * 25 = 75) >>> minimum_cost_to_change(\\"abcdef\\", \\"ghijkl\\") == 36 # sum of individual costs: 6 pass # Define your test cases def test_minimum_cost_to_change_same_strings(): assert minimum_cost_to_change(\\"abc\\", \\"abc\\") == 0 def test_minimum_cost_to_change_single_difference(): assert minimum_cost_to_change(\\"abc\\", \\"bbc\\") == 1 def test_minimum_cost_to_change_multiple_differences(): assert minimum_cost_to_change(\\"abc\\", \\"cba\\") == 4 def test_minimum_cost_to_change_all_different(): assert minimum_cost_to_change(\\"aaa\\", \\"zzz\\") == 75 # Each 'a' to 'z' costs 25 (3 * 25 = 75) def test_minimum_cost_to_change_mixed_characters(): assert minimum_cost_to_change(\\"abcdef\\", \\"ghijkl\\") == 36 # sum of individual costs: 6","solution":"def minimum_cost_to_change(s1, s2): Calculate the minimum cost required to change string s1 to string s2. Parameters: s1 (str): The original string. s2 (str): The target string. Returns: int: The minimum cost to change s1 to s2. cost = 0 for char_s1, char_s2 in zip(s1, s2): cost += abs(ord(char_s1) - ord(char_s2)) return cost"},{"question":"def maxProfit(nums: List[int], fee: int) -> int: Given an integer array \`nums\` where the ith element represents the number of coins you have on the ith day, and an integer \`fee\` representing the transaction fee, return the maximum profit you can achieve. Args: nums (List[int]): List of integers representing coins on each day. fee (int): The transaction fee for each sell operation. Returns: int: The maximum profit achievable. >>> maxProfit([1, 3, 2, 8, 4, 9], 2) 8 >>> maxProfit([1, 2, 3, 4, 5], 10) 0 >>> maxProfit([5, 4, 3, 2, 1], 1) 0 >>> maxProfit([5], 1) 0 >>> maxProfit([1, 3, 7, 5, 10, 3], 3) 6 >>> maxProfit([1, 1, 1, 1, 1], 1) 0 >>> maxProfit([4, 3, 2, 1], 0) 0","solution":"def maxProfit(nums, fee): Returns the maximum profit you can achieve given the coins and transaction fee. n = len(nums) if n < 2: return 0 # Initialize the current cash and stock cash, stock = 0, -nums[0] for i in range(1, n): cash = max(cash, stock + nums[i] - fee) stock = max(stock, cash - nums[i]) return cash"},{"question":"def k_largest_peaks_sum(arr: List[int], k: int) -> int: Returns the sum of the values of the k largest peaks in the array. If there are fewer than k peaks, returns the sum of all the peak values. >>> k_largest_peaks_sum([1, 2, 3, 4, 5], 1) 0 >>> k_largest_peaks_sum([1, 3, 1], 1) 3 >>> k_largest_peaks_sum([1, 3, 1, 4, 1, 5, 1], 2) 9","solution":"def k_largest_peaks_sum(arr, k): Returns the sum of the values of the k largest peaks in the array. If there are fewer than k peaks, returns the sum of all the peak values. # Helper to find peaks def find_peaks(arr): peaks = [] for i in range(1, len(arr) - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(arr[i]) return peaks peaks = find_peaks(arr) if len(peaks) < k: return sum(peaks) # Sort the peaks in descending order and take the sum of the k largest peaks.sort(reverse=True) return sum(peaks[:k])"},{"question":"def longest_good_subsequence(arr, k): Finds the length of the longest \\"good\\" subsequence. A \\"good\\" subsequence is defined as a subsequence where the absolute difference between the maximum and minimum integers is less than or equal to \`k\`. Parameters: - arr: List[int], the array of integers - k: int, the maximum allowed absolute difference between max and min in the subsequence Returns: - int, length of the longest good subsequence pass # Unit Tests def test_empty_array(): assert longest_good_subsequence([], 3) == 0 def test_single_element(): assert longest_good_subsequence([5], 2) == 1 def test_no_good_subsequence(): assert longest_good_subsequence([1, 10, 20], 5) == 1 def test_all_elements_good(): assert longest_good_subsequence([3, 4, 5, 2], 3) == 4 def test_mixed_elements(): assert longest_good_subsequence([10, 1, 2, 9, 7, 3], 4) == 3 def test_multiple_good_subsequences(): assert longest_good_subsequence([1, 2, 3, 8, 9, 10], 2) == 3 assert longest_good_subsequence([1, 2, 4, 6, 8, 10], 4) == 3 def test_large_k(): assert longest_good_subsequence([1, 2, 3, 4, 5], 10) == 5 def test_zero_k(): assert longest_good_subsequence([1, 2, 3, 4, 5], 0) == 1","solution":"def longest_good_subsequence(arr, k): Finds the length of the longest \\"good\\" subsequence. A \\"good\\" subsequence is defined as a subsequence where the absolute difference between the maximum and minimum integers is less than or equal to \`k\`. Parameters: - arr: List[int], the array of integers - k: int, the maximum allowed absolute difference between max and min in the subsequence Returns: - int, length of the longest good subsequence if not arr: return 0 arr.sort() max_length = 0 n = len(arr) for i in range(n): j = i while j < n and arr[j] - arr[i] <= k: j += 1 max_length = max(max_length, j - i) return max_length"},{"question":"def max_sum_subarray(nums: List[int], k: int) -> int: Returns the maximum sum of a contiguous subarray of length k. >>> max_sum_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_sum_subarray([1, 2, 3, 4, 5], 3) 12 >>> max_sum_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_sum_subarray([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_subarray([1, -2, 3, 10, -3, 5, 1], 3) 12 >>> max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4], 1) 4","solution":"def max_sum_subarray(nums, k): Returns the maximum sum of a contiguous subarray of length k. Parameters: nums (list of int): The input array. k (int): The length of the subarray. Returns: int: The maximum sum of a contiguous subarray of length k. if len(nums) < k: raise ValueError(\\"The length of the subarray k cannot be greater than the length of the input array.\\") max_sum = sum(nums[:k]) current_sum = max_sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def count_intervals(intervals: List[List[int]], k: int) -> List[int]: Returns an array of length k where result[i] is the number of intervals that include the number i. >>> count_intervals([[0, 4]], 5) [1, 1, 1, 1, 1] >>> count_intervals([[0, 2], [1, 3], [2, 4]], 5) [1, 2, 3, 2, 1] >>> count_intervals([[0, 1], [2, 3]], 4) [1, 1, 1, 1] >>> count_intervals([[0, 1], [2, 3]], 5) [1, 1, 1, 1, 0] >>> count_intervals([], 5) [0, 0, 0, 0, 0]","solution":"def count_intervals(intervals, k): Returns an array of length k where result[i] is the number of intervals that include the number i. result = [0] * k for start, end in intervals: for i in range(max(0, start), min(k, end + 1)): result[i] += 1 return result"},{"question":"def find_peak_element(arr): This function takes in a list of integers 'arr' and returns the index of any peak element. A peak element is one that is not smaller than its neighbors. # Unit Test from solution import find_peak_element def test_single_element(): assert find_peak_element([1]) == 0 def test_peak_at_start(): assert find_peak_element([3, 2, 1]) in [0] def test_peak_at_end(): assert find_peak_element([1, 2, 3]) in [2] def test_peak_in_the_middle(): assert find_peak_element([1, 3, 2]) in [1] def test_multiple_peaks(): assert find_peak_element([1, 3, 2, 4, 1]) in [1, 3] def test_flat_array(): assert find_peak_element([5, 5, 5, 5, 5]) in [0, 1, 2, 3, 4] def test_random_array(): assert find_peak_element([10, 20, 15, 2, 23, 90, 67]) in [1, 5]","solution":"def find_peak_element(arr): This function takes in a list of integers 'arr' and returns the index of any peak element. A peak element is one that is not smaller than its neighbors. n = len(arr) if n == 1: return 0 low, high = 0, n - 1 while low < high: mid = (low + high) // 2 if arr[mid] < arr[mid + 1]: low = mid + 1 else: high = mid return low"},{"question":"def max_sum_non_negative_subarray(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray of \`arr\` that does not contain any negative numbers. If all numbers in \`arr\` are negative, returns 0. >>> max_sum_non_negative_subarray([-1, -2, -3]) == 0 >>> max_sum_non_negative_subarray([1, 2, 3]) == 6 >>> max_sum_non_negative_subarray([1, -2, 3, 4, -1]) == 7 >>> max_sum_non_negative_subarray([-1, 2, 3, -4, 5, 6]) == 11 >>> max_sum_non_negative_subarray([5]) == 5 >>> max_sum_non_negative_subarray([-5]) == 0 >>> max_sum_non_negative_subarray([1, 2, -1, 2, 3, -5, 4, 5]) == 9","solution":"def max_sum_non_negative_subarray(arr): Returns the maximum sum of any contiguous subarray of \`arr\` that does not contain any negative numbers. If all numbers in \`arr\` are negative, returns 0. max_sum = 0 current_sum = 0 for num in arr: if num >= 0: current_sum += num else: max_sum = max(max_sum, current_sum) current_sum = 0 max_sum = max(max_sum, current_sum) # To catch the last subarray if it has the maximum sum return max_sum"},{"question":"def min_transformations_to_palindrome(s: str) -> int: Returns the minimum number of transformations needed to make the string s a palindrome. A transformation means changing one character to another. >>> min_transformations_to_palindrome(\\"racecar\\") == 0 >>> min_transformations_to_palindrome(\\"abcdef\\") == 3 >>> min_transformations_to_palindrome(\\"abca\\") == 1 >>> min_transformations_to_palindrome(\\"\\") == 0 >>> min_transformations_to_palindrome(\\"a\\") == 0 >>> min_transformations_to_palindrome(\\"z\\") == 0 >>> min_transformations_to_palindrome(\\"ab\\") == 1 >>> min_transformations_to_palindrome(\\"aa\\") == 0 >>> min_transformations_to_palindrome(\\"abba\\") == 0 >>> min_transformations_to_palindrome(\\"abcd\\") == 2 >>> min_transformations_to_palindrome(\\"abcba\\") == 0 >>> min_transformations_to_palindrome(\\"abbca\\") == 1 pass","solution":"def min_transformations_to_palindrome(s): Returns the minimum number of transformations needed to make the string s a palindrome. A transformation means changing one character to another. Arguments: s -- string to be transformed into a palindrome Returns: int -- minimum number of transformations required n = len(s) cnt = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: cnt += 1 return cnt"},{"question":"def longest_subarray_divisible_by_k(arr: List[int], k: int) -> int: Given an integer array arr and an integer k, return the length of the longest contiguous subarray such that the sum of the elements in the subarray is divisible by k. If no such subarray exists, return -1. >>> longest_subarray_divisible_by_k([4, 5, 7, 9, 12], 5) 4 >>> longest_subarray_divisible_by_k([1, 2, 3], 7) -1 >>> longest_subarray_divisible_by_k([5], 5) 1 >>> longest_subarray_divisible_by_k([5, 10, 15, 20], 5) 4 >>> longest_subarray_divisible_by_k([-1, 2, 9, -5, 8], 6) 3","solution":"def longest_subarray_divisible_by_k(arr, k): Returns the length of the longest contiguous subarray whose sum is divisible by k. If no such subarray exists, return -1. # Dictionary to store the first occurrence of a particular remainder remainder_dict = {0: -1} total_sum = 0 max_length = 0 for i, num in enumerate(arr): total_sum += num remainder = total_sum % k # We need to handle negative remainders if remainder < 0: remainder += k if remainder in remainder_dict: subarray_length = i - remainder_dict[remainder] max_length = max(max_length, subarray_length) else: remainder_dict[remainder] = i return max_length if max_length > 0 else -1"},{"question":"def longest_path(grid: List[List[int]]) -> int: Determine the longest path in the grid where bacteria spread from one cell to another according to the rule where bacteria can only spread to adjacent cells with smaller values. >>> longest_path([[5]]) 1 >>> longest_path([[1, 2, 3, 4, 5]]) 5 >>> longest_path([[1], [2], [3], [4], [5]]) 5 >>> longest_path([[5, 3, 6, 7, 1]]) 3 >>> longest_path([[8], [2], [10], [5], [1]]) 3 >>> longest_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) 4 >>> longest_path([ ... [7, 7, 7], ... [7, 7, 7], ... [7, 7, 7] ... ]) 1 >>> longest_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) 4 pass","solution":"def longest_path(grid): Function to find the longest path in the grid where bacteria spread from one cell to another according to the rule where bacteria can only spread to adjacent cells with smaller values. def dfs(x, y, memo): if memo[x][y] != -1: return memo[x][y] directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] < grid[x][y]: max_length = max(max_length, 1 + dfs(nx, ny, memo)) memo[x][y] = max_length return max_length if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) memo = [[-1 for _ in range(cols)] for _ in range(rows)] longest = 0 for i in range(rows): for j in range(cols): longest = max(longest, dfs(i, j, memo)) return longest"},{"question":"class DataStream: A class that helps in finding and managing the average of the last k elements in a stream of integers. Initialize the DataStream class with an integer k. def __init__(self, k: int): Initialize the DataStream with the given window size k. def addElement(self, value: int): Adds a new integer value to the data stream. def getAverage(self) -> float: Returns the average of the last k elements added to the stream. If fewer than k elements are present, return the average of all elements. # Unit Tests def test_add_element_and_get_average(): ds = DataStream(3) ds.addElement(1) assert ds.getAverage() == 1 ds.addElement(2) assert ds.getAverage() == 1.5 ds.addElement(3) assert ds.getAverage() == 2 ds.addElement(4) assert ds.getAverage() == 3 def test_get_average_with_fewer_elements_than_k(): ds = DataStream(5) ds.addElement(10) ds.addElement(20) assert ds.getAverage() == 15 ds.addElement(30) assert ds.getAverage() == 20 def test_get_average_with_large_k(): ds = DataStream(100) for i in range(1, 11): # Adding 1 to 10 ds.addElement(i) assert ds.getAverage() == 5.5 # Average of numbers 1 to 10 def test_get_average_when_k_equals_1(): ds = DataStream(1) ds.addElement(7) assert ds.getAverage() == 7 ds.addElement(9) assert ds.getAverage() == 9 ds.addElement(10) assert ds.getAverage() == 10","solution":"class DataStream: def __init__(self, k): Initialize the DataStream with the given window size k. self.k = k self.stream = [] def addElement(self, value): Adds a new integer value to the data stream. self.stream.append(value) def getAverage(self): Returns the average of the last k elements added to the stream. If fewer than k elements are present, return the average of all elements. if len(self.stream) <= self.k: return sum(self.stream) / len(self.stream) else: return sum(self.stream[-self.k:]) / self.k"},{"question":"def search_matrix(matrix: List[List[int]], target: int) -> bool: Returns True if target is found in the matrix, else False. >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 5) True >>> search_matrix([ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ], 20) False","solution":"def search_matrix(matrix, target): Returns True if target is found in the matrix, else False. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"from typing import List def can_attend_all_meetings(intervals: List[List[int]], n: int) -> bool: Determine if it is possible to attend all meetings without any overlap within the given n hours a day. Parameters: intervals (list of list of int): Intervals representing meeting times. n (int): Maximum hours available in one day. Returns: bool: True if it is possible to attend all meetings without any overlap within the given n hours a day, otherwise false. pass # Test cases def test_can_attend_all_meetings_no_overlaps(): assert can_attend_all_meetings([[1, 2], [3, 4], [5, 6]], 24) == True def test_can_attend_all_meetings_with_overlaps(): assert can_attend_all_meetings([[1, 3], [2, 4], [5, 6]], 24) == False def test_can_attend_all_meetings_single_meeting_too_long(): assert can_attend_all_meetings([[1, 10]], 8) == False def test_can_attend_all_meetings_boundary_case(): assert can_attend_all_meetings([[1, 8]], 8) == True def test_can_attend_all_meetings_large_multiple_meets(): assert can_attend_all_meetings([[1, 4], [5, 8], [9, 12], [13, 16]], 16) == True def test_can_attend_all_meetings_large_multiple_overlapping_meets(): assert can_attend_all_meetings([[1, 4], [3, 5], [6, 9], [10, 13]], 16) == False def test_can_attend_all_meetings_meetings_at_day_limits(): assert can_attend_all_meetings([[1, 8], [9, 16], [17, 24]], 8) == True def test_can_attend_all_meetings_meetings_exceeding_day_limits(): assert can_attend_all_meetings([[1, 8], [9, 17]], 8) == False","solution":"def can_attend_all_meetings(intervals, n): Determine if it is possible to attend all meetings without any overlap within the given n hours a day. Parameters: intervals (list of list of int): Intervals representing meeting times. n (int): Maximum hours available in one day. Returns: bool: True if it is possible to attend all meetings without any overlap within the given n hours a day, otherwise false. # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Check for overlaps for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: # Overlapping condition return False # Check if an interval exceeds the daily limit for start, end in intervals: if end - start + 1 > n: return False return True"},{"question":"def min_path_sum(grid): Given a 2D matrix \`grid\` where \`grid[i][j]\` represents the cost of stepping on the cell \`(i, j)\`, return the minimum cost to travel from the top-left corner \`(0, 0)\` to the bottom-right corner \`(m-1, n-1)\`. You can only move right or down at any point in time. If there is no path to the bottom-right corner, return \`-1\`. >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6]]) == 12 >>> min_path_sum([[1, 2], [1, 1]]) == 3 >>> min_path_sum([[1]]) == 1 >>> min_path_sum([[1, 2, 5], [3, 2, 1]]) == 6 >>> min_path_sum([[]]) == -1 # empty row >>> min_path_sum([]) == -1 # empty grid","solution":"def min_path_sum(grid): Finds the minimum path sum from top-left to bottom-right in a grid. if not grid or not grid[0]: return -1 # No possible path because grid is empty or malformed m, n = len(grid), len(grid[0]) # Initialize the top row for i in range(1, n): grid[0][i] += grid[0][i-1] # Initialize the left column for i in range(1, m): grid[i][0] += grid[i-1][0] # Fill in the rest of the grid for i in range(1, m): for j in range(1, n): grid[i][j] += min(grid[i-1][j], grid[i][j-1]) return grid[-1][-1]"},{"question":"def count_connected_buildings(grid: List[List[int]]) -> int: Determine the number of separate connected buildings in the grid. A cell with height 0 represents an empty lot. Two buildings are deemed connected if there exists a direct path consisting of cells either vertically or horizontally adjacent. >>> count_connected_buildings([[]]) == 0 >>> count_connected_buildings([[1]]) == 1 >>> count_connected_buildings([[0, 0], [0, 0]]) == 0 >>> count_connected_buildings([[1, 0], [0, 1]]) == 2 >>> count_connected_buildings([[1, 1], [1, 0]]) == 1 >>> count_connected_buildings([[1, 1, 0, 0], [0, 1, 0, 1], [0, 0, 1, 1], [1, 0, 0, 0]]) == 3","solution":"def count_connected_buildings(grid): Returns the number of separate connected buildings in the grid. Parameters: grid (List[List[int]]): A 2D list representing the grid where each element is a non-negative integer. Returns: int: The number of separate connected buildings in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] > 0: visited[nx][ny] = True stack.append((nx, ny)) count = 0 for i in range(m): for j in range(n): if grid[i][j] > 0 and not visited[i][j]: visited[i][j] = True count += 1 dfs(i, j) return count"},{"question":"def can_make_anagram_by_deleting_one_char(s1: str, s2: str) -> bool: Determine if \`s1\` can be made into an anagram of \`s2\` by deleting exactly one character. >>> can_make_anagram_by_deleting_one_char(\\"abc\\", \\"ab\\") True >>> can_make_anagram_by_deleting_one_char(\\"aabb\\", \\"ab\\") False >>> can_make_anagram_by_deleting_one_char(\\"aabcd\\", \\"abcd\\") True >>> can_make_anagram_by_deleting_one_char(\\"abcd\\", \\"abcd\\") False","solution":"def can_make_anagram_by_deleting_one_char(s1, s2): Determine if \`s1\` can be made into an anagram of \`s2\` by deleting exactly one character. from collections import Counter # Ensure the lengths are appropriate if len(s1) != len(s2) + 1: return False # Count frequency of each character in both strings counter_s1 = Counter(s1) counter_s2 = Counter(s2) # Compare character counts diff_count = 0 for char in counter_s1: if counter_s1[char] > counter_s2.get(char, 0): diff_count += counter_s1[char] - counter_s2.get(char, 0) # There should be exactly one extra character in s1 return diff_count == 1"},{"question":"def max_buildings(heights: List[int], k: int) -> int: Return the maximum number of buildings that can be visited starting from the first building and making at most k jumps. >>> max_buildings([1, 2, 3, 4], 2) 3 >>> max_buildings([4, 1, 2, 3], 0) 1 >>> max_buildings([5, 1, 2, 4, 3, 6], 2) 3 >>> max_buildings([1, 2, 3, 5, 4, 6], 10) 5 >>> max_buildings([3, 3, 3, 3], 2) 1 >>> max_buildings([4], 5) 1 >>> max_buildings([5, 4, 3, 2, 1], 3) 1","solution":"def max_buildings(heights, k): Returns the maximum number of buildings that can be visited starting from the first building and making at most k jumps. n = len(heights) dp = [1] * n for i in range(n): for j in range(i + 1, n): if heights[j] > heights[i]: dp[j] = max(dp[j], dp[i] + 1) if dp[j] > k + 1: # As we start counting from the first building break return min(max(dp), k + 1)"},{"question":"import heapq from typing import List, Tuple def shortest_distance(n: int, edges: List[Tuple[int, int, int]], start: int, end: int) -> int: Finds the shortest distance from start node to end node in a directed graph. :param n: Number of nodes in the graph :param edges: List of tuples (u, v, w) where u is the start node, v is the end node, and w is the weight of the edge :param start: Start node :param end: End node :return: Shortest distance from start to end or -1 if no path exists >>> shortest_distance(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1)], 1, 4) 4 >>> shortest_distance(4, [(1, 2, 1), (2, 3, 2)], 1, 4) -1 >>> shortest_distance(3, [(1, 2, 4), (2, 3, 1), (3, 1, 2), (1, 3, 5)], 1, 3) 5 >>> shortest_distance(2, [(1, 2, 2), (2, 2, 1)], 1, 2) 2 >>> shortest_distance(5, [(1, 2, 2), (1, 3, 5), (2, 3, 2), (2, 4, 6), (3, 4, 1), (4, 5, 1)], 1, 5) 6 pass def test_shortest_distance(): assert shortest_distance(4, [(1, 2, 1), (2, 3, 2), (3, 4, 1)], 1, 4) == 4 assert shortest_distance(4, [(1, 2, 1), (2, 3, 2)], 1, 4) == -1 assert shortest_distance(3, [(1, 2, 4), (2, 3, 1), (3, 1, 2), (1, 3, 5)], 1, 3) == 5 assert shortest_distance(2, [(1, 2, 2), (2, 2, 1)], 1, 2) == 2 assert shortest_distance(5, [(1, 2, 2), (1, 3, 5), (2, 3, 2), (2, 4, 6), (3, 4, 1), (4, 5, 1)], 1, 5) == 6","solution":"import heapq def shortest_distance(n, edges, start, end): Finds the shortest distance from start node to end node in a directed graph. :param n: Number of nodes :param edges: List of tuples (u, v, w) representing directed edges and their weights :param start: Start node :param end: End node :return: Shortest distance from start to end, or -1 if no path exists # Create adjacency list graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) # Use Dijkstra's algorithm to find the shortest path heap = [(0, start)] distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while heap: current_distance, current_node = heapq.heappop(heap) if current_node == end: return current_distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(heap, (distance, neighbor)) return -1 if distances[end] == float('inf') else distances[end]"},{"question":"def count_divisible_pairs(arr, m): Returns the number of distinct pairs (i, j) such that 0 <= i < j < arr.length and the sum of arr[i] and arr[j] is divisible by m. >>> count_divisible_pairs([1, 2, 3, 4, 5], 3) == 4 >>> count_divisible_pairs([5], 3) == 0 >>> count_divisible_pairs([1, 1, 1, 1, 1], 5) == 0 >>> count_divisible_pairs([3, 6, 9, 12], 3) == 6 >>> count_divisible_pairs([-3, 3, -6, 6], 3) == 6 >>> count_divisible_pairs([1, 2, 3, 4, 5], 10) == 0","solution":"def count_divisible_pairs(arr, m): Returns the number of distinct pairs (i, j) such that 0 <= i < j < arr.length and the sum of arr[i] and arr[j] is divisible by m. n = len(arr) count = 0 # Iterate over each pair (i, j) and check the sum divisibility for i in range(n): for j in range(i + 1, n): if (arr[i] + arr[j]) % m == 0: count += 1 return count"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head): Returns True if the linked list is a palindrome, False otherwise. :param head: ListNode - the head of the linked list :return: bool - True if the linked list is a palindrome, False otherwise def test_palindrome_even_length(): # Create linked list 1 -> 2 -> 2 -> 1 node4 = ListNode(1) node3 = ListNode(2, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert isPalindrome(node1) == True def test_palindrome_odd_length(): # Create linked list 1 -> 2 -> 3 -> 2 -> 1 node5 = ListNode(1) node4 = ListNode(2, node5) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert isPalindrome(node1) == True def test_not_palindrome(): # Create linked list 1 -> 2 -> 3 -> 4 -> 5 node5 = ListNode(5) node4 = ListNode(4, node5) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert isPalindrome(node1) == False def test_single_element(): # Create linked list 1 node1 = ListNode(1) assert isPalindrome(node1) == True def test_empty_list(): assert isPalindrome(None) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def isPalindrome(head): Returns True if the linked list is a palindrome, False otherwise. :param head: ListNode - the head of the linked list :return: bool - True if the linked list is a palindrome, False otherwise # Fast and slow pointers to reach the middle of the linked list slow, fast = head, head stack = [] # Push half of the linked list onto the stack while fast and fast.next: stack.append(slow.val) slow = slow.next fast = fast.next.next # If the length is odd, skip the middle element if fast: slow = slow.next # Compare the second half of the list with the values in the stack while slow: top = stack.pop() if top != slow.val: return False slow = slow.next return True"},{"question":"def count_distinct_characters(s: str, queries: List[Tuple[int, int]]) -> List[int]: Given a string \`s\` containing only lowercase English letters and a list of queries where each query specifies two indices \`start\` and \`end\`, return the count of distinct characters in the substring \`s[start:end+1]\` for each query. Args: s: str - Input string containing only lowercase English letters. queries: List[Tuple[int, int]] - List of queries where each query is a tuple (start, end). Returns: List[int] - List of counts of distinct characters for each query. Examples: >>> count_distinct_characters(\\"abcde\\", [(0, 0)]) [1] >>> count_distinct_characters(\\"abcde\\", [(0, 4)]) [5] >>> count_distinct_characters(\\"abcde\\", [(1, 3)]) [3] >>> count_distinct_characters(\\"abcde\\", [(2, 10)]) [3] >>> count_distinct_characters(\\"abcde\\", [(0, 1), (1, 2), (2, 4), (0, 4)]) [2, 2, 3, 5] >>> count_distinct_characters(\\"aaa\\", [(0, 2)]) [1] >>> count_distinct_characters(\\"abcde\\", [(3, 2)]) [0]","solution":"def count_distinct_characters(s, queries): Returns a list of counts of distinct characters in the specified substrings. Args: s: str - Input string containing only lowercase English letters. queries: List[Tuple[int, int]] - List of queries where each query is a tuple (start, end). Returns: List[int] - List of counts of distinct characters for each query. results = [] for start, end in queries: # Adjust end if it is out of bounds if end >= len(s): end = len(s) - 1 substring = s[start:end+1] distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"def can_attend_all_events(events): Determines if a person can attend all events without any overlap. :param events: List of tuples where each tuple contains (start, end) of an event :return: True if it's possible to attend all events without any overlap, False otherwise >>> can_attend_all_events([]) True >>> can_attend_all_events([(1, 2), (3, 4), (5, 6)]) True >>> can_attend_all_events([(1, 4), (2, 5), (6, 7)]) False >>> can_attend_all_events([(1, 2), (2, 3), (3, 4)]) True >>> can_attend_all_events([(1, 2), (2, 3), (1, 5)]) False >>> can_attend_all_events([(1, 3), (2, 4), (3, 5), (4, 6)]) False >>> can_attend_all_events([(1, 2), (2, 3), (1, 3), (3, 4)]) False","solution":"def can_attend_all_events(events): Determines if a person can attend all events without any overlap. :param events: List of tuples where each tuple contains (start, end) of an event :return: True if it's possible to attend all events without any overlap, False otherwise # Sort events based on their start time first, and end time if start times are the same events.sort(key=lambda x: (x[0], x[1])) # Check for any overlapping events for i in range(1, len(events)): if events[i][0] < events[i-1][1]: return False return True"},{"question":"def rotate_array(arr, k): Rotates the array \`arr\` to the right by \`k\` steps. If \`k\` is negative, rotates to the left by \`-k\` steps. Args: arr: List[int] - The array to be rotated. k: int - Steps to rotate the array. Returns: List[int] - The rotated array. >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([], 3) [] >>> rotate_array([1], 3) [1]","solution":"def rotate_array(arr, k): Rotates the array \`arr\` to the right by \`k\` steps. If \`k\` is negative, rotates to the left by \`-k\` steps. Args: arr: List[int] - The array to be rotated. k: int - Steps to rotate the array. Returns: List[int] - The rotated array. n = len(arr) if n == 0: return arr k = k % n # Handling cases where k is greater than the length of the array return arr[-k:] + arr[:-k]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists where each node contains a single digit. The digits are stored in reverse order, and the function returns their sum as a linked list. >>> def linked_list_to_list(node): ... result = [] ... while node: ... result.append(node.val) ... node = node.next ... return result >>> def list_to_linked_list(numbers): ... dummy_head = ListNode(0) ... current = dummy_head ... for num in numbers: ... current.next = ListNode(num) ... current = current.next ... return dummy_head.next >>> l1 = list_to_linked_list([2, 4, 3]) >>> l2 = list_to_linked_list([5, 6, 4]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [7, 0, 8] True >>> l1 = list_to_linked_list([1, 8]) >>> l2 = list_to_linked_list([0]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [1, 8] True >>> l1 = list_to_linked_list([9, 9, 9]) >>> l2 = list_to_linked_list([1]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [0, 0, 0, 1] True >>> l1 = list_to_linked_list([0]) >>> l2 = list_to_linked_list([0]) >>> result = add_two_numbers(l1, l2) >>> linked_list_to_list(result) == [0] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def add_two_numbers(l1, l2): Adds two numbers represented by linked lists where each node contains a single digit. The digits are stored in reverse order, and the function returns their sum as a linked list. dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy_head.next"},{"question":"def find_valid_words(sentence: str, valid_words: List[str]) -> List[str]: Returns a list of words in \`sentence\` which are valid permutations found in \`valid_words\`. >>> find_valid_words(\\"god dog cat\\", [\\"dog\\", \\"cat\\"]) [\\"god\\", \\"dog\\", \\"cat\\"] >>> find_valid_words(\\"fish bird\\", [\\"dog\\", \\"cat\\"]) [] >>> find_valid_words(\\"god bird tac\\", [\\"dog\\", \\"cat\\"]) [\\"god\\", \\"tac\\"] >>> find_valid_words(\\"god dog god\\", [\\"dog\\"]) [\\"god\\", \\"dog\\", \\"god\\"] >>> find_valid_words(\\"\\", [\\"dog\\", \\"cat\\"]) [] >>> find_valid_words(\\"god dog cat\\", []) [] >>> find_valid_words(\\"God Dog Cat\\", [\\"dog\\", \\"cat\\"]) [] >>> find_valid_words(\\"listen silent\\", [\\"enlist\\"]) [\\"listen\\", \\"silent\\"]","solution":"def is_permutation(word, valid_word): return sorted(word) == sorted(valid_word) def find_valid_words(sentence, valid_words): Returns a list of words in \`sentence\` which are valid permutations found in \`valid_words\`. words = sentence.split() result = [] for word in words: for valid_word in valid_words: if is_permutation(word, valid_word): result.append(word) break return result"},{"question":"from typing import List def is_valid_tree(n: int, edges: List[List[int]]) -> bool: Determines if the undirected graph with n nodes and edges forms a valid tree. >>> is_valid_tree(5, [[0, 1], [0, 2], [0, 3], [1, 4]]) == True >>> is_valid_tree(5, [[0, 1], [0, 2], [0, 3], [1, 4], [2, 4]]) == False >>> is_valid_tree(5, [[0, 1], [0, 2], [3, 4]]) == False >>> is_valid_tree(1, []) == True >>> is_valid_tree(2, [[0, 1]]) == True >>> is_valid_tree(0, []) == False","solution":"def is_valid_tree(n, edges): Determines if the undirected graph with n nodes and edges forms a valid tree. if n == 0: return False # For a graph to be a valid tree, it must have exactly n-1 edges if len(edges) != n - 1: return False # Create an adjacency list from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Perform BFS to check connectivity and acyclity visited = set() stack = [(0, -1)] # (current node, parent node) while stack: node, parent = stack.pop() if node in visited: return False # Cycle detected visited.add(node) for neighbor in graph[node]: if neighbor != parent: stack.append((neighbor, node)) return len(visited) == n # Check if all nodes are visited"},{"question":"def partition_string(s: str) -> List[int]: Partitions the given string \`s\` into as few parts as possible such that each substring contains at most one unique character. Each part must form a contiguous block of the original string. Returns a list with the lengths of each part. >>> partition_string(\\"aaabbbcccaaa\\") [3, 3, 3, 3] >>> partition_string(\\"aaa\\") [3] >>> partition_string(\\"ababab\\") [1, 1, 1, 1, 1, 1] >>> partition_string(\\"\\") [] >>> partition_string(\\"a\\") [1] >>> partition_string(\\"aabbcc\\") [2, 2, 2] >>> partition_string(\\"aaaabbaaaabb\\") [4, 2, 4, 2]","solution":"def partition_string(s): Partitions the given string \`s\` into as few parts as possible such that each substring contains at most one unique character. Returns a list with the lengths of each part. :param s: str, the input string containing only lowercase letters :return: List[int], lengths of each part in the partition if not s: return [] partitions = [] current_char = s[0] current_length = 1 for char in s[1:]: if char == current_char: current_length += 1 else: partitions.append(current_length) current_char = char current_length = 1 partitions.append(current_length) return partitions"},{"question":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Returns the sum of the largest subarray. >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1,2,3,4,5]) 15 >>> max_subarray_sum([-1,-2,-3,-4,-5]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) -5 >>> max_subarray_sum([3,-2,5,-1,4]) 9 >>> max_subarray_sum([-5,1,2,3,-1,2,1,4,-5]) 12","solution":"def max_subarray_sum(nums): Returns the sum of the largest subarray. # Initialize with the first element of the array max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def count_people_who_can_see(heights: List[int]) -> int: Find and return the number of people in the array that can see over both of their neighbors. >>> count_people_who_can_see([1]) 0 >>> count_people_who_can_see([1, 2]) 0 >>> count_people_who_can_see([1, 3, 2]) 1 >>> count_people_who_can_see([2, 1, 3, 1, 2]) 1 >>> count_people_who_can_see([1, 3, 2, 4, 2, 5, 3]) 3 >>> count_people_who_can_see([1, 2, 3, 4, 5]) 0 >>> count_people_who_can_see([5, 4, 3, 2, 1]) 0 >>> count_people_who_can_see([1, 2, 2, 2, 1]) 0 >>> count_people_who_can_see([1, 3, 1, 3, 1]) 2 pass","solution":"def count_people_who_can_see(heights): count = 0 n = len(heights) for i in range(1, n-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: count += 1 return count"},{"question":"def trap(heights: list[int]) -> int: Computes the maximum amount of water that can be trapped between buildings after it rains. :param heights: List[int], the heights of buildings. :return: int, the maximum amount of water that can be trapped. >>> trap([]) 0 >>> trap([3, 2, 1]) 0 >>> trap([1, 2, 3]) 0 >>> trap([0, 1, 0, 2]) 1 >>> trap([0, 2, 0, 3, 0, 1]) 3 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([4, 2, 0, 3, 2, 5]) 9 >>> trap([3, 3, 3, 3, 3]) 0 >>> trap([1, 1, 1, 1, 1, 1]) 0","solution":"def trap(heights): Computes the maximum amount of water that can be trapped between buildings after it rains. :param heights: List[int], the heights of buildings. :return: int, the maximum amount of water that can be trapped. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += max(0, min(left_max[i], right_max[i]) - heights[i]) return water_trapped"},{"question":"def subarrayProductSum(nums: List[int]) -> int: Calculate the sum of product sums of all non-empty subarrays of the array nums. >>> subarrayProductSum([2]) 2 >>> subarrayProductSum([-3]) -3 >>> subarrayProductSum([1, 2]) 5 >>> subarrayProductSum([-1, 3]) -1 >>> subarrayProductSum([1, 2, 3]) 23 >>> subarrayProductSum([2, 0, 1]) 3 >>> subarrayProductSum([-1, -2, -3]) -7 >>> subarrayProductSum([1, -2, 3, -4]) 79","solution":"def subarrayProductSum(nums): Calculate the sum of product sums of all non-empty subarrays of the array nums. n = len(nums) total_sum = 0 for start in range(n): product = 1 for end in range(start, n): product *= nums[end] total_sum += product return total_sum"},{"question":"def is_path_exist(grid: List[List[int]], start: List[int], end: List[int]) -> bool: Determines if there is a path from start to end in the given grid. :param grid: List[List[int]] - the grid representing the maze :param start: List[int] - starting position in the grid [x, y] :param end: List[int] - ending position in the grid [x, y] :return: bool - True if there is a path, False otherwise >>> is_path_exist([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0]], [0, 0], [2, 2]) True >>> is_path_exist([ ... [0, 1, 0], ... [0, 1, 0], ... [0, 1, 0]], [0, 0], [2, 2]) False >>> is_path_exist([ ... [0, 1], ... [1, 0]], [0, 0], [1, 1]) False >>> is_path_exist([ ... [0, 0, 1, 0, 0], ... [1, 0, 1, 0, 1], ... [0, 0, 0, 0, 0], ... [0, 1, 1, 1, 0], ... [0, 0, 0, 0, 0]], [0, 0], [4, 4]) True","solution":"def is_path_exist(grid, start, end): Determines if there is a path from start to end in the given grid. :param grid: List[List[int]] - the grid representing the maze :param start: List[int] - starting position in the grid \`[x, y]\` :param end: List[int] - ending position in the grid \`[x, y]\` :return: bool - True if there is a path, False otherwise rows, cols = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y, visited): return 0 <= x < rows and 0 <= y < cols and grid[x][y] == 0 and not visited[x][y] def dfs(x, y, visited): if [x, y] == end: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, visited) and dfs(nx, ny, visited): return True return False visited = [[False for _ in range(cols)] for _ in range(rows)] return dfs(start[0], start[1], visited)"},{"question":"from typing import List def findAllConcatenations(s: str, dict: List[str]) -> List[int]: A function to find all starting indices of substring(s) in \`s\` that is a concatenation of each word in \`dict\` exactly once and without any intervening characters. Args: s (str): The string to search within. dict (List[str]): A list of words to concatenate. Returns: List[int]: A list of starting indices of the concatenation substrings. Example: >>> findAllConcatenations(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> findAllConcatenations(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) [] pass from solution import findAllConcatenations def test_basic_case(): s = \\"barfoothefoobarman\\" dict = [\\"foo\\", \\"bar\\"] assert findAllConcatenations(s, dict) == [0, 9] def test_no_concatenations(): s = \\"wordgoodgoodgoodbestword\\" dict = [\\"word\\", \\"good\\", \\"best\\", \\"word\\"] assert findAllConcatenations(s, dict) == [] def test_multiple_concatenations(): s = \\"wordgoodgoodgoodbestword\\" dict = [\\"word\\", \\"good\\", \\"best\\", \\"good\\"] assert findAllConcatenations(s, dict) == [8] def test_single_word(): s = \\"abcdefg\\" dict = [\\"abc\\"] assert findAllConcatenations(s, dict) == [0] def test_non_existent_words(): s = \\"abcdefg\\" dict = [\\"xyz\\"] assert findAllConcatenations(s, dict) == [] def test_same_words_multiple_times(): s = \\"aaaabbbb\\" dict = [\\"aa\\", \\"aa\\", \\"bb\\", \\"bb\\"] assert findAllConcatenations(s, dict) == [0] def test_concatenation_at_end(): s = \\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\" dict = [\\"fooo\\",\\"barr\\",\\"wing\\",\\"ding\\",\\"wing\\"] assert findAllConcatenations(s, dict) == [13]","solution":"from collections import defaultdict def findAllConcatenations(s, dict): if not dict or not s: return [] word_len = len(dict[0]) num_words = len(dict) total_len = word_len * num_words word_count = defaultdict(int) for word in dict: word_count[word] += 1 def valid_substring(start): seen_words = defaultdict(int) words_used = 0 for i in range(start, start + total_len, word_len): current_word = s[i:i+word_len] if current_word in word_count: if seen_words[current_word] < word_count[current_word]: seen_words[current_word] += 1 words_used += 1 else: return False else: return False return words_used == num_words result_indices = [] for i in range(len(s) - total_len + 1): if valid_substring(i): result_indices.append(i) return result_indices"},{"question":"def max_coins(coins): Return the maximum value of coins the player can pick without breaking the adjacency rule. >>> max_coins([5]) 5 >>> max_coins([1, 2]) 2 >>> max_coins([5, 1, 2]) 7 >>> max_coins([2, 7, 9, 5, 1]) 12 >>> max_coins([1, 2, 3, 1]) 4 >>> max_coins([2, 3, 2]) 4 >>> max_coins([2, 4, 8, 9, 9, 3]) 19 >>> max_coins([]) 0","solution":"def max_coins(coins): n = len(coins) if n == 0: return 0 if n == 1: return coins[0] if n == 2: return max(coins) # Initialize dp array dp = [0] * n # base cases for dp array dp[0] = coins[0] dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i - 1], coins[i] + dp[i - 2]) return dp[-1]"},{"question":"def can_traverse(arr: List[int], queries: List[List[int]], k: int) -> List[bool]: Determines if a path exists between buildings in each query such that the difference in heights between adjacent buildings is at most k. Parameters: arr (list of int): Heights of buildings. queries (list of list of int): Each query represented as [start_index, end_index]. k (int): The maximum allowable height difference. Returns: list of bool: A list of boolean values indicating the result for each query. >>> can_traverse([1, 3, 5, 7], [[0, 2], [1, 3]], 2) [True, True] >>> can_traverse([1, 10, 20, 30], [[0, 3], [1, 2]], 5) [False, False] >>> can_traverse([5], [[0, 0]], 10) [True] >>> can_traverse([1, 2, 3], [], 1) [] >>> can_traverse([1, 2, 3, 4, 5], [[0, 4], [0, 1], [2, 3], [3, 4], [1, 3]], 1) [True, True, True, True, True] >>> can_traverse([1, 2, 3, 4, 5], [[4, 0], [3, 1]], 1) [True, True]","solution":"def can_traverse(arr, queries, k): Determines if a path exists between buildings in each query such that the difference in heights between adjacent buildings is at most k. Parameters: arr (list of int): Heights of buildings. queries (list of list of int): Each query represented as [start_index, end_index]. k (int): The maximum allowable height difference. Returns: list of bool: A list of boolean values indicating the result for each query. def is_path_possible(start, end): if start == end: return True direction = 1 if end > start else -1 for i in range(start, end, direction): if abs(arr[i] - arr[i + direction]) > k: return False return True results = [is_path_possible(start, end) for start, end in queries] return results"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorder the linked list in the specified pattern. def list_to_array(head): Helper function to convert linked list to array arr = [] curr = head while curr: arr.append(curr.val) curr = curr.next return arr def array_to_list(arr): Helper function to convert array to linked list if not arr: return None head = ListNode(arr[0]) curr = head for val in arr[1:]: curr.next = ListNode(val) curr = curr.next return head def test_reorderList_example(): head = array_to_list([1, 2, 3, 4, 5]) reorderList(head) assert list_to_array(head) == [1, 5, 2, 4, 3] def test_reorderList_empty(): head = array_to_list([]) reorderList(head) assert list_to_array(head) == [] def test_reorderList_single(): head = array_to_list([1]) reorderList(head) assert list_to_array(head) == [1] def test_reorderList_two_elements(): head = array_to_list([1, 2]) reorderList(head) assert list_to_array(head) == [1, 2] def test_reorderList_three_elements(): head = array_to_list([1, 2, 3]) reorderList(head) assert list_to_array(head) == [1, 3, 2]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reorderList(head): Reorder the linked list in the specified pattern. if not head or not head.next: return # Find the middle of the linked list with slow and fast pointers slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev, curr = None, slow while curr: next_temp = curr.next curr.next = prev prev = curr curr = next_temp # Merge two halves first, second = head, prev while second.next: temp1, temp2 = first.next, second.next first.next = second second.next = temp1 first = temp1 second = temp2"},{"question":"from typing import List def min_operations_to_unique(nums: List[int]) -> int: Find the minimum number of operations required to make all elements of the array unique. In one operation, you can pick an integer \`a\` from the array and replace it with any integer from \`1\` to \`a-1\`, inclusive. If it's impossible to make all elements unique, return \`-1\`. >>> min_operations_to_unique([1]) 0 >>> min_operations_to_unique([1, 2, 3]) 0 >>> min_operations_to_unique([2, 2, 2]) 3 >>> min_operations_to_unique([3, 2, 1, 2, 1, 7]) 6 >>> min_operations_to_unique([10, 20, 30, 40]) 0 >>> min_operations_to_unique([5, 5, 5, 5]) 6 >>> min_operations_to_unique([2, 3, 3, 2, 1]) 4","solution":"def min_operations_to_unique(nums): nums.sort() operations = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment = (nums[i - 1] + 1) - nums[i] operations += increment nums[i] = nums[i - 1] + 1 return operations"},{"question":"def min_difference(arr: List[int], x: int) -> int: Returns the minimum possible difference between the height of the tallest and shortest person among the selected x people. >>> min_difference([1, 3, 6, 7, 9], 3) # Test case 1 3 >>> min_difference([1, 5, 9], 2) # Test case 2 4 >>> min_difference([1, 2, 3], 3) # Test case 3 2 >>> min_difference([10, 13, 1, 5, 8, 12], 4) # Test case 4 5 >>> min_difference([5, 10, 14], 2) # Test case 5 4 >>> min_difference([], 1) # Test case 6 0 >>> min_difference([4, 9, 1], 0) # Test case 7 0 >>> min_difference([10, 20, 30], 1) # Test case 8 0","solution":"def min_difference(arr, x): Returns the minimum possible difference between the height of the tallest and shortest person among the selected x people. if x == 0 or not arr or len(arr) < x: return 0 arr.sort() # Sort the array to find the minimum difference efficiently min_diff = float('inf') # Initialize minimum difference to infinity # Iterate through array to find the minimum difference between # the highest and lowest in every x-sized subsequence for i in range(len(arr) - x + 1): min_diff = min(min_diff, arr[i + x - 1] - arr[i]) return min_diff"},{"question":"from typing import List def count_repeated_subarrays(arr: List[int], k: int) -> int: Returns the count of contiguous subarrays of length k that have at least one element that appears more than once. :param arr: List[int] - the input array of integers :param k: int - the length of the contiguous subarrays :return: int - the count of such subarrays pass def test_count_repeated_subarrays_no_repeats(): assert count_repeated_subarrays([1, 2, 3, 4, 5], 3) == 0 def test_count_repeated_subarrays_single_repeat(): assert count_repeated_subarrays([1, 2, 2, 4, 5], 3) == 2 def test_count_repeated_subarrays_multiple_repeats(): assert count_repeated_subarrays([1, 2, 2, 4, 2, 5], 3) == 3 def test_count_repeated_subarrays_all_repeats(): assert count_repeated_subarrays([2, 2, 2, 2, 2], 2) == 4 def test_count_repeated_subarrays_k_equals_n(): assert count_repeated_subarrays([1, 1, 2, 3, 4], 5) == 1","solution":"def count_repeated_subarrays(arr, k): Returns the count of contiguous subarrays of length k that have at least one element that appears more than once. :param arr: List[int] - the input array of integers :param k: int - the length of the contiguous subarrays :return: int - the count of such subarrays from collections import Counter n = len(arr) count = 0 for i in range(n - k + 1): subarray = arr[i:i+k] freq = Counter(subarray) if any(value > 1 for value in freq.values()): count += 1 return count"},{"question":"def canDivideEqualCoins(nums: List[int]) -> bool: Returns True if it's possible to divide the coins into two groups with equal sum, otherwise False. >>> canDivideEqualCoins([1, 5, 11, 5]) == True >>> canDivideEqualCoins([1, 2, 3, 5]) == False >>> canDivideEqualCoins([1]) == False >>> canDivideEqualCoins([]) == True >>> canDivideEqualCoins([3, 1, 4, 2, 2]) == True >>> canDivideEqualCoins([1, 1, 1]) == False","solution":"def canDivideEqualCoins(nums): Returns True if it's possible to divide the coins into two groups with equal sum, otherwise False. total_sum = sum(nums) # If total sum is odd, we can't divide it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset of nums[0..i-1] has a sum equal to \`target_sum\` dp = [False] * (target_sum + 1) dp[0] = True for coin in nums: for j in range(target_sum, coin - 1, -1): dp[j] = dp[j] or dp[j - coin] return dp[target_sum]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head: ListNode, k: int) -> ListNode: Reverse the nodes of a linked list \`head\` in groups of \`k\` and return its modified head. The function should reverse none if the remaining nodes are less than \`k\`. >>> lst = [1, 2, 3, 4, 5] >>> new_head = reverseKGroup(list_to_linked_list(lst), 3) >>> linked_list_to_list(new_head) [3, 2, 1, 4, 5] >>> lst = [1, 2, 3, 4, 5] >>> new_head = reverseKGroup(list_to_linked_list(lst), 2) >>> linked_list_to_list(new_head) [2, 1, 4, 3, 5] >>> lst = [1, 2, 3, 4, 5] >>> new_head = reverseKGroup(list_to_linked_list(lst), 1) >>> linked_list_to_list(new_head) [1, 2, 3, 4, 5] >>> lst = [1, 2, 3, 4, 5] >>> new_head = reverseKGroup(list_to_linked_list(lst), 6) >>> linked_list_to_list(new_head) [1, 2, 3, 4, 5] >>> lst = [] >>> new_head = reverseKGroup(list_to_linked_list(lst), 3) >>> linked_list_to_list(new_head) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverseKGroup(head, k): def reverse_linked_list(head, k): new_head = None ptr = head while k > 0: next_node = ptr.next ptr.next = new_head new_head = ptr ptr = next_node k -= 1 return new_head count = 0 ptr = head while count < k and ptr: ptr = ptr.next count += 1 if count == k: reversed_head = reverse_linked_list(head, k) head.next = reverseKGroup(ptr, k) return reversed_head return head"},{"question":"def min_sum_path(matrix): Returns the minimum sum path to reach the bottom-right corner of the matrix starting from the top-left corner. You can only move either down or right at any point in time. >>> min_sum_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_sum_path([[5]]) == 5 >>> min_sum_path([ ... [1, 2, 3, 4] ... ]) == 10 >>> min_sum_path([ ... [1], ... [2], ... [3], ... [4] ... ]) == 10 >>> min_sum_path([]) == 0 >>> min_sum_path([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 21","solution":"def min_sum_path(matrix): Returns the minimum sum path to reach the bottom-right corner of the matrix starting from the top-left corner. You can only move either down or right at any point in time. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) # Create a 2D dp array with the same dimensions as the matrix dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of dp array for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[m-1][n-1]"},{"question":"def can_construct_target(nums: List[int], target: int) -> bool: Determines if the target can be constructed using a subset of elements in nums. >>> can_construct_target([2, 3, 7, 8, 10], 11) True >>> can_construct_target([1, 2, 3, 4, 5], 15) True >>> can_construct_target([1, 2, 3, 8], 6) True >>> can_construct_target([1, 2, 3, 4, 5], 20) False >>> can_construct_target([10, 20, 30, 40], 60) True >>> can_construct_target([1, 2], 4) False >>> can_construct_target([], 0) True >>> can_construct_target([], 5) False","solution":"def can_construct_target(nums, target): Determines if the target can be constructed using a subset of elements in nums. Args: nums (list): List of integers. target (int): Target integer to construct using a subset of nums. Returns: bool: True if target can be constructed, otherwise false. def can_construct(index, current_sum): if current_sum == target: return True if current_sum > target or index == len(nums): return False # Choose the number at index include_num = can_construct(index + 1, current_sum + nums[index]) # Do not choose the number at index exclude_num = can_construct(index + 1, current_sum) return include_num or exclude_num return can_construct(0, 0)"},{"question":"def num_decodings(s: str) -> int: Return the total number of ways to decode the string s. >>> num_decodings(\\"1\\") == 1 >>> num_decodings(\\"9\\") == 1 >>> num_decodings(\\"12\\") == 2 >>> num_decodings(\\"26\\") == 2 >>> num_decodings(\\"27\\") == 1 >>> num_decodings(\\"123\\") == 3 >>> num_decodings(\\"226\\") == 3 >>> num_decodings(\\"06\\") == 0 >>> num_decodings(\\"1111111111\\") == 89 >>> num_decodings(\\"\\") == 0 >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"10\\") == 1 >>> num_decodings(\\"101\\") == 1 >>> num_decodings(\\"230\\") == 0","solution":"def num_decodings(s): Return the total number of ways to decode the string s. if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i != 1 and s[i - 2] != '0' and 10 <= int(s[i - 2:i]) <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"def can_form_palindrome(words: List[str]) -> bool: Returns True if any subset of two words can form a palindrome upon concatenation. >>> can_form_palindrome([\\"ab\\", \\"ba\\"]) == True >>> can_form_palindrome([\\"abc\\", \\"def\\"]) == False >>> can_form_palindrome([\\"abc\\", \\"cba\\"]) == True >>> can_form_palindrome([\\"xyz\\", \\"zyx\\", \\"abc\\"]) == True >>> can_form_palindrome([\\"abcd\\", \\"efgh\\"]) == False >>> can_form_palindrome([]) == False >>> can_form_palindrome([\\"abc\\"]) == False >>> can_form_palindrome([\\"aa\\", \\"a\\"]) == True >>> can_form_palindrome([\\"a\\", \\"a\\"]) == True >>> can_form_palindrome([\\"aba\\", \\"ba\\"]) == True >>> can_form_palindrome([\\"ab\\", \\"abab\\", \\"cba\\"]) == True >>> can_form_palindrome([\\"ab\\", \\"cad\\", \\"d\\"]) == False >>> can_form_palindrome([\\"race\\", \\"car\\", \\"ecar\\"]) == True","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def can_form_palindrome(words): Returns True if any subset of two words can form a palindrome upon concatenation. for i in range(len(words)): for j in range(i + 1, len(words)): if is_palindrome(words[i] + words[j]) or is_palindrome(words[j] + words[i]): return True return False"},{"question":"from typing import List def find_palindromic_substrings(s: str) -> List[str]: Given a string \`s\` consisting of lowercase letters, find all possible palindromic substrings in \`s\`. :param s: The input string consisting of lowercase letters. :return: A list containing all unique palindromic substrings. >>> set(find_palindromic_substrings(\\"a\\")) == {\\"a\\"} True >>> set(find_palindromic_substrings(\\"abc\\")) == {\\"a\\", \\"b\\", \\"c\\"} True >>> set(find_palindromic_substrings(\\"aaa\\")) == {\\"a\\", \\"aa\\", \\"aaa\\"} True >>> set(find_palindromic_substrings(\\"ababa\\")) == {\\"a\\", \\"b\\", \\"aba\\", \\"bab\\", \\"ababa\\"} True >>> set(find_palindromic_substrings(\\"abcd\\")) == {\\"a\\", \\"b\\", \\"c\\", \\"d\\"} True # Your code here","solution":"def find_palindromic_substrings(s): Returns all unique palindromic substrings in the given string. :param s: The input string consisting of lowercase letters. :return: A list containing all unique palindromic substrings. def is_palindrome(sub): return sub == sub[::-1] unique_palindromes = set() for i in range(len(s)): for j in range(i+1, len(s)+1): substring = s[i:j] if is_palindrome(substring): unique_palindromes.add(substring) return list(unique_palindromes)"},{"question":"from typing import List def min_modifications_to_strictly_increasing(arr: List[int]) -> int: Returns the minimum number of modifications needed to make the array strictly increasing with at most one modification. If it's not possible with one modification, returns -1. >>> min_modifications_to_strictly_increasing([1, 2, 3, 4, 5]) 0 >>> min_modifications_to_strictly_increasing([1, 2, 3, 2, 5]) 1 >>> min_modifications_to_strictly_increasing([1, 2, 5, 3, 4]) 1 >>> min_modifications_to_strictly_increasing([10, 1, 2, 3, 4]) 1 >>> min_modifications_to_strictly_increasing([1, 3, 2, 4, 5]) 1 >>> min_modifications_to_strictly_increasing([5, 4, 3, 2, 1]) -1 >>> min_modifications_to_strictly_increasing([1, 3, 2, 4, 3]) -1 >>> min_modifications_to_strictly_increasing([2, 2, 2, 2, 2]) -1","solution":"def min_modifications_to_strictly_increasing(arr): Returns the minimum number of modifications needed to make the array strictly increasing with at most one modification. If it's not possible with one modification, returns -1. n = len(arr) if n <= 1: return 0 decreasing_errors = [] for i in range(n - 1): if arr[i] >= arr[i + 1]: decreasing_errors.append(i + 1) if len(decreasing_errors) == 0: return 0 elif len(decreasing_errors) > 1: return -1 index = decreasing_errors[0] if index == 1 or arr[index] > arr[index - 2]: return 1 if index == n - 1 or arr[index - 1] < arr[index + 1]: return 1 return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestSubtreeSum(root): Return the largest subtree sum in the given binary tree. :param root: TreeNode :return: int from solution import TreeNode, largestSubtreeSum def test_single_node(): root = TreeNode(5) assert largestSubtreeSum(root) == 5 def test_all_positive_values(): root = TreeNode(1, left=TreeNode(2), right=TreeNode(3)) assert largestSubtreeSum(root) == 6 # The entire tree def test_includes_negative_values(): root = TreeNode(1, left=TreeNode(-2), right=TreeNode(3)) assert largestSubtreeSum(root) == 3 # Subtree with root 3 def test_large_tree(): root = TreeNode(1, left=TreeNode(2, left=TreeNode(4), right=TreeNode(5)), right=TreeNode(3, left=TreeNode(6), right=TreeNode(7))) assert largestSubtreeSum(root) == 28 # The entire tree def test_tree_with_only_negative_values(): root = TreeNode(-10, left=TreeNode(-2, left=TreeNode(-1), right=TreeNode(-3)), right=TreeNode(-5)) assert largestSubtreeSum(root) == -1 # Subtree with root -1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestSubtreeSum(root): Return the largest subtree sum in the given binary tree. :param root: TreeNode :return: int def dfs(node): if not node: return 0 # Calculate left and right subtree sums recursively left_sum = dfs(node.left) right_sum = dfs(node.right) # Calculate the sum of the current subtree current_subtree_sum = node.val + left_sum + right_sum # Update the largest sum found so far nonlocal largest_sum largest_sum = max(largest_sum, current_subtree_sum) return current_subtree_sum largest_sum = float(\\"-inf\\") dfs(root) return largest_sum"},{"question":"class MovieRating: Implement a Movie Rating System that allows users to rate movies and retrieve average ratings. Methods ------- addMovie(movieId: int): Adds a movie with the ID \`movieId\` to the system. rateMovie(userId: int, movieId: int, rating: int): Allows a user with the ID \`userId\` to rate a movie with the ID \`movieId\` with a rating value from \`1\` to \`5\`. getAverageRating(movieId: int) -> float: Returns the average rating of the movie with the ID \`movieId\`. If the movie has not been rated yet, return \`0.0\`. getUserRating(userId: int, movieId: int) -> int: Returns the rating given by the user with the ID \`userId\` for the movie with the ID \`movieId\`. If the user has not rated the movie yet, return \`-1\`. >>> m = MovieRating() >>> m.addMovie(101) >>> m.rateMovie(1, 101, 5) >>> m.rateMovie(2, 101, 4) >>> m.getAverageRating(101) 4.5 >>> m.getUserRating(1, 101) 5 >>> m.getUserRating(2, 101) 4 >>> m.getUserRating(3, 101) -1 >>> m.getAverageRating(102) 0.0","solution":"class MovieRating: def __init__(self): self.movies = {} self.user_ratings = {} def addMovie(self, movieId): if movieId not in self.movies: self.movies[movieId] = [] def rateMovie(self, userId, movieId, rating): if movieId in self.movies and 1 <= rating <= 5: self.movies[movieId].append(rating) if userId not in self.user_ratings: self.user_ratings[userId] = {} self.user_ratings[userId][movieId] = rating def getAverageRating(self, movieId): if movieId in self.movies and self.movies[movieId]: return sum(self.movies[movieId]) / len(self.movies[movieId]) return 0.0 def getUserRating(self, userId, movieId): if userId in self.user_ratings and movieId in self.user_ratings[userId]: return self.user_ratings[userId][movieId] return -1"},{"question":"def distinct_elements_in_subarrays(nums: List[int], k: int) -> List[int]: Given an integer array \`nums\` and an integer \`k\`, find the number of distinct elements in each subarray of length \`k\`. Return an array \`result\` where \`result[i]\` is the number of distinct elements in the subarray starting from position \`i\` and ending at position \`i + k - 1\`. >>> distinct_elements_in_subarrays([1, 2, 3, 4], 2) [2, 2, 2] >>> distinct_elements_in_subarrays([1, 2, 1, 3, 4], 3) [2, 3, 3]","solution":"def distinct_elements_in_subarrays(nums, k): Returns an array where each element represents the number of distinct elements in each subarray of length k in the input list nums. if k > len(nums): return [] result = [] for i in range(len(nums) - k + 1): distinct_count = len(set(nums[i:i + k])) result.append(distinct_count) return result"},{"question":"def longest_valid_parentheses(sequence: str) -> int: Returns the length of the longest valid parentheses substring. >>> longest_valid_parentheses(\\"\\") == 0 >>> longest_valid_parentheses(\\"((((\\") == 0 >>> longest_valid_parentheses(\\"))))\\") == 0 >>> longest_valid_parentheses(\\"()()(()\\") == 4 >>> longest_valid_parentheses(\\"()\\") == 2 >>> longest_valid_parentheses(\\"(()\\") == 2 >>> longest_valid_parentheses(\\")()())\\") == 4 >>> longest_valid_parentheses(\\"()((())\\") == 4 >>> longest_valid_parentheses(\\"(())()\\") == 6 >>> longest_valid_parentheses(\\"(()())\\") == 6 >>> longest_valid_parentheses(\\"(()))())(\\") == 4 >>> longest_valid_parentheses(\\"(()((()(())\\") == 6 >>> longest_valid_parentheses(\\"()(()))())(()())\\") == 6 >>> longest_valid_parentheses(\\"((())()())()\\") == 12","solution":"def longest_valid_parentheses(sequence): Returns the length of the longest valid parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(sequence): if char == '(': stack.append(i) else: stack.pop() if not stack: stack.append(i) else: max_length = max(max_length, i - stack[-1]) return max_length"},{"question":"def count_reversible_words(words: List[str]) -> int: Returns the count of reversible words in the list. A word w is called a \\"reversible word\\" if reversing the order of characters in w gives another word which is present in the list. pass from typing import List def test_count_reversible_words_single_pair(): assert count_reversible_words(['abc', 'cba']) == 1 def test_count_reversible_words_no_reversible_words(): assert count_reversible_words(['abc', 'def', 'ghi']) == 0 def test_count_reversible_words_multiple_pairs(): assert count_reversible_words(['abc', 'cba', 'ghi', 'ihg']) == 2 def test_count_reversible_words_duplicate_words(): assert count_reversible_words(['abc', 'abc', 'cba', 'cba']) == 1 def test_count_reversible_words_palindrome(): assert count_reversible_words(['abc', 'cba', 'madam']) == 1 def test_count_reversible_words_mixed(): assert count_reversible_words(['abc', 'def', 'cba', 'fed', 'ghi']) == 2","solution":"def count_reversible_words(words): Returns the count of reversible words in the list. A word w is called a \\"reversible word\\" if reversing the order of characters in w gives another word which is present in the list. word_set = set(words) reversible_count = 0 seen_words = set() for word in words: if word not in seen_words: # Ensure each word is counted only once reversed_word = word[::-1] if reversed_word in word_set and reversed_word != word: reversible_count += 1 seen_words.add(reversed_word) seen_words.add(word) return reversible_count"},{"question":"from typing import List def smallest_missing_positive(arr: List[int]) -> int: Returns the smallest positive integer that does not appear in the array \`arr\`. >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([-5, -9, -1]) 1 >>> smallest_missing_positive([1, 2, 3]) 4 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([1]) 2 >>> smallest_missing_positive([-1]) 1 >>> smallest_missing_positive([999, 1000, 1001]) 1 >>> smallest_missing_positive([7, 8, 9, 11, 12, -1, 1]) 2","solution":"def smallest_missing_positive(arr): Returns the smallest positive integer that does not appear in the array \`arr\`. nums_set = set(arr) smallest_missing = 1 while smallest_missing in nums_set: smallest_missing += 1 return smallest_missing"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def has_prime_sum_subarray(arr: List[int]) -> bool: Determines whether there exists a subarray in arr whose sum is prime. >>> has_prime_sum_subarray([1, 2, 4, 3]) True >>> has_prime_sum_subarray([4, 6, 8]) False","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def has_prime_sum_subarray(arr): Determines whether there exists a subarray in arr whose sum is prime. n = len(arr) # Generate all subarrays for start in range(n): subarray_sum = 0 for end in range(start, n): subarray_sum += arr[end] if is_prime(subarray_sum): return True return False"},{"question":"def topological_sort(graph: dict) -> list: Returns one of the topological orderings of a directed acyclic graph. Parameters: graph (dict): A dictionary where keys are node integers and values are lists of integers representing directed edges. Returns: list: A list of integers representing one of the topological orderings of the graph. pass # Your implementation here # Example usage: # graph = {0: [1], 1: [2], 2: []} # print(topological_sort(graph)) # Output: [0, 1, 2] # Unit Tests def test_topological_sort_simple(): graph = {0: [1], 1: [2], 2: []} ordering = topological_sort(graph) assert ordering == [0, 1, 2], f\\"Expected [0, 1, 2], but got {ordering}\\" def test_topological_sort_disconnected(): graph = {0: [1], 1: [], 2: [3], 3: []} ordering = topological_sort(graph) assert set(ordering) == {0, 1, 2, 3}, f\\"Expected some topological order with set {0, 1, 2, 3}, but got {ordering}\\" def test_topological_sort_single_node(): graph = {0: []} ordering = topological_sort(graph) assert ordering == [0], f\\"Expected [0], but got {ordering}\\" def test_topological_sort_complex(): graph = {5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: []} ordering = topological_sort(graph) assert set(ordering) == {5, 4, 3, 2, 1, 0}, f\\"Expected some topological order with set {5, 4, 3, 2, 1, 0}, but got {ordering}\\" # Ensure precedence rules in topological order for node in graph: for neighbor in graph[node]: assert ordering.index(node) < ordering.index(neighbor), f\\"Node {node} should come before its neighbor {neighbor}.\\" def test_topological_sort_multiple_sources(): graph = {0: [1], 2: [3], 1: [3], 3: []} ordering = topological_sort(graph) assert set(ordering) == {0, 1, 2, 3}, f\\"Expected some topological order with set {0, 1, 2, 3}, but got {ordering}\\" # Ensure precedence rules in topological order for node in graph: for neighbor in graph[node]: assert ordering.index(node) < ordering.index(neighbor), f\\"Node {node} should come before its neighbor {neighbor}.\\"","solution":"def topological_sort(graph): Returns one of the topological orderings of a directed acyclic graph. Parameters: graph (dict): A dictionary where keys are node integers and values are lists of integers representing directed edges. Returns: list: A list of integers representing one of the topological orderings of the graph. def dfs(node): nonlocal graph, visited, stack visited.add(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) stack.append(node) visited = set() stack = [] # Call DFS from all nodes to cover disconnected parts of the graph for node in graph: if node not in visited: dfs(node) return stack[::-1] # return the stack reversed as the topological order"},{"question":"def shortest_substring_with_n_distinct_chars(s: str, n: int) -> int: Find the length of the shortest substring of \`s\` that contains at least \`n\` distinct characters. If no such substring exists, return \`-1\`. >>> shortest_substring_with_n_distinct_chars(\\"abcabcabc\\", 3) 3 >>> shortest_substring_with_n_distinct_chars(\\"aabbcc\\", 4) -1 >>> shortest_substring_with_n_distinct_chars(\\"abcd\\", 4) 4 >>> shortest_substring_with_n_distinct_chars(\\"aabbaabb\\", 2) 2 >>> shortest_substring_with_n_distinct_chars(\\"aabbbc\\", 3) 5","solution":"def shortest_substring_with_n_distinct_chars(s, n): This function finds the length of the shortest substring of \`s\` that contains at least \`n\` distinct characters. If no such substring exists, it returns \`-1\`. if n > len(set(s)): return -1 start = 0 min_length = float('inf') char_count = {} for end in range(len(s)): if s[end] in char_count: char_count[s[end]] += 1 else: char_count[s[end]] = 1 while len(char_count) >= n: min_length = min(min_length, end - start + 1) char_count[s[start]] -= 1 if char_count[s[start]] == 0: del char_count[s[start]] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Returns true if s can be segmented into a space-separated sequence of one or more dictionary words from wordDict. >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == True >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == False >>> word_break(\\"catsanddog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == True >>> word_break(\\"aaaaaaa\\", [\\"aaaa\\",\\"aa\\"]) == False >>> word_break(\\"\\", [\\"anything\\"]) == True >>> word_break(\\"bb\\", [\\"a\\",\\"b\\",\\"bbb\\",\\"bbbb\\"]) == True >>> word_break(\\"cars\\", [\\"car\\",\\"ca\\",\\"rs\\"]) == True","solution":"def word_break(s, wordDict): Returns true if s can be segmented into a space-separated sequence of one or more dictionary words from wordDict. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can be segmented. for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def search_matrix(matrix, target): Searches for a target value in a matrix. Returns the position of the target as [row_index, column_index]. If the target does not exist, returns [-1, -1]. :param matrix: List[List[int]] - A list of lists of integers representing the matrix. :param target: int - The target integer to search for in the matrix. :return: List[int] - A list of two integers representing the position of the target. # Implement the function here # Test cases def test_search_matrix_target_present(): matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] target = 9 assert search_matrix(matrix, target) == [1, 1] def test_search_matrix_target_absent(): matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] target = 10 assert search_matrix(matrix, target) == [-1, -1] def test_search_matrix_target_first_element(): matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] target = 1 assert search_matrix(matrix, target) == [0, 0] def test_search_matrix_target_last_element(): matrix = [ [1, 3, 5], [7, 9, 11], [13, 15, 17] ] target = 17 assert search_matrix(matrix, target) == [2, 2] def test_search_matrix_empty_matrix(): matrix = [] target = 1 assert search_matrix(matrix, target) == [-1, -1] def test_search_matrix_single_row(): matrix = [[1, 2, 3, 4, 5]] target = 3 assert search_matrix(matrix, target) == [0, 2] def test_search_matrix_single_column(): matrix = [ [1], [2], [3], [4], [5] ] target = 4 assert search_matrix(matrix, target) == [3, 0]","solution":"def search_matrix(matrix, target): Searches for a target value in a matrix. Returns the position of the target as [row_index, column_index]. If the target does not exist, returns [-1, -1]. :param matrix: List[List[int]] - A list of lists of integers representing the matrix. :param target: int - The target integer to search for in the matrix. :return: List[int] - A list of two integers representing the position of the target. if not matrix or not matrix[0]: return [-1, -1] rows = len(matrix) cols = len(matrix[0]) left, right = 0, (rows * cols) - 1 while left <= right: mid = left + (right - left) // 2 mid_value = matrix[mid // cols][mid % cols] if mid_value == target: return [mid // cols, mid % cols] elif mid_value < target: left = mid + 1 else: right = mid - 1 return [-1, -1]"},{"question":"def is_balanced(s: str) -> bool: Determines if the given string is balanced. A string is balanced if every letter appears in it exactly the same number of times. Args: s (str): Input string containing only lowercase letters Returns: bool: True if the string is balanced, false otherwise","solution":"def is_balanced(s: str) -> bool: Determines if the given string is balanced. A string is balanced if every letter appears in it exactly the same number of times. Args: s (str): Input string containing only lowercase letters Returns: bool: True if the string is balanced, false otherwise from collections import Counter if not s: return True # An empty string is considered balanced counter = Counter(s) frequencies = list(counter.values()) return len(set(frequencies)) == 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: Returns the sum of values of all nodes with a value in the range [low, high]. pass # Unit Tests def test_rangeSumBST_all_within_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert rangeSumBST(root, 7, 15) == 32 # nodes with values 7, 10, 15 def test_rangeSumBST_some_within_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert rangeSumBST(root, 5, 10) == 22 # nodes with values 5, 7, 10 def test_rangeSumBST_single_value_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert rangeSumBST(root, 10, 10) == 10 # node with value 10 def test_rangeSumBST_no_values_in_range(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert rangeSumBST(root, 20, 25) == 0 # no nodes within range def test_rangeSumBST_empty_tree(): assert rangeSumBST(None, 0, 0) == 0 # empty tree def test_rangeSumBST_entire_tree(): root = TreeNode(10, TreeNode(5, TreeNode(3), TreeNode(7)), TreeNode(15, None, TreeNode(18))) assert rangeSumBST(root, 3, 18) == 58 # sum all nodes","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def rangeSumBST(root: TreeNode, low: int, high: int) -> int: Returns the sum of values of all nodes with a value in the range [low, high]. if root is None: return 0 total_sum = 0 if low <= root.val <= high: total_sum += root.val if low < root.val: total_sum += rangeSumBST(root.left, low, high) if root.val < high: total_sum += rangeSumBST(root.right, low, high) return total_sum"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array in place and returns the new combined list. >>> merge_sorted_arrays([], []) == [] >>> merge_sorted_arrays([1, 3, 5], []) == [1, 3, 5] >>> merge_sorted_arrays([], [2, 4, 6]) == [2, 4, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([2, 4, 6], [1, 3, 5]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 4], [2, 3, 5, 6]) == [1, 2, 3, 4, 5, 6] >>> merge_sorted_arrays([1, 3, 5], [2, 4]) == [1, 2, 3, 4, 5] >>> merge_sorted_arrays([1, 2, 3], [7, 8, 9]) == [1, 2, 3, 7, 8, 9] >>> merge_sorted_arrays([1, 2, 6], [3, 4, 5]) == [1, 2, 3, 4, 5, 6]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into a single sorted array in place and returns the new combined list. Parameters: arr1 (list of int): First sorted array arr2 (list of int): Second sorted array Returns: list of int: The merged and sorted array m, n = len(arr1), len(arr2) i, j = m - 1, 0 # First loop to adjust elements as per rules to ignore extra space while i >= 0 and j < n: if arr1[i] > arr2[j]: arr1[i], arr2[j] = arr2[j], arr1[i] i -= 1 j += 1 # Sort both arrays again since we may have disrupted order arr1.sort() arr2.sort() # Combine both arrays return arr1 + arr2"},{"question":"def duplicate_zeros(arr: List[int]) -> None: Duplicates each occurrence of zero in the list, shifting the remaining elements to the right. The list length remains unchanged. >>> arr = [1, 2, 3] >>> duplicate_zeros(arr) >>> arr [1, 2, 3] >>> arr = [1, 0, 3] >>> duplicate_zeros(arr) >>> arr [1, 0, 0] >>> arr = [1, 0, 2, 0, 3] >>> duplicate_zeros(arr) >>> arr [1, 0, 0, 2, 0] >>> arr = [1, 2, 0] >>> duplicate_zeros(arr) >>> arr [1, 2, 0] >>> arr = [0, 0, 0] >>> duplicate_zeros(arr) >>> arr [0, 0, 0] >>> arr = [8, 4, 5, 0, 0, 0, 7] >>> duplicate_zeros(arr) >>> arr [8, 4, 5, 0, 0, 0, 0]","solution":"def duplicate_zeros(arr): Duplicates each occurrence of zero in the list, shifting the remaining elements to the right. The list length remains unchanged. :param arr: List of integers to modify in place. n = len(arr) i = 0 while i < n: if arr[i] == 0: arr.insert(i + 1, 0) arr.pop() # To maintain the same length i += 1 # skip the next zero i += 1"},{"question":"def can_complete_all_tasks(tasks: List[List[int]]) -> bool: Determine if a single person can complete all tasks without overlapping. Return true if it is possible, otherwise return false. >>> can_complete_all_tasks([[1, 2], [3, 4], [5, 6]]) == True >>> can_complete_all_tasks([[1, 3], [2, 4], [5, 6]]) == False >>> can_complete_all_tasks([[1, 2]]) == True >>> can_complete_all_tasks([[1, 2], [2, 3], [3, 4]]) == True >>> can_complete_all_tasks([[1, 2], [1, 2], [1, 2]]) == False >>> can_complete_all_tasks([]) == True","solution":"def can_complete_all_tasks(tasks): Returns true if a single person can complete all tasks without overlapping, false otherwise. # First, sort the tasks based on their start times tasks.sort(key=lambda x: x[0]) # Iterate through the sorted tasks to check for any overlap for i in range(1, len(tasks)): # If the current task's start time is less than the previous task's end time, there is an overlap if tasks[i][0] < tasks[i-1][1]: return False return True"},{"question":"def shortest_subarray_with_sum_at_least_k(arr, k): Given an array of integers \`arr\`, return the length of the shortest continuous subarray such that the sum of its elements is at least a given integer \`k\`. If no such subarray exists, return \`-1\`. >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 11) == 3 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 15) == 5 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 1) == 1 >>> shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 20) == -1 >>> shortest_subarray_with_sum_at_least_k([-1, 4, 1, 2, 5], 7) == 2 >>> shortest_subarray_with_sum_at_least_k([10], 10) == 1 >>> shortest_subarray_with_sum_at_least_k([10], 15) == -1 >>> shortest_subarray_with_sum_at_least_k([5, 1, 3, 2, 8], 5) == 1 >>> shortest_subarray_with_sum_at_least_k([5, 1, 3, 2, 8], 20) == -1","solution":"from collections import deque def shortest_subarray_with_sum_at_least_k(arr, k): n = len(arr) prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + arr[i] result = float('inf') mono_queue = deque() for i in range(n + 1): while mono_queue and prefix_sums[i] - prefix_sums[mono_queue[0]] >= k: result = min(result, i - mono_queue.popleft()) while mono_queue and prefix_sums[i] <= prefix_sums[mono_queue[-1]]: mono_queue.pop() mono_queue.append(i) return result if result != float('inf') else -1"},{"question":"def count_special_rows(mat: List[List[int]], k: int) -> int: Returns the count of special rows in the matrix \`mat\` that contain exactly \`k\` distinct numbers. Args: mat: List of List of integers, representing the matrix. k: Integer, the number of distinct numbers that a row must have to be special. Returns: Integer: The number of special rows. >>> count_special_rows([[1, 2, 2, 3], [3, 3, 3, 4], [1, 2, 3, 4]], 3) 1 >>> count_special_rows([[1, 2, 2, 2], [3, 3, 3, 4], [1, 2, 3, 4]], 5) 0 >>> count_special_rows([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) 3 >>> count_special_rows([[1, 1, 1], [1, 2, 1], [1, 2, 3], [1, 2, 3, 3], [1, 2, 3, 4]], 3) 2 >>> count_special_rows([], 3) 0","solution":"def count_special_rows(mat, k): Returns the count of special rows in the matrix \`mat\` that contain exactly \`k\` distinct numbers. Args: mat: List of List of integers, representing the matrix. k: Integer, the number of distinct numbers that a row must have to be special. Returns: Integer: The number of special rows. count = 0 for row in mat: if len(set(row)) == k: count += 1 return count"},{"question":"def add_strings(num1: str, num2: str) -> str: Given two non-negative integers num1 and num2 represented as strings, return the sum of num1 and num2 as a string. You must solve the problem by performing the addition directly, without converting the inputs to integers. >>> add_strings(\\"123\\", \\"456\\") \\"579\\" >>> add_strings(\\"123\\", \\"7890\\") \\"8013\\"","solution":"def add_strings(num1, num2): Returns the sum of num1 and num2, which are non-negative integers represented as strings. # Ensure num1 is the longer string, swap if necessary. if len(num1) < len(num2): num1, num2 = num2, num1 # Reverse the strings to facilitate addition from the least significant digit. num1, num2 = num1[::-1], num2[::-1] carry, result = 0, [] # Iterate over digits, adding corresponding ones and the carry. for i in range(len(num1)): digit1 = int(num1[i]) digit2 = int(num2[i]) if i < len(num2) else 0 total = digit1 + digit2 + carry carry = total // 10 result.append(str(total % 10)) # If there's a carry left at the end, append it. if carry: result.append(str(carry)) # Reverse the result list to construct the final result string. return ''.join(result[::-1])"},{"question":"def findUnique(arr: List[int]) -> int: Returns the integer that appears exactly once in the array where every other integer appears exactly three times. >>> findUnique([2, 2, 3, 2]) 3 >>> findUnique([0, 1, 0, 1, 0, 1, 99]) 99 >>> findUnique([7]) 7","solution":"def findUnique(arr): Returns the integer that appears exactly once in the array where every other integer appears exactly three times. ones, twos = 0, 0 for num in arr: twos |= ones & num ones ^= num common_mask = ~(ones & twos) ones &= common_mask twos &= common_mask return ones"},{"question":"def min_resources(tasks: List[List[int]]) -> int: Determine the minimum number of resources required to complete all the tasks without any overlap in time for the same resource. >>> min_resources([[1, 2], [3, 4], [5, 6]]) 1 >>> min_resources([[1, 5], [2, 6], [3, 7]]) 3 >>> min_resources([[1, 4], [2, 5], [9, 12]]) 2 >>> min_resources([[1, 3], [3, 5], [5, 7]]) 1 >>> min_resources([[1, 4], [2, 6], [4, 7], [5, 8]]) 3","solution":"def min_resources(tasks): events = [] # Add start and end times to events list for start, end in tasks: events.append((start, 'start')) events.append((end, 'end')) # Sort the events list first by time, then by type (end before start if times are the same) events.sort(key=lambda x: (x[0], x[1] == 'start')) max_resources = 0 current_resources = 0 # Traverse the sorted events list to calculate the minimum resources needed for _, event in events: if event == 'start': current_resources += 1 max_resources = max(max_resources, current_resources) else: current_resources -= 1 return max_resources"},{"question":"def min_operations_to_avoid_consecutive_ones(s: str) -> int: Returns the minimum number of powerful operations needed to transform the binary string s into a string that contains no two consecutive '1's. >>> min_operations_to_avoid_consecutive_ones(\\"1110\\") == 1 >>> min_operations_to_avoid_consecutive_ones(\\"101010\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"111111\\") == 1 >>> min_operations_to_avoid_consecutive_ones(\\"01010101\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"0\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"1\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"11\\") == 1 >>> min_operations_to_avoid_consecutive_ones(\\"111\\") == 1 >>> min_operations_to_avoid_consecutive_ones(\\"101\\") == 0 >>> min_operations_to_avoid_consecutive_ones(\\"11011\\") == 2","solution":"def min_operations_to_avoid_consecutive_ones(s): Returns the minimum number of powerful operations needed to transform the binary string s into a string that contains no two consecutive '1's. n = len(s) cnt = 0 i = 0 while i < n: if s[i] == '1': j = i while j < n and s[j] == '1': j += 1 if j - i > 1: cnt += 1 i = j else: i += 1 return cnt"},{"question":"def longestUniqueSubarray(arr: List[int]) -> int: Given an array of integers \`arr\`, find the length of the longest subarray that contains unique elements. >>> longestUniqueSubarray([1, 2, 3, 4, 5]) == 5 >>> longestUniqueSubarray([4, 2, 4, 5, 6, 7, 4]) == 5 >>> longestUniqueSubarray([1, 2, 3, 1, 2, 3, 4, 5]) == 5 >>> longestUniqueSubarray([1]) == 1 >>> longestUniqueSubarray([]) == 0 >>> longestUniqueSubarray([1, 1, 1, 1, 1]) == 1 >>> longestUniqueSubarray(list(range(10000))) == 10000","solution":"def longestUniqueSubarray(arr): Returns the length of the longest subarray with unique elements. seen = {} left = 0 max_length = 0 for right in range(len(arr)): if arr[right] in seen: left = max(left, seen[arr[right]] + 1) seen[arr[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def can_transform_by_one_swap(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 by exactly one swap of any two characters. >>> can_transform_by_one_swap(\\"abcd\\", \\"abdc\\") True >>> can_transform_by_one_swap(\\"abcd\\", \\"abcd\\") False >>> can_transform_by_one_swap(\\"abcd\\", \\"abdd\\") False >>> can_transform_by_one_swap(\\"ab\\", \\"ba\\") True","solution":"def can_transform_by_one_swap(s1, s2): Determines if s1 can be transformed into s2 by exactly one swap of any two characters. if len(s1) != len(s2): return False # Find all positions where the characters are different diff = [] for i in range(len(s1)): if s1[i] != s2[i]: diff.append(i) # If there are exactly 2 positions where characters are different, # check if swapping them will make s1 equal to s2. if len(diff) == 2: i, j = diff s1 = list(s1) s1[i], s1[j] = s1[j], s1[i] if s1 == list(s2): return True return False"},{"question":"def word_break(s: str, wordDict: List[str]) -> List[str]: Given a string s and a dictionary of words wordDict, returns a list of all possible sentences that can be formed by concatenating words from the dictionary without reordering the characters in s. :param s: The input string. :param wordDict: The dictionary of words. :return: A list of sentences formed by concatenating words from the dictionary. pass from typing import List def test_word_break_basic(): s = \\"catsanddog\\" wordDict = [\\"cat\\", \\"cats\\", \\"and\\", \\"sand\\", \\"dog\\"] assert set(word_break(s, wordDict)) == set([\\"cat sand dog\\", \\"cats and dog\\"]) def test_word_break_single_word(): s = \\"applepenapple\\" wordDict = [\\"apple\\", \\"pen\\"] assert set(word_break(s, wordDict)) == set([\\"apple pen apple\\"]) def test_word_break_no_possible_sentence(): s = \\"catsandog\\" wordDict = [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"] assert word_break(s, wordDict) == [] def test_word_break_repeated_words(): s = \\"aaaa\\" wordDict = [\\"a\\", \\"aa\\"] assert set(word_break(s, wordDict)) == set([\\"a a a a\\", \\"aa a a\\", \\"a aa a\\", \\"a a aa\\", \\"aa aa\\"]) def test_word_break_empty_string(): s = \\"\\" wordDict = [\\"anything\\"] assert word_break(s, wordDict) == [\\"\\"] def test_word_break_word_longer_than_string(): s = \\"cat\\" wordDict = [\\"cats\\", \\"dog\\"] assert word_break(s, wordDict) == []","solution":"def word_break(s, wordDict): Given a string s and a dictionary of words wordDict, returns a list of all possible sentences that can be formed by concatenating words from the dictionary without reordering the characters in s. :param s: The input string. :param wordDict: The dictionary of words. :return: A list of sentences formed by concatenating words from the dictionary. memo = {} def dfs(s): if s in memo: return memo[s] if not s: return [\\"\\"] sentences = [] for word in wordDict: if s.startswith(word): sub_sentences = dfs(s[len(word):]) for sub_sentence in sub_sentences: if sub_sentence: sentences.append(word + \\" \\" + sub_sentence) else: sentences.append(word) memo[s] = sentences return sentences return dfs(s)"},{"question":"def max_count(m: int, n: int, ops: List[List[int]]) -> int: Returns the number of cells which have the maximum integer in the grid after performing all the given operations. >>> max_count(3, 3, []) == 9 >>> max_count(3, 3, [[2, 2]]) == 4 >>> max_count(3, 3, [[2, 2], [1, 1]]) == 1 >>> max_count(4, 5, [[3, 3], [2, 2], [1, 4]]) == 2 >>> max_count(5, 5, [[5, 5], [4, 4], [3, 3], [2, 2], [1, 1]]) == 1 >>> max_count(7, 4, []) == 28 >>> max_count(3, 3, [[3, 1], [3, 2]]) == 3","solution":"def max_count(m, n, ops): Returns the number of cells which have the maximum integer in the grid after performing all the given operations. if not ops: return m * n min_row = m min_col = n for r, c in ops: min_row = min(min_row, r) min_col = min(min_col, c) return min_row * min_col"},{"question":"def convert_zigzag(s: str, numRows: int) -> str: Converts the given string into a zigzag pattern on the given number of rows. Then reads the pattern row by row to form a new string. >>> convert_zigzag(\\"PAYPALISHIRING\\", 3) \\"PAHNAPLSIIGYIR\\" >>> convert_zigzag(\\"PAYPALISHIRING\\", 4) \\"PINALSIGYAHRPI\\" >>> convert_zigzag(\\"A\\", 1) \\"A\\" >>> convert_zigzag(\\"AB\\", 1) \\"AB\\" >>> convert_zigzag(\\"ABCD\\", 2) \\"ACBD\\" >>> convert_zigzag(\\"ABCDE\\", 4) \\"ABCED\\" >>> convert_zigzag(\\"\\", 3) \\"\\" >>> convert_zigzag(\\"GEEKSFORGEEKS\\", 3) \\"GSGSEKFREKEOE\\" >>> convert_zigzag(\\"HELLO\\", 10) \\"HELLO\\" >>> convert_zigzag(\\"HELLO\\", 1) \\"HELLO\\" >>> convert_zigzag(\\"AAAAAA\\", 3) \\"AAAAAA\\"","solution":"def convert_zigzag(s: str, numRows: int) -> str: Converts the given string into a zigzag pattern on the given number of rows. Then reads the pattern row by row to form a new string. if numRows == 1 or numRows >= len(s): return s rows = [''] * min(numRows, len(s)) curRow, goingDown = 0, False for char in s: rows[curRow] += char if curRow == 0 or curRow == numRows - 1: goingDown = not goingDown curRow += 1 if goingDown else -1 return ''.join(rows)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Determine whether a binary tree is symmetric. Args: root (TreeNode): The root of the binary tree. Returns: bool: True if the binary tree is symmetric, False otherwise. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: def is_mirror(left: TreeNode, right: TreeNode) -> bool: if not left and not right: return True if not left or not right: return False return (left.val == right.val) and is_mirror(left.right, right.left) and is_mirror(left.left, right.right) if not root: return True return is_mirror(root.left, root.right)"},{"question":"def k_sorted_sort(arr, k): Sorts a k-sorted array. An array is k-sorted if every element is at most k positions away from its target position in the sorted array. :param arr: List of integers to be sorted :param k: Integer, max distance each element is away from its target position :return: Sorted list of integers >>> k_sorted_sort([1, 2, 3, 4], 3) == [1, 2, 3, 4] >>> k_sorted_sort([4, 3, 2, 1], 3) == [1, 2, 3, 4] >>> k_sorted_sort([2, 1, 5, 4, 3], 2) == [1, 2, 3, 4, 5] >>> k_sorted_sort([1], 0) == [1] >>> k_sorted_sort([3, 3, 2, 1], 3) == [1, 2, 3, 3] >>> k_sorted_sort([10, 20, 30, 40, 50], 10) == [10, 20, 30, 40, 50] >>> k_sorted_sort([], 0) == [] >>> k_sorted_sort([10, 9, 8, 7, 4, 70, 60, 50], 4) == [4, 7, 8, 9, 10, 50, 60, 70]","solution":"import heapq def k_sorted_sort(arr, k): Sorts a k-sorted array. An array is k-sorted if every element is at most k positions away from its target position in the sorted array. :param arr: List of integers to be sorted :param k: Integer, max distance each element is away from its target position :return: Sorted list of integers # Initialize a min heap heap = [] # Build a min heap with the first k+1 elements for i in range(min(k+1, len(arr))): heapq.heappush(heap, arr[i]) result = [] index = 0 # For the rest elements in the array, pop elements from the heap and add new elements to it for i in range(k+1, len(arr)): arr[index] = heapq.heappop(heap) heapq.heappush(heap, arr[i]) index += 1 # Pop the remaining elements from the heap and place them into the array while heap: arr[index] = heapq.heappop(heap) index += 1 return arr"},{"question":"def min_words_to_form_string(s, words): Determines the minimum number of words from the list \`words\` required to form the string \`str\`. If it's not possible to form \`str\` using the words from \`words\`, returns \`-1\`. >>> min_words_to_form_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) 2 >>> min_words_to_form_string(\\"apple\\", [\\"apple\\"]) 1 >>> min_words_to_form_string(\\"appleapple\\", [\\"apple\\", \\"le\\"]) 2 >>> min_words_to_form_string(\\"apple\\", [\\"banana\\", \\"orange\\"]) -1 >>> min_words_to_form_string(\\"aaaa\\", [\\"a\\"]) 4 >>> min_words_to_form_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) 3 >>> min_words_to_form_string(\\"\\", [\\"apple\\", \\"pen\\"]) 0 >>> min_words_to_form_string(\\"a\\", [\\"a\\"]) 1 >>> min_words_to_form_string(\\"a\\", [\\"b\\"]) -1","solution":"def min_words_to_form_string(s, words): Determines the minimum number of words from the list \`words\` required to form the string \`str\`. If it's not possible to form \`str\` using the words from \`words\`, returns \`-1\`. from functools import lru_cache word_set = set(words) @lru_cache(None) def dfs(remaining): if not remaining: return 0 min_words = float('inf') for word in word_set: if remaining.startswith(word): next_count = dfs(remaining[len(word):]) if next_count != -1: min_words = min(min_words, next_count + 1) return min_words if min_words != float('inf') else -1 return dfs(s)"},{"question":"from typing import List class MusicStreams: def __init__(self, streams: List[int]): Initializes the object with the list of initial streams for each song. :param streams: List[int] pass def addStreams(self, songIndex: int, numStreams: int): Adds numStreams to the streams of the song at songIndex. :param songIndex: int :param numStreams: int pass def topKSongs(self, k: int) -> List[int]: Returns a list of the indices of the top k most streamed songs. :param k: int :return: List[int] pass # Unit tests def test_MusicStreams_initialization(): streams = [5, 3, 10, 6] ms = MusicStreams(streams) assert ms.streams == [5, 3, 10, 6] def test_MusicStreams_addStreams(): streams = [5, 3, 10, 6] ms = MusicStreams(streams) ms.addStreams(1, 4) assert ms.streams[1] == 7 ms.addStreams(2, 2) assert ms.streams[2] == 12 def test_MusicStreams_topKSongs(): streams = [5, 3, 10, 6] ms = MusicStreams(streams) # Checking top 2 songs top_2 = ms.topKSongs(2) assert top_2 == [2, 3] ms.addStreams(1, 10) # Checking top 2 songs after adding streams to song 1 top_2 = ms.topKSongs(2) assert top_2 == [1, 2] # Checking top 3 songs top_3 = ms.topKSongs(3) assert top_3 == [1, 2, 3] # New additions to the list ms.addStreams(0, 15) # Checking top 1 songs after significant addition top_1 = ms.topKSongs(1) assert top_1 == [0]","solution":"from heapq import nlargest class MusicStreams: def __init__(self, streams): Initializes the object with the list of initial streams for each song. :param streams: List[int] self.streams = streams def addStreams(self, songIndex, numStreams): Adds numStreams to the streams of the song at songIndex. :param songIndex: int :param numStreams: int self.streams[songIndex] += numStreams def topKSongs(self, k): Returns a list of the indices of the top k most streamed songs. :param k: int :return: List[int] pairs = [(self.streams[i], i) for i in range(len(self.streams))] top_k_pairs = nlargest(k, pairs, key=lambda x: (x[0], -x[1])) return [index for _, index in top_k_pairs]"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Returns the maximum sum of any contiguous subarray within the array \`arr\`. >>> max_subarray_sum([1, 2, 3, 4]) == 10 >>> max_subarray_sum([-1, -2, -3, -4]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([5]) == 5 >>> max_subarray_sum([-5]) == -5 >>> max_subarray_sum([]) == 0 >>> max_subarray_sum([0, -1, 2, 0, 3]) == 5","solution":"def max_subarray_sum(arr): Returns the maximum sum of any contiguous subarray within the array \`arr\`. if not arr: return 0 max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_changes_to_beautiful(s: str) -> int: Returns the minimal number of bit changes required to make the binary string s beautiful, such that it doesn't contain the substring \\"010\\". >>> min_changes_to_beautiful(\\"111\\") == 0 >>> min_changes_to_beautiful(\\"001010\\") == 1 >>> min_changes_to_beautiful(\\"010010\\") == 2 >>> min_changes_to_beautiful(\\"0100110\\") == 1","solution":"def min_changes_to_beautiful(s): Returns the minimal number of bit changes required to make the binary string s beautiful. count = 0 i = 0 while i < len(s) - 2: if s[i:i+3] == \\"010\\": count += 1 i += 3 # Skip past this \\"010\\" to avoid overlapping changes else: i += 1 return count"},{"question":"def longest_zero_sum_subarray(nums: List[int]) -> int: Find the length of the longest subarray with a sum equal to zero. >>> longest_zero_sum_subarray([1, 2, 3, 4, 5]) == 0 >>> longest_zero_sum_subarray([-1, -2, -3, -4, -5]) == 0 >>> longest_zero_sum_subarray([0]) == 1 >>> longest_zero_sum_subarray([1, 2, -2, -1, 0, 1]) == 5 >>> longest_zero_sum_subarray([1, -1, 3, 2, -2, -3, 4]) == 6 >>> longest_zero_sum_subarray([3, 4, -7, 1, 2, -2, -1]) == 7 >>> longest_zero_sum_subarray([1, 2, -1, -2]) == 4 >>> longest_zero_sum_subarray([]) == 0","solution":"def longest_zero_sum_subarray(nums): prefix_sum_to_index = {} prefix_sum = 0 max_length = 0 for index, num in enumerate(nums): prefix_sum += num if prefix_sum == 0: max_length = index + 1 if prefix_sum in prefix_sum_to_index: subarray_length = index - prefix_sum_to_index[prefix_sum] if subarray_length > max_length: max_length = subarray_length else: prefix_sum_to_index[prefix_sum] = index return max_length"},{"question":"def is_path_exist(matrix): Determines if there exists a path from the top-left corner to the bottom-right corner in a 2D matrix where you can only move down or right and can only pass through cells containing 1. Args: matrix (list of list of int): The 2D matrix containing 1s and 0s. Returns: bool: True if such a path exists, False otherwise. from solution import is_path_exist def test_path_exists_simple(): matrix = [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ] assert is_path_exist(matrix) == True def test_no_path_due_to_zeros(): matrix = [ [1, 0, 0], [0, 1, 0], [0, 1, 1] ] assert is_path_exist(matrix) == False def test_single_cell_path(): matrix = [ [1] ] assert is_path_exist(matrix) == True def test_no_path_in_single_cell(): matrix = [ [0] ] assert is_path_exist(matrix) == False def test_path_exists_additional_case(): matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 1], [0, 0, 1, 1] ] assert is_path_exist(matrix) == True def test_path_not_exists_blocked_at_end(): matrix = [ [1, 1, 0, 1], [0, 1, 1, 0], [1, 0, 1, 0], [0, 0, 1, 0] ] assert is_path_exist(matrix) == False","solution":"def is_path_exist(matrix): Determines if there exists a path from the top-left corner to the bottom-right corner in a 2D matrix where you can only move down or right and can only pass through cells containing 1. Args: matrix (list of list of int): The 2D matrix containing 1s and 0s. Returns: bool: True if such a path exists, False otherwise. if not matrix or matrix[0][0] != 1 or matrix[-1][-1] != 1: return False n, m = len(matrix), len(matrix[0]) directions = [(1, 0), (0, 1)] def dfs(x, y, visited): if x == n - 1 and y == m - 1: return True if not (0 <= x < n and 0 <= y < m) or (x, y) in visited or matrix[x][y] != 1: return False visited.add((x, y)) for dx, dy in directions: if dfs(x + dx, y + dy, visited): return True return False return dfs(0, 0, set())"},{"question":"def find_path(tree: List[int], target: int) -> List[int]: Find the path from the root to the node with the value equal to \`target\` in the given tree. Parameters: tree (List[int]): A binary tree represented as a list of integers in level-order traversal. target (int): The value of the target node. Returns: List[int]: The path from the root to the target node as a list of integers. >>> find_path([3, 9, 20, None, None, 15, 7], 7) [3, 20, 7] >>> find_path([3, 9, 20, None, None, 15, 7], 3) [3] >>> find_path([3, 9, 20, None, None, 15, 7], 10) [] >>> find_path([], 7) [] >>> find_path([1], 1) [1] >>> find_path([1, 2, None, 3, None, None, None, 4], 4) [1, 2, 3, 4] >>> find_path([1, 2, 3, 4, 5, 6, 7, 8, 9], 7) [1, 3, 7] >>> find_path([1, 2, 3, 4, 5], 5) [1, 2, 5]","solution":"def find_path(tree, target): def get_child_index(parent_index, left_child): return 2 * parent_index + (1 if left_child else 2) def dfs(index, path): if index >= len(tree) or tree[index] is None: return False path.append(tree[index]) if tree[index] == target: return True left_child_idx = get_child_index(index, True) right_child_idx = get_child_index(index, False) if dfs(left_child_idx, path) or dfs(right_child_idx, path): return True path.pop() return False if not tree: return [] path = [] dfs(0, path) return path if tree[0] == target or path else []"},{"question":"def min_piles(coins, m): Returns the minimum number of piles required to collect at least m coins. If it is not possible to collect m coins, returns -1. >>> min_piles([7, 4, 2], 5) == 1 >>> min_piles([1, 1, 1, 1], 4) == 4 >>> min_piles([1, 2, 3, 4], 6) == 3 >>> min_piles([1, 1, 1], 10) == -1 >>> min_piles([2, 3, 4], 9) == 3","solution":"def min_piles(coins, m): Returns the minimum number of piles required to collect at least m coins. If it is not possible to collect m coins, returns -1. current_sum = 0 for i, coin in enumerate(coins): current_sum += coin if current_sum >= m: return i + 1 return -1"},{"question":"def minimum_moves_to_sort(heights: List[int]) -> int: Given an array \`heights\` representing the heights of students standing in a row from left to right, determine the minimum number of students that must move to ensure all students are standing in non-decreasing order of their heights. >>> minimum_moves_to_sort([1, 3, 2, 6, 5]) 2 >>> minimum_moves_to_sort([1, 2, 3, 4, 5]) 0 >>> minimum_moves_to_sort([5, 4, 3, 2, 1]) 4 >>> minimum_moves_to_sort([5]) 0 >>> minimum_moves_to_sort([4, 3, 5, 1, 6, 2]) 3 >>> minimum_moves_to_sort([4, 3, 7, 1, 2, 6, 5]) 4","solution":"def minimum_moves_to_sort(heights): Returns the minimum number of moves needed to make the array non-decreasing. n = len(heights) lis_length = [1] * n # Find the longest increasing subsequence (LIS) for i in range(n): for j in range(i): if heights[i] >= heights[j]: lis_length[i] = max(lis_length[i], lis_length[j] + 1) longest_increasing_subsequence = max(lis_length) moves = n - longest_increasing_subsequence return moves"},{"question":"def subarray_sum(nums: List[int], k: int) -> int: Returns the number of contiguous subarrays that sum to k. >>> subarray_sum([1, 1, 1], 2) == 2 >>> subarray_sum([1, -1, 1, 2, 3], 3) == 3 >>> subarray_sum([1, 2, 3, 4, 5], 15) == 1 >>> subarray_sum([1, -1, 1, -1], 0) == 4 >>> subarray_sum([1, 2, 3], 7) == 0 >>> subarray_sum([3], 3) == 1 >>> subarray_sum([3], 2) == 0","solution":"def subarray_sum(nums, k): Returns the number of contiguous subarrays that sum to k. count = 0 current_sum = 0 sum_map = {0: 1} for num in nums: current_sum += num if (current_sum - k) in sum_map: count += sum_map[current_sum - k] if current_sum in sum_map: sum_map[current_sum] += 1 else: sum_map[current_sum] = 1 return count"},{"question":"def subarray_sum_with_one_removal(nums: List[int], k: int) -> bool: Determines if there exists a subarray with sum k after removing exactly one element. >>> subarray_sum_with_one_removal([1, 2, 3, 4, 5], 9) True >>> subarray_sum_with_one_removal([1, 2, 3, 4, 5], 8) True >>> subarray_sum_with_one_removal([1, 2, 3, 7, 8], 13) True >>> subarray_sum_with_one_removal([1, 2, 3], 7) False >>> subarray_sum_with_one_removal([2, 3, 5], 10) False >>> subarray_sum_with_one_removal([1], 1) False >>> subarray_sum_with_one_removal([10], 10) False >>> subarray_sum_with_one_removal([], 0) False >>> subarray_sum_with_one_removal([1, 2, 6, 1], 9) True","solution":"def subarray_sum_with_one_removal(nums, k): Determines if there exists a subarray with sum k after removing exactly one element. n = len(nums) # Helper function to find if there exists a subarray with the exact sum using given array def has_subarray_with_sum(array, target): curr_sum = 0 lookup = set([0]) for num in array: curr_sum += num if (curr_sum - target) in lookup: return True lookup.add(curr_sum) return False for i in range(n): # Remove element at index i modified_nums = nums[:i] + nums[i+1:] if has_subarray_with_sum(modified_nums, k): return True return False"},{"question":"def min_moves_to_zero(grid): Returns the minimum number of moves required to make at least one element in the grid equal to 0. >>> min_moves_to_zero([[3, 4, 2]]) == 4 >>> min_moves_to_zero([[1], [0], [5]]) == 5 >>> min_moves_to_zero([[2, 3], [4, 1]]) == 4 >>> min_moves_to_zero([[5, 5, 5], [5, 5, 5]]) == 5 >>> min_moves_to_zero([[0, 0], [0, 0]]) == 0","solution":"def min_moves_to_zero(grid): Returns the minimum number of moves required to make at least one element in the grid equal to 0. max_element = max(max(row) for row in grid) return max_element"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if there is a cycle in a linked list using Floyd's Tortoise and Hare algorithm. :param head: ListNode, the head of the singly linked list :return: bool, True if there is a cycle, False otherwise >>> node1 = ListNode(1) >>> node2 = ListNode(2) >>> node1.next = node2 >>> hasCycle(node1) False >>> node1.next = node1 >>> hasCycle(node1) True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head): Determines if there is a cycle in a linked list using Floyd's Tortoise and Hare algorithm. :param head: ListNode, the head of the singly linked list :return: bool, True if there is a cycle, False otherwise if not head or not head.next: return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True"},{"question":"def find_element_with_equal_sides(arr: List[int], n: int) -> int: Given a sorted array of n unique integers, find the integer such that the number of elements less than it is equal to the number of elements greater than it. If multiple such integers exist, return the smallest one. If no such integer exists, return -1. >>> find_element_with_equal_sides([1, 2, 3], 3) 2 >>> find_element_with_equal_sides([1, 2], 2) -1 >>> find_element_with_equal_sides([1, 2, 3, 4, 5], 5) 3 >>> find_element_with_equal_sides([1, 2, 3, 4, 5, 6], 6) -1 >>> find_element_with_equal_sides([], 0) -1 >>> find_element_with_equal_sides([1], 1) -1 >>> find_element_with_equal_sides([1, 3, 5, 7, 9], 5) 5","solution":"def find_element_with_equal_sides(arr, n): Given a sorted array of n unique integers, find the integer such that the number of elements less than it is equal to the number of elements greater than it. If multiple such integers exist, return the smallest one. If no such integer exists, return -1. # If the array is empty or has less than 3 elements, return -1 if not arr or n < 3: return -1 # For the element to have equal elements on both sides, it must be at the middle mid = n // 2 # Check if it is perfectly in the middle if (n - mid - 1) == mid: return arr[mid] else: return -1"},{"question":"class KDistinctElements: def __init__(self, nums, k): Initializes the object with the integer array nums and the integer k. self.nums = nums self.k = k def processArray(self): Processes the array such that each element appears at most k times. Returns: list: The modified array. pass # Test Cases def test_example_case(): k_distinct = KDistinctElements([1,1,1,2,2,3], 2) assert k_distinct.processArray() == [1, 1, 2, 2, 3] def test_all_elements_single_occurrence(): k_distinct = KDistinctElements([1, 2, 3, 4], 1) assert k_distinct.processArray() == [1, 2, 3, 4] def test_all_elements_twice_occurrence(): k_distinct = KDistinctElements([1, 1, 2, 2, 3, 3], 2) assert k_distinct.processArray() == [1, 1, 2, 2, 3, 3] def test_elements_more_than_k(): k_distinct = KDistinctElements([1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4], 2) assert k_distinct.processArray() == [1, 1, 2, 2, 3, 3, 4, 4] def test_k_is_zero(): k_distinct = KDistinctElements([1, 1, 1, 2, 2, 3], 0) assert k_distinct.processArray() == [] def test_empty_array(): k_distinct = KDistinctElements([], 2) assert k_distinct.processArray() == [] def test_array_with_negative_elements(): k_distinct = KDistinctElements([-1, -1, -2, -2, -3, -3, -3], 2) assert k_distinct.processArray() == [-1, -1, -2, -2, -3, -3]","solution":"class KDistinctElements: def __init__(self, nums, k): Initializes the object with the integer array nums and the integer k. self.nums = nums self.k = k def processArray(self): Processes the array such that each element appears at most k times. Returns: list: The modified array. if self.k < 1: return [] element_count = {} result = [] for num in self.nums: if num not in element_count: element_count[num] = 0 if element_count[num] < self.k: result.append(num) element_count[num] += 1 return result"},{"question":"def single_number(nums: List[int]) -> int: Returns the single element in the array that appears only once. >>> single_number([2, 2, 3, 4, 4]) 3 >>> single_number([-1, -1, -2]) -2 >>> single_number([4, 1, 2, 1, 2]) 4 >>> single_number([99]) 99 >>> single_number([100000, 50000, 100000]) 50000","solution":"def single_number(nums): Returns the single element in the array that appears only once. unique_num = 0 for num in nums: unique_num ^= num return unique_num"},{"question":"from typing import List, Optional from collections import deque class Node: def __init__(self, val: Optional[int] = None, children: List['Node'] = None): self.val = val self.children = children if children is not None else [] def level_order(root: Optional[Node]) -> List[List[int]]: Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of lists of integers representing the node values at each level >>> root = Node(1, [Node(2), Node(3, [Node(6), Node(7)]), Node(4), Node(5)]) >>> level_order(root) [[1], [2, 3, 4, 5], [6, 7]] >>> root = Node(1) >>> level_order(root) [[1]] >>> level_order(None) [] >>> root = Node(1, [Node(2, [Node(5), Node(6)]), Node(3, [Node(7)]), Node(4, [Node(8), Node(9)])]) >>> level_order(root) [[1], [2, 3, 4], [5, 6, 7, 8, 9]] >>> root = Node(1, [Node(2, [Node(5, [Node(10, [Node(12)])]), Node(6)]), Node(3, [Node(7, [Node(11)])]), Node(4, [Node(8), Node(9)])]) >>> level_order(root) [[1], [2, 3, 4], [5, 6, 7, 8, 9], [10, 11], [12]]","solution":"from collections import deque class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def level_order(root): Returns the level order traversal of an n-ary tree. :param root: Root node of the n-ary tree :return: List of lists of integers representing the node values at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) for child in node.children: queue.append(child) result.append(level_nodes) return result"},{"question":"def find_isolated_networks(n: int, connections: List[List[int]]) -> int: Determines the number of isolated networks. Parameters: n (int): The number of networks. connections (List[List[int]]): The list of direct connections. Returns: int: The number of isolated networks. >>> find_isolated_networks(5, []) 5 >>> find_isolated_networks(4, [[1, 2], [2, 3], [3, 4]]) 0 >>> find_isolated_networks(5, [[1, 2], [3, 4]]) 1 >>> find_isolated_networks(3, [[1, 2], [2, 3], [3, 1]]) 0 >>> find_isolated_networks(6, [[1, 2], [2, 3], [4, 5]]) 1 >>> find_isolated_networks(1, []) 1 >>> find_isolated_networks(2, []) 2","solution":"def find_isolated_networks(n, connections): Determines the number of isolated networks. Parameters: n (int): The number of networks. connections (List[List[int]]): The list of direct connections. Returns: int: The number of isolated networks. def dfs(network, visited, adjacency_list): if visited[network]: return visited[network] = True for neighbor in adjacency_list[network]: dfs(neighbor, visited, adjacency_list) # Initialize adjacency list for each network adjacency_list = [[] for _ in range(n+1)] for a, b in connections: adjacency_list[a].append(b) adjacency_list[b].append(a) visited = [False] * (n+1) isolated_networks = 0 for i in range(1, n+1): if not visited[i] and len(adjacency_list[i]) == 0: isolated_networks += 1 elif not visited[i]: dfs(i, visited, adjacency_list) return isolated_networks"},{"question":"import heapq from typing import List def trapRainWater(heightMap: List[List[int]]) -> int: Calculate the total volume of water trapped in a grid after raining. >>> trapRainWater([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 4], ... [2, 3, 3, 2, 3, 1] ... ]) == 4 >>> trapRainWater([ ... [3, 3, 3, 3, 3], ... [3, 2, 2, 2, 3], ... [3, 2, 1, 2, 3], ... [3, 2, 2, 2, 3], ... [3, 3, 3, 3, 3] ... ]) == 10 >>> trapRainWater([ ... [1, 1, 1, 1], ... [1, 0, 0, 1], ... [1, 1, 1, 1] ... ]) == 2 >>> trapRainWater([[1]]) == 0 >>> trapRainWater([]) == 0","solution":"import heapq def trapRainWater(heightMap): if not heightMap or not heightMap[0]: return 0 m, n = len(heightMap), len(heightMap[0]) visited = [[False] * n for _ in range(m)] heap = [] for i in range(m): heapq.heappush(heap, (heightMap[i][0], i, 0)) visited[i][0] = True heapq.heappush(heap, (heightMap[i][n - 1], i, n - 1)) visited[i][n - 1] = True for j in range(1, n - 1): heapq.heappush(heap, (heightMap[0][j], 0, j)) visited[0][j] = True heapq.heappush(heap, (heightMap[m - 1][j], m - 1, j)) visited[m - 1][j] = True volume = 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] while heap: height, x, y = heapq.heappop(heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True volume += max(0, height - heightMap[nx][ny]) heapq.heappush(heap, (max(height, heightMap[nx][ny]), nx, ny)) return volume"},{"question":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums: List[int]) -> TreeNode: Construct a binary tree from a list of integers representing level order traversal. >>> construct_tree([1, 2, 3, -1, 5, -1, -1]) # returns the root of the tree pass def reflect_levels(levels: List[List[int]]) -> List[List[int]]: Reflect each level of the tree around the center. >>> reflect_levels([[1], [2, 3], [4, 5]]) [[1], [3, 2], [5, 4]] pass def level_order_traversal(root: TreeNode) -> List[List[int]]: Perform level order traversal of the binary tree. >>> level_order_traversal(root_of_tree) [[1], [2, 3], [4, 5]] pass def reflected_level_order(nums: List[int]) -> List[List[int]]: Construct the binary tree and return the reflected level order traversal. >>> reflected_level_order([1, 2, 3, -1, 5, -1, -1]) [[1], [3, 2], [5]] pass def test_reflected_level_order(): nums = [1, 2, 3, -1, 5, -1, -1] expected = [ [1], [3, 2], [5] ] assert reflected_level_order(nums) == expected nums = [1, 2, 3, 4, 5, 6, 7] expected = [ [1], [3, 2], [7, 6, 5, 4] ] assert reflected_level_order(nums) == expected nums = [1] expected = [ [1] ] assert reflected_level_order(nums) == expected nums = [] expected = [] assert reflected_level_order(nums) == expected nums = [1, 2, -1, 3, -1, 4, -1] expected = [ [1], [2], [3], [4] ] assert reflected_level_order(nums) == expected nums = [1, -1, 2, -1, 3, -1, 4] expected = [ [1], [2], [3], [4] ] assert reflected_level_order(nums) == expected","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(nums): if not nums: return None from collections import deque root = TreeNode(nums[0]) queue = deque([root]) i = 1 while queue and i < len(nums): node = queue.popleft() if nums[i] != -1: node.left = TreeNode(nums[i]) queue.append(node.left) i += 1 if i < len(nums) and nums[i] != -1: node.right = TreeNode(nums[i]) queue.append(node.right) i += 1 return root def reflect_levels(levels): return [level[::-1] for level in levels] def level_order_traversal(root): if not root: return [] from collections import deque result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result def reflected_level_order(nums): root = construct_tree(nums) levels = level_order_traversal(root) return reflect_levels(levels)"},{"question":"def longest_subarray(arr: List[int], limit: int) -> int: Finds the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to the given integer \`limit\`. Parameters: - arr: List[int] - limit: int Returns: - int: The length of the longest such subarray. >>> longest_subarray([8, 2, 4, 7], 4) 2 >>> longest_subarray([4, 4, 4, 4], 0) 4 >>> longest_subarray([1, 3, 5, 7, 9], 10) 5 >>> longest_subarray([10, 1, 2, 4, 7, 2], 5) 4 >>> longest_subarray([], 5) 0 >>> longest_subarray([10, 20, 30], 1) 1","solution":"from collections import deque def longest_subarray(arr, limit): Finds the length of the longest contiguous subarray where the absolute difference between any two elements is less than or equal to limit. Parameters: - arr: List[int] - limit: int Returns: - int: The length of the longest such subarray. min_deque, max_deque = deque(), deque() left = 0 max_len = 0 for right in range(len(arr)): while min_deque and arr[right] < arr[min_deque[-1]]: min_deque.pop() while max_deque and arr[right] > arr[max_deque[-1]]: max_deque.pop() min_deque.append(right) max_deque.append(right) while arr[max_deque[0]] - arr[min_deque[0]] > limit: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() max_len = max(max_len, right - left + 1) return max_len"},{"question":"def numDecodings(s: str) -> int: Return the number of ways to decode the message. Since the answer could be very large, return it modulo 10^9 + 7. >>> numDecodings(\\"12\\") == 2 >>> numDecodings(\\"*\\") == 9 >>> numDecodings(\\"1*\\") == 18 >>> numDecodings(\\"2*\\") == 15 >>> numDecodings(\\"*1\\") == 11 >>> numDecodings(\\"**\\") == 96 >>> numDecodings(\\"0\\") == 0 >>> numDecodings(\\"06\\") == 0 >>> numDecodings(\\"********************\\") == 104671669 % (10 ** 9 + 7) MOD = 10**9 + 7 # ensure to compute the number of ways to decode # ...","solution":"def numDecodings(s): MOD = 10**9 + 7 n = len(s) if n == 0: return 0 dp = [0] * (n + 1) dp[0] = 1 # Handling the first character if s[0] == '0': return 0 elif s[0] == '*': dp[1] = 9 else: dp[1] = 1 for i in range(1, n): if s[i] == '*': dp[i + 1] = 9 * dp[i] % MOD elif s[i] != '0': dp[i + 1] = dp[i] if s[i-1] == '1': if s[i] == '*': dp[i + 1] = (dp[i + 1] + 9 * dp[i-1]) % MOD else: dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD elif s[i-1] == '2': if s[i] == '*': dp[i + 1] = (dp[i + 1] + 6 * dp[i-1]) % MOD elif s[i] <= '6': dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD elif s[i-1] == '*': if s[i] == '*': dp[i + 1] = (dp[i + 1] + 15 * dp[i-1]) % MOD elif s[i] <= '6': dp[i + 1] = (dp[i + 1] + 2 * dp[i-1]) % MOD else: dp[i + 1] = (dp[i + 1] + dp[i-1]) % MOD return dp[n]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root: TreeNode) -> List[int]: Given a binary tree, returns the values of the nodes you can see ordered from top to bottom. :param root: TreeNode, the root of the binary tree :return: List[int], values of the nodes as seen from the right side view >>> right_side_view(None) [] >>> right_side_view(TreeNode(1)) [1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> right_side_view(root) [1, 2, 3] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> right_side_view(root) [1, 3, 6] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> right_side_view(root) [1, 3, 4, 8]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def right_side_view(root): Returns the values of the nodes you can see from the right side of the binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], values of the nodes as seen from the right side view if not root: return [] from collections import deque queue = deque([root]) right_view = [] while queue: level_length = len(queue) for i in range(level_length): node = queue.popleft() # If it's the last node in the current level, add it to right_view if i == level_length - 1: right_view.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) return right_view"},{"question":"def total_wood_collected(heights: List[int], cut_height: int) -> int: Calculate the total amount of wood collected after cutting down all trees taller than cut_height to the cut_height. >>> total_wood_collected([2, 3, 4], 5) 0 >>> total_wood_collected([6, 7, 8], 5) 6 >>> total_wood_collected([1, 6, 3, 8, 7], 5) 6 >>> total_wood_collected([5, 5, 5], 5) 0 >>> total_wood_collected([], 5) 0 >>> total_wood_collected([2, 5, 7], 0) 14 >>> total_wood_collected([1, 2, 3], 4) 0","solution":"def total_wood_collected(heights, cut_height): Returns the total amount of wood collected after cutting down all trees taller than cut_height to the cut_height. Parameters: heights (list of int): List of integers representing the heights of trees. cut_height (int): The height to which trees taller than this should be cut. Returns: int: Total amount of wood collected. total_wood = 0 for height in heights: if height > cut_height: total_wood += height - cut_height return total_wood"},{"question":"# Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder(root): Given the root of an n-ary tree, return the preorder traversal of its nodes' values. >>> root = Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)]) >>> preorder(root) [1, 3, 5, 6, 2, 4] >>> root = Node(1) >>> preorder(root) [1] >>> preorder(None) [] >>> root = Node(1, [Node(2)]) >>> preorder(root) [1, 2] >>> root = Node(1, [Node(2), Node(3), Node(4, [Node(5, [Node(6)])])]) >>> preorder(root) [1, 2, 3, 4, 5, 6]","solution":"# Definition for a Node. class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def preorder(root): Given the root of an n-ary tree, return the preorder traversal of its nodes' values. if not root: return [] result = [] stack = [root] while stack: current = stack.pop() result.append(current.val) stack.extend(reversed(current.children)) return result"},{"question":"from typing import List def minimum_effort_path(grid: List[List[int]]) -> int: Returns the minimum possible value of the maximum height difference between two consecutive cells in the path from top-left to bottom-right. >>> grid = [ ... [1, 2, 2], ... [3, 8, 2], ... [5, 3, 5] ... ] >>> minimum_effort_path(grid) 2 >>> grid = [ ... [1] ... ] >>> minimum_effort_path(grid) 0 >>> grid = [ ... [1, 2] ... ] >>> minimum_effort_path(grid) 1 >>> grid = [ ... [4], ... [1] ... ] >>> minimum_effort_path(grid) 3 >>> grid = [ ... [1, 1000000], ... [1000000, 1] ... ] >>> minimum_effort_path(grid) 999999 >>> grid = [ ... [1, 2, 1], ... [2, 3, 2], ... [3, 3, 4] ... ] >>> minimum_effort_path(grid) 1 pass","solution":"import heapq def minimum_effort_path(grid): Returns the minimum possible value of the maximum height difference between two consecutive cells in the path from top-left to bottom-right. m, n = len(grid), len(grid[0]) # Directions for right and down movements directions = [(0, 1), (1, 0)] # Min Heap to store (effort, x, y) heap = [(0, 0, 0)] # Start at top-left corner with 0 effort efforts = [[float('inf')] * n for _ in range(m)] efforts[0][0] = 0 while heap: current_effort, x, y = heapq.heappop(heap) if x == m - 1 and y == n - 1: return current_effort for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: new_effort = max(current_effort, abs(grid[nx][ny] - grid[x][y])) if new_effort < efforts[nx][ny]: efforts[nx][ny] = new_effort heapq.heappush(heap, (new_effort, nx, ny)) return -1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(root1, root2): Determine if root2 is a subtree of root1. >>> root1 = TreeNode(3) >>> root1.left = TreeNode(4) >>> root1.right = TreeNode(5) >>> root1.left.left = TreeNode(1) >>> root1.left.right = TreeNode(2) >>> root2 = TreeNode(4) >>> root2.left = TreeNode(1) >>> root2.right = TreeNode(2) >>> is_subtree(root1, root2) True >>> root1.left.right.left = TreeNode(0) >>> is_subtree(root1, root2) False >>> root2 = None >>> is_subtree(root1, root2) True >>> root1 = None >>> root2 = TreeNode(1) >>> is_subtree(root1, root2) False >>> is_subtree(None, None) True pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(root1, root2): if not root2: return True if not root1: return False if is_same_tree(root1, root2): return True return is_subtree(root1.left, root2) or is_subtree(root1.right, root2) def is_same_tree(s, t): if not s and not t: return True if not s or not t: return False if s.val != t.val: return False return is_same_tree(s.left, t.left) and is_same_tree(s.right, t.right)"},{"question":"def kth_smallest_element(matrix, k): Returns the k-th smallest element in a matrix where each row and each column is sorted in ascending order. >>> kth_smallest_element([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest_element([ ... [1, 3, 5], ... [6, 7, 12], ... [11, 14, 14] ... ], 6) 11 >>> kth_smallest_element([ ... [1, 2], ... [1, 3] ... ], 2) 1 >>> kth_smallest_element([[5]], 1) 5 >>> kth_smallest_element([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ], 5) 1","solution":"import heapq def kth_smallest_element(matrix, k): Returns the k-th smallest element in a matrix where each row and each column is sorted in ascending order. n = len(matrix) min_heap = [(matrix[0][0], 0, 0)] visited = set((0, 0)) for _ in range(k - 1): val, r, c = heapq.heappop(min_heap) if r + 1 < n and (r + 1, c) not in visited: heapq.heappush(min_heap, (matrix[r + 1][c], r + 1, c)) visited.add((r + 1, c)) if c + 1 < n and (r, c + 1) not in visited: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) visited.add((r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"def insert_interval(intervals, new_interval): Inserts a new interval into a list of existing non-overlapping intervals and merges overlapping intervals if necessary. Args: intervals (List[List[int]]): List of non-overlapping intervals sorted by start times. new_interval (List[int]): The new interval to insert. Returns: List[List[int]]: The updated list of non-overlapping intervals after insertion and merging. from solution import insert_interval def test_insert_interval_no_overlap_before(): assert insert_interval([[1, 3], [6, 9]], [2, 5]) == [[1, 5], [6, 9]] def test_insert_interval_no_overlap_after(): assert insert_interval([[1, 3], [6, 9]], [10, 11]) == [[1, 3], [6, 9], [10, 11]] def test_insert_interval_with_overlap(): assert insert_interval([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]], [4, 8]) == [[1, 2], [3, 10], [12, 16]] def test_insert_interval_single_interval(): assert insert_interval([], [5, 7]) == [[5, 7]] def test_insert_interval_overlapping_all(): assert insert_interval([[1, 5]], [2, 3]) == [[1, 5]] assert insert_interval([[1, 4], [5, 6]], [3, 5]) == [[1, 6]] assert insert_interval([[1, 4], [5, 6], [7, 8]], [3, 7]) == [[1, 8]] def test_insert_interval_edge_case(): assert insert_interval([[2, 4], [6, 8]], [4, 6]) == [[2, 8]] assert insert_interval([[2, 4]], [0, 1]) == [[0, 1], [2, 4]]","solution":"def insert_interval(intervals, new_interval): Inserts a new interval into a list of existing non-overlapping intervals and merges overlapping intervals if necessary. Args: intervals (List[List[int]]): List of non-overlapping intervals sorted by start times. new_interval (List[int]): The new interval to insert. Returns: List[List[int]]: The updated list of non-overlapping intervals after insertion and merging. merged = [] i = 0 n = len(intervals) # Add all intervals ending before new_interval starts. while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge all overlapping intervals into new_interval. while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged.append(new_interval) # Add the remaining intervals. while i < n: merged.append(intervals[i]) i += 1 return merged"},{"question":"def four_sum(nums: List[int], target: int) -> List[List[int]]: Returns all unique quadruples [nums[a], nums[b], nums[c], nums[d]] such that nums[a] + nums[b] + nums[c] + nums[d] == target. The quadruples should be returned in ascending order. >>> four_sum([1, 0, -1, 0, -2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([1, 2, 3, 4, 5], 50) [] >>> four_sum([1, 1, 1, 1], 4) [[1, 1, 1, 1]] >>> four_sum([1, 4, 45, 6, 10, 12], 21) [[1, 4, 6, 10]] >>> four_sum([1, 0, -1, 0, -2, 2, 2], 0) [[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]] >>> four_sum([-3, -2, -1, 0, 0, 1, 2, 3], 0) [[-3, -2, 2, 3], [-3, -1, 1, 3], [-3, 0, 0, 3], [-3, 0, 1, 2], [-2, -1, 0, 3], [-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]","solution":"def four_sum(nums, target): Returns all unique quadruples [nums[a], nums[b], nums[c], nums[d]] such that nums[a] + nums[b] + nums[c] + nums[d] == target. The quadruples should be returned in ascending order. nums.sort() quadruples = set() n = len(nums) for i in range(n): for j in range(i+1, n): left = j + 1 right = n - 1 while left < right: total = nums[i] + nums[j] + nums[left] + nums[right] if total == target: quadruples.add((nums[i], nums[j], nums[left], nums[right])) left += 1 right -= 1 elif total < target: left += 1 else: right -= 1 return [list(quad) for quad in sorted(quadruples)]"},{"question":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: Given a list of integers \`temperatures\` where each integer represents the temperature of the day, return a list where, for each day in the input, you determine how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put \`0\` in the corresponding position. Args: temperatures (list of int): List of daily temperatures. Returns: list of int: List of days to wait for a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 40, 50, 60]) [1, 1, 1, 0] >>> daily_temperatures([30, 20, 10, 0]) [0, 0, 0, 0] >>> daily_temperatures([50]) [0] >>> daily_temperatures([70, 70, 70, 70]) [0, 0, 0, 0]","solution":"def daily_temperatures(temperatures): Given a list of integers \`temperatures\` where each integer represents the temperature of the day, return a list where, for each day in the input, you determine how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put \`0\` in the corresponding position. Args: temperatures (list of int): List of daily temperatures. Returns: list of int: List of days to wait for a warmer temperature. n = len(temperatures) answer = [0] * n stack = [] # this will store indices of temperatures list for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() answer[index] = i - index stack.append(i) return answer"},{"question":"def min_stacks(arr: List[int]) -> int: Find the minimum number of stacks required so that each stack is non-increasing in height from bottom to top. >>> min_stacks([5]) 1 >>> min_stacks([1, 2, 3, 4, 5]) 5 >>> min_stacks([5, 4, 3, 2, 1]) 1 >>> min_stacks([3, 4, 2, 1, 5, 2]) 3 >>> min_stacks([2, 2, 2, 2, 2]) 1 >>> min_stacks([1, 3, 2, 4, 2, 5, 2]) 4","solution":"def min_stacks(arr): stacks = [] for height in arr: placed = False for stack in stacks: if height <= stack[-1]: stack.append(height) placed = True break if not placed: stacks.append([height]) return len(stacks)"},{"question":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pairs(words): Given a list of unique words, return all pairs of different indices (i, j) such that the concatenation of the two words words[i] + words[j] is a palindrome. :param List[str] words: List of unique words :return List[List[int]]: List of pairs of indices forming palindrome concatenation from solution import palindrome_pairs def test_palindrome_pairs_example(): words = [\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"] result = palindrome_pairs(words) expected = [[0, 1], [1, 0], [3, 2], [2, 4]] assert sorted(result) == sorted(expected) def test_palindrome_pairs_no_pairs(): words = [\\"abc\\", \\"def\\", \\"ghi\\"] result = palindrome_pairs(words) expected = [] assert result == expected def test_palindrome_pairs_single_characters(): words = [\\"a\\", \\"b\\", \\"c\\"] result = palindrome_pairs(words) expected = [] assert result == expected def test_palindrome_pairs_mixed(): words = [\\"bat\\", \\"tab\\", \\"cat\\"] result = palindrome_pairs(words) expected = [[0, 1], [1, 0]] assert sorted(result) == sorted(expected) def test_palindrome_pairs_all_palindromes(): words = [\\"a\\", \\"aa\\", \\"aaa\\"] result = palindrome_pairs(words) expected = [[0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]] assert sorted(result) == sorted(expected) def test_palindrome_pairs_empty(): words = [] result = palindrome_pairs(words) assert result == []","solution":"def is_palindrome(s): Helper function to check if a string is a palindrome. return s == s[::-1] def palindrome_pairs(words): Given a list of unique words, return all pairs of different indices (i, j) such that the concatenation of the two words words[i] + words[j] is a palindrome. :param List[str] words: List of unique words :return List[List[int]]: List of pairs of indices forming palindrome concatenation pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j: if is_palindrome(words[i] + words[j]): pairs.append([i, j]) return pairs"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Given a list of integers \`arr\`, return a list of integers such that each element at index \`i\` is the product of all the numbers in the original array except the one at \`i\`. You must solve the problem without using division, and the algorithm should run in O(n) time where \`n\` is the length of the input list. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([10]) [1] >>> product_except_self([3, 5]) [5, 3] >>> product_except_self([1, 2, 0, 4, 3]) [0, 0, 24, 0, 0] >>> product_except_self([0, 2, 3, 4]) [24, 0, 0, 0] >>> product_except_self([0, 0, 0, 0]) [0, 0, 0, 0] >>> product_except_self([-1, 1, -2, 2]) [-4, 4, -2, 2] pass","solution":"def product_except_self(nums): Returns a list of integers such that each element at index i is the product of all the numbers in the original array except the one at i. length = len(nums) result = [1] * length prefix = 1 for i in range(length): result[i] = prefix prefix *= nums[i] suffix = 1 for i in range(length - 1, -1, -1): result[i] *= suffix suffix *= nums[i] return result"},{"question":"def min_smallest_palindromic_partition_length(s: str) -> int: Given a string \`s\`, partition \`s\` into as few substrings as possible such that each substring is a palindrome. Return the length of the smallest substring in any of the optimal palindromic partitionings of \`s\`. >>> min_smallest_palindromic_partition_length(\\"a\\") 1 >>> min_smallest_palindromic_partition_length(\\"ab\\") 1 >>> min_smallest_palindromic_partition_length(\\"aab\\") 1 >>> min_smallest_palindromic_partition_length(\\"aba\\") 1 >>> min_smallest_palindromic_partition_length(\\"abc\\") 1 >>> min_smallest_palindromic_partition_length(\\"aabbcc\\") 1 >>> min_smallest_palindromic_partition_length(\\"abacdfgdcaba\\") 1","solution":"def min_smallest_palindromic_partition_length(s): n = len(s) def is_palindrome(sub): return sub == sub[::-1] # dp[i] will be the minimum number of cuts needed to partition s[:i+1] dp = [float('inf')] * n # palin[i][j] will be True if s[i:j+1] is a palindrome palin = [[False] * n for _ in range(n)] for i in range(n): min_cut = i # Maximum cuts, which is i (all single characters) for j in range(i + 1): if s[j] == s[i] and (i - j < 3 or palin[j + 1][i - 1]): palin[j][i] = True min_cut = 0 if j == 0 else min(min_cut, dp[j - 1] + 1) dp[i] = min_cut smallest_length = n start = 0 while start < n: end = start while end < n and not palin[start][end]: end += 1 smallest_length = min(smallest_length, end - start + 1) start = end + 1 return smallest_length"},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Returns the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): A 2D grid representing the map of land (1) and water (0). Returns: int: The perimeter of the island. pass # Unit Tests def test_single_cell(): grid = [[1]] assert island_perimeter(grid) == 4 def test_square_island(): grid = [ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0] ] assert island_perimeter(grid) == 12 def test_long_rectangular_island(): grid = [ [0, 1, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0] ] assert island_perimeter(grid) == 8 def test_L_shaped_island(): grid = [ [0, 1, 0, 0], [0, 1, 0, 0], [1, 1, 0, 0], [1, 0, 0, 0] ] assert island_perimeter(grid) == 12 def test_all_land_island(): grid = [ [1, 1], [1, 1] ] assert island_perimeter(grid) == 8","solution":"def island_perimeter(grid): Returns the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): A 2D grid representing the map of land (1) and water (0). Returns: int: The perimeter of the island. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Initial count for the current land. perimeter += 4 # Subtract perimeter count for adjacent lands. if r > 0 and grid[r-1][c] == 1: perimeter -= 2 if c > 0 and grid[r][c-1] == 1: perimeter -= 2 return perimeter"},{"question":"from typing import List def valid_mountain_array(nums: List[int]) -> bool: Returns true if there exists an integer in the array such that all elements to the left of it are in strictly increasing order and all elements to the right of it are in strictly decreasing order. >>> valid_mountain_array([1, 3, 2]) True >>> valid_mountain_array([0, 3, 2, 1]) True >>> valid_mountain_array([2, 1]) False >>> valid_mountain_array([3, 5, 5]) False pass","solution":"def valid_mountain_array(nums): Returns true if there exists an integer in the array such that all elements to the left of it are in strictly increasing order and all elements to the right of it are in strictly decreasing order. n = len(nums) if n < 3: return False i = 1 # walk up while i < n and nums[i] > nums[i - 1]: i += 1 # peak can't be first or last if i == 1 or i == n: return False # walk down while i < n and nums[i] < nums[i - 1]: i += 1 return i == n"},{"question":"def find_two_sum(arr, target): Finds two distinct indices i and j in the array such that arr[i] + arr[j] == target. Parameters: arr (list of int): List of integers. target (int): Target sum. Returns: list of int: A list containing two indices [i, j]. pass # Unit tests def test_find_two_sum_example(): assert find_two_sum([2, 7, 11, 15], 9) == [0, 1] def test_find_two_sum_with_negatives(): assert find_two_sum([-3, 4, 3, 90], 0) == [0, 2] def test_find_two_sum_with_mixed_numbers(): assert find_two_sum([1, 2, 3, 6, 8], 14) == [3, 4] def test_find_two_sum_small_array(): assert find_two_sum([1, 5], 6) == [0, 1] def test_find_two_sum_multiple_solutions(): result = find_two_sum([3, 3, 4, 1], 6) # Since there are multiple valid solutions, we check for both possible [(0, 1) or (1, 0)] assert result == [0, 1] or result == [1, 0]","solution":"def find_two_sum(arr, target): Finds two distinct indices i and j in the array such that arr[i] + arr[j] == target. Parameters: arr (list of int): List of integers. target (int): Target sum. Returns: list of int: A list containing two indices [i, j]. value_to_index = {} for index, value in enumerate(arr): complement = target - value if complement in value_to_index: return [value_to_index[complement], index] value_to_index[value] = index"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: TreeNode, target: int) -> List[List[int]]: Find all paths in the binary tree such that the sum of the node values in each path equals the target. Each path should be represented as a list of the node values. >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(1) >>> path_sum(root, 22) [[5, 4, 11, 2]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> path_sum(root, 5) [] >>> root = TreeNode(5) >>> root.left = TreeNode(4) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(11) >>> root.left.left.left = TreeNode(7) >>> root.left.left.right = TreeNode(2) >>> root.right.left = TreeNode(13) >>> root.right.right = TreeNode(4) >>> root.right.right.left = TreeNode(5) >>> root.right.right.right = TreeNode(1) >>> path_sum(root, 22) [[5, 4, 11, 2], [5, 8, 4, 5]] >>> root = None >>> path_sum(root, 0) []","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root, target): def dfs(node, current_path, current_sum): if not node: return current_path.append(node.val) current_sum += node.val if not node.left and not node.right and current_sum == target: result.append(list(current_path)) dfs(node.left, current_path, current_sum) dfs(node.right, current_path, current_sum) current_path.pop() result = [] dfs(root, [], 0) return result"},{"question":"def single_number(arr: List[int]) -> int: Given an unsorted array \`arr\` of integers where every element appears twice except for one element which appears once, find and return that single element. The solution should have linear runtime complexity and only use constant extra space. >>> single_number([2, 2, 3, 3, 4]) == 4 >>> single_number([4, 1, 2, 1, 2]) == 4 >>> single_number([1]) == 1 >>> single_number([0, 0, 1, 1, 2, 2, 3]) == 3 >>> single_number([2, 3, 2, 4, 3, 5, 4]) == 5","solution":"def single_number(arr): Given an unsorted array \`arr\` of integers where every element appears twice except for one element which appears once, find and return that single element. The solution should have linear runtime complexity and only use constant extra space. single = 0 for num in arr: single ^= num return single"},{"question":"def count_sorted_subsequences(nums: List[int], k: int) -> int: Find the number of distinct subsequences of length k in the array \`nums\` that are sorted in non-decreasing order. >>> count_sorted_subsequences([1, 3, 2, 4], 2) 5 >>> count_sorted_subsequences([2, 2, 2, 2], 2) 1 >>> count_sorted_subsequences([], 2) 0 >>> count_sorted_subsequences([1, 2], 3) 0 >>> count_sorted_subsequences([1, 3, 2, 4], 1) 4 >>> count_sorted_subsequences([4, 3, 2, 1], 2) 0","solution":"def count_sorted_subsequences(nums, k): from itertools import combinations sorted_combinations = set() for combination in combinations(nums, k): if list(combination) == sorted(combination): sorted_combinations.add(combination) return len(sorted_combinations)"},{"question":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: Node) -> Node: Connects each node's next pointer to its next right node in a perfect binary tree. If there is no next right node, the next pointer should be set to NULL. This must be done using constant extra space. >>> root = build_perfect_binary_tree() >>> connect(root) >>> root.next None >>> root.left.next == root.right True >>> root.right.next None >>> root.left.left.next == root.left.right True >>> root.left.right.next == root.right.left True >>> root.right.left.next == root.right.right True >>> root.right.right.next None def build_perfect_binary_tree(): Creates a perfect binary tree for testing: 1 / 2 3 / / 4 5 6 7 n7 = Node(7) n6 = Node(6) n5 = Node(5) n4 = Node(4) n3 = Node(3, n6, n7) n2 = Node(2, n4, n5) n1 = Node(1, n2, n3) return n1 def test_connect(): root = build_perfect_binary_tree() connect(root) # Level 1 assert root.next == None # Level 2 assert root.left.next == root.right assert root.right.next == None # Level 3 assert root.left.left.next == root.left.right assert root.left.right.next == root.right.left assert root.right.left.next == root.right.right assert root.right.right.next == None def test_empty_tree(): assert connect(None) == None","solution":"class Node: def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next def connect(root: Node) -> Node: Connects each node's next pointer to its next right node. if not root: return root # Start with the root node leftmost = root while leftmost.left: # Iterate the \\"linked list\\" at the current level using the next pointers head = leftmost while head: # Connection 1 head.left.next = head.right # Connection 2 if head.next: head.right.next = head.next.left # Move to the next node in the current level head = head.next # Move to the leftmost node in the next level leftmost = leftmost.left return root"},{"question":"from typing import List def count_characters(words: List[str], chars: str) -> int: Return the length of the total number of characters in all good strings in words. A string is considered good if it can be formed by characters in chars. Each character in chars can only be used once. >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") == 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") == 10 >>> count_characters([\\"a\\", \\"abc\\", \\"de\\"], \\"fgh\\") == 0 >>> count_characters([\\"anything\\", \\"goes\\", \\"here\\"], \\"\\") == 0 >>> count_characters([], \\"somechars\\") == 0 >>> count_characters([\\"abc\\"], \\"aabbcc\\") == 3 >>> count_characters([\\"aabbcc\\"], \\"abcabc\\") == 6 >>> count_characters([\\"abcd\\"], \\"abc\\") == 0","solution":"def count_characters(words, chars): from collections import Counter chars_count = Counter(chars) total_length = 0 for word in words: word_count = Counter(word) if all(word_count[char] <= chars_count[char] for char in word_count): total_length += len(word) return total_length"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Find the shortest path for the robot to reach the bottom-right corner of the grid, starting from the top-left corner. Return the minimum number of steps required to reach the target, or -1 if no such path exists. >>> shortest_path([[0, 0, 0], [0, -1, 0], [0, 0, 0]]) == 4 >>> shortest_path([[0, -1, 0], [-1, -1, 0], [0, -1, 0]]) == -1 >>> shortest_path([[0, 0, 0, 0], [0, -1, -1, 0], [0, 0, 0, 0], [0, -1, 0, 0]]) == 6 >>> shortest_path([[0]]) == 0 >>> shortest_path([[-1, 0], [0, 0]]) == -1 >>> shortest_path([[0, 0], [0, -1]]) == -1","solution":"from collections import deque def shortest_path(grid): m, n = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] if grid[0][0] == -1 or grid[m-1][n-1] == -1: return -1 queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if (r, c) == (m-1, n-1): return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != -1 and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1"},{"question":"def longest_alphabetical_subsequence_length(s: str) -> int: Given a string \`s\` consisting of lowercase alphabets, determine the length of the longest subsequence that appears in alphabetical order. >>> longest_alphabetical_subsequence_length('abcabd') 3 >>> longest_alphabetical_subsequence_length('a') 1 >>> longest_alphabetical_subsequence_length('bbbb') 4 >>> longest_alphabetical_subsequence_length('edcba') 1 >>> longest_alphabetical_subsequence_length('abdecfg') 4 >>> longest_alphabetical_subsequence_length('') 0 >>> longest_alphabetical_subsequence_length('abcdefg') 7 pass","solution":"def longest_alphabetical_subsequence_length(s): Returns the length of the longest subsequence that appears in alphabetical order. if not s: return 0 longest_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] >= s[i-1]: current_length += 1 else: current_length = 1 longest_length = max(longest_length, current_length) return longest_length"},{"question":"def can_split_array(arr: List[int]) -> bool: Determines if it's possible to split the array into two non-empty subsequences such that the sum of the elements in both subsequences is the same. Parameters: arr (list of int): The input array. Returns: bool: True if such a split is possible, False otherwise. >>> can_split_array([1, 2, 3, 4, 6]) True >>> can_split_array([1, 2, 3, 5]) False >>> can_split_array([1]) False >>> can_split_array([1, 1]) True >>> can_split_array([2, 4, 2, 4]) True >>> can_split_array([1, 5, 11, 5]) True >>> can_split_array([3, 3, 3, 3]) True >>> can_split_array([1, 2, 3, 8]) False","solution":"def can_split_array(arr): Determines if it's possible to split the array into two non-empty subsequences such that the sum of the elements in both subsequences is the same. Parameters: arr (list of int): The input array. Returns: bool: True if such a split is possible, False otherwise. total_sum = sum(arr) # If the total sum is odd, we cannot divide it into two equal parts if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(arr) # Initialize a set to store the sums that can be achieved achievable_sums = {0} for num in arr: new_sums = achievable_sums.copy() for s in achievable_sums: new_sum = s + num if new_sum == target_sum: return True new_sums.add(new_sum) achievable_sums = new_sums return False"},{"question":"def longest_str_chain(words: List[str]) -> int: Given a list of unique strings \`words\`, return the length of the longest chain of words. A word w1 can be a predecessor of another word w2 if and only if w1 can be formed by removing exactly one character from w2 and the resulting word is in the original list. >>> longest_str_chain([\\"a\\", \\"b\\", \\"ba\\", \\"bca\\", \\"bda\\", \\"bdca\\"]) == 4 >>> longest_str_chain([\\"a\\", \\"b\\", \\"c\\"]) == 1 >>> longest_str_chain([\\"xbc\\", \\"pcxbcf\\", \\"xb\\", \\"cxbc\\", \\"pcxbc\\"]) == 5 >>> longest_str_chain([\\"abcd\\", \\"dbqca\\"]) == 1 >>> longest_str_chain([\\"a\\"]) == 1","solution":"def longest_str_chain(words): Given a list of unique strings \`words\`, return the length of the longest chain of words. A word w1 can be a predecessor of another word w2 if and only if w1 can be formed by removing exactly one character from w2 and the resulting word is in the original list. words.sort(key=len) # Sort by length dp = {} max_chain_length = 1 for word in words: dp[word] = 1 # Each word is at least a chain of length 1 for i in range(len(word)): prev = word[:i] + word[i+1:] if prev in dp: dp[word] = max(dp[word], dp[prev] + 1) max_chain_length = max(max_chain_length, dp[word]) return max_chain_length"},{"question":"def longest_increasing_path(matrix: List[List[int]]) -> int: Write a function to find the longest path in a matrix where each cell contains an integer. The path must increase at each step. You can move in four directions (up, down, left, right). Return the length of the longest path. >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([[]]) == 0 >>> longest_increasing_path([[1]]) == 1 >>> longest_increasing_path([ [9, 9, 4], [6, 6, 8], [2, 1, 1] ]) == 4 >>> longest_increasing_path([ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]) == 1 >>> longest_increasing_path([ [3, 4, 5], [3, 2, 6], [2, 2, 1] ]) == 4 >>> longest_increasing_path([ [1, 2, 3], [6, 5, 4], [7, 8, 9] ]) == 9","solution":"def longest_increasing_path(matrix): Finds the longest increasing path in a given matrix. Parameters: matrix (List[List[int]]): 2D list of integers representing the matrix. Returns: int: Length of the longest increasing path. if not matrix or not matrix[0]: return 0 def dfs(x, y): if cache[x][y] != -1: return cache[x][y] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and matrix[nx][ny] > matrix[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) cache[x][y] = max_length return max_length rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] cache = [[-1]*cols for _ in range(rows)] longest_path_length = 0 for r in range(rows): for c in range(cols): longest_path_length = max(longest_path_length, dfs(r, c)) return longest_path_length"},{"question":"from typing import List class minMutations: def __init__(self, start: str, goal: str, bank: List[str]): Initializes the minMutations class with start, goal, and bank. pass def getMinMutations(self) -> int: Returns the minimum number of mutations required to mutate start into goal, or -1 if not possible. pass def test_basic_case(): solution = minMutations(\\"AACCGGTT\\", \\"AACCGGTA\\", [\\"AACCGGTA\\"]) assert solution.getMinMutations() == 1 def test_no_possible_mutation(): solution = minMutations(\\"AACCGGTT\\", \\"AAACGGTA\\", [\\"AACCGGTA\\", \\"AACCGCTA\\", \\"AAACGGTT\\"]) assert solution.getMinMutations() == -1 def test_multiple_steps(): solution = minMutations(\\"AACCGGTT\\", \\"AAACGGTA\\", [\\"AACCGGTA\\", \\"AACCGCTA\\", \\"AAACGGTA\\"]) assert solution.getMinMutations() == 2 def test_goal_not_in_bank(): solution = minMutations(\\"AACCGGTT\\", \\"AAACGGTA\\", [\\"AACCGGTA\\", \\"AACCGCTA\\"]) assert solution.getMinMutations() == -1 def test_multiple_paths(): solution = minMutations(\\"AAAAACCC\\", \\"AACCCCCC\\", [\\"AAAACCCC\\", \\"AAACCCCC\\", \\"AACCCCCC\\"]) assert solution.getMinMutations() == 3 def test_identical_start_and_goal(): solution = minMutations(\\"AAAA\\", \\"AAAA\\", [\\"AAAA\\"]) assert solution.getMinMutations() == 0 def test_goal_immediately_reachable_and_in_bank(): solution = minMutations(\\"AAAA\\", \\"AAAC\\", [\\"AAAC\\"]) assert solution.getMinMutations() == 1","solution":"from collections import deque class minMutations: def __init__(self, start, goal, bank): self.start = start self.goal = goal self.bank = set(bank) # Using set for O(1) lookups def getMinMutations(self): if self.goal not in self.bank: return -1 def is_valid_mutation(current, next_str): count = 0 for c1, c2 in zip(current, next_str): if c1 != c2: count += 1 if count > 1: return False return count == 1 queue = deque([(self.start, 0)]) visited = set([self.start]) while queue: current, mutations = queue.popleft() if current == self.goal: return mutations for candidate in list(self.bank): if candidate not in visited and is_valid_mutation(current, candidate): visited.add(candidate) queue.append((candidate, mutations + 1)) return -1"},{"question":"from typing import List def max_non_overlapping(nums: List[int], k: int) -> int: Returns the maximum number of non-overlapping subarrays that sum up to k. >>> max_non_overlapping([1, 1, 1, 1, 1], 2) 2 >>> max_non_overlapping([-1, 3, 4, -2, -2, 5], 5) 2 >>> max_non_overlapping([1, 2, 3], 7) 0 >>> max_non_overlapping([5], 5) 1 >>> max_non_overlapping([1, 2, 3, 4, -2, -2, 5, 1, -1, 1], 3) 3 >>> max_non_overlapping([3, 3, 3, 3, 3], 3) 5 >>> max_non_overlapping([], 1) 0 >>> max_non_overlapping([1], 2) 0 # Implementation goes here","solution":"def maxNonOverlapping(nums, k): Returns the maximum number of non-overlapping subarrays that sum up to k. prefix_sums = {0} current_sum = 0 count = 0 for num in nums: current_sum += num if current_sum - k in prefix_sums: count += 1 prefix_sums = {0} current_sum = 0 else: prefix_sums.add(current_sum) return count"},{"question":"def countSubarraysWithProductLessThanK(arr, k): Given an integer array \`arr\`, return the number of subarrays where the product of all the elements in the subarray is less than \`k\`. Args: arr : List[int] - an array of integers k : int - positive integer Returns: int - count of subarrays with product less than \`k\` >>> countSubarraysWithProductLessThanK([10, 5, 2, 6], 100) == 8 >>> countSubarraysWithProductLessThanK([], 10) == 0 >>> countSubarraysWithProductLessThanK([1], 2) == 1 >>> countSubarraysWithProductLessThanK([2], 2) == 0 >>> countSubarraysWithProductLessThanK([3], 2) == 0 >>> countSubarraysWithProductLessThanK([1, 2, 3], 10) == 6 >>> countSubarraysWithProductLessThanK([1, 2, 3, 1000], 1000) == 6 >>> countSubarraysWithProductLessThanK([10, 20, 30], 5) == 0","solution":"def countSubarraysWithProductLessThanK(arr, k): if k <= 1: return 0 count = 0 product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product >= k: product //= arr[start] start += 1 count += end - start + 1 return count"},{"question":"def three_sum(nums, target): Determines if there are three integers in nums whose sum equals the target. Args: - nums: List of integers. - target: An integer representing the target sum. Returns: - A boolean, True if there exists three integers that sum up to the target, False otherwise. >>> three_sum([1, 2, 3, 4, 5], 9) True >>> three_sum([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum([1, 2, 3, 4, 5], 50) False >>> three_sum([1, 1, 1, 1, 1], 10) False >>> three_sum([0, -1, 2, -3, 1], -2) True >>> three_sum([], 0) False >>> three_sum([1, 1, 1, 2, 2, 2, -1, -1, -1], 2) True >>> three_sum([1, 1, 1, 1, 1], 3) True >>> three_sum([-4, -2, -7, -5, 0, 2, 6, 10], -11) True >>> three_sum([-10, -1, -2, -5, 6, 6, 0], -10) False","solution":"def three_sum(nums, target): Determines if there are three integers in nums whose sum equals the target. Args: - nums: List of integers. - target: An integer representing the target sum. Returns: - A boolean, True if there exists three integers that sum up to the target, False otherwise. nums.sort() n = len(nums) for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: # Skip duplicate elements continue left, right = i + 1, n - 1 while left < right: total = nums[i] + nums[left] + nums[right] if total == target: return True elif total < target: left += 1 else: right -= 1 return False"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Returns the maximum sum you can collect by traversing from the top-left to the bottom-right of the grid. Args: grid (List[List[int]]): 2D matrix of integers. Returns: int: Maximum sum from top-left to bottom-right. Example: >>> max_path_sum([[5, 3, 2, 1], [1, 2, 1, 1], [4, 2, 1, 2], [1, 1, 1, 4]]) 19 >>> max_path_sum([[1, 2], [1, 1]]) 4","solution":"def max_path_sum(grid): Returns the maximum sum you can collect by traversing from the top-left to the bottom-right of the grid. n = len(grid) # Create a dp matrix to store the max sum at each cell dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp matrix for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) # The bottom-right cell contains the maximum sum return dp[n-1][n-1]"},{"question":"def can_transform(start: str, end: str) -> bool: Given a start string and an end string of the same length, return True if you can transform start into end by changing each character in start to its subsequent or preceding character in the alphabet in a single pass. Otherwise, return False. >>> can_transform(\\"abc\\", \\"bcd\\") True >>> can_transform(\\"abc\\", \\"xyz\\") False >>> can_transform(\\"zab\\", \\"abc\\") True >>> can_transform(\\"axbycz\\", \\"bacd\\") False from solution import can_transform def test_can_transform_true(): assert can_transform(\\"abc\\", \\"bcd\\") == True def test_can_transform_false(): assert can_transform(\\"abc\\", \\"xyz\\") == False def test_can_transform_same_string(): assert can_transform(\\"abc\\", \\"abc\\") == True def test_can_transform_circular_forward(): assert can_transform(\\"zab\\", \\"abc\\") == True def test_can_transform_circular_backward(): assert can_transform(\\"abc\\", \\"zab\\") == True def test_can_transform_single_character(): assert can_transform(\\"a\\", \\"b\\") == True assert can_transform(\\"z\\", \\"a\\") == True def test_can_transform_different_length(): assert can_transform(\\"abcd\\", \\"abc\\") == False assert can_transform(\\"abc\\", \\"abcd\\") == False def test_can_transform_complex_failure(): assert can_transform(\\"axbycz\\", \\"bacd\\") == False assert can_transform(\\"mnomno\\", \\"opplq\\" ) == False def test_can_transform_complex_success(): assert can_transform(\\"abcdefghijklmnopqrstuvwxy\\", \\"bcdefghijklmnopqrstuvwxyz\\") == True","solution":"def can_transform(start, end): Returns True if the start string can be transformed into the end string character by character. if len(start) != len(end): return False for s, e in zip(start, end): if s == e: continue # Calculate distance in the alphabet (considering circular nature) forward_steps = (ord(e) - ord(s)) % 26 backward_steps = (ord(s) - ord(e)) % 26 if not (forward_steps == 1 or backward_steps == 1): return False return True"},{"question":"from typing import List def largest_good_subset_size(nums: List[int]) -> int: Returns the size of the largest subset of nums where the product of its elements is a perfect square. >>> largest_good_subset_size([4, 3, 9, 7, 16]) 3 >>> largest_good_subset_size([3, 7, 11]) 0 >>> largest_good_subset_size([1, 4, 9, 25, 36, 64]) 6 >>> largest_good_subset_size([4, 4, 4, 4, 4, 4, 4, 4]) 8 >>> largest_good_subset_size([1]) 1 >>> largest_good_subset_size([1, 1, 1, 1, 1, 1, 1, 1, 1]) 9 >>> largest_good_subset_size([4, 16, 25, 49, 64]) 5","solution":"from itertools import combinations import math def largest_good_subset_size(nums): Returns the size of the largest subset of nums where the product of its elements is a perfect square. def is_perfect_square(n): return int(math.isqrt(n)) ** 2 == n n = len(nums) max_size = 0 for r in range(1, n + 1): for subset in combinations(nums, r): product = math.prod(subset) if is_perfect_square(product): max_size = max(max_size, len(subset)) return max_size"},{"question":"def largest_rectangle_area(nums: List[int]) -> int: Finds the area of the largest rectangle that can be formed within the bounds of the histogram. :param nums: List of integers representing the heights of histogram bars :return: The maximum area of the rectangle >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) 9 >>> largest_rectangle_area([2, 2, 2, 2, 2]) 10 >>> largest_rectangle_area([3, 1, 3, 2, 2]) 6 >>> largest_rectangle_area([]) 0 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([5]) 5 >>> largest_rectangle_area([1, 1]) 2 >>> largest_rectangle_area([2, 1]) 2 >>> largest_rectangle_area([1, 2]) 2","solution":"def largest_rectangle_area(nums): Finds the area of the largest rectangle that can be formed within the bounds of the histogram. :param nums: List of integers representing the heights of histogram bars :return: The maximum area of the rectangle stack = [] max_area = 0 index = 0 while index < len(nums): if not stack or nums[stack[-1]] <= nums[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (nums[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> List[int]: Given an integer array \`nums\` and an integer \`target\`, return the indices of the first pair of distinct indices \`(i, j)\` such that their corresponding values add up to \`target\`. If there is no such pair, return an empty list. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 8) [] >>> two_sum([-1, -2, -3, -4], -6) [1, 3] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([1, 4, 5, 1, 5], 10) [2, 4] >>> two_sum([3, 3], 6) [0, 1]","solution":"def two_sum(nums, target): Returns indices of the two numbers such that they add up to target. If no such pair exists, returns an empty array. num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Return the number of distinct islands in the grid. Args: grid: a 2D grid of integers (0 for water, 1 for land) Returns: An integer representing the number of distinct islands. Examples: >>> numDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> numDistinctIslands([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) 1 >>> numDistinctIslands([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 >>> numDistinctIslands([[1, 0, 0], [0, 1, 1], [0, 1, 0]]) 2 >>> numDistinctIslands([[1, 0, 1], [1, 1, 1], [0, 1, 0]]) 1 >>> grid = [ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 1, 0, 0, 0], ... [0, 1, 1, 1, 0] ... ] >>> numDistinctIslands(grid) 3 from typing import List def test_no_islands(): assert numDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 def test_single_cell_island(): assert numDistinctIslands([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 1 def test_all_cells_island(): assert numDistinctIslands([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 1 def test_two_distinct_islands(): assert numDistinctIslands([[1, 0, 0], [0, 1, 1], [0, 1, 0]]) == 2 def test_identical_islands(): assert numDistinctIslands([[1, 0, 1], [1, 1, 1], [0, 1, 0]]) == 1 def test_complex_islands(): grid = [ [1, 1, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 1, 1], [0, 1, 0, 0, 0], [0, 1, 1, 1, 0] ] assert numDistinctIslands(grid) == 3 def test_rotated_island(): grid = [ [1, 0, 0], [1, 1, 0], [0, 1, 0] ] rotated_grid = [ [0, 0, 1], [0, 1, 1], [0, 1, 0] ] # Separate tests to treat them as distinct shapes in this simplified problem assert numDistinctIslands(grid) == 1 assert numDistinctIslands(rotated_grid) == 1","solution":"def numDistinctIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = set() distinct_islands = set() def dfs(r, c, pos, origin): stack = [(r, c, pos)] shape = [] while stack: curr_r, curr_c, pos = stack.pop() if (curr_r, curr_c) in visited or not (0 <= curr_r < rows and 0 <= curr_c < cols) or grid[curr_r][curr_c] == 0: continue visited.add((curr_r, curr_c)) shape.append((pos[0] - origin[0], pos[1] - origin[1])) for dr, dc, direction in [(1, 0, (1, 0)), (-1, 0, (-1, 0)), (0, 1, (0, 1)), (0, -1, (0, -1))]: stack.append((curr_r + dr, curr_c + dc, (pos[0] + direction[0], pos[1] + direction[1]))) return tuple(shape) for r in range(rows): for c in range(cols): if grid[r][c] == 1 and (r, c) not in visited: island_shape = dfs(r, c, (0, 0), (0, 0)) distinct_islands.add(island_shape) return len(distinct_islands)"},{"question":"def coinChange(coins: List[int], amount: int) -> int: Finds the minimum number of coins needed to make up the given amount. Returns -1 if the amount cannot be made up by any combination of the coins. >>> coinChange([1, 2, 5], 0) == 0 >>> coinChange([1, 2, 5], 1) == 1 >>> coinChange([1, 2, 5], 11) == 3 # 5 + 5 + 1 >>> coinChange([2], 3) == -1 >>> coinChange([1, 2, 5], 7) == 2 # 5 + 2 >>> coinChange([1, 2, 5], 100) == 20 # 5 * 20 >>> coinChange([1, 3, 4], 6) == 2 # 3 + 3 or 4 + 1 + 1 >>> coinChange([2, 3, 5], 8) == 2 # 3 + 5 >>> coinChange([5], 3) == -1 >>> coinChange([1, 5, 10, 25], 63) == 6 # 25 + 25 + 10 + 1 + 1 + 1","solution":"def coinChange(coins, amount): Finds the minimum number of coins needed to make up the given amount. Returns -1 if the amount cannot be made up by any combination of the coins. # Initialize DP table with a value greater than the highest possible number of coins needed dp = [float('inf')] * (amount + 1) dp[0] = 0 # Base case: 0 coins needed to make amount 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1"},{"question":"def min_initial_health(grid: List[List[int]]) -> int: Calculate the minimum initial health needed for the knight to traverse the dungeon. The knight can only move right or down and must keep his health above 0 at all times. >>> min_initial_health([ ... [-2, -3, 3], ... [-5, -10, 1], ... [10, 30, -5] ... ]) 7 >>> min_initial_health([ ... [1, -3, 3], ... [0, -2, 0], ... [-3, -3, -3] ... ]) 3 >>> min_initial_health([ ... [0, 0, 0], ... [1, 1, -1] ... ]) 1 >>> min_initial_health([ ... [5] ... ]) 1 >>> min_initial_health([ ... [-10] ... ]) 11","solution":"def min_initial_health(grid): Calculate the minimum initial health needed for the knight to traverse the dungeon. The knight can only move right or down and must keep his health above 0 at all times. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] # Bottom-right cell (target) dp[-1][-1] = max(1, 1 - grid[-1][-1]) # Last row (moving left) for j in range(n - 2, -1, -1): dp[-1][j] = max(1, dp[-1][j + 1] - grid[-1][j]) # Last column (moving up) for i in range(m - 2, -1, -1): dp[i][-1] = max(1, dp[i + 1][-1] - grid[i][-1]) # Fill the rest of the dp table for i in range(m - 2, -1, -1): for j in range(n - 2, -1, -1): min_health_on_exit = min(dp[i + 1][j], dp[i][j + 1]) dp[i][j] = max(1, min_health_on_exit - grid[i][j]) return dp[0][0]"},{"question":"def find_closest_numbers(arr, N, target): Returns a list of N integers from the sorted array \`arr\` that are closest to \`target\`. If there is a tie between two numbers, the smaller number is chosen. >>> find_closest_numbers([1, 2, 3, 4, 5], 4, 3) [1, 2, 3, 4] >>> find_closest_numbers([1, 2, 3, 4, 5], 4, -1) [1, 2, 3, 4] >>> find_closest_numbers([10, 15, 7, 3, 8], 3, 9) [7, 8, 10] >>> find_closest_numbers([20, 30, 40, 50, 60], 2, 25) [20, 30] >>> find_closest_numbers([1], 1, 0) [1]","solution":"def find_closest_numbers(arr, N, target): Returns a list of N integers from the sorted array \`arr\` that are closest to \`target\`. If there is a tie between two numbers, the smaller number is chosen. arr.sort() closest_numbers = sorted(arr, key=lambda x: (abs(x - target), x))[:N] return sorted(closest_numbers)"},{"question":"def find_max_average(arr: List[int], k: int) -> float: Given a list of integers \`arr\` and an integer \`k\`, return the maximum average of any contiguous subarray of length \`k\`. >>> find_max_average([1, 12, -5, -6, 50, 3], 4) 12.75 >>> find_max_average([1, 12, -5, -6, 50, 3], 6) 9.166666666666666 >>> find_max_average([4, 2, 1, 3, 5], 2) 4 >>> find_max_average([4, 2, 1, 3, 5], 3) 3 >>> find_max_average([-1, -2, -3, -4, -5], 2) -1.5","solution":"def find_max_average(arr, k): Returns the maximum average of any contiguous subarray of length k. Parameters: arr (list of int): The input list of integers. k (int): The length of the subarray. Returns: float: The maximum average of any contiguous subarray of length k. if not arr or k <= 0 or k > len(arr): return 0.0 # Calculate the sum of the first k elements. current_sum = sum(arr[:k]) max_sum = current_sum # Use a sliding window to find the maximum sum of any contiguous subarray of length k. for i in range(k, len(arr)): current_sum = current_sum - arr[i - k] + arr[i] max_sum = max(max_sum, current_sum) # Return the maximum average return max_sum / k"},{"question":"def shortest_subarray_with_sum_at_least_k(arr, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. pass def test_case_1(): assert shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 11) == 3 def test_case_2(): assert shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 15) == 5 def test_case_3(): assert shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 6) == 2 def test_case_4(): assert shortest_subarray_with_sum_at_least_k([1, 1, 1, 1, 1, 1, 1], 10) == -1 def test_case_5(): assert shortest_subarray_with_sum_at_least_k([10, 2, 3], 10) == 1 def test_case_6(): assert shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 8) == 2 def test_case_7(): assert shortest_subarray_with_sum_at_least_k([1, 2, 3, 4, 5], 1) == 1 def test_case_8(): assert shortest_subarray_with_sum_at_least_k([5, 1, 3], 5) == 1","solution":"def shortest_subarray_with_sum_at_least_k(arr, k): Returns the length of the shortest subarray with sum at least k. If no such subarray exists, returns -1. n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= k: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Recursively removes adjacent duplicate characters in the string \`s\` and returns the final string after all such duplicate removals have been made. :param s: Input string consisting of lowercase English letters :type s: str :return: String after removing all adjacent duplicates :rtype: str >>> remove_adjacent_duplicates(\\"abbaca\\") == \\"ca\\" >>> remove_adjacent_duplicates(\\"abcdef\\") == \\"abcdef\\" >>> remove_adjacent_duplicates(\\"a\\") == \\"a\\" >>> remove_adjacent_duplicates(\\"aa\\") == \\"\\" >>> remove_adjacent_duplicates(\\"aabbaacc\\") == \\"\\" >>> remove_adjacent_duplicates(\\"azxxzy\\") == \\"ay\\" >>> remove_adjacent_duplicates(\\"\\") == \\"\\" >>> remove_adjacent_duplicates(\\"abcde\\") == \\"abcde\\"","solution":"def remove_adjacent_duplicates(s): Recursively removes adjacent duplicate characters in the string \`s\` and returns the final string after all such duplicate removals have been made. :param s: Input string consisting of lowercase English letters :type s: str :return: String after removing all adjacent duplicates :rtype: str # Base case: if the string is empty or has only one character, return it as is if len(s) <= 1: return s # Use a stack to process the string stack = [] for char in s: if stack and stack[-1] == char: stack.pop() # Remove the last character if it is the same as the current one else: stack.append(char) # Convert the stack back to a string result = ''.join(stack) return result"},{"question":"def longest_concat_word(words: List[str]) -> str: Returns the longest string in the list that can be formed by concatenating other words from the list exactly once. In case of a tie, the lexicographically smallest word is returned. If no such string exists, returns an empty string. >>> longest_concat_word([\\"cat\\", \\"bat\\", \\"rat\\", \\"catbat\\"]) == \\"catbat\\" >>> longest_concat_word([\\"cat\\", \\"dog\\", \\"fish\\"]) == \\"\\" >>> longest_concat_word([\\"a\\", \\"b\\", \\"aabb\\", \\"ab\\"]) == \\"ab\\" >>> longest_concat_word([\\"ab\\", \\"cd\\", \\"abcd\\", \\"ef\\", \\"efcd\\", \\"cdef\\", \\"cdefab\\"]) == \\"cdefab\\" >>> longest_concat_word([\\"a\\", \\"b\\", \\"ab\\", \\"ba\\"]) == \\"ab\\" >>> longest_concat_word([]) == \\"\\"","solution":"def get_candidates(words): # This helper function generates all possible concatenations of the given words. candidates = set() for i in range(len(words)): for j in range(len(words)): if i != j: candidates.add(words[i] + words[j]) return candidates def longest_concat_word(words): Returns the longest string in the list that can be formed by concatenating other words from the list exactly once. In case of a tie, the lexicographically smallest word is returned. If no such string exists, returns an empty string. candidates = get_candidates(words) valid_words = [word for word in words if word in candidates] if not valid_words: return \\"\\" valid_words.sort(key=lambda x: (-len(x), x)) return valid_words[0]"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumEvenGrandparent(root): Return the sum of the values of all nodes with an even-valued grandparent. >>> root = TreeNode(2) >>> sumEvenGrandparent(root) 0 >>> root = TreeNode(2) >>> root.left = TreeNode(3) >>> root.right = TreeNode(4) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(7) >>> sumEvenGrandparent(root) 13 >>> root = TreeNode(6) >>> root.left = TreeNode(7) >>> root.right = TreeNode(8) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(7) >>> root.right.left = TreeNode(1) >>> root.right.right = TreeNode(3) >>> root.left.left.left = TreeNode(9) >>> root.left.right.left = TreeNode(1) >>> root.left.right.right = TreeNode(4) >>> root.right.right.right = TreeNode(5) >>> sumEvenGrandparent(root) 18 pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def sumEvenGrandparent(root): def dfs(node, parent, grandparent): if not node: return 0 sum_left = dfs(node.left, node, parent) sum_right = dfs(node.right, node, parent) sum_current = 0 if grandparent and grandparent.val % 2 == 0: sum_current += node.val return sum_current + sum_left + sum_right return dfs(root, None, None)"},{"question":"def minimize_replacements(s: str) -> int: Given a string consisting of characters 'a', 'b', and 'c', this function returns the minimum number of replacements needed to ensure that no three consecutive characters are the same. >>> minimize_replacements(\\"abcabc\\") == 0 >>> minimize_replacements(\\"ababab\\") == 0 >>> minimize_replacements(\\"acbacb\\") == 0 >>> minimize_replacements(\\"aaab\\") == 1 >>> minimize_replacements(\\"abccc\\") == 1 >>> minimize_replacements(\\"aaaa\\") == 1 >>> minimize_replacements(\\"aaaabaaa\\") == 2 >>> minimize_replacements(\\"aaaacccc\\") == 2 >>> minimize_replacements(\\"aaa\\") == 1 >>> minimize_replacements(\\"aaaaaa\\") == 2 >>> minimize_replacements(\\"\\") == 0 >>> minimize_replacements(\\"a\\") == 0 >>> minimize_replacements(\\"aa\\") == 0 >>> minimize_replacements(\\"aaa\\") == 1 pass","solution":"def minimize_replacements(s): Given a string consisting of characters 'a', 'b', and 'c', this function returns the minimum number of replacements needed to ensure that no three consecutive characters are the same. if len(s) < 3: return 0 replacements = 0 s = list(s) for i in range(2, len(s)): if s[i] == s[i-1] == s[i-2]: replacements += 1 # Choose a different character that is not equal to the previous two characters for replacement in 'abc': if replacement != s[i-1]: s[i] = replacement break return replacements"},{"question":"def can_win(nums, target): Determines if it is possible to win the game by coloring numbers in nums such that their sum equals target. >>> can_win([2, 3, 4, 9], 7) == False >>> can_win([2, 3, 5, 7], 10) == False >>> can_win([2, 4, 8, 16], 12) == True >>> can_win([4, 6, 15, 35], 10) == True >>> can_win([1, 30, 25, 15], 55) == True","solution":"from math import gcd def can_win(nums, target): Determines if it is possible to win the game by coloring numbers in nums such that their sum equals target. n = len(nums) dp = [False] * (target + 1) def helper(available_nums, cur_sum): if cur_sum == target: return True if cur_sum > target: return False for i, num in enumerate(available_nums): if cur_sum + num <= target: next_available_nums = [x for j, x in enumerate(available_nums) if j != i and gcd(x, num) > 1] if helper(next_available_nums, cur_sum + num): return True return False for num in nums: if helper([x for x in nums if x != num and gcd(x, num) > 1], num): return True return False"},{"question":"class Solution: def __init__(self, words, order): Initializes the object with the list of \`words\` and the lexicographical \`order\` of the alien language. >>> solution = Solution([\\"hello\\", \\"leetcode\\"], \\"hlabcdefgijkmnopqrstuvwxyz\\") >>> solution.isAlienSorted() True >>> solution = Solution([\\"word\\", \\"world\\", \\"row\\"], \\"worldabcefghijkmnpqstuvxyz\\") >>> solution.isAlienSorted() False pass def isAlienSorted(self): Returns \`true\` if the \`words\` are sorted according to the given \`order\`, otherwise returns \`false\`. pass","solution":"class Solution: def __init__(self, words, order): self.words = words self.order = order self.order_map = {char: index for index, char in enumerate(order)} def isAlienSorted(self): def compare(word1, word2): i = 0 while i < len(word1) and i < len(word2): if word1[i] != word2[i]: return self.order_map[word1[i]] - self.order_map[word2[i]] i += 1 return len(word1) - len(word2) for i in range(len(self.words) - 1): if compare(self.words[i], self.words[i + 1]) > 0: return False return True"},{"question":"def longestDistinctivelySpacedSubsequence(arr: List[int], d: int) -> int: Find the length of the longest distinctively spaced subsequence among all possible subsequences of the given array. A subsequence is called distinctively spaced if the difference between any two consecutive elements is at least d. >>> longestDistinctivelySpacedSubsequence([1], 1) == 1 >>> longestDistinctivelySpacedSubsequence([1, 3, 6, 10], 2) == 4 >>> longestDistinctivelySpacedSubsequence([1, 2, 3, 4, 5], 2) == 3 >>> longestDistinctivelySpacedSubsequence([1, 10, 20写道:丢掉年度最有价值球员的我们，还会再拿到冠军吗？”的内容--- def longestDistinctivelySpacedSubsequence(arr: List[int], d: int) -> int: Given an integer array \`arr\` and an integer \`d\`, return the length of the longest distinctively spaced subsequence among all possible subsequences of \`arr\`. A subsequence is distinctively spaced if the difference between any two consecutive elements is at least \`d\`. >>> longestDistinctivelySpacedSubsequence([1], 1) 1 >>> longestDistinctivelySpacedSubsequence([1, 3, 6, 10], 2) 4 >>> longestDistinctivelySpacedSubsequence([1, 2, 3, 4, 5], 2) 3 >>> longestDistinctivelySpacedSubsequence([1, 10, 20, 30], 5) 4 >>> longestDistinctivelySpacedSubsequence([1, 10, 9, 8, 7], 1) 5 >>> longestDistinctivelySpacedSubsequence([], 1) 0","solution":"def longestDistinctivelySpacedSubsequence(arr, d): n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest distinctively spaced subsequence ending at index i dp = [1] * n # Iterate through each element to find a valid distinctively spaced subsequence for i in range(n): for j in range(i): if abs(arr[i] - arr[j]) >= d: dp[i] = max(dp[i], dp[j] + 1) # The result is the maximum value in dp array return max(dp)"},{"question":"def max_non_overlapping_events(records): Returns the maximum number of non-overlapping events that can be attended. Each record is represented as a list containing exactly two integers, [start, end]. >>> max_non_overlapping_events([]) == 0 >>> max_non_overlapping_events([[1, 2]]) == 1 >>> max_non_overlapping_events([[1, 2], [3, 4], [5, 6]]) == 3 >>> max_non_overlapping_events([[1, 3], [2, 4], [3, 5], [4, 6]]) == 2 >>> max_non_overlapping_events([[1, 3], [3, 5], [2, 6], [4, 7]]) == 2 >>> max_non_overlapping_events([[1, 2], [2, 3], [3, 4], [1, 2], [2, 3]]) == 3","solution":"def max_non_overlapping_events(records): Returns the maximum number of non-overlapping events that can be attended. Each record is represented as a list containing exactly two integers, [start, end]. if not records: return 0 # Sort the events by their end time. records.sort(key=lambda x: x[1]) # Initialize the end time of the last attended event to a very small value. last_end_time = float('-inf') count = 0 for start, end in records: if start >= last_end_time: # If the current event starts after or when the last attended event ends, attend it. last_end_time = end count += 1 return count"},{"question":"def min_cost_path(matrix): Find the minimum cost path from top-left to bottom-right in a grid where you can only move right or down. :param matrix: List of Lists of integers representing the cost grid :return: Integer representing the minimum cost to reach the bottom-right corner >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2], [1, 1]]) 3 >>> min_cost_path([]) 0 >>> min_cost_path([[2]]) 2","solution":"def min_cost_path(matrix): Find the minimum cost path from top-left to bottom-right in a grid where you can only move right or down. :param matrix: List of Lists of integers representing the cost grid :return: Integer representing the minimum cost to reach the bottom-right corner if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) # Create a DP table to store the minimum cost path dp = [[0] * cols for _ in range(rows)] dp[0][0] = matrix[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the DP table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[rows-1][cols-1]"},{"question":"def min_operations_to_empty_string(s: str) -> int: Calculate and return the minimum number of operations needed to make the string \`s\` empty. The string \`s\` consists of only characters \\"A\\" and \\"B\\". >>> min_operations_to_empty_string('') == 0 >>> min_operations_to_empty_string('AAAA') == 1 >>> min_operations_to_empty_string('BBBB') == 1 >>> min_operations_to_empty_string('ABABAB') == 6 >>> min_operations_to_empty_string('BABA') == 4 >>> min_operations_to_empty_string('AAABBB') == 2 >>> min_operations_to_empty_string('AABBBBBBAAAB') == 4 >>> min_operations_to_empty_string('AAABBBAAABBB') == 4 >>> min_operations_to_empty_string('ABBABBAAABBB') == 6 >>> min_operations_to_empty_string('ABABABBABA') == 9","solution":"def min_operations_to_empty_string(s): Returns the minimum number of operations needed to make the string \`s\` empty. if not s: # if the string is empty return 0 # Count the number of contiguous blocks of characters count_blocks = 1 for i in range(1, len(s)): if s[i] != s[i - 1]: count_blocks += 1 return count_blocks"},{"question":"from typing import List def three_sum(nums: List[int], target: int) -> bool: Determines if there exist three elements in nums whose sum is exactly equal to target. Args: nums (list of int): List of integers. target (int): Target sum. Returns: bool: True if there exist three elements in nums whose sum is exactly equal to target, otherwise False. >>> three_sum([1, 2, 3, 4, 5], 12) True >>> three_sum([1, 2, 3, 7, 5], 15) True >>> three_sum([1, 2, 3, 4, 5], 20) False >>> three_sum([1, 2, -3, 4, 5], 3) True >>> three_sum([1, 1, 1], 3) True >>> three_sum([], 0) False >>> three_sum([1], 1) False","solution":"from itertools import combinations def three_sum(nums, target): Determines if there exist three elements in nums whose sum is exactly equal to target. Args: nums (list of int): List of integers. target (int): Target sum. Returns: bool: True if there exist three elements in nums whose sum is exactly equal to target, otherwise False. for comb in combinations(nums, 3): if sum(comb) == target: return True return False"},{"question":"def is_repeating(s: str, queries: List[List[int]]) -> List[bool]: Determines if substrings specified by queries in the given string s are repeating. Args: s (str): The input string. queries (list of lists): List of queries with each query containing [start, end]. Returns: list of bool: List of boolean values indicating if the substrings are repeating. >>> is_repeating(\\"abab\\", [[0, 3]]) == [True] >>> is_repeating(\\"abcd\\", [[0, 3]]) == [False] >>> is_repeating(\\"abcabcabc\\", [[0, 8], [0, 5], [3, 5]]) == [True, True, False] >>> is_repeating(\\"a\\", [[0, 0]]) == [False] >>> is_repeating(\\"aaa\\", [[0, 2], [1, 2]]) == [True, True] >>> is_repeating(\\"ababab\\", [[0, 5]]) == [True] >>> is_repeating(\\"ababab\\", [[0, 3]]) == [True] >>> is_repeating(\\"abcdabc\\", [[0, 6]]) == [False]","solution":"def is_repeating(s, queries): Determines if substrings specified by queries in the given string s are repeating. Args: s (str): The input string. queries (list of lists): List of queries with each query containing [start, end]. Returns: list of bool: List of boolean values indicating if the substrings are repeating. def check_repeating(substring): sub_len = len(substring) for i in range(1, sub_len//2 + 1): if sub_len % i == 0: if substring[:i] * (sub_len // i) == substring: return True return False result = [] for query in queries: start, end = query substring = s[start:end + 1] result.append(check_repeating(substring)) return result"},{"question":"from typing import List def subset_sum(nums: List[int], target: int) -> bool: Determine if there exists a subset of \`nums\` that adds up to \`target\` and contains at least 2 elements. Example: >>> subset_sum([2, 3, 5], 5) True >>> subset_sum([5], 5) False","solution":"from itertools import combinations def subset_sum(nums, target): Determine if there exists a subset of \`nums\` that adds up to \`target\` and contains at least 2 elements. if len(nums) < 2: return False # If there are fewer than 2 elements, it's impossible # Check all possible subsets of length 2 or more for r in range(2, len(nums) + 1): for subset in combinations(nums, r): if sum(subset) == target: return True return False"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcde\\") 5 >>> length_of_longest_substring(\\"aaaaaa\\") 1 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"abc123abc\\") 6","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_set = set() left = 0 max_len = 0 for right in range(len(s)): while s[right] in char_set: char_set.remove(s[left]) left += 1 char_set.add(s[right]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_sum_k_elements(nums, k): Returns the maximum sum possible by selecting k elements from nums. If k is greater than the length of nums or nums is empty, return 0. >>> max_sum_k_elements([4, 1, 3, 2, 5], 2) 9 >>> max_sum_k_elements([5, 7, 9, 1, 3], 3) 21 >>> max_sum_k_elements([3, 1, 2], 5) 6 >>> max_sum_k_elements([], 3) 0 >>> max_sum_k_elements([1, 2, 3], 0) 0 >>> max_sum_k_elements([8, 2, 3], 3) 13 >>> max_sum_k_elements([5, 6, 1], -1) 0 >>> max_sum_k_elements([7, 8, 9], 0) 0 pass","solution":"def max_sum_k_elements(nums, k): Returns the maximum sum possible by selecting k elements from nums. If k is greater than the length of nums or nums is empty, return 0. if not nums or k <= 0: return 0 if k >= len(nums): return sum(nums) nums.sort(reverse=True) return sum(nums[:k])"},{"question":"def blocked_views(heights: List[int]) -> int: Determines the number of buildings that have their view partially or completely blocked by the shadows of taller buildings to their left. Parameters: heights (list of int): List of heights of buildings along a street. Returns: int: Number of buildings with blocked views. >>> blocked_views([]) == 0 >>> blocked_views([1, 2, 3, 4, 5]) == 0 >>> blocked_views([5, 4, 3, 2, 1]) == 4 >>> blocked_views([3, 1, 4, 2, 5]) == 2 >>> blocked_views([1, 3, 2, 4, 3, 5]) == 2 >>> blocked_views([1, 1, 1, 1]) == 3 >>> blocked_views([5]) == 0 >>> blocked_views([3, 3, 3, 3, 3]) == 4","solution":"def blocked_views(heights): Determines the number of buildings that have their view partially or completely blocked by the shadows of taller buildings to their left. Parameters: heights (list of int): List of heights of buildings along a street. Returns: int: Number of buildings with blocked views. max_height_so_far = 0 blocked_count = 0 for height in heights: if height <= max_height_so_far: blocked_count += 1 else: max_height_so_far = height return blocked_count"},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Given a list of \`n\` integers, return the length of the longest consecutive sequence of numbers. The sequence can be in any order but must consist of consecutive integers. Examples: >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([1, 2, 3, 4, 5]) 5 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([3, 9, 1, 4, 7, 2, 8, 6, 5]) 9 >>> longest_consecutive_sequence([1, -1, 0, 2, -2, 3, -3, 4, -4]) 9 >>> longest_consecutive_sequence([]) 0","solution":"def longest_consecutive_sequence(nums): if not nums: return 0 nums_set = set(nums) max_length = 0 for num in nums_set: if num - 1 not in nums_set: current_num = num current_length = 1 while current_num + 1 in nums_set: current_num += 1 current_length += 1 max_length = max(max_length, current_length) return max_length"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Returns the indices of the two numbers in 'nums' such that their sum is equal to 'target'. Args: nums (List[int]): A list of integers sorted in non-decreasing order. target (int): The target sum for which we need to find indices. Returns: List[int]: A list containing the two indices, or an empty list if no such indices exist. >>> two_sum([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [] >>> two_sum([-1, 0], -1) [0, 1] pass","solution":"def two_sum(nums, target): Returns the indices of the two numbers in 'nums' such that their sum is equal to 'target'. Args: nums (List[int]): A list of integers sorted in non-decreasing order. target (int): The target sum for which we need to find indices. Returns: List[int]: A list containing the two indices, or an empty list if no such indices exist. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"from typing import List def walls_and_gates(rooms: List[List[int]]) -> None: Given a m x n 2D grid initialized with the possible values: - \`-1\` for a wall or an obstacle, - \`0\` for a gate, - \`2147483647\` (2^31 - 1) for an empty room. Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave it as \`2147483647\`. >>> grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] >>> walls_and_gates(grid) >>> grid [[3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4]] # TODO: Implement this function def test_walls_and_gates_example(): grid = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] expected = [ [3, -1, 0, 1], [2, 2, 1, -1], [1, -1, 2, -1], [0, -1, 3, 4] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_empty_grid(): grid = [] expected = [] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_no_gates(): grid = [ [2147483647, -1, 2147483647, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [2147483647, -1, 2147483647, 2147483647] ] expected = [ [2147483647, -1, 2147483647, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [2147483647, -1, 2147483647, 2147483647] ] walls_and_gates(grid) assert grid == expected def test_walls_and_gates_all_walls(): grid = [ [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1] ] expected = [ [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1] ] walls_and_gates(grid) assert grid == expected","solution":"from collections import deque def walls_and_gates(rooms): if not rooms or not rooms[0]: return m, n = len(rooms), len(rooms[0]) gates = [(i, j) for i in range(m) for j in range(n) if rooms[i][j] == 0] queue = deque(gates) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"def get_skyline(heights: List[int]) -> List[List[int]]: Returns the skyline formed by the buildings represented by their heights. >>> get_skyline([3, 1, 4, 2]) [[0, 3], [1, 1], [2, 4], [3, 2]] >>> get_skyline([5]) [[0, 5]] >>> get_skyline([4, 6]) [[0, 4], [1, 6]] >>> get_skyline([1, 2, 3, 4]) [[0, 1], [1, 2], [2, 3], [3, 4]] >>> get_skyline([4, 3, 2, 1]) [[0, 4], [1, 3], [2, 2], [3, 1]]","solution":"def get_skyline(heights): Returns the skyline formed by the buildings represented by their heights. n = len(heights) key_points = [] for i in range(n): key_points.append([i, heights[i]]) return key_points"},{"question":"def product_except_self(arr): Given an array of integers \`arr\`, return an array where each element \`i\` is replaced by the product of all other elements in \`arr\` except \`arr[i]\`. You must solve it without using division and in linear time. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 2, 0, 4]) == [0, 0, 8, 0] >>> product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] >>> product_except_self([4]) == [1] >>> product_except_self([3, 5]) == [5, 3] >>> product_except_self([-1, 2, -3, 4]) == [-24, 12, -8, 6] >>> product_except_self([sys.maxsize, 1, 2]) == [2, sys.maxsize * 2, sys.maxsize] >>> product_except_self([]) == []","solution":"def product_except_self(arr): n = len(arr) if n == 0: return [] left_products = [1] * n right_products = [1] * n result = [1] * n # Compute left running product for each element for i in range(1, n): left_products[i] = left_products[i-1] * arr[i-1] # Compute right running product for each element for i in range(n-2, -1, -1): right_products[i] = right_products[i+1] * arr[i+1] # Combine them to get the final result for i in range(n): result[i] = left_products[i] * right_products[i] return result"},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Given a list of intervals, this function merges all overlapping intervals and returns a list of the merged intervals sorted by the starting points. >>> merge_intervals([[1, 2], [3, 4]]) [[1, 2], [3, 4]] >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 3], [2, 5], [4, 8], [5, 6], [7, 9]]) [[1, 9]] >>> merge_intervals([[5, 7]]) [[5, 7]] >>> merge_intervals([[6, 8], [1, 3], [2, 4], [7, 9]]) [[1, 4], [6, 9]] >>> merge_intervals([]) []","solution":"def merge_intervals(intervals): Given a list of intervals, this function merges all overlapping intervals and returns a list of the merged intervals sorted by the starting points. if not intervals: return [] # Sort intervals by start time, and if equal then by end time intervals.sort(key=lambda x: (x[0], x[1])) merged = [intervals[0]] for current in intervals[1:]: previous = merged[-1] if current[0] <= previous[1]: # Overlapping intervals # Merge the intervals merged[-1] = [previous[0], max(previous[1], current[1])] else: merged.append(current) return merged"},{"question":"def can_form_morphism(s1: str, s2: str) -> bool: Determines if a one-to-one mapping exists between the characters of s1 and s2. :param s1: First string. :param s2: Second string. :return: Boolean - True if a valid morphism exists, otherwise False. >>> can_form_morphism(\\"abc\\", \\"abc\\") True >>> can_form_morphism(\\"abc\\", \\"def\\") True >>> can_form_morphism(\\"aab\\", \\"xyz\\") False >>> can_form_morphism(\\"abc\\", \\"xxy\\") False >>> can_form_morphism(\\"foo\\", \\"bar\\") False >>> can_form_morphism(\\"paper\\", \\"title\\") True >>> can_form_morphism(\\"eggs\\", \\"addd\\") False >>> can_form_morphism(\\"a\\", \\"aa\\") False >>> can_form_morphism(\\"\\", \\"\\") True","solution":"def can_form_morphism(s1, s2): Determines if a one-to-one mapping exists between the characters of s1 and s2. :param s1: First string. :param s2: Second string. :return: Boolean - True if a valid morphism exists, otherwise False. # A one-to-one morphism can exist if both strings have unique characters mapped uniquely if len(s1) != len(s2): return False mapping_s1_to_s2 = {} mapping_s2_to_s1 = {} for char1, char2 in zip(s1, s2): if char1 in mapping_s1_to_s2: if mapping_s1_to_s2[char1] != char2: return False else: mapping_s1_to_s2[char1] = char2 if char2 in mapping_s2_to_s1: if mapping_s2_to_s1[char2] != char1: return False else: mapping_s2_to_s1[char2] = char1 return True"},{"question":"def smallest_number(nums): Given a list of non-negative integers \`nums\`, represented as strings, return the smallest number possible when these numbers are concatenated together. If the result starts with zeroes (e.g., \\"00032\\"), the leading zeroes should be removed, and only \\"32\\" should be returned. If the final result is \\"0\\", return \\"0\\". >>> smallest_number([\\"5\\"]) '5' >>> smallest_number([\\"0\\"]) '0' >>> smallest_number([\\"3\\", \\"30\\", \\"34\\", \\"5\\", \\"9\\"]) '3033459' >>> smallest_number([\\"10\\", \\"2\\"]) '102' >>> smallest_number([\\"1\\", \\"11\\", \\"111\\"]) '111111' >>> smallest_number([\\"00\\", \\"0\\"]) '0' >>> smallest_number([\\"30\\", \\"3\\", \\"34\\", \\"5\\", \\"9\\", \\"0\\"]) '3033459' >>> smallest_number([\\"000\\", \\"1\\", \\"0000\\"]) '1' >>> smallest_number([\\"0\\", \\"0\\", \\"0\\", \\"0\\"]) '0' >>> smallest_number([\\"12\\", \\"121\\"]) '12112' >>> smallest_number([\\"128\\", \\"12\\"]) '12128' >>> smallest_number([\\"128\\", \\"1288\\"]) '1281288'","solution":"from functools import cmp_to_key def compare(x, y): Custom comparator function to order strings based on their concatenated result. If 'xy' < 'yx', then 'x' should come before 'y', otherwise 'y' should come before 'x'. if x + y < y + x: return -1 elif x + y > y + x: return 1 else: return 0 def smallest_number(nums): Returns the smallest number possible from the concatenation of the strings in nums. # Sort \`nums\` based on the custom comparator nums_sorted = sorted(nums, key=cmp_to_key(compare)) # Concatenate the sorted numbers result = ''.join(nums_sorted) # Strip leading zeroes result = result.lstrip('0') # Return '0' if the result is empty, otherwise return the result return result if result else '0'"},{"question":"from typing import Dict def countAtoms(formula: str) -> Dict[str, int]: You are given a string formula representing a chemical formula, and you need to return a dictionary that stores the count of each atom in the formula. The formula will contain element names, which start with uppercase characters and may be followed by lowercase characters, and possibly numeric subscripts indicating the number of atoms. For nested parts of the formula enclosed in parentheses, the entire group can have a subscript following it, which multiplies the count of each atom in the group. >>> countAtoms(\\"H2O\\") == {\\"H\\": 2, \\"O\\": 1} >>> countAtoms(\\"Mg(OH)2\\") == {\\"Mg\\": 1, \\"O\\": 2, \\"H\\": 2} >>> countAtoms(\\"K4(ON(SO3)2)2\\") == {\\"K\\": 4, \\"O\\": 14, \\"N\\": 2, \\"S\\": 4}","solution":"import re from collections import defaultdict def countAtoms(formula): def multiply_counts(multi_dict, multiplier): return {k: v * multiplier for k, v in multi_dict.items()} def merge_counts(main_dict, temp_dict): for key, value in temp_dict.items(): main_dict[key] += value def parse_formula(f): stack = [] current_dict = defaultdict(int) i, n = 0, len(f) while i < n: if f[i] == '(': stack.append(current_dict) current_dict = defaultdict(int) i += 1 elif f[i] == ')': i += 1 i_start = i while i < n and f[i].isdigit(): i += 1 multiplier = int(f[i_start:i] or 1) temp_dict = multiply_counts(current_dict, multiplier) current_dict = stack.pop() merge_counts(current_dict, temp_dict) else: i_start = i i += 1 while i < n and f[i].islower(): i += 1 element = f[i_start:i] i_start = i while i < n and f[i].isdigit(): i += 1 count = int(f[i_start:i] or 1) current_dict[element] += count return current_dict return dict(parse_formula(formula))"},{"question":"def partition_subset(arr, x): Partition the array into two subsets such that the sum of elements in subset one is greater than or equal to x, and the number of elements in subset one is minimized. Parameters: arr (list of int): The input array of integers. x (int): The required sum of subset one. Returns: list of int: The elements of subset one that meet the criteria. pass # Example test cases from solution import partition_subset def test_partition_exact_sum(): arr = [3, 1, 4, 1, 5] x = 9 result = partition_subset(arr, x) assert sum(result) >= x assert len(result) == 2 # Example: [5, 4] def test_partition_more_than_sum(): arr = [2, 2, 3, 3, 4, 5] x = 10 result = partition_subset(arr, x) assert sum(result) >= x assert len(result) == 3 # Example: [5, 4, 3] def test_partition_single_element(): arr = [4] x = 4 result = partition_subset(arr, x) assert sum(result) >= x assert len(result) == 1 # Example: [4] def test_partition_no_element(): arr = [1, 1, 2, 2] x = 10 result = partition_subset(arr, x) assert sum(result) < x # No subset can sum to 10 or more def test_partition_with_repetition(): arr = [9, 7, 7, 4, 4, 1] x = 15 result = partition_subset(arr, x) assert sum(result) >= x assert len(result) == 2 # Example: [9, 7]","solution":"def partition_subset(arr, x): Partition the array into two subsets such that the sum of elements in subset one is greater than or equal to x, and the number of elements in subset one is minimized. Parameters: arr (list of int): The input array of integers. x (int): The required sum of subset one. Returns: list of int: The elements of subset one that meet the criteria. # Sort the array in descending order to get the largest numbers first arr.sort(reverse=True) subset = [] current_sum = 0 for num in arr: if current_sum >= x: break subset.append(num) current_sum += num return subset"},{"question":"def search_in_rotated_array(nums, target): Searches for target in a rotated sorted array. Params: nums: List[int] - a list of integers sorted in ascending order but rotated at some unknown pivot target: int - integer target to be searched Returns: bool - True if target is found, False otherwise >>> search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) True >>> search_in_rotated_array([6, 7, 1, 2, 3, 4, 5], 4) True >>> search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) False pass # implement the function def test_target_found_in_rotated_array(): assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) == True assert search_in_rotated_array([6, 7, 1, 2, 3, 4, 5], 4) == True assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 7) == True def test_target_not_found_in_rotated_array(): assert search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) == False assert search_in_rotated_array([6, 7, 1, 2, 3, 4, 5], 8) == False assert search_in_rotated_array([1], 0) == False def test_single_element_array(): assert search_in_rotated_array([1], 1) == True assert search_in_rotated_array([], 1) == False def test_target_found_in_non_rotated_array(): assert search_in_rotated_array([1, 2, 3, 4, 5, 6, 7, 8], 5) == True assert search_in_rotated_array([1, 2, 3, 4, 5, 6, 7, 8], 1) == True def test_target_not_found_in_non_rotated_array(): assert search_in_rotated_array([1, 2, 3, 4, 5, 6, 7, 8], 0) == False assert search_in_rotated_array([1, 2, 3, 4, 5, 6, 7, 8], 9) == False","solution":"def search_in_rotated_array(nums, target): Searches for target in a rotated sorted array. Params: nums: List[int] - a list of integers target: int - integer target to be searched Returns: bool - True if target is found, False otherwise if not nums: return False left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return True # If left part is sorted if nums[left] <= nums[mid]: if nums[left] <= target < nums[mid]: right = mid - 1 else: left = mid + 1 # If right part is sorted else: if nums[mid] < target <= nums[right]: left = mid + 1 else: right = mid - 1 return False"},{"question":"def min_transformations(s1: str, s2: str) -> int: Determine the minimum number of transformations required to change s1 into s2, or -1 if it is not possible to transform s1 into s2. Args: s1 (str): Source string s2 (str): Target string Returns: int: The minimum number of transformations, or -1 if not possible. Test cases: >>> min_transformations(\\"abc\\", \\"abc\\") 0 >>> min_transformations(\\"abc\\", \\"abd\\") 1 >>> min_transformations(\\"abc\\", \\"xyz\\") 3 >>> min_transformations(\\"abc\\", \\"abcd\\") -1 >>> min_transformations(\\"\\", \\"\\") 0 >>> min_transformations(\\"a\\", \\"abc\\") -1 >>> min_transformations(\\"abc\\", \\"a\\") -1","solution":"def min_transformations(s1, s2): Returns the minimum number of transformations required to change s1 into s2, or -1 if it is not possible to transform s1 into s2. if len(s1) != len(s2): return -1 transformations = 0 for char_s1, char_s2 in zip(s1, s2): if char_s1 != char_s2: transformations += 1 return transformations"},{"question":"def can_reorder_transactions(transactions: List[int]) -> bool: Determines if the transactions can be reordered so that the balance never drops below zero. Args: transactions (list of int): List of integers representing deposits (positive) and withdrawals (negative). Returns: bool: True if the transactions can be reordered to prevent the balance from dropping below zero, otherwise False. >>> can_reorder_transactions([1, 2, 3, -1, -2]) True >>> can_reorder_transactions([1, 2, -1, -2, -2]) False >>> can_reorder_transactions([3, -4, 4, -3]) True >>> can_reorder_transactions([10, 20, 30]) True >>> can_reorder_transactions([-5, -10, -15]) False >>> can_reorder_transactions([1, -1]) True >>> can_reorder_transactions([100, 200, -50, -100, -150]) True >>> can_reorder_transactions([100, 200, -50, -100, -300]) False","solution":"def can_reorder_transactions(transactions): Determines if the transactions can be reordered so that the balance never drops below zero. Args: transactions (list of int): List of integers representing deposits (positive) and withdrawals (negative). Returns: bool: True if the transactions can be reordered to prevent the balance from dropping below zero, otherwise False. current_balance = 0 transactions.sort(reverse=True) for transaction in transactions: current_balance += transaction if current_balance < 0: return False return True"},{"question":"def is_palindrome(word): Helper function to check if a word is a palindrome. >>> is_palindrome(\\"level\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"radar\\") True >>> is_palindrome(\\"world\\") False def palindromePairs(words): Returns the total number of pairs (i, j) where 0 <= i < j < words.length, and the concatenation of words[i] + words[j] or words[j] + words[i] forms a palindrome. >>> palindromePairs([\\"bat\\", \\"tab\\", \\"cat\\"]) == 2 # \\"battab\\" and \\"tabbat\\" >>> palindromePairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) == 4 # \\"abcddcba\\", \\"dcbaabcd\\", \\"llssssll\\", \\"ssslls\\" >>> palindromePairs([\\"a\\", \\"aa\\", \\"aaa\\"]) == 6 # \\"aaa\\", \\"aaa\\", \\"aaa\\", \\"aaaa\\", \\"aaaa\\", \\"aaaaaa\\" >>> palindromePairs([\\"\\"]) == 0 # No other words to compare >>> palindromePairs([\\"a\\", \\"\\"]) == 2 # \\"a\\", \\"a\\" >>> palindromePairs([\\"abc\\", \\"def\\", \\"ghi\\"]) == 0 # No palindromic combinations >>> palindromePairs([\\"not\\", \\"a\\", \\"palindrome\\"]) == 0 # No palindromic combinations","solution":"def is_palindrome(word): Helper function to check if a word is a palindrome. return word == word[::-1] def palindromePairs(words): Returns the total number of pairs (i, j) where 0 <= i < j < words.length, and the concatenation of words[i] + words[j] or words[j] + words[i] forms a palindrome. count = 0 for i in range(len(words)): for j in range(i + 1, len(words)): if is_palindrome(words[i] + words[j]): count += 1 if is_palindrome(words[j] + words[i]): count += 1 return count"},{"question":"def interleave_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Given two integer arrays \`arr1\` and \`arr2\` of length \`n\`, interleave these arrays to form a new array of length \`2n\` such that the elements from \`arr1\` appear at the even indices and the elements from \`arr2\` appear at the odd indices. >>> interleave_arrays([1, 2, 3], [4, 5, 6]) [1, 4, 2, 5, 3, 6] >>> interleave_arrays([10, 20, 30], [11, 21, 31]) [10, 11, 20, 21, 30, 31] >>> interleave_arrays([-1, -2, -3], [-4, -5, -6]) [-1, -4, -2, -5, -3, -6] >>> interleave_arrays([1], [2]) [1, 2] >>> interleave_arrays([], []) []","solution":"def interleave_arrays(arr1, arr2): Interleaves two arrays of the same length such that elements from arr1 appear at even indices and elements from arr2 appear at odd indices. if len(arr1) != len(arr2): raise ValueError(\\"Arrays must be of the same length\\") interleaved = [None] * (len(arr1) + len(arr2)) interleaved[::2] = arr1 interleaved[1::2] = arr2 return interleaved"},{"question":"def can_convert_string(s: str, t: str, k: int) -> bool: Determine if it is possible to convert \`s\` into \`t\` by performing exactly \`k\` operations. An operation allows you to change any character of \`s\` to any other lowercase English letter. Args: s (str): The source string. t (str): The target string. k (int): The number of operations. Returns: bool: True if the conversion is possible within exactly \`k\` operations, False otherwise. >>> can_convert_string(\\"abc\\", \\"bcd\\", 3) True >>> can_convert_string(\\"abc\\", \\"def\\", 2) False >>> can_convert_string(\\"abc\\", \\"abc\\", 4) True >>> can_convert_string(\\"abc\\", \\"abc\\", 3) False >>> can_convert_string(\\"abcd\\", \\"abc\\", 3) False >>> can_convert_string(\\"abc\\", \\"abc\\", 0) True >>> can_convert_string(\\"abc\\", \\"abd\\", 0) False >>> can_convert_string(\\"aaaa\\", \\"zzzz\\", 4) True >>> can_convert_string(\\"aaaa\\", \\"zzzz\\", 3) False","solution":"def can_convert_string(s, t, k): Returns True if s can be converted to t in exactly k operations, False otherwise. if len(s) != len(t): return False # Count the different characters diff_count = sum(1 for sc, tc in zip(s, t) if sc != tc) # We can convert s to t in exactly k operations if and only if diff_count <= k and # the difference (k - diff_count) is an even number (each change can be undone or # a new change can be made in a pairwise manner). return diff_count <= k and (k - diff_count) % 2 == 0"},{"question":"def merge_and_sort_substrings(s: str) -> str: Given a string \`s\` of lowercase English letters, form a new string by merging two non-overlapping substrings and sorting the result in non-decreasing order. Return the lexicographically smallest string that can be obtained by this process. >>> merge_and_sort_substrings(\\"abc\\") 'abc' >>> merge_and_sort_substrings(\\"a\\") 'a' >>> merge_and_sort_substrings(\\"ba\\") 'ab' >>> merge_and_sort_substrings(\\"bbbb\\") 'bbbb' >>> merge_and_sort_substrings(\\"dacbe\\") 'abcde' >>> merge_and_sort_substrings(\\"zxyabc\\") 'abcxyz' >>> merge_and_sort_substrings(\\"aaaa\\") 'aaaa' >>> merge_and_sort_substrings(\\"hello\\") 'ehllo'","solution":"def merge_and_sort_substrings(s): Given a string s of lowercase English letters, form a new string by merging two non-overlapping substrings and sorting the result in non-decreasing order. Return the lexicographically smallest string that can be obtained by this process. n = len(s) smallest_string = s # Initialize with the original string for i in range(1, n): left_part = s[:i] right_part = s[i:] merged_string = ''.join(sorted(left_part + right_part)) if merged_string < smallest_string: smallest_string = merged_string return smallest_string"},{"question":"def min_operations(coins, target): Returns the minimum number of operations needed to achieve the target sum with the given coins. If it's not possible, return -1. >>> min_operations([1, 2, 3], 5) 2 >>> min_operations([1, 1, 1], 2) 2 >>> min_operations([3, 7, 4], 10) 2 >>> min_operations([2, 4], 7) -1 >>> min_operations([], 0) 0 >>> min_operations([1, 2, 3], 0) 0 >>> min_operations([5], 5) 1","solution":"def min_operations(coins, target): n = len(coins) MAX_OPS = float('inf') dp = [[MAX_OPS] * (target + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n + 1): coin = coins[i - 1] for j in range(target + 1): # Not picking the i-th coin dp[i][j] = dp[i - 1][j] # Picking the i-th coin, only if it's not larger than the current sum we're considering if j >= coin: dp[i][j] = min(dp[i][j], dp[i - 1][j - coin] + 1) return dp[n][target] if dp[n][target] != MAX_OPS else -1"},{"question":"def count_greater_buildings(heights): Returns an array where each element corresponds to the number of buildings to the right that have heights strictly greater than the current building. >>> count_greater_buildings([3, 3, 3, 3]) [0, 0, 0, 0] >>> count_greater_buildings([1, 2, 3, 4]) [3, 2, 1, 0] >>> count_greater_buildings([4, 3, 2, 1]) [0, 0, 0, 0] >>> count_greater_buildings([2, 3, 1, 4]) [2, 1, 1, 0] >>> count_greater_buildings([5]) [0] >>> count_greater_buildings([]) []","solution":"def count_greater_buildings(heights): Returns an array where each element corresponds to the number of buildings to the right that have heights strictly greater than the current building. n = len(heights) ans = [0] * n for i in range(n - 1): count = 0 for j in range(i + 1, n): if heights[j] > heights[i]: count += 1 ans[i] = count return ans"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level order traversal of a binary tree. :param TreeNode root: The root node of the binary tree. :return: A list of lists, where each inner list contains the values of the nodes at that level. :rtype: List[List[int]] pass from solution import TreeNode, level_order def test_level_order_empty_tree(): assert level_order(None) == [] def test_level_order_single_node(): root = TreeNode(1) assert level_order(root) == [[1]] def test_level_order_complete_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) root.left.right = TreeNode(5) root.right.left = TreeNode(6) root.right.right = TreeNode(7) assert level_order(root) == [[1], [2, 3], [4, 5, 6, 7]] def test_level_order_incomplete_tree(): root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(4) root.right.right = TreeNode(5) assert level_order(root) == [[1], [2, 3], [4, 5]] def test_level_order_skewed_tree(): root = TreeNode(1) root.right = TreeNode(2) root.right.right = TreeNode(3) root.right.right.right = TreeNode(4) assert level_order(root) == [[1], [2], [3], [4]]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root): Returns the level order traversal of a binary tree. :param TreeNode root: The root node of the binary tree. :return: A list of lists, where each inner list contains the values of the nodes at that level. :rtype: List[List[int]] if not root: return [] result = [] queue = deque([root]) while queue: level_nodes = [] for _ in range(len(queue)): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"from typing import List def is_valid_identifier(identifier: str) -> bool: Checks if an incident identifier is valid. A valid identifier: - Starts with a lowercase alphabetic character - Is at least 3 characters long - Consists only of lowercase alphabetic characters and digits Args: identifier (str): The incident identifier to validate. Returns: bool: True if the identifier is valid, False otherwise. pass def count_valid_identifiers(identifiers: List[str]) -> int: Counts the number of valid incident identifiers in a list. Args: identifiers (list of str): List of incident identifiers. Returns: int: Number of valid identifiers. pass # Unit tests def test_count_valid_identifiers(): assert count_valid_identifiers([\\"a123\\", \\"ab1\\", \\"1abc\\", \\"abcd\\", \\"ab\\"]) == 3 def test_count_no_identifiers(): assert count_valid_identifiers([]) == 0 def test_count_all_valid_identifiers(): assert count_valid_identifiers([\\"abc\\", \\"b123\\", \\"x9z\\"]) == 3 def test_count_all_invalid_identifiers(): assert count_valid_identifiers([\\"a1\\", \\"1abc\\", \\"ab!\\", \\"a_bc\\"]) == 0 def test_mixed_identifiers(): assert count_valid_identifiers([\\"abc\\", \\"1bc\\", \\"xyz\\", \\"w2\\", \\"valid123\\"]) == 3 def test_with_long_identifiers(): assert count_valid_identifiers([\\"a1b2c3\\", \\"abcde12345\\", \\"z9y8x7\\"]) == 3","solution":"def is_valid_identifier(identifier): Checks if an incident identifier is valid. A valid identifier: - Starts with a lowercase alphabetic character - Is at least 3 characters long - Consists only of lowercase alphabetic characters and digits Args: identifier (str): The incident identifier to validate. Returns: bool: True if the identifier is valid, False otherwise. if len(identifier) < 3: return False if not identifier[0].islower(): return False if not identifier.isalnum(): return False return True def count_valid_identifiers(identifiers): Counts the number of valid incident identifiers in a list. Args: identifiers (list of str): List of incident identifiers. Returns: int: Number of valid identifiers. return sum(is_valid_identifier(identifier) for identifier in identifiers)"},{"question":"def min_subarray_len(nums: List[int], x: int) -> int: Returns the length of the shortest contiguous subarray with sum >= x, or -1 if no such subarray exists. >>> min_subarray_len([1, 4, 4], 8) 2 >>> min_subarray_len([1, 2, 3, 4, 5], 20) -1 >>> min_subarray_len([5], 5) 1 >>> min_subarray_len([5], 10) -1 >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4, 8], 8) 1 >>> min_subarray_len([10, 5, 2], 17) 3 >>> min_subarray_len([], 1) -1 >>> min_subarray_len([10], 10) 1 >>> min_subarray_len([1, 2, 3, 4, 5], 15) 5","solution":"def min_subarray_len(nums, x): Returns the length of the shortest contiguous subarray with sum >= x, or -1 if no such subarray exists. n = len(nums) min_len = float('inf') current_sum = start = 0 for end in range(n): current_sum += nums[end] while current_sum >= x: min_len = min(min_len, end - start + 1) current_sum -= nums[start] start += 1 return min_len if min_len != float('inf') else -1"},{"question":"def max_comparisons(nums1, nums2): You are given two 0-indexed integer arrays nums1 and nums2, both of length n. A comparison for a pair of indices (i, j) is defined as follows: nums1[i] < nums2[j]. Return the maximum number of such comparisons for all valid pairs of indices (i, j) (i.e., where 0 <= i, j < n). Note that each element in nums1 and nums2 can only be used in one comparison. >>> max_comparisons([1, 2, 3], [3, 2, 1]) 2 >>> max_comparisons([1, 1, 1], [1, 1, 1]) 0 >>> max_comparisons([1, 2, 3], [4, 5, 6]) 3 >>> max_comparisons([4, 5, 6], [1, 2, 3]) 0 >>> max_comparisons([1, 4, 2], [3, 5, 1]) 2","solution":"def max_comparisons(nums1, nums2): Returns the maximum number of comparisons (i, j) where nums1[i] < nums2[j]. Each element in nums1 and nums2 can only be used in one comparison. count = 0 nums1_sorted = sorted(nums1) nums2_sorted = sorted(nums2) j = 0 for i in range(len(nums1_sorted)): while j < len(nums2_sorted) and nums1_sorted[i] >= nums2_sorted[j]: j += 1 if j < len(nums2_sorted): count += 1 j += 1 return count"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root: TreeNode, k: int) -> int: Returns the kth smallest value in the BST. >>> root = TreeNode(3, left=TreeNode(1, right=TreeNode(2)), right=TreeNode(4)) >>> kth_smallest(root, 2) 2 >>> root = TreeNode(1) >>> kth_smallest(root, 1) 1 >>> root = TreeNode(5, left=TreeNode(3, TreeNode(2, TreeNode(1)), TreeNode(4)), right=TreeNode(6)) >>> kth_smallest(root, 3) 3","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def kth_smallest(root, k): Returns the kth smallest value in the BST. def inorder_traversal(node): if not node: return [] # Traverse left subtree, root, then right subtree return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right) # Get all the values in the BST in sorted order sorted_values = inorder_traversal(root) # Return the kth smallest value (1-indexed -> k-1 for 0-indexed) return sorted_values[k-1]"},{"question":"def countFairPairs(nums1: List[int], nums2: List[int], k: int) -> int: Returns the number of fair pairs (u, v) such that the absolute difference between u and v is less than or equal to k. Parameters: nums1 (list): The first list of integers. nums2 (list): The second list of integers. k (int): The maximum allowed absolute difference. Returns: int: The count of fair pairs. >>> countFairPairs([1, 2, 3], [4, 5, 6], 3) 6 >>> countFairPairs([1, 3, 5], [10, 12, 14], 2) 0 >>> countFairPairs([1, 2, 3], [1, 2, 3], 0) 3 >>> countFairPairs([1, 1, 1], [2, 2, 2], 100) 9 >>> countFairPairs([-1, -2, -3], [-4, -5, -6], 3) 6","solution":"def countFairPairs(nums1, nums2, k): Returns the number of fair pairs (u, v) such that the absolute difference between u and v is less than or equal to k. Parameters: nums1 (list): The first list of integers. nums2 (list): The second list of integers. k (int): The maximum allowed absolute difference. Returns: int: The count of fair pairs. count = 0 for u in nums1: for v in nums2: if abs(u - v) <= k: count += 1 return count"},{"question":"def strongest_battalion(arr, k, m): Returns the maximum possible strength of a battalion formed under the given conditions. :param arr: List of positive integers representing the strength of soldiers. :param k: Integer representing number of soldiers in the battalion. :param m: Integer representing the maximum number of consecutive soldiers that can be chosen. :return: Integer representing the maximum possible strength of the battalion. Example: >>> strongest_battalion([1, 3, 2, 1, 4, 1, 5], 3, 2) 12 from solution import strongest_battalion def test_strongest_battalion_small(): arr = [1, 3, 2, 1, 4, 1, 5] k = 3 m = 2 assert strongest_battalion(arr, k, m) == 12 def test_strongest_battalion_all_consecutive(): arr = [1, 2, 3, 4, 5] k = 2 m = 1 assert strongest_battalion(arr, k, m) == 9 def test_strongest_battalion_non_consecutive(): arr = [1, 2, 3, 4, 5] k = 3 m = 1 assert strongest_battalion(arr, k, m) == 12 def test_strongest_battalion_large_k(): arr = [1, 2, 3, 4, 5] k = 5 m = 2 assert strongest_battalion(arr, k, m) == 15 def test_strongest_battalion_all_same_strength(): arr = [4, 4, 4, 4, 4] k = 3 m = 2 assert strongest_battalion(arr, k, m) == 12","solution":"def strongest_battalion(arr, k, m): Returns the maximum possible strength of a battalion formed under the given conditions. :param arr: List of positive integers representing the strength of soldiers. :param k: Integer representing number of soldiers in the battalion. :param m: Integer representing the maximum number of consecutive soldiers that can be chosen. :return: Integer representing the maximum possible strength of the battalion. n = len(arr) max_strength = 0 # Go through all possible combinations of picking k soldiers with at most m consecutive ones def dfs(index, selected, current_strength, last_taken): nonlocal max_strength # If we've picked k soldiers, compare and update max_strength if selected == k: max_strength = max(max_strength, current_strength) return for i in range(index, n): # Can only pick current soldier if it's not consecutive to the last chosen (if last_taken is not None) if last_taken is None or i - last_taken > m: dfs(i + 1, selected + 1, current_strength + arr[i], i) elif last_taken is not None and (0 < i - last_taken <= m): dfs(i + 1, selected + 1, current_strength + arr[i], i) dfs(0, 0, 0, None) return max_strength"},{"question":"def lcs_lengths(target: str, wordlist: List[str]) -> List[int]: Given a target string and a list of wordlist strings, find the longest common subsequence (LCS) between the target string and each string in the wordlist. The LCS is the longest sequence that appears in both strings in the same order, but not necessarily consecutively. Return an array answer where answer[i] is the length of the longest common subsequence between the target string and wordlist[i]. If there is no common subsequence, the length should be 0. Example: >>> lcs_lengths(\\"abcde\\", [\\"ace\\", \\"aec\\", \\"bd\\"]) [3, 2, 2] >>> lcs_lengths(\\"abcdef\\", [\\"abc\\", \\"def\\", \\"xyz\\"]) [3, 3, 0] from typing import List import pytest def test_lcs_lengths(): assert lcs_lengths(\\"abcde\\", [\\"ace\\", \\"aec\\", \\"bd\\"]) == [3, 2, 2] assert lcs_lengths(\\"abcdef\\", [\\"abc\\", \\"def\\", \\"xyz\\"]) == [3, 3, 0] assert lcs_lengths(\\"xyz\\", [\\"a\\", \\"b\\", \\"c\\"]) == [0, 0, 0] assert lcs_lengths(\\"qwerty\\", [\\"wert\\", \\"wer\\", \\"ty\\"]) == [4, 3, 2] assert lcs_lengths(\\"a\\", [\\"a\\", \\"aaa\\", \\"b\\"]) == [1, 1, 0] def test_lcs_lengths_empty_target(): assert lcs_lengths(\\"\\", [\\"a\\", \\"b\\", \\"c\\"]) == [0, 0, 0] def test_lcs_lengths_empty_wordlist(): assert lcs_lengths(\\"abc\\", []) == [] def test_lcs_lengths_both_empty(): assert lcs_lengths(\\"\\", [\\"\\"]) == [0]","solution":"def lcs_length(target, word): Returns the length of the longest common subsequence (LCS) between target and word. m, n = len(target), len(word) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if target[i - 1] == word[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def lcs_lengths(target, wordlist): Returns a list where each element is the length of the LCS between the target string and the corresponding word in wordlist. return [lcs_length(target, word) for word in wordlist]"},{"question":"def trap(heights: List[int]) -> int: Calculate the maximum amount of water that can be trapped. >>> trap([]) == 0 >>> trap([5]) == 0 >>> trap([4, 4]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0 >>> trap([3, 0, 2]) == 2 >>> trap([0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2]) == 8 >>> trap([2, 0, 0, 2]) == 4 >>> trap([4, 2, 0, 3, 2, 5]) == 9","solution":"def trap(heights): Calculate the maximum amount of water that can be trapped. :param heights: List of integers representing the heights of the pillars :return: Integer representing the maximum units of water that can be trapped if not heights: return 0 n = len(heights) max_water = 0 # Create left_max and right_max arrays left_max = [0]*n right_max = [0]*n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(n): max_water += min(left_max[i], right_max[i]) - heights[i] return max_water"},{"question":"from typing import List def rearrange_string(text: str) -> str: Rearrange the characters in the text such that any two adjacent characters are not the same. If it is not possible, return an empty string. >>> rearrange_string(\\"aab\\") in [\\"aba\\"] True >>> rearrange_string(\\"\\") == \\"\\" True >>> rearrange_string(\\"aaab\\") == \\"\\" True >>> rearrange_string(\\"a\\") == \\"a\\" True >>> rearrange_string(\\"aa\\") == \\"\\" True >>> result = rearrange_string(\\"abab\\") >>> result in [\\"abab\\", \\"baba\\"] True >>> result = rearrange_string(\\"aaabbc\\") >>> result in [\\"ababac\\", \\"ababca\\", \\"acbaba\\", \\"bacaba\\"] True >>> result = rearrange_string(\\"abcdefg\\") >>> result == \\"abcdefg\\" True","solution":"import heapq from collections import Counter def rearrange_string(text): Rearrange the characters in the text such that any two adjacent characters are not the same. If it is not possible, return an empty string. # Count the frequency of each character char_count = Counter(text) # Create a max-heap based on character count max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) # Add the previous character back if it exists if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Append current character to the result result.append(char) prev_count, prev_char = count + 1, char # Decrement count rearranged_string = ''.join(result) # Check if the rearranged string is of the same length as the input text return rearranged_string if len(rearranged_string) == len(text) else \\"\\""},{"question":"def can_rearrange_to_palindrome(s: str, k: int) -> bool: Determine if it is possible to rearrange the characters in the string \`s\` to form a palindrome such that no two adjacent characters are the same. Return True if such a rearrangement is possible, otherwise return False. >>> can_rearrange_to_palindrome('a', 1) True >>> can_rearrange_to_palindrome('aabb', 2) True >>> can_rearrange_to_palindrome('aaabc', 2) False >>> can_rearrange_to_palindrome('aaaabb', 3) False >>> can_rearrange_to_palindrome('aabbcc', 3) True >>> can_rearrange_to_palindrome('aaabb', 2) True","solution":"def can_rearrange_to_palindrome(s, k): from collections import Counter char_count = Counter(s) # In a valid palindrome, at most one character can have an odd count. odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If there are more than one character with odd counts, it's impossible. if odd_count > 1: return False # Check if the k constraint can be satisfied # Check that with current frequency counts, no two of the same characters can be adjacent half_length = (len(s) // 2) max_allowed_same_char = (len(s) // 2) + (len(s) % 2) max_char_frequency = max(char_count.values()) if max_char_frequency > max_allowed_same_char: return False return True"},{"question":"def count_even_sum_pairs(nums: List[int]) -> int: Returns the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] is even. >>> count_even_sum_pairs([1, 2, 3, 4]) == 2 >>> count_even_sum_pairs([2, 4, 6, 8, 10]) == 10 >>> count_even_sum_pairs([1, 3, 5, 7, 9]) == 10 >>> count_even_sum_pairs([1, 2, 4, 6, 9]) == 4 >>> count_even_sum_pairs([1]) == 0 >>> count_even_sum_pairs([2]) == 0 >>> count_even_sum_pairs([]) == 0 >>> count_even_sum_pairs([0, 0, 0, 0]) == 6","solution":"def count_even_sum_pairs(nums): Returns the number of pairs (i, j) where 0 <= i < j < n and nums[i] + nums[j] is even. Parameters: nums (list): a list of integers. Returns: int: count of pairs with an even sum. even_count = 0 odd_count = 0 # Count even and odd numbers in the array for num in nums: if num % 2 == 0: even_count += 1 else: odd_count += 1 # Pairs (i, j) with even sum can be formed by: # - both even numbers # - both odd numbers even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 # Return the sum of even pairs and odd pairs return even_pairs + odd_pairs"},{"question":"def trap_rain_water(heights): Calculate the maximum volume of water that can be trapped between the columns after a rain. :param heights: List[int] - a list of non-negative integers representing elevation heights :return: int - total volume of trapped rain water >>> trap_rain_water([]) == 0 >>> trap_rain_water([1, 2, 3, 4, 5]) == 0 >>> trap_rain_water([5, 4, 3, 2, 1]) == 0 >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) == 9 >>> trap_rain_water([1, 0, 2, 0, 1]) == 2 >>> trap_rain_water([3, 3, 3, 3]) == 0 >>> trap_rain_water([4]) == 0 >>> trap_rain_water([0, 1]) == 0","solution":"def trap_rain_water(heights): Calculate the maximum volume of water that can be trapped between the columns after a rain. :param heights: List[int] - a list of non-negative integers representing elevation heights :return: int - total volume of trapped rain water if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def simplify_directory_paths(paths: List[str]) -> List[str]: Simplify a list of directory paths by removing redundant components. >>> simplify_directory_paths([\\"/a//b//c/\\", \\"/a/b/c/./\\", \\"/a/b/../c/\\"]) [\\"/a/b/c\\", \\"/a/b/c\\", \\"/a/c\\"] >>> simplify_directory_paths([\\"//a///b/c/\\"]) [\\"/a/b/c\\"] >>> simplify_directory_paths([\\"/./\\", \\"/../\\", \\"/a/b/c/./../../\\"]) [\\"/\\", \\"/\\", \\"/a\\"] >>> simplify_directory_paths([\\"/a//./b/../\\" + basedir + \\"sbin/\\"]) env.Append(LD_LIBRARY_PATH=[\\"INSTALL_DIR/lib\\"]) # Add rpath options env.AppendUnique(RPATH=[os.path.join(basedir, \\"lib\\")]) env.Tool(\\"actions\\") env.Tool(\\"config\\") env.Tool(\\"install_tree\\")","solution":"def simplify_directory_paths(paths): def simplify_path(path): parts = path.split('/') stack = [] for part in parts: if part == '' or part == '.': continue elif part == '..': if stack: stack.pop() elif not stack: continue else: stack.append(part) return '/' + '/'.join(stack) return [simplify_path(path) for path in paths]"},{"question":"def subarray_sum_equals_k(arr: List[int], k: int) -> int: Returns the total number of continuous subarrays whose sum equals to k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: Total number of continuous subarrays whose sum equals to k. >>> subarray_sum_equals_k([1, 1, 1], 2) 2 >>> subarray_sum_equals_k([5], 5) 1 >>> subarray_sum_equals_k([5], 7) 0 >>> subarray_sum_equals_k([1, 2, 3], 3) 2 >>> subarray_sum_equals_k([-1, -1, 1], 0) 1 >>> subarray_sum_equals_k([1, 2, 3, 4, 5], 9) 2 >>> subarray_sum_equals_k([1, 2, 3], 7) 0","solution":"def subarray_sum_equals_k(arr, k): Returns the total number of continuous subarrays whose sum equals to k. Parameters: arr (list of int): The list of integers. k (int): The target sum. Returns: int: Total number of continuous subarrays whose sum equals to k. count = 0 current_sum = 0 sum_dict = {0: 1} # Initialize with 0 sum having one count as a base case for num in arr: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] if current_sum in sum_dict: sum_dict[current_sum] += 1 else: sum_dict[current_sum] = 1 return count"},{"question":"def find_distinct_islands(grid) -> int: Find the number of distinct-shaped islands in a 2D grid. An island is a group of connected land cells (1s) orthogonally. Distinct islands have unique shapes even if rotated or flipped. >>> find_distinct_islands([ [1, 1, 0, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 0, 1], [0, 0, 0, 0, 0] ]) 2 >>> find_distinct_islands([ [1, 1, 0, 1], [0, 1, 0, 0], [1, 0, 0, 1], [0, 1, 1, 1] ]) 3 >>> find_distinct_islands([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 1] ]) 2","solution":"def find_distinct_islands(grid): def dfs(x, y, direction, island_shape): if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] != 1: return grid[x][y] = -1 island_shape.append(direction) dfs(x-1, y, 'U', island_shape) # Up dfs(x+1, y, 'D', island_shape) # Down dfs(x, y-1, 'L', island_shape) # Left dfs(x, y+1, 'R', island_shape) # Right island_shape.append('B') # Back to previous cell unique_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: island_shape = [] dfs(i, j, 'S', island_shape) # Start of a shape unique_islands.add(tuple(island_shape)) return len(unique_islands)"},{"question":"from typing import List from collections import Counter def count_characters(strings: List[str], chars: str) -> int: Returns the total length of strings that can be formed using the characters in chars. Each character in chars can only be used once per word but could be reused in forming different words. Examples: >>> count_characters([\\"cat\\"], \\"atach\\") 3 >>> count_characters([\\"bt\\"], \\"atach\\") 0 >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"atach\\") 6 >>> count_characters([\\"hello\\", \\"world\\", \\"leetcode\\"], \\"welldonehoneyr\\") 10 >>> count_characters([], \\"abcdef\\") 0 >>> count_characters([\\"cat\\", \\"bt\\", \\"hat\\", \\"tree\\"], \\"\\") 0 >>> count_characters([\\"dog\\", \\"rat\\", \\"elephant\\"], \\"apple\\") 0 >>> count_characters([\\"a\\", \\"b\\", \\"c\\", \\"abc\\"], \\"aabbcc\\") 6 >>> count_characters([\\"aa\\", \\"bb\\", \\"cc\\", \\"aabbcc\\"], \\"aabbcc\\") 12","solution":"from collections import Counter def count_characters(strings, chars): Returns the total length of strings that can be formed using the characters in chars. Each character in chars can only be used once per word. chars_count = Counter(chars) total_length = 0 for word in strings: word_count = Counter(word) can_form = True for char in word_count: if word_count[char] > chars_count.get(char, 0): can_form = False break if can_form: total_length += len(word) return total_length"},{"question":"def min_moves_to_sort_heights(heights): Returns the minimum number of moves needed to sort the heights array by picking one student and moving them to any position. >>> min_moves_to_sort_heights([1, 2, 3, 4, 5]) 0 >>> min_moves_to_sort_heights([1, 3, 2, 4, 5]) 1 >>> min_moves_to_sort_heights([5, 1, 2, 3, 4]) 2 >>> min_moves_to_sort_heights([1, 3, 5, 4, 2]) 2 >>> min_moves_to_sort_heights([1]) 0 >>> min_moves_to_sort_heights([1, 2]) 0 >>> min_moves_to_sort_heights([2, 1]) 1","solution":"def min_moves_to_sort_heights(heights): Returns the minimum number of moves needed to sort the heights array by picking one student and moving them to any position. sorted_heights = sorted(heights) differences = sum([1 for i, height in enumerate(heights) if height != sorted_heights[i]]) # If the list is already sorted if differences == 0: return 0 # If only one element is out of place, one move is always sufficient if differences == 2: return 1 # If more than two elements are out of place, more than one move is needed return 2"},{"question":"def two_sum(nums, target): Determines if there are two distinct numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target sum. Returns: Boolean indicating whether there are two distinct numbers that add up to the target. >>> two_sum([2, 7, 11, 15], 9) True >>> two_sum([1, 3, 4, 2], 6) True >>> two_sum([2, 7, 11, 15], 10) False >>> two_sum([1, 2, 3, 9], 20) False >>> two_sum([], 5) False >>> two_sum([1], 2) False >>> two_sum([-1, -2, -3, -4], -6) True >>> two_sum([-1, -2, -3, -4], -10) False >>> two_sum([0, 4, 3, 0], 0) True >>> two_sum([1, 2, 3], 0) False","solution":"def two_sum(nums, target): Determines if there are two distinct numbers in the list that add up to the target. Args: nums: List of integers. target: Integer target sum. Returns: Boolean indicating whether there are two distinct numbers that add up to the target. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def can_partition_to_max_weight(weights: List[int], maxWeight: int) -> bool: Determine if it's possible to partition the items into two groups such that the sum of weights in each group does not exceed maxWeight. >>> can_partition_to_max_weight([1, 2, 3, 4], 5) True >>> can_partition_to_max_weight([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) True >>> can_partition_to_max_weight([1, 1, 1, 1, 1, 1, 1, 1, 1, 10], 5) False >>> can_partition_to_max_weight([10, 10, 10, 10, 10], 20) False >>> can_partition_to_max_weight([i for i in range(1, 20)], 100) True >>> can_partition_to_max_weight([i for i in range(1, 51)], 125) False from typing import List def test_example_case(): assert can_partition_to_max_weight([1, 2, 3, 4], 5) def test_partition_possible_case_1(): assert can_partition_to_max_weight([1, 1, 1, 1, 1, 1, 1, 1, 1, 1], 5) def test_partition_impossible_case_1(): assert can_partition_to_max_weight([1, 1, 1, 1, 1, 1, 1, 1, 1, 10], 5) def test_partition_impossible_case_2(): assert can_partition_to_max_weight([10, 10, 10, 10, 10], 20) def test_large_input_possible_case(): weights = [i for i in range(1, 20)] assert can_partition_to_max_weight(weights, 100) def test_large_input_impossible_case(): weights = [i for i in range(1, 51)] assert can_partition_to_max_weight(weights, 125)","solution":"def can_partition_to_max_weight(weights, maxWeight): totalWeight = sum(weights) if totalWeight > 2 * maxWeight: return False n = len(weights) target = maxWeight dp = [False] * (target + 1) dp[0] = True for weight in weights: for j in range(target, weight - 1, -1): if dp[j - weight]: dp[j] = True for w in range(target, -1, -1): if dp[w] and totalWeight - w <= maxWeight: return True return False"},{"question":"from typing import List def maxDensityOfSubRegion(grid: List[List[int]]) -> int: Returns the maximum density of any rectangular sub-region within the given field. >>> maxDensityOfSubRegion([[1, 2], [3, 4]]) 10 >>> maxDensityOfSubRegion([[1, 2, 3]]) 6 >>> maxDensityOfSubRegion([[1], [2], [3]]) 6 >>> maxDensityOfSubRegion([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> maxDensityOfSubRegion([[1, 2, 3], [4, 5, 6]]) 21 >>> maxDensityOfSubRegion([[5]]) 5 >>> maxDensityOfSubRegion([]) 0","solution":"def maxDensityOfSubRegion(grid): Returns the maximum density of any rectangular sub-region within the given field. if not grid or not grid[0]: return 0 m = len(grid) n = len(grid[0]) max_density = 0 # Compute the prefix sum array prefix_sum = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): prefix_sum[i][j] = (grid[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]) # Find the maximum density sub-region for i1 in range(1, m + 1): for j1 in range(1, n + 1): for i2 in range(i1, m + 1): for j2 in range(j1, n + 1): current_density = (prefix_sum[i2][j2] - prefix_sum[i1 - 1][j2] - prefix_sum[i2][j1 - 1] + prefix_sum[i1 - 1][j1 - 1]) max_density = max(max_density, current_density) return max_density"},{"question":"def max_rectangle_area(heights): Returns the maximum rectangle area that can be formed by the given heights of buildings. heights: List[int] - heights of buildings in a row. pass def test_single_building(): assert max_rectangle_area([5]) == 5 def test_two_buildings_same_height(): assert max_rectangle_area([3, 3]) == 6 def test_two_buildings_different_height(): assert max_rectangle_area([3, 1]) == 3 def test_increasing_heights(): assert max_rectangle_area([1, 2, 3, 4, 5]) == 9 def test_decreasing_heights(): assert max_rectangle_area([5, 4, 3, 2, 1]) == 9 def test_mixed_heights(): assert max_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 def test_all_same_heights(): assert max_rectangle_area([4, 4, 4, 4]) == 16 def test_empty_input(): assert max_rectangle_area([]) == 0","solution":"def max_rectangle_area(heights): Returns the maximum rectangle area that can be formed by the given heights of buildings. heights: List[int] - heights of buildings in a row. max_area = 0 stack = [] for i, height in enumerate(heights): start = i while stack and stack[-1][1] > height: index, h = stack.pop() max_area = max(max_area, h * (i - index)) start = index stack.append((start, height)) for i, height in stack: max_area = max(max_area, height * (len(heights) - i)) return max_area"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. Returns the head of the rotated linked list. from solution import rotateRight, ListNode def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result def list_to_linked_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def test_rotate_right(): head = list_to_linked_list([1, 2, 3, 4, 5]) k = 2 new_head = rotateRight(head, k) assert linked_list_to_list(new_head) == [4, 5, 1, 2, 3] def test_rotate_right_single_element(): head = list_to_linked_list([1]) k = 5 new_head = rotateRight(head, k) assert linked_list_to_list(new_head) == [1] def test_rotate_right_empty(): head = list_to_linked_list([]) k = 3 new_head = rotateRight(head, k) assert linked_list_to_list(new_head) == [] def test_rotate_right_no_rotation_needed(): head = list_to_linked_list([1, 2, 3]) k = 3 new_head = rotateRight(head, k) assert linked_list_to_list(new_head) == [1, 2, 3] def test_rotate_right_more_than_length(): head = list_to_linked_list([1, 2, 3, 4]) k = 7 new_head = rotateRight(head, k) assert linked_list_to_list(new_head) == [2, 3, 4, 1]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # First, determine the length of the list old_tail = head length = 1 while old_tail.next: old_tail = old_tail.next length += 1 # Form a circular list old_tail.next = head # Find the new tail : (length - k % length - 1)th node k = k % length new_tail = head for _ in range(length - k - 1): new_tail = new_tail.next # Find the new head : (length - k % length)th node new_head = new_tail.next # Break the cycle new_tail.next = None return new_head"},{"question":"def largestIntegerSum(x: int, y: int) -> int: Returns the largest integer n such that the sum of the integers from 1 to n is less than or equal to the sum of x and y. Parameters: x (int): First integer y (int): Second integer Returns: int: Largest possible integer n # Your implementation here # Unit tests def test_largest_integer_sum_case_1(): assert largestIntegerSum(3, 4) == 3 def test_largest_integer_sum_case_2(): assert largestIntegerSum(10, 0) == 4 def test_largest_integer_sum_case_3(): assert largestIntegerSum(5, 5) == 4 def test_largest_integer_sum_case_4(): assert largestIntegerSum(1, 1) == 1 def test_largest_integer_sum_case_5(): assert largestIntegerSum(0, 0) == 0 def test_largest_integer_sum_case_6(): assert largestIntegerSum(15, 15) == 7 def test_largest_integer_sum_large_numbers(): assert largestIntegerSum(1000, 1000) == 62","solution":"def largestIntegerSum(x, y): Returns the largest integer n such that the sum of the integers from 1 to n is less than or equal to the sum of x and y. Parameters: x (int): First integer y (int): Second integer Returns: int: Largest possible integer n total_sum = x + y n = 1 while n * (n + 1) // 2 <= total_sum: n += 1 return n - 1"},{"question":"def smallest_lexicographic_substring(s: str, k: int) -> str: Returns the smallest lexicographically substring of length k from string s. If there is no such substring, return an empty string. >>> smallest_lexicographic_substring(\\"abcde\\", 3) == \\"abc\\" >>> smallest_lexicographic_substring(\\"dcba\\", 2) == \\"ba\\" >>> smallest_lexicographic_substring(\\"z\\", 1) == \\"z\\" >>> smallest_lexicographic_substring(\\"xyzabc\\", 6) == \\"xyzabc\\" >>> smallest_lexicographic_substring(\\"\\", 2) == \\"\\" >>> smallest_lexicographic_substring(\\"abcd\\", 5) == \\"\\" >>> smallest_lexicographic_substring(\\"aaaaa\\", 3) == \\"aaa\\" >>> smallest_lexicographic_substring(\\"abcd\\", 0) == \\"\\" >>> smallest_lexicographic_substring(\\"bcda\\", 1) == \\"a\\" >>> smallest_lexicographic_substring(\\"acbdxyz\\", 3) == \\"acb\\"","solution":"def smallest_lexicographic_substring(s, k): Returns the smallest lexicographically substring of length k from string s. If there is no such substring, return an empty string. if len(s) < k or k <= 0: return \\"\\" min_substring = s[:k] for i in range(1, len(s) - k + 1): current_substring = s[i:i+k] if current_substring < min_substring: min_substring = current_substring return min_substring"},{"question":"def length_of_lis(arr: List[int]) -> int: Returns the length of the longest increasing subsequence from the given array. Parameters: arr (List[int]): List of unique integers. Returns: int: Length of the longest increasing subsequence. >>> length_of_lis([]) == 0 >>> length_of_lis([10]) == 1 >>> length_of_lis([1, 2, 3, 4, 5]) == 5 >>> length_of_lis([5, 4, 3, 2, 1]) == 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> length_of_lis([0, 8, 4, 12, 2]) == 3 >>> length_of_lis([1, 3, 6, 7, 9, 4, 10, 5, 6]) == 6","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence from the given array. Parameters: arr (List[int]): List of unique integers. Returns: int: Length of the longest increasing subsequence. if not arr: return 0 # Initialize DP array with 1s since the shortest increasing subsequence is 1 lis = [1] * len(arr) # Fill \`lis\` array in a bottom-up DP fashion for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) # Return the maximum value in the \`lis\` array return max(lis)"},{"question":"def min_subarray_length(arr: List[int], threshold: int) -> int: Returns the length of the shortest subarray of \`arr\` with a sum greater than or equal to \`threshold\`. If no such subarray exists, returns -1. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) == 2 >>> min_subarray_length([1, 4, 4], 4) == 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) == -1 >>> min_subarray_length([1, 2, 3, 4, 5], 11) == 3 >>> min_subarray_length([] , 5) == -1 >>> min_subarray_length([1, 2, 3, 4, 5], 15) == 5","solution":"def min_subarray_length(arr, threshold): Returns the length of the shortest subarray of \`arr\` with a sum greater than or equal to \`threshold\`. If no such subarray exists, returns -1. n = len(arr) min_len = float('inf') # Start with an infinitely large number start = 0 current_sum = 0 for end in range(n): current_sum += arr[end] while current_sum >= threshold: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 # If min_len was never updated, return -1 return min_len if min_len != float('inf') else -1"},{"question":"def shortest_to_char(s: str, ch: str) -> List[int]: Given a string \`s\` consisting of lowercase English letters and a character \`ch\`, return an array of integers representing the shortest distance from each character in the string to the character \`ch\`. If the character \`ch\` does not exist in the string, return an array of the same length as \`s\` filled with \`-1\`. >>> shortest_to_char(\\"loveleetcode\\", 'e') == [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_to_char(\\"a\\", 'a') == [0] >>> shortest_to_char(\\"abcd\\", 'e') == [-1, -1, -1, -1] >>> shortest_to_char(\\"aaaa\\", 'a') == [0, 0, 0, 0] >>> shortest_to_char(\\"abacaba\\", 'b') == [1, 0, 1, 2, 1, 0, 1] >>> shortest_to_char(\\"baa\\", 'b') == [0, 1, 2] >>> shortest_to_char(\\"aab\\", 'b') == [2, 1, 0]","solution":"def shortest_to_char(s, ch): Given a string \`s\` consisting of lowercase English letters and a character \`ch\`, returns an array of integers representing the shortest distance from each character in the string to the character \`ch\`. If the character \`ch\` does not exist in the string, returns an array of the same length as \`s\` filled with \`-1\`. if ch not in s: return [-1] * len(s) n = len(s) result = [float('inf')] * n # Forward pass distance = float('inf') for i in range(n): if s[i] == ch: distance = 0 result[i] = distance if distance != float('inf'): distance += 1 # Backward pass distance = float('inf') for i in range(n-1, -1, -1): if s[i] == ch: distance = 0 result[i] = min(result[i], distance) if distance != float('inf'): distance += 1 return result"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root: TreeNode) -> bool: Determines if a binary tree is height-balanced. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is height-balanced, False otherwise >>> is_balanced(None) True >>> root = TreeNode(1) >>> is_balanced(root) True >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> is_balanced(root) True >>> root = TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4)))) >>> is_balanced(root) False >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> is_balanced(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced(root): Determines if a binary tree is height-balanced. :param root: TreeNode, the root of the binary tree :return: bool, True if the tree is height-balanced, False otherwise def check_balanced(node): if not node: return 0, True left_height, left_balanced = check_balanced(node.left) right_height, right_balanced = check_balanced(node.right) current_height = 1 + max(left_height, right_height) is_current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, is_current_balanced return check_balanced(root)[1]"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of rainwater trapped. :param height: List[int] - non-negative integers representing building heights :return: int - total amount of rainwater trapped >>> trap([]) 0 >>> trap([1]) 0 >>> trap([1, 2]) 0 >>> trap([2, 2, 2, 2]) 0 >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trap([4,2,0,3,2,5]) 9","solution":"def trap(height): Calculate the total amount of rainwater trapped. :param height: List[int] - non-negative integers representing building heights :return: int - total amount of rainwater trapped if not height: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] total_water = 0 while left < right: if height[left] < height[right]: left += 1 left_max = max(left_max, height[left]) total_water += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) total_water += max(0, right_max - height[right]) return total_water"},{"question":"from typing import List def can_split(nums: List[int], m: int, k: int) -> bool: Determines if the nums array can be split into exactly \`m\` non-empty subarrays such that the sum of the maximum elements of these subarrays is at least \`k\`. Args: nums (List[int]): List of integers. m (int): Number of subarrays. k (int): Minimum required sum of maximum elements of subarrays. Returns: bool: True if possible to partition as described, otherwise False. >>> can_split([7, 2, 5, 10, 8], 2, 15) == True >>> can_split([1, 2, 3, 4, 5], 2, 15) == False >>> can_split([1, 2, 3], 4, 5) == False >>> can_split([1, 5, 2, 6, 3], 3, 9) == True >>> can_split([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 4, 20) == True","solution":"def can_split(nums, m, k): Determines if the nums array can be split into exactly m non-empty subarrays such that the sum of the maximum elements of these subarrays is at least k. Args: nums (list of int): List of integers. m (int): Number of subarrays. k (int): Minimum required sum of maximum elements of subarrays. Returns: bool: True if possible to partition as described, otherwise False. if len(nums) < m: return False # Function to determine if a given limit for maximum subarray sum is possible def can_partition_with_max_sum(limit): count = 1 current_sum = 0 for num in nums: if current_sum + num > limit: count += 1 current_sum = num if count > m: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_partition_with_max_sum(mid): right = mid else: left = mid + 1 max_each_subarray_sum_possible = left if can_partition_with_max_sum(max_each_subarray_sum_possible): return sum([max(nums[i:i + len(nums) // m]) for i in range(0, len(nums), len(nums) // m)]) >= k return False"},{"question":"def subarray_sum(arr, k): Returns the number of subarrays with elements that sum up to k. >>> subarray_sum([1, 1, 1], 2) == 2 >>> subarray_sum([1, 2, 3], 3) == 2 >>> subarray_sum([1, 2, 3, -3, 2, 1, 1, 1], 3) == 6 >>> subarray_sum([0, 0, 0], 0) == 6 >>> subarray_sum([1, -1, 1, -1, 1, -1], 0) == 9 >>> subarray_sum([-1, -1, 1], 0) == 1","solution":"def subarray_sum(arr, k): Returns the number of subarrays with elements that sum up to k. from collections import defaultdict count = 0 current_sum = 0 sum_dict = defaultdict(int) sum_dict[0] = 1 # there is one way to have a sum of 0 (with an empty subarray) for num in arr: current_sum += num if (current_sum - k) in sum_dict: count += sum_dict[current_sum - k] sum_dict[current_sum] += 1 return count"},{"question":"def findWinners(matches: List[List[int]]) -> List[int]: Determines the winners of a gaming competition. A player is considered a winner if they won all their matches. Parameters: matches (list of list): Each sub-list consists of three elements [player_id, opponent_id, result]. The result is 1 if \`player_id\` won, and 0 if \`opponent_id\` won. Returns: list: List of winner player IDs in ascending order. >>> findWinners([ ... [1, 2, 1], # 1 wins ... [1, 3, 1], # 1 wins ... [4, 2, 1], # 4 wins ... [4, 3, 1] # 4 wins ... ]) == [1, 4] >>> findWinners([ ... [1, 2, 1], # 1 wins ... [2, 3, 1], # 2 wins ... [3, 1, 1] # 3 wins ... ]) == [] >>> findWinners([ ... [1, 2, 1], # 1 wins ... [1, 3, 1], # 1 wins ... [3, 4, 0], # 4 wins ... [4, 2, 1] # 4 wins ... ]) == [1, 4] >>> findWinners([ ... [1, 2, 1], # 1 wins ... [3, 4, 1], # 3 wins ... [5, 6, 1], # 5 wins ... [7, 8, 1] # 7 wins ... ]) == [1, 3, 5, 7] >>> findWinners([]) == []","solution":"def findWinners(matches): Determines the winners of a gaming competition. A player is considered a winner if they won all their matches. Parameters: matches (list of list): Each sub-list consists of three elements [player_id, opponent_id, result]. The result is 1 if \`player_id\` won, and 0 if \`opponent_id\` won. Returns: list: List of winner player IDs in ascending order. from collections import defaultdict # Win and lose counters for each player wins = defaultdict(int) losses = defaultdict(int) players = set() for match in matches: player_id, opponent_id, result = match players.add(player_id) players.add(opponent_id) if result == 1: wins[player_id] += 1 losses[opponent_id] += 1 else: wins[opponent_id] += 1 losses[player_id] += 1 # A player is a winner if they won all their matches (i.e., they have 0 losses) winners = [player for player in players if losses[player] == 0] return sorted(winners)"},{"question":"def max_non_overlapping_requests(n: int, requests: List[List[int]]) -> int: Returns the maximum number of non-overlapping requests. Parameters: n (int): Number of slots. requests (List[List[int]]): List of [start, end] for each request. Returns: int: Maximum number of requests that can be accommodated without overlap. >>> max_non_overlapping_requests(10, [[0, 5]]) == 1 >>> max_non_overlapping_requests(10, [[0, 2], [3, 5], [6, 9]]) == 3 >>> max_non_overlapping_requests(10, [[0, 5], [1, 6], [7, 9]]) == 2 >>> max_non_overlapping_requests(10, [[0, 2], [1, 5], [3, 4], [6, 7], [8, 9]]) == 4 >>> max_non_overlapping_requests(10, [[0, 9], [1, 8], [2, 7], [3, 6]]) == 1 >>> max_non_overlapping_requests(10, []) == 0 >>> max_non_overlapping_requests(10, [[0, 5], [1, 5], [2, 5], [3, 5]]) == 1","solution":"def max_non_overlapping_requests(n, requests): Returns the maximum number of non-overlapping requests. Parameters: n (int): Number of slots. requests (List[List[int]]): List of [start, end] for each request. Returns: int: Maximum number of requests that can be accommodated without overlap. # Sort requests based on the ending slot requests.sort(key=lambda x: x[1]) count = 0 last_end = -1 for start, end in requests: if start > last_end: count += 1 last_end = end return count"},{"question":"def find_duplicate_id(ids: List[int]) -> int: Finds and returns the ID number that is repeated exactly twice. The list is sorted in non-decreasing order. Time complexity: O(log n) pass from typing import List def test_single_duplicate(): assert find_duplicate_id([1, 2, 3, 4, 4, 5, 6]) == 4 def test_duplicate_at_start(): assert find_duplicate_id([1, 1, 2, 3, 4, 5, 6]) == 1 def test_duplicate_at_end(): assert find_duplicate_id([1, 2, 3, 4, 5, 6, 6]) == 6 def test_large_range(): ids = list(range(1, 100001)) + [50000] ids.sort() assert find_duplicate_id(ids) == 50000 def test_small_list(): assert find_duplicate_id([1, 1]) == 1 def test_duplicate_in_middle(): assert find_duplicate_id([1, 2, 3, 4, 5, 6, 7, 7, 8, 9, 10]) == 7","solution":"def find_duplicate_id(ids): Finds and returns the ID number that is repeated exactly twice. The list is sorted in non-decreasing order. Time complexity: O(log n) left, right = 0, len(ids) - 1 while left < right: mid = left + (right - left) // 2 # Check the number of unique numbers on the left part of the array if ids[mid] >= mid + ids[0]: left = mid + 1 else: right = mid return ids[left]"},{"question":"def min_watering_time(plants: List[int], capacity: int, refillTime: int) -> int: Calculate the minimum time required to water all the plants. Parameters: - plants: list of int, each representing the water required by each plant. - capacity: int, capacity of the watering can. - refillTime: int, time taken to refill the watering can. Returns: - int, minimum time required to water all plants. >>> min_watering_time([2, 3, 4], 5, 1) 1 >>> min_watering_time([2, 3, 5], 5, 2) 2 >>> min_watering_time([3, 3, 3], 3, 5) 10 >>> min_watering_time([1, 2, 3, 4], 4, 2) 4 >>> min_watering_time([1, 1, 1, 1], 1, 1) 3 >>> min_watering_time([5, 5, 5, 5], 5, 1) 3","solution":"def min_watering_time(plants, capacity, refillTime): Calculate the minimum time required to water all the plants. Parameters: - plants: list of int, each representing the water required by each plant. - capacity: int, capacity of the watering can. - refillTime: int, time taken to refill the watering can. Returns: - int, minimum time required to water all plants. time = 0 current_water = capacity for water_needed in plants: if current_water >= water_needed: current_water -= water_needed else: time += refillTime current_water = capacity - water_needed return time"},{"question":"def min_distance(s: str, t: str) -> int: Returns the minimum number of operations required to transform string s into string t. The operations allowed are Insert, Delete, Replace. >>> min_distance(\\"horse\\", \\"ros\\") == 3 >>> min_distance(\\"intention\\", \\"execution\\") == 5 >>> min_distance(\\"\\", \\"abc\\") == 3 >>> min_distance(\\"abc\\", \\"\\") == 3 >>> min_distance(\\"abcdef\\", \\"abcdef\\") == 0 >>> min_distance(\\"kitten\\", \\"sitting\\") == 3 >>> min_distance(\\"flaw\\", \\"lawn\\") == 2 >>> min_distance(\\"gumbo\\", \\"gambol\\") == 2","solution":"def min_distance(s, t): Returns the minimum number of operations required to transform string s into string t. The operations allowed are Insert, Delete, Replace. m, n = len(s), len(t) # Create a DP table to store the number of operations required dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the table with the base cases for i in range(m + 1): dp[i][0] = i # Delete all characters from s to make it empty for j in range(n + 1): dp[0][j] = j # Insert all characters of t into s # Fill the DP table for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j - 1], # Replace dp[i - 1][j], # Delete dp[i][j - 1]) # Insert dp[i][j] += 1 return dp[m][n]"},{"question":"def generate_pascal_triangle(numRows): Generate the first \`numRows\` of Pascal's Triangle. Each number is the sum of the two numbers directly above it. The triangle starts with a single \`1\` at the top, and each row has one more number than the previous row. For example, if \`numRows\` is \`5\`, the result should be: [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] :param numRows: The number of rows of Pascal's Triangle to generate :type numRows: int :return: A list of lists representing the first \`numRows\` of Pascal's Triangle :rtype: list >>> generate_pascal_triangle(0) [] >>> generate_pascal_triangle(1) [[1]] >>> generate_pascal_triangle(2) [[1], [1, 1]] >>> generate_pascal_triangle(3) [[1], [1, 1], [1, 2, 1]] >>> generate_pascal_triangle(4) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]] >>> generate_pascal_triangle(5) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> generate_pascal_triangle(6) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]] >>> generate_pascal_triangle(-3) []","solution":"def generate_pascal_triangle(numRows): Generate the first \`numRows\` of Pascal's Triangle. :param numRows: The number of rows of Pascal's Triangle to generate :type numRows: int :return: A list of lists representing the first \`numRows\` of Pascal's Triangle :rtype: list if numRows <= 0: return [] triangle = [[1]] for row_num in range(1, numRows): row = [1] prev_row = triangle[row_num - 1] for i in range(1, row_num): row.append(prev_row[i - 1] + prev_row[i]) row.append(1) triangle.append(row) return triangle"},{"question":"from typing import List def min_subset_sum_diff(arr: List[int]) -> int: Given an even-sized array, splits it into two subsets of equal size and returns the minimum possible absolute difference between the sums of the two subsets. >>> min_subset_sum_diff([1, 2, 3, 4]) 0 >>> min_subset_sum_diff([10, 20, 15, 25]) 0 >>> min_subset_sum_diff([1, 6, 11, 5]) 1 >>> min_subset_sum_diff([2, 2, 2, 2]) 0 >>> min_subset_sum_diff([1, 2, 1, 2]) 0 >>> min_subset_sum_diff([2, -1, 5, 3]) 1","solution":"from itertools import combinations def min_subset_sum_diff(arr): Given an even-sized array, splits it into two subsets of equal size and returns the minimum possible absolute difference between the sums of the two subsets. n = len(arr) total_sum = sum(arr) half_n = n // 2 # Generate all combinations of size half_n combinations_list = list(combinations(arr, half_n)) min_diff = float('inf') for combo in combinations_list: subset_sum = sum(combo) complement_sum = total_sum - subset_sum diff = abs(subset_sum - complement_sum) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def shortest_path_bfs(matrix: List[List[int]]) -> int: Finds the shortest path in a binary matrix from top-left to bottom-right corner using BFS. Args: matrix: List[List[int]] - Binary matrix containing 0s and 1s where 0 represents empty cell and 1 represents blocked cell. Returns: int - Length of the shortest path from top-left to bottom-right corner. If no such path exists, return -1. >>> shortest_path_bfs([ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 0, 0] ... ]) 9 >>> shortest_path_bfs([ ... [0, 1, 0, 0, 0], ... [1, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 1, 1, 0], ... [0, 0, 0, 0, 0] ... ]) -1","solution":"from collections import deque def shortest_path_bfs(matrix): Finds the shortest path in a binary matrix from top-left to bottom-right corner using BFS. Args: matrix: List[List[int]] - Binary matrix containing 0s and 1s where 0 represents empty cell and 1 represents blocked cell. Returns: int - Length of the shortest path from top-left to bottom-right corner. If no such path exists, return -1. if not matrix or not matrix[0] or matrix[0][0] == 1 or matrix[-1][-1] == 1: return -1 n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up queue = deque([(0, 0, 1)]) # (x, y, distance) matrix[0][0] = 1 # mark as visited while queue: x, y, distance = queue.popleft() if x == n - 1 and y == m - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 0: queue.append((nx, ny, distance + 1)) matrix[nx][ny] = 1 # mark as visited return -1"},{"question":"def minimize_string_by_removal(s: str, k: int) -> str: Minimize the lexicographical order of the string \`s\` by exactly removing \`k\` characters. >>> minimize_string_by_removal(\\"abc\\", 1) == \\"ab\\" >>> minimize_string_by_removal(\\"cab\\", 2) == \\"a\\" >>> minimize_string_by_removal(\\"bcabc\\", 2) == \\"abc\\" >>> minimize_string_by_removal(\\"baabaa\\", 3) == \\"aaa\\" >>> minimize_string_by_removal(\\"a\\", 1) == \\"\\" >>> minimize_string_by_removal(\\"abcde\\", 0) == \\"abcde\\" >>> minimize_string_by_removal(\\"abcd\\", 4) == \\"\\" >>> minimize_string_by_removal(\\"acbdge\\", 3) == \\"abd\\" >>> minimize_string_by_removal(\\"bbca\\", 2) == \\"ba\\" >>> minimize_string_by_removal(\\"adbac\\", 2) == \\"aac\\" >>> minimize_string_by_removal(\\"aaaa\\", 2) == \\"aa\\" >>> minimize_string_by_removal(\\"bbbb\\", 3) == \\"b\\"","solution":"def minimize_string_by_removal(s, k): This function minimizes the lexicographical order of the string \`s\` by exactly removing \`k\` characters. Parameters: s (str): The input string k (int): The number of characters to remove Returns: str: The minimized lexicographical order string stack = [] for char in s: while k > 0 and stack and stack[-1] > char: stack.pop() k -= 1 stack.append(char) # If there are still characters to remove, remove them from the end final_stack = stack[:-k] if k > 0 else stack return ''.join(final_stack)"},{"question":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling one stock. :param prices: List[int] - List of stock prices where prices[i] is the price on the ith day. :return: int - Maximum profit possible, or 0 if no profit can be made.","solution":"def maxProfit(prices): Returns the maximum profit that can be achieved by buying and selling one stock. :param prices: List[int] - List of stock prices where prices[i] is the price on the ith day. :return: int - Maximum profit possible, or 0 if no profit can be made. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges all overlapping intervals and returns an array of the merged intervals. Args: intervals (list of lists): A list of [start, end] intervals. Returns: list of lists: A list of the merged intervals in ascending order by their starting point. >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) == [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) == [[1, 5]] >>> merge_intervals([[1, 4], [2, 3], [3, 4]]) == [[1, 4]] >>> merge_intervals([[1, 10], [2, 6], [8, 10], [15, 18]]) == [[1, 10], [15, 18]] >>> merge_intervals([]) == [] >>> merge_intervals([[5, 7]]) == [[5, 7]] >>> merge_intervals([[1, 5], [2, 3], [4, 8], [10, 12], [11, 15]]) == [[1, 8], [10, 15]]","solution":"def merge_intervals(intervals): Merges all overlapping intervals and returns an array of the merged intervals. Args: intervals (list of lists): A list of [start, end] intervals. Returns: list of lists: A list of the merged intervals in ascending order by their starting point. if not intervals: return [] # Sort the intervals based on the starting points intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If the list of merged intervals is empty or if the current interval does not overlap with the last one, add it. if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # Otherwise, there is overlap, so we merge the current interval with the last one. merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def min_operations_to_one_component(grid: List[List[int]]) -> int: Return the minimum number of operations required to turn the grid into a grid with exactly one connected component of land. >>> min_operations_to_one_component([[1, 1, 0], [1, 1, 0], [0, 0, 0]]) == 0 >>> min_operations_to_one_component([[0, 0], [0, 0]]) == 0 >>> min_operations_to_one_component([[1, 0, 0, 1], [0, 0, 0, 0], [1, 0, 1, 1]]) == 3 >>> min_operations_to_one_component([[1, 1], [1, 1]]) == 0 >>> min_operations_to_one_component([[1, 0, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 0], [0, 0, 0, 1, 1]]) == 3","solution":"from collections import deque # Define direction vectors for 4-directional movement (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def bfs(x, y, grid, visited): m, n = len(grid), len(grid[0]) queue = deque([(x, y)]) visited[x][y] = True while queue: cx, cy = queue.popleft() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 1: visited[nx][ny] = True queue.append((nx, ny)) def count_components(grid): m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] count = 0 for i in range(m): for j in range(n): if grid[i][j] == 1 and not visited[i][j]: count += 1 bfs(i, j, grid, visited) return count def min_operations_to_one_component(grid): components = count_components(grid) # If already one component, return 0 return max(components - 1, 0)"},{"question":"def reverse_in_groups(arr, k): Given an array of integers \`arr\`, reverse the order of elements in each subarray of size \`k\`. If the number of elements in the last subarray is less than \`k\`, simply reverse all the remaining elements. The array should be modified in place. Return the modified array. :param arr: List[int] - the array of integers to be modified. :param k: int - the size of the subarray to be reversed. :return: List[int] - the modified array with the reversed subarrays. >>> reverse_in_groups([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) [3, 2, 1, 6, 5, 4, 9, 8, 7] >>> reverse_in_groups([1, 2, 3, 4, 5, 6, 7], 3) [3, 2, 1, 6, 5, 4, 7] >>> reverse_in_groups([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], 4) [4, 3, 2, 1, 8, 7, 6, 5, 12, 11, 10, 9] >>> reverse_in_groups([1, 2, 3, 4, 5, 6, 7, 8], 2) [2, 1, 4, 3, 6, 5, 8, 7] >>> reverse_in_groups([1, 2, 3, 4, 5], 10) [5, 4, 3, 2, 1] >>> reverse_in_groups([1, 2, 3, 4, 5], 1) [1, 2, 3, 4, 5] >>> reverse_in_groups([], 3) []","solution":"def reverse_in_groups(arr, k): Reverses the order of elements in each subarray of size \`k\`. If the number of elements in the last subarray is less than \`k\`, reverse all the remaining elements. The array is modified in place. :param arr: List[int] - the array of integers to be modified. :param k: int - the size of the subarray to be reversed. :return: List[int] - the modified array with the reversed subarrays. n = len(arr) for start in range(0, n, k): end = min(start + k, n) arr[start:end] = arr[start:end][::-1] return arr"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Find all strings in words that match the pattern. A word matches the pattern if there exists some permutation of letters p so that after replacing every letter x in the pattern with p(x), you get exactly the word. >>> find_and_replace_pattern([\\"abc\\",\\"deq\\",\\"mee\\",\\"aqq\\",\\"dkd\\",\\"ccc\\"], \\"abb\\") == [\\"mee\\",\\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\",\\"cba\\",\\"xyx\\",\\"yxx\\",\\"yyx\\"], \\"abc\\") == [\\"abc\\",\\"cba\\"] >>> find_and_replace_pattern([\\"a\\",\\"b\\",\\"c\\"], \\"a\\") == [\\"a\\",\\"b\\",\\"c\\"] >>> find_and_replace_pattern([], \\"xyz\\") == [] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"aaa\\") == [] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"mnop\\") == [\\"abcd\\", \\"efgh\\", \\"ijkl\\"] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\", \\"aa\\", \\"bb\\"], \\"a\\") == [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"xy\\") == []","solution":"def find_and_replace_pattern(words, pattern): def match(word): if len(word) != len(pattern): return False word_to_pattern = {} pattern_to_word = {} for w, p in zip(word, pattern): if w not in word_to_pattern: word_to_pattern[w] = p if p not in pattern_to_word: pattern_to_word[p] = w if word_to_pattern[w] != p or pattern_to_word[p] != w: return False return True return [word for word in words if match(word)]"},{"question":"class MatrixManipulator: def __init__(self, mat): Initialize the MatrixManipulator with a 2D integer array 'mat'. pass def transpose(self): Transpose the matrix. pass def rotate(self, direction): Rotate the matrix 90 degrees. Parameters: direction (str): The direction of rotation, either 'clockwise' or 'counterclockwise'. pass def sumRegion(self, row1, col1, row2, col2): Return the sum of elements in the rectangular region defined by the corners (row1, col1) and (row2, col2) inclusive. Parameters: row1 (int): The starting row index. col1 (int): The starting column index. row2 (int): The ending row index. col2 (int): The ending column index. pass import pytest def test_transpose(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) manipulator.transpose() assert manipulator.mat == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] def test_transpose_non_square(): mat = [[1, 2], [3, 4], [5, 6]] manipulator = MatrixManipulator(mat) manipulator.transpose() assert manipulator.mat == [[1, 3, 5], [2, 4, 6]] def test_rotate_clockwise(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) manipulator.rotate('clockwise') assert manipulator.mat == [[7, 4, 1], [8, 5, 2], [9, 6, 3]] def test_rotate_counterclockwise(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) manipulator.rotate('counterclockwise') assert manipulator.mat == [[3, 6, 9], [2, 5, 8], [1, 4, 7]] def test_sumRegion(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) assert manipulator.sumRegion(0, 0, 1, 1) == 12 # (1+2+4+5) assert manipulator.sumRegion(1, 1, 2, 2) == 28 # (5+6+8+9) assert manipulator.sumRegion(0, 0, 2, 2) == 45 # (1+2+3+4+5+6+7+8+9) def test_sumRegion_single_element(): mat = [[1, 2], [3, 4]] manipulator = MatrixManipulator(mat) assert manipulator.sumRegion(1, 1, 1, 1) == 4 def test_sumRegion_row(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) assert manipulator.sumRegion(1, 0, 1, 2) == 15 # (4+5+6) def test_sumRegion_column(): mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] manipulator = MatrixManipulator(mat) assert manipulator.sumRegion(0, 1, 2, 1) == 15 # (2+5+8)","solution":"class MatrixManipulator: def __init__(self, mat): self.mat = mat def transpose(self): self.mat = list(map(list, zip(*self.mat))) def rotate(self, direction): if direction == 'clockwise': self.transpose() for row in self.mat: row.reverse() elif direction == 'counterclockwise': self.transpose() self.mat.reverse() def sumRegion(self, row1, col1, row2, col2): return sum( self.mat[i][j] for i in range(row1, row2 + 1) for j in range(col1, col2 + 1) )"},{"question":"def min_swaps_to_transform(s: str, target: str) -> int: Find the minimum number of operations required to transform \`s\` into \`target\`. The only allowed operation is swapping any two adjacent characters in \`s\`. Return the minimum number of swaps, or -1 if it is impossible to do so. >>> min_swaps_to_transform(\\"ab\\", \\"ba\\") 1 >>> min_swaps_to_transform(\\"abc\\", \\"bca\\") 2 >>> min_swaps_to_transform(\\"aabb\\", \\"abab\\") 1 >>> min_swaps_to_transform(\\"abcd\\", \\"dcba\\") 6 >>> min_swaps_to_transform(\\"a\\", \\"a\\") 0 >>> min_swaps_to_transform(\\"abc\\", \\"def\\") -1 >>> min_swaps_to_transform(\\"abac\\", \\"baca\\") 2","solution":"def min_swaps_to_transform(s, target): if sorted(s) != sorted(target): return -1 def count_inversions(s_list): inversions = 0 for i in range(len(s_list)): for j in range(i + 1, len(s_list)): if s_list[i] > s_list[j]: inversions += 1 return inversions s_list = list(s) target_list = list(target) inversions_initial = count_inversions(s_list) inversions_target = count_inversions(target_list) return abs(inversions_initial - inversions_target)"},{"question":"def num_subarrays_with_product_less_than_n(arr: List[int], n: int) -> int: Returns the count of subarrays whose product of elements is less than n. >>> num_subarrays_with_product_less_than_n([10, 5, 2, 6], 100) == 8 >>> num_subarrays_with_product_less_than_n([1, 2, 3], 10) == 6 >>> num_subarrays_with_product_less_than_n([10, 20, 30], 5) == 0 >>> num_subarrays_with_product_less_than_n([1], 2) == 1 >>> num_subarrays_with_product_less_than_n([2], 2) == 0 >>> num_subarrays_with_product_less_than_n([], 10) == 0 >>> num_subarrays_with_product_less_than_n([5, 6, 7], 1000) == 6 >>> num_subarrays_with_product_less_than_n([1, 2, 3], 1) == 0","solution":"def num_subarrays_with_product_less_than_n(arr, n): Returns the count of subarrays whose product of elements is less than n. if n <= 1: return 0 count = 0 product = 1 start = 0 for end in range(len(arr)): product *= arr[end] while product >= n and start <= end: product //= arr[start] start += 1 count += (end - start + 1) return count"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Given an array of integers nums of length n, find the maximum sum you can obtain by forming a contiguous subarray. Your function should return an integer representing this maximum sum. If the input array is empty or the maximum sum is negative, return 0. >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4]) 0 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([-5]) 0 >>> max_subarray_sum([100, -1, 2, -1, 100]) 200","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray. If the input array is empty or the maximum sum is negative, return 0. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max(max_sum, 0)"},{"question":"def largest_connected_component_sum(n: int, edges: List[List[int]], nodeValue: List[int]) -> int: Find the sum of node values for the largest connected component in the graph. >>> largest_connected_component_sum(4, [[0, 1], [1, 2], [2, 3]], [1, 2, 3, 4]) 10 >>> largest_connected_component_sum(5, [[0, 1], [2, 3], [3, 4]], [1, 2, 10, 20, 30]) 60 >>> largest_connected_component_sum(4, [[0, 1], [2, 3]], [10, 20, 30, 40]) 70 >>> largest_connected_component_sum(1, [], [100]) 100 >>> largest_connected_component_sum(3, [], [5, 10, 20]) 20 pass","solution":"def largest_connected_component_sum(n, edges, nodeValue): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited[node] = True component_sum = 0 while queue: current = queue.popleft() component_sum += nodeValue[current] for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return component_sum # Create the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * n max_sum = 0 for i in range(n): if not visited[i]: component_sum = bfs(i) max_sum = max(max_sum, component_sum) return max_sum"},{"question":"def min_operations(nums: List[int]) -> int: Return the minimum number of operations needed to make all elements of the array pairwise distinct. You are given an integer array \`nums\` and you are allowed to perform a specific operation any number of times on \`nums\`. In one operation, you can choose any element of the array and increment it by 1. >>> min_operations([3,2,1,2,1,7]) 6 >>> min_operations([1,2,3,4,5]) 0 >>> min_operations([1,1,1,1,1]) 10 >>> min_operations([10,9,8,7,6]) 0 >>> min_operations([5]) 0 >>> min_operations([1,1]) 1 >>> min_operations([2, 2, 2, 2, 2, 2]) 15","solution":"def min_operations(nums): nums.sort() operations = 0 for i in range(1, len(nums)): if nums[i] <= nums[i - 1]: increment = nums[i - 1] - nums[i] + 1 nums[i] += increment operations += increment return operations"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Finds the length of the longest common subsequence between two strings. Args: s1 (str): The first string. s2 (str): The second string. Returns: int: The length of the longest common subsequence. Examples: >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(s1, s2): Finds the length of the longest common subsequence between two strings s1 and s2. :param s1: First string :param s2: Second string :return: Length of the longest common subsequence m, n = len(s1), len(s2) # Create a 2D list (m+1) x (n+1) filled with zeros dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array, iterating through each character of both strings for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of the longest common subsequence is at dp[m][n] return dp[m][n]"},{"question":"def maximum_sum(nums: List[int]) -> int: Given an integer array \`nums\` of length \`n\`, find the maximum sum you can obtain by selecting some non-empty subarray (contiguous elements) of \`nums\` such that, for each selected subarray, at most one element can be deleted. You may assume that the given array contains at least one positive element. Return the maximum possible sum of the subarray, considering the constraint of deleting at most one element. >>> maximum_sum([5]) == 5 >>> maximum_sum([1, 2, 3, 4]) == 10 >>> maximum_sum([1, -2, 3, 4]) == 8 >>> maximum_sum([-1, -2, -3, -4, -5]) == -1 >>> maximum_sum([1, -2, 0, 3]) == 4 >>> maximum_sum([10, -50, 10, -50, 10, -50, 10]) == 20 >>> maximum_sum([1, -1, 1, -1, 1]) == 2","solution":"def maximum_sum(nums): Returns the maximum sum of a subarray with at most one element deletion. n = len(nums) if n == 1: return nums[0] max_ending_here = [0] * n max_starting_here = [0] * n # Initialize the first elements max_ending_here[0] = nums[0] for i in range(1, n): max_ending_here[i] = max(nums[i], max_ending_here[i-1] + nums[i]) max_starting_here[n-1] = nums[n-1] for i in range(n-2, -1, -1): max_starting_here[i] = max(nums[i], max_starting_here[i+1] + nums[i]) max_sum = max(max_ending_here) # This is the max sum without deleting any element for i in range(1, n-1): max_sum = max(max_sum, max_ending_here[i-1] + max_starting_here[i+1]) return max_sum"},{"question":"def max_area(height: List[int]) -> int: Returns the maximum amount of water a container can store. >>> max_area([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> max_area([4, 3, 2, 1, 4]) 16 >>> max_area([1, 2, 1]) 2 >>> max_area([1, 1]) 1 >>> max_area([1, 2, 4, 3]) 4 >>> max_area([1, 0, 0, 0, 0, 0, 0, 1]) 7","solution":"def max_area(height): Returns the maximum amount of water a container can store. max_water = 0 left, right = 0, len(height) - 1 while left < right: # Calculating the width and the current water amount width = right - left current_water = min(height[left], height[right]) * width # Updating the maximum water if the current is larger max_water = max(max_water, current_water) # Moving the pointer with the smaller height inward if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"from typing import List def shortest_distance_to_land(grid: List[List[int]]) -> int: Given a 2D grid of size \`m x n\` where each cell represents a piece of land marked by \`1\` or water marked by \`0\`, find the shortest distance from any water cell to the nearest land cell. The distance between two cells is measured by the number of cells traversed in a 4-directional path (up, down, left, right). Return the shortest such distance. If there is no water cell or no land cell in the grid, return -1. >>> shortest_distance_to_land([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == -1 >>> shortest_distance_to_land([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == -1 >>> shortest_distance_to_land([ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) == 1 >>> shortest_distance_to_land([ ... [1, 1, 1, 1, 1], ... [1, 1, 0, 0, 1], ... [1, 0, 0, 0, 1], ... [1, 1, 1, 1, 1] ... ]) == 1 >>> shortest_distance_to_land([ ... [0, 1, 0], ... [1, 0, 1], ... [0, 1, 0] ... ]) == 1 >>> shortest_distance_to_land([ ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ]) == 1","solution":"from collections import deque def shortest_distance_to_land(grid): if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) distance = [[-1] * n for _ in range(m)] queue = deque() # Initialize the queue with all land cells and distances set to 0 for i in range(m): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) distance[i][j] = 0 if not queue: return -1 # No land cell in the grid if len(queue) == m * n: return -1 # No water cell in the grid directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < m and 0 <= new_y < n and distance[new_x][new_y] == -1: distance[new_x][new_y] = distance[x][y] + 1 queue.append((new_x, new_y)) shortest_distance = float('inf') for i in range(m): for j in range(n): if grid[i][j] == 0 and distance[i][j] != -1: shortest_distance = min(shortest_distance, distance[i][j]) return shortest_distance if shortest_distance != float('inf') else -1"},{"question":"def max_length_more_evens(arr: List[int]) -> int: Given an array of integers \`arr\`, find the maximum length of a contiguous subarray that satisfies the condition that there are more even numbers than odd numbers. If no such subarray exists, return \`0\`. >>> max_length_more_evens([1, 2, 2, 1, 2]) 5 >>> max_length_more_evens([1, 2, 2, 1, 1]) 4 >>> max_length_more_evens([1, 1, 1]) 0 >>> max_length_more_evens([2, 2, 2]) 3 >>> max_length_more_evens([2]) 1","solution":"def max_length_more_evens(arr): Returns the maximum length of a contiguous subarray that has more even numbers than odd numbers. If no such subarray exists, returns 0. n = len(arr) even_count = 0 odd_count = 0 max_length = 0 count_diff_map = {0: -1} for i in range(n): if arr[i] % 2 == 0: even_count += 1 else: odd_count += 1 diff = even_count - odd_count if diff > 0: max_length = i + 1 elif diff in count_diff_map: max_length = max(max_length, i - count_diff_map[diff]) else: count_diff_map[diff] = i return max_length"},{"question":"def checkValidString(s: str) -> bool: Determine if the string can be made valid by replacing the asterisks. Uses a greedy approach by tracking the possible minimum and maximum number of open parentheses at any given point in the string scan. :param s: str, input string containing '(', ')' and '*' :return: bool, True if the string can be made valid, else False >>> checkValidString(\\"()\\") == True >>> checkValidString(\\"(())\\") == True >>> checkValidString(\\"(()\\") == False >>> checkValidString(\\"())\\") == False >>> checkValidString(\\"(*)\\") == True >>> checkValidString(\\"(*))\\") == True >>> checkValidString(\\"(*()\\") == True >>> checkValidString(\\"**\\") == True >>> checkValidString(\\"()*)\\") == True >>> checkValidString(\\")(\\") == False >>> checkValidString(\\"(*))*(*)\\") == True >>> checkValidString(\\"(((((*)))\\") == False >>> checkValidString(\\"()((*\\") == False >>> checkValidString(\\"((*))(*)(*\\") == True >>> checkValidString(\\"\\") == True >>> checkValidString(\\"*\\") == True >>> checkValidString(\\"(\\") == False >>> checkValidString(\\")\\") == False >>> checkValidString(\\"(**()**)\\") == True","solution":"def checkValidString(s): Determine if the string can be made valid by replacing the asterisks. Uses a greedy approach by tracking the possible minimum and maximum number of open parentheses at any given point in the string scan. :param s: str, input string containing '(', ')' and '*' :return: bool, True if the string can be made valid, else False min_open = 0 # minimum number of open parentheses max_open = 0 # maximum number of open parentheses for char in s: if char == '(': min_open += 1 max_open += 1 elif char == ')': min_open = max(min_open - 1, 0) max_open -= 1 elif char == '*': min_open = max(min_open - 1, 0) max_open += 1 if max_open < 0: return False return min_open == 0"},{"question":"def remove_covered_intervals(intervals): Removes intervals covered by another interval from the list of intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end]. Returns: List[List[int]]: The list of intervals after removing the covered ones. Examples: >>> remove_covered_intervals([[1, 2], [3, 4], [5, 6]]) [[1, 2], [3, 4], [5, 6]] >>> remove_covered_intervals([[1, 4], [2, 3]]) [[1, 4]] >>> remove_covered_intervals([[1, 10], [2, 5], [3, 6]]) [[1, 10]] >>> remove_covered_intervals([[1, 4], [1, 3], [1, 2]]) [[1, 4]] >>> remove_covered_intervals([[1, 3], [2, 3], [0, 3]]) [[0, 3]] >>> remove_covered_intervals([[1, 4], [3, 6], [2, 8], [5, 7], [4, 5]]) [[1, 4], [2, 8]]","solution":"def remove_covered_intervals(intervals): Removes intervals covered by another interval from the list of intervals. Args: intervals (List[List[int]]): A list of intervals where each interval is represented as [start, end]. Returns: List[List[int]]: The list of intervals after removing the covered ones. # Sort intervals by starting point; if two intervals have the same start, sort by end in descending order. intervals.sort(key=lambda x: (x[0], -x[1])) remaining_intervals = [] prev_end = 0 for start, end in intervals: # An interval is not covered if its end point is greater than the previously recorded end point. if end > prev_end: remaining_intervals.append([start, end]) prev_end = end return remaining_intervals"},{"question":"from typing import List def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Given a list of words and a pattern, return a list of words that match the given pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing each letter x in the pattern with p(x), we get the desired word. >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"xyz\\"], \\"aab\\") [] >>> find_and_replace_pattern([\\"abc\\", \\"bca\\", \\"cab\\"], \\"xyz\\") [\\"abc\\", \\"bca\\", \\"cab\\"] >>> find_and_replace_pattern([], \\"xyz\\") [] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"d\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"abc\\") []","solution":"def find_and_replace_pattern(words, pattern): def match(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w, p in zip(word, pattern): if p not in char_map: if w in used_chars: return False char_map[p] = w used_chars.add(w) elif char_map[p] != w: return False return True return [word for word in words if match(word, pattern)]"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root: TreeNode, k: int) -> bool: Returns whether there exist two different nodes in the BST such that their values sum up to k. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(6) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.right = TreeNode(7) >>> find_target(root, 9) True >>> find_target(root, 28) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_target(root, k): Returns whether there exist two different nodes in the BST such that their values sum up to k. if not root: return False def inorder_traversal(node): # Conduct an in-order traversal to get a sorted list of values if not node: return [] left_values = inorder_traversal(node.left) right_values = inorder_traversal(node.right) return left_values + [node.val] + right_values values = inorder_traversal(root) left, right = 0, len(values) - 1 while left < right: current_sum = values[left] + values[right] if current_sum == k: return True elif current_sum < k: left += 1 else: right -= 1 return False"},{"question":"def longest_common_subsequence(nums1: List[int], nums2: List[int]) -> int: Returns the length of the longest common subsequence between two integer arrays nums1 and nums2. >>> longest_common_subsequence([1, 3, 4, 1], [3, 4, 1, 2, 1]) 3 >>> longest_common_subsequence([1, 2, 3], [4, 5, 6]) 0 >>> longest_common_subsequence([1, 2, 3], [1, 2, 3]) 3 >>> longest_common_subsequence([1, 3, 7, 1, 7, 5], [1, 9, 2, 5, 1]) 2 >>> longest_common_subsequence([], []) 0 >>> longest_common_subsequence([1, 2, 3], []) 0 >>> longest_common_subsequence([], [1, 2, 3]) 0","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence between nums1 and nums2. n, m = len(nums1), len(nums2) # Create a 2D DP array dp = [[0] * (m + 1) for _ in range(n + 1)] # Iterate over each element in nums1 and nums2 for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: # If elements are the same, take diagonal value and add 1 dp[i][j] = dp[i - 1][j - 1] + 1 else: # If elements are different, take the maximum of the top or left value dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def leadsToTerminal(graph: List[List[int]]) -> bool: Determines if all paths starting from node 0 lead to terminal nodes. Parameters: graph (List[List[int]]): The DAG represented by an adjacency list. Returns: bool: True if all paths from node 0 lead to terminal nodes, False otherwise. >>> leadsToTerminal([[1, 2], [3], [3], []]) True >>> leadsToTerminal([[1, 2], [2], [0], []]) False >>> leadsToTerminal([[]]) True >>> leadsToTerminal([[0]]) False >>> leadsToTerminal([[1], [2], [3], [], [], [6], []]) True >>> leadsToTerminal([[1, 2], [3], [4], [], [2]]) False","solution":"def leadsToTerminal(graph): Determines if all paths starting from node 0 lead to terminal nodes. Parameters: graph (List[List[int]]): The DAG represented by an adjacency list. Returns: bool: True if all paths from node 0 lead to terminal nodes, False otherwise. def dfs(node, visited): if visited[node] != 0: return visited[node] == 1 if not graph[node]: visited[node] = 1 return True visited[node] = -1 for neighbor in graph[node]: if not dfs(neighbor, visited): return False visited[node] = 1 return True visited = [0] * len(graph) return dfs(0, visited)"},{"question":"def maxDistance(positions, m): Given an array 'positions' of size 'n', where 'positions[i]' is the position of the 'i-th' ball on a number line. Calculate the maximum possible minimum distance between any two of the 'm' placed balls. Example: >>> maxDistance([1, 2, 8, 4, 9], 3) 3 >>> maxDistance([1, 2, 4, 8, 9], 3) 3","solution":"def canPlaceBalls(positions, m, minDist): Helper function to check if we can place \`m\` balls with at least \`minDist\` apart. count = 1 # place the first ball at the first position last_position = positions[0] for i in range(1, len(positions)): if positions[i] - last_position >= minDist: count += 1 last_position = positions[i] if count >= m: return True return False def maxDistance(positions, m): Returns the maximum possible minimum distance between the placed balls. positions.sort() low, high = 1, positions[-1] - positions[0] best = 0 while low <= high: mid = (low + high) // 2 if canPlaceBalls(positions, m, mid): best = mid low = mid + 1 else: high = mid - 1 return best"},{"question":"def max_non_overlapping_subarrays(s: int, arr: List[int]) -> int: Finds the maximum number of non-overlapping subarrays such that the sum of the elements in each subarray is equal to \`s\`. Args: s (int): the target sum for each subarray. arr (list of int): the list of integers. Returns: int: the maximum number of non-overlapping subarrays with sum equal to \`s\`. >>> max_non_overlapping_subarrays(3, [1, 1, 1, 1, 1, 1]) 2 >>> max_non_overlapping_subarrays(1, []) 0 >>> max_non_overlapping_subarrays(10, [1, 2, 3]) 0 >>> max_non_overlapping_subarrays(1, [1, -1, 1, -1, 1, -1, 1]) 4 >>> max_non_overlapping_subarrays(5, [1, 2, 3, 4, 5, -1, 1, 6, -1, 2, 3, 6]) 4","solution":"def max_non_overlapping_subarrays(s, arr): Finds the maximum number of non-overlapping subarrays such that the sum of the elements in each subarray is equal to \`s\`. Args: s (int): the target sum for each subarray. arr (list of int): the list of integers. Returns: int: the maximum number of non-overlapping subarrays with sum equal to \`s\`. count = 0 current_sum = 0 sum_indices = {0: -1} for idx, num in enumerate(arr): current_sum += num if current_sum - s in sum_indices: count += 1 sum_indices = {0: idx} current_sum = 0 else: sum_indices[current_sum] = idx return count"},{"question":"from typing import List def calculate(part: List[int]) -> int: Calculate the product of non-zero elements in the part. If the part has no non-zero elements, its product is considered to be 1. def compare_products(nums: List[int]) -> bool: Returns true if the product of non-zero elements in the left part is greater than the product of non-zero elements in the right part. Otherwise, returns false. # Unit tests def test_calculate(): assert calculate([1, 2]) == 2 assert calculate([0, 3, 4]) == 12 assert calculate([0, 0]) == 1 assert calculate([5]) == 5 assert calculate([]) == 1 def test_compare_products(): assert compare_products([1, 2, 0, 3, 4, 0]) == False assert compare_products([1, 0, 2, 0, 3, 4]) == False assert compare_products([5, 6, 1, 0]) == True assert compare_products([0, 2, 4, 1]) == False assert compare_products([1, 1, 1, 1]) == False assert compare_products([0, 0, 0, 0]) == False","solution":"def calculate(part): Calculate the product of non-zero elements in the part. If the part has no non-zero elements, its product is considered to be 1. product = 1 has_non_zero = False for num in part: if num != 0: product *= num has_non_zero = True return product if has_non_zero else 1 def compare_products(nums): Returns true if the product of non-zero elements in the left part is greater than the product of non-zero elements in the right part. Otherwise, returns false. n = len(nums) left_part = nums[:n//2] right_part = nums[n//2:] left_product = calculate(left_part) right_product = calculate(right_part) return left_product > right_product"},{"question":"from typing import List from collections import Counter def k_most_frequent_strings(strs: List[str], k: int) -> List[str]: Returns the k most frequent strings from the list 'strs' sorted by their frequency. If multiple strings have the same frequency, they are sorted lexicographically. :param strs: List of strings. :param k: Number of top most frequent strings to return. :return: List of k most frequent strings. >>> k_most_frequent_strings([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"], 2) [\\"banana\\", \\"apple\\"] >>> k_most_frequent_strings([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\"], 2) [\\"a\\", \\"b\\"] >>> k_most_frequent_strings([\\"cat\\", \\"dog\\", \\"cat\\", \\"bird\\", \\"dog\\", \\"dog\\"], 2) [\\"dog\\", \\"cat\\"] >>> k_most_frequent_strings([\\"one\\", \\"two\\", \\"three\\", \\"four\\"], 2) [\\"four\\", \\"one\\"] >>> k_most_frequent_strings([], 3) [] >>> k_most_frequent_strings([\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"], 10) [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"f\\", \\"g\\"]","solution":"from collections import defaultdict, Counter def k_most_frequent_strings(strs, k): Returns the k most frequent strings from the list 'strs' sorted by their frequency. If multiple strings have the same frequency, they are sorted lexicographically. :param strs: List of strings. :param k: Number of top most frequent strings to return. :return: List of k most frequent strings. frequency = Counter(strs) sorted_items = sorted(frequency.items(), key=lambda item: (-item[1], item[0])) return [item[0] for item in sorted_items[:k]]"},{"question":"from typing import List class IntervalManager: The IntervalManager class manages a list of integer intervals, allowing for the addition and removal of intervals while ensuring proper merging and splitting. Methods: addInterval(self, start: int, end: int) -> None: Adds the interval [start, end] to the list, merging overlapping or adjacent intervals. removeInterval(self, start: int, end: int) -> None: Removes the interval [start, end] from the list, ensuring that the intervals are updated correctly. getIntervals(self) -> List[List[int]]: Returns the current list of intervals, sorted by the starting interval in ascending order. Example Usage: >>> im = IntervalManager() >>> im.addInterval(1, 3) >>> im.addInterval(6, 9) >>> im.addInterval(2, 5) >>> im.getIntervals() [[1, 5], [6, 9]] >>> im.removeInterval(4, 7) >>> im.getIntervals() [[1, 3], [8, 9]] def __init__(self): self.intervals = [] def addInterval(self, start: int, end: int) -> None: pass def removeInterval(self, start: int, end: int) -> None: pass def getIntervals(self) -> List[List[int]]: pass","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, start, end): new_intervals = [] i, n = 0, len(self.intervals) while i < n and self.intervals[i][1] < start: new_intervals.append(self.intervals[i]) i += 1 while i < n and self.intervals[i][0] <= end: start = min(start, self.intervals[i][0]) end = max(end, self.intervals[i][1]) i += 1 new_intervals.append([start, end]) while i < n: new_intervals.append(self.intervals[i]) i += 1 self.intervals = new_intervals def removeInterval(self, start, end): new_intervals = [] for interval in self.intervals: if interval[1] < start or interval[0] > end: new_intervals.append(interval) else: if interval[0] < start: new_intervals.append([interval[0], start - 1]) if interval[1] > end: new_intervals.append([end + 1, interval[1]]) self.intervals = new_intervals def getIntervals(self): return self.intervals"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root: Optional[TreeNode]) -> List[int]: Find the largest value in each row of the binary tree. >>> tree = TreeNode(1) >>> tree.left = TreeNode(3) >>> tree.right = TreeNode(2) >>> tree.left.left = TreeNode(5) >>> tree.left.right = TreeNode(3) >>> tree.right.right = TreeNode(9) >>> largestValues(tree) [1, 3, 9] >>> tree = TreeNode(10) >>> largestValues(tree) [10] >>> largestValues(None) []","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def largestValues(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = [(root, 0)] while queue: node, level = queue.pop(0) if level == len(result): result.append(node.val) else: result[level] = max(result[level], node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return result"},{"question":"def max_meetings(meetings: List[List[int]]) -> int: Returns the maximum number of meetings a person can attend. >>> max_meetings([[1, 2], [2, 3], [3, 4]]) 3 >>> max_meetings([]) 0 >>> max_meetings([[1, 2]]) 1 >>> max_meetings([[1, 4], [2, 3], [3, 5]]) 2 >>> max_meetings([[1, 4], [2, 3], [4, 5]]) 2 >>> max_meetings([[1, 4], [1, 4], [1, 4]]) 1 >>> max_meetings([[1, 2], [3, 4], [5, 6]]) 3","solution":"def max_meetings(meetings): Returns the maximum number of meetings a person can attend. Arguments: meetings -- list of meetings [start_i, end_i] Returns: max number of meetings # Sort meetings by their end times to maximize the number of non-overlapping meetings sorted_meetings = sorted(meetings, key=lambda x: x[1]) last_end_time = 0 count = 0 for meeting in sorted_meetings: if meeting[0] >= last_end_time: # If the meeting starts after the last meeting ends count += 1 last_end_time = meeting[1] return count"},{"question":"def rightmost_insert_index(nums: List[int], target: int) -> int: Determines the rightmost index where target can be inserted in order to maintain the sorted order of the array in O(log n) time complexity. Args: nums (list of int): A sorted list of integers. target (int): The target value to insert. Returns: int: The rightmost insertion index for the target value. Examples: >>> rightmost_insert_index([], 1) 0 >>> rightmost_insert_index([1, 3, 5, 7], 0) 0 >>> rightmost_insert_index([1, 3, 5, 7], 8) 4 >>> rightmost_insert_index([1, 3, 5, 7], 4) 2 >>> rightmost_insert_index([1, 3, 3, 3, 5, 7], 3) 4 >>> rightmost_insert_index([1, 3, 5, 7], 7) 4 >>> rightmost_insert_index([-10, -3, 0, 5, 7], -3) 2 >>> rightmost_insert_index([-10, -3, 0, 5, 7], -5) 1 >>> rightmost_insert_index([1], 0) 0 >>> rightmost_insert_index([1], 1) 1 >>> rightmost_insert_index([1], 2) 1","solution":"def rightmost_insert_index(nums, target): Determines the rightmost index where target can be inserted in order to maintain the sorted order of the array in O(log n) time complexity. Args: nums (list of int): A sorted list of integers. target (int): The target value to insert. Returns: int: The rightmost insertion index for the target value. left, right = 0, len(nums) while left < right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid return left"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree by swapping the left and right children of all nodes. Args: root (TreeNode): Root of the binary tree. Returns: TreeNode: Root of the inverted binary tree. >>> root = TreeNode(4, ... TreeNode(2, TreeNode(1), TreeNode(3)), ... TreeNode(7, TreeNode(6), TreeNode(9))) >>> inverted = invertTree(root) >>> tree_to_list(inverted) [4, 7, 2, 9, 6, 3, 1]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root): Inverts a binary tree by swapping the left and right children of all nodes. Args: root (TreeNode): Root of the binary tree. Returns: TreeNode: Root of the inverted binary tree. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"def island_perimeter(grid: List[List[str]]) -> int: Calculates the perimeter of the island in the given grid. :param grid: List[List[str]], 2D list representing the grid with 'L' for land and 'W' for water :return: int, the perimeter of the island >>> test_single_land() >>> test_rectangular_island() >>> test_irregular_island() >>> test_large_island() >>> test_global_output()","solution":"def island_perimeter(grid): Calculates the perimeter of the island in the given grid. :param grid: List[List[str]], 2D list representing the grid with 'L' for land and 'W' for water :return: int, the perimeter of the island def is_land(i, j): return 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 'L' perimeter = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 'L': count_borders = 4 # Start with assuming the cell is surrounded by water on all four sides if is_land(i - 1, j): # Top cell count_borders -= 1 if is_land(i + 1, j): # Bottom cell count_borders -= 1 if is_land(i, j - 1): # Left cell count_borders -= 1 if is_land(i, j + 1): # Right cell count_borders -= 1 perimeter += count_borders return perimeter"},{"question":"from typing import List from collections import Counter def min_length_with_k_distinct(s: str, k: int) -> int: Returns the minimum possible length of a new string such that there are no more than k distinct characters in the new string. Args: s: str - The input string. k: int - The maximum number of distinct characters allowed in the new string. Returns: int - The minimum length of the new string with at most k distinct characters. Examples: >>> min_length_with_k_distinct(\\"\\", 2) 0 >>> min_length_with_k_distinct(\\"aabc\\", 0) 0 >>> min_length_with_k_distinct(\\"aabc\\", 3) 4 >>> min_length_with_k_distinct(\\"aabc\\", 2) 3 >>> min_length_with_k_distinct(\\"aabbcc\\", 2) 4 >>> min_length_with_k_distinct(\\"aaaa\\", 1) 4 >>> min_length_with_k_distinct(\\"aaabbbccc\\", 2) 6 >>> min_length_with_k_distinct(\\"abacadef\\", 10) 8","solution":"from collections import Counter def min_length_with_k_distinct(s, k): Returns the minimum possible length of a new string such that there are no more than k distinct characters in the new string. if k == 0: return 0 char_count = Counter(s) distinct_count = len(char_count) if distinct_count <= k: return len(s) sorted_counts = sorted(char_count.values(), reverse=True) min_length = sum(sorted_counts[:k]) return min_length"},{"question":"def find_communication_path(hierarchy: List[List[int]], target: int) -> List[int]: Returns the sequence of employee IDs representing the communication path from the CEO to the target employee. >>> find_communication_path([[2, 1], [3, 1], [4, 2], [5, 2], [6, 3], [7, 3]], 5) [1, 2, 5] >>> find_communication_path([[2, 1], [3, 1], [4, 2], [5, 2], [6, 3], [7, 3]], 1) [1] >>> find_communication_path([[2, 1], [3, 1], [4, 2], [5, 2], [6, 3], [7, 3]], 8) []","solution":"def find_communication_path(hierarchy, target): Returns the sequence of employee IDs representing the communication path from the CEO to the target employee. :param hierarchy: List[List[int]] - a list of pairs [employee, supervisor] :param target: int - the ID of the target employee :return: List[int] - the sequence of IDs from the CEO to the target employee supervisor_map = {employee: supervisor for employee, supervisor in hierarchy} # Find the CEO (root node), who doesn't appear as an employee all_employees = set(supervisor_map.keys()) all_supervisors = set(supervisor_map.values()) ceo = (all_supervisors - all_employees).pop() # Create the path from the target to the CEO path = [] current = target while current != ceo: path.append(current) if current not in supervisor_map: return [] # In case there is no valid path current = supervisor_map[current] path.append(ceo) return path[::-1]"},{"question":"def minimize_max_sum(arr: List[int], k: int) -> int: Distribute all elements of arr into exactly k non-empty subsets such that the maximum sum of the subsets is minimized. Return the minimized maximum sum considering all possible distributions of the array into k subsets. >>> minimize_max_sum([1], 1) == 1 >>> minimize_max_sum([1, 1, 1, 1], 2) == 2 >>> minimize_max_sum([3, 5, 2, 7, 1], 3) == 7 >>> minimize_max_sum([1, 2, 3, 4, 5], 5) == 5 >>> minimize_max_sum([4, 3, 2, 6, 7, 4], 1) == 26 >>> minimize_max_sum([1, 2, 3, 4, 10, 11], 3) == 11 >>> minimize_max_sum([1]*1000, 100) == 10","solution":"def minimize_max_sum(arr, k): def can_partition(max_sum): partitions, current_sum = 1, 0 for num in arr: if current_sum + num > max_sum: partitions += 1 current_sum = 0 current_sum += num return partitions <= k arr.sort(reverse=True) low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if can_partition(mid): high = mid else: low = mid + 1 return low"},{"question":"def max_water(nums: List[int]) -> int: Given a list of \`n\` integers, where each integer \`nums[i]\` represents the number of units of water that can be held by the bucket at the \`i-th\` position, adjust the height of the buckets such that the total amount of water they hold is maximized without any two adjacent buckets overflowing. Return the maximum amount of water that can be held by the buckets after adjustment. >>> max_water([]) == 0 >>> max_water([5]) == 5 >>> max_water([5, 1]) == 5 >>> max_water([1, 5]) == 5 >>> max_water([5, 1, 1, 5]) == 10 >>> max_water([3, 2, 7, 10]) == 13 >>> max_water([10, 2, 3, 5]) == 15 >>> max_water([1, 2, 3]) == 4 >>> max_water([4, 1, 1, 4]) == 8 >>> max_water([5, 5, 5, 5, 5]) == 15","solution":"def max_water(nums): Returns the maximum amount of water that can be held by the buckets after adjustment. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] # dp[i] will store the maximum amount of water up to the i-th bucket that can be held dp = [0] * n # Initialize the first two buckets dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill the dp array using dynamic programming approach for i in range(2, n): dp[i] = max(dp[i-1], nums[i] + dp[i-2]) return dp[n-1]"},{"question":"def is_balanced(s: str) -> bool: Determine if the string s has balanced parentheses, brackets, and braces. >>> is_balanced(\\"()\\") == True >>> is_balanced(\\"()[]{}\\") == True >>> is_balanced(\\"(]\\") == False >>> is_balanced(\\"([)]\\") == False >>> is_balanced(\\"{[]}\\") == True >>> is_balanced(\\"{[()()]}\\") == True >>> is_balanced(\\"(\\") == False >>> is_balanced(\\")\\") == False >>> is_balanced(\\"{\\") == False >>> is_balanced(\\"}\\") == False >>> is_balanced(\\"\\") == True >>> is_balanced(\\"[({}())()]\\") == True >>> is_balanced(\\"[({}())(]\\") == False","solution":"def is_balanced(s): Returns True if the string s has balanced parentheses, brackets, and braces, otherwise False. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in s: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"def longest_subarray(nums: List[int]) -> int: Returns the length of the longest contiguous subarray within nums where the difference between the maximum and minimum values is at most 1. >>> longest_subarray([]) == 0 >>> longest_subarray([5, 5, 5, 5, 5]) == 5 >>> longest_subarray([1, 2, 3, 4, 5]) == 2 >>> longest_subarray([1, 2]) == 2 >>> longest_subarray([2, 2, 2, 2, 2]) == 5 >>> longest_subarray([1, 3, 2, 2, 1, 5, 6, 6, 7, 8]) == 3 >>> longest_subarray([4]) == 1","solution":"def longest_subarray(nums): Returns the length of the longest contiguous subarray where the difference between the maximum and minimum values is at most 1. if not nums: return 0 left = 0 max_len = 0 current_max = current_min = nums[0] for right in range(len(nums)): current_max = max(current_max, nums[right]) current_min = min(current_min, nums[right]) while current_max - current_min > 1: left += 1 current_max = max(nums[left:right+1]) current_min = min(nums[left:right+1]) max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target number in a sorted n x n matrix. Args: matrix (List[List[int]]): 2D list where each row and column are sorted in ascending order. target (int): The number to search for. Returns: bool: True if the target number is found, False otherwise. pass # Unit tests def test_search_element_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert searchMatrix(matrix, target) == True def test_search_element_not_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 assert searchMatrix(matrix, target) == False def test_search_small_matrix(): matrix = [ [1, 3], [2, 4] ] target = 4 assert searchMatrix(matrix, target) == True def test_search_single_element_matrix_found(): matrix = [ [5] ] target = 5 assert searchMatrix(matrix, target) == True def test_search_single_element_matrix_not_found(): matrix = [ [10] ] target = 5 assert searchMatrix(matrix, target) == False def test_search_empty_matrix(): matrix = [] target = 5 assert searchMatrix(matrix, target) == False def test_search_large_element(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 31 assert searchMatrix(matrix, target) == False def test_search_negative_element_not_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = -1 assert searchMatrix(matrix, target) == False def test_search_negative_element_found(): matrix = [ [-10, -5, 0, 3, 8], [-8, -4, 1, 4, 9], [-6, -3, 2, 5, 10], [0, 2, 6, 8, 12], [3, 6, 8, 10, 15] ] target = -3 assert searchMatrix(matrix, target) == True","solution":"from typing import List def searchMatrix(matrix: List[List[int]], target: int) -> bool: Searches for a target number in a sorted n x n matrix. Args: matrix (List[List[int]]): 2D list where each row and column are sorted in ascending order. target (int): The number to search for. Returns: bool: True if the target number is found, False otherwise. if not matrix or not matrix[0]: return False # Start from the top-right corner of the matrix row, col = 0, len(matrix[0]) - 1 while row < len(matrix) and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def shortest_path(grid: List[List[int]]) -> int: Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid, navigating through empty cells ('0'). If no such path exists, returns -1. >>> shortest_path([[0, 1, 0], [0, 0, 0], [1, 0, 0]]) 5 >>> shortest_path([[0, 1], [1, 0]]) -1 >>> shortest_path([[0]]) 1 >>> shortest_path([[1, 1], [1, 1]]) -1 >>> shortest_path([]) -1 >>> shortest_path([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 5","solution":"from collections import deque def shortest_path(grid): Returns the length of the shortest path from the top-left corner to the bottom-right corner of the grid, navigating through empty cells ('0'). If no such path exists, returns -1. if not grid or not grid[0]: return -1 m, n = len(grid), len(grid[0]) if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == m-1 and y == n-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def findUniqueElement(nums): Returns the element that appears only once in the list nums where each element appears twice except for one element. >>> findUniqueElement([4, 2, 2, 4, 3]) 3 >>> findUniqueElement([1, 1, 5]) 5 >>> findUniqueElement([-1, -1, -2]) -2 >>> findUniqueElement([0, 1, 0, 1, 5]) 5 >>> findUniqueElement([10, -10, 20, 20, -10, 30, 10]) 30 >>> findUniqueElement([3, 3, 7, 2, 2, 5, 7]) 5","solution":"def findUniqueElement(nums): Returns the element that appears only once in the list nums where each element appears twice except for one element. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], the inorder traversal of the tree's nodes' values >>> inorder_traversal(None) [] >>> root = TreeNode(1) >>> inorder_traversal(root) [1] >>> root = TreeNode(1, TreeNode(2, TreeNode(3))) >>> inorder_traversal(root) [3, 2, 1] >>> root = TreeNode(1, None, TreeNode(2, None, TreeNode(3))) >>> inorder_traversal(root) [1, 2, 3] >>> root = TreeNode(2, TreeNode(1), TreeNode(3)) >>> inorder_traversal(root) [1, 2, 3] >>> root = TreeNode(1, ... TreeNode(2, TreeNode(4), TreeNode(5)), ... TreeNode(3, None, TreeNode(6))) >>> inorder_traversal(root) [4, 2, 5, 1, 3, 6]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Perform an inorder traversal of a binary tree. :param root: TreeNode, the root of the binary tree :return: List[int], the inorder traversal of the tree's nodes' values def traverse(node): if node: traverse(node.left) result.append(node.val) traverse(node.right) result = [] traverse(root) return result"},{"question":"from typing import List def min_operations_to_equal_candies(arr: List[int]) -> int: Given an integer array \`arr\` of positive integers where \`arr[i]\` represents the number of candies the \`i-th\` child has. You are allowed to perform the following operation any number of times: - Choose any two adjacent children and give one candy from one child to the other. Return the minimum number of operations required to achieve the goal where every child has the same number of candies. If it is impossible to make every child have the same number of candies, return \`-1\`. >>> min_operations_to_equal_candies([1, 2, 3]) 2 >>> min_operations_to_equal_candies([5, 5, 5, 5]) 0 >>> min_operations_to_equal_candies([3, 4, 7, 2]) 4 >>> min_operations_to_equal_candies([1, 1, 1, 2]) -1 >>> min_operations_to_equal_candies([5, 3, 2]) -1 >>> min_operations_to_equal_candies([10]) 0 >>> min_operations_to_equal_candies([5, 5]) 0 >>> min_operations_to_equal_candies([5, 9]) 2 >>> min_operations_to_equal_candies([100000, 300000, 200000, 400000]) 400000 # Implementation here","solution":"def min_operations_to_equal_candies(arr): total_candies = sum(arr) n = len(arr) # Check if it is possible to distribute candies equally if total_candies % n != 0: return -1 target = total_candies // n operations = 0 excess = 0 for candies in arr: excess += candies - target operations += abs(excess) return operations"},{"question":"def count_good_pairs(A: list, B: list, k: int) -> int: Returns the number of good pairs \`(i, j)\` such that \`A[i] + B[j] == k\`. Parameters: A (list of int): Array of integers. B (list of int): Array of integers. k (int): Target sum. Returns: int: The number of good pairs. pass def test_count_good_pairs(): A = [1, 2, 3] B = [3, 2, 1] k = 4 assert count_good_pairs(A, B, k) == 3 def test_no_good_pairs(): A = [1, 2, 3] B = [4, 5, 6] k = 10 assert count_good_pairs(A, B, k) == 0 def test_all_pairs_good(): A = [2, 2, 2] B = [3, 3, 3] k = 5 assert count_good_pairs(A, B, k) == 9 def test_single_element_arrays(): A = [2] B = [3] k = 5 assert count_good_pairs(A, B, k) == 1 def test_large_numbers(): A = [100000] * 1000 B = [-99999] * 1000 k = 1 assert count_good_pairs(A, B, k) == 1000000","solution":"def count_good_pairs(A, B, k): Returns the number of good pairs \`(i, j)\` such that \`A[i] + B[j] == k\`. Parameters: A (list of int): Array of integers. B (list of int): Array of integers. k (int): Target sum. Returns: int: The number of good pairs. good_pair_count = 0 n = len(A) for i in range(n): for j in range(n): if A[i] + B[j] == k: good_pair_count += 1 return good_pair_count"},{"question":"def min_deletions_to_make_palindrome(s: str) -> int: Returns the minimum number of deletions required to make the string a palindrome. >>> min_deletions_to_make_palindrome(\\"a\\") == 0 >>> min_deletions_to_make_palindrome(\\"ab\\") == 1 >>> min_deletions_to_make_palindrome(\\"aa\\") == 0 >>> min_deletions_to_make_palindrome(\\"aba\\") == 0 >>> min_deletions_to_make_palindrome(\\"aab\\") == 1 >>> min_deletions_to_make_palindrome(\\"abb\\") == 1 >>> min_deletions_to_make_palindrome(\\"abc\\") == 2 >>> min_deletions_to_make_palindrome(\\"abcb\\") == 1 >>> min_deletions_to_make_palindrome(\\"aabb\\") == 2 >>> min_deletions_to_make_palindrome(\\"abab\\") == 1 >>> min_deletions_to_make_palindrome(\\"aaaa\\") == 0","solution":"def min_deletions_to_make_palindrome(s): Returns the minimum number of deletions required to make the string a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for x in range(n)] for y in range(n)] # Strings of length 1 are already palindromes for i in range(n): dp[i][i] = 0 # Fill the table for length in range(2, n+1): for i in range(n-length+1): j = i+length-1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1 # The result is the minimum number of deletions for s[0...n-1] return dp[0][n-1]"},{"question":"def daily_temperatures(temperatures: List[int]) -> List[int]: Determine, for each day, how many days you would have to wait until a warmer temperature. :param temperatures: List of integers representing daily temperatures. :return: List of integers representing the count of days until a warmer temperature. >>> daily_temperatures([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> daily_temperatures([30, 29, 28, 27]) [0, 0, 0, 0] >>> daily_temperatures([30, 31, 32, 33, 34]) [1, 1, 1, 1, 0] >>> daily_temperatures([30]) [0] >>> daily_temperatures([30, 30, 30, 30]) [0, 0, 0, 0] >>> daily_temperatures([30, 40, 50, 10]) [1, 1, 0, 0]","solution":"def daily_temperatures(temperatures): Determine, for each day, how many days you would have to wait until a warmer temperature. :param temperatures: List of integers representing daily temperatures. :return: List of integers representing the count of days until a warmer temperature. n = len(temperatures) result = [0] * n stack = [] # Iterate through the list of temperatures for i in range(n): # While stack is not empty and the current temperature is greater than temperature at index stored in stack while stack and temperatures[i] > temperatures[stack[-1]]: index = stack.pop() result[index] = i - index stack.append(i) return result"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Given a string \`s\`, find the length of the longest contiguous substring that contains at most two distinct characters. A contiguous substring is defined as a sequence of characters within \`s\` that occur in a continuous block without any gaps. Return the length of the longest substring that meets the criteria. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"a\\") 1 >>> length_of_longest_substring_two_distinct(\\"aa\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcdefg\\") 2 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"aabbbc\\") 5","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest contiguous substring that contains at most two distinct characters. n = len(s) if n < 3: return n # Sliding window [left, right] left, right = 0, 0 # HashMap to store the rightmost position of each character in the current window hash_map = {} max_len = 2 while right < n: # Add the character at the right pointer to the hashmap and update the right pointer hash_map[s[right]] = right right += 1 # If the window contains 3 characters, we need to remove the leftmost character if len(hash_map) == 3: # Find the leftmost character in the current window del_idx = min(hash_map.values()) # Remove it from the hashmap del hash_map[s[del_idx]] # Move the left pointer of the sliding window left = del_idx + 1 max_len = max(max_len, right - left) return max_len"},{"question":"def three_sum_exists(arr: List[int], target: int) -> bool: You are given a list of \`n\` integers, \`arr\`, and an integer \`target\`. Your task is to determine if there are three distinct elements in the list that sum up to the \`target\`. Return \`true\` if such a combination exists, and \`false\` otherwise. >>> three_sum_exists([1, 2, 3, 4, 5], 9) True >>> three_sum_exists([1, 2, 3, 4, 5], 20) False >>> three_sum_exists([1], 3) False >>> three_sum_exists([], 3) False >>> three_sum_exists([1, 4, 45, 6, 10, 8], 22) True >>> three_sum_exists([-1, 0, 1, 2, -1, -4], 0) True >>> three_sum_exists([-1, -2, -3, -4, -5], -20) False >>> three_sum_exists([1, 1, 1, 1, 1], 3) True pass","solution":"def three_sum_exists(arr, target): Determines if there are three distinct elements in the list that sum up to the target. :param arr: List of integers :param target: Integer target sum :return: Boolean, True if such a combination exists, False otherwise. n = len(arr) arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def count_pairs_with_sum(arr: List[int], target: int) -> int: Returns the number of pairs of elements in arr that sum up to target. >>> count_pairs_with_sum([1, 2, 3], 7) == 0 >>> count_pairs_with_sum([1, 2, 3, 4], 5) == 2 # (1, 4) and (2, 3) >>> count_pairs_with_sum([1, 1, 1, 1], 2) == 6 # (1, 1) pairs >>> count_pairs_with_sum([-1, -2, 1, 3], 1) == 1 # (-2, 3) >>> count_pairs_with_sum([], 5) == 0 >>> count_pairs_with_sum([2, 2, 2, 2], 4) == 6 # (2, 2)","solution":"def count_pairs_with_sum(arr, target): Returns the number of pairs of elements in arr that sum up to target. count = 0 seen = {} for number in arr: complement = target - number if complement in seen: count += seen[complement] if number in seen: seen[number] += 1 else: seen[number] = 1 return count"},{"question":"def rearrange_array(arr: List[int], k: int) -> List[int]: Rearranges the elements of the array such that the element at position \`k\` is the same as it would be if the array was sorted. The order of other elements is not important. :param arr: List[int] - The unsorted array of integers :param k: int - The position to ensure has the correct element :return: List[int] - The rearranged array >>> rearrange_array([3, 2, 1, 5, 4], 2) [1, 2, 3, 5, 4] >>> rearrange_array([0, -10, 7, -3, 2], 2) [-10, -3, 0, 7, 2]","solution":"def rearrange_array(arr, k): Rearranges the elements of the array such that the element at position \`k\` is the same as it would be if the array was sorted. The order of other elements is not important. :param arr: List[int] - The unsorted array of integers :param k: int - The position to ensure has the correct element :return: List[int] - The rearranged array if not (0 <= k < len(arr)): raise IndexError(\\"k is out of the bounds of the array length.\\") # Perform nth element (quickselect algorithm) def partition(left, right, pivot_index): pivot_value = arr[pivot_index] arr[pivot_index], arr[right] = arr[right], arr[pivot_index] store_index = left for i in range(left, right): if arr[i] < pivot_value: arr[store_index], arr[i] = arr[i], arr[store_index] store_index += 1 arr[right], arr[store_index] = arr[store_index], arr[right] return store_index def quickselect(left, right, k): if left == right: return arr[left] pivot_index = (left + right) // 2 pivot_index = partition(left, right, pivot_index) if k == pivot_index: return arr[k] elif k < pivot_index: return quickselect(left, pivot_index - 1, k) else: return quickselect(pivot_index + 1, right, k) quickselect(0, len(arr) - 1, k) return arr"},{"question":"def rob_alternating(nums: List[int]) -> int: Returns the maximum amount of money the first robber can rob when robbing houses in a street alternatively with the second robber. >>> rob_alternating([1, 2, 3, 1]) 4 >>> rob_alternating([2, 7, 9, 3, 1]) 12 >>> rob_alternating([1, 1, 1, 1]) 2 >>> rob_alternating([]) 0 >>> rob_alternating([5]) 5 >>> rob_alternating([2, 1, 1, 2]) 4 >>> rob_alternating([6, 7, 1, 30, 8, 2, 4]) 41 >>> rob_alternating([3, 10, 3, 1, 2]) 12 >>> rob_alternating([100, 2, 100, 2, 100, 2]) 300 >>> rob_alternating([5, 3, 1, 3]) 8","solution":"def rob_alternating(nums): Returns the maximum amount of money the first robber can rob when robbing houses in a street alternatively with the second robber. n = len(nums) if n == 0: return 0 if n == 1: return nums[0] # Dynamic programming to maximize the money robbed with DP array dp = [0] * n # Initialize the dp array based on first and second house. dp[0] = nums[0] if n > 1: dp[1] = max(nums[0], nums[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) # The maximum amount of money first robber can rob return dp[n-1]"},{"question":"def first_missing_positive(nums: List[int]) -> int: Given an integer array \`nums\`, return the smallest positive integer that is missing from the array. The array can contain duplicate numbers and negative numbers. Your algorithm should have a linear runtime complexity and use constant extra space. >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([-1, 3, 4, 1]) 2 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([2]) 1 >>> first_missing_positive([2, 1, 4, 6, 5, -1, -2, 3, 8, 7, 10, 12]) 9 >>> first_missing_positive([]) 1 >>> first_missing_positive([-1, -2, -3]) 1","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is missing from the array. n = len(nums) # Mark elements out of scope by replacing them with n + 1 for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Use the index to place positive numbers in their \\"correct\\" positions for i in range(n): num = abs(nums[i]) if num <= n and nums[num - 1] > 0: nums[num - 1] = -nums[num - 1] # The first missing positive number is the first index that has a positive value for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def trap(height: List[int]) -> int: Calculate the total amount of rainwater trapped between the buildings. :param height: List of integers representing the heights of the buildings. :return: Total amount of trapped rainwater. pass # Unit tests def test_trap_basic(): assert trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 def test_trap_no_buildings(): assert trap([]) == 0 def test_trap_single_building(): assert trap([4]) == 0 def test_trap_two_buildings(): assert trap([2, 1]) == 0 def test_trap_equal_height_buildings(): assert trap([1, 1, 1, 1, 1]) == 0 def test_trap_increasing_height_buildings(): assert trap([1, 2, 3, 4, 5]) == 0 def test_trap_decreasing_height_buildings(): assert trap([5, 4, 3, 2, 1]) == 0 def test_trap_mixed_height_buildings(): assert trap([4, 2, 3]) == 1","solution":"def trap(height): Calculate the total amount of rainwater trapped between the buildings. :param height: List of integers representing the heights of the buildings. :return: Total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) # Fill right_max array right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) # Calculate water trapped using the precomputed arrays for i in range(n): water_trapped += min(left_max[i], right_max[i]) - height[i] return water_trapped"},{"question":"from typing import List def trap_water(heights: List[int]) -> int: Calculates the total amount of water trapped between pillars. :param heights: List[int] - list of heights of the pillars :return: int - total amount of trapped water >>> trap_water([]) == 0 >>> trap_water([1, 1, 1, 1]) == 0 >>> trap_water([5]) == 0 >>> trap_water([3, 2, 1]) == 0 >>> trap_water([2, 0, 2]) == 2 >>> trap_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap_water([2, 1, 0, 2]) == 3 >>> trap_water([1, 2, 3, 4, 5]) == 0 >>> trap_water([5, 4, 3, 2, 1]) == 0 >>> trap_water([3, 0, 2, 0, 4]) == 7","solution":"def trap_water(heights): Calculates the total amount of water trapped between pillars. :param heights: List[int] - list of heights of the pillars :return: int - total amount of trapped water if not heights: return 0 n = len(heights) # Arrays to store the maximum height to the left and right of each pillar left_max = [0] * n right_max = [0] * n # Fill the left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill the right_max array right_max[-1] = heights[-1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def longest_increasing_subsequence_with_diff(arr: List[int], d: int) -> int: Returns the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order and the elements of the subsequence differ by at most \`d\`. >>> longest_increasing_subsequence_with_diff([1, 2, 3, 4], 1) == 4 >>> longest_increasing_subsequence_with_diff([1, 3, 5, 7], 2) == 4 >>> longest_increasing_subsequence_with_diff([1, 3, 5, 7], 1) == 1 >>> longest_increasing_subsequence_with_diff([1, 3, 2, 4, 5], 2) == 4 >>> longest_increasing_subsequence_with_diff([], 10) == 0 >>> longest_increasing_subsequence_with_diff([1, 1, 1, 1], 0) == 1","solution":"def longest_increasing_subsequence_with_diff(arr, d): Returns the length of the longest subsequence such that all elements of the subsequence are sorted in strictly increasing order and the elements of the subsequence differ by at most \`d\`. n = len(arr) if n == 0: return 0 # dp[i] will store the length of the longest subsequence ending at arr[i] dp = [1] * n # Iterate through the array for i in range(1, n): for j in range(i): if arr[i] > arr[j] and arr[i] - arr[j] <= d: dp[i] = max(dp[i], dp[j] + 1) # The longest subsequence will be the maximum value in dp array return max(dp)"},{"question":"from typing import List def powerset(seq: List[int]) -> List[List[int]]: Given a list of n unique integers, return all possible subsets (the power set) of the list. Each subset should be sorted in ascending order and the output list of subsets should be sorted lexicographically. >>> powerset([1, 2, 3]) [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]] >>> powerset([5]) [[], [5]] >>> powerset([]) [[]] >>> powerset([2, 1]) [[], [1], [1, 2], [2]] >>> powerset([0, 1]) [[], [0], [0, 1], [1]] >>> powerset([100, 200]) [[], [100], [100, 200], [200]]","solution":"from itertools import chain, combinations def powerset(seq): Returns all possible subsets of the list, sorted. Each subset is sorted in ascending order, and the list of subsets is sorted lexicographically. seq_sorted = sorted(seq) all_subsets = list(chain.from_iterable(combinations(seq_sorted, r) for r in range(len(seq_sorted) + 1))) subsets_as_lists = [list(subset) for subset in all_subsets] return sorted(subsets_as_lists)"},{"question":"def trap_rainwater(heights: List[int]) -> int: Calculate the amount of trapped rainwater given the height of buildings. :param heights: List[int] - A list of integers where each integer represents the height of a building. :return: int - The total amount of trapped rainwater. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([3, 0, 3]) 3 >>> trap_rainwater([1, 5, 1]) 0 >>> trap_rainwater([4, 1, 3, 1, 5]) 7","solution":"def trap_rainwater(heights): Calculate the amount of trapped rainwater given the height of buildings. :param heights: List[int] - A list of integers where each integer represents the height of a building. :return: int - The total amount of trapped rainwater. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max from left to right left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max from right to left right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the amount of water trapped at each index for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Given a 0-indexed integer array nums, return an array answer where answer[i] is the product of all the elements of nums except nums[i]. The product of any subset of elements in nums is guaranteed to be within the range of a 32-bit integer. Implement the solution with a time complexity of O(n) without using division. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] >>> product_except_self([1, 1, 1, 1]) == [1, 1, 1, 1] >>> product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] >>> product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] >>> product_except_self([1, -1, 1, -1]) == [1, -1, 1, -1]","solution":"def product_except_self(nums): Returns an array answer where answer[i] is the product of all the elements of nums except nums[i]. # Initialize the length of the input array nums length = len(nums) # Initialize the answer array where we will keep our results answer = [1] * length # Variable to store the product of elements to the left of current element left_product = 1 for i in range(length): answer[i] = left_product left_product *= nums[i] # Variable to store the product of elements to the right of current element right_product = 1 for i in range(length - 1, -1, -1): answer[i] *= right_product right_product *= nums[i] return answer"},{"question":"def findSingle(nums: List[int]) -> int: Returns the single element that appears only once in the array where every other element appears twice. Your algorithm should have a linear runtime complexity and utilize only constant space. >>> findSingle([2, 2, 3, 4, 4]) 3 >>> findSingle([-1, -1, -2, -2, -3]) -3 >>> findSingle([1, 2, 1, 2, 3]) 3 >>> findSingle([1000000, 1000001, 1000000, 1000001, 999999]) 999999 >>> findSingle([0, 1, 1, 2, 2]) 0 >>> findSingle([5, 4, 3, 4, 3, 2, 5]) 2 pass","solution":"def findSingle(nums): Returns the single element that appears only once in the array where every other element appears twice. result = 0 for num in nums: result ^= num return result"},{"question":"class LibrarySystem: def __init__(self, numberOfBooks: int): Initialize the LibrarySystem object with a total number of books. Each book is initially available. pass def borrowBook(self, bookId: int) -> bool: Checks if the book with the given bookId is available to borrow. If so, mark it as borrowed and return True. If the book is already borrowed, return False. pass def returnBook(self, bookId: int) -> None: Marks the book with the given bookId as available again in the system. pass # Example usage and unit tests def test_initialize_library_system(): lib = LibrarySystem(5) # All books should initially be available assert lib.books == [True, True, True, True, True] def test_borrow_book(): lib = LibrarySystem(3) assert lib.borrowBook(1) == True assert lib.books == [False, True, True] assert lib.borrowBook(1) == False # Already borrowed def test_return_book(): lib = LibrarySystem(3) lib.borrowBook(1) assert lib.books == [False, True, True] lib.returnBook(1) assert lib.books == [True, True, True] def test_borrow_and_return_sequence(): lib = LibrarySystem(2) # Borrow and return sequence for book 1 assert lib.borrowBook(1) == True assert lib.borrowBook(1) == False # Already borrowed lib.returnBook(1) assert lib.borrowBook(1) == True # Book is now available again # Checking status of another book (book 2) assert lib.borrowBook(2) == True assert lib.books == [False, False]","solution":"class LibrarySystem: def __init__(self, numberOfBooks): Initializes the LibrarySystem with a total number of books. Each book is initially available. self.books = [True] * numberOfBooks # True means the book is available def borrowBook(self, bookId): Checks if the book with the given bookId is available to borrow. If so, mark it as borrowed and return True. If the book is already borrowed, return False. if self.books[bookId - 1]: self.books[bookId - 1] = False return True else: return False def returnBook(self, bookId): Marks the book with the given bookId as available again in the system. self.books[bookId - 1] = True"},{"question":"def islandPerimeter(grid: List[List[int]]) -> int: Calculate and return the perimeter of the island in the grid. >>> islandPerimeter([ [0, 1, 0, 0], [1, 1, 1, 0], [0, 1, 0, 0], [1, 1, 0, 0] ]) == 16","solution":"def islandPerimeter(grid): Returns the perimeter of the island in the grid. rows = len(grid) cols = len(grid[0]) perimeter = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: # Each land cell starts with 4 sides perimeter += 4 # Subtract sides for adjacent land cells if r > 0 and grid[r - 1][c] == 1: # Check above perimeter -= 2 if c > 0 and grid[r][c - 1] == 1: # Check left perimeter -= 2 return perimeter"},{"question":"def max_coins(grid: List[List[int]]) -> int: You are given a \`m x n\` grid filled with non-negative numbers, representing the number of coins in each cell. You have a robot starting at the top-left corner of the grid (i.e., grid[0][0]). The robot can move either down or right at any point in time. The robot's goal is to reach the bottom-right corner of the grid (i.e., grid[m-1][n-1]) while collecting the maximum number of coins possible. Return the maximum number of coins the robot can collect by the time it reaches the bottom-right corner. >>> max_coins([[1, 2, 3, 4]]) 10 >>> max_coins([[1], [2], [3], [4]]) 10 >>> max_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_coins([[1, 2, 5], [3, 2, 1]]) 9 >>> max_coins([[1, 2], [3, 4]]) 8 >>> max_coins([]) 0 >>> max_coins([[]]) 0 >>> max_coins([[0]]) 0 >>> max_coins([[5]]) 5","solution":"def max_coins(grid): Returns the maximum number of coins the robot can collect in the grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp table to store the maximum coins collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the dp table with the value of grid at the starting position dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remaining cells (can come either from the left or above) for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def longest_single_char_substring(s: str) -> int: Given a string s consisting of only two characters 'a' and 'b', find the length of the longest substring containing only one distinct character. >>> longest_single_char_substring(\\"aababba\\") == 2 >>> longest_single_char_substring(\\"aaaa\\") == 4 >>> longest_single_char_substring(\\"bbbb\\") == 4 >>> longest_single_char_substring(\\"abab\\") == 1 >>> longest_single_char_substring(\\"aabbaaa\\") == 3 >>> longest_single_char_substring(\\"\\") == 0 >>> longest_single_char_substring(\\"aaabbb\\") == 3 pass","solution":"def longest_single_char_substring(s): Given a string s consisting of only two characters 'a' and 'b', find the length of the longest substring containing only one distinct character. if not s: return 0 max_len = 1 current_char = s[0] current_len = 1 for i in range(1, len(s)): if s[i] == current_char: current_len += 1 else: max_len = max(max_len, current_len) current_char = s[i] current_len = 1 return max(max_len, current_len)"},{"question":"from typing import List def trapWater(heights: List[int]) -> int: Calculate the total amount of trapped water given heights of the blocks. Parameters: heights (list of int): The heights of the blocks. Returns: int: The total amount of trapped water. >>> trapWater([]) 0 >>> trapWater([1, 1, 1, 1]) 0 >>> trapWater([0,1,0,2,1,0,1,3,2,1,2,1]) 6 >>> trapWater([1]) 0 >>> trapWater([5, 2, 5]) 3 >>> trapWater([4, 1, 3]) 2 >>> trapWater([3, 0, 2, 0, 4]) 7 >>> trapWater([1, 2, 3, 4, 5]) 0 >>> trapWater([5, 4, 3, 2, 1]) 0","solution":"def trapWater(heights): Calculate the amount of trapped water given heights of the blocks. Parameters: heights (list of int): The heights of the blocks. Returns: int: The total amount of trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Perform a level-order traversal on a binary tree. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[List[int]]: A list of lists, where each sublist contains the values of nodes at each level. Examples: >>> root = TreeNode(1, TreeNode(2), TreeNode(3)) >>> levelOrderTraversal(root) [[1], [2, 3]] >>> root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3, None, TreeNode(5))) >>> levelOrderTraversal(root) [[1], [2, 3], [4, 5]] >>> root = None >>> levelOrderTraversal(root) [] >>> root = TreeNode(1) >>> levelOrderTraversal(root) [[1]]","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_nodes) return result"},{"question":"def maximum_time(time: str) -> str: Given a string \`time\` in the format \`HH:MM\`, returns the maximum possible time by replacing at most two characters of the string with any digit from 0 to 9. >>> maximum_time(\\"??:??\\") == \\"23:59\\" >>> maximum_time(\\"23:59\\") == \\"23:59\\" >>> maximum_time(\\"2?:22\\") == \\"23:22\\" >>> maximum_time(\\"?3:45\\") == \\"23:45\\" >>> maximum_time(\\"17:?5\\") == \\"17:55\\" >>> maximum_time(\\"08:4?\\") == \\"08:49\\" >>> maximum_time(\\"?4:?2\\") == \\"14:52\\" >>> maximum_time(\\"1?:5?\\") == \\"19:59\\" >>> maximum_time(\\"?2:??\\") == \\"22:59\\" >>> maximum_time(\\"?3:?4\\") == \\"23:54\\" >>> maximum_time(\\"14:??\\") == \\"14:59\\" >>> maximum_time(\\"??:23\\") == \\"23:23\\"","solution":"def maximum_time(time): Given a string \`time\` in the format \`HH:MM\`, returns the maximum possible time by replacing at most two characters of the string with any digit from 0 to 9. time = list(time) if time[0] == '?': time[0] = '2' if time[1] in ('?', '0', '1', '2', '3') else '1' if time[1] == '?': time[1] = '3' if time[0] == '2' else '9' if time[3] == '?': time[3] = '5' if time[4] == '?': time[4] = '9' return ''.join(time)"},{"question":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in-place. Args: nums1 : List[int] - The first sorted array with extra space at the end. m : int - The number of elements initially in nums1. nums2 : List[int] - The second sorted array to merge into nums1. n : int - The number of elements in nums2. >>> merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3) [1, 2, 2, 3, 5, 6] >>> merge([4, 5, 6, 0, 0, 0], 3, [1, 2, 3], 3) [1, 2, 3, 4, 5, 6] >>> merge([1, 2, 3, 0, 0, 0], 3, [], 0) [1, 2, 3, 0, 0, 0] >>> merge([0, 0, 0, 0, 0, 0], 0, [1, 2, 3, 4, 5, 6], 6) [1, 2, 3, 4, 5, 6] >>> merge([2, 2, 2, 0, 0, 0], 3, [2, 2, 2], 3) [2, 2, 2, 2, 2, 2] >>> merge([], 0, [], 0) []","solution":"def merge(nums1, m, nums2, n): Merges nums2 into nums1 in-place. Args: nums1 : List[int] - The first sorted array with extra space at the end. m : int - The number of elements initially in nums1. nums2 : List[int] - The second sorted array to merge into nums1. n : int - The number of elements in nums2. # Start from the end of both arrays and merge while m > 0 and n > 0: if nums1[m - 1] > nums2[n - 1]: nums1[m + n - 1] = nums1[m - 1] m -= 1 else: nums1[m + n - 1] = nums2[n - 1] n -= 1 # If there are remaining elements in nums2, copy them while n > 0: nums1[m + n - 1] = nums2[n - 1] n -= 1"},{"question":"def longest_path_in_dag(n: int, edges: List[List[int]]) -> int: Finds the length of the longest path in a directed acyclic graph (DAG). Args: n (int): The number of nodes in the DAG. edges (List[List[int]]): The list of directed edges in the DAG. Returns: int: The length of the longest path. >>> longest_path_in_dag(4, [[0, 1], [1, 2], [2, 3]]) == 3 >>> longest_path_in_dag(5, [[0, 1], [1, 2], [0, 2], [2, 3], [2, 4]]) == 3 >>> longest_path_in_dag(1, []) == 0 >>> longest_path_in_dag(6, [[0, 1], [1, 2], [3, 4]]) == 2 >>> longest_path_in_dag(6, [[0, 1], [1, 2], [0, 2], [2, 3], [2, 4], [4, 5], [3, 5]]) == 4","solution":"def longest_path_in_dag(n, edges): Finds the length of the longest path in a directed acyclic graph (DAG). Args: n (int): The number of nodes in the DAG. edges (List[List[int]]): The list of directed edges in the DAG. Returns: int: The length of the longest path. # Create adjacency list representation of the graph from collections import defaultdict, deque graph = defaultdict(list) indegree = [0] * n for u, v in edges: graph[u].append(v) indegree[v] += 1 # Identify all starting nodes with indegree 0 queue = deque([i for i in range(n) if indegree[i] == 0]) distance = [0] * n while queue: node = queue.popleft() for neighbor in graph[node]: if distance[neighbor] < distance[node] + 1: distance[neighbor] = distance[node] + 1 indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) return max(distance)"},{"question":"from typing import List def max_trapped_water(grid: List[List[int]]) -> int: Given a matrix of integers grid where each cell represents a block of height grid[i][j], find the maximum water that can be trapped after raining. Water can only be trapped in a cell if there are higher blocks on all four sides of the cell. Return the total amount of trapped water. The grid is surrounded by blocks of zero height. >>> max_trapped_water([ ... [1, 4, 3, 1, 3, 2], ... [3, 2, 1, 3, 2, 3], ... [2, 3, 3, 2, 3, 1] ... ]) == 4 >>> max_trapped_water([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) == 0 >>> max_trapped_water([[1, 2, 1, 2, 1]]) == 0 >>> max_trapped_water([ ... [1], ... [2], ... [1], ... [2], ... [1] ... ]) == 0 >>> max_trapped_water([ ... [3, 3, 3, 3, 3, 3], ... [3, 0, 0, 0, 0, 3], ... [3, 0, 3, 3, 0, 3], ... [3, 3, 3, 3, 3, 3] ... ]) == 18 >>> max_trapped_water([]) == 0 >>> max_trapped_water([[0]]) == 0 pass","solution":"import heapq def max_trapped_water(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) visited = [[False] * m for _ in range(n)] heap = [] water = 0 # Push all the border cells into the heap for i in range(n): for j in range(m): if i == 0 or i == n-1 or j == 0 or j == m-1: heapq.heappush(heap, (grid[i][j], i, j)) visited[i][j] = True # 4 possible directions to move directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while heap: height, x, y = heapq.heappop(heap) # Traverse the adjacent cells for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: visited[nx][ny] = True water += max(0, height - grid[nx][ny]) heapq.heappush(heap, (max(height, grid[nx][ny]), nx, ny)) return water"},{"question":"def max_profit(arr: List[int]) -> int: Returns the maximum profit that can be achieved by buying and selling one share of stock. Parameters: arr (List[int]): A list of integers representing stock prices. Returns: int: The maximum profit possible, or 0 if no profit is possible. Examples: >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(arr): Returns the maximum profit that can be achieved by buying and selling one share of stock. Parameters: arr (List[int]): A list of integers representing stock prices. Returns: int: The maximum profit possible, or 0 if no profit is possible. if not arr or len(arr) < 2: return 0 min_price = arr[0] max_profit = 0 for price in arr[1:]: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def can_convert_by_rearranging(s: str, t: str) -> bool: Determine if you can convert string \`s\` into string \`t\` by performing some number of operations, where in one operation you can select any substring of \`s\` and rearrange its characters in any order. >>> can_convert_by_rearranging(\\"abc\\", \\"bca\\") True >>> can_convert_by_rearranging(\\"abc\\", \\"abcd\\") False >>> can_convert_by_rearranging(\\"aabbcc\\", \\"abc\\") False >>> can_convert_by_rearranging(\\"abc\\", \\"abc\\") True >>> can_convert_by_rearranging(\\"abc\\", \\"def\\") False >>> can_convert_by_rearranging(\\"\\", \\"\\") True >>> can_convert_by_rearranging(\\"abc\\", \\"\\") False >>> can_convert_by_rearranging(\\"\\", \\"abc\\") False >>> can_convert_by_rearranging(\\"a!b@c#\\", \\"#c@b!a\\") True","solution":"def can_convert_by_rearranging(s, t): Determines if string \`s\` can be converted into string \`t\` by rearranging any substrings of \`s\` any number of times. from collections import Counter return Counter(s) == Counter(t)"},{"question":"def intersection(arr1: List[int], arr2: List[int]) -> List[int]: Returns the intersection of arr1 and arr2 in ascending order. Args: arr1 : List[int] - The first list of integers. arr2 : List[int] - The second list of integers. Returns: List[int] - A list of unique elements that are present in both arrays in ascending order. Examples: >>> intersection([1, 2, 3], [4, 5, 6]) [] >>> intersection([1, 2, 3, 4], [3, 4, 5, 6]) [3, 4] >>> intersection([1, 2, 3], [1, 2, 3]) [1, 2, 3] >>> intersection([], [1, 2, 3]) [] >>> intersection([1, 2, 3], []) [] >>> intersection([], []) [] >>> intersection([1, 2, 2, 3, 3], [2, 3, 3, 4]) [2, 3]","solution":"def intersection(arr1, arr2): Returns the intersection of arr1 and arr2 in ascending order. # Convert both arrays to sets to find the intersection set1 = set(arr1) set2 = set(arr2) # Find intersection of both sets result_set = set1.intersection(set2) # Convert the result to a sorted list result_list = sorted(result_set) return result_list"},{"question":"def find_duplicates(nums: List[int]) -> List[int]: Finds all elements that appear exactly twice in the list of integers \`nums\`. The solution works in linear time and uses constant extra space. :param nums: List of integers where some elements may appear twice. :return: List of integers that appear exactly twice, in ascending order. >>> find_duplicates([1, 2, 3, 4]) [] >>> find_duplicates([1, 2, 3, 2, 4]) [2] >>> find_duplicates([4, 3, 2, 7, 8, 2, 3, 1]) [2, 3] >>> find_duplicates([2, 2, 3, 3]) [2, 3] >>> find_duplicates([10, 5, 10, 1, 5, 7, 8, 8, 9, 7]) [5, 7, 8, 10] >>> find_duplicates([]) [] >>> find_duplicates([1]) [] >>> find_duplicates([1, 2, 2, 3, 3, 3, 4, 4]) [2, 3, 4]","solution":"def find_duplicates(nums): Finds all elements that appear exactly twice in the list of integers \`nums\`. The solution works in linear time and uses constant extra space. :param nums: List of integers where some elements may appear twice. :return: List of integers that appear exactly twice, in ascending order. result = [] for num in nums: index = abs(num) - 1 if nums[index] < 0: result.append(abs(num)) nums[index] = -nums[index] return sorted(result)"},{"question":"def minimize_highest_and_lowest_difference(nums: List[int], k: int) -> List[int]: Rearranges the array such that the difference between the highest and lowest numbers in each subarray of size k is minimized. :param nums: List[int] - the input array of integers :param k: int - the size of each subarray :return: List[int] - the rearranged array >>> minimize_highest_and_lowest_difference([4, 1, 3, 2], 2) == [1, 2, 3, 4] >>> minimize_highest_and_lowest_difference([6, 2, 8, 4, 1], 3) == [1, 2, 4, 6, 8] >>> minimize_highest_and_lowest_difference([], 2) == [] >>> minimize_highest_and_lowest_difference([4, 1, 3], 4) == [] >>> minimize_highest_and_lowest_difference([4, 1, 3], 5) == [] >>> minimize_highest_and_lowest_difference([1, 2, 3, 4, 5], 2) == [1, 2, 3, 4, 5] >>> minimize_highest_and_lowest_difference([5, 3, 1, 2, 4], 1) == [1, 2, 3, 4, 5]","solution":"def minimize_highest_and_lowest_difference(nums, k): Rearranges the array such that the difference between the highest and lowest numbers in each subarray of size k is minimized. :param nums: List[int] - the input array of integers :param k: int - the size of each subarray :return: List[int] - the rearranged array if k > len(nums): return [] nums.sort() rearranged = [] subarrays = [nums[i:i + k] for i in range(0, len(nums), k)] for subarray in subarrays: rearranged += subarray return rearranged"},{"question":"def numRescueBoats(people: List[int], limit: int) -> int: Returns the minimum number of boats required to carry everyone across to the other side. >>> numRescueBoats([1, 2], 3) 1 >>> numRescueBoats([3, 2, 2, 1], 3) 3 >>> numRescueBoats([3, 5, 3, 4], 5) 4 >>> numRescueBoats([5, 1, 7, 4, 3, 2], 8) 3 >>> numRescueBoats([50, 50, 70, 80], 100) 3 >>> numRescueBoats([40, 50, 60, 70], 50) 4 >>> numRescueBoats([30], 50) 1 >>> numRescueBoats([100, 200, 150, 80], 200) 3 pass","solution":"def numRescueBoats(people, limit): Returns the minimum number of boats required to carry everyone across to the other side. Parameters: people (list of int): Weights of the people. limit (int): Maximum weight that a boat can carry. Returns: int: Minimum number of boats required. people.sort() left, right = 0, len(people) - 1 boats = 0 while left <= right: if people[left] + people[right] <= limit: left += 1 right -= 1 boats += 1 return boats"},{"question":"def is_subsequence(sub, s): Helper function to determine if 'sub' is a subsequence of 's'. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"\\", \\"ahbgdc\\") True >>> is_subsequence(\\"ahbgdc\\", \\"ahbgdc\\") True pass def longest_subsequence_length(s, words): Returns the length of the longest string in words that is a subsequence of s. >>> longest_subsequence_length(\\"abppplee\\", [\\"able\\", \\"ale\\", \\"apple\\", \\"bale\\"]) 5 >>> longest_subsequence_length(\\"abc\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) 1 >>> longest_subsequence_length(\\"xyz\\", [\\"a\\", \\"b\\", \\"c\\"]) 0 >>> longest_subsequence_length(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\", \\"ace\\"]) 3 pass","solution":"def is_subsequence(sub, s): Helper function to determine if 'sub' is a subsequence of 's'. it = iter(s) return all(char in it for char in sub) def longest_subsequence_length(s, words): Returns the length of the longest string in words that is a subsequence of s. max_length = 0 for word in words: if is_subsequence(word, s): max_length = max(max_length, len(word)) return max_length"},{"question":"def is_anagram(word1: str, word2: str) -> bool: Determines if word2 is an anagram of word1. >>> is_anagram(\\"listen\\", \\"silent\\") == True >>> is_anagram(\\"evil\\", \\"vile\\") == True >>> is_anagram(\\"fluster\\", \\"restful\\") == True >>> is_anagram(\\"listen\\", \\"listens\\") == False >>> is_anagram(\\"hello\\", \\"bello\\") == False >>> is_anagram(\\"\\", \\"\\") == True >>> is_anagram(\\"Listen\\", \\"Silent\\") == False >>> is_anagram(\\"a*b&c\\", \\"c&b*a\\") == True","solution":"def is_anagram(word1, word2): Determines if word2 is an anagram of word1. Args: word1 (str): The first word. word2 (str): The second word. Returns: bool: True if word2 is an anagram of word1, False otherwise. # Check lengths first to short-circuit non-anagrams if len(word1) != len(word2): return False # Count characters in both words from collections import Counter return Counter(word1) == Counter(word2)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def left_side_view_sum(root): Returns the sum of node values visible from the left side of a binary tree. :param root: TreeNode :return: int >>> root1 = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) >>> left_side_view_sum(root1) 7 >>> root2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) >>> left_side_view_sum(root2) 7 >>> root3 = TreeNode(1, None, TreeNode(3, TreeNode(5), TreeNode(6))) >>> left_side_view_sum(root3) 9 >>> root4 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5, TreeNode(7))), TreeNode(3, None, TreeNode(6, None, TreeNode(8)))) >>> left_side_view_sum(root4) 14 >>> left_side_view_sum(None) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def left_side_view_sum(root): Returns the sum of node values visible from the left side of a binary tree. :param root: TreeNode :return: int if not root: return 0 left_side_sum = 0 max_level = -1 def dfs(node, level): nonlocal left_side_sum, max_level if not node: return if level > max_level: left_side_sum += node.val max_level = level # Traverse left before right to ensure left-most node is counted first dfs(node.left, level + 1) dfs(node.right, level + 1) dfs(root, 0) return left_side_sum"},{"question":"def min_removals_to_make_valid_palindrome(s: str) -> int: Determine the minimum number of characters you need to remove to make the string a palindrome with only one character appearing an odd number of times, if possible. Return -1 if it is not possible. >>> min_removals_to_make_valid_palindrome(\\"abccba\\") 0 >>> min_removals_to_make_valid_palindrome(\\"aabbc\\") 0 >>> min_removals_to_make_valid_palindrome(\\"aaabbbc\\") 2 >>> min_removals_to_make_valid_palindrome(\\"abc\\") 2 >>> min_removals_to_make_valid_palindrome(\\"aaabbbccc\\") 2","solution":"def min_removals_to_make_valid_palindrome(s): Returns the minimum number of characters to remove to make the string a palindrome with only one character having an odd frequency count. Returns -1 if it's not possible. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # a valid palindrome can have at most one character with an odd count if odd_count > 1: return odd_count - 1 return 0"},{"question":"def find_longest_substring(s: str) -> int: Given a string \`s\` containing only the characters 'a' and 'b', return the length of the longest substring that contains the same number of 'a's as 'b's. >>> find_longest_substring(\\"aabb\\") == 4 >>> find_longest_substring(\\"abab\\") == 4 >>> find_longest_substring(\\"aabbaabb\\") == 8","solution":"def find_longest_substring(s): Returns the length of the longest substring that contains the same number of 'a's as 'b's. count_dict = {0: -1} # Dictionary to store the first occurrence of each count max_length = 0 count = 0 for i, char in enumerate(s): if char == 'a': count += 1 else: # char == 'b' count -= 1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length"},{"question":"from collections import deque from typing import List class TreeNode: def __init__(self, val: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right class TreeLevelAverages: def __init__(self, root: TreeNode): Initialize the TreeLevelAverages object with the root node of the binary tree. Args: root (TreeNode): The root node of the binary tree. self.root = root def levelAverages(self) -> List[float]: Returns a list of doubles representing the average value of the nodes on each level of the binary tree. Returns: List[float]: A list of averages of each level in the binary tree. pass # Unit Tests def test_basic_tree(): root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7))) tla = TreeLevelAverages(root) assert tla.levelAverages() == [3, 14.5, 11] def test_single_node(): root = TreeNode(10) tla = TreeLevelAverages(root) assert tla.levelAverages() == [10] def test_empty_tree(): tla = TreeLevelAverages(None) assert tla.levelAverages() == [] def test_unbalanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4)), TreeNode(3)) tla = TreeLevelAverages(root) assert tla.levelAverages() == [1, 2.5, 4] def test_tree_with_negative_values(): root = TreeNode(1, TreeNode(-2), TreeNode(-3, TreeNode(-4), TreeNode(-5))) tla = TreeLevelAverages(root) assert tla.levelAverages() == [1, -2.5, -4.5] def test_large_tree(): root = TreeNode( 1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7, TreeNode(8), TreeNode(9))) ) tla = TreeLevelAverages(root) assert tla.levelAverages() == [1, 2.5, 5.5, 8.5]","solution":"from collections import deque from typing import List class TreeNode: def __init__(self, val: int, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right class TreeLevelAverages: def __init__(self, root: TreeNode): self.root = root def levelAverages(self) -> List[float]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"def numDistinctIslands(grid: List[List[int]]) -> int: Count the number of distinct islands in the grid. An island is a group of connected 1s (vertical or horizontal). >>> numDistinctIslands([ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) == 0 >>> numDistinctIslands([ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ]) == 1 >>> numDistinctIslands([ [1, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 1, 1] ]) == 2 >>> numDistinctIslands([ [1, 1, 0, 1, 1], [1, 1, 0, 1, 1], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [1, 1, 0, 1, 1] ]) == 1 >>> numDistinctIslands([ [1, 1, 0, 1], [1, 0, 0, 1], [0, 0, 1, 0], [1, 0, 1, 1] ]) == 4","solution":"def numDistinctIslands(grid): def dfs(x, y, direction): if (x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0): return grid[x][y] = 0 path_signature.append(direction) dfs(x + 1, y, 'd') dfs(x - 1, y, 'u') dfs(x, y + 1, 'r') dfs(x, y - 1, 'l') path_signature.append('0') distinct_islands = set() for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: path_signature = [] dfs(i, j, 's') distinct_islands.add(tuple(path_signature)) return len(distinct_islands)"},{"question":"def product_except_self(nums: List[int]) -> List[int]: Returns an array such that each element is the product of all the numbers in nums except the number at the position of the element. >>> product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] >>> product_except_self([1, 0, 3, 4]) == [0, 12, 0, 0] >>> product_except_self([10]) == [1] >>> product_except_self([0, 0, 0, 0]) == [0, 0, 0, 0] >>> product_except_self([-1, 1, 0, -3, 3]) == [0, 0, 9, 0, 0] >>> product_except_self([1, 2, -3, 4]) == [-24, -12, 8, -6]","solution":"def product_except_self(nums): Returns an array such that each element is the product of all the numbers in nums except the number at the position of the element. length = len(nums) results = [1] * length # initialize the results array with 1s # Calculate products of all elements to the left of each element left_product = 1 for i in range(length): results[i] = left_product left_product *= nums[i] # Calculate products of all elements to the right of each element and multiply with the previously calculated left product right_product = 1 for i in range(length-1, -1, -1): results[i] *= right_product right_product *= nums[i] return results"},{"question":"def count_k_length_subarrays_with_sum(nums: List[int], k: int, target: int) -> int: Returns the number of unique k-length subarrays whose sum is equal to target. Parameters: nums (list[int]): List of integers. k (int): Length of subarray. target (int): Target sum of subarray. Returns: int: count of k-length subarrays with sum equal to target. >>> count_k_length_subarrays_with_sum([1, 2, 3, 4, 5], 2, 5) 1 >>> count_k_length_subarrays_with_sum([1, 1, 1, 1, 1], 2, 2) 4 >>> count_k_length_subarrays_with_sum([1, 2, 3, 4, 5], 3, 15) 0 >>> count_k_length_subarrays_with_sum([3, 3, 3, 3, 3], 1, 3) 5 >>> count_k_length_subarrays_with_sum([1, 2, 3, 4, 5, 6], 6, 21) 1 >>> count_k_length_subarrays_with_sum([1, 2, 3], 4, 6) 0 >>> count_k_length_subarrays_with_sum([], 3, 0) 0","solution":"def count_k_length_subarrays_with_sum(nums, k, target): Returns the number of unique k-length subarrays whose sum is equal to target. Parameters: nums (list[int]): List of integers. k (int): Length of subarray. target (int): Target sum of subarray. Returns: int: count of k-length subarrays with sum equal to target. if k > len(nums): return 0 count = 0 current_sum = sum(nums[:k]) if current_sum == target: count += 1 for i in range(1, len(nums) - k + 1): current_sum = current_sum - nums[i - 1] + nums[i + k - 1] if current_sum == target: count += 1 return count"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. :param s: The input string containing only lowercase alphabets :type s: str :return: Length of the longest substring without repeating characters :rtype: int","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: The input string containing only lowercase alphabets :type s: str :return: Length of the longest substring without repeating characters :rtype: int char_map = {} max_length = 0 start = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def trap(height): Given an array of integers heights representing the heights of buildings, where buildings are aligned in a row from left to right, you need to calculate how much water this structure will trap after raining. Return the total amount of trapped rainwater. >>> trap([]) == 0 >>> trap([4]) == 0 >>> trap([3, 2]) == 0 >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trap([3, 3, 3, 3, 3]) == 0 >>> trap([5, 4, 3, 2, 1]) == 0 >>> trap([1, 2, 3, 4, 5]) == 0","solution":"def trap(height): Computes the total amount of trapped rainwater given the heights of the buildings. :param height: List[int] - A list of integers representing the height of buildings. :return: int - The total amount of trapped rainwater. if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i-1], height[i]) right_max[n-1] = height[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def max_sum_submatrix(matrix): Finds the maximum sum of any rectangular submatrix within the given matrix. Parameters: matrix (list of list of int): A 2D list with m rows and n columns representing the matrix. Returns: int: The maximum sum of a rectangular submatrix. pass from solution import max_sum_submatrix def test_max_sum_submatrix_all_positive(): matrix = [ [1, 2, -1, -4, -20], [-8, -3, 4, 2, 1], [3, 8, 10, 1, 3], [-4, -1, 1, 7, -6] ] assert max_sum_submatrix(matrix) == 29 def test_max_sum_submatrix_with_negative_numbers(): matrix = [ [-1, -2, -3, -4], [-5, -6, -7, -8], [-9, -10, -11, -12], [-13, -14, -15, -16] ] assert max_sum_submatrix(matrix) == -1 def test_max_sum_submatrix_single_element(): matrix = [ [5] ] assert max_sum_submatrix(matrix) == 5 def test_max_sum_submatrix_empty_matrix(): matrix = [] assert max_sum_submatrix(matrix) == 0 def test_max_sum_submatrix_mixed_elements(): matrix = [ [2, 1, -3, -4, 5], [0, 6, 3, 4, 1], [2, -2, -1, 4, -5], [-3, 3, 1, 0, 3] ] assert max_sum_submatrix(matrix) == 18","solution":"def max_sum_submatrix(matrix): Finds the maximum sum of any rectangular submatrix within the given matrix. Parameters: matrix (list of list of int): A 2D list with m rows and n columns representing the matrix. Returns: int: The maximum sum of a rectangular submatrix. if not matrix or not matrix[0]: return 0 def max_subarray_sum(arr): max_sum = arr[0] current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum m, n = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(n): row_sums = [0] * m for right in range(left, n): for i in range(m): row_sums[i] += matrix[i][right] current_max_sum = max_subarray_sum(row_sums) max_sum = max(max_sum, current_max_sum) return max_sum"},{"question":"def can_transform(s1: str, s2: str) -> bool: Determines if s1 can be transformed into s2 using the allowed operations. Args: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, otherwise False. >>> can_transform(\\"abc\\", \\"ac\\") True >>> can_transform(\\"hello\\", \\"hello\\") True >>> can_transform(\\"abcd\\", \\"abcde\\") False >>> can_transform(\\"abacb\\", \\"abc\\") True >>> can_transform(\\"axbycz\\", \\"abc\\") True >>> can_transform(\\"xyz\\", \\"abc\\") False >>> can_transform(\\"anystring\\", \\"\\") True >>> can_transform(\\"aaaaa\\", \\"aa\\") True","solution":"def can_transform(s1, s2): Determines if s1 can be transformed into s2 using the allowed operations. Args: s1 (str): The source string. s2 (str): The target string. Returns: bool: True if s1 can be transformed into s2, otherwise False. def is_subsequence(s1, s2): # Helper function to check if s2 is a subsequence of s1 it = iter(s1) return all(char in it for char in s2) return is_subsequence(s1, s2)"},{"question":"class ParkingSystem: Design and implement a \`ParkingSystem\` class to simulate a parking lot with three different types of spots: big, medium, and small. * \`ParkingSystem(int big, int medium, int small)\` initializes the parking system with the number of available spots for each parking type. * \`boolean addCar(int carType)\` checks whether there is a slot available for the given car type. \`carType\` can be \`1\` for big cars, \`2\` for medium cars, and \`3\` for small cars. If there is an available slot, parks the car in that slot and returns \`true\`. Otherwise, returns \`false\`. Unit Test: from solution import ParkingSystem def test_parking_system_initialization(): ps = ParkingSystem(1, 1, 1) assert ps.spots == {1: 1, 2: 1, 3: 1} def test_add_big_car(): ps = ParkingSystem(1, 0, 0) assert ps.addCar(1) == True assert ps.addCar(1) == False def test_add_medium_car(): ps = ParkingSystem(0, 1, 0) assert ps.addCar(2) == True assert ps.addCar(2) == False def test_add_small_car(): ps = ParkingSystem(0, 0, 1) assert ps.addCar(3) == True assert ps.addCar(3) == False def test_add_car_to_empty_spot(): ps = ParkingSystem(0, 0, 0) assert ps.addCar(1) == False assert ps.addCar(2) == False assert ps.addCar(3) == False def test_add_different_types_of_cars(): ps = ParkingSystem(1, 1, 1) assert ps.addCar(1) == True assert ps.addCar(2) == True assert ps.addCar(3) == True assert ps.addCar(1) == False assert ps.addCar(2) == False assert ps.addCar(3) == False","solution":"class ParkingSystem: def __init__(self, big, medium, small): self.spots = {1: big, 2: medium, 3: small} def addCar(self, carType): if self.spots[carType] > 0: self.spots[carType] -= 1 return True return False"},{"question":"def two_sum(nums, target): Given an array of integers nums and an integer target, find two distinct indices (i, j) such that nums[i] + nums[j] = target. Return the indices (i, j) as a tuple. If no such indices exist, return None. Args: nums: List[int] - list of integers target: int - target sum Returns: Tuple[int, int] or None - indices of two numbers whose sum equals the target >>> two_sum([2, 7, 11, 15], 9) (0, 1) >>> two_sum([1, 2, 3, 4], 10) None >>> two_sum([-1, -2, -3, -4, -5], -8) (2, 4) >>> two_sum([3, 2, 4, 3], 6) (0, 3) >>> two_sum([0, 4, 5, 0], 0) (0, 3)","solution":"def two_sum(nums, target): Given an array of integers nums and an integer target, find two distinct indices (i, j) such that nums[i] + nums[j] = target. Return the indices (i, j) as a tuple. If no such indices exist, return None. Args: nums: List[int] - list of integers target: int - target sum Returns: Tuple[int, int] or None - indices of two numbers whose sum equals the target num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"from typing import List def length_of_LIS(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given array. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) # Output: 4 >>> length_of_LIS([10]) # Output: 1 >>> length_of_LIS([]) # Output: 0 >>> length_of_LIS([5, 4, 3, 2, 1]) # Output: 1 >>> length_of_LIS([1, 2, 3, 4, 5]) # Output: 5 >>> length_of_LIS([7, 4, 5, 6, 2, 8, 10, 12, 14, 1, 3, 9, 11]) # Output: 7","solution":"def length_of_LIS(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 n = len(arr) dp = [1] * n # dp[i] represents the length of the longest increasing subsequence ending at index i for i in range(n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"from typing import List def rearrange_characters(characters: List[str], k: int) -> str: Rearrange characters such that no two adjacent characters are the same, and each character appears k times if possible. Return an empty string if not possible. >>> rearrange_characters(['a', 'a', 'b', 'b', 'c', 'c'], 2) in [\\"abcabc\\", \\"acbacb\\", \\"bacbac\\"] True >>> rearrange_characters(['a'], 1) 'a' >>> rearrange_characters(['a'], 2) 'a' >>> rearrange_characters(['a', 'a', 'a'], 2) '' >>> rearrange_characters([], 1) '' >>> rearrange_characters(['a', 'a', 'b', 'b', 'c', 'c', 'd', 'd', 'e', 'e'], 3) in [\\"abcdeabcde\\", \\"abdecabdec\\", \\"bacdebaced\\", \\"bdecabdata\\", \\"cabdeabcde\\"] True >>> rearrange_characters(['a', 'b', 'c', 'd'], 4) in [\\"abcd\\", \\"abdc\\", \\"acbd\\", \\"acdb\\", \\"adbc\\", \\"adcb\\", \\"bacd\\", \\"badc\\", \\"bcad\\", \\"bcda\\", \\"bdac\\", \\"bdca\\", \\"cabd\\", \\"cadb\\", \\"cbad\\", \\"cbda\\", \\"cdab\\", \\"cdba\\", \\"dabc\\", \\"dacb\\", \\"dbac\\", \\"dbca\\", \\"dcab\\", \\"dcba\\"] True # Your implementation here","solution":"from collections import Counter import heapq def rearrange_characters(characters, k): Rearrange characters such that no two adjacent characters are the same, and each character appears k times if possible. Return an empty string if not possible. :param characters: List of characters :param k: Int representing the required frequency of each character :return: A rearranged string meeting the condition or empty string if not possible if not characters: return \\"\\" counter = Counter(characters) max_heap = [(-freq, char) for char, freq in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) if len(wait_queue) >= k: freq, char = wait_queue.pop(0) if freq < 0: heapq.heappush(max_heap, (freq, char)) if len(result) == len(characters): return \\"\\".join(result) else: return \\"\\""},{"question":"def letter_combinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent. >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letter_combinations(\\"237\\") [\\"adp\\", \\"adq\\", \\"adr\\", \\"ads\\", \\"aep\\", \\"aeq\\", \\"aer\\", \\"aes\\", \\"afp\\", \\"afq\\", \\"afr\\", \\"afs\\", \\"bdp\\", \\"bdq\\", \\"bdr\\", \\"bds\\", \\"bep\\", \\"beq\\", \\"ber\\", \\"bes\\", \\"bfp\\", \\"bfq\\", \\"bfr\\", \\"bfs\\", \\"cdp\\", \\"cdq\\", \\"cdr\\", \\"cds\\", \\"cep\\", \\"ceq\\", \\"cer\\", \\"ces\\", \\"cfp\\", \\"cfq\\", \\"cfr\\", \\"cfs\\"]","solution":"def letter_combinations(digits): Returns all possible letter combinations that the number could represent. if not digits: return [] digit_to_chars = { \\"2\\": \\"abc\\", \\"3\\": \\"def\\", \\"4\\": \\"ghi\\", \\"5\\": \\"jkl\\", \\"6\\": \\"mno\\", \\"7\\": \\"pqrs\\", \\"8\\": \\"tuv\\", \\"9\\": \\"wxyz\\" } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_chars[digits[index]] for letter in possible_letters: backtrack(index + 1, path + [letter]) combinations = [] backtrack(0, []) return combinations"},{"question":"def is_balanced_parentheses(s: str) -> bool: Determine if the parentheses in the string are balanced. Args: s (str): input string containing '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is balanced, False otherwise Examples: >>> is_balanced_parentheses(\\"()\\") True >>> is_balanced_parentheses(\\"{[()]}\\") True >>> is_balanced_parentheses(\\"(\\") False >>> is_balanced_parentheses(\\"{[}\\") False >>> is_balanced_parentheses(\\"{[a + (b * c) - d]}\\") True >>> is_balanced_parentheses(\\"\\") True","solution":"def is_balanced_parentheses(s): Determine if the parentheses in the string are balanced. Args: s (str): input string containing '(', ')', '{', '}', '[' and ']' Returns: bool: True if the string is balanced, False otherwise stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses: if stack == [] or matching_parentheses[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def sunset_houses(heights: List[int]) -> List[int]: Returns the indices of the houses that can see the sunset, sorted in ascending order. >>> sunset_houses([5, 4, 3, 2, 1]) == [0, 1, 2, 3, 4] >>> sunset_houses([1, 2, 3, 4, 5]) == [4] >>> sunset_houses([4, 2, 3, 1]) == [0, 2, 3] >>> sunset_houses([6]) == [0] >>> sunset_houses([3, 5]) == [1] >>> sunset_houses([5, 3]) == [0, 1] >>> sunset_houses([]) == []","solution":"def sunset_houses(heights): Returns the indices of the houses that can see the sunset, sorted in ascending order. :param heights: List[int] - The heights of the houses. :return: List[int] - The indices of the houses that can see the sunset. n = len(heights) result = [] max_height = -1 for i in range(n-1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return sorted(result)"},{"question":"from typing import List, Optional from collections import defaultdict class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right class DuplicateSubtrees: def __init__(self, root: TreeNode): Initializes the object with the root of the binary tree. self.root = root def findDuplicateSubtrees(self) -> List[TreeNode]: Returns all duplicate subtrees. For each kind of duplicated subtree, you only need to return the root node of any one of them. Example: >>> root = TreeNode(1) >>> root.left = TreeNode(2, TreeNode(4)) >>> root.right = TreeNode(3, TreeNode(2, TreeNode(4)), TreeNode(4)) >>> dt = DuplicateSubtrees(root) >>> duplicates = dt.findDuplicateSubtrees() >>> len(duplicates) 2","solution":"from typing import List, Optional, Tuple from collections import defaultdict class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right class DuplicateSubtrees: def __init__(self, root: TreeNode): self.root = root self.serial_map = defaultdict(list) def findDuplicateSubtrees(self) -> List[TreeNode]: def serialize(node: Optional[TreeNode]) -> str: if not node: return \\"#\\" serial = f\\"{node.val},{serialize(node.left)},{serialize(node.right)}\\" self.serial_map[serial].append(node) return serial serialize(self.root) result = [] for nodes in self.serial_map.values(): if len(nodes) > 1: result.append(nodes[0]) return result"},{"question":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. Args: nums (List[int]): An array representing the amount of money in each house. Returns: int: The maximum amount of money that can be robbed. Examples: >>> rob([]) 0 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([2, 3, 2]) 4 >>> rob([1, 2, 3, 1]) 4 >>> rob([2, 7, 9, 3, 1]) 12 >>> rob([5, 5, 5, 5, 5]) 15","solution":"def rob(nums): Returns the maximum amount of money that can be robbed without alerting the police. if not nums: return 0 if len(nums) <= 2: return max(nums) prev1, prev2 = 0, 0 for num in nums: temp = prev1 prev1 = max(prev2 + num, prev1) prev2 = temp return prev1"},{"question":"from typing import List def top_k_frequent(arr: List[int], k: int) -> List[int]: Returns a list of the \`k\` most frequent elements in the array \`arr\`. >>> top_k_frequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> top_k_frequent([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) [1, 2, 3] from solution import top_k_frequent def test_top_k_frequent_case_1(): arr = [1, 1, 1, 2, 2, 3] k = 2 assert top_k_frequent(arr, k) == [1, 2] def test_top_k_frequent_case_2(): arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] k = 3 assert top_k_frequent(arr, k) == [1, 2, 3] def test_top_k_frequent_case_3(): arr = [4, 4, 4, 6, 6, 7, 7, 7, 7, 3, 3, 3] k = 2 assert top_k_frequent(arr, k) == [7, 3] def test_top_k_frequent_with_ties(): arr = [5, 5, 6, 6, 1, 2, 3, 4] k = 2 assert top_k_frequent(arr, k) == [5, 6] def test_top_k_frequent_single_element(): arr = [7] k = 1 assert top_k_frequent(arr, k) == [7]","solution":"from collections import Counter def top_k_frequent(arr, k): Returns a list of the \`k\` most frequent elements in the array \`arr\`. Parameters: arr (list of int): The input array of integers. k (int): The number of most frequent elements to return. Returns: list of int: The \`k\` most frequent elements in the array sorted in ascending order in case of a tie. frequency = Counter(arr) # Get the list of elements sorted by frequency (descending) and then by value (ascending) sorted_elements = sorted(frequency.items(), key=lambda x: (-x[1], x[0])) # Extract the top k elements return [element[0] for element in sorted_elements[:k]]"},{"question":"from typing import List def findTargetSumWays(nums: List[int], target: int) -> int: Returns the number of ways to add the elements of nums (using both addition and subtraction) to reach exactly target. >>> findTargetSumWays([1, 1, 1, 1, 1], 3) 5 >>> findTargetSumWays([5], 5) 1 >>> findTargetSumWays([5], -5) 1 >>> findTargetSumWays([5], 3) 0 >>> findTargetSumWays([1, 2, 1], 2) 2 >>> findTargetSumWays([0, 0, 0, 0, 0], 0) 32 >>> findTargetSumWays([1, 2, 3], 10) 0 pass","solution":"def findTargetSumWays(nums, target): Returns the number of ways to add the elements of nums (using both addition and subtraction) to reach exactly target. memo = {} def backtrack(i, current_sum): if i == len(nums): return 1 if current_sum == target else 0 if (i, current_sum) in memo: return memo[(i, current_sum)] # Choose the number with a plus sign add = backtrack(i + 1, current_sum + nums[i]) # Choose the number with a minus sign subtract = backtrack(i + 1, current_sum - nums[i]) memo[(i, current_sum)] = add + subtract return memo[(i, current_sum)] return backtrack(0, 0)"},{"question":"def max_consecutive_chars(s: str, k: int) -> int: Given a string \`s\` that contains only lowercase alphabets, this function returns the length of the longest substring containing identical characters after performing at most \`k\` operations, where in each operation we can change any character to any other lowercase alphabet. Example: >>> max_consecutive_chars(\\"aabccbb\\", 2) 5 >>> max_consecutive_chars(\\"abbcb\\", 1) 4 >>> max_consecutive_chars(\\"abccde\\", 1) 3","solution":"def max_consecutive_chars(s, k): Returns the length of the longest substring containing identical characters after performing at most k operations. from collections import Counter max_len = 0 left = 0 freq = Counter() for right in range(len(s)): freq[s[right]] += 1 while (right - left + 1) - max(freq.values()) > k: freq[s[left]] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Return a list of all the strings in 'words' that match the given 'pattern'. A string is said to match a pattern if there is a bijective mapping between a letter in the pattern and a letter in the string. >>> find_and_replace_pattern([\\"mee\\"], \\"abb\\") ['mee'] >>> find_and_replace_pattern([\\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") ['mee', 'aqq'] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"abb\\") [] >>> find_and_replace_pattern([\\"abaa\\", \\"abc\\"], \\"ab\\") [] >>> find_and_replace_pattern([\\"a\\" * 1000 + \\"b\\", \\"a\\" * 999 + \\"b\\", \\"a\\" * 1000], \\"a\\" * 1000 + \\"b\\") ['a' * 1000 + \\"b\\"]","solution":"def find_and_replace_pattern(words, pattern): def is_match(word): if len(word) != len(pattern): return False w_to_p, p_to_w = {}, {} for w, p in zip(word, pattern): if w not in w_to_p: w_to_p[w] = p if p not in p_to_w: p_to_w[p] = w if w_to_p[w] != p or p_to_w[p] != w: return False return True return [word for word in words if is_match(word)]"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the given unsorted integer array nums. >>> find_kth_largest([3, 2, 1, 5, 6, 4], 2) 5 >>> find_kth_largest([3, 2, 1, 5, 6, 4], 1) 6 >>> find_kth_largest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the given unsorted integer array nums. def quickselect(start, end, idx): pivot = nums[end] p = start for i in range(start, end): if nums[i] >= pivot: nums[i], nums[p] = nums[p], nums[i] p += 1 nums[p], nums[end] = nums[end], nums[p] if p == idx: return nums[p] elif p > idx: return quickselect(start, p - 1, idx) else: return quickselect(p + 1, end, idx) return quickselect(0, len(nums) - 1, k - 1)"},{"question":"def max_abs_diff(nums: List[int]) -> int: Given an array of integers \`nums\`, find two distinct indices \`i\` and \`j\` in the array such that the absolute difference between \`nums[i]\` and \`nums[j]\` is maximized. Return the maximum absolute difference. >>> max_abs_diff([1, 2, 3, 4, 5]) == 4 >>> max_abs_diff([-10, -5, 0, 5, 10]) == 20 >>> max_abs_diff([-20, -15, -10, -5]) == 15 >>> max_abs_diff([10**9, -10**9, 0]) == 2000000000 >>> max_abs_diff([2, 3]) == 1 >>> max_abs_diff([1, 1, 1, 1, 5]) == 4","solution":"def max_abs_diff(nums): Returns the maximum absolute difference between two distinct elements in the array nums. min_val = min(nums) max_val = max(nums) return max_val - min_val"},{"question":"def min_cut_palindrome_substrings(s: str) -> int: Given a string \`s\`, split the string into the minimum number of substrings such that each substring is a palindrome. Args: s (str): The input string. Returns: int: The minimum number of palindromic substrings. >>> min_cut_palindrome_substrings(\\"a\\") == 1 >>> min_cut_palindrome_substrings(\\"aa\\") == 1 >>> min_cut_palindrome_substrings(\\"ab\\") == 2 >>> min_cut_palindrome_substrings(\\"aab\\") == 2 >>> min_cut_palindrome_substrings(\\"racecar\\") == 1 >>> min_cut_palindrome_substrings(\\"madamracecar\\") == 2 >>> min_cut_palindrome_substrings(\\"abcbd\\") == 3 >>> min_cut_palindrome_substrings(\\"aaa\\") == 1 >>> min_cut_palindrome_substrings(\\"abcdef\\") == 6","solution":"def min_cut_palindrome_substrings(s): Returns the minimum number of palindromic substrings that \`s\` can be split into. n = len(s) dp = [[False] * n for _ in range(n)] cuts = [0] * n for end in range(n): min_cut = end for start in range(end + 1): if s[start] == s[end] and (end - start <= 1 or dp[start + 1][end - 1]): dp[start][end] = True min_cut = 0 if start == 0 else min(min_cut, cuts[start - 1] + 1) cuts[end] = min_cut return cuts[-1] + 1"},{"question":"def findMaxLength(arr: List[int]) -> int: Returns the length of the largest subarray with an equal number of 0s and 1s. >>> findMaxLength([0, 1, 0]) 2 >>> findMaxLength([0, 1]) 2 >>> findMaxLength([0, 1, 0, 1, 1, 0, 0]) 6 >>> findMaxLength([1, 1, 0, 0, 1]) 4 >>> findMaxLength([0, 1, 0, 1, 0, 1]) 6 >>> findMaxLength([0]) 0 >>> findMaxLength([1]) 0 >>> findMaxLength([]) 0 >>> findMaxLength([0, 0, 0]) 0 >>> findMaxLength([1, 1, 1]) 0","solution":"def findMaxLength(arr): Returns the length of the largest subarray with an equal number of 0s and 1s. hash_map = {0: -1} max_length = 0 count = 0 for i, num in enumerate(arr): # Replace 0 with -1 if num == 0: count -= 1 else: count += 1 if count in hash_map: max_length = max(max_length, i - hash_map[count]) else: hash_map[count] = i return max_length"},{"question":"def find_substring(s: str, words: List[str]) -> int: Given a string \`s\` and an array of strings \`words\`, find the length of the longest substring in \`s\` that is a concatenation of each word in \`words\` exactly once and without any intervening characters. Each word in \`words\` must be of the same length. Return the starting index of the longest substring. If there is no such substring, return -1. >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\"]) == 3 >>> find_substring(\\"barfoothefoobarman\\", [\\"bar\\"]) == 0 >>> find_substring(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == 0 >>> find_substring(\\"wordgoodgoodgoodbestword\\", [\\"word\\", \\"good\\", \\"best\\", \\"word\\"]) == -1 >>> find_substring(\\"abcdefg\\", [\\"hij\\"]) == -1 >>> find_substring(\\"abcabcabc\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == -1 >>> find_substring(\\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\", [\\"fooo\\", \\"barr\\", \\"wing\\", \\"ding\\", \\"wing\\"]) == 13 >>> find_substring(\\"\\", [\\"foo\\"]) == -1 >>> find_substring(\\"foobar\\", []) == -1 >>> find_substring(\\"barfoofoobar\\", [\\"bar\\", \\"foo\\"]) == 0 >>> find_substring(\\"foobarfoobar\\", [\\"bar\\", \\"foo\\"]) == 0 >>> find_substring(\\"foobarfoobar\\", [\\"foo\\", \\"bar\\"]) == 0","solution":"def find_substring(s, words): if not s or not words: return -1 word_length = len(words[0]) total_words = len(words) substring_length = word_length * total_words word_count = {word: words.count(word) for word in words} def check(start): seen = {} for i in range(total_words): word_start = start + i * word_length word = s[word_start:word_start + word_length] if word not in word_count: return False seen[word] = seen.get(word, 0) + 1 if seen[word] > word_count[word]: return False return True for i in range(len(s) - substring_length + 1): if check(i): return i return -1"},{"question":"def two_sum_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Returns all unique pairs (a, b) from the list nums such that a + b = target, sorted by the first element and then by the second element. Args: nums (list of int): List of integers. target (int): Target sum of pairs. Returns: list of tuple: Unique pairs (a, b) such that a + b = target. >>> two_sum_pairs([2, 7, 11, 15], 9) [(2, 7)] >>> two_sum_pairs([1, 2, 3, 2, 1, 4, 3, 5], 5) [(1, 4), (2, 3)] >>> two_sum_pairs([1, 2, 3, 4], 10) [] >>> two_sum_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)] >>> two_sum_pairs([-1, 0, 1, 2, -1, -4], 0) [(-1, 1)] >>> two_sum_pairs([-1000, 500, 0, 500, 1000, -500], 0) [(-1000, 1000), (-500, 500)]","solution":"def two_sum_pairs(nums, target): Returns all unique pairs (a, b) from the list nums such that a + b = target, sorted by the first element and then by the second element. Args: nums (list of int): List of integers. target (int): Target sum of pairs. Returns: list of tuple: Unique pairs (a, b) such that a + b = target. nums = sorted(nums) # Sort nums to ensure the pairs are in ascending order pairs = set() seen = {} for num in nums: complement = target - num if complement in seen: pairs.add((complement, num)) seen[num] = complement return sorted(list(pairs))"},{"question":"import heapq from typing import List def kth_smallest(matrix: List[List[int]], k: int) -> int: Given a 2D integer array \`matrix\`, where each row is sorted in non-decreasing order, find the \`k-th\` smallest element in the matrix. The function should return the k-th smallest element while maintaining the sorting properties of each row. :param matrix: List[List[int]], 2D matrix where each row is sorted in non-decreasing order :param k: int, the k-th smallest element to find :return: int, the k-th smallest element in the matrix # Implement this function def test_kth_smallest_example_1(): matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ] assert kth_smallest(matrix, 8) == 13 def test_kth_smallest_single_element(): matrix = [[1]] assert kth_smallest(matrix, 1) == 1 def test_kth_smallest_all_elements_same(): matrix = [ [2, 2], [2, 2] ] assert kth_smallest(matrix, 3) == 2 def test_kth_smallest_first_element(): matrix = [ [1, 3, 5], [6, 7, 12], [11, 14, 14] ] assert kth_smallest(matrix, 1) == 1 def test_kth_smallest_large_k(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert kth_smallest(matrix, 16) == 16","solution":"import heapq def kth_smallest(matrix, k): Finds the k-th smallest element in a sorted 2D matrix. :param matrix: List[List[int]], 2D matrix where each row is sorted in non-decreasing order :param k: int, the k-th smallest element to find :return: int, the k-th smallest element in the matrix n = len(matrix) min_heap = [] for r in range(min(k, n)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) count = 0 while min_heap: element, r, c = heapq.heappop(min_heap) count += 1 if count == k: return element if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1))"},{"question":"def largest_power_of_two(x: int) -> int: Returns the largest power of two less than or equal to x. >>> largest_power_of_two(0) 0 >>> largest_power_of_two(1) 1 >>> largest_power_of_two(2) 2 >>> largest_power_of_two(3) 2 >>> largest_power_of_two(4) 4 >>> largest_power_of_two(-1) 0 >>> largest_power_of_two(100) 64","solution":"def largest_power_of_two(x): Returns the largest power of two less than or equal to x. if x < 1: return 0 power = 1 while power * 2 <= x: power *= 2 return power"},{"question":"def max_product_of_consecutive_elements(arr, x): Returns the maximum product of any x consecutive elements in the list arr. If there are fewer than x elements in the list, returns 0. >>> max_product_of_consecutive_elements([], 3) == 0 >>> max_product_of_consecutive_elements([1, 2], 3) == 0 >>> max_product_of_consecutive_elements([1, 2, 3], 3) == 6 >>> max_product_of_consecutive_elements([1, 2, 3, 4], 2) == 12 >>> max_product_of_consecutive_elements([-1, -2, -3, -4], 2) == 12 >>> max_product_of_consecutive_elements([-1, 2, -3, 4, -5], 3) == 60 >>> max_product_of_consecutive_elements([5], 1) == 5 >>> max_product_of_consecutive_elements([1, 2, 3, 4, 5, 6], 3) == 120","solution":"def max_product_of_consecutive_elements(arr, x): Returns the maximum product of any x consecutive elements in the list arr. If there are fewer than x elements in the list, returns 0. if len(arr) < x: return 0 max_product = float('-inf') for i in range(len(arr) - x + 1): product = 1 for j in range(x): product *= arr[i + j] if product > max_product: max_product = product return max_product"},{"question":"from typing import List def min_absolute_difference(nums: List[int]) -> int: Returns the minimum absolute difference between any two elements in the array nums. >>> min_absolute_difference([3, 8, 15, 1]) 2 >>> min_absolute_difference([-7, -13, -5, -1]) 2 >>> min_absolute_difference([1, -1, 5, 10]) 2 >>> min_absolute_difference([2, 2, 2, 2]) 0 >>> min_absolute_difference([11, 12, 13, 14, 15]) 1 >>> min_absolute_difference([100, 101]) 1","solution":"def min_absolute_difference(nums): Returns the minimum absolute difference between any two elements in the array nums. nums.sort() min_diff = float('inf') for i in range(1, len(nums)): min_diff = min(min_diff, abs(nums[i] - nums[i - 1])) return min_diff"},{"question":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_sum(root: Optional[TreeNode]) -> int: Returns the sum of values of the nodes with the minimum depth in a binary tree. The minimum depth is the shortest distance from the root node to any leaf node. >>> root = TreeNode(1) >>> min_depth_sum(root) 1 >>> root = TreeNode(1, TreeNode(2), TreeNode(3, None, TreeNode(4))) >>> min_depth_sum(root) 2","solution":"from collections import deque def min_depth_sum(root): Returns the sum of values of the nodes with the minimum depth in a binary tree. The minimum depth is the shortest distance from the root node to any leaf node. if not root: return 0 queue = deque([(root, 1)]) min_depth = float('inf') min_depth_sum = 0 while queue: node, depth = queue.popleft() if not node.left and not node.right: if depth < min_depth: min_depth = depth min_depth_sum = node.val elif depth == min_depth: min_depth_sum += node.val else: if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return min_depth_sum # Definition for a binary tree node class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right"},{"question":"def remove_adjacent_duplicates(s: str) -> str: Transforms the string by repeatedly removing adjacent duplicate characters. :param s: Input string containing only lowercase letters. :return: Transformed string with no adjacent duplicates. >>> remove_adjacent_duplicates(\\"abbaca\\") \\"ca\\" >>> remove_adjacent_duplicates(\\"aaaa\\") \\"\\" >>> remove_adjacent_duplicates(\\"abcde\\") \\"abcde\\" >>> remove_adjacent_duplicates(\\"aabbccddeeff\\") \\"\\" >>> remove_adjacent_duplicates(\\"abbc\\") \\"ac\\" >>> remove_adjacent_duplicates(\\"\\") \\"\\"","solution":"def remove_adjacent_duplicates(s): Transforms the string by repeatedly removing adjacent duplicate characters. :param s: Input string containing only lowercase letters. :return: Transformed string with no adjacent duplicates. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def findMaximumOverlap(events: List[Tuple[str, int]]) -> int: Given a list of events represented as (type, timestamp), returns the maximum number of overlapping events at any point in time. >>> findMaximumOverlap([(\\"start\\", 1), (\\"end\\", 2)]) 1 >>> findMaximumOverlap([(\\"start\\", 1), (\\"end\\", 2), (\\"start\\", 3), (\\"end\\", 4)]) 1 >>> findMaximumOverlap([(\\"start\\", 1), (\\"start\\", 2), (\\"end\\", 3), (\\"end\\", 4)]) 2 >>> findMaximumOverlap([(\\"start\\", 1), (\\"start\\", 2), (\\"end\\", 4), (\\"start\\", 3), (\\"end\\", 5), (\\"start\\", 5), (\\"end\\", 6)]) 3 >>> findMaximumOverlap([(\\"start\\", 1), (\\"start\\", 1), (\\"start\\", 1), (\\"end\\", 2), (\\"end\\", 2), (\\"end\\", 2)]) 3","solution":"def findMaximumOverlap(events): Given a list of events represented as (type, timestamp), returns the maximum number of overlapping events at any point in time. from collections import defaultdict # Create a dictionary to count the changes in active events at each timestamp event_changes = defaultdict(int) for event_type, timestamp in events: if event_type == \\"start\\": event_changes[timestamp] += 1 elif event_type == \\"end\\": event_changes[timestamp] -= 1 max_overlap = 0 current_overlap = 0 # Sort the timestamps and calculate the overlap for key in sorted(event_changes): current_overlap += event_changes[key] if current_overlap > max_overlap: max_overlap = current_overlap return max_overlap"},{"question":"def min_cuts_to_increasing_sequence(nums: List[int]) -> int: Returns the minimum number of cuts required to ensure that the heights of the remaining trees form a strictly increasing sequence. >>> min_cuts_to_increasing_sequence([1, 2, 3, 4, 5]) == 0 >>> min_cuts_to_increasing_sequence([10, 20, 30]) == 0 >>> min_cuts_to_increasing_sequence([1, 1, 1, 1]) == 3 >>> min_cuts_to_increasing_sequence([5, 5, 5, 5, 5]) == 4 >>> min_cuts_to_increasing_sequence([4, 3, 2, 5, 6]) == 2 >>> min_cuts_to_increasing_sequence([3, 1, 2, 1, 5]) == 2 >>> min_cuts_to_increasing_sequence([1, 2, 3, 4]) == 0 >>> min_cuts_to_increasing_sequence([10, 15, 20]) == 0 >>> min_cuts_to_increasing_sequence([1, 3, 2, 4, 5]) == 1 >>> min_cuts_to_increasing_sequence([10, 1, 2, 3, 5]) == 1 >>> min_cuts_to_increasing_sequence([5]) == 0 >>> min_cuts_to_increasing_sequence([]) == 0","solution":"def min_cuts_to_increasing_sequence(nums): Returns the minimum number of cuts required to ensure that the heights of the remaining trees form a strictly increasing sequence. n = len(nums) # Edge case for empty list or single element list. if n <= 1: return 0 # dp[i] will store the length of the longest increasing subsequence ending at index i. dp = [1] * n # Fill the dp array for i in range(n): for j in range(i): if nums[j] < nums[i]: dp[i] = max(dp[i], dp[j] + 1) # Find the length of the longest increasing subsequence. lis_length = max(dp) # The minimum number of cuts required is # total number of elements - length of the longest increasing subsequence. return n - lis_length"},{"question":"def minimizeMaxGroupTime(times: List[int], k: int) -> int: Given a list of \`n\` integers, each integer represents the time taken by a team member to complete their task. Partition the team members into \`k\` non-empty groups such that the maximum time taken by any group is minimized. The time taken by a group is the sum of the individual times of the members in that group. Args: times (List[int]): list of integers representing the time taken by each team member. k (int): the number of groups to be formed. Returns: int: the minimized maximum time taken by any group after partitioning the team members. >>> minimizeMaxGroupTime([1, 2, 3, 4, 5], 2) 9 >>> minimizeMaxGroupTime([1, 2, 3, 4, 5], 3) 6 >>> minimizeMaxGroupTime([7, 2, 5, 10, 8], 2) 18 >>> minimizeMaxGroupTime([7, 2, 5, 10, 8], 3) 14 >>> minimizeMaxGroupTime([10, 20, 30, 40, 50], 2) 90","solution":"def minimizeMaxGroupTime(times, k): def is_valid_partition(max_time): # Try to partition the array under the assumption that no group's time exceeds max_time current_sum = 0 groups_count = 1 for time in times: if current_sum + time > max_time: groups_count += 1 current_sum = time if groups_count > k: return False else: current_sum += time return True left, right = max(times), sum(times) while left < right: mid = left + (right - left) // 2 if is_valid_partition(mid): right = mid else: left = mid + 1 return left"},{"question":"def max_area_rectangle(heights, widths): This function calculates the area of rectangles and finds the index of the rectangle that has the maximum area. Parameters: heights (list of int): A list of heights of the rectangles. widths (list of int): A list of widths of the rectangles. Returns: int: The index of the rectangle with the maximum area. int: The maximum area formed by the rectangles. pass if __name__ == \\"__main__\\": from solution import max_area_rectangle def test_max_area_rectangle_basic(): heights = [1, 2, 3] widths = [4, 5, 6] assert max_area_rectangle(heights, widths) == (2, 18) def test_max_area_rectangle_equal_areas(): heights = [2, 3, 4] widths = [6, 4, 3] assert max_area_rectangle(heights, widths) == (0, 12) def test_max_area_rectangle_single_element(): heights = [5] widths = [10] assert max_area_rectangle(heights, widths) == (0, 50) def test_max_area_rectangle_zero_area(): heights = [0, 2, 3] widths = [1, 0, 1] assert max_area_rectangle(heights, widths) == (2, 3) def test_max_area_rectangle_large_inputs(): heights = [100, 200, 300] widths = [400, 500, 600] assert max_area_rectangle(heights, widths) == (2, 180000) test_max_area_rectangle_basic() test_max_area_rectangle_equal_areas() test_max_area_rectangle_single_element() test_max_area_rectangle_zero_area() test_max_area_rectangle_large_inputs()","solution":"def max_area_rectangle(heights, widths): This function calculates the area of rectangles and finds the index of the rectangle that has the maximum area. Parameters: heights (list of int): A list of heights of the rectangles. widths (list of int): A list of widths of the rectangles. Returns: int: The index of the rectangle with the maximum area. int: The maximum area formed by the rectangles. max_area = 0 max_index = 0 n = len(heights) for i in range(n): area = heights[i] * widths[i] if area > max_area: max_area = area max_index = i return max_index, max_area"},{"question":"from typing import List def count_subarrays_with_sum(arr: List[int], target: int) -> int: Given an integer array \`arr\` and an integer \`target\`, return the total count of subarrays whose sum is equal to \`target\`. A subarray is defined as a contiguous non-empty sequence of elements within an array. >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, 3], 3) 2 pass def test_example_cases(): assert count_subarrays_with_sum([1, 1, 1], 2) == 2 assert count_subarrays_with_sum([1, 2, 3], 3) == 2 def test_single_element_equal_to_target(): assert count_subarrays_with_sum([5], 5) == 1 assert count_subarrays_with_sum([5], 1) == 0 def test_all_elements_equal_to_target(): assert count_subarrays_with_sum([1, 1, 1], 1) == 3 def test_no_subarray_sums_to_target(): assert count_subarrays_with_sum([1, 2, 3], 7) == 0 def test_negative_numbers(): assert count_subarrays_with_sum([-1, -1, 1], 0) == 1 assert count_subarrays_with_sum([1, -1, 1, -1], 0) == 4 def test_large_array(): arr = [1] * 1000 assert count_subarrays_with_sum(arr, 10) == 991 def test_target_zero(): assert count_subarrays_with_sum([0, 0, 0, 0], 0) == 10","solution":"from typing import List def count_subarrays_with_sum(arr: List[int], target: int) -> int: from collections import defaultdict sum_count = defaultdict(int) sum_count[0] = 1 current_sum = 0 count = 0 for num in arr: current_sum += num count += sum_count.get(current_sum - target, 0) sum_count[current_sum] += 1 return count"},{"question":"import random class RandomizedSet: Design a class named \`RandomizedSet\` that holds unique integers and allows insertion, deletion, and random element retrieval all in average constant time. Methods: - \`RandomizedSet()\`: Initializes the \`RandomizedSet\` object. - \`bool insert(int val)\`: Inserts an item \`val\` into the set if not already present. Returns \`true\` if the item was not present, \`false\` otherwise. - \`bool remove(int val)\`: Removes an item \`val\` from the set if present. Returns \`true\` if the item was present, \`false\` otherwise. - \`int getRandom()\`: Returns a random element from the current set of elements. Example usage: >>> random_set = RandomizedSet() >>> random_set.insert(1) True >>> random_set.insert(1) False >>> random_set.insert(2) True >>> random_set.remove(2) True >>> random_set.getRandom() 1 def __init__(self): pass def insert(self, val): pass def remove(self, val): pass def getRandom(self): pass # Unit Test def test_randomized_set_operations(): random_set = RandomizedSet() # Test insert operation assert random_set.insert(1) == True assert random_set.insert(1) == False # Already inserted, should return False assert random_set.insert(2) == True # Test remove operation assert random_set.remove(2) == True assert random_set.remove(2) == False # Already removed, should return False assert random_set.remove(3) == False # Non-existent element # Test getRandom operation - since element '1' is the only element left, it should always return '1' assert random_set.getRandom() == 1 # Test insert operation after removing elements assert random_set.insert(2) == True values_set = {random_set.getRandom() for _ in range(100)} assert values_set == {1, 2} # both elements '1' and '2' should be present","solution":"import random class RandomizedSet: def __init__(self): self.data = {} self.list = [] def insert(self, val): if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def remove(self, val): if val not in self.data: return False last_element = self.list[-1] index = self.data[val] self.list[index] = last_element self.data[last_element] = index self.list.pop() del self.data[val] return True def getRandom(self): return random.choice(self.list)"},{"question":"def min_partitions(nums: List[int], k: int) -> int: Returns the minimum number of subsets in which the array 'nums' can be partitioned such that each partition is valid with the given condition. :param nums: List[int], the list of integers to be partitioned :param k: int, the maximum allowed difference between max and min values in any subset :return: int, the minimum number of subsets >>> min_partitions([3, 6, 1, 2, 5], 2) 2 >>> min_partitions([1, 3, 5, 6], 2) 2 >>> min_partitions([10], 5) 1 >>> min_partitions([4, 5, 6, 7, 8], 4) 1 >>> min_partitions([1, 7, 15, 20, 25], 4) 5 >>> min_partitions([1, 2, 3, 10, 11, 12, 20, 21, 22], 1) 6","solution":"def min_partitions(nums, k): Returns the minimum number of subsets in which the array 'nums' can be partitioned such that each partition is valid with the given condition. :param nums: List[int], the list of integers to be partitioned :param k: int, the maximum allowed difference between max and min values in any subset :return: int, the minimum number of subsets nums.sort() subsets = 0 i = 0 while i < len(nums): subsets += 1 start = nums[i] while i < len(nums) and nums[i] - start <= k: i += 1 return subsets"},{"question":"def longest_valid_substring(s: str, k: int) -> int: Returns the length of the longest substring containing at most k distinct characters. >>> longest_valid_substring(\\"eceba\\", 2) 3 >>> longest_valid_substring(\\"aa\\", 1) 2 >>> longest_valid_substring(\\"abc\\", 0) 0 >>> longest_valid_substring(\\"\\", 2) 0 >>> longest_valid_substring(\\"aabbcc\\", 4) 6 >>> longest_valid_substring(\\"aabbcc\\", 6) 6 >>> longest_valid_substring(\\"a\\", 1) 1 >>> longest_valid_substring(\\"a\\", 2) 1 >>> longest_valid_substring(\\"abcabcabcabc\\", 2) 2 >>> longest_valid_substring(\\"abcabcabcabc\\", 3) 12 >>> longest_valid_substring(\\"a\\"*1000, 1) 1000 >>> longest_valid_substring(\\"a\\"*999 + \\"b\\", 2) 1000","solution":"def longest_valid_substring(s, k): Returns the length of the longest substring containing at most k distinct characters. n = len(s) if k == 0 or n == 0: return 0 left = 0 right = 0 max_length = 0 char_map = {} while right < n: current_char = s[right] if current_char in char_map: char_map[current_char] += 1 else: char_map[current_char] = 1 while len(char_map) > k: left_char = s[left] char_map[left_char] -= 1 if char_map[left_char] == 0: del char_map[left_char] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"from typing import List def maxRectangleArea(heights: List[int]) -> int: Returns the maximum rectangle area that can be formed between consecutive buildings. >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([2, 4]) 4 >>> maxRectangleArea([1, 2, 3, 4, 5]) 9 >>> maxRectangleArea([5, 4, 3, 2, 1]) 9 >>> maxRectangleArea([2, 1, 2]) 3 >>> maxRectangleArea([6, 2, 5, 4, 5, 1, 6]) 12 >>> maxRectangleArea([]) 0 >>> maxRectangleArea([2]) 2 >>> maxRectangleArea([3, 3, 3]) 9","solution":"def maxRectangleArea(heights): Returns the maximum rectangle area that can be formed between consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_subarray_with_max_bitwise_and(arr: List[int]) -> int: Given an integer array \`arr\`, return the length of the longest subarray with the maximum bitwise AND. >>> longest_subarray_with_max_bitwise_and([5]) == 1 >>> longest_subarray_with_max_bitwise_and([1, 1, 1, 1]) == 4 >>> longest_subarray_with_max_bitwise_and([1, 2, 3, 2, 1]) == 1 >>> longest_subarray_with_max_bitwise_and([2, 2, 1, 2, 2, 2]) == 3 >>> longest_subarray_with_max_bitwise_and([5, 1, 7, 5, 7, 7]) == 2 >>> longest_subarray_with_max_bitwise_and([]) == 0 >>> longest_subarray_with_max_bitwise_and([4, 4, 4, 2, 3, 4, 4, 4, 4]) == 4 >>> longest_subarray_with_max_bitwise_and([8, 1, 8, 8, 2, 8, 8, 8, 3, 8]) == 3","solution":"def longest_subarray_with_max_bitwise_and(arr): Returns the length of the longest subarray with the maximum bitwise AND. if not arr: return 0 # Find the overall maximum value in the array max_value = max(arr) # Initialize variables for the longest subarray length and current subarray length longest_length = current_length = 0 for num in arr: if num == max_value: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 0 return longest_length"},{"question":"def maxValue(events: List[List[int]]) -> int: You are given an array events where events[i] = [startDayi, endDayi, valuei] represents an event that starts at startDayi and ends at endDayi with a value of valuei. You can attend an event i at any day d where startDayi <= d <= endDayi. Note that you can only attend one event at a time. Return the maximum total value you can obtain by attending events. >>> maxValue([[1, 2, 4]]) == 4 >>> maxValue([[1, 2, 4], [3, 4, 3], [5, 6, 2]]) == 9 >>> maxValue([[1, 3, 4], [2, 4, 3], [3, 5, 2]]) == 4 >>> maxValue([[1, 2, 4], [2, 3, 7], [3, 4, 2], [1, 3, 5]]) == 7 >>> maxValue([[1, 3, 4], [1, 3, 2], [1, 3, 7], [1, 3, 5]]) == 7","solution":"def maxValue(events): events.sort(key=lambda x:(x[1], x[0])) dp = [0] * (len(events) + 1) def binary_search(events, end_day): lo, hi = 0, len(events) - 1 while lo <= hi: mid = (lo + hi) // 2 if events[mid][1] <= end_day: lo = mid + 1 else: hi = mid - 1 return lo for i in range(1, len(events) + 1): j = binary_search(events, events[i-1][0] - 1) dp[i] = max(dp[i-1], dp[j] + events[i-1][2]) return dp[-1]"},{"question":"class SearchRange: def __init__(self, nums): Initializes the object with a sorted array of integers. self.nums = nums def searchRange(self, target): Returns an array with two elements, where the first element is the starting position and the second element is the ending position of the \`target\` value. If the target is not found, return \`[-1, -1]\`. >>> sr = SearchRange([5, 7, 7, 8, 8, 10]) >>> sr.searchRange(8) [3, 4] >>> sr.searchRange(6) [-1, -1] >>> sr = SearchRange([]) >>> sr.searchRange(0) [-1, -1]","solution":"class SearchRange: def __init__(self, nums): self.nums = nums def searchRange(self, target): start = self.binarySearch(target, True) end = self.binarySearch(target, False) if start != -1 else -1 return [start, end] def binarySearch(self, target, findFirst): start, end = 0, len(self.nums) - 1 index = -1 while start <= end: mid = (start + end) // 2 if self.nums[mid] == target: index = mid if findFirst: end = mid - 1 else: start = mid + 1 elif self.nums[mid] < target: start = mid + 1 else: end = mid - 1 return index"},{"question":"def shortestPathAllKeys(grid: List[List[str]]) -> int: Given a board representing an m x n grid, where each cell is either a wall ('#'), an empty slot ('.'), a key ('a'-'f'), or a lock ('A'-'F'), find the shortest path to collect all keys. A path is defined as the sequence of adjacent cells that must be traversed from the start to the end. You can move up, down, left, or right on the grid. You start at a given starting point denoted by '@'. The goal is to find the shortest path to collect all keys. The number of keys is between 1 and 6, and each key has a corresponding lock. Parameters: grid (List[List[str]]): The grid representing the board. Returns: int: The length of the shortest path to collect all keys. If it is impossible to collect all the keys, return -1. >>> shortestPathAllKeys([\\"@.a..\\", \\"#.#\\", \\"b.A.B\\"]) 8 >>> shortestPathAllKeys([\\"@..aA\\", \\"..B#.\\", \\"....b\\"]) 6 >>> shortestPathAllKeys([\\"@.a..\\", \\"#.#\\", \\"b.B.A\\"]) -1 >>> shortestPathAllKeys([\\"@a\\"]) 1 >>> shortestPathAllKeys([\\"@.a.#\\", \\"#.#\\", \\"b.A.B\\", \\".C.c.\\"]) 10","solution":"from collections import deque def shortestPathAllKeys(grid): m, n = len(grid), len(grid[0]) start = None total_keys = 0 # Find the start position and number of keys for i in range(m): for j in range(n): if grid[i][j] == '@': start = (i, j) elif 'a' <= grid[i][j] <= 'f': total_keys += 1 # Direction vectors for moving up, down, left, right directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Queue will store tuples of (x, y, current_keys_bitmask) queue = deque([(start[0], start[1], 0)]) visited = set((start[0], start[1], 0)) steps = 0 all_keys_bitmask = (1 << total_keys) - 1 while queue: for _ in range(len(queue)): x, y, keys = queue.popleft() # If we've collected all keys, return the number of steps if keys == all_keys_bitmask: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n: cell = grid[nx][ny] if cell == '#': continue if 'A' <= cell <= 'F' and not (keys & (1 << (ord(cell) - ord('A')))): continue new_keys = keys if 'a' <= cell <= 'f': new_keys |= (1 << (ord(cell) - ord('a'))) if (nx, ny, new_keys) not in visited: visited.add((nx, ny, new_keys)) queue.append((nx, ny, new_keys)) steps += 1 return -1"},{"question":"from collections import deque from typing import List class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root: TreeNode) -> List[List[int]]: Perform level order traversal of a binary tree and return values in level order. Args: root (TreeNode): Root node of the binary tree. Returns: List[List[int]]: List of lists containing node values at each level. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> level_order_traversal(root) [[1], [2, 3]] >>> root = TreeNode(1) >>> level_order_traversal(root) [[1]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def level_order_traversal(root): Perform level order traversal of a binary tree and return values in level order. Args: root (TreeNode): Root node of the binary tree. Returns: List[List[int]]: List of lists containing node values at each level. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.value) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def maxSumSubmatrix(matrix, k): Find the maximum sum of a rectangle in the matrix such that the sum is no larger than a given integer k. >>> maxSumSubmatrix([ ... [1, 0, 1], ... [0, -2, 3] ... ], 2) 2 >>> maxSumSubmatrix([ ... [2, 2, -1] ... ], 3) 3 >>> maxSumSubmatrix([ ... [2, 2, -1] ... ], 0) -1 >>> maxSumSubmatrix([ ... [5] ... ], 5) 5 >>> maxSumSubmatrix([ ... [2, 1, -3, -4, 5], ... [0, 6, 3, 4, 1], ... [2, -2, -1, 4, 7], ... [8, 0, -3, -2, 1], ... [3, -2, 1, 4, -5] ... ], 10) 10","solution":"import bisect def maxSumSubmatrix(matrix, k): Find the maximum sum of a rectangle within the matrix such that the sum is no larger than k. def maxSumSubarray(arr, k): max_sum = float('-inf') curr_sum = 0 sum_set = [0] for num in arr: curr_sum += num i = bisect.bisect_left(sum_set, curr_sum - k) if i < len(sum_set): max_sum = max(max_sum, curr_sum - sum_set[i]) bisect.insort(sum_set, curr_sum) return max_sum if not matrix or not matrix[0]: return 0 rows, cols = len(matrix), len(matrix[0]) max_sum = float('-inf') for left in range(cols): row_sum = [0] * rows for right in range(left, cols): for r in range(rows): row_sum[r] += matrix[r][right] max_sum = max(max_sum, maxSumSubarray(row_sum, k)) return max_sum"},{"question":"def process_backspaces(s: str) -> str: Processes a string \`s\` with backspaces indicated by '#' the backspace character removes the preceding character. Args: s (str): Input string consisting of lowercase letters and '#'. Returns: str: Processed string after applying backspaces. Examples: >>> process_backspaces(\\"abc#d\\") \\"abd\\" >>> process_backspaces(\\"abc\\") \\"c\\" from solution import process_backspaces def test_single_backspace(): assert process_backspaces(\\"abc#d\\") == \\"abd\\" def test_double_backspace(): assert process_backspaces(\\"abc\\") == \\"c\\" def test_multiple_backspaces(): assert process_backspaces(\\"abc#d\\") == \\"d\\" assert process_backspaces(\\"a#b#c\\") == \\"c\\" def test_no_backspaces(): assert process_backspaces(\\"abcd\\") == \\"abcd\\" def test_all_backspaces(): assert process_backspaces(\\"\\") == \\"\\" def test_complex_cases(): assert process_backspaces(\\"a#b#c#d\\") == \\"d\\" assert process_backspaces(\\"#a#b#c#\\") == \\"\\" assert process_backspaces(\\"ab\\") == \\"\\" assert process_backspaces(\\"abcde#fg#\\") == \\"f\\"","solution":"def process_backspaces(s): Processes a string \`s\` with backspaces indicated by '#' the backspace character removes the preceding character. :param s: str: Input string consisting of lowercase letters and '#'. :return: str: Processed string after applying backspaces. result = [] for char in s: if char == '#': if result: result.pop() else: result.append(char) return ''.join(result)"},{"question":"def filter_duplicates(arr): Given an integer array 'arr', returns a new array only containing those elements that appear more than once. The returned array should be sorted in the same order in which elements first appear in 'arr'. If no element in 'arr' appears more than once, return an empty array. Examples: >>> filter_duplicates([1, 2, 3, 4, 5]) [] >>> filter_duplicates([2, 2, 2, 2, 2]) [2] >>> filter_duplicates([1, 2, 2, 3, 3, 4, 5, 1, 6, 6]) [1, 2, 3, 6] >>> filter_duplicates([10, 20, 20, 30, 40, 10, 50, 60, 40, 10]) [10, 20, 40] >>> filter_duplicates([]) [] >>> filter_duplicates([1]) []","solution":"def filter_duplicates(arr): Returns a list of elements that appear more than once in 'arr', sorted in the order in which they first appear in 'arr'. from collections import Counter # Count the occurrences of each element counts = Counter(arr) # Filter elements that appear more than once and preserve order result = [item for item in arr if counts[item] > 1] # To ensure only one instance of such elements (preserve the appearance order) seen = set() duplicates = [] for item in result: if item not in seen: duplicates.append(item) seen.add(item) return duplicates"},{"question":"from typing import List def count_good_subarrays(nums: List[int], k: int) -> int: Returns the total number of good subarrays in nums such that the sum of its elements is divisible by k. Args: nums (list of int): List of integers. k (int): An integer divisor. Returns: int: Number of good subarrays. >>> count_good_subarrays([1, 2, 3, 4, 5], 5) 4 >>> count_good_subarrays([0, 0, 0, 0, 0], 3) 15 >>> count_good_subarrays([-1, 2, 9, -6, 1], 5) 4 >>> count_good_subarrays([3, 1, 4, 1, 5, 9], 5) 6 >>> count_good_subarrays([1, 2, 3, 4, 5], 100) 0","solution":"def count_good_subarrays(nums, k): Returns the total number of good subarrays in nums such that the sum of its elements is divisible by k. Args: nums (list of int): List of integers. k (int): An integer divisor. Returns: int: Number of good subarrays. from collections import defaultdict remainder_count = defaultdict(int) remainder_count[0] = 1 # to handle subarrays which directly sum to a multiple of k current_sum = 0 good_subarray_count = 0 for num in nums: current_sum += num remainder = current_sum % k if remainder < 0: remainder += k good_subarray_count += remainder_count[remainder] remainder_count[remainder] += 1 return good_subarray_count"},{"question":"from typing import List def maxGroups(cards: List[int]) -> int: Returns the maximum number of groups that can be formed from the cards array where each group consists of two or more consecutive cards with the same value. If it's not possible to use all cards in groups, returns -1. >>> maxGroups([1, 1, 2, 2, 2, 2]) 3 >>> maxGroups([1, 1, 2, 2, 3]) -1 >>> maxGroups([4, 4, 4, 4]) 2 >>> maxGroups([6, 7, 8, 9]) -1 >>> maxGroups([10] * 10000) 5000","solution":"def maxGroups(cards): Returns the maximum number of groups that can be formed from the cards array where each group consists of two or more consecutive cards with the same value. If it's not possible to use all cards in groups, returns -1. :param cards: List[int] - a 0-indexed integer array representing the value of each card :return: int - the maximum number of groups, or -1 if not all cards can be grouped from collections import Counter count = Counter(cards) # For each card value, we need at least two cards to form a group for value in count.values(): if value < 2: return -1 # The number of groups will depend on the most frequently occurring card value return sum(value // 2 for value in count.values())"},{"question":"from typing import List def first_missing_positive(nums: List[int]) -> int: Given a list of non-negative integers nums, return the smallest positive integer that is not present in nums. You must solve this in linear time and using constant extra space. >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([]) 1 >>> first_missing_positive([0]) 1 >>> first_missing_positive([1]) 2 >>> first_missing_positive([2]) 1 >>> first_missing_positive([1, 1]) 2 >>> first_missing_positive([1, 2, 3]) 4 >>> first_missing_positive([2, 3, 4]) 1 >>> first_missing_positive(list(range(1, 100000))) 100000","solution":"def first_missing_positive(nums): Returns the smallest positive integer that is not present in nums. Uses a linear time algorithm with constant extra space. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root: TreeNode) -> int: Given a binary tree where each node has a value 0 or 1, return the sum of the values of all nodes lying on the paths from the root to the leaves where the path represents a binary number when read from top to bottom. Args: root (TreeNode): The root node of the binary tree. Returns: int: The sum of the binary numbers represented by the paths from the root to the leaves. Examples: >>> root = TreeNode(1) >>> sumRootToLeaf(root) == 1 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(0) >>> root.left.right = TreeNode(1) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(1) >>> sumRootToLeaf(root) 22 >>> root = TreeNode(1) >>> root.left = TreeNode(0) >>> root.left.left = TreeNode(0) >>> sumRootToLeaf(root) 4 >>> root = TreeNode(1) >>> root.right = TreeNode(1) >>> root.right.right = TreeNode(1) >>> sumRootToLeaf(root) 7 >>> root = TreeNode(1) >>> root.left = TreeNode(1) >>> root.right = TreeNode(0) >>> root.right.left = TreeNode(1) >>> sumRootToLeaf(root) 8 pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumRootToLeaf(root): Returns the sum of the binary numbers represented by the paths from the root to the leaves. def dfs(node, current_number): if not node: return 0 current_number = current_number * 2 + node.val # If it's a leaf node, return the current_number. if not node.left and not node.right: return current_number # Continue DFS on left and right children. return dfs(node.left, current_number) + dfs(node.right, current_number) return dfs(root, 0)"},{"question":"def min_max_sum_diff(arr, k): Returns the minimized difference between the maximum and minimum sums of k contiguous subarrays from the given array. >>> min_max_sum_diff([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) == 17 >>> min_max_sum_diff([10], 1) == 10 >>> min_max_sum_diff([7, 7, 7, 7], 2) == 14 >>> min_max_sum_diff([1, 2, 3, 4, 5], 2) == 9 >>> min_max_sum_diff([2, 1, 1, 2, 1, 8, 2], 2) == 10","solution":"def min_max_sum_diff(arr, k): Returns the minimized difference between the maximum and minimum sums of k contiguous subarrays from the given array. def canPartition(mid): current_sum, count = 0, 1 for num in arr: if current_sum + num > mid: count += 1 current_sum = num if count > k: return False else: current_sum += num return True low, high = max(arr), sum(arr) while low < high: mid = (low + high) // 2 if canPartition(mid): high = mid else: low = mid + 1 return low"},{"question":"def find_and_replace_pattern(words: List[str], pattern: str) -> List[str]: Finds and returns the list of words that match the given pattern. A word matches the pattern if it can be transformed into the pattern by replacing each letter with a common letter. :param words: List[str], list of words to check :param pattern: Str, the pattern to match :return: List[str], list of words that match the pattern >>> find_and_replace_pattern([\\"abc\\", \\"deq\\", \\"mee\\", \\"aqq\\", \\"dkd\\", \\"ccc\\"], \\"abb\\") [\\"mee\\", \\"aqq\\"] >>> find_and_replace_pattern([\\"a\\", \\"b\\", \\"c\\"], \\"a\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_and_replace_pattern([\\"abc\\", \\"def\\", \\"ghi\\"], \\"zzz\\") [] >>> find_and_replace_pattern([\\"aaa\\", \\"bbb\\", \\"ccc\\", \\"abc\\", \\"xyz\\"], \\"aaa\\") [\\"aaa\\", \\"bbb\\", \\"ccc\\"] >>> find_and_replace_pattern([\\"abcd\\", \\"efgh\\"], \\"abc\\") []","solution":"def find_and_replace_pattern(words, pattern): Finds and returns the list of words that match the given pattern. A word matches the pattern if it can be transformed into the pattern by replacing each letter with a common letter. :param words: List[str], list of words to check :param pattern: Str, the pattern to match :return: List[str], list of words that match the pattern def matches(word, pattern): if len(word) != len(pattern): return False char_map = {} used_chars = set() for w_char, p_char in zip(word, pattern): if p_char in char_map: if char_map[p_char] != w_char: return False else: if w_char in used_chars: return False char_map[p_char] = w_char used_chars.add(w_char) return True return [word for word in words if matches(word, pattern)]"},{"question":"def find_timestamp_pairs(timestamps: List[str], d: int) -> List[Tuple[int, int]]: You are given a list of \`n\` video timestamps in the format \`hours:minutes:seconds\`, and a target duration \`d\` in seconds. Write a function to find pairs of timestamps where the absolute difference in their durations is less than or equal to \`d\` seconds. Return a list of tuples, where each tuple contains the indices of the two timestamps forming such a pair. Indices in the output list should be in ascending order, and the pairs themselves should be sorted lexicographically by the first index then the second index. >>> find_timestamp_pairs([\\"00:00:05\\", \\"00:00:10\\", \\"00:00:15\\"], 5) [(0, 1), (1, 2)] >>> find_timestamp_pairs([\\"01:00:00\\", \\"02:00:00\\", \\"03:00:00\\"], 3600) [(0, 1), (1, 2)] >>> find_timestamp_pairs([\\"00:00:10\\", \\"00:00:20\\", \\"00:00:30\\"], 0) [] >>> find_timestamp_pairs([\\"00:05:00\\", \\"00:04:50\\", \\"00:10:00\\"], 10) [(0, 1)] >>> find_timestamp_pairs([\\"00:00:30\\", \\"00:15:00\\", \\"00:30:00\\"], 20) []","solution":"def timestamp_to_seconds(timestamp): hours, minutes, seconds = map(int, timestamp.split(':')) return hours * 3600 + minutes * 60 + seconds def find_timestamp_pairs(timestamps, d): Returns a list of tuples where each tuple contains the indices of two timestamps with durations that differ by less than or equal to \`d\` seconds. n = len(timestamps) seconds_list = [timestamp_to_seconds(t) for t in timestamps] result = [] for i in range(n): for j in range(i + 1, n): if abs(seconds_list[i] - seconds_list[j]) <= d: result.append((i, j)) return sorted(result)"},{"question":"def reverse_words(s: str) -> str: Reverses each word in the string while maintaining word order and spaces. Test cases: >>> reverse_words(\\"hello\\") == \\"olleh\\" >>> reverse_words(\\"hello world\\") == \\"olleh dlrow\\" >>> reverse_words(\\"hello world\\") == \\"olleh dlrow\\" >>> reverse_words(\\" hello world \\") == \\" olleh dlrow \\" >>> reverse_words(\\"\\") == \\"\\" >>> reverse_words(\\" \\") == \\" \\" >>> reverse_words(\\"a b c d\\") == \\"a b c d\\" >>> reverse_words(\\"abc def ghi\\") == \\"cba fed ihg\\"","solution":"def reverse_words(s): Reverses each word in the string while maintaining word order and spaces. words = s.split(' ') reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def longest_substring(s: str, k: int) -> int: Determine the length of the longest substring containing only 'a' or only 'b' that can be obtained by performing up to k operations. In each operation, you can flip 'a' to 'b' or 'b' to 'a'. >>> longest_substring(\\"aaaa\\", 1) 4 >>> longest_substring(\\"bbbb\\", 1) 4 >>> longest_substring(\\"ababab\\", 1) 3 >>> longest_substring(\\"aababba\\", 1) 4 >>> longest_substring(\\"abab\\", 0) 1 >>> longest_substring(\\"aaaaabbbb\\", 0) 5 >>> longest_substring(\\"aaabbaaa\\", 2) 8 >>> longest_substring(\\"\\", 2) 0","solution":"def longest_substring(s, k): def max_length_with_char(s, k, char): max_len = 0 left = 0 count = 0 for right in range(len(s)): if s[right] != char: count += 1 while count > k: if s[left] != char: count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len return max(max_length_with_char(s, k, 'a'), max_length_with_char(s, k, 'b'))"},{"question":"def findBuildingsWithOceanView(heights): Returns the indices of buildings that have an ocean view in increasing order. Args: heights (list): A list of integers representing building heights. Returns: list: A list of indices of buildings with an ocean view. >>> findBuildingsWithOceanView([4, 2, 3, 1]) [0, 2, 3] >>> findBuildingsWithOceanView([1, 3, 2, 4]) [3] >>> findBuildingsWithOceanView([4, 3, 2, 1]) [0, 1, 2, 3] >>> findBuildingsWithOceanView([1, 2, 3, 4]) [3] >>> findBuildingsWithOceanView([]) [] >>> findBuildingsWithOceanView([10]) [0] >>> findBuildingsWithOceanView([2, 2, 2, 2]) [3]","solution":"def findBuildingsWithOceanView(heights): Returns the indices of buildings that have an ocean view in increasing order. Args: heights (list): A list of integers representing building heights. Returns: list: A list of indices of buildings with an ocean view. n = len(heights) if n == 0: return [] result = [] max_height = float('-inf') for i in range(n - 1, -1, -1): if heights[i] > max_height: result.append(i) max_height = heights[i] return result[::-1]"},{"question":"def find_three_sum(arr: List[int], x: int) -> bool: Determines if there are any three distinct indices i, j, and k in the array such that the sum of the elements at these indices is equal to x. >>> find_three_sum([1, 2, 3, 4, 5], 50) False >>> find_three_sum([1, 2, 3, 4, 5], 12) True >>> find_three_sum([-1, -2, -3, -4, -5], -6) True >>> find_three_sum([-1, 0, 1, 2], 2) True >>> find_three_sum([], 0) False >>> find_three_sum([1, 2], 3) False >>> find_three_sum([3, 3, 3, 3], 9) True","solution":"def find_three_sum(arr, x): Determines if there are any three distinct indices i, j, and k in the array such that the sum of the elements at these indices is equal to x. n = len(arr) # Iterate through each element for i in range(n): # Use a set to track the seen values seen = set() # Iterate through the remaining elements starting from the next element of i for j in range(i + 1, n): required = x - arr[i] - arr[j] # Check if the required value exists in the seen set if required in seen: return True seen.add(arr[j]) return False"},{"question":"import heapq class MedianFinder: A data structure that supports adding new numbers and finding the median of all numbers added so far. Methods: addNum(num: int) -> None Adds an integer num to the data structure. findMedian() -> float Returns the median of all elements so far. def __init__(self): Initialize the MedianFinder object. def addNum(self, num: int) -> None: Adds the integer num to the data structure. def findMedian(self) -> float: Returns the median of all elements so far. # Test cases def test_medianfinder(): mf = MedianFinder() mf.addNum(1) assert mf.findMedian() == 1 mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2 def test_even_count_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) mf.addNum(4) assert mf.findMedian() == 2.5 def test_odd_count_elements(): mf = MedianFinder() mf.addNum(1) mf.addNum(2) mf.addNum(3) assert mf.findMedian() == 2 def test_negative_numbers(): mf = MedianFinder() mf.addNum(-1) mf.addNum(-2) mf.addNum(-3) assert mf.findMedian() == -2 def test_mixed_numbers(): mf = MedianFinder() mf.addNum(-1) mf.addNum(2) mf.addNum(-3) mf.addNum(3) assert mf.findMedian() == 0.5","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder object. self.max_heap = [] # For the left half self.min_heap = [] # For the right half def addNum(self, num: int): Adds the integer num to the data structure. # Add to max_heap heapq.heappush(self.max_heap, -1 * num) # Balance the heaps if self.max_heap and self.min_heap and (-1 * self.max_heap[0]) > self.min_heap[0]: value = -1 * heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) if len(self.max_heap) > len(self.min_heap) + 1: value = -1 * heapq.heappop(self.max_heap) heapq.heappush(self.min_heap, value) if len(self.min_heap) > len(self.max_heap): value = heapq.heappop(self.min_heap) heapq.heappush(self.max_heap, -1 * value) def findMedian(self) -> float: Returns the median of all elements so far. if len(self.max_heap) > len(self.min_heap): return -1 * self.max_heap[0] return (-1 * self.max_heap[0] + self.min_heap[0]) / 2"},{"question":"def min_members_to_complete_projects(members, projects): Assign projects to members respecting their project capacities and return the minimum number of members required. >>> min_members_to_complete_projects([1], [1]) 1 >>> min_members_to_complete_projects([3, 1, 2], [2, 1]) 2 >>> min_members_to_complete_projects([4, 2], [1, 1]) 2 >>> min_members_to_complete_projects([7, 4, 2], [4, 2, 1]) 3 >>> min_members_to_complete_projects([1], [2]) -1 >>> min_members_to_complete_projects([3, 5, 2, 1], [2, 1, 3]) 3","solution":"def min_members_to_complete_projects(members, projects): # Sort the members capacities and project requirements members.sort() projects.sort() member_count = 0 i = 0 j = 0 while i < len(members) and j < len(projects): if members[i] >= projects[j]: j += 1 # This member takes the current project member_count += 1 i += 1 # If there are still projects left and no members, we can't fulfill the requirement. if j < len(projects): return -1 return member_count"},{"question":"def find_triplet_with_sum(nums, target): Finds a triplet in the array that sums up to the given target. :param nums: List of integers :param target: Target sum :return: List containing the triplet, or an empty list if no such triplet exists >>> find_triplet_with_sum([1, 2, 3, 4, 5], 9) [1, 3, 5] >>> find_triplet_with_sum([1, 2, 3], 10) [] >>> find_triplet_with_sum([-1, 0, 1, 2, -2, 4], 3) [-1, 0, 4] >>> find_triplet_with_sum([-1, 0, 1, 2], 0) [-1, 0, 1] >>> find_triplet_with_sum([], 5) [] >>> find_triplet_with_sum([1, -1, -1, 0, 2, 4], 3) [1, -1, 3] >>> find_triplet_with_sum([1, 2, 3, 4, 6, 5], 15) [4, 5, 6]","solution":"def find_triplet_with_sum(nums, target): Finds a triplet in the array that sums up to the given target. :param nums: List of integers :param target: Target sum :return: List containing the triplet, or an empty list if no such triplet exists nums.sort() length = len(nums) for i in range(length-2): left, right = i+1, length-1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def can_form_palindrome_after_one_removal(s: str) -> bool: Check if it's possible to rearrange the string into a palindrome by removing exactly one character. >>> can_form_palindrome_after_one_removal(\\"abccba\\") == True >>> can_form_palindrome_after_one_removal(\\"abccbax\\") == True >>> can_form_palindrome_after_one_removal(\\"a\\") == True >>> can_form_palindrome_after_one_removal(\\"ab\\") == True >>> can_form_palindrome_after_one_removal(\\"aba\\") == True >>> can_form_palindrome_after_one_removal(\\"abc\\") == False >>> can_form_palindrome_after_one_removal(\\"racecarx\\") == True >>> can_form_palindrome_after_one_removal(\\"aabbccx\\") == True","solution":"from collections import Counter def can_form_palindrome_after_one_removal(s): Check if it's possible to rearrange the string into a palindrome by removing exactly one character. def can_form_palindrome(s): odd_count = sum(1 for count in Counter(s).values() if count % 2 != 0) return odd_count <= 1 if len(s) <= 2: return True for i in range(len(s)): modified_string = s[:i] + s[i+1:] if can_form_palindrome(modified_string): return True return False"},{"question":"def can_achieve_sum(arr, x): Determines if it is possible to modify the array to achieve the sum x by repeatedly replacing any two adjacent elements with their sum. Parameters: arr (list of int): The array of integers. x (int): The target sum. Returns: bool: True if it is possible to modify the array to achieve the sum x, else False. pass def test_can_achieve_sum_exact_match(): assert can_achieve_sum([1, 2, 3], 6) == True def test_can_achieve_sum_more_elements(): assert can_achieve_sum([1, 2, 3, 4], 10) == True def test_can_achieve_sum_less_elements(): assert can_achieve_sum([1, 2, 3], 7) == False def test_can_achieve_sum_single_element(): assert can_achieve_sum([5], 5) == True assert can_achieve_sum([5], 10) == False def test_can_achieve_sum_empty_array(): assert can_achieve_sum([], 0) == True assert can_achieve_sum([], 1) == False def test_can_achieve_sum_negative_numbers(): assert can_achieve_sum([-1, -2, -3], -6) == True assert can_achieve_sum([-1, -2, -3], -5) == False def test_can_achieve_sum_mixed_numbers(): assert can_achieve_sum([1, -2, 3, -4], -2) == True","solution":"def can_achieve_sum(arr, x): Determines if it is possible to modify the array to achieve the sum x by repeatedly replacing any two adjacent elements with their sum. Parameters: arr (list of int): The array of integers. x (int): The target sum. Returns: bool: True if it is possible to modify the array to achieve the sum x, else False. return sum(arr) == x"},{"question":"from typing import List, Dict class WordFrequencyAnalyzer: Analyzes the frequency of words in a given text document. Attributes: words (List[str]): A list of words to be analyzed. Methods: getWordFrequencies() -> Dict[str, int]: Returns a dictionary where keys are words and values are their frequencies. getTopKFrequentWords(k: int) -> List[str]: Returns a list of the top k most frequent words. >>> words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] >>> analyzer = WordFrequencyAnalyzer(words) >>> analyzer.getWordFrequencies() {'apple': 2, 'banana': 3, 'orange': 1} >>> analyzer.getTopKFrequentWords(2) ['banana', 'apple'] def __init__(self, words: List[str]): pass # Initialize the WordFrequencyAnalyzer with the given list of words. def getWordFrequencies(self) -> Dict[str, int]: pass # Return a dictionary where keys are words and values are their frequencies. def getTopKFrequentWords(self, k: int) -> List[str]: pass # Return a list of the top k most frequent words. # Unit test def test_word_frequency_analyzer(): words = [\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"] analyzer = WordFrequencyAnalyzer(words) assert analyzer.getWordFrequencies() == {\\"apple\\": 2, \\"banana\\": 3, \\"orange\\": 1} assert analyzer.getTopKFrequentWords(1) == [\\"banana\\"] assert analyzer.getTopKFrequentWords(2) == [\\"banana\\", \\"apple\\"] assert analyzer.getTopKFrequentWords(5) == [\\"banana\\", \\"apple\\", \\"orange\\"] empty_analyzer = WordFrequencyAnalyzer([]) assert empty_analyzer.getWordFrequencies() == {} assert empty_analyzer.getTopKFrequentWords(1) == [] single_word_analyzer = WordFrequencyAnalyzer([\\"apple\\"]) assert single_word_analyzer.getWordFrequencies() == {\\"apple\\": 1} assert single_word_analyzer.getTopKFrequentWords(1) == [\\"apple\\"]","solution":"from collections import Counter from typing import List, Dict class WordFrequencyAnalyzer: def __init__(self, words: List[str]): self.words = words self.word_frequencies = Counter(words) def getWordFrequencies(self) -> Dict[str, int]: return dict(self.word_frequencies) def getTopKFrequentWords(self, k: int) -> List[str]: return [word for word, _ in self.word_frequencies.most_common(k)]"},{"question":"def largest_square_area(matrix: List[List[int]]) -> int: Find the largest square containing only '1's in a given 2D matrix and return its area. :param matrix: List[List[int]], 2D array with elements 0 or 1 :return: int, area of the largest square of 1's >>> largest_square_area([]) == 0 >>> largest_square_area([[]]) == 0 >>> largest_square_area([[0, 0], [0, 0]]) == 0 >>> largest_square_area([[1, 1], [1, 1]]) == 4 >>> largest_square_area([[1, 0], [1, 1]]) == 1 >>> largest_square_area([[1, 1, 0], [1, 1, 1]]) == 4 >>> largest_square_area([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) == 4 >>> largest_square_area([[1, 1, 1, 1]]) == 1 >>> largest_square_area([[1], [1], [1], [1]]) == 1 >>> largest_square_area([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 1","solution":"def largest_square_area(matrix): Find the largest square containing only '1's in a given 2D matrix and return its area. :param matrix: List[List[int]], 2D array with elements 0 or 1 :return: int, area of the largest square of 1's if not matrix or not matrix[0]: return 0 rows = len(matrix) cols = len(matrix[0]) dp = [[0] * cols for _ in range(rows)] max_side = 0 for i in range(rows): for j in range(cols): if matrix[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 max_side = max(max_side, dp[i][j]) return max_side ** 2"},{"question":"def generate_subsets(s: set) -> List[List[int]]: Generates all subsets of the given set of unique integers such that: - Elements within subsets are sorted in non-descending order. - Subsets are sorted in non-descending order of their lengths. - Subsets of the same length are sorted lexicographically. Args: s (set): A set of unique integers. Returns: List[List[int]]: A list of all possible subsets sorted according to the mentioned criteria. >>> generate_subsets(set()) [[]] >>> generate_subsets({1}) [[], [1]] >>> generate_subsets({2, 1}) [[], [1], [2], [1, 2]] >>> generate_subsets({1, 2, 3}) [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] >>> generate_subsets({4, 1, 2, 3}) [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]","solution":"def generate_subsets(s): Generates all subsets of the given set of unique integers such that: - Elements within subsets are sorted in non-descending order. - Subsets are sorted in non-descending order of their lengths. - Subsets of the same length are sorted lexicographically. Args: s (set): A set of unique integers. Returns: List[List[int]]: A list of all possible subsets sorted according to the mentioned criteria. from itertools import combinations sorted_input = sorted(s) subsets = [] for r in range(len(sorted_input) + 1): for subset in combinations(sorted_input, r): subsets.append(list(subset)) return subsets"},{"question":"def contains_cycle(graph): Determines if an undirected graph contains a cycle. Args: graph (dict): An adjacency list representing the graph. Returns: bool: True if the graph contains a cycle, False otherwise. pass # Unit Tests def test_no_cycle(): graph = { 0: [1], 1: [0, 2], 2: [1, 3], 3: [2] } assert not contains_cycle(graph) def test_with_cycle(): graph = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } assert contains_cycle(graph) def test_disconnected_components_with_cycle(): graph = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3, 5], 5: [4, 3] } assert contains_cycle(graph) def test_disconnected_components_no_cycle(): graph = { 0: [1], 1: [0, 2], 2: [1], 3: [4], 4: [3, 5], 5: [4] } assert not contains_cycle(graph) def test_self_loop(): graph = { 0: [0] } assert contains_cycle(graph) def test_empty_graph(): graph = {} assert not contains_cycle(graph)","solution":"def contains_cycle(graph): Determines if an undirected graph contains a cycle. Args: graph (dict): An adjacency list representing the graph. Returns: bool: True if the graph contains a cycle, False otherwise. visited = set() def dfs(v, parent): visited.add(v) for neighbor in graph.get(v, []): if neighbor not in visited: if dfs(neighbor, v): return True elif neighbor != parent: return True return False for vertex in graph: if vertex not in visited: if dfs(vertex, None): return True return False"},{"question":"def findUnsortedSubarray(arr: List[int]) -> int: Given an integer array \`arr\`, return the length of the shortest subarray that, after sorting, makes the whole array \`arr\` sorted in non-decreasing order. If the array is already non-decreasing, return \`0\`. >>> findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5 >>> findUnsortedSubarray([1, 2, 3, 4]) == 0 >>> findUnsortedSubarray([1, 3, 2, 2, 2]) == 4 >>> findUnsortedSubarray([2, 1]) == 2 >>> findUnsortedSubarray([1]) == 0 >>> findUnsortedSubarray([2, 3, 3, 2, 4]) == 3 >>> findUnsortedSubarray([5, 4, 3, 2, 1]) == 5 >>> findUnsortedSubarray([1, 2, 3, 3, 3, 4, 5, 6, 7, 7, 7, 8, 9, 10]) == 0 >>> findUnsortedSubarray([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]) == 0","solution":"def findUnsortedSubarray(arr): Given an integer array \`arr\`, this function returns the length of the shortest subarray that, after sorting, makes the whole array \`arr\` sorted in non-decreasing order. If the array is already non-decreasing, it returns \`0\`. n = len(arr) start, end = 0, -1 max_seen, min_seen = -float('inf'), float('inf') for i in range(n): if arr[i] < max_seen: end = i else: max_seen = arr[i] for i in range(n-1, -1, -1): if arr[i] > min_seen: start = i else: min_seen = arr[i] return end - start + 1"},{"question":"def find_triplet(arr, target_sum): Determines if there are three distinct elements in the array \`arr\` that add up to the given \`sum\`. Parameters: arr : list of int : List of non-negative integers target_sum : int : Target sum Returns: bool : True if such a triplet exists, False otherwise >>> find_triplet([1, 4, 45, 6, 10, 8], 22) True >>> find_triplet([1, 2, 4, 3, 6], 19) False >>> find_triplet([12, 3, 4, 1, 6, 9], 24) True >>> find_triplet([-1, -4, 5, -3, 2], -3) True >>> find_triplet([], 10) False >>> find_triplet([10], 10) False >>> find_triplet([5, 5], 10) False >>> find_triplet([100, 200, 300, 400], 1000) False >>> find_triplet([1, 2, 3, 4, 5], 10) True >>> find_triplet([1, 2, 3], 6) True >>> find_triplet([1, 3, 5], 10) False","solution":"def find_triplet(arr, target_sum): Determines if there are three distinct elements in the array \`arr\` that add up to the given \`sum\`. Parameters: arr : list of int : List of non-negative integers target_sum : int : Target sum Returns: bool : True if such a triplet exists, False otherwise arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target_sum: return True elif current_sum < target_sum: left += 1 else: right -= 1 return False"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_paths(root): Counts the number of good paths in a binary tree where no two consecutive nodes have the same value. >>> root = TreeNode(0) >>> count_good_paths(root) 1 >>> root = TreeNode(0, TreeNode(1)) >>> count_good_paths(root) 1 >>> root = TreeNode(0, TreeNode(0)) >>> count_good_paths(root) 0 >>> root = TreeNode(0, TreeNode(1, TreeNode(0, TreeNode(1)))) >>> count_good_paths(root) 1 >>> root = TreeNode(1, TreeNode(0, TreeNode(1)), TreeNode(0)) >>> count_good_paths(root) 2 >>> root = TreeNode(0, TreeNode(0, TreeNode(0)), TreeNode(0)) >>> count_good_paths(root) 0","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def count_good_paths(root): Counts the number of good paths in a binary tree where no two consecutive nodes have the same value. def is_good_path(node, parent_value, count): if not node: return 0 current_count = count if node.value != parent_value: current_count += 1 if not node.left and not node.right: return 1 count_left = is_good_path(node.left, node.value, current_count) count_right = is_good_path(node.right, node.value, current_count) return count_left + count_right return 0 return is_good_path(root, -1, 0)"},{"question":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. Args: arr: List[int] - The input array. k: int - The number of steps to rotate the array. Returns: List[int] - The rotated array. >>> rotate_array([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 1) [5, 1, 2, 3, 4] >>> rotate_array([1, 2, 3, 4, 5], 3) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 8) [3, 4, 5, 1, 2] >>> rotate_array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1000003) [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]","solution":"def rotate_array(arr, k): Rotates the array to the right by k steps. Args: arr: List[int] - The input array. k: int - The number of steps to rotate the array. Returns: List[int] - The rotated array. n = len(arr) k = k % n # In case k is larger than the length of the array arr[:] = arr[-k:] + arr[:-k] # Rotate in place return arr"},{"question":"def shift_string(s: str, n: int) -> str: Shifts each character in the string s by n positions forward in the alphabet. Wraps around to the beginning of the alphabet if necessary. Parameters: s (str): Input string consisting of lowercase alphabets. n (int): Number of positions to shift each character. Returns: str: Resulting string after shifting characters. Examples: >>> shift_string('abc', 2) 'cde' >>> shift_string('xyz', 3) 'abc' >>> shift_string('abc', 28) 'cde' >>> shift_string('abcdefghijklmnopqrstuvwxyz', 1) 'bcdefghijklmnopqrstuvwxyza' >>> shift_string('', 1) '' >>> shift_string('a', 25) 'z' >>> shift_string('z', 1) 'a'","solution":"def shift_string(s, n): Shifts each character in the string s by n positions forward in the alphabet. Wraps around to the beginning of the alphabet if necessary. Parameters: s (str): Input string consisting of lowercase alphabets. n (int): Number of positions to shift each character. Returns: str: Resulting string after shifting characters. shifted_string = [] for char in s: shifted_char = chr((ord(char) - ord('a') + n) % 26 + ord('a')) shifted_string.append(shifted_char) return ''.join(shifted_string)"},{"question":"def min_toggles_to_alternating(s: str) -> int: Returns the minimum number of toggles required to make the binary string s an alternating binary string. >>> min_toggles_to_alternating(\\"0000\\") 2 >>> min_toggles_to_alternating(\\"0101\\") 0 >>> min_toggles_to_alternating(\\"1111\\") 2 >>> min_toggles_to_alternating(\\"1010\\") 0 >>> min_toggles_to_alternating(\\"0011\\") 2 >>> min_toggles_to_alternating(\\"0110\\") 2 >>> min_toggles_to_alternating(\\"1001\\") 2 >>> min_toggles_to_alternating(\\"0\\") 0 >>> min_toggles_to_alternating(\\"1\\") 0 >>> min_toggles_to_alternating(\\"\\") 0","solution":"def min_toggles_to_alternating(s): Returns the minimum number of toggles required to make the binary string s an alternating binary string. n = len(s) # Count mismatches for pattern starting with '0' i.e., \\"010101...\\" count1 = sum(s[i] != '0' if i % 2 == 0 else s[i] != '1' for i in range(n)) # Count mismatches for pattern starting with '1' i.e., \\"101010...\\" count2 = sum(s[i] != '1' if i % 2 == 0 else s[i] != '0' for i in range(n)) # Minimum of the two counts is our answer return min(count1, count2)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def isPalindrome(head): Determine whether a singly linked list is a palindrome. :param head: ListNode, the head of the singly linked list :return: bool, True if the list is a palindrome, False otherwise >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(2) >>> head.next.next.next.next = ListNode(1) >>> isPalindrome(head) True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(2) >>> head.next.next.next = ListNode(1) >>> isPalindrome(head) True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(4) >>> isPalindrome(head) False >>> head = ListNode(1) >>> isPalindrome(head) True >>> head = None >>> isPalindrome(head) True >>> head = ListNode(1) >>> head.next = ListNode(1) >>> isPalindrome(head) True >>> head = ListNode(1) >>> head.next = ListNode(2) >>> isPalindrome(head) False","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def isPalindrome(head): Determine whether a singly linked list is a palindrome. :param head: ListNode, the head of the singly linked list :return: bool, True if the list is a palindrome, False otherwise if head is None or head.next is None: return True # Find the middle of the linked list using fast and slow pointers slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Reverse the second half of the list prev = None while slow: next_node = slow.next slow.next = prev prev = slow slow = next_node # Compare the first and second halves left, right = head, prev while right: if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"def min_path_sum(grid): Returns the minimum sum of the path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. >>> min_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_path_sum([ ... [1, 2, 3] ... ]) == 6 >>> min_path_sum([ ... [1], ... [2], ... [3] ... ]) == 6 >>> min_path_sum([[42]]) == 42 >>> min_path_sum([]) == 0 >>> min_path_sum([[]]) == 0","solution":"def min_path_sum(grid): Returns the minimum sum of the path from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Initialize the first row for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"def max_min_after_swap(nums: List[int]) -> int: Returns the maximum possible value of the smallest element of the nums array after performing exactly one swap. >>> max_min_after_swap([3, 1, 4, 5, 2]) 2 >>> max_min_after_swap([10, 20, 30, 40]) 20 >>> max_min_after_swap([8, 1, 6, 3, 7]) 3 >>> max_min_after_swap([5, 5, 5, 5]) 5 >>> max_min_after_swap([1, 1000, 100, 10]) 10","solution":"def max_min_after_swap(nums): Returns the maximum possible value of the smallest element of the nums array after performing exactly one swap. # Determine the two largest elements. max_first, max_second = float('-inf'), float('-inf') max_first_index, max_second_index = -1, -1 for i in range(len(nums)): if nums[i] > max_first: max_second = max_first max_second_index = max_first_index max_first = nums[i] max_first_index = i elif nums[i] > max_second: max_second = nums[i] max_second_index = i # Determine the two smallest elements. min_first, min_second = float('inf'), float('inf') min_first_index, min_second_index = -1, -1 for i in range(len(nums)): if nums[i] < min_first: min_second = min_first min_second_index = min_first_index min_first = nums[i] min_first_index = i elif nums[i] < min_second: min_second = nums[i] min_second_index = i # Check swapping the smallest with the largest swap_first = min(nums[min_first_index], max_first) # Check swapping the second smallest with the second largest swap_second = min(nums[min_second_index], max_second) # Return the better swap result return max(swap_first, swap_second)"},{"question":"def hasPath(maze: List[List[int]]) -> bool: Determines if there is a path from any '2' to any '3' in a given maze. :param maze: A 2D list representing the maze :return: True if a path exists, False otherwise >>> hasPath([[0, 1, 0, 0], [2, 0, 0, 1], [1, 3, 0, 0]]) True >>> hasPath([[0, 1, 0, 0], [3, 0, 0, 1], [1, 0, 0, 0]]) False >>> hasPath([[0, 1, 0, 0], [2, 0, 0, 1], [1, 0, 0, 0]]) False >>> hasPath([[2, 1, 1, 1], [1, 1, 1, 1], [1, 1, 0, 3]]) False >>> hasPath([[0, 0, 0], [0, 2, 3], [0, 0, 0]]) True","solution":"def hasPath(maze): Determines if there is a path from any '2' to any '3' in a given maze. :param maze: A 2D list representing the maze :return: True if a path exists, False otherwise if not maze or not maze[0]: return False rows, cols = len(maze), len(maze[0]) def find_start(): for r in range(rows): for c in range(cols): if maze[r][c] == 2: return (r, c) return None start = find_start() if not start: return False def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or maze[r][c] == 1: return False if maze[r][c] == 3: return True maze[r][c] = 1 # mark as visited # explore all four possible directions if dfs(r+1, c) or dfs(r-1, c) or dfs(r, c+1) or dfs(r, c-1): return True return False return dfs(start[0], start[1])"},{"question":"class FriendRecommender: A class to recommend new friends to users on a social media platform based on mutual friends. Attributes: n (int): Number of users on the platform. friends (List[List[int]]): List of lists where friends[i] contains the list of friends for user i. Methods: recommendFriends(userId: int) -> List[int]: Returns a list of recommended friends for the given user sorted by the number of mutual friends. def __init__(self, n: int, friends: List[List[int]]): Initializes the recommender system with the given number of users and friendship connections. Args: n (int): Number of users on the platform. friends (List[List[int]]): List of lists where friends[i] contains the list of friends for user i. def recommendFriends(self, userId: int) -> List[int]: Returns a list of recommended friends for the given user sorted by the number of mutual friends. Args: userId (int): The ID of the user for whom to recommend friends. Returns: List[int]: Sorted list of recommended friends. Example: >>> n = 4 >>> friends = [ ... [1, 2], ... [0, 2, 3], ... [0, 1, 3], ... [1, 2] ... ] >>> recommender = FriendRecommender(n, friends) >>> recommender.recommendFriends(0) [3] import pytest from solution import FriendRecommender def test_recommend_friends_case_1(): n = 4 friends = [ [1, 2], [0, 2, 3], [0, 1, 3], [1, 2] ] recommender = FriendRecommender(n, friends) assert recommender.recommendFriends(0) == [3] def test_recommend_friends_case_2(): n = 5 friends = [ [1, 2], [0, 3], [0, 3], [1, 2, 4], [3] ] recommender = FriendRecommender(n, friends) assert recommender.recommendFriends(0) == [3] def test_recommend_friends_case_3(): n = 6 friends = [ [1], [0, 2, 3], [1, 3], [1, 2, 4, 5], [3, 5], [3, 4] ] recommender = FriendRecommender(n, friends) assert recommender.recommendFriends(0) == [2, 3] def test_recommend_friends_no_recommendations(): n = 3 friends = [ [1], [0], [] ] recommender = FriendRecommender(n, friends) assert recommender.recommendFriends(0) == [] def test_recommend_friends_all_friends(): n = 3 friends = [ [1, 2], [0, 2], [0, 1] ] recommender = FriendRecommender(n, friends) assert recommender.recommendFriends(0) == []","solution":"class FriendRecommender: def __init__(self, n, friends): # Initialize the friend list for each user self.n = n self.friends = friends def recommendFriends(self, userId): # Get the current list of friends for userId user_friends = set(self.friends[userId]) mutual_counts = {} # Iterate through each friend of userId for friend in user_friends: # Get friends of the current friend friends_of_friend = self.friends[friend] for fof in friends_of_friend: # Ensure that who we consider as a recommendation is not already a friend or the user itself if fof != userId and fof not in user_friends: if fof not in mutual_counts: mutual_counts[fof] = 0 mutual_counts[fof] += 1 # Convert the mutual_counts dictionary into a sorted list of friend recommendations recommendations = sorted(mutual_counts.keys(), key=lambda x: (-mutual_counts[x], x)) return recommendations"},{"question":"from typing import List def third_max(nums: List[int]) -> int: Given an integer array \`nums\`, return the third maximum number in this array. If the third maximum does not exist, return the maximum number. The solution should have a linear runtime complexity. >>> third_max([3, 2, 1]) == 1 >>> third_max([1, 2, 2, 3]) == 1 >>> third_max([2, 1]) == 2 >>> third_max([1]) == 1 >>> third_max([-1, -2, -3, -4]) == -3 >>> third_max([5, 2, 2, 4, 3, 1]) == 3 >>> third_max([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == 8 >>> third_max([3, 3, 3]) == 3 >>> third_max([0, -1, -2]) == -2","solution":"def third_max(nums): Returns the third maximum number in the array. If the third maximum does not exist, returns the maximum number. max_nums = [float('-inf'), float('-inf'), float('-inf')] for num in nums: if num not in max_nums: if num > max_nums[0]: max_nums = [num, max_nums[0], max_nums[1]] elif num > max_nums[1]: max_nums = [max_nums[0], num, max_nums[1]] elif num > max_nums[2]: max_nums = [max_nums[0], max_nums[1], num] return max_nums[2] if max_nums[2] != float('-inf') else max_nums[0]"},{"question":"def has_subarray_with_sum(arr, target): Determine if there exists a subarray (non-empty) whose sum equals target. Args: arr (list of int): List of integers. target (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. >>> has_subarray_with_sum([1, 2, 3, 4], 6) True >>> has_subarray_with_sum([1, 2, 3], 7) False >>> has_subarray_with_sum([10, 2, -2, -20, 10], -10) True >>> has_subarray_with_sum([], 1) False >>> has_subarray_with_sum([5], 5) True >>> has_subarray_with_sum([1, -1, 1, -1, 1], 5) False >>> has_subarray_with_sum([10**6, 10**7, 10**8, 10**9], 10**7 + 10**8) True","solution":"def has_subarray_with_sum(arr, target): Determine if there exists a subarray (non-empty) whose sum equals target. Args: arr (list of int): List of integers. target (int): Target sum. Returns: bool: True if such a subarray exists, False otherwise. cumulative_sum = 0 cumulative_sum_set = set() for num in arr: cumulative_sum += num if cumulative_sum == target: return True if (cumulative_sum - target) in cumulative_sum_set: return True cumulative_sum_set.add(cumulative_sum) return False"},{"question":"from typing import List class WindowMax: def __init__(self, arr: List[int], k: int): Initialize the object with the integers array arr and window size k. pass def getMax(self) -> List[int]: Returns an array containing the maximum values of each sliding window of size k. >>> wm = WindowMax([1,3,-1,-3,5,3,6,7], 3) >>> wm.getMax() [3, 3, 5, 5, 6, 7] >>> wm = WindowMax([5], 1) >>> wm.getMax() [5] >>> wm = WindowMax([1, 2, 3], 5) >>> wm.getMax() [] >>> wm = WindowMax([1, 3, 5, 2, 8], 5) >>> wm.getMax() [8] >>> wm = WindowMax([1, 1, 1, 1, 1], 3) >>> wm.getMax() [1, 1, 1] >>> wm = WindowMax([4, 2, 12, 3, 8, 6, 7], 4) >>> wm.getMax() [12, 12, 12, 8] pass","solution":"from collections import deque class WindowMax: def __init__(self, arr, k): self.arr = arr self.k = k def getMax(self): if self.k > len(self.arr): return [] result = [] deq = deque() for i in range(len(self.arr)): # Ensure the deque's elements remain relevant within the window if deq and deq[0] == i - self.k: deq.popleft() # Maintain the decreasing order in deque for max value tracking while deq and self.arr[deq[-1]] < self.arr[i]: deq.pop() deq.append(i) # Append to result only when we have a complete window of size k if i >= self.k - 1: result.append(self.arr[deq[0]]) return result"},{"question":"def generate_sequence(n: int) -> List[int]: Generates a sequence of n elements where the next element is determined based on the current element. >>> generate_sequence(1) [1] >>> generate_sequence(2) [1, 2] >>> generate_sequence(10) [1, 2, 1, 2, 1, 2, 1, 2, 1, 2] >>> generate_sequence(6) [1, 2, 1, 2, 1, 2] >>> generate_sequence(3) [1, 2, 1] >>> generate_sequence(0) [] >>> generate_sequence(15) [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1]","solution":"def generate_sequence(n): Generates a sequence of n elements where the next element is determined based on the current element. Args: n (int): The number of elements in the sequence. Returns: List[int]: The sequence of n elements. if n <= 0: return [] sequence = [1] for _ in range(1, n): prev = sequence[-1] if prev == 1: sequence.append(2) elif prev % 2 == 0: sequence.append(prev // 2) else: sequence.append(3 * prev + 1) return sequence"},{"question":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root: Optional[TreeNode]) -> List[float]: Given a binary tree, return the average value of the nodes on each level in the form of an array. >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> averageOfLevels(root) [3.0, 14.5, 11.0] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> averageOfLevels(root) [1.0, 2.5, 5.5]","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def averageOfLevels(root): if not root: return [] result = [] queue = deque([root]) while queue: level_length = len(queue) level_sum = 0 for _ in range(level_length): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level_sum / level_length) return result"},{"question":"def largest_rectangle_area(heights): Given an array heights representing the heights of columns, returns the area of the largest rectangle that can be formed within the bounds of the histogram. >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([1]) == 1 >>> largest_rectangle_area([5]) == 5 >>> largest_rectangle_area([2, 1]) == 2 >>> largest_rectangle_area([1, 2]) == 2 >>> largest_rectangle_area([2, 2]) == 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([3, 3, 3, 3]) == 12 >>> largest_rectangle_area([2, 4, 2, 1, 10, 6, 10, 10]) == 24","solution":"def largest_rectangle_area(heights): Given an array heights representing the heights of columns, returns the area of the largest rectangle that can be formed within the bounds of the histogram. stack = [] max_area = 0 index = 0 while index < len(heights): # If this bar is higher than the bar at stack top, push it to the stack if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with heights[top_of_stack] as the smallest (or minimum height) bar 'h' area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max area, if needed max_area = max(max_area, area) # Now pop the remaining bars from stack and calculate area while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def min_subarray_len(arr: List[int], m: int) -> int: Returns the length of the smallest contiguous subarray whose sum is greater than or equal to m. If there isn't one, return 0. >>> min_subarray_len([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_len([1, 4, 4], 4) 1 >>> min_subarray_len([1, 2, 3], 7) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 5) 1 >>> min_subarray_len([1, 1, 1, 1, 1, 1], 6) 6 >>> min_subarray_len([], 5) 0 >>> min_subarray_len([1, 2, 3, 4, 5], 11) 3","solution":"def min_subarray_len(arr, m): Returns the length of the smallest contiguous subarray whose sum is greater than or equal to m. If there isn't one, return 0. n = len(arr) if n == 0: return 0 min_len = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= m: min_len = min(min_len, end - start + 1) current_sum -= arr[start] start += 1 return min_len if min_len != n + 1 else 0"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: A class for representing a binary tree with integer nodes. Methods: - __init__(self, elements: List[Optional[int]]): Initializes the binary tree with given integer elements (level-order). - insert(self, value: int): Inserts a node into the binary tree. - levelOrderTraversal(self) -> List[int]: Returns the level-order traversal list of the binary tree. - findMaxDepth(self) -> int: Returns the maximum depth of the binary tree. - sumOfLeafNodes(self) -> int: Returns the sum of all leaf nodes in the binary tree. def __init__(self, elements): Initializes the binary tree with the given integer elements. The elements array represents a level-order traversal of the tree. A value of \`None\` in the array indicates that the corresponding node is missing. Args: elements (List[Optional[int]]): List of integers representing the tree in level-order. def insert(self, value): Inserts a new node with the given value into the binary tree while maintaining it as a proper binary tree. Args: value (int): The value to be inserted into the tree. def levelOrderTraversal(self): Returns the level order traversal of the binary tree as a list of integers. Returns: List[int]: List of integers representing the level order traversal of the tree. def findMaxDepth(self): Returns the maximum depth of the binary tree. The depth of the root node is 1. Returns: int: The maximum depth of the tree. def sumOfLeafNodes(self): Returns the sum of all leaf nodes in the binary tree. A leaf node is a node with no children. Returns: int: The sum of all leaf node values in the tree. from typing import List, Optional def test_binary_tree_initialization(): elements = [1, 2, 3, None, 4, 5, 6] bt = BinaryTree(elements) assert bt.levelOrderTraversal() == [1, 2, 3, 4, 5, 6] def test_insert(): bt = BinaryTree([1, 2, 3]) bt.insert(4) assert bt.levelOrderTraversal() == [1, 2, 3, 4] bt.insert(5) assert bt.levelOrderTraversal() == [1, 2, 3, 4, 5] def test_find_max_depth(): bt = BinaryTree([1, 2, 3, 4, None, None, None]) assert bt.findMaxDepth() == 3 def test_sum_of_leaf_nodes(): bt = BinaryTree([1, 2, 3, None, 4, 5, 6]) assert bt.sumOfLeafNodes() == 15 def test_empty_tree(): bt = BinaryTree([]) assert bt.levelOrderTraversal() == [] assert bt.findMaxDepth() == 0 assert bt.sumOfLeafNodes() == 0 bt.insert(1) assert bt.levelOrderTraversal() == [1] assert bt.findMaxDepth() == 1 assert bt.sumOfLeafNodes() == 1","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self, elements): if not elements: self.root = None return self.root = TreeNode(elements[0]) queue = [self.root] i = 1 while i < len(elements): current = queue.pop(0) if elements[i] is not None: current.left = TreeNode(elements[i]) queue.append(current.left) i += 1 if i < len(elements) and elements[i] is not None: current.right = TreeNode(elements[i]) queue.append(current.right) i += 1 def insert(self, value): if not self.root: self.root = TreeNode(value) return queue = [self.root] while queue: current = queue.pop(0) if not current.left: current.left = TreeNode(value) return else: queue.append(current.left) if not current.right: current.right = TreeNode(value) return else: queue.append(current.right) def levelOrderTraversal(self): if not self.root: return [] result = [] queue = [self.root] while queue: current = queue.pop(0) result.append(current.value) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result def findMaxDepth(self): def depth(node): if not node: return 0 return 1 + max(depth(node.left), depth(node.right)) return depth(self.root) def sumOfLeafNodes(self): if not self.root: return 0 sum_leaves = 0 queue = [self.root] while queue: current = queue.pop(0) if not current.left and not current.right: sum_leaves += current.value if current.left: queue.append(current.left) if current.right: queue.append(current.right) return sum_leaves"},{"question":"class Solution: def longestSubarraySumEqualsK(self, nums, k): Finds and returns the length of the longest subarray whose sum equals to k. If no such subarray exists, returns 0. Examples: >>> sol = Solution() >>> sol.longestSubarraySumEqualsK([1, -1, 5, -2, 3], 3) 4 >>> sol.longestSubarraySumEqualsK([-2, -1, 2, 1], 1) 2","solution":"class Solution: def longestSubarraySumEqualsK(self, nums, k): sum_map = {} current_sum = 0 max_length = 0 for i in range(len(nums)): current_sum += nums[i] if current_sum == k: max_length = i + 1 if (current_sum - k) in sum_map: max_length = max(max_length, i - sum_map[current_sum - k]) if current_sum not in sum_map: sum_map[current_sum] = i return max_length"},{"question":"def count_even_sum_subarrays(arr: List[int]) -> int: Return the number of subarrays with an even sum in the given array \`arr\`. The result is modulo 10^9 + 7. >>> count_even_sum_subarrays([1, 2, 3, 4]) == 4 # Subarrays: [2], [1, 3], [3, 1], [1, 2, 3, 4] >>> count_even_sum_subarrays([1, 1, 1, 1]) == 4 # Subarrays: [1, 1], [1, 1], [1, 1], [1, 1, 1, 1] >>> count_even_sum_subarrays([-1, -2, -3, -4]) == 4 # Subarrays: [-2], [-1, -3], [-3, -1], [-1, -2, -3, -4] >>> count_even_sum_subarrays([0, 0, 0]) == 6 # Subarrays: [0], [0], [0], [0, 0], [0, 0], [0, 0, 0] >>> count_even_sum_subarrays([]) == 0 # Empty array >>> count_even_sum_subarrays([1]) == 0 # No subarray with even sum >>> count_even_sum_subarrays([2]) == 1 # Subarrays: [2] >>> count_even_sum_subarrays([1, 2, 3]) == 2 # Subarrays: [2], [1, 3] >>> count_even_sum_subarrays([2, 2, 2]) == 6 # Subarrays: [2], [2], [2], [2,2], [2,2], [2,2,2]","solution":"def count_even_sum_subarrays(arr): Returns the number of subarrays with an even sum in the given array \`arr\`. The result is modulo 10^9 + 7. MOD = 10**9 + 7 # Initialize counters for prefix sums current_prefix_sum = 0 count_even_prefix_sum = 1 # There's 1 even prefix sum at start (0) count_odd_prefix_sum = 0 result = 0 for num in arr: current_prefix_sum += num if current_prefix_sum % 2 == 0: result = (result + count_even_prefix_sum) % MOD count_even_prefix_sum += 1 else: result = (result + count_odd_prefix_sum) % MOD count_odd_prefix_sum += 1 return result"},{"question":"def largest_rectangle_area(heights): This function calculates the maximum rectangular area in a histogram. :param heights: List[int] heights of the buildings. :return: int, maximum rectangular area. >>> largest_rectangle_area([]) == 0 >>> largest_rectangle_area([5]) == 5 >>> largest_rectangle_area([1, 1, 1, 1]) == 4 >>> largest_rectangle_area([1, 2, 3, 4, 5]) == 9 >>> largest_rectangle_area([5, 4, 3, 2, 1]) == 9 >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) == 10 >>> largest_rectangle_area([2, 4, 2, 1]) == 6","solution":"def largest_rectangle_area(heights): This function calculates the maximum rectangular area in a histogram. :param heights: List[int] heights of the buildings. :return: int, maximum rectangular area. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> int: Returns the length of the longest common subsequence (LCS) that can be obtained by deleting some characters from each string. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"aab\\", \\"azb\\") 2 >>> longest_common_subsequence(\\"aabbcc\\", \\"abccba\\") 4 >>> longest_common_subsequence(\\"abcxyz\\", \\"xyzabc\\") 3 >>> longest_common_subsequence(\\"abcdef\\", \\"fbdamn\\") 2","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence (LCS) that can be obtained by deleting some characters from each string. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"from typing import List def max_unique_integers(nums: List[int], k: int) -> int: Finds the maximum number of unique integers in any subarray of length k. Parameters: - nums: List[int] - The list of integers. - k: int - The length of the subarray. Returns: - int - The maximum number of unique integers in any subarray of length k. If the length of the array is less than k, return -1. >>> max_unique_integers([1, 2, 1, 3, 4, 2, 3], 4) 4 >>> max_unique_integers([1, 2, 1, 1, 1, 1, 1], 3) 2 >>> max_unique_integers([1, 2, 3, 4, 5], 3) 3 >>> max_unique_integers([1, 2, 3, 4, 5], 5) 5 >>> max_unique_integers([1, 2], 3) -1 >>> max_unique_integers([], 1) -1 >>> max_unique_integers([2, 2, 2, 2], 2) 1","solution":"def max_unique_integers(nums, k): Finds the maximum number of unique integers in any subarray of length k. Parameters: - nums: List[int] - The list of integers. - k: int - The length of the subarray. Returns: - int - The maximum number of unique integers in any subarray of length k. if len(nums) < k: return -1 from collections import defaultdict current_window = defaultdict(int) max_unique = 0 for i in range(k): current_window[nums[i]] += 1 max_unique = len(current_window) for i in range(k, len(nums)): new_num = nums[i] old_num = nums[i - k] current_window[old_num] -= 1 if current_window[old_num] == 0: del current_window[old_num] current_window[new_num] += 1 max_unique = max(max_unique, len(current_window)) return max_unique"},{"question":"def is_palindrome(s: str) -> bool: Given a string s, determine if it is a valid palindrome considering only alphanumeric characters and ignoring cases. The function returns True if it is a valid palindrome, and False otherwise. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"A\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"A1B2B1A\\") True >>> is_palindrome(\\"A1B2C2A\\") False >>> is_palindrome(\\"Able was I ere I saw Elba\\") True","solution":"def is_palindrome(s): Returns true if the given string s is a valid palindrome, false otherwise. A valid palindrome considers only alphanumeric characters and ignores cases. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Compare the filtered list to its reverse return filtered_chars == filtered_chars[::-1]"},{"question":"def find_k_largest_elements(arr, k): Returns the k largest unique elements in ascending order. If there are fewer than k unique elements, return all unique elements sorted in ascending order. Parameters: arr (list): List of integers. k (int): Number of largest elements to retrieve. Returns: list: k largest unique elements in ascending order. >>> find_k_largest_elements([1, 4, 2, 5, 3], 3) [3, 4, 5] >>> find_k_largest_elements([1, 1, 2, 2, 3, 3], 5) [1, 2, 3] >>> find_k_largest_elements([7, 2, 1, 4, 8, 9], 3) [7, 8, 9] >>> find_k_largest_elements([5, 1, 1, 5, 3, 9, 3], 2) [5, 9] >>> find_k_largest_elements([-1, -4, -2, -2, -5], 2) [-2, -1] >>> find_k_largest_elements([1, 2, 3, 4], 0) [] >>> find_k_largest_elements([], 3) [] pass","solution":"def find_k_largest_elements(arr, k): Returns the k largest unique elements in ascending order. If there are fewer than k unique elements, return all unique elements sorted in ascending order. Parameters: arr (list): List of integers. k (int): Number of largest elements to retrieve. Returns: list: k largest unique elements in ascending order. unique_elements = list(set(arr)) unique_elements.sort(reverse=True) k_largest_elements = unique_elements[:k] k_largest_elements.sort() return k_largest_elements"},{"question":"def twoSum(nums: List[int], target: int) -> List[int]: Returns indices of the two numbers such that they add up to target. :param nums: List[int], the input array :param target: int, the target sum :return: List[int], list of two indices >>> twoSum([2, 7, 11, 15], 9) [0, 1] >>> twoSum([3, 2, 4], 6) [1, 2] >>> twoSum([-1, -2, -3, -4, -5], -8) [2, 4] >>> twoSum([1, 2, 3, 4, 5], 6) [1, 3] >>> twoSum([0, 4, 3, 0], 0) [0, 3]","solution":"def twoSum(nums, target): Returns indices of the two numbers such that they add up to target. :param nums: List[int], the input array :param target: int, the target sum :return: List[int], list of two indices num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i"},{"question":"from typing import List def max_area_of_island(grid: List[List[int]]) -> int: Returns the size of the largest island in the given 2D grid. An island is formed by group of \`1\`s connected vertically or horizontally. >>> max_area_of_island([ ... [0, 1, 0, 0], ... [1, 1, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 0, 0] ... ]) == 4 >>> max_area_of_island([ ... [0, 1, 0, 0], ... [1, 1, 0, 0], ... [0, 0, 0, 1], ... [0, 0, 1, 1] ... ]) == 3 >>> max_area_of_island([ ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0] ... ]) == 0 >>> max_area_of_island([ ... [1, 1, 1, 1], ... [1, 1, 1, 1], ... [1, 1, 1, 1] ... ]) == 12 >>> max_area_of_island([ ... [1, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 1, 0] ... ]) == 1","solution":"def max_area_of_island(grid): Returns the size of the largest island in the given 2D grid. An island is formed by group of \`1\`s connected vertically or horizontally. if not grid or not grid[0]: return 0 def dfs(i, j): if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == 0: return 0 grid[i][j] = 0 # mark as visited area = 1 area += dfs(i+1, j) area += dfs(i-1, j) area += dfs(i, j+1) area += dfs(i, j-1) return area max_area = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: max_area = max(max_area, dfs(i, j)) return max_area"},{"question":"class CircularQueue: Implements a fixed-size circular queue for integers. Methods: - CircularQueue(int k): Initializes the queue with a maximum size of k. - boolean enQueue(int value): Adds an integer value to the circular queue. Returns true if the operation is successful, otherwise false. - boolean deQueue(): Deletes an integer from the circular queue. Returns true if the operation is successful, otherwise false. - int Front(): Retrieves the front item from the queue. Returns -1 if the queue is empty. - int Rear(): Retrieves the last item from the queue. Returns -1 if the queue is empty. - boolean isEmpty(): Checks whether the queue is empty. Returns true if the queue is empty, otherwise false. - boolean isFull(): Checks whether the queue is full. Returns true if the queue is full, otherwise false. def __init__(self, k: int): pass def enQueue(self, value: int) -> bool: pass def deQueue(self) -> bool: pass def Front(self) -> int: pass def Rear(self) -> int: pass def isEmpty(self) -> bool: pass def isFull(self) -> bool: pass from solution import CircularQueue def test_circular_queue_initialization(): queue = CircularQueue(3) assert queue.isEmpty() == True assert queue.isFull() == False assert queue.Front() == -1 assert queue.Rear() == -1 def test_enqueue(): queue = CircularQueue(3) assert queue.enQueue(1) == True assert queue.enQueue(2) == True assert queue.enQueue(3) == True assert queue.enQueue(4) == False # Queue is full, cannot add more elements def test_dequeue(): queue = CircularQueue(3) queue.enQueue(1) queue.enQueue(2) queue.enQueue(3) assert queue.deQueue() == True assert queue.Front() == 2 assert queue.deQueue() == True assert queue.Front() == 3 assert queue.deQueue() == True assert queue.Front() == -1 # Queue is now empty assert queue.deQueue() == False def test_front_rear(): queue = CircularQueue(3) assert queue.Front() == -1 assert queue.Rear() == -1 queue.enQueue(1) assert queue.Front() == 1 assert queue.Rear() == 1 queue.enQueue(2) assert queue.Front() == 1 assert queue.Rear() == 2 queue.enQueue(3) assert queue.Front() == 1 assert queue.Rear() == 3 queue.deQueue() assert queue.Front() == 2 assert queue.Rear() == 3 queue.deQueue() assert queue.Front() == 3 assert queue.Rear() == 3 queue.deQueue() assert queue.Front() == -1 # Queue is now empty assert queue.Rear() == -1 def test_is_empty_is_full(): queue = CircularQueue(3) assert queue.isEmpty() == True assert queue.isFull() == False queue.enQueue(1) assert queue.isEmpty() == False assert queue.isFull() == False queue.enQueue(2) queue.enQueue(3) assert queue.isFull() == True queue.deQueue() assert queue.isFull() == False queue.deQueue() queue.deQueue() assert queue.isEmpty() == True assert queue.isFull() == False","solution":"class CircularQueue: def __init__(self, k: int): self.size = k self.queue = [0] * k self.front = -1 self.rear = -1 def enQueue(self, value: int) -> bool: if self.isFull(): return False if self.isEmpty(): self.front = 0 self.rear = (self.rear + 1) % self.size self.queue[self.rear] = value return True def deQueue(self) -> bool: if self.isEmpty(): return False if self.front == self.rear: self.front = -1 self.rear = -1 else: self.front = (self.front + 1) % self.size return True def Front(self) -> int: if self.isEmpty(): return -1 return self.queue[self.front] def Rear(self) -> int: if self.isEmpty(): return -1 return self.queue[self.rear] def isEmpty(self) -> bool: return self.front == -1 def isFull(self) -> bool: return (self.rear + 1) % self.size == self.front"},{"question":"def count_valid_subarrays(nums: List[int], x: int, y: int) -> int: Return the total number of valid subarrays in nums. A subarray is valid if its minimum value is at least x and its maximum value is at most y. >>> count_valid_subarrays([1, 2, 3, 4], 2, 3) == 3 >>> count_valid_subarrays([4, 3, 2, 1], 2, 4) == 6 >>> count_valid_subarrays([], 1, 3) == 0 >>> count_valid_subarrays([5, 6, 7, 8], 1, 4) == 0 >>> count_valid_subarrays([2, 3, 2, 3], 2, 3) == 10 >>> count_valid_subarrays([2], 2, 2) == 1 >>> count_valid_subarrays([2], 1, 3) == 1 >>> count_valid_subarrays([2], 3, 4) == 0 >>> count_valid_subarrays([-1, 2, 4, 3, 1], 0, 3) == 4","solution":"def count_valid_subarrays(nums, x, y): Returns the total number of valid subarrays in nums. A subarray is valid if its minimum value is at least x and its maximum value is at most y. n = len(nums) valid_count = 0 for start in range(n): min_val = float('inf') max_val = float('-inf') for end in range(start, n): min_val = min(min_val, nums[end]) max_val = max(max_val, nums[end]) if min_val >= x and max_val <= y: valid_count += 1 # This subarray is valid return valid_count"},{"question":"def can_be_increasing_or_one_reverse(nums: list) -> bool: Determine if it is possible to rearrange the elements of \`nums\` into a strictly increasing sequence by reversing at most one subarray from \`nums\`. Args: - nums (list): A list of integers. Returns: - bool: True if it is possible to rearrange and get strictly increasing order, otherwise False. >>> can_be_increasing_or_one_reverse([1, 2, 3, 4, 5]) True >>> can_be_increasing_or_one_reverse([1, 3, 2, 4, 5]) True >>> can_be_increasing_or_one_reverse([5, 4, 3, 2, 1]) True >>> can_be_increasing_or_one_reverse([1, 3, 5, 4, 2]) False >>> can_be_increasing_or_one_reverse([1, 5, 3, 4, 2]) False >>> can_be_increasing_or_one_reverse([1]) True >>> can_be_increasing_or_one_reverse([]) True >>> can_be_increasing_or_one_reverse([3, 2, 1, 4, 5]) True","solution":"def can_be_increasing_or_one_reverse(nums): Determine if it is possible to rearrange the elements of \`nums\` into a strictly increasing sequence by reversing at most one subarray from \`nums\`. Args: - nums (list): A list of integers. Returns: - bool: True if it is possible to rearrange and get strictly increasing order, otherwise False. for i in range(len(nums) - 1): if nums[i] >= nums[i + 1]: # Find the subarray to reverse j = i while j < len(nums) - 1 and nums[j] >= nums[j + 1]: j += 1 # Reverse the subarray reversed_subarray = nums[i:j + 1][::-1] new_nums = nums[:i] + reversed_subarray + nums[j + 1:] return new_nums == sorted(new_nums) and len(set(new_nums)) == len(new_nums) return True"},{"question":"def min_subarrays(blocks, m): Returns the minimum number of subarrays required such that the sum of each subarray is less than or equal to m. Parameters: blocks (list of int): The array representing the blocks at each position. m (int): The maximum number of blocks that the bag can carry. Returns: int: The minimum number of subarrays required. >>> min_subarrays([1, 2, 3, 4], 5) 3 >>> min_subarrays([1, 2, 3], 6) 1 >>> min_subarrays([5, 5, 5], 5) 3 >>> min_subarrays([], 5) 0 >>> min_subarrays([1, 1, 1, 1, 1, 1, 1, 1], 4) 2 >>> min_subarrays([10, 5, 7, 6], 10) 4","solution":"def min_subarrays(blocks, m): Returns the minimum number of subarrays required such that the sum of each subarray is less than or equal to m. Parameters: blocks (list of int): The array representing the blocks at each position. m (int): The maximum number of blocks that the bag can carry. Returns: int: The minimum number of subarrays required. n = len(blocks) if not blocks: return 0 num_subarrays = 0 current_sum = 0 for block in blocks: if current_sum + block > m: num_subarrays += 1 current_sum = block else: current_sum += block if current_sum > 0: num_subarrays += 1 return num_subarrays"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head: ListNode, k: int) -> ListNode: Removes the k-th node from the end of the list and returns the head of the modified list. :param ListNode head: The head of the singly-linked list. :param int k: The 1-indexed position from the end to remove. :return: The head of the modified list. :rtype: ListNode >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> new_head = remove_kth_from_end(head, 2) >>> linked_list_to_list(new_head) [1, 2, 3, 5] >>> head = create_linked_list([1, 2, 3, 4]) >>> new_head = remove_kth_from_end(head, 1) >>> linked_list_to_list(new_head) [1, 2, 3] >>> head = create_linked_list([1, 2, 3, 4, 5]) >>> new_head = remove_kth_from_end(head, 5) >>> linked_list_to_list(new_head) [2, 3, 4, 5] >>> head = create_linked_list([1]) >>> new_head = remove_kth_from_end(head, 1) >>> new_head is None True >>> head = create_linked_list([1, 2]) >>> new_head = remove_kth_from_end(head, 2) >>> linked_list_to_list(new_head) [2] pass","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_kth_from_end(head, k): Removes the k-th node from the end of the list and returns the head of the modified list. :param ListNode head: The head of the singly-linked list. :param int k: The 1-indexed position from the end to remove. :return: The head of the modified list. :rtype: ListNode dummy = ListNode(0) dummy.next = head first = second = dummy # Move first k+1 steps ahead for _ in range(k+1): first = first.next # Move both first and second pointers till first reaches the end while first: first = first.next second = second.next # Remove the k-th node from the end second.next = second.next.next return dummy.next"},{"question":"def count_unique_pairs(nums: List[int], target: int) -> int: Returns the number of unique pairs in the array that sum up to exactly \`target\`. >>> count_unique_pairs([1, 2, 3], 10) == 0 >>> count_unique_pairs([1, 2, 3, 4], 5) == 2 >>> count_unique_pairs([1, 1, 2, 45, 46, 46, 2, 45], 47) == 2 >>> count_unique_pairs([1, 5, 7, 1, 5, 7], 6) == 1 >>> count_unique_pairs([-1, -2, -3, 3, 2, 1], 0) == 3","solution":"def count_unique_pairs(nums, target): Returns the number of unique pairs in the array that sum up to exactly \`target\`. nums_seen = set() pairs_seen = set() count = 0 for num in nums: complement = target - num if complement in nums_seen: pair = tuple(sorted((num, complement))) if pair not in pairs_seen: pairs_seen.add(pair) count += 1 nums_seen.add(num) return count"},{"question":"from typing import List def longest_contiguous_subarray(nums: List[int]) -> int: Given an array of integers \`nums\`, returns the length of the longest contiguous subarray with all elements equal. Args: nums (List[int]): An array of integers. Returns: int: The length of the longest contiguous subarray with all elements equal. >>> longest_contiguous_subarray([]) == 0 >>> longest_contiguous_subarray([1]) == 1 >>> longest_contiguous_subarray([2, 2, 2, 2]) == 4 >>> longest_contiguous_subarray([1, 2, 3, 4]) == 1 >>> longest_contiguous_subarray([1, 1, 2, 2, 2, 3, 3, 1]) == 3 >>> longest_contiguous_subarray([1, 3, 3, 4, 4, 4, 2, 2]) == 3 >>> longest_contiguous_subarray([5, 5, 5, 2, 2, 3]) == 3 >>> longest_contiguous_subarray([2, 3, 4, 4, 4]) == 3","solution":"def longest_contiguous_subarray(nums): Returns the length of the longest contiguous subarray with all elements equal. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] == nums[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 return max(max_length, current_length)"},{"question":"def min_operations_to_make_equal(nums: List[int]) -> int: Given an array of integers \`nums\`, return the minimum number of operations needed to make all elements in the array equal. You may apply one of the following operations any number of times: 1. Pick an index \`i\` and increment \`nums[i]\` by 1. 2. Pick two indices \`i\` and \`j\` (i ≠ j) and make \`nums[i]\` equal to \`nums[j]\`. Examples: >>> min_operations_to_make_equal([1, 1, 1]) == 0 >>> min_operations_to_make_equal([1, 2, 3]) == 2 >>> min_operations_to_make_equal([1, 1, 2]) == 1 >>> min_operations_to_make_equal([3, 3, 3, 3, 2, 1]) == 2 >>> min_operations_to_make_equal([1, 2, 1, 2, 1, 2]) == 3 >>> min_operations_to_make_equal([5]) == 0 >>> min_operations_to_make_equal([i % 3 for i in range(1000)]) == 666","solution":"def min_operations_to_make_equal(nums): from collections import Counter # Step 1: Count frequency of each number frequency = Counter(nums) # Step 2: Find the maximum frequency max_freq = max(frequency.values()) # Step 3: Operations required to make all elements equal return len(nums) - max_freq"},{"question":"def minDistance(nums: List[int]) -> int: Returns the minimum distance the person needs to travel to visit exactly two landmarks and return to 0. >>> minDistance([2, 4, 5, 9]) == 12 >>> minDistance([1, 3, 5, 7, 9]) == 8 >>> minDistance([1, 2, 3, 4, 5]) == 6 >>> minDistance([1, 5]) == 12 >>> minDistance([3]) == float('inf')","solution":"def minDistance(nums): Returns the minimum distance the person needs to travel to visit exactly two landmarks and return to 0. # Sort the list of landmarks nums.sort() # Initialize the minimum distance to a large number min_distance = float('inf') # Iterate through combinations of two different landmarks n = len(nums) for i in range(n): for j in range(i+1, n): distance = nums[i] + nums[i] + nums[j] + nums[j] # 2 * nums[i] + 2 * nums[j] if distance < min_distance: min_distance = distance return min_distance"},{"question":"from typing import List def min_possible_price(prices: List[int]) -> int: Returns the minimum price he should sell to maximize his profit while maintaining the total sum of prices by increasing and decreasing prices of consecutive boxes respectively. >>> min_possible_price([4, 2, 6]) == 2 >>> min_possible_price([]) == 0 >>> min_possible_price([5]) == 5 >>> min_possible_price([3, 3, 3, 3]) == 3 >>> min_possible_price([9, 7, 2, 10, 5]) == 2 pass","solution":"def min_possible_price(prices): Returns the minimum price he should sell to maximize his profit while maintaining the total sum of prices by increasing and decreasing prices of consecutive boxes respectively. sum_prices = sum(prices) n = len(prices) if n == 0: return 0 min_price = float('inf') # Let's assume the price of the ith box to find the minimum possible price across all boxes for price in prices: min_price = min(min_price, price) # This min_price ensures that no box is priced lower than this return min_price"},{"question":"def find_substrings_in_words(words, word, k): Returns all substrings of \`word\` that are present as whole elements in \`words\` and have a minimum length of \`k\`. Parameters: words (list): A list of strings. word (str): The word to find substrings in. k (int): The minimum length of substrings. Returns: list: Sorted list of substrings found in \`words\`. >>> find_substrings_in_words([\\"apple\\", \\"banana\\", \\"car\\", \\"dog\\", \\"elephant\\"], \\"banana\\", 3) [\\"banana\\"] >>> find_substrings_in_words([\\"ban\\", \\"ana\\", \\"nan\\"], \\"banana\\", 3) [\\"ban\\", \\"ana\\", \\"nan\\", \\"ana\\"] >>> find_substrings_in_words([\\"apple\\", \\"car\\", \\"dog\\"], \\"banana\\", 3) [] >>> find_substrings_in_words([\\"ap\\", \\"le\\"], \\"apple\\", 2) [\\"ap\\", \\"le\\"] >>> find_substrings_in_words([\\"a\\", \\"b\\", \\"c\\"], \\"abc\\", 1) [\\"a\\", \\"b\\", \\"c\\"] >>> find_substrings_in_words([\\"ran\\", \\"dom\\", \\"andom\\"], \\"random\\", 4) [\\"andom\\"] >>> find_substrings_in_words([\\"ana\\", \\"nan\\"], \\"banana\\", 3) [\\"ana\\", \\"nan\\", \\"ana\\"]","solution":"def find_substrings_in_words(words, word, k): Returns all substrings of \`word\` that are present as whole elements in \`words\` and have a minimum length of \`k\`. Parameters: words (list): A list of strings. word (str): The word to find substrings in. k (int): The minimum length of substrings. Returns: list: Sorted list of substrings found in \`words\`. result = [] len_word = len(word) word_set = set(words) for start in range(len_word): for end in range(start + k, len_word + 1): substring = word[start:end] if substring in word_set: result.append(substring) return result"},{"question":"def maximize_min_num(nums: list, s: int) -> int: Returns the maximum possible value of the minimum number after performing the operation any number of times. You are given an array of integers \`nums\` and an integer \`s\`. You can perform the following operation any number of times: choose an index \`i\` and replace \`nums[i]\` with the sum \`nums[i] + nums[j]\` for any \`j\` where \`0 <= j < nums.length\` and \`j != i\`. Your goal is to maximize the minimum number in the array. Return the maximum possible value of the minimum number after performing any number of operations. >>> maximize_min_num([5], 0) 5 >>> maximize_min_num([3, 3, 3], 0) 3 >>> maximize_min_num([1, 2, 3, 4, 5], 0) 3 >>> maximize_min_num([4, 9, 2, 3, 8], 0) 5 >>> maximize_min_num([0, 0, 0, 0], 0) 0 >>> maximize_min_num([-1, -5, -3], 0) -3 >>> maximize_min_num([10, -10, 20, -20], 0) 0","solution":"def maximize_min_num(nums: list, s: int) -> int: Returns the maximum possible value of the minimum number after performing the operation any number of times. total_sum = sum(nums) n = len(nums) return total_sum // n"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: Adds two numbers represented by linked lists in reverse order and returns the sum as a linked list. >>> l1 = build_linked_list([2, 4, 3]) >>> l2 = build_linked_list([5, 6, 4]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [7, 0, 8] >>> l1 = build_linked_list([9, 9, 9]) >>> l2 = build_linked_list([9, 9, 9]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [8, 9, 9, 1] >>> l1 = build_linked_list([1, 8]) >>> l2 = build_linked_list([0]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [1, 8] >>> l1 = build_linked_list([1]) >>> l2 = build_linked_list([9, 9]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [0, 0, 1] >>> l1 = build_linked_list([0]) >>> l2 = build_linked_list([0]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [0] >>> l1 = build_linked_list([5]) >>> l2 = build_linked_list([0]) >>> result = addTwoNumbers(l1, l2) >>> linked_list_to_list(result) [5] pass # implement the function here","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists in reverse order and returns the sum as a linked list. dummy = ListNode(0) current = dummy carry = 0 while l1 is not None or l2 is not None: x = l1.val if l1 is not None else 0 y = l2.val if l2 is not None else 0 total = carry + x + y carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next if carry > 0: current.next = ListNode(carry) return dummy.next"},{"question":"def find_pairs(nums: List[int], target: int) -> List[Tuple[int, int]]: Finds pairs of integers in the array such that their sum is equal to target. Parameters: nums (list of int): The array of integers. target (int): The target sum. Returns: list of tuple: A list of pairs (tuples) that sum up to the target. >>> find_pairs([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_pairs([1, 2, 3], 7) [] >>> find_pairs([-3, -1, 0, 1, 2, 3], 0) [(-3, 3), (-1, 1)] >>> find_pairs([], 4) [] >>> find_pairs([4], 4) [] >>> find_pairs([1, 1, 2, 2, 3, 3], 4) [(1, 3), (2, 2)]","solution":"def find_pairs(nums, target): Finds pairs of integers in the array such that their sum is equal to target. Parameters: nums (list of int): The array of integers. target (int): The target sum. Returns: list of tuple: A list of pairs (tuples) that sum up to the target. seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pair = tuple(sorted((num, complement))) pairs.add(pair) seen.add(num) return list(pairs)"},{"question":"def two_sum(nums, target): Find two distinct indices such that nums[i] + nums[j] equals target. :param nums: List[int], list of integers :param target: int, target sum :return: List[int], indices of the two numbers such that they add up to target >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([3, 3], 6) [0, 1] >>> two_sum([1, 2, 3, 4, 5], 10) [] >>> two_sum([], 5) [] >>> two_sum([1, 2, 3], 5) [1, 2] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([1, 5, 3, 6, 8], 11) [1, 3]","solution":"def two_sum(nums, target): Find two distinct indices such that nums[i] + nums[j] equals target. :param nums: List[int], list of integers :param target: int, target sum :return: List[int], indices of the two numbers such that they add up to target num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def word_break(s: str, wordDict: List[str]) -> bool: Returns whether the string 's' can be segmented into a space-separated sequence of one or more dictionary words. >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> word_break(\\"apple\\", [\\"apple\\"]) True >>> word_break(\\"appleapple\\", [\\"apple\\"]) True >>> word_break(\\"cars\\", [\\"car\\", \\"ca\\", \\"rs\\"]) True >>> word_break(\\"leetcod\\", [\\"leet\\", \\"code\\"]) False >>> word_break(\\"\\", [\\"cat\\", \\"dog\\"]) True >>> word_break(\\"a\\", []) False","solution":"def word_break(s, wordDict): Returns whether the string 's' can be segmented into a space-separated sequence of one or more dictionary words. word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # Empty substring can be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[-1]"},{"question":"def unobstructed_skyscrapers(arr): Returns an array representing the indices of the skyscrapers that have an unobstructed view to the right. >>> unobstructed_skyscrapers([1, 2, 3, 4]) [3] >>> unobstructed_skyscrapers([4, 3, 2, 1]) [0, 1, 2, 3] >>> unobstructed_skyscrapers([2, 3, 1, 4, 5, 3]) [4, 5] >>> unobstructed_skyscrapers([10]) [0] >>> unobstructed_skyscrapers([]) [] >>> unobstructed_skyscrapers([3, 3, 3, 3]) [3] >>> unobstructed_skyscrapers([4, 2, 3, 1, 5]) [4]","solution":"def unobstructed_skyscrapers(arr): Returns an array representing the indices of the skyscrapers that have an unobstructed view to the right. n = len(arr) if n == 0: return [] result = [] max_height = -1 for i in range(n-1, -1, -1): if arr[i] > max_height: result.append(i) max_height = arr[i] result.reverse() return result"},{"question":"def valid_palindrome(s: str) -> bool: Returns true if the input string can be made into a valid palindrome by removing at most one character. >>> valid_palindrome(\\"aba\\") == True >>> valid_palindrome(\\"racecar\\") == True >>> valid_palindrome(\\"abca\\") == True >>> valid_palindrome(\\"abc\\") == False >>> valid_palindrome(\\"\\") == True >>> valid_palindrome(\\"a\\") == True >>> valid_palindrome(\\"ab\\") == True >>> valid_palindrome(\\"abcbca\\") == True","solution":"def valid_palindrome(s): Returns true if the input string can be made into a valid palindrome by removing at most one character. def is_palindrome(left, right, s): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try skipping either the left or the right character return is_palindrome(left + 1, right, s) or is_palindrome(left, right - 1, s) left += 1 right -= 1 return True"},{"question":"def length_of_shortest_string_after_removal(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, return the length of the shortest string that can be obtained by removing all occurrences of one character. If the string contains only one unique character, return 0. >>> length_of_shortest_string_after_removal(\\"abac\\") 2 >>> length_of_shortest_string_after_removal(\\"aabbcc\\") 4 >>> length_of_shortest_string_after_removal(\\"abcd\\") 3 >>> length_of_shortest_string_after_removal(\\"aaaa\\") 0 >>> length_of_shortest_string_after_removal(\\"a\\") 0 >>> length_of_shortest_string_after_removal(\\"abcde\\") 4 >>> length_of_shortest_string_after_removal(\\"\\") 0 >>> length_of_shortest_string_after_removal(\\"aabaca\\") 2 >>> length_of_shortest_string_after_removal(\\"abbac\\") 3 >>> length_of_shortest_string_after_removal(\\"ababab\\") 3 >>> length_of_shortest_string_after_removal(\\"a\\"*1000 + \\"b\\"*500) 500 >>> length_of_shortest_string_after_removal(\\"a\\"*999 + \\"b\\"*500) 500","solution":"def length_of_shortest_string_after_removal(s): This function calculates the length of the shortest string that can be obtained by removing all occurrences of one character. If the string contains only one unique character, it returns 0. import collections counter = collections.Counter(s) # If there's only one unique character, the resulting length is 0 if len(counter) == 1: return 0 # Calculate the minimum string length after removing each unique character min_length = len(s) for char in counter: char_length = len(s) - counter[char] min_length = min(min_length, char_length) return min_length"},{"question":"def min_trucks_needed(capacities: List[int], packages: List[int]) -> int: Find the minimum number of trucks needed to transport all the packages. If it is not possible to transport all the packages with the available trucks, return -1. :param capacities: List of integers representing the capacities of the trucks. :param packages: List of integers representing the weights of the packages. :return: Minimum number of trucks needed, or -1 if not possible. >>> min_trucks_needed([10, 8, 7], [5, 5, 5]) 2 >>> min_trucks_needed([5], [6, 4]) -1 >>> min_trucks_needed([10, 10], [7, 3, 8, 2]) 2 >>> min_trucks_needed([20], [5, 5, 5, 5]) 1 >>> min_trucks_needed([10, 10, 10], []) 0 >>> min_trucks_needed([8, 5, 5], [5, 3, 5, 2, 1]) 3 >>> min_trucks_needed([15, 10, 7], [7, 8, 5, 1]) 2","solution":"def min_trucks_needed(capacities, packages): Finds the minimum number of trucks needed to transport all packages. If it is not possible to transport all the packages with the available trucks, returns -1. :param capacities: List of integers representing the capacities of the trucks. :param packages: List of integers representing the weights of the packages. :return: Minimum number of trucks needed, or -1 if not possible. capacities.sort(reverse=True) packages.sort(reverse=True) truck_count = 0 package_index = 0 used_capacity = [0] * len(capacities) while package_index < len(packages): placed = False for i in range(len(capacities)): if used_capacity[i] + packages[package_index] <= capacities[i]: used_capacity[i] += packages[package_index] placed = True break if not placed: return -1 truck_count = max(truck_count, i + 1) package_index += 1 return truck_count"},{"question":"def max_substrings(s: str) -> int: Returns the maximum number of substrings consisting of exactly one 'a', one 'b', and one 'c'. >>> max_substrings(\\"aaa\\") == 0 >>> max_substrings(\\"bbb\\") == 0 >>> max_substrings(\\"ccc\\") == 0 >>> max_substrings(\\"aabb\\") == 0 >>> max_substrings(\\"abc\\") == 1 >>> max_substrings(\\"cab\\") == 1 >>> max_substrings(\\"bca\\") == 1 >>> max_substrings(\\"aabbcc\\") == 2 >>> max_substrings(\\"abcabc\\") == 2 >>> max_substrings(\\"aaabbbccc\\") == 3 >>> max_substrings(\\"abababccc\\") == 3 >>> max_substrings(\\"abacbcab\\") == 2 >>> max_substrings(\\"abcabcabc\\") == 3 >>> max_substrings(\\"abccbaabc\\") == 3 >>> max_substrings(\\"\\") == 0","solution":"def max_substrings(s): Returns the maximum number of substrings consisting of exactly one 'a', one 'b', and one 'c'. count_a = count_b = count_c = 0 substrings_count = 0 for char in s: if char == 'a': count_a += 1 elif char == 'b': count_b += 1 elif char == 'c': count_c += 1 # If we have at least one of each character, we can form a substring if count_a > 0 and count_b > 0 and count_c > 0: substrings_count += 1 count_a -= 1 count_b -= 1 count_c -= 1 return substrings_count"},{"question":"def can_reorganize(s: str) -> bool: Determine if it is possible to rearrange the string \`s\` such that no two adjacent characters are the same. >>> can_reorganize(\\"aab\\") True >>> can_reorganize(\\"aaab\\") False >>> can_reorganize(\\"abcdefg\\") True >>> can_reorganize(\\"aabbcc\\") True >>> can_reorganize(\\"a\\") True >>> can_reorganize(\\"bbbbbb\\") False","solution":"def can_reorganize(s): Returns True if the string can be reorganized such that no two adjacent characters are the same. Otherwise, returns False. from collections import Counter # Count frequency of each character count = Counter(s) max_freq = max(count.values()) # Check if the most frequent character can fit without adjacent duplicates return max_freq <= (len(s) + 1) // 2"},{"question":"from typing import List def max_visible_buildings(heights: List[int]) -> int: Returns the maximum number of distinct buildings you can see when looking from the left (i.e., from index 0 to the end of the list). >>> max_visible_buildings([1, 2, 3, 4, 5]) 5 >>> max_visible_buildings([3, 3, 3, 3, 3]) 1 >>> max_visible_buildings([2, 1, 4, 3, 6, 5, 7]) 4 >>> max_visible_buildings([1]) 1 >>> max_visible_buildings([5, 4, 3, 2, 1]) 1 >>> max_visible_buildings([]) 0","solution":"def max_visible_buildings(heights): Returns the maximum number of distinct buildings you can see when looking from the left (i.e., from index 0 to the end of the list). max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"def silhouette(heights: List[int]) -> List[int]: Returns the silhouette of the skyline represented by the list of building heights. Args: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of integers representing the silhouette of the skyline. Examples: >>> silhouette([]) [] >>> silhouette([5]) [5] >>> silhouette([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> silhouette([5, 4, 3, 2, 1]) [5, 5, 5, 5, 5] >>> silhouette([3, 1, 4, 1, 5, 9, 2, 6, 5]) [3, 3, 4, 4, 5, 9, 9, 9, 9] >>> silhouette([2, 2, 2, 2, 2]) [2, 2, 2, 2, 2] >>> silhouette([1, 3, 1, 3, 1]) [1, 3, 3, 3, 3]","solution":"def silhouette(heights): Returns the silhouette of the skyline represented by the list of building heights. Args: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of integers representing the silhouette of the skyline. if not heights: return [] silhouette = [heights[0]] for i in range(1, len(heights)): silhouette.append(max(silhouette[-1], heights[i])) return silhouette"},{"question":"def restore_string(s: str, indices: List[int]) -> str: Restores the original string based on the given indices. Args: s (str): The shuffled string. indices (list): List of indices representing the original positions of the characters. Returns: str: The original string. >>> restore_string(\\"codeleet\\", [4, 5, 6, 7, 0, 2, 1, 3]) 'leetcode' >>> restore_string(\\"a\\", [0]) 'a' >>> restore_string(\\"\\", []) '' >>> restore_string(\\"abc\\", [2, 1, 0]) 'cba' >>> restore_string(\\"aaaa\\", [1, 3, 0, 2]) 'aaaa'","solution":"def restore_string(s, indices): Restores the original string based on the given indices. Args: s (str): The shuffled string. indices (list): List of indices representing the original positions of the characters. Returns: str: The original string. # Initialize a list of the same length as s with placeholders restored = [''] * len(s) # Place each character in its original position based on the indices array for char, idx in zip(s, indices): restored[idx] = char # Join the list into a single string and return return ''.join(restored)"},{"question":"def next_greater_element(nums1, nums2): Finds the next greater number for each element in nums1 by using the corresponding order from nums2. If no greater number exists, -1 is returned for that number. >>> next_greater_element([4, 1, 2], [1, 3, 4, 2]) [-1, 3, -1] >>> next_greater_element([2, 4], [1, 2, 3, 4]) [3, -1] >>> next_greater_element([4, 3], [4, 3, 2, 1]) [-1, -1] >>> next_greater_element([1], [1, 2, 3, 4]) [2] >>> next_greater_element([1, 3, 5], [5, 3, 1]) [-1, -1, -1]","solution":"def next_greater_element(nums1, nums2): Finds the next greater number for each element in nums1 by using the corresponding order from nums2. If no greater number exists, -1 is returned for that number. next_greater = {} stack = [] # Store the next greater element for each number in nums2 for num in nums2: while stack and stack[-1] < num: next_greater[stack.pop()] = num stack.append(num) # For all the remaining elements in the stack, there is no next greater element for num in stack: next_greater[num] = -1 # Prepare the result for nums1 based on computed next greater elements result = [next_greater.get(num, -1) for num in nums1] return result"},{"question":"def move_elements_to_end(arr, k): Moves the first k elements of the array to the end, maintaining order and without using extra space. Args: arr (list of int): The input array of integers. k (int): The number of elements to move. Returns: list of int: The modified array with the first k elements moved to the end. >>> move_elements_to_end([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> move_elements_to_end([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> move_elements_to_end([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> move_elements_to_end([1, 2, 3, 4, 5], 1) [2, 3, 4, 5, 1] >>> move_elements_to_end([1, 2, 3, 4, 5], -1) [1, 2, 3, 4, 5] >>> move_elements_to_end([], 2) [] >>> move_elements_to_end([1], 1) [1] >>> move_elements_to_end([1, 2, 3], 3) [1, 2, 3]","solution":"def move_elements_to_end(arr, k): Moves the first k elements of the array to the end, maintaining order and without using extra space. Args: arr (list of int): The input array of integers. k (int): The number of elements to move. Returns: list of int: The modified array with the first k elements moved to the end. if k <= 0 or k >= len(arr): return arr # No change if k is out of lower/upper bounds return arr[k:] + arr[:k]"},{"question":"def min_possible_value(arr: list[int]) -> int: Determine the minimum possible value of the resulting single element after performing operations on the array where you replace two adjacent elements with their sum as many times as you want. >>> min_possible_value([5]) 5 >>> min_possible_value([2, 3]) 5 >>> min_possible_value([1, 2, 3, 4]) 10 >>> min_possible_value([0, 0, 0]) 0 >>> min_possible_value([-1, -2, -3]) -6 >>> min_possible_value([-1, 2, -3, 4]) 2 >>> min_possible_value([1] * 1000) 1000","solution":"def min_possible_value(arr): Returns the minimum possible value of the resulting single element after performing the specified operation on the array. Parameters: arr (list of int): The input array of integers. Returns: int: The minimum possible value of the resulting single element. return sum(arr)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head: ListNode, k: int) -> ListNode: Rotate the linked list to the right by k places. >>> linkedlist_to_list(rotateRight(list_to_linkedlist([1, 2, 3, 4, 5]), 2)) [4, 5, 1, 2, 3] >>> linkedlist_to_list(rotateRight(list_to_linkedlist([0, 1, 2]), 4)) [2, 0, 1] >>> linkedlist_to_list(rotateRight(list_to_linkedlist([]), 1)) [] >>> linkedlist_to_list(rotateRight(list_to_linkedlist([1]), 1)) [1] >>> linkedlist_to_list(rotateRight(list_to_linkedlist([1, 2]), 3)) [2, 1] pass def list_to_linkedlist(lst): if not lst: return None head = ListNode(lst[0]) current = head for val in lst[1:]: current.next = ListNode(val) current = current.next return head def linkedlist_to_list(head): result = [] current = head while current: result.append(current.val) current = current.next return result","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotateRight(head, k): if not head or not head.next or k == 0: return head # Determine the length of the list and the last node length = 1 current = head while current.next: current = current.next length += 1 # Connect the last node with the head to make it circular current.next = head # Find the new head and the new tail k = k % length steps_to_new_head = length - k new_tail = head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next new_head = new_tail.next new_tail.next = None return new_head"},{"question":"def split_array(nums: List[int], k: int) -> int: Given an array of integers \`nums\` and an integer \`k\`, split the array into exactly \`k\` non-empty contiguous subarrays such that the sum of the largest subarray sum among them is the minimum possible. Return this minimum possible value. >>> split_array([7,2,5,10,8], 2) == 18 >>> split_array([1,2,3,4,5], 5) == 5 >>> split_array([1,2,3,4,5], 1) == 15 >>> split_array([1,4,4], 3) == 4 >>> split_array([1000000, 1000000, 1000000], 2) == 2000000 >>> split_array([1,2,0,3,4], 3) == 4 \`","solution":"def split_array(nums, k): def can_split(max_sum): current_sum = 0 subarray_count = 1 for num in nums: if current_sum + num > max_sum: current_sum = num subarray_count += 1 if subarray_count > k: return False else: current_sum += num return True left, right = max(nums), sum(nums) while left < right: mid = (left + right) // 2 if can_split(mid): right = mid else: left = mid + 1 return left"},{"question":"def minimized_adjacent_difference(nums): Rearrange the integers in the list \`nums\` in such a way that the sum of the absolute differences between every two adjacent integers is minimized. >>> minimized_adjacent_difference([4, 2, 1, 3]) [1, 2, 3, 4] >>> minimized_adjacent_difference([4, 1, 2, 2, 3]) [1, 2, 2, 3, 4] pass def test_minimized_adjacent_difference(): assert minimized_adjacent_difference([1, 2, 3, 4]) == [1, 2, 3, 4] assert minimized_adjacent_difference([4, 2, 1, 3]) == [1, 2, 3, 4] assert minimized_adjacent_difference([4, 1, 2, 2, 3]) == [1, 2, 2, 3, 4] assert minimized_adjacent_difference([4, -1, 2, -2, 3]) == [-2, -1, 2, 3, 4] assert minimized_adjacent_difference([1]) == [1] assert minimized_adjacent_difference([]) == []","solution":"def minimized_adjacent_difference(nums): Returns a list of integers rearranged in such a way that the sum of the absolute differences between every two adjacent integers is minimized. return sorted(nums)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitCircularList(head): Split a circular linked list into two smaller circular linked lists of (almost) equal size. >>> values = [1, 2, 3, 4] >>> head = create_circular_linked_list(values) >>> head1, head2 = splitCircularList(head) >>> list_to_array(head1, 2) == [1, 2] True >>> list_to_array(head2, 2) == [3, 4] True >>> values = [1, 2, 3, 4, 5] >>> head = create_circular_linked_list(values) >>> head1, head2 = splitCircularList(head) >>> list_to_array(head1, 3) == [1, 2, 3] True >>> list_to_array(head2, 2) == [4, 5] True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def splitCircularList(head): if not head or head.next == head: # Handle edge cases where list is empty or only one node return head, None slow = fast = head # Find the middle point using slow and fast pointer approach while fast.next != head and fast.next.next != head: slow = slow.next fast = fast.next.next # If there are odd number of nodes, move fast pointer one step further if fast.next.next == head: fast = fast.next # head1 is the first part of the list head1 = head # head2 is the second part of the list head2 = slow.next # Break the list into two halves slow.next = head1 fast.next = head2 return head1, head2"},{"question":"def remove_empty_buckets(nums): Returns a list of integers in nums after removing all values that correspond to empty buckets (i.e., values that are zero). Args: nums (list): A list of integers where nums[i] is the number of elements in the ith bucket. Returns: list: A list of integers with empty buckets removed. pass def test_remove_empty_buckets_with_empty_buckets(): assert remove_empty_buckets([0, 1, 0, 2, 0, 3]) == [1, 2, 3] def test_remove_empty_buckets_with_no_empty_buckets(): assert remove_empty_buckets([1, 2, 3, 4]) == [1, 2, 3, 4] def test_remove_empty_buckets_with_all_empty_buckets(): assert remove_empty_buckets([0, 0, 0, 0]) == [] def test_remove_empty_buckets_with_mixed_values(): assert remove_empty_buckets([0, 5, 0, 0, 12, 0, 7]) == [5, 12, 7] def test_remove_empty_buckets_with_single_non_empty_bucket(): assert remove_empty_buckets([7]) == [7] def test_remove_empty_buckets_with_single_empty_bucket(): assert remove_empty_buckets([0]) == []","solution":"def remove_empty_buckets(nums): Returns a list of integers in nums after removing all values that correspond to empty buckets (i.e., values that are zero). Args: nums (list): A list of integers where nums[i] is the number of elements in the ith bucket. Returns: list: A list of integers with empty buckets removed. return [num for num in nums if num != 0]"},{"question":"from typing import List def second_minimum_spanning_tree(n: int, edges: List[List[int]]) -> int: Given an undirected graph with n vertices labeled from 0 to n-1, represented by a 2D array edges where edges[i] = [u, v, w] denotes an edge between nodes u and v with weight w, find the weight of the second minimum spanning tree (SMST). A second minimum spanning tree (SMST) is a spanning tree that has the smallest weight greater than the weight of the minimum spanning tree (MST). If the graph does not have a second minimum spanning tree, return -1. >>> second_minimum_spanning_tree(3, [[0, 1, 1], [1, 2, 1], [0, 2, 2]]) == 3 >>> second_minimum_spanning_tree(2, [[0, 1, 1]]) == -1 >>> second_minimum_spanning_tree(4, [[0, 1, 1], [1, 2, 1], [0, 2, 2]]) == -1","solution":"import heapq from collections import defaultdict def find_parent(parents, node): if parents[node] == node: return node parents[node] = find_parent(parents, parents[node]) return parents[node] def union(parents, ranks, node1, node2): root1 = find_parent(parents, node1) root2 = find_parent(parents, node2) if root1 != root2: if ranks[root1] > ranks[root2]: parents[root2] = root1 elif ranks[root1] < ranks[root2]: parents[root1] = root2 else: parents[root2] = root1 ranks[root1] += 1 def kruskal(n, edges, skip_edge_index=-1): parents = [i for i in range(n)] ranks = [0] * n mst_weight = 0 edge_count = 0 for i, (u, v, w) in enumerate(edges): if i == skip_edge_index: continue if find_parent(parents, u) != find_parent(parents, v): mst_weight += w union(parents, ranks, u, v) edge_count += 1 if edge_count == n - 1: return mst_weight else: return float('inf') def second_minimum_spanning_tree(n, edges): edges.sort(key=lambda x: x[2]) mst_weight = kruskal(n, edges) if mst_weight == float('inf'): return -1 smst_weight = float('inf') for i in range(len(edges)): weight = kruskal(n, edges, skip_edge_index=i) if weight > mst_weight: smst_weight = min(smst_weight, weight) return smst_weight if smst_weight != float('inf') else -1"},{"question":"def findMedianSortedArrays(nums1: List[int], nums2: List[int]) -> float: You are given two sorted integer arrays \`nums1\` and \`nums2\`, each of size \`m\` and \`n\` respectively. Return the **median** of the two sorted arrays. The overall run-time complexity should be \`O(log(min(m,n)))\`. Note: The median of a sorted array of size \`k\` is defined as the middle element if \`k\` is odd, and the average of the two middle elements if \`k\` is even (\`(a+b)/2\` where \`a\` and \`b\` are the two middle elements). >>> findMedianSortedArrays([1, 3], [2]) 2 >>> findMedianSortedArrays([1, 2], [3, 4]) 2.5 >>> findMedianSortedArrays([], [1]) 1 >>> findMedianSortedArrays([2], []) 2 >>> findMedianSortedArrays([0, 0], [0, 0]) 0 >>> findMedianSortedArrays([1, 2], []) 1.5 >>> findMedianSortedArrays([2], [1, 3]) 2","solution":"def findMedianSortedArrays(nums1, nums2): def merge_arrays(arr1, arr2): merged = [] i, j = 0, 0 while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged.append(arr1[i]) i += 1 else: merged.append(arr2[j]) j += 1 merged.extend(arr1[i:]) merged.extend(arr2[j:]) return merged # Merge the two sorted arrays merged_array = merge_arrays(nums1, nums2) length = len(merged_array) # Find the median if length % 2 == 1: return merged_array[length // 2] else: return (merged_array[length // 2 - 1] + merged_array[length // 2]) / 2"},{"question":"def max_path_sum(grid): Given a matrix \`grid\` consisting of \`m\` rows and \`n\` columns, where each cell has a non-negative integer, returns the maximum possible sum of numbers that can be collected from top to bottom. The ball can move directly down, or diagonally down-left or down-right. >>> max_path_sum([ ... [5, 1], ... [4, 6] ... ]) == 11 >>> max_path_sum([ ... [5, 1, 2], ... [4, 8, 3], ... [1, 9, 5] ... ]) == 22 >>> max_path_sum([[2, 3, 1]]) == 3 >>> max_path_sum([ ... [2], ... [3], ... [4] ... ]) == 9 >>> max_path_sum([]) == 0 >>> max_path_sum([[]]) == 0 >>> max_path_sum([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 3","solution":"def max_path_sum(grid): Given a matrix \`grid\`, returns the maximum sum that can be collected from top to bottom. The ball can move directly down, or diagonally down-left or down-right. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Initialize dp array to store the max sum at each cell dp = [[0] * n for _ in range(m)] # Copy the first row as starting points for j in range(n): dp[0][j] = grid[0][j] for i in range(1, m): for j in range(n): max_score = dp[i-1][j] if j > 0: max_score = max(max_score, dp[i-1][j-1]) if j < n - 1: max_score = max(max_score, dp[i-1][j+1]) dp[i][j] = grid[i][j] + max_score return max(dp[-1])"},{"question":"def max_sum_subarray_of_length_k(nums: List[int], k: int) -> int: Returns the maximum sum of a contiguous subarray of length k. If k is greater than the length of the array, returns 0. >>> max_sum_subarray_of_length_k([1, 2, 3, 4, 5], 3) == 12 >>> max_sum_subarray_of_length_k([1, 2, 3], 4) == 0 >>> max_sum_subarray_of_length_k([5], 1) == 5 >>> max_sum_subarray_of_length_k([-1, -2, -3, -4, -5], 2) == -3 >>> max_sum_subarray_of_length_k([1, -2, 3, 4, -1, 2, 1, -5, 4], 5) == 9 >>> max_sum_subarray_of_length_k([4], 1) == 4 >>> max_sum_subarray_of_length_k([], 1) == 0 >>> max_sum_subarray_of_length_k([1, 2, 3, 4, 5], 5) == 15","solution":"def max_sum_subarray_of_length_k(nums, k): Returns the maximum sum of a contiguous subarray of length k. If k is greater than the length of the array, returns 0. n = len(nums) if k > n: return 0 # Calculate the sum of the first k elements max_sum = curr_sum = sum(nums[:k]) # Use a sliding window to find the maximum sum for subarrays of size k for i in range(k, n): curr_sum += nums[i] - nums[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"def max_candies(nums: List[int]) -> int: Returns the maximum number of candies that can be collected from the given jars without selecting adjacent jars. >>> max_candies([]) == 0 >>> max_candies([10]) == 10 >>> max_candies([5, 10]) == 10 >>> max_candies([2, 3, 2]) == 4 >>> max_candies([1, 2, 3, 1]) == 4 >>> max_candies([3, 2, 5, 10, 7]) == 15 >>> max_candies([5, 5, 5, 5, 5]) == 15 >>> max_candies([10, 1, 10, 1, 10]) == 30","solution":"def max_candies(nums): Returns the maximum number of candies that can be collected from the given jars without selecting adjacent jars. if not nums: return 0 if len(nums) == 1: return nums[0] include = nums[0] exclude = 0 for i in range(1, len(nums)): new_exclude = max(include, exclude) include = exclude + nums[i] exclude = new_exclude return max(include, exclude)"},{"question":"def max_number_of_pairs(nums: List[int], k: int) -> int: Given a list of \`n\` distinct integers representing participants' abilities and an integer \`k\`, returns the maximum number of pairs such that the sum of the abilities in each pair is equal to \`k\`. >>> max_number_of_pairs([1, 2, 3, 4], 5) 2 >>> max_number_of_pairs([3, 4, 2, 5, 7, 8, 1, 9], 10) 3 >>> max_number_of_pairs([1, 2, 3], 7) 0 >>> max_number_of_pairs([5, 5, 5, 5], 10) 2 >>> max_number_of_pairs([1, 5, 3, 6, 2, 4], 7) 3 >>> max_number_of_pairs([1], 2) 0 >>> max_number_of_pairs([5], 5) 0 >>> max_number_of_pairs([-1, 6, -3, 5, 3, -2, 2, 8], 5) 3","solution":"def max_number_of_pairs(nums, k): Given a list of \`n\` distinct integers representing participants' abilities and an integer \`k\`, returns the maximum number of pairs such that the sum of the abilities in each pair is equal to \`k\`. num_counter = {} for num in nums: if num in num_counter: num_counter[num] += 1 else: num_counter[num] = 1 pairs = 0 for num in list(num_counter): complement = k - num if complement in num_counter and num_counter[num] > 0 and num_counter[complement] > 0: if num == complement: pairs += num_counter[num] // 2 num_counter[num] = 0 else: min_count = min(num_counter[num], num_counter[complement]) pairs += min_count num_counter[num] -= min_count num_counter[complement] -= min_count return pairs"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: You are given a 2D grid \`grid\` of size \`m x n\` consisting of non-negative integers. You are initially positioned at cell \`(0, 0)\` and must move to cell \`(m-1, n-1)\` while accumulating the maximum sum of values of the cells you visit. You can only move either right or down from a cell. Return the maximum sum of values you can accumulate by the time you reach the cell \`(m-1, n-1)\`. >>> max_path_sum([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_path_sum([ ... [1, 2, 5], ... [3, 2, 1] ... ]) == 9 >>> max_path_sum([ ... [5] ... ]) == 5 >>> max_path_sum([]) == 0 >>> max_path_sum([[]]) == 0 >>> max_path_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29 >>> max_path_sum([ ... [1, 3], ... [2, 1] ... ]) == 5 # Your code here","solution":"def max_path_sum(grid): Returns the maximum path sum from top-left to bottom-right in a grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) # Create a dp array where dp[i][j] will store the maximum sum path to reach cell (i, j) dp = [[0] * n for _ in range(m)] dp[0][0] = grid[0][0] # Initialize the first column for i in range(1, m): dp[i][0] = dp[i - 1][0] + grid[i][0] # Initialize the first row for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill in the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[m - 1][n - 1]"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of any contiguous subarray. >>> max_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_sum([3]) == 3 >>> max_subarray_sum([-3]) == -3 >>> max_subarray_sum([]) == 0","solution":"def max_subarray_sum(nums): Returns the maximum sum of any contiguous subarray. Parameters: nums (List[int]): List of integers, either positive or negative. Returns: int: Maximum sum of any contiguous subarray. if not nums: return 0 max_so_far = nums[0] current_max = nums[0] for num in nums[1:]: current_max = max(num, current_max + num) max_so_far = max(max_so_far, current_max) return max_so_far"},{"question":"def findPalindromePairs(words: List[str]) -> List[Tuple[int, int]]: Given a list of unique words, find all pairs of distinct indices (i, j) such that the concatenation of the two words words[i] + words[j] is a palindrome. >>> findPalindromePairs([\\"abc\\", \\"def\\", \\"ghi\\"]) [] >>> findPalindromePairs([\\"bat\\", \\"tab\\", \\"cat\\"]) [(0, 1), (1, 0)] >>> findPalindromePairs([\\"abcd\\", \\"dcba\\", \\"lls\\", \\"s\\", \\"sssll\\"]) [(0, 1), (1, 0), (2, 4), (3, 2)] >>> findPalindromePairs([\\"\\", \\"abc\\", \\"cba\\"]) [(1, 2), (2, 1)] >>> findPalindromePairs([\\"xyz\\", \\"pqr\\", \\"abc\\"]) [] >>> findPalindromePairs([\\"a\\", \\"\\"]) [(0, 1), (1, 0)]","solution":"def is_palindrome(word): Helper function to check if a word is a palindrome. return word == word[::-1] def findPalindromePairs(words): Returns a list of all pairs of distinct indices (i, j) such that the concatenation of words[i] + words[j] is a palindrome. palindrome_pairs = [] for i in range(len(words)): for j in range(len(words)): if i != j and is_palindrome(words[i] + words[j]): palindrome_pairs.append((i, j)) return palindrome_pairs"},{"question":"def find_three_sum(nums, target): You are given an integer array \`nums\` containing \`n\` unique elements, and an integer \`target\`. Your task is to determine if there exists three distinct elements in \`nums\` whose sum is exactly equal to \`target\`. If such elements exist, return a list containing these three numbers. If there are multiple valid triplets, return any one of them. If no such triplet exists, return an empty list. >>> find_three_sum([1, 2, 3, 4, 5, 6], 10) [1, 3, 6] >>> find_three_sum([1, 2, 3, 4, 5, 6], 20) [] >>> find_three_sum([-1, 0, 1, 2, -1, -4], 0) in [[-1, -1, 2], [-1, 0, 1]] True >>> find_three_sum([0, 0, 0, 0], 0) [0, 0, 0] >>> find_three_sum([-5, -4, -3, -2, -1], -10) [-5, -4, -1]","solution":"def find_three_sum(nums, target): Find three distinct elements in nums whose sum equals target. Returns a list containing these three numbers, or an empty list if no such numbers exist. nums.sort() n = len(nums) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return [nums[i], nums[left], nums[right]] elif current_sum < target: left += 1 else: right -= 1 return []"},{"question":"def count_unique_integers(s: str) -> int: Returns the count of unique integers present in the string s. >>> count_unique_integers(\\"a123bc34d8ef34\\") 3 >>> count_unique_integers(\\"abc\\") 0 >>> count_unique_integers(\\"a00123bc034d08ef034\\") 3 >>> count_unique_integers(\\"1a2b3c4d5e\\") 5 >>> count_unique_integers(\\"123a123b123c\\") 1 >>> count_unique_integers(\\"123abc456\\") 2 # Your implementation here","solution":"import re def count_unique_integers(s): Returns the count of unique integers present in the string s. # Find all numbers in the string using regular expressions numbers = re.findall(r'd+', s) # Convert each number to an integer to remove leading zeros and find unique ones unique_numbers = set(map(int, numbers)) return len(unique_numbers)"},{"question":"def find_substring_indices(s: str, words: List[str]) -> List[int]: Find all starting indices in the string \`s\` that are the starting points of substrings in \`s\` that can be rearranged to form words in \`dict\`. Each word must be matched exactly once, and a substring can cover multiple words from \`dict\`. The order of characters within each word can be rearranged, but the overall order of words in \`s\` must be maintained. >>> find_substring_indices(\\"catdogdogcat\\", [\\"cat\\", \\"dog\\"]) [0, 6] >>> find_substring_indices(\\"catdogdogcat\\", [\\"mouse\\", \\"elephant\\"]) [] >>> find_substring_indices(\\"\\", [\\"cat\\", \\"dog\\"]) [] >>> find_substring_indices(\\"catdogdogcat\\", []) [] >>> find_substring_indices(\\"catdogdogcat\\", [\\"cat\\"]) [0, 9] >>> find_substring_indices(\\"catdogcatdogcatdog\\", [\\"cat\\", \\"dog\\", \\"cat\\"]) [0, 6] >>> find_substring_indices(\\"catcatcatcat\\", [\\"cat\\", \\"cat\\"]) [0, 3, 6]","solution":"def find_substring_indices(s, words): from collections import Counter if not s or not words: return [] word_len = len(words[0]) num_words = len(words) sub_len = word_len * num_words word_count = Counter(words) def is_valid(start): seen = Counter() for i in range(start, start + sub_len, word_len): word = s[i:i + word_len] if word not in word_count: return False seen[word] += 1 if seen[word] > word_count[word]: return False return True return [i for i in range(len(s) - sub_len + 1) if is_valid(i)]"},{"question":"def num_unique_emails(emails: List[str]) -> int: Returns the total number of unique email addresses. When considering uniqueness, treat email addresses as case-insensitive, and ignore any characters after a '+' in the local part (before the '@') as well as all periods '.' within the local part. >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.e.mail+bob.cathy@leetcode.com\\", \\"testemail+david@lee.tcode.com\\"]) 2 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"Test.Email+alex@LeetCode.Com\\", \\"testemail@leetcode.com\\"]) 1 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.email+alex@yahoo.com\\", \\"testemail@gmail.com\\"]) 3 >>> num_unique_emails([\\"test.email@leetcode.com\\", \\"test.email@leetcode.com\\"]) 1 >>> num_unique_emails([\\"test.email+alex@leetcode.com\\", \\"test.email+alex@lee.t.code.com\\", \\"tes..t.e.mail+b.ob.c.athy@lee.t.code.com\\", \\"testemail@lee.t.code.com\\"]) 2","solution":"def num_unique_emails(emails): Returns the total number of unique email addresses. :param emails: List of email addresses as strings :return: Integer count of unique email addresses unique_emails = set() for email in emails: local, domain = email.split('@') local = local.split('+')[0].replace('.', '') unique_emails.add(local.lower() + '@' + domain.lower()) return len(unique_emails)"},{"question":"def max_coin_groups(nums: List[int], k: int) -> int: Returns the maximum number of groups of exactly 'k' coins each that can be formed from the 'nums' array. :param nums: List[int] - Array of integers representing the number of coins in each pile. :param k: int - The exact number of coins each group should have. :return: int - The maximum number of groups that can be formed, or -1 if it is not possible. >>> max_coin_groups([5, 10, 15], 5) == 6 >>> max_coin_groups([4, 4, 4], 4) == 3 >>> max_coin_groups([7, 8, 9], 3) == 8 >>> max_coin_groups([7, 8, 9], 5) == -1 >>> max_coin_groups([10], 10) == 1 >>> max_coin_groups([10], 3) == -1 >>> max_coin_groups([0, 0, 0], 1) == 0 >>> max_coin_groups([100, 50, 200], 25) == 14 >>> max_coin_groups([1024, 512, 2048], 64) == 56","solution":"def max_coin_groups(nums, k): Returns the maximum number of groups of exactly 'k' coins each that can be formed from the 'nums' array. :param nums: List[int] - Array of integers representing the number of coins in each pile. :param k: int - The exact number of coins each group should have. :return: int - The maximum number of groups that can be formed, or -1 if it is not possible. total_coins = sum(nums) if total_coins % k != 0: return -1 return total_coins // k"},{"question":"def count_pairs(height: List[int]) -> int: Returns the number of pairs (i, j) such that i < j and height[i] > height[j]. >>> count_pairs([4, 3, 2, 1]) 6 >>> count_pairs([1, 2, 3, 4]) 0 >>> count_pairs([3, 1, 4, 2]) 3 from solution import count_pairs def test_count_pairs_example(): assert count_pairs([4, 3, 2, 1]) == 6 # All pairs (i, j)omg_buzzer_off]()\`. buzzer_off = False return buzzer_off from solution import omg_buzzer_off def test_omg_buzzer_off(): assert omg_buzzer_off() == False","solution":"def count_pairs(height): Returns the number of pairs (i, j) such that i < j and height[i] > height[j]. count = 0 n = len(height) for i in range(n): for j in range(i + 1, n): if height[i] > height[j]: count += 1 return count"},{"question":"def longest_ones(bits: List[int]) -> int: Returns the length of the longest contiguous subarray of \`1\`s that can be obtained by flipping at most one bit from \`0\` to \`1\`. >>> longest_ones([1, 1, 1, 1]) 4 >>> longest_ones([1, 1, 0, 1, 1]) 5 >>> longest_ones([0, 1, 1, 1, 1]) 5","solution":"def longest_ones(bits): Returns the length of the longest contiguous subarray of \`1\`s that can be obtained by flipping at most one bit from \`0\` to \`1\`. max_len = 0 left = 0 zero_count = 0 for right in range(len(bits)): if bits[right] == 0: zero_count += 1 while zero_count > 1: if bits[left] == 0: zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def search_matrix(matrix, target): Searches for a target value in a matrix where each row and column is sorted in ascending order. Returns True if the target is found, and False otherwise. pass def test_search_matrix_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 assert search_matrix(matrix, target) == True def test_search_matrix_not_found(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 20 assert search_matrix(matrix, target) == False def test_search_matrix_empty(): matrix = [] target = 1 assert search_matrix(matrix, target) == False def test_search_matrix_single_element_found(): matrix = [[1]] target = 1 assert search_matrix(matrix, target) == True def test_search_matrix_single_element_not_found(): matrix = [[1]] target = 2 assert search_matrix(matrix, target) == False","solution":"def search_matrix(matrix, target): Searches for a target value in a matrix where each row and column is sorted in ascending order. Returns True if the target is found, and False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top right corner of the matrix row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def count_unique_elements(arr1, arr2): Returns the count of distinct elements in arr1 that are not present in arr2. >>> count_unique_elements([1, 2, 3], [4, 5, 6]) == 3 >>> count_unique_elements([1, 2, 3], [1, 2, 3]) == 0 >>> count_unique_elements([1, 2, 3, 4], [3, 4, 5, 6]) == 2 >>> count_unique_elements([], [1, 2, 3]) == 0 >>> count_unique_elements([1, 2, 3], []) == 3 >>> count_unique_elements([-1, -2, 3], [-1, 4, 5]) == 2 >>> count_unique_elements([1, 2, 2, 3, 3], [3, 4, 5]) == 2 >>> count_unique_elements(list(range(-1000, 0)), list(range(0, 1000))) == 1000","solution":"def count_unique_elements(arr1, arr2): Returns the count of distinct elements in arr1 that are not present in arr2. set_arr2 = set(arr2) unique_elements = {element for element in arr1 if element not in set_arr2} return len(unique_elements)"},{"question":"from typing import List def smallestCommonElement(mat: List[List[int]]) -> int: Given a matrix \`mat\` where each row is sorted in non-decreasing order, find the smallest common element in all rows. If there is no common element, return \`-1\`. >>> smallestCommonElement([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == 1 >>> smallestCommonElement([[1, 2, 3], [2, 3, 4], [2, 5, 6]]) == 2 >>> smallestCommonElement([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == -1 >>> smallestCommonElement([[1, 2, 3], [2, 3, 4], [2, 3, 5]]) == 2 >>> smallestCommonElement([[1, 4, 5], [2, 3, 5], [1, 5, 6]]) == 5 >>> smallestCommonElement([[1, 2, 3, 4]]) == 1 >>> smallestCommonElement([[1]]) == 1","solution":"def smallestCommonElement(mat): Finds the smallest common element in all rows of a matrix. If no such element exists, returns -1. :param mat: List[List[int]] :return: int count = {} for row in mat: for num in set(row): # Convert each row to a set to avoid duplicate counts within the same row if num in count: count[num] += 1 else: count[num] = 1 rows = len(mat) for num in sorted(count.keys()): # Check the numbers in sorted order if count[num] == rows: return num return -1"},{"question":"def max_widgets_in_subarray(nums: List[int], k: int) -> int: Returns the maximum number of widgets produced on any consecutive subarray of length k. Args: nums: List[int] - the list of integers representing the number of widgets produced each day. k: int - the length of the subarray. Returns: int - the maximum sum of any subarray of length k. >>> max_widgets_in_subarray([1, 2, 3, 4, 5], 2) 9 >>> max_widgets_in_subarray([1, 2, 3, 4, 5], 3) 12 >>> max_widgets_in_subarray([5], 1) 5 >>> max_widgets_in_subarray([4, 4, 4, 4], 2) 8 >>> max_widgets_in_subarray([4, 4, 4, 4], 3) 12 >>> max_widgets_in_subarray([6, 7, 8], 1) 8 >>> max_widgets_in_subarray([1, 2, 3, 4, 5], 5) 15 >>> max_widgets_in_subarray([], 3) 0 >>> max_widgets_in_subarray([1, 2, 3], 0) 0 >>> max_widgets_in_subarray([1, 2, 3], 4) 0","solution":"def max_widgets_in_subarray(nums, k): Returns the maximum number of widgets produced on any consecutive subarray of length k. Args: nums: List[int] - the list of integers representing the number of widgets produced each day. k: int - the length of the subarray. Returns: int - the maximum sum of any subarray of length k. if not nums or k <= 0 or k > len(nums): return 0 max_sum = current_sum = sum(nums[:k]) # Initial window sum for i in range(k, len(nums)): current_sum += nums[i] - nums[i - k] # Slide the window to the right max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_sum_of_k_items(nums: List[int], k: int) -> int: Returns the maximum possible sum of the prices of any k different items you can choose. If k is greater than the number of elements in nums, returns the sum of all elements in nums. >>> max_sum_of_k_items([4, 7, 2, 9, 5], 3) == 21 >>> max_sum_of_k_items([4, 7, 2, 9, 5], 5) == 27 >>> max_sum_of_k_items([4, 7, 2, 9, 5], 10) == 27 >>> max_sum_of_k_items([4, 7, 2, 9, 5], 0) == 0 >>> max_sum_of_k_items([], 3) == 0 >>> max_sum_of_k_items([4, 7, 2, 9, 5], -1) == 0 >>> max_sum_of_k_items([10], 1) == 10 >>> max_sum_of_k_items([10], 2) == 10","solution":"def max_sum_of_k_items(nums, k): Returns the maximum possible sum of the prices of any k different items you can choose. If k is greater than the number of elements in nums, returns the sum of all elements in nums. Parameters: nums (list of int): List containing the prices of items. k (int): Number of items to choose. if not nums or k <= 0: return 0 nums_sorted = sorted(nums, reverse=True) return sum(nums_sorted[:min(k, len(nums))])"},{"question":"def find_single_number(arr: List[int]) -> int: Finds and returns the integer that appears exactly once in the list, where every other integer appears exactly twice. >>> find_single_number([2, 2, 1]) == 1 >>> find_single_number([4, 1, 2, 1, 2]) == 4 >>> find_single_number([5, 5, 3, 3, 9]) == 9 >>> find_single_number([0, 1, 0]) == 1 >>> find_single_number([100, 200, 300, 100, 300]) == 200 >>> find_single_number([-1, -1, -2]) == -2","solution":"def find_single_number(arr): Finds and returns the integer that appears exactly once in the list, where every other integer appears exactly twice. :param arr: List of integers where each integer appears twice except for one. :return: The integer that appears only once. unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Perform level order traversal on a binary tree and return values of nodes in level order. :param root: TreeNode, the root node of the binary tree :return: List[List[int]], a list of lists containing values of nodes at each level >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> level_order_traversal(None) [] pass","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Perform level order traversal on a binary tree and return values of nodes in level order. :param root: TreeNode, the root node of the binary tree :return: List[List[int]], a list of lists containing values of nodes at each level if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for i in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeSerializer: def serialize(self, root): Converts the binary tree rooted at \`root\` to a string. >>> node1 = TreeNode(1) >>> node2 = TreeNode(2) >>> node3 = TreeNode(3) >>> node4 = TreeNode(4) >>> node5 = TreeNode(5) >>> node1.left = node2 >>> node1.right = node3 >>> node3.left = node4 >>> node3.right = node5 >>> serializer = BinaryTreeSerializer() >>> serializer.serialize(node1) \\"1,2,null,null,3,4,null,null,5,null,null\\" def deserialize(self, data): Converts the serialized string \`data\` back to the original binary tree and returns the root of the tree. >>> serialized_str = \\"1,2,null,null,3,4,null,null,5,null,null\\" >>> serializer = BinaryTreeSerializer() >>> root = serializer.deserialize(serialized_str) >>> serializer.serialize(root) \\"1,2,null,null,3,4,null,null,5,null,null\\"","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTreeSerializer: def serialize(self, root): Encodes a tree to a single string. def preorder_traversal(node): if not node: return \\"null,\\" return str(node.val) + \\",\\" + preorder_traversal(node.left) + preorder_traversal(node.right) return preorder_traversal(root) def deserialize(self, data): Decodes your encoded data to tree. def preorder_construction(data_list): if data_list[0] == \\"null\\": data_list.pop(0) return None root = TreeNode(int(data_list[0])) data_list.pop(0) root.left = preorder_construction(data_list) root.right = preorder_construction(data_list) return root data_list = data.split(',') return preorder_construction(data_list)"},{"question":"class IntervalManager: A class to manage a collection of intervals. The system should be able to add new intervals and merge any overlapping intervals automatically. - \`IntervalManager()\` Initializes the interval manager. - \`addInterval(int start, int end)\` Adds a new interval \`[start, end]\` to the collection of intervals, merging any overlapping intervals if necessary. - \`getIntervals()\` Returns a list of merged intervals sorted by their start times. Example: >>> manager = IntervalManager() >>> manager.addInterval(1, 3) >>> manager.addInterval(4, 6) >>> manager.getIntervals() [[1, 3], [4, 6]] >>> manager.addInterval(2, 5) >>> manager.getIntervals() [[1, 6]] def __init__(self): pass # Initialize the interval manager def addInterval(self, start, end): pass # Add a new interval and merge any overlapping intervals def getIntervals(self): pass # Return a list of merged intervals # Example unit test cases def test_add_non_overlapping_intervals(): manager = IntervalManager() manager.addInterval(1, 3) manager.addInterval(4, 6) result = manager.getIntervals() assert result == [[1, 3], [4, 6]] def test_add_overlapping_intervals(): manager = IntervalManager() manager.addInterval(1, 3) manager.addInterval(2, 5) result = manager.getIntervals() assert result == [[1, 5]] def test_add_nested_intervals(): manager = IntervalManager() manager.addInterval(1, 5) manager.addInterval(2, 3) result = manager.getIntervals() assert result == [[1, 5]] def test_add_touching_intervals(): manager = IntervalManager() manager.addInterval(1, 3) manager.addInterval(3, 6) result = manager.getIntervals() assert result == [[1, 6]] def test_add_disjoint_intervals_in_reverse_order(): manager = IntervalManager() manager.addInterval(4, 6) manager.addInterval(1, 3) result = manager.getIntervals() assert result == [[1, 3], [4, 6]] def test_add_mixed_intervals(): manager = IntervalManager() manager.addInterval(1, 3) manager.addInterval(5, 6) manager.addInterval(2, 4) manager.addInterval(7, 8) result = manager.getIntervals() assert result == [[1, 4], [5, 6], [7, 8]]","solution":"class IntervalManager: def __init__(self): self.intervals = [] def addInterval(self, start, end): new_interval = [start, end] self.intervals.append(new_interval) self.intervals.sort(key=lambda x: x[0]) merged_intervals = [] for interval in self.intervals: if not merged_intervals or merged_intervals[-1][1] < interval[0]: merged_intervals.append(interval) else: merged_intervals[-1][1] = max(merged_intervals[-1][1], interval[1]) self.intervals = merged_intervals def getIntervals(self): return self.intervals"},{"question":"def min_subsequences(nums: List[int], k: int) -> int: Returns the minimum number of subsequences required such that the difference between the maximum and minimum values in each subsequence is at most k. >>> min_subsequences([], 3) 0 >>> min_subsequences([1], 3) 1 >>> min_subsequences([1, 2, 3], 3) 1 >>> min_subsequences([1, 2, 8], 3) 2 >>> min_subsequences([1, 5, 9, 13], 3) 4 >>> min_subsequences([1, 2, 3, 4, 5, 6], 10) 1 >>> min_subsequences([1, 10, 20, 30], 5) 4 >>> min_subsequences([1, 2, 6, 7, 8, 10, 11], 2) 3","solution":"def min_subsequences(nums, k): Returns the minimum number of subsequences required such that the difference between the maximum and minimum values in each subsequence is at most k. if not nums: return 0 nums.sort() # Sort the array subsequences = 1 # Initialize the number of subsequences start = 0 # Start of the current subsequence for i in range(1, len(nums)): # If the difference between current element and the start of the subsequence is more than k if nums[i] - nums[start] > k: subsequences += 1 # Need a new subsequence start = i # Update the start of the new subsequence return subsequences"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Find the subarray with the maximum sum among all subarrays and return the sum. :param nums: List[int] - a list of integers. :return: int - the maximum sum of a contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4]) 10 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([5]) 5 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum([]) 0","solution":"def max_subarray_sum(nums): This function returns the maximum sum of a contiguous subarray. :param nums: List[int] - a list of integers. :return: int - the maximum sum of a contiguous subarray. if not nums: return 0 max_current = max_global = nums[0] for number in nums[1:]: max_current = max(number, max_current + number) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_unique_length(nums: List[int], k: int) -> int: Returns the maximum possible length of a unique subsequence that can be formed by removing at most k elements from nums. >>> max_unique_length([1, 2, 3, 4], 0) == 4 >>> max_unique_length([1, 2, 2, 3], 1) == 3 >>> max_unique_length([1, 2, 2, 3, 3], 2) == 3 >>> max_unique_length([1, 1, 1, 1], 3) == 1 >>> max_unique_length([1, 1, 1, 1], 4) == 1 >>> max_unique_length([], 0) == 0 >>> max_unique_length([1], 0) == 1 >>> max_unique_length([1, 1, 2, 2, 3], 3) == 3 >>> max_unique_length([1, 1, 1, 2, 2, 2, 3, 3, 3], 6) == 3 >>> max_unique_length([1, 2, 3, 3, 2, 1, 4, 5], 0) == 5 >>> max_unique_length([1, 2, 3, 4, 5, 6, 7, 8, 9], 2) == 9 >>> max_unique_length([1, 1, 2, 2, 3, 3, 4, 4, 5, 5], 5) == 5 >>> max_unique_length([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0) == 10","solution":"def max_unique_length(nums, k): Returns the maximum possible length of a unique subsequence that can be formed by removing at most k elements from nums. n = len(nums) if n == 0: return 0 # Count the frequency of each element in nums freq = {} for num in nums: if num in freq: freq[num] += 1 else: freq[num] = 1 # Count the number of unique elements unique_count = len(freq) # If the number of unique elements is greater or equal to n - k, # then we can obtain a unique subsequence by removing at most k elements if unique_count >= n - k: return unique_count # Otherwise, find how many more elements need to be removed to make the subsequence unique duplicated_count = n - unique_count return min(unique_count + k, n)"},{"question":"def findWords(board: List[List[str]], words: List[str]) -> List[str]: Given a 2D grid of characters and a list of words, return the list of words that can be found in the grid. A word can be formed by moving left, right, up, or down from a starting position, and each cell can be used only once per word. The same word can appear multiple times at different positions, but each occurrence must be a separate instance in the grid traversal. >>> findWords([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], [\\"ABCCED\\"]) [\\"ABCCED\\"] >>> findWords([ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ], [\\"HELLO\\", \\"WORLD\\"]) []","solution":"def findWords(board, words): def backtrack(x, y, word): if not word: return True if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or board[x][y] != word[0]: return False temp = board[x][y] board[x][y] = \\"#\\" found = (backtrack(x+1, y, word[1:]) or backtrack(x-1, y, word[1:]) or backtrack(x, y+1, word[1:]) or backtrack(x, y-1, word[1:])) board[x][y] = temp return found found_words = set() for word in words: word_found = False for i in range(len(board)): for j in range(len(board[0])): if backtrack(i, j, word): found_words.add(word) word_found = True break if word_found: break return list(found_words)"},{"question":"def min_deletions_to_avoid_repeated_letters(s: str) -> int: Given a string \`s\` consisting of lowercase English letters, determine the minimum number of letters you need to remove from the string so that the remaining string does not contain any two identical consecutive letters. >>> min_deletions_to_avoid_repeated_letters(\\"abc\\") == 0 >>> min_deletions_to_avoid_repeated_letters(\\"aaaaa\\") == 4 >>> min_deletions_to_avoid_repeated_letters(\\"ababab\\") == 0 >>> min_deletions_to_avoid_repeated_letters(\\"aaabbb\\") == 4 >>> min_deletions_to_avoid_repeated_letters(\\"aabbaa\\") == 3 >>> min_deletions_to_avoid_repeated_letters(\\"a\\") == 0 >>> min_deletions_to_avoid_repeated_letters(\\"\\") == 0","solution":"def min_deletions_to_avoid_repeated_letters(s): Given a string \`s\`, determine the minimum number of letters to remove so that no two identical consecutive letters remain. Arguments: s: str - Input string consisting of lowercase English letters Returns: int - Minimum number of deletions needed deletions = 0 prev_char = '' for char in s: if char == prev_char: deletions += 1 else: prev_char = char return deletions"},{"question":"from typing import List def longest_subarray(A: List[int], K: int) -> int: Given a list of integers A, find the length of the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to K. Parameters: A (list): List of integers. K (int): Maximum allowed absolute difference. Returns: int: Length of the longest contiguous subarray. pass def test_example_case(): assert longest_subarray([10, 1, 2, 4, 7, 2], 5) == 4 def test_all_elements_same(): assert longest_subarray([2, 2, 2, 2, 2], 3) == 5 def test_no_valid_subarray(): assert longest_subarray([1, 5, 9, 13], 3) == 1 def test_entire_array_is_valid(): assert longest_subarray([1, 2, 3, 4, 5], 4) == 5 def test_empty_array(): assert longest_subarray([], 3) == 0 def test_single_element(): assert longest_subarray([5], 0) == 1 def test_negative_numbers(): assert longest_subarray([-1, -2, -3, -4, -5], 2) == 3 def test_large_K(): assert longest_subarray([1, -1, 2, -2, 3, -3], 10) == 6","solution":"def longest_subarray(A, K): Given a list of integers A, find the length of the longest contiguous subarray such that the absolute difference between the maximum and minimum elements in this subarray is less than or equal to K. Parameters: A (list): List of integers. K (int): Maximum allowed absolute difference. Returns: int: Length of the longest contiguous subarray. if not A: return 0 max_len = 0 start = 0 min_queue, max_queue = [], [] for end in range(len(A)): while min_queue and A[min_queue[-1]] >= A[end]: min_queue.pop() while max_queue and A[max_queue[-1]] <= A[end]: max_queue.pop() min_queue.append(end) max_queue.append(end) while A[max_queue[0]] - A[min_queue[0]] > K: start += 1 if min_queue[0] < start: min_queue.pop(0) if max_queue[0] < start: max_queue.pop(0) max_len = max(max_len, end - start + 1) return max_len"},{"question":"from typing import List def min_traverse_cost(grid: List[List[int]]) -> int: Determines the minimum cost to traverse from the top-left corner to the bottom-right corner of an n x n grid consisting of non-negative integers. Movement is restricted to up, down, left, and right. Args: grid (List[List[int]]): 2D list representing the grid. Returns: int: Minimum cost to reach the bottom-right corner from the top-left corner. pass # Example test cases def test_min_traverse_cost_1(): grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert min_traverse_cost(grid) == 7 def test_min_traverse_cost_2(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert min_traverse_cost(grid) == 21 def test_min_traverse_cost_single_element(): grid = [ [0] ] assert min_traverse_cost(grid) == 0 def test_min_traverse_cost_large_values(): grid = [ [1, 100, 1, 1], [1, 100, 1, 100], [1, 1, 1, 100], [100, 1, 1, 1] ] assert min_traverse_cost(grid) == 7 def test_min_traverse_cost_empty_grid(): grid = [] assert min_traverse_cost(grid) == 0","solution":"import heapq def min_traverse_cost(grid): Determines the minimum cost to traverse from the top-left corner to the bottom-right corner of an n x n grid consisting of non-negative integers. Movement is restricted to up, down, left, and right. Args: grid (List[List[int]]): 2D list representing the grid. Returns: int: Minimum cost to reach the bottom-right corner from the top-left corner. n = len(grid) if n == 0 or len(grid[0]) == 0: return 0 # Directions for moving in four possible directions - right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Min-heap to store (cost, x, y) min_heap = [(grid[0][0], 0, 0)] costs = {(0, 0): grid[0][0]} while min_heap: current_cost, x, y = heapq.heappop(min_heap) # If we have reached the bottom-right corner if x == n-1 and y == n-1: return current_cost for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n: new_cost = current_cost + grid[nx][ny] if (nx, ny) not in costs or new_cost < costs[(nx, ny)]: costs[(nx, ny)] = new_cost heapq.heappush(min_heap, (new_cost, nx, ny)) return -1 # Return -1 if there's no possible path (shouldn't happen with valid input)"},{"question":"def shortest_to_char(s: str, c: str) -> List[int]: Return an array of integers representing the shortest distance from each character in the string to the given character c. >>> shortest_to_char(\\"loveleetcode\\", 'e') [3,2,1,0,1,0,0,1,2,2,1,0] >>> shortest_to_char(\\"aaab\\", 'b') [3,2,1,0] >>> shortest_to_char(\\"a\\", 'a') [0] >>> shortest_to_char(\\"bbbbbb\\", 'b') [0,0,0,0,0,0] >>> shortest_to_char(\\"abacadae\\", 'a') [0,1,0,1,0,1,0,1] >>> shortest_to_char(\\"abbbbbba\\", 'a') [0,1,2,3,3,2,1,0]","solution":"def shortest_to_char(s, c): Returns an array of integers representing the shortest distance from each character in the string to the given character c. n = len(s) distances = [0] * n prev = float('-inf') # Forward pass to find shortest distances from the left for i in range(n): if s[i] == c: prev = i distances[i] = i - prev prev = float('inf') # Backward pass to find shortest distances from the right for i in range(n-1, -1, -1): if s[i] == c: prev = i distances[i] = min(distances[i], prev - i) return distances"},{"question":"def min_cuts(cake: List[List[int]]) -> int: Determine the minimum number of cuts needed to slice a cake such that each piece contains exactly one chocolate. If it is not possible, return -1. >>> min_cuts([ ... [1, 0], ... [0, 1]]) 2 >>> min_cuts([ ... [0, 0], ... [0, 0]]) -1 >>> min_cuts([ ... [1, 1], ... [0, 0]]) -1 >>> min_cuts([ ... [1, 0], ... [1, 0]]) -1 >>> min_cuts([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1]]) 4 >>> min_cuts([ ... [1]]) 0 >>> min_cuts([ ... [1, 0, 0], ... [0, 0, 0], ... [0, 0, 1], ... [0, 1, 0]]) 3","solution":"def min_cuts(cake): h = len(cake) w = len(cake[0]) if h > 0 else 0 def is_feasible(): chocolate_count = sum(cake[i][j] for i in range(h) for j in range(w)) if chocolate_count == 0: return False for row in cake: if sum(row) > 1: return False for col in range(w): if sum(cake[row][col] for row in range(h)) > 1: return False return True if not is_feasible(): return -1 cuts = 0 # Horizontal cuts for i in range(h - 1): if sum(cake[i]) > 0 and sum(cake[i + 1]) > 0: cuts += 1 # Vertical cuts for j in range(w - 1): if sum(cake[i][j] for i in range(h)) > 0 and sum(cake[i][j + 1] for i in range(h)) > 0: cuts += 1 return cuts"},{"question":"def search_matrix(matrix, target): Check if a target exists in an n x n matrix where each row and each column is sorted in non-decreasing order. Args: matrix (List[List[int]]): The n x n matrix target (int): The target value to search for Returns: bool: True if target is found, False otherwise # Test cases def test_target_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 5) == True assert search_matrix(matrix, 16) == True def test_target_not_exists(): matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] assert search_matrix(matrix, 20) == False assert search_matrix(matrix, 0) == False def test_empty_matrix(): assert search_matrix([], 1) == False assert search_matrix([[]], 1) == False def test_single_element_matrix(): assert search_matrix([[5]], 5) == True assert search_matrix([[5]], 1) == False","solution":"def search_matrix(matrix, target): Check if a target exists in an n x n matrix where each row and each column is sorted in non-decreasing order. Args: matrix (List[List[int]]): The n x n matrix target (int): The target value to search for Returns: bool: True if target is found, False otherwise if not matrix or not matrix[0]: return False # Start from the top-right corner of the matrix n = len(matrix) row, col = 0, n - 1 while row < n and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"def num_decodings(s: str) -> int: Returns the total number of ways to decode a string consisting of digits. Each digit from '1' to '9' maps to 'a' to 'i' and digits '10' to '26' map to 'j' to 'z'. The answer should be returned modulo 10^9 + 7. >>> num_decodings(\\"1\\") == 1 >>> num_decodings(\\"9\\") == 1 >>> num_decodings(\\"12\\") == 2 >>> num_decodings(\\"27\\") == 1 >>> num_decodings(\\"30\\") == 0 >>> num_decodings(\\"11106\\") == 2 >>> num_decodings(\\"2611055971756562\\") > 0 >>> num_decodings(\\"0\\") == 0 >>> num_decodings(\\"011\\") == 0 >>> num_decodings(\\"226\\") == 3 >>> num_decodings(\\"1234\\") == 3 >>> num_decodings(\\"111111\\") == 13","solution":"MOD = 10**9 + 7 def num_decodings(s): Returns the number of ways to decode the string s. if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 # Base case: an empty string has one way to decode it (doing nothing). for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] in '0123456'): dp[i] += dp[i - 2] dp[i] %= MOD return dp[n]"},{"question":"def calculate_spans(heights): Function to calculate the span of buildings based on their heights. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of spans for each building. pass # Example Usage: # spans = calculate_spans([3, 2, 1, 4, 5]) # print(spans) # Output: [1, 1, 1, 4, 5]","solution":"def calculate_spans(heights): Function to calculate the span of buildings based on their heights. Parameters: heights (list): A list of integers representing the heights of buildings. Returns: list: A list of spans for each building. n = len(heights) spans = [1] * n # Initialize spans to 1 for each building for i in range(n): span = 1 while i - span >= 0 and heights[i - span] <= heights[i]: span += spans[i - span] spans[i] = span return spans"},{"question":"def find_leaders(nums): Returns an array of all leaders in the given array A leader is an element that is greater than all the elements to its right. The rightmost element is always a leader. Parameters: nums (list): A list of integers Returns: list: A list of leader integers Examples: >>> find_leaders([16, 17, 4, 3, 5, 2]) [17, 5, 2] >>> find_leaders([1, 2, 3, 4, 0]) [4, 0]","solution":"def find_leaders(nums): Returns an array of all leaders in the given array A leader is an element that is greater than all the elements to its right. The rightmost element is always a leader. Parameters: nums (list): A list of integers Returns: list: A list of leader integers if not nums: # Handle empty list case return [] leaders = [] max_from_right = nums[-1] leaders.append(max_from_right) for i in reversed(range(len(nums) - 1)): if nums[i] > max_from_right: max_from_right = nums[i] leaders.append(max_from_right) return leaders[::-1] # Reversing to maintain the order from left to right in the original array"},{"question":"def min_cost_path(grid: List[List[int]]) -> int: Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. grid: List[List[int]] - 2D matrix containing integer values. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[5]]) 5 >>> min_cost_path([[1, 2], [1, 1]]) 3 >>> min_cost_path([]) 0 >>> min_cost_path([[]]) 0 >>> min_cost_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21","solution":"def min_cost_path(grid): Returns the minimum cost to traverse from the top-left corner to the bottom-right corner of the grid. grid: List[List[int]] - 2D matrix containing integer values. if not grid or not grid[0]: return 0 n = len(grid) # Initialize a 2D dp array with the same dimensions as grid dp = [[0] * n for _ in range(n)] # Start at the top-left corner dp[0][0] = grid[0][0] # Fill the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the first column for j in range(1, n): dp[j][0] = dp[j-1][0] + grid[j][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the minimum cost return dp[n-1][n-1]"},{"question":"def min_words_to_form_target(words: List[str], target: str) -> int: Returns the minimum number of words required to form the target word by concatenating words from the list \`words\`. >>> min_words_to_form_target([\\"ab\\", \\"c\\", \\"abc\\"], \\"abcc\\") 2 >>> min_words_to_form_target([\\"a\\", \\"b\\", \\"abc\\"], \\"abc\\") 1 >>> min_words_to_form_target([\\"a\\", \\"aa\\", \\"aaa\\"], \\"aaaaa\\") 2 >>> min_words_to_form_target([\\"a\\", \\"b\\", \\"c\\"], \\"abcd\\") -1 >>> min_words_to_form_target([\\"apple\\", \\"pen\\"], \\"applepen\\") 2 >>> min_words_to_form_target([\\"cat\\", \\"dog\\", \\"rat\\"], \\"catdog\\") 2 >>> min_words_to_form_target([\\"a\\", \\"aa\\", \\"aaa\\", \\"aaaa\\"], \\"aaaaaaaa\\") 2 >>> min_words_to_form_target([\\"a\\", \\"abc\\", \\"abcd\\", \\"b\\"], \\"abcdabc\\") 2","solution":"def min_words_to_form_target(words, target): from collections import deque, defaultdict word_set = set(words) queue = deque([(target, 0)]) visited = set() while queue: current, steps = queue.popleft() if current == \\"\\": return steps for word in word_set: if current.startswith(word): new_target = current[len(word):] if new_target not in visited: visited.add(new_target) queue.append((new_target, steps + 1)) return -1"},{"question":"import heapq from typing import List from collections import Counter def rearrange_string(s: str, k: int) -> str: Re-arranges the string \`s\` such that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. >>> rearrange_string(\\"aabbcc\\", 3) 'abcabc' >>> rearrange_string(\\"aabbcc\\", 1) 'abcabc' >>> rearrange_string(\\"aaabbc\\", 2) 'ababac' >>> rearrange_string(\\"aa\\", 2) '' >>> rearrange_string(\\"aaaabc\\", 3) '' >>> rearrange_string(\\"\\", 1) '' >>> rearrange_string(\\"a\\", 1) 'a' >>> rearrange_string(\\"aabbcc\\", 0) 'aabbcc' >>> rearrange_string(\\"aaabbcc\\", 0) 'aaabbcc'","solution":"import heapq from collections import Counter def rearrange_string(s: str, k: int) -> str: Rearranges the string \`s\` such that no two adjacent characters are the same. If such an arrangement is not possible, returns an empty string. if k == 0: return s # if k is 0, no restriction on adjacent characters char_count = Counter(s) max_heap = [(-count, char) for char, count in char_count.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) < k: continue front = wait_queue.pop(0) if front[0] < 0: heapq.heappush(max_heap, front) rearranged_string = ''.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"def StringReorder(s: str, indices: List[int]) -> str: Reorders the characters in s according to indices. >>> StringReorder(\\"abc\\", [2, 1, 0]) \\"cba\\" >>> StringReorder(\\"a\\", [0]) \\"a\\" >>> StringReorder(\\"ab\\", [1, 0]) \\"ba\\" >>> StringReorder(\\"abcde\\", [0, 1, 2, 3, 4]) \\"abcde\\" >>> StringReorder(\\"aiohn\\", [3, 1, 4, 2, 0]) \\"nihao\\" >>> StringReorder(\\"aabbcc\\", [5, 4, 3, 2, 1, 0]) \\"ccbbaa\\"","solution":"def StringReorder(s, indices): Reorders the characters in s according to indices. Parameters: s (str): The input string. indices (list of int): The indices array representing the new order. Returns: str: The reordered string. # Initialize an empty list of the same length as the input string result = [''] * len(s) # Populate the result list according to the indices array for i, index in enumerate(indices): result[index] = s[i] # Join and return the list as a string return ''.join(result)"},{"question":"def min_operations_to_transform(s: str, t: str) -> int: Calculates the minimum number of operations required to transform string s into string t. >>> min_operations_to_transform(\\"abc\\", \\"abc\\") 0 >>> min_operations_to_transform(\\"abc\\", \\"abd\\") 1 >>> min_operations_to_transform(\\"aaaa\\", \\"bbbb\\") 4 >>> min_operations_to_transform(\\"abcd\\", \\"wxyz\\") 4 >>> min_operations_to_transform(\\"aabbcc\\", \\"xyzxyz\\") 6","solution":"def min_operations_to_transform(s, t): Calculates the minimum number of operations required to transform string s into string t. Parameters: s (str): Source string. t (str): Target string. Returns: int: Minimum number of operations required to make the strings equal. # Initialize an array to count the frequency of each character (26 lowercase letters). freq_s = [0] * 26 freq_t = [0] * 26 # Calculate the frequency of each character in s and t. for i in range(len(s)): freq_s[ord(s[i]) - ord('a')] += 1 freq_t[ord(t[i]) - ord('a')] += 1 # Calculate the number of changes needed. operations = 0 for i in range(26): if freq_s[i] > freq_t[i]: operations += freq_s[i] - freq_t[i] return operations"},{"question":"def calculate(expression: str) -> int: Evaluate a given arithmetic expression string and return its integer result. Operations follow the standard rules of arithmetic precedence. Division is integer division. >>> calculate(\\"3+5\\") == 8 >>> calculate(\\"10-2\\") == 8 >>> calculate(\\"4*5\\") == 20 >>> calculate(\\"8/3\\") == 2 # Integer division >>> calculate(\\"3+5*2\\") == 13 # Multiplication before addition >>> calculate(\\"10+2*6\\") == 22 >>> calculate(\\"100*2+12\\") == 212 >>> calculate(\\"100*(2+12)\\") == 1400 >>> calculate(\\"100*(2+12)/14\\") == 100 >>> calculate(\\"(3+5)*2\\") == 16 >>> calculate(\\"10+5*6/3-7\\") == 13","solution":"def calculate(expression): Evaluate a given arithmetic expression string and return its integer result. Operations follow the standard rules of arithmetic precedence. Division is integer division. import re tokens = re.findall(r'd+|[-+*/()]', expression) precedence = {'+': 1, '-': 1, '*': 2, '/': 2} def shunting_yard(tokens): output = [] operators = [] for token in tokens: if token.isdigit(): output.append(int(token)) elif token in precedence: while (operators and operators[-1] != '(' and precedence[token] <= precedence[operators[-1]]): output.append(operators.pop()) operators.append(token) elif token == '(': operators.append(token) elif token == ')': while operators and operators[-1] != '(': output.append(operators.pop()) operators.pop() while operators: output.append(operators.pop()) return output def eval_rpn(tokens): stack = [] for token in tokens: if isinstance(token, int): stack.append(token) else: b, a = stack.pop(), stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': stack.append(int(float(a) / b)) # truncating towards zero return stack[0] rpn = shunting_yard(tokens) return eval_rpn(rpn)"},{"question":"def min_moves_to_take_all_stones(n: int, piles: List[int]) -> int: Given an integer 'n' representing the total number of stones and an integer array 'piles' of length 'm', where each element in 'piles' represents the number of stones in that pile, return the minimum number of moves required to take all stones. You may choose any pile and take any positive number of stones from that pile. However, if you want to take stones from a pile, you need to take at least as many stones as there are in the smallest pile among the remaining piles. A move consists of taking stones from one pile. >>> min_moves_to_take_all_stones(10, [3, 1, 2]) 3 >>> min_moves_to_take_all_stones(9, [3, 3, 3]) 3 >>> min_moves_to_take_all_stones(5, [5]) 1 >>> min_moves_to_take_all_stones(15, [5, 3, 7]) 3 >>> min_moves_to_take_all_stones(21, [7, 5, 9]) 3","solution":"def min_moves_to_take_all_stones(n, piles): # Sort the piles to simplify the process of finding the smallest remaining pile piles.sort() moves = 0 for i in range(len(piles)): # Since we're always taking stones from the smallest or larger remaining piles # the number of stones we take in each move is piles[i] moves += 1 # Remove piles[i] from all piles (since we took at least piles[i] stones from each of the remaining piles) piles = [p - piles[i] for p in piles[i+1:]] return moves"},{"question":"def two_sum_sorted(nums: List[int], target: int) -> List[int]: This function returns the indices of the two numbers such that they add up to the target. The input array nums is sorted in non-decreasing order. >>> two_sum_sorted([1, 2, 3, 4, 5], 9) [3, 4] >>> two_sum_sorted([1, 2, 3, 4, 4, 5], 8) [2, 5] >>> two_sum_sorted([1, 2, 3, 4, 5], 10) [-1, -1] >>> two_sum_sorted([1, 2, 3, 4, 5], 1) [-1, -1] >>> two_sum_sorted([2, 7, 11, 15], 9) [0, 1] >>> two_sum_sorted([2, 3, 4, 4], 8) [2, 3] >>> two_sum_sorted([1], 2) [-1, -1] >>> two_sum_sorted([], 1) [-1, -1] >>> two_sum_sorted([1, 2], 3) [0, 1] >>> two_sum_sorted([1, 2], 4) [-1, -1]","solution":"def two_sum_sorted(nums, target): This function returns the indices of the two numbers such that they add up to the target. The input array nums is sorted in non-decreasing order. left, right = 0, len(nums) - 1 while left < right: current_sum = nums[left] + nums[right] if current_sum == target: return [left, right] elif current_sum < target: left += 1 else: right -= 1 return [-1, -1]"},{"question":"def two_sum_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: Returns a list of unique pairs (a, b) from the array such that a + b equals target. Each pair (a, b) and (b, a) should be considered the same and should not be duplicated. >>> two_sum_pairs([1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> two_sum_pairs([1, 1, 2, 3, 4, 4], 5) [(1, 4), (2, 3)] >>> two_sum_pairs([-1, -2, 0, 1, 2, 3], 1) [(-2, 3), (-1, 2), (0, 1)] >>> two_sum_pairs([-2, -1, 0, 1, 2], 0) [(-2, 2), (-1, 1)] >>> two_sum_pairs([1, 2, 3, 4, 5], 10) []","solution":"def two_sum_pairs(arr, target): Returns a list of unique pairs (a, b) from the array such that a + b equals target. Each pair (a, b) and (b, a) should be considered the same and should not be duplicated. Args: arr (list of int): The input array of integers. target (int): The target sum. Returns: list of tuple of int: The list of unique pairs. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return list(pairs)"}]`),A={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:F,isLoading:!1}},computed:{filteredPoems(){const s=this.searchQuery.trim().toLowerCase();return s?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(s)||e.solution&&e.solution.toLowerCase().includes(s)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(s=>setTimeout(s,1e3)),this.visibleCount+=4,this.isLoading=!1}}},S={class:"search-container"},I={class:"card-container"},z={key:0,class:"empty-state"},C=["disabled"],D={key:0},P={key:1};function E(s,e,l,h,i,a){const c=g("PoemCard");return r(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",S,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),p(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(r(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):u("",!0)]),t("div",I,[(r(!0),n(x,null,v(a.displayedPoems,(o,f)=>(r(),y(c,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(r(),n("div",z,' No results found for "'+d(i.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(r(),n("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(r(),n("span",P,"Loading...")):(r(),n("span",D,"See more"))],8,C)):u("",!0)])}const M=_(A,[["render",E],["__scopeId","data-v-b6840b12"]]),O=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/23.md","filePath":"library/23.md"}'),B={name:"library/23.md"},U=Object.assign(B,{setup(s){return(e,l)=>(r(),n("div",null,[w(M)]))}});export{O as __pageData,U as default};
