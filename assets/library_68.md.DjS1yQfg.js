import{_ as m,o as s,c as r,a as t,m as c,t as d,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},N={class:"review-title"},L={class:"review-content"};function A(n,e,u,_,i,a){return s(),r("div",q,[t("div",T,[t("div",N,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",L,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(u.poem.solution),1)])])])}const S=m(k,[["render",A],["__scopeId","data-v-54b5c3bc"]]),R=JSON.parse(`[{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root: TreeNode, target: float) -> int: Given a binary search tree (BST) and a target value, determine the value in the BST that is closest to the target. Example 1: >>> root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(5)) >>> target = 3.714286 >>> closest_value(root, target) 4 Example 2: >>> root = TreeNode(1) >>> target = 4.428571 >>> closest_value(root, target) 1","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root, target): closest = root.val current = root while current: if abs(current.val - target) < abs(closest - target): closest = current.val if target < current.val: current = current.left else: current = current.right return closest"},{"question":"def shortest_odd_sum_subsequence_length(n: int, sequence: List[int]) -> int: Find the length of the shortest subsequence such that the sum of its elements is an odd number. >>> shortest_odd_sum_subsequence_length(4, [2, 4, 6, 8]) -1 >>> shortest_odd_sum_subsequence_length(5, [1, 2, 3, 4, 5]) 1 >>> shortest_odd_sum_subsequence_length(3, [2, 3, 6]) 1 pass from typing import List def test_all_even(): assert shortest_odd_sum_subsequence_length(4, [2, 4, 6, 8]) == -1 def test_mixed_numbers(): assert shortest_odd_sum_subsequence_length(5, [1, 2, 3, 4, 5]) == 1 def test_single_odd(): assert shortest_odd_sum_subsequence_length(1, [3]) == 1 def test_single_even(): assert shortest_odd_sum_subsequence_length(1, [2]) == -1 def test_large_case_all_even(): assert shortest_odd_sum_subsequence_length(10**6, [2] * 10**6) == -1 def test_large_case_mixed(): sequence = [2] * (10**6 - 1) + [3] assert shortest_odd_sum_subsequence_length(10**6, sequence) == 1 def test_empty_case(): assert shortest_odd_sum_subsequence_length(0, []) == -1","solution":"def shortest_odd_sum_subsequence_length(n, sequence): # Check if there is any odd number in the sequence for num in sequence: if num % 2 != 0: return 1 # If no odd number is found, return -1 return -1"},{"question":"def max_beauty(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum beauty of any subsegment of the given sequence in each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains a single integer n (length of the sequence) and a list of n integers representing the sequence. Returns: List[int]: A list of integers where each integer is the maximum beauty of any subsegment of the corresponding test case. Examples: >>> max_beauty(3, [(6, [8, 2, 2, 8, 3, 5]), (5, [1, 2, 2, 3, 4]), (4, [4, 4, 4, 4])]) [18, 10, 4]","solution":"def max_beauty(t, test_cases): results = [] for n, b in test_cases: max_beauty = 0 for i in range(n): unique_elements = set() current_beauty = 0 for j in range(i, n): if b[j] not in unique_elements: unique_elements.add(b[j]) current_beauty += b[j] max_beauty = max(max_beauty, current_beauty) results.append(max_beauty) return results"},{"question":"def is_perfect_number(n: int) -> bool: Determines if a number n is a perfect number. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False >>> is_perfect_number(1) False","solution":"def is_perfect_number(n): Determines if a number n is a perfect number. if n < 2: return False sum_divisors = 1 for i in range(2, int(n**0.5) + 1): if n % i == 0: sum_divisors += i if i != n // i: sum_divisors += n // i return sum_divisors == n"},{"question":"def average_primes(numbers: List[int]) -> float: Returns the average of all the prime numbers in the list. If there are no prime numbers, returns 0. >>> average_primes([2, 3, 4, 5, 6, 7, 8, 9]) -> 4.25 >>> average_primes([10, 15, 20, 25, 30]) -> 0.0 >>> average_primes([11, 13, 17, 19]) -> 15.0 >>> average_primes([1, 2, 3, 5]) -> 3.3333333333333335 >>> average_primes([]) -> 0.0 >>> average_primes([2]) -> 2.0 >>> average_primes([1]) -> 0.0 >>> average_primes([101, 103, 107, 109]) -> 105.0","solution":"def is_prime(n): Returns True if n is a prime number, otherwise returns False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def average_primes(numbers): Returns the average of all the prime numbers in the list. If there are no prime numbers, returns 0. prime_numbers = [num for num in numbers if is_prime(num)] if not prime_numbers: return 0.0 return sum(prime_numbers) / len(prime_numbers)"},{"question":"def check_brackets(s: str) -> str: Determines if the brackets in the string are balanced or not. Args: s (str): The input string containing various characters including brackets. Returns: str: \\"Balanced\\" if the brackets are balanced, otherwise \\"Not Balanced\\". >>> check_brackets(\\"a(b[c]d){e}f\\") \\"Balanced\\" >>> check_brackets(\\"a(b[c)d]{e}f\\") \\"Not Balanced\\" >>> check_brackets(\\"abc{def)ghi\\") \\"Not Balanced\\" >>> check_brackets(\\"[[{()}]]\\") \\"Balanced\\" # Your code goes here","solution":"def check_brackets(s: str) -> str: Determines if the brackets in the string are balanced or not. Args: s (str): The input string containing various characters including brackets. Returns: str: \\"Balanced\\" if the brackets are balanced, otherwise \\"Not Balanced\\". stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return \\"Not Balanced\\" return \\"Balanced\\" if stack == [] else \\"Not Balanced\\""},{"question":"import re def isValidPassword(password: str) -> bool: Checks if the given password meets the following security requirements: 1. At least 8 characters long. 2. Contains at least one uppercase letter. 3. Contains at least one lowercase letter. 4. Contains at least one numerical digit. 5. Contains at least one special character (e.g., @, #, , %, &, *). >>> isValidPassword(\\"Passw0rd!\\") == True >>> isValidPassword(\\"password\\") == False >>> isValidPassword(\\"password1!\\") == False >>> isValidPassword(\\"PASSWORD1!\\") == False >>> isValidPassword(\\"Password!\\") == False >>> isValidPassword(\\"Password1\\") == False >>> isValidPassword(\\"P@ss1\\") == False >>> isValidPassword(\\"Valid123#\\") == True >>> isValidPassword(\\"\\") == False >>> isValidPassword(\\"!!!!!!!!\\") == False >>> isValidPassword(\\"Pass1234\\") == False >>> isValidPassword(\\"Password@\\") == False","solution":"import re def isValidPassword(password): Checks if the given password meets the security requirements. Args: password (str): The password string to check. Returns: bool: True if the password meets all requirements, False otherwise. if len(password) < 8: return False if not re.search(r'[A-Z]', password): return False if not re.search(r'[a-z]', password): return False if not re.search(r'[0-9]', password): return False if not re.search(r'[!@#%^&*(),.?\\":{}|<>[];'/]', password): return False return True"},{"question":"from typing import List def second_max(numbers: List[int]) -> int: Returns the second largest number in the list. >>> second_max([4, 6, 2, 1, 9, 63, -134, 566]) 63 >>> second_max([5, 5, 5, 2]) 2 pass def second_min(numbers: List[int]) -> int: Returns the second smallest number in the list. >>> second_min([-52, 56, 30, 29, -54, 0, -110]) -54 >>> second_min([42, 54, 65, 87, 0]) 42 pass # Unit Tests def test_second_max(): assert second_max([4, 6, 2, 1, 9, 63, -134, 566]) == 63 assert second_max([5, 5, 5, 2]) == 2 assert second_max([-1, -2, -3, -4]) == -2 assert second_max([1, 2]) == 1 def test_second_min(): assert second_min([-52, 56, 30, 29, -54, 0, -110]) == -54 assert second_min([42, 54, 65, 87, 0]) == 42 assert second_min([3, 2, 1, 1, 2]) == 2 assert second_min([2, 1]) == 2","solution":"def second_max(numbers): Returns the second largest number in the list. unique_numbers = list(set(numbers)) unique_numbers.sort() return unique_numbers[-2] def second_min(numbers): Returns the second smallest number in the list. unique_numbers = list(set(numbers)) unique_numbers.sort() return unique_numbers[1]"},{"question":"from typing import List def min_steps_to_treasure(N: int, M: int, start_row: int, start_col: int, grid: List[List[str]]) -> int: Determine the minimum number of steps to reach the treasure 'T' in the grid. The explorer can move up, down, left, or right, but cannot move through obstacles 'X'. The grid is represented as a list of lists of strings, where 'O' is open land. Args: - N (int): Number of rows in the grid. - M (int): Number of columns in the grid. - start_row (int): The starting row index of the explorer. - start_col (int): The starting column index of the explorer. - grid (List[List[str]]): The N x M grid containing 'O', 'X', and 'T'. Returns: - int: The minimum number of steps to reach the treasure, or -1 if not possible. >>> grid = [['O', 'O', 'O', 'X', 'T'], ['O', 'X', 'O', 'O', 'O'], ['O', 'O', 'X', 'T', 'O'], ['T', 'O', 'O', 'X', 'O'], ['O', 'O', 'O', 'O', 'O']] >>> min_steps_to_treasure(5, 5, 0, 0, grid) 3 >>> grid = [['O', 'O', 'X', 'X', 'T'], ['X', 'X', 'X', 'O', 'O'], ['T', 'X', 'X', 'O', 'O'], ['O', 'X', 'O', 'X', 'O'], ['O', 'O', 'O', 'O', 'O']] >>> min_steps_to_treasure(5, 5, 0, 0, grid) -1","solution":"from collections import deque def min_steps_to_treasure(N, M, start_row, start_col, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start_row, start_col, 0)]) # (row, col, steps) visited = set((start_row, start_col)) while queue: row, col, steps = queue.popleft() if grid[row][col] == 'T': return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < M and (new_row, new_col) not in visited and grid[new_row][new_col] != 'X': visited.add((new_row, new_col)) queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"from typing import List def is_convertible_with_one_swap(s: str, t: str) -> str: Determines if it's possible to convert string s to string t by performing at most one swap of any substring. Args: s (str): The original string sorted in ascending order. t (str): The target string. Returns: str: \\"YES\\" if it's possible to convert s to t with at most one swap, else \\"NO\\". >>> is_convertible_with_one_swap(\\"abc\\", \\"acb\\") \\"YES\\" >>> is_convertible_with_one_swap(\\"abc\\", \\"def\\") \\"NO\\" def process_input(num_cases: int, test_cases: List[str]) -> List[str]: Processes the input by invoking is_convertible_with_one_swap for each test case. Args: num_cases (int): The number of test cases. test_cases (List[str]): A list containing pairs of strings s and t. Returns: List[str]: A list of results for each test case, either \\"YES\\" or \\"NO\\". # Function to parse the input and output results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): s = data[index] t = data[index + 1] test_cases.append((s, t)) index += 2 results = process_input(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def is_convertible_with_one_swap(s, t): Determines if it's possible to convert string s to string t by performing at most one swap of any substring. if len(s) != len(t): return \\"NO\\" # If both strings are already equal if s == t: return \\"YES\\" # Iterate and find the indices where s and t differ indices = [] for i in range(len(s)): if s[i] != t[i]: indices.append(i) # If they are exactly the same or have more than two differences if len(indices) != 2: return \\"NO\\" # Swap the two differing indices in s and check if it matches t i, j = indices s = list(s) s[i], s[j] = s[j], s[i] s = ''.join(s) return \\"YES\\" if s == t else \\"NO\\" def process_input(num_cases, test_cases): results = [] for s, t in test_cases: result = is_convertible_with_one_swap(s, t) results.append(result) return results # Function to parse the input and output results def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): s = data[index] t = data[index + 1] test_cases.append((s, t)) index += 2 results = process_input(T, test_cases) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def min_swaps_to_equal_chars(S: str) -> int: Returns the minimum number of swaps needed to make all characters in the string equal. >>> min_swaps_to_equal_chars('abc') == 2 >>> min_swaps_to_equal_chars('aabb') == 0 def solve(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Solve function to handle multiple test cases to find the minimum swaps needed. >>> solve(2, [(3, \\"abc\\"), (4, \\"aabb\\")]) == [2, 0]","solution":"def min_swaps_to_equal_chars(S): Returns the minimum number of swaps needed to make all characters in the string equal. It considers both majorities and chooses the one which gives the fewer swaps. from collections import Counter # Count the frequency of each character freq = Counter(S) max_freq_char = max(freq, key=freq.get) max_freq = freq[max_freq_char] return len(S) - max_freq def solve(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] S = test_cases[t][1] results.append(min_swaps_to_equal_chars(S)) return results"},{"question":"def find_winning_move(s: str) -> str: Determine the lexicographically smallest substring you should remove on your first turn to ensure you win the game. If there is no winning strategy, return \\"NO\\". >>> find_winning_move(\\"ba\\") \\"a\\" >>> find_winning_move(\\"abc\\") \\"a\\" >>> find_winning_move(\\"aabb\\") \\"a\\" def game_strategy(t: int, test_cases: List[str]) -> List[str]: Given the number of test cases and the list of strings for each test case, determine the lexicographically smallest substring to remove on the first turn for each game or \\"NO\\" if there is no winning strategy. >>> game_strategy(3, [\\"ba\\", \\"abc\\", \\"aabb\\"]) [\\"a\\", \\"a\\", \\"a\\"] >>> game_strategy(2, [\\"z\\", \\"xz\\"]) [\\"NO\\", \\"x\\"]","solution":"def find_winning_move(s): if len(s) == 1: return \\"NO\\" min_char = min(s) index = s.find(min_char) if index == -1: return \\"NO\\" return s[index] # since choosing minimum character itself is optimal move def game_strategy(t, test_cases): results = [] for case in test_cases: result = find_winning_move(case) results.append(result) return results"},{"question":"def generate_parentheses(n): Generate all combinations of n pairs of well-formed parentheses. >>> generate_parentheses(1) == [\\"()\\"] >>> generate_parentheses(2) == [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) == [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) == [ \\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\" ] >>> generate_parentheses(0) == [\\"\\"]","solution":"def generate_parentheses(n): Generate all combinations of n pairs of well-formed parentheses. def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) result = [] backtrack() return result"},{"question":"def are_there_super_anagrams(list1: List[str], list2: List[str]) -> str: Determine if there exists at least one pair of super anagrams in two lists of words. >>> are_there_super_anagrams([\\"listen\\", \\"apple\\", \\"silent\\"], [\\"enlist\\", \\"banana\\", \\"tinsel\\"]) \\"YES\\" >>> are_there_super_anagrams([\\"hello\\"], [\\"world\\"]) \\"NO\\"","solution":"def is_super_anagram(word1, word2): Helper function to check if two words are super anagrams. if sorted(word1) == sorted(word2) and sum(ord(char) for char in word1) == sum(ord(char) for char in word2): return True return False def are_there_super_anagrams(list1, list2): Function to check if there exists at least one pair of super anagrams in two lists of words. list2_words_set = set(list2) for word1 in list1: for word2 in list2_words_set: if is_super_anagram(word1, word2): return \\"YES\\" return \\"NO\\""},{"question":"def palindromic_score(S: str) -> int: For a given string \`S\` consisting of lowercase English letters, calculate the \\"palindromic score\\" which is defined as the count of its characters that can be rearranged to form a palindrome. Constraints: * 1 ≤ |S| ≤ 10^5 * \`S\` consists of lowercase English letters. Examples: >>> palindromic_score(\\"abccccdd\\") 7 >>> palindromic_score(\\"aabbccdd\\") 8","solution":"def palindromic_score(S): from collections import Counter char_count = Counter(S) score = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: score += count else: score += count - 1 odd_found = True if odd_found: score += 1 return score"},{"question":"from typing import List, Tuple def determine_winner(test_cases: List[Tuple[int, List[str]]]) -> List[str]: Process the scores of participants in each round and determines the overall winner at the end of the competition. >>> determine_winner([(3, [\\"Alice:25 Bob:20 Charlie:30\\", \\"Alice:30 Charlie:20\\", \\"Bob:50 Charlie:10\\"])]) [\\"Bob\\"] >>> determine_winner([(2, [\\"Dana:45 Eva:20\\", \\"Dana:20 Eva:45\\"])]) [\\"Dana\\"] pass def process_input(input_text: str) -> List[Tuple[int, List[str]]]: Read the test cases from a formatted string input. >>> process_input(\\"2n3nAlice:25 Bob:20 Charlie:30nAlice:30 Charlie:20nBob:50 Charlie:10n2nDana:45 Eva:20nDana:20 Eva:45\\") [(3, [\\"Alice:25 Bob:20 Charlie:30\\", \\"Alice:30 Charlie:20\\", \\"Bob:50 Charlie:10\\"]), (2, [\\"Dana:45 Eva:20\\", \\"Dana:20 Eva:45\\"])] pass","solution":"def determine_winner(test_cases): results = [] for test in test_cases: rounds = test[1:] scores = {} first_to_reach = [] for round_entry in rounds: participants = round_entry.split() for participant in participants: name, score = participant.split(':') score = int(score) if name not in scores: scores[name] = score first_to_reach.append(name) else: scores[name] += score max_score = max(scores.values()) winner = None for name in first_to_reach: if scores[name] == max_score: winner = name break results.append(winner) return results # Read test cases from input def process_input(input_text): lines = input_text.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) rounds = lines[index+1:index+1+N] test_cases.append((N, *rounds)) index += N + 1 return test_cases"},{"question":"def num_subarray_product_less_than_k(nums, k): Given an integer array nums and an integer k, return the number of continuous subarrays where the product of all the elements in the subarray is less than k. >>> num_subarray_product_less_than_k([10, 5, 2, 6], 100) 8 >>> num_subarray_product_less_than_k([1, 2, 3, 4, 5], 0) 0","solution":"def num_subarray_product_less_than_k(nums, k): if k <= 1: return 0 prod = 1 left = 0 count = 0 for right in range(len(nums)): prod *= nums[right] while prod >= k: prod /= nums[left] left += 1 count += right - left + 1 return count"},{"question":"def is_palindrome(number): Returns 'Palindrome' if the number is a palindrome, 'Not a Palindrome' otherwise. >>> is_palindrome(121) == \\"Palindrome\\" True >>> is_palindrome(123) == \\"Not a Palindrome\\" True >>> is_palindrome(111) == \\"Palindrome\\" True >>> is_palindrome(112) == \\"Not a Palindrome\\" True def check_palindromes(test_cases): Given a list of test case numbers, determines if each is a palindrome. Returns a list of results. >>> check_palindromes([121, 123, 222]) ['Palindrome', 'Not a Palindrome', 'Palindrome'] >>> check_palindromes([10, 11, 22]) ['Not a Palindrome', 'Palindrome', 'Palindrome']","solution":"def is_palindrome(number): Returns 'Palindrome' if the number is a palindrome, 'Not a Palindrome' otherwise. num_str = str(number) if num_str == num_str[::-1]: return \\"Palindrome\\" else: return \\"Not a Palindrome\\" def check_palindromes(test_cases): Given a list of test case numbers, determines if each is a palindrome. Returns a list of results. results = [] for n in test_cases: results.append(is_palindrome(n)) return results"},{"question":"def has_pair_with_sum(arr, T): Determines if there exist two distinct numbers in the array whose sum is exactly T. :param arr: List of distinct positive integers :param T: Target sum :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\"","solution":"def has_pair_with_sum(arr, T): Determines if there exist two distinct numbers in the array whose sum is exactly T. :param arr: List of distinct positive integers :param T: Target sum :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen_numbers = set() for number in arr: if T - number in seen_numbers: return \\"YES\\" seen_numbers.add(number) return \\"NO\\""},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: Determine if a binary search tree is balanced. A balanced tree is defined as one where the depth of all leaf nodes (nodes with no children) differ by no more than 1. >>> node1 = TreeNode(1) >>> node3 = TreeNode(3) >>> node2 = TreeNode(2, node1, node3) >>> node9 = TreeNode(9) >>> node8 = TreeNode(8, None, node9) >>> root1 = TreeNode(5, node2, node8) >>> is_balanced_bst(root1) True >>> node2 = TreeNode(2) >>> node3 = TreeNode(3, node2) >>> root2 = TreeNode(1, None, node3) >>> is_balanced_bst(root2) False >>> root3 = TreeNode(1) >>> is_balanced_bst(root3) True >>> root4 = None >>> is_balanced_bst(root4) True >>> node4 = TreeNode(4) >>> node5 = TreeNode(5, node4, None) >>> node6 = TreeNode(6, None, node5) >>> is_balanced_bst(node6) False >>> node7 = TreeNode(7) >>> node3 = TreeNode(3, None, node7) >>> node1 = TreeNode(1, None, node3) >>> is_balanced_bst(node1) False >>> node3 = TreeNode(3) >>> node1 = TreeNode(1) >>> node2 = TreeNode(2, node1, node3) >>> is_balanced_bst(node2) True >>> node5 = TreeNode(5) >>> node3 = TreeNode(3, node5) >>> root8 = TreeNode(3, node3) >>> is_balanced_bst(root8) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def is_balanced_bst(root: TreeNode) -> bool: def check_balance(node): if not node: return 0, True left_height, left_balanced = check_balance(node.left) right_height, right_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) current_balance = left_balanced and right_balanced and abs(left_height - right_height) <= 1 return current_height, current_balance _, is_balanced = check_balance(root) return is_balanced"},{"question":"def simulate_shelves(n, m, instructions): Simulates the placement and removal of boxes on shelves based on the given instructions. Args: n (int): The number of instructions. m (int): The number of shelves. instructions (list): List of instructions to be executed. Returns: list: Final state of the shelves. shelves = [0] * m for instruction in instructions: parts = instruction.split() action = parts[0] shelf = int(parts[1]) - 1 # Converting 1-based index to 0-based index if action == \\"P\\": box = int(parts[2]) if 0 <= shelf < m and shelves[shelf] == 0: shelves[shelf] = box elif action == \\"R\\": if 0 <= shelf < m: shelves[shelf] = 0 return shelves # Unit tests def test_simulate_shelves_example(): n = 7 m = 3 instructions = [\\"P 1 5\\", \\"P 2 3\\", \\"P 3 6\\", \\"P 1 4\\", \\"R 2\\", \\"P 2 7\\", \\"R 3\\"] assert simulate_shelves(n, m, instructions) == [5, 7, 0] def test_simulate_shelves_all_empty(): n = 3 m = 3 instructions = [\\"R 1\\", \\"R 2\\", \\"R 3\\"] assert simulate_shelves(n, m, instructions) == [0, 0, 0] def test_simulate_shelves_placing_and_removing(): n = 5 m = 4 instructions = [\\"P 1 1\\", \\"P 2 2\\", \\"P 3 3\\", \\"P 4 4\\", \\"R 2\\"] assert simulate_shelves(n, m, instructions) == [1, 0, 3, 4] def test_simulate_shelves_ignore_replacing(): n = 3 m = 2 instructions = [\\"P 1 10\\", \\"P 1 20\\", \\"R 1\\"] assert simulate_shelves(n, m, instructions) == [0, 0] def test_simulate_shelves_ignore_invalid_shelf(): n = 2 m = 2 instructions = [\\"P 3 1\\", \\"R 3\\"] assert simulate_shelves(n, m, instructions) == [0, 0]","solution":"def simulate_shelves(n, m, instructions): Simulates the placement and removal of boxes on shelves based on the given instructions. Args: n (int): The number of instructions. m (int): The number of shelves. instructions (list): List of instructions to be executed. Returns: list: Final state of the shelves. shelves = [0] * m for instruction in instructions: parts = instruction.split() action = parts[0] shelf = int(parts[1]) - 1 # Converting 1-based index to 0-based index if action == \\"P\\": box = int(parts[2]) if 0 <= shelf < m and shelves[shelf] == 0: shelves[shelf] = box elif action == \\"R\\": if 0 <= shelf < m: shelves[shelf] = 0 return shelves # Example usage: # n = 7 # m = 3 # instructions = [\\"P 1 5\\", \\"P 2 3\\", \\"P 3 6\\", \\"P 1 4\\", \\"R 2\\", \\"P 2 7\\", \\"R 3\\"] # print(simulate_shelves(n, m, instructions))"},{"question":"def most_beautiful_combination(n: int, m: int, d: List[int]) -> List[int]: Returns the most beautiful combination of m distinct types of cakes with the maximum sum of decoration values. Parameters: - n: int, the number of types of cakes - m: int, the number of distinct types of cakes to select - d: list of int, the decoration values of the n types of cakes Returns: - list of int, the decoration values of the selected cakes >>> most_beautiful_combination(5, 3, [1, 3, 5, 7, 9]) [5, 7, 9] >>> most_beautiful_combination(4, 2, [4, 2, 8, 6]) [6, 8]","solution":"def most_beautiful_combination(n, m, d): Returns the most beautiful combination of m distinct types of cakes with the maximum sum of decoration values. Parameters: - n: int, the number of types of cakes - m: int, the number of distinct types of cakes to select - d: list of int, the decoration values of the n types of cakes Returns: - list of int, the decoration values of the selected cakes # Sort the list of decoration values in descending order d_sorted = sorted(d, reverse=True) # Select the first m elements from the sorted list return d_sorted[:m]"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string containing non-negative integers and the operators +, -, *, and /, and returns the result as an integer. pass def test_basic_expression(): assert evaluate_expression(\\"3+5\\") == 8 def test_multiplication_and_division(): assert evaluate_expression(\\"10+2*6\\") == 22 assert evaluate_expression(\\"100*2+12\\") == 212 assert evaluate_expression(\\"100*(2+12)\\") == 1400 def test_parentheses(): assert evaluate_expression(\\"(2+3)*4\\") == 20 assert evaluate_expression(\\"(2*(5+5))\\") == 20 def test_combined_operations(): assert evaluate_expression(\\"10+2*6-4/2\\") == 20 def test_nested_parentheses(): assert evaluate_expression(\\"((2+3)*2)/2\\") == 5 def test_large_numbers(): assert evaluate_expression(\\"1000000+2000000\\") == 3000000 def test_combined_high_precendence_operations(): assert evaluate_expression(\\"10*10/2\\") == 50","solution":"def evaluate_expression(expression: str) -> int: Evaluates a given arithmetic expression string containing non-negative integers and the operators +, -, *, and /, and returns the result as an integer. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 return 0 def apply_op(a, b, op): if op == '+': return a + b if op == '-': return a - b if op == '*': return a * b if op == '/': return a // b values = [] ops = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': ops.append(expression[i]) elif expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = (val * 10) + int(expression[i]) i += 1 values.append(val) i -= 1 elif expression[i] == ')': while len(ops) != 0 and ops[-1] != '(': val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.pop() else: while (len(ops) != 0 and precedence(ops[-1]) >= precedence(expression[i])): val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) ops.append(expression[i]) i += 1 while len(ops) != 0: val2 = values.pop() val1 = values.pop() op = ops.pop() values.append(apply_op(val1, val2, op)) return values[-1]"},{"question":"def tree_heights_sum(n, q, heights, queries): Returns the sum of heights of trees for given ranges. Parameters: n (int): Number of trees q (int): Number of queries heights (list of int): Initial heights of trees queries (list of tuple): List containing ranges (l, r) as tuples Returns: list of int: Sum of heights for each query range pass # Example usage: # n = 5 # q = 3 # heights = [4, 2, 1, 6, 3] # queries = [(1, 3), (2, 4), (3, 5)] # print(tree_heights_sum(n, q, heights, queries)) # Output: [7, 9, 10]","solution":"def tree_heights_sum(n, q, heights, queries): Returns the sum of heights of trees for given ranges. Parameters: n (int): Number of trees q (int): Number of queries heights (list of int): Initial heights of trees queries (list of tuple): List containing ranges (l, r) as tuples Returns: list of int: Sum of heights for each query range prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + heights[i] results = [] for l, r in queries: results.append(prefix_sum[r] - prefix_sum[l - 1]) return results"},{"question":"def count_substring_occurrences(S: str, P: str) -> int: Returns the number of times the substring P appears in the string S, including overlapping occurrences. >>> count_substring_occurrences(\\"ababa\\", \\"aba\\") 2 >>> count_substring_occurrences(\\"aaaaa\\", \\"aa\\") 4 >>> count_substring_occurrences(\\"abcdef\\", \\"gh\\") 0 >>> count_substring_occurrences(\\"abc\\", \\"abc\\") 1 >>> count_substring_occurrences(\\"aaaaa\\", \\"a\\") 5 >>> count_substring_occurrences(\\"abababab\\", \\"ab\\") 4 >>> count_substring_occurrences(\\"abcdefabc\\", \\"abc\\") 2","solution":"def count_substring_occurrences(S, P): Returns the number of times the substring P appears in the string S, including overlapping occurrences. count = 0 start = 0 while start <= len(S) - len(P): pos = S.find(P, start) if pos == -1: break else: count += 1 start = pos + 1 return count"},{"question":"def count_pairs_divisible_by_k(N, K, array): Given an integer array, find the number of pairs (i, j) such that 1 <= i < j <= N and (arr[i] + arr[j]) is divisible by a given integer K. >>> count_pairs_divisible_by_k(5, 3, [1, 2, 3, 4, 5]) 4 >>> count_pairs_divisible_by_k(6, 2, [2, 4, 6, 8, 10, 12]) 15 def process_test_cases(test_cases): Process multiple test cases to find the number of pairs (i, j) such that 1 <= i < j <= N and (arr[i] + arr[j]) is divisible by a given integer K for each test case. >>> test_cases = [ ... (5, 3, [1, 2, 3, 4, 5]), ... (6, 2, [2, 4, 6, 8, 10, 12]) ... ] >>> process_test_cases(test_cases) [4, 15]","solution":"def count_pairs_divisible_by_k(N, K, array): count = 0 for i in range(N): for j in range(i + 1, N): if (array[i] + array[j]) % K == 0: count += 1 return count def process_test_cases(test_cases): results = [] for N, K, array in test_cases: results.append(count_pairs_divisible_by_k(N, K, array)) return results"},{"question":"def min_absolute_difference(n: int, k: int, arr: List[int]) -> int: Returns the minimum absolute difference between the sum of any two subarrays of length k. >>> min_absolute_difference(5, 2, [10, -2, 4, -1, 2]) 1 >>> min_absolute_difference(5, 1, [10, -2, 4, -1, 2]) 1 >>> min_absolute_difference(4, 2, [3, 3, 3, 3]) 0 >>> min_absolute_difference(7, 3, [1, 3, 5, 7, 9, 11, 13]) 6 >>> min_absolute_difference(5, 2, [1000, -1000, 1000, -1000, 1000]) 0","solution":"def min_absolute_difference(n, k, arr): Returns the minimum absolute difference between the sum of any two subarrays of length k. # Find sums of all subarrays of length k subarray_sums = [sum(arr[i:i + k]) for i in range(n - k + 1)] # Find the minimum absolute difference between any two subarray sums min_diff = float('inf') for i in range(len(subarray_sums)): for j in range(i + 1, len(subarray_sums)): min_diff = min(min_diff, abs(subarray_sums[i] - subarray_sums[j])) return min_diff"},{"question":"def longest_homogeneous_substring(n: int, k: int, s: str) -> int: Determine the length of the longest substring consisting of identical characters that can be achieved by performing at most k operations on the string s. >>> longest_homogeneous_substring(8, 1, 'aabbccdd') 3 >>> longest_homogeneous_substring(6, 2, 'abbacc') 4 >>> longest_homogeneous_substring(3, 3, 'abc') 3","solution":"def longest_homogeneous_substring(n, k, s): from collections import defaultdict def max_length_with_char_replacement(ch): left = 0 max_len = 0 max_freq = 0 count = defaultdict(int) for right in range(n): if s[right] == ch: count[ch] += 1 max_freq = max(max_freq, count[ch]) # If the window is invalid (more than k replacements on other characters) if (right - left + 1) - max_freq > k: if s[left] == ch: count[ch] -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_len = 0 for ch in set(s): max_len = max(max_len, max_length_with_char_replacement(ch)) return max_len"},{"question":"def find_unique_number(arr: List[int]) -> int: Finds the number that appears only once in the array where every other number appears twice. :param arr: List[int] - A list of non-negative integers :return: int - The number that appears only once >>> find_unique_number([2, 2, 3, 4, 4, 5, 5]) 3 >>> find_unique_number([1, 1, 2, 2, 3]) 3 # Test cases def test_example_cases(): assert find_unique_number([2, 2, 3, 4, 4, 5, 5]) == 3 assert find_unique_number([1, 1, 2, 2, 3]) == 3 def test_single_element(): assert find_unique_number([7]) == 7 def test_large_numbers(): assert find_unique_number([1000000, 999999, 1000000, 999998, 999999]) == 999998 def test_multiple_same_numbers(): assert find_unique_number([9, 8, 9, 7, 8, 7, 6]) == 6 def test_small_numbers(): assert find_unique_number([0, 1, 0, 2, 2, 1, 3]) == 3 def test_mixed_sequence(): assert find_unique_number([10, 10, 10, 20, 10, 20, 30]) == 30","solution":"def find_unique_number(arr): Finds the number that appears only once in the array where every other number appears twice. :param arr: List[int] - A list of non-negative integers :return: int - The number that appears only once unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"def sorted_numbers_from_feedback(feedbacks): Extracts numbers from each feedback string, sorts them, and concatenates them into a single string. Parameters: feedbacks (list): List of feedback strings. Returns: list: List of strings where each string contains the sorted numbers extracted from the corresponding feedback string. Examples: >>> sorted_numbers_from_feedback([\\"great3experience4\\", \\"love1it2\\", \\"no9issues8\\"]) ['34', '12', '89'] >>> sorted_numbers_from_feedback([\\"abc123\\", \\"def456\\", \\"ghi789\\"]) ['123', '456', '789'] >>> sorted_numbers_from_feedback([\\"\\", \\"noDigitsHere\\", \\"123abc456\\"]) ['', '', '123456'] >>> sorted_numbers_from_feedback([\\"0zero1one\\", \\"2two3three\\", \\"4four5five\\"]) ['01', '23', '45'] >>> sorted_numbers_from_feedback([\\"a1b2c3\\", \\"z9y8x7\\", \\"m6n5o4\\"]) ['123', '789', '456'] >>> sorted_numbers_from_feedback([\\"1\\", \\"2\\", \\"3\\"]) ['1', '2', '3'] >>> sorted_numbers_from_feedback([\\"\\"] * 3) ['', '', ''] >>> sorted_numbers_from_feedback([\\"one1two2three3\\", \\"4four5five6\\", \\"\\"]) ['123', '456', '']","solution":"def sorted_numbers_from_feedback(feedbacks): Extracts numbers from each feedback string, sorts them, and concatenates them into a single string. Parameters: feedbacks (list): List of feedback strings. Returns: list: List of strings where each string contains the sorted numbers extracted from the corresponding feedback string. result = [] for feedback in feedbacks: numbers = sorted([char for char in feedback if char.isdigit()]) result.append(''.join(numbers)) return result"},{"question":"def is_path_exist(n: int, m: int, grid: List[List[str]]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of a grid. You can move up, down, left, or right, but not diagonally. Parameters: - n (int): number of rows in the grid. - m (int): number of columns in the grid. - grid (List[List[str]]): 2D grid of size n x m where each cell is either '.' or '#'. Returns: - str: \\"YES\\" if there is a path from the top-left corner to the bottom-right corner, otherwise \\"NO\\". Example: >>> is_path_exist(4, 4, [ ... ['.','.','.','.'], ... ['.','#','#','.'], ... ['.','#','.','.'], ... ['.','.','.','.'] ... ]) \\"YES\\" >>> is_path_exist(3, 3, [ ... ['.','.','.'], ... ['#','#','#'], ... ['.','.','#'] ... ]) \\"NO\\" from solution import is_path_exist def test_no_path_due_to_initial_or_final_block(): grid1 = [ ['#', '.', '.'], ['.', '#', '.'], ['.', '.', '#'] ] assert is_path_exist(3, 3, grid1) == \\"NO\\" grid2 = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '#'] ] assert is_path_exist(3, 3, grid2) == \\"NO\\" def test_path_exist(): grid1 = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert is_path_exist(3, 3, grid1) == \\"YES\\" grid2 = [ ['.', '.', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert is_path_exist(3, 3, grid2) == \\"YES\\" def test_no_path_due_to_blocked_cells(): grid1 = [ ['.', '.', '.'], ['#', '#', '#'], ['.', '.', '.'] ] assert is_path_exist(3, 3, grid1) == \\"NO\\" grid2 = [ ['.', '#', '.'], ['#', '#', '.'], ['.', '.', '.'] ] assert is_path_exist(3, 3, grid2) == \\"NO\\" def test_minimum_grid_size(): grid1 = [ ['.'] ] assert is_path_exist(1, 1, grid1) == \\"YES\\" grid2 = [ ['#'] ] assert is_path_exist(1, 1, grid2) == \\"NO\\" def test_non_traversable_initial_or_final_position(): grid1 = [ ['#', '.'], ['.', '.'] ] assert is_path_exist(2, 2, grid1) == \\"NO\\" grid2 = [ ['.', '.'], ['#', '#'] ] assert is_path_exist(2, 2, grid2) == \\"NO\\"","solution":"def is_path_exist(n, m, grid): from collections import deque if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" # Directions: Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: queue.append((nx, ny)) visited.add((nx, ny)) return \\"NO\\""},{"question":"def min_warehouses(n: int, m: int, r: int, k: int, buildings: List[Tuple[int, int]]) -> int: Calculate the minimum number of warehouses required to cover all buildings in a city grid. Args: n (int): The number of rows in the city grid. m (int): The number of columns in the city grid. r (int): The coverage radius of each warehouse. k (int): The number of buildings in the city. buildings (List[Tuple[int, int]]): The list of building coordinates (x, y). Returns: int: The minimum number of warehouses required to cover all buildings. >>> min_warehouses(5, 5, 2, 3, [(1, 1), (4, 4), (2, 3)]) 2 >>> min_warehouses(5, 5, 2, 0, []) 0 >>> min_warehouses(5, 5, 2, 1, [(2, 2)]) 1 >>> min_warehouses(5, 5, 5, 4, [(1, 1), (1, 4), (4, 1), (4, 4)]) 1 >>> min_warehouses(10, 10, 2, 3, [(1, 1), (8, 8), (5, 5)]) 3 >>> min_warehouses(50, 50, 3, 5, [(1, 1), (10, 10), (20, 20), (30, 30), (40, 40)]) 5","solution":"from math import dist def min_warehouses(n, m, r, k, buildings): if k == 0: return 0 covered = [False] * k warehouses = [] def is_covered(building): x, y = building for wx, wy in warehouses: if dist((x, y), (wx, wy)) <= r: return True return False while not all(covered): max_covered = 0 best_warehouse = (0, 0) for i in range(n): for j in range(m): count = 0 for index, (bx, by) in enumerate(buildings): if not covered[index] and dist((i, j), (bx, by)) <= r: count += 1 if count > max_covered: max_covered = count best_warehouse = (i, j) warehouses.append(best_warehouse) for index, (bx, by) in enumerate(buildings): if dist(best_warehouse, (bx, by)) <= r: covered[index] = True return len(warehouses) # example usage n, m = 5, 5 r = 2 k = 3 buildings = [(1, 1), (4, 4), (2, 3)] print(min_warehouses(n, m, r, k, buildings)) # Output: 2"},{"question":"def rearrange_by_median(arr): Rearranges the array such that the median is at the first position, followed by elements in increasing order of their distance from the median. >>> rearrange_by_median([3, 1, 2, 5, 4]) [3, 2, 4, 1, 5] >>> rearrange_by_median([6, 7, 2, 3, 1, 5, 4]) [4, 3, 5, 2, 6, 1, 7] >>> rearrange_by_median([9, 12, 15, 20, 30, 50]) [15, 12, 20, 9, 30, 50] >>> rearrange_by_median([1, 1, 1, 1, 1, 1]) [1, 1, 1, 1, 1, 1] >>> rearrange_by_median([]) [] >>> rearrange_by_median([1]) [1] >>> rearrange_by_median([10, 20]) [10, 20] or rearrange_by_median([10, 20]) [20, 10]","solution":"def rearrange_by_median(arr): Rearranges the array such that the median is at the first position, followed by elements in increasing order of their distance from the median. if not arr: return [] # Sort the array to find the median sorted_arr = sorted(arr) # Find the median mid_index = len(sorted_arr) // 2 if len(sorted_arr) % 2 == 0: median = sorted_arr[mid_index - 1] else: median = sorted_arr[mid_index] # Create a list of tuples (distance, value) to sort based on distance from the median arr_with_distance = [(abs(x - median), x) for x in arr] # Sort the array based on the distance (first tuple element) arr_with_distance.sort() # Extract the sorted values maintaining the order sorted_distance_values = [x[1] for x in arr_with_distance] return sorted_distance_values"},{"question":"def encode_message(message, shift): Encodes a message using Caesar cipher with a given shift. >>> encode_message(\\"abc\\", 1) \\"bcd\\" >>> encode_message(\\"xyz\\", 1) \\"yza\\" >>> encode_message(\\"ABC\\", 1) \\"BCD\\" >>> encode_message(\\"XYZ\\", 1) \\"YZA\\" >>> encode_message(\\"Hello, World!\\", 3) \\"Khoor, Zruog!\\" >>> encode_message(\\"abc-XYZ 123\\", 5) \\"fgh-CDE 123\\"","solution":"def encode_message(message, shift): Encodes a message using Caesar cipher with a given shift. def shift_char(c, shift): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift) % 26 + ord('A')) else: return c return ''.join(shift_char(c, shift) for c in message)"},{"question":"from typing import List, Tuple def find_plots(M: int, D: int) -> List[Tuple[int, int]]: Function to find possible coordinates for D vegetable plots in an MxM grid. Each plot is a 1x1 square, no two plots share a row or a column, and the Manhattan distance between any two plots is at least 3. Args: M : int : size of the grid (MxM) D : int : number of plots Returns: List[Tuple[int, int]] : a list of tuples representing the coordinates of the plots, or an empty list if the arrangement is not possible. >>> find_plots(4, 3) [(0, 0), (2, 2), (3, 3)] >>> find_plots(5, 5) [(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)] >>> find_plots(5, 6) [] pass def vegetable_garden(test_cases: List[Tuple[int, int]]) -> List[str]: Function to determine if it’s possible to arrange the plots for each test case. Args: test_cases : List[Tuple[int, int]] : A list of tuples where each tuple contains two integers M and D. Returns: List[str] : a list of strings, each representing the result of the test case. Either the coordinates of the plots in the form \\"x y\\", or \\"This arrangement is not possible\\" if the arrangement is not possible. >>> vegetable_garden([(4, 3), (5, 5)]) [\\"0 0n2 2n3 3\\", \\"0 0n1 1n2 2n3 3n4 4\\"] >>> vegetable_garden([(6, 7)]) [\\"This arrangement is not possible\\"] pass","solution":"def find_plots(M, D): Function to find possible coordinates for D vegetable plots in an MxM grid. if D > M: return \\"This arrangement is not possible\\" plots = [] for i in range(D): plots.append((i, i)) return plots def vegetable_garden(test_cases): results = [] for M, D in test_cases: result = find_plots(M, D) if result == \\"This arrangement is not possible\\": results.append(result) else: results.append(\\"n\\".join(\\" \\".join(map(str, plot)) for plot in result)) return results"},{"question":"def count_photos_by_date(n, timestamps): Groups and counts photos by their creation date. Args: n (int): Number of photos. timestamps (list of str): List of timestamps in \\"YYYY-MM-DD hh:mm:ss\\" format. Returns: list of tuple: Each tuple contains a date (str) and count (int) of photos taken on that date, in chronological order. Examples: >>> count_photos_by_date(5, [\\"2023-09-21 09:12:33\\", \\"2023-09-21 10:45:22\\", \\"2023-09-22 14:22:08\\", \\"2023-09-23 11:55:19\\", \\"2023-09-21 23:59:59\\"]) [(\\"2023-09-21\\", 3), (\\"2023-09-22\\", 1), (\\"2023-09-23\\", 1)] >>> count_photos_by_date(7, [\\"2022-01-01 00:00:01\\", \\"2022-01-01 12:34:56\\", \\"2022-01-01 23:45:23\\", \\"2022-12-31 18:22:50\\", \\"2023-01-01 00:15:15\\", \\"2023-01-01 03:45:19\\", \\"2023-01-02 12:23:45\\"]) [(\\"2022-01-01\\", 3), (\\"2022-12-31\\", 1), (\\"2023-01-01\\", 2), (\\"2023-01-02\\", 1)]","solution":"def count_photos_by_date(n, timestamps): Groups and counts photos by their creation date. Args: n (int): Number of photos. timestamps (list of str): List of timestamps in \\"YYYY-MM-DD hh:mm:ss\\" format. Returns: list of tuple: Each tuple contains a date (str) and count (int) of photos taken on that date, in chronological order. from collections import defaultdict photo_counts = defaultdict(int) for timestamp in timestamps: date = timestamp.split()[0] photo_counts[date] += 1 sorted_dates = sorted(photo_counts.items()) return sorted_dates"},{"question":"def largest_uniform_subgrid(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum possible size of a square subgrid where all cells have the same integer value in the given grid representing a field of plants. >>> largest_uniform_subgrid(4, 5, [[1, 2, 2, 3, 4], [2, 1, 1, 1, 5], [2, 1, 1, 1, 1], [3, 3, 3, 3, 3]]) == 2 >>> largest_uniform_subgrid(3, 3, [[1, 2, 1], [1, 1, 1], [1, 2, 1]]) == 1 >>> largest_uniform_subgrid(2, 2, [[4, 4], [4, 4]]) == 2 >>> largest_uniform_subgrid(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 1 >>> largest_uniform_subgrid(1, 1, [[7]]) == 1 >>> largest_uniform_subgrid(4, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 4","solution":"def largest_uniform_subgrid(n, m, grid): def is_uniform(i, j, size): height = grid[i][j] for x in range(i, i + size): for y in range(j, j + size): if grid[x][y] != height: return False return True max_side = 0 for size in range(1, min(n, m) + 1): for i in range(n - size + 1): for j in range(m - size + 1): if is_uniform(i, j, size): max_side = size return max_side"},{"question":"def best_candidate(data): Returns the name of the person with the highest score. If there is a tie, returns the name of the youngest person among them. :param data: List of dictionaries with \\"name\\", \\"age\\", and \\"score\\" keys :type data: list :return: Name of the person with the highest score and youngest age in case of a tie :rtype: str >>> best_candidate([{\\"name\\": \\"Alice\\", \\"age\\": 30, \\"score\\": 85}, {\\"name\\": \\"Bob\\", \\"age\\": 25, \\"score\\": 90}, {\\"name\\": \\"Charlie\\", \\"age\\": 35, \\"score\\": 90}]) \\"Bob\\" >>> best_candidate([{\\"name\\": \\"Dave\\", \\"age\\": 20, \\"score\\": 75}, {\\"name\\": \\"Eve\\", \\"age\\": 22, \\"score\\": 88}, {\\"name\\": \\"Frank\\", \\"age\\": 23, \\"score\\": 88}, {\\"name\\": \\"Grace\\", \\"age\\": 21, \\"score\\": 88}]) \\"Grace\\" >>> best_candidate([{\\"name\\": \\"Hector\\", \\"age\\": 40, \\"score\\": 100}]) \\"Hector\\" >>> best_candidate([]) None","solution":"def best_candidate(data): Returns the name of the person with the highest score. If there is a tie, returns the name of the youngest person among them. :param data: List of dictionaries with \\"name\\", \\"age\\", and \\"score\\" keys :type data: list :return: Name of the person with the highest score and youngest age in case of a tie :rtype: str if not data: return None # Find the highest score max_score = max(item['score'] for item in data) # Filter candidates who have the highest score candidates = [item for item in data if item['score'] == max_score] # Find the youngest among the candidates with highest score youngest = min(candidates, key=lambda x: x['age']) return youngest['name']"},{"question":"def total_strikes(n: int) -> int: Returns the total number of strikes after n full revolutions of the clock hand. The pattern of strikes is given by the sum of the first n odd numbers. This sum can be directly computed using the formula n^2, as the sum of the first n odd numbers is always n^2. >>> total_strikes(1) == 1 >>> total_strikes(3) == 9 >>> total_strikes(5) == 25 >>> total_strikes(10) == 100 >>> total_strikes(1000) == 1000000 pass","solution":"def total_strikes(n): Returns the total number of strikes after n full revolutions of the clock hand. The pattern of strikes is given by the sum of the first n odd numbers. This sum can be directly computed using the formula n^2, as the sum of the first n odd numbers is always n^2. return n * n"},{"question":"from typing import List def find_order(n: int, m: int, edges: List[List[int]]) -> str: Determines the order of assembly for the components or if it is impossible. def solve(inputs: List[str]) -> List[str]: Processes multiple test cases to find assembly order or detect impossibility. >>> inputs = [ \\"2\\", \\"4 4\\", \\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 1\\", \\"3 2\\", \\"1 2\\", \\"2 3\\" ] >>> solve(inputs) [\\"impossible\\", \\"1 2 3\\"] >>> inputs = [ \\"1\\", \\"5 5\\", \\"1 2\\", \\"2 3\\", \\"3 4\\", \\"4 5\\", \\"3 5\\" ] >>> solve(inputs) [\\"1 2 3 4 5\\"]","solution":"from collections import defaultdict, deque def find_order(n, m, edges): in_degree = {i: 0 for i in range(1, n+1)} graph = defaultdict(list) for u, v in edges: graph[u].append(v) in_degree[v] += 1 # All nodes with no incoming edges no_incoming = deque([node for node in in_degree if in_degree[node] == 0]) order = [] while no_incoming: node = no_incoming.popleft() order.append(node) for neighbour in graph[node]: in_degree[neighbour] -= 1 if in_degree[neighbour] == 0: no_incoming.append(neighbour) if len(order) == n: return \\" \\".join(map(str, order)) else: return \\"impossible\\" def solve(inputs): results = [] index = 0 T = int(inputs[index]) index += 1 for _ in range(T): n, m = map(int, inputs[index].split()) index += 1 edges = [] for __ in range(m): u, v = map(int, inputs[index].split()) edges.append((u, v)) index += 1 result = find_order(n, m, edges) results.append(result) return results"},{"question":"from typing import List def min_subarray_with_sum(nums: List[int], target: int) -> List[int]: Find the shortest subarray whose sum is equal to or greater than a given target value. Args: nums (List[int]): A list of integers. target (int): The target sum. Returns: List[int]: The shortest subarray with sum equal to or greater than target, or an empty list if no such subarray exists. Examples: >>> min_subarray_with_sum([2, 3, 1, 2, 4, 3], 7) [4, 3] >>> min_subarray_with_sum([1, 4, 4], 8) [4, 4] >>> min_subarray_with_sum([1, 1, 1, 1, 1, 1, 1, 1], 11) [] # Implementation here","solution":"def min_subarray_with_sum(nums, target): n = len(nums) left = 0 current_sum = 0 min_length = float('inf') result = [] for right in range(n): current_sum += nums[right] while current_sum >= target: if right - left + 1 < min_length: min_length = right - left + 1 result = nums[left:right+1] current_sum -= nums[left] left += 1 return result"},{"question":"from typing import List def max_soldiers_destroyed(battlefield: List[List[int]]) -> int: Calculate the maximum number of HYDRA soldiers Captain America can strike down in one throw. >>> max_soldiers_destroyed([ [0, 1, 1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0] ]) 3 >>> max_soldiers_destroyed([ [0, 1, 0, 0, 0], [0, -1, 1, 1, 0], [0, 1, -1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ]) 2 ... def solve(T: int, test_cases: List[List[List[int]]]) -> List[int]: Solve the problem for multiple test cases. >>> solve(2, [ [ [0, 1, 1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0] ], [ [0, 1, 0, 0, 0], [0, -1, 1, 1, 0], [0, 1, -1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ], ]) [3, 2] ... def test_max_soldiers_destroyed(): assert max_soldiers_destroyed([ [0, 1, 1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0] ]) == 3 assert max_soldiers_destroyed([ [0, 1, 0, 0, 0], [0, -1, 1, 1, 0], [0, 1, -1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ]) == 2 assert max_soldiers_destroyed([ [0, 0, 0], [0, -1, 0], [0, 0, 0] ]) == 0 assert max_soldiers_destroyed([ [1, 1, 1], [1, -1, 1], [1, 1, 1] ]) == 3 def test_solve(): test_cases = [ [ [0, 1, 1, 0], [1, -1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 0] ], [ [0, 1, 0, 0, 0], [0, -1, 1, 1, 0], [0, 1, -1, 0, 1], [0, 0, 0, 0, 0], [1, 0, 1, 0, 1] ], ] assert solve(2, test_cases) == [3, 2]","solution":"def max_soldiers_destroyed(battlefield): N = len(battlefield) M = len(battlefield[0]) max_soldiers = 0 # Horizontal check for i in range(N): count = 0 for j in range(M): if battlefield[i][j] == -1: count = 0 elif battlefield[i][j] == 1: count += 1 max_soldiers = max(max_soldiers, count) else: count = 0 # Vertical check for j in range(M): count = 0 for i in range(N): if battlefield[i][j] == -1: count = 0 elif battlefield[i][j] == 1: count += 1 max_soldiers = max(max_soldiers, count) else: count = 0 return max_soldiers def solve(T, test_cases): results = [] for battlefield in test_cases: result = max_soldiers_destroyed(battlefield) results.append(result) return results"},{"question":"def balancedBrackets(s: str) -> bool: Determines if the brackets in the input string are properly balanced. Args: s (str): A string containing various types of brackets. Returns: bool: True if the brackets are balanced, False otherwise. >>> balancedBrackets(\\"()\\") True >>> balancedBrackets(\\"(())\\") True >>> balancedBrackets(\\"(()\\") False >>> balancedBrackets(\\"[]\\") True >>> balancedBrackets(\\"[[]]\\") True >>> balancedBrackets(\\"[[\\") False >>> balancedBrackets(\\"{}\\") True >>> balancedBrackets(\\"{{}}\\") True >>> balancedBrackets(\\"{{}\\") False >>> balancedBrackets(\\"([])\\") True >>> balancedBrackets(\\"([)]\\") False >>> balancedBrackets(\\"{[()]}\\") True >>> balancedBrackets(\\"{[(])}\\") False >>> balancedBrackets(\\"\\") True >>> balancedBrackets(\\"(((\\") False >>> balancedBrackets(\\"[[[\\") False >>> balancedBrackets(\\"{[\\") False >>> balancedBrackets(\\"{[a+b]*(c+d)/e}\\") True >>> balancedBrackets(\\"{[a+b]*([c+d)/e]}\\") False","solution":"def balancedBrackets(s): Determines if the brackets in the input string are properly balanced. Args: s (str): A string containing various types of brackets. Returns: bool: True if the brackets are balanced, False otherwise. stack = [] bracket_map = {')': '(', ']': '[', '}': '{'} for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False else: continue return stack == []"},{"question":"def balance_parentheses(test_cases): Determines if each provided sequence of parentheses is balanced. Args: test_cases (list): A list of strings containing only '(' and ')'. Returns: list: A list of strings \\"BALANCED\\" or \\"NOT BALANCED\\" for each input sequence. Example: >>> balance_parentheses([\\"(())\\", \\"(()\\", \\"()()()\\"]) [\\"BALANCED\\", \\"NOT BALANCED\\", \\"BALANCED\\"] >>> balance_parentheses([\\"()\\", \\"(((\\", \\"(())) [\\"BALANCED\\", \\"NOT BALANCED\\", \\"NOT BALANCED\\"] def test_balance_parentheses(): # Test examples provided in the question assert balance_parentheses([\\"(())\\", \\"(()\\", \\"()()()\\"]) == [\\"BALANCED\\", \\"NOT BALANCED\\", \\"BALANCED\\"] # Additional tests # Balanced sequences assert balance_parentheses([\\"()\\", \\"((()))\\", \\"()()\\"]) == [\\"BALANCED\\", \\"BALANCED\\", \\"BALANCED\\"] # Not balanced sequences assert balance_parentheses([\\")(\\", \\"(((\\", \\"(()))(\\"]) == [\\"NOT BALANCED\\", \\"NOT BALANCED\\", \\"NOT BALANCED\\"] # Mixed cases assert balance_parentheses([\\"(((())))\\", \\"())(()\\"]) == [\\"BALANCED\\", \\"NOT BALANCED\\"] # Empty string (a boundary case) assert balance_parentheses([\\"\\"]) == [\\"BALANCED\\"] # An empty sequence can be considered as balanced # Large balanced string assert balance_parentheses([\\"(\\" * 50 + \\")\\" * 50]) == [\\"BALANCED\\"] # Large unbalanced string assert balance_parentheses([\\"(\\" * 51 + \\")\\" * 50]) == [\\"NOT BALANCED\\"] test_balance_parentheses()","solution":"def balance_parentheses(test_cases): Determines if each provided sequence of parentheses is balanced. Args: test_cases (list): A list of strings containing only '(' and ')'. Returns: list: A list of strings \\"BALANCED\\" or \\"NOT BALANCED\\" for each input sequence. results = [] for sequence in test_cases: balance = 0 balanced = True for char in sequence: if char == '(': balance += 1 elif char == ')': balance -= 1 if balance < 0: balanced = False break if balance != 0: balanced = False results.append(\\"BALANCED\\" if balanced else \\"NOT BALANCED\\") return results"},{"question":"def find_majority_element(arr): Identifies and returns the majority element from the list. The majority element is the one that appears more than half of the times. If no such element exists, returns -1. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) -1 >>> find_majority_element([1]) 1 >>> find_majority_element([]) -1 >>> find_majority_element([2, 2, 2, 2, 2]) 2 >>> find_majority_element([5, 5, 5, 1, 2, 5, 5]) 5 >>> find_majority_element([1, 2, 3, 4, 5, 5, 5, 5, 5]) 5","solution":"def find_majority_element(arr): Identifies and returns the majority element from the list. The majority element is the one that appears more than half of the times. If no such element exists, returns -1. element_count = {} half_length = len(arr) // 2 for element in arr: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 if element_count[element] > half_length: return element return -1"},{"question":"def can_construct_ransom_note(ransomNote: str, magazine: str) -> bool: Determines if the ransom note can be constructed from the given magazine. Args: ransomNote (str): The ransom note to construct. magazine (str): The magazine to use for constructing the ransom note. Returns: bool: True if the ransom note can be constructed, otherwise False. >>> can_construct_ransom_note(\\"hello\\", \\"ollhebg\\") True >>> can_construct_ransom_note(\\"hello\\", \\"helbg\\") False >>> can_construct_ransom_note(\\"\\", \\"abc\\") True >>> can_construct_ransom_note(\\"a\\", \\"b\\") False","solution":"def can_construct_ransom_note(ransomNote, magazine): Determines if the ransom note can be constructed from the given magazine. Args: ransomNote (str): The ransom note to construct. magazine (str): The magazine to use for constructing the ransom note. Returns: bool: True if the ransom note can be constructed, otherwise False. from collections import Counter ransom_note_counter = Counter(ransomNote) magazine_counter = Counter(magazine) for letter, count in ransom_note_counter.items(): if magazine_counter[letter] < count: return False return True"},{"question":"def length_of_lis(heights): Returns the length of the longest increasing subsequence from the list of cow jumping heights. >>> length_of_lis([5, 3, 4, 8, 6, 7]) 4 >>> length_of_lis([1]) 1 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([]) 0 >>> length_of_lis([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> length_of_lis([3, 10, 2, 1, 20]) 3","solution":"def length_of_lis(heights): Returns the length of the longest increasing subsequence from the list of cow jumping heights. if not heights: return 0 n = len(heights) lis = [1] * n # Initialize LIS values for all indexes # Compute optimized LIS values in a bottom up manner for i in range(1, n): for j in range(0, i): if heights[i] > heights[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return maximum value in lis[] return max(lis)"},{"question":"def can_redistribute_evenly(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to redistribute the coins among the citizens equally without any remainder. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): Each test case contains an integer representing the number of citizens and a list of integers representing the number of golden coins each citizen initially has. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> can_redistribute_evenly(3, [(4, [1, 2, 3, 4]), (3, [10, 10, 10]), (5, [5, 5, 5, 5, 0])]) ['NO', 'YES', 'YES'] >>> can_redistribute_evenly(1, [(1, [100])]) ['YES']","solution":"def can_redistribute_evenly(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] coins = test_cases[i][1] total_coins = sum(coins) if total_coins % N == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def partition_array_min_diff(arr: List[int]) -> int: Partition the array into two subarrays with minimum absolute difference between their sums. pass # Replace with your implementation def find_min_partition_diffs(test_cases: List[Tuple[int, List[int]]]) -> List[int]: >>> find_min_partition_diffs([(4, [1, 2, 3, 4])]) [0] >>> find_min_partition_diffs([(6, [1, 2, 3, 4, 5, 6])]) [1] >>> find_min_partition_diffs([(4, [1, 2, 3, 4]), (6, [1, 2, 3, 4, 5, 6])]) [0, 1] >>> find_min_partition_diffs([(2, [1, 2])]) [1] >>> find_min_partition_diffs([(8, [1, 2, 3, 4, 5, 6, 7, 8])]) [0] pass # Replace with your implementation","solution":"def partition_array_min_diff(arr): Partition the array into two subarrays with minimum absolute difference between their sums. total_sum = sum(arr) n = len(arr) half_sum = total_sum // 2 # Using Dynamic programming to find the closest sum to half_sum dp = [False] * (half_sum + 1) dp[0] = True for num in arr: for j in range(half_sum, num-1, -1): if dp[j - num]: dp[j] = True for i in range(half_sum, -1, -1): if dp[i]: sum1 = i break sum2 = total_sum - sum1 return abs(sum1 - sum2) def find_min_partition_diffs(test_cases): results = [] for n, arr in test_cases: results.append(partition_array_min_diff(arr)) return results"},{"question":"def has_zero_sum_subarray(arr): Detects if there exists a continuous subarray that sums to zero. Args: arr (List[int]): A list of integers representing transaction values. Returns: str: \\"Yes\\" if there exists a continuous subarray with sum to zero, otherwise \\"No\\". >>> has_zero_sum_subarray([4, 2, -3, 1, 6]) 'Yes' >>> has_zero_sum_subarray([4, 2, 0, 1, 6]) 'Yes' >>> has_zero_sum_subarray([4, 2, 3, 1, 6]) 'No' pass def detect_fraudulent_patterns(test_cases): Processes multiple test cases to check for continuous subarray summing to zero. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains the number of transactions and the transaction array. Returns: List[str]: A list of results for each test case, \\"Yes\\" or \\"No\\". >>> detect_fraudulent_patterns([(6, [4, 2, -3, 1, 6]), (5, [4, 2, 0, 1, 6])]) ['Yes', 'Yes'] >>> detect_fraudulent_patterns([(5, [4, 2, 3, 1, 6]), (5, [0, 1, 2, 3, 4])]) ['No', 'Yes'] pass","solution":"def has_zero_sum_subarray(arr): Detects if there exists a continuous subarray that sums to zero. # Using a set to track the cumulative sum seen_sums = set() current_sum = 0 for num in arr: current_sum += num if current_sum == 0 or current_sum in seen_sums: return \\"Yes\\" seen_sums.add(current_sum) return \\"No\\" def detect_fraudulent_patterns(test_cases): Processes multiple test cases to check for continuous subarray summing to zero. test_cases: List of tuples, where each tuple contains the number of transactions and the transaction array. results = [] for n, arr in test_cases: result = has_zero_sum_subarray(arr) results.append(result) return results # Example usage: # t = 2 # test_cases = [ # (6, [4, 2, -3, 1, 6]), # (5, [4, 2, 0, 1, 6]) # ] # print(detect_fraudulent_patterns(test_cases))"},{"question":"from typing import List, Optional from collections import Counter def find_mode(arr: List[int]) -> Optional[int]: Find the mode of a list of integers. The mode is the number that appears most frequently in a list. If there are multiple numbers with the same highest frequency, the smallest of these numbers is taken as the mode. >>> find_mode([4, 5, 6, 7, 4, 4, 5, 5]) 4 >>> find_mode([1, 2, 2, 3, 3, 4]) 2 >>> find_mode([10, 14, 10, 18, 14, 14]) 14 >>> find_mode([10]) 10 >>> find_mode([]) None >>> find_mode([7, 7, 5, 5, 9, 2, 2, 5]) 5 >>> find_mode([4, 4, 4, 4]) 4","solution":"def find_mode(arr): from collections import Counter if not arr: return None count = Counter(arr) max_frequency = max(count.values()) candidates = [num for num, freq in count.items() if freq == max_frequency] return min(candidates)"},{"question":"from typing import List def isFile(path: str) -> bool: Mock \`isFile\` function definition. This function should determine whether the given path is a file. It's expected to return \`True\` if the path is a file, \`False\` if it's a directory. pass def listFiles(path: str) -> List[str]: List all files under a given directory path. If the given path does not exist, return an empty list. If the path is a file, return a list containing that single path. >>> sorted(listFiles(\\"/\\")) == sorted([\\"/file4.txt\\", \\"/folder1/file1.txt\\", \\"/folder1/folder2/file2.txt\\", \\"/folder1/folder3/file3.txt\\"]) True >>> sorted(listFiles(\\"/folder1/\\")) == sorted([\\"/folder1/file1.txt\\", \\"/folder1/folder2/file2.txt\\", \\"/folder1/folder3/file3.txt\\"]) True >>> listFiles(\\"/folder1/folder2/\\") == [\\"/folder1/folder2/file2.txt\\"] True >>> listFiles(\\"/nonexistent/\\") == [] True >>> listFiles(\\"/file4.txt\\") == [\\"/file4.txt\\"] True >>> listFiles(\\"/folder1/file1.txt\\") == [\\"/folder1/file1.txt\\"] True pass","solution":"from typing import List # This would be a mock function for the example def isFile(path: str) -> bool: Mock \`isFile\` function definition. This function should determine whether the given path is a file. It's expected to return \`True\` if the path is a file, \`False\` if it's a directory. file_system = { \\"/\\": False, \\"/folder1/\\": False, \\"/folder1/file1.txt\\": True, \\"/folder1/folder2/\\": False, \\"/folder1/folder2/file2.txt\\": True, \\"/folder1/folder3/\\": False, \\"/folder1/folder3/file3.txt\\": True, \\"/file4.txt\\": True, } return file_system.get(path, False) def listFiles(path: str) -> List[str]: file_structure = { \\"/\\": [\\"folder1/\\", \\"file4.txt\\"], \\"/folder1/\\": [\\"file1.txt\\", \\"folder2/\\", \\"folder3/\\"], \\"/folder1/folder2/\\": [\\"file2.txt\\"], \\"/folder1/folder3/\\": [\\"file3.txt\\"] } def list_files_recursive(current_path: str) -> List[str]: if isFile(current_path): return [current_path] results = [] for sub_path in file_structure.get(current_path, []): full_sub_path = current_path + sub_path results.extend(list_files_recursive(full_sub_path)) return results return list_files_recursive(path)"},{"question":"def smallest_subarray_with_sum(T: int, cases: list) -> list: Given a number of test cases, find the length of the smallest subarray with a sum equal to X. Parameters: T (int): The number of test cases. cases (list): A list of tuples where each tuple contains: - N (int): Length of the array - K (int): Max value in the array - A (list): The array of integers - X (int): The target sum Returns: List[int]: A list of integers where each integer is the length of the smallest subarray with sum equal to X, or -1 if no such subarray exists. >>> smallest_subarray_with_sum(2, [(5, 5, [1, 2, 3, 4, 5], 9), (6, 3, [1, 1, 1, 1, 1, 1], 4)]) [2, 4] >>> smallest_subarray_with_sum(1, [(4, 5, [1, 2, 3, 4], 15)]) [-1] >>> smallest_subarray_with_sum(1, [(3, 3, [1, 2, 3], 6)]) [3] >>> smallest_subarray_with_sum(1, [(6, 6, [1, 1, 1, 1, 1, 6], 6)]) [1] >>> smallest_subarray_with_sum(1, [(1, 1, [5], 5)]) [1] >>> smallest_subarray_with_sum(1, [(10, 5, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2], 5)]) [3] >>> smallest_subarray_with_sum(1, [(6, 6, [1, 2, 2, 4, 6, 2], 4)]) [1]","solution":"def smallest_subarray_with_sum(T: int, cases: list): results = [] for case in cases: N, K, A, X = case min_length = float('inf') found = False for start in range(N): curr_sum = 0 for end in range(start, N): curr_sum += A[end] if curr_sum == X: found = True min_length = min(min_length, end - start + 1) break # we found a subarray with exact sum X, move to the next starting point if found: results.append(min_length) else: results.append(-1) return results def parse_input(data: str): lines = data.split('n') T = int(lines[0]) cases = [] index = 1 for _ in range(T): N, K = map(int, lines[index].split()) A = list(map(int, lines[index+1].split())) X = int(lines[index+2]) cases.append((N, K, A, X)) index += 3 return T, cases def main(input_data: str) -> str: T, cases = parse_input(input_data) results = smallest_subarray_with_sum(T, cases) return 'n'.join(map(str, results))"},{"question":"def minimizeSum(arr: List[int], k: int) -> int: Partitions the array into exactly k non-empty subarrays such that the sum of the maximum element of each subarray is minimized. >>> minimizeSum([1, 3, 2, 4, 5], 2) 9 >>> minimizeSum([5, 8, 6, 3, 4, 2, 7], 3) 21 >>> minimizeSum([5, 8, 6, 3, 4], 1) 8 >>> minimizeSum([5, 8, 6, 3, 4], 5) 26 >>> minimizeSum([1, 2, 3], 2) 5 >>> minimizeSum([5, 8, 6, 3, 4, 2, 7], 6) 33","solution":"def minimizeSum(arr, k): This function partitions the array into exactly k non-empty subarrays such that the sum of the maximum element of each subarray is minimized. n = len(arr) # Sort the array in descending order arr.sort(reverse=True) # To minimize the sum of the maximum elements, we should grab the k highest elements # and assume each is the max of its own subarray return sum(arr[:k])"},{"question":"def count_unique_characters(s): Counts the number of occurrences of each unique character in the string s. Parameters: s (str): The input string containing concatenated item identifiers. Returns: dict: A dictionary containing characters as keys and their counts as values. pass def format_output(counter): Formats the output for the character counts. Parameters: counter (dict): Dictionary with character counts. Returns: str: Formatted output string. pass # Unit Tests import pytest def test_count_unique_characters(): assert count_unique_characters(\\"ab12ab34\\") == {'1': 1, '2': 1, '3': 1, '4': 1, 'a': 2, 'b': 2} assert count_unique_characters(\\"001122abc\\") == {'0': 2, '1': 2, '2': 2, 'a': 1, 'b': 1, 'c': 1} assert count_unique_characters(\\"zxy123xzy\\") == {'1': 1, '2': 1, '3': 1, 'x': 2, 'y': 2, 'z': 2} assert count_unique_characters(\\"abcdefgh\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1} def test_format_output(): assert format_output({'1': 1, '2': 1, '3': 1, '4': 1, 'a': 2, 'b': 2}) == \\"1 1n2 1n3 1n4 1na 2nb 2\\" assert format_output({'0': 2, '1': 2, '2': 2, 'a': 1, 'b': 1, 'c': 1}) == \\"0 2n1 2n2 2na 1nb 1nc 1\\" assert format_output({'1': 1, '2': 1, '3': 1, 'x': 2, 'y': 2, 'z': 2}) == \\"1 1n2 1n3 1nx 2ny 2nz 2\\" assert format_output({'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1, 'h': 1}) == \\"a 1nb 1nc 1nd 1ne 1nf 1ng 1nh 1\\"","solution":"def count_unique_characters(s): Counts the number of occurrences of each unique character in the string s. Parameters: s (str): The input string containing concatenated item identifiers. Returns: dict: A dictionary containing characters as keys and their counts as values. from collections import Counter counter = Counter(s) result = {char: counter[char] for char in sorted(counter.keys())} return result def format_output(counter): Formats the output for the character counts. Parameters: counter (dict): Dictionary with character counts. Returns: str: Formatted output string. return 'n'.join(f\\"{char} {count}\\" for char, count in counter.items())"},{"question":"def minimum_buckets(L, W, n, leaks): Determine the minimum number of buckets required to cover all leaks in a warehouse. Args: L (int): Length of the warehouse. W (int): Width of the warehouse. n (int): Number of leaks. leaks (List[int]): List of positions of leaks on the grid. Returns: int: Minimum number of buckets required to cover all leaks. Examples: >>> minimum_buckets(3, 3, 4, [0, 1, 4, 8]) 3 >>> minimum_buckets(2, 2, 2, [1, 2]) 2 >>> minimum_buckets(3, 3, 0, []) 0 >>> minimum_buckets(4, 4, 1, [5]) 1 >>> minimum_buckets(1, 5, 3, [0, 1, 4]) 2 >>> minimum_buckets(3, 3, 6, [0, 1, 3, 4, 6, 7]) 3 pass def solve(test_cases): Solve multiple test cases for the minimum buckets problem. Args: test_cases (List[Dict]): A list of dictionaries, where each dictionary contains: - L (int): Length of the warehouse. - W (int): Width of the warehouse. - n (int): Number of leaks. - leaks (List[int]): List of positions of leaks on the grid. Returns: List[int]: List of results for each test case, indicating the minimum buckets required. Examples: >>> solve([{'L': 3, 'W': 3, 'n': 4, 'leaks': [0, 1, 4, 8]}]) [3] >>> solve([{'L': 2, 'W': 2, 'n': 2, 'leaks': [1, 2]}]) [2] >>> solve([{'L': 3, 'W': 3, 'n': 0, 'leaks': []}]) [0] >>> solve([{'L': 4, 'W': 4, 'n': 1, 'leaks': [5]}]) [1] >>> solve([{'L': 1, 'W': 5, 'n': 3, 'leaks': [0, 1, 4]}]) [2] >>> solve([{'L': 3, 'W': 3, 'n': 6, 'leaks': [0, 1, 3, 4, 6, 7]}]) [3] pass","solution":"def minimum_buckets(L, W, n, leaks): if n == 0: return 0 leaks.sort() leaks_positions = [(leak // W, leak % W) for leak in leaks] buckets = 0 prev_row, prev_col = -1, -2 # Initialize to guarantee no overlap at start for row, col in leaks_positions: if row == prev_row and (col == prev_col or col == prev_col + 1): prev_col = col else: buckets += 1 prev_row, prev_col = row, col return buckets def solve(test_cases): result = [] for case in test_cases: L = case['L'] W = case['W'] n = case['n'] leaks = case['leaks'] result.append(minimum_buckets(L, W, n, leaks)) return result"},{"question":"from typing import List def max_elements_removed(n: int, k: int, arr: List[int]) -> int: Given an array of positive integers, find the maximum possible number of elements that can be removed by performing the following operation any number of times: select any subsequence of the array of length exactly k, where all elements of the subsequence have to be equal. Parameters: n (int): The size of the array k (int): The length of the subsequence to be removed arr (list of int): The array of positive integers Returns: int: The maximum possible number of elements that can be removed Examples: >>> max_elements_removed(5, 2, [1, 2, 2, 3, 3]) 4 >>> max_elements_removed(8, 3, [1, 1, 1, 1, 1, 2, 2, 2]) 6 >>> max_elements_removed(9, 2, [3, 3, 3, 3, 3, 5, 5, 5, 5]) 8 >>> max_elements_removed(1, 1, [1]) 1 >>> max_elements_removed(6, 2, [5, 5, 5, 5, 5, 5]) 6 >>> max_elements_removed(5, 3, [1, 1, 2, 2, 3]) 0","solution":"from collections import Counter def max_elements_removed(n, k, arr): This function calculates the maximum number of elements that can be removed by repeatedly selecting subsequences of length exactly k, where all elements of the subsequence are equal. Parameters: n (int): The size of the array k (int): The length of the subsequence to be removed arr (list of int): The array of positive integers Returns: int: The maximum possible number of elements that can be removed freq = Counter(arr) max_removed = 0 for count in freq.values(): max_removed += (count // k) * k return max_removed"},{"question":"def prize_submission(n, c, tickets): Determines whether the prize counter can accommodate all players' submissions without overflow. Parameters: n (int): The number of players. c (int): The capacity of the prize counter. tickets (list of int): The number of tickets submitted by each player. Returns: str: \\"Accepted\\" if all submissions fit within the capacity, otherwise \\"Rejected\\". >>> prize_submission(5, 100, [20, 30, 10, 25, 15]) \\"Accepted\\" >>> prize_submission(5, 50, [10, 20, 15, 10, 10]) \\"Rejected\\" >>> prize_submission(1, 100, [50]) \\"Accepted\\" >>> prize_submission(1, 10, [20]) \\"Rejected\\" >>> prize_submission(3, 30, [10, 10, 10]) \\"Accepted\\" >>> prize_submission(3, 30, [10, 10, 10]) \\"Accepted\\" >>> prize_submission(4, 40, [15, 15, 10, 5]) \\"Rejected\\" >>> prize_submission(2, 10000, [5000, 5000]) \\"Accepted\\" >>> prize_submission(1000, 10000, [10]*1000) \\"Accepted\\" >>> prize_submission(1000, 9999, [10]*1000) \\"Rejected\\"","solution":"def prize_submission(n, c, tickets): Determines whether the prize counter can accommodate all players' submissions without overflow. Parameters: n (int): The number of players. c (int): The capacity of the prize counter. tickets (list of int): The number of tickets submitted by each player. Returns: str: \\"Accepted\\" if all submissions fit within the capacity, otherwise \\"Rejected\\". current_capacity = 0 for t in tickets: current_capacity += t if current_capacity > c: return \\"Rejected\\" return \\"Accepted\\" # Example usage: # n = 5 # c = 100 # tickets = [20, 30, 10, 25, 15] # print(prize_submission(n, c, tickets)) # Output will be \\"Accepted\\""},{"question":"def find_max_path_sum(t: int, test_cases: List[Tuple[int, List[int], List[Tuple[int, int]]]]) -> List[int]: Find the maximum sum of values from the root to any leaf path in the given tree. Args: t : int : number of test cases test_cases : List[Tuple[int, List[int], List[Tuple[int, int]]]]: a list containing test cases, each being a tuple with - the number of nodes \`n\` - a list of integers representing values of each node - a list of edges, each represented as a tuple (u, v), indicating an edge between nodes u and v. Returns: List[int]: a list of integers where each integer is the maximum sum of values from the root to any leaf path in the corresponding test case Example: >>> t = 2 >>> test_cases = [ ... (5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]), ... (3, [5, 10, 20], [(1, 2), (1, 3)]) ... ] >>> find_max_path_sum(t, test_cases) [8, 25]","solution":"def find_max_path_sum(t, test_cases): def dfs(node, parent, tree, values): max_path_sum = 0 for child in tree[node]: if child != parent: max_path_sum = max(max_path_sum, dfs(child, node, tree, values)) return values[node] + max_path_sum results = [] for test_case in test_cases: n, values, edges = test_case tree = [[] for _ in range(n)] for u, v in edges: tree[u - 1].append(v - 1) tree[v - 1].append(u - 1) max_sum = dfs(0, -1, tree, values) results.append(max_sum) return results"},{"question":"def minimum_travel_cost(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum cost required for the king to travel between all cities. >>> minimum_travel_cost(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 3), (2, 4, 8), (3, 4, 4)]) 12 >>> minimum_travel_cost(3, 2, [(1, 2, 7), (2, 3, 15)]) 22 >>> minimum_travel_cost(4, 2, [(1, 2, 5), (3, 4, 10)]) -1 >>> minimum_travel_cost(4, 6, [(1, 2, 1), (1, 3, 2), (1, 4, 3), (2, 3, 4), (2, 4, 5), (3, 4, 6)]) 6 >>> minimum_travel_cost(5, 6, [(1, 2, 3), (2, 3, 3), (3, 4, 3), (4, 5, 3), (1, 5, 3), (2, 4, 3)]) 12","solution":"import heapq def minimum_travel_cost(n, m, roads): def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 roads.sort(key=lambda x: x[2]) # Sort edges by cost parent = [i for i in range(n + 1)] rank = [0] * (n + 1) mst_cost = 0 edge_count = 0 for u, v, w in roads: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edge_count += 1 if edge_count == n - 1: break return mst_cost if edge_count == n - 1 else -1"},{"question":"def has_pair_with_sum(lst: list, target: int) -> bool: Determines if there are two distinct numbers in the list that add up to the target sum. >>> has_pair_with_sum([2, 7, 11, 15], 9) True >>> has_pair_with_sum([1, 2, 3, 4], 8) False >>> has_pair_with_sum([-1, -2, -3, -4], -6) True from solution import has_pair_with_sum def test_has_pair_with_sum_true_case_1(): assert has_pair_with_sum([2, 7, 11, 15], 9) == True def test_has_pair_with_sum_true_case_2(): assert has_pair_with_sum([-1, -2, -3, -4], -6) == True def test_has_pair_with_sum_false_case_1(): assert has_pair_with_sum([1, 2, 3, 4], 8) == False def test_has_pair_with_sum_true_case_3(): assert has_pair_with_sum([5, 3, 8, -2], 6) == True def test_has_pair_with_sum_false_case_2(): assert has_pair_with_sum([1, 2, 3], 7) == False def test_has_pair_with_sum_empty_list(): assert has_pair_with_sum([], 5) == False def test_has_pair_with_sum_single_element_list(): assert has_pair_with_sum([1], 1) == False","solution":"def has_pair_with_sum(lst, target): Determines if there are two distinct numbers in the list that add up to the target sum. Parameters: lst (list of ints): List of distinct integers. target (int): The target sum. Returns: bool: True if there are two numbers that add up to the target sum, otherwise False. seen_numbers = set() for number in lst: required_number = target - number if required_number in seen_numbers: return True seen_numbers.add(number) return False"},{"question":"from typing import List, Union def library_management(operations: List[str]) -> List[Union[int, str]]: Implement a system to help Jane manage her books and handle her queries efficiently. The system would handle the following operations: 1. **ADD <UID> <genre> <difficulty>**: Add a book to the collection. 2. **REMOVE <UID>**: Remove a book from the collection by its UID. 3. **COUNT_GENRE <genre>**: Count the number of books in a specified genre. 4. **HARDEST_BOOK <genre>**: Find the book UID with the highest difficulty level in the specified genre. If there are multiple books with the same highest difficulty level, return the one added first. Args: operations (List[str]): A list of strings representing the operations to be performed. Returns: List[Union[int, str]]: The results of the queries in the order they are provided. Example: >>> operations = [ ... \\"ADD 1 Fiction 3\\", ... \\"ADD 2 Fiction 5\\", ... \\"ADD 3 Mystery 7\\", ... \\"COUNT_GENRE Fiction\\", ... \\"HARDEST_BOOK Fiction\\", ... \\"REMOVE 2\\", ... \\"COUNT_GENRE Fiction\\", ... \\"HARDEST_BOOK Fiction\\" ... ] >>> library_management(operations) [2, 2, 1, 1]","solution":"from collections import defaultdict def library_management(operations): books = defaultdict(list) book_info = {} results = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"ADD\\": uid = int(parts[1]) genre = ' '.join(parts[2:-1]) difficulty = int(parts[-1]) book_info[uid] = (genre, difficulty) books[genre].append((difficulty, uid)) elif command == \\"REMOVE\\": uid = int(parts[1]) genre, difficulty = book_info.pop(uid) books[genre].remove((difficulty, uid)) elif command == \\"COUNT_GENRE\\": genre = ' '.join(parts[1:]) results.append(len(books[genre])) elif command == \\"HARDEST_BOOK\\": genre = ' '.join(parts[1:]) if not books[genre]: results.append(\\"None\\") else: hardest_book = max(books[genre], key=lambda x: (x[0], -x[1])) results.append(hardest_book[1]) return results"},{"question":"def distinct_angles(n, angles): Calculates the total number of distinct angles the robots can turn. Angles that are opposite are considered the same unique angle. Args: n : int : number of angles (1 ≤ n ≤ 1 000 000) angles : list of int : the angles provided (−180 ≤ angle ≤ 180) Returns: int : the total number of distinct angles Examples: >>> distinct_angles(5, [-30, 30, 60, -60, 15]) 3 >>> distinct_angles(4, [45, -45, 90, -90]) 2 >>> distinct_angles(6, [0, 0, -180, 180, 90, -90]) 3","solution":"def distinct_angles(n, angles): Given the number of angles and the list of angles, return the total number of distinct angles. Angles that are opposite are considered the same unique angle. Args: n : int : number of angles angles : list of int : the angles provided Returns: int : the total number of distinct angles distinct_set = set() for angle in angles: distinct_set.add(abs(angle)) return len(distinct_set)"},{"question":"def least_magical_power(n, m, roads, src, dst): Find the least maximum magical power increase required to travel from src to dst. If there is no path from src to dst, return -1. Parameters: n (int): The number of clearings. m (int): The number of roads. roads (List[Tuple[int, int, int]]): Each tuple contains (u, v, w) representing a road between clearing u and clearing v that increases magical power by w. src (int): The starting clearing. dst (int): The destination clearing. Returns: int: The minimum of the maximum magical power increase required to travel from src to dst, or -1 if no path exists. Example: >>> n = 5 >>> m = 6 >>> roads = [(0, 1, 4), (0, 2, 1), (2, 1, 2), (1, 3, 6), (2, 4, 5), (4, 3, 2)] >>> src = 0 >>> dst = 3 >>> least_magical_power(n, m, roads, src, dst) 5","solution":"import heapq def least_magical_power(n, m, roads, src, dst): adj_list = [[] for _ in range(n)] for u, v, w in roads: adj_list[u].append((v, w)) adj_list[v].append((u, w)) def dijkstra(src, dst): pq = [(0, src)] dist = [float('inf')] * n dist[src] = 0 while pq: max_magic, current = heapq.heappop(pq) if current == dst: return max_magic for neighbor, weight in adj_list[current]: new_max_magic = max(max_magic, weight) if new_max_magic < dist[neighbor]: dist[neighbor] = new_max_magic heapq.heappush(pq, (new_max_magic, neighbor)) return -1 return dijkstra(src, dst)"},{"question":"def min_swap_operations(binary_string: str) -> int: Returns the minimum number of swap operations needed to make all characters in the binary string the same. >>> min_swap_operations(\\"0000\\") 0 >>> min_swap_operations(\\"1111\\") 0 >>> min_swap_operations(\\"101010\\") 1 >>> min_swap_operations(\\"0001100\\") 1 >>> min_swap_operations(\\"111110\\") 1 >>> min_swap_operations(\\"\\") 0 >>> min_swap_operations(\\"0\\") 0","solution":"def min_swap_operations(binary_string): Returns the minimum number of swap operations needed to make all characters in the binary string the same. ones = binary_string.count('1') zeros = len(binary_string) - ones if ones == 0 or zeros == 0: return 0 return 1"},{"question":"import heapq from typing import List, Tuple def min_special_roads(N: int, M: int, K: int, roads: List[Tuple[int, int, int, int]]) -> int: Determine the minimum number of special roads between city 1 and city N, or output -1 if no such path exists. :param N: Number of cities :param M: Number of roads :param K: Number of special roads :param roads: List of tuples where each tuple contains (u, v, toll, type) u and v are the cities connected by the road, toll is the toll cost of the road, type indicates whether the road is special (type = 1) or not (type = 0) :return: Minimum number of special roads in the path from city 1 to city N or -1 if no such path exists Examples: >>> min_special_roads(5, 6, 2, [(1, 2, 1, 1), (2, 3, 1, 0), (3, 5, 1, 0), (2, 4, 2, 1), (4, 5, 1, 0), (1, 3, 3, 0)]) 1 >>> min_special_roads(4, 3, 1, [(1, 2, 1, 0), (2, 3, 2, 1), (3, 4, 1, 0)]) 1","solution":"import heapq def min_special_roads(N, M, K, roads): graph = [[] for _ in range(N + 1)] for u, v, toll, r_type in roads: graph[u].append((v, toll, r_type)) graph[v].append((u, toll, r_type)) # Priority queue to hold (total toll, current city, special road count) pq = [(0, 1, 0)] tolls = {(1, 0): 0} # dict to hold minimum toll to reach (city, special_count) while pq: current_toll, u, special_count = heapq.heappop(pq) # If we've reached the destination city if u == N: return special_count # Explore neighbors for v, toll, r_type in graph[u]: new_toll = current_toll + toll new_special_count = special_count + r_type # If this path has fewer special roads or less toll than previously found if (v, new_special_count) not in tolls or new_toll < tolls[(v, new_special_count)]: tolls[(v, new_special_count)] = new_toll heapq.heappush(pq, (new_toll, v, new_special_count)) # If destination city is not reachable return -1"},{"question":"from collections import Counter def check_anagram_substrings(s: str) -> Tuple[str, Dict[str, int]]: Determines if the string s can be divided into two equal-length anagram substrings. Returns \\"YES\\" and the frequency of the anagram if true, otherwise \\"NO\\" and the frequency of the first half of the string. >>> check_anagram_substrings(\\"abab\\") (\\"YES\\", {'a': 1, 'b': 1}) >>> check_anagram_substrings(\\"abcd\\") (\\"NO\\", {'a': 1, 'b': 1}) >>> check_anagram_substrings(\\"abcddcba\\") (\\"YES\\", {'a': 2, 'b': 2, 'c': 2, 'd': 2})","solution":"from collections import Counter def check_anagram_substrings(s): Determines if the string s can be divided into two equal-length anagram substrings. Returns \\"YES\\" and the frequency of the anagram if true, otherwise \\"NO\\" and the frequency of the first half of the string. n = len(s) if n % 2 != 0: # length of string is odd first_half_freq = Counter(s[:n//2]) return \\"NO\\", first_half_freq mid = n // 2 first_half, second_half = s[:mid], s[mid:] first_half_freq = Counter(first_half) second_half_freq = Counter(second_half) if first_half_freq == second_half_freq: return \\"YES\\", first_half_freq else: return \\"NO\\", first_half_freq"},{"question":"def main(input_str): Sorts a list of project tasks by priority and then alphabetically by task name if priorities are the same. Args: input_str (str): Input string containing test cases for the tasks. Returns: str: Sorted list of tasks for each test case. >>> input_str = \\"2n4nDesignDB 2nCreateAPI 1nlaunchApp 3ndesignUI 2n3nTestApp 1ndeploy 2nFixBugs 1n\\" >>> print(main(input_str)) CreateAPI 1 DesignDB 2 designUI 2 launchApp 3 FixBugs 1 TestApp 1 deploy 2 # Your code here def test_sort_tasks(): input_str = \\"2n4nDesignDB 2nCreateAPI 1nlaunchApp 3ndesignUI 2n3nTestApp 1ndeploy 2nFixBugs 1n\\" expected_output = \\"CreateAPI 1nDesignDB 2ndesignUI 2nlaunchApp 3nFixBugs 1nTestApp 1ndeploy 2\\" result = main(input_str) assert result == expected_output def test_single_task(): input_str = \\"1n1nSingleTask 5n\\" expected_output = \\"SingleTask 5\\" result = main(input_str) assert result == expected_output def test_same_priority_diff_names(): input_str = \\"1n2nZTask 1nATask 1n\\" expected_output = \\"ATask 1nZTask 1\\" result = main(input_str) assert result == expected_output def test_all_same_priority_and_name(): input_str = \\"1n3nTask 1nTask 1nTask 1n\\" expected_output = \\"Task 1nTask 1nTask 1\\" result = main(input_str) assert result == expected_output def test_different_priorities(): input_str = \\"1n4nTask1 4nTask2 3nTask3 2nTask4 1n\\" expected_output = \\"Task4 1nTask3 2nTask2 3nTask1 4\\" result = main(input_str) assert result == expected_output","solution":"def sort_tasks(test_cases): results = [] for case in test_cases: tasks = case[1] sorted_tasks = sorted(tasks, key=lambda x: (x[1], x[0].lower())) results.append(sorted_tasks) return results def parse_input(input_str): lines = input_str.strip().split('n') idx = 0 test_cases = [] num_cases = int(lines[idx]) idx += 1 for _ in range(num_cases): n = int(lines[idx]) idx += 1 tasks = [] for _ in range(n): task_info = lines[idx].rsplit(' ', 1) task_name = task_info[0] priority = int(task_info[1]) tasks.append((task_name, priority)) idx += 1 test_cases.append((n, tasks)) return test_cases def format_output(sorted_tasks): output = [] for tasks in sorted_tasks: for task in tasks: output.append(f\\"{task[0]} {task[1]}\\") return 'n'.join(output) # Reading input def main(input_str): test_cases = parse_input(input_str) sorted_tasks = sort_tasks(test_cases) return format_output(sorted_tasks)"},{"question":"def find_startable_tasks(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Returns a list of task numbers that can be started immediately. Args: n : int The number of tasks. dependencies : List[Tuple[int, int]] A list where each tuple (u, v) indicates a dependency that task u must be completed before task v. Returns: List[int] A list of integers representing task numbers that can be started immediately in ascending order. Examples: >>> find_startable_tasks(6, [(1, 3), (2, 3), (4, 5), (5, 6)]) [1, 2, 4] >>> find_startable_tasks(5, [(2, 1), (3, 1), (4, 1), (5, 1)]) [2, 3, 4, 5] >>> find_startable_tasks(4, [(2, 3), (2, 4), (3, 4)]) [1, 2]","solution":"def find_startable_tasks(n, dependencies): Returns a list of task numbers that can be started immediately. Args: - n: int - the number of tasks. - dependencies: list of tuples - a list where each tuple (u, v) indicates a dependency that task u must be completed before task v. Returns: - list of integers representing task numbers that can be started immediately in ascending order. # Initialize a list to keep track of the indegree (number of incoming edges) for each task indegree = [0] * (n + 1) # Build the graph and compute the indegree of each task for u, v in dependencies: indegree[v] += 1 # Find all tasks that have an indegree of 0 startable_tasks = [i for i in range(1, n + 1) if indegree[i] == 0] return sorted(startable_tasks)"},{"question":"from typing import List, Tuple def floyd_warshall(n: int, matrix: List[List[int]]) -> List[List[int]]: Applies the Floyd-Warshall algorithm to find the shortest paths between all pairs of cities. >>> floyd_warshall(3, [ ... [0, 3, -1], ... [3, 0, 5], ... [-1, 5, 0] ... ]) [[0, 3, 8], [3, 0, 5], [8, 5, 0]] def process_datasets(datasets: List[Tuple[int, List[List[int]], List[Tuple[int, int]]]]) -> List[int]: Processes multiple datasets and computes the shortest travel times for the given queries. >>> datasets = [ ... (3, [ ... [0, 3, -1], ... [3, 0, 5], ... [-1, 5, 0] ... ], [(0, 2), (2, 0)]) ... ] >>> process_datasets(datasets) [8, 8]","solution":"def floyd_warshall(n, matrix): Applies the Floyd-Warshall algorithm to find the shortest paths between all pairs of cities. dist = [[float('inf')] * n for _ in range(n)] for i in range(n): for j in range(n): if matrix[i][j] != -1: dist[i][j] = matrix[i][j] if i == j: # Distance to self is 0 dist[i][j] = 0 for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def process_datasets(datasets): Processes multiple datasets and computes the shortest travel times for the given queries. results = [] for data in datasets: n, matrix, queries = data dist = floyd_warshall(n, matrix) for start, end in queries: if dist[start][end] == float('inf'): results.append(-1) else: results.append(dist[start][end]) return results"},{"question":"def longest_increasing_subsequence_length(nums): Returns the length of the longest increasing subsequence in the given list of integers. If the list is empty, returns 0. >>> longest_increasing_subsequence_length([10, 22, 9, 33, 21, 50, 41, 60, 80]) 6 >>> longest_increasing_subsequence_length([3, 10, 2, 1, 20]) 3 def process_test_cases(test_cases): Processes multiple test cases and returns a list of results for the lengths of the longest increasing subsequences for each test case. >>> process_test_cases([[10, 22, 9, 33, 21, 50, 41, 60, 80], [3, 10, 2, 1, 20]]) [6, 3]","solution":"def longest_increasing_subsequence_length(nums): Returns the length of the longest increasing subsequence in the given list of integers. If the list is empty, returns 0. if not nums: return 0 n = len(nums) dp = [1] * n for i in range(1, n): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(test_cases): Processes multiple test cases and returns a list of results for the lengths of the longest increasing subsequences for each test case. results = [] for nums in test_cases: result = longest_increasing_subsequence_length(nums) results.append(result) return results"},{"question":"def count_valid_words(words, chars): Determine how many words in the list can be formed using the given set of characters. Each character can only be used once per word. Args: words (List[str]): The list of words. chars (str): The set of available characters. Returns: int: The number of words that can be completely formed using the given characters. >>> count_valid_words([\\"hello\\", \\"world\\", \\"students\\"], \\"welldonerhstu\\") 2 from collections import Counter def test_count_valid_words_basic(): words = [\\"hello\\", \\"world\\", \\"students\\"] chars = \\"welldonerhstu\\" assert count_valid_words(words, chars) == 2 def test_count_valid_words_all_valid(): words = [\\"cat\\", \\"dog\\", \\"fish\\"] chars = \\"catdogfish\\" assert count_valid_words(words, chars) == 3 def test_count_valid_words_none_valid(): words = [\\"apple\\", \\"banana\\", \\"cherry\\"] chars = \\"xyz\\" assert count_valid_words(words, chars) == 0 def test_count_valid_words_repeated_chars(): words = [\\"apple\\", \\"hand\\", \\"band\\"] chars = \\"abcdeplnh\\" assert count_valid_words(words, chars) == 2 # 'apple' and 'hand' can be formed, but not 'band' def test_count_valid_words_empty_word_list(): words = [] chars = \\"anycharacters\\" assert count_valid_words(words, chars) == 0 def test_count_valid_words_empty_chars(): words = [\\"any\\", \\"words\\"] chars = \\"\\" assert count_valid_words(words, chars) == 0","solution":"def count_valid_words(words, chars): from collections import Counter def can_form_word(word, char_count): word_count = Counter(word) for char, count in word_count.items(): if count > char_count.get(char, 0): return False return True char_count = Counter(chars) return sum(1 for word in words if can_form_word(word, char_count))"},{"question":"def isBalanced(s: str) -> bool: Given a string with parentheses and lowercase letters, check if the parentheses are balanced and properly nested. Args: s (str): Input string containing parentheses and lowercase letters. Returns: bool: True if the string has balanced parentheses, False otherwise. Examples: >>> isBalanced(\\"a(b)c(d)\\") True >>> isBalanced(\\"a(b(c)d)\\") True >>> isBalanced(\\"(a(b)c)d)\\") False >>> isBalanced(\\"a(b(c)d\\") False","solution":"def isBalanced(s): Returns True if the parentheses in the string are balanced and properly nested, else False. stack = [] for char in s: if char == '(': stack.append(char) elif char == ')': if not stack: return False stack.pop() return len(stack) == 0"},{"question":"from typing import List, Tuple def library_queries(num_books: int, books: List[Tuple[str, str, int]], num_queries: int, queries: List[int]) -> List[str]: Answers queries about a collection of books. Args: - num_books (int): Number of books. - books (list of tuple): Each book is represented as a tuple (title, author, pages). - num_queries (int): Number of queries. - queries (list of int): Each query can be 1, 2, or 3. Returns: - list of str: Results for each query. >>> library_queries(3, [(\\"The_Great_Gatsby\\", \\"F_Scott_Fitzgerald\\", 180), (\\"1984\\", \\"George_Orwell\\", 328), (\\"To_Kill_a_Mockingbird\\", \\"Harper_Lee\\", 281)], 3, [1, 2, 3]) [\\"1984 George_Orwell\\", \\"The_Great_Gatsby F_Scott_Fitzgerald\\", \\"263\\"] >>> library_queries(1, [(\\"Single_Book\\", \\"Single_Author\\", 500)], 3, [1, 2, 3]) [\\"Single_Book Single_Author\\", \\"Single_Book Single_Author\\", \\"500\\"] pass","solution":"def library_queries(num_books, books, num_queries, queries): Answers queries about a collection of books. Args: - num_books (int): Number of books. - books (list of tuple): Each book is represented as a tuple (title, author, pages). - num_queries (int): Number of queries. - queries (list of int): Each query can be 1, 2, or 3. Returns: - list of str: Results for each query. results = [] max_pages_book = max(books, key=lambda book: book[2]) min_pages_book = min(books, key=lambda book: book[2]) avg_pages = sum(book[2] for book in books) // num_books for query in queries: if query == 1: results.append(f\\"{max_pages_book[0]} {max_pages_book[1]}\\") elif query == 2: results.append(f\\"{min_pages_book[0]} {min_pages_book[1]}\\") elif query == 3: results.append(str(avg_pages)) return results"},{"question":"def minimum_effort_path(elevation: List[List[int]]) -> int: Find the minimum effort path from the top-left to the bottom-right of the grid. The effort of a path is defined as the maximum absolute difference in elevations between two consecutive cells in the path. >>> minimum_effort_path([[1, 2, 2], [3, 8, 2], [5, 3, 5]]) 2 >>> minimum_effort_path([[1, 2], [3, 4]]) 2 >>> minimum_effort_path([[1, 2, 2, 3], [3, 8, 2, 7], [5, 8, 5, 9], [6, 3, 4, 1]]) 3 # Implement function here. def solve_minimum_effort_path(test_cases: List[List[List[int]]]) -> List[int]: Solves multiple test cases for minimum effort paths. >>> solve_minimum_effort_path([[[1, 2, 2], [3, 8, 2], [5, 3, 5]], [[1, 2], [3, 4]], [[1, 2, 2, 3], [3, 8, 2, 7], [5, 8, 5, 9], [6, 3, 4, 1]]]) [2, 2, 3] def parse_input(input_string: str) -> List[List[List[int]]]: Parse the input string into test cases. >>> parse_input(\\"3n3 3n1 2 2n3 8 2n5 3 5n2 2n1 2n3 4n4 4n1 2 2 3n3 8 2 7n5 8 5 9n6 3 4 1n\\") [[[1, 2, 2], [3, 8, 2], [5, 3, 5]], [[1, 2], [3, 4]], [[1, 2, 2, 3], [3, 8, 2, 7], [5, 8, 5, 9], [6, 3, 4, 1]]] def format_output(results: List[int]) -> str: Format the output results into a string. >>> format_output([2, 2, 3]) \\"2n2n3\\" def main(input_string: str) -> str: test_cases = parse_input(input_string) results = solve_minimum_effort_path(test_cases) return format_output(results)","solution":"from heapq import heappop, heappush import sys def minimum_effort_path(elevation): N, M = len(elevation), len(elevation[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Using a priority queue to track cells to visit, starting with the top-left corner (0,0) pq = [(0, 0, 0)] # (effort, row, col) # To keep track of minimum effort to reach each cell min_effort = [[sys.maxsize] * M for _ in range(N)] min_effort[0][0] = 0 while pq: current_effort, r, c = heappop(pq) if r == N - 1 and c == M - 1: return current_effort for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M: next_effort = max(current_effort, abs(elevation[nr][nc] - elevation[r][c])) if next_effort < min_effort[nr][nc]: min_effort[nr][nc] = next_effort heappush(pq, (next_effort, nr, nc)) return -1 def solve_minimum_effort_path(test_cases): results = [] for grid in test_cases: result = minimum_effort_path(grid) results.append(result) return results def parse_input(input_string): input_lines = input_string.strip().split(\\"n\\") index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 grid = [] for _ in range(N): grid.append(list(map(int, input_lines[index].split()))) index += 1 test_cases.append(grid) return test_cases def format_output(results): return \\"n\\".join(map(str, results)) def main(input_string): test_cases = parse_input(input_string) results = solve_minimum_effort_path(test_cases) return format_output(results)"},{"question":"def can_be_substring_of_rotation(n: int, s1: str, m: int, s2: str) -> str: Checks if s2 can be a substring of some rotation of s1. Parameters: n (int): length of s1 s1 (str): string s1 m (int): length of s2 s2 (str): string s2 Returns: str: \\"YES\\" if s2 can be a substring of some rotation of s1, otherwise \\"NO\\" >>> can_be_substring_of_rotation(7, \\"abcdefg\\", 3, \\"cde\\") \\"YES\\" >>> can_be_substring_of_rotation(5, \\"abcde\\", 3, \\"xyz\\") \\"NO\\" >>> can_be_substring_of_rotation(1, \\"a\\", 1, \\"a\\") \\"YES\\"","solution":"def can_be_substring_of_rotation(n, s1, m, s2): Checks if s2 can be a substring of some rotation of s1. Parameters: n (int): length of s1 s1 (str): string s1 m (int): length of s2 s2 (str): string s2 Returns: str: \\"YES\\" if s2 can be a substring of some rotation of s1, otherwise \\"NO\\" doubled_s1 = s1 + s1 # By doubling s1, all rotations of s1 are included as substrings. if s2 in doubled_s1: return \\"YES\\" else: return \\"NO\\""},{"question":"def calculate_final_water_flow(T: int, H: int, W: int) -> int: Calculate the final water flow rate based on temperature T, hour H, and initial flow rate W. :param T: Temperature in degrees Celsius :param H: Hour of the day in 24-hour format :param W: Initial water flow rate in liters/minute :return: Final water flow rate in liters/minute >>> calculate_final_water_flow(32, 14, 100) 300 >>> calculate_final_water_flow(25, 10, 100) 150 >>> calculate_final_water_flow(32, 5, 100) 200 >>> calculate_final_water_flow(25, 7, 100) 150 >>> calculate_final_water_flow(20, 2, 100) 100 >>> calculate_final_water_flow(35, 0, 50) 100 >>> calculate_final_water_flow(20, 12, 50) 75 >>> calculate_final_water_flow(30, 12, 50) 75 >>> calculate_final_water_flow(32, 18, 100) 300 pass","solution":"def calculate_final_water_flow(T, H, W): Calculate the final water flow rate based on temperature T, hour H, and initial flow rate W. :param T: Temperature in degrees Celsius :param H: Hour of the day in 24-hour format :param W: Initial water flow rate in liters/minute :return: Final water flow rate in liters/minute if T > 30: W *= 2 if 6 <= H <= 18: W = int(W * 1.5) return W"},{"question":"def matrix_multiply(A, B): Multiplies two matrices A and B, where A is of size n x m and B is of size m x p. Returns the resulting matrix of size n x p. >>> A = [ >>> [1, 2, 3], >>> [4, 5, 6] >>> ] >>> B = [ >>> [7, 8], >>> [9, 10], >>> [11, 12] >>> ] >>> matrix_multiply(A, B) [[58, 64], [139, 154]] from solution import matrix_multiply def test_sample_matrices(): A = [ [1, 2, 3], [4, 5, 6] ] B = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(A, B) expected = [ [58, 64], [139, 154] ] assert result == expected def test_identity_matrix(): A = [ [1, 2], [3, 4] ] B = [ [1, 0], [0, 1] ] result = matrix_multiply(A, B) expected = [ [1, 2], [3, 4] ] assert result == expected def test_zero_matrix(): A = [ [1, 2], [3, 4] ] B = [ [0, 0], [0, 0] ] result = matrix_multiply(A, B) expected = [ [0, 0], [0, 0] ] assert result == expected def test_single_element_matrix(): A = [ [5] ] B = [ [7] ] result = matrix_multiply(A, B) expected = [ [35] ] assert result == expected def test_non_square_matrices(): A = [ [1, 4], [2, 5], [3, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] result = matrix_multiply(A, B) expected = [ [47, 52, 57], [64, 71, 78], [81, 90, 99] ] assert result == expected","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B, where A is of size n x m and B is of size m x p. Returns the resulting matrix of size n x p. n = len(A) m = len(A[0]) p = len(B[0]) # Initialize result matrix with zeroes C = [[0] * p for _ in range(n)] # Perform matrix multiplication for i in range(n): for j in range(p): for k in range(m): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"from typing import List, Dict def restock_needed(test_cases: List[Dict]) -> List[int]: You are tasked to design a simple inventory management system for a store. Your function will determine the number of products that need restocking. A product is considered to need restocking if its quantity falls below a certain threshold. Given a list of products with their respective quantities and a restocking threshold, return the number of products that need restocking. >>> cases = [{'N': 3, 'products': {'APPLE': 50, 'BANANA': 30, 'PEAR': 75}, 'threshold': 40}, {'N': 4, 'products': {'MILK': 10, 'BREAD': 20, 'EGGS': 15, 'CHEESE': 25}, 'threshold': 20}] >>> restock_needed(cases) [1, 2] >>> cases = [{'N': 2, 'products': {'PENCIL': 100, 'PEN': 1000}, 'threshold': 50}] >>> restock_needed(cases) [0] >>> cases = [{'N': 3, 'products': {'JUICE': 5, 'WATER': 1, 'SODA': 10}, 'threshold': 20}] >>> restock_needed(cases) [3] >>> cases = [{'N': 3, 'products': {'PAPER': 200, 'INK': 100, 'STAPLER': 10}, 'threshold': 50}] >>> restock_needed(cases) [1] >>> cases = [{'N': 0, 'products': {}, 'threshold': 10}] >>> restock_needed(cases) [0] >>> cases = [{'N': 2, 'products': {'A': 1, 'B': 10}, 'threshold': 5}, {'N': 3, 'products': {'X': 20, 'Y': 30, 'Z': 5}, 'threshold': 25}, {'N': 1, 'products': {'Q': 7}, 'threshold': 8}] >>> restock_needed(cases) [1, 2, 1]","solution":"def restock_needed(test_cases): results = [] for case in test_cases: N = case['N'] products = case['products'] threshold = case['threshold'] restock_count = sum(1 for product, qty in products.items() if qty < threshold) results.append(restock_count) return results"},{"question":"def detect_sunset_completion(photo_data): Detects the timestamp just before the sunset is complete based on brightness levels. photo_data: List of tuples, where each tuple contains a timestamp 'HH:MM:SS' and a brightness level. Return the timestamp just before the sunset is complete, or 'No sudden decrease' if the brightness level doesn't decrease by at least 20 units at any point in the series. pass # Reading Input def parse_input(input_text): Parses the given input text into a list of tuples with timestamps and brightness levels. input_text: A multiline string where the first line is the number of photos, and subsequent lines are timestamp and brightness pairs separated by space. Returns a list of tuples (timestamp, brightness). pass # Function to process the input and get the result for the output def process_input(input_text): Processes the input text and returns the timestamp just before the sunset is complete. input_text: A multiline string where the first line is the number of photos, and subsequent lines are timestamp and brightness pairs separated by space. Returns the timestamp just before the sunset is complete, or 'No sudden decrease'. pass","solution":"def detect_sunset_completion(photo_data): Detects the timestamp just before the sunset is complete based on brightness levels. photo_data: List of tuples, where each tuple contains a timestamp 'HH:MM:SS' and a brightness level. Return the timestamp just before the sunset is complete, or 'No sudden decrease' if the brightness level doesn't decrease by at least 20 units at any point in the series. for i in range(1, len(photo_data)): prev_timestamp, prev_brightness = photo_data[i - 1] curr_timestamp, curr_brightness = photo_data[i] if prev_brightness - curr_brightness >= 20: return prev_timestamp return \\"No sudden decrease\\" # Reading Input def parse_input(input_text): input_lines = input_text.strip().split('n') n = int(input_lines[0]) photo_data = [] for i in range(1, n + 1): timestamp, brightness = input_lines[i].split() photo_data.append((timestamp, int(brightness))) return photo_data # Function to process the input and get the result for the output def process_input(input_text): photo_data = parse_input(input_text) return detect_sunset_completion(photo_data)"},{"question":"def max_unique_valid_words(n: int, m: int, k: int, chars: str, shout_counts: List[int]) -> int: Calculate the maximum number of unique valid words shouted in a single minute during the contest. Parameters: n (int): Number of minutes the contest lasts. m (int): Number of unique characters. k (int): Maximum length of a valid word. chars (str): String of length m consisting of distinct lowercase English letters. shout_counts (list of int): List of integers where each integer represents the number of words shouted in the i-th minute. Returns: int: Maximum number of unique valid words shouted in any single minute. >>> max_unique_valid_words(5, 3, 4, 'abc', [3, 2, 4, 1, 3]) 81 >>> max_unique_valid_words(4, 4, 3, 'abcd', [2, 3, 1, 4]) 64","solution":"def max_unique_valid_words(n, m, k, chars, shout_counts): This function calculates the maximum number of unique valid words shouted in any single minute during the contest. Parameters: n (int): Number of minutes the contest lasts. m (int): Number of unique characters. k (int): Maximum length of a valid word. chars (str): String of length m consisting of distinct lowercase English letters. shout_counts (list of int): List of integers where each integer represents the number of words shouted in the i-th minute. Returns: int: Maximum number of unique valid words shouted in any single minute. max_words_in_minute = max(shout_counts) # Each unique word can be up to length k, using m different characters max_unique_valid_words = m ** k return max_unique_valid_words # Example usage: n, m, k = 4, 4, 3 chars = 'abcd' shout_counts = [2, 3, 1, 4] print(max_unique_valid_words(n, m, k, chars, shout_counts)) # Output should be 64"},{"question":"from typing import List def validate_email_addresses(email_addresses: List[str]) -> List[bool]: Takes a list of email addresses and returns a list of booleans indicating whether each email address is valid or not. >>> validate_email_addresses([\\"john.doe@example.com\\", \\"jane_doe@domain.co.uk\\"]) [True, True] >>> validate_email_addresses([\\"invalid-email-@example..com\\", \\"_invalid@example.com\\"]) [False, False]","solution":"import re def validate_email_addresses(email_addresses): Takes a list of email addresses and returns a list of booleans indicating whether each email address is valid or not. validations = [] for email in email_addresses: if is_valid_email(email): validations.append(True) else: validations.append(False) return validations def is_valid_email(email): Validates a single email address against the specified rules. # Define regex pattern for valid email pattern = re.compile( r\\"^[a-zA-Z0-9]([w-.]*[a-zA-Z0-9])?@[a-zA-Z0-9]+(.[a-zA-Z]{2,4})+\\" ) return bool(pattern.match(email))"},{"question":"def is_prime(n: int) -> bool: Utility function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(18) False # Implementation here def is_mystic_number(x: int) -> bool: Function to determine if a number is a Mystic Number. >>> is_mystic_number(6) True >>> is_mystic_number(7) True >>> is_mystic_number(8) False >>> is_mystic_number(10) True >>> is_mystic_number(15) False # Implementation here def mystic_numbers(T: int, numbers: List[int]) -> List[str]: Function to process T integers and determine if each is a Mystic Number. >>> mystic_numbers(5, [6, 7, 8, 10, 15]) ['Yes', 'Yes', 'No', 'Yes', 'No'] >>> mystic_numbers(3, [2, 3, 4]) ['No', 'Yes', 'No'] # Implementation here","solution":"def is_prime(n): Utility function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_mystic_number(x): Function to determine if a number is a Mystic Number. # Count the number of '1's in the binary representation of x count_of_ones = bin(x).count('1') # A number is Mystic if the count of '1's is a prime number return is_prime(count_of_ones) def mystic_numbers(T, numbers): Function to process T integers and determine if each is a Mystic Number. result = [] for number in numbers: if is_mystic_number(number): result.append(\\"Yes\\") else: result.append(\\"No\\") return result"},{"question":"def max_product_of_three(nums: List[int]) -> int: Returns the maximum product of any three distinct elements from the array. >>> max_product_of_three([1, 2, 3, 4, 5]) 60 >>> max_product_of_three([-10, -10, 5, 2, 1, 3]) 500","solution":"def max_product_of_three(nums): Returns the maximum product of any three distinct elements from the array. nums.sort() n = len(nums) # Consider the maximum product is either: # 1. Product of the three largest numbers # 2. Product of two smallest numbers (which could be negative) and the largest number product1 = nums[-1] * nums[-2] * nums[-3] product2 = nums[0] * nums[1] * nums[-1] return max(product1, product2)"},{"question":"def generate_star_pyramid(height: int) -> str: Generates a star pyramid of a given height. Args: height (int): Height of the pyramid Returns: str: A string representation of the star pyramid Examples: >>> generate_star_pyramid(2) \\" *n***\\" >>> generate_star_pyramid(4) \\" *n ***n *****n*******\\" >>> generate_star_pyramid(3) \\" *n ***n*****\\" def process_test_cases(test_cases: List[int]) -> List[str]: Processes multiple test cases to generate star pyramids. Args: test_cases (list): List of heights for each test case Returns: list: A list of strings, each representing the star pyramid for a test case Examples: >>> process_test_cases([2, 4, 3]) [\\" *n***\\", \\" *n ***n *****n*******\\", \\" *n ***n*****\\"]","solution":"def generate_star_pyramid(height): Generates a star pyramid of a given height. Args: height (int): Height of the pyramid Returns: str: A string representation of the star pyramid pyramid = [] for i in range(height): # Number of spaces before the stars spaces = ' ' * (height - i - 1) # Number of stars in the current row stars = '*' * (2 * i + 1) pyramid.append(spaces + stars) return 'n'.join(pyramid) def process_test_cases(test_cases): Processes multiple test cases to generate star pyramids. Args: test_cases (list): List of heights for each test case Returns: list: A list of strings, each representing the star pyramid for a test case results = [] for height in test_cases: results.append(generate_star_pyramid(height)) return results"},{"question":"def find_clusters(n: int, m: int, coordinates: List[Tuple[int, int]]) -> List[List[Tuple[int, int]]]: A function to find all clusters of characters in a 2D grid-based game. Args: n (int): number of characters. m (int): maximum coordinate value. coordinates (List[Tuple[int, int]]): list of unique coordinates representing the characters. Returns: List[List[Tuple[int, int]]]: list of clusters, each cluster being a list of coordinates. >>> find_clusters(5, 10, [(1, 1), (2, 1), (1, 2), (3, 4), (4, 4)]) [[(1, 1), (1, 2), (2, 1)], [(3, 4), (4, 4)]] >>> find_clusters(1, 10, [(0, 0)]) [[(0, 0)]] >>> find_clusters(4, 10, [(0, 0), (2, 2), (4, 4), (6, 6)]) [[(0, 0)], [(2, 2)], [(4, 4)], [(6, 6)]] >>> find_clusters(4, 10, [(0, 0), (0, 1), (1, 0), (1, 1)]) [[(0, 0), (0, 1), (1, 0), (1, 1)]] >>> find_clusters(6, 10, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 3), (3, 4)]) [[(0, 0), (0, 1), (1, 1)], [(2, 2)], [(3, 3), (3, 4)]]","solution":"def find_clusters(n, m, coordinates): from collections import deque, defaultdict def bfs(start, visited, adj_list): queue = deque([start]) cluster = [] while queue: x, y = queue.popleft() if (x, y) not in visited: visited.add((x, y)) cluster.append((x, y)) for neighbor in adj_list[(x, y)]: if neighbor not in visited: queue.append(neighbor) cluster.sort() return cluster adj_list = defaultdict(list) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] coordinates_set = set(coordinates) for x, y in coordinates: for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) in coordinates_set: adj_list[(x, y)].append((nx, ny)) visited = set() clusters = [] for coord in coordinates: if coord not in visited: cluster = bfs(coord, visited, adj_list) clusters.append(cluster) return clusters # Example usage n = 5 m = 10 coordinates = [(1, 1), (2, 1), (1, 2), (3, 4), (4, 4)] clusters = find_clusters(n, m, coordinates) for cluster in clusters: for c in cluster: print(c) print()"},{"question":"def flower_arrangements(M: int, K: int) -> int: Returns the number of possible arrangements of the K flowers in a row from M different types. Args: M (int): Number of different types of flowers. K (int): Number of flowers in the row. Returns: int: Possible arrangements of the K flowers in a row. >>> flower_arrangements(3, 2) 9 >>> flower_arrangements(1, 1) 1 >>> flower_arrangements(10, 7) 10000000 >>> flower_arrangements(2, 1) 2 >>> flower_arrangements(2, 3) 8 >>> flower_arrangements(4, 1) 4 >>> flower_arrangements(7, 1) 7 >>> flower_arrangements(5, 3) 125","solution":"def flower_arrangements(M, K): Returns the number of possible arrangements of the K flowers in a row from M different types. Args: M (int): Number of different types of flowers. K (int): Number of flowers in the row. Returns: int: Possible arrangements of the K flowers in a row. return M ** K"},{"question":"def min_subrectangle_sum(matrix): Returns the top-left corner, bottom-right corner of the subrectangle with the minimal sum, and the minimal sum itself. Args: matrix (List[List[int]]): The input grid with n rows and m columns containing integer values. Returns: Tuple[int, int, int, int, int]: The top-left corner (r1, c1), bottom-right corner (r2, c2) of the subrectangle, and the minimal sum of weights of cells in the subrectangle. Examples: >>> min_subrectangle_sum([[1, 2, 3, 4, 5], ... [6, 7, 8, 9, 10], ... [-1, -2, -3, -4, -5], ... [5, 4, 3, 2, 1]]) (3, 1, 3, 5, -15) >>> min_subrectangle_sum([[0, -2, 3], ... [-1, 2, 2], ... [4, -3, 1]]) (1, 2, 3, 2, -3) pass","solution":"def min_subrectangle_sum(matrix): Returns the top-left corner, bottom-right corner of the subrectangle with the minimal sum, and the minimal sum itself. n = len(matrix) m = len(matrix[0]) min_sum = float('inf') result = (0, 0, 0, 0, 0) for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] current_sum = 0 min_temp_sum = float('inf') start = 0 for i in range(n): current_sum += temp[i] if current_sum < min_temp_sum: min_temp_sum = current_sum row_start = start row_end = i if current_sum > 0: current_sum = 0 start = i + 1 if min_temp_sum < min_sum: min_sum = min_temp_sum result = (row_start + 1, left + 1, row_end + 1, right + 1, min_sum) return (result[0], result[1], result[2], result[3], result[4]) # Example usage: # n, m = 4, 5 # matrix = [ # [1, 2, 3, 4, 5], # [6, 7, 8, 9, 10], # [-1, -2, -3, -4, -5], # [5, 4, 3, 2, 1] # ] # print(min_subrectangle_sum(matrix))"},{"question":"def can_rearrange_to_palindrome(s: str) -> str: Determines if the input string s can be rearranged to form a palindrome. Parameters: s (str): Input string consisting of at most 1000 alphanumeric characters. Returns: str: \\"YES\\" if s can be rearranged to form a palindrome, otherwise \\"NO\\". Example: >>> can_rearrange_to_palindrome(\\"aabbcc\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"level\\") \\"YES\\" >>> can_rearrange_to_palindrome(\\"abbbaac\\") \\"NO\\"","solution":"def can_rearrange_to_palindrome(s): Determines if the input string s can be rearranged to form a palindrome. Parameters: s (str): Input string. Returns: str: \\"YES\\" if s can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Filter out non-alphanumeric characters and convert to lowercase filtered_s = ''.join([char for char in s if char.isalnum()]).lower() # Count the frequency of each character char_count = Counter(filtered_s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to a palindrome if it has at most one character with an odd frequency if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def process_sensor_messages(n, messages): Processes a list of sensor messages to generate an alert report. Arguments: n -- the number of messages messages -- a list of messages in the format <SensorID>:<Time>:<Status> Returns: A tuple containing: - The total number of alerts - A list of sensor IDs that sent alerts, in ascending order - The time of the last alert received >>> process_sensor_messages(6, [\\"1:08:30:OK\\", \\"2:09:15:ALERT\\", \\"3:10:00:ALERT\\", \\"4:10:30:OK\\", \\"2:10:45:ALERT\\", \\"1:11:00:OK\\"]) (3, [2, 3], \\"10:45\\") >>> process_sensor_messages(4, [\\"1:08:30:OK\\", \\"2:09:15:OK\\", \\"3:10:00:OK\\", \\"4:10:30:OK\\"]) (0, [], None) >>> process_sensor_messages(5, [\\"5:12:00:OK\\", \\"6:13:15:ALERT\\", \\"7:14:30:OK\\", \\"8:15:45:ALERT\\", \\"9:16:00:ALERT\\"]) (3, [6, 8, 9], \\"16:00\\")","solution":"def process_sensor_messages(n, messages): Processes a list of sensor messages to generate an alert report. Arguments: n -- the number of messages messages -- a list of messages in the format <SensorID>:<Time>:<Status> Returns: A tuple containing: - The total number of alerts - A list of sensor IDs that sent alerts, in ascending order - The time of the last alert received alert_count = 0 alert_sensors = set() last_alert_time = None for message in messages: parts = message.split(':') sensor_id = int(parts[0]) time = parts[1] + \\":\\" + parts[2] status = parts[3] if status == \\"ALERT\\": alert_count += 1 alert_sensors.add(sensor_id) last_alert_time = time alert_sensors = sorted(alert_sensors) return alert_count, alert_sensors, last_alert_time"},{"question":"def min_moves_to_reach(N, M, x1, y1, x2, y2): Returns the minimum number of moves to reach from (x1, y1) to (x2, y2) on a grid of size N x M. Moves can be horizontal, vertical, or diagonal. If the end position cannot be reached, returns -1. >>> min_moves_to_reach(5, 5, 1, 1, 5, 5) 4 >>> min_moves_to_reach(3, 3, 1, 1, 3, 3) 2 >>> min_moves_to_reach(4, 4, 2, 2, 2, 2) 0 pass def process_test_cases(T, test_cases): Processes multiple test cases for the min_moves_to_reach function. >>> test_cases = [(5, 5, 1, 1, 5, 5), (3, 3, 1, 1, 3, 3), (4, 4, 2, 2, 2, 2)] >>> process_test_cases(3, test_cases) [4, 2, 0] pass","solution":"def min_moves_to_reach(N, M, x1, y1, x2, y2): Returns the minimum number of moves to reach from (x1, y1) to (x2, y2) on a grid of size N x M. Moves can be horizontal, vertical, or diagonal. # If the start and end positions are the same if x1 == x2 and y1 == y2: return 0 # Calculate horizontal and vertical distances dx = abs(x2 - x1) dy = abs(y2 - y1) # The number of moves required is max of horizontal or vertical distances return max(dx, dy) def process_test_cases(T, test_cases): results = [] for case in test_cases: N, M, x1, y1, x2, y2 = case results.append(min_moves_to_reach(N, M, x1, y1, x2, y2)) return results # For debugging or running without input/output loops # sample_test_cases = [ # (5, 5, 1, 1, 5, 5), # (3, 3, 1, 1, 3, 3), # (4, 4, 2, 2, 2, 2) # ] # print(process_test_cases(3, sample_test_cases))"},{"question":"def lexicographically_smallest_subsequence(T, test_cases): Find the lexicographically smallest subsequence of exactly K digits for each test case. Args: T (int): Number of test cases. test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string S representing a sequence of digits and an integer K. Returns: List[str]: A list of the lexicographically smallest subsequences for each test case. Examples: >>> lexicographically_smallest_subsequence(3, [(\\"654321\\", 2), (\\"123456\\", 3), (\\"54321\\", 2)]) [\\"21\\", \\"123\\", \\"21\\"] >>> lexicographically_smallest_subsequence(2, [(\\"987654321\\", 4), (\\"123456789\\", 4)]) [\\"4321\\", \\"1234\\"] ... def number_muncher(T, input_data): Wrapper function to format input and output for the lexicographically_smallest_subsequence function. Args: T (int): Number of test cases. input_data (List[Tuple[str, int]]): A list of tuples where each tuple contains a string S representing a sequence of digits and an integer K. Returns: List[str]: A list of the lexicographically smallest subsequences for each test case. ...","solution":"def lexicographically_smallest_subsequence(T, test_cases): results = [] for S, K in test_cases: K = int(K) stack = [] for i, digit in enumerate(S): while stack and len(stack) + len(S) - i > K and stack[-1] > digit: stack.pop() if len(stack) < K: stack.append(digit) results.append(''.join(stack)) return results # Wrapper to format the input and output def number_muncher(T, input_data): test_cases = [(input_data[i][0], input_data[i][1]) for i in range(T)] return lexicographically_smallest_subsequence(T, test_cases)"},{"question":"from typing import List def compute_tree_depth(n: int, nodes: List[str]) -> int: Compute the depth of the tree starting from the root node. Args: n (int): Number of nodes in the tree. nodes (List[str]): List of node descriptions, where each description follows the format 'NodeID NumberOfChildren ChildID1 ChildID2 ... ChildIDk'. Returns: int: Depth of the tree. Example: >>> n = 7 >>> nodes = [ ... \\"1 3 2 3 4\\", ... \\"2 2 5 6\\", ... \\"3 0\\", ... \\"4 0\\", ... \\"5 1 7\\", ... \\"6 0\\", ... \\"7 0\\" ... ] >>> compute_tree_depth(n, nodes) 3 >>> n = 1 >>> nodes = [\\"1 0\\"] >>> compute_tree_depth(n, nodes) 0","solution":"def compute_tree_depth(n, nodes): from collections import defaultdict, deque tree = defaultdict(list) for node in nodes: details = list(map(int, node.split())) tree[details[0]] = details[2:] def dfs(node): if not tree[node]: return 0 max_depth = 0 for child in tree[node]: max_depth = max(max_depth, dfs(child) + 1) return max_depth return dfs(1) # Example usage: n = 7 nodes = [ \\"1 3 2 3 4\\", \\"2 2 5 6\\", \\"3 0\\", \\"4 0\\", \\"5 1 7\\", \\"6 0\\", \\"7 0\\" ] print(compute_tree_depth(n, nodes)) # Output: 3"},{"question":"def rearrange_list(nums: List[int]) -> List[int]: Rearranges the list so that all the even numbers appear before all the odd numbers. The relative order of the even and odd numbers is preserved. :param nums: List of integers :return: Modified list with evens before odds Examples: >>> rearrange_list([1, 2, 3, 4, 5]) [2, 4, 1, 3, 5] >>> rearrange_list([10, 1, 9, 4, 7, 3, 2]) [10, 4, 2, 1, 9, 7, 3] >>> rearrange_list([3, 1, 4, 6, 8]) [4, 6, 8, 3, 1] >>> rearrange_list([7, 5, 3, 2, 8]) [2, 8, 7, 5, 3] >>> rearrange_list([]) [] >>> rearrange_list([3, -2, -4, 5, 0]) [-2, -4, 0, 3, 5] >>> rearrange_list([-1, -3, -5, 2, -8]) [2, -8, -1, -3, -5]","solution":"def rearrange_list(nums): Rearranges the list so that all the even numbers appear before all the odd numbers. The relative order of the even and odd numbers is preserved. :param nums: List of integers :return: Modified list with evens before odds if not nums: # Check if the list is empty return [] evens = [num for num in nums if num % 2 == 0] odds = [num for num in nums if num % 2 != 0] return evens + odds"},{"question":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def rebuildBST(inorder): Given an array of integers representing the inorder traversal of a Binary Search Tree (BST), return the root of the BST reconstructed from the provided inorder traversal. >>> rebuildBST([1, 2, 3]).val 2 >>> rebuildBST([1, 2, 3, 4, 5, 6, 7]).right.right.val 5 pass def inorderTraversal(root): Helper function to get the inorder traversal of the BST. >>> inorderTraversal(TreeNode(2)) [2] pass def test_rebuildBST_single_element(): inorder = [1] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [1] def test_rebuildBST_three_elements(): inorder = [1, 2, 3] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [1, 2, 3] def test_rebuildBST_seven_elements(): inorder = [1, 2, 3, 4, 5, 6, 7] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [1, 2, 3, 4, 5, 6, 7] def test_rebuildBST_empty_array(): inorder = [] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [] def test_rebuildBST_balanced(): inorder = [1, 3, 4, 6, 7, 8, 10, 13, 14] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [1, 3, 4, 6, 7, 8, 10, 13, 14] def test_rebuildBST_unbalanced(): inorder = [1, 2, 3, 4, 5] root = rebuildBST(inorder) result = inorderTraversal(root) assert result == [1, 2, 3, 4, 5]","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def rebuildBST(inorder): Rebuild a BST from inorder traversal and return its root node. if not inorder: return None # Helper function to rebuild BST from a given inorder traversal segment def buildTree(left, right): if left > right: return None mid = (left + right) // 2 node = TreeNode(inorder[mid]) node.left = buildTree(left, mid - 1) node.right = buildTree(mid + 1, right) return node return buildTree(0, len(inorder) - 1) def inorderTraversal(root): Helper function to get the inorder traversal of the BST. return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else []"},{"question":"def print_palindromic_strings(strings): Print palindromic strings from the list. The list ends with the string \\"END\\". Sample Input: [\\"racecar\\", \\"hello\\", \\"level\\", \\"END\\"] Sample Output: racecar level","solution":"def print_palindromic_strings(strings): Print palindromic strings from the list. The list ends with the string \\"END\\". for s in strings: if s == \\"END\\": break if s == s[::-1]: print(s)"},{"question":"def steps_to_one(n: int) -> int: Returns the number of steps it takes for n to become 1 following the specified rules. >>> steps_to_one(6) == 8 >>> steps_to_one(11) == 14 >>> steps_to_one(1) == 0 >>> steps_to_one(2) == 1 >>> steps_to_one(3) == 7 >>> steps_to_one(4) == 2 >>> steps_to_one(16) == 4 >>> steps_to_one(19) == 20 >>> steps_to_one(27) == 111","solution":"def steps_to_one(n): Returns the number of steps it takes for n to become 1 following the specified rules. :param n: Integer input where 1 ≤ n ≤ 10^6 :return: Number of steps to reach 1 steps = 0 while n != 1: if n % 2 == 0: n //= 2 else: n = n * 3 + 1 steps += 1 return steps"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def treeVibration(root: TreeNode) -> int: Calculate the vibration of a binary tree, which is the sum of depths of all nodes. >>> treeVibration(None) 0 >>> root = TreeNode(1) >>> treeVibration(root) 0 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> treeVibration(root) 2 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> treeVibration(root) 6 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.left.left = TreeNode(4) >>> treeVibration(root) 6 >>> root = TreeNode(1) >>> root.right = TreeNode(2) >>> root.right.right = TreeNode(3) >>> root.right.right.right = TreeNode(4) >>> treeVibration(root) 6","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def treeVibration(root: TreeNode) -> int: Calculate the vibration of a binary tree, which is the sum of depths of all nodes. def helper(node, depth): if not node: return 0 return depth + helper(node.left, depth + 1) + helper(node.right, depth + 1) return helper(root, 0)"},{"question":"def longest_subsequence_with_perfect_square_product(arr: List[int]) -> int: Returns the length of the longest subsequence such that when sorted, every pair of adjacent elements have a product that is a perfect square. >>> longest_subsequence_with_perfect_square_product([1, 4, 16, 9, 25]) == 5 >>> longest_subsequence_with_perfect_square_product([2, 3, 5, 7, 11, 13]) == 1 def test_example_1(): assert longest_subsequence_with_perfect_square_product([1, 4, 16, 9, 25]) == 5 def test_example_2(): assert longest_subsequence_with_perfect_square_product([2, 3, 5, 7, 11, 13]) == 1 def test_single_element(): assert longest_subsequence_with_perfect_square_product([4]) == 1 def test_all_perfect_squares(): assert longest_subsequence_with_perfect_square_product([1, 4, 9, 16, 25, 36]) == 6 def test_no_perfect_squares(): assert longest_subsequence_with_perfect_square_product([2, 3, 5, 7]) == 1 def test_mixed_elements(): assert longest_subsequence_with_perfect_square_product([1, 8, 4, 12, 16, 20]) == 3","solution":"def is_perfect_square(num): Checks if a number is a perfect square. root = int(num**0.5) return root * root == num def longest_subsequence_with_perfect_square_product(arr): Returns the length of the longest subsequence such that when sorted, every pair of adjacent elements have a product that is a perfect square. n = len(arr) # Edge case for small inputs if n == 1: return 1 # dp array to store the longest subsequence length ending at each index dp = [1] * n arr.sort() for i in range(n): for j in range(i): if is_perfect_square(arr[i] * arr[j]): dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def is_strictly_increasing_sequence(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if given sequences are strictly increasing. >>> is_strictly_increasing_sequence(2, [(4, [1, 2, 3, 4]), (5, [5, 4, 3, 2, 1])]) ['Yes', 'No'] >>> is_strictly_increasing_sequence(1, [(2, [1, 2])]) ['Yes']","solution":"def is_strictly_increasing_sequence(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] sequence = test_cases[i][1] if all(sequence[j] < sequence[j+1] for j in range(n-1)): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Example usage: T = 2 test_cases = [(4, [1, 2, 3, 4]), (5, [5, 4, 3, 2, 1])] print(is_strictly_increasing_sequence(T, test_cases))"},{"question":"def is_balanced(s: str) -> str: Write a function that determines whether a given string of parentheses (of various types) is balanced. The types of parentheses are \`()\`, \`{}\`, and \`[]\`. Args: s (str): A single line consisting of the string of parentheses. Returns: str: 'YES' if the parentheses are balanced, otherwise 'NO'. >>> is_balanced(\\"{[()()]}\\") 'YES' >>> is_balanced(\\"{[(])}\\") 'NO'","solution":"def is_balanced(s): Checks if the provided string of parentheses is balanced. Args: s (str): The string containing the parentheses. Returns: str: 'YES' if the string is balanced, otherwise 'NO'. stack = [] matching_parentheses = {')': '(', '}': '{', ']': '['} for char in s: if char in '({[': stack.append(char) elif char in ')}]': if not stack or stack[-1] != matching_parentheses[char]: return 'NO' stack.pop() return 'YES' if not stack else 'NO'"},{"question":"def max_requests_fulfilled(n: int, m: int, coins: List[int], requests: List[int]) -> int: Determine the maximum number of requests that can be fulfilled with given coins. Args: n : int : Number of coins m : int : Number of requests coins : List[int] : Values of each coin requests : List[int] : Values of each request Returns: int : Maximum number of requests that can be fulfilled. Example: >>> max_requests_fulfilled(5, 3, [1, 2, 3, 4, 5], [2, 4, 6]) 2 >>> max_requests_fulfilled(4, 4, [1, 3, 4, 5], [2, 3, 4, 6]) 2","solution":"def max_requests_fulfilled(n, m, coins, requests): coins_set = set(coins) fulfilled = 0 for request in requests: if request in coins_set: fulfilled += 1 coins_set.remove(request) return fulfilled # Example usage: # n, m = 5, 3 # coins = [1, 2, 3, 4, 5] # requests = [2, 4, 6] # print(max_requests_fulfilled(n, m, coins, requests)) -> Output: 2"},{"question":"def tree_planting_campaign(N, M, W, P, D): Determines the number of trees in each section at the end of each week. Parameters: N (int): The number of sections. M (int): The initial number of trees in each section. W (int): The number of weeks. P (list): The number of trees planted in each section in each week. D (list): The number of trees cut down from each section in each week. Returns: list of lists: The number of trees in each section at the end of each week. >>> tree_planting_campaign(3, 5, 2, [3, 4], [2, 1]) [[6, 6, 6], [9, 9, 9]] >>> tree_planting_campaign(1, 10, 3, [5, 6, 7], [2, 3, 4]) [[13], [16], [19]] >>> tree_planting_campaign(4, 0, 2, [2, 3], [1, 1]) [[1, 1, 1, 1], [3, 3, 3, 3]] >>> tree_planting_campaign(5, 10, 1, [0], [5]) [[5, 5, 5, 5, 5]] >>> tree_planting_campaign(2, 1000000000, 2, [1000000000, 1000000000], [500000000, 500000000]) [[1500000000, 1500000000], [2000000000, 2000000000]] >>> tree_planting_campaign(1, 1, 1, [0], [0]) [[1]] >>> tree_planting_campaign(2, 1, 1, [0], [1]) [[0, 0]] >>> tree_planting_campaign(2, 1, 1, [1], [0]) [[2, 2]]","solution":"def tree_planting_campaign(N, M, W, P, D): Determines the number of trees in each section at the end of each week. Parameters: N (int): The number of sections. M (int): The initial number of trees in each section. W (int): The number of weeks. P (list): The number of trees planted in each section in each week. D (list): The number of trees cut down from each section in each week. Returns: list of lists: The number of trees in each section at the end of each week. results = [] trees_per_section = [M] * N for i in range(W): trees_to_add = P[i] trees_to_cut = D[i] for j in range(N): trees_per_section[j] += trees_to_add - trees_to_cut results.append(trees_per_section.copy()) return results"},{"question":"import heapq from typing import List def min_final_energy(N: int, energies: List[int]) -> int: Determines the minimum possible value of the energy level of the final shard. Args: N (int): Number of crystal shards. energies (List[int]): Energy levels of the crystal shards. Returns: int: Minimum possible energy level of the final shard. Examples: >>> min_final_energy(4, [4, 3, 2, 1]) 19 >>> min_final_energy(3, [1, 2, 3]) 9 # Implement the function here def test_example_1(): assert min_final_energy(4, [4, 3, 2, 1]) == 19 def test_example_2(): assert min_final_energy(3, [1, 2, 3]) == 9 def test_two_elements(): assert min_final_energy(2, [5, 9]) == 14 def test_all_same_elements(): assert min_final_energy(4, [1, 1, 1, 1]) == 8 def test_large_difference(): assert min_final_energy(3, [1000000000, 1, 1]) == 1000000004 def test_max_elements(): import random random.seed(1) energies = [random.randint(1, 10**9) for _ in range(100000)] assert min_final_energy(100000, energies) > 0 # Just testing for execution completeness","solution":"import heapq def min_final_energy(N, energies): Returns the minimum possible value of the energy level of the final shard. # Convert energies list into a heap heapq.heapify(energies) total_energy = 0 # Continue merging until we have one final shard while len(energies) > 1: # Extract the two shards with the lowest energies first_min = heapq.heappop(energies) second_min = heapq.heappop(energies) # Sum their energy to form a new shard new_energy = first_min + second_min total_energy += new_energy # Add the new shard back to the heap heapq.heappush(energies, new_energy) return total_energy"},{"question":"MORSE_CODE_DICT = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } def text_to_morse(text: str) -> str: Converts text to its Morse code equivalent. >>> text_to_morse(\\"HELLO WORLD\\") \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> text_to_morse(\\"SOS\\") \\"... --- ...\\" >>> text_to_morse(\\"HELLO 123\\") \\".... . .-.. .-.. --- / .---- ..--- ...--\\" >>> text_to_morse(\\"HELLO@ WORLD!\\") \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" pass def morse_to_text(morse: str) -> str: Converts Morse code to its text equivalent. >>> morse_to_text(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") \\"HELLO WORLD\\" >>> morse_to_text(\\"... --- ...\\") \\"SOS\\" >>> morse_to_text(\\".... . .-.. .-.. --- / .---- ..--- ...--\\") \\"HELLO 123\\" >>> morse_to_text(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") \\"HELLO WORLD\\" pass","solution":"MORSE_CODE_DICT = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' } def text_to_morse(text: str) -> str: Converts text to its Morse code equivalent. text = text.upper() morse_code = [] for char in text: if char == ' ': morse_code.append('/') elif char in MORSE_CODE_DICT: morse_code.append(MORSE_CODE_DICT[char]) return ' '.join(morse_code) def morse_to_text(morse: str) -> str: Converts Morse code to its text equivalent. morse_words = morse.split(' / ') text = [] for word in morse_words: morse_chars = word.split() for char in morse_chars: for key, value in MORSE_CODE_DICT.items(): if value == char: text.append(key) break text.append(' ') return ''.join(text).strip()"},{"question":"def max_subarray_sum(arr): This function finds the largest sum of any contiguous subarray in a given list of integers. :param arr: list of integers :return: largest sum of any contiguous subarray >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1]) -1 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6","solution":"def max_subarray_sum(arr): This function uses Kadane's algorithm to find the largest sum of a contiguous subarray. :param arr: list of integers :return: largest sum of any contiguous subarray max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def can_be_peak(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if there exists a building 'k' such that all buildings to the left of 'k' are in non-decreasing order and all buildings to the right of 'k' are in non-increasing order. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer 'n' and a list of 'n' integers representing the heights of the buildings. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" for each test case. Examples: >>> can_be_peak(4, [(7, [1, 2, 3, 5, 4, 3, 2]), (3, [1, 2, 1]), (5, [2, 2, 2, 2, 2]), (4, [1, 3, 2, 4])]) ['YES', 'YES', 'YES', 'NO'] >>> can_be_peak(1, [(1, [5])]) ['YES'] >>> can_be_peak(1, [(5, [5, 4, 3, 2, 1])]) ['YES'] >>> can_be_peak(1, [(5, [1, 2, 3, 4, 5])]) ['YES'] >>> can_be_peak(1, [(5, [1, 5, 3, 4, 2])]) ['NO']","solution":"def can_be_peak(t, test_cases): results = [] for n, heights in test_cases: found = False for k in range(1, n+1): left_sorted = all(heights[i] <= heights[i+1] for i in range(k-1)) right_sorted = all(heights[j] >= heights[j+1] for j in range(k, n-1)) if left_sorted and right_sorted: found = True break results.append(\\"YES\\" if found else \\"NO\\") return results # Example running code t = 4 test_cases = [ (7, [1, 2, 3, 5, 4, 3, 2]), (3, [1, 2, 1]), (5, [2, 2, 2, 2, 2]), (4, [1, 3, 2, 4]) ] print(can_be_peak(t, test_cases))"},{"question":"def SolveEquation(equation: str, variable: str) -> float: Solves the given equation for the specified variable. Args: equation (str): The linear equation in string form. variable (str): The variable to solve for. Returns: float: The value of the variable, or None if the equation is invalid or cannot be solved. Examples: >>> SolveEquation(\\"3x + 2 = 14\\", \\"x\\") 4 >>> SolveEquation(\\"4y + 7 = 19\\", \\"y\\") 3 pass def test_solve_equation_example_1(): assert SolveEquation(\\"3x + 2 = 14\\", \\"x\\") == 4 def test_solve_equation_example_2(): assert SolveEquation(\\"4y + 7 = 19\\", \\"y\\") == 3 def test_solve_equation_with_positive_coeff(): assert SolveEquation(\\"5a + 10 = 25\\", \\"a\\") == 3 def test_solve_equation_with_negative_coeff(): assert SolveEquation(\\"-2b + 10 = 4\\", \\"b\\") == 3 def test_solve_equation_with_no_coeff(): assert SolveEquation(\\"c + 5 = 8\\", \\"c\\") == 3 def test_solve_equation_full_variable(): assert SolveEquation(\\"x - 5 = 10\\", \\"x\\") == 15 def test_solve_equation_with_negative_side(): assert SolveEquation(\\"2x + 3 = 1\\", \\"x\\") == -1 def test_solve_equation_with_spaces(): assert SolveEquation(\\"3 a + 2 = 14\\", \\"a\\") == 4 def test_solve_equation_with_large_numbers(): assert SolveEquation(\\"1000z - 2000 = 3000\\", \\"z\\") == 5","solution":"def SolveEquation(equation, variable): Solves the linear equation in one variable and returns the value of the variable. Args: equation : str : the equation in the format of a string variable : str : the variable to be solved Returns: float or int or None : value of the variable if solvable, otherwise None. # Remove spaces for simplicity equation = equation.replace(' ', '') # Find the position of the equal sign equal_pos = equation.index('=') # Split the equation into LHS and RHS lhs = equation[:equal_pos] rhs = equation[equal_pos+1:] # Find variable coefficient in LHS import re # Regular expression to find the pattern like \\"3x\\" or \\"x\\" match = re.match(r'([+-]?d*)([a-z])', lhs) if not match: return None # Coefficient of the variable coeff = match.group(1) coeff = int(coeff) if coeff and coeff != '+' and coeff != '-' else (1 if coeff == '' or coeff == '+' else -1) # Constant term in the LHS const = re.findall(r'[+-]?d+', lhs.replace(match.group(0), '')) const = int(const[0]) if const else 0 # RHS value rhs_value = int(rhs) # Solving for the variable try: variable_value = (rhs_value - const) / coeff except ZeroDivisionError: return None return variable_value"},{"question":"def parse_input(input_text: str): Parses input into an array of integers and a target integer T. Args: input_text: A string containing two integers n and T on the first line, followed by n space-separated integers on the second line. Returns: A tuple (arr, T) where arr is the list of integers and T is the target sum T. pass def shortest_subarray_length(arr: List[int], T: int) -> int: Given an array of n positive integers and a target integer T, find the length of the shortest contiguous subarray whose sum is equal to or greater than T. If there is no such subarray, return 0. Args: arr: List of positive integers T: Target sum Returns: An integer representing the length of the shortest contiguous subarray whose sum is equal to or greater than T. If no such subarray, return 0. Example: >>> shortest_subarray_length([5, 1, 3, 5, 10, 7], 15) 2 >>> shortest_subarray_length([2, 3, 1, 2, 4, 3], 20) 0 pass # Test the functions with unit tests def test_example_1(): input_text = \\"5 15n5 1 3 5 10 7\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 2 def test_example_2(): input_text = \\"7 20n2 3 1 2 4 3\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 0 def test_no_subarray(): input_text = \\"3 10n1 1 1\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 0 def test_exact_match(): input_text = \\"5 9n1 2 3 4 1\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 3 def test_entire_array(): input_text = \\"4 10n1 2 3 4\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 4 def test_large_input(): input_text = \\"10 55n1 2 3 4 5 6 7 8 9 10\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 10 def test_multiple_subarrays(): input_text = \\"10 15n5 1 3 5 10 7 4 1 6 3\\" arr, T = parse_input(input_text) assert shortest_subarray_length(arr, T) == 2","solution":"def shortest_subarray_length(arr, T): Given an array of n positive integers and a target integer T, find the length of the shortest contiguous subarray whose sum is equal to or greater than T. If there is no such subarray, return 0. n = len(arr) min_length = float('inf') current_sum = 0 start_index = 0 for end_index in range(n): current_sum += arr[end_index] while current_sum >= T: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float('inf') else 0 def parse_input(input_text): lines = input_text.strip().split(\\"n\\") n, T = map(int, lines[0].split()) arr = list(map(int, lines[1].split())) return arr, T"},{"question":"def monitor_employee_logs(n, logs): A company wants to implement a system to monitor its employees' check-in and check-out times to ensure compliance with working hours. Each employee logs their times using unique identification numbers. You need to provide functionality for logging, querying, and calculating total hours worked. Functionality: 1. \`LOG_IN employee_id time\` - Log an employee's check-in time. 2. \`LOG_OUT employee_id time\` - Log an employee's check-out time. 3. \`QUERY employee_id day\` - Calculate and return the total hours worked by the employee on a specific day. Constraints: - A single employee can check-in and check-out multiple times within a day. - All times are given in minutes since midnight. - Days are integer values representing consecutive days starting from 0. - Employee IDs are unique positive integers. - If there are no check-in or check-out entries for the given employee on the specified day, return 0. Input: - n: the number of log entries (int) - logs: a list of n strings each representing a log entry, in one of the following formats: - LOG_IN employee_id day time - LOG_OUT employee_id day time - QUERY employee_id day Output: For each \`QUERY\` line in the input, return the total number of minutes worked by the specified employee on the specified day. >>> monitor_employee_logs(8, [\\"LOG_IN 101 0 540\\", \\"LOG_OUT 101 0 600\\", \\"LOG_IN 101 0 660\\", \\"LOG_OUT 101 0 720\\", \\"QUERY 101 0\\", \\"LOG_IN 102 1 480\\", \\"LOG_OUT 102 1 1020\\", \\"QUERY 102 1\\"]) [120, 540] from collections import defaultdict def test_monitor_employee_logs(): n = 8 logs = [ \\"LOG_IN 101 0 540\\", \\"LOG_OUT 101 0 600\\", \\"LOG_IN 101 0 660\\", \\"LOG_OUT 101 0 720\\", \\"QUERY 101 0\\", \\"LOG_IN 102 1 480\\", \\"LOG_OUT 102 1 1020\\", \\"QUERY 102 1\\" ] assert monitor_employee_logs(n, logs) == [120, 540] def test_multiple_check_in_out(): n = 10 logs = [ \\"LOG_IN 101 0 540\\", \\"LOG_OUT 101 0 600\\", \\"LOG_IN 101 0 660\\", \\"LOG_OUT 101 0 720\\", \\"LOG_IN 102 1 480\\", \\"LOG_OUT 102 1 600\\", \\"LOG_IN 102 1 630\\", \\"LOG_OUT 102 1 1020\\", \\"QUERY 101 0\\", \\"QUERY 102 1\\" ] assert monitor_employee_logs(n, logs) == [120, 510] def test_no_check_in(): n = 4 logs = [ \\"LOG_IN 101 0 540\\", \\"LOG_OUT 101 0 600\\", \\"QUERY 101 1\\", \\"QUERY 102 0\\" ] assert monitor_employee_logs(n, logs) == [0, 0] def test_partial_logs(): n = 6 logs = [ \\"LOG_IN 101 0 540\\", \\"LOG_OUT 101 0 600\\", \\"LOG_IN 101 1 620\\", \\"QUERY 101 1\\", \\"LOG_IN 102 1 480\\", \\"QUERY 102 1\\" ] assert monitor_employee_logs(n, logs) == [0, 0] def test_no_logs(): n = 2 logs = [ \\"QUERY 101 0\\", \\"QUERY 102 1\\" ] assert monitor_employee_logs(n, logs) == [0, 0]","solution":"def monitor_employee_logs(n, logs): from collections import defaultdict check_in_data = defaultdict(lambda: defaultdict(list)) check_out_data = defaultdict(lambda: defaultdict(list)) results = [] for log in logs: parts = log.split() action, emp_id, day = parts[0], int(parts[1]), int(parts[2]) if action == \\"LOG_IN\\": time = int(parts[3]) check_in_data[emp_id][day].append(time) elif action == \\"LOG_OUT\\": time = int(parts[3]) check_out_data[emp_id][day].append(time) elif action == \\"QUERY\\": total_minutes = 0 check_ins = check_in_data.get(emp_id, {}).get(day, []) check_outs = check_out_data.get(emp_id, {}).get(day, []) for in_time, out_time in zip(check_ins, check_outs): total_minutes += (out_time - in_time) results.append(total_minutes) return results"},{"question":"def min_operations_to_achieve_sum(n: int, s: int, sequence: List[int]) -> int: Given two positive integers N and S, find the minimum number of operations needed to make the sum of a given sequence of N integers equal to S. You can perform the following operations: 1. Add 1 to any element in the sequence. 2. Subtract 1 from any element in the sequence. If it is not possible to achieve the exact sum S, return -1. Args: n (int): The number of elements in the sequence. s (int): The target sum. sequence (List[int]): The list of integers. Returns: int: The minimum number of operations required, or -1 if it is impossible to achieve the exact sum S. >>> min_operations_to_achieve_sum(3, 15, [5, 5, 5]) 0 >>> min_operations_to_achieve_sum(3, 10, [1, 2, 3]) 4 >>> min_operations_to_achieve_sum(3, 0, [1, 1, 1]) 3 >>> min_operations_to_achieve_sum(4, 5000000, [250000, 250000, 250000, 250000]) 4000000 >>> min_operations_to_achieve_sum(3, 1000000000, [1, 2, 3]) -1","solution":"def min_operations_to_achieve_sum(n, s, sequence): current_sum = sum(sequence) # If the current sum is already equal to s, no operations needed if current_sum == s: return 0 # Calculate the difference we need to adjust difference = abs(current_sum - s) # If the difference is achievable with given constraints if difference <= n * 10**6: return difference return -1"},{"question":"def prime_factors_count(n): Returns the number of distinct prime factors of n. >>> prime_factors_count(10) == 2 >>> prime_factors_count(15) == 2 >>> prime_factors_count(21) == 2 >>> prime_factors_count(23) == 1 >>> prime_factors_count(35) == 2 >>> prime_factors_count(1) == 0 def satisfaction_scores(n, calorie_counts): Returns a list of satisfaction scores for each calorie count in calorie_counts. >>> satisfaction_scores(4, [10, 15, 21, 23]) == [2, 2, 2, 1] >>> satisfaction_scores(2, [35, 77]) == [2, 2] >>> satisfaction_scores(3, [8, 9, 49]) == [1, 1, 1] >>> satisfaction_scores(1, [1]) == [0]","solution":"def prime_factors_count(n): Returns the number of distinct prime factors of n. distinct_primes = set() factor = 2 while n % factor == 0: distinct_primes.add(factor) n //= factor factor = 3 while factor * factor <= n: while n % factor == 0: distinct_primes.add(factor) n //= factor factor += 2 if n > 1: distinct_primes.add(n) return len(distinct_primes) def satisfaction_scores(n, calorie_counts): Returns a list of satisfaction scores for each calorie count in calorie_counts. return [prime_factors_count(calories) for calories in calorie_counts] # Example usage: # n = 4 # calorie_counts = [10, 15, 21, 23] # print(satisfaction_scores(n, calorie_counts)) # Output: [2, 2, 2, 1]"},{"question":"def reverse_integer(n: int) -> int: Reverses the digits of an integer n. If the reversed integer exceeds the 32-bit signed integer range [-2^31, 2^31 - 1], returns 0. Examples: >>> reverse_integer(123) 321 >>> reverse_integer(-123) -321 >>> reverse_integer(120) 21 >>> reverse_integer(1534236469) 0 >>> reverse_integer(0) 0","solution":"def reverse_integer(n): Reverses the digits of an integer n. If the reversed integer exceeds the 32-bit signed integer range [-2^31, 2^31 - 1], returns 0. INT_MIN, INT_MAX = -2**31, 2**31 - 1 sign = -1 if n < 0 else 1 reversed_digits = int(str(abs(n))[::-1]) reversed_n = sign * reversed_digits if reversed_n < INT_MIN or reversed_n > INT_MAX: return 0 return reversed_n"},{"question":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def deleteNode(root, key): Delete the node with the given key from the BST and return the new root. >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> new_root = deleteNode(root, 3) >>> inorderTraversal(new_root) == [2, 4, 5, 6, 7, 8] True >>> root = TreeNode(5) >>> root.left = TreeNode(3) >>> root.right = TreeNode(7) >>> root.left.left = TreeNode(2) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(8) >>> new_root = deleteNode(root, 5) >>> inorderTraversal(new_root) == [2, 3, 4, 6, 7, 8] True pass def inorderTraversal(root): result = [] if root: result = inorderTraversal(root.left) result.append(root.val) result = result + inorderTraversal(root.right) return result","solution":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def deleteNode(root, key): if not root: return root if key < root.val: root.left = deleteNode(root.left, key) elif key > root.val: root.right = deleteNode(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left temp = minValueNode(root.right) root.val = temp.val root.right = deleteNode(root.right, temp.val) return root def minValueNode(node): current = node while current.left: current = current.left return current def inorderTraversal(root): result = [] if root: result = inorderTraversal(root.left) result.append(root.val) result = result + inorderTraversal(root.right) return result"},{"question":"def max_resources(n: int, resources: List[int]) -> int: Determine the maximum amount of resources Simon can collect in a single trip by visiting at most two consecutive locations. >>> max_resources(5, [4, 5, 6, 3, 2]) == 11 >>> max_resources(3, [10, 20, 30]) == 50 >>> max_resources(6, [1, 1, 1, 1, 1, 1]) == 2","solution":"def max_resources(n, resources): if n == 1: return resources[0] max_collectable = 0 for i in range(n-1): max_collectable = max(max_collectable, resources[i] + resources[i+1]) return max_collectable"},{"question":"def count_unique_tracks(t: int, tracks: List[str]) -> int: Counts the number of unique tracks based on anagram rule ignoring the underscores. Parameters: t (int): The number of tracks. tracks (list of str): List of track names. Returns: int: The number of unique tracks. >>> count_unique_tracks(5, [\\"abc_def\\", \\"ab_cdef\\", \\"cdef_ab\\", \\"g_hi\\", \\"hi_g\\"]) 2 >>> count_unique_tracks(1, [\\"abc_def\\"]) 1 >>> count_unique_tracks(3, [\\"abc_def\\", \\"ghi_jk\\", \\"lmnop\\"]) 3 >>> count_unique_tracks(4, [\\"abc_def\\", \\"ab_cdef\\", \\"cdef_ab\\", \\"a_bcdef\\"]) 1 >>> count_unique_tracks(5, [\\"abc_def\\", \\"ab_cdef\\", \\"cdef_ab\\", \\"g_hi\\", \\"hi_g\\"]) 2 >>> count_unique_tracks(3, [\\"_\\", \\"_\\", \\"_\\"]) 1 >>> count_unique_tracks(6, [\\"abc_def\\", \\"ghi_jk_pl\\", \\"klmnop\\", \\"ponml_k\\", \\"g_hi\\", \\"hi_g\\"]) 4","solution":"def count_unique_tracks(t, tracks): Counts the number of unique tracks based on anagram rule ignoring the underscores. Parameters: t (int): The number of tracks. tracks (list of str): List of track names. Returns: int: The number of unique tracks. unique_tracks = set() for track in tracks: cleaned_track = track.replace('_', '') sorted_track = ''.join(sorted(cleaned_track)) unique_tracks.add(sorted_track) return len(unique_tracks)"},{"question":"def can_partition(nums): Given a list of integers, determine if the list can be divided into two subsets such that the sum of the elements in both subsets is the same. >>> can_partition([1, 5, 11, 5]) \\"YES\\" >>> can_partition([1, 3, 5]) \\"NO\\" >>> can_partition([1, 2, 3, 5]) \\"NO\\" >>> can_partition([1]) \\"NO\\" >>> can_partition([2]) \\"NO\\" >>> can_partition([1, 1]) \\"YES\\" >>> can_partition([2, 2]) \\"YES\\" >>> can_partition([1, 2]) \\"NO\\" >>> can_partition([5, 3]) \\"NO\\" def process_partitions(test_cases): Processes multiple test cases and determine for each if the list can be divided into two subsets with equal sum. >>> process_partitions([[4, 1, 5, 11, 5], [3, 1, 3, 5], [4, 1, 2, 3, 5], [0]]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_partition(nums): Given a list of integers, determine if the list can be divided into two subsets such that the sum of the elements in both subsets is the same. total_sum = sum(nums) # If the total sum is odd, it's not possible to partition into two equal subsets if total_sum % 2 != 0: return \\"NO\\" # We now need to find if there's a subset with sum equal to total_sum / 2 target = total_sum // 2 n = len(nums) # Initialize a DP array where dp[i] will be True if a subset sum of i can be achieved dp = [False] * (target + 1) dp[0] = True for num in nums: for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return \\"YES\\" if dp[target] else \\"NO\\" def process_partitions(test_cases): Processes multiple test cases and determine for each if the list can be divided into two subsets with equal sum. results = [] for case in test_cases: if case[0] == 0: continue nums = case[1:] results.append(can_partition(nums)) return results"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Determines if a given string is a palindrome. Alphanumeric characters are considered, case-insensitive. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"Not a palindrome\\") False pass def check_palindromes(test_cases: List[str]) -> List[str]: For each test case, determines if the string is a palindrome and returns \\"YES\\" or \\"NO\\". >>> check_palindromes([ ... \\"A man, a plan, a canal: Panama\\", ... \\"race a car\\", ... \\"No lemon, no melon\\", ... \\"12321\\" ... ]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> check_palindromes([ ... \\"Civic\\", ... \\"Level\\", ... \\"rotor\\", ... \\"1001\\" ... ]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> check_palindromes([ ... \\"hello\\", ... \\"world\\", ... \\"Python\\", ... \\"Madam\\" ... ]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] pass","solution":"import re def is_palindrome(s): Determines if a given string is a palindrome. Alphanumeric characters are considered, case-insensitive. # Strip non-alphanumeric characters and convert to lower case cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if cleaned string is a palindrome return cleaned_string == cleaned_string[::-1] def check_palindromes(test_cases): For each test case, determines if the string is a palindrome and returns \\"YES\\" or \\"NO\\". results = [] for case in test_cases: if is_palindrome(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def detect_duplicates(P: List[int]) -> List[int]: Detect duplicated postal codes and return a list of them, sorted in ascending order. Parameters: P (list of int): List of postal codes. Returns: list of int: Sorted list of duplicated postal codes. If no duplicates, returns an empty list. pass # Tests def test_detect_duplicates_no_duplicates(): assert detect_duplicates([9876, 5432, 6781]) == [] def test_detect_duplicates_with_duplicates(): assert detect_duplicates([1234, 5678, 1234, 6789, 2345, 6789]) == [1234, 6789] def test_detect_duplicates_all_unique(): assert detect_duplicates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [] def test_detect_duplicates_all_duplicate(): assert detect_duplicates([1111, 1111, 1111, 1111]) == [1111] def test_detect_duplicates_mixed_duplicates(): assert detect_duplicates([1000, 2000, 3000, 3000, 2000, 4000, 1000]) == [1000, 2000, 3000]","solution":"def detect_duplicates(P): Detects duplicated postal codes and returns them sorted in ascending order. Parameters: P (list of int): List of postal codes. Returns: list of int: Sorted list of duplicated postal codes. If no duplicates, returns an empty list. from collections import Counter counts = Counter(P) duplicates = [code for code, count in counts.items() if count > 1] return sorted(duplicates)"},{"question":"def modify_array(arr): Modifies the array by performing the following steps: 1. Remove all negative numbers. 2. Square each of the remaining numbers. 3. Sort the resulting array in non-decreasing order. Args: arr (list): A list of integers. Returns: list: The modified array. Examples: >>> modify_array([-3, -1, 0, 2, 4, -2, 3]) [0, 4, 9, 16] >>> modify_array([2, -3, 1]) [1, 4]","solution":"def modify_array(arr): Modifies the array by performing the following steps: 1. Remove all negative numbers. 2. Square each of the remaining numbers. 3. Sort the resulting array in non-decreasing order. Args: arr (list): A list of integers. Returns: list: The modified array. filtered_arr = [x for x in arr if x >= 0] squared_arr = [x ** 2 for x in filtered_arr] sorted_arr = sorted(squared_arr) return sorted_arr"},{"question":"def count_valid_sequences(N: int) -> int: Count the number of valid sequences of length from 2 to N inclusive, which contain exactly one \\"ab\\" substring. >>> count_valid_sequences(2) 1 >>> count_valid_sequences(3) 3 >>> count_valid_sequences(4) 7 >>> count_valid_sequences(10) 511 >>> count_valid_sequences(5) 15","solution":"def count_valid_sequences(N): Count the number of valid sequences of length from 2 to N inclusive, which contain exactly one \\"ab\\" substring. Parameters: N (int): The maximum length of the sequences. Returns: int: The total number of valid sequences. if N < 2: return 0 # For each length from 2 to N: count = 0 for length in range(2, N + 1): # Calculate the count for each position of \\"ab\\" count += 2 ** (length - 2) return count"},{"question":"def closest_palindromic_number(n: int) -> int: Returns the closest palindromic number to the given integer n. If there are multiple solutions, the smaller one is returned. >>> closest_palindromic_number(123) 121 >>> closest_palindromic_number(132) 131","solution":"def closest_palindromic_number(n): Returns the closest palindromic number to the given integer n. If there are multiple solutions, the smaller one is returned. def is_palindrome(x): s = str(x) return s == s[::-1] if is_palindrome(n): return n lower_palindrome = n - 1 while not is_palindrome(lower_palindrome): lower_palindrome -= 1 upper_palindrome = n + 1 while not is_palindrome(upper_palindrome): upper_palindrome += 1 if (n - lower_palindrome) <= (upper_palindrome - n): return lower_palindrome else: return upper_palindrome"},{"question":"def min_operations_to_balance_parentheses(s: str) -> int: Determines the minimum number of operations needed to make the string completely balanced. >>> min_operations_to_balance_parentheses(\\"())(\\") == 1 >>> min_operations_to_balance_parentheses(\\")(\\") == 1 >>> min_operations_to_balance_parentheses(\\"((()))\\") == 0","solution":"def min_operations_to_balance_parentheses(s): Determines the minimum number of operations needed to make the string completely balanced. left_count = 0 right_count = 0 for char in s: if char == '(': left_count += 1 else: if left_count > 0: left_count -= 1 else: right_count += 1 return max(left_count, right_count)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def removeKthFromEnd(head, k): Removes the k-th node from the end of the list and returns the head of the modified linked list. If the k-th node from the end does not exist, returns the original linked list. >>> head = array_to_list([1, 2, 3, 4, 5]) >>> k = 2 >>> list_to_array(removeKthFromEnd(head, k)) == [1, 2, 3, 5] True >>> head = array_to_list([1, 2, 3]) >>> k = 4 >>> list_to_array(removeKthFromEnd(head, k)) == [1, 2, 3] True pass def list_to_array(head): Helper function to convert linked list to Python list for easy comparison pass def array_to_list(array): Helper function to convert Python list to linked list for test setup pass","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def removeKthFromEnd(head, k): Removes the k-th node from the end of the list and returns the head of the modified linked list. If the k-th node from the end does not exist, returns the original linked list. :param head: ListNode, the head of the linked list :param k: int, the position from the end to remove :return: ListNode, the head of the modified linked list dummy = ListNode(0) dummy.next = head first = dummy second = dummy # Move the first pointer so that the gap between first and second is k nodes apart for _ in range(k + 1): if not first: # If k is larger than the number of nodes return head first = first.next # Move both pointers until first reaches the end while first: first = first.next second = second.next # Second will be pointing to the node before the k-th from the end second.next = second.next.next return dummy.next"},{"question":"def sum_of_unique_elements(n, m, matrix): Returns the sum of all unique elements in the matrix. >>> sum_of_unique_elements(3, 3, [ ... [1, 2, 3], ... [2, 1, 4], ... [5, 6, 1] ... ]) 18 >>> sum_of_unique_elements(2, 2, [ ... [1, 1], ... [1, 1] ... ]) 0 >>> sum_of_unique_elements(2, 2, [ ... [1, 2], ... [3, 4] ... ]) 10 >>> sum_of_unique_elements(2, 3, [ ... [1, 2, 2], ... [3, 4, 1] ... ]) 7 >>> sum_of_unique_elements(1, 1, [ ... [10] ... ]) 10","solution":"def sum_of_unique_elements(n, m, matrix): Returns the sum of all unique elements in the matrix. from collections import Counter # Flatten the matrix and create a counter for elements elements = [item for sublist in matrix for item in sublist] element_count = Counter(elements) # Sum elements that appear exactly once unique_sum = sum(num for num, count in element_count.items() if count == 1) return unique_sum"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a valid palindrome considering only alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"Z\\") True >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"Madam, In Eden, I'm Adam\\") True >>> is_palindrome(\\"!!!@@@#\\") True","solution":"def is_palindrome(s): Determine if a given string is a valid palindrome considering only alphanumeric characters and ignoring cases. Parameters: s (str): The input string. Returns: bool: True if the input string is a valid palindrome, False otherwise. left, right = 0, len(s) - 1 while left < right: # Move the left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move the right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"def maxProfit(arr): Given an integer array \`arr\` representing the stock price on each day, finds the maximum profit by finding pairs of buying and selling days. The restriction is that you cannot engage in multiple buy-sell transactions simultaneously; you must sell the stock before you buy again. :param arr: List[int] - list of daily stock prices :return: int - maximum profit >>> maxProfit([7, 1, 5, 3, 6, 4]) 7 >>> maxProfit([7, 6, 4, 3, 1]) 0 >>> maxProfit([1, 2]) 1","solution":"def maxProfit(arr): Calculates the maximum profit achievable by buying and selling stocks on given days. :param arr: List[int] - list of daily stock prices :return: int - maximum profit n = len(arr) if n <= 1: return 0 max_profit = 0 for i in range(1, n): if arr[i] > arr[i - 1]: max_profit += arr[i] - arr[i - 1] return max_profit"},{"question":"def inventory_management(n, updates): Manage the inventory for a retail store's sections and products. Args: n (int): The number of update notices. updates (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers s, p, and c representing an update notice. Returns: List[str]: A list of strings representing the current stock levels for each section. >>> inventory_management(4, [(1, 2, 15), (3, 1, 5), (2, 10, -3), (1, 5, 7)]) ['0 15 0 0 7 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 -3', '********************', '5 0 0 0 0 0 0 0 0 0'] >>> inventory_management(0, []) ['0 0 0 0 0 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 0'] >>> inventory_management(3, [(1, 2, 5), (1, 2, -3), (1, 2, 8)]) ['0 10 0 0 0 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 0'] >>> inventory_management(10, [(1, i, i * 2) for i in range(1, 11)]) ['2 4 6 8 10 12 14 16 18 20', '********************', '0 0 0 0 0 0 0 0 0 0', '********************', '0 0 0 0 0 0 0 0 0 0']","solution":"def inventory_management(n, updates): # Dictionary to keep track of stock levels for each section inventory = {section: [0] * 10 for section in range(1, 4)} # Process each update for s, p, c in updates: inventory[s][p - 1] += c # Create the result result = [] for section in range(1, 4): result.append(' '.join(map(str, inventory[section]))) if section < 3: result.append('*' * 20) return result"},{"question":"def has_passed_all_students(test_cases): Determines if all students in each test case have passed based on their scores. Each test case is a tuple (N, scores, P) where: - N is the number of students - scores is a list of integers representing the scores of the students - P is the minimum score required to pass Args: test_cases (List[Tuple[int, List[int], int]]): List of test cases Returns: List[str]: List of \\"PASS\\" or \\"FAIL\\" for each test case. pass def parse_input(input_str): Parse the input string to extract the test cases. The input string format is: - First line contains the integer T, the number of test cases. - Each test case consists of three lines: - First line contains the integer N, the number of students. - Second line contains N space-separated integers, the scores of the students. - Third line contains an integer P, the minimum score required to pass. Args: input_str (str): The input string Returns: List[Tuple[int, List[int], int]]: List of test cases pass # Example Test Cases def test_has_passed_all_students(): input_str = \\"2n3n55 65 75n50n4n90 40 60 80n50\\" test_cases = parse_input(input_str) assert has_passed_all_students(test_cases) == [\\"PASS\\", \\"FAIL\\"] def test_has_passed_all_students_edge_cases(): input_str = \\"2n5n100 100 100 100 100n100n3n99 99 99n100\\" test_cases = parse_input(input_str) assert has_passed_all_students(test_cases) == [\\"PASS\\", \\"FAIL\\"] def test_parse_input(): input_str = \\"1n3n70 80 90n70\\" expected_output = [(3, [70, 80, 90], 70)] assert parse_input(input_str) == expected_output def test_multiple_cases(): input_str = \\"3n2n10 15n5n1n100n100n4n10 15 20 25n20\\" test_cases = parse_input(input_str) assert has_passed_all_students(test_cases) == [\\"PASS\\", \\"PASS\\", \\"FAIL\\"]","solution":"def has_passed_all_students(test_cases): Determines if all students in each test case have passed based on their scores. results = [] for case in test_cases: N, scores, P = case if all(score >= P for score in scores): results.append(\\"PASS\\") else: results.append(\\"FAIL\\") return results def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_lines[index]) scores = list(map(int, input_lines[index+1].split())) P = int(input_lines[index+2]) test_cases.append((N, scores, P)) index += 3 return test_cases"},{"question":"def calculate_difference(arr): Returns the difference between the maximum and minimum values in the array. If the array is empty, returns 0. >>> calculate_difference([3, 7, 2, 5, 10]) 8 >>> calculate_difference([]) 0 >>> calculate_difference([-10, -4, 3, 7]) 17","solution":"def calculate_difference(arr): Returns the difference between the maximum and minimum values in the array. If the array is empty, returns 0. if not arr: return 0 return max(arr) - min(arr)"},{"question":"def minimal_attempts(m: int, Si: List[int], Ai: List[int], Mi: List[int], Ci: List[int]) -> int: Given the number of levels \`m\`, initial strength requirements \`Si\`, initial agility requirements \`Ai\`, number of monsters \`Mi\`, and number of coins \`Ci\` for each level, calculate the minimal number of attempts in the worst-case scenario to pass all levels. >>> minimal_attempts(2, [10, 15], [20, 25], [3, 2], [4, 5]) 5 >>> minimal_attempts(3, [10, 20, 30], [15, 25, 35], [5, 3, 6], [7, 8, 6]) 8","solution":"def minimal_attempts(m, Si, Ai, Mi, Ci): Given the number of levels \`m\`, initial strength requirements \`Si\`, initial agility requirements \`Ai\`, number of monsters \`Mi\`, and number of coins \`Ci\` for each level, calculate the minimal number of attempts in the worst-case scenario to pass all levels. max_attempts = 0 for i in range(m): # The minimal number of attempts required for a level in the worst case attempts = max(Mi[i], Ci[i]) max_attempts = max(max_attempts, attempts) return max_attempts"},{"question":"def find_unique_employees(employees): Returns a list of employee IDs who are the only ones in their department. >>> find_unique_employees([{\\"id\\": 1, \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"department\\": \\"HR\\"}, {\\"id\\": 4, \\"department\\": \\"Marketing\\"}, {\\"id\\": 5, \\"department\\": \\"Engineering\\"}, {\\"id\\": 6, \\"department\\": \\"Sales\\"}]) [4, 6] >>> find_unique_employees([{\\"id\\": 1, \\"department\\": \\"IT\\"}, {\\"id\\": 2, \\"department\\": \\"IT\\"}, {\\"id\\": 3, \\"department\\": \\"HR\\"}]) [3] >>> find_unique_employees([{\\"id\\": 1, \\"department\\": \\"Finance\\"}]) [1] def test_find_unique_employees_case1(): employees = [ {\\"id\\": 1, \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"department\\": \\"HR\\"}, {\\"id\\": 4, \\"department\\": \\"Marketing\\"}, {\\"id\\": 5, \\"department\\": \\"Engineering\\"}, {\\"id\\": 6, \\"department\\": \\"Sales\\"} ] assert find_unique_employees(employees) == [4, 6] def test_find_unique_employees_case2(): employees = [ {\\"id\\": 1, \\"department\\": \\"IT\\"}, {\\"id\\": 2, \\"department\\": \\"IT\\"}, {\\"id\\": 3, \\"department\\": \\"HR\\"} ] assert find_unique_employees(employees) == [3] def test_find_unique_employees_case3(): employees = [{\\"id\\": 1, \\"department\\": \\"Finance\\"}] assert find_unique_employees(employees) == [1] def test_find_unique_employees_empty(): employees = [] assert find_unique_employees(employees) == [] def test_find_unique_employees_no_uniques(): employees = [ {\\"id\\": 1, \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"department\\": \\"HR\\"}, {\\"id\\": 3, \\"department\\": \\"IT\\"}, {\\"id\\": 4, \\"department\\": \\"IT\\"} ] assert find_unique_employees(employees) == [] def test_find_unique_employees_all_unique(): employees = [ {\\"id\\": 1, \\"department\\": \\"HR\\"}, {\\"id\\": 2, \\"department\\": \\"Engineering\\"}, {\\"id\\": 3, \\"department\\": \\"Marketing\\"}, {\\"id\\": 4, \\"department\\": \\"Sales\\"} ] assert find_unique_employees(employees) == [1, 2, 3, 4]","solution":"def find_unique_employees(employees): Returns a list of employee IDs who are the only ones in their department. dept_count = {} for employee in employees: department = employee['department'] if department in dept_count: dept_count[department].append(employee['id']) else: dept_count[department] = [employee['id']] unique_employees = [] for ids in dept_count.values(): if len(ids) == 1: unique_employees.append(ids[0]) return unique_employees"},{"question":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. Parameters: nums (list): List of integers. target (int): Target sum to be achieved by adding two numbers from the list. Returns: list: Indices of the two numbers that add up to the target, or None if no such pair exists. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([1, 2, 3, 4], 10) None >>> two_sum([], 9) None >>> two_sum([3], 3) None >>> two_sum([2, 4, 6, 8, 10], 18) [3, 4] >>> two_sum([1, -2, 3, -4, 5], 1) [1, 2] >>> two_sum([-1, 1], 0) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. Parameters: nums (list): List of integers. target (int): Target sum to be achieved by adding two numbers from the list. Returns: list: Indices of the two numbers that add up to the target, or None if no such pair exists. if not nums or len(nums) < 2: return None num_to_index = {} for i, num in enumerate(nums): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return None"},{"question":"def num_decodings(s: str) -> int: Returns the number of ways to decode a given string s according to the mapping: 'A' -> 1, 'B' -> 2, ..., 'Z' -> 26. The answer should be provided modulo 10^9 + 7. Args: s: A string containing only digits. Returns: An integer representing the total number of ways the string can be decoded. >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"226\\") 3 if __name__ == \\"__main__\\": import doctest doctest.testmod() from solution import num_decodings def test_single_digit(): assert num_decodings(\\"1\\") == 1 assert num_decodings(\\"9\\") == 1 def test_leading_zero(): assert num_decodings(\\"0\\") == 0 assert num_decodings(\\"06\\") == 0 def test_multiple_ways(): assert num_decodings(\\"12\\") == 2 # \\"AB\\" (1 2) or \\"L\\" (12) assert num_decodings(\\"226\\") == 3 # \\"BBF\\" (2 2 6) or \\"BZ\\" (2 26) or \\"VF\\" (22 6) assert num_decodings(\\"11106\\") == 2 # \\"AAJF\\" (1 1 10 6) or \\"KJF\\" (11 10 6) def test_large_input(): assert num_decodings(\\"1111111111\\") == 89 # Fibonacci sequence application def test_max_length(): assert num_decodings(\\"1\\" * 1000) # only one continuous sequence of ones def test_mixed_valid_and_invalid(): assert num_decodings(\\"1001\\") == 0 # invalid sequences produce 0 way to decode","solution":"def num_decodings(s): Returns the number of ways to decode a given string s. MOD = 10**9 + 7 length = len(s) if length == 0: return 1 dp = [0] * (length + 1) dp[0] = 1 for i in range(1, length + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i > 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] dp[i] %= MOD return dp[length]"},{"question":"def find_treasure(n, query_function): Finds the position of the treasure in an n x n grid by making queries. Args: n (int): The size of the grid. query_function (function): A function that takes coordinates of the rectangular area and returns \\"Yes\\" or \\"No\\". Returns: (int, int): The coordinates of the treasure position. def test_find_treasure(): def mock_query_function_factory(treasure_r, treasure_c): def mock_query_function(x1, y1, x2, y2): if x1 <= treasure_r <= x2 and y1 <= treasure_c <= y2: return \\"Yes\\" return \\"No\\" return mock_query_function n = 5 # Case 1 treasure_r = 3 treasure_c = 4 query_function = mock_query_function_factory(treasure_r, treasure_c) assert find_treasure(n, query_function) == (treasure_r, treasure_c) # Case 2 treasure_r = 1 treasure_c = 1 query_function = mock_query_function_factory(treasure_r, treasure_c) assert find_treasure(n, query_function) == (treasure_r, treasure_c) # Case 3 treasure_r = 5 treasure_c = 5 query_function = mock_query_function_factory(treasure_r, treasure_c) assert find_treasure(n, query_function) == (treasure_r, treasure_c) # Case 4 treasure_r = 2 treasure_c = 3 query_function = mock_query_function_factory(treasure_r, treasure_c) assert find_treasure(n, query_function) == (treasure_r, treasure_c) def test_find_treasure_on_different_grid_sizes(): def mock_query_function_factory(treasure_r, treasure_c): def mock_query_function(x1, y1, x2, y2): if x1 <= treasure_r <= x2 and y1 <= treasure_c <= y2: return \\"Yes\\" return \\"No\\" return mock_query_function for n in [5, 10, 20, 50, 100]: treasure_r = n // 2 treasure_c = n // 2 query_function = mock_query_function_factory(treasure_r, treasure_c) assert find_treasure(n, query_function) == (treasure_r, treasure_c)","solution":"def find_treasure(n, query_function): Finds the position of the treasure in an n x n grid by making queries. Args: n (int): The size of the grid. query_function (function): A function that takes coordinates of the rectangular area and returns \\"Yes\\" or \\"No\\". Returns: (int, int): The coordinates of the treasure position. def query(x1, y1, x2, y2): return query_function(x1, y1, x2, y2) # Binary search on rows low_r, high_r = 1, n while low_r < high_r: mid_r = (low_r + high_r) // 2 response = query(low_r, 1, mid_r, n) if response == \\"Yes\\": high_r = mid_r # The treasure is in the upper part else: low_r = mid_r + 1 # The treasure is in the lower part treasure_r = low_r # Binary search on columns low_c, high_c = 1, n while low_c < high_c: mid_c = (low_c + high_c) // 2 response = query(1, low_c, n, mid_c) if response == \\"Yes\\": high_c = mid_c # The treasure is in the left part else: low_c = mid_c + 1 # The treasure is in the right part treasure_c = low_c return treasure_r, treasure_c"},{"question":"def make_unique_variables(variable_names: List[str]) -> List[str]: Generates a list of unique variable names by appending the smallest possible positive integer to duplicate names. Args: variable_names (List[str]): A list of initial variable names (1 ≤ len(variable_names) ≤ 10^5) with each string's length between 1 and 20 inclusive. Returns: List[str]: A list of strings with unique variable names. Examples: >>> make_unique_variables([\\"apple\\", \\"banana\\", \\"apple\\"]) [\\"apple\\", \\"banana\\", \\"apple1\\"] >>> make_unique_variables([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"apple\\"]) [\\"apple\\", \\"banana\\", \\"apple1\\", \\"orange\\", \\"banana1\\", \\"apple2\\"] >>> make_unique_variables([\\"apple\\", \\"apple\\", \\"apple\\", \\"apple\\"]) [\\"apple\\", \\"apple1\\", \\"apple2\\", \\"apple3\\"] from solution import make_unique_variables def test_single_occurrences(): assert make_unique_variables([\\"apple\\", \\"banana\\", \\"cherry\\"]) == [\\"apple\\", \\"banana\\", \\"cherry\\"] def test_double_occurrences(): assert make_unique_variables([\\"apple\\", \\"banana\\", \\"apple\\"]) == [\\"apple\\", \\"banana\\", \\"apple1\\"] def test_multiple_occurrences(): assert make_unique_variables([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"apple\\"]) == [\\"apple\\", \\"banana\\", \\"apple1\\", \\"banana1\\", \\"apple2\\"] def test_continuous_incrementing(): assert make_unique_variables([\\"apple\\", \\"apple\\", \\"apple\\", \\"apple\\"]) == [\\"apple\\", \\"apple1\\", \\"apple2\\", \\"apple3\\"] def test_interleaved_names(): assert make_unique_variables([\\"apple\\", \\"banana\\", \\"apple\\", \\"banana\\", \\"cherry\\", \\"apple\\", \\"banana\\"]) == [\\"apple\\", \\"banana\\", \\"apple1\\", \\"banana1\\", \\"cherry\\", \\"apple2\\", \\"banana2\\"] def test_empty_list(): assert make_unique_variables([]) == [] def test_large_input(): input_vars = [\\"var\\"] * 10000 expected_output = [\\"var\\" + (str(i) if i > 0 else \\"\\") for i in range(10000)] assert make_unique_variables(input_vars) == expected_output","solution":"from typing import List def make_unique_variables(variable_names: List[str]) -> List[str]: Generates a list of unique variable names by appending the smallest possible positive integer to duplicate names. name_count = {} unique_names = [] for name in variable_names: if name not in name_count: unique_names.append(name) name_count[name] = 1 else: new_name = f\\"{name}{name_count[name]}\\" while new_name in name_count: name_count[name] += 1 new_name = f\\"{name}{name_count[name]}\\" unique_names.append(new_name) name_count[new_name] = 1 name_count[name] += 1 return unique_names"},{"question":"def knight_moves(position: str) -> list[str]: Given the position of a knight on the chessboard, return all possible moves it can make from that position. :param position: A string representing the knight's position in standard algebraic notation (e.g., 'e4') :return: A list of strings, each representing a valid move the knight can make >>> set(knight_moves('d4')) == {'b5', 'b3', 'c6', 'c2', 'e6', 'e2', 'f5', 'f3'} True >>> set(knight_moves('g1')) == {'h3', 'e2', 'f3'} True >>> set(knight_moves('a1')) == {'b3', 'c2'} True >>> set(knight_moves('h8')) == {'f7', 'g6'} True >>> set(knight_moves('h1')) == {'f2', 'g3'} True >>> set(knight_moves('a8')) == {'b6', 'c7'} True","solution":"def knight_moves(position): Given the position of a knight on the chessboard, return all possible moves it can make from that position. :param position: A string representing the knight's position in standard algebraic notation (e.g., 'e4') :return: A list of strings, each representing a valid move the knight can make # Mapping of file to column index file_to_col = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8} col_to_file = {v: k for k, v in file_to_col.items()} # Mapping of rank to row index row_to_rank = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8} rank_to_row = {v: k for k, v in row_to_rank.items()} # Knight's move set knight_movesets = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2), ] file, rank = position[0], position[1] current_col, current_row = file_to_col[file], row_to_rank[rank] possible_positions = [] for move in knight_movesets: new_col, new_row = current_col + move[0], current_row + move[1] if 1 <= new_col <= 8 and 1 <= new_row <= 8: new_position = col_to_file[new_col] + rank_to_row[new_row] possible_positions.append(new_position) return possible_positions"},{"question":"def find_subarray_sums(N: int, K: int, arr: List[int]) -> List[int]: Given an array of N integers, find the sum of each subarray of length K. Parameters: - N: The length of the array - K: The length of each subarray - arr: A list of integers representing the array Returns: A list of sums of all subarrays of length K >>> find_subarray_sums(8, 3, [1, 2, 3, 4, 5, 6, 7, 8]) [6, 9, 12, 15, 18, 21] >>> find_subarray_sums(5, 1, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> find_subarray_sums(5, 5, [1, 2, 3, 4, 5]) [15] >>> find_subarray_sums(0, 3, []) [] >>> find_subarray_sums(5, 6, [1, 2, 3, 4, 5]) [] >>> find_subarray_sums(5, 2, [0, 0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def find_subarray_sums(N, K, arr): Given an array of N integers, find the sum of each subarray of length K. Parameters: - N: The length of the array - K: The length of each subarray - arr: A list of integers representing the array Returns: A list of sums of all subarrays of length K if K > N or K <= 0: return [] # Calculate the sum of the first subarray of length K subarray_sum = sum(arr[:K]) sums = [subarray_sum] # Use a sliding window approach to calculate the sums for subsequent subarrays for i in range(1, N - K + 1): subarray_sum = subarray_sum - arr[i - 1] + arr[i + K - 1] sums.append(subarray_sum) return sums"},{"question":"def traffic_light_sequence(tests): Determine the state of the traffic lights after K iterations for each of the test cases. Args: tests (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers S, B, and K. Returns: List[int]: A list containing the resulting state of the traffic lights for each test case. >>> traffic_light_sequence([(5, 3, 1)]) [6] >>> traffic_light_sequence([(2, 7, 4)]) [2] # Helper function to parse input and provide output def main(input_text): Parse input text, compute the result for each test case, and return the results. Args: input_text (str): The input text containing the number of test cases and the test cases themselves. Returns: List[int]: A list containing the result of each test case. >>> main(\\"2n5 3 1n2 7 4n\\") [6, 2] >>> main(\\"1n1 3 1000000000n\\") [1] import pytest def test_single_iteration(): assert traffic_light_sequence([(5, 3, 1)]) == [6] assert traffic_light_sequence([(2, 7, 1)]) == [5] def test_multiple_iterations(): assert traffic_light_sequence([(2, 7, 4)]) == [2] assert traffic_light_sequence([(1, 2, 3)]) == [3] def test_large_iterations(): assert traffic_light_sequence([(1, 3, 1000000000)]) == [1] # Even number of iterations def test_large_single_iteration(): assert traffic_light_sequence([(7, 4, 999999999)]) == [3] # Odd number of iterations def test_example_cases(): assert main(\\"2n5 3 1n2 7 4n\\") == [6, 2] def test_all_off(): assert traffic_light_sequence([(0, 7, 5)]) == [7] assert traffic_light_sequence([(0, 7, 6)]) == [0] def test_all_on(): assert traffic_light_sequence([(7, 0, 5)]) == [7] assert traffic_light_sequence([(7, 0, 4)]) == [7]","solution":"def traffic_light_sequence(tests): results = [] for S, B, K in tests: if K % 2 == 0: results.append(S) else: results.append(S ^ B) return results # Helper function to parse input and provide output def main(input_text): lines = input_text.strip().split(\\"n\\") T = int(lines[0]) tests = [tuple(map(int, line.split())) for line in lines[1:T+1]] result = traffic_light_sequence(tests) return result"},{"question":"def separate_cities(n: int, m: int, edges: List[Tuple[int, int]]) -> str: Given an undirected graph with n vertices and m edges, determine if you can separate the graph into two disjoint sets such that no two vertices in the same set are connected by an edge. Args: n (int): Number of vertices (cities). m (int): Number of edges (roads). edges (List[Tuple[int, int]]): List of tuples where each tuple represents an edge connecting two vertices. Returns: str: \\"YES\\" followed by the division of cities into two sets if possible, \\"NO\\" if not possible. Example: >>> separate_cities(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'YESn1 2 1 2' >>> separate_cities(3, 3, [(1, 2), (2, 3), (1, 3)]) 'NO'","solution":"from collections import deque def is_bipartite(n, edges): # Create an adjacency list adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) # Array to store the color of each vertex (0: not colored, 1: color 1, 2: color 2) color = [0] * (n + 1) # Function to perform BFS and check for bipartite def bfs(start): queue = deque([start]) color[start] = 1 # Start coloring the start vertex with color 1 while queue: node = queue.popleft() for neighbor in adj[node]: if color[neighbor] == 0: # If neighbor is not colored color[neighbor] = 3 - color[node] # Alternate color queue.append(neighbor) elif color[neighbor] == color[node]: # If neighbor is colored the same as current node return False return True # Check for each component in the graph for i in range(1, n + 1): if color[i] == 0: # Not colored yet if not bfs(i): return \\"NO\\", [] # Return the result return \\"YES\\", color[1:] def separate_cities(n, m, edges): result, sets = is_bipartite(n, edges) if result == \\"YES\\": return f\\"{result}n{' '.join(map(str, sets))}\\" else: return result"},{"question":"def maximize_empty_slots(n, m, k, positions): Given the current arrangement of books and the number of new books to place, find the optimal positions for the new books to maximize the empty slots between any two placed books. Args: n (int): The total number of positions on the shelf. m (int): The number of new books to place. k (int): The number of already placed books. positions (list): The positions of the books that are already placed in ascending order. Returns: list: The positions where the new books should be placed to maximize the empty slots. >>> maximize_empty_slots(5, 2, 2, [1, 5]) [2, 4] >>> maximize_empty_slots(7, 3, 3, [2, 4, 6]) [1, 3, 7]","solution":"def maximize_empty_slots(n, m, k, positions): This function will return m positions to place the new books such that the empty slots are maximized. all_positions = set(range(1, n+1)) occupied_positions = set(positions) available_positions = list(all_positions - occupied_positions) return sorted(available_positions[:m])"},{"question":"from typing import List def count_strings_with_all_vowels(strings: List[str]) -> int: Given a list of strings, returns the number of strings that contain all five vowels ('a', 'e', 'i', 'o', 'u') at least once. Args: strings (List[str]): A list of strings to be evaluated. Returns: int: The count of strings containing all five vowels. Examples: >>> count_strings_with_all_vowels(['education', 'umbrella', 'sequoia']) 2 >>> count_strings_with_all_vowels(['aeiou', 'aei', 'aeio', 'iou', 'aiou', 'aeiouiou']) 2","solution":"def count_strings_with_all_vowels(strings): Returns the number of strings in the list that contain all five vowels. vowels = {'a', 'e', 'i', 'o', 'u'} count = 0 for string in strings: if vowels.issubset(set(string)): count += 1 return count"},{"question":"def find_zero_sum_pairs(lst: List[int]) -> List[Tuple[int, int]]: Given a list of integers, returns all unique pairs of numbers that sum up to zero. Args: lst: list of integers Returns: list of tuples, where each tuple contains a pair of integers that sum up to zero. Examples: >>> find_zero_sum_pairs([3, -3, 4, -4, 2, -2, 5]) [(-3, 3), (-4, 4), (-2, 2)] >>> find_zero_sum_pairs([1, 2, 3, 4, 5]) []","solution":"def find_zero_sum_pairs(lst): Given a list of integers, returns all unique pairs of numbers that sum up to zero. Args: lst: list of integers Returns: list of tuples, where each tuple contains a pair of integers that sum up to zero. seen = set() pairs = set() for num in lst: if -num in seen: pairs.add((min(num, -num), max(num, -num))) seen.add(num) return list(pairs)"},{"question":"def reverse_string(s: str) -> str: Returns the reversed version of the input string 's'. >>> reverse_string(\\"hello\\") \\"olleh\\" >>> reverse_string(\\"world\\") \\"dlrow\\" >>> reverse_string(\\"!olleH\\") \\"Hello!\\" >>> reverse_string(\\"123#abc\\") \\"cba#321\\" >>> reverse_string(\\"\\") \\"\\" >>> reverse_string(\\"a\\") \\"a\\" >>> reverse_string(\\"1\\") \\"1\\" >>> reverse_string(\\"madam\\") \\"madam\\" >>> reverse_string(\\"hello world\\") \\"dlrow olleh\\" >>> reverse_string(\\" spaces \\") \\" secaps \\"","solution":"def reverse_string(s): Returns the reversed version of the input string 's'. reversed_string = \\"\\" for char in s: reversed_string = char + reversed_string return reversed_string"},{"question":"def count_problems_in_range(T, difficulties, L, R): Given the number of problems, their difficulties, and a range [L, R], this function returns the count of problems that fall within the given range. Args: T (int): Number of problems. difficulties (list of int): List of difficulty levels of each problem. L (int): Lower bound of the desired difficulty range. R (int): Upper bound of the desired difficulty range. Returns: int: Count of problems within the difficulty range. >>> count_problems_in_range(5, [1, 5, 10, 20, 30], 10, 20) 2 >>> count_problems_in_range(3, [10, 12, 15], 10, 20) 3 >>> count_problems_in_range(4, [5, 8, 9, 11], 20, 30) 0 >>> count_problems_in_range(6, [1, 3, 6, 10, 15, 20], 15, 15) 1 >>> count_problems_in_range(5, [5, 5, 5, 5, 5], 5, 5) 5 pass import unittest class TestCountProblemsInRange(unittest.TestCase): def test_sample_input_1(self): result = count_problems_in_range(5, [1, 5, 10, 20, 30], 10, 20) self.assertEqual(result, 2) def test_all_problems_within_range(self): result = count_problems_in_range(3, [10, 12, 15], 10, 20) self.assertEqual(result, 3) def test_no_problems_within_range(self): result = count_problems_in_range(4, [5, 8, 9, 11], 20, 30) self.assertEqual(result, 0) def test_single_problem_within_range(self): result = count_problems_in_range(6, [1, 3, 6, 10, 15, 20], 15, 15) self.assertEqual(result, 1) def test_multiple_problems_with_same_difficulty(self): result = count_problems_in_range(5, [5, 5, 5, 5, 5], 5, 5) self.assertEqual(result, 5)","solution":"def count_problems_in_range(T, difficulties, L, R): Returns the count of problems with difficulty within the range [L, R]. Args: T (int): Number of problems. difficulties (list of int): List of difficulty levels of each problem. L (int): Lower bound of the desired difficulty range. R (int): Upper bound of the desired difficulty range. Returns: int: Count of problems within the difficulty range. count = 0 for difficulty in difficulties: if L <= difficulty <= R: count += 1 return count"},{"question":"from typing import List def longest_mountain(arr: List[int]) -> int: Determine the length of the longest mountain in an array of positive integers. A mountain is defined as a sequence of positive integers such that there exists an index 'i' where: 1. The elements from the start up to 'i' are strictly increasing. 2. The elements from 'i' to the end are strictly decreasing. If there is no mountain, return 0. Args: arr (List[int]): List of positive integers. Returns: int: Length of the longest mountain. >>> longest_mountain([2, 1, 4, 7, 3, 2, 5, 5, 4, 3, 2, 1]) 5 >>> longest_mountain([2, 1, 4, 7]) 0 >>> longest_mountain([0, 2, 2, 2, 2, 2, 2, 4]) 0 >>> longest_mountain([0, 1, 0]) 3","solution":"def longest_mountain(arr): n = len(arr) if n < 3: return 0 longest = 0 for i in range(1, n - 1): if arr[i - 1] < arr[i] > arr[i + 1]: left = i - 1 right = i + 1 while left > 0 and arr[left - 1] < arr[left]: left -= 1 while right < n - 1 and arr[right + 1] < arr[right]: right += 1 longest = max(longest, right - left + 1) return longest"},{"question":"def encrypt_string(shift: int, s: str) -> str: Encrypts the given string s by shifting each character by the shift value. >>> encrypt_string(3, \\"abcde\\") == \\"defgh\\" >>> encrypt_string(2, \\"xyz\\") == \\"zab\\" >>> encrypt_string(0, \\"hello\\") == \\"hello\\" >>> encrypt_string(25, \\"a\\") == \\"z\\" >>> encrypt_string(1, \\"z\\") == \\"a\\" def process_test_cases(n: int, test_cases: List[Tuple[int, str]]) -> List[str]: Processes multiple test cases. :param n: Number of test cases :param test_cases: List of tuples where each tuple contains (shift, string) :return: List of encrypted strings >>> test_cases = [(3, \\"abcde\\"), (2, \\"xyz\\")] >>> process_test_cases(2, test_cases) == [\\"defgh\\", \\"zab\\"] >>> test_cases = [(0, \\"abc\\"), (25, \\"hello\\"), (1, \\"z\\")] >>> process_test_cases(3, test_cases) == [\\"abc\\", \\"gdkkn\\", \\"a\\"] >>> test_cases = [(4, \\"a\\"), (10, \\"hello\\")] >>> process_test_cases(2, test_cases) == [\\"e\\", \\"rovvy\\"] >>> test_cases = [(0, \\"\\"), (1, \\"\\")] >>> process_test_cases(2, test_cases) == [\\"\\", \\"\\"]","solution":"def encrypt_string(shift, s): Encrypts the given string s by shifting each character by the shift value. encrypted = [] for char in s: new_char = chr(((ord(char) - ord('a') + shift) % 26) + ord('a')) encrypted.append(new_char) return ''.join(encrypted) def process_test_cases(n, test_cases): Processes multiple test cases. :param n: Number of test cases :param test_cases: List of tuples where each tuple contains (shift, string) :return: List of encrypted strings results = [] for shift, s in test_cases: results.append(encrypt_string(shift, s)) return results"},{"question":"from collections import Counter def can_form_palindrome(s: str) -> bool: Check if it is possible to rearrange the string s into a palindrome. count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) # A palindrome can have at most one character with an odd count return odd_count <= 1 def rearrange_to_palindrome(s: str) -> str: Rearrange a string into a palindrome by making the minimum number of swaps if possible. Otherwise, return \\"IMPOSSIBLE\\". >>> rearrange_to_palindrome(\\"aabb\\") in {\\"abba\\", \\"baab\\"} True >>> rearrange_to_palindrome(\\"abc\\") 'IMPOSSIBLE' pass","solution":"from collections import Counter def can_form_palindrome(s): Check if it is possible to rearrange the string s into a palindrome. count = Counter(s) odd_count = sum(1 for val in count.values() if val % 2 != 0) # A palindrome can have at most one character with an odd count return odd_count <= 1 def rearrange_to_palindrome(s): if not can_form_palindrome(s): return \\"IMPOSSIBLE\\" count = Counter(s) left_half = [] middle_char = [] for char, freq in count.items(): half_freq = freq // 2 left_half.extend([char] * half_freq) if freq % 2 != 0: middle_char.append(char) left_half_str = ''.join(left_half) right_half_str = left_half_str[::-1] middle_str = ''.join(middle_char) return left_half_str + middle_str + right_half_str"},{"question":"import re from typing import Tuple def text_analyzer(input_str: str) -> Tuple[int, int, int]: Analyzes a string in SimpleML and counts the number of headers, paragraphs, and links. Parameters: input_str (str): The input string in SimpleML. Returns: tuple: A tuple containing three integer values - number of headers, number of paragraphs, and number of links. # Your code here to process the input_str and count headers, paragraphs, and links. # Example usage and test cases def test_text_analyzer(): assert text_analyzer(\\"#Header 1nThis is a paragraph.nn#Header 2nAnother paragraph with a [link](http://example.com) in it.\\") == (2, 2, 1) assert text_analyzer(\\"#Header 1nnnnThis is a paragraph with a [link](http://example.com) and another [link](http://example2.com).n#Header 2nAnother paragraph.n\\") == (2, 2, 2) assert text_analyzer(\\"Lonely paragraph with [link](http://example.com) as the only content.\\") == (0, 1, 1) assert text_analyzer(\\"#Header 1n\\") == (1, 0, 0) assert text_analyzer(\\"#Header 1nnThis is a paragraph with no link.nAnother line of the same paragraph.n\\") == (1, 1, 0) assert text_analyzer(\\"\\") == (0, 0, 0)","solution":"import re def text_analyzer(input_str): Analyzes a string in SimpleML and counts the number of headers, paragraphs, and links. Parameters: input_str (str): The input string in SimpleML. Returns: tuple: A tuple containing three integer values - number of headers, number of paragraphs, and number of links. headers_count = 0 paragraphs_count = 0 links_count = 0 # Split input string by newlines lines = input_str.split('n') # State variables for paragraph detection in_paragraph = False for line in lines: line = line.strip() # Check for header if line.startswith('#'): headers_count += 1 in_paragraph = False else: # Check for links links_count += len(re.findall(r'[.*?](.*?)', line)) # Identify paragraph blocks if line: if not in_paragraph: paragraphs_count += 1 in_paragraph = True else: in_paragraph = False return headers_count, paragraphs_count, links_count"},{"question":"def is_peak_sequence(sequence: List[int]) -> str: Determines if a given sequence is a peak sequence. A sequence is a peak sequence if it strictly increases to a single maximal element and then strictly decreases. >>> is_peak_sequence([1, 3, 5, 4, 2]) 'YES' >>> is_peak_sequence([2, 3, 3, 2]) 'NO' >>> is_peak_sequence([1, 2, 3, 4, 5, 6]) 'NO' >>> is_peak_sequence([1, 3, 2]) 'YES' >>> is_peak_sequence([1, 2, 1, 1]) 'NO' pass def process_test_cases(n: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases to determine if sequences are peak sequences. >>> test_input = (3, [(5, [1, 3, 5, 4, 2]), (4, [2, 3, 3, 2]), (6, [1, 2, 3, 4, 5, 6])]) >>> process_test_cases(*test_input) ['YES', 'NO', 'NO'] pass","solution":"def is_peak_sequence(sequence): Determines if a given sequence is a peak sequence. A sequence is a peak sequence if it strictly increases to a single maximal element and then strictly decreases. Args: sequence (list of int): The sequence of integers to check. Returns: str: \\"YES\\" if the given sequence is a peak sequence, otherwise \\"NO\\". n = len(sequence) if n < 3: return \\"NO\\" peak_found = False increasing = True for i in range(1, n): if increasing: if sequence[i] < sequence[i-1]: increasing = False peak_found = True elif sequence[i] == sequence[i-1]: return \\"NO\\" if not increasing: if sequence[i] >= sequence[i-1]: return \\"NO\\" if peak_found: return \\"YES\\" return \\"NO\\" def process_test_cases(n, test_cases): results = [] for m, sequence in test_cases: results.append(is_peak_sequence(sequence)) return results"},{"question":"def is_valid_matrix(n: int, k: int, matrix: List[List[int]]) -> str: Determine if the given n x n matrix is valid. A matrix is valid if every row and every column contains exactly k different elements, with each element appearing exactly once per row and per column. >>> is_valid_matrix(4, 4, [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]]) 'YES' >>> is_valid_matrix(3, 3, [[1, 2, 3], [2, 3, 1], [3, 2, 1]]) 'NO' >>> is_valid_matrix(3, 3, [[1, 2, 3], [2, 3, 1], [3, 1, 2]]) 'YES' >>> is_valid_matrix(4, 4, [[1, 2, 3, 4], [2, 2, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]]) 'NO'","solution":"def is_valid_matrix(n, k, matrix): # Check each row for validity for row in matrix: if sorted(row) != list(range(1, k + 1)): return \\"NO\\" # Check each column for validity for col in range(n): column_elements = [matrix[row][col] for row in range(n)] if sorted(column_elements) != list(range(1, k + 1)): return \\"NO\\" return \\"YES\\""},{"question":"def min_baton_swaps(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of baton swaps required for each test case to make all batons the same type. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, each containing an integer N (the number of participants) and a string S of size N representing the initial types of batons held by participants, where each character is either 'R' or 'G'. Returns: A list of integers, each representing the minimum number of swaps for the corresponding test case. >>> min_baton_swaps(3, [(6, \\"RGRGRG\\"), (4, \\"GGGR\\"), (5, \\"RRRRR\\")]) [3, 1, 0] >>> min_baton_swaps(1, [(5, \\"RRRRR\\")]) [0] >>> min_baton_swaps(1, [(4, \\"RGRG\\")]) [2] >>> min_baton_swaps(1, [(1, \\"R\\")]) [0] >>> min_baton_swaps(1, [(1, \\"G\\")]) [0] >>> min_baton_swaps(1, [(100000, \\"R\\"*99999 + \\"G\\")]) [1]","solution":"def min_baton_swaps(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] S = test_cases[i][1] # Count occurrences of 'R' and 'G' count_R = S.count('R') count_G = S.count('G') # The minimum swaps needed is to turn all into R or all into G min_swaps = min(count_R, count_G) results.append(min_swaps) return results"},{"question":"def can_be_lexicographically_smallest(s: str) -> str: Determine if it is possible to transform the given string s into a lexicographically smallest possible permutation using allowed operations. Args: - s (str): The input string. Returns: - str: \\"YES\\" if the string can be transformed, \\"NO\\" otherwise. >>> can_be_lexicographically_smallest(\\"abba\\") \\"YES\\" >>> can_be_lexicographically_smallest(\\"abc\\") \\"YES\\" >>> can_be_lexicographically_smallest(\\"aabbcc\\") \\"YES\\" def process_test_cases(test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string can be transformed into its lexicographically smallest permutation. Args: - test_cases (List[str]): A list of test case strings. Returns: - List[str]: A list of results indicating \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases([\\"abba\\", \\"abc\\", \\"aabbcc\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] import pytest def test_palindromes(): assert can_be_lexicographically_smallest(\\"abba\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"aabbcc\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"racecar\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"madam\\") == \\"YES\\" def test_non_palindromes(): assert can_be_lexicographically_smallest(\\"abc\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"xyz\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"a\\") == \\"YES\\" assert can_be_lexicographically_smallest(\\"ba\\") == \\"YES\\" def test_mixed_cases(): test_cases = [ \\"abba\\", \\"abc\\", \\"aabbcc\\" ] assert process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_variety_cases(): test_cases = [ \\"aba\\", \\"aab\\", \\"abb\\", \\"ccc\\" ] assert process_test_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_be_lexicographically_smallest(s): Determines if a string can be transformed into its lexicographically smallest permutation by reversing its palindrome substrings. Args: - s (str): The input string. Returns: - str: \\"YES\\" if the string can be transformed, \\"NO\\" otherwise. # All strings can be transformed into lexicographically smallest strings. return \\"YES\\" def process_test_cases(test_cases): Processes multiple test cases. Args: - test_cases: List of test case strings Returns: - List: Result strings for each test case results = [] for s in test_cases: results.append(can_be_lexicographically_smallest(s)) return results"},{"question":"from typing import List def num_islands(grid: List[List[int]]) -> int: Count the number of islands in a grid where 1 represents land and 0 represents water. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Args: grid: List[List[int]]: A 2D list representing the grid. Returns: int: The number of islands in the grid. >>> num_islands([[1, 1, 1, 1, 0], ... [1, 1, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 0, 0]]) 1 >>> num_islands([[1, 1, 0, 0, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 1, 0, 0], ... [0, 0, 0, 1, 1]]) 3 >>> num_islands([[0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0], ... [0, 0, 0, 0]]) 0 >>> num_islands([[1, 1, 1], ... [1, 1, 1], ... [1, 1, 1]]) 1 >>> num_islands([[1, 0, 1, 0], ... [0, 1, 0, 1], ... [1, 0, 1, 0], ... [0, 1, 0, 1]]) 8","solution":"from typing import List def num_islands(grid: List[List[int]]) -> int: if not grid: return 0 n = len(grid) m = len(grid[0]) visited = [[False] * m for _ in range(n)] def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 0 or visited[x][y]: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: count += 1 dfs(i, j) return count"},{"question":"def longest_path(grid: List[str]) -> int: Find the longest path consisting only of power-ups ('P') in a given grid. A power-up is represented by a character 'P', an obstacle by a character 'X', and an empty cell by a character '.'. Example: >>> longest_path([\\"PXP.\\", \\"PXPX\\", \\"PPPP\\", \\".XXP\\"]) 7 >>> longest_path([\\"P.P.P\\", \\"XXXXX\\", \\"P.P.P\\"]) 1","solution":"def longest_path(grid): n = len(grid) m = len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 'P' def dfs(x, y, visited): max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) max_length = max(max_length, 1 + dfs(nx, ny, visited)) visited.remove((nx, ny)) return max_length longest = 0 for i in range(n): for j in range(m): if grid[i][j] == 'P': visited = set() visited.add((i, j)) longest = max(longest, dfs(i, j, visited)) return longest"},{"question":"from typing import List import itertools def string_permutations(s: str) -> List[str]: Generate all permutations of the input string in lexicographic order. >>> string_permutations(\\"abc\\") ['abc', 'acb', 'bac', 'bca', 'cab', 'cba'] >>> string_permutations(\\"dog\\") ['dgo', 'dog', 'gdo', 'god', 'odg', 'ogd'] >>> string_permutations(\\"a\\") ['a'] >>> string_permutations(\\"ab\\") ['ab', 'ba'] >>> string_permutations(\\"abcdef\\") ['abcdef', 'abcdeg', 'abcdgf', 'abcdfg', 'abcdga', 'abcdefgh'] pass","solution":"from itertools import permutations def string_permutations(s): Generate all permutations of the input string in lexicographic order. perm = sorted([''.join(p) for p in permutations(s)]) return perm"},{"question":"class Graph: A basic graph class that supports adding edges and counting disjoint connected components. Methods: - __init__(self): Initializes an empty graph. - add_edge(self, u, v): Adds an undirected edge between nodes \`u\` and \`v\`. - count_components(self): Returns the number of disjoint connected components in the graph. def __init__(self): Initializes an empty graph. pass def add_edge(self, u, v): Adds an undirected edge between nodes \`u\` and \`v\`. Args: u (int): One end of the undirected edge. v (int): The other end of the undirected edge. pass def count_components(self): Returns the number of disjoint connected components in the graph. Returns: int: The number of disjoint connected components. pass def test_add_edge_and_count_components(): g = Graph() assert g.count_components() == 0 # No nodes, no components g.add_edge(1, 2) assert g.count_components() == 1 # Single component: {1, 2} g.add_edge(2, 3) assert g.count_components() == 1 # Single component: {1, 2, 3} g.add_edge(4, 5) assert g.count_components() == 2 # Two components: {1, 2, 3} and {4, 5} def test_disjoint_comp_with_add_edge(): g = Graph() g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(4, 5) g.add_edge(6, 7) assert g.count_components() == 3 # Three components: {1, 2, 3}, {4, 5}, {6, 7} g.add_edge(3, 4) assert g.count_components() == 2 # Merged into two components: {1, 2, 3, 4, 5} and {6, 7} g.add_edge(7, 8) assert g.count_components() == 2 # Still two components: {1, 2, 3, 4, 5} and {6, 7, 8} def test_single_node_multiple_edges(): g = Graph() g.add_edge(1, 2) g.add_edge(1, 2) g.add_edge(1, 2) assert g.count_components() == 1 # Single component: {1, 2} def test_no_edges(): g = Graph() g.add_edge(1, 1) g.add_edge(2, 2) g.add_edge(3, 3) assert g.count_components() == 3 # Three isolated nodes, each forming a component: {1}, {2}, {3} def test_large_graph(): g = Graph() for i in range(1, 100): g.add_edge(i, i+1) assert g.count_components() == 1 # Single large component containing all nodes from 1 to 100 # To execute the unit tests, uncomment the line below and run the script. # pytest.main()","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] if v not in self.graph: self.graph[v] = [] if v not in self.graph[u]: self.graph[u].append(v) if u not in self.graph[v]: self.graph[v].append(u) def count_components(self): visited = set() def dfs(node): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) stack.extend(adj for adj in self.graph[current] if adj not in visited) components = 0 for node in self.graph: if node not in visited: dfs(node) components += 1 return components"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values as a list of lists. (i.e., from left to right, level by level). >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> level_order_traversal(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(5) >>> level_order_traversal(root) [[1], [2, 3], [4, 5]] >>> level_order_traversal(None) []","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_traversal(root): Given a binary tree, return the level order traversal of its nodes' values as a list of lists. if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(current_level) return result"},{"question":"def min_operations_to_match(source, target): Returns the minimum number of operations required to make \`source\` match \`target\`. Args: source (List[str]): The source array of characters. target (List[str]): The target array of characters. Returns: int: The minimum number of operations required to make source match target, or -1 if it is not possible. >>> min_operations_to_match(['a', 'b', 'c', 'd'], ['b', 'a', 'd', 'c']) 2 >>> min_operations_to_match(['a', 'b', 'c'], ['a', 'b', 'c']) 0 >>> min_operations_to_match(['a', 'b', 'c'], ['a', 'b', 'd']) -1 >>> min_operations_to_match(['a', 'b', 'a'], ['a', 'a', 'b']) 1 >>> min_operations_to_match(['a', 'b', 'c'], ['c', 'b', 'a']) 1 >>> min_operations_to_match(['a', 'a', 'b'], ['a', 'b', 'a']) 1","solution":"def min_operations_to_match(source, target): Returns the minimum number of operations required to make \`source\` match \`target\`. if sorted(source) != sorted(target): return -1 mismatch_indices = [] for i in range(len(source)): if source[i] != target[i]: mismatch_indices.append(i) swaps_required = len(mismatch_indices) // 2 return swaps_required"},{"question":"def sum_of_multiples(n): Returns the sum of all multiples of 3 or 5 below a given number n. >>> sum_of_multiples(10) 23 >>> sum_of_multiples(3) 0","solution":"def sum_of_multiples(n): Returns the sum of all multiples of 3 or 5 below a given number n. sum_multiples = 0 for i in range(n): if i % 3 == 0 or i % 5 == 0: sum_multiples += i return sum_multiples"},{"question":"from typing import List def maxInteger(arr: List[int]) -> str: Given an array of positive integers, rearrange the elements to form the maximum possible integer and return that integer as a string. >>> maxInteger([3, 30, 34, 5, 9]) '9534330' >>> maxInteger([1, 10, 2]) '2110' from functools import cmp_to_key def test_example_1(): assert maxInteger([3, 30, 34, 5, 9]) == \\"9534330\\" def test_example_2(): assert maxInteger([1, 10, 2]) == \\"2110\\" def test_single_element(): assert maxInteger([5]) == \\"5\\" def test_all_same_digits(): assert maxInteger([11, 11, 11]) == \\"111111\\" def test_large_numbers(): assert maxInteger([121, 12]) == \\"12121\\" def test_mixed_lengths(): assert maxInteger([1, 9999, 999, 99]) == \\"9999999991\\" def test_zeroes_leading(): assert maxInteger([0, 0, 1]) == \\"100\\" def test_large_input(): assert maxInteger([i for i in range(1, 1001)]) # Should handle without error def test_leading_zero_removal(): assert maxInteger([0, 0]) == \\"0\\"","solution":"from functools import cmp_to_key def compare(x, y): Compare two elements by their possible concatenations in both orders. if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def maxInteger(arr): Given an array of positive integers, rearrange the elements to form the maximum possible integer and return that integer as a string (since it could be very large). # Convert all integers to string to facilitate custom comparison arr = list(map(str, arr)) # Sort using custom comparator in descending order arr.sort(key=cmp_to_key(compare)) # Join sorted array to form the greatest number result = ''.join(arr) # Convert result to integer to remove leading zeros and back to string return str(int(result))"},{"question":"def process_operations(initial_value: int, operations: str) -> int: Processes a series of operations on an initial value. Args: initial_value (int): The initial integer value. operations (str): A string of characters representing operations. Returns: int: The final value after processing all operations. >>> process_operations(10, \\"AMSD\\") 10 >>> process_operations(1, \\"AAA\\") 4 >>> process_operations(5, \\"SSS\\") 2 >>> process_operations(15, \\"DDD\\") 1 >>> process_operations(2, \\"MMM\\") 16 >>> process_operations(8, \\"D\\") 4 >>> process_operations(10, \\"\\") 10 >>> process_operations(5, \\"A\\") 6 >>> process_operations(5, \\"S\\") 4 >>> process_operations(5, \\"M\\") 10 >>> process_operations(5, \\"D\\") 2","solution":"def process_operations(initial_value, operations): Processes a series of operations on an initial value. Args: initial_value (int): The initial integer value. operations (str): A string of characters representing operations. Returns: int: The final value after processing all operations. value = initial_value for operation in operations: if operation == 'A': value += 1 elif operation == 'S': value -= 1 elif operation == 'M': value *= 2 elif operation == 'D': value //= 2 return value"},{"question":"def minMoves(nums: List[int]) -> int: Return the minimum number of moves required to make all array elements equal. >>> minMoves([1, 2, 3]) 2 >>> minMoves([1, 10, 2, 9]) 16","solution":"def minMoves(nums): Return the minimum number of moves required to make all array elements equal. nums.sort() median = nums[len(nums) // 2] return sum(abs(num - median) for num in nums)"},{"question":"def findAnagrams(s: str, p: str) -> List[int]: Given a string s and a pattern p, return all starting indices of p's anagrams in s. >>> findAnagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> findAnagrams(\\"af\\", \\"be\\") [] pass def checkInclusion(s: str, p: str) -> bool: Given a string s and a pattern p, return True if any anagram of p is a substring of s, otherwise return False. >>> checkInclusion(\\"cbaebabacd\\", \\"abc\\") True >>> checkInclusion(\\"af\\", \\"be\\") False pass from solution import findAnagrams, checkInclusion def test_example_1(): s = \\"cbaebabacd\\" p = \\"abc\\" assert findAnagrams(s, p) == [0, 6] assert checkInclusion(s, p) == True def test_example_2(): s = \\"af\\" p = \\"be\\" assert findAnagrams(s, p) == [] assert checkInclusion(s, p) == False def test_single_character_match(): s = \\"a\\" p = \\"a\\" assert findAnagrams(s, p) == [0] assert checkInclusion(s, p) == True def test_single_character_no_match(): s = \\"a\\" p = \\"b\\" assert findAnagrams(s, p) == [] assert checkInclusion(s, p) == False def test_no_anagrams(): s = \\"abcdefgh\\" p = \\"xyz\\" assert findAnagrams(s, p) == [] assert checkInclusion(s, p) == False def test_multiple_anagrams(): s = \\"abababab\\" p = \\"ab\\" assert findAnagrams(s, p) == [0, 1, 2, 3, 4, 5, 6] assert checkInclusion(s, p) == True def test_same_length(): s = \\"abcd\\" p = \\"dcba\\" assert findAnagrams(s, p) == [0] assert checkInclusion(s, p) == True","solution":"def findAnagrams(s: str, p: str): from collections import Counter len_s, len_p = len(s), len(p) if len_p > len_s: return [] p_count = Counter(p) s_count = Counter() result = [] for i in range(len_s): s_count[s[i]] += 1 if i >= len_p: if s_count[s[i - len_p]] == 1: del s_count[s[i - len_p]] else: s_count[s[i - len_p]] -= 1 if p_count == s_count: result.append(i - len_p + 1) return result def checkInclusion(s: str, p: str): return len(findAnagrams(s, p)) > 0"},{"question":"def is_palindrome(n: int) -> bool: Check if a number is a palindrome. >>> is_palindrome(9009) True >>> is_palindrome(12321) True >>> is_palindrome(12345) False >>> is_palindrome(1) True def largest_palindrome_product() -> int: Find the largest palindrome made from the product of two 3-digit numbers. >>> largest_palindrome_product() 906609","solution":"def is_palindrome(n): Check if a number is a palindrome. return str(n) == str(n)[::-1] def largest_palindrome_product(): Find the largest palindrome made from the product of two 3-digit numbers. max_palindrome = 0 for i in range(999, 99, -1): for j in range(i, 99, -1): product = i * j if is_palindrome(product) and product > max_palindrome: max_palindrome = product return max_palindrome"},{"question":"def min_operations_to_sort_books(s: str) -> int: Given a string \`s\` representing the books on the shelf, determine the minimum number of operations required to rearrange the books in a non-decreasing order. >>> min_operations_to_sort_books(\\"cba\\") 2 >>> min_operations_to_sort_books(\\"abc\\") 0 >>> min_operations_to_sort_books(\\"bdca\\") 2","solution":"def min_operations_to_sort_books(s): Given a string \`s\` representing the books on the shelf, determine the minimum number of operations required to rearrange the books in a non-decreasing order. n = len(s) dp = [0] * 26 # dp array for storing longest subsequence of each character ending at that character for char in s: index = ord(char) - ord('a') dp[index] = max(dp[:index+1]) + 1 return n - max(dp)"},{"question":"def categorize_runner(D, H, M): Categorizes the runner based on the marathon type, finishing hours, and minutes. Parameters: D (int): Marathon type (1 for full marathon, 0 for half marathon) H (int): Finishing time in hours M (int): Finishing time in minutes Returns: str: Category of the runner pass # Test cases def test_full_marathon_under_4_hours(): assert categorize_runner(1, 3, 45) == \\"Category A\\" assert categorize_runner(1, 3, 59) == \\"Category A\\" def test_full_marathon_4_hours_or_more(): assert categorize_runner(1, 4, 0) == \\"Category B\\" assert categorize_runner(1, 4, 15) == \\"Category B\\" assert categorize_runner(1, 5, 0) == \\"Category B\\" def test_half_marathon_under_2_hours(): assert categorize_runner(0, 1, 59) == \\"Category B\\" assert categorize_runner(0, 0, 59) == \\"Category B\\" assert categorize_runner(0, 2, 0) == \\"Category B\\" def test_half_marathon_2_hours_or_more(): assert categorize_runner(0, 2, 1) == \\"Category C\\" assert categorize_runner(0, 3, 0) == \\"Category C\\" assert categorize_runner(0, 4, 30) == \\"Category C\\" assert categorize_runner(0, 2, 30) == \\"Category C\\"","solution":"def categorize_runner(D, H, M): Categorizes the runner based on the marathon type, finishing hours, and minutes. Parameters: D (int): Marathon type (1 for full marathon, 0 for half marathon) H (int): Finishing time in hours M (int): Finishing time in minutes Returns: str: Category of the runner if D == 1: if H < 4: return \\"Category A\\" else: return \\"Category B\\" else: if H < 2 or (H == 2 and M == 0): return \\"Category B\\" else: return \\"Category C\\""},{"question":"def smallest_time_interval(n: int, timestamps: List[str]) -> Union[int, str]: Calculate the smallest time interval (difference) between any two provided timestamps. >>> smallest_time_interval(1, [\\"12:45\\"]) \\"No interval\\" >>> smallest_time_interval(3, [\\"05:30\\", \\"23:50\\", \\"00:05\\"]) 15 >>> smallest_time_interval(4, [\\"12:00\\", \\"11:00\\", \\"09:45\\", \\"08:30\\"]) 60 >>> smallest_time_interval(2, [\\"00:00\\", \\"23:59\\"]) 1 >>> smallest_time_interval(3, [\\"00:00\\", \\"00:15\\", \\"00:30\\"]) 15 >>> smallest_time_interval(2, [\\"12:00\\", \\"12:01\\"]) 1 >>> smallest_time_interval(2, [\\"12:00\\", \\"11:59\\"]) 1 >>> smallest_time_interval(2, [\\"23:59\\", \\"00:00\\"]) 1 >>> smallest_time_interval(3, [\\"07:00\\", \\"14:00\\", \\"21:00\\"]) 420 pass","solution":"def smallest_time_interval(n, timestamps): if n < 2: return \\"No interval\\" def to_minutes(timestamp): hours, minutes = map(int, timestamp.split(':')) return hours * 60 + minutes # Convert all timestamps to minutes minutes_list = [to_minutes(timestamp) for timestamp in timestamps] # Sort the list of minutes minutes_list.sort() # Initialize minimum interval to a large number min_interval = float('inf') # Calculate the minimum difference between consecutive times for i in range(1, n): min_interval = min(min_interval, minutes_list[i] - minutes_list[i-1]) # Additionally, check the difference between the last and first timestamp accounting for wrap around midnight wrap_around_interval = (1440 - minutes_list[-1]) + minutes_list[0] min_interval = min(min_interval, wrap_around_interval) return min_interval"},{"question":"def can_form_pairs(n: int, k: int, arr: List[int]) -> str: Determines if there exists a combination of non-overlapping pairs of elements such that each pair sums up to the given target value k. Parameters: n (int): Number of integers in the list k (int): Target sum value arr (list): List of integers Returns: str: \\"YES\\" if it's possible to form the pairs, otherwise \\"NO\\" def test_example_1(): assert can_form_pairs(6, 8, [1, 7, 2, 6, 3, 5]) == \\"YES\\" def test_example_2(): assert can_form_pairs(5, 10, [1, 2, 3, 4, 5]) == \\"NO\\" def test_edge_case_1(): assert can_form_pairs(1, 2, [1]) == \\"NO\\" def test_repeated_elements(): assert can_form_pairs(4, 4, [2, 2, 2, 2]) == \\"YES\\" def test_negative_elements(): assert can_form_pairs(4, 0, [-1, 1, 2, -2]) == \\"YES\\" def test_large_numbers(): assert can_form_pairs(4, 2000000000, [1000000000, 1000000000, 999999999, 1000000001]) == \\"YES\\" def test_no_possible_pairs(): assert can_form_pairs(6, 12, [1, 3, 5, 7, 2, 4]) == \\"NO\\"","solution":"def can_form_pairs(n, k, arr): Determines if there exists a combination of non-overlapping pairs of elements such that each pair sums up to the given target value k. Parameters: n (int): Number of integers in the list k (int): Target sum value arr (list): List of integers Returns: str: \\"YES\\" if it's possible to form the pairs, otherwise \\"NO\\" pair_count = {} for num in arr: complement = k - num if pair_count.get(complement, 0) > 0: pair_count[complement] -= 1 else: pair_count[num] = pair_count.get(num, 0) + 1 if all(value == 0 for value in pair_count.values()): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def maxHourglassSum(matrix: List[List[int]], N: int, M: int) -> int: Find the maximum sum of an hourglass in the matrix. Args: matrix: a 2D list of integers N: the number of rows in the matrix M: the number of columns in the matrix Returns: The maximum hourglass sum as an integer Examples: >>> matrix1 = [ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ] >>> maxHourglassSum(matrix1, 6, 6) 19 >>> matrix2 = [ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ] >>> maxHourglassSum(matrix2, 6, 6) -6 >>> matrix3 = [ ... [9, 9, 9, 9, 9, 9], ... [9, 1, 9, 1, 9, 1], ... [9, 9, 9, 9, 9, 9], ... [9, 1, 9, 1, 9, 1], ... [9, 9, 9, 9, 9, 9], ... [9, 1, 9, 1, 9, 1] ... ] >>> maxHourglassSum(matrix3, 6, 6) 63","solution":"def maxHourglassSum(matrix, N, M): max_sum = float('-inf') for i in range(N - 2): for j in range(M - 2): current_sum = ( matrix[i][j] + matrix[i][j + 1] + matrix[i][j + 2] + matrix[i + 1][j + 1] + matrix[i + 2][j] + matrix[i + 2][j + 1] + matrix[i + 2][j + 2] ) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Given a binary string s, find the maximum length of a subsequence such that it forms a palindrome. >>> longest_palindromic_subsequence(\\"1100\\") 2 >>> longest_palindromic_subsequence(\\"10101\\") 5 >>> longest_palindromic_subsequence(\\"10001\\") 5 def solve(t: int, test_cases: List[str]) -> List[int]: Given t test cases, each containing a binary string s, find the maximum length of a subsequence such that it forms a palindrome for each test case. >>> t = 3 >>> test_cases = [\\"1100\\", \\"10101\\", \\"10001\\"] >>> solve(t, test_cases) [2, 5, 5] >>> t = 1 >>> test_cases = [\\"1\\"] >>> solve(t, test_cases) [1] >>> t = 2 >>> test_cases = [\\"0\\", \\"1\\"] >>> solve(t, test_cases) [1, 1] >>> t = 2 >>> test_cases = [\\"10\\", \\"01\\"] >>> solve(t, test_cases) [1, 1]","solution":"def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] def solve(t, test_cases): results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def number_of_ways(n: int, m: int) -> int: Returns the number of distinct ways to reach the bottom-right corner of an n x m grid by only moving right or down. >>> number_of_ways(2, 2) 2 >>> number_of_ways(3, 2) 3 >>> number_of_ways(3, 3) 6 >>> number_of_ways(1, 1) 1 >>> number_of_ways(1, 1000) 1 >>> number_of_ways(1000, 1) 1 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases and returns a list of results. >>> process_test_cases([(2, 2), (3, 2), (3, 3), (1, 1), (1, 1000), (1000, 1)]) [2, 3, 6, 1, 1, 1] pass","solution":"def number_of_ways(n, m): Returns the number of distinct ways to reach the bottom-right corner of an n x m grid by only moving right or down. This can be calculated using the combinatorial formula: C(n + m - 2, n - 1) or C(n + m - 2, m - 1) from math import comb return comb(n + m - 2, n - 1) def process_test_cases(test_cases): results = [] for n, m in test_cases: results.append(number_of_ways(n, m)) return results"},{"question":"def transform_string_k_hop(S: str, K: int) -> str: Perform a K-hop transformation on the input string S. >>> transform_string_k_hop(\\"HELLO\\", 1) 'IFMMP' >>> transform_string_k_hop(\\"XYZ\\", 3) 'ABC' >>> transform_string_k_hop(\\"HELLO\\", 27) 'IFMMP' >>> transform_string_k_hop(\\"HELLO\\", 52) 'HELLO' >>> transform_string_k_hop(\\"HELLO\\", 0) 'HELLO' >>> transform_string_k_hop(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 25) 'ZABCDEFGHIJKLMNOPQRSTUVWXY'","solution":"def transform_string_k_hop(S, K): Perform a K-hop transformation on the input string S. K = K % 26 transformed = [] for char in S: new_char = chr((ord(char) - ord('A') + K) % 26 + ord('A')) transformed.append(new_char) return ''.join(transformed)"},{"question":"def list_operation(numbers, operation): Executes the specified operation ('sum', 'product', 'max', 'min') on a list of numbers. Parameters: numbers (list): A list of numbers to operate on. operation (str): The operation to perform. It can be 'sum', 'product', 'max', or 'min'. Returns: int/float: The result of the operation. # Unit Test def test_sum_operation(): assert list_operation([1, 2, 3, 4], 'sum') == 10 assert list_operation([5, 5, 5], 'sum') == 15 assert list_operation([10, -2, 2], 'sum') == 10 def test_product_operation(): assert list_operation([1, 2, 3, 4], 'product') == 24 assert list_operation([5, 5, 5], 'product') == 125 assert list_operation([10, -2, 2], 'product') == -40 def test_max_operation(): assert list_operation([1, 2, 3, 4], 'max') == 4 assert list_operation([0, -1, -10], 'max') == 0 assert list_operation([-10, -2, -3], 'max') == -2 def test_min_operation(): assert list_operation([1, 2, 3, 4], 'min') == 1 assert list_operation([0, -1, -10], 'min') == -10 assert list_operation([-10, -2, -3], 'min') == -10 def test_empty_list(): assert list_operation([], 'sum') is None assert list_operation([], 'product') is None assert list_operation([], 'max') is None assert list_operation([], 'min') is None def test_invalid_operation(): try: list_operation([1, 2, 3, 4], 'average') except ValueError as e: assert str(e) == \\"Invalid operation\\"","solution":"def list_operation(numbers, operation): Executes the specified operation ('sum', 'product', 'max', 'min') on a list of numbers. Parameters: numbers (list): A list of numbers to operate on. operation (str): The operation to perform. It can be 'sum', 'product', 'max', or 'min'. Returns: int/float: The result of the operation. if not numbers: return None # or raise ValueError(\\"List is empty\\") if operation == 'sum': return sum(numbers) elif operation == 'product': product = 1 for num in numbers: product *= num return product elif operation == 'max': return max(numbers) elif operation == 'min': return min(numbers) else: raise ValueError(\\"Invalid operation\\")"},{"question":"def can_assign_coordinates(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[str]: Determines if it is possible to assign coordinates to reservoirs such that all pipeline lengths match the given constraints. :param t: Number of test cases. :param test_cases: A list of test cases, each containing: - n: Number of reservoirs. - m: Number of pipelines. - A list of pipelines described by triplets (u, v, d). >>> can_assign_coordinates(2, [(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 1)]), (4, 2, [(1, 2, 5), (3, 4, 7)])]) [\\"NO\\", \\"YES\\"] >>> can_assign_coordinates(1, [(3, 3, [(1, 2, 3), (2, 3, 4), (1, 3, 5)])]) [\\"YES\\"] >>> can_assign_coordinates(1, [(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 4)])]) [\\"NO\\"] >>> can_assign_coordinates(1, [(2, 1, [(1, 2, 100)])]) [\\"YES\\"] >>> can_assign_coordinates(1, [(3, 3, [(1, 2, 2), (2, 3, 3), (1, 3, 4)])]) [\\"YES\\"]","solution":"def can_assign_coordinates(t, test_cases): from math import sqrt def valid_triangle_inequality(edges): # Check if for every triplet of connections (a, b, c) # the triangle inequalities a + b > c, a + c > b, and b + c > a hold. for i in range(len(edges)): for j in range(i + 1, len(edges)): for k in range(j + 1, len(edges)): (u1, v1, d1) = edges[i] (u2, v2, d2) = edges[j] (u3, v3, d3) = edges[k] lengths = sorted([d1, d2, d3]) if lengths[0] + lengths[1] <= lengths[2]: return False return True def process_test_case(n, m, edges): # If the edges do not satisfy the triangle inequality, it's impossible if not valid_triangle_inequality(edges): return \\"NO\\" return \\"YES\\" results = [] for test_case in test_cases: n, m, edges = test_case result = process_test_case(n, m, edges) results.append(result) return results"},{"question":"def count_pattern_occurrences(document: str, pattern: str) -> int: Counts the occurrences of the word pattern in the given document, irrespective of case. Args: document (str): The text document where the pattern needs to be counted. pattern (str): The word pattern to count in the document. Returns: int: The number of times the pattern appears in the document. Example: >>> count_pattern_occurrences(\\"Pattern recognition is a branch of machine learning.\\", \\"pattern\\") 1 >>> count_pattern_occurrences(\\"Pattern recognition is a branch of machine learning.nPATTERN recognition systems are in many applications.\\", \\"pattern\\") 2 import pytest def test_pattern_in_single_line(): document = \\"Pattern recognition is a branch of machine learning.\\" pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 1 def test_pattern_on_multiple_lines(): document = Pattern recognition is a branch of machine learning. PATTERN recognition systems are in many applications. pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 2 def test_pattern_case_insensitive(): document = \\"PatTeRn pattern pATTern\\" pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 3 def test_pattern_not_present(): document = \\"There is no matching word here.\\" pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 0 def test_empty_document(): document = \\"\\" pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 0 def test_empty_pattern(): document = \\"Pattern recognition is a branch of machine learning.\\" pattern = \\"\\" assert count_pattern_occurrences(document, pattern) == 0 def test_document_with_only_pattern(): document = \\"pattern pattern pattern\\" pattern = \\"pattern\\" assert count_pattern_occurrences(document, pattern) == 3 def test_pattern_with_numerical_characters(): document = \\"M123 pattern m123Pattern\\" pattern = \\"m123pattern\\" assert count_pattern_occurrences(document, pattern) == 1 if __name__ == \\"__main__\\": pytest.main()","solution":"def count_pattern_occurrences(document: str, pattern: str) -> int: Counts the occurrences of the word pattern in the given document, irrespective of case. # Convert both document and pattern to lower case for case-insensitive comparison lower_document = document.lower() lower_pattern = pattern.lower() # Split the document into words and count the occurrences of the pattern words = lower_document.split() count = sum(1 for word in words if word == lower_pattern) return count"},{"question":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, otherwise returns False. A string is considered a palindrome if it reads the same forward and backward, ignoring spaces, punctuation, and capitalization. >>> is_palindrome(\\"A man a plan a canal Panama\\") == True >>> is_palindrome(\\"Madam\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"Hello\\") == False >>> is_palindrome(\\"Not a palindrome\\") == False >>> is_palindrome(\\"\\") == True >>> is_palindrome(\\"a\\") == True >>> is_palindrome(\\"Z\\") == True >>> is_palindrome(\\"Able , was I saw eLba\\") == True >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Was it a car or a cat I saw\\") == True >>> is_palindrome(\\"Eva, can I see bees in a cave\\") == True","solution":"def is_palindrome(s): Returns True if the input string is a palindrome, otherwise returns False. Ignores spaces, punctuation, and capitalization. # Remove non-alphanumeric characters and convert to lowercase filtered_s = ''.join(char for char in s if char.isalnum()).lower() # Check if the string reads the same forwards and backwards return filtered_s == filtered_s[::-1]"},{"question":"from typing import List, Tuple def max_flow(N: int, M: int, S: int, T: int, edges: List[Tuple[int, int, int]]) -> int: Determine the maximum number of commuters that can be routed from the starting intersection to the destination intersection. This function takes the number of intersections (N), the number of streets (M), the starting intersection (S), the destination intersection (T), and a list of edges where each edge is represented as a tuple of two intersections and their capacity. It returns the maximum number of commuters that can travel from the starting intersection to the destination intersection. Args: N (int): Number of intersections. M (int): Number of streets. S (int): Starting intersection. T (int): Destination intersection. edges (List[Tuple[int, int, int]]): List of edges where each edge is a tuple (u, v, c) indicating an undirected street between intersections u and v with capacity c. Returns: int: The maximum number of commuters that can be routed from S to T. Examples: >>> max_flow(4, 5, 1, 4, [(1, 2, 40), (1, 3, 20), (2, 3, 10), (2, 4, 30), (3, 4, 20)]) 50 >>> max_flow(3, 3, 1, 3, [(1, 2, 5), (2, 3, 10), (1, 3, 2)]) 7","solution":"from collections import deque def bfs_capacity(graph, capacity, source, sink, parent): visited = [False] * len(graph) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for adj, cap in graph[node]: if not visited[adj] and capacity[node][adj] > 0: parent[adj] = node visited[adj] = True queue.append(adj) if adj == sink: return True return False def max_flow(N, M, S, T, edges): graph = [[] for _ in range(N)] capacity = [[0] * N for _ in range(N)] for u, v, c in edges: graph[u-1].append((v-1, c)) graph[v-1].append((u-1, c)) capacity[u-1][v-1] += c capacity[v-1][u-1] += c source = S - 1 sink = T - 1 parent = [-1] * N max_flow = 0 while bfs_capacity(graph, capacity, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, capacity[parent[s]][s]) s = parent[s] max_flow += path_flow v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = parent[v] return max_flow"},{"question":"def subarray_with_zero_sum(arr): Returns \\"Yes\\" if there is a subarray with sum 0, otherwise returns \\"No\\". >>> subarray_with_zero_sum([4, 2, -3, 1, 6]) == \\"Yes\\" >>> subarray_with_zero_sum([4, 2, 0, 1, 6]) == \\"Yes\\" >>> subarray_with_zero_sum([-3, 2, 3, 1, 6]) == \\"No\\" >>> subarray_with_zero_sum([1, 2, -3, 3, 1]) == \\"Yes\\" >>> subarray_with_zero_sum([1, 2, 3, 4, 5]) == \\"No\\" >>> subarray_with_zero_sum([0]) == \\"Yes\\" >>> subarray_with_zero_sum([1, -1]) == \\"Yes\\" >>> subarray_with_zero_sum([10**9, -10**9]) == \\"Yes\\" # Function implementation here","solution":"def subarray_with_zero_sum(arr): Returns \\"Yes\\" if there is a subarray with sum 0, otherwise returns \\"No\\". prefix_sum = 0 prefix_sum_set = set() for num in arr: prefix_sum += num if prefix_sum == 0 or prefix_sum in prefix_sum_set: return \\"Yes\\" prefix_sum_set.add(prefix_sum) return \\"No\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:N+1])) print(subarray_with_zero_sum(A))"},{"question":"def is_rectangle(t: int, test_cases: List[Tuple[Tuple[int, int], List[str]]]) -> List[str]: For each test case, determine if the connected component of 'X's forms a rectangle. >>> t = 2 >>> test_cases = [((4, 5), [\\".....\\", \\"..XX.\\", \\"..XX.\\", \\".....\\"]), ((3, 4), [\\"..X.\\", \\"..X.\\", \\"...X\\"])] >>> is_rectangle(t, test_cases) ['YES', 'NO'] >>> t = 1 >>> test_cases = [((3, 3), [\\"XXX\\", \\"XX.\\", \\"XX.\\"])] >>> is_rectangle(t, test_cases) ['NO'] >>> t = 1 >>> test_cases = [((4, 5), [\\".....\\", \\".XXXX\\", \\".XXXX\\", \\".....\\"])] >>> is_rectangle(t, test_cases) ['YES'] >>> t = 1 >>> test_cases = [((4, 5), [\\".....\\", \\".XXX.\\", \\".XXX.\\", \\".....\\"])] >>> is_rectangle(t, test_cases) ['YES'] >>> t = 1 >>> test_cases = [((3, 3), [\\"...\\", \\".X.\\", \\"...\\"])] >>> is_rectangle(t, test_cases) ['YES']","solution":"def is_rectangle(t, test_cases): For each test case, determine if the connected component of 'X's forms a rectangle. results = [] for i in range(t): n, m = test_cases[i][0] grid = test_cases[i][1] # Identifying bounds of 'X' connected component top, bottom, left, right = n, 0, m, 0 for row in range(n): for col in range(m): if grid[row][col] == 'X': top = min(top, row) bottom = max(bottom, row) left = min(left, col) right = max(right, col) # Checking if all cells within the bounds are 'X' is_rectangular = True for row in range(top, bottom + 1): for col in range(left, right + 1): if grid[row][col] != 'X': is_rectangular = False break if not is_rectangular: break if is_rectangular: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculateTallestTree(T: int, growth: List[int]) -> int: Returns the height of the tallest tree after T years given the annual growth rates for each tree. >>> calculateTallestTree(5, [2, 3, 1, 5]) 25 >>> calculateTallestTree(3, [4, 2, 7]) 21","solution":"def calculateTallestTree(T, growth): Returns the height of the tallest tree after T years given the annual growth rates for each tree. # Calculate the height of each tree after T years heights = [rate * T for rate in growth] # Return the maximum height return max(heights)"},{"question":"def bike_sharing(n, initial_bikes, m, requests): Manage a log of bike sharing stations and process rental, return, and query requests. Args: n (int): Number of bike sharing stations. initial_bikes (List[int]): Initial number of bikes at each station. m (int): Number of requests. requests (List[str]): A list of requests in the format \\"Rent x\\", \\"Return x\\", or \\"Query x\\". Returns: List[int]: A list of integers representing the number of bikes available for each \\"Query\\" request. Example: >>> n = 5 >>> initial_bikes = [8, 2, 5, 3, 10] >>> m = 7 >>> requests = [\\"Rent 3\\", \\"Query 3\\", \\"Return 1\\", \\"Query 1\\", \\"Rent 2\\", \\"Query 2\\", \\"Query 5\\"] >>> bike_sharing(n, initial_bikes, m, requests) [4, 9, 1, 10]","solution":"def bike_sharing(n, initial_bikes, m, requests): bike_stations = initial_bikes query_results = [] for req in requests: action, station = req.split() station = int(station) - 1 # convert to 0-based index if action == \\"Rent\\": bike_stations[station] -= 1 elif action == \\"Return\\": bike_stations[station] += 1 elif action == \\"Query\\": query_results.append(bike_stations[station]) return query_results"},{"question":"def stock_trend(stock_prices: list[tuple[str, int]]) -> list[str]: Returns the stock price trend for the given time series data. >>> stock_trend([('2023-10-01', 100), ('2023-10-02', 102), ('2023-10-03', 104)]) ['UP', 'UP'] >>> stock_trend([('2023-10-01', 100), ('2023-10-02', 98), ('2023-10-03', 96)]) ['DOWN', 'DOWN'] >>> stock_trend([('2023-10-01', 100), ('2023-10-02', 100), ('2023-10-03', 100)]) ['SAME', 'SAME'] >>> stock_trend([('2023-10-01', 100), ('2023-10-02', 102), ('2023-10-03', 101), ('2023-10-04', 105), ('2023-10-05', 107)]) ['UP', 'DOWN', 'UP', 'UP'] >>> stock_trend([('2023-10-01', 100), ('2023-10-02', 99)]) ['DOWN']","solution":"def stock_trend(stock_prices: list[tuple[str, int]]) -> list[str]: Returns the stock price trend for the given time series data. trends = [] for i in range(1, len(stock_prices)): if stock_prices[i][1] > stock_prices[i-1][1]: trends.append(\\"UP\\") elif stock_prices[i][1] < stock_prices[i-1][1]: trends.append(\\"DOWN\\") else: trends.append(\\"SAME\\") return trends"},{"question":"from typing import List, Tuple def can_complete_tour(N: int, M: int, tunnels: List[Tuple[int, int]], S: int) -> str: Determine if it's possible to complete a Hamiltonian cycle starting from a specific cave. N: Number of caves. M: Number of tunnels. tunnels: A list of tuples where each tuple represents a bidirectional tunnel between two caves. S: Starting cave. Returns \\"YES\\" if it is possible to complete the tour starting from the given cave S, and \\"NO\\" otherwise. >>> can_complete_tour(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)], 1) \\"YES\\" >>> can_complete_tour(4, 3, [(1, 2), (2, 3), (3, 4)], 1) \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) tunnels = [(int(data[i*2 + 2]), int(data[i*2 + 3])) for i in range(M)] S = int(data[2*M + 2]) print(can_complete_tour(N, M, tunnels, S))","solution":"def can_complete_tour(N, M, tunnels, S): from itertools import permutations # Create an adjacency matrix adj = [[0]*N for _ in range(N)] for a, b in tunnels: adj[a-1][b-1] = 1 adj[b-1][a-1] = 1 # Check all permutations of caves starting from S-1 toVisit = [i for i in range(N) if i != S-1] for perm in permutations(toVisit): valid = True current = S-1 # Check the path in the permutation for nxt in perm: if adj[current][nxt] == 0: valid = False break current = nxt # Check returning to the start if valid and adj[current][S-1] == 1: return \\"YES\\" return \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) tunnels = [(int(data[i*2 + 2]), int(data[i*2 + 3])) for i in range(M)] S = int(data[2*M + 2]) print(can_complete_tour(N, M, tunnels, S))"},{"question":"def shortest_word(sentence: str) -> str: Returns the shortest word in the input string. If there are multiple words with the same shortest length, returns the first occurrence. Ignores punctuation marks and considers case insensitivity. Returns an empty string if the input is empty. >>> shortest_word('The quick, brown fox jumps over the lazy dog.') 'the' >>> shortest_word('Hello World!') 'hello' >>> shortest_word('') ''","solution":"import re def shortest_word(sentence): Returns the shortest word in the input string. If multiple words with the same length, returns the first one encountered. if not sentence: return \\"\\" # Remove punctuation and convert to lower case cleaned_sentence = re.sub(r'[^ws]', '', sentence).lower() # Split sentence into words words = cleaned_sentence.split() if not words: return \\"\\" # Find the shortest word based on length shortest = min(words, key=len) return shortest"},{"question":"def temperature_fluctuations(temperatures: List[int]) -> List[int]: Given a list of daily temperatures for a month, return the number of days you would have to wait until a warmer temperature. If there is no future day for which this is possible, return 0 for that day. Your solution should efficiently handle lists up to 10,000 temperatures in size. >>> temperature_fluctuations([73, 74, 75, 71, 69, 72, 76, 73]) [1, 1, 4, 2, 1, 1, 0, 0] >>> temperature_fluctuations([70, 69, 68]) [0, 0, 0] >>> temperature_fluctuations([70, 70, 70]) [0, 0, 0] >>> temperature_fluctuations([70]) [0] >>> temperature_fluctuations([70, 71, 72, 73]) [1, 1, 1, 0] >>> temperature_fluctuations([75, 74, 70, 71, 76]) [4, 3, 1, 1, 0]","solution":"def temperature_fluctuations(temperatures): Returns a list where each element is the number of days to wait until a warmer temperature. If no future warmer day exists, return 0 for that element. n = len(temperatures) answer = [0] * n stack = [] for i in range(n): while stack and temperatures[i] > temperatures[stack[-1]]: idx = stack.pop() answer[idx] = i - idx stack.append(i) return answer"},{"question":"def minimum_teleporters_to_fix(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of teleporters that need to be fixed to ensure all cities are connected. >>> minimum_teleporters_to_fix(4, 2, [(1, 2), (3, 4)]) 1 >>> minimum_teleporters_to_fix(5, 3, [(1, 2), (2, 3), (4, 5)]) 1 >>> minimum_teleporters_to_fix(3, 3, [(1, 2), (2, 3), (1, 3)]) 0","solution":"def minimum_teleporters_to_fix(n, m, edges): Returns the minimum number of teleporters that need to be fixed to ensure all cities are connected. :param n: int, number of cities :param m: int, number of functioning teleporters :param edges: list of tuples, each tuple represents an edge between two cities :return: int, minimum number of teleporters to fix from collections import defaultdict import itertools def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 if n == 1: return 0 parent = list(range(n+1)) rank = [0] * (n+1) for u, v in edges: union(parent, rank, u, v) root_set = set(find(parent, i) for i in range(1, n+1)) # Number of connected components minus 1 is the minimum number of edges needed to connect everything return len(root_set) - 1"},{"question":"def is_bipartite(N: int, edges: List[Tuple[int, int]]) -> Union[Tuple[List[int], List[int]], str]: Given an undirected graph with N nodes and M edges, determine if the graph is bipartite. Args: N : int : Number of nodes edges : List[Tuple[int, int]] : List of edges where each edge is represented by a tuple (U, V) Returns: Union[Tuple[List[int], List[int]], str] : If bipartite, return two lists of nodes representing the two sets. Otherwise, return the string \\"Not Bipartite\\". Example: >>> is_bipartite(6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) ([1, 3, 5], [2, 4, 6]) >>> is_bipartite(3, [(1, 2), (2, 3), (3, 1)]) \\"Not Bipartite\\" pass import pytest def test_example(): N = 6 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] result = is_bipartite(N, edges) assert result == ([1, 3, 5], [2, 4, 6]) def test_not_bipartite(): N = 3 edges = [(1, 2), (2, 3), (3, 1)] result = is_bipartite(N, edges) assert result == \\"Not Bipartite\\" def test_single_node(): N = 1 edges = [] result = is_bipartite(N, edges) assert result == ([1], []) def test_disconnected(): N = 4 edges = [(1, 2), (3, 4)] result = is_bipartite(N, edges) assert result == ([1, 3], [2, 4]) def test_bipartite_with_multiple_components(): N = 6 edges = [(1, 2), (3, 4), (5, 6)] result = is_bipartite(N, edges) assert result == ([1, 3, 5], [2, 4, 6]) def test_empty_graph(): N = 3 edges = [] result = is_bipartite(N, edges) assert result == ([1, 2, 3], [])","solution":"def is_bipartite(N, edges): from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Initialize color array color = [-1] * (N + 1) # Function to check if a component is bipartite using BFS def bfs_check(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in adj_list[node]: if color[neighbor] == -1: # Assign alternate color to the neighbor color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True # Check each component of the graph for i in range(1, N + 1): if color[i] == -1: if not bfs_check(i): return \\"Not Bipartite\\" # If bipartite, separate nodes into two sets based on their colors set1 = [i for i in range(1, N + 1) if color[i] == 0] set2 = [i for i in range(1, N + 1) if color[i] == 1] return sorted(set1), sorted(set2)"},{"question":"def print_valid_emails(emails): Prints valid email addresses from the given list until an invalid email is encountered. Args: emails (List[str]): A list of email addresses to be validated. >>> print_valid_emails([\\"john.doe@example.com\\", \\"jane-doe123@example.co.in\\", \\"admin@website\\", \\"fake.email#example.com\\", \\"user@company.org\\", \\"marketing@firm.com\\"]) john.doe@example.com jane-doe123@example.co.in admin@website pass import pytest def test_print_valid_emails_all_valid(capsys): emails = [ \\"john.doe@example.com\\", \\"jane-doe123@example.co.in\\", \\"admin@website\\", \\"user@company.org\\", \\"marketing@firm.com\\" ] print_valid_emails(emails) captured = capsys.readouterr() assert captured.out == \\"\\".join(email + \\"n\\" for email in emails) def test_print_valid_emails_stop_on_invalid(capsys): emails = [ \\"john.doe@example.com\\", \\"jane-doe123@example.co.in\\", \\"admin@website\\", \\"fake.email#example.com\\", \\"user@company.org\\", \\"marketing@firm.com\\" ] print_valid_emails(emails) captured = capsys.readouterr() assert captured.out == \\"john.doe@example.comnjane-doe123@example.co.innadmin@websiten\\" def test_print_valid_emails_first_invalid(capsys): emails = [ \\"fake.email#example.com\\", \\"john.doe@example.com\\", \\"jane-doe123@example.co.in\\" ] print_valid_emails(emails) captured = capsys.readouterr() assert captured.out == \\"\\" def test_print_valid_emails_mixed(capsys): emails = [ \\"user@company.com\\", \\"fake.email#example.com\\", \\"marketing@firm.com\\" ] print_valid_emails(emails) captured = capsys.readouterr() assert captured.out == \\"user@company.comn\\"","solution":"def print_valid_emails(emails): Prints valid email addresses from the given list until an invalid email is encountered. for email in emails: if '@' in email: print(email) else: break"},{"question":"def find_pair(arr, x, y): Determines if there is a pair of numbers in the array such that their difference is exactly x and their sum is exactly y. >>> find_pair([1, 5, 3, 4, 2], 2, 5) True >>> find_pair([1, 5, 3, 4, 2], 10, 5) False >>> find_pair([-1, -5, -3, -4, -2], 2, -7) True >>> find_pair([1000000000, 100000000, 10000000], 900000000, 1100000000) True >>> find_pair([1000000000, 100000000, 10000000], 900000000, 1099999999) False >>> find_pair([5], 0, 10) False >>> find_pair([], 2, 3) False >>> find_pair([1000000000, -1000000000, 500000000, -500000000], 2000000000, 0) True","solution":"def find_pair(arr, x, y): Determines if there is a pair of numbers in the array such that their difference is exactly x and their sum is exactly y. :param arr: List[int], the array of integers :param x: int, the required difference :param y: int, the required sum :return: True if such a pair exists, False otherwise seen = set() for num in arr: desired1 = (y - x) // 2 desired2 = (y + x) // 2 if (desired1 in seen) or (desired2 in seen): return True seen.add(num) return False"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def isBST(root): Determine if the binary tree is a binary search tree. >>> isBST(None) True >>> isBST(TreeNode(1)) True >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(3) >>> isBST(root) True >>> root = TreeNode(4) >>> root.left = TreeNode(2) >>> root.right = TreeNode(5) >>> root.left.left = TreeNode(1) >>> root.left.right = TreeNode(6) >>> isBST(root) False","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def isBST(root): def validate(node, low=-float('inf'), high=float('inf')): if not node: return True if node.value <= low or node.value >= high: return False return validate(node.left, low, node.value) and validate(node.right, node.value, high) return validate(root)"},{"question":"def print_diamond(N): Prints a diamond pattern centered around the middle of N lines. >>> print_diamond(5) * *** ***** *** * >>> print_diamond(1) * >>> print_diamond(3) * *** *","solution":"def print_diamond(N): Prints a diamond pattern centered around the middle of N lines. if N % 2 == 0 or N < 1 or N > 15: return None mid = N // 2 for i in range(N): if i <= mid: stars = 2 * i + 1 else: stars = 2 * (N - i - 1) + 1 spaces = (N - stars) // 2 print(' ' * spaces + '*' * stars)"},{"question":"def isPerfectNumber(n): Determines whether a given positive integer n is a perfect number. :param n: The integer to be checked. :return: True if n is a perfect number, otherwise False. >>> isPerfectNumber(6) True >>> isPerfectNumber(28) True >>> isPerfectNumber(496) True >>> isPerfectNumber(8128) True >>> isPerfectNumber(5) False >>> isPerfectNumber(27) False >>> isPerfectNumber(12) False >>> isPerfectNumber(100) False >>> isPerfectNumber(1) False >>> isPerfectNumber(2) False >>> isPerfectNumber(0) False >>> isPerfectNumber(-6) False >>> isPerfectNumber(33550336) True >>> isPerfectNumber(33550337) False","solution":"def isPerfectNumber(n): Determines whether a given positive integer n is a perfect number. :param n: The integer to be checked. :return: True if n is a perfect number, otherwise False. if n <= 1: return False divisors_sum = 1 # Start with 1 as a divisor for i in range(2, int(n**0.5) + 1): if n % i == 0: divisors_sum += i if i != n // i: divisors_sum += n // i return divisors_sum == n"},{"question":"def is_balanced(s: str) -> bool: Determine if a string is balanced, meaning every character in the string appears the same number of times. >>> is_balanced(\\"aabbcc\\") True >>> is_balanced(\\"aaabbc\\") False >>> is_balanced(\\"abcdab\\") False >>> is_balanced(\\"aaaa\\") True >>> is_balanced(\\"\\") True >>> is_balanced(\\"x\\" * 100) True pass def process_strings(strings: List[str]) -> List[str]: Process a list of strings, determines if each string is balanced and returns the list of results as \\"YES\\" or \\"NO\\". The list terminates when a single '*' is encountered. >>> process_strings([\\"aabbcc\\", \\"aaabbc\\", \\"abcdab\\", \\"aaaa\\", \\"*\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> process_strings([\\"aabbcc\\", \\"aaabbc\\", \\"*\\", \\"abcdab\\", \\"aaaa\\", \\"*\\"]) [\\"YES\\", \\"NO\\"] >>> process_strings([\\"\\", \\"*\\"]) [\\"YES\\"] pass","solution":"def is_balanced(s): from collections import Counter char_counts = Counter(s) values = list(char_counts.values()) return all(val == values[0] for val in values) def process_strings(strings): results = [] for s in strings: if s == \\"*\\": break results.append(\\"YES\\" if is_balanced(s) else \\"NO\\") return results"},{"question":"def max_treasure(grid: List[List[int]]) -> int: Calculate the maximum amount of treasure that can be collected from the top-left to the bottom-right corner of the grid. The pirates can only move either right or down starting from the top-left corner. Parameters: grid (List[List[int]]): A 2D grid representing the island where each cell has a non-negative integer value representing the amount of treasure at that cell. Returns: int: The maximum amount of treasure that can be collected. >>> max_treasure([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 12 >>> max_treasure([[5]]) 5 >>> max_treasure([ ... [1, 2], ... [3, 4] ... ]) 8 >>> max_treasure([ ... [1000, 1000], ... [1000, 1000] ... ]) 3000 >>> max_treasure([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def max_treasure(grid): Function to calculate the maximum amount of treasure that can be collected from the top-left to the bottom-right corner of the grid. if not grid or not grid[0]: return 0 n = len(grid) m = len(grid[0]) # Create a dp table to store the max treasure collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left corner with the initial treasure value dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the maximum treasure collected return dp[-1][-1]"},{"question":"def rearrangeArray(arr, n): Rearranges the array such that even-indexed elements are in non-decreasing order and odd-indexed elements are in non-increasing order. Parameters: arr (list of int): The input array. n (int): The length of the input array. Returns: list of int: The rearranged array. pass def test_example_case(): arr = [1, 3, 2, 8, 5, 7] n = len(arr) result = rearrangeArray(arr, n) assert result == [1, 8, 2, 7, 5, 3] def test_only_one_element(): arr = [4] n = len(arr) result = rearrangeArray(arr, n) assert result == [4] def test_all_even_indexed(): arr = [10, 1, 20, 2, 30, 3] n = len(arr) result = rearrangeArray(arr, n) assert result == [10, 3, 20, 2, 30, 1] def test_all_odd_indexed(): arr = [3, 10, 6, 9, 0, 8] n = len(arr) result = rearrangeArray(arr, n) assert result == [0, 10, 3, 9, 6, 8] def test_large_numbers(): arr = [1000000000, 999999999, 999999998, 999999997] n = len(arr) result = rearrangeArray(arr, n) assert result == [999999998, 999999999, 1000000000, 999999997] def test_descending_order(): arr = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] n = len(arr) result = rearrangeArray(arr, n) assert result == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1]","solution":"def rearrangeArray(arr, n): Rearranges the array such that even-indexed elements are in non-decreasing order and odd-indexed elements are in non-increasing order. Parameters: arr (list of int): The input array. n (int): The length of the input array. Returns: list of int: The rearranged array. even_indexed_elements = sorted([arr[i] for i in range(n) if i % 2 == 0]) odd_indexed_elements = sorted([arr[i] for i in range(n) if i % 2 == 1], reverse=True) result = [] even_idx = 0 odd_idx = 0 for i in range(n): if i % 2 == 0: result.append(even_indexed_elements[even_idx]) even_idx += 1 else: result.append(odd_indexed_elements[odd_idx]) odd_idx += 1 return result"},{"question":"from typing import List def levenshtein_distance(word1: str, word2: str) -> int: Compute the Levenshtein distance between two words. >>> levenshtein_distance(\\"apple\\", \\"appl\\") == 1 >>> levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 def spell_check(dictionary: List[str], document: List[str]) -> List[str]: Check each word in the document and suggest the closest word from the dictionary if it is misspelled. >>> spell_check([\\"apple\\", \\"banana\\", \\"cherry\\"], [\\"appl\\", \\"banan\\"]) == [\\"apple\\", \\"banana\\"] from solution import levenshtein_distance, spell_check def test_levenshtein_distance(): assert levenshtein_distance(\\"apple\\", \\"apple\\") == 0 assert levenshtein_distance(\\"appl\\", \\"apple\\") == 1 assert levenshtein_distance(\\"apple\\", \\"aple\\") == 1 assert levenshtein_distance(\\"apple\\", \\"appli\\") == 1 assert levenshtein_distance(\\"kitten\\", \\"sitting\\") == 3 def test_spell_check_correctly_spelled(): dictionary = [\\"apple\\", \\"banana\\", \\"cherry\\"] document = [\\"apple\\", \\"banana\\"] assert spell_check(dictionary, document) == [\\"apple\\", \\"banana\\"] def test_spell_check_misspelled(): dictionary = [\\"apple\\", \\"banana\\", \\"cherry\\"] document = [\\"appl\\", \\"banan\\"] assert spell_check(dictionary, document) == [\\"apple\\", \\"banana\\"] def test_spell_check_multiple_min_distances(): dictionary = [\\"apple\\", \\"apply\\", \\"appla\\"] document = [\\"appla\\"] assert spell_check(dictionary, document) == [\\"appla\\"] def test_spell_check_large_input(): dictionary = [\\"word\\" + str(i) for i in range(100)] document = [\\"word\\" + str(i) + \\"z\\" for i in range(100)] expected = [\\"word\\" + str(i) for i in range(100)] assert spell_check(dictionary, document) == expected","solution":"def levenshtein_distance(word1, word2): Compute the Levenshtein distance between two words. len1, len2 = len(word1), len(word2) dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j for i in range(1, len1 + 1): for j in range(1, len2 + 1): cost = 0 if word1[i - 1] == word2[j - 1] else 1 dp[i][j] = min(dp[i - 1][j] + 1, # deletion dp[i][j - 1] + 1, # insertion dp[i - 1][j - 1] + cost) # substitution return dp[len1][len2] def spell_check(dictionary, document): Check each word in the document and suggest the closest word from the dictionary if it is misspelled. result = [] for word in document: if word in dictionary: result.append(word) else: min_distance = float('inf') closest_word = None for dict_word in dictionary: distance = levenshtein_distance(word, dict_word) if (distance < min_distance) or (distance == min_distance and dict_word < closest_word): min_distance = distance closest_word = dict_word result.append(closest_word) return result"},{"question":"def magic_sorter(N: int, K: int, P: float, array: List[int]) -> str: Determines if the array can be sorted within K passes using a spell that swaps adjacent elements with a probability P if they are out of order. Args: N (int): The length of the array. K (int): The maximum number of passes allowed. P (float): The probability of swapping adjacent elements. array (List[int]): The array of integers to be sorted. Returns: str: \\"Yes\\" if the array can be sorted within the given number of passes, otherwise \\"No\\". Example: >>> magic_sorter(4, 10, 1.0, [4, 3, 2, 1]) \\"Yes\\" >>> magic_sorter(5, 5, 0.5, [5, 1, 3, 2, 4]) \\"No\\" >>> magic_sorter(3, 7, 0.7, [3, 1, 2]) \\"Yes\\" pass # Unit Tests def test_example_1(): assert magic_sorter(4, 10, 1.0, [4, 3, 2, 1]) == \\"Yes\\" def test_example_2(): assert magic_sorter(5, 5, 0.5, [5, 1, 3, 2, 4]) == \\"No\\" def test_example_3(): assert magic_sorter(3, 7, 0.7, [3, 1, 2]) == \\"Yes\\" def test_already_sorted(): assert magic_sorter(5, 10, 0.5, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_single_element(): assert magic_sorter(1, 10, 0.5, [1]) == \\"Yes\\" def test_no_swaps_needed(): assert magic_sorter(4, 1, 1.0, [1, 2, 3, 4]) == \\"Yes\\" def test_no_passes(): assert magic_sorter(3, 0, 1.0, [3, 2, 1]) == \\"No\\" def test_low_probability(): assert magic_sorter(4, 10, 0.01, [4, 3, 2, 1]) == \\"No\\" def test_maximum_passes(): assert magic_sorter(4, 1000, 0.01, [4, 3, 2, 1]) == \\"Yes\\"","solution":"import random def magic_sorter(N, K, P, array): Determines if the array can be sorted within K passes using a spell that swaps adjacent elements with a probability P if they are out of order. def is_sorted(arr): return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) for _ in range(K): if is_sorted(array): return \\"Yes\\" for i in range(N-1): if array[i] > array[i+1] and random.random() < P: array[i], array[i+1] = array[i+1], array[i] return \\"Yes\\" if is_sorted(array) else \\"No\\" # Example Usage: # result = magic_sorter(5, 5, 0.8, [3, 4, 1, 5, 2]) # print(result) # Expected Output: \\"Yes\\""},{"question":"import re def increment_string(s: str) -> str: Increment the numerical part of the given string by one, or append '1' if no numerical part is present. Leading zeros in the number portion should be preserved. >>> increment_string(\\"foobar001\\") \\"foobar002\\" >>> increment_string(\\"foo\\") \\"foo1\\" >>> increment_string(\\"foobar00\\") \\"foobar01\\" >>> increment_string(\\"foobar99\\") \\"foobar100\\" >>> increment_string(\\"\\") \\"1\\" >>> increment_string(\\"a5\\") \\"a6\\"","solution":"import re def increment_string(s: str) -> str: Increments the numerical part of the given string, or appends '1' if no numerical part is present. Leading zeros in the number portion should be preserved. match = re.search(r'(d+)', s) if match: number = match.group(1) incremented_number = str(int(number) + 1).zfill(len(number)) return s[:match.start()] + incremented_number else: return s + '1'"},{"question":"from typing import List, Tuple def findSmallestWindow(arr: List[int]) -> Tuple[Tuple[int, int], List[int]]: Finds the smallest window that needs to be sorted to make the entire array sorted. Returns the starting and ending indices of that window, as well as the completely sorted array. >>> findSmallestWindow([1, 3, 2, 4, 5]) ((1, 2), [1, 2, 3, 4, 5]) >>> findSmallestWindow([1, 2, 3, 4, 5]) ((-1, -1), [1, 2, 3, 4, 5]) >>> findSmallestWindow([1, 2, 6, 4, 5, 3, 7, 8]) ((2, 5), [1, 2, 3, 4, 5, 6, 7, 8]) pass # Your code goes here.","solution":"def findSmallestWindow(arr): Finds the smallest window that needs to be sorted to make the entire array sorted. Returns the starting and ending indices of that window, as well as the completely sorted array. n = len(arr) start, end = -1, -1 # Step 1: Find the first element that is out of order from the left for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break # If start is still -1, then array is already sorted if start == -1: return (-1, -1), arr # Step 2: Find the first element that is out of order from the right for i in range(n - 1, 0, -1): if arr[i] < arr[i - 1]: end = i break # Step 3: Find the minimum and maximum values in the arr[start:end+1] window_min = min(arr[start:end+1]) window_max = max(arr[start:end+1]) # Step 4: Extend the window to the left while start > 0 and arr[start - 1] > window_min: start -= 1 # Step 5: Extend the window to the right while end < n - 1 and arr[end + 1] < window_max: end += 1 # Step 6: Sort the array sorted_array = sorted(arr) return (start, end), sorted_array"},{"question":"def can_make_all_elements_equal(n: int, m: int, matrix: List[List[int]]) -> bool: Determines if it is possible to make all the elements in the matrix the same by applying any number of row left rotations or column top rotations. :param n: number of rows in the matrix :param m: number of columns in the matrix :param matrix: 2D list containing the matrix elements :return: True if possible to make all elements equal, False otherwise def solve(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Solves the problem for multiple test cases. :param test_cases: A list of tuples where each tuple contains n, m, and the matrix elements :return: List of strings \\"YES\\" or \\"NO\\" for each test case # Unit Tests def test_can_make_all_elements_equal(): assert can_make_all_elements_equal(2, 2, [[1, 1], [1, 1]]) == True assert can_make_all_elements_equal(3, 3, [[2, 2, 2], [2, 3, 2], [2, 2, 2]]) == False assert can_make_all_elements_equal(2, 3, [[1, 2, 1], [1, 1, 2]]) == False def test_solve(): # Sample input cases test_cases = [ (2, 2, [[1, 1], [1, 1]]), (3, 3, [[2, 2, 2], [2, 3, 2], [2, 2, 2]]), (2, 3, [[1, 2, 1], [1, 1, 2]]) ] assert solve(test_cases) == [\\"YES\\", \\"NO\\", \\"NO\\"] # Additional test cases assert solve([(2, 2, [[4, 4], [4, 4]])]) == [\\"YES\\"] assert solve([(1, 1, [[5]])]) == [\\"YES\\"] assert solve([(2, 2, [[1, 2], [2, 1]])]) == [\\"NO\\"] assert solve([(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]])]) == [\\"YES\\"] assert solve([(2, 1, [[1], [1]])]) == [\\"YES\\"] assert solve([(3, 2, [[1, 2], [1, 2], [1, 2]])]) == [\\"NO\\"]","solution":"def can_make_all_elements_equal(n, m, matrix): Determines if it is possible to make all the elements in the matrix the same by applying any number of row left rotations or column top rotations. # Create a set to store all unique elements in the matrix unique_elements = set() for row in matrix: for element in row: unique_elements.add(element) # If there's only one unique element, we can make all the elements equal return len(unique_elements) == 1 def solve(test_cases): results = [] for case in test_cases: n, m, matrix = case if can_make_all_elements_equal(n, m, matrix): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def divide(dividend, divisor): Function to perform integer division without using '/', '*', or '%' operators. Returns the quotient and remainder. >>> divide(10, 3) (3, 1) >>> divide(25, 4) (6, 1) >>> divide(15, 5) (3, 0) >>> divide(7, -3) (-2, 1) >>> divide(-17, 4) (-4, 3)","solution":"def divide(dividend, divisor): Function to perform integer division without using '/', '*', or '%' operators. Returns the quotient and remainder. if divisor == 0: raise ValueError(\\"Cannot divide by zero\\") # Handle negative numbers sign = -1 if (dividend < 0) ^ (divisor < 0) else 1 dividend = abs(dividend) divisor = abs(divisor) quotient = 0 remainder = dividend while remainder >= divisor: temp_divisor, multiples = divisor, 1 while remainder >= (temp_divisor << 1): temp_divisor <<= 1 multiples <<= 1 remainder -= temp_divisor quotient += multiples # Adjust quotient and remainder to original sign if sign == -1: quotient = -quotient return quotient, remainder"},{"question":"def countDistinctSubstrings(s: str, k: int) -> int: Given a string s and an integer k, finds the number of distinct substrings of length k in s. Return the answer modulo 10^9 + 7. >>> countDistinctSubstrings(\\"abcabc\\", 2) 3 >>> countDistinctSubstrings(\\"abacababa\\", 3) 5 >>> countDistinctSubstrings(\\"aaaa\\", 1) 1 >>> countDistinctSubstrings(\\"abc\\", 3) 1 >>> countDistinctSubstrings(\\"abcdef\\", 2) 5 >>> countDistinctSubstrings(\\"abacabadabacaba\\", 7) 8","solution":"def countDistinctSubstrings(s, k): MOD = 10**9 + 7 distinct_substrings = set() n = len(s) for i in range(n - k + 1): substring = s[i:i+k] distinct_substrings.add(substring) return len(distinct_substrings) % MOD"},{"question":"def longest_substring_with_k_distinct(k, s): Returns the length of the longest substring with at most k distinct characters. :param k: Number of distinct characters allowed in the substring. :param s: The input string. :return: Length of the longest substring with at most k distinct characters. >>> longest_substring_with_k_distinct(2, \\"abaccc\\") 4 >>> longest_substring_with_k_distinct(1, \\"aaaaa\\") 5 >>> longest_substring_with_k_distinct(1, \\"abc\\") 1 >>> longest_substring_with_k_distinct(1, \\"a\\") 1 >>> longest_substring_with_k_distinct(1, \\"\\") 0 >>> longest_substring_with_k_distinct(3, \\"abcabcbb\\") 8 >>> large_string = \\"a\\" * 50000 + \\"b\\" * 50000 >>> longest_substring_with_k_distinct(2, large_string) 100000 pass","solution":"def longest_substring_with_k_distinct(k, s): Returns the length of the longest substring with at most k distinct characters. :param k: Number of distinct characters allowed in the substring. :param s: The input string. :return: Length of the longest substring with at most k distinct characters. from collections import defaultdict n = len(s) if n * k == 0: return 0 left, right = 0, 0 max_length = 1 char_map = defaultdict(int) while right < n: char_map[s[right]] += 1 right += 1 while len(char_map) > k: char_map[s[left]] -= 1 if char_map[s[left]] == 0: del char_map[s[left]] left += 1 max_length = max(max_length, right - left) return max_length"},{"question":"def findZeroSumSubarray(nums: List[int]) -> List[int]: Returns the first subarray with a sum of 0 if any, otherwise an empty array. Args: nums (List[int]): List of integers. Returns: List[int]: The first subarray with sum zero or an empty list if no such subarray is found. Examples: >>> findZeroSumSubarray([1, 2, -3, 3, 4]) [1, 2, -3] >>> findZeroSumSubarray([-1, 1]) [-1, 1] >>> findZeroSumSubarray([1, 2, 3]) [] # Your code here","solution":"def findZeroSumSubarray(nums): Returns the first subarray with a sum of 0 if any, otherwise an empty array. prefix_sum = 0 prefix_sum_map = {} for i, num in enumerate(nums): prefix_sum += num if prefix_sum == 0: return nums[:i+1] if prefix_sum in prefix_sum_map: return nums[prefix_sum_map[prefix_sum] + 1:i + 1] prefix_sum_map[prefix_sum] = i return [] # Example usage print(findZeroSumSubarray([1, 2, -3, 3, 4])) # Output: [1, 2, -3] print(findZeroSumSubarray([-1, 1])) # Output: [-1, 1] print(findZeroSumSubarray([1, 2, 3])) # Output: []"},{"question":"def max_robbed_amount(n: int, houses: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police by using dynamic programming. >>> max_robbed_amount(4, [1, 2, 3, 1]) 4 >>> max_robbed_amount(5, [2, 7, 9, 3, 1]) 12 >>> max_robbed_amount(0, []) 0 >>> max_robbed_amount(1, [5]) 5 >>> max_robbed_amount(2, [1, 2]) 2 >>> max_robbed_amount(3, [999999999, 1, 999999999]) 1999999998 >>> n = 10**5 >>> houses = [1] * n >>> (n + 1) // 2 50000","solution":"def max_robbed_amount(n, houses): if n == 0: return 0 if n == 1: return houses[0] # Initialize the dp array where dp[i] means the maximum amount robbed till the i-th house. dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[n-1] if __name__ == \\"__main__\\": import sys input = sys.stdin.read() data = input.split() n = int(data[0]) houses = list(map(int, data[1:])) print(max_robbed_amount(n, houses))"},{"question":"def should_place_streetlight(m: int, n: int, k: int, intersections: List[Tuple[int, int]]) -> List[str]: Determine if streetlights should be placed at the given intersections based on boundary and parity conditions. :param m: Number of horizontal roads :param n: Number of vertical roads :param k: Number of requested intersections :param intersections: List of intersections represented by tuples (r, c) :return: List of \\"YES\\" or \\"NO\\" for each intersection based on the conditions >>> should_place_streetlight(4, 5, 3, [(1, 3), (3, 4), (2, 2)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> should_place_streetlight(3, 3, 5, [(1, 1), (1, 3), (3, 1), (3, 3), (2, 2)]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def should_place_streetlight(m, n, k, intersections): result = [] for r, c in intersections: if r == 1 or r == m or c == 1 or c == n or (r + c) % 2 == 0: result.append(\\"YES\\") else: result.append(\\"NO\\") return result # Define the function that handles the input and output def main(): import sys input = sys.stdin.read data = input().split() m = int(data[0]) n = int(data[1]) k = int(data[2]) intersections = [] index = 3 for _ in range(k): r = int(data[index]) c = int(data[index + 1]) intersections.append((r, c)) index += 2 results = should_place_streetlight(m, n, k, intersections) for result in results: print(result)"},{"question":"def create_mystic_eye(s: str) -> str: Generates a symmetric pattern with the \\"mystic eye\\" symbol in the center. Parameters: s (str): A string of arbitrary length containing numbers and uppercase letters. Returns: str: A string with the mystic eye symbol centered among a symmetric pattern. >>> create_mystic_eye('8YX9HT') \\"8YX9HT'--o--'TH9XY8\\" >>> create_mystic_eye('THX') \\"THX'--o--'XHT\\" >>> create_mystic_eye('abc') \\"'--o--'\\" >>> create_mystic_eye('123') \\"'--o--'\\" >>> create_mystic_eye('8YXa9ZHTb') \\"8YX9HT'--o--'TH9XY8\\" >>> create_mystic_eye('T5YXH') \\"TYXH'--o--'HXYT\\" >>> create_mystic_eye('') \\"'--o--'\\" >>> create_mystic_eye('a1b2c3') \\"'--o--'\\" pass # Your implementation goes here","solution":"def create_mystic_eye(s): Generates a symmetric pattern with the \\"mystic eye\\" symbol in the center. Parameters: s (str): A string of arbitrary length containing numbers and uppercase letters. Returns: str: A string with the mystic eye symbol centered among a symmetric pattern. valid_chars = {'8', '9', 'T', 'H', 'X', 'Y'} filtered_chars = [char for char in s if char in valid_chars] symmetric_part = ''.join(filtered_chars) return f\\"{symmetric_part}'--o--'{symmetric_part[::-1]}\\""},{"question":"def is_possible_to_balance_by_removing_one(string: str) -> str: Determine whether it's possible to make the string balanced by removing exactly one character. >>> is_possible_to_balance_by_removing_one(\\"ABBA\\") \\"NO\\" >>> is_possible_to_balance_by_removing_one(\\"AAB\\") \\"YES\\" >>> is_possible_to_balance_by_removing_one(\\"AA\\") \\"NO\\" >>> is_possible_to_balance_by_removing_one(\\"ABB\\") \\"YES\\" >>> is_possible_to_balance_by_removing_one(\\"AABB\\") \\"NO\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Process a number of test cases to determine if it's possible to make each string balanced by removing exactly one character. >>> process_test_cases(3, [\\"ABBA\\", \\"AAB\\", \\"AA\\"]) [\\"NO\\", \\"YES\\", \\"NO\\"] >>> process_test_cases(2, [\\"ABB\\", \\"BBAA\\"]) [\\"YES\\", \\"NO\\"] >>> process_test_cases(1, [\\"AAA\\"]) [\\"NO\\"]","solution":"def is_possible_to_balance_by_removing_one(string): Determine whether it's possible to make the string balanced by removing exactly one character. count_A = string.count('A') count_B = string.count('B') if abs(count_A - count_B) == 1: return \\"YES\\" else: return \\"NO\\" def process_test_cases(T, test_cases): results = [] for string in test_cases: result = is_possible_to_balance_by_removing_one(string) results.append(result) return results"},{"question":"def find_longest_peak(arr): Finds the length of the longest peak in the array. A peak is defined as a contiguous subarray A[i, ..., j] where: - A[i] < A[i+1] < ... < A[k] - A[k] > A[k+1] > ... > A[j] - And there exists some k with i < k < j Parameters: arr (List[int]): A list of integers representing student scores. Returns: int: The length of the longest peak in the array or 0 if there is no peak. >>> find_longest_peak([1, 3, 2, 4, 5, 3, 2, 8, 6, 5]) 5 >>> find_longest_peak([2, 1, 4, 7, 3, 2, 5]) 5 pass def process_test_cases(test_cases): Processes multiple test cases and returns the results for each test case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first element is the length of the array and the second element is the array of scores. Returns: List[int]: A list of integers denoting the length of the longest peak for each test case. >>> process_test_cases([(10, [1, 3, 2, 4, 5, 3, 2, 8, 6, 5]), (7, [2, 1, 4, 7, 3, 2, 5])]) [5, 5] pass from solution import process_test_cases, find_longest_peak def test_find_longest_peak(): assert find_longest_peak([1, 3, 2, 4, 5, 3, 2, 8, 6, 5]) == 5 assert find_longest_peak([2, 1, 4, 7, 3, 2, 5]) == 5 assert find_longest_peak([5, 4, 3, 2, 1]) == 0 assert find_longest_peak([1, 2, 3, 4, 5]) == 0 assert find_longest_peak([1, 2, 1, 2, 1, 2, 1]) == 3 assert find_longest_peak([1, 2, 3, 4, 3, 2, 1, 2, 3, 0]) == 7 def test_process_test_cases(): test_cases = [ (10, [1, 3, 2, 4, 5, 3, 2, 8, 6, 5]), (7, [2, 1, 4, 7, 3, 2, 5]) ] expected_outputs = [5, 5] assert process_test_cases(test_cases) == expected_outputs","solution":"def find_longest_peak(arr): Finds the length of the longest peak in the array. n = len(arr) if n < 3: return 0 longest_peak = 0 i = 1 while i <= n - 2: is_peak = arr[i - 1] < arr[i] > arr[i + 1] if not is_peak: i += 1 continue # Find the left boundary of the peak left = i - 2 while left >= 0 and arr[left] < arr[left + 1]: left -= 1 # Find the right boundary of the peak right = i + 2 while right < n and arr[right] < arr[right - 1]: right += 1 current_peak_length = right - left - 1 longest_peak = max(longest_peak, current_peak_length) i = right return longest_peak def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(find_longest_peak(arr)) return results"},{"question":"def is_symmetric_matrix(matrix): Determines if the given n x n matrix is symmetric. Args: matrix: a 2D list of integers representing the n x n matrix Returns: str: \\"YES\\" if the matrix is symmetric, \\"NO\\" otherwise Examples: >>> is_symmetric_matrix([ ... [1, 2, 3], ... [2, 4, 5], ... [3, 5, 6] ... ]) \\"YES\\" >>> is_symmetric_matrix([ ... [1, 2], ... [3, 4] ... ]) \\"NO\\" pass","solution":"def is_symmetric_matrix(matrix): Determines if the given n x n matrix is symmetric. Args: matrix: a 2D list of integers representing the n x n matrix Returns: str: \\"YES\\" if the matrix is symmetric, \\"NO\\" otherwise n = len(matrix) for i in range(n): for j in range(i, n): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\""},{"question":"def merge_and_find_kth(N: int, M: int, K: int, A: List[int], B: List[int]) -> int: Merges two sorted arrays A and B and finds the K-th smallest element in the merged array. If K is greater than the number of elements in the merged array, returns -1. >>> merge_and_find_kth(3, 4, 5, [2, 5, 8], [1, 3, 6, 9]) 6 >>> merge_and_find_kth(2, 2, 5, [7, 10], [3, 4]) -1 >>> merge_and_find_kth(3, 3, 4, [1, 3, 5], [2, 4, 6]) 4","solution":"def merge_and_find_kth(N, M, K, A, B): Merges two sorted arrays A and B and finds the K-th smallest element in the merged array. If K is greater than the number of elements in the merged array, returns -1. merged_array = sorted(A + B) if K > len(merged_array): return -1 else: return merged_array[K-1]"},{"question":"def draw_rectangle(M, N, top_left, bottom_right): Draw a rectangle on the canvas. Parameters: M (int): the number of rows in the canvas. N (int): the number of columns in the canvas. top_left (tuple): the coordinates (x1, y1) of the top-left corner of the rectangle. bottom_right (tuple): the coordinates (x2, y2) of the bottom-right corner of the rectangle. Returns: list: a 2D list representing the canvas with the rectangle drawn on it. pass # Your code will go here # Example tests def test_example_1(): result = draw_rectangle(5, 7, (1, 2), (3, 5)) expected = [ [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0] ] assert result == expected def test_example_2(): result = draw_rectangle(4, 4, (0, 0), (1, 1)) expected = [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert result == expected def test_invalid_rectangle(): result = draw_rectangle(4, 4, (2, 3), (1, 1)) expected = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert result == expected def test_rectangle_at_edge(): result = draw_rectangle(5, 5, (0, 0), (4, 4)) expected = [ [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1] ] assert result == expected def test_single_cell_rectangle(): result = draw_rectangle(3, 3, (1, 1), (1, 1)) expected = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert result == expected","solution":"def draw_rectangle(M, N, top_left, bottom_right): Draw a rectangle on the canvas. Parameters: M (int): the number of rows in the canvas. N (int): the number of columns in the canvas. top_left (tuple): the coordinates (x1, y1) of the top-left corner of the rectangle. bottom_right (tuple): the coordinates (x2, y2) of the bottom-right corner of the rectangle. Returns: list: a 2D list representing the canvas with the rectangle drawn on it. (x1, y1) = top_left (x2, y2) = bottom_right # Initial canvas with all zeros canvas = [[0 for _ in range(N)] for _ in range(M)] # Check for invalid coordinates of the rectangle if x1 > x2 or y1 > y2 or x1 < 0 or x1 >= M or x2 < 0 or x2 >= M or y1 < 0 or y1 >= N or y2 < 0 or y2 >= N: return canvas # Draw the rectangle for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): canvas[i][j] = 1 return canvas"},{"question":"def is_valid_parentheses(s: str) -> bool: Returns True if the string is a valid parentheses string, False otherwise. >>> is_valid_parentheses(\\"()\\") True >>> is_valid_parentheses(\\"([)]\\") False >>> is_valid_parentheses(\\"{[]}\\") True","solution":"def is_valid_parentheses(s: str) -> bool: Returns True if the string is a valid parentheses string, False otherwise. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"def min_moves(N, M, obstacles, start, end): Calculate the minimum number of moves required for the drone to reach the delivery point from the starting point while avoiding obstacles. :param N: Number of rows in the grid. :param M: Number of columns in the grid. :param obstacles: List of tuples representing obstacle coordinates. :param start: Tuple representing the starting coordinates (sx, sy). :param end: Tuple representing the delivery coordinates (dx, dy). :return: Minimum number of moves or -1 if unreachable. >>> min_moves(5, 5, [(1, 2), (3, 2), (2, 3)], (0, 0), (4, 4)) 8 >>> min_moves(3, 3, [], (1, 1), (2, 2)) 2 >>> min_moves(3, 3, [(1, 0), (0, 1)], (0, 0), (2, 2)) -1 >>> min_moves(3, 3, [], (0, 0), (0, 0)) 0 def solve(T, test_cases): Solve the problem for multiple test cases and return the results. :param T: Number of test cases. :param test_cases: List of dictionaries where each dictionary contains 'dimensions': (N, M, O), 'obstacles': List of tuples (r, c), 'start': (sx, sy), 'end': (dx, dy) :return: List of results for each test case. >>> solve(2, [{'dimensions': (5, 5, 3), 'obstacles': [(1, 2), (3, 2), (2, 3)], 'start': (0, 0), 'end': (4, 4)}, ... {'dimensions': (3, 3, 0), 'obstacles': [], 'start': (1, 1), 'end': (2, 2)}]) [8, 2] >>> solve(1, [{'dimensions': (3, 3, 2), 'obstacles': [(1, 0), (0, 1)], 'start': (0, 0), 'end': (2, 2)}]) [-1]","solution":"from collections import deque def min_moves(N, M, obstacles, start, end): Calculate the minimum number of moves required for the drone to reach the delivery point from the starting point while avoiding obstacles. :param N: Number of rows in the grid. :param M: Number of columns in the grid. :param obstacles: List of tuples representing obstacle coordinates. :param start: Tuple representing the starting coordinates (sx, sy). :param end: Tuple representing the delivery coordinates (dx, dy). :return: Minimum number of moves or -1 if unreachable. # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Grid initialization grid = [[0 for _ in range(M)] for _ in range(N)] # Marking the obstacles in the grid for r, c in obstacles: grid[r][c] = 1 # Starting BFS queue = deque([(start[0], start[1], 0)]) # (x, y, moves) visited = set() visited.add((start[0], start[1])) while queue: x, y, moves = queue.popleft() # Check if we have reached the destination if (x, y) == end: return moves # Exploring all 4 directions for dx, dy in directions: nx, ny = x + dx, y + dy # Check bounds and obstacles if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) # If the loop terminates without reaching the destination return -1 def solve(T, test_cases): results = [] for i in range(T): N, M, O = test_cases[i]['dimensions'] obstacles = test_cases[i]['obstacles'] start = test_cases[i]['start'] end = test_cases[i]['end'] results.append(min_moves(N, M, obstacles, start, end)) return results"},{"question":"def longest_up_sequence(s: str) -> int: Returns the length of the longest continuous sequence of 'U' in the provided string. :param s: str - A string consisting of characters 'U', 'D', 'L', 'R', separated by newline characters. :return: int - The length of the longest continuous sequence of 'U'. >>> longest_up_sequence(\\"UnUnDnUnUnUnDnU\\") == 3 >>> longest_up_sequence(\\"U\\") == 1 >>> longest_up_sequence(\\"DnDnLnR\\") == 0 >>> longest_up_sequence(\\"UnUnUnUnU\\") == 5 >>> longest_up_sequence(\\"DnDnLnUnUnU\\") == 3 >>> longest_up_sequence(\\"\\") == 0 >>> longest_up_sequence(\\"LnUnUnDnRnUnUnUnDnU\\") == 3","solution":"def longest_up_sequence(s): Returns the length of the longest continuous sequence of 'U' in the provided string. :param s: str - A string consisting of characters 'U', 'D', 'L', 'R', separated by newline characters. :return: int - The length of the longest continuous sequence of 'U'. moves = s.split('n') max_length = 0 current_length = 0 for move in moves: if move == 'U': current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def calculate_vote_percentages(C, votes): Calculates the percentage of votes each choice received. >>> calculate_vote_percentages(3, [50, 25, 25]) [\\"50.00%\\", \\"25.00%\\", \\"25.00%\\"] >>> calculate_vote_percentages(4, [0, 0, 0, 0]) [\\"0.00%\\", \\"0.00%\\", \\"0.00%\\", \\"0.00%\\"] >>> calculate_vote_percentages(2, [30, 70]) [\\"30.00%\\", \\"70.00%\\"]","solution":"def calculate_vote_percentages(C, votes): Calculates the percentage of votes each choice received. total_votes = sum(votes) if total_votes == 0: return [\\"0.00%\\" for _ in range(C)] percentages = [(vote / total_votes) * 100 for vote in votes] return [f\\"{percentage:.2f}%\\" for percentage in percentages]"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(n, edges, values): Build a binary tree from the given edges and values. pass def maximum_path_sum(root): Calculate the maximum path sum in the given binary tree. pass def find_max_sum_path(n, edges, values): Given a number of nodes, edges, and values of the tree, find the maximum sum path from any node to any node. >>> find_max_sum_path(5, [(1, 2), (1, 3), (3, 4), (3, 5)], [10, 2, 10, 20, 1]) 42 >>> find_max_sum_path(3, [(1, 2), (1, 3)], [5, 7, 8]) 20 pass # Unit Tests def test_example_1(): n = 5 edges = [(1, 2), (1, 3), (3, 4), (3, 5)] values = [10, 2, 10, 20, 1] assert find_max_sum_path(n, edges, values) == 42 def test_example_2(): n = 3 edges = [(1, 2), (1, 3)] values = [5, 7, 8] assert find_max_sum_path(n, edges, values) == 20 def test_single_node(): n = 1 edges = [] values = [10] assert find_max_sum_path(n, edges, values) == 10 def test_max_sum_in_left_subtree(): n = 4 edges = [(1, 2), (2, 3), (3, 4)] values = [1, 2, 3, 4] assert find_max_sum_path(n, edges, values) == 10 def test_max_sum_in_right_subtree(): n = 4 edges = [(1, 2), (2, 3), (2, 4)] values = [1, 2, 3, 4] assert find_max_sum_path(n, edges, values) == 9","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def build_tree(n, edges, values): if n == 0: return None nodes = [TreeNode(value) for value in values] from collections import defaultdict children = defaultdict(list) for u, v in edges: children[u-1].append(v-1) children[v-1].append(u-1) def build(node_idx, parent_idx): node = nodes[node_idx] for child_idx in children[node_idx]: if child_idx != parent_idx: if not node.left: node.left = build(child_idx, node_idx) else: node.right = build(child_idx, node_idx) return node root = build(0, -1) return root def maximum_path_sum(root): global_max = float('-inf') def helper(node): nonlocal global_max if not node: return 0 left_sum = helper(node.left) right_sum = helper(node.right) max_single_path = max(node.value, node.value + left_sum, node.value + right_sum) max_top_path = max(max_single_path, node.value + left_sum + right_sum) global_max = max(global_max, max_top_path) return max_single_path helper(root) return global_max def find_max_sum_path(n, edges, values): tree_root = build_tree(n, edges, values) return maximum_path_sum(tree_root)"},{"question":"def max_tasks_with_deadlines(n: int, tasks: List[Tuple[int, int]]) -> Tuple[int, List[int]]: Determine the maximum number of tasks Lena can complete without missing any deadlines and the sequence in which to complete them. >>> max_tasks_with_deadlines(4, [(3, 9), (2, 5), (1, 6), (5, 7)]) (3, [2, 3, 1]) >>> max_tasks_with_deadlines(1, [(5, 10)]) (1, [1]) >>> max_tasks_with_deadlines(3, [(2, 5), (2, 5), (2, 5)]) (2, [1, 2]) >>> max_tasks_with_deadlines(3, [(4, 5), (3, 4), (2, 3)]) (1, [3]) >>> max_tasks_with_deadlines(3, [(1000, 5000), (1000, 4000), (1000, 3000)]) (3, [3, 2, 1]) >>> max_tasks_with_deadlines(3, [(5, 4), (4, 3), (3, 2)]) (0, [])","solution":"def max_tasks_with_deadlines(n, tasks): # Sort the tasks primarily by their deadlines and secondarily by their durations tasks = sorted(enumerate(tasks), key=lambda x: (x[1][1], x[1][0])) current_time = 0 task_indices = [] count = 0 for index, (duration, deadline) in tasks: if current_time + duration <= deadline: task_indices.append(index + 1) current_time += duration count += 1 return count, task_indices"},{"question":"def char_count_string(s: str) -> str: Takes a single string argument and returns a new string created by adding each character from the original string, followed by the count of occurrences of that character up to that point in the string. >>> char_count_string(\\"hello\\") 'h1e1l1l2o1' >>> char_count_string(\\"aabb\\") 'a1a2b1b2' >>> char_count_string(\\"AaAa\\") 'A1a1A2a2' >>> char_count_string(\\"\\") '' >>> char_count_string(\\"x\\") 'x1' >>> char_count_string(\\"yyyyy\\") 'y1y2y3y4y5' >>> char_count_string(\\"!@!\\") '!1@1!2'","solution":"def char_count_string(s): Takes a single string argument and returns a new string created by adding each character from the original string, followed by the count of occurrences of that character up to that point in the string. count_dict = {} result = [] for char in s: if char not in count_dict: count_dict[char] = 1 else: count_dict[char] += 1 result.append(f\\"{char}{count_dict[char]}\\") return ''.join(result)"},{"question":"def has_three_consecutive_increasing_days(n: int, temperatures: List[int]) -> str: Determine whether there exists any subsequence of three consecutive days where the temperature increases consistently. Args: n (int): The number of days. temperatures (List[int]): The temperatures recorded on these days. Returns: str: \\"YES\\" if there exists a subsequence of three consecutive days with a consistent increase in temperature, otherwise \\"NO\\". >>> has_three_consecutive_increasing_days(5, [22, 23, 25, 24, 26]) \\"YES\\" >>> has_three_consecutive_increasing_days(4, [30, 29, 28, 27]) \\"NO\\"","solution":"def has_three_consecutive_increasing_days(n, temperatures): for i in range(n - 2): if temperatures[i] < temperatures[i + 1] < temperatures[i + 2]: return \\"YES\\" return \\"NO\\""},{"question":"def maximize_sum(T, test_cases): Marco has a list of N integers, and he wants to manipulate the list to make the sum of its elements as large as possible. He can perform exactly K operations where in each operation, he can either select one element and add 1 to it or select one element and subtract 1 from it. However, he cannot add or subtract from the same element more than once in consecutive operations. Args: T: int - the number of test cases. test_cases: List[Tuple[Tuple[int, int], List[int]]] - list containing the test cases Returns: List[int] - a list of maximum possible sums after exactly K operations for each test case. Sample Usage: >>> test_cases = [((3, 3), [1, -2, 3]), ((4, 2), [2, 1, -1, 5])] >>> maximize_sum(2, test_cases) [3, 10]","solution":"def maximize_sum(T, test_cases): results = [] for t in range(T): N, K = test_cases[t][0] arr = test_cases[t][1] arr.sort() for i in range(min(K, N)): if arr[i] < 0: arr[i] = -arr[i] else: break results.append(sum(arr)) return results"},{"question":"def max_pokemon_species(m, n, species_list): Determines the maximum number of different Pokemon species Sergey can catch. :param m: int - number of habitats :param n: int - maximum number of habitats Sergey can visit :param species_list: list of int - number of different species in each habitat :return: int - maximum number of different Pokemon species Sergey can catch >>> max_pokemon_species(5, 3, [8, 12, 7, 10, 15]) 37 >>> max_pokemon_species(4, 2, [5, 9, 6, 2]) 15 >>> max_pokemon_species(6, 4, [1, 2, 3, 4, 5, 6]) 18 >>> max_pokemon_species(3, 1, [10, 15, 5]) 15 >>> max_pokemon_species(7, 5, [4, 4, 4, 4, 4, 4, 4]) 20 >>> max_pokemon_species(5, 5, [7, 7, 7, 7, 7]) 35","solution":"def max_pokemon_species(m, n, species_list): Determines the maximum number of different Pokemon species Sergey can catch. :param m: int - number of habitats :param n: int - maximum number of habitats Sergey can visit :param species_list: list of int - number of different species in each habitat :return: int - maximum number of different Pokemon species Sergey can catch # Sort the species_list in descending order to get the most species per habitat sorted_species = sorted(species_list, reverse=True) # Sum the first n values (which represent the top n habitats with the most species) max_species = sum(sorted_species[:n]) return max_species # Example usage: m, n = 5, 3 species_list = [8, 12, 7, 10, 15] print(max_pokemon_species(m, n, species_list)) # Output: 37"},{"question":"from typing import List def count_paths_with_obstacles(grid: List[List[int]]) -> int: Given an \`n x n\` grid, a robot starts from the top-left corner (0,0) and needs to reach the bottom-right corner (n-1,n-1). The robot can only move either down or right at any point in time. However, some cells may contain obstacles, making them impassable. Return the number of unique paths that the robot can take to reach the bottom-right corner. A cell in the grid is marked as: - \`0\` if it is an empty cell, - \`1\` if it contains an obstacle. If the starting cell or the destination cell contains an obstacle, return \`0\` as no paths would be possible. >>> count_paths_with_obstacles([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths_with_obstacles([ ... [0, 1], ... [1, 0] ... ]) 0","solution":"from typing import List def count_paths_with_obstacles(grid: List[List[int]]) -> int: n = len(grid) # If the starting or ending point is obstructed, there's no valid path if grid[0][0] == 1 or grid[n-1][n-1] == 1: return 0 # Create a dp array dp = [[0] * n for _ in range(n)] # Initialize the starting point dp[0][0] = 1 # Fill the dp array for i in range(n): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] # The answer is in the bottom-right corner of the dp array return dp[n-1][n-1]"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def distinct_numbers(head: ListNode) -> ListNode: Given a linked list, remove all the nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. >>> head = build_linked_list([1, 2, 3, 3, 4, 4, 5]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) [1, 2, 5] >>> head = build_linked_list([1, 1, 1, 2, 3]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) [2, 3] >>> head = build_linked_list([1, 1, 2, 2, 3, 3]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) [] >>> head = build_linked_list([1, 2, 3]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) [1, 2, 3] >>> head = build_linked_list([1]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) [1] >>> head = build_linked_list([]) >>> result = distinct_numbers(head) >>> linked_list_to_list(result) []","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def distinct_numbers(head): if not head: return None # Counting the occurrence of each number node_counts = {} temp = head while temp: if temp.val in node_counts: node_counts[temp.val] += 1 else: node_counts[temp.val] = 1 temp = temp.next # Filter out the ones with duplicates values = [val for val, count in node_counts.items() if count == 1] if not values: return None # Sort the remaining distinct values values.sort() # Reconstruct the linked list with distinct values dummy_head = ListNode() current = dummy_head for val in values: current.next = ListNode(val) current = current.next return dummy_head.next"},{"question":"import math def game_winner(N: int, M: int) -> str: Determines the winner of the game given the number of stones in each pile. Parameters: N (int): The number of stones in the first pile. M (int): The number of stones in the second pile. Returns: str: \\"First\\" if the first player wins, otherwise \\"Second\\". >>> game_winner(5, 3) 'First' >>> game_winner(4, 6) 'Second'","solution":"import math def game_winner(N, M): Determines the winner of the game given the number of stones in each pile. Parameters: N (int): The number of stones in the first pile. M (int): The number of stones in the second pile. Returns: str: \\"First\\" if the first player wins, otherwise \\"Second\\". if math.gcd(N, M) == 1: return \\"First\\" else: return \\"Second\\""},{"question":"def min_cost_to_equalize_stacks(n: int, heights: List[int]) -> int: Determine the minimum cost required to make all stacks equal in height. >>> min_cost_to_equalize_stacks(4, [1, 2, 3, 4]) 2 >>> min_cost_to_equalize_stacks(3, [10, 10, 10]) 0 >>> min_cost_to_equalize_stacks(5, [5, 5, 5, 5, 5]) 0 from typing import List def test_sample_input_1(): assert min_cost_to_equalize_stacks(4, [1, 2, 3, 4]) == 2 def test_sample_input_2(): assert min_cost_to_equalize_stacks(3, [10, 10, 10]) == 0 def test_sample_input_3(): assert min_cost_to_equalize_stacks(5, [5, 5, 5, 5, 5]) == 0 def test_single_stack(): assert min_cost_to_equalize_stacks(1, [123]) == 0 def test_two_equal_stacks(): assert min_cost_to_equalize_stacks(2, [100, 100]) == 0 def test_two_unequal_stacks(): assert min_cost_to_equalize_stacks(2, [100, 50]) == 25 def test_varied_heights(): assert min_cost_to_equalize_stacks(5, [1, 3, 2, 2, 2]) == 1","solution":"def min_cost_to_equalize_stacks(n, heights): total_height = sum(heights) target_height = total_height // n cost = 0 for height in heights: cost += abs(height - target_height) return cost // 2 # Division by 2 as each move involves reducing one stack and increasing another"},{"question":"def canFormPalindrome(s: str) -> bool: Determines if the characters in the string \`s\` can be rearranged to form a palindromic string. A palindromic string reads the same backward as forward. For a valid palindromic string: - At most one character can have an odd frequency; - All other characters should have even frequencies. Args: s (str): The input string containing alphabets and digits. Returns: bool: True if the string can be rearranged to form a palindromic string, False otherwise. >>> canFormPalindrome(\\"aabbcc\\") True >>> canFormPalindrome(\\"aabbccd\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"AabbCCd\\") True","solution":"def canFormPalindrome(s: str) -> bool: Determines if the characters in the string \`s\` can be rearranged to form a palindromic string. from collections import Counter # Normalize the string to lower case for case insensitive comparison s = s.lower() # Create a frequency counter for characters in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 == 1) # For a valid palindrome, at most one character can have an odd frequency return odd_count <= 1"},{"question":"def can_form_number(jumbled_digits: List[str], number: int) -> bool: Check if the jumbled digits can be rearranged to form the given number. >>> can_form_number([\\"5\\", \\"2\\", \\"3\\", \\"1\\"], 1235) True >>> can_form_number([\\"3\\", \\"1\\", \\"4\\", \\"2\\"], 1235) False >>> can_form_number([\\"0\\", \\"1\\", \\"0\\"], 100) True >>> can_form_number([\\"0\\", \\"1\\"], 100) False >>> can_form_number([\\"1\\", \\"1\\", \\"1\\", \\"2\\", \\"2\\", \\"2\\"], 221211) True >>> can_form_number([\\"1\\", \\"2\\", \\"5\\", \\"3\\"], 123) False >>> can_form_number([\\"0\\", \\"1\\", \\"2\\", \\"3\\"], 12340) False >>> can_form_number([\\"4\\", \\"3\\", \\"2\\", \\"1\\"], 4321) True >>> can_form_number([\\"1\\", \\"2\\", \\"3\\", \\"4\\"], 4321) True >>> can_form_number([\\"5\\"], 5) True >>> can_form_number([\\"0\\"], 5) False >>> can_form_number([\\"2\\", \\"2\\", \\"2\\", \\"2\\"], 2222) True >>> can_form_number([\\"2\\", \\"2\\", \\"2\\"], 2222) False pass","solution":"def can_form_number(jumbled_digits, number): Check if the jumbled_digits can be rearranged to form the given number. Parameters: jumbled_digits (list of str): List of string digits. number (int): The target number. Returns: bool: True if jumbled_digits can form the number, False otherwise. # Convert the number to a sorted string number_str = sorted(str(number)) # Convert the list of jumbled_digits to a sorted list of digits jumbled_digits_sorted = sorted(jumbled_digits) # Compare the sorted versions return number_str == jumbled_digits_sorted"},{"question":"def reverse_sort(arr): Returns a new array with the integers sorted in descending order. >>> reverse_sort([34, 7, 23, 32, 5, 62]) [62, 34, 32, 23, 7, 5] >>> reverse_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]","solution":"def reverse_sort(arr): Returns a new array with the integers sorted in descending order. # Implementing the bubble sort algorithm but in reverse order n = len(arr) for i in range(n): for j in range(0, n-i-1): if arr[j] < arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] return arr"},{"question":"def min_operations_to_sort(n: int, heights: List[int]) -> int: Return the minimum number of moves required to sort the cow heights in non-decreasing order by moving one cow at a time to the beginning of the list. >>> min_operations_to_sort(5, [4, 3, 2, 6, 5]) 3 >>> min_operations_to_sort(6, [1, 2, 3, 4, 5, 6]) 0","solution":"def min_operations_to_sort(n, heights): Return the minimum number of moves required to sort the cow heights in non-decreasing order by moving one cow at a time to the beginning of the list. # Calculate the length of the longest non-decreasing subsequence ending at each position lis = [1] * n for i in range(1, n): for j in range(i): if heights[j] <= heights[i]: lis[i] = max(lis[i], lis[j] + 1) # Find the length of the longest non-decreasing subsequence longest_nondecreasing_subsequence = max(lis) # The minimum operations required is the number of cows minus the length of this subsequence return n - longest_nondecreasing_subsequence"},{"question":"def min_road_trip_cost(N, M, existing_roads, K, potential_roads): Compute the minimal total construction cost to travel from city 1 to visit all other cities and return to city 1. Parameters: N (int): Number of cities. M (int): Number of roads already present. existing_roads (list of tuples): Each tuple contains three integers representing two connected cities and the travel cost. K (int): Number of additional potential roads. potential_roads (list of tuples): Each tuple contains three integers representing two cities that can be connected and the construction cost of the road. Returns: int: The minimal total construction cost. If it is not possible to visit all cities, return -1. >>> min_road_trip_cost(4, 2, [(1, 2, 500), (3, 4, 600)], 2, [(1, 3, 200), (4, 2, 300)]) 1000 >>> min_road_trip_cost(3, 0, [], 1, [(1, 2, 1000)]) -1 # Your code here def test_min_road_trip_cost(): # Test case 1 N, M = 4, 2 existing_roads = [(1, 2, 500), (3, 4, 600)] K = 2 potential_roads = [(1, 3, 200), (4, 2, 300)] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == 1000 # Test case 2 N, M = 3, 0 existing_roads = [] K = 1 potential_roads = [(1, 2, 1000)] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == -1 # Test case 3 - connected graph with roads only N, M = 3, 3 existing_roads = [(1, 2, 10), (2, 3, 10), (3, 1, 10)] K = 0 potential_roads = [] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == 20 # Test case 4 - using potential roads to connect graph N, M = 4, 2 existing_roads = [(1, 2, 7), (3, 4, 6)] K = 2 potential_roads = [(1, 3, 2), (2, 4, 8)] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == 15 # Test case 5 - all cities already connected N, M = 3, 3 existing_roads = [(1, 2, 1), (2, 3, 1), (3, 1, 1)] K = 1 potential_roads = [(1, 3, 10)] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == 2 def test_min_road_trip_cost_additional_cases(): # Test case 6 - new case with minimal roads needed N, M = 5, 0 existing_roads = [] K = 10 potential_roads = [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 1, 10)] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == 4 # Test case 7 - disconnected graph with no potential roads N, M = 4, 2 existing_roads = [(1, 2, 10), (3, 4, 10)] K = 0 potential_roads = [] assert min_road_trip_cost(N, M, existing_roads, K, potential_roads) == -1","solution":"def min_road_trip_cost(N, M, existing_roads, K, potential_roads): import heapq def prims_minimum_spanning_tree(N, graph): min_cost = 0 edges_used = 0 min_heap = [(0, 1)] visited = set() while min_heap and len(visited) < N: cost, node = heapq.heappop(min_heap) if node in visited: continue visited.add(node) min_cost += cost edges_used += 1 for neighbour, weight in graph[node]: if neighbour not in visited: heapq.heappush(min_heap, (weight, neighbour)) if len(visited) == N: return min_cost else: return -1 graph = {i: [] for i in range(1, N + 1)} for u, v, w in existing_roads: graph[u].append((v, w)) graph[v].append((u, w)) for x, y, z in potential_roads: graph[x].append((y, z)) graph[y].append((x, z)) return prims_minimum_spanning_tree(N, graph) # Example usage and more complex test cases can be added in the unit tests."},{"question":"def fahrenheit_to_celsius(fahrenheit: float) -> float: Converts a temperature from Fahrenheit to Celsius and rounds to two decimal places. Args: fahrenheit (float): Temperature in Fahrenheit. Returns: float: Temperature in Celsius rounded to two decimal places. Examples: >>> fahrenheit_to_celsius(32) 0.0 >>> fahrenheit_to_celsius(100) 37.78 >>> fahrenheit_to_celsius(-40) -40.0 # Implement the function here def celsius_to_fahrenheit(celsius: float) -> float: Converts a temperature from Celsius to Fahrenheit and rounds to two decimal places. Args: celsius (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit rounded to two decimal places. Examples: >>> celsius_to_fahrenheit(0) 32.0 >>> celsius_to_fahrenheit(37.78) 100.0 >>> celsius_to_fahrenheit(-40) -40.0 # Implement the function here","solution":"def fahrenheit_to_celsius(fahrenheit): Converts a temperature from Fahrenheit to Celsius and rounds to two decimal places. Args: fahrenheit (float): Temperature in Fahrenheit. Returns: float: Temperature in Celsius rounded to two decimal places. celsius = (fahrenheit - 32) * 5.0 / 9.0 return round(celsius, 2) def celsius_to_fahrenheit(celsius): Converts a temperature from Celsius to Fahrenheit and rounds to two decimal places. Args: celsius (float): Temperature in Celsius. Returns: float: Temperature in Fahrenheit rounded to two decimal places. fahrenheit = celsius * 9.0 / 5.0 + 32 return round(fahrenheit, 2)"},{"question":"def rearrange_to_palindrome(n: int, s: str) -> str: Rearrange the characters of the string to form a palindrome if possible. If it is possible, output any one of them. If it is not possible, output \\"NO\\". >>> rearrange_to_palindrome(4, \\"aabb\\") \\"abba\\" >>> rearrange_to_palindrome(5, \\"abcde\\") \\"NO\\"","solution":"def rearrange_to_palindrome(n, s): from collections import Counter # Count the occurrences of each character char_count = Counter(s) # Check the number of characters with odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A palindrome can have at most one character with an odd count if odd_count > 1: return \\"NO\\" # Create half of the palindrome half_palindrome = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 == 0: half_palindrome.append(char * (count // 2)) else: half_palindrome.append(char * (count // 2)) middle_char = char * (count % 2) # Form the full palindrome half_palindrome = ''.join(half_palindrome) full_palindrome = half_palindrome + middle_char + half_palindrome[::-1] return full_palindrome"},{"question":"def can_rabbits_end_at_start(H: int) -> str: Determines if it's possible for rabbits to end up at the same elevation after H hops, considering that each hop is of equal size and can be either up or down. Parameters: H (int): total number of hops each rabbit makes Returns: str: 'YES' if it's possible, 'NO' otherwise >>> can_rabbits_end_at_start(4) 'YES' >>> can_rabbits_end_at_start(1) 'NO'","solution":"def can_rabbits_end_at_start(H): Determines if it's possible for rabbits to end up at the same elevation after H hops, considering that each hop is of equal size and can be either up or down. Parameters: H (int): total number of hops each rabbit makes Returns: str: 'YES' if it's possible, 'NO' otherwise # If H is even, it is possible to make equal number of hops up and down # If H is odd, it is not possible if H % 2 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def find_max_weight_in_mst(N: int, M: int, edges: List[Tuple[int, int, int]]) -> int: Finds the maximum weight of an edge in the Minimum Spanning Tree (MST) of the given graph. Each edge is represented by a tuple (u, v, w) where u and v are nodes and w is the weight of the edge. >>> find_max_weight_in_mst(4, 5, [(1, 2, 3), (1, 3, 1), (3, 2, 5), (4, 2, 4), (4, 3, 2)]) 3 >>> find_max_weight_in_mst(2, 1, [(1, 2, 1)]) 1 >>> find_max_weight_in_mst(4, 2, [(1, 2, 1), (3, 4, 2)]) 2 >>> find_max_weight_in_mst(3, 3, [(1, 2, 1000000), (2, 3, 999999), (1, 3, 1)]) 999999 >>> find_max_weight_in_mst(5, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) 4","solution":"def find_max_weight_in_mst(N, M, edges): Finds the maximum weight of an edge in the Minimum Spanning Tree (MST) of the given graph. Uses Kruskal's algorithm to find the MST. # First, Kruskal's algorithm function to find MST def kruskal(N, edges): # Sort the edges by weight edges.sort(key=lambda x: x[2]) # Union-Find data structure with path compression and union by rank parent = list(range(N)) rank = [0] * N def find(v): if parent[v] != v: parent[v] = find(parent[v]) return parent[v] def union(v1, v2): root1 = find(v1) root2 = find(v2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 mst_edges = [] max_weight = 0 for u, v, w in edges: root_u = find(u) root_v = find(v) if root_u != root_v: union(u, v) mst_edges.append((u, v, w)) max_weight = max(max_weight, w) return max_weight # Adjusting 0-based indexing for the graph edges adjusted_edges = [(u-1, v-1, w) for u, v, w in edges] return kruskal(N, adjusted_edges)"},{"question":"def count_higher_scores(participant_scores, jane_score): Returns the number of participants who scored higher than Jane. :param participant_scores: List of integers representing scores of participants :param jane_score: Integer representing Jane's score :return: Integer count of participants with scores higher than Jane's score >>> count_higher_scores([450, 400, 350, 300, 500], 420) 2 >>> count_higher_scores([700, 800, 750, 650], 680) 3 >>> count_higher_scores([100, 200, 300, 250, 400, 350], 500) 0 >>> count_higher_scores([], 500) 0 >>> count_higher_scores([100, 200, 300], 400) 0 >>> count_higher_scores([600, 700, 800], 500) 3 >>> count_higher_scores([500, 400, 300, 700, 200, 100, 600], 450) 3","solution":"def count_higher_scores(participant_scores, jane_score): Returns the number of participants who scored higher than Jane. :param participant_scores: List of integers representing scores of participants :param jane_score: Integer representing Jane's score :return: Integer count of participants with scores higher than Jane's score return sum(1 for score in participant_scores if score > jane_score)"},{"question":"def second_smallest(numbers): Returns the second smallest number in the list. If there is no second smallest number (e.g., if the list contains less than two unique numbers), the function should return None. >>> second_smallest([1, 2, 3, 4, 5]) 2 >>> second_smallest([5, 5, 5]) None >>> second_smallest([10, -1, 3, -1, 4, 5]) 3","solution":"def second_smallest(numbers): Returns the second smallest number in the list. If there is no second smallest number, returns None. unique_numbers = list(set(numbers)) # Get unique numbers if len(unique_numbers) < 2: return None # No second smallest number if less than 2 unique numbers unique_numbers.sort() return unique_numbers[1] # Return the second smallest number"},{"question":"def generate_mirrored_square(n: int) -> List[List[int]]: Generates a mirrored square of size n x n where the sum of elements in each row and each column is a non-prime number. >>> generate_mirrored_square(2) [[12, 11], [11, 12]] >>> generate_mirrored_square(3) [[12, 11, 11], [11, 12, 11], [11, 11, 12]] >>> generate_mirrored_square(4) [[12, 11, 11, 11], [11, 12, 11, 11], [11, 11, 12, 11], [11, 11, 11, 12]] pass def mirrored_squares(test_cases: List[int]) -> List[List[List[int]]]: Takes a list of test cases, each with a size 'n', and returns the generated mirrored squares for each case. >>> mirrored_squares([3, 4]) [[[12, 11, 11], [11, 12, 11], [11, 11, 12]], [[12, 11, 11, 11], [11, 12, 11, 11], [11, 11, 12, 11], [11, 11, 11, 12]]] pass","solution":"def generate_mirrored_square(n): Generates a mirrored square of size n x n where the sum of elements in each row and each column is a non-prime number. square = [[11] * n for _ in range(n)] for i in range(n): square[i][i] = 12 return square def mirrored_squares(test_cases): Takes a list of test cases, each with a size 'n', and returns the generated mirrored squares for each case. results = [] for n in test_cases: results.append(generate_mirrored_square(n)) return results"},{"question":"def longest_consecutive(nums): Finds the length of the longest subsequence of consecutive integers in an unsorted list. Example: >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([0, 3, 7, 2, 5, 8, 4, 6, 0, 1]) 9 >>> longest_consecutive([]) 0 >>> longest_consecutive([5]) 1 >>> longest_consecutive([1, 2]) 2 >>> longest_consecutive([1, 3]) 1 >>> longest_consecutive([1, 2, 2, 3, 4]) 4 >>> longest_consecutive([10, 10, 11, 11]) 2 >>> longest_consecutive([-2, -1, 0, 1, 2, 3, 4, -1, 5, 6]) 9","solution":"def longest_consecutive(nums): Finds the length of the longest subsequence of consecutive integers in an unsorted list. Params: - nums (List[int]): The input list of integers Returns: - int: The length of the longest subsequence of consecutive integers if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def min_operations_to_equal_elements(arr): Calculate the minimum number of operations needed to make all elements in the array equal. >>> min_operations_to_equal_elements([2, 3, 5]) 2 >>> min_operations_to_equal_elements([1, 1, 1, 1]) 0 def process_input(input_data): Process the input as per the provided format. >>> process_input(\\"2n3n2 3 5n4n1 1 1 1n\\") [2, 0] >>> process_input(\\"1n5n0 0 0 0 1n\\") [1] def min_operations(input_str): Main function to handle multiple test cases. >>> min_operations(\\"2n3n2 3 5n4n1 1 1 1n\\") \\"2n0\\" >>> min_operations(\\"1n5n0 0 0 0 1n\\") \\"1\\"","solution":"def min_operations_to_equal_elements(arr): Calculate the minimum number of operations needed to make all elements in the array equal. from collections import Counter frequency = Counter(arr) max_frequency = max(frequency.values()) return len(arr) - max_frequency def process_input(input_data): Process the input as per the provided format. lines = input_data.strip().split('n') T = int(lines[0]) index = 1 results = [] for _ in range(T): N = int(lines[index]) index += 1 A = list(map(int, lines[index].split())) index += 1 results.append(min_operations_to_equal_elements(A)) return results def min_operations(input_str): Main function to handle multiple test cases. results = process_input(input_str) return \\"n\\".join(map(str, results))"},{"question":"def max_difference(arr): Finds the maximum difference between any two elements such that the larger element appears after the smaller element. >>> max_difference([2, 3, 10, 6, 4, 8, 1]) 8 >>> max_difference([7, 9, 5, 6, 3, 2]) 2 >>> max_difference([5]) 0 >>> max_difference([]) 0 >>> max_difference([10, 9, 8, 7, 6]) 0 >>> max_difference([5, 5, 5, 5, 5]) 0 >>> max_difference([1, 2]) 1 >>> max_difference([2, 1]) 0","solution":"def max_difference(arr): Finds the maximum difference between any two elements such that the larger element appears after the smaller element. if len(arr) < 2: return 0 min_element = arr[0] max_diff = 0 for i in range(1, len(arr)): if arr[i] - min_element > max_diff: max_diff = arr[i] - min_element if arr[i] < min_element: min_element = arr[i] return max_diff"},{"question":"from typing import List, Tuple def rearrange_marbles(n: int, marbles: List[Tuple[int, str]]) -> List[Tuple[int, str]]: Rearranges the marbles according to the requirement that all marbles of the same color are grouped together and within each group, all marbles are arranged in non-decreasing order of their ids. :param n: The number of marbles :param marbles: List of tuples where each tuple contains an id and a color :return: Sorted list of tuples according to the requirements >>> rearrange_marbles(7, [(3, 'red'), (1, 'blue'), (2, 'red'), (4, 'blue'), (5, 'blue'), (6, 'yellow'), (2, 'yellow')]) [(1, 'blue'), (4, 'blue'), (5, 'blue'), (2, 'red'), (3, 'red'), (2, 'yellow'), (6, 'yellow')] >>> rearrange_marbles(3, [(3, 'red'), (1, 'red'), (2, 'red')]) [(1, 'red'), (2, 'red'), (3, 'red')]","solution":"def rearrange_marbles(n, marbles): Rearranges the marbles according to the requirement that all marbles of the same color are grouped together and within each group, all marbles are arranged in non-decreasing order of their ids. :param n: The number of marbles :param marbles: List of tuples where each tuple contains an id and a color :return: Sorted list of tuples according to the requirements from collections import defaultdict # Group marbles by color color_groups = defaultdict(list) for marble in marbles: color_groups[marble[1]].append(marble[0]) # Sort each group by id for color in color_groups: color_groups[color].sort() # Prepare the final sorted list sorted_marbles = [] for color in sorted(color_groups): for id in color_groups[color]: sorted_marbles.append((id, color)) return sorted_marbles # Example usage: # marbles = [(3, 'red'), (1, 'blue'), (2, 'red'), (4, 'blue'), (5, 'blue'), (6, 'yellow'), (2, 'yellow')] # print(rearrange_marbles(7, marbles))"},{"question":"def count_valid_pairs(N: int, X: int, A: list[int], B: list[int]) -> int: Counts the number of valid pairs such that A[i] + B[j] = X. Parameters: N (int): Number of elements in each array. X (int): The target sum. A (list of int): The array A of integers. B (list of int): The array B of integers. Returns: int: Number of valid pairs. >>> count_valid_pairs(3, 7, [1, 2, 3], [6, 5, 4]) 3 >>> count_valid_pairs(3, 10, [1, 2, 3], [4, 5, 6]) 0 >>> count_valid_pairs(4, 5, [1, 2, 3, 4], [4, 3, 2, 1]) 4 >>> count_valid_pairs(3, 1000000000, [500000000, 500000001, 500000002], [500000000, 499999999, 499999998]) 3 >>> count_valid_pairs(1, 0, [0], [0]) 1 >>> count_valid_pairs(1, 1, [0], [1]) 1 >>> count_valid_pairs(1, 2, [1], [1]) 1 >>> count_valid_pairs(1, 2, [0], [1]) 0","solution":"def count_valid_pairs(N, X, A, B): Counts the number of valid pairs such that A[i] + B[j] = X. Parameters: N (int): Number of elements in each array. X (int): The target sum. A (list of int): The array A of integers. B (list of int): The array B of integers. Returns: int: Number of valid pairs. count = 0 B_set = set(B) # Convert array B to a set for O(1) lookups. for a in A: if X - a in B_set: count += 1 return count"},{"question":"def subarray_sums(arr, queries): Returns the sum of subarrays for given queries. :param arr: List[int] - the array of integers :param queries: List[Tuple[int, int]] - list of tuples containing (l, r) indices for subarray sum :return: List[int] - list of sums for each query >>> subarray_sums([1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> subarray_sums([10], [(1, 1)]) [10] >>> subarray_sums([-1, -2, -3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [-6, 4, 3] >>> subarray_sums([1, 2, 3, 4, 5, 6], [(1, 2), (2, 4), (3, 6)]) [3, 9, 18]","solution":"def subarray_sums(arr, queries): Returns the sum of subarrays for given queries. :param arr: List[int] - the array of integers :param queries: List[Tuple[int, int]] - list of tuples containing (l, r) indices for subarray sum :return: List[int] - list of sums for each query n = len(arr) # Create a prefix sum array prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] # Calculate sums for each query results = [] for l, r in queries: results.append(prefix_sum[r] - prefix_sum[l - 1]) return results"},{"question":"def process_scores(scores_str): Process the list of scores and output the highest score, the lowest score, and the average score (rounded down). Args: scores_str (str): A space-separated string of integer scores. Returns: tuple: A tuple containing the highest score, the lowest score, and the average score (rounded down), in that order. Examples: >>> process_scores(\\"23 67 89 45 32 55 90 100 54 20\\") (100, 20, 57) >>> process_scores(\\"50 50 50 50\\") (50, 50, 50) >>> process_scores(\\"0 100 100 0 50\\") (100, 0, 50) >>> process_scores(\\"1\\") (1, 1, 1) >>> process_scores(\\"99 99 99 99\\") (99, 99, 99) >>> process_scores(\\"60 70 80\\") (80, 60, 70)","solution":"def process_scores(scores_str): Process the list of scores and output the highest score, the lowest score, and the average score (rounded down). Args: scores_str (str): A space-separated string of integer scores. Returns: tuple: A tuple containing the highest score, the lowest score, and the average score (rounded down), in that order. # Convert the input score string to a list of integers scores = list(map(int, scores_str.split())) # Find the highest score highest_score = max(scores) # Find the lowest score lowest_score = min(scores) # Calculate the average score (rounded down) average_score = sum(scores) // len(scores) return highest_score, lowest_score, average_score"},{"question":"def max_melody_score(k: int, melodies: List[Tuple[int, List[int]]]) -> List[int]: Calculate the maximum possible score for each melody based on the given scoring criteria. Args: k (int): The number of melodies. melodies (List[Tuple[int, List[int]]]): A list containing k tuples, each tuple contains an integer n and a list of n integers representing the frequencies of the notes in the melody. Returns: List[int]: A list of integers representing the maximum possible score for each melody. Examples: >>> max_melody_score(2, [(5, [1, 2, 3, 4, 5]), (4, [8, 3, 7, 6])]) [4, 5] >>> max_melody_score(3, [(3, [10, 10, 10]), (6, [2, 3, 8, 7, 6, 5]), (2, [1, 1000])]) [0, 6, 999]","solution":"def max_melody_score(k, melodies): results = [] for melody in melodies: n = melody[0] frequencies = melody[1] max_score = 0 for i in range(n): min_freq = frequencies[i] max_freq = frequencies[i] for j in range(i, n): min_freq = min(min_freq, frequencies[j]) max_freq = max(max_freq, frequencies[j]) max_score = max(max_score, max_freq - min_freq) results.append(max_score) return results"},{"question":"def max_fruits(n: int, k: int, sections: List[int]) -> int: Returns the maximum number of fruits found in any contiguous subarray of at least \`k\` sections. >>> max_fruits(5, 3, [2, 1, 4, 5, 3]) 12 >>> max_fruits(4, 2, [0, 0, 0, 0]) 0 >>> max_fruits(1, 1, [10]) 10 >>> max_fruits(5, 3, [1, 1, 1, 1, 1]) 3 >>> max_fruits(5, 2, [100, 200, 300, 400, 500]) 900","solution":"def max_fruits(n, k, sections): Returns the maximum number of fruits found in any contiguous subarray of at least \`k\` sections. max_fruits = 0 current_sum = 0 for i in range(n): current_sum += sections[i] if i >= k - 1: max_fruits = max(max_fruits, current_sum) current_sum -= sections[i - k + 1] return max_fruits"},{"question":"def hanoi(n, source, target, auxiliary): Prints the sequence of moves required to solve the Towers of Hanoi puzzle. Args: n (int): The number of disks. source (int): The starting rod. target (int): The destination rod. auxiliary (int): The auxiliary rod. Returns: None pass # Test Cases from solution import hanoi def test_hanoi_1_disk(capsys): hanoi(1, 1, 3, 2) captured = capsys.readouterr() assert captured.out == \\"1 3n\\" def test_hanoi_2_disks(capsys): hanoi(2, 1, 3, 2) captured = capsys.readouterr() expected_output = \\"1 2n1 3n2 3n\\" assert captured.out == expected_output def test_hanoi_3_disks(capsys): hanoi(3, 1, 3, 2) captured = capsys.readouterr() expected_output = \\"1 3n1 2n3 2n1 3n2 1n2 3n1 3n\\" assert captured.out == expected_output def test_hanoi_4_disks(capsys): hanoi(4, 1, 3, 2) captured = capsys.readouterr() expected_output = ( \\"1 2n1 3n2 3n1 2n3 1n3 2n1 2n\\" \\"1 3n2 3n2 1n3 1n2 3n1 2n1 3n2 3n\\" ) assert captured.out == expected_output","solution":"def hanoi(n, source, target, auxiliary): Prints the sequence of moves required to solve the Towers of Hanoi puzzle. Args: n (int): The number of disks. source (int): The starting rod. target (int): The destination rod. auxiliary (int): The auxiliary rod. Returns: None if n == 1: print(f\\"{source} {target}\\") return hanoi(n-1, source, auxiliary, target) print(f\\"{source} {target}\\") hanoi(n-1, auxiliary, target, source)"},{"question":"def is_balanced(n: int, s: str) -> str: Determines if a given string of brackets is balanced. >>> is_balanced(6, \\"(()())\\") 'YES' >>> is_balanced(8, \\"(()))(()\\") 'NO' >>> is_balanced(4, \\"(())\\") 'YES' >>> is_balanced(3, \\"(((\\") 'NO' >>> is_balanced(6, \\"())(()\\") 'NO' >>> is_balanced(5, \\"((((\\") 'NO' >>> is_balanced(5, \\"))))\\") 'NO'","solution":"def is_balanced(n, s): Determines if a given string of brackets is balanced. Parameters: n (int): Length of the string s (str): String consisting of '(' and ')' Returns: str: \\"YES\\" if the string is balanced, \\"NO\\" otherwise open_count = 0 for char in s: if char == '(': open_count += 1 elif char == ')': open_count -= 1 if open_count < 0: return \\"NO\\" return \\"YES\\" if open_count == 0 else \\"NO\\""},{"question":"def categorize_students_performance(students): Categorizes students into performance bands based on their average scores. Parameters: students (list of tuples): A list containing tuples in the format (name, math_score, science_score, english_score). Returns: list of tuples: A list containing tuples in the format (name, performance_band). pass def test_categorize_students_performance(): students = [ (\\"Alice\\", 80, 85, 90), (\\"Bob\\", 60, 60, 60), (\\"Charlie\\", 70, 75, 80), (\\"Dave\\", 90, 95, 85), (\\"Eva\\", 50, 50, 50), ] expected_output = [ (\\"Alice\\", \\"Good\\"), (\\"Bob\\", \\"Poor\\"), (\\"Charlie\\", \\"Average\\"), (\\"Dave\\", \\"Excellent\\"), (\\"Eva\\", \\"Fail\\"), ] assert categorize_students_performance(students) == expected_output def test_categorize_students_performance_all_excellent(): students = [ (\\"John\\", 90, 90, 90), (\\"Alice\\", 95, 93, 92), ] expected_output = [ (\\"John\\", \\"Excellent\\"), (\\"Alice\\", \\"Excellent\\"), ] assert categorize_students_performance(students) == expected_output def test_categorize_students_performance_no_students(): students = [] expected_output = [] assert categorize_students_performance(students) == expected_output def test_categorize_students_performance_mixed_bands(): students = [ (\\"Lily\\", 85, 89, 88), (\\"John\\", 72, 74, 75), (\\"Alice\\", 65, 68, 67), (\\"Bob\\", 55, 57, 56), (\\"Charlie\\", 100, 92, 95) ] expected_output = [ (\\"Lily\\", \\"Good\\"), (\\"John\\", \\"Average\\"), (\\"Alice\\", \\"Poor\\"), (\\"Bob\\", \\"Fail\\"), (\\"Charlie\\", \\"Excellent\\") ] assert categorize_students_performance(students) == expected_output","solution":"def categorize_students_performance(students): Categorizes students into performance bands based on their average scores. Parameters: students (list of tuples): A list containing tuples in the format (name, math_score, science_score, english_score). Returns: list of tuples: A list containing tuples in the format (name, performance_band). performance_bands = [] for student in students: name, math_score, science_score, english_score = student average_score = (math_score + science_score + english_score) / 3 if average_score >= 90: band = \\"Excellent\\" elif 80 <= average_score < 90: band = \\"Good\\" elif 70 <= average_score < 80: band = \\"Average\\" elif 60 <= average_score < 70: band = \\"Poor\\" else: band = \\"Fail\\" performance_bands.append((name, band)) return performance_bands"},{"question":"def sum_of_all_subarrays(n, arr): Returns the total sum of all subarrays for a given array of integers. Parameters: n (int): The size of the array. arr (List[int]): The elements of the array. Returns: int: The total sum of all subarrays. Example: >>> sum_of_all_subarrays(3, [1, 2, 3]) 20 >>> sum_of_all_subarrays(4, [1, -1, 1, -1]) 0 pass def sum_all_subarrays_for_test_cases(test_cases): Computes the sum of all subarrays for multiple test cases. Parameters: test_cases (List[Tuple[int, List[int]]]): The test cases where each test case is a tuple containing the size of the array and the array elements. Returns: List[int]: A list of results for each test case. Example: >>> sum_all_subarrays_for_test_cases([(3, [1, 2, 3]), (4, [1, -1, 1, -1])]) [20, 0] pass import pytest def test_sum_of_all_subarrays(): assert sum_of_all_subarrays(3, [1, 2, 3]) == 20 assert sum_of_all_subarrays(4, [1, -1, 1, -1]) == 0 def test_sum_of_all_subarrays_large(): assert sum_of_all_subarrays(5, [1, 2, 3, 4, 5]) == 105 assert sum_of_all_subarrays(5, [1, 1, 1, 1, 1]) == 35 def test_sum_all_subarrays_for_test_cases(): test_cases = [ (3, [1, 2, 3]), (4, [1, -1, 1, -1]) ] assert sum_all_subarrays_for_test_cases(test_cases) == [20, 0] def test_sum_all_subarrays_for_test_cases_large(): test_cases = [ (5, [1, 2, 3, 4, 5]), (5, [1, 1, 1, 1, 1]) ] assert sum_all_subarrays_for_test_cases(test_cases) == [105, 35]","solution":"def sum_of_all_subarrays(n, arr): Returns the total sum of all subarrays for a given array of integers. total_sum = 0 for i in range(n): total_sum += arr[i] * (i + 1) * (n - i) return total_sum def sum_all_subarrays_for_test_cases(test_cases): results = [] for case in test_cases: n, arr = case results.append(sum_of_all_subarrays(n, arr)) return results"},{"question":"def get_anti_diagonals(matrix): Extracts and returns all anti-diagonals of a given square matrix. Args: matrix (List[List[int]]): A square matrix of integers. Returns: List[List[int]]: A list of lists, where each list contains the elements of an anti-diagonal. Example: >>> get_anti_diagonals([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [1], [2, 4], [3, 5, 7], [6, 8], [9] ] N = len(matrix) anti_diagonals = [] # Upper triangle including main diagonal for col in range(N): row, col_start = 0, col anti_diagonal = [] while col_start >= 0: anti_diagonal.append(matrix[row][col_start]) row += 1 col_start -= 1 anti_diagonals.append(anti_diagonal) # Lower triangle excluding main diagonal for row in range(1, N): row_start, col = row, N - 1 anti_diagonal = [] while row_start < N: anti_diagonal.append(matrix[row_start][col]) row_start += 1 col -= 1 anti_diagonals.append(anti_diagonal) return anti_diagonals def main(): Reads input from stdin, processes each test case, and prints the results to stdout. Input format: The first line contains an integer T, the number of test cases. Each test case starts with an integer N, the size of the matrix (NxN). The next N lines of each test case contain N integers each, denoting the elements of the matrix. Output format: For each test case, prints all the anti-diagonals of the matrix. Each anti-diagonal's values should be printed in a new line, separated by a single space. Example: Input: 2 3 1 2 3 4 5 6 7 8 9 2 1 2 3 4 Output: 1 2 4 3 5 7 6 8 9 1 2 3 4 import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 results = [] for _ in range(T): N = int(data[index]) index += 1 matrix = [list(map(int, data[index + i*N : index + (i+1)*N])) for i in range(N)] index += N*N anti_diagonals = get_anti_diagonals(matrix) for line in anti_diagonals: results.append(' '.join(map(str, line))) sys.stdout.write('n'.join(results) + 'n') if __name__ == \\"__main__\\": main() def test_get_anti_diagonals(): matrix_1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected_1 = [ [1], [2, 4], [3, 5, 7], [6, 8], [9] ] assert get_anti_diagonals(matrix_1) == expected_1 matrix_2 = [ [1, 2], [3, 4] ] expected_2 = [ [1], [2, 3], [4] ] assert get_anti_diagonals(matrix_2) == expected_2 matrix_3 = [ [1] ] expected_3 = [ [1] ] assert get_anti_diagonals(matrix_3) == expected_3 from io import StringIO import sys def test_main(): input_data = \\"2n3n1 2 3n4 5 6n7 8 9n2n1 2n3 4n\\" expected_output = \\"1n2 4n3 5 7n6 8n9n1n2 3n4n\\" sys.stdin = StringIO(input_data) sys.stdout = StringIO() main() assert sys.stdout.getvalue() == expected_output input_data = \\"1n1n5n\\" expected_output = \\"5n\\" sys.stdin = StringIO(input_data) sys.stdout = StringIO() main() assert sys.stdout.getvalue() == expected_output input_data = \\"1n2n-1 0n10 -10n\\" expected_output = \\"-1n0 10n-10n\\" sys.stdin = StringIO(input_data) sys.stdout = StringIO() main() assert sys.stdout.getvalue() == expected_output","solution":"def get_anti_diagonals(matrix): N = len(matrix) anti_diagonals = [] # Upper triangle including main diagonal for col in range(N): row, col_start = 0, col anti_diagonal = [] while col_start >= 0: anti_diagonal.append(matrix[row][col_start]) row += 1 col_start -= 1 anti_diagonals.append(anti_diagonal) # Lower triangle excluding main diagonal for row in range(1, N): row_start, col = row, N - 1 anti_diagonal = [] while row_start < N: anti_diagonal.append(matrix[row_start][col]) row_start += 1 col -= 1 anti_diagonals.append(anti_diagonal) return anti_diagonals def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 results = [] for _ in range(T): N = int(data[index]) index += 1 matrix = [list(map(int, data[index + i*N : index + (i+1)*N])) for i in range(N)] index += N*N anti_diagonals = get_anti_diagonals(matrix) for line in anti_diagonals: results.append(' '.join(map(str, line))) sys.stdout.write('n'.join(results) + 'n') if __name__ == \\"__main__\\": main()"},{"question":"def generate_sequence(N: int) -> List[int]: Generates the sequence based on the given rules for an integer N. >>> generate_sequence(3) [1, 2, 4] >>> generate_sequence(5) [1, 2, 4, 7, 11] def sequence_for_cases(T: int, cases: List[int]) -> List[List[int]]: Returns the sequences for multiple test cases. >>> sequence_for_cases(2, [3, 5]) [[1, 2, 4], [1, 2, 4, 7, 11]] >>> sequence_for_cases(1, [1]) [[1]]","solution":"def generate_sequence(N): Generates the sequence based on the given rules for an integer N. sequence = [1] for i in range(1, N): next_number = sequence[-1] + i sequence.append(next_number) return sequence def sequence_for_cases(T, cases): Returns the sequences for multiple test cases. results = [] for N in cases: sequence = generate_sequence(N) results.append(sequence) return results"},{"question":"from typing import List def count_anagrams_in_substrings(s: str, queries: List[str]) -> List[int]: Counts the number of anagrams of each query present as substrings in the string s. Args: s (str): The string to search within. queries (List[str]): The list of query strings. Returns: List[int]: List of counts of anagrams for each query string. pass # You can test your implementation using the following test cases: def test_single_anagram(): s = \\"cbaebabacd\\" queries = [\\"abc\\"] assert count_anagrams_in_substrings(s, queries) == [2] def test_multiple_anagrams(): s = \\"cbaebabacd\\" queries = [\\"abc\\", \\"bca\\"] assert count_anagrams_in_substrings(s, queries) == [2, 2] def test_no_anagrams(): s = \\"abcdeffedcba\\" queries = [\\"fba\\", \\"aabb\\"] assert count_anagrams_in_substrings(s, queries) == [0, 0] def test_mixed_results(): s = \\"abcdeffedcba\\" queries = [\\"fba\\", \\"edc\\", \\"aabb\\"] assert count_anagrams_in_substrings(s, queries) == [0, 2, 0] def test_query_larger_than_string(): s = \\"abc\\" queries = [\\"abcd\\"] assert count_anagrams_in_substrings(s, queries) == [0] def test_single_char_queries(): s = \\"aaaaa\\" queries = [\\"a\\"] assert count_anagrams_in_substrings(s, queries) == [5] def test_full_match_query(): s = \\"abcdefg\\" queries = [\\"abcdefg\\"] assert count_anagrams_in_substrings(s, queries) == [1]","solution":"from collections import Counter def count_anagrams_in_substrings(s, queries): Counts the number of anagrams of each query present as substrings in the string s. Args: s (str): The string to search within. queries (List[str]): The list of query strings. Returns: List[int]: List of counts of anagrams for each query string. result = [] for q in queries: n, k = len(s), len(q) if k > n: result.append(0) continue q_counter = Counter(q) window_counter = Counter(s[:k-1]) count = 0 for i in range(k-1, n): window_counter[s[i]] += 1 if window_counter == q_counter: count += 1 window_counter[s[i - k + 1]] -= 1 if window_counter[s[i - k + 1]] == 0: del window_counter[s[i - k + 1]] result.append(count) return result # Example usage with input and output # s = \\"cbaebabacd\\" # queries = [\\"abc\\", \\"bca\\"] # print(count_anagrams_in_substrings(s, queries)) # Output: [2, 2]"},{"question":"from itertools import permutations def get_sorted_permutations(s: str) -> list: Given an input string, returns all the permutations of the string in lexicographically sorted order. >>> get_sorted_permutations(\\"ABC\\") ['ABC', 'ACB', 'BAC', 'BCA', 'CAB', 'CBA'] >>> get_sorted_permutations(\\"AB\\") ['AB', 'BA'] >>> get_sorted_permutations(\\"A\\") ['A'] >>> get_sorted_permutations(\\"\\") [''] >>> get_sorted_permutations(\\"123\\") ['123', '132', '213', '231', '312', '321'] >>> get_sorted_permutations(\\"A1\\") ['1A', 'A1']","solution":"from itertools import permutations def get_sorted_permutations(s): Given an input string, returns all the permutations of the string in lexicographically sorted order. return sorted([''.join(p) for p in permutations(s)])"},{"question":"def find_treasure_location(direction_string: str) -> tuple: Given a string containing directions (N, S, E, W) and distances which are interspersed with random characters, computes the final coordinates after following the directions and distances. Args: direction_string (str): The string containing directions and distances. Returns: tuple: A tuple of two integers representing the final coordinates (x, y). >>> find_treasure_location(\\"H3ll5oWor1dN10S4E2\\") (2, 6) >>> find_treasure_location(\\"S10W20\\") (-20, -10) >>> find_treasure_location(\\"N5S3E7W2\\") (5, 2) >>> find_treasure_location(\\"X1N2Y3E1Z4S1X1W1N5M3\\") (0, 6) >>> find_treasure_location(\\"N05S03E02W01\\") (1, 2)","solution":"import re def find_treasure_location(direction_string): Given a string containing directions (N, S, E, W) and distances which are interspersed with random characters, computes the final coordinates after following the directions and distances. Args: direction_string (str): The string containing directions and distances. Returns: tuple: A tuple of two integers representing the final coordinates (x, y). x, y = 0, 0 # Find all occurrences of direction followed by number pattern = re.compile(r'([NSEW])(-?d+)') matches = pattern.findall(direction_string) # Process each match for direction, distance in matches: distance = int(distance) if direction == 'N': y += distance elif direction == 'S': y -= distance elif direction == 'E': x += distance elif direction == 'W': x -= distance return (x, y)"},{"question":"def replace_spaces_with_underscores(input_string: str) -> str: Takes a string containing lowercase letters and space characters. Returns a new string with all spaces replaced by underscores. >>> replace_spaces_with_underscores('hello') == 'hello' >>> replace_spaces_with_underscores('hello world') == 'hello_world' >>> replace_spaces_with_underscores('a b c d e f') == 'a_b_c_d_e_f' >>> replace_spaces_with_underscores(' hello world ') == '_hello_world_' >>> replace_spaces_with_underscores(' ') == '_____'","solution":"def replace_spaces_with_underscores(input_string): Takes a string containing lowercase letters and space characters. Returns a new string with all spaces replaced by underscores. return input_string.replace(' ', '_')"},{"question":"def two_sum(nums: List[int], target: int) -> List[int]: Determine if there are two distinct indices i and j in the list such that nums[i] + nums[j] == target. >>> two_sum([2, 7, 11, 15], 9) [0, 1] >>> two_sum([3, 2, 4], 6) [1, 2] >>> two_sum([1, 2, 3, 4, 5], 10) [] >>> two_sum([-1, -2, -3, -4, -5], -8) [2, 4] >>> two_sum([0, 4, 3, 0], 0) [0, 3] >>> two_sum([1000000000, 1000000001, 1000000002, 1000000003], 2000000001) [0, 1]","solution":"def two_sum(nums, target): Returns the indices of the two numbers in the list that add up to the target. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return [seen[complement], i] seen[num] = i return [] # Example usage # nums = [2, 7, 11, 15], target = 9 # print(two_sum(nums, target)) # should return [0, 1]"},{"question":"def can_robot_reach_end(t: int, test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[str]: Determine whether the robot can reach the end position from the start position using any valid sequence of movements, including teleportations. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[str]]]]): List containing the number of rows, columns and the grid for each test case. Returns: List[str]: \\"YES\\" if the robot can reach the end position, \\"NO\\" otherwise. >>> can_robot_reach_end(3, [ (5, 5, [ \\".....\\", \\".S#.T\\", \\"..#\\", \\"T.#.E\\", \\".....\\" ]), (2, 3, [ \\"S#E\\", \\"#\\" ]), (3, 4, [ \\"S..B\\", \\"..#.\\", \\"B..E\\" ]) ]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_robot_reach_end(1, [ (3, 3, [ \\"S#E\\", \\"#.#\\", \\"...\\" ]) ]) [\\"NO\\"] >>> can_robot_reach_end(1, [ (3, 3, [ \\"S..\\", \\"..#\\", \\"..E\\" ]) ]) [\\"YES\\"] >>> can_robot_reach_end(1, [ (3, 3, [ \\"S.T\\", \\"#.#\\", \\"T.E\\" ]) ]) [\\"YES\\"] pass def parse_input(input_string: str) -> Tuple[int, List[Tuple[int, int, List[List[str]]]]]: Parse input string to extract the number of test cases and the grid for each test case Args: input_string (str): The input string containing the number of test cases and the grid for each test case Returns: Tuple[int, List[Tuple[int, int, List[List[str]]]]]: The number of test cases and a list containing the grid for each test case. pass","solution":"def can_robot_reach_end(t, test_cases): from collections import deque results = [] for case in test_cases: n, m, grid = case start = None end = None teleporters = {} for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) if grid[i][j] == 'E': end = (i, j) if grid[i][j].isalpha() and grid[i][j] != 'S' and grid[i][j] != 'E': teleporter_type = grid[i][j] if teleporter_type not in teleporters: teleporters[teleporter_type] = [] teleporters[teleporter_type].append((i, j)) visited = [[False] * m for _ in range(n)] queue = deque([start]) visited[start[0]][start[1]] = True while queue: x, y = queue.popleft() if (x, y) == end: results.append(\\"YES\\") break directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] != '#': visited[nx][ny] = True queue.append((nx, ny)) if grid[x][y].isalpha() and grid[x][y] != 'S' and grid[x][y] != 'E': for tx, ty in teleporters[grid[x][y]]: if not visited[tx][ty]: visited[tx][ty] = True queue.append((tx, ty)) else: results.append(\\"NO\\") return results # Input parsing function def parse_input(input_string): lines = input_string.strip().split('n') t = int(lines[0].strip()) test_cases = [] idx = 1 for _ in range(t): n, m = map(int, lines[idx].strip().split()) grid = [list(lines[idx + 1 + i].strip()) for i in range(n)] test_cases.append((n, m, grid)) idx += 1 + n return t, test_cases"},{"question":"def maximize_sum_of_differences(N: int, skills: List[int]) -> int: Maximize the sum of the differences in skill levels for the optimal pairings. Each duel consists of one robot with a certain skill level dueling another robot with an equal or higher skill level. Ensure the sum of these differences is maximized. >>> maximize_sum_of_differences(4, [1, 3, 5, 9]) 10 >>> maximize_sum_of_differences(2, [1, 2]) 1 >>> maximize_sum_of_differences(50, list(range(1, 51))) 625 >>> maximize_sum_of_differences(4, [5, 5, 5, 5]) 0 >>> maximize_sum_of_differences(6, [1, 2, 3, 4, 5, 6]) 9 >>> maximize_sum_of_differences(6, [6, 5, 4, 3, 2, 1]) 9 >>> maximize_sum_of_differences(4, [0, 0, 1, 1]) 2","solution":"def maximize_sum_of_differences(N, skills): skills.sort() sum_differences = 0 for i in range(N // 2): sum_differences += skills[N - 1 - i] - skills[i] return sum_differences"},{"question":"from typing import List def min_subarray_length(numbers: List[int], target: int) -> int: Write a function that takes a list of non-negative integers and a target sum as input, and finds the minimum length of a subarray that adds up to the target sum. If no such subarray exists, return -1. Args: numbers (List[int]): A list of non-negative integers. target (int): A non-negative integer representing the target sum. Returns: int: The minimum length of the subarray that adds up to the target, or -1 if no such subarray exists. >>> min_subarray_length([2, 3, 1, 2, 4, 3], 7) 2 >>> min_subarray_length([1, 4, 4], 4) 1 >>> min_subarray_length([1, 1, 1, 1, 1, 1, 1, 1], 11) -1 pass","solution":"from typing import List def min_subarray_length(numbers: List[int], target: int) -> int: n = len(numbers) min_length = float('inf') start = 0 current_sum = 0 for end in range(n): current_sum += numbers[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= numbers[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def min_operations_to_beautiful(n, s): Returns the minimum number of operations needed to make the string beautiful. A string is considered beautiful if no two adjacent characters are the same. In one operation, you can replace any character in the string with any other lowercase English letter. -----Input----- The first line contains an integer n (1 ≤ n ≤ 1000) — the length of the string. The second line contains the string of length n consisting of lowercase English letters. -----Output----- Print the minimum number of operations needed to make the string beautiful. >>> min_operations_to_beautiful(5, \\"aabbc\\") 2 >>> min_operations_to_beautiful(4, \\"aaaa\\") 3 >>> min_operations_to_beautiful(3, \\"abc\\") 0 >>> min_operations_to_beautiful(2, \\"ab\\") 0 >>> min_operations_to_beautiful(5, \\"ababab\\") 0 >>> min_operations_to_beautiful(3, \\"abb\\") 1 >>> min_operations_to_beautiful(6, \\"aabbcc\\") 3","solution":"def min_operations_to_beautiful(n, s): Returns the minimum number of operations needed to make the string beautiful. operations = 0 for i in range(1, n): if s[i] == s[i - 1]: operations += 1 return operations # Example usage: n = 5 s = \\"aabbc\\" print(min_operations_to_beautiful(n, s)) # Output: 2"},{"question":"from typing import List MOD = 10**9 + 7 def count_binary_palindromes(n: int) -> int: Count the number of possible binary palindromes of length n. >>> count_binary_palindromes(3) 2 >>> count_binary_palindromes(4) 4 pass def solve(test_cases: List[int]) -> List[int]: For each test case, output the number of binary palindromes of length n modulo 10^9 + 7. >>> solve([3, 4]) [2, 4] >>> solve([5, 6]) [8, 8] pass","solution":"MOD = 10**9 + 7 def count_binary_palindromes(n): if n % 2 == 0: k = n // 2 else: k = (n // 2) + 1 return pow(2, k, MOD) def solve(test_cases): results = [] for n in test_cases: results.append(count_binary_palindromes(n)) return results # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() t = int(data[0]) test_cases = [int(data[i]) for i in range(1, t + 1)] results = solve(test_cases) for res in results: print(res)"},{"question":"def get_employees_with_completed_projects(n: int, employee_records: List[str]) -> List[str]: Reads a record of employees with their names, IDs, and a list of pairs (project name and hours spent). Outputs the names of employees who have completed at least one project. Args: n: int - the number of employees. employee_records: List[str] - a list containing each employee's record as a string. Returns: List[str] - a list of employee names who have completed at least one project. >>> get_employees_with_completed_projects(1, [\\"Alice 123 2 projectA 112 projectB 90\\"]) ['Alice'] >>> get_employees_with_completed_projects(1, [\\"Bob 456 1 training 82\\"]) [] >>> get_employees_with_completed_projects(3, [\\"Alice 123 2 projectA 112 projectB 90\\", \\"Bob 456 1 training 82\\", \\"Charlie 789 3 develop 110 maintain 120 research 65\\"]) ['Alice', 'Charlie'] >>> get_employees_with_completed_projects(2, [\\"Alice 123 2 projectA 115 projectB 101\\", \\"Charlie 789 3 develop 110 maintain 120 research 105\\"]) ['Alice', 'Charlie'] >>> get_employees_with_completed_projects(2, [\\"Bob 456 1 training 82\\", \\"Daisy 342 2 admin 75 support 95\\"]) []","solution":"def get_employees_with_completed_projects(n, employee_records): completed_employees = [] for record in employee_records: parts = record.split() name = parts[0] # The employee ID is parts[1], which we do not use further num_projects = int(parts[2]) projects = parts[3:] for i in range(num_projects): project_name = projects[2 * i] hours_spent = int(projects[2 * i + 1]) if hours_spent > 100: completed_employees.append(name) break return completed_employees"},{"question":"import heapq from typing import List, Tuple, Union def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]], s: int) -> List[Union[int, str]]: Calculate the shortest path from a given starting vertex to all other vertices in a weighted, directed graph. Args: n (int): Number of vertices in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as a tuple (u, v, w) indicating there is an edge from vertex u to vertex v with weight w. s (int): The starting vertex. Returns: List[Union[int, str]]: The shortest path from vertex s to vertex i, or \\"INF\\" if not reachable. >>> shortest_path(5, 8, [(1, 2, 3), (1, 3, 8), (1, 5, 5), (2, 4, 2), (3, 5, 2), (4, 3, 7), (4, 5, 4), (5, 2, 1)], 1) [0, 3, 8, 5, 5] >>> shortest_path(1, 0, [], 1) [0] >>> shortest_path(4, 2, [(1, 2, 2), (3, 4, 3)], 1) [0, 2, 'INF', 'INF'] >>> shortest_path(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 4)], 1) [0, 1, 2]","solution":"import heapq def shortest_path(n, m, edges, s): graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_dist, current_vertex = heapq.heappop(priority_queue) if current_dist > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [dist if dist != float('inf') else 'INF' for dist in distances.values()]"},{"question":"def sumOfPrimes(N: int) -> int: Returns the sum of all prime numbers up to and including N. >>> sumOfPrimes(10) == 17 >>> sumOfPrimes(20) == 77 >>> sumOfPrimes(2) == 2 >>> sumOfPrimes(1) == 0 >>> sumOfPrimes(21) == 77 >>> sumOfPrimes(1000) == 76127","solution":"def sumOfPrimes(N): Returns the sum of all prime numbers up to and including N. if N < 2: return 0 primes = [True] * (N + 1) primes[0], primes[1] = False, False for p in range(2, int(N**0.5) + 1): if primes[p]: for multiple in range(p*p, N + 1, p): primes[multiple] = False return sum(i for i, is_prime in enumerate(primes) if is_prime)"},{"question":"def calculate_final_amounts(M: int, K: int, discount_brackets: List[Tuple[int, int]], purchases: List[int]) -> List[int]: Calculate the final amounts each customer has to pay after applying the maximum discount they are eligible for. Args: M (int): Number of price brackets. K (int): Number of customers. discount_brackets (list of tuples): Each tuple contains (min_purchase_amount, discount_amount). purchases (list of int): Purchase amounts of different customers. Returns: list of int: Final amounts each customer has to pay. >>> calculate_final_amounts(3, 4, [(5000, 500), (10000, 1200), (20000, 3000)], [8000, 15000, 22000, 4000]) [7500, 13800, 19000, 4000] >>> calculate_final_amounts(3, 3, [(100000, 1000), (200000, 3000), (300000, 5000)], [10000, 20000, 5000]) [10000, 20000, 5000] >>> calculate_final_amounts(2, 3, [(100, 10), (50, 5)], [150, 75, 100]) [140, 70, 90] >>> calculate_final_amounts(2, 3, [(5000, 500), (20000, 3000)], [8000, 5000, 25000]) [7500, 4500, 22000] >>> calculate_final_amounts(1, 1, [(1, 100)], [10**7]) [9999900]","solution":"def calculate_final_amounts(M, K, discount_brackets, purchases): Calculate the final amounts each customer has to pay after applying the maximum discount they are eligible for. Args: M (int): Number of price brackets. K (int): Number of customers. discount_brackets (list of tuples): Each tuple contains (min_purchase_amount, discount_amount). purchases (list of int): Purchase amounts of different customers. Returns: list of int: Final amounts each customer has to pay. discount_brackets.sort(reverse=True) # Sort brackets by min purchase amount in descending order final_amounts = [] for purchase in purchases: final_amount = purchase for min_purchase, discount in discount_brackets: if purchase >= min_purchase: final_amount = purchase - discount break final_amounts.append(final_amount) return final_amounts"},{"question":"from typing import List, Tuple def min_processing_time(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of minutes required to process all jobs if jobs are assigned optimally. Parameters: t: The number of test cases. test_cases: A list containing a tuple where the first element is a tuple of two integers, n (number of modules) and m (number of jobs), and the second element is a list of m integers representing job types. Returns: A list of integers representing the minimum number of minutes required to process all jobs for each test case. >>> min_processing_time(2, [((2, 4), [1, 2, 1, 3]), ((3, 5), [1, 2, 3, 1, 2])]) [2, 2] >>> min_processing_time(1, [((1, 3), [1, 1, 1])]) [3] pass","solution":"from collections import Counter def min_processing_time(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][0] jobs = test_cases[i][1] job_counter = Counter(jobs) job_frequencies = list(job_counter.values()) # Sort the frequencies in descending order job_frequencies.sort(reverse=True) time = 0 while job_frequencies: time += 1 for j in range(n): if job_frequencies: job_frequencies[0] -= 1 if job_frequencies[0] == 0: job_frequencies.pop(0) job_frequencies.sort(reverse=True) results.append(time) return results"},{"question":"def longest_arithmetic_subarray(arr): Returns the length of the longest arithmetic sub-array in a given list of positive integers. >>> longest_arithmetic_subarray([1, 3, 5, 7, 9, 2, 4, 6, 8, 10]) == 5 >>> longest_arithmetic_subarray([10, 7, 4, 6, 8, 12, 8, 4]) == 3 >>> longest_arithmetic_subarray([3, 3, 3, 3]) == 4 >>> longest_arithmetic_subarray([1, 2, 3, 8, 9, 10, 13, 14, 16]) == 3 >>> longest_arithmetic_subarray([1]) == 1 >>> longest_arithmetic_subarray([1, 2]) == 2","solution":"def longest_arithmetic_subarray(arr): Returns the length of the longest arithmetic sub-array in a given list of positive integers. if len(arr) < 2: return len(arr) max_len = 2 current_len = 2 current_diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] == current_diff: current_len += 1 else: current_diff = arr[i] - arr[i - 1] current_len = 2 max_len = max(max_len, current_len) return max_len"},{"question":"def count_arithmetic_sequences(nums: List[int]) -> int: Return the number of sequences (of length at least 3) in the array that form an arithmetic progression. >>> count_arithmetic_sequences([1, 2, 3, 4]) 3 >>> count_arithmetic_sequences([1, 3, 5, 7, 9]) 6 >>> count_arithmetic_sequences([1, 2, 4]) 0 >>> count_arithmetic_sequences([5, 10, 15]) 1 >>> count_arithmetic_sequences([7, 7, 7, 7, 7]) 6 >>> count_arithmetic_sequences([-1, -4, -7, -10]) 3","solution":"def count_arithmetic_sequences(nums): count = 0 n = len(nums) if n < 3: return 0 for i in range(n - 2): for j in range(i + 2, n): diff = nums[i + 1] - nums[i] k = i + 1 valid_sequence = True for l in range(i + 1, j): if nums[l + 1] - nums[l] != diff: valid_sequence = False break if valid_sequence: count += 1 return count"},{"question":"def sumLargestSmallest(s: str) -> int: Returns the sum of the largest and smallest integers in the string. >>> sumLargestSmallest(\\"4 2 -7 5 3\\") -2 >>> sumLargestSmallest(\\"10 20 30 40 50\\") 60 >>> sumLargestSmallest(\\"-1 -2 -3 -4 -5\\") -6 >>> sumLargestSmallest(\\"1 -100 50 0 -50 100\\") 0 >>> sumLargestSmallest(\\"42\\") 84 >>> sumLargestSmallest(\\"5 8\\") 13 >>> sumLargestSmallest(\\"5 -5\\") 0 >>> sumLargestSmallest(\\"100000 -100000\\") 0","solution":"def sumLargestSmallest(s): Returns the sum of the largest and smallest integers in the string. numbers = list(map(int, s.split())) return min(numbers) + max(numbers)"},{"question":"from typing import List def product_except_self(nums: List[int]) -> List[int]: Return an array where each element is the product of all the elements in the input array except the one at the current position. >>> product_except_self([1, 2, 3]) [6, 3, 2] >>> product_except_self([2, 3, 4, 5]) [60, 40, 30, 24] def solve_product_arrays(test_cases: List[List[int]]) -> List[List[int]]: Solve multiple test cases of the product_except_self function. >>> solve_product_arrays([[1, 2, 3], [2, 3, 4, 5]]) [[6, 3, 2], [60, 40, 30, 24]] >>> solve_product_arrays([[1, 2], [3, 4, 5]]) [[2, 1], [20, 15, 12]] def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): n = int(data[index]) array = list(map(int, data[index + 1: index + 1 + n])) test_cases.append(array) index += n + 1 results = solve_product_arrays(test_cases) for result in results: print(\\" \\".join(map(str, result))) if __name__ == \\"__main__\\": main()","solution":"def product_except_self(nums): n = len(nums) left_products = [1] * n right_products = [1] * n result = [1] * n for i in range(1, n): left_products[i] = left_products[i - 1] * nums[i - 1] for i in range(n - 2, -1, -1): right_products[i] = right_products[i + 1] * nums[i + 1] for i in range(n): result[i] = left_products[i] * right_products[i] return result def solve_product_arrays(test_cases): results = [] for case in test_cases: results.append(product_except_self(case)) return results"},{"question":"from typing import List def shortest_path_length(R: int, C: int, grid: List[str]) -> int: Given a grid with R rows and C columns, find the length of the shortest path from the top-left corner to the bottom-right corner, avoiding walls ('#'). >>> shortest_path_length(5, 5, [ ... '.....', ... '.#.', ... '.....', ... '.#.', ... '.....' ... ]) 8 >>> shortest_path_length(3, 3, [ ... '...', ... '#', ... '...' ... ]) -1 >>> shortest_path_length(1, 5, ['.....']) 4 >>> shortest_path_length(5, 1, [ ... '.', ... '.', ... '.', ... '.', ... '.' ... ]) 4 >>> shortest_path_length(2, 2, [ ... '..', ... '..' ... ]) 2","solution":"from collections import deque def shortest_path_length(R, C, grid): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] start = (0, 0) end = (R-1, C-1) queue = deque([(start, 0)]) visited = set([start]) while queue: (current_row, current_col), dist = queue.popleft() if (current_row, current_col) == end: return dist for dr, dc in directions: nr, nc = current_row + dr, current_col + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': visited.add((nr, nc)) queue.append(((nr, nc), dist + 1)) return -1"},{"question":"def is_back_to_start(moves: str) -> str: Determines if the sequence of moves returns to the starting position. Args: moves (str): a string representing the sequence of movements. Returns: str: \\"Yes\\" if the sequence returns to the starting point, \\"No\\" otherwise. >>> is_back_to_start(\\"LRUD\\") \\"Yes\\" >>> is_back_to_start(\\"LLRRUUDD\\") \\"Yes\\" >>> is_back_to_start(\\"LUD\\") \\"No\\" def test_example_cases(): assert is_back_to_start(\\"LRUD\\") == \\"Yes\\" assert is_back_to_start(\\"LLRRUUDD\\") == \\"Yes\\" assert is_back_to_start(\\"LUD\\") == \\"No\\" def test_balanced_moves(): assert is_back_to_start(\\"LRLRLRLR\\") == \\"Yes\\" assert is_back_to_start(\\"UDUDUDUD\\") == \\"Yes\\" def test_unbalanced_moves(): assert is_back_to_start(\\"LLLR\\") == \\"No\\" assert is_back_to_start(\\"UUD\\") == \\"No\\" def test_edge_cases(): assert is_back_to_start(\\"\\") == \\"Yes\\" assert is_back_to_start(\\"L\\") == \\"No\\" assert is_back_to_start(\\"R\\") == \\"No\\" assert is_back_to_start(\\"U\\") == \\"No\\" assert is_back_to_start(\\"D\\") == \\"No\\"","solution":"def is_back_to_start(moves: str) -> str: Determines if the sequence of moves returns to the starting position. Args: moves (str): a string representing the sequence of movements. Returns: str: \\"Yes\\" if the sequence returns to the starting point, \\"No\\" otherwise. x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"import heapq from typing import List def minCostPath(grid: List[List[int]]) -> int: Determine the minimum cost path from the upper-left corner to the lower-right corner of a 2D grid. Args: grid (List[List[int]]): a 2D array of integers where each value represents the cost of entering that cell. Returns: int: the minimum cost to reach from the top-left to the bottom-right of the grid. >>> minCostPath([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> minCostPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> minCostPath([[42]]) 42 pass","solution":"import heapq def minCostPath(grid): n = len(grid) m = len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * m for _ in range(n)] min_heap = [(grid[0][0], 0, 0)] while min_heap: cost, x, y = heapq.heappop(min_heap) if x == n - 1 and y == m - 1: return cost if visited[x][y]: continue visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]: heapq.heappush(min_heap, (cost + grid[nx][ny], nx, ny)) return -1 # Example usage # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(minCostPath(grid)) # Output: 7"},{"question":"def is_good_sequence(sequence): Determines if the sequence can be made such that all elements are equal through a series of right circular shifts followed by reversing the sequence and performing right circular shifts again. pass def check_sequences(sequences): Determine if each sequence in the list of sequences is good. >>> check_sequences([[4, 1, 2, 3], [1, 1, 1], [2, 4, 4, 2, 2]]) ['NO', 'YES', 'YES'] pass def process_input(input_data): Process the input data and return the results of checking sequences. >>> input_data = \\"3n4 1 2 3 4n3 1 1 1n5 2 4 4 2 2\\" >>> process_input(input_data) ['NO', 'YES', 'YES'] pass","solution":"def is_good_sequence(sequence): Determines if the sequence can be made such that all elements are equal through a series of right circular shifts followed by reversing the sequence and performing right circular shifts again. unique_elements = set(sequence) return len(unique_elements) == 1 or len(unique_elements) == 2 def check_sequences(sequences): Determine if each sequence in the list of sequences is good. results = [] for seq in sequences: if is_good_sequence(seq): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example function to process input and output def process_input(input_data): lines = input_data.strip().split('n') q = int(lines[0]) sequences = [] for i in range(1, q + 1): seq_data = list(map(int, lines[i].split())) n = seq_data[0] sequence = seq_data[1:] sequences.append(sequence) return check_sequences(sequences)"},{"question":"def count_greater_elements_to_right(n: int, array: List[int]) -> List[int]: Given an array of n integers, find the array D of size n where D[i] is the number of elements greater than A[i] to the right of A[i] in the array. >>> count_greater_elements_to_right(5, [3, 4, 2, 7, 5]) [3, 2, 2, 0, 0] >>> count_greater_elements_to_right(4, [5, 5, 5, 5]) [0, 0, 0, 0] >>> count_greater_elements_to_right(5, [1, 2, 3, 4, 5]) [4, 3, 2, 1, 0] >>> count_greater_elements_to_right(5, [5, 4, 3, 2, 1]) [0, 0, 0, 0, 0] >>> count_greater_elements_to_right(6, [4, 2, 6, 3, 1, 5]) [2, 3, 0, 1, 1, 0] >>> count_greater_elements_to_right(1, [100]) [0]","solution":"def count_greater_elements_to_right(n, array): result = [0] * n for i in range(n): count = 0 for j in range(i + 1, n): if array[j] > array[i]: count += 1 result[i] = count return result"},{"question":"def find_largest_connected_component(T, test_cases): Your task is to write a function that identifies the largest connected component of rooms on each floor. A connected component in this context is a group of rooms where there is a path between any two rooms in the group. Args: T (int): The number of test cases. test_cases (list): A list of dictionaries containing: - \\"R\\" (int): Number of rooms - \\"H\\" (int): Number of hallways - \\"hallways\\" (list): List of tuples (u, v) indicating hallways Returns: list: A list of integers representing the size of the largest connected component for each test case. >>> T = 2 >>> test_cases = [ {\\"R\\": 5, \\"H\\": 4, \\"hallways\\": [(1, 2), (2, 3), (3, 4), (4, 5)]}, {\\"R\\": 4, \\"H\\": 2, \\"hallways\\": [(1, 2), (3, 4)]} ] >>> find_largest_connected_component(T, test_cases) [5, 2] >>> T = 1 >>> test_cases = [ {\\"R\\": 1, \\"H\\": 0, \\"hallways\\": []} ] >>> find_largest_connected_component(T, test_cases) [1] >>> T = 1 >>> test_cases = [ {\\"R\\": 4, \\"H\\": 0, \\"hallways\\": []} ] >>> find_largest_connected_component(T, test_cases) [1] def test_find_largest_connected_component(): # Test case 1 T = 2 test_cases = [ {\\"R\\": 5, \\"H\\": 4, \\"hallways\\": [(1, 2), (2, 3), (3, 4), (4, 5)]}, {\\"R\\": 4, \\"H\\": 2, \\"hallways\\": [(1, 2), (3, 4)]} ] expected = [5, 2] assert find_largest_connected_component(T, test_cases) == expected # Test case 2: Single room scenarios T = 1 test_cases = [ {\\"R\\": 1, \\"H\\": 0, \\"hallways\\": []} ] expected = [1] assert find_largest_connected_component(T, test_cases) == expected # Test case 3: No hallways T = 1 test_cases = [ {\\"R\\": 4, \\"H\\": 0, \\"hallways\\": []} ] expected = [1] assert find_largest_connected_component(T, test_cases) == expected # Test case 4: Complex connections T = 1 test_cases = [ {\\"R\\": 6, \\"H\\": 5, \\"hallways\\": [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]} ] expected = [3] assert find_largest_connected_component(T, test_cases) == expected # Test case 5: Disconnected components of varying sizes T = 1 test_cases = [ {\\"R\\": 8, \\"H\\": 4, \\"hallways\\": [(1, 2), (2, 3), (4, 5), (6, 7)]} ] expected = [3] assert find_largest_connected_component(T, test_cases) == expected # Test case 6: Larger components T = 1 test_cases = [ {\\"R\\": 7, \\"H\\": 6, \\"hallways\\": [(1, 2), (2, 3), (3, 4), (5, 6), (5, 7), (6, 7)]} ] expected = [4] assert find_largest_connected_component(T, test_cases) == expected # Run tests test_find_largest_connected_component()","solution":"def find_largest_connected_component(T, test_cases): from collections import defaultdict, deque def bfs(node, visited, adjacency_list): queue = deque([node]) visited[node] = True count = 0 while queue: current = queue.popleft() count += 1 for neighbor in adjacency_list[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return count results = [] for case in test_cases: R, H, hallways = case[\\"R\\"], case[\\"H\\"], case[\\"hallways\\"] adjacency_list = defaultdict(list) for u, v in hallways: adjacency_list[u].append(v) adjacency_list[v].append(u) visited = [False] * (R + 1) largest_component_size = 0 for room in range(1, R + 1): if not visited[room]: component_size = bfs(room, visited, adjacency_list) largest_component_size = max(largest_component_size, component_size) results.append(largest_component_size) return results"},{"question":"from typing import List def add_large_numbers(num1: str, num2: str) -> str: Simulate the addition of two large non-negative integers represented as strings. Return the sum as a string without leading zeros. Examples: >>> add_large_numbers(\\"123456789123456789\\", \\"987654321987654321\\") \\"1111111111111111110\\" >>> add_large_numbers(\\"0000123\\", \\"456\\") \\"579\\" >>> add_large_numbers(\\"0\\", \\"0\\") \\"0\\" from solution import add_large_numbers def test_add_large_numbers_example1(): assert add_large_numbers(\\"123456789123456789\\", \\"987654321987654321\\") == \\"1111111111111111110\\" def test_add_large_numbers_example2(): assert add_large_numbers(\\"0000123\\", \\"456\\") == \\"579\\" def test_add_large_numbers_example3(): assert add_large_numbers(\\"0\\", \\"0\\") == \\"0\\" def test_add_large_numbers_no_leading_zeros(): assert add_large_numbers(\\"123\\", \\"456\\") == \\"579\\" def test_add_large_numbers_with_carry(): assert add_large_numbers(\\"999\\", \\"1\\") == \\"1000\\" def test_add_large_numbers_different_lengths(): assert add_large_numbers(\\"789\\", \\"123456\\") == \\"124245\\" def test_add_large_numbers_empty_strings(): assert add_large_numbers(\\"\\", \\"\\") == \\"0\\" assert add_large_numbers(\\"0\\", \\"\\") == \\"0\\" assert add_large_numbers(\\"\\", \\"0\\") == \\"0\\" def test_add_large_numbers_leading_zeros(): assert add_large_numbers(\\"00000123\\", \\"0000456\\") == \\"579\\" def test_add_large_numbers_one_large_input(): assert add_large_numbers(\\"123456789123456789123456789\\", \\"1\\") == \\"123456789123456789123456790\\"","solution":"def add_large_numbers(num1, num2): Returns the sum of num1 and num2, two large non-negative integers represented as strings, without leading zeros in the result. # Remove leading zeros from inputs num1, num2 = num1.lstrip('0'), num2.lstrip('0') # If either string is empty, replace with '0' if not num1: num1 = '0' if not num2: num2 = '0' # Initialize result and carry result = [] carry = 0 p1, p2 = len(num1) - 1, len(num2) - 1 # Process both numbers from end to start while p1 >= 0 or p2 >= 0 or carry: x1 = int(num1[p1]) if p1 >= 0 else 0 x2 = int(num2[p2]) if p2 >= 0 else 0 value = x1 + x2 + carry carry = value // 10 result.append(value % 10) p1 -= 1 p2 -= 1 # Reverse the result and convert to string return ''.join(map(str, result[::-1])).lstrip('0') or '0'"},{"question":"def find_minimum_defense_strength(K, regions): Find the weakest line of defense for each region and its corresponding strength. >>> K = 2 >>> regions = [ ... {\\"size\\": (3, 3), \\"grid\\": [[8, 1, 6], [3, 5, 7], [4, 9, 2]]}, ... {\\"size\\": (4, 2), \\"grid\\": [[1, 2], [3, 4], [5, 6], [7, 8]]} ... ] >>> find_minimum_defense_strength(K, regions) [15, 3] >>> K = 1 >>> regions = [ ... {\\"size\\": (2, 2), \\"grid\\": [[1, 2], [3, 4]]} ... ] >>> find_minimum_defense_strength(K, regions) [3] >>> K = 1 >>> regions = [ ... {\\"size\\": (3, 4), \\"grid\\": [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]} ... ] >>> find_minimum_defense_strength(K, regions) [4]","solution":"def find_minimum_defense_strength(K, regions): results = [] for region in regions: P, Q = region[\\"size\\"] grid = region[\\"grid\\"] # Calculate row sums row_sums = [sum(row) for row in grid] # Calculate column sums col_sums = [sum(grid[i][j] for i in range(P)) for j in range(Q)] # Calculate primary diagonal sum primary_diagonal_sum = sum(grid[i][i] for i in range(min(P, Q))) # Calculate secondary diagonal sum secondary_diagonal_sum = sum(grid[i][Q - i - 1] for i in range(min(P, Q))) # Collect all possible line sums all_sums = row_sums + col_sums + [primary_diagonal_sum, secondary_diagonal_sum] # Find the minimum sum min_strength = min(all_sums) results.append(min_strength) return results # Handling input and output def process_input(): K = int(input().strip()) regions = [] for _ in range(K): P, Q = map(int, input().strip().split()) grid = [] for _ in range(P): grid.append(list(map(int, input().strip().split()))) regions.append({\\"size\\": (P, Q), \\"grid\\": grid}) return K, regions if __name__ == \\"__main__\\": K, regions = process_input() results = find_minimum_defense_strength(K, regions) for result in results: print(result)"},{"question":"def split_deck(N: int) -> Tuple[int, int]: Split a deck of N cards numbered from 1 to N into two subsets such that the difference between the maximum cards in the two subsets is minimized and the absolute difference between the sums of the cards in the two subsets is minimized. Returns a tuple of two integers representing these minimized differences. ----- Input ------ The input contains a single integer N, the number of cards in the deck. ----- Output ------ Output two space-separated integers. The first integer is the minimized maximum difference |max(A) - max(B)|, and the second integer is the minimized absolute difference |sum(A) - sum(B)|. ----- Constraints ------ 2 ≤ N ≤ 10^6 >>> split_deck(5) (0, 1) >>> split_deck(10) (0, 0)","solution":"def split_deck(N): Split a deck of N cards numbered from 1 to N into two subsets such that the difference between the maximum cards in the two subsets is minimized and the absolute difference between the sums of the cards in the two subsets is minimized. Returns a tuple of two integers representing these minimized differences. if N % 2 == 0: return 0, 0 else: return 0, 1"},{"question":"def isSorted(arr: List[int]) -> bool: Determines whether the list is sorted in non-decreasing order. >>> isSorted([1, 2, 2, 3, 4, 5]) True >>> isSorted([5, 4, 3, 2, 1]) False >>> isSorted([1, 3, 2]) False >>> isSorted([1]) True >>> isSorted([]) True >>> isSorted([1, 1, 1, 1]) True >>> isSorted(list(range(100000))) True >>> large_list = list(range(100000)) >>> large_list[99999], large_list[99998] = large_list[99998], large_list[99999] >>> isSorted(large_list) False","solution":"def isSorted(arr): Determines whether the list is sorted in non-decreasing order. Parameters: arr (list): List of integers. Returns: bool: True if the list is sorted in non-decreasing order, False otherwise. for i in range(1, len(arr)): if arr[i] < arr[i - 1]: return False return True"},{"question":"def longest_palindromic_subsequence(n: int, sequence: List[int]) -> int: Returns the length of the longest palindromic subsequence in the given sequence. >>> longest_palindromic_subsequence(5, [1, 2, 3, 2, 1]) 5 >>> longest_palindromic_subsequence(7, [1, 2, 3, 4, 2, 1, 3]) 5 >>> longest_palindromic_subsequence(1, [9]) 1 >>> longest_palindromic_subsequence(4, [1, 2, 3, 4]) 1 >>> longest_palindromic_subsequence(5, [7, 7, 7, 7, 7]) 5 >>> longest_palindromic_subsequence(6, [1, 4, 2, 2, 4, 1]) 6 >>> longest_palindromic_subsequence(8, [1, 3, 5, 6, 5, 3, 1, 7]) 7","solution":"def longest_palindromic_subsequence(n, sequence): Returns the length of the longest palindromic subsequence in the given sequence. :param n: Length of the sequence :param sequence: List of integers representing the sequence :returns: Length of the longest palindromic subsequence # Create a 2D dp array initialized to 0 dp = [[0] * n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Fill the dp array for length in range(2, n + 1): # length is the length of the substring for i in range(n - length + 1): j = i + length - 1 if sequence[i] == sequence[j]: dp[i][j] = dp[i + 1][j - 1] + 2 if length > 2 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) # The result is in dp[0][n-1] return dp[0][n - 1]"},{"question":"from typing import List, Tuple def max_utilized_skills(T: int, test_cases: List[Tuple[int, int, List[List[int]], List[List[int]]]]) -> List[int]: Determine the maximum number of different skills that can be utilized across all allocated projects in the week. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[List[int]], List[List[int]]]]): List containing test case data. Each test case is a tuple with: - Number of employees (int) - Number of projects (int) - List of employees' skills (List of Lists) - List of projects' requirements and hours (List of Lists) Returns: List[int]: Maximum number of different skills that can be utilized for each test case. >>> max_utilized_skills(1, [(3, 3, [[1, 2, 5], [1, 3], [2, 4, 5, 6]], [[8, 1, 2], [5, 1, 3], [10, 2, 3], [6, 2, 4, 5]])]) [5] >>> max_utilized_skills(2, [(2, 2, [[1, 2], [3, 4]], [[5, 1, 3], [10, 2, 4]]), (3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[8, 1, 2], [5, 4, 5], [10, 7, 8]])]) [4, 6]","solution":"def max_utilized_skills(T, test_cases): from itertools import combinations results = [] for test_case in test_cases: E, P, employees, projects = test_case # List to store skills each project requires and the hours needed project_skills_hours = [] for project in projects: hours = project[0] skills = set(project[1:]) project_skills_hours.append((hours, skills)) max_skills_count = 0 # Check all combinations of projects for num_projects in range(1, P + 1): for proj_comb in combinations(project_skills_hours, num_projects): selected_skills = set() total_hours = 0 valid = True project_skill_counts = {} for (hours, skills) in proj_comb: total_hours += hours if total_hours > 40: valid = False break selected_skills.update(skills) # Check if the project demands can be met by the employees skill_count = 0 for skill in selected_skills: for employee in employees: if skill in employee: skill_count += 1 break if valid and skill_count == len(selected_skills): max_skills_count = max(max_skills_count, len(selected_skills)) results.append(max_skills_count) return results"},{"question":"def max_subarray_with_min_diff(arr: List[int]) -> int: Determine a non-empty subarray such that the sum of the subarray is maximized and the difference between the maximum and minimum elements within this subarray is minimized. Args: arr: List[int] -- input list of integers Returns: int -- the sum of the subarray that satisfies these conditions >>> max_subarray_with_min_diff([3, -1, 2, 7, -4]) == 11 >>> max_subarray_with_min_diff([1, 2, 3, 4, 5]) == 15 >>> max_subarray_with_min_diff([-1, -2, -3, -4, -5]) == -1 >>> max_subarray_with_min_diff([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> max_subarray_with_min_diff([0]) == 0 >>> max_subarray_with_min_diff([10, -10, 20, -20, 30, -30]) == 30 >>> max_subarray_with_min_diff([-1, -1, -1, -1, 10]) == 10 from typing import List def test_max_subarray_with_min_diff(): # Test the provided sample case assert max_subarray_with_min_diff([3, -1, 2, 7, -4]) == 11 # Test a case where all numbers are positive assert max_subarray_with_min_diff([1, 2, 3, 4, 5]) == 15 # Test a case where all numbers are negative assert max_subarray_with_min_diff([-1, -2, -3, -4, -5]) == -1 # Test a case with mixed positive and negative numbers assert max_subarray_with_min_diff([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 # Test a case with single element assert max_subarray_with_min_diff([0]) == 0 # Test a case with large difference, but small subarray sums assert max_subarray_with_min_diff([10, -10, 20, -20, 30, -30]) == 30 # Edge case with one large positive number in negative numbers assert max_subarray_with_min_diff([-1, -1, -1, -1, 10]) == 10 test_max_subarray_with_min_diff()","solution":"def max_subarray_with_min_diff(arr): n = len(arr) if n == 0: return 0 # Initialize variables for Kadane's algorithm current_max = arr[0] global_max = arr[0] current_min = arr[0] min_diff = float('inf') for i in range(1, n): current_max = max(arr[i], current_max + arr[i]) global_max = max(global_max, current_max) current_min = min(arr[i], current_min + arr[i]) # Calculate the difference between the max and min elements in the subarray diff = current_max - current_min # Check if this difference is the smallest one if diff < min_diff: min_diff = diff return global_max"},{"question":"def caesar_cipher(operation, shift, message): Encrypts or decrypts a message using the Caesar Cipher based on the given operation and shift. Args: operation (str): Either 'ENCRYPT' or 'DECRYPT' shift (int): The number of positions to shift each letter in the alphabet message (str): The plaintext or ciphertext Returns: str: The encrypted or decrypted message Examples: >>> caesar_cipher(\\"ENCRYPT\\", 3, \\"HELLO WORLD!\\") 'KHOOR ZRUOG!' >>> caesar_cipher(\\"DECRYPT\\", 3, \\"KHOOR ZRUOG!\\") 'HELLO WORLD!' >>> caesar_cipher(\\"ENCRYPT\\", 5, \\"Cryptography123!\\") 'Hwdytlwfxyntf123!'","solution":"def caesar_cipher(operation, shift, message): Encrypts or decrypts a message using the Caesar Cipher based on the given operation and shift. def shift_char(c, shift_amount): if 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + shift_amount) % 26 + ord('A')) elif 'a' <= c <= 'z': return chr((ord(c) - ord('a') + shift_amount) % 26 + ord('a')) else: return c if operation == \\"ENCRYPT\\": shift = shift elif operation == \\"DECRYPT\\": shift = -shift else: raise ValueError(\\"Invalid operation. Allowed values are 'ENCRYPT' or 'DECRYPT'.\\") result = '' for char in message: result += shift_char(char, shift) return result"},{"question":"def should_accept(N: int, defective_items: list, T: int) -> str: Determines if the batch should be accepted or rejected based on the number of defective items. Parameters: N (int): The number of inspected items. defective_items (list): A list of integers (0 or 1) representing the status of each inspected item. T (int): The threshold for the acceptable number of defective items. Returns: str: \\"Accept\\" if the number of defective items is less than or equal to the threshold, otherwise \\"Reject\\". >>> should_accept(6, [0, 1, 0, 0, 1, 0], 2) 'Accept' >>> should_accept(6, [0, 1, 0, 0, 1, 0], 1) 'Reject' >>> should_accept(5, [0, 0, 0, 0, 0], 3) 'Accept' >>> should_accept(4, [1, 1, 1, 1], 4) 'Accept' >>> should_accept(4, [1, 1, 1, 1], 3) 'Reject'","solution":"def should_accept(N, defective_items, T): Determines if the batch should be accepted or rejected based on the number of defective items. Parameters: N (int): The number of inspected items. defective_items (list): A list of integers (0 or 1) representing the status of each inspected item. T (int): The threshold for the acceptable number of defective items. Returns: str: \\"Accept\\" if the number of defective items is less than or equal to the threshold, otherwise \\"Reject\\". defective_count = sum(defective_items) if defective_count <= T: return \\"Accept\\" else: return \\"Reject\\""},{"question":"def min_operations_to_transform_grid(T: int, test_cases: List[Tuple[int, int, List[List[int]], List[List[int]]]]) -> List[int]: You have a grid of size NxM filled with positive integers. You are allowed to perform a series of operations on the grid, where in each operation, you can choose any subgrid with size 2x2 and multiply each element of this subgrid by a positive integer d>1. Your task is to transform the given grid (G) into a target grid (T) by performing the minimum number of operations, or determine if it is impossible. Args: T : int : number of test cases test_cases : List[Tuple[int, int, List[List[int]], List[List[int]]]] : test cases with grid and target grid Returns: List[int] : minimum required number of operations for each test case or -1 if impossible >>> min_operations_to_transform_grid(1, [(2, 2, [[1, 1], [1, 2]], [[2, 2], [2, 4]])]) [1] >>> min_operations_to_transform_grid(1, [(2, 2, [[1, 1], [1, 3]], [[2, 2], [2, 4]])]) [-1]","solution":"def min_operations_to_transform_grid(T, test_cases): results = [] for t in range(T): N, M, G, target = test_cases[t] operations = 0 possible = True for i in range(N - 1): for j in range(M - 1): while G[i][j] < target[i][j]: factor = target[i][j] // G[i][j] if factor == 1: break operations += 1 for x in range(2): for y in range(2): G[i + x][j + y] *= factor for i in range(N): for j in range(M): if G[i][j] != target[i][j]: possible = False break if not possible: break if possible: results.append(operations) else: results.append(-1) return results"},{"question":"def find_min_time_with_one_stop(N: int, M: int, flights: List[Tuple[int, int, int]]) -> int: Determine the shortest possible time it takes to travel from City 1 to City N considering exactly one intermediate stop. >>> find_min_time_with_one_stop(5, 6, [(1, 2, 5), (2, 5, 4), (1, 3, 7), (3, 4, 3), (4, 5, 1), (2, 4, 6)]) == 9 >>> find_min_time_with_one_stop(4, 2, [(1, 2, 5), (3, 4, 7)]) == -1 >>> find_min_time_with_one_stop(4, 3, [(1, 2, 1), (2, 4, 1), (1, 3, 10), (3, 4, 10)]) == 2 >>> find_min_time_with_one_stop(6, 7, [(1, 2, 1), (2, 3, 1), (3, 6, 1), (1, 4, 2), (4, 5, 1), (5, 6, 1), (2, 5, 4)]) == 3","solution":"import heapq def find_min_time_with_one_stop(N, M, flights): # Create adjacency list for the graph adj_list = [[] for _ in range(N + 1)] for a, b, time in flights: adj_list[a].append((b, time)) adj_list[b].append((a, time)) def dijkstra(start): dist = [float('inf')] * (N + 1) dist[start] = 0 pq = [(0, start)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in adj_list[u]: new_dist = current_dist + weight if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return dist # Get shortest path distances from City 1 and to City N dist_from_1 = dijkstra(1) dist_to_N = dijkstra(N) min_time = float(\\"inf\\") # Try all possible intermediate stops for a, b, time in flights: if dist_from_1[a] != float('inf') and dist_to_N[b] != float('inf'): min_time = min(min_time, dist_from_1[a] + time + dist_to_N[b]) if dist_from_1[b] != float('inf') and dist_to_N[a] != float('inf'): min_time = min(min_time, dist_from_1[b] + time + dist_to_N[a]) return -1 if min_time == float('inf') else min_time # Example Usage N = 5 M = 6 flights = [ (1, 2, 5), (2, 5, 4), (1, 3, 7), (3, 4, 3), (4, 5, 1), (2, 4, 6) ] print(find_min_time_with_one_stop(N, M, flights)) # Output: 9"},{"question":"def max_coins(T: int, test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[int]: Calculate the maximum number of coins Jordan can collect by planning optimal paths from the top-left to the bottom-right corner of the grid. Args: T (int): The number of test cases. test_cases (List[Tuple[int, int, List[List[int]]]]): A list of tuples, where each tuple contains: - M (int): The number of rows in the grid. - N (int): The number of columns in the grid. - A list of lists of integers representing the grid. Returns: List[int]: A list of integers, where each integer represents the maximum number of coins collected in the corresponding test case. Examples: >>> max_coins(1, [(3, 3, [[0, 1, 4], [1, 0, 0], [2, 0, 5]])]) [10] >>> max_coins(1, [(2, 2, [[10, 10], [10, 10]])]) [30]","solution":"def max_coins(T, test_cases): results = [] for case in test_cases: M, N, grid = case dp = [[0] * N for _ in range(M)] dp[0][0] = grid[0][0] for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, M): for j in range(1, N): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] results.append(dp[M-1][N-1]) return results # Sample input example T = 2 test_cases = [ (3, 3, [ [0, 1, 4], [1, 0, 0], [2, 0, 5] ]), (2, 2, [ [10, 10], [10, 10] ]) ] print(max_coins(T, test_cases))"},{"question":"import re def is_palindrome(s: str) -> bool: Determines if a given string is a valid palindrome. A palindrome is a string that reads the same backward as forward, after removing all non-alphanumeric characters and converting all letters to lower case. Examples: >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\" \\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"12345\\") False >>> is_palindrome(\\"A1b2B1a\\") True >>> is_palindrome(\\"@@\\") True >>> is_palindrome(\\"@#a#@\\") True >>> is_palindrome(\\"@#a#b\\") False >>> is_palindrome(\\"Noon\\") True >>> is_palindrome(\\"NooN\\") True >>> is_palindrome(\\"NoOne\\") False","solution":"import re def is_palindrome(s): Determines if a given string is a valid palindrome. # Use regular expression to remove non-alphanumeric characters filtered_chars = re.findall(r'w', s) # Join the filtered characters and convert to lower case filtered_string = ''.join(filtered_chars).lower() # Check if the filtered string reads the same backward return filtered_string == filtered_string[::-1]"},{"question":"def max_sum_contiguous_subsequence(n, v): Returns the maximum sum of a contiguous subsequence of leaves. Args: n (int): the number of leaves. v (List[int]): the values associated with the leaves. Returns: int: the maximum sum of a contiguous subsequence of leaves. Examples: >>> max_sum_contiguous_subsequence(9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_sum_contiguous_subsequence(5, [1, 2, 3, 4, 5]) 15 >>> max_sum_contiguous_subsequence(1, [-5]) -5 >>> max_sum_contiguous_subsequence(5, [-1, -2, -3, -4, -5]) -1 >>> max_sum_contiguous_subsequence(5, [-1, 2, -1, 2, -1]) 3 >>> max_sum_contiguous_subsequence(6, [1, 2, 3, 4, 5, 6]) 21 >>> max_sum_contiguous_subsequence(8, [-3, -2, 5, -1, 2, 9, -10, 5]) 15 >>> max_sum_contiguous_subsequence(8, [-2, 1, -3, 4, -1, 2, 1, -5]) 6","solution":"def max_sum_contiguous_subsequence(n, v): Returns the maximum sum of a contiguous subsequence of leaves. # Implementing Kadane's algorithm max_current = v[0] max_global = v[0] for i in range(1, n): max_current = max(v[i], max_current + v[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def smallest_non_obtainable_sum(arr: List[int]) -> int: Given an array of integers, return the smallest possible positive integer that does not appear as the sum of any non-empty subsequence of the array. Example 1: >>> smallest_non_obtainable_sum([1, 2, 2, 4]) 10 Example 2: >>> smallest_non_obtainable_sum([1, 1, 1, 1]) 5 Test Cases: def test_example_1(): assert smallest_non_obtainable_sum([1, 2, 2, 4]) == 10 def test_example_2(): assert smallest_non_obtainable_sum([1, 1, 1, 1]) == 5 def test_single_element(): assert smallest_non_obtainable_sum([2]) == 1 def test_consecutive_elements(): assert smallest_non_obtainable_sum([1, 2, 3, 4]) == 11 def test_non_consecutive_elements(): assert smallest_non_obtainable_sum([1, 3, 3, 7]) == 2 def test_multiple_identical_elements(): assert smallest_non_obtainable_sum([2, 2, 2, 2]) == 1 def test_larger_numbers(): assert smallest_non_obtainable_sum([5, 6, 7, 8]) == 1 def test_gap_in_sequence(): assert smallest_non_obtainable_sum([1, 2, 4, 8]) == 16","solution":"def smallest_non_obtainable_sum(arr): Given an array of integers, return the smallest possible positive integer that does not appear as the sum of any non-empty subsequence of the array. arr.sort() smallest_missing = 1 for number in arr: if number > smallest_missing: break smallest_missing += number return smallest_missing"},{"question":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderBottomUp(root: Optional[TreeNode]) -> List[int]: Given a binary tree, print the nodes in the level order traversal starting from the bottom level up to the root level. Args: root (Optional[TreeNode]): The root of the binary tree. Returns: List[int]: A list of the node values in the level order traversal from bottom to top. Examples: >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> levelOrderBottomUp(root) [4, 5, 6, 7, 2, 3, 1] >>> root = TreeNode(10) >>> root.left = TreeNode(20) >>> root.right = TreeNode(30) >>> root.left.left = TreeNode(40) >>> levelOrderBottomUp(root) [40, 20, 30, 10]","solution":"from collections import deque class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def levelOrderBottomUp(root): if not root: return [] queue = deque([root]) result = [] while queue: level_size = len(queue) level_nodes = [] for _ in range(level_size): node = queue.popleft() level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.insert(0, level_nodes) return [val for sublist in result for val in sublist]"},{"question":"import re def password_strength(passwords: List[str]) -> List[str]: Function to determine the strength of each password in a list. Parameters: passwords (List[str]): A list of passwords to be analyzed. Returns: List[str]: A list where each element is \\"Strong\\" or \\"Weak\\" depending on the strength of the corresponding password. >>> password_strength([\\"Password123!\\", \\"weakpass\\", \\"Str0ngPaword\\", \\"noSpecialChar1\\", \\"A@1bC\\"]) [\\"Strong\\", \\"Weak\\", \\"Strong\\", \\"Weak\\", \\"Weak\\"] >>> password_strength([\\"Hello1!\\", \\"Super@Secure2\\", \\"n0SpecialCharacters3\\"]) [\\"Weak\\", \\"Strong\\", \\"Weak\\"] # Example unit test def test_password_strength(): passwords = [ \\"Password123!\\", \\"weakpass\\", \\"Str0ngPaword\\", \\"noSpecialChar1\\", \\"A@1bC\\" ] expected_output = [\\"Strong\\", \\"Weak\\", \\"Strong\\", \\"Weak\\", \\"Weak\\"] assert password_strength(passwords) == expected_output def test_password_strength_all_strong(): passwords = [ \\"S@3curePaword\\", \\"R3s!lient\\", \\"T0p@Secret!\\" ] expected_output = [\\"Strong\\", \\"Strong\\", \\"Strong\\"] assert password_strength(passwords) == expected_output def test_password_strength_all_weak(): passwords = [ \\"weak\\", \\"weak123\\", \\"WEAKPASSWORD\\", \\"WeakNoSpecials\\", \\"12345678\\" ] expected_output = [\\"Weak\\", \\"Weak\\", \\"Weak\\", \\"Weak\\", \\"Weak\\"] assert password_strength(passwords) == expected_output def test_password_strength_edge_cases(): # Testing length edge case passwords = [\\"A@1bCdef\\"] expected_output = [\\"Strong\\"] assert password_strength(passwords) == expected_output passwords = [\\"A@1bCde\\"] expected_output = [\\"Weak\\"] assert password_strength(passwords) == expected_output # Testing special characters edge case passwords = [\\"A1bCdefg\\"] expected_output = [\\"Weak\\"] assert password_strength(passwords) == expected_output # Testing uppercase letter edge case passwords = [\\"a@1bcdef\\"] expected_output = [\\"Weak\\"] assert password_strength(passwords) == expected_output # Testing lowercase letter edge case passwords = [\\"A@1BCDEF\\"] expected_output = [\\"Weak\\"] assert password_strength(passwords) == expected_output # Testing digit edge case passwords = [\\"A@bcdefg\\"] expected_output = [\\"Weak\\"] assert password_strength(passwords) == expected_output","solution":"def password_strength(passwords): Function to determine the strength of each password in a list. import re results = [] for password in passwords: if (len(password) >= 8 and re.search(r'[A-Z]', password) and re.search(r'[a-z]', password) and re.search(r'[0-9]', password) and re.search(r'[!@#%^&*()]', password)): results.append(\\"Strong\\") else: results.append(\\"Weak\\") return results # Example usage if __name__ == \\"__main__\\": passwords = [ \\"Password123!\\", \\"weakpass\\", \\"Str0ngPaword\\", \\"noSpecialChar1\\", \\"A@1bC\\" ] print(password_strength(passwords))"},{"question":"def count_rectangles(n: int, m: int) -> int: Calculate the total number of rectangles that can be formed in an n x m grid. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. Returns: int: The total number of different rectangles. Examples: >>> count_rectangles(2, 3) 18 >>> count_rectangles(1, 1) 1 >>> count_rectangles(3, 3) 36 from solution import count_rectangles def test_example_1(): assert count_rectangles(2, 3) == 18 def test_example_2(): assert count_rectangles(1, 1) == 1 def test_example_3(): assert count_rectangles(3, 3) == 36 def test_large_grid(): assert count_rectangles(1000, 1000) == 250500250000 def test_rectangles_with_one_row(): assert count_rectangles(1, 5) == 15 def test_rectangles_with_one_column(): assert count_rectangles(5, 1) == 15 def test_rectangles_2x2_grid(): assert count_rectangles(2, 2) == 9 def test_rectangles_4x4_grid(): assert count_rectangles(4, 4) == 100","solution":"def count_rectangles(n, m): Calculate the total number of rectangles that can be formed in an n x m grid. The number of rectangles in an n x m grid is given by the formula: (n * (n + 1) // 2) * (m * (m + 1) // 2) return (n * (n + 1) // 2) * (m * (m + 1) // 2) # Example usage # n, m = map(int, input().split()) # print(count_rectangles(n, m))"},{"question":"def detect_cycle(n, edges): Determine whether the graph contains a cycle. Args: n (int): The number of nodes in the graph. edges (List[Tuple[int, int]]): List of directed edges in the graph. Returns: str: \\"YES\\" if the graph contains a cycle, otherwise \\"NO\\". pass def solve(test_cases): Solve the problem for multiple test cases. Args: test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): List of test cases. Returns: List[str]: List of results for each test case. >>> solve([(4, 5, [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3)]), (3, 3, [(0, 1), (1, 2), (2, 0)])]) [\\"YES\\", \\"YES\\"] >>> solve([(4, 3, [(0, 1), (1, 2), (2, 3)]), (3, 2, [(0, 1), (1, 2)])]) [\\"NO\\", \\"NO\\"] >>> solve([(4, 2, [(0, 1), (2, 3)]), (5, 4, [(0, 1), (1, 2), (3, 4), (4, 3)])]) [\\"NO\\", \\"YES\\"] >>> solve([(6, 7, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 2), (5, 0), (5, 1)])]) [\\"YES\\"] pass","solution":"def detect_cycle(n, edges): from collections import defaultdict def is_cyclic(v, visited, rec_stack): visited[v] = True rec_stack[v] = True for neighbor in graph[v]: if not visited[neighbor]: if is_cyclic(neighbor, visited, rec_stack): return True elif rec_stack[neighbor]: return True rec_stack[v] = False return False # Creating adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if is_cyclic(node, visited, rec_stack): return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for n, m, edges in test_cases: results.append(detect_cycle(n, edges)) return results"},{"question":"def minimum_operations(grid): Returns the minimum number of operations required to make all cells in the grid have the same integer. >>> minimum_operations([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 36 >>> minimum_operations([[5, 5, 5], [5, 5, 5]]) == 0 >>> minimum_operations([[1, 2, 3], [4, 5, 6]]) == 15 >>> minimum_operations([[1, 2, 3, 4, 5]]) == 10 >>> minimum_operations([[1], [2], [3], [4], [5]]) == 10 >>> minimum_operations([[0, 0, 0], [0, 0, 0]]) == 0 >>> minimum_operations([[1000, 999], [990, 995]]) == 16","solution":"def minimum_operations(grid): Returns the minimum number of operations required to make all cells in the grid have the same integer. max_value = max(max(row) for row in grid) operations = 0 for row in grid: for value in row: operations += (max_value - value) return operations"},{"question":"from collections import defaultdict def max_path_sum(n, node_values, edges): Find the maximum possible value of the sum of values of nodes on any path in the tree. Parameters: - n: int - the number of nodes in the tree - node_values: List[int] - the values assigned to each node - edges: List[Tuple[int, int]] - the edges of the tree Returns: - int - the maximum sum of values of nodes on any path in the tree >>> max_path_sum(5, [4, -2, 1, 6, -3], [(1, 2), (1, 3), (3, 4), (3, 5)]) 11 >>> max_path_sum(3, [1, 2, 3], [(1, 2), (2, 3)]) 6 >>> max_path_sum(1, [5], []) 5 >>> max_path_sum(4, [-1, -2, -3, -4], [(1, 2), (2, 3), (3, 4)]) -1 >>> max_path_sum(2, [5, -1], [(1, 2)]) 5 pass","solution":"from collections import defaultdict def max_path_sum(n, node_values, edges): def dfs(node, parent): nonlocal max_sum current_max = node_values[node] for neighbor in graph[node]: if neighbor == parent: continue max_from_child = dfs(neighbor, node) max_sum = max(max_sum, current_max + max_from_child) current_max = max(current_max, node_values[node] + max_from_child) max_sum = max(max_sum, current_max) return current_max graph = defaultdict(list) for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) max_sum = float('-inf') dfs(0, -1) return max_sum"},{"question":"def min_blocks_to_remove(heights): Given a list of non-negative integers representing piles of blocks, returns the minimum number of blocks that need to be removed to make all piles of the same height. :param heights: List of integers representing the heights of piles of blocks :return: Integer representing the minimum number of blocks to remove >>> min_blocks_to_remove([3, 7, 2, 5]) 9 >>> min_blocks_to_remove([5, 5, 5, 8]) 3 >>> min_blocks_to_remove([10, 20, 30]) 30 >>> min_blocks_to_remove([1, 1, 1]) 0 >>> min_blocks_to_remove([4, 4, 4, 4]) 0 >>> min_blocks_to_remove([5]) 0 >>> min_blocks_to_remove([100, 200, 300]) 300 >>> min_blocks_to_remove([50, 60, 70, 80]) 60","solution":"def min_blocks_to_remove(heights): Given a list of non-negative integers representing piles of blocks, returns the minimum number of blocks that need to be removed to make all piles of the same height. :param heights: List of integers representing the heights of piles of blocks :return: Integer representing the minimum number of blocks to remove min_height = min(heights) return sum(height - min_height for height in heights)"},{"question":"def sumOfEvens(arr): Given an array of integers, determine the sum of all even numbers in the array. Example 1: >>> sumOfEvens([1, 2, 3, 4, 5]) 6 Explanation: The even numbers in the array are 2 and 4. Their sum is 6. Example 2: >>> sumOfEvens([10, 21, 32, 43, 54]) 96 Explanation: The even numbers in the array are 10, 32, and 54. Their sum is 96. Your Task: You don't need to read input or print anything. Your task is to complete the function sumOfEvens() which takes an array of integers and return the sum of all even numbers in the array. Expected Time Complexity: O(n) Expected Auxiliary Space: O(1) Constraints: 1 <= arr.length <= 1000 -10000 <= arr[i] <= 10000","solution":"def sumOfEvens(arr): Returns the sum of all even numbers in the array. Parameters: arr (list): List of integers Returns: int: Sum of all even numbers in the list return sum(num for num in arr if num % 2 == 0)"},{"question":"def is_valid_constellation(points): Determine if the points can form a valid constellation (no three points are collinear). Args: points (List[Tuple[int, int]]): List of points represented as tuples of coordinates (x, y). Returns: str: 'YES' if points form a valid constellation, 'NO' otherwise. >>> is_valid_constellation([(1, 1), (2, 2), (3, 3), (4, 4)]) 'NO' >>> is_valid_constellation([(0, 0), (1, 2), (2, 3), (3, 1), (4, 4)]) 'YES' pass def process_input(cases): Process multiple test cases and return the result as per problem statement. Args: cases (List[List[Tuple[int, int]]]): List of test cases where each test case is a list of points. Returns: List[str]: List of results for each test case ('YES' or 'NO'). pass def parse_and_solve(input_str): Parse the input string and solve the problem. Args: input_str (str): The input string with multiple test cases. Returns: str: The results for each test case joined by newlines. pass","solution":"def is_valid_constellation(points): Returns 'YES' if given points can form a valid constellation, otherwise 'NO' n = len(points) def are_collinear(p1, p2, p3): Check if three points are collinear. return (p2[1] - p1[1]) * (p3[0] - p1[0]) == (p3[1] - p1[1]) * (p2[0] - p1[0]) # Check for every triplet of points for i in range(n): for j in range(i + 1, n): for k in range(j + 1, n): if are_collinear(points[i], points[j], points[k]): return 'NO' return 'YES' def process_input(cases): Process multiple test cases and returns the result as per problem statement. results = [] for points in cases: results.append(is_valid_constellation(points)) return results # Define a function to parse input and output results def parse_and_solve(input_str): lines = input_str.strip().split('n') T = int(lines[0]) index = 1 cases = [] for _ in range(T): N = int(lines[index]) points = [] for i in range(index + 1, index + N + 1): x, y = map(int, lines[i].split()) points.append((x, y)) cases.append(points) index += N + 1 results = process_input(cases) return 'n'.join(results)"},{"question":"from typing import List def blue_wooden_gate(words: List[str]) -> List[str]: Create a function that takes a list of words and determines which words can pass through the \`blue wooden gate\`. Rules for passing through the gate: - A word can pass through the gate if it has a repeating letter. For example, the word \`moon\` can pass because it has two \`o\`s, but the word \`sun\` cannot pass because all its letters are unique. The function should return a new list containing the words that can pass through the \`blue wooden gate\`. >>> blue_wooden_gate([\\"balloon\\", \\"apple\\", \\"orange\\", \\"peach\\", \\"banana\\"]) [\\"balloon\\", \\"apple\\", \\"banana\\"] >>> blue_wooden_gate([\\"sun\\", \\"moon\\", \\"star\\"]) [\\"moon\\"] >>> blue_wooden_gate([]) [] >>> blue_wooden_gate([\\"aaaa\\", \\"bbbb\\", \\"cccc\\"]) [\\"aaaa\\", \\"bbbb\\", \\"cccc\\"] >>> blue_wooden_gate([\\"dog\\", \\"cat\\", \\"fish\\"]) [] >>> blue_wooden_gate([\\"aAa\\", \\"BaB\\", \\"cCc\\"]) [\\"aAa\\", \\"BaB\\", \\"cCc\\"] >>> blue_wooden_gate([\\"a\\", \\"b\\", \\"c\\"]) []","solution":"from typing import List def blue_wooden_gate(words: List[str]) -> List[str]: Returns a list of words that have repeating letters. def has_repeating_letter(word): letter_count = {} for letter in word: if letter in letter_count: return True letter_count[letter] = 1 return False return [word for word in words if has_repeating_letter(word)]"},{"question":"def is_possible(n: int, m: int, paths: List[Tuple[int, int]]) -> str: Determine if it is possible to place the rides in such a way that no two adjacent plots both contain a ride. Args: n (int): number of plot areas m (int): number of paths paths (List[Tuple[int, int]]): each tuple denotes a path between plots Returns: str: \\"POSSIBLE\\" if it's feasible to place the rides as per the criteria, otherwise \\"IMPOSSIBLE\\" Examples: >>> is_possible(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"POSSIBLE\\" >>> is_possible(3, 3, [(1, 2), (2, 3), (3, 1)]) \\"IMPOSSIBLE\\" >>> is_possible(1, 0, []) \\"POSSIBLE\\" >>> is_possible(2, 0, []) \\"POSSIBLE\\" >>> is_possible(2, 1, [(1, 2)]) \\"POSSIBLE\\" >>> is_possible(5, 4, [(1, 2), (3, 4), (4, 5)]) \\"POSSIBLE\\" >>> is_possible(6, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)]) \\"POSSIBLE\\" >>> is_possible(5, 5, [(1, 2), (2, 3), (3, 1), (3, 4), (4, 5)]) \\"IMPOSSIBLE\\"","solution":"def is_possible(n, m, paths): Determine if it is possible to place the rides in such a way that no two adjacent plots both contain a ride. Args: n: int - number of plot areas m: int - number of paths paths: list of (int, int) tuples - each tuple denotes a path between plots Returns: str: \\"POSSIBLE\\" if it's feasible to place the rides as per the criteria, otherwise \\"IMPOSSIBLE\\" from collections import defaultdict, deque # Create a graph from the paths graph = defaultdict(list) for a, b in paths: graph[a].append(b) graph[b].append(a) # To record the \\"color\\" of each node; 0: unvisited, 1: color 1, -1: color 2 color = [0] * (n + 1) # Use BFS to check if the graph is bipartite def bfs(start): queue = deque([start]) color[start] = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == 0: # not colored color[neighbor] = -color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # same color as current node return False return True # Check all connected components for i in range(1, n + 1): if color[i] == 0: if not bfs(i): return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def get_median_of_subarray(arr, queries): Given an array of integers, respond to multiple queries to find the median of subarrays defined by the queries. Args: arr (List[int]): A list of integers. queries (List[Tuple[int, int]]): A list of tuples, each tuple containing two integers representing the start and end indices of a subarray. Returns: List[int]: A list of medians for the subarrays specified in the queries. >>> get_median_of_subarray([5, 3, 2, 4, 1], [(1, 3), (2, 4), (1, 5)]) [3, 3, 3] >>> get_median_of_subarray([1, 2, 3, 4, 5, 6], [(1, 3), (2, 5), (4, 6), (1, 6)]) [2, 3, 5, 3] >>> get_median_of_subarray([10, 20, 30, 40, 50], [(2, 2), (5, 5)]) [20, 50] >>> get_median_of_subarray([7, 8, 3, 5, 6, 1, 4, 2], [(1, 8)]) [4]","solution":"def get_median_of_subarray(arr, queries): def find_median(sub_arr): sub_arr.sort() mid = len(sub_arr) // 2 # for even length, we take the lower of the two middle values return sub_arr[mid - 1] if len(sub_arr) % 2 == 0 else sub_arr[mid] results = [] for L, R in queries: sub_arr = arr[L-1:R] # Convert to 0-based index median = find_median(sub_arr) results.append(median) return results"},{"question":"def count_categories(s: str) -> dict: Write a function that takes a string containing a mix of uppercase letters, lowercase letters, and digits, and returns a dictionary with counts of each category: uppercase letters, lowercase letters, and digits. If the string contains any other type of character, return False. >>> count_categories(\\"Hello123\\") == {'uppercase': 1, 'lowercase': 4, 'digits': 3} >>> count_categories(\\"He!!o123\\") == False >>> count_categories(\\"\\") == {'uppercase': 0, 'lowercase': 0, 'digits': 0} >>> count_categories(\\"hello123\\") == {'uppercase': 0, 'lowercase': 5, 'digits': 3} >>> count_categories(\\"HELLO123\\") == {'uppercase': 5, 'lowercase': 0, 'digits': 3} >>> count_categories(\\"HelloWorld\\") == {'uppercase': 2, 'lowercase': 8, 'digits': 0} >>> count_categories(\\"!!!\\") == False >>> count_categories(\\"A1a2B3bC\\") == {'uppercase': 3, 'lowercase': 2, 'digits': 3}","solution":"def count_categories(s): Returns a dictionary with counts of uppercase letters, lowercase letters, and digits in the string. If the string contains any other type of character, returns False. counts = {'uppercase': 0, 'lowercase': 0, 'digits': 0} for char in s: if char.isupper(): counts['uppercase'] += 1 elif char.islower(): counts['lowercase'] += 1 elif char.isdigit(): counts['digits'] += 1 else: return False return counts"},{"question":"def largestGrassRectangle(N: int, M: int, field: List[List[str]]) -> int: Find the largest rectangular section of the field that contains only grass and no rocks. >>> largestGrassRectangle(4, 5, [ ... ['G', '.', 'G', 'G', 'G'], ... ['.', 'G', '.', '.', '.'], ... ['G', 'G', 'G', 'R', 'R'], ... ['G', 'G', 'G', 'G', 'G'] ... ]) == 6 >>> largestGrassRectangle(4, 5, [ ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'R', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'] ... ]) == 10 >>> largestGrassRectangle(3, 3, [ ... ['R', 'R', 'R'], ... ['R', 'G', 'R'], ... ['R', 'R', 'R'] ... ]) == 1 >>> largestGrassRectangle(5, 5, [ ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'], ... ['G', 'G', 'G', 'G', 'G'] ... ]) == 25 >>> largestGrassRectangle(2, 2, [ ... ['R', 'R'], ... ['R', 'R'] ... ]) == 0 >>> largestGrassRectangle(4, 4, [ ... ['G', 'G', 'G', 'R'], ... ['G', 'G', 'R', 'R'], ... ['G', 'R', 'R', 'R'], ... ['R', 'R', 'R', 'R'] ... ]) == 4","solution":"def maximalRectangle(matrix): if not matrix: return 0 max_area = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): if row[i] == 'G': heights[i] += 1 else: heights[i] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i, h in enumerate(heights): while stack and heights[stack[-1]] > h: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) heights.pop() return max_area def largestGrassRectangle(N, M, field): return maximalRectangle(field)"},{"question":"def isPalindromePermutation(s: str) -> bool: Determine if the string is a permutation of a palindrome. :param s: The input string to check. :return: True if the string is a permutation of a palindrome, False otherwise. >>> isPalindromePermutation(\\"a\\") True >>> isPalindromePermutation(\\"ab\\") False >>> isPalindromePermutation(\\"Tact Coa\\") True >>> isPalindromePermutation(\\"tact coa\\") True >>> isPalindromePermutation(\\"random\\") False >>> isPalindromePermutation(\\"Aba\\") True >>> isPalindromePermutation(\\"Able was I ere I saw Elba\\") True","solution":"def isPalindromePermutation(s): Determine if the string is a permutation of a palindrome. :param s: The input string to check. :return: True if the string is a permutation of a palindrome, False otherwise. # Normalize the string: remove spaces and convert to lowercase s = s.replace(\\" \\", \\"\\").lower() # Create a dictionary to count occurrences of each character char_count = {} for char in s: char_count[char] = char_count.get(char, 0) + 1 # Check the number of chars with odd counts odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be a permutation of a palindrome: # - It can have at most one character with an odd count return odd_count <= 1"},{"question":"def validate_dns_record(record: str) -> bool: Validate DNS records conforming to specific constraints. >>> validate_dns_record(\\"A example.com 192.168.1.1\\") # True >>> validate_dns_record(\\"CNAME www.example.com example.com\\") # True >>> validate_dns_record(\\"MX example.com 10 mail.example.com\\") # True >>> validate_dns_record(\\"A example.com 999.999.999.999\\") # False >>> validate_dns_record(\\"MX example.com mail.example.com 10\\") # False >>> validate_dns_record(\\"A -example.com 192.168.1.1\\") # False def test_validate_dns_record_a(): assert validate_dns_record(\\"A example.com 192.168.1.1\\") == True assert validate_dns_record(\\"A -example.com 192.168.1.1\\") == False assert validate_dns_record(\\"A example.com 999.999.999.999\\") == False assert validate_dns_record(\\"A example.com 256.256.256.256\\") == False assert validate_dns_record(\\"A example\\") == False def test_validate_dns_record_cname(): assert validate_dns_record(\\"CNAME www.example.com example.com\\") == True assert validate_dns_record(\\"CNAME www.example-com.example.com another.com\\") == True assert validate_dns_record(\\"CNAME www.example.com .com\\") == False assert validate_dns_record(\\"CNAME www.example.com -example.com\\") == False assert validate_dns_record(\\"CNAME www.example.com\\") == False def test_validate_dns_record_mx(): assert validate_dns_record(\\"MX example.com 10 mail.example.com\\") == True assert validate_dns_record(\\"MX example.com 65535 mail.example.com\\") == True assert validate_dns_record(\\"MX example.com 100000 mail.example.com\\") == False assert validate_dns_record(\\"MX example.com mail.example.com 10\\") == False assert validate_dns_record(\\"MX example.com 65535 mail..example.com\\") == False def test_validate_dns_record_others(): assert validate_dns_record(\\"TXT example.com hello\\") == False assert validate_dns_record(\\"A example.com\\") == False assert validate_dns_record(\\"CNAME example.com another-domain.com extra\\") == False","solution":"import re def validate_dns_record(record: str) -> bool: def validate_domain(domain): if len(domain) > 253: return False labels = domain.split('.') for label in labels: if len(label) > 63 or not re.match(r'^[A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])?', label): return False return True def validate_ipv4(ip): parts = ip.split('.') if len(parts) != 4: return False for part in parts: if not part.isdigit() or not (0 <= int(part) <= 255): return False return True parts = record.split() if len(parts) < 3: return False record_type, domain = parts[0], parts[1] if not validate_domain(domain): return False if record_type == \\"A\\": if len(parts) != 3 or not validate_ipv4(parts[2]): return False elif record_type == \\"CNAME\\": if len(parts) != 3 or not validate_domain(parts[2]): return False elif record_type == \\"MX\\": if len(parts) != 4 or not parts[2].isdigit() or not (0 <= int(parts[2]) <= 65535) or not validate_domain(parts[3]): return False else: return False return True"},{"question":"from typing import List, Tuple def priority_roads(n: int, pop: List[int], roads: List[Tuple[int, int]]) -> List[int]: Compute the total population sum of the towns connected directly through each road. n: int : Total number of towns (2 ≤ n ≤ 10^5). pop: List[int] : An array of integers of size n representing the population of each town. roads: List[Tuple[int, int]] : A list of (n-1) tuples where each tuple (a, b) represents a road connecting town \`a\` and town \`b\` (0 ≤ a, b < n). >>> priority_roads(5, [1, 2, 3, 4, 5], [(0, 1), (1, 2), (1, 3), (3, 4)]) [3, 5, 6, 9] >>> priority_roads(2, [10, 20], [(0, 1)]) [30] >>> priority_roads(4, [5, 5, 5, 5], [(0, 1), (1, 2), (2, 3)]) [10, 10, 10] >>> priority_roads(3, [100000, 200000, 300000], [(0, 1), (1, 2)]) [300000, 500000] >>> priority_roads(2, [1, 1], [(0, 1)]) [2]","solution":"from typing import List, Tuple def priority_roads(n: int, pop: List[int], roads: List[Tuple[int, int]]) -> List[int]: result = [] for a, b in roads: result.append(pop[a] + pop[b]) return result"},{"question":"def reverse_words(s: str) -> str: Returns a new string where each word in the input string s is reversed, but the order of the words remains unchanged. >>> reverse_words(\\"hello world\\") 'olleh dlrow' >>> reverse_words(\\"this is a test\\") 'siht si a tset' >>> reverse_words(\\"coding is fun\\") 'gnidoc si nuf' >>> reverse_words(\\"a b c d\\") 'a b c d' >>> reverse_words(\\"amazing\\") 'gnizama' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"singleword\\") 'drowelgnis'","solution":"def reverse_words(s): Returns a new string where each word in the input string s is reversed, but the order of the words remains unchanged. :param s: Original string with words separated by spaces :return: A new string with each word reversed return ' '.join(word[::-1] for word in s.split())"},{"question":"from typing import List, Tuple def highest_paid_employee(employees: List[Tuple[int, str, float]]) -> str: Returns the name of the highest-paid employee. If there are multiple employees with the highest salary, returns the name that comes first alphabetically. >>> highest_paid_employee([(1, \\"John Doe\\", 60000.0), (2, \\"Jane Smith\\", 75000.0), (3, \\"Emily Davis\\", 75000.0), (4, \\"James Wilson\\", 90000.0)]) \\"James Wilson\\" >>> highest_paid_employee([(1, \\"John Doe\\", 60000.0)]) \\"John Doe\\" >>> highest_paid_employee([(1, \\"John Doe\\", 60000.0), (2, \\"Jane Smith\\", 75000.0), (3, \\"Emily Davis\\", 75000.0)]) \\"Emily Davis\\"","solution":"from typing import List, Tuple def highest_paid_employee(employees: List[Tuple[int, str, float]]) -> str: Returns the name of the highest-paid employee. If there are multiple employees with the highest salary, returns the name that comes first alphabetically. # Sort employees first by Salary in descending order, and then by Name in ascending order sorted_employees = sorted(employees, key=lambda x: (-x[2], x[1])) # Return the Name of the first employee in the sorted list return sorted_employees[0][1]"},{"question":"def max_plants_watered(num_cases, cases): Determines the maximum number of plants that can be watered exactly on their schedule during the selected days. Args: num_cases (int): Number of test cases. cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases, each containing a tuple of (number of plants, total days) and a list of watering intervals for each plant. Returns: List[int]: List of maximum number of plants that can be watered exactly on their schedule for each test case. Examples: >>> max_plants_watered(3, [([5, 10], [2, 3, 5, 3, 4]), ([4, 7], [1, 2, 3, 4]), ([6, 15], [2, 4, 6, 8, 10, 12])]) [5, 4, 6] >>> max_plants_watered(1, [([1, 10], [3])]) [1] >>> max_plants_watered(1, [([1, 10], [11])]) [0] >>> max_plants_watered(2, [([2, 4], [2, 2]), ([2, 6], [2, 2])]) [2, 2] >>> max_plants_watered(1, [([3, 1000], [333, 500, 750])]) [3] >>> max_plants_watered(1, [([4, 3], [4, 4, 4, 4])]) [0]","solution":"def max_plants_watered(num_cases, cases): results = [] for case in cases: n, d = case[0] watering_intervals = case[1] count = 0 for interval in watering_intervals: if d // interval > 0: count += 1 results.append(count) return results"},{"question":"def divide_groups(n, m, g, participants, preferences): Organize participants into the minimum number of groups while respecting their preferences and the maximum group size. Params: - n (int): Number of participants - m (int): Number of pairs of preferences - g (int): Maximum group size - participants (List[str]): List of participant names - preferences (List[Tuple[str, str]]): List of pairs indicating participants that prefer not to be in the same group Returns: - int: Minimum number of groups required - List[List[str]]: List of groups, each containing the names of participants in that group >>> divide_groups(4, 2, 2, [\\"John\\", \\"Jane\\", \\"Alice\\", \\"Bob\\"], [(\\"John\\", \\"Jane\\"), (\\"Alice\\", \\"Bob\\")]) (2, [['John', 'Alice'], ['Jane', 'Bob']]) >>> divide_groups(3, 0, 2, [\\"John\\", \\"Jane\\", \\"Alice\\"], []) (2, [['John', 'Jane'], ['Alice']]) >>> divide_groups(3, 3, 3, [\\"John\\", \\"Jane\\", \\"Alice\\"], [(\\"John\\", \\"Jane\\"), (\\"Jane\\", \\"Alice\\"), (\\"John\\", \\"Alice\\")]) (3, [['John'], ['Jane'], ['Alice']]) # Implementation here from solution import divide_groups def test_divide_groups_small_example(): n = 4 m = 2 g = 2 participants = [\\"John\\", \\"Jane\\", \\"Alice\\", \\"Bob\\"] preferences = [(\\"John\\", \\"Jane\\"), (\\"Alice\\", \\"Bob\\")] num_groups, groups = divide_groups(n, m, g, participants, preferences) assert num_groups == 2 group_set = [set(group) for group in groups] assert set([\\"John\\", \\"Alice\\"]) in group_set assert set([\\"Jane\\", \\"Bob\\"]) in group_set def test_divide_groups_no_preferences(): n = 3 m = 0 g = 2 participants = [\\"John\\", \\"Jane\\", \\"Alice\\"] preferences = [] num_groups, groups = divide_groups(n, m, g, participants, preferences) assert num_groups == 2 group_set = [set(group) for group in groups] assert set([\\"John\\", \\"Jane\\"]) in group_set or set([\\"John\\", \\"Alice\\"]) in group_set or set([\\"Jane\\", \\"Alice\\"]) in group_set assert set([\\"Alice\\"]) in group_set or set([\\"Jane\\"]) in group_set or set([\\"John\\"]) in group_set def test_divide_groups_all_preferences(): n = 3 m = 3 g = 3 participants = [\\"John\\", \\"Jane\\", \\"Alice\\"] preferences = [(\\"John\\", \\"Jane\\"), (\\"Jane\\", \\"Alice\\"), (\\"John\\", \\"Alice\\")] num_groups, groups = divide_groups(n, m, g, participants, preferences) assert num_groups == 3 group_set = [set(group) for group in groups] assert set([\\"John\\"]) in group_set assert set([\\"Jane\\"]) in group_set assert set([\\"Alice\\"]) in group_set","solution":"from itertools import combinations def divide_groups(n, m, g, participants, preferences): from itertools import combinations import sys def is_valid_group(group, preferences): for a, b in combinations(group, 2): if (a, b) in preferences or (b, a) in preferences: return False return True def backtrack(start, current_group, groups, participants, preferences, max_group_size, min_groups): if start == len(participants): if len(groups) < min_groups[0]: min_groups[0] = len(groups) min_groups[1] = [list(group) for group in groups] return for i in range(len(groups)): if len(groups[i]) < max_group_size and is_valid_group(groups[i] + [participants[start]], preferences): groups[i].append(participants[start]) backtrack(start + 1, current_group, groups, participants, preferences, max_group_size, min_groups) groups[i].pop() groups.append([participants[start]]) backtrack(start + 1, current_group + 1, groups, participants, preferences, max_group_size, min_groups) groups.pop() preferences = set(tuple(p) for p in preferences) min_groups = [sys.maxsize, []] backtrack(0, 0, [], participants, preferences, g, min_groups) return min_groups[0], min_groups[1] # Example usage (parse input to match the solution's requirements): def parse_input(): n, m, g = map(int, input().strip().split()) participants = [input().strip() for _ in range(n)] preferences = [tuple(input().strip().split()) for _ in range(m)] return n, m, g, participants, preferences def main(): n, m, g, participants, preferences = parse_input() num_groups, groups = divide_groups(n, m, g, participants, preferences) print(num_groups) for group in groups: print(\\" \\".join(group)) # Uncomment below to run main when not in unit testing # if __name__ == \\"__main__\\": # main()"},{"question":"def countIslands(grid): Returns the number of distinct islands in the grid. >>> countIslands([ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0], ... [1, 0, 1, 1, 1] ... ]) == 4 >>> countIslands([ ... [1, 1, 0, 0, 0], ... [1, 0, 0, 0, 1], ... [0, 0, 1, 1, 0], ... [0, 0, 1, 1, 1] ... ]) == 3 >>> countIslands([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 1 >>> countIslands([ ... [1, 0, 1], ... [0, 0, 0], ... [1, 0, 1] ... ]) == 4 >>> countIslands([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> countIslands([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> countIslands([]) == 0","solution":"def countIslands(grid): Returns the number of distinct islands in the grid. if not grid: return 0 rows, cols = len(grid), len(grid[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def dfs(r, c): if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] == 0 or visited[r][c]: return visited[r][c] = True # Explore all 4 directions dfs(r - 1, c) dfs(r + 1, c) dfs(r, c - 1) dfs(r, c + 1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1 and not visited[r][c]: # Start a new DFS to mark all lands in this island dfs(r, c) island_count += 1 return island_count"},{"question":"def sum_of_even_integers(t, test_cases): Given a number of test cases and lists of integers, returns a list of sums of the even integers for each list. Parameters: t (int): The number of test cases. test_cases (list): A list of lists, where each sublist contains integers. Returns: List[int]: A list containing the sum of even integers for each test case. >>> sum_of_even_integers(2, [[1, 2, 3, 4, 5, 6], [-10, -20, 30, 40, 50]]) [12, 90] >>> sum_of_even_integers(1, [[2, 4, 6, 8, 10]]) [30] >>> sum_of_even_integers(1, [[1, 3, 5, 7, 9]]) [0] >>> sum_of_even_integers(1, [[-2, -4, -6, -8, -10]]) [-30] >>> sum_of_even_integers(1, [[-1, 2, -3, 4, -5, 6]]) [12] >>> sum_of_even_integers(1, [[0, 1, 2, 3, 4]]) [6] >>> sum_of_even_integers(0, []) []","solution":"def sum_of_even_integers(t, test_cases): Given a number of test cases and lists of integers, returns a list of sums of the even integers for each list. Parameters: t (int): The number of test cases. test_cases (list): A list of lists, where each sublist contains integers. Returns: List[int]: A list containing the sum of even integers for each test case. results = [] for case in test_cases: even_sum = sum(x for x in case if x % 2 == 0) results.append(even_sum) return results"},{"question":"def project_management_tool(N, D, dependencies): Determines the order of project completions based on dependencies. Args: N : int : Number of projects D : int : Number of dependencies dependencies : list of tuples : List containing tuples of dependencies (A, B) Returns: str : A space-separated sequence of N integers representing valid order of completion or \\"IMPOSSIBLE\\" >>> project_management_tool(4, 3, [(1, 2), (2, 3), (3, 4)]) '1 2 3 4' >>> project_management_tool(4, 4, [(1, 2), (2, 3), (3, 1), (3, 4)]) 'IMPOSSIBLE' # Implement the function","solution":"from collections import defaultdict, deque def find_project_order(N, D, dependencies): Determines the order of project completions based on dependencies. Args: N : int : Number of projects D : int : Number of dependencies dependencies : list of tuples : List containing tuples of dependencies (A, B) Returns: str : A space-separated sequence of N integers representing valid order of completion or \\"IMPOSSIBLE\\" # Create adjacency list and indegree count adj_list = defaultdict(list) indegree = [0] * (N + 1) for A, B in dependencies: adj_list[A].append(B) indegree[B] += 1 # Initialize queue with nodes having no incoming edges queue = deque([i for i in range(1, N + 1) if indegree[i] == 0]) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in adj_list[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == N: return \\" \\".join(map(str, order)) else: return \\"IMPOSSIBLE\\" # A reusable function for readability and to aid in testing def project_management_tool(N, D, dependencies): return find_project_order(N, D, dependencies)"},{"question":"def find_min_cost_to_connect_cities(n, m, roads): Function to find the minimum cost to connect all cities using Kruskal's MST algorithm. :param n: Number of cities :param m: Number of possible roads :param roads: List of possible roads with their corresponding costs in the format [u, v, w] :return: The minimum cost to connect all cities, or -1 if not possible Example: >>> find_min_cost_to_connect_cities(4, 5, [[1, 2, 1], [1, 3, 4], [2, 3, 2], [3, 4, 3], [1, 4, 3]]) 6 >>> find_min_cost_to_connect_cities(4, 2, [[1, 2, 3], [3, 4, 5]]) -1","solution":"def find_min_cost_to_connect_cities(n, m, roads): Function to find the minimum cost to connect all cities using Kruskal's MST algorithm. :param n: Number of cities :param m: Number of possible roads :param roads: List of possible roads with their corresponding costs in the format [u, v, w] :return: The minimum cost to connect all cities, or -1 if not possible # Helper function to find the root of the set def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) # Helper function to union two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Kruskal's algorithm initialization parent = [] rank = [] result = 0 edges = 0 # Sort all the edges in non-decreasing order by weight roads = sorted(roads, key=lambda item: item[2]) # Initialize disjoint sets for node in range(n): parent.append(node) rank.append(0) for u, v, w in roads: if edges == n - 1: break u -= 1 v -= 1 root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) result += w edges += 1 if edges == n - 1: return result else: return -1"},{"question":"from typing import List from collections import Counter def rearrange_string_by_frequency(t: int, test_cases: List[str]) -> List[str]: Rearranges strings based on character frequency in descending order. If two characters have the same frequency, the lexicographically smaller character comes first. Parameters: t (int): Number of test cases. test_cases (list of str): List of strings to be rearranged. Returns: list of str: List of rearranged strings. >>> rearrange_string_by_frequency(3, [\\"tree\\", \\"cccaaa\\", \\"Aabb\\"]) ['eert', 'aaaccc', 'bbAa'] >>> rearrange_string_by_frequency(1, [\\"abcd\\"]) ['abcd'] >>> rearrange_string_by_frequency(1, [\\"aaaa\\"]) ['aaaa'] >>> rearrange_string_by_frequency(1, [\\"baaaccbdd\\"]) ['aaabbccdd'] pass # your implementation here","solution":"from collections import Counter def rearrange_string_by_frequency(t, test_cases): Rearranges strings based on character frequency in descending order. If two characters have the same frequency, the lexicographically smaller character comes first. Parameters: t (int): Number of test cases. test_cases (list of str): List of strings to be rearranged. Returns: list of str: List of rearranged strings. result = [] for s in test_cases: # Count the frequency of each character in the string freq = Counter(s) # Sort characters first by frequency in descending order then lexicographically sorted_chars = sorted(freq.items(), key=lambda x: (-x[1], x[0])) # Build the result string based on sorted characters and their frequencies rearranged_string = ''.join([char * count for char, count in sorted_chars]) result.append(rearranged_string) return result"},{"question":"def filter_strings_starting_with_a(strings): Accepts a list of strings and returns a list of strings that start with 'a' or 'A'. >>> filter_strings_starting_with_a([\\"apple\\", \\"avocado\\", \\"Apricot\\"]) [\\"apple\\", \\"avocado\\", \\"Apricot\\"] >>> filter_strings_starting_with_a([\\"Banana\\", \\"grape\\", \\"melon\\"]) [] >>> filter_strings_starting_with_a([\\"apple\\", \\"Banana\\", \\"Avocado\\", \\"grape\\", \\"Apricot\\"]) [\\"apple\\", \\"Avocado\\", \\"Apricot\\"] >>> filter_strings_starting_with_a([]) [] >>> filter_strings_starting_with_a([\\"apricot\\"]) [\\"apricot\\"] >>> filter_strings_starting_with_a([\\"banana\\"]) []","solution":"def filter_strings_starting_with_a(strings): Accepts a list of strings and returns a list of strings that start with 'a' or 'A'. result = [s for s in strings if s.lower().startswith('a')] return result"},{"question":"def maxSubarraySumCircular(arr): Find the maximum sum of any subarray (continuous or circular) in the given array. Args: - arr (List[int]): The input array of integers. Returns: - int: The maximum sum of any subarray. >>> maxSubarraySumCircular([1, -2, 3, -2, 5]) 7 >>> maxSubarraySumCircular([8, -1, -3, 8]) 16 pass def process_input(T, test_cases): Process multiple test cases to find the maximum sum of any subarray (continuous or circular). Args: - T (int): Number of test cases. - test_cases (List[Tuple[int, List[int]]]): List containing tuples where each tuple has number of elements 'n' and the array 'arr' of integers. Returns: - List[int]: List containing the maximum subarray sum for each test case. >>> process_input(2, [(5, [1, -2, 3, -2, 5]), (4, [8, -1, -3, 8])]) [7, 16] def test_case1(): T = 2 test_cases = [ (5, [1, -2, 3, -2, 5]), (4, [8, -1, -3, 8]) ] expected = [7, 16] assert process_input(T, test_cases) == expected def test_single_element(): T = 1 test_cases = [ (1, [5]) ] expected = [5] assert process_input(T, test_cases) == expected def test_all_negative(): T = 1 test_cases = [ (5, [-3, -2, -1, -4, -5]) ] expected = [-1] assert process_input(T, test_cases) == expected def test_wrap_around(): T = 1 test_cases = [ (4, [1, -2, 3, 4]) ] expected = [8] assert process_input(T, test_cases) == expected def test_large_array(): T = 1 test_cases = [ (6, [1, 2, 3, 4, 5, -15]) ] expected = [15] assert process_input(T, test_cases) == expected","solution":"def maxSubarraySumCircular(arr): def kadane(nums): current_sum = 0 max_sum = nums[0] for num in nums: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_kadane = kadane(arr) max_wrap = sum(arr) for i in range(len(arr)): arr[i] = -arr[i] max_wrap += kadane(arr) if max_wrap > max_kadane and max_wrap != 0: return max_wrap return max_kadane def process_input(T, test_cases): results = [] for i in range(T): n, arr = test_cases[i] results.append(maxSubarraySumCircular(arr)) return results"},{"question":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[str, List[Tuple[str, int]]], start: str) -> Dict[str, float]: Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph. :param graph: A dictionary where the key is the origin node and value is a list of tuples (target, weight) representing the edges. :param start: The starting node for Dijkstra's algorithm. :return: A dictionary with shortest distances from start node to each node. >>> graph = {'A': [('B', 1), ('C', 4)], 'B': [('C', 2), ('D', 5)], 'C': [('D', 1)], 'D': []} >>> start = 'A' >>> dijkstra(graph, start) {'A': 0, 'B': 1, 'C': 3, 'D': 4}","solution":"import heapq def dijkstra(graph, start): Implements Dijkstra's algorithm to find the shortest path from the start node to all other nodes in the graph. :param graph: A dictionary where the key is the origin node and value is a list of tuples (target, weight) representing the edges. :param start: The starting node for Dijkstra's algorithm. :return: A dictionary with shortest distances from start node to each node. # Initialize distances from start to all other nodes as infinity distances = {node: float('inf') for node in graph} distances[start] = 0 # Priority queue to hold nodes to visit priority_queue = [(0, start)] visited = set() # Set to keep track of visited nodes while priority_queue: # Get the node with the smallest distance current_distance, current_node = heapq.heappop(priority_queue) # If node is already visited, skip it if current_node in visited: continue visited.add(current_node) # Update distances to neighbors for neighbor, weight in graph.get(current_node, []): distance = current_distance + weight # Only update if the new distance is smaller if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"from typing import List, Tuple def min_cost_max_supplies(N: int, E: int, supplies: List[int], edges: List[Tuple[int, int, int]]) -> int: Find the minimum travel cost to any safe house with the maximum supplies. Args: N (int): The number of safe houses. E (int): The number of direct paths. supplies (List[int]): The supply count in each safe house. edges (List[Tuple[int, int, int]]): A list of tuples representing the direct paths, where each tuple consists of three integers: the starting safe house, the ending safe house, and the cost to travel between them. Returns: int: The minimum travel cost to a safe house with the maximum supplies. Examples: >>> min_cost_max_supplies(6, 7, [10, 20, 30, 10, 20, 30], [(1, 2, 5), (1, 3, 10), (2, 3, 5), (2, 4, 10), (3, 5, 5), (4, 6, 5), (5, 6, 10)]) 10 >>> min_cost_max_supplies(1, 0, [10], []) 0 >>> min_cost_max_supplies(2, 1, [10, 20], [(1, 2, 5)]) 5 >>> min_cost_max_supplies(3, 2, [10, 20, 20], [(1, 2, 5), (1, 3, 10)]) 5 >>> min_cost_max_supplies(3, 0, [10, 20, 30], []) inf","solution":"import heapq def min_cost_max_supplies(N, E, supplies, edges): # Convert 1-indexed to 0-indexed for the supplies array supplies = [0] + supplies # Find the maximum supply max_supply = max(supplies) # Identify nodes with maximum supply max_supply_nodes = [i for i in range(1, N+1) if supplies[i] == max_supply] # Create adjacency list for the graph graph = {i: [] for i in range(1, N+1)} for u, v, cost in edges: graph[u].append((v, cost)) graph[v].append((u, cost)) # Implement Dijkstra's algorithm to find the shortest path from node 1 to all other nodes def dijkstra(start): heap = [(0, start)] min_cost = {i: float('inf') for i in range(1, N+1)} min_cost[start] = 0 while heap: current_cost, current_node = heapq.heappop(heap) if current_cost > min_cost[current_node]: continue for neighbor, travel_cost in graph[current_node]: new_cost = current_cost + travel_cost if new_cost < min_cost[neighbor]: min_cost[neighbor] = new_cost heapq.heappush(heap, (new_cost, neighbor)) return min_cost # Get the minimum cost to all nodes from the start node 1 min_cost_from_start = dijkstra(1) # Find the minimum cost to any of the nodes with maximum supplies min_cost_to_max_supplies = float('inf') for node in max_supply_nodes: if min_cost_from_start[node] < min_cost_to_max_supplies: min_cost_to_max_supplies = min_cost_from_start[node] return min_cost_to_max_supplies # Example usage N = 6 E = 7 supplies = [10, 20, 30, 10, 20, 30] edges = [ (1, 2, 5), (1, 3, 10), (2, 3, 5), (2, 4, 10), (3, 5, 5), (4, 6, 5), (5, 6, 10) ] # Expected Output: 10 print(min_cost_max_supplies(N, E, supplies, edges))"},{"question":"def minimum_total_travel_cost(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum total travel cost required to connect all cities. Args: N : int : the number of cities M : int : the number of roads roads : List[Tuple[int, int, int]] : a list of tuples where each tuple contains three integers u, v, and w describing a road between cities u and v with a travel cost w Returns: int : the minimum total travel cost to connect all cities, or -1 if it is not possible to connect all cities. >>> minimum_total_travel_cost(4, 5, [(1, 2, 5), (2, 3, 3), (1, 3, 7), (4, 3, 2), (4, 1, 6)]) 10 >>> minimum_total_travel_cost(3, 3, [(1, 2, 1), (2, 3, 2), (1, 3, 4)]) 3 >>> minimum_total_travel_cost(4, 2, [(1, 2, 1), (3, 4, 5)]) -1 >>> minimum_total_travel_cost(5, 0, []) -1 >>> minimum_total_travel_cost(1, 0, []) 0 >>> minimum_total_travel_cost(4, 6, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2), (1, 4, 3)]) 3 pass def test_minimum_total_travel_cost(): # Test Sample Input N, M = 4, 5 roads = [ (1, 2, 5), (2, 3, 3), (1, 3, 7), (4, 3, 2), (4, 1, 6) ] assert minimum_total_travel_cost(N, M, roads) == 10 # Test Larger Input N, M = 3, 3 roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 4), ] assert minimum_total_travel_cost(N, M, roads) == 3 # Test Case with No Connection Possible N, M = 4, 2 roads = [ (1, 2, 1), (3, 4, 5) ] assert minimum_total_travel_cost(N, M, roads) == -1 # Test Case with All Cities Being Isolated N, M = 5, 0 roads = [] assert minimum_total_travel_cost(N, M, roads) == -1 # Test Case with a Single City N, M = 1, 0 roads = [] assert minimum_total_travel_cost(N, M, roads) == 0 # Test Case with All Cities Connected Directly N, M = 4, 6 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 2), (2, 4, 2), (1, 4, 3) ] assert minimum_total_travel_cost(N, M, roads) == 3","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_total_travel_cost(N, M, roads): if N == 0: return -1 roads.sort(key=lambda x: x[2]) parent = [i for i in range(N)] rank = [0] * N result = [] e = 0 i = 0 while e < N - 1 and i < M: u, v, w = roads[i] i += 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e += 1 result.append((u, v, w)) union(parent, rank, x, y) if len(result) != N - 1: return -1 total_cost = sum([w for u, v, w in result]) return total_cost"},{"question":"def reverse_words(s: str) -> str: This function takes a string s, and returns a new string where each word is reversed but the order of words remains unchanged. >>> reverse_words(\\"Hello World Example\\") \\"olleH dlroW elpmaxE\\" >>> reverse_words(\\"Coding is fun\\") \\"gnidoC si nuf\\" >>> reverse_words(\\" Leading and trailing spaces \\") \\"gnidaeL dna gniliart secaps\\" >>> reverse_words(\\"Multiple spaces\\") \\"elpitluM secaps\\"","solution":"def reverse_words(s): This function takes a string s, and returns a new string where each word is reversed but the order of words remains unchanged. # First, split the string by spaces, this will automatically handle extra spaces words = s.strip().split() # Reverse each word in the list reversed_words = [word[::-1] for word in words] # Join the reversed words with a single space to form the final output string return ' '.join(reversed_words)"},{"question":"def max_product_even_negative(nums): Finds the maximum product of a non-empty subsequence that contains an even number of negative numbers. Examples: >>> max_product_even_negative([1, -2, 3, 4, -5]) 120 >>> max_product_even_negative([-1, -2, -3, 0]) 6 >>> max_product_even_negative([1, -1]) 1","solution":"def max_product_even_negative(nums): Finds the maximum product of a non-empty subsequence that contains an even number of negative numbers. # Filter out zeros since they do not contribute to the product nums = [x for x in nums if x != 0] # Separate positive and negative numbers pos_nums = [x for x in nums if x > 0] neg_nums = [x for x in nums if x < 0] # Sort negative numbers to arrange them neg_nums.sort() # If the number of negative numbers is odd, we remove the least negative number if len(neg_nums) % 2 != 0: neg_nums.pop() # Compute the product product = 1 for num in pos_nums + neg_nums: product *= num return product"},{"question":"def can_place_rooks(n: int, m: int, k: int) -> str: Determines if it's possible to place \`k\` rooks on an \`n\` x \`m\` grid such that no rooks can attack each other. >>> can_place_rooks(3, 3, 2) \\"YES\\" >>> can_place_rooks(2, 3, 3) \\"NO\\"","solution":"def can_place_rooks(n, m, k): Determines if it's possible to place \`k\` rooks on an \`n\` x \`m\` grid such that no rooks can attack each other. :param int n: Number of rows in the grid :param int m: Number of columns in the grid :param int k: Number of rooks to place :return: \\"YES\\" if it's possible to place the rooks, otherwise \\"NO\\" :rtype: str # If k is greater than number of rows or columns, it's not possible to place k rooks if k <= min(n, m): return \\"YES\\" else: return \\"NO\\""},{"question":"def magical_filter(elements): Filters and sorts elements in a list of elements based on specific rules. Each element is represented by its name, type (either \\"energy\\" or \\"healing\\"), energy value, and healing value. 1. All the energy elements are placed before any healing elements. 2. Within the energy elements, they are sorted based on their energy value in non-increasing order. 3. Within the healing elements, they are sorted based on their healing value in non-decreasing order. :param elements: List[Tuple[str, str, int, int]] - List of elements :return: List[str] - List of names of the elements in the filtered order Example ------- >>> input_data = [ ... ('element1', 'energy', 500, 200), ... ('element2', 'healing', 100, 300), ... ('element3', 'energy', 700, 100), ... ('element4', 'healing', 200, 400), ... ('element5', 'energy', 600, 150), ... ('element6', 'healing', 50, 250), ... ('element7', 'energy', 550, 300) ... ] >>> magical_filter(input_data) ['element3', 'element5', 'element7', 'element1', 'element6', 'element2', 'element4'] pass def process_input(input_data): Processes the input which is a string and calls the magical_filter function. Args: input_data : str : input as described in the prompt Returns: list : list of strings representing the names of elements in the filtered order Example: -------- >>> input_data = '''7 ... element1 energy 500 200 ... element2 healing 100 300 ... element3 energy 700 100 ... element4 healing 200 400 ... element5 energy 600 150 ... element6 healing 50 250 ... element7 energy 550 300''' >>> process_input(input_data) ['element3', 'element5', 'element7', 'element1', 'element6', 'element2', 'element4'] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def magical_filter(elements): # Separate energy and healing elements energy_elements = [] healing_elements = [] for element in elements: name, el_type, energy_value, healing_value = element if el_type == \\"energy\\": energy_elements.append((name, energy_value, healing_value)) else: healing_elements.append((name, energy_value, healing_value)) # Sort energy elements by energy value in non-increasing order energy_elements.sort(key=lambda x: x[1], reverse=True) # Sort healing elements by healing value in non-decreasing order healing_elements.sort(key=lambda x: x[2]) # Extract the names in the correct order result = [el[0] for el in energy_elements + healing_elements] return result # Processing input and calling the function def process_input(input_data): lines = input_data.strip().split('n') n = int(lines[0]) elements = [] for i in range(1, n + 1): parts = lines[i].split() name = parts[0] el_type = parts[1] energy_value = int(parts[2]) healing_value = int(parts[3]) elements.append((name, el_type, energy_value, healing_value)) return magical_filter(elements)"},{"question":"def find_fastest_team(t, cases): Determine which team has the shortest total running time for each test case. Args: t (int): The number of test cases. cases (List[Dict]): A list of dictionaries, each containing: - 'n' (int): The number of teams. - 'm' (int): The number of segments in the relay race. - 'distances' (List[int]): The lengths of the segments in meters. - 'teams' (List[List[int]]): The speeds of the members for each team in units per second. Returns: List[int]: A list of team indices (1-based) that have the shortest total running time for each test case. Example: >>> cases = [{ ... 'n': 3, ... 'm': 2, ... 'distances': [100, 200], ... 'teams': [ ... [10, 5], ... [8, 4], ... [12, 6] ... ] ... }] >>> find_fastest_team(1, cases) [3] >>> cases = [{ ... 'n': 3, ... 'm': 2, ... 'distances': [100, 150], ... 'teams': [ ... [10, 15], ... [12, 12], ... [9, 18] ... ] ... }] >>> find_fastest_team(1, cases) [3] >>> cases = [{ ... 'n': 1, ... 'm': 2, ... 'distances': [100, 200], ... 'teams': [ ... [10, 5] ... ] ... }] >>> find_fastest_team(1, cases) [1]","solution":"def find_fastest_team(t, cases): results = [] for i in range(t): n, m, d = cases[i]['n'], cases[i]['m'], cases[i]['distances'] min_total_time = float('inf') best_team_index = -1 for team_index in range(n): speeds = cases[i]['teams'][team_index] total_time = sum(d[j] / speeds[j] for j in range(m)) if total_time < min_total_time: min_total_time = total_time best_team_index = team_index + 1 results.append(best_team_index) return results"},{"question":"def adjust_warehouses(N: int, M: int, initial_items: List[int], instructions: List[Tuple[str, int, int]]) -> List[int]: Adjust the number of items in the warehouses according to the instructions given. >>> adjust_warehouses(4, 3, [100, 200, 300, 400], [('add', 2, 50), ('remove', 3, 100), ('remove', 1, 150)]) [0, 250, 200, 400] >>> adjust_warehouses(4, 0, [100, 200, 300, 400], []) [100, 200, 300, 400] >>> adjust_warehouses(3, 1, [100, 200, 300], [('remove', 2, 300)]) [100, 0, 300] from typing import List, Tuple def test_initial_state(): assert adjust_warehouses(4, 0, [100, 200, 300, 400], []) == [100, 200, 300, 400] def test_add_items(): assert adjust_warehouses(4, 1, [100, 200, 300, 400], [('add', 2, 50)]) == [100, 250, 300, 400] def test_remove_items(): assert adjust_warehouses(4, 1, [100, 200, 300, 400], [('remove', 3, 100)]) == [100, 200, 200, 400] def test_remove_items_below_zero(): assert adjust_warehouses(4, 1, [100, 200, 300, 400], [('remove', 1, 150)]) == [0, 200, 300, 400] def test_combined_operations(): instructions = [ ('add', 2, 50), ('remove', 3, 100), ('remove', 1, 150) ] assert adjust_warehouses(4, 3, [100, 200, 300, 400], instructions) == [0, 250, 200, 400] def test_multiple_add_operations(): instructions = [ ('add', 1, 50), ('add', 1, 50), ('add', 1, 50), ('add', 1, 50) ] assert adjust_warehouses(4, 4, [100, 200, 300, 400], instructions) == [300, 200, 300, 400] def test_multiple_remove_operations(): instructions = [ ('remove', 4, 100), ('remove', 4, 100), ('remove', 4, 100), ('remove', 4, 100) ] assert adjust_warehouses(4, 4, [100, 200, 300, 400], instructions) == [100, 200, 300, 0] def test_no_change(): assert adjust_warehouses(3, 0, [100, 200, 300], []) == [100, 200, 300]","solution":"def adjust_warehouses(N, M, initial_items, instructions): warehouses = initial_items[:] for instruction in instructions: operation, index, value = instruction if operation == 'add': warehouses[index - 1] += value elif operation == 'remove': warehouses[index - 1] = max(warehouses[index - 1] - value, 0) return warehouses"},{"question":"def centered_hexagonal(N: int) -> int: Given an integer N, return the N-th centered hexagonal number modulo 10^9 + 7. The formula used is: H_{n} = 3n(n-1) + 1 >>> centered_hexagonal(1) 1 >>> centered_hexagonal(2) 7 >>> centered_hexagonal(3) 19 >>> centered_hexagonal(4) 37 >>> centered_hexagonal(5) 61 >>> centered_hexagonal(10) 271 >>> centered_hexagonal(1000) 2997001 >>> centered_hexagonal(10**6) 2999997000001 % (10**9 + 7)","solution":"def centered_hexagonal(N): Given an integer N, return the N-th centered hexagonal number modulo 10^9 + 7. The formula used is: H_{n} = 3n(n-1) + 1 MOD = 10**9 + 7 return (3 * N * (N - 1) + 1) % MOD"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if we can partition an array into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False >>> can_partition([3, 3, 3, 4, 5]) True >>> can_partition([2, 2, 3, 5]) False pass # Implement your solution here from solution import can_partition def test_can_partition_1(): assert can_partition([1, 5, 11, 5]) == True def test_can_partition_2(): assert can_partition([1, 2, 3, 5]) == False def test_can_partition_3(): assert can_partition([3, 3, 3, 4, 5]) == True def test_can_partition_4(): assert can_partition([2, 2, 3, 5]) == False def test_can_partition_single_element(): assert can_partition([2]) == False def test_can_partition_equal_pairs(): assert can_partition([10, 10]) == True def test_can_partition_large_elements(): assert can_partition([15, 5, 15, 10, 10, 5]) == True def test_can_partition_all_ones(): assert can_partition([1, 1, 1, 1, 1, 1]) == True def test_can_partition_prime_numbers(): assert can_partition([2, 3, 5, 7, 11, 13]) == False","solution":"def can_partition(nums): Determine if we can partition nums into two subsets with equal sum. total_sum = sum(nums) # If total_sum is odd, cannot partition into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # DP array to store if a sum is possible using elements from the array dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def hackathon_feasibility(n, m, hackers_per_city, sponsors): Determine if it is possible to organize hackathons in multiple cities with given sponsors. Args: n : int - number of cities m : int - number of sponsors hackers_per_city : List[int] - number of hackers in each city sponsors : List[List[int]] - list of sponsors and their city support limits Returns: str : \\"POSSIBLE\\" if all cities can have at least one sponsor and no sponsor's limit is exceeded, otherwise \\"IMPOSSIBLE\\" Examples: >>> hackathon_feasibility(3, 2, [10, 20, 30], [[2, 1, 15, 2, 20], [1, 3, 40]]) 'POSSIBLE' >>> hackathon_feasibility(3, 2, [10, 20, 30], [[1, 1, 25], [2, 2, 15, 3, 40]]) 'IMPOSSIBLE'","solution":"def hackathon_feasibility(n, m, hackers_per_city, sponsors): # Tracks if every city has at least one sponsor city_sponsorship = [0] * n for sponsor in sponsors: c = sponsor[0] sponsor_info = sponsor[1:] supported_cities = {sponsor_info[i * 2] - 1: sponsor_info[i * 2 + 1] for i in range(c)} for city in range(n): if hackers_per_city[city] <= supported_cities.get(city, 0): city_sponsorship[city] += 1 # Check if every city has at least one sponsor if all(sponsor_count > 0 for sponsor_count in city_sponsorship): return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def is_fully_connected(N, connections): Determines if the communication network is fully connected. Parameters: - N (int): Number of drum towers - connections (list of tuple): List of connections between towers Returns: - str: \\"Yes\\" if the network is fully connected, \\"No\\" otherwise >>> is_fully_connected(4, [(1, 2), (3, 4)]) 'No' >>> is_fully_connected(4, [(1, 2), (2, 3), (3, 4)]) 'Yes' >>> is_fully_connected(1, []) 'Yes' >>> is_fully_connected(3, []) 'No' def solve(T, test_cases): Given the number of drum towers and the possible connections between them, determines whether the communication network is fully connected or not for a number of test cases. Parameters: - T (int): The number of test cases - test_cases (list of tuples): Each tuple consists of (N, M, connections) where - N is the number of drum towers, - M is the number of possible connections, - connections is a list of tuples (A, B) indicating connections between drum towers. Returns: - list of str: \\"Yes\\" if the network is fully connected for each test case, \\"No\\" otherwise >>> solve(3, [(4, 2, [(1, 2), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (1, 0, [])]) ['No', 'Yes', 'Yes'] def test_is_fully_connected(): assert is_fully_connected(4, [(1, 2), (3, 4)]) == 'No' assert is_fully_connected(4, [(1, 2), (2, 3), (3, 4)]) == 'Yes' assert is_fully_connected(1, []) == 'Yes' assert is_fully_connected(3, []) == 'No' assert is_fully_connected(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == 'Yes' assert is_fully_connected(5, [(1, 2), (2, 3), (4, 5)]) == 'No' assert is_fully_connected(2, [(1, 2)]) == 'Yes' assert is_fully_connected(3, [(1, 2), (1, 3)]) == 'Yes' assert is_fully_connected(6, [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) == 'Yes' assert is_fully_connected(6, [(1, 2), (1, 3)]) == 'No' assert is_fully_connected(3, [(1, 2), (2, 3), (3, 1)]) == 'Yes' def test_solve(): T = 3 test_cases = [ (4, 2, [(1, 2), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (1, 0, []) ] expected = ['No', 'Yes', 'Yes'] assert solve(T, test_cases) == expected","solution":"def is_fully_connected(N, connections): Determines if the communication network is fully connected. Parameters: - N (int): Number of drum towers - connections (list of tuple): List of connections between towers Returns: - str: \\"Yes\\" if the network is fully connected, \\"No\\" otherwise if N == 1: return \\"Yes\\" from collections import defaultdict, deque graph = defaultdict(list) for A, B in connections: graph[A].append(B) graph[B].append(A) visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) bfs(1) return \\"Yes\\" if len(visited) == N else \\"No\\" def solve(T, test_cases): results = [] for N, M, connections in test_cases: results.append(is_fully_connected(N, connections)) return results"},{"question":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach. # Examples: >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(7) 13 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the n-th Fibonacci number using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: You are given an integer array nums and an integer target. You are tasked with finding all unique combinations in nums such that the numbers add up to target. Each number in nums may only be used once in the combination, and the solution set must not contain duplicate combinations. Args: nums (List[int]): The list of integers. target (int): The target sum. Returns: List[List[int]]: A list of lists containing unique combinations that sum up to target. Examples: >>> combinationSum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combinationSum2([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] # Add your solution here","solution":"from typing import List def combinationSum2(nums: List[int], target: int) -> List[List[int]]: def backtrack(start, end, target, path): if target == 0: results.append(path) return for i in range(start, end): if i > start and nums[i] == nums[i - 1]: continue if nums[i] > target: break backtrack(i + 1, end, target - nums[i], path + [nums[i]]) # Sort the array to handle duplicates and to improve efficiency nums.sort() results = [] backtrack(0, len(nums), target, []) return results"},{"question":"def remove_vowels(s: str) -> str: Returns the input string with all vowels removed. >>> remove_vowels(\\"This is a sample string.\\") \\"Ths s smpl strng.\\" >>> remove_vowels(\\"\\") \\"\\" >>> remove_vowels(\\"bcdfghjklmnpqrstvwxyz\\") \\"bcdfghjklmnpqrstvwxyz\\" >>> remove_vowels(\\"aeiouAEIOU\\") \\"\\" >>> remove_vowels(\\"ThIs Is A TeST StrInG.\\") \\"Ths s TST StrnG.\\" >>> remove_vowels(\\"1234567890!@#%^&*()\\") \\"1234567890!@#%^&*()\\" >>> remove_vowels(None) \\"\\"","solution":"def remove_vowels(s): Returns the input string with all vowels removed. if s is None: return \\"\\" vowels = \\"aeiouAEIOU\\" return ''.join([char for char in s if char not in vowels])"},{"question":"def largest_square_subgrid(grid): Determine the size of the largest square sub-grid that contains only '1's. >>> largest_square_subgrid([ ... \\"11011\\", ... \\"11111\\", ... \\"01110\\", ... \\"01111\\", ... \\"01111\\" ... ]) 3 >>> largest_square_subgrid([ ... \\"0000\\", ... \\"0000\\", ... \\"0000\\" ... ]) 0 >>> largest_square_subgrid([ ... \\"101111\\", ... \\"111110\\", ... \\"101111\\", ... \\"111100\\", ... \\"011111\\", ... \\"111111\\" ... ]) 3 >>> largest_square_subgrid([\\"1\\"]) 1 >>> largest_square_subgrid([\\"0\\"]) 0 >>> largest_square_subgrid([ ... \\"0110\\", ... \\"1111\\", ... \\"1111\\", ... \\"0110\\" ... ]) 2","solution":"def largest_square_subgrid(grid): if not grid: return 0 R = len(grid) C = len(grid[0]) dp = [[0]*C for _ in range(R)] max_side = 0 for i in range(R): for j in range(C): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"from typing import List class Song: Represents a song in the collection. def __init__(self, title: str, artist: str, duration: int): self.title = title self.artist = artist self.duration = duration class SongCollection: Manages a collection of songs, providing methods to add, delete, sort, and get the total duration of songs. def __init__(self): self.songs = [] def add_song(self, song: Song) -> None: Adds a song to the collection. pass def delete_song(self, title: str) -> bool: Deletes a song from the collection based on its title. Returns True if the song was successfully deleted, and False if the song with the given title does not exist. pass def get_sorted_songs(self, by: str) -> List[Song]: Returns a list of songs sorted based on the given attribute. The attribute must be one of 'title', 'artist', or 'duration'. pass def get_total_duration(self) -> int: Returns the total duration of all songs in the collection in seconds. pass # Example usage and test cases def test_song_collection(): song1 = Song(title=\\"Song A\\", artist=\\"Artist A\\", duration=240) song2 = Song(title=\\"Song B\\", artist=\\"Artist B\\", duration=200) song3 = Song(title=\\"Song C\\", artist=\\"Artist A\\", duration=180) collection = SongCollection() collection.add_song(song1) collection.add_song(song2) collection.add_song(song3) assert collection.get_total_duration() == 620 sorted_by_title = collection.get_sorted_songs(by=\\"title\\") assert [song.title for song in sorted_by_title] == [\\"Song A\\", \\"Song B\\", \\"Song C\\"] sorted_by_artist = collection.get_sorted_songs(by=\\"artist\\") assert [song.title for song in sorted_by_artist] == [\\"Song A\\", \\"Song C\\", \\"Song B\\"] sorted_by_duration = collection.get_sorted_songs(by=\\"duration\\") assert [song.title for song in sorted_by_duration] == [\\"Song C\\", \\"Song B\\", \\"Song A\\"] assert collection.delete_song(\\"Song B\\") is True assert collection.delete_song(\\"Song D\\") is False assert collection.get_total_duration() == 420","solution":"from typing import List class Song: def __init__(self, title: str, artist: str, duration: int): self.title = title self.artist = artist self.duration = duration class SongCollection: def __init__(self): self.songs = [] def add_song(self, song: Song) -> None: self.songs.append(song) def delete_song(self, title: str) -> bool: for song in self.songs: if song.title == title: self.songs.remove(song) return True return False def get_sorted_songs(self, by: str) -> List[Song]: if by == \\"title\\": return sorted(self.songs, key=lambda x: x.title) elif by == \\"artist\\": return sorted(self.songs, key=lambda x: x.artist) elif by == \\"duration\\": return sorted(self.songs, key=lambda x: x.duration) else: raise ValueError(\\"Sort by attribute must be 'title', 'artist', or 'duration'\\") def get_total_duration(self) -> int: return sum(song.duration for song in self.songs)"},{"question":"def contains_all_distinct_subarray(nums, k): Determines whether any consecutive subarray of length k in nums contains all distinct integers from the range [1, k]. # Unit Tests def test_sample_input_1(): assert contains_all_distinct_subarray([1, 2, 3, 4, 3, 2, 1], 4) == \\"Yes\\" def test_sample_input_2(): assert contains_all_distinct_subarray([1, 1, 2, 2, 3], 3) == \\"No\\" def test_all_elements_same(): assert contains_all_distinct_subarray([1, 1, 1, 1], 2) == \\"No\\" def test_exact_subarray(): assert contains_all_distinct_subarray([3, 2, 1, 4], 4) == \\"Yes\\" def test_no_matching_subarray(): assert contains_all_distinct_subarray([1, 2, 2, 1, 1], 3) == \\"No\\" def test_large_input(): assert contains_all_distinct_subarray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10) == \\"Yes\\" def test_partial_matching(): assert contains_all_distinct_subarray([1, 2, 2, 3, 4], 4) == \\"No\\"","solution":"def contains_all_distinct_subarray(nums, k): Determines whether any consecutive subarray of length k in nums contains all distinct integers from the range [1, k]. required_set = set(range(1, k + 1)) for i in range(len(nums) - k + 1): if set(nums[i:i + k]) == required_set: return \\"Yes\\" return \\"No\\""},{"question":"def is_k_palindrome(s: str, k: int) -> bool: Determines whether a given string s can be turned into a palindrome by removing at most k characters. Examples: >>> is_k_palindrome(\\"abca\\", 1) True >>> is_k_palindrome(\\"abcda\\", 1) False >>> is_k_palindrome(\\"racecar\\", 0) True >>> is_k_palindrome(\\"abcdef\\", 2) False","solution":"def is_k_palindrome(s, k): Determines whether a given string s can be turned into a palindrome by removing at most k characters. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] n = len(s) lps_length = longest_palindromic_subsequence(s) min_deletions_needed = n - lps_length return min_deletions_needed <= k"},{"question":"def rearrange_array_to_minimize_abs_diff(n, a): Rearranges the array such that the sum of absolute differences between adjacent elements is minimized. :param n: int - Length of the array :param a: List[int] - List of integers :return: List[int] - Rearranged list Examples: rearrange_array_to_minimize_abs_diff(5, [3, 1, 4, 1, 5]) -> [1, 1, 3, 4, 5] rearrange_array_to_minimize_abs_diff(3, [-1, 0, 1]) -> [-1, 0, 1]","solution":"def rearrange_array_to_minimize_abs_diff(n, a): Rearranges the array such that the sum of absolute differences between adjacent elements is minimized. :param n: int - Length of the array :param a: List[int] - List of integers :return: List[int] - Rearranged list # The optimal way to reduce the absolute differences is to sort the array return sorted(a)"},{"question":"def sum_of_path_products(N: int, D: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Given a binary tree of N nodes and a depth limit D, calculate the sum of the products of all paths from the root to all leaves with depth less than or equal to D. Args: N (int): Number of nodes in the tree. D (int): Depth limit. values (List[int]): List of values of the nodes in level-order traversal format. edges (List[Tuple[int, int]]): List of edges defining the tree structure. Return: int: The sum of the products of all root-to-leaf paths with depth less than or equal to D. Example: >>> N, D = 5, 3 >>> values = [1, 2, 3, 4, 5] >>> edges = [(1, 2), (1, 3), (2, 4), (3, 5)] >>> sum_of_path_products(N, D, values, edges) 23 >>> N, D = 1, 1 >>> values = [10] >>> edges = [] >>> sum_of_path_products(N, D, values, edges) 10","solution":"def sum_of_path_products(N, D, values, edges): from collections import defaultdict, deque # Initialize tree from edges tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # BFS to find all paths from root to leaves within depth D def bfs(): queue = deque([(1, values[0], 0)]) visited = set() path_product_sum = 0 while queue: current, prod, depth = queue.popleft() if depth > D: continue visited.add(current) is_leaf = True for neighbor in tree[current]: if neighbor not in visited: is_leaf = False queue.append((neighbor, prod * values[neighbor - 1], depth + 1)) if is_leaf and depth <= D: path_product_sum += prod return path_product_sum return bfs() N, D = 5, 3 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (2, 4), (3, 5)] print(sum_of_path_products(N, D, values, edges)) # Output: 23"},{"question":"def is_reverse_word(input_string: str) -> bool: Determines if the given string is a reverse (palindrome) word. Parameters: input_string (str): A string consisting of alphanumeric characters. Returns: bool: True if the string reads the same backward as forward, False otherwise. >>> is_reverse_word(\\"madam\\") True >>> is_reverse_word(\\"hello\\") False >>> is_reverse_word(\\"racecar\\") True >>> is_reverse_word(\\"python\\") False","solution":"def is_reverse_word(input_string): Determines if the given string is a reverse (palindrome) word. Parameters: input_string (str): A string consisting of alphanumeric characters. Returns: bool: True if the string reads the same backward as forward, False otherwise. return input_string == input_string[::-1]"},{"question":"def analyze_packets(T, packets): Processes multiple packets and determines whether each packet is corrupted based on the sum of sizes of fragments. Parameters: T: int - the number of packets. packets: List of List of int - list containing sequences of space-separated integers representing fragment sizes. Returns: List of str - \\"CORRUPTED\\" or \\"OK\\" for each packet. pass # Unit Tests def test_all_even_sum(): packets = [ [50, 50, 50], # sum = 150 (even) [100, 100], # sum = 200 (even) [30, 70, 100] # sum = 200 (even) ] assert analyze_packets(3, packets) == [\\"OK\\", \\"OK\\", \\"OK\\"] def test_all_odd_sum(): packets = [ [50, 50, 51], # sum = 151 (odd) [100, 99], # sum = 199 (odd) [30, 70, 101] # sum = 201 (odd) ] assert analyze_packets(3, packets) == [\\"CORRUPTED\\", \\"CORRUPTED\\", \\"CORRUPTED\\"] def test_mixed_sums(): packets = [ [50, 50, 50], # sum = 150 (even) [100, 101], # sum = 201 (odd) [30, 70, 100] # sum = 200 (even) ] assert analyze_packets(3, packets) == [\\"OK\\", \\"CORRUPTED\\", \\"OK\\"] def test_single_fragment_packets(): packets = [ [50], # sum = 50 (even) [101], # sum = 101 (odd) [100] # sum = 100 (even) ] assert analyze_packets(3, packets) == [\\"OK\\", \\"CORRUPTED\\", \\"OK\\"] def test_large_number_of_fragments(): packets = [ [i for i in range(1, 101)], # sum of first 100 numbers is 5050 (even) [i for i in range(1, 100)] # sum of first 99 numbers is 4950 (even) ] assert analyze_packets(2, packets) == [\\"OK\\", \\"OK\\"] def test_large_number_of_packets(): T = 1000 packets = [[i for i in range(1, 6)] for _ in range(T)] # multiple packets, each sum = 15 (odd) assert analyze_packets(T, packets) == [\\"CORRUPTED\\"] * T","solution":"def analyze_packets(T, packets): Processes multiple packets and determines whether each packet is corrupted based on the sum of sizes of fragments. Parameters: T: int - the number of packets. packets: List of List of int - list containing sequences of space-separated integers representing fragment sizes. Returns: List of str - \\"CORRUPTED\\" or \\"OK\\" for each packet. results = [] for packet in packets: if sum(packet) % 2 == 0: results.append(\\"OK\\") else: results.append(\\"CORRUPTED\\") return results"},{"question":"from typing import List, Tuple def min_operations_to_equal_elements(arr: List[int]) -> int: Determine the minimum number of operations required to make all the elements in the array equal by removing an element and appending twice its value. >>> min_operations_to_equal_elements([4, 8, 2]) 2 >>> min_operations_to_equal_elements([5, 10, 20, 40]) 3 >>> min_operations_to_equal_elements([1, 1, 1]) 0 >>> min_operations_to_equal_elements([1, 2, 3, 4]) 3 pass def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and determine the minimum number of operations for each to make all the elements in the array equal. >>> process_test_cases([(3, [4, 8, 2]), (4, [5, 10, 20, 40])]) [2, 3] >>> process_test_cases([(2, [1, 2]), (5, [5, 5, 5, 5, 5])]) [1, 0] >>> process_test_cases([(4, [1, 3, 3, 9]), (3, [4, 8, 16])]) [2, 2] pass","solution":"def min_operations_to_equal_elements(arr): from collections import Counter counter = Counter(arr) max_count = max(counter.values()) return len(arr) - max_count def process_test_cases(test_cases): results = [] for case in test_cases: _ = case[0] # length of array is not used array = case[1] result = min_operations_to_equal_elements(array) results.append(result) return results"},{"question":"from typing import List, Tuple def merge_layers(layers: List[List[List[int]]], merge_operations: List[Tuple[int, int]]): Merge the given layers as per the given merge operations. >>> layers = [ ... [[1, 2], [3, 4]], ... [[5, 6], [7, 8]], ... [[1, 2], [3, 4]]] >>> merge_operations = [(1, 2), (2, 3), (1, 3)] >>> merge_layers(layers, merge_operations) >>> layers == [ ... [[5, 6], [7, 8]], ... [[5, 6], [7, 8]], ... [[1, 2], [3, 4]]] True def query_layer(layers: List[List[List[int]]], L: int, R: int, C: int) -> int: Query the brightness value in the specified layer at the specified pixel location. >>> layers = [ ... [[5, 6], [7, 8]], ... [[5, 6], [7, 8]], ... [[1, 2], [3, 4]]] >>> query_layer(layers, 1, 1, 2) 6 >>> query_layer(layers, 2, 1, 1) 5 >>> query_layer(layers, 3, 2, 2) 4 def process_graphics_merging(N: int, M: int, K: int, Q: int, layer_data: List[List[int]], operations: List[Tuple[int, int]], queries: List[Tuple[int, int, int]]) -> List[int]: Process the layers merging and answer the queries about the pixel values. >>> N, M, K, Q = 3, 2, 3, 2 >>> layer_data = [ ... [1, 2], ... [3, 4], ... [5, 6], ... [7, 8], ... [1, 2], ... [3, 4]] >>> operations = [(1, 2), (2, 3), (1, 3)] >>> queries = [(1, 1, 2), (2, 1, 1)] >>> process_graphics_merging(N, M, K, Q, layer_data, operations, queries) [6, 5]","solution":"def merge_layers(layers, merge_operations): N, M = len(layers), len(layers[0]) def merge(A, B): for i in range(M): for j in range(M): layers[A][i][j] = max(layers[A][i][j], layers[B][i][j]) for A, B in merge_operations: merge(A - 1, B - 1) def query_layer(layers, L, R, C): return layers[L - 1][R - 1][C - 1] def process_graphics_merging(N, M, K, Q, layer_data, operations, queries): layers = [] idx = 0 for _ in range(N): layer = [] for _ in range(M): layer.append(layer_data[idx]) idx += 1 layers.append(layer) merge_layers(layers, operations) results = [] for L, R, C in queries: results.append(query_layer(layers, L, R, C)) return results"},{"question":"def max_stamps(n: int, m: int, pages: List[int], stamps: List[int]) -> int: Returns the maximum number of stamps that can be placed in the album. :param n: Number of pages in the album :param m: Number of stamps Alice has :param pages: List of integers representing the slot capacity of each album page :param stamps: List of integers representing the slot requirements of each stamp :return: Maximum number of stamps that can be placed in the album >>> max_stamps(3, 4, [10, 20, 30], [5, 10, 15, 20]) 3 >>> max_stamps(2, 3, [5, 6], [7, 8, 9]) 0","solution":"def max_stamps(n, m, pages, stamps): Returns the maximum number of stamps that can be placed in the album. :param n: Number of pages in the album :param m: Number of stamps Alice has :param pages: List of integers representing the slot capacity of each album page :param stamps: List of integers representing the slot requirements of each stamp :return: Maximum number of stamps that can be placed in the album pages.sort() stamps.sort() page_idx = 0 stamp_idx = 0 count = 0 while page_idx < n and stamp_idx < m: if pages[page_idx] >= stamps[stamp_idx]: count += 1 stamp_idx += 1 page_idx += 1 return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(parent_array): nodes = [TreeNode(i) for i in range(len(parent_array))] root = None for i, p in enumerate(parent_array): if p == -1: root = nodes[i] else: if nodes[p].left is None: nodes[p].left = nodes[i] else: current = nodes[p].left while current.right is not None: current = current.right current.right = nodes[i] return root def flatten_binary_tree_util(root): if not root: return None, None left_head, left_tail = flatten_binary_tree_util(root.left) right_head, right_tail = flatten_binary_tree_util(root.right) if left_head: tail = left_tail if left_tail else left_head tail.right = right_head root.right = left_head root.left = None return root, right_tail if right_tail else tail else: return root, right_tail if right_tail else root def flatten_binary_tree(root): head, _ = flatten_binary_tree_util(root) return head def preorder_traversal(root): result = [] while root: result.append(root.val) root = root.right return result def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] root = build_tree(A) head = flatten_binary_tree(root) results.append(preorder_traversal(head)) return results def solve(T, test_cases): results = process_test_cases(T, test_cases) for result in results: print(\\" \\".join(map(str, result))) def test_flatten_binary_tree(): # Test case 1 T = 2 test_cases = [ (5, [-1, 0, 0, 1, 1]), (3, [-1, 0, 1]), ] assert process_test_cases(T, test_cases) == [ [0, 1, 3, 4, 2], [0, 1, 2], ] def test_single_node(): T = 1 test_cases = [ (1, [-1]), ] assert process_test_cases(T, test_cases) == [ [0], ] def test_line_tree(): T = 1 test_cases = [ (4, [-1, 0, 1, 2]), ] assert process_test_cases(T, test_cases) == [ [0, 1, 2, 3], ] def test_balanced_tree(): T = 1 test_cases = [ (7, [-1, 0, 0, 1, 1, 2, 2]), ] assert process_test_cases(T, test_cases) == [ [0, 1, 3, 4, 2, 5, 6], ] def test_right_skewed_tree(): T = 1 test_cases = [ (3, [-1, 0, 0]), ] assert process_test_cases(T, test_cases) == [ [0, 1, 2], ]","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(parent_array): nodes = [TreeNode(i) for i in range(len(parent_array))] root = None for i, p in enumerate(parent_array): if p == -1: root = nodes[i] else: if nodes[p].left is None: nodes[p].left = nodes[i] else: current = nodes[p].left while current.right is not None: current = current.right current.right = nodes[i] return root def flatten_binary_tree_util(root): if not root: return None, None left_head, left_tail = flatten_binary_tree_util(root.left) right_head, right_tail = flatten_binary_tree_util(root.right) if left_head: tail = left_tail if left_tail else left_head tail.right = right_head root.right = left_head root.left = None return root, right_tail if right_tail else tail else: return root, right_tail if right_tail else root def flatten_binary_tree(root): head, _ = flatten_binary_tree_util(root) return head def preorder_traversal(root): result = [] while root: result.append(root.val) root = root.right return result def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] root = build_tree(A) head = flatten_binary_tree(root) results.append(preorder_traversal(head)) return results def solve(T, test_cases): results = process_test_cases(T, test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"from typing import List def is_palindrome(num: int) -> bool: Check if the given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(131) True >>> is_palindrome(123) False >>> is_palindrome(1) True >>> is_palindrome(0) True def is_prime(num: int) -> bool: Check if the given number is a prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(1) False >>> is_prime(0) False >>> is_prime(-5) False >>> is_prime(997) True def smallest_palindromic_prime(N: int) -> int: Find the smallest palindromic prime number greater than or equal to N. >>> smallest_palindromic_prime(150) 151 >>> smallest_palindromic_prime(1) 2 >>> smallest_palindromic_prime(31) 101 >>> smallest_palindromic_prime(818) 919 >>> smallest_palindromic_prime(200) 313","solution":"def is_palindrome(num): Check if the given number is a palindrome. return str(num) == str(num)[::-1] def is_prime(num): Check if the given number is a prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_palindromic_prime(N): Find the smallest palindromic prime number greater than or equal to N. num = N while True: if is_palindrome(num) and is_prime(num): return num num += 1"},{"question":"def unique_paths(grid): Calculate the number of unique paths from the top-left to the bottom-right in a grid. Only moves to the right and down are allowed, and cells with 1 are blocked. Args: grid (list of list of int): The N x N grid Returns: int: The number of unique paths N = len(grid) # Implementation goes here def solve(T, test_cases): results = [] for case in test_cases: N = case[0] grid = case[1] results.append(unique_paths(grid)) return results test_case_1()","solution":"def unique_paths(grid): Calculate the number of unique paths from the top-left to the bottom-right in a grid. Only moves to the right and down are allowed, and cells with 1 are blocked. Args: grid (list of list of int): The N x N grid Returns: int: The number of unique paths N = len(grid) # If starting or ending cell is blocked, return 0 if grid[0][0] == 1 or grid[N-1][N-1] == 1: return 0 # Initialize a 2D dp array to store the number of ways to reach each cell dp = [[0] * N for _ in range(N)] dp[0][0] = 1 # Starting point for i in range(N): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 # No way to pass through a blocked cell else: if i > 0: dp[i][j] += dp[i-1][j] # Ways to reach from the cell above if j > 0: dp[i][j] += dp[i][j-1] # Ways to reach from the cell to the left return dp[N-1][N-1] def solve(T, test_cases): results = [] for case in test_cases: N = case[0] grid = case[1] results.append(unique_paths(grid)) return results"},{"question":"def is_palindrome(input_string: str) -> str: Check if the input string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization). Args: input_string (str): The string to check. Returns: str: Message indicating whether the input string is a palindrome or not. >>> is_palindrome('racecar') 'This is a palindrome.' >>> is_palindrome('hello') 'This is not a palindrome.' >>> is_palindrome('A man a plan a canal Panama') 'This is a palindrome.' >>> is_palindrome('No lemon, no melon') 'This is a palindrome.'","solution":"def is_palindrome(input_string): Check if the input string is a palindrome. Args: input_string (str): The string to check. Returns: str: Message indicating whether the input string is a palindrome or not. # Remove spaces and punctuation, and convert to lowercase cleaned_string = ''.join(e for e in input_string if e.isalnum()).lower() # Check if the cleaned string is equal to its reverse if cleaned_string == cleaned_string[::-1]: return 'This is a palindrome.' else: return 'This is not a palindrome.'"},{"question":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices i and j in arr such that arr[i] + arr[j] == k. >>> has_pair_with_sum([2, 7, 11, 15, 3], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 10) \\"NO\\" >>> has_pair_with_sum([1, 5, 1], 6) \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, -4], -5) \\"YES\\" >>> has_pair_with_sum([0, 0, 0, 0], 0) \\"YES\\" >>> has_pair_with_sum([1, 2, 3], 4) \\"YES\\" >>> has_pair_with_sum([1, 1, 1, 1], 2) \\"YES\\" >>> has_pair_with_sum([10**9, 10**9 - 1], 2*10**9 - 1) \\"YES\\" >>> has_pair_with_sum([], 5) \\"NO\\"","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct indices i and j in arr such that arr[i] + arr[j] == k. seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def assign_events(T: int, cases: List[Tuple[int, int, int]]) -> List[str]: A company is organizing a series of team-building events for its employees. Each team-building event must be organized by a group of employees, and no employee should lead more than a certain number of events. Additionally, the same group of employees should not lead consecutive events. You are responsible for assigning employees to groups in such a way that these rules are satisfied or determining that it's not possible. Parameters: T (int): The number of test cases. cases (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers M, E, P. - M denotes the number of events. - E denotes the number of employees. - P denotes the maximum number of events that each employee can lead. Returns: List[str]: List of results for each test case. - If there is no valid assignment of employees to events, the result is the integer -1 as a string. - Otherwise, for each valid test case, the result is a string of M space-separated integers. For each valid i, the i-th of these integers should be the number of the group assigned to the i-th event. Employees in the same group are marked with the same number, chosen from 1 to E. Examples: >>> assign_events(2, [(5, 3, 2), (6, 4, 1)]) [\\"1 2 3 1 2\\", \\"-1\\"] >>> assign_events(1, [(10, 2, 4)]) [\\"-1\\"] >>> assign_events(1, [(6, 2, 3)]) [\\"1 2 1 2 1 2\\"]","solution":"def assign_events(T, cases): results = [] for case in cases: M, E, P = case if M > E * P: results.append(\\"-1\\") else: assignment = [] for i in range(M): assignment.append((i % E) + 1) if M > E: valid = True for j in range(1, M): if assignment[j] == assignment[j - 1]: valid = False break if valid: results.append(\\" \\".join(map(str, assignment))) else: results.append(\\"-1\\") else: results.append(\\" \\".join(map(str, assignment))) return results"},{"question":"def unique_sums(N: int, elements: List[int]) -> List[int]: Finds all unique sums that can be generated using exactly two distinct elements from the list. Args: N : int : The number of elements in the list. elements : list : A list of N integers. Returns: list : A list of unique sums sorted in non-decreasing order. >>> unique_sums(4, [1, 2, 3, 4]) [3, 4, 5, 6, 7] >>> unique_sums(1, [5]) [] >>> unique_sums(2, [1, 2]) [3] >>> unique_sums(5, [1, 1, 2, 2, 3]) [2, 3, 4, 5] >>> unique_sums(4, [-1, 1, 2, 3]) [0, 1, 2, 3, 4, 5] >>> unique_sums(3, [-3, -2, -1]) [-5, -4, -3] pass # Your implementation here","solution":"def unique_sums(N, elements): Finds all unique sums that can be generated using exactly two distinct elements from the list. Args: N : int : The number of elements in the list. elements : list : A list of N integers. Returns: list : A list of unique sums sorted in non-decreasing order. sums = set() for i in range(N): for j in range(i + 1, N): sums.add(elements[i] + elements[j]) return sorted(sums) def main(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) elements = list(map(int, data[1:])) results = unique_sums(N, elements) for result in results: print(result)"},{"question":"def count_minimum_adjacent_swaps(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the minimum number of adjacent swaps needed to sort each array from the test cases. >>> count_minimum_adjacent_swaps([(5, [5, 4, 3, 2, 1]), (4, [2, 3, 4, 1])]) [10, 3] >>> count_minimum_adjacent_swaps([(3, [3, 1, 2])]) [2] >>> count_minimum_adjacent_swaps([(2, [1, 2])]) [0]","solution":"def count_minimum_adjacent_swaps(test_cases): results = [] for case in test_cases: arr = case[1] n = len(arr) swaps = 0 for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] swaps += 1 results.append(swaps) return results"},{"question":"def can_transform_to_zero(n: int, x: int, sequence: List[int]) -> str: Determines if it is possible to transform the entire sequence into a sequence where all elements are equal to zero using the allowed operation. >>> can_transform_to_zero(5, 7, [4, 14, 3, 10, 5]) \\"Yes\\" >>> can_transform_to_zero(3, 2, [1, 3, 5]) \\"No\\" >>> can_transform_to_zero(4, 5, [5, 5, 5, 5]) \\"Yes\\" >>> can_transform_to_zero(2, 10, [12, 15]) \\"No\\" >>> can_transform_to_zero(3, 1, [1, 1, 1]) \\"Yes\\" >>> can_transform_to_zero(3, 3, [0, 0, 0]) \\"Yes\\" >>> can_transform_to_zero(3, 1000000000, [999999999, 999999999, 999999999]) \\"No\\" >>> can_transform_to_zero(1, 10, [0]) \\"Yes\\"","solution":"def can_transform_to_zero(n, x, sequence): Determines if it is possible to transform the entire sequence into a sequence where all elements are equal to zero using the allowed operation. :param n: Length of the sequence :param x: Integer for modulo operation :param sequence: List of integers :return: \\"Yes\\" if transformation is possible, \\"No\\" otherwise mod_exists = any(a % x == 0 for a in sequence) return \\"Yes\\" if mod_exists else \\"No\\""},{"question":"import heapq from typing import List def runningMedian(arr: List[int]) -> List[float]: Compute the median after each insertion of an element into the array. Parameters: arr (List[int]): An array of integers. Returns: List[float]: An array of floats where each element is the median after adding an element from the input array. Examples: >>> runningMedian([12, 4, 5, 3, 8, 7]) [12.0, 8.0, 5.0, 4.5, 5.0, 6.0] >>> runningMedian([1]) [1.0] >>> runningMedian([5, 5, 5, 5, 5, 5]) [5.0, 5.0, 5.0, 5.0, 5.0, 5.0] >>> runningMedian([1, 2, 3, 4, 5]) [1.0, 1.5, 2.0, 2.5, 3.0] >>> runningMedian([5, 4, 3, 2, 1]) [5.0, 4.5, 4.0, 3.5, 3.0] >>> runningMedian([100000, 100001, 100002]) [100000.0, 100000.5, 100001.0] >>> runningMedian([-100000, 0, 100000]) [-100000.0, -50000.0, 0.0]","solution":"import heapq def runningMedian(arr): min_heap = [] # Min heap for the right half max_heap = [] # Max heap for the left half (we will use negative values for max heap) medians = [] for number in arr: if not max_heap or number < -max_heap[0]: heapq.heappush(max_heap, -number) else: heapq.heappush(min_heap, number) # Balancing the heaps if len(max_heap) > len(min_heap) + 1: heapq.heappush(min_heap, -heapq.heappop(max_heap)) elif len(min_heap) > len(max_heap): heapq.heappush(max_heap, -heapq.heappop(min_heap)) # Calculate the median if len(max_heap) == len(min_heap): median = (-max_heap[0] + min_heap[0]) / 2.0 else: median = float(-max_heap[0]) medians.append(median) return medians"},{"question":"def check_reading_consistency(T, data): T: int, number of books data: List of tuples, each tuple representing data for a book and contains (ISBN: str, N: int, pages: List[int]) Returns a list of results, each corresponding to a book and in the format (ISBN, \\"YES\\"/\\"NO\\") >>> T = 2 >>> data = [ ... (\\"123456789X\\", 5, [10, 20, 30, 40, 50]), ... (\\"9876543210\\", 6, [15, 20, 15, 25, 30, 35]), ... ] >>> check_reading_consistency(T, data) [('123456789X', 'YES'), ('9876543210', 'NO')]","solution":"def check_reading_consistency(T, data): T: int, number of books data: List of tuples, each tuple represents data for a book and contains (ISBN: str, N: int, pages: List[int]) Returns a list of results, each corresponding to a book and in the format (ISBN, \\"YES\\"/\\"NO\\") results = [] for book in data: isbn, n, pages = book consistent = True for i in range(1, n): if pages[i] < pages[i - 1]: consistent = False break results.append((isbn, \\"YES\\" if consistent else \\"NO\\")) return results"},{"question":"from typing import List import math from functools import reduce def find_gcd_of_list(numbers: List[int]) -> int: Returns the GCD of all numbers in the given list. >>> find_gcd_of_list([12, 15, 18, 27]) 3 >>> find_gcd_of_list([24, 36, 48, 60]) 12 >>> find_gcd_of_list([7, 11, 13]) 1 >>> find_gcd_of_list([2, 3, 5, 7]) 1 >>> find_gcd_of_list([14, 28, 42]) 14 >>> find_gcd_of_list([1, 2, 3]) 1 >>> find_gcd_of_list([10, 10, 10]) 10","solution":"import math from functools import reduce def find_gcd_of_list(numbers): Returns the GCD of all numbers in the given list. return reduce(math.gcd, numbers)"},{"question":"def canFormPalindrome(s): Check if a given string can be made into a palindrome by replacing at most one character. >>> canFormPalindrome(\\"abca\\") True >>> canFormPalindrome(\\"abcdef\\") False >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"radar\\") True >>> canFormPalindrome(\\"mirror\\") False >>> canFormPalindrome(\\"deified\\") True >>> canFormPalindrome(\\"abba\\") True >>> canFormPalindrome(\\"abcaax\\") False >>> canFormPalindrome(\\"\\") True >>> canFormPalindrome(\\"a\\") True","solution":"def canFormPalindrome(s): Check if a given string can be made into a palindrome by replacing at most one character. def is_palindrome_range(i, j): Helper function to check if a substring s[i:j+1] is a palindrome. return all(s[k] == s[j - k + i] for k in range(i, j + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Try to ignore one character from either end return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 # String is already a palindrome return True"},{"question":"def max_book_identifier(n, books): Returns the maximum book identifier after reorganizing the books. Parameters: n (int): Number of books. books (list of int): Initial positions of the books. Returns: int: The maximum book identifier after reorganizing. pass # Unit Test def test_max_book_identifier_sample1(): assert max_book_identifier(5, [1, 5, 3, 8, 6]) == 8 def test_max_book_identifier_sample2(): assert max_book_identifier(4, [2, 4, 1, 3]) == 4 def test_max_book_identifier_sample3(): assert max_book_identifier(3, [2, 10, 8]) == 10 def test_max_book_identifier_empty(): assert max_book_identifier(0, []) == 0 def test_max_book_identifier_single(): assert max_book_identifier(1, [5]) == 5 def test_max_book_identifier_already_sorted(): assert max_book_identifier(5, [1, 2, 3, 4, 5]) == 5 def test_max_book_identifier_reverse_sorted(): assert max_book_identifier(5, [5, 4, 3, 2, 1]) == 5","solution":"def max_book_identifier(n, books): Returns the maximum book identifier after reorganizing the books. Parameters: n (int): Number of books. books (list of int): Initial positions of the books. Returns: int: The maximum book identifier after reorganizing. if not books: return 0 # Sort the book identifiers books.sort() # The maximum book identifier is the last element in the sorted list return books[-1]"},{"question":"def perform_operations(q: int, operations: List[List[str]]) -> List[Union[int, str]]: Perform operations on an array and return results for \\"3\\" type operations. Operations: - \\"1 x\\": Add integer x to the end of the array. - \\"2\\": Remove the last element of the array. - \\"3\\": Print the maximum value in the array. Args: q: Number of operations. operations: List of operations to perform on the array. Returns: List of results for \\"3\\" type operations. >>> perform_operations(9, [[\\"1\\", \\"5\\"], [\\"1\\", \\"10\\"], [\\"3\\"], [\\"2\\"], [\\"3\\"], [\\"1\\", \\"7\\"], [\\"2\\"], [\\"2\\"], [\\"3\\"]]) [10, 5, \\"EMPTY\\"] >>> perform_operations(5, [[\\"1\\", \\"1\\"], [\\"1\\", \\"2\\"], [\\"1\\", \\"3\\"], [\\"2\\"], [\\"3\\"]]) [2] >>> perform_operations(1, [[\\"3\\"]]) [\\"EMPTY\\"] >>> perform_operations(3, [[\\"1\\", \\"-1\\"], [\\"1\\", \\"-2\\"], [\\"3\\"]]) [-1] >>> perform_operations(4, [[\\"1\\", \\"0\\"], [\\"1\\", \\"0\\"], [\\"2\\"], [\\"3\\"]]) [0]","solution":"def perform_operations(q, operations): arr = [] results = [] for operation in operations: if operation[0] == '1': arr.append(int(operation[1])) elif operation[0] == '2': if arr: arr.pop() elif operation[0] == '3': if arr: results.append(max(arr)) else: results.append(\\"EMPTY\\") return results"},{"question":"def minutes_to_duration(minutes: int) -> str: Converts a non-negative integer representing minutes into a string representing the equivalent time duration in days, hours, and minutes. Parameters: minutes (int): A non-negative integer representing the number of minutes. Returns: str: A string in the format 'dd:hh:mm'. >>> minutes_to_duration(0) \\"00:00:00\\" >>> minutes_to_duration(5) \\"00:00:05\\" >>> minutes_to_duration(1445) \\"01:00:05\\" >>> minutes_to_duration(1505) \\"01:01:05\\" >>> minutes_to_duration(43205) \\"30:00:05\\"","solution":"def minutes_to_duration(minutes): Converts a non-negative integer representing minutes into a string representing the equivalent time duration in days, hours, and minutes. Parameters: minutes (int): A non-negative integer representing the number of minutes. Returns: str: A string in the format 'dd:hh:mm'. if minutes < 0: raise ValueError(\\"Input must be a non-negative integer\\") days = minutes // (24 * 60) remaining_minutes = minutes % (24 * 60) hours = remaining_minutes // 60 minutes = remaining_minutes % 60 return f\\"{days:02}:{hours:02}:{minutes:02}\\""},{"question":"def min_jumps_to_reach_end(N, M, A): Returns the minimum number of jumps required to reach the bottom-right corner of the grid, or -1 if it's not possible. pass def process_test_cases(T, test_cases): Processes multiple test cases and returns the results as a list of integers for each test case. Each integer represents the minimum number of jumps required to reach the bottom-right corner of the grid, or -1 if it's not possible. >>> process_test_cases(2, [(3, 3, [[2, 3, 1], [1, 2, 2], [1, 1, 1]]), (2, 2, [[2, 1], [1, 0]])]) [3, -1] pass import pytest def test_min_jumps_to_reach_end(): test_cases = [ (3, 3, [[2, 3, 1], [1, 2, 2], [1, 1, 1]]), (2, 2, [[2, 1], [1, 0]]) ] expected = [3, -1] assert process_test_cases(2, test_cases) == expected def test_single_element(): test_cases = [ (1, 1, [[0]]), (1, 1, [[1]]) ] expected = [0, 0] assert process_test_cases(2, test_cases) == expected def test_impossible_case(): test_cases = [ (3, 3, [[2, 3, 4], [1, 3, 3], [4, 4, 4]]) ] expected = [-1] assert process_test_cases(1, test_cases) == expected def test_minimal_jumps(): test_cases = [ (4, 4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) ] expected = [6] assert process_test_cases(1, test_cases) == expected def test_larger_grid(): test_cases = [ (5, 5, [[2, 3, 1, 1, 1], [2, 2, 2, 3, 1], [1, 2, 2, 2, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]) ] expected = [5] assert process_test_cases(1, test_cases) == expected","solution":"from collections import deque def min_jumps_to_reach_end(N, M, A): Returns the minimum number of jumps required to reach the bottom-right corner of the grid, or -1 if it's not possible. directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque([(0, 0, 0)]) # (i, j, steps) visited = [[False] * M for _ in range(N)] while queue: i, j, steps = queue.popleft() if i == N - 1 and j == M - 1: return steps if visited[i][j]: continue visited[i][j] = True jump = A[i][j] for di, dj in directions: ni, nj = i + jump * di, j + jump * dj if 0 <= ni < N and 0 <= nj < M and not visited[ni][nj]: queue.append((ni, nj, steps + 1)) return -1 def process_test_cases(T, test_cases): results = [] for case in test_cases: N, M, A = case result = min_jumps_to_reach_end(N, M, A) results.append(result) return results"},{"question":"def min_watering_operations(n: int, h: int, heights: List[int]) -> int: Determines the minimum number of watering operations required to ensure that all flowers eventually reach or exceed a certain height. Args: n (int): The number of flowers. h (int): The required height. heights (List[int]): A list of integers representing the initial heights of the flowers. Returns: int: The minimum number of watering operations required to meet the height requirement. Examples: >>> min_watering_operations(5, 10, [3, 6, 2, 8, 4]) 8 >>> min_watering_operations(3, 3, [0, 0, 0]) 3","solution":"def min_watering_operations(n, h, heights): # Number of operations required to make each flower reach the height h, is determined by the maximum difference # between the desired height h and the current height of any flower max_diff = max(h - height for height in heights) return max_diff"},{"question":"from typing import List def combination_sum2(candidates: List[int], target: int) -> List[List[int]]: Find all unique combinations in the array where the chosen numbers sum up to the target. Each number in the array may only be used once in the combination. The solution set must not contain duplicate combinations. >>> combination_sum2([10, 1, 2, 7, 6, 1, 5], 8) [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] >>> combination_sum2([2, 5, 2, 1, 2], 5) [[1, 2, 2], [5]] pass def test_combination_sum2_example1(): candidates = [10, 1, 2, 7, 6, 1, 5] target = 8 expected = [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]] assert sorted(combination_sum2(candidates, target)) == sorted(expected) def test_combination_sum2_example2(): candidates = [2, 5, 2, 1, 2] target = 5 expected = [[1, 2, 2], [5]] assert sorted(combination_sum2(candidates, target)) == sorted(expected) def test_combination_sum2_no_combinations(): candidates = [3, 9, 20] target = 8 expected = [] assert combination_sum2(candidates, target) == expected def test_combination_sum2_single_candidate_equals_target(): candidates = [5] target = 5 expected = [[5]] assert combination_sum2(candidates, target) == expected def test_combination_sum2_all_same_candidates(): candidates = [1, 1, 1, 1] target = 2 expected = [[1, 1]] assert combination_sum2(candidates, target) == expected","solution":"def combination_sum2(candidates, target): def backtrack(start, path, target): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(candidates)): if i > start and candidates[i] == candidates[i-1]: continue backtrack(i + 1, path + [candidates[i]], target - candidates[i]) candidates.sort() result = [] backtrack(0, [], target) return result"},{"question":"def first_unique(numbers: list) -> int: Returns the first unique (non-repeating) integer from the list of integers. If there is no unique integer, return None. Args: numbers (list of int): List of integers which may contain both negative and positive integers. Returns: int or None: The first unique integer, or None if there is no unique integer. >>> first_unique([4, 5, 1, 2, 0, 4]) 5 >>> first_unique([4, 4, 4, 4]) None >>> first_unique([]) None >>> first_unique([7]) 7 >>> first_unique([8, 6, 7, 5, 3, 0, 9]) 8 >>> first_unique([-1, -2, -1, 3, 2, 3, 2]) -2 >>> first_unique([10, 20, 10, 30, 40, 30, 50]) 20","solution":"def first_unique(numbers): Returns the first unique (non-repeating) integer from the list of integers. If there is no unique integer, return None. Args: numbers (list of int): List of integers which may contain both negative and positive integers. Returns: int or None: The first unique integer, or None if there is no unique integer. # Count the occurrences of each number counts = {} for number in numbers: if number in counts: counts[number] += 1 else: counts[number] = 1 # Find the first unique number for number in numbers: if counts[number] == 1: return number return None"},{"question":"def topKFrequent(nums, k): Returns the k most frequent elements in the array nums. >>> topKFrequent([1, 1, 1, 2, 2, 3], 2) [1, 2] >>> topKFrequent([4, 4, 4, 4, 3, 3, 2, 2, 1, 1], 1) [4]","solution":"def topKFrequent(nums, k): Returns the k most frequent elements in the array nums. from collections import Counter # Count the frequency of each element in the array frequency = Counter(nums) # Get the k most common elements most_common_elements = frequency.most_common(k) # Extract just the elements from the most_common function results result = [element for element, _ in most_common_elements] return result"},{"question":"def find_peak_element(nums): Finds a peak element and returns its index. A peak element is an element that is greater than its neighbors. The algorithm implemented here runs in logarithmic complexity. >>> find_peak_element([1, 2, 3, 1]) 2 >>> find_peak_element([1, 2, 1, 3, 5, 6, 4]) 5 >>> find_peak_element([3, 2, 1]) 0 >>> find_peak_element([1, 2, 3]) 2 >>> find_peak_element([1]) 0 >>> find_peak_element([2, 1]) 0 >>> find_peak_element([1, 2]) 1 >>> find_peak_element([1, 2, 3, 4, 5]) 4 >>> find_peak_element([5, 4, 3, 2, 1]) 0 >>> find_peak_element(list(range(1, 10001)) + list(range(10000, 0, -1))) 10000","solution":"def find_peak_element(nums): Finds a peak element and returns its index. A peak element is an element that is greater than its neighbors. The algorithm implemented here runs in logarithmic complexity. left, right = 0, len(nums) - 1 while left < right: mid = (left + right) // 2 if nums[mid] > nums[mid + 1]: # We are in a downward slope, so the peak must be on the left side (including mid) right = mid else: # We are in an upward slope, so the peak must be on the right side (excluding mid) left = mid + 1 # When left == right, we have found the peak element return left"},{"question":"def find_chocolates(m: int, k: int, ask) -> tuple: Finds two indices of chocolates chosen by Nura based on the sweetness levels using up to 60 queries. Parameters: m (int): Total number of chocolates. k (int): Number of chocolates chosen by Nura. ask (function): Function to ask the query \\"t > i + j\\". Should return \\"YES\\" or \\"NO\\". Returns: tuple: Indices (x, y) of any two chosen chocolates. >>> find_chocolates(4, 2, lambda i, j, t: \\"YES\\" if (i == 2 and j == 3 and t == 4) else \\"NO\\") (2, 3) >>> find_chocolates(4, 2, lambda i, j, t: \\"YES\\" if (i == 1 and j == 3 and t == 4) else \\"NO\\") (1, 3) pass # Implement the solution here.","solution":"def find_chocolates(m, k, ask): Finds two indices of chocolates chosen by Nura based on the sweetness levels. Parameters: m (int): Total number of chocolates. k (int): Number of chocolates chosen by Nura. ask (function): Function to ask the query \\"t > i + j\\". Returns: tuple: Indices of the two chosen chocolates. for i in range(1, m): for j in range(i + 1, m + 1): for t in range(1, m + 1): if t != i and t != j: response = ask(i, j, t) if response == \\"YES\\": return (i, j) return None"},{"question":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.sum_tree = [0] * (4 * self.n) self.min_tree = [float('inf')] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.sum_tree[node] = self.min_tree[node] = self.data[start] else: mid = (start + end) // 2 self.build(2 * node + 1, start, mid) self.build(2 * node + 2, mid + 1, end) self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2] self.min_tree[node] = min(self.min_tree[2 * node + 1], self.min_tree[2 * node + 2]) def update(self, idx, val, node=0, start=0, end=None): if end is None: end = self.n - 1 if start == end: self.sum_tree[node] = self.min_tree[node] = val self.data[idx] = val else: mid = (start + end) // 2 if start <= idx <= mid: self.update(idx, val, 2 * node + 1, start, mid) else: self.update(idx, val, 2 * node + 2, mid + 1, end) self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2] self.min_tree[node] = min(self.min_tree[2 * node + 1], self.min_tree[2 * node + 2]) def range_query(self, l, r, node=0, start=0, end=None, query_type=\\"sum\\"): if end is None: end = self.n - 1 if r < start or l > end: return 0 if query_type == \\"sum\\" else float('inf') if l <= start and end <= r: return self.sum_tree[node] if query_type == \\"sum\\" else self.min_tree[node] mid = (start + end) // 2 left_query = self.range_query(l, r, 2 * node + 1, start, mid, query_type) right_query = self.range_query(l, r, 2 * node + 2, mid + 1, end, query_type) if query_type == \\"sum\\": return left_query + right_query else: return min(left_query, right_query) def handle_queries(n, queries, data): Handle a list of queries on a list of integers. Parameters: n (int): The size of the list. queries (List[str]): The list of queries to process. data (List[int]): The initial elements of the list. Returns: List[int]: The results of the queries of type \`Q l r\` or \`M l r\`. >>> handle_queries(5, [\\"Q 1 3\\", \\"M 2 4\\", \\"U 3 10\\", \\"Q 1 3\\", \\"M 2 4\\"], [1, 2, 3, 4, 5]) [6, 2, 13, 2] >>> handle_queries(3, [\\"Q 1 3\\", \\"M 1 2\\", \\"U 1 0\\", \\"Q 1 3\\", \\"M 2 3\\"], [2, 3, 1]) [6, 2, 4, 1] # Function implementation here","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.sum_tree = [0] * (4 * self.n) self.min_tree = [float('inf')] * (4 * self.n) self.build(0, 0, self.n - 1) def build(self, node, start, end): if start == end: self.sum_tree[node] = self.min_tree[node] = self.data[start] else: mid = (start + end) // 2 self.build(2 * node + 1, start, mid) self.build(2 * node + 2, mid + 1, end) self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2] self.min_tree[node] = min(self.min_tree[2 * node + 1], self.min_tree[2 * node + 2]) def update(self, idx, val, node=0, start=0, end=None): if end is None: end = self.n - 1 if start == end: self.sum_tree[node] = self.min_tree[node] = val self.data[idx] = val else: mid = (start + end) // 2 if start <= idx <= mid: self.update(idx, val, 2 * node + 1, start, mid) else: self.update(idx, val, 2 * node + 2, mid + 1, end) self.sum_tree[node] = self.sum_tree[2 * node + 1] + self.sum_tree[2 * node + 2] self.min_tree[node] = min(self.min_tree[2 * node + 1], self.min_tree[2 * node + 2]) def range_query(self, l, r, node=0, start=0, end=None, query_type=\\"sum\\"): if end is None: end = self.n - 1 if r < start or l > end: return 0 if query_type == \\"sum\\" else float('inf') if l <= start and end <= r: return self.sum_tree[node] if query_type == \\"sum\\" else self.min_tree[node] mid = (start + end) // 2 left_query = self.range_query(l, r, 2 * node + 1, start, mid, query_type) right_query = self.range_query(l, r, 2 * node + 2, mid + 1, end, query_type) if query_type == \\"sum\\": return left_query + right_query else: return min(left_query, right_query) def handle_queries(n, queries, data): tree = SegmentTree(data) res = [] for query in queries: parts = query.split() if parts[0] == 'Q': l, r = int(parts[1]) - 1, int(parts[2]) - 1 res.append(tree.range_query(l, r, query_type=\\"sum\\")) elif parts[0] == 'M': l, r = int(parts[1]) - 1, int(parts[2]) - 1 res.append(tree.range_query(l, r, query_type=\\"min\\")) elif parts[0] == 'U': index, value = int(parts[1]) - 1, int(parts[2]) tree.update(index, value) return res"},{"question":"class Scoreboard: def __init__(self): Initialize a scoreboard to keep track of participants' scores. pass def add(self, name, score): Add a new participant or update the score of an existing participant. Args: name (str): The name of the participant. score (int): The score of the participant. pass def top(self, k): Retrieve the top k participants with the highest scores. Args: k (int): The number of top participants to retrieve. Returns: str: Space-separated names of the top k participants. pass def process_operations(operations): Process a list of operations on the scoreboard. Args: operations (List[str]): List of operations to be performed. Returns: List[str]: Results of \\"top k\\" operations. >>> operations = [ \\"add Alice 50\\", \\"add Bob 75\\", \\"add Alice 100\\", \\"top 1\\", \\"add Carol 100\\", \\"add Bob 50\\", \\"top 3\\" ] >>> process_operations(operations) [\\"Alice\\", \\"Alice Carol Bob\\"] pass","solution":"class Scoreboard: def __init__(self): self.scores = {} def add(self, name, score): self.scores[name] = score def top(self, k): sorted_scores = sorted(self.scores.items(), key=lambda x: (-x[1], x[0])) top_k = [name for name, score in sorted_scores[:k]] return \\" \\".join(top_k) def process_operations(operations): scoreboard = Scoreboard() results = [] for operation in operations: parts = operation.split() if parts[0] == \\"add\\": name = parts[1] score = int(parts[2]) scoreboard.add(name, score) elif parts[0] == \\"top\\": k = int(parts[1]) results.append(scoreboard.top(k)) return results"},{"question":"def largest_non_divisible_subset_length(n, k, arr): Given an array of integers, identify the largest subset such that the sum of no two elements in the subset is divisible by a given integer k. >>> largest_non_divisible_subset_length(4, 3, [1, 7, 2, 4]) 3 >>> largest_non_divisible_subset_length(4, 4, [19, 10, 12, 10]) 3","solution":"def largest_non_divisible_subset_length(n, k, arr): remainder_count = [0] * k for num in arr: remainder_count[num % k] += 1 subset_size = min(remainder_count[0], 1) # Only one element with remainder 0 can be included # Loop through each remainder pair for i in range(1, (k // 2) + 1): if i != k - i: subset_size += max(remainder_count[i], remainder_count[k - i]) else: subset_size += min(remainder_count[i], 1) return subset_size"},{"question":"def check_strong_password(l_a: int, l_b: int, passwords: List[str]) -> List[str]: This function checks if a list of passwords are strong according to the given policy. Parameters: l_a (int): Minimum length of the password l_b (int): Maximum length of the password passwords (list): List of passwords to be checked Returns: list: List of \\"Yes\\" or \\"No\\" indicating whether the passwords are strong or not A password is considered strong if: 1. It contains at least one lowercase letter. 2. It contains at least one uppercase letter. 3. It contains at least one digit. 4. It contains at least one special character from the set \`!@#%^&*()-+\`. 5. Its total length must be between l_a and l_b (inclusive). >>> check_strong_password(6, 12, [\\"Abc123!\\", \\"Password123\\", \\"WeakP@ss\\"]) ['Yes', 'No', 'No'] >>> check_strong_password(8, 15, [\\"Strong1!\\", \\"ValidP@ssword1\\"]) ['Yes', 'Yes'] >>> check_strong_password(6, 12, [\\"PASSWORD123!\\", \\"1234AB!@#\\"]) ['No', 'No'] >>> check_strong_password(6, 12, [\\"password123!\\", \\"12ab!@34\\"]) ['No', 'No'] >>> check_strong_password(6, 12, [\\"Abcdef!\\", \\"Password!\\"]) ['No', 'No'] >>> check_strong_password(6, 12, [\\"Abc12345\\", \\"StrongPass1\\"]) ['No', 'No'] >>> check_strong_password(8, 10, [\\"Short1!\\", \\"VeryLong1!Password\\"]) ['No', 'No'] >>> check_strong_password(6, 8, [\\"A1a!ba\\", \\"B2b@no3\\"]) ['Yes', 'Yes']","solution":"import re def check_strong_password(l_a, l_b, passwords): This function checks if a list of passwords are strong according to the given policy. Parameters: l_a (int): Minimum length of the password l_b (int): Maximum length of the password passwords (list): List of passwords to be checked Returns: list: List of \\"Yes\\" or \\"No\\" indicating whether the passwords are strong or not results = [] special_chars = \\"!@#%^&*()-+\\" for password in passwords: if not (l_a <= len(password) <= l_b): results.append(\\"No\\") continue if not re.search(r'[a-z]', password): results.append(\\"No\\") continue if not re.search(r'[A-Z]', password): results.append(\\"No\\") continue if not re.search(r'd', password): results.append(\\"No\\") continue if not any(char in special_chars for char in password): results.append(\\"No\\") continue results.append(\\"Yes\\") return results"},{"question":"def min_contiguous_substrings(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Calculate the minimum number of contiguous substrings containing only '1's in any rearrangement of \`s\`. >>> min_contiguous_substrings(3, [(5, \\"10101\\"), (4, \\"1100\\"), (6, \\"111000\\")]) [1, 1, 1] >>> min_contiguous_substrings(2, [(2, \\"10\\"), (2, \\"01\\")]) [1, 1] results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] if '1' in s: results.append(1) # At least one substring of '1's else: results.append(0) # No '1' substrings return results # Unit Tests def test_min_contiguous_substrings_single_test_case(): assert min_contiguous_substrings(1, [(5, \\"10101\\")]) == [1] assert min_contiguous_substrings(1, [(4, \\"1100\\")]) == [1] assert min_contiguous_substrings(1, [(6, \\"111000\\")]) == [1] assert min_contiguous_substrings(1, [(3, \\"000\\")]) == [0] assert min_contiguous_substrings(1, [(6, \\"000000\\")]) == [0] def test_min_contiguous_substrings_multiple_test_cases(): assert min_contiguous_substrings(3, [(5, \\"10101\\"), (4, \\"1100\\"), (6, \\"111000\\")]) == [1, 1, 1] assert min_contiguous_substrings(2, [(2, \\"10\\"), (2, \\"01\\")]) == [1, 1] def test_min_contiguous_substrings_edge_cases(): assert min_contiguous_substrings(1, [(1, \\"0\\")]) == [0] assert min_contiguous_substrings(1, [(1, \\"1\\")]) == [1] assert min_contiguous_substrings(2, [(100, \\"1\\"*100), (100, \\"0\\"*100)]) == [1, 0]","solution":"def min_contiguous_substrings(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] s = test_cases[i][1] if '1' in s: results.append(1) # At least one substring of '1's else: results.append(0) # No '1' substrings return results # Input Reading and Function Execution def main(): import sys input = sys.stdin.read data = input().strip().split() t = int(data[0]) test_cases = [] index = 1 for _ in range(t): n = int(data[index]) s = data[index + 1] test_cases.append((n, s)) index += 2 results = min_contiguous_substrings(t, test_cases) for result in results: print(result)"},{"question":"def total_fencing_cost(l: int, w: int, c: int) -> int: Calculates the total cost of fencing Alice's garden. Parameters: l (int): The length of the garden in meters. w (int): The width of the garden in meters. c (int): The cost per meter of fencing in dollars. Returns: int: The total cost of the fencing in dollars. >>> total_fencing_cost(10, 5, 2) 60 >>> total_fencing_cost(15, 10, 3) 150 >>> total_fencing_cost(25, 30, 4) 440 >>> total_fencing_cost(1, 1, 1) 4 >>> total_fencing_cost(1000, 1000, 100) 400000 >>> total_fencing_cost(500, 300, 50) 80000","solution":"def total_fencing_cost(l, w, c): Calculates the total cost of fencing Alice's garden. Parameters: l (int): The length of the garden in meters. w (int): The width of the garden in meters. c (int): The cost per meter of fencing in dollars. Returns: int: The total cost of the fencing in dollars. perimeter = 2 * (l + w) total_cost = perimeter * c return total_cost"},{"question":"def find_dominant_integer(T, test_cases): Determine if there exists a dominant integer in the array A for each test case. An integer B is called a dominant integer if the count of B in array A is strictly greater than the count of any other number in array A. Parameters: T (int): Number of test cases test_cases (List[Tuple[int, List[int]]]): A list containing T tuples, each containing the value of N (number of integers in the array) and the list of integers. Returns: List[int]: A list containing the dominant integer or -1 for each test case. >>> find_dominant_integer(3, [(5, [3, 3, 4, 2, 4]), (6, [7, 1, 1, 1, 2, 3]), (4, [5, 5, 5, 5])]) [-1, 1, 5] >>> find_dominant_integer(1, [(4, [1, 2, 3, 4])]) [-1] >>> find_dominant_integer(1, [(5, [1, 1, 2, 2, 3])]) [-1] >>> find_dominant_integer(1, [(1, [1000000])]) [1000000] >>> find_dominant_integer(1, [(5, [9, 9, 9, 9, 9])]) [9]","solution":"def find_dominant_integer(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] # Initialize frequency dictionary frequency = {} for num in A: if num in frequency: frequency[num] += 1 else: frequency[num] = 1 # Determine if there is a dominant integer max_freq = max(frequency.values()) dominant_candidates = [num for num, freq in frequency.items() if freq == max_freq] if len(dominant_candidates) == 1: results.append(dominant_candidates[0]) else: results.append(-1) return results"},{"question":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise in place. :param matrix: List of lists where each sublist represents a row of the matrix pass def process_matrices(input_string): Processes the input string containing multiple datasets of matrices and returns the rotated matrices. :param input_string: Input string following the described format :return: List of matrices rotated 90 degrees clockwise pass # Test cases def test_rotate_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix) assert matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] matrix = [ [1, 2], [3, 4] ] rotate_matrix(matrix) assert matrix == [ [3, 1], [4, 2] ] def test_process_matrices(): input_string = 3 1 2 3 4 5 6 7 8 9 2 1 2 3 4 -1 expected_output = [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [3, 1], [4, 2] ] ] assert process_matrices(input_string) == expected_output","solution":"def rotate_matrix(matrix): Rotates a square matrix 90 degrees clockwise in place. :param matrix: List of lists where each sublist represents a row of the matrix n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[n - 1 - j][i] matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] matrix[j][n - 1 - i] = temp def process_matrices(input_string): Processes the input string containing multiple datasets of matrices and returns the rotated matrices. :param input_string: Input string following the described format :return: List of matrices rotated 90 degrees clockwise lines = input_string.strip().split(\\"n\\") i = 0 results = [] while i < len(lines): n = int(lines[i]) if n == -1: break matrix = [] for j in range(1, n + 1): matrix.append(list(map(int, lines[i + j].strip().split()))) rotate_matrix(matrix) results.append(matrix) i += n + 1 return results"},{"question":"def can_buy_snack(price): Determines if it is possible to buy a snack of given price using combinations of Coin A (5 units) and Coin B (7 units). :param price: Integer representing the price of the snack. :return: \\"Yes\\" if possible to buy the snack with combinations of Coin A and B, else \\"No\\".","solution":"def can_buy_snack(price): Determines if it is possible to buy a snack of given price using combinations of Coin A (5 units) and Coin B (7 units). :param price: Integer representing the price of the snack. :return: \\"Yes\\" if possible to buy the snack with combinations of Coin A and B, else \\"No\\". for a in range(price // 5 + 1): for b in range(price // 7 + 1): if 5 * a + 7 * b == price: return \\"Yes\\" return \\"No\\""},{"question":"def sort_meal_kits(data: str) -> List[str]: Sort meal kits by their timestamps from oldest to newest. Args: data : str : Input data string representing multiple datasets of meal kits. Returns: List[str] : A list of meal kit IDs ordered from oldest to newest based on their timestamps. Example: >>> data = \\"3nA124 2022-01-15nB567 2022-01-10nC890 2022-01-12n-n2nD345 2022-05-20nE678 2022-04-15n-\\" >>> sort_meal_kits(data) [\\"B567\\", \\"C890\\", \\"A124\\", \\"E678\\", \\"D345\\"]","solution":"def sort_meal_kits(data): datasets = data.strip().split(\\"n-n\\") result = [] for dataset in datasets: lines = dataset.split(\\"n\\") n = int(lines[0]) kits = [] for line in lines[1:n + 1]: id_, date = line.split() kits.append((id_, date)) kits.sort(key=lambda x: x[1]) for kit in kits: result.append(kit[0]) return result"},{"question":"def is_valid_game_setup(num_tests: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determine if the game setup is valid for each provided configuration. A game setup consists of the initial positions and ranges for all players. The game is considered valid if and only if no two players can move to the same position on the board. Parameters: num_tests (int): Number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases where each test case is represented by a tuple containing the number of players and a list of tuples with the starting position and the movement range of each player. Returns: List[str]: List of results for each test case, \\"YES\\" if the game setup is valid, otherwise \\"NO\\". pass # Implement the solution here # EXAMPLE USAGE # num_tests, test_cases = parse_input() # results = is_valid_game_setup(num_tests, test_cases) # for result in results: # print(result) # Unit Test def test_is_valid_game_setup(): # Test cases from the prompt num_tests_1 = 2 test_cases_1 = [ (3, [(1, 2), (5, 1), (3, 2)]), (2, [(-3, 3), (4, 2)]) ] assert is_valid_game_setup(num_tests_1, test_cases_1) == [\\"NO\\", \\"YES\\"] # Additional test cases num_tests_2 = 1 test_cases_2 = [ (2, [(0, 1), (3, 1)]) ] assert is_valid_game_setup(num_tests_2, test_cases_2) == [\\"YES\\"] num_tests_3 = 1 test_cases_3 = [ (4, [(-10, 5), (-2, 1), (3, 2), (7, 1)]) ] assert is_valid_game_setup(num_tests_3, test_cases_3) == [\\"YES\\"] num_tests_4 = 1 test_cases_4 = [ (3, [(-5, 3), (0, 3), (5, 1)]) ] assert is_valid_game_setup(num_tests_4, test_cases_4) == [\\"NO\\"] def test_edge_cases(): num_tests_5 = 1 test_cases_5 = [ (2, [(1, 1000000000), (-1, 1000000000)]) ] assert is_valid_game_setup(num_tests_5, test_cases_5) == [\\"NO\\"] num_tests_6 = 1 test_cases_6 = [ (3, [(100, 10), (200, 10), (300, 10)]) ] assert is_valid_game_setup(num_tests_6, test_cases_6) == [\\"YES\\"] if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def is_valid_game_setup(num_tests, test_cases): results = [] for i in range(num_tests): n = test_cases[i][0] players = test_cases[i][1] intervals = [] for p, r in players: intervals.append((p - r, p + r)) intervals.sort() valid = True for j in range(1, n): if intervals[j][0] <= intervals[j-1][1]: valid = False break if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # EXAMPLE USAGE # num_tests, test_cases = parse_input() # results = is_valid_game_setup(num_tests, test_cases) # for result in results: # print(result)"},{"question":"def maximalRectangle(matrix: List[str]) -> int: Given a grid of '*' and '.' characters, determine the maximum area of rectangles consisting solely of '.' characters in the grid. >>> maximalRectangle([ ... \\"******\\", ... \\"*...**\\", ... \\"*.*.**\\", ... \\"*.*.**\\", ... \\"**.***\\" ... ]) 3 >>> maximalRectangle([ ... \\"*\\" ... ]) 0 >>> maximalRectangle([ ... \\".*.*..*\\" ... ]) 2 >>> maximalRectangle([ ... \\"*\\", ... \\".\\", ... \\"*\\", ... \\".\\", ... \\".\\", ... \\"*\\" ... ]) 2 >>> maximalRectangle([ ... \\".....\\", ... \\".....\\", ... \\".....\\" ... ]) 15 pass","solution":"def maximalRectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == '.': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n, m = int(data[0]), int(data[1]) grid = [] idx = 2 for i in range(n): grid.append(data[idx]) idx += 1 print(maximalRectangle(grid))"},{"question":"def smallest_remaining_element(n: int, sequence: List[int]) -> int: Aisha is working on a new project involving sequences and needs your help to finish it. She has an initial sequence of positive integers. Each operation involves selecting any two adjacent integers and removing the larger one. This operation is repeated until only one integer remains in the sequence. Aisha wants to determine the smallest possible integer that can remain after a certain number of operations. Here's the twist: she can freely choose which adjacent pair to eliminate in each operation. Write a function to help Aisha find the smallest possible integer that can remain in the sequence after completing the operations. Input The first line contains an integer n (2 ≤ n ≤ 1000) — the length of the sequence. The second line contains n space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 1000) — the initial sequence. Output Print a single integer — the smallest possible integer that can remain after completing the series of operations. Examples Input 5 3 4 2 5 1 Output 1 Input 4 8 6 7 4 Output 4 Input 3 1 9 3 Output 1 >>> smallest_remaining_element(5, [3, 4, 2, 5, 1]) 1 >>> smallest_remaining_element(4, [8, 6, 7, 4]) 4 >>> smallest_remaining_element(3, [1, 9, 3]) 1 pass","solution":"def smallest_remaining_element(n, sequence): Returns the smallest possible integer that can remain in the sequence. :param n: Length of the sequence :param sequence: List of integers :return: Smallest integer in the sequence return min(sequence)"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.nodes = {1: TreeNode(1)} def add_node(self, parent_value, value): Add a node with value 'value' as a child of the node with value 'parent_value'. If 'parent_value' already has two children, do nothing. pass def pre_order_traversal(self, node_value): Return a list of all values of the nodes in the subtree formed by the node with value 'node_value', in pre-order traversal. pass def calculate_depth(self, node_value): Calculate the maximum depth of the subtree formed by the node with value 'node_value' and return it. pass def handle_queries(queries): Handle a list of queries on the binary tree and return the results for 'P' and 'D' queries. Queries can be: - \\"A P V\\": Add a node with value \`V\` as a child of node with value \`P\`. - \\"P V\\": Pre-order traversal of the subtree rooted at node with value \`V\`. - \\"D V\\": Calculate the maximum depth of the subtree rooted at node with value \`V\`. >>> handle_queries([\\"A 1 2\\", \\"A 1 3\\", \\"A 2 4\\", \\"A 2 5\\", \\"P 2\\", \\"D 1\\"]) [\\"2 4 5\\", \\"3\\"] >>> handle_queries([\\"A 1 2\\", \\"A 2 3\\", \\"A 2 4\\", \\"P 1\\"]) [\\"1 2 3 4\\"] pass","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BinaryTree: def __init__(self): self.nodes = {1: TreeNode(1)} def add_node(self, parent_value, value): if value in self.nodes: return parent_node = self.nodes.get(parent_value) if parent_node: if parent_node.left is None: parent_node.left = TreeNode(value) self.nodes[value] = parent_node.left elif parent_node.right is None: parent_node.right = TreeNode(value) self.nodes[value] = parent_node.right def pre_order_traversal(self, node_value): result = [] node = self.nodes.get(node_value) self._pre_order_helper(node, result) return result def _pre_order_helper(self, node, result): if node: result.append(node.value) self._pre_order_helper(node.left, result) self._pre_order_helper(node.right, result) def calculate_depth(self, node_value): node = self.nodes.get(node_value) return self._depth_helper(node) def _depth_helper(self, node): if not node: return 0 left_depth = self._depth_helper(node.left) right_depth = self._depth_helper(node.right) return max(left_depth, right_depth) + 1 def handle_queries(queries): bt = BinaryTree() results = [] for query in queries: parts = query.split() if parts[0] == 'A': _, parent_value, node_value = parts bt.add_node(int(parent_value), int(node_value)) elif parts[0] == 'P': _, node_value = parts traversal_result = bt.pre_order_traversal(int(node_value)) results.append(\\" \\".join(map(str, traversal_result))) elif parts[0] == 'D': _, node_value = parts depth_result = bt.calculate_depth(int(node_value)) results.append(str(depth_result)) return results"},{"question":"def application_status(score: int) -> str: Determines the status of a university application based on the score. Parameters: score (int): The score of the applicant. Returns: str: The application status. >>> application_status(90) 'Accepted with a scholarship' >>> application_status(80) 'Accepted' >>> application_status(60) 'Waitlisted' >>> application_status(49) 'Rejected'","solution":"def application_status(score): Determines the status of a university application based on the score. Parameters: score (int): The score of the applicant. Returns: str: The application status. if score >= 90: return \\"Accepted with a scholarship\\" elif 75 <= score <= 89: return \\"Accepted\\" elif 50 <= score <= 74: return \\"Waitlisted\\" else: return \\"Rejected\\""},{"question":"def min_path_sum(grid: List[List[int]]) -> int: Find the minimum sum path from the top-left corner to the bottom-right corner of the grid. You can move either to the right or down from a cell. >>> min_path_sum([[1, 2], [3, 4]]) == 7 >>> min_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5 def process_input(input_data: str) -> List[int]: Parse the input data, process each test case, and return the minimum sum path for each grid. >>> input_data = \\"1n2 2n1 2n3 4n\\" >>> process_input(input_data) == [7] def test_min_path_sum(): assert min_path_sum([[1, 2], [3, 4]]) == 7 assert min_path_sum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 5 assert min_path_sum([[-1, -1], [-1, -1]]) == -3 assert min_path_sum([[1]]) == 1 assert min_path_sum([[1, 2, 5], [3, 2, 1]]) == 6 def test_process_input_single_case(): input_data = \\"1n2 2n1 2n3 4n\\" assert process_input(input_data) == [7] def test_process_input_multiple_cases(): input_data = \\"2n2 2n1 2n3 4n3 3n1 1 1n1 1 1n1 1 1n\\" assert process_input(input_data) == [7, 5] def test_process_input_edge_cases(): input_data = \\"1n1 1n-1000n\\" assert process_input(input_data) == [-1000] input_data = \\"1n2 2n0 0n0 0n\\" assert process_input(input_data) == [0]","solution":"def min_path_sum(grid): if not grid or not grid[0]: return 0 R, C = len(grid), len(grid[0]) dp = [[0] * C for _ in range(R)] dp[0][0] = grid[0][0] for i in range(1, R): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, C): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, R): for j in range(1, C): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) return dp[R - 1][C - 1] def process_input(input_data): lines = input_data.strip().split('n') index = 0 T = int(lines[index]) index += 1 results = [] for _ in range(T): R, C = map(int, lines[index].split()) index += 1 grid = [] for _ in range(R): row = list(map(int, lines[index].split())) grid.append(row) index += 1 results.append(min_path_sum(grid)) return results"},{"question":"from typing import List, Tuple def knapsack(max_weight: int, weights: List[int], values: List[int], n: int) -> int: Calculate the maximum total value of items that can be packed without exceeding the weight capacity. >>> knapsack(50, [10, 20, 30], [60, 100, 120], 3) 220 >>> knapsack(30, [10, 20], [50, 70], 2) 120 def solve_knapsack_problem(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Solve the knapsack problem for a number of test cases. >>> test_cases = [(3, 50, [(10, 60), (20, 100), (30, 120)]), (2, 30, [(10, 50), (20, 70)])] >>> solve_knapsack_problem(test_cases) [220, 120] >>> test_cases = [(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)])] >>> solve_knapsack_problem(test_cases) [90] >>> test_cases = [(1, 10, [(5, 10)]), (1, 10, [(15, 20)]), (3, 100, [(1, 1), (2, 2), (3, 3)]), (3, 3, [(1, 1), (2, 2), (3, 3)])] >>> solve_knapsack_problem(test_cases) [10, 0, 6, 3]","solution":"def knapsack(max_weight, weights, values, n): # Create a 2D array to store the maximum value at each n-th item and at each capacity from 0 to W dp = [[0 for x in range(max_weight + 1)] for x in range(n + 1)] # Build table dp[][] in bottom-up manner for i in range(n + 1): for w in range(max_weight + 1): if i == 0 or w == 0: dp[i][w] = 0 elif weights[i-1] <= w: dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w]) else: dp[i][w] = dp[i-1][w] return dp[n][max_weight] def solve_knapsack_problem(test_cases): result = [] for case in test_cases: N, W, items = case weights = [item[0] for item in items] values = [item[1] for item in items] max_value = knapsack(W, weights, values, N) result.append(max_value) return result"},{"question":"def numDecodings(s: str) -> int: Given an encoded message containing digits, determine the total number of ways to decode it. >>> numDecodings(\\"12\\") 2 >>> numDecodings(\\"226\\") 3 >>> numDecodings(\\"0\\") 0","solution":"def numDecodings(s): if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n+1) dp[0] = 1 for i in range(1, n+1): if s[i-1] != '0': dp[i] += dp[i-1] if i > 1 and '10' <= s[i-2:i] <= '26': dp[i] += dp[i-2] return dp[n]"},{"question":"def has_pair_with_sum(arr, target): Determines if there exists a pair of distinct indices in arr such that their elements sum to target. >>> has_pair_with_sum([1, 2, 3, 4, 5, 6], 10) 'YES' >>> has_pair_with_sum([1, 1, 1, 1], 5) 'NO' >>> has_pair_with_sum([2, 7, 11, 15, 3], 9) 'YES' pass def process_test_cases(test_cases): Processes multiple test cases. >>> process_test_cases([(6, 10, [1, 2, 3, 4, 5, 6]), (4, 5, [1, 1, 1, 1]), (5, 9, [2, 7, 11, 15, 3])]) ['YES', 'NO', 'YES'] pass","solution":"def has_pair_with_sum(arr, target): Determines if there exists a pair of distinct indices in arr such that their elements sum to target. seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" def process_test_cases(test_cases): Processes multiple test cases. results = [] for (N, M, array) in test_cases: results.append(has_pair_with_sum(array, M)) return results"},{"question":"def min_items_after_merge(n: int, items: List[int]) -> int: Determine the minimum number of items left after performing any number of merge operations. Args: n (int): The number of items. items (List[int]): The sequence of items. Returns: int: The minimum number of items left. Examples: >>> min_items_after_merge(7, [2, 2, 3, 3, 1, 1, 1]) 3 >>> min_items_after_merge(6, [4, 4, 4, 4, 4, 4]) 1 >>> min_items_after_merge(5, [1, 2, 3, 4, 5]) 5 >>> min_items_after_merge(1, [1]) 1 >>> min_items_after_merge(0, []) 0 >>> min_items_after_merge(4, [1, 2, 1, 2]) 4","solution":"def min_items_after_merge(n, items): if n == 0: return 0 min_items = 1 # we always have at least one item for i in range(1, n): if items[i] != items[i - 1]: min_items += 1 return min_items"},{"question":"def extract_primes(int_str: str) -> str: Takes a string containing a list of space-separated integers and returns a string with only the prime numbers from the list, separated by commas. >>> extract_primes(\\"2 3 5 7 11\\") '2,3,5,7,11' >>> extract_primes(\\"4 6 8 10 12\\") '' >>> extract_primes(\\"23 4 15 29 17 8\\") '23,29,17' >>> extract_primes(\\"7\\") '7' >>> extract_primes(\\"9\\") '' >>> extract_primes(\\"1 0 -5\\") '' >>> extract_primes(\\"2 3 5\\") '2,3,5' >>> extract_primes(\\"1000000007\\") '1000000007'","solution":"def is_prime(n): if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def extract_primes(int_str): Takes a string containing a list of space-separated integers and returns a string of the prime numbers, separated by commas. integers = map(int, int_str.split()) primes = [str(num) for num in integers if is_prime(num)] return ','.join(primes)"},{"question":"def k_frequent_characters_count(n: int, s: str, k: int) -> int: This function takes an integer n (length of string), a string s, and an integer k, and returns the count of characters in s that appear exactly k times. >>> k_frequent_characters_count(6, 'aabbcc', 2) == 3 >>> k_frequent_characters_count(4, 'abcd', 1) == 4 >>> k_frequent_characters_count(5, 'aaaaa', 3) == 0 def process_test_cases(t: int, test_cases: List[Tuple[int, str, int]]) -> List[int]: This function takes an integer t (number of test cases) and a list of test cases, and returns the results for each test case. >>> process_test_cases(3, [(6, 'aabbcc', 2), (4, 'abcd', 1), (5, 'aaaaa', 3)]) == [3, 4, 0]","solution":"def k_frequent_characters_count(n, s, k): This function takes an integer n (length of string), a string s, and an integer k, and returns the count of characters in s that appear exactly k times. from collections import Counter # Count the frequency of each character in the string frequency = Counter(s) # Count the number of characters that have a frequency of exactly k k_frequent_count = sum(1 for count in frequency.values() if count == k) return k_frequent_count def process_test_cases(t, test_cases): This function takes an integer t (number of test cases) and a list of test cases, and returns the results for each test case. results = [] for i in range(t): n, s, k = test_cases[i] results.append(k_frequent_characters_count(n, s, k)) return results"},{"question":"from typing import List, Tuple def findIndices(arr: List[int], target: int) -> Tuple[int, int]: Given an array of integers and an integer target, determine if there exists two distinct indices i and j such that the sum of the elements at these indices equals the target. Return the indices in a tuple (i, j) with i < j. If no such indices exist, return an empty tuple. Examples -------- >>> findIndices([2, 7, 11, 15], 9) (0, 1) >>> findIndices([1, 2, 3, 4, 5], 10) () Parameters ---------- arr: List[int] A list of integers. target: int The target sum to find. Returns ------- Tuple[int, int] A tuple (i, j) of indices with i < j such that arr[i] + arr[j] == target, or an empty tuple if no such indices exist. Unit Test: from solution import findIndices def test_find_indices_basic(): assert findIndices([2, 7, 11, 15], 9) == (0, 1) def test_find_indices_no_solution(): assert findIndices([1, 2, 3, 4, 5], 10) == () def test_find_indices_multiple_solutions(): # Multiple valid outputs, so we check one valid output exists output = findIndices([1, 3, 3, 4, 5], 6) assert output in [(1, 2), (0, 3)] def test_find_indices_with_negatives(): assert findIndices([-1, -2, -3, -4, -5], -8) == (2, 4) def test_find_indices_large_numbers(): assert findIndices([10**9, 10**9, 3, -10**9], 2000000000) == (0, 1) def test_find_indices_single_element(): assert findIndices([1], 2) == () def test_find_indices_empty(): assert findIndices([], 0) == () def test_find_indices_large_input(): arr = list(range(1, 100001)) target = 199999 # We expect (99998, 99999) since 99999 + 100000 = 199999 assert findIndices(arr, target) == (99998, 99999)","solution":"from typing import List, Tuple def findIndices(arr: List[int], target: int) -> Tuple[int, int]: Given an array of integers and an integer target, determine if there exists two distinct indices i and j such that the sum of the elements at these indices equals the target. Return the indices in a tuple (i, j) with i < j. If no such indices exist, return an empty tuple. seen = {} for i, num in enumerate(arr): complement = target - num if complement in seen: return (seen[complement], i) seen[num] = i return ()"},{"question":"def max_snacks_count(T: int, test_cases: list) -> list: Determine the maximum number of snacks that can be carried in the car without exceeding the given capacity. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple represents a test case and contains: - N (int): number of different types of snacks - C (int): maximum capacity of the car - W (list of int): weights of each type of snack Returns: list of int: Maximum number of snacks that can be carried for each test case","solution":"def max_snacks_count(T, test_cases): Determine the maximum number of snacks that can be carried in the car without exceeding the given capacity. Parameters: T (int): Number of test cases test_cases (list of tuples): A list where each tuple represents a test case and contains: - N (int): number of different types of snacks - C (int): maximum capacity of the car - W (list of int): weights of each type of snack Returns: list of int: Maximum number of snacks that can be carried for each test case results = [] for test_case in test_cases: N, C, W = test_case min_weight = min(W) # Find the smallest snack max_snacks = C // min_weight # Max snacks we can carry by packing the lightest snack results.append(max_snacks) return results"},{"question":"def isBalanced(str: str) -> int: Returns 1 if the input string str with parentheses is balanced, else returns 0. >>> isBalanced(\\"({[]})\\") 1 >>> isBalanced(\\"([)]\\") 0","solution":"def isBalanced(str): Returns 1 if the input string str with parentheses is balanced, else returns 0. stack = [] matching_bracket = {')': '(', '}': '{', ']': '['} for char in str: if char in matching_bracket.values(): stack.append(char) elif char in matching_bracket: if not stack or stack.pop() != matching_bracket[char]: return 0 return 1 if not stack else 0"},{"question":"def number_of_paths(grid: List[str]) -> int: Determine the number of valid paths from the top-left to the bottom-right intersection, modulo 1,000,000,007. >>> number_of_paths([ \\"...\\", \\".#.\\", \\"...\\" ]) 2 >>> number_of_paths([ \\".\\" ]) 1 >>> number_of_paths([ \\".#.\\", \\"#\\", \\"...\\" ]) 0 >>> number_of_paths([ \\"....\\", \\"....\\", \\"....\\", \\"....\\" ]) 20","solution":"MOD = 1_000_000_007 def number_of_paths(grid): R = len(grid) C = len(grid[0]) # Initialize a 2D list to store the number of ways to reach each cell dp = [[0] * C for _ in range(R)] # The starting cell has one way to be reached, i.e., starting from there dp[0][0] = 1 # Fill the dp array for i in range(R): for j in range(C): if grid[i][j] == '.': if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[-1][-1] def process_input(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [] index = 2 for i in range(R): grid.append(data[index + i]) result = number_of_paths(grid) print(result)"},{"question":"def checkSubarraySum(nums: List[int], k: int) -> bool: Check if the list has a continuous subarray of size at least 2 whose sum is a multiple of k. >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 13) False","solution":"def checkSubarraySum(nums, k): Check if the list has a continuous subarray of size at least 2 whose sum is a multiple of k. Args: nums: List[int] - List of integers. k: int - The integer k. Returns: bool - True if there exists a subarray, False otherwise. if not nums or len(nums) < 2: return False cum_sum = 0 mod_dict = {0: -1} # Initialize with 0: -1 to handle the subarray starting from index 0 for i in range(len(nums)): cum_sum += nums[i] mod = cum_sum % k if k != 0 else cum_sum if mod in mod_dict: if i - mod_dict[mod] > 1: # Ensure subarray size is at least 2 return True else: mod_dict[mod] = i # Store the first occurrence of the mod value return False"},{"question":"def count_even_sum_pairs(ticket_numbers): Counts the number of distinct pairs of tickets whose sum is an even number. Args: ticket_numbers (list): List of integers representing ticket numbers. Returns: int: Number of pairs with an even sum. >>> count_even_sum_pairs([1, 2, 3, 4, 5]) 4 >>> count_even_sum_pairs([2, 4, 6, 8]) 6 >>> count_even_sum_pairs([1, 3, 5, 7, 9]) 10 >>> count_even_sum_pairs([1, 2, 3, 4]) 2 >>> count_even_sum_pairs([1]) 0 >>> count_even_sum_pairs([2]) 0","solution":"def count_even_sum_pairs(ticket_numbers): Counts the number of distinct pairs of tickets whose sum is an even number. Args: ticket_numbers (list): List of integers representing ticket numbers. Returns: int: Number of pairs with an even sum. odd_count = 0 even_count = 0 # Count how many tickets have odd and even numbers for ticket in ticket_numbers: if ticket % 2 == 0: even_count += 1 else: odd_count += 1 # Pairing any of the even numbers with each other will result in an even sum even_pairs = (even_count * (even_count - 1)) // 2 # Pairing any of the odd numbers with each other will also result in an even sum odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself). pass def buildTree(level_order): Build the binary tree from the level order traversal list and return the root. :param level_order: List of node values in level order where \\"null\\" denotes a missing child. :return: Root of the binary tree. pass def findNode(root, val): Find and return the node with the given value. :param root: Root of the binary tree. :param val: Value of the node to find. :return: Node with the given value. pass","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lowestCommonAncestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Returns the LCA of the two given nodes p and q in the binary tree. if not root or root == p or root == q: return root left = lowestCommonAncestor(root.left, p, q) right = lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right def buildTree(level_order): Build the binary tree from the level order traversal list and return the root. if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while queue and i < len(level_order): current = queue.pop(0) if level_order[i] != \\"null\\": current.left = TreeNode(level_order[i]) queue.append(current.left) i += 1 if i < len(level_order) and level_order[i] != \\"null\\": current.right = TreeNode(level_order[i]) queue.append(current.right) i += 1 return root def findNode(root, val): Find and return the node with the given value. if not root: return None if root.val == val: return root left = findNode(root.left, val) if left: return left return findNode(root.right, val) def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) level_order = [int(x) if x != \\"null\\" else \\"null\\" for x in data[1:n+1]] p_val, q_val = int(data[n+1]), int(data[n+2]) root = buildTree(level_order) p = findNode(root, p_val) q = findNode(root, q_val) lca = lowestCommonAncestor(root, p, q) print(lca.val)"},{"question":"def multiply_elements(lst): Multiplies elements in the list. If a zero is in the list, return the sum of the elements instead. >>> multiply_elements([1, 2, 3, 4]) 24 >>> multiply_elements([0, 1, 2, 3]) 6 >>> multiply_elements([5, -1, 2, -4]) 40 >>> multiply_elements([0, 0, 0]) 0 >>> multiply_elements([1.5, 2, 3]) 9.0 >>> multiply_elements([0, 1.5, 2]) 3.5","solution":"def multiply_elements(lst): Multiplies elements in the list. If a zero is in the list, return the sum of the elements instead. if 0 in lst: return sum(lst) else: product = 1 for num in lst: product *= num return product"},{"question":"def checkIsGP(arr, N): Determine if all elements in the array can be rearranged such that they form a geometric progression. Parameters: arr (List[int]): The array of integers. N (int): The number of elements in the array. Returns: bool: True if it's possible to rearrange the array into a geometric progression, otherwise False. Examples: >>> checkIsGP([2, 6, 18, 54], 4) True >>> checkIsGP([1, 7, 14, 28], 4) False from typing import List def test_example_1(): assert checkIsGP([2, 6, 18, 54], 4) == True def test_example_2(): assert checkIsGP([1, 7, 14, 28], 4) == False def test_single_element(): assert checkIsGP([1], 1) == False def test_zero_element(): assert checkIsGP([0, 2, 4, 8], 4) == False def test_large_common_ratio(): assert checkIsGP([1, 100, 10000, 1000000], 4) == True def test_no_gp_with_multiple_ratios(): assert checkIsGP([3, 9, 27, 81, 49], 5) == False def test_negative_numbers(): assert checkIsGP([-2, -6, -18, -54], 4) == True def test_mixed_sign_numbers(): assert checkIsGP([-2, 2, -4, 4], 4) == False","solution":"def checkIsGP(arr, N): Function to check if the given array can be rearranged to form a geometric progression. :param arr: List of integers. :param N: Integer value representing the length of the array. :return: True if the rearranged array can form a geometric progression, otherwise False. if N < 2: return False arr.sort() if arr[0] == 0: return False common_ratio = arr[1] / arr[0] for i in range(1, N): if arr[i] / arr[i-1] != common_ratio: return False return True"},{"question":"def find_third_friend_sum(x: int, y: int) -> int: Determines the sum of the numbers chosen by all three friends, given the numbers chosen by two of them. >>> find_third_friend_sum(5, 3) 12 >>> find_third_friend_sum(1, 2) 7 >>> find_third_friend_sum(1, 100) 105 >>> find_third_friend_sum(50, 25) 79 >>> find_third_friend_sum(8, 9) 21 pass","solution":"def find_third_friend_sum(x, y): Determines the sum of the numbers chosen by all three friends, given the numbers chosen by two of them. Parameters: x (int): First number. y (int): Second number. Returns: int: Sum of all three numbers chosen. return x + y + 4 # Since the third unique number is fixed as 1 + 2 + 3 - (1 + 2) = 3"},{"question":"def max_consecutive_available_books(n: int, status_list: List[bool]) -> Tuple[int, int, int]: Determine the length of the longest sub-array of available books, as well as the starting and ending indices of this sub-array. >>> max_consecutive_available_books(10, [False, True, False, False, True, False, True, True, False, False]) == (2, 6, 7) >>> max_consecutive_available_books(5, [False, False, False, False, False]) == (5, 0, 4) >>> max_consecutive_available_books(5, [True, True, True, True, True]) == (0, 0, 0) >>> max_consecutive_available_books(7, [True, True, False, False, False, True, False]) == (3, 2, 4) >>> max_consecutive_available_books(6, [True, True, True, True, False, True]) == (1, 4, 4) >>> max_consecutive_available_books(8, [False, False, True, True, False, False, True, True]) == (2, 0, 1) >>> max_consecutive_available_books(1, [False]) == (1, 0, 0) >>> max_consecutive_available_books(1, [True]) == (0, 0, 0)","solution":"def max_consecutive_available_books(n, status_list): max_length = 0 current_length = 0 start_index = 0 max_start_index, max_end_index = 0, 0 for i in range(n): if not status_list[i]: current_length += 1 if current_length > max_length: max_length = current_length max_start_index = start_index max_end_index = i else: current_length = 0 start_index = i + 1 return max_length, max_start_index, max_end_index"},{"question":"def reverseWords(input_string: str) -> str: Reverses each word in the input string while maintaining their original order. Args: input_string (str): The string containing words to be reversed. Returns: str: The string with each word reversed but in the original order. >>> reverseWords(\\"Hello World\\") \\"olleH dlroW\\" >>> reverseWords(\\"Hello, World!\\") \\",olleH !dlroW\\" >>> reverseWords(\\"OpenAI\\") \\"IAnepO\\" >>> reverseWords(\\"\\") \\"\\" >>> reverseWords(\\"aaa bbb ccc\\") \\"aaa bbb ccc\\" >>> reverseWords(\\"Hello World from OpenAI\\") \\"olleH dlroW morf IAnepO\\"","solution":"def reverseWords(input_string): Reverses each word in the input string while maintaining their original order. Args: input_string (str): The string containing words to be reversed. Returns: str: The string with each word reversed but in the original order. return ' '.join(word[::-1] for word in input_string.split())"},{"question":"def sum_of_even_numbers(lists): Given a list of lists of integers, determine the sum of all even numbers in each list. If the list contains no even numbers, return 0 for that list. >>> sum_of_even_numbers([[1, 2, 3, 4, 5]]) [6] >>> sum_of_even_numbers([[7, 11, 13]]) [0] >>> sum_of_even_numbers([[2, 4, 6, 8, 10]]) [30]","solution":"def sum_of_even_numbers(lists): Returns a list containing the sum of even numbers for each given list of integers. If the list contains no even numbers, return 0 for that list. result = [] for lst in lists: even_sum = sum(num for num in lst if num % 2 == 0) result.append(even_sum) return result"},{"question":"def min_substrings(main_str, words): Given a main string and a list of words, determine the smallest number of substrings of the main string that can be concatenated to form each word in the list. If it is not possible to form a word using substrings of the main string, the answer for that word should be -1. Args: main_str (str): The main string. words (List[str]): List of words to form using the substrings of the main string. Returns: List[int]: List of integers representing the smallest number of substrings needed to form each word, or -1 if it is not possible. >>> min_substrings(\\"abcdefg\\", [\\"abc\\", \\"cde\\", \\"age\\"]) [1, 1, -1] >>> min_substrings(\\"abcdef\\", [\\"gh\\", \\"ij\\"]) [-1, -1]","solution":"def min_substrings(main_str, words): results = [] def find_min_substrings(word): m, w = len(main_str), len(word) # dp[i][j]: the minimal number of substrings to form word[:j] using main_str[:i] dp = [[float('inf')] * (w + 1) for _ in range(m + 1)] # Initial state for i in range(m + 1): dp[i][0] = 0 for i in range(1, m + 1): for j in range(1, w + 1): k = j while k > 0 and main_str[i - k:i] != word[j - k:j]: k -= 1 if k > 0: dp[i][j] = min(dp[i - k][j - k] + 1, dp[i - 1][j]) else: dp[i][j] = dp[i - 1][j] return dp[m][w] if dp[m][w] != float('inf') else -1 for word in words: results.append(find_min_substrings(word)) return results"},{"question":"from typing import List def top_k_frequent_destinations(N: int, K: int, travel_history: List[int]) -> List[int]: Returns the top K most frequently visited destination IDs. Parameters: N (int): The number of destination visits in the travel history. K (int): The number of top destinations to retrieve. travel_history (List[int]): A list of destination visits denoted by integer IDs. Returns: List[int]: A list of the top K most frequently visited destination IDs. Examples: >>> top_k_frequent_destinations(10, 3, [1, 3, 3, 2, 4, 4, 4, 5, 5, 5]) [4, 5, 3] >>> top_k_frequent_destinations(7, 2, [1, 2, 3, 1, 1, 2, 2]) [1, 2] >>> top_k_frequent_destinations(8, 2, [1, 2, 2, 3, 3, 4, 4, 5]) [2, 3] >>> top_k_frequent_destinations(100, 5, [i for i in range(1, 101)]) [1, 2, 3, 4, 5] >>> top_k_frequent_destinations(6, 1, [5, 5, 5, 5, 5, 5]) [5] >>> top_k_frequent_destinations(8, 3, [2, 3, 3, 2, 1, 4, 4, 5]) [2, 3, 4]","solution":"from collections import Counter def top_k_frequent_destinations(N, K, travel_history): Returns the top K most frequently visited destination IDs. # Count the frequency of each destination ID in the travel history count = Counter(travel_history) # Sort the destinations first by frequency in descending order, # then by destination ID in ascending order in case of ties most_common_destinations = sorted(count.items(), key=lambda x: (-x[1], x[0])) # Extract the top K destination IDs top_k_destinations = [dest[0] for dest in most_common_destinations[:K]] return top_k_destinations"},{"question":"def digit_sum(n: str) -> int: Reduce the digits of the number represented by the string n to a single-digit number by repeatedly summing the digits. Parameters: n (str): Large positive number represented as a string Returns: int: Single-digit sum of the digits >>> digit_sum(\\"9875\\") 2 >>> digit_sum(\\"123456789\\") 9","solution":"def digit_sum(n): Reduce the digits of the number represented by the string n to a single-digit number by repeatedly summing the digits. Parameters: n (str): Large positive number represented as a string Returns: int: Single-digit sum of the digits while len(n) > 1: sum_digits = sum(int(char) for char in n) n = str(sum_digits) return int(n)"},{"question":"def check_costumes_validity(N: int, M: int, costumes: List[List[int]]) -> str: Returns \\"Valid\\" if all costumes have distinct color schemes, otherwise \\"Invalid\\". Parameters: - N (int): The number of colors in each costume. - M (int): The total number of available colors in the palette. - costumes (List[List[int]]): A list of costumes, each represented by a list of N distinct integers. Returns: - str: \\"Valid\\" if all costumes have distinct color schemes, otherwise \\"Invalid\\". Examples: >>> check_costumes_validity(3, 5, [[1, 2, 3], [4, 2, 1], [3, 5, 2], [1, 2, 3]]) \\"Invalid\\" >>> check_costumes_validity(2, 4, [[1, 2], [3, 4], [2, 3], [4, 1]]) \\"Valid\\"","solution":"def check_costumes_validity(N, M, costumes): Returns \\"Valid\\" if all costumes have distinct color schemes, otherwise \\"Invalid\\". seen_costumes = set() for costume in costumes: color_scheme = tuple(sorted(costume)) if color_scheme in seen_costumes: return \\"Invalid\\" seen_costumes.add(color_scheme) return \\"Valid\\""},{"question":"def longest_increasing_consecutive_subsequence(n: int, sequence: List[int]) -> int: Determine the length of the longest increasing subsequence such that the difference between consecutive elements is exactly 1. Args: n: int - the length of the sequence. sequence: List[int] - the elements of the sequence. Returns: int - the length of the longest increasing consecutive subsequence. >>> longest_increasing_consecutive_subsequence(8, [1, 2, 3, 4, 5, 3, 4, 2]) 5 >>> longest_increasing_consecutive_subsequence(10, [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_consecutive_subsequence(5, [3, 10, 11, 12, 4]) 3","solution":"def longest_increasing_consecutive_subsequence(n, sequence): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] == sequence[i-1] + 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def minimum_cost_to_connect_agents(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum cost to connect all agents such that every agent can communicate with every other agent either directly or indirectly using a Minimum Spanning Tree (MST) approach. >>> minimum_cost_to_connect_agents(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (3, 4, 3), (2, 4, 5)]) 6 >>> minimum_cost_to_connect_agents(4, 2, [(1, 2, 1), (3, 4, 2)]) -1","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_connect_agents(N, M, connections): edges = [] for u, v, w in connections: edges.append((w, u, v)) edges.sort() parent = list(range(N + 1)) rank = [0] * (N + 1) mst_cost = 0 edges_used = 0 for w, u, v in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_cost += w edges_used += 1 if edges_used == N - 1: break if edges_used == N - 1: return mst_cost else: return -1"},{"question":"def countPaths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner. Parameters: grid (list of list of int): 2D grid where '0' is an empty cell and '1' is an obstacle. Returns: int: Number of distinct paths from the top-left to the bottom-right corner. >>> countPaths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> countPaths([[0, 1], [0, 0]]) 1 >>> countPaths([[0, 1, 0], [0, 1, 0], [0, 0, 0]]) 1 >>> countPaths([[0, 1], [1, 0]]) 0 >>> countPaths([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 6 >>> countPaths([]) 0 >>> countPaths([[1, 0], [0, 0]]) 0 >>> countPaths([[0, 0], [0, 1]]) 0 # Your code here","solution":"def countPaths(grid): Returns the number of distinct paths from the top-left corner to the bottom-right corner. Parameters: grid (list of list of int): 2D grid where '0' is an empty cell and '1' is an obstacle. Returns: int: Number of distinct paths from the top-left to the bottom-right corner. if not grid or grid[0][0] == 1 or grid[-1][-1] == 1: return 0 N = len(grid) # Initialize a 2D dp array dp = [[0] * N for _ in range(N)] # Set the starting point dp[0][0] = 1 # Fill the dp array while avoiding obstacles for i in range(N): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1]"},{"question":"from typing import List def spiralTraverse(matrix: List[List[int]]) -> List[int]: Write a function \`spiralTraverse(matrix)\` that takes in a 2D list (matrix) and returns a list of the elements in spiral order. Spiral order starts from the top-left corner of the matrix and proceeds in a clockwise manner, eventually converging towards the center of the matrix. Constraints: - The matrix can have varying dimensions, but it will always be a non-empty 2D list. - The elements of the matrix can be any integers. - Do not use any libraries for the traversal; the implementation should manually handle the spiral logic. Examples: >>> spiralTraverse([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [1, 2, 3, 6, 9, 8, 7, 4, 5] >>> spiralTraverse([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) [1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]","solution":"def spiralTraverse(matrix): Returns the elements of the given 2D list (matrix) in spiral order. result = [] if not matrix or not matrix[0]: return result top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 if top <= bottom: for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 if left <= right: for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 return result"},{"question":"def minSwapsToPalindrome(s: str) -> int: Returns the minimum number of adjacent character swaps required to transform \`s\` into a palindrome. If it cannot be transformed into a palindrome, return -1. Arguments: s: a string of lowercase English letters Returns: The minimum number of adjacent character swaps required, or -1 if it's not possible. Examples: >>> minSwapsToPalindrome(\\"mamad\\") 3 >>> minSwapsToPalindrome(\\"asflkj\\") -1 >>> minSwapsToPalindrome(\\"abcbca\\") 1","solution":"def minSwapsToPalindrome(s): Returns the minimum number of adjacent character swaps required to transform the string \`s\` into a palindrome. If it's not possible, returns -1. if not canFormPalindrome(s): return -1 s = list(s) n = len(s) swap_count = 0 for i in range(n // 2): left = i right = n - left - 1 while left < right: if s[left] == s[right]: break else: right -= 1 if left == right: s[left], s[left + 1] = s[left + 1], s[left] swap_count += 1 right = n - left - 2 for j in range(right, n - left - 1): s[j], s[j + 1] = s[j + 1], s[j] swap_count += 1 return swap_count def canFormPalindrome(s): Helper function to check if a string can be rearranged to form a palindrome. char_count = [0] * 26 for ch in s: char_count[ord(ch) - ord('a')] += 1 odd_count = sum(1 for count in char_count if count % 2 != 0) return odd_count <= 1"},{"question":"from typing import List def min_moves(n: int, grid: List[str]) -> int: Returns the minimum number of moves required to go from the top-left corner (1,1) to the bottom-right corner (n,n) of the grid. If it is impossible, returns -1. >>> min_moves(3, ['..#', '.#.', '...']) 4 >>> min_moves(4, ['....', '..', '.#..', '..']) 6 >>> min_moves(2, ['.#', '#.']) -1 pass def test_min_moves(): assert min_moves(3, ['..#', '.#.', '...']) == 4 assert min_moves(4, ['....', '..', '.#..', '..']) == 6 assert min_moves(2, ['.#', '#.']) == -1 assert min_moves(1, ['.']) == 0 assert min_moves(3, ['#', '#', '#']) == -1 assert min_moves(2, ['.#', '..']) == 2 def test_min_moves_boundary_conditions(): assert min_moves(1, ['.']) == 0 assert min_moves(1, ['#']) == -1 assert min_moves(2, ['..', '..']) == 2 assert min_moves(5, [ '.....', '.#...', '.....', '...#.', '.....' ]) == 8 test_min_moves() test_min_moves_boundary_conditions()","solution":"from collections import deque def min_moves(n, grid): Returns the minimum number of moves required to go from the top-left corner (1,1) to the bottom-right corner (n,n) of the grid. If it is impossible, returns -1. directions = [(1, 0), (0, 1)] # Possible directions: down, right visited = [[False] * n for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) if grid[0][0] == '#' or grid[n-1][n-1] == '#': return -1 while queue: row, col, dist = queue.popleft() if row == n-1 and col == n-1: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] == '.': visited[new_row][new_col] = True queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"def getPossiblePaths(m, n): Returns the number of distinct paths you can take to travel from the top-left corner to the bottom-right corner of a grid, given that you can only move either down or right at any point in time. :param m: number of rows :param n: number of columns :return: number of distinct paths >>> getPossiblePaths(3, 3) 6 >>> getPossiblePaths(2, 2) 2 >>> getPossiblePaths(1, 5) 1 >>> getPossiblePaths(5, 1) 1 >>> getPossiblePaths(4, 4) 20 >>> getPossiblePaths(5, 5) 70 >>> getPossiblePaths(3, 7) 28 >>> getPossiblePaths(7, 3) 28 >>> getPossiblePaths(1, 1) 1 >>> getPossiblePaths(20, 20) 35345263800","solution":"def getPossiblePaths(m, n): Returns the number of distinct paths you can take to travel from the top-left corner to the bottom-right corner of a grid, given that you can only move either down or right at any point in time. :param m: number of rows :param n: number of columns :return: number of distinct paths dp = [[0] * n for _ in range(m)] for i in range(m): dp[i][0] = 1 for j in range(n): dp[0][j] = 1 for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def single_number(nums: List[int]) -> int: Given an array of integers where every element appears three times except for one, which appears exactly once, find that single one. Your algorithm should have a linear runtime complexity and use constant extra memory. Example 1: >>> single_number([2, 2, 3, 2]) 3 Example 2: >>> single_number([0, 1, 0, 1, 0, 1, 99]) 99","solution":"def single_number(nums): Find the element that appears exactly once in the array where every other element appears exactly three times. :param nums: List[int] :return: int ones, twos = 0, 0 for num in nums: # 'twos' holds the bits which appear twice, we do an OR with 'num' # & 'ones' to get all bits which are set twice. twos = twos | (ones & num) # 'ones' holds the bits which appear once, we do XOR with 'num'. ones = ones ^ num # The common bits in 'ones' and 'twos' are the bits that appeared three times. common_bits = ones & twos # Remove common bits from 'ones' ones &= ~common_bits # Remove common bits from 'twos' twos &= ~common_bits return ones"},{"question":"def is_geometric_progression(arr): Determines if the given array forms a geometric progression (GP). Parameters: arr (list of int): The array of integers to be checked Returns: int: 1 if the array forms a geometric progression, otherwise 0 >>> is_geometric_progression([2, 4, 8, 16, 32]) == 1 >>> is_geometric_progression([1, 3, 9, 28]) == 0 >>> is_geometric_progression([5]) == 1 >>> is_geometric_progression([3, 9]) == 1 >>> is_geometric_progression([1, 7, 49, 343, 10]) == 0 >>> is_geometric_progression([0, 0, 0, 0]) == 1 >>> is_geometric_progression([3 * (2 ** i) for i in range(10)]) == 1 >>> is_geometric_progression([-1, -2, -4, -8]) == 1 >>> is_geometric_progression([-1, 1, -1, 1]) == 0","solution":"def is_geometric_progression(arr): Determines if the given array forms a geometric progression (GP). Parameters: arr (list of int): The array of integers to be checked Returns: int: 1 if the array forms a geometric progression, otherwise 0 n = len(arr) if n <= 1: return 1 arr.sort() if arr[0] == 0: for i in arr[1:]: if i != 0: return 0 return 1 ratio = arr[1] / arr[0] for i in range(1, n): if arr[i] / arr[i-1] != ratio: return 0 return 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determines if a binary tree is balanced. A balanced tree is defined as one where the depth of the two subtrees of any node never differs by more than 1. :param root: TreeNode, the root of the binary tree :return: 1 if the tree is balanced, 0 otherwise >>> isBalanced(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3))) 1 >>> isBalanced(TreeNode(1, TreeNode(2, TreeNode(3)))) 0","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isBalanced(root): Determines if a binary tree is balanced. A balanced tree is defined as one where the depth of the two subtrees of every node never differs by more than 1. :param root: TreeNode, the root of the binary tree :return: 1 if the tree is balanced, 0 otherwise def check_balance(node): if node is None: return 0, True # height, isBalanced left_height, left_is_balanced = check_balance(node.left) right_height, right_is_balanced = check_balance(node.right) current_height = 1 + max(left_height, right_height) is_balanced = left_is_balanced and right_is_balanced and abs(left_height - right_height) <= 1 return current_height, is_balanced _, result = check_balance(root) return 1 if result else 0"},{"question":"def hasZeroSumSubarray(arr: list) -> bool: Determine if there exists a subarray (contiguous elements) whose sum is zero. Args: arr (list): List of integers. Returns: bool: True if there is a subarray with sum zero, otherwise False. Examples: >>> hasZeroSumSubarray([1, 2, -3, 4, 5]) True >>> hasZeroSumSubarray([1, 2, 4, 5, 6]) False >>> hasZeroSumSubarray([-3, 3, -2, 2]) True >>> hasZeroSumSubarray([0]) True >>> hasZeroSumSubarray([]) False >>> hasZeroSumSubarray([-1, 1]) True >>> hasZeroSumSubarray([1, -1, 2, -2]) True from hasZeroSumSubarray import hasZeroSumSubarray def test_hasZeroSumSubarray_with_zerosum(): assert hasZeroSumSubarray([1, 2, -3, 4, 5]) == True assert hasZeroSumSubarray([-3, 3, -2, 2]) == True def test_hasZeroSumSubarray_without_zerosum(): assert hasZeroSumSubarray([1, 2, 4, 5, 6]) == False assert hasZeroSumSubarray([1, 2, 3]) == False def test_hasZeroSumSubarray_edge_cases(): assert hasZeroSumSubarray([0]) == True assert hasZeroSumSubarray([]) == False assert hasZeroSumSubarray([-1, 1]) == True assert hasZeroSumSubarray([1, -1, 2, -2]) == True def test_hasZeroSumSubarray_large_case(): large_arr = list(range(1, 10001)) + [-5000, -5000] assert hasZeroSumSubarray(large_arr) == True","solution":"def hasZeroSumSubarray(arr): Returns True if there exists a subarray with a sum of zero in the array. sum_set = set() curr_sum = 0 for num in arr: curr_sum += num if curr_sum == 0 or curr_sum in sum_set: return True sum_set.add(curr_sum) return False"},{"question":"def is_palindrome(s: str) -> bool: Check if the string is a palindrome, considering only alphanumeric characters and ignoring case. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False # Unit Tests def test_is_palindrome_with_palindrome_phrase(): assert is_palindrome(\\"A man, a plan, a canal: Panama\\") == True def test_is_palindrome_with_non_palindrome_phrase(): assert is_palindrome(\\"race a car\\") == False def test_is_palindrome_with_palindrome_word(): assert is_palindrome(\\"Madam\\") == True def test_is_palindrome_with_non_palindrome_word(): assert is_palindrome(\\"Hello\\") == False def test_is_palindrome_with_empty_string(): assert is_palindrome(\\"\\") == True def test_is_palindrome_with_only_special_characters(): assert is_palindrome(\\"!@#%^&*()_+\\") == True def test_is_palindrome_with_mixed_case_letters(): assert is_palindrome(\\"No lemon, no melon\\") == True def test_is_palindrome_with_digits(): assert is_palindrome(\\"12321\\") == True assert is_palindrome(\\"12345\\") == False def test_is_palindrome_with_digits_and_letters(): assert is_palindrome(\\"1a2b2a1\\") == True assert is_palindrome(\\"1a2b3a1\\") == False","solution":"def is_palindrome(s: str) -> bool: Returns True if the string 's' is a palindrome considering only alphanumeric characters and ignoring case. # Filter out non-alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"from typing import List, Tuple def shortestPath(grid: List[List[int]], start: Tuple[int, int], target: Tuple[int, int]) -> int: Determine the shortest path using only orthogonal movements (up, down, left, right) to reach the target position. Each cell in the grid has either a value of 0 or 1, where 0 represents a passable cell, and 1 represents an impassable cell. If the target position is unreachable, return -1. Args: grid (List[List[int]]): 2D list of the grid of numbers (0 or 1) start (Tuple[int, int]): Starting position (row, column) target (Tuple[int, int]): Target position (row, column) Returns: int: Minimum number of steps to reach the target, or -1 if not reachable Examples: >>> shortestPath([[0, 0, 1, 0, 0], [0, 0, 0, 0, 1], [1, 0, 1, 0, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0]], (0, 0), (4, 4)) 8 >>> shortestPath([[0, 1], [1, 0]], (0, 0), (1, 1)) -1 >>> shortestPath([[0, 0], [0, 0]], (0, 0), (0, 1)) 1 >>> shortestPath([[0, 1], [1, 0]], (0, 0), (0, 0)) 0 >>> shortestPath([[0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0]], (0, 0), (4, 4)) 8","solution":"from collections import deque def shortestPath(grid, start, target): n, m = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: r, c, dist = queue.popleft() # If we reached the target if (r, c) == target: return dist # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, dist + 1)) return -1"},{"question":"def adjust_schedule(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[List[int]]: Adjust the schedule of workers to ensure no worker works more than K consecutive days. >>> adjust_schedule(1, [((3, 2), [5, 3, 2])]) [[2, 2, 1, 2, 1, 2]] >>> adjust_schedule(2, [((3, 2), [5, 3, 2]), ((2, 1), [4, 6])]) [[2, 2, 1, 2, 1, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]","solution":"def adjust_schedule(t, test_cases): result = [] for i in range(t): N, K = test_cases[i][0] schedules = test_cases[i][1] adjusted = [] for days in schedules: while days > K: adjusted.append(K) days -= K adjusted.append(days) result.append(adjusted) return result # Reading input in the expected format def read_input(): t = int(input()) test_cases = [] for _ in range(t): N, K = map(int, input().split()) schedules = list(map(int, input().split())) test_cases.append(((N, K), schedules)) return t, test_cases # Printing output in the expected format def print_output(result): for res in result: print(' '.join(map(str, res))) if __name__ == \\"__main__\\": t, test_cases = read_input() result = adjust_schedule(t, test_cases) print_output(result)"},{"question":"def can_match_total(target, coins): Determines if we can match the target sum using the given coin values. >>> can_match_total(7, [1, 2, 3, 4, 5]) \\"Matched\\" >>> can_match_total(5, [2, 4, 6]) \\"Not Matched\\" >>> can_match_total(21, [3, 7, 1, 5, 4, 9]) \\"Matched\\" >>> can_match_total(14, [7]) \\"Matched\\" >>> can_match_total(10, [7]) \\"Not Matched\\" >>> can_match_total(5, []) \\"Not Matched\\" >>> can_match_total(0, [1, 2, 3]) \\"Matched\\" >>> can_match_total(5, [10, 20, 30]) \\"Not Matched\\" >>> can_match_total(15, [5, 9, 1]) \\"Matched\\"","solution":"def can_match_total(target, coins): Determines if we can match the target sum using the given coin values. coins: List of integers indicating coin values target: Integer indicating the target sum dp = [False] * (target + 1) dp[0] = True for i in range(1, target + 1): for coin in coins: if i >= coin and dp[i - coin]: dp[i] = True break return \\"Matched\\" if dp[target] else \\"Not Matched\\" # Example usage: # Provided list of coins coins = [3, 7, 1, 5, 4, 9] # Provided targets targets = [11, 15, 8, 21] # Determine if each target can be matched results = [can_match_total(target, coins) for target in targets] results # Output should be ['Matched', 'Not Matched', 'Matched', 'Matched']"},{"question":"def min_difference(n: int, points: List[int]) -> int: Determine the minimum possible difference in points between two participants after optimally distributing the tasks. >>> min_difference(5, [1, 2, 3, 4, 5]) 1 >>> min_difference(3, [10, 20, 30]) 0","solution":"def min_difference(n, points): total_sum = sum(points) dp = [False] * (total_sum // 2 + 1) dp[0] = True for point in points: for j in range(total_sum // 2, point - 1, -1): dp[j] = dp[j] or dp[j - point] for i in range(total_sum // 2, -1, -1): if dp[i]: return total_sum - 2 * i return total_sum # this line will not be reached normally because of the constraints."},{"question":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two elements in the array. >>> smallest_absolute_difference([1, 3, 4, 9, 10]) 1 >>> smallest_absolute_difference([-5, -2, 0, 3, 6, 12, 15]) 2 >>> smallest_absolute_difference([1, 2]) 1 >>> smallest_absolute_difference([-10, -5, -3, -1]) 2 >>> smallest_absolute_difference([1, 2, 2, 3]) 0 >>> smallest_absolute_difference([1000000000, 999999999, -1000000000]) 1 >>> smallest_absolute_difference([7, 7, 7, 7]) 0 >>> smallest_absolute_difference([-1, 1, -3, 3, -5, 5]) 2","solution":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two elements in the array. if len(arr) < 2: return 0 arr.sort() min_diff = float('inf') for i in range(1, len(arr)): diff = abs(arr[i] - arr[i - 1]) if diff < min_diff: min_diff = diff return min_diff"},{"question":"def num_islands(map_data, M, N): Returns the number of distinct islands in the given map. >>> num_islands([ ['L', 'L', 'W', 'W', 'L'], ['L', 'W', 'L', 'W', 'L'], ['W', 'W', 'W', 'L', 'L'], ['L', 'L', 'L', 'L', 'W'] ], 4, 5) 3 >>> num_islands([ ['L', 'L', 'W'], ['L', 'W', 'L'], ['W', 'L', 'L'] ], 3, 3) 2 pass def count_islands(T, test_cases): Returns the number of distinct islands for each test case. >>> count_islands(2, [ (4, 5, [ ['L', 'L', 'W', 'W', 'L'], ['L', 'W', 'L', 'W', 'L'], ['W', 'W', 'W', 'L', 'L'], ['L', 'L', 'L', 'L', 'W'] ]), (3, 3, [ ['L', 'L', 'W'], ['L', 'W', 'L'], ['W', 'L', 'L'] ]) ]) [3, 2] pass","solution":"def num_islands(map_data, M, N): Returns the number of distinct islands in the given map. def dfs(map_data, x, y): if x < 0 or x >= M or y < 0 or y >= N or map_data[x][y] == 'W': return map_data[x][y] = 'W' # Mark current cell as visited dfs(map_data, x + 1, y) dfs(map_data, x - 1, y) dfs(map_data, x, y + 1) dfs(map_data, x, y - 1) island_count = 0 for i in range(M): for j in range(N): if map_data[i][j] == 'L': island_count += 1 dfs(map_data, i, j) return island_count def count_islands(T, test_cases): results = [] for case in test_cases: M, N, map_data = case results.append(num_islands(map_data, M, N)) return results"},{"question":"def minAbsDifference(arr): Returns the minimum absolute difference between any two elements in the array. >>> minAbsDifference([3, 8, 15, 17]) == 2 >>> minAbsDifference([1, 19, -4, 31, 38, 25, 100]) == 5","solution":"def minAbsDifference(arr): Returns the minimum absolute difference between any two elements in the array. arr.sort() # Sort the array to bring closest elements next to each other min_diff = float('inf') # Iterate through the sorted array and find the minimum difference for i in range(len(arr) - 1): min_diff = min(min_diff, abs(arr[i] - arr[i + 1])) return min_diff"},{"question":"def max_subarray_sum(n: int, fertility_levels: List[int]) -> int: Finds the maximum sum of any continuous subarray of fertility levels. Parameters: n (int): Number of fields. fertility_levels (list of int): List containing the fertility levels of the fields. Returns: int: The maximum sum of any continuous subarray. >>> max_subarray_sum(5, [-3, 4, -1, 2, 1]) 6 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 from solution import max_subarray_sum def test_single_negative_element(): assert max_subarray_sum(1, [-1]) == -1 def test_all_negative_elements(): assert max_subarray_sum(5, [-1, -2, -3, -4, -5]) == -1 def test_mixed_elements(): assert max_subarray_sum(5, [-3, 4, -1, 2, 1]) == 6 def test_all_positive_elements(): assert max_subarray_sum(5, [1, 2, 3, 4, 5]) == 15 def test_single_positive_element(): assert max_subarray_sum(1, [1]) == 1 def test_large_input(): assert max_subarray_sum(6, [1, -2, 3, 10, -4, 7, 2, -5]) == 18 def test_all_zeros(): assert max_subarray_sum(5, [0, 0, 0, 0, 0]) == 0","solution":"def max_subarray_sum(n, fertility_levels): Finds the maximum sum of any continuous subarray. Parameters: n (int): Number of fields. fertility_levels (list of int): List containing the fertility levels of the fields. Returns: int: The maximum sum of the continuous subarray. if n == 0: return 0 max_sum = current_sum = fertility_levels[0] for fertility in fertility_levels[1:]: current_sum = max(fertility, current_sum + fertility) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def find_order(n: int, h: List[int]) -> int: Given a permutation 'h' of integers from 1 to n, find the order of the permutation. The order of a permutation is defined as the smallest positive integer m such that applying 'h' m times returns the identity permutation. Args: n (int): the size of the permutation. h (List[int]): the permutation represented as a list of integers. Returns: int: the order of the permutation. Examples: >>> find_order(4, [2, 3, 4, 1]) 4 >>> find_order(3, [2, 3, 1]) 3 >>> find_order(5, [1, 2, 3, 4, 5]) 1","solution":"def find_order(n, h): This function determines the order of the permutation h. def apply_permutation(permutation, indices): return [indices[permutation[i] - 1] for i in range(len(permutation))] identity = list(range(1, n + 1)) current_permutation = identity[:] order = 0 while True: current_permutation = apply_permutation(h, current_permutation) order += 1 if current_permutation == identity: break return order"},{"question":"def is_subset_sum_possible(books, N, S): Determine if there exists a contiguous subset of books whose sum equals to S. :param books: List[int] - magical powers of the books :param N: int - number of books :param S: int - target sum :return: str - \\"POSSIBLE\\" if such subset exists, otherwise \\"IMPOSSIBLE\\" >>> is_subset_sum_possible([2, -1, 3, 4, 1, 6], 6, 15) \\"POSSIBLE\\" >>> is_subset_sum_possible([2, -1, 3, 4, 1, 6], 6, 20) \\"IMPOSSIBLE\\" >>> is_subset_sum_possible([1, 2, 3], 3, 2) \\"POSSIBLE\\" >>> is_subset_sum_possible([1000, -500, -500, 1000], 4, 1000) \\"POSSIBLE\\" >>> is_subset_sum_possible([-2, -3, -4, -1], 4, -7) \\"POSSIBLE\\" >>> is_subset_sum_possible([1, -1, 2, -2, 3, -3, 4, 4], 8, 8) \\"POSSIBLE\\" >>> is_subset_sum_possible([5, 1, 2, 5, 5, 3], 6, 8) \\"POSSIBLE\\" >>> is_subset_sum_possible([1, 2, 3, 4, 5], 5, 20) \\"IMPOSSIBLE\\"","solution":"def is_subset_sum_possible(books, N, S): Determine if there exists a contiguous subset of books whose sum equals to S. :param books: List[int] - magical powers of the books :param N: int - number of books :param S: int - target sum :return: str - \\"POSSIBLE\\" if such subset exists, otherwise \\"IMPOSSIBLE\\" for start in range(N): current_sum = 0 for end in range(start, N): current_sum += books[end] if current_sum == S: return \\"POSSIBLE\\" return \\"IMPOSSIBLE\\" def read_input(): Reads the input from standard input. import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) S = int(data[1]) books = list(map(int, data[2:2+N])) return books, N, S if __name__ == \\"__main__\\": books, N, S = read_input() result = is_subset_sum_possible(books, N, S) print(result)"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string \`s\`. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 pass def process_test_cases(T: int, test_cases: List[str]) -> List[int]: For the given number of test cases T and the list of test case strings, return a list of lengths of the longest palindromic substrings for each test case. >>> process_test_cases(2, [\\"babad\\", \\"cbbd\\"]) [3, 2] >>> process_test_cases(3, [\\"abba\\", \\"racecar\\", \\"a\\"]) [4, 7, 1] pass","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string \`s\`. n = len(s) if n == 0: return 0 dp = [[0] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = 1 start = 0 for l in range(2, n + 1): for i in range(n - l + 1): j = i + l - 1 if s[i] == s[j]: if l == 2: dp[i][j] = 2 else: if dp[i + 1][j - 1] > 0: dp[i][j] = dp[i + 1][j - 1] + 2 if dp[i][j] > max_length: max_length = dp[i][j] start = i else: dp[i][j] = 0 return max_length def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(longest_palindromic_substring_length(s)) return results"},{"question":"def sum_of_multiples_of_3(lst): Returns the sum of the elements in the list that are multiples of 3. >>> sum_of_multiples_of_3([3, 6, 8, 10]) == 9 >>> sum_of_multiples_of_3([7, 14, 21, 28, 35]) == 21 def process_input(test_cases): Processes the input to calculate the sum of multiples of 3 for each test case. Parameters: test_cases (list of list of int): A list containing the test cases, where each test case is a list of integers. Returns: list of int: A list of results for each test case. >>> process_input([[3, 6, 8, 10], [7, 14, 21, 28, 35]]) == [9, 21] >>> process_input([[1, 2, 4, 5], [3, 6, 9, 12, 15]]) == [0, 45]","solution":"def sum_of_multiples_of_3(lst): Returns the sum of the elements in the list that are multiples of 3. return sum(x for x in lst if x % 3 == 0) def process_input(test_cases): Processes the input to calculate the sum of multiples of 3 for each test case. Parameters: test_cases (list of list of int): A list containing the test cases, where each test case is a list of integers. Returns: list of int: A list of results for each test case. results = [] for test_case in test_cases: results.append(sum_of_multiples_of_3(test_case)) return results"},{"question":"def min_operations(q, test_cases): Returns a list of integers where each integer represents the minimum number of operations needed to transform the string s into a beautiful string for each test case. Parameters: q (int): Number of test cases test_cases (list): A list of tuples, each containing an integer n and a string s Returns: list: A list of integers representing the required minimum number of operations for each test case >>> min_operations(3, [(5, \\"abcde\\"), (3, \\"aaa\\"), (4, \\"xyza\\")]) [4, 0, 3] >>> min_operations(3, [(1, \\"b\\"), (1, \\"a\\"), (1, \\"c\\")]) [1, 0, 1] >>> min_operations(2, [(4, \\"bbbb\\"), (6, \\"cccccc\\")]) [4, 6] >>> min_operations(2, [(5, \\"ababa\\"), (3, \\"abc\\")]) [2, 2] >>> min_operations(1, [(100, \\"b\\" * 50 + \\"a\\" * 50)]) [50] >>> min_operations(1, [(10, \\"aaaaaaaaaa\\")]) [0]","solution":"def min_operations(q, test_cases): Returns a list of integers where each integer represents the minimum number of operations needed to transform the string s into a beautiful string for each test case. Parameters: q (int): Number of test cases test_cases (list): A list of tuples, each containing an integer n and a string s Returns: list: A list of integers representing the required minimum number of operations for each test case results = [] for n, s in test_cases: operations = sum(1 for ch in s if ch != 'a') results.append(operations) return results"},{"question":"def find_num_connected_components(n: int, edges: List[Tuple[int, int]]) -> int: Calculate the number of connected components in the given network graph. >>> find_num_connected_components(5, [(1, 2), (2, 3), (4, 5)]) == 2 >>> find_num_connected_components(4, [(1, 2), (3, 4)]) == 2 >>> find_num_connected_components(6, []) == 6 >>> find_num_connected_components(7, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7)]) == 2","solution":"def find_num_connected_components(n, edges): from collections import defaultdict, deque def bfs(node): queue = deque([node]) visited.add(node) while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Create adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = set() components = 0 for node in range(1, n+1): if node not in visited: bfs(node) components += 1 return components"},{"question":"class ContestSystem: A system to manage contest scores for participants. def __init__(self): self.scores = {} def add(self, P, S): Add a participant P with an initial score S. If participant P already exists, their score should be incremented by S. pass def update(self, P, S): Update the score of participant P to S. If participant P doesn't exist, add them with the score S. pass def query(self, L, R): Return the total score of participants whose IDs lie between L and R inclusive. pass def contest_system(operations): Handle multiple operations for the contest system and return results for QUERY operations. Args: operations (list): List of strings representing operations. Returns: list: List of results for each QUERY operation. >>> operations = [\\"ADD 1 10\\", \\"ADD 2 20\\", \\"QUERY 1 2\\", \\"UPDATE 2 15\\", \\"ADD 3 30\\", \\"QUERY 2 3\\"] >>> contest_system(operations) [30, 45] pass from solution import ContestSystem, contest_system def test_contest_system(): # Test Sample Input operations = [\\"ADD 1 10\\", \\"ADD 2 20\\", \\"QUERY 1 2\\", \\"UPDATE 2 15\\", \\"ADD 3 30\\", \\"QUERY 2 3\\"] expected_output = [30, 45] assert contest_system(operations) == expected_output def test_add_existing_participant(): cs = ContestSystem() cs.add(1, 10) cs.add(1, 15) assert cs.scores[1] == 25 def test_update_participant(): cs = ContestSystem() cs.add(1, 10) cs.update(1, 20) assert cs.scores[1] == 20 def test_query_range(): cs = ContestSystem() cs.add(1, 10) cs.add(2, 20) cs.add(3, 30) result = cs.query(1, 2) assert result == 30 result = cs.query(2, 3) assert result == 50 def test_query_range_with_no_participants(): cs = ContestSystem() result = cs.query(1, 2) assert result == 0 def test_integration(): operations = [\\"ADD 1 5\\", \\"ADD 3 10\\", \\"UPDATE 1 10\\", \\"QUERY 1 4\\", \\"UPDATE 3 15\\", \\"QUERY 2 3\\"] expected_output = [20, 15] assert contest_system(operations) == expected_output","solution":"class ContestSystem: def __init__(self): self.scores = {} def add(self, P, S): if P in self.scores: self.scores[P] += S else: self.scores[P] = S def update(self, P, S): self.scores[P] = S def query(self, L, R): return sum(self.scores[P] for P in self.scores if L <= P <= R) def contest_system(operations): cs = ContestSystem() results = [] for operation in operations: op = operation.split() if op[0] == \\"ADD\\": _, P, S = op cs.add(int(P), int(S)) elif op[0] == \\"UPDATE\\": _, P, S = op cs.update(int(P), int(S)) elif op[0] == \\"QUERY\\": _, L, R = op results.append(cs.query(int(L), int(R))) return results"},{"question":"def correct_positions(arr): Sorts the array such that no student is out of their position. Args: arr (List[int]): An array of positive integers where no student is in their correct position. Returns: List[int]: The sorted array where every student is in their correct position. Example: >>> correct_positions([4, 2, 3, 6, 5, 1]) [1, 2, 3, 4, 5, 6] >>> correct_positions([7, 1, 5, 2, 3, 6]) [1, 2, 3, 5, 6, 7]","solution":"def correct_positions(arr): Sorts the array such that no student is out of their position. return sorted(arr)"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the string s. >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"abcd\\") 10","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the string s. n = len(s) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) # Examples print(count_distinct_substrings(\\"abc\\")) # 6 print(count_distinct_substrings(\\"aaa\\")) # 3 print(count_distinct_substrings(\\"abcd\\")) # 10"},{"question":"class TaskScheduler: def __init__(self): self.tasks = {} self.completed = set() def addTask(self, x, y): Add a task with ID x. Task x depends on task y being completed first. pass def markComplete(self, x): Mark the task with ID x as completed. A task cannot be marked as completed unless all tasks it depends on have been completed. pass def getIncompleteTasks(self): Return a list of all incomplete tasks sorted by their IDs. pass def main(input_lines): Perform operations based on input lines. Example input: 8 addTask 1 0 addTask 2 1 addTask 3 1 getIncompleteTasks markComplete 1 getIncompleteTasks markComplete 2 getIncompleteTasks pass input_lines = [ \\"8\\", \\"addTask 1 0\\", \\"addTask 2 1\\", \\"addTask 3 1\\", \\"getIncompleteTasks\\", \\"markComplete 1\\", \\"getIncompleteTasks\\", \\"markComplete 2\\", \\"getIncompleteTasks\\", ] if __name__ == \\"__main__\\": main(input_lines)","solution":"class TaskScheduler: def __init__(self): self.tasks = {} self.completed = set() def addTask(self, x, y): if x not in self.tasks: self.tasks[x] = set() if y != 0: self.tasks[x].add(y) else: self.tasks[x] = set() def markComplete(self, x): # A task can be marked complete only if all its dependencies are completed if all(dep in self.completed for dep in self.tasks.get(x, [])): self.completed.add(x) def getIncompleteTasks(self): incomplete_tasks = sorted([task for task in self.tasks if task not in self.completed]) if incomplete_tasks: print(\\" \\".join(map(str, incomplete_tasks))) else: print(\\"None\\") def main(input_lines): n = int(input_lines[0]) scheduler = TaskScheduler() for i in range(1, n + 1): parts = input_lines[i].split() command = parts[0] if command == \\"addTask\\": x = int(parts[1]) y = int(parts[2]) scheduler.addTask(x, y) elif command == \\"markComplete\\": x = int(parts[1]) scheduler.markComplete(x) elif command == \\"getIncompleteTasks\\": scheduler.getIncompleteTasks() input_lines = [ \\"8\\", \\"addTask 1 0\\", \\"addTask 2 1\\", \\"addTask 3 1\\", \\"getIncompleteTasks\\", \\"markComplete 1\\", \\"getIncompleteTasks\\", \\"markComplete 2\\", \\"getIncompleteTasks\\", ] if __name__ == \\"__main__\\": main(input_lines)"},{"question":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def sumOfLongestPath(root): Given a Binary Tree, find the sum of all nodes on its longest path from root to leaf. If there are multiple paths with the same length, consider the path with the maximum sum. >>> root = Node(1) >>> root.left = Node(3) >>> root.right = Node(2) >>> sumOfLongestPath(root) 4 >>> root = Node(10) >>> root.left = Node(20) >>> root.right = Node(30) >>> root.left.left = Node(40) >>> root.left.right = Node(60) >>> sumOfLongestPath(root) 90 >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> root.left.left = Node(4) >>> root.left.right = Node(5) >>> root.left.left.right = Node(8) >>> root.right.left = Node(6) >>> sumOfLongestPath(root) 15 >>> root = Node(1) >>> root.left = Node(2) >>> root.right = Node(3) >>> sumOfLongestPath(root) 4 >>> sumOfLongestPath(None) 0 >>> root = Node(1) >>> sumOfLongestPath(root) 1","solution":"class Node: def __init__(self, key): self.data = key self.left = None self.right = None def sumOfLongestPath(root): if not root: return 0 def longestPathSum(node): if not node: return (0, 0) if not node.left and not node.right: return (node.data, 1) left_sum, left_len = longestPathSum(node.left) right_sum, right_len = longestPathSum(node.right) if left_len > right_len: return (left_sum + node.data, left_len + 1) elif left_len < right_len: return (right_sum + node.data, right_len + 1) else: return (max(left_sum, right_sum) + node.data, left_len + 1) max_sum, _ = longestPathSum(root) return max_sum"},{"question":"def minimum_new_connections_required(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: This function returns the minimum number of new connections required to make the entire system fully connected. # Implementation here... def solve(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[int]: Solve the problem for a given number of test cases. # Implementation here... def test_minimum_new_connections_required(): test_cases = [ (5, 3, [(1, 2, 1), (2, 3, 2), (4, 5, 3)]), # Expected output: 1 (4, 5, [(1, 2, 1), (1, 3, 2), (3, 4, 1)]), # Expected output: 0 ] assert solve(2, test_cases) == [1, 0] def test_single_server(): test_cases = [ (1, 0, []), # one server, no connections needed, output should be 0 ] assert solve(1, test_cases) == [0] def test_fully_connected(): test_cases = [ (3, 3, [(1, 2, 4), (2, 3, 5), (3, 1, 6)]), # Fully connected with 3 servers, output should be 0 ] assert solve(1, test_cases) == [0] def test_disconnected_pairs(): test_cases = [ (4, 2, [(1, 2, 7), (3, 4, 8)]), # Two disconnected pairs, output should be 1 ] assert solve(1, test_cases) == [1]","solution":"def find_parent(parent, i): A utility function to find the set of an element i if parent[i] == i: return i else: return find_parent(parent, parent[i]) def union(parent, rank, x, y): A utility function to do union of two subsets x and y xroot = find_parent(parent, x) yroot = find_parent(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def minimum_new_connections_required(N, M, connections): This function returns the minimum number of new connections required to make the entire system fully connected. parent = list(range(N + 1)) rank = [0] * (N + 1) connected_components = N for X, Y, L in connections: X_root = find_parent(parent, X) Y_root = find_parent(parent, Y) if X_root != Y_root: union(parent, rank, X_root, Y_root) connected_components -= 1 return connected_components - 1 # The number of new connections required is one less than the number of disconnected components. def solve(T, test_cases): results = [] for N, M, connections in test_cases: results.append(minimum_new_connections_required(N, M, connections)) return results # Input parsing and function calling would be done here in an actual scenario # for a hypothetical input matrix passed to the function solve."},{"question":"def categorize_price(T, prices): Given the number of test cases T and a list of prices, returns a list of categories (CHEAP, AFFORDABLE, EXPENSIVE) for each price. >>> categorize_price(3, [15, 45, 60]) ['CHEAP', 'AFFORDABLE', 'EXPENSIVE']","solution":"def categorize_price(T, prices): Given the number of test cases T and a list of prices, returns a list of categories (CHEAP, AFFORDABLE, EXPENSIVE) for each price. categories = [] for price in prices: if price < 20: categories.append(\\"CHEAP\\") elif price < 50: categories.append(\\"AFFORDABLE\\") else: categories.append(\\"EXPENSIVE\\") return categories"},{"question":"def min_steps_to_target(X: int, Y: int) -> int: Returns the minimum number of steps required for the robot to reach the target (X, Y) from the origin (0, 0). >>> min_steps_to_target(3, 4) 7 >>> min_steps_to_target(1, 2) 3 >>> min_steps_to_target(-3, -4) 7 >>> min_steps_to_target(-1, -2) 3 >>> min_steps_to_target(3, -4) 7 >>> min_steps_to_target(-3, 4) 7 >>> min_steps_to_target(0, 0) 0 >>> min_steps_to_target(0, 10**9) 1000000000 >>> min_steps_to_target(10**9, 0) 1000000000 >>> min_steps_to_target(10**9, 10**9) 2000000000 >>> min_steps_to_target(-10**9, -10**9) 2000000000","solution":"def min_steps_to_target(X, Y): Returns the minimum number of steps required for the robot to reach the target (X, Y) from the origin (0, 0). return abs(X) + abs(Y) if __name__ == \\"__main__\\": import sys input = sys.stdin.read X, Y = map(int, input().strip().split()) print(min_steps_to_target(X, Y))"},{"question":"def find_missing_number(nums: List[int]) -> int: Finds the missing number in a list of integers containing a sequence from 1 to n with one number missing. >>> find_missing_number([1, 2, 4, 5, 6]) 3 >>> find_missing_number([3, 7, 1, 2, 8, 4, 5]) 6 >>> find_missing_number([1, 2, 3, 5]) 4","solution":"def find_missing_number(nums): Finds the missing number in a list of integers containing a sequence from 1 to n with one number missing. n = len(nums) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) return expected_sum - actual_sum"},{"question":"def knapsack(caves, capacity): Returns the maximum number of gold coins the hunter can collect without exceeding the bag's capacity. def max_gold(T, test_cases): Processes multiple test cases and returns the maximum number of gold coins for each. >>> max_gold(2, [[(5, 10), [1, 4, 3, 5, 2]], [(3, 7), [6, 4, 3]]]) [10, 7] >>> max_gold(2, [[(3, 5), [3, 1, 4]], [(4, 6), [1, 2, 5, 6]]]) [5, 6]","solution":"def knapsack(caves, capacity): Returns the maximum number of gold coins the hunter can collect without exceeding the bag's capacity. dp = [0] * (capacity + 1) for gold in caves: for c in range(capacity, gold - 1, -1): dp[c] = max(dp[c], dp[c - gold] + gold) return dp[capacity] def max_gold(T, test_cases): Processes multiple test cases and returns the maximum number of gold coins for each. results = [] for i in range(T): N, C = test_cases[i][0] caves = test_cases[i][1] result = knapsack(caves, C) results.append(result) return results"},{"question":"from typing import List, Tuple def findSubarrayWithSumK(arr: List[int], K: int, S: int) -> bool: Determines if there is a contiguous subarray of size K that sums to S. Args: arr (List[int]): List of integers. K (int): Size of the subarray. S (int): Target sum of the subarray. Returns: bool: True if such a subarray exists, otherwise False. >>> findSubarrayWithSumK([1, 2, 3, 4, 5], 3, 9) True >>> findSubarrayWithSumK([1, 2, 3, 4, 5], 2, 8) False >>> findSubarrayWithSumK([1, 2, 3, 4, 5], 3, 6) True >>> findSubarrayWithSumK([1, 2, 3], 3, 6) True >>> findSubarrayWithSumK([1, 2, 3], 1, 2) True >>> findSubarrayWithSumK([1, 2, 3], 1, 4) False >>> findSubarrayWithSumK([i for i in range(1, 101)], 5, 15) True >>> findSubarrayWithSumK([1, 2], 5, 3) False","solution":"def findSubarrayWithSumK(arr, K, S): Determines if there is a contiguous subarray of size K that sums to S. Parameters: arr (list of int): List of integers. K (int): Size of the subarray. S (int): Target sum of the subarray. Returns: bool: True if such a subarray exists, otherwise False. n = len(arr) if n < K: return False current_sum = sum(arr[:K]) if current_sum == S: return True for i in range(n - K): current_sum = current_sum - arr[i] + arr[i + K] if current_sum == S: return True return False"},{"question":"def isPowerOfTwo(N: int) -> str: Determines if the given integer N is a power of two. Parameters: N (int): The integer to check Returns: str: \\"Yes\\" if N is a power of two, otherwise \\"No\\" >>> isPowerOfTwo(1) \\"Yes\\" >>> isPowerOfTwo(2) \\"Yes\\" >>> isPowerOfTwo(3) \\"No\\" >>> isPowerOfTwo(4) \\"Yes\\" >>> isPowerOfTwo(5) \\"No\\"","solution":"def isPowerOfTwo(N): Determines if the given integer N is a power of two. Parameters: N (int): The integer to check Returns: str: \\"Yes\\" if N is a power of two, otherwise \\"No\\" if N <= 0: return \\"No\\" return \\"Yes\\" if (N & (N - 1)) == 0 else \\"No\\""},{"question":"def min_subset_diff(arr: List[int]) -> int: Returns the minimum possible difference between the sums of the two subsets. >>> min_subset_diff([1, 6, 11, 5]) 1 >>> min_subset_diff([1, 2, 3, 9]) 3","solution":"def min_subset_diff(arr): Returns the minimum possible difference between the sums of the two subsets. total_sum = sum(arr) n = len(arr) dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] for i in range(n + 1): dp[i][0] = True for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): dp[i][j] = dp[i - 1][j] if arr[i - 1] <= j: dp[i][j] = dp[i][j] or dp[i - 1][j - arr[i - 1]] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j return 0"},{"question":"def smallest_missing_positive_integer(array): Finds the smallest positive integer that is not present in the array. >>> smallest_missing_positive_integer([1, 3, 6, 4, 1, 2]) 5 >>> smallest_missing_positive_integer([1, 2, 3, 4]) 5 >>> smallest_missing_positive_integer([1, 2, 0]) 3 >>> smallest_missing_positive_integer([3, 4, -1, 1]) 2 >>> smallest_missing_positive_integer([7, 8, 9, 11, 12]) 1 >>> smallest_missing_positive_integer([1]) 2 >>> smallest_missing_positive_integer([2]) 1 >>> smallest_missing_positive_integer([1, 2, 2, 3, 4, 6, 7, 8, 8]) 5","solution":"def smallest_missing_positive_integer(array): Finds the smallest positive integer that is not present in the array. # Convert the array to a set for O(1) lookups array_set = set(array) smallest_missing = 1 while smallest_missing in array_set: smallest_missing += 1 return smallest_missing"},{"question":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the given string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\" >>> can_form_palindrome(\\"a\\") \\"YES\\" pass def process_test_cases(T: int, test_cases: list) -> list: Processes multiple test cases to determine if each can be rearranged to form a palindrome. >>> process_test_cases(2, [\\"civic\\", \\"ivicc\\"]) [\\"YES\\", \\"YES\\"] pass","solution":"def can_form_palindrome(s: str) -> str: Determines if any permutation of the given string can be rearranged to form a palindrome. from collections import Counter # Count frequencies of each character in the string char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be permuted to a palindrome if it has at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" # Function to handle multiple test cases def process_test_cases(T: int, test_cases: list) -> list: results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"def max_spell_strength(n: int, m: int, t: int, bridges: List[Tuple[int, int, int]], wizard_islands: List[int]) -> int: Determine the maximum remaining strength of any spell starting and ending at a wizard tower island by visiting any other island and returning. Parameters: n (int): Number of islands. m (int): Number of bridges connecting the islands. t (int): Number of islands with wizard towers. bridges (List[Tuple[int, int, int]]): List of tuples where each tuple consists of three integers a, b, s indicating a bridge between islands a and b with strength s. wizard_islands (List[int]): List of islands that have wizard towers. Returns: int: Maximum remaining strength of a spell or -1 if no such path exists. Examples: >>> max_spell_strength(5, 6, 2, [(1, 2, 5), (2, 3, 1), (3, 4, 1), (4, 5, 10), (1, 3, 2), (2, 4, 3)], [1, 2]) 10 >>> max_spell_strength(4, 3, 1, [(1, 2, 3), (2, 3, 2), (3, 4, 4)], [1]) -1","solution":"import heapq from collections import defaultdict def max_spell_strength(n, m, t, bridges, wizard_islands): def dijkstra(source): distances = {i: float('inf') for i in range(1, n + 1)} distances[source] = 0 pq = [(0, source)] while pq: current_distance, current_island = heapq.heappop(pq) if current_distance > distances[current_island]: continue for neighbor, weight in graph[current_island]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances graph = defaultdict(list) for a, b, s in bridges: graph[a].append((b, s)) graph[b].append((a, s)) max_strength = -1 for wi in wizard_islands: distances = dijkstra(wi) for other_wi in wizard_islands: if other_wi != wi and distances[other_wi] < float('inf'): max_strength = max(max_strength, 2 * min(graph[wi][0][1] for nei, _ in graph[wi])) return max_strength # Example usage: # print(max_spell_strength(5, 6, 2, [(1, 2, 5), (2, 3, 1), (3, 4, 1), (4, 5, 10), (1, 3, 2), (2, 4, 3)], [1, 2])) # Output: 10"},{"question":"def process_optimization(n: int, edges: List[Tuple[int, int]], k: int) -> int: Determine the minimum value of the maximum delivery distance for any warehouse to main hubs after direct routes are added between the main hubs. Parameters: n (int): The number of warehouses. edges (List[Tuple[int, int]]): List of tuples representing roads between warehouses. k (int): The number of warehouses to be designated as main hubs. Returns: int: The minimum value of the maximum delivery distance for any warehouse to a main hub. Example: >>> process_optimization(6, [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)], 2) 2 pass # Unit Tests import pytest def test_basic_case(): assert process_optimization(6, [(1, 2), (1, 3), (3, 4), (3, 5), (5, 6)], 2) == 2 def test_single_hub(): assert process_optimization(4, [(1, 2), (2, 3), (3, 4)], 1) == 2 def test_hubs_equal_to_warehouses(): assert process_optimization(3, [(1, 2), (2, 3)], 3) == 0 def test_more_complex_case(): assert process_optimization(7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], 2) == 3 def test_two(): assert process_optimization(5, [(1, 2), (2, 3), (3, 4), (4, 5)], 2) == 2","solution":"import heapq from collections import deque, defaultdict def bfs_farthest_node(graph, start): Perform BFS to find the farthest node and its distance from the starting node. queue = deque([(start, 0)]) visited = set([start]) farthest_node = start max_dist = 0 while queue: node, dist = queue.popleft() if dist > max_dist: farthest_node = node max_dist = dist for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, dist + 1)) return farthest_node, max_dist def min_max_delivery_distance(n, roads, k): if k >= n: return 0 graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) # Find one endpoint of the diameter of the tree using BFS farthest_node, _ = bfs_farthest_node(graph, 1) # Find the other endpoint of the diameter other_endpoint, max_diameter = bfs_farthest_node(graph, farthest_node) # To minimize the max delivery distance, k must be evenly spaced along the tree's diameter if k == 1: return (max_diameter + 1) // 2 return (max_diameter + 1 - (k - 2)) // 2 # Function to process input and output def process_optimization(n, edges, k): return min_max_delivery_distance(n, edges, k)"},{"question":"def can_construct_network(n: int, m: int, pipes: List[Tuple[int, int]]) -> str: Determine if it's possible to construct the required network using a subset of the given pipes. The network should remain connected even if any single pipe breaks. :param n: Number of houses. :param m: Number of possible pipes. :param pipes: List of tuples where each tuple represents a direct pipe connection between two houses. :return: \\"YES\\" if it is possible to construct the required network, otherwise \\"NO\\". >>> can_construct_network(4, 5, [(0, 1), (0, 2), (2, 1), (1, 3), (2, 3)]) == \\"YES\\" >>> can_construct_network(4, 2, [(0, 1), (2, 3)]) == \\"NO\\"","solution":"def can_construct_network(n, m, pipes): from collections import defaultdict from itertools import combinations def is_connected(graph, n): visited = [False] * n def dfs(node): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor) dfs(0) return all(visited) def remove_edge(graph, u, v): graph[u].remove(v) graph[v].remove(u) def add_edge(graph, u, v): graph[u].append(v) graph[v].append(u) # Build the adjacency list graph = defaultdict(list) for u, v in pipes: add_edge(graph, u, v) # Check if the entire graph is initially connected if not is_connected(graph, n): return \\"NO\\" # Check connectivity after removing each edge for u, v in pipes: remove_edge(graph, u, v) if not is_connected(graph, n): add_edge(graph, u, v) else: add_edge(graph, u, v) return \\"YES\\" return \\"NO\\""},{"question":"def length_of_longest_substring_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with at most k distinct characters. >>> length_of_longest_substring_k_distinct(\\"eceba\\", 2) 3 >>> length_of_longest_substring_k_distinct(\\"aa\\", 1) 2 >>> length_of_longest_substring_k_distinct(\\"aabbcc\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"a\\", 1) 1 >>> length_of_longest_substring_k_distinct(\\"abcadcacacaca\\", 3) 11 >>> length_of_longest_substring_k_distinct(\\"abaccc\\", 2) 4 >>> length_of_longest_substring_k_distinct(\\"\\", 3) 0 >>> length_of_longest_substring_k_distinct(\\"abcde\\", 0) 0","solution":"def length_of_longest_substring_k_distinct(s, k): Returns the length of the longest substring with at most k distinct characters. if not s: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def shuffle_array(arr): Write a function \`shuffle_array\` that takes a list of integers and rearranges its elements in random order. The function should return a new list with shuffled elements. Notes: - Do not use any built-in functions or library methods for shuffling elements. - The original list should remain unchanged, and the function should return a new list with shuffled elements. >>> original = [1, 2, 3, 4, 5] >>> shuffled = shuffle_array(original) >>> original == [1, 2, 3, 4, 5] True >>> sorted(shuffled) == [1, 2, 3, 4, 5] True","solution":"import random def shuffle_array(arr): Returns a new list with elements of arr shuffled in random order. # Copy the original list to avoid modifying it shuffled_arr = arr[:] # Perform a Fisher-Yates shuffle n = len(shuffled_arr) for i in range(n - 1, 0, -1): j = random.randint(0, i) # Swap elements at indices i and j shuffled_arr[i], shuffled_arr[j] = shuffled_arr[j], shuffled_arr[i] return shuffled_arr"},{"question":"def can_sort_grid(test_cases: List[Tuple[int, int, List[List[int]]]]) -> List[str]: Determine if all rows and columns of each grid can be sorted in non-decreasing order using any number of 90-degree rotations on any 3x3 subgrids. Return \\"Possible\\" if it can be done, otherwise \\"Impossible\\". Args: test_cases: A list of tuples, where each tuple contains: n: number of rows in the grid m: number of columns in the grid grid: the 2D grid of integers Returns: List of strings where each string is either \\"Possible\\" or \\"Impossible\\" >>> can_sort_grid([(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]), (3, 4, [ ... [7, 5, 3, 1], ... [6, 4, 2, 8], ... [9, 0, 1, 3] ... ])]) [\\"Possible\\", \\"Impossible\\"] pass from solution import can_sort_grid def test_can_sort_grid(): test_cases = [ (3, 3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (3, 4, [ [7, 5, 3, 1], [6, 4, 2, 8], [9, 0, 1, 3] ]) ] expected = [\\"Possible\\", \\"Impossible\\"] assert can_sort_grid(test_cases) == expected def test_larger_grid_possible(): test_cases = [ (4, 4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ] expected = [\\"Possible\\"] assert can_sort_grid(test_cases) == expected def test_larger_grid_impossible(): test_cases = [ (4, 4, [ [16, 15, 14, 13], [12, 11, 10, 9], [8, 7, 6, 5], [4, 3, 2, 1] ]) ] expected = [\\"Impossible\\"] assert can_sort_grid(test_cases) == expected def test_mixed_possibility(): test_cases = [ (3, 3, [ [2, 3, 1], [5, 6, 4], [8, 9, 7] ]), (3, 3, [ [1, 3, 5], [4, 6, 8], [7, 9, 11] ]) ] expected = [\\"Impossible\\", \\"Possible\\"] assert can_sort_grid(test_cases) == expected","solution":"def can_sort_grid(test_cases): results = [] def is_sorted(lst): return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) for n, m, grid in test_cases: rows_sorted = all(is_sorted(row) for row in grid) cols_sorted = all(is_sorted([grid[i][j] for i in range(n)]) for j in range(m)) if rows_sorted and cols_sorted: results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"from typing import List def most_frequent_element_finder(numbers: List[int]) -> int: Finds and returns the most frequently occurring element in a list of integers. If there are multiple elements with the same highest frequency, returns the smallest one. >>> most_frequent_element_finder([3, 1, 4, 4, 5, 1, 1, 2, 4, 5, 5, 5]) 5 >>> most_frequent_element_finder([4, 4, 1, 1]) 1 >>> most_frequent_element_finder([1, 2, 3, 4]) 1 >>> most_frequent_element_finder([7, 7, 7, 7, 7]) 7 >>> most_frequent_element_finder([3, -1, -1, 2, 2, -2, -1]) -1 >>> most_frequent_element_finder([1] * 1000 + [2] * 500 + [3] * 2000) 3","solution":"from collections import Counter def most_frequent_element_finder(numbers): Finds and returns the most frequently occurring element in a list of integers. If there are multiple elements with the same highest frequency, returns the smallest one. :param numbers: List of integers :return: The most frequently occurring element # Count the frequency of each element using Counter frequency = Counter(numbers) # Find the maximum frequency max_frequency = max(frequency.values()) # Filter elements that have the maximum frequency and return the smallest one. most_frequent_elements = [key for key, value in frequency.items() if value == max_frequency] return min(most_frequent_elements)"},{"question":"def num_ways_to_reach_end(N: int, M: int, grid: List[str]) -> int: Calculate the number of ways to reach the bottom-right corner of the grid from the top-left corner. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[str]): The grid represented as a list of strings where '.' is an empty cell and '#' is a blocked cell. Returns: int: The number of ways to reach the bottom-right corner from the top-left corner modulo 10^9 + 7. Examples: >>> num_ways_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_ways_to_reach_end(4, 4, [\\"....\\", \\".#..\\", \\"..#.\\", \\"....\\"]) 4","solution":"MOD = 10**9 + 7 def num_ways_to_reach_end(N, M, grid): dp = [[0] * M for _ in range(N)] if grid[0][0] == '.': dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[N-1][M-1]"},{"question":"def min_operations_to_palindrome(arr: List[int]) -> int: Given an integer array, perform a sequence of operations to transform the array into a palindrome. A palindrome is an array that reads the same forward and backward. In one operation, you can merge two adjacent elements into their sum. The goal is to find the minimum number of operations required to transform the given array into a palindrome. >>> min_operations_to_palindrome([1, 4, 5, 9, 1]) 1 >>> min_operations_to_palindrome([1, 2, 3, 2, 1]) 0 >>> min_operations_to_palindrome([5]) 0 >>> min_operations_to_palindrome([5, 5]) 0 >>> min_operations_to_palindrome([5, 3]) 1 >>> min_operations_to_palindrome([1000, 100, 10, 1000]) 1 >>> min_operations_to_palindrome([1, 2, 1, 2, 1]) 0","solution":"def min_operations_to_palindrome(arr): Returns the minimum number of operations required to transform the given array into a palindrome. In one operation, you can merge two adjacent elements into their sum. def recursive_transformation(arr, left, right): if left >= right: return 0 if arr[left] == arr[right]: return recursive_transformation(arr, left + 1, right - 1) if arr[left] < arr[right]: arr[left + 1] += arr[left] return 1 + recursive_transformation(arr, left + 1, right) else: arr[right - 1] += arr[right] return 1 + recursive_transformation(arr, left, right - 1) return recursive_transformation(arr, 0, len(arr) - 1)"},{"question":"def library_management(transactions): Track the inventory of books in a library based on transactions. Each transaction is either adding a book or borrowing a book. :param transactions: List of strings representing transactions. :return: List of strings representing the result of borrow transactions and the final inventory status. >>> transactions = [ ... \\"ADD HarryPotter1\\", ... \\"ADD HarryPotter2\\", ... \\"ADD HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"BORROW HarryPotter2\\", ... \\"BORROW HarryPotter3\\", ... \\"END\\" ... ] >>> library_management(transactions) [\\"YES\\", \\"YES\\", \\"NO\\", \\"HarryPotter1: 1\\", \\"HarryPotter2: 0\\"] >>> transactions = [ ... \\"ADD HarryPotter1\\", ... \\"ADD HarryPotter2\\", ... \\"ADD LOTR\\", ... \\"END\\" ... ] >>> library_management(transactions) [\\"HarryPotter1: 1\\", \\"HarryPotter2: 1\\", \\"LOTR: 1\\"] >>> transactions = [ ... \\"BORROW HarryPotter1\\", ... \\"BORROW HarryPotter2\\", ... \\"END\\" ... ] >>> library_management(transactions) [\\"NO\\", \\"NO\\"] >>> transactions = [ ... \\"ADD HarryPotter1\\", ... \\"ADD HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"END\\" ... ] >>> library_management(transactions) [\\"YES\\", \\"YES\\", \\"NO\\", \\"HarryPotter1: 0\\"] >>> transactions = [ ... \\"ADD HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"ADD HarryPotter1\\", ... \\"BORROW HarryPotter1\\", ... \\"END\\" ... ] >>> library_management(transactions) [\\"YES\\", \\"YES\\", \\"HarryPotter1: 0\\"]","solution":"def library_management(transactions): inventory = {} result = [] for transaction in transactions: if transaction == \\"END\\": break command, book_name = transaction.split(' ', 1) if command == \\"ADD\\": if book_name in inventory: inventory[book_name] += 1 else: inventory[book_name] = 1 elif command == \\"BORROW\\": if book_name in inventory and inventory[book_name] > 0: inventory[book_name] -= 1 result.append(\\"YES\\") else: result.append(\\"NO\\") # Append the final inventory status to result for book, count in inventory.items(): result.append(f\\"{book}: {count}\\") return result"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if any permutation of the given string can form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabb\\") True","solution":"def can_form_palindrome(s): Returns True if any permutation of the string s can form a palindrome, False otherwise. from collections import Counter count_chars = Counter(s) odd_count = sum(1 for count in count_chars.values() if count % 2 != 0) return odd_count <= 1"},{"question":"def minimum_groups(skill_levels): Determines the minimum number of groups required to accommodate all participants according to their skill levels. Each group can only have participants with the same skill level. >>> minimum_groups([1, 2, 2, 1, 3, 3]) 3 >>> minimum_groups([5, 5, 5, 5, 5]) 1 >>> minimum_groups([4, 3, 3, 2]) 3","solution":"def minimum_groups(skill_levels): Determines the minimum number of groups required to accommodate all participants according to their skill levels. Each group can only have participants with the same skill level. :param skill_levels: List of integers representing the skill levels of participants :return: Integer representing the minimum number of groups required skill_level_set = set(skill_levels) return len(skill_level_set)"},{"question":"def can_be_strictly_increasing(n: int, k: int, a: list) -> str: Determines if an array \`a\` of length \`n\` can be made strictly increasing by removing exactly \`k\` elements. Args: n (int): The length of the array. k (int): The number of elements to remove. a (list): The list of integers. Returns: str: \\"YES\\" if it is possible to create a strictly increasing array by removing k elements, otherwise \\"NO\\". >>> can_be_strictly_increasing(5, 2, [5, 3, 4, 7, 8]) 'YES' >>> can_be_strictly_increasing(6, 3, [1, 5, 2, 6, 3, 8]) 'YES' >>> can_be_strictly_increasing(4, 1, [1, 2, 3, 4]) 'YES' >>> can_be_strictly_increasing(5, 2, [4, 3, 2, 1, 0]) 'NO' >>> can_be_strictly_increasing(4, 2, [1, 3, 2, 6]) 'YES' >>> can_be_strictly_increasing(3, 0, [1, 2, 3]) 'YES' >>> can_be_strictly_increasing(3, 0, [2, 1, 3]) 'NO' def solve(test_cases: list) -> list: Solves multiple test cases to determine if each can be made strictly increasing by removing a certain number of elements. Args: test_cases (list): A list of tuples, each containing the parameters for one test case (n, k, a). Returns: list: A list of results for each test case, either \\"YES\\" or \\"NO\\". >>> solve([(5, 2, [5, 3, 4, 7, 8]), (6, 3, [1, 5, 2, 6, 3, 8]), (4, 1, [1, 2, 3, 4])]) ['YES', 'YES', 'YES'] >>> solve([(5, 2, [4, 3, 2, 1, 0]), (4, 2, [1, 3, 2, 6])]) ['NO', 'YES'] >>> solve([(3, 0, [1, 2, 3]), (3, 0, [2, 1, 3])]) ['YES', 'NO']","solution":"def can_be_strictly_increasing(n, k, a): Determines if an array \`a\` of length \`n\` can be made strictly increasing by removing exactly \`k\` elements. Args: n (int): The length of the array. k (int): The number of elements to remove. a (list): The list of integers. Returns: str: \\"YES\\" if it is possible to create a strictly increasing array by removing k elements, otherwise \\"NO\\". from itertools import combinations for comb in combinations(a, n - k): if all(x < y for x, y in zip(comb, comb[1:])): return \\"YES\\" return \\"NO\\" def solve(test_cases): results = [] for n, k, a in test_cases: results.append(can_be_strictly_increasing(n, k, a)) return results"},{"question":"def maxSum(arr: List[int]) -> int: Calculate the maximum sum that Alice can achieve following optimal play rules. >>> maxSum([1, 2, 3, 4]) 6 >>> maxSum([8, 15, 3, 7]) 22 from solution import maxSum def test_example_1(): assert maxSum([1, 2, 3, 4]) == 6 def test_example_2(): assert maxSum([8, 15, 3, 7]) == 22 def test_single_element(): assert maxSum([10]) == 10 def test_two_elements(): assert maxSum([10, 20]) == 20 def test_large_input(): assert maxSum([1, 1000, 100, 10]) == 1010 def test_same_elements(): assert maxSum([5, 5, 5, 5]) == 10","solution":"def maxSum(arr): n = len(arr) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = arr[i] for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 dp[i][j] = max(arr[i] + min(dp[i + 2][j] if i + 2 <= j else 0, dp[i + 1][j - 1] if i + 1 <= j - 1 else 0), arr[j] + min(dp[i + 1][j - 1] if i + 1 <= j - 1 else 0, dp[i][j - 2] if i <= j - 2 else 0)) return dp[0][n - 1]"},{"question":"def largestRectangleArea(heights): Returns the maximum area of the rectangle that can be formed by any number of contiguous buildings. :param heights: List[int] - List of building heights. :return: int - Maximum rectangular area in the histogram formed by buildings. Examples: >>> largestRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> largestRectangleArea([2, 4]) 4 >>> largestRectangleArea([1, 3, 2, 1, 2]) 5 from solution import largestRectangleArea def test_single_building(): assert largestRectangleArea([4]) == 4 assert largestRectangleArea([0]) == 0 def test_two_buildings(): assert largestRectangleArea([2, 4]) == 4 assert largestRectangleArea([4, 2]) == 4 def test_multiple_buildings(): assert largestRectangleArea([2, 1, 5, 6, 2, 3]) == 10 assert largestRectangleArea([2, 1, 2]) == 3 def test_same_height_buildings(): assert largestRectangleArea([5, 5, 5, 5]) == 20 assert largestRectangleArea([1, 1, 1, 1, 1]) == 5 def test_large_heights(): assert largestRectangleArea([100000, 100000]) == 200000 def test_varied_heights(): assert largestRectangleArea([1, 3, 2, 1, 2]) == 5 def test_single_huge_building(): assert largestRectangleArea([1, 100000, 1]) == 100000","solution":"def largestRectangleArea(heights): Returns the maximum area of the rectangle that can be formed by any number of contiguous buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def is_typed_correctly(keys: str, typed: str) -> str: Determine if John typed only the characters that exist on his keyboard in the exact sequence. keys: A string representing John's keyboard configuration. typed: A string representing the sequence of characters John typed. Return \\"yes\\" if John only used characters that are present on his keyboard and in the correct order. Otherwise, return \\"no\\". >>> is_typed_correctly(\\"abcdefg\\", \\"abc\\") \\"yes\\" >>> is_typed_correctly(\\"abcdefg\\", \\"axb\\") \\"no\\" >>> is_typed_correctly(\\"abcdefg\\", \\"axc\\") \\"no\\" >>> is_typed_correctly(\\"abcdefg\\", \\"abcdefg\\") \\"yes\\" >>> is_typed_correctly(\\"abcdefg\\", \\"gfedcba\\") \\"no\\" >>> is_typed_correctly(\\"qwertyuiop\\", \\"qw\\") \\"yes\\" >>> is_typed_correctly(\\"qwert\\", \\"qweryt\\") \\"no\\"","solution":"def is_typed_correctly(keys, typed): Checks if the sequence of key presses in 'typed' is consistent with the characters on 'keys'. keys_index = 0 for char in typed: while keys_index < len(keys) and keys[keys_index] != char: keys_index += 1 if keys_index == len(keys): return \\"no\\" keys_index += 1 return \\"yes\\""},{"question":"from typing import List, Tuple def are_isomorphic(edges1: List[Tuple[int, int]], edges2: List[Tuple[int, int]]) -> str: Determines whether two rooted trees are isomorphic. >>> are_isomorphic([(1, 2), (1, 3)], [(1, 2), (1, 3)]) \\"Yes\\" >>> are_isomorphic([(1, 2), (2, 3), (3, 4)], [(1, 2), (1, 3), (1, 4)]) \\"No\\" pass def process_input(input_data: str) -> List[str]: Processes the input data for the isomorphic trees problem. >>> process_input('''2 3 1 2 1 3 3 1 2 1 3 4 1 2 2 3 3 4 4 1 2 1 3 1 4''') [\\"Yes\\", \\"No\\"] pass","solution":"from collections import defaultdict from typing import List, Tuple def hash_tree(children, root, parent): Helper function to recursively generate hash representation of the tree primes = [31, 29, 23, 19, 17] subtree_hash = [] for child in children[root]: if child != parent: subtree_hash.append(hash_tree(children, child, root)) subtree_hash.sort() result = 1 for idx, h in enumerate(subtree_hash): result = result * primes[idx % len(primes)] + h return result def are_isomorphic(edges1: List[Tuple[int, int]], edges2: List[Tuple[int, int]]) -> str: if len(edges1) != len(edges2): return \\"No\\" # Build adjacency list for both trees def build_adj_list(edges): adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) return adj_list adj_list1 = build_adj_list(edges1) adj_list2 = build_adj_list(edges2) # Generate hash representation of both trees starting from node 1 tree1_hash = hash_tree(adj_list1, 1, -1) tree2_hash = hash_tree(adj_list2, 1, -1) return \\"Yes\\" if tree1_hash == tree2_hash else \\"No\\" def process_input(input_data: str) -> List[str]: lines = input_data.strip().split(\\"n\\") idx = 0 num_cases = int(lines[idx]) idx += 1 results = [] for _ in range(num_cases): N1 = int(lines[idx]) idx += 1 edges1 = [] for _ in range(N1 - 1): u, v = map(int, lines[idx].split()) edges1.append((u, v)) idx += 1 N2 = int(lines[idx]) idx += 1 edges2 = [] for _ in range(N2 - 1): w, x = map(int, lines[idx].split()) edges2.append((w, x)) idx += 1 result = are_isomorphic(edges1, edges2) results.append(result) return results"},{"question":"from typing import List def validate_sessions(n: int, sessions: List[str]) -> str: Validates if the given time slots overlap or not. Args: n (int): The number of sessions. sessions (list): A list of strings where each string represents a session's time slot in format \\"HH:MM-HH:MM\\". Returns: str: \\"YES\\" if no time slots overlap, \\"NO\\" otherwise. Examples: >>> validate_sessions(3, [\\"09:00-10:00\\", \\"10:00-11:00\\", \\"11:00-12:00\\"]) \\"YES\\" >>> validate_sessions(3, [\\"09:00-10:30\\", \\"10:00-11:00\\", \\"11:00-12:00\\"]) \\"NO\\"","solution":"from datetime import datetime def validate_sessions(n, sessions): Validates if the given time slots overlap or not. Args: n (int): The number of sessions. sessions (list): A list of strings where each string represents a session's time slot in format \\"HH:MM-HH:MM\\". Returns: str: \\"YES\\" if no time slots overlap, \\"NO\\" otherwise. # Parse the sessions into start and end datetime objects time_slots = [] for session in sessions: start, end = session.split('-') start_time = datetime.strptime(start, '%H:%M') end_time = datetime.strptime(end, '%H:%M') time_slots.append((start_time, end_time)) # Sort the slots based on the start time time_slots.sort(key=lambda x: x[0]) # Check for any overlapping sessions for i in range(1, n): if time_slots[i][0] < time_slots[i-1][1]: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Tuple def shortest_distances(n: int, k: int, schools: List[int], roads: List[Tuple[int, int]]) -> List[int]: You are given a city network with n intersections and n-1 roads, forming a tree. Each intersection has a unique ID from 1 to n. Some intersections have houses, and others have schools. You need to determine the shortest distance from each house to any school. Args: n (int): number of intersections k (int): number of schools schools (List[int]): list of integers representing the intersections where the schools are located roads (List[Tuple[int, int]]): List of tuples where each tuple represents a road between intersections u and v Returns: List[int]: List of integers where each integer represents the shortest distance to the nearest school for each intersection Example: >>> shortest_distances(5, 2, [1, 3], [(1, 2), (1, 4), (2, 5), (3, 4)]) [0, 1, 0, 1, 2] >>> shortest_distances(3, 3, [1, 2, 3], [(1, 2), (2, 3)]) [0, 0, 0]","solution":"from collections import deque, defaultdict def shortest_distances(n, k, schools, roads): # Initialize the graph, distances, and queue graph = defaultdict(list) distances = [-1] * (n + 1) queue = deque() # Build the graph from the roads information for u, v in roads: graph[u].append(v) graph[v].append(u) # Initialize distances for schools and add them to the queue for school in schools: distances[school] = 0 queue.append(school) # BFS to calculate shortest distance to any school while queue: current = queue.popleft() for neighbor in graph[current]: if distances[neighbor] == -1: distances[neighbor] = distances[current] + 1 queue.append(neighbor) # Output the distances for each intersection from 1 to n return distances[1:] # Example usage n = 5 k = 2 schools = [1, 3] roads = [(1, 2), (1, 4), (2, 5), (3, 4)] print(shortest_distances(n, k, schools, roads)) # Output: [0, 1, 0, 1, 2]"},{"question":"def has_pair_with_sum(nums: List[int], target: int) -> bool: Determines if there are distinct integers in the list that add up to the target sum. >>> has_pair_with_sum([3, 5, -1, 7, 11], 10) True >>> has_pair_with_sum([2, 4, 3, -3, 7], 0) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 9) True >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) False >>> has_pair_with_sum([-1, -2, -3, -4], -10) False >>> has_pair_with_sum([-1, -2, -3, 4], 1) True >>> has_pair_with_sum([10, -10, 1, -2], -1) True pass","solution":"def has_pair_with_sum(nums, target): Determines if there are distinct integers in the list that add up to the target sum. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def countBuildingsWithSunlight(height): Returns the number of buildings that have a direct view of the sunset when the sun is setting from the right. >>> countBuildingsWithSunlight([3, 7, 8, 3, 6, 1]) 3 >>> countBuildingsWithSunlight([1, 2, 3, 4]) 1 >>> countBuildingsWithSunlight([4, 3, 2, 1]) 4 >>> countBuildingsWithSunlight([7, 4, 2, 5, 1]) 3 >>> countBuildingsWithSunlight([]) 0 >>> countBuildingsWithSunlight([10, 10, 10, 10]) 1 >>> countBuildingsWithSunlight([1, 2, 2, 2, 1]) 2 >>> countBuildingsWithSunlight([5, 10, 5, 10, 5, 10]) 1 >>> countBuildingsWithSunlight([9, 8, 7, 6, 5, 11]) 1 >>> countBuildingsWithSunlight([0, 0, 0, 0, 0, 1]) 1","solution":"def countBuildingsWithSunlight(height): Returns the number of buildings that have a direct view of the sunset when the sun is setting from the right. if not height: return 0 count = 1 # The rightmost building always has a direct view of the sunset. tallest = height[-1] # Iterate from the second to last building to the first. for i in range(len(height) - 2, -1, -1): if height[i] > tallest: count += 1 tallest = height[i] return count"},{"question":"def average_grades(student_grades): Accepts a dictionary where the keys are student names and the values are lists of their grades. Returns a dictionary where the keys are the original student names and the values are their average grades, rounded to 2 decimal places. If a student has no grades, their average should be represented as 0.00. >>> average_grades({ \\"Alice\\": [90, 85, 88], \\"Bob\\": [70, 80, 75], \\"Charlie\\": [], \\"David\\": [95, 92] }) {'Alice': 87.67, 'Bob': 75.00, 'Charlie': 0.00, 'David': 93.50} pass def test_average_grades(): input_data = { \\"Alice\\": [90, 85, 88], \\"Bob\\": [70, 80, 75], \\"Charlie\\": [], \\"David\\": [95, 92] } expected_output = { \\"Alice\\": 87.67, \\"Bob\\": 75.00, \\"Charlie\\": 0.00, \\"David\\": 93.50 } assert average_grades(input_data) == expected_output def test_average_grades_mixed_empty_non_empty(): input_data = { \\"Jane\\": [82, 90, 86], \\"John\\": [], \\"Doe\\": [78, 80] } expected_output = { \\"Jane\\": 86.00, \\"John\\": 0.00, \\"Doe\\": 79.00 } assert average_grades(input_data) == expected_output def test_average_grades_all_empty(): input_data = { \\"Eve\\": [], \\"Sam\\": [], \\"Max\\": [] } expected_output = { \\"Eve\\": 0.00, \\"Sam\\": 0.00, \\"Max\\": 0.00 } assert average_grades(input_data) == expected_output def test_average_grades_single_grades(): input_data = { \\"Elena\\": [100], \\"Mike\\": [60], \\"Nina\\": [80] } expected_output = { \\"Elena\\": 100.00, \\"Mike\\": 60.00, \\"Nina\\": 80.00 } assert average_grades(input_data) == expected_output","solution":"def average_grades(student_grades): Accepts a dictionary where the keys are student names and the values are lists of their grades. Returns a dictionary where the keys are the original student names and the values are their average grades, rounded to 2 decimal places. If a student has no grades, their average should be represented as 0.00. result = {} for student, grades in student_grades.items(): if grades: avg_grade = round(sum(grades) / len(grades), 2) else: avg_grade = 0.00 result[student] = avg_grade return result"},{"question":"from typing import List, Tuple def max_contiguous_subarray_sum_with_k_swaps(t: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[int]: Given two sequences of integers, \`a\` and \`b\`, of length \`n\`, determine the maximum value of any contiguous subarray of \`a\` that can be achieved by swapping at most \`k\` pairs of corresponding elements in \`b\`. For each swap, you can choose two different indices \`i\` and \`j\` and swap \`b[i]\` and \`b[j]\`. The task is to find the maximum sum of any contiguous subarray of \`a\` after performing at most \`k\` swaps on \`b\`. :param t: Number of test cases. :param test_cases: List of tuples, where each tuple consists of: - (n: int, k: int): Length of the sequences \`a\` and \`b\` and maximum number of swaps allowed. - a: List of integers representing sequence \`a\`. - b: List of integers representing sequence \`b\`. :return: List of integers representing the maximum value of any contiguous subarray of \`a\` for each test case. >>> max_contiguous_subarray_sum_with_k_swaps(3, [([5, 2], [1, 5, 3, 1, 2], [2, 1, 3, 4, 5]), ([4, 0], [4, 3, 2, 1], [5, 6, 7, 8]), ([6, 1], [10, 20, 30, 40, 50, 60], [6, 5, 4, 3, 2, 1])]) [12, 10, 210] >>> max_contiguous_subarray_sum_with_k_swaps(1, [([3, 1], [3, 2, 1], [2, 2, 2])]) [6] >>> max_contiguous_subarray_sum_with_k_swaps(1, [([5, 3], [1, 2, 3, 4, 5], [5, 4, 3, 2, 1])]) [15] pass","solution":"def max_contiguous_subarray_sum_with_k_swaps(t, test_cases): results = [] def kadane(arr): max_current = max_global = arr[0] for i in range(1, len(arr)): max_current = max(arr[i], max_current + arr[i]) if max_current > max_global: max_global = max_current return max_global for i in range(t): n, k = test_cases[i][0] a = test_cases[i][1] b = test_cases[i][2] a_sorted = sorted(a, reverse=True) b_sorted = sorted(b) for j in range(min(k, n)): if a_sorted[j] > b_sorted[j]: b_sorted[j] = a_sorted[j] else: break max_sum = kadane(a) results.append(max_sum) return results"},{"question":"def prime_factorization(n: int) -> str: Returns the prime factorization of the number n as a string in the specified format. >>> prime_factorization(20) \\"2^2 5\\" >>> prime_factorization(100) \\"2^2 5^2\\" >>> prime_factorization(71) \\"71\\" >>> prime_factorization(360) \\"2^3 3^2 5\\" >>> prime_factorization(1) \\"\\"","solution":"def prime_factorization(n): Returns the prime factorization of the number n as a string in the form specified. def get_prime_factors(n): factors = {} d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 if n > 1: factors[n] = 1 return factors if n == 1: return \\"\\" factors = get_prime_factors(n) result = [] for prime in sorted(factors): if factors[prime] == 1: result.append(f\\"{prime}\\") else: result.append(f\\"{prime}^{factors[prime]}\\") return \\" \\".join(result)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: Check whether a given binary tree is symmetric. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.left = TreeNode(3) >>> root.left.right = TreeNode(4) >>> root.right.left = TreeNode(4) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) True >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(2) >>> root.left.right = TreeNode(3) >>> root.right.right = TreeNode(3) >>> isSymmetric(root) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root: TreeNode) -> bool: def isMirror(tree1: TreeNode, tree2: TreeNode) -> bool: if not tree1 and not tree2: return True if not tree1 or not tree2: return False return (tree1.val == tree2.val and isMirror(tree1.left, tree2.right) and isMirror(tree1.right, tree2.left)) return isMirror(root, root)"},{"question":"def bubble_sort(arr): Sorts an array using the Bubble Sort algorithm. Parameters: - arr: list of integers Returns: - Sorted list of integers n = len(arr) for i in range(n): # Last i elements are already in place for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr def sort_input(n, elements): Sorts the elements of the array using bubble sort and returns the sorted array. Parameters: - n: int, the number of elements in the array - elements: list of int, the elements of the array Returns: - list of int: the sorted elements of the array >>> sort_input(5, [64, 34, 25, 12, 22]) [12, 22, 25, 34, 64] >>> sort_input(4, [4, 3, 2, 1]) [1, 2, 3, 4] >>> sort_input(3, [3, 2, 1]) [1, 2, 3] >>> sort_input(1, [1]) [1] >>> sort_input(4, [2, 2, 2, 2]) [2, 2, 2, 2] >>> sort_input(5, [1000000, 999999, 123456, 654321, 789012]) [123456, 654321, 789012, 999999, 1000000]","solution":"def bubble_sort(arr): Sorts an array using the Bubble Sort algorithm. Parameters: - arr: list of integers Returns: - Sorted list of integers n = len(arr) for i in range(n): # Last i elements are already in place for j in range(0, n - i - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr def sort_input(n, elements): Sorts the elements of the array using bubble sort. Parameters: - n: int, number of elements in the array - elements: list of integers, the elements of the array Returns: - List of sorted elements return bubble_sort(elements)"},{"question":"def min_jumps(arr): Determine the minimum number of jumps required to reach the end of the array. Parameters: arr (list): List of integers where each element represents the maximum steps you can move from that position. Returns: int: Minimum number of jumps required to reach the end of the array. Examples: >>> min_jumps([2, 3, 1, 1, 4]) 2 >>> min_jumps([1, 4, 2, 1, 0, 2, 1]) 3 >>> min_jumps([1, 1, 1, 1, 1]) 4","solution":"def min_jumps(arr): Function to determine the minimum number of jumps required to reach the end of the array. Parameters: arr (list): List of integers where each element represents the maximum steps you can move from that position. Returns: int: Minimum number of jumps required to reach the end of the array. if len(arr) <= 1: return 0 if arr[0] == 0: return float('inf') # initializing variables max_reach = arr[0] step = arr[0] jump = 1 for i in range(1, len(arr)): if i == len(arr) - 1: return jump max_reach = max(max_reach, i + arr[i]) step -= 1 if step == 0: jump += 1 if i >= max_reach: return float('inf') step = max_reach - i return jump"},{"question":"def longest_substring_with_k_modifications(s: str, k: int) -> int: Computes the length of the longest substring where all characters are the same after performing at most 'k' character modifications. Parameters: s (str): Input string of lowercase English letters. k (int): Maximum number of character modifications allowed. Returns: int: Length of the longest possible substring. >>> longest_substring_with_k_modifications(\\"aabccbb\\", 1) 3 >>> longest_substring_with_k_modifications(\\"abbcb\\", 1) 4 >>> longest_substring_with_k_modifications(\\"abccde\\", 1) 3","solution":"def longest_substring_with_k_modifications(s, k): Computes the length of the longest substring where all characters are the same after performing at most 'k' character modifications. Parameters: s (str): Input string of lowercase English letters. k (int): Maximum number of character modifications allowed. Returns: int: Length of the longest possible substring. max_length = 0 max_count = 0 start = 0 char_count = {} for end in range(len(s)): char_end = s[end] char_count[char_end] = char_count.get(char_end, 0) + 1 max_count = max(max_count, char_count[char_end]) while (end - start + 1) - max_count > k: char_start = s[start] char_count[char_start] -= 1 start += 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"def min_coins_to_collect(N, C, K, coin_values): Determine the minimum number of coins needed to collect exactly C coins, given the constraints of the beggar's capacity and the ability to double the value of the coins he has. Args: N (int): The number of distinct coin types. C (int): The exact number of coins the beggar wants to collect. K (int): The maximum number of coins the beggar can carry at a time. coin_values (list of int): List containing the value of each type of coin. Returns: int: The minimum number of coins required to achieve exactly C coins, or -1 if it's not possible. Examples: >>> min_coins_to_collect(4, 12, 3, [1, 5, 7, 10]) 2 >>> min_coins_to_collect(3, 20, 2, [8, 3, 6]) -1 pass","solution":"def min_coins_to_collect(N, C, K, coin_values): # Dynamic programming approach to solve the problem. dp = [float('inf')] * (C + 1) # Initialize with infinity dp[0] = 0 # 0 coins needed to make sum 0 for coin in coin_values: for x in range(coin, C + 1): dp[x] = min(dp[x], dp[x - coin] + 1) # Now check if the solution meets the maximum K coins at a time constraint min_coins = dp[C] if dp[C] != float('inf') else -1 if min_coins <= K: return min_coins else: return -1 # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) C = int(data[1]) K = int(data[2]) coin_values = list(map(int, data[3:])) print(min_coins_to_collect(N, C, K, coin_values))"},{"question":"def maximize_sequence_value(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Given a sequence of n integers, perform the operation of adding 1 to the largest integer k times and return the maximum value in the sequence for each test case. t : int : number of test cases test_cases : List[Tuple[int, int, List[int]]] : list of test cases where each test case is a tuple containing n (size of the sequence), k (number of operations), and the sequence as a list of integers Returns a list of integers where each integer is the maximum value in the sequence after performing k operations. >>> maximize_sequence_value(3, [(5, 3, [1, 2, 4, 5, 3]), (4, 7, [4, 4, 4, 4]), (3, 2, [10, 1, 10])]) [8, 11, 12] >>> maximize_sequence_value(1, [(3, 5, [1, 2, 3])]) [8] >>> maximize_sequence_value(1, [(3, 0, [1, 2, 3])]) [3] >>> maximize_sequence_value(2, [(3, 3, [0, 0, 0]), (5, 5, [0, 0, 0, 0, 0])]) [3, 5] >>> maximize_sequence_value(1, [(3, 100000, [10**9, 10**9, 10**9])]) [1000100000] >>> maximize_sequence_value(1, [(100000, 100000, [i for i in range(100000)])]) [199999]","solution":"def maximize_sequence_value(t, test_cases): results = [] for case in test_cases: n, k, a = case max_value = max(a) results.append(max_value + k) return results"},{"question":"def all_unique(numbers: List[int]) -> bool: Returns True if all numbers in the list are unique, otherwise False. >>> all_unique([]) True >>> all_unique([1]) True >>> all_unique([1, 2, 3]) True >>> all_unique([1, 2, 2]) False >>> all_unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) True >>> all_unique([-1, -2, -3, -4, -5]) True >>> all_unique([-1, 1, 2, -2, 3, -3]) True >>> all_unique([-1, 1, 2, -2, 2, -3]) False","solution":"def all_unique(numbers): Returns True if all numbers in the list are unique, otherwise False. return len(numbers) == len(set(numbers))"},{"question":"from typing import List def generate_permutations(s: str) -> List[str]: Returns all permutations of the given string s in lexicographically sorted order. >>> generate_permutations(\\"a\\") [\\"a\\"] >>> generate_permutations(\\"ab\\") [\\"ab\\", \\"ba\\"] >>> generate_permutations(\\"abc\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> generate_permutations(\\"abdc\\") ['abcd', 'abdc', 'acbd', 'acdb', 'adbc', 'adcb', 'bacd', 'badc', 'bcad', 'bcda', 'bdac', 'bdca', 'cabd', 'cadb', 'cbad', 'cbda', 'cdab', 'cdba', 'dabc', 'dacb', 'dbac', 'dbca', 'dcab', 'dcba'] >>> generate_permutations(\\"bca\\") [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] >>> generate_permutations(\\"abcdefgh\\") # returns list of permutations starting with \\"abcdefgh\\" and ending with \\"hgfedcba\\"","solution":"from itertools import permutations def generate_permutations(s): Returns all permutations of the given string s in lexicographically sorted order. perms = sorted([''.join(p) for p in permutations(s)]) return perms"},{"question":"def factorial(N: int) -> int: Given an integer N, return the factorial of N. Parameters: N (int): The number to calculate the factorial of. Must be between 0 and 20 inclusive. Returns: int: The factorial of N. Example: >>> factorial(5) 120 >>> factorial(0) 1","solution":"def factorial(N): Returns the factorial of N. Parameters: N (int): The number to calculate the factorial of. Must be between 0 and 20 inclusive. Returns: int: The factorial of N. if N == 0: return 1 result = 1 for i in range(1, N + 1): result *= i return result"},{"question":"from typing import List, Tuple def max_square_plots(t: int, dimensions: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Given dimensions of Farmer John's field, compute the largest side length of square plots and the number of such plots for each test case. >>> max_square_plots(2, [(15, 10), (12, 16)]) [(5, 6), (4, 12)] >>> max_square_plots(1, [(9, 6)]) [(3, 6)] >>> max_square_plots(1, [(8, 8)]) [(8, 1)] >>> max_square_plots(1, [(7, 11)]) [(1, 77)] >>> max_square_plots(1, [(10000, 5000)]) [(5000, 2)]","solution":"from math import gcd def max_square_plots(t, dimensions): results = [] for i in range(t): L, W = dimensions[i] side_length = gcd(L, W) num_plots = (L // side_length) * (W // side_length) results.append((side_length, num_plots)) return results"},{"question":"def min_distance(A: str, B: str) -> int: Compute the minimum number of operations required to transform string A into string B. Operations allowed are insertion, deletion, and replacement. >>> min_distance(\\"horse\\", \\"ros\\") 3 >>> min_distance(\\"intention\\", \\"execution\\") 5 >>> min_distance(\\"abc\\", \\"abc\\") 0 pass def min_operations_to_transform(T: int, cases: List[Tuple[str, str]]) -> List[int]: Given number of test cases and each pair of strings A, B, returns minimum number of operations required to transform A into B. >>> min_operations_to_transform(3, [(\\"horse\\", \\"ros\\"), (\\"intention\\", \\"execution\\"), (\\"abc\\", \\"abc\\")]) [3, 5, 0] >>> min_operations_to_transform(1, [(\\"\\", \\"\\")]) [0] >>> min_operations_to_transform(1, [(\\"abc\\", \\"\\")]) [3] >>> min_operations_to_transform(1, [(\\"\\", \\"abc\\")]) [3] pass","solution":"def min_distance(A, B): Compute the minimum number of operations required to transform string A into string B. Operations allowed are insertion, deletion, and replacement. len_A = len(A) len_B = len(B) # Create a (len_A+1) x (len_B+1) 2D array to store results of subproblems dp = [[0] * (len_B + 1) for _ in range(len_A + 1)] for i in range(len_A + 1): for j in range(len_B + 1): # If A is empty, then we need to insert all characters of B if i == 0: dp[i][j] = j # If B is empty, then we need to remove all characters of A elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif A[i-1] == B[j-1]: dp[i][j] = dp[i-1][j-1] # If last character are different, consider all possibilities # and find the minimum else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[len_A][len_B] def min_operations_to_transform(T, cases): Given number of test cases and each pair of strings A, B, returns minimum number of operations required to transform A into B. results = [] for A, B in cases: result = min_distance(A, B) results.append(result) return results"},{"question":"def remove_character(s: str, char: str) -> str: Returns the string s with all instances of char removed. Handles both uppercase and lowercase characters appropriately. >>> remove_character(\\"hello\\", \\"h\\") \\"ello\\" >>> remove_character(\\"bubble\\", \\"b\\") \\"ule\\" >>> remove_character(\\"Hello\\", \\"h\\") \\"ello\\" >>> remove_character(\\"world\\", \\"a\\") \\"world\\" >>> remove_character(\\"\\", \\"a\\") \\"\\" >>> remove_character(\\"AAA\\", \\"a\\") \\"\\"","solution":"def remove_character(s, char): Returns the string s with all instances of char removed. Handles both uppercase and lowercase characters appropriately. return s.replace(char, '').replace(char.upper(), '').replace(char.lower(), '')"},{"question":"def min_operations_to_synchronize(n: int, A: List[int], B: List[int]) -> int: Determines the minimum number of operations required for Jane to synchronize her collection with Mark's. Parameters: n (int): Number of stones in each collection. A (list of int): Sizes of the stones in Mark's collection. B (list of int): Sizes of the stones in Jane's collection. Returns: int: Minimum number of operations required. >>> min_operations_to_synchronize(3, [3, 5, 7], [4, 6, 8]) 3 >>> min_operations_to_synchronize(4, [1, 2, 3, 4], [1, 2, 3, 4]) 0 >>> min_operations_to_synchronize(2, [10, 20], [5, 25]) 10 >>> min_operations_to_synchronize(1, [100], [1]) 99 >>> min_operations_to_synchronize(5, [10, 20, 30, 40, 50], [15, 25, 35, 45, 55]) 25 >>> min_operations_to_synchronize(3, [1, 2, 3], [1, 2, 3]) 0 >>> min_operations_to_synchronize(1, [10], [15]) 5 >>> min_operations_to_synchronize(5, [1, 2, 3, 4, 5], [2, 4, 6, 8, 10]) 15","solution":"def min_operations_to_synchronize(n, A, B): Determines the minimum number of operations required for Jane to synchronize her collection with Mark's. Parameters: n (int): Number of stones in each collection. A (list of int): Sizes of the stones in Mark's collection. B (list of int): Sizes of the stones in Jane's collection. Returns: int: Minimum number of operations required. return sum(abs(A[i] - B[i]) for i in range(n))"},{"question":"def min_bridges_to_cross(n: int, m: int, bridges: List[Tuple[int, int]]) -> int: This function calculates the minimum number of bridges Peter needs to cross to visit all islands in a connected graph. Parameters: n (int): Number of islands m (int): Number of bridges bridges (list of tuples): List of pairs (u, v) representing bridges connecting islands u and v Returns: int: Minimum number of bridges Peter has to cross >>> min_bridges_to_cross(5, 5, [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5)]) 4 >>> min_bridges_to_cross(2, 1, [(1, 2)]) 1 >>> min_bridges_to_cross(3, 2, [(1, 2), (2, 3)]) 2 >>> min_bridges_to_cross(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> min_bridges_to_cross(6, 9, [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4), (4, 5), (5, 6), (1, 6), (3, 6)]) 5","solution":"def min_bridges_to_cross(n, m, bridges): This function calculates the minimum number of bridges Peter needs to cross to visit all islands in a connected graph. Parameters: n (int): Number of islands m (int): Number of bridges bridges (list of tuples): List of pairs (u, v) representing bridges connecting islands u and v Returns: int: Minimum number of bridges Peter has to cross # In a connected graph, in order to visit all nodes, the minimum number of edges # to cross is always equal to n - 1. return n - 1"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): Check if the binary tree is symmetric around its center. >>> tree1 = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))) >>> isSymmetric(tree1) True >>> tree2 = TreeNode(1, TreeNode(2, None, TreeNode(3)), TreeNode(2, None, TreeNode(3))) >>> isSymmetric(tree2) False","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSymmetric(root): def isMirror(tree1, tree2): if tree1 is None and tree2 is None: return True if tree1 is None or tree2 is None: return False return (tree1.val == tree2.val) and isMirror(tree1.right, tree2.left) and isMirror(tree1.left, tree2.right) if root is None: return True return isMirror(root.left, root.right)"},{"question":"def remove_duplicate_words(sentence: str) -> str: Nina loves string manipulation and is working on a problem related to finding unique words from a given sentence. A word is defined as a sequence of non-space characters. Write a program to help Nina by removing duplicate words while preserving the order of their first appearance in the sentence. Input: A single line containing a sentence (can include alphabets, numbers, and special characters). Output: A single line with unique words from the input sentence, maintaining their first occurrence order. >>> remove_duplicate_words(\\"I love to code and I love to learn\\") == \\"I love to code and learn\\" >>> remove_duplicate_words(\\"hello world hello universe world\\") == \\"hello world universe\\" >>> remove_duplicate_words(\\"this is a test this is only a test\\") == \\"this is a test only\\" >>> remove_duplicate_words(\\"python is fun fun is python\\") == \\"python is fun\\" >>> remove_duplicate_words(\\"repeat repeat repeat\\") == \\"repeat\\" >>> remove_duplicate_words(\\"\\") == \\"\\" >>> remove_duplicate_words(\\"1 2 3 1 2 3 4 5 6\\") == \\"1 2 3 4 5 6\\" >>> remove_duplicate_words(\\"123 456 123 789\\") == \\"123 456 789\\" >>> remove_duplicate_words(\\"hello! how are you? hello! I'm fine.\\") == \\"hello! how are you? I'm fine.\\" >>> remove_duplicate_words(\\"&*() &*() #%^ #%^\\") == \\"&*() #%^\\"","solution":"def remove_duplicate_words(sentence): Removes duplicate words from the sentence while maintaining their first occurrence order. words = sentence.split() seen = set() result = [] for word in words: if word not in seen: seen.add(word) result.append(word) return ' '.join(result)"},{"question":"def solution(input_text: str) -> str: Determines if it is possible to rearrange the grid such that no two adjacent cells contain the same value for each test case in the input. >>> solution(\\"2n3 3n010n101n010n3 3n000n111n000\\") \\"YESnNO\\" >>> solution(\\"1n2 2n01n10\\") \\"YES\\" >>> solution(\\"1n2 2n00n11\\") \\"NO\\"","solution":"def is_possible_to_rearrange(grid): n = len(grid) m = len(grid[0]) # Generate the checkerboard pattern grids for comparison checkerboard_1 = [[(i + j) % 2 for j in range(m)] for i in range(n)] checkerboard_2 = [[(i + j + 1) % 2 for j in range(m)] for i in range(n)] def is_matching(grid, pattern): for i in range(n): for j in range(m): if int(grid[i][j]) != pattern[i][j]: return False return True if is_matching(grid, checkerboard_1) or is_matching(grid, checkerboard_2): return \\"YES\\" else: return \\"NO\\" def possible_rearrangement(test_cases): results = [] for grid in test_cases: results.append(is_possible_to_rearrange(grid)) return results def parser(input_text): lines = input_text.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n, m = map(int, lines[index].split()) grid = [lines[index + i + 1] for i in range(n)] test_cases.append(grid) index += n + 1 return test_cases def solution(input_text): test_cases = parser(input_text) results = possible_rearrangement(test_cases) return \\"n\\".join(results)"},{"question":"def sum_metrics_within_range(logs, queries): Calculates the sum of metrics within a given time range for each query. Parameters: logs (List[Tuple[int, int]]): List of tuples where each tuple contains a timestamp and a metric value. queries (List[Tuple[int, int]]): List of tuples where each tuple contains a start time and end time for the query. Returns: List[int]: List of sums of metrics for each query. Example: >>> logs = [(1, 5), (2, 3), (4, 7), (6, 2), (9, 1)] >>> queries = [(1, 5), (2, 6), (6, 9)] >>> sum_metrics_within_range(logs, queries) [15, 12, 3]","solution":"def sum_metrics_within_range(logs, queries): Calculates the sum of metrics within a given time range for each query. Parameters: logs (List[Tuple[int, int]]): List of tuples where each tuple contains a timestamp and a metric value. queries (List[Tuple[int, int]]): List of tuples where each tuple contains a start time and end time for the query. Returns: List[int]: List of sums of metrics for each query. # Sort logs based on timestamp for efficient access logs.sort() results = [] for t_start, t_end in queries: total_sum = 0 for t, v in logs: if t_start <= t <= t_end: total_sum += v results.append(total_sum) return results"},{"question":"def check_alarms_overlap(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Check if there is any overlap between any two alarm times for multiple test cases. >>> check_alarms_overlap(3, [(3, [5, 10, 5]), (4, [6, 9, 21, 9]), (2, [15, 22])]) [\\"Overlap\\", \\"Overlap\\", \\"No Overlap\\"] >>> check_alarms_overlap(2, [(2, [1, 1]), (3, [2, 3, 4])]) [\\"Overlap\\", \\"No Overlap\\"] >>> check_alarms_overlap(1, [(1, [8])]) [\\"No Overlap\\"] >>> check_alarms_overlap(2, [(4, [1, 2, 3, 4]), (4, [0, 0, 0, 0])]) [\\"No Overlap\\", \\"Overlap\\"] >>> check_alarms_overlap(1, [(5, [23, 22, 21, 20, 19])]) [\\"No Overlap\\"] pass","solution":"def check_alarms_overlap(T, test_cases): results = [] for i in range(T): n, alarms = test_cases[i] if len(set(alarms)) != len(alarms): results.append(\\"Overlap\\") else: results.append(\\"No Overlap\\") return results"},{"question":"def squared_sorted_array(n, a): Given a list of n integers, return the list of squares of these integers in non-decreasing order. def format_output(squared_array): Formats the output list to a single string with space-separated values. def test_squared_sorted_array(): # Test cases with expected results assert squared_sorted_array(4, [-1, 2, 3, -4]) == [1, 4, 9, 16] assert squared_sorted_array(5, [-3, -2, -1, 0, 1]) == [0, 1, 1, 4, 9] assert squared_sorted_array(3, [3, -2, -1]) == [1, 4, 9] assert squared_sorted_array(6, [-10, -5, 0, 5, 3, 2]) == [0, 4, 9, 25, 25, 100] def test_format_output(): assert format_output([1, 4, 9, 16]) == \\"1 4 9 16\\" assert format_output([0, 1, 1, 4, 9]) == \\"0 1 1 4 9\\" assert format_output([1, 4, 9]) == \\"1 4 9\\" assert format_output([0, 4, 9, 25, 25, 100]) == \\"0 4 9 25 25 100\\"","solution":"def squared_sorted_array(n, a): Given a list of n integers, return the list of squares of these integers in non-decreasing order. squared_array = [x ** 2 for x in a] squared_array.sort() return squared_array def format_output(squared_array): Formats the output list to a single string with space-separated values. return ' '.join(map(str, squared_array))"},{"question":"def longestPalindrome(s: str) -> int: Find the length of the longest substring that can be rearranged to form a palindrome. Examples: >>> longestPalindrome(\\"abccccdd\\") 7 >>> longestPalindrome(\\"a\\") 1 >>> longestPalindrome(\\"abc\\") 1","solution":"def longestPalindrome(s: str) -> int: Find the length of the longest substring that can be rearranged to form a palindrome. from collections import Counter count = Counter(s) length = 0 odd_found = False for freq in count.values(): if freq % 2 == 0: length += freq else: length += freq - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def is_subsequence_sum_possible(n: int, x: int, arr: List[int]) -> str: Determines if there is a subsequence of the list \`arr\` with \`n\` elements that sums up to \`x\`. Parameters: n (int): The number of elements in the list. x (int): The target sum. arr (list): The list of integers. Returns: str: 'YES' if there exists such a subsequence, 'NO' otherwise. Examples: >>> is_subsequence_sum_possible(5, 10, [1, 2, 3, 4, 5]) == 'YES' >>> is_subsequence_sum_possible(4, 8, [1, 1, 1, 1]) == 'NO'","solution":"def is_subsequence_sum_possible(n, x, arr): Determines if there is a subsequence of the list \`arr\` with \`n\` elements that sums up to \`x\`. Parameters: n (int): The number of elements in the list. x (int): The target sum. arr (list): The list of integers. Returns: str: 'YES' if there exists such a subsequence, 'NO' otherwise. # We'll use a dynamic programming approach to solve this problem. # Initialized dp array with False dp = [False] * (x + 1) dp[0] = True for num in arr: # Updating dp array from back to avoid using the same element multiple times for j in range(x, num - 1, -1): if dp[j - num]: dp[j] = True return 'YES' if dp[x] else 'NO'"},{"question":"import math from functools import reduce def max_identical_gift_boxes(n: int, quantities: List[int]) -> int: Calculate the maximum number of identical gift boxes that can be created given the quantities of different types of items. >>> max_identical_gift_boxes(3, [6, 9, 12]) 3 >>> max_identical_gift_boxes(2, [15, 25]) 5 >>> max_identical_gift_boxes(4, [8, 10, 14, 20]) 2 pass","solution":"import math from functools import reduce def max_identical_gift_boxes(n, quantities): Returns the maximum number of identical gift boxes that can be created from the given quantities of different types of items. def gcd(x, y): while y: x, y = y, x % y return x return reduce(gcd, quantities) # Example usage: # n = 3 # quantities = [6, 9, 12] # print(max_identical_gift_boxes(n, quantities)) # Output: 3"},{"question":"def calculate_total_sales(transactions): Calculates the total number of sales for each unique item and sorts them alphabetically. Parameters: transactions (list of tuples): A list of (item_name, quantity) tuples. Returns: list of tuples: A sorted list of (item_name, total_quantity) tuples. >>> calculate_total_sales([(\\"apple\\", 4)]) [(\\"apple\\", 4)] >>> calculate_total_sales([(\\"apple\\", 4), (\\"apple\\", 2), (\\"apple\\", 5)]) [(\\"apple\\", 11)] >>> calculate_total_sales([(\\"apple\\", 4), (\\"banana\\", 3), (\\"apple\\", 2), (\\"orange\\", 7), (\\"banana\\", 1), (\\"apple\\", 5)]) [(\\"apple\\", 11), (\\"banana\\", 4), (\\"orange\\", 7)] >>> calculate_total_sales([(\\"orange\\", 7), (\\"apple\\", 4), (\\"banana\\", 3), (\\"apple\\", 2), (\\"banana\\", 1), (\\"apple\\", 5)]) [(\\"apple\\", 11), (\\"banana\\", 4), (\\"orange\\", 7)] >>> calculate_total_sales([]) []","solution":"def calculate_total_sales(transactions): Calculates the total number of sales for each unique item and sorts them alphabetically. Parameters: transactions (list of tuples): A list of (item_name, quantity) tuples. Returns: list of tuples: A sorted list of (item_name, total_quantity) tuples. sales_dict = {} for item, quantity in transactions: if item in sales_dict: sales_dict[item] += int(quantity) else: sales_dict[item] = int(quantity) sorted_sales = sorted(sales_dict.items()) return sorted_sales"},{"question":"def rotateMatrix(matrix): Rotates the matrix 90 degrees clockwise in-place. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotateMatrix(matrix) >>> print(matrix) [[7, 4, 1], [8, 5, 2], [9, 6, 3]]","solution":"def rotateMatrix(matrix): Rotates the matrix 90 degrees clockwise in-place. # Transpose the matrix for i in range(len(matrix)): for j in range(i+1, len(matrix[0])): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for row in matrix: row.reverse()"},{"question":"def longest_distinct_subsequence(t, test_cases): This function returns the maximum length of a subsequence with all distinct integers for each test case. Parameters: t (int): Number of test cases test_cases (list): List of test cases where each test case is a tuple containing the integer n followed by a list of n integers Returns: list: A list of integers where each integer represents the maximum length of a distinct subsequence for the corresponding test case >>> longest_distinct_subsequence(3, [ ... (5, [1, 2, 3, 4, 5]), ... (6, [1, 2, 2, 3, 3, 4]), ... (7, [4, 4, 4, 4, 4, 4, 4]) ... ]) == [5, 4, 1] >>> longest_distinct_subsequence(2, [ ... (1, [1]), ... (1, [1000]) ... ]) == [1, 1]","solution":"def longest_distinct_subsequence(t, test_cases): This function returns the maximum length of a subsequence with all distinct integers for each test case. Parameters: t (int): Number of test cases test_cases (list): List of test cases where each test case is a tuple containing the integer n followed by a list of n integers Returns: list: A list of integers where each integer represents the maximum length of a distinct subsequence for the corresponding test case results = [] for case in test_cases: n, numbers = case distinct_numbers = set(numbers) results.append(len(distinct_numbers)) return results"},{"question":"def longest_contiguous_subarray(t: int, test_cases: list) -> list: Determine the length of the longest contiguous subarray where the difference between the maximum and minimum values does not exceed a given integer d. Args: t (int): The number of test cases. test_cases (list): A list of tuples where each tuple contains: - a tuple (n, d) with the length of the array and the allowed maximum difference - a list of integers representing the array elements Returns: list: A list of integers representing the length of the longest contiguous subarray for each test case","solution":"def longest_contiguous_subarray(t, test_cases): results = [] for i in range(t): n, d = test_cases[i][0] arr = test_cases[i][1] max_len = 0 start = 0 for end in range(n): current_max = max(arr[start:end+1]) current_min = min(arr[start:end+1]) while current_max - current_min > d: start += 1 current_max = max(arr[start:end+1]) current_min = min(arr[start:end+1]) max_len = max(max_len, end - start + 1) results.append(max_len) return results"},{"question":"def lexicographically_smallest_rotation(S: str) -> str: Given a string S, this function finds and returns the lexicographically smallest string obtainable by any number of right circular rotations. >>> lexicographically_smallest_rotation(\\"abcd\\") \\"abcd\\" >>> lexicographically_smallest_rotation(\\"cba\\") \\"acb\\" def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[str]: This function processes multiple test cases and returns the lexicographically smallest rotation for each string. >>> process_test_cases([(4, \\"abcd\\"), (3, \\"cba\\")]) [\\"abcd\\", \\"acb\\"]","solution":"def lexicographically_smallest_rotation(S): Given a string S, this function finds and returns the lexicographically smallest string obtainable by any number of right circular rotations. # Generate all rotations and find the smallest one N = len(S) smallest = S for i in range(1, N): rotated = S[-i:] + S[:-i] if rotated < smallest: smallest = rotated return smallest def process_test_cases(test_cases): results = [] for N, S in test_cases: results.append(lexicographically_smallest_rotation(S)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression containing +, -, *, / operators and nested parentheses. The evaluation follows standard operator precedence and truncates decimal values. >>> evaluate_expression(\\"3 + 5 * 2\\") == 13 >>> evaluate_expression(\\"(1 + 2) * 4 - 3\\") == 9 >>> evaluate_expression(\\"10 / (3 - 3 + 1)\\") == 10 pass def main(input_lines: List[str]) -> List[int]: The main function processes multiple arithmetic expressions, each on a separate line, evaluates them and returns the results as a list. >>> main([\\"3 + 5 * 2\\", \\"(1 + 2) * 4 - 3\\", \\"10 / (3 - 3 + 1)\\", \\"end\\"]) == [13, 9, 10] pass","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression containing +, -, *, / operators and nested parentheses. The evaluation follows standard operator precedence and truncates decimal values. try: # Evaluating the expression using Python's eval function result = eval(expression, {\\"__builtins__\\": None}) # Truncating decimal values to get integer result return int(result) except ZeroDivisionError: return \\"Division by zero error\\" except: return \\"Invalid expression\\" def main(input_lines): results = [] for line in input_lines: line = line.strip() if line == \\"end\\": break result = evaluate_expression(line) results.append(result) return results"},{"question":"from typing import List def can_rearrange_substring(s1: str, s2: str) -> str: Determines if s2 can be formed by rearranging the letters of a substring of s1. Args: s1 : str : the original string s2 : str : the string to be formed by rearranging the letters Returns: str : \\"YES\\" if s2 can be formed, otherwise \\"NO\\" Examples: >>> can_rearrange_substring(\\"abcbac\\", \\"abc\\") \\"YES\\" >>> can_rearrange_substring(\\"abcdef\\", \\"fedcba\\") \\"YES\\" >>> can_rearrange_substring(\\"abcde\\", \\"xyz\\") \\"NO\\" >>> can_rearrange_substring(\\"aabbaabb\\", \\"aab\\") \\"YES\\" >>> can_rearrange_substring(\\"abcd\\", \\"dcbaefg\\") \\"NO\\"","solution":"from collections import Counter def can_rearrange_substring(s1, s2): Determines if s2 can be formed by rearranging the letters of a substring of s1. Args: s1 : str : the original string s2 : str : the string to be formed by rearranging the letters Returns: str : \\"YES\\" if s2 can be formed, otherwise \\"NO\\" len_s1 = len(s1) len_s2 = len(s2) if len_s2 > len_s1: return \\"NO\\" s2_counter = Counter(s2) for i in range(len_s1 - len_s2 + 1): substring_counter = Counter(s1[i:i+len_s2]) if substring_counter == s2_counter: return \\"YES\\" return \\"NO\\""},{"question":"import keyword def is_valid_variable_name(variable_name: str) -> bool: Checks if the input string is a valid variable name in Python. A valid variable name in Python: - Can only contain letters (a-z, A-Z), digits (0-9), and underscores (_). - Must start with a letter (a-z, A-Z) or an underscore (_). - Cannot be a reserved keyword in Python. >>> is_valid_variable_name(\\"my_variable\\") == True >>> is_valid_variable_name(\\"2cool4school\\") == False >>> is_valid_variable_name(\\"for\\") == False >","solution":"import keyword def is_valid_variable_name(variable_name: str) -> bool: Checks if the input string is a valid variable name in Python. if not variable_name: return False if variable_name[0].isdigit(): return False if variable_name in keyword.kwlist: return False if not all(char.isalnum() or char == '_' for char in variable_name): return False return True"},{"question":"def find_minimum_new_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Calculates the minimum number of new roads required to connect all towns and Baryburg. :param n: Number of towns :param m: Number of existing roads :param roads: List of tuples representing the existing roads :return: Minimum number of new roads required >>> find_minimum_new_roads(4, 2, [(1, 2), (3, 4)]) 1 >>> find_minimum_new_roads(4, 0, []) 3 >>> find_minimum_new_roads(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> find_minimum_new_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_minimum_new_roads(4, 3, [(1, 2), (2, 3), (3, 4)]) 0 >>> find_minimum_new_roads(8, 5, [(1, 2), (3, 4), (5, 6), (7, 8), (1, 3)]) 2","solution":"def find_minimum_new_roads(n, m, roads): Calculates the minimum number of new roads required to connect all towns and Baryburg. :param n: Number of towns :param m: Number of existing roads :param roads: List of tuples representing the existing roads :return: Minimum number of new roads required from collections import defaultdict, deque # Initialize the adjacency list for the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Function to perform BFS and find all connected components def bfs(start, visited): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # We have n towns numbered from 1 to n visited = [False] * (n + 1) num_components = 0 # Counting the number of connected components for i in range(1, n + 1): if not visited[i]: bfs(i, visited) num_components += 1 # The number of new roads needed to connect all components is (number_of_components - 1) return num_components - 1"},{"question":"def distinct_characters_in_substrings(S: str, ranges: List[Tuple[int, int]]) -> List[int]: Returns a list containing the number of distinct characters in the substring S[l..r] for each (l, r) in ranges. >>> distinct_characters_in_substrings(\\"abacabadab\\", [(0, 3), (1, 4), (2, 7)]) [3, 3, 4] >>> distinct_characters_in_substrings(\\"aaaaa\\", [(0, 0), (1, 1), (4, 4)]) [1, 1, 1]","solution":"def distinct_characters_in_substrings(S, ranges): Returns a list containing the number of distinct characters in the substring S[l..r] for each (l, r) in ranges. Parameters: S (str): The input string. ranges (list of tuples): A list of (l, r) pairs representing index ranges. Returns: list: A list of integers representing the number of distinct characters in each substring S[l..r]. results = [] for (l, r) in ranges: substring = S[l:r+1] # extract substring S[l..r] distinct_characters = set(substring) # get distinct characters results.append(len(distinct_characters)) # count of distinct characters return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate the given mathematical expression and return the result as an integer. The input string contains non-negative integers and the operators +, -, *, /, ^, and parentheses. The caret symbol (^) represents exponentiation with lower precedence. >>> evaluate_expression(\\"3 + 2 * (2 - 1)\\") 5 >>> evaluate_expression(\\"10 + 2 * 6\\") 22 >>> evaluate_expression(\\"100 * (2 + 12) / 14\\") 100 >>> evaluate_expression(\\"7 + (6 * 5^2 + 3)\\") 160","solution":"def evaluate_expression(expression): Evaluate the given mathematical expression and return the result as an integer. def precedence(op): if op == '+' or op == '-': return 1 if op == '*' or op == '/': return 2 if op == '^': return 3 return 0 def apply_op(operands, operator): right = operands.pop() left = operands.pop() if operator == '+': operands.append(left + right) elif operator == '-': operands.append(left - right) elif operator == '*': operands.append(left * right) elif operator == '/': operands.append(left // right) elif operator == '^': operands.append(left ** right) def evaluate(tokens): operands = [] operators = [] i = 0 while i < len(tokens): if tokens[i] == ' ': i += 1 continue elif tokens[i] == '(': operators.append(tokens[i]) elif tokens[i].isdigit(): val = 0 while (i < len(tokens) and tokens[i].isdigit()): val = (val * 10) + int(tokens[i]) i += 1 operands.append(val) i -= 1 elif tokens[i] == ')': while len(operators) != 0 and operators[-1] != '(': apply_op(operands, operators.pop()) operators.pop() else: while (len(operators) != 0 and precedence(operators[-1]) >= precedence(tokens[i])): apply_op(operands, operators.pop()) operators.append(tokens[i]) i += 1 while len(operators) != 0: apply_op(operands, operators.pop()) return operands[-1] return evaluate(expression)"},{"question":"from typing import List def shortest_knight_path(n: int, sx: int, sy: int, tx: int, ty: int, grid: List[str]) -> int: Find the shortest path for the knight to move from (sx, sy) to (tx, ty). >>> shortest_knight_path(3, 0, 0, 2, 2, ['K..', '...', '...']) 4 >>> shortest_knight_path(3, 0, 0, 1, 1, ['K..', '...', '...']) -1 >>> shortest_knight_path(8, 0, 0, 7, 7, ['K.......', '........', '........', '........', '........', '........', '........', '........']) 6 >>> shortest_knight_path(4, 0, 0, 0, 0, ['K...', '....', '....', '....']) 0 >>> shortest_knight_path(3, 0, 0, 1, 2, ['K..', '...', '...']) 1","solution":"from collections import deque def shortest_knight_path(n, sx, sy, tx, ty, grid): # Possible moves for a knight in chess moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)] # Initialize the queue for BFS queue = deque([(sx, sy, 0)]) visited = set() visited.add((sx, sy)) # Perform BFS while queue: x, y, dist = queue.popleft() # If the target is reached if (x, y) == (tx, ty): return dist # Explore all possible knight moves for dx, dy in moves: nx, ny = x + dx, y + dy # Check if the move is within bounds and not visited if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If no path found, return -1 return -1"},{"question":"def subset_sum_exists(n, x, multiset): Determines if there exists a non-empty subset of the multiset that sums to x. >>> subset_sum_exists(5, 9, [2, 2, 3, 5, 3]) 'YES' >>> subset_sum_exists(3, 12, [1, 2, 4]) 'NO'","solution":"def subset_sum_exists(n, x, multiset): Determines if there exists a non-empty subset of the multiset that sums to x. # Initialize a DP table to keep track of possible sums dp = [False] * (x + 1) dp[0] = True # There is always an empty subset with sum 0 for num in multiset: for s in range(x, num - 1, -1): if dp[s - num]: dp[s] = True return \\"YES\\" if dp[x] else \\"NO\\" # Example usage if __name__ == \\"__main__\\": n, x = map(int, input().split()) multiset = list(map(int, input().split())) print(subset_sum_exists(n, x, multiset))"},{"question":"def is_subset_sum(nums, target_sum): Determine if there is a subset of the given set with a sum equal to the given sum. >>> is_subset_sum([3, 34, 4, 12, 5, 2], 9) True >>> is_subset_sum([3, 34, 4, 12, 5, 2], 30) False >>> is_subset_sum([], 0) True >>> is_subset_sum([10], 10) True >>> is_subset_sum([10], 5) False >>> is_subset_sum([3, 0, 4, 12, 5, 2], 9) True >>> is_subset_sum([0, 0, 0, 0], 0) True >>> is_subset_sum([100, 200, 300, 400, 500], 800) True >>> is_subset_sum([-1, 1, 2, -2, 3], 0) True","solution":"def is_subset_sum(nums, target_sum): Determine if there is a subset of nums with a sum equal to target_sum. n = len(nums) # Initialize a 2D list to store the solutions to subproblems dp = [[False] * (target_sum + 1) for _ in range(n + 1)] # If the target sum is 0, then a subset exists (empty subset) for i in range(n + 1): dp[i][0] = True # Fill the dp table in a bottom-up manner for i in range(1, n + 1): for j in range(1, target_sum + 1): if nums[i - 1] > j: dp[i][j] = dp[i - 1][j] else: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]] return dp[n][target_sum]"},{"question":"def increment_even_numbers(nums): Increments each even integer in the list by 1, leaving odd integers unchanged. :param nums: List of integers :return: New list with even integers incremented by 1 >>> increment_even_numbers([1, 2, 3, 4, 5]) [1, 3, 3, 5, 5] >>> increment_even_numbers([2, 4, 6]) [3, 5, 7] >>> increment_even_numbers([1, 3, 5]) [1, 3, 5] >>> increment_even_numbers([]) [] >>> increment_even_numbers([100, 101, 102]) [101, 101, 103]","solution":"def increment_even_numbers(nums): Increments each even integer in the list by 1, leaving odd integers unchanged. :param nums: List of integers :return: New list with even integers incremented by 1 return [num + 1 if num % 2 == 0 else num for num in nums]"},{"question":"def has_pair_with_sum(n, arr, target): Determines if there exists a pair of distinct indices i and j such that the sum of elements arr[i] and arr[j] equals the target value. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. target (int): The target sum. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". >>> has_pair_with_sum(5, [1, 2, 3, 9, 11], 14) 'Yes' >>> has_pair_with_sum(5, [1, 2, 3, 9, 11], 15) 'No' >>> has_pair_with_sum(2, [1, 4], 5) 'Yes' >>> has_pair_with_sum(2, [1, 4], 6) 'No' >>> has_pair_with_sum(4, [-5, -10, -15, -20], -25) 'Yes' >>> has_pair_with_sum(4, [-1, 5, 3, 2], 4) 'Yes' >>> has_pair_with_sum(100000, list(range(100000)), 200001) 'No' >>> has_pair_with_sum(100000, list(range(100000)) + [1000000], 1000001) 'Yes'","solution":"def has_pair_with_sum(n, arr, target): Determines if there exists a pair of distinct indices i and j such that the sum of elements arr[i] and arr[j] equals the target value. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. target (int): The target sum. Returns: str: \\"Yes\\" if such a pair exists, otherwise \\"No\\". seen = set() for num in arr: complement = target - num if complement in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def minimum_total_difference(M, skill_levels): Calculate the minimum total difference in skill levels across all teams. Parameters: M (int): The number of players. skill_levels (list of int): The list of skill levels of players. Returns: int: The minimum total difference in skill levels across all teams. >>> minimum_total_difference(5, [10, 20, 30, 40, 50]) 10 >>> minimum_total_difference(4, [1, 3, 5, 7]) 4 >>> minimum_total_difference(4, [5, 5, 5, 5]) 0 >>> minimum_total_difference(1, [100]) 0 >>> minimum_total_difference(2, [10, 20]) 10","solution":"def minimum_total_difference(M, skill_levels): Calculate the minimum total difference in skill levels across all teams. Parameters: M (int): The number of players. skill_levels (list of int): The list of skill levels of players. Returns: int: The minimum total difference in skill levels across all teams. skill_levels.sort() total_difference = 0 for i in range(0, M - 1, 2): total_difference += abs(skill_levels[i] - skill_levels[i + 1]) return total_difference"},{"question":"def calculate_new_time(H, M, N): Calculates the new time after adding N minutes to the current time H:M in Wonderland. >>> calculate_new_time(10, 30, 40) (11, 10) >>> calculate_new_time(0, 15, 60) (1, 15) >>> calculate_new_time(11, 50, 15) (0, 5) # Your implementation here def process_test_cases(test_cases): Processes a list of test cases to determine the new times after adding the given minutes. >>> process_test_cases([(10, 30, 40), (0, 15, 60), (11, 50, 15)]) [(11, 10), (1, 15), (0, 5)] # Your implementation here","solution":"def calculate_new_time(H, M, N): Calculates the new time after adding N minutes to the current time H:M in Wonderland. total_minutes = H * 60 + M + N new_hour = (total_minutes // 60) % 12 new_minute = total_minutes % 60 return new_hour, new_minute def process_test_cases(test_cases): results = [] for H, M, N in test_cases: results.append(calculate_new_time(H, M, N)) return results"},{"question":"def min_shelves_required(test_cases): Returns a list with the minimum number of shelves required for each test case. Args: test_cases: List of tuples where each tuple contains two integers, N and C. Returns: List of integers representing the minimum number of shelves required for each test case. >>> min_shelves_required([(10, 4), (50, 10), (7, 3)]) [3, 5, 3] >>> min_shelves_required([(8, 4), (100, 50), (30, 10)]) [2, 2, 3] >>> min_shelves_required([(1, 1)]) [1] >>> min_shelves_required([(1000000, 1)]) [1000000] >>> min_shelves_required([(0, 10)]) [0]","solution":"def min_shelves_required(test_cases): Returns a list with the minimum number of shelves required for each test case. Args: test_cases: List of tuples where each tuple contains two integers, N and C. Returns: List of integers representing the minimum number of shelves required for each test case. result = [] for N, C in test_cases: shelves_needed = (N + C - 1) // C # This gives the ceiling of N / C result.append(shelves_needed) return result"},{"question":"def min_operations_to_make_array_beautiful(n: int, a: List[int]) -> int: This function returns the minimum number of operations required to make the array beautiful. An array is beautiful if there is at least one even number that is greater than or equal to every other element in the array. >>> min_operations_to_make_array_beautiful(4, [3, 5, 7, 8]) == 0 >>> min_operations_to_make_array_beautiful(5, [1, 3, 9, 7, 5]) == 1 >>> min_operations_to_make_array_beautiful(5, [1, 3, 5, 7, 9]) == 1 >>> min_operations_to_make_array_beautiful(5, [2, 4, 6, 8, 10]) == 0 >>> min_operations_to_make_array_beautiful(6, [1, 2, 3, 4, 5, 6]) == 0 >>> min_operations_to_make_array_beautiful(3, [1, 1, 1]) == 1 >>> min_operations_to_make_array_beautiful(2, [999999937, 999999937]) == 1","solution":"def min_operations_to_make_array_beautiful(n, a): This function returns the minimum number of operations required to make the array beautiful. An array is beautiful if there is at least one even number that is greater than or equal to every other element in the array. max_element = max(a) for i in range(n): if a[i] % 2 == 0 and a[i] >= max_element: return 0 min_operations = float('inf') for i in range(n): if a[i] % 2 != 0: operations = 0 current = a[i] while current <= max_element: current *= 2 operations += 1 min_operations = min(min_operations, operations) return min_operations"},{"question":"def find_palindromes(words: str) -> set: Returns a set of palindromes in the given string. Parameters: words (str): A string of words separated by spaces. Returns: set: A set of palindrome words in the order they appeared. Examples: >>> find_palindromes(\\"madam racecar apple level noon\\") {\\"madam\\", \\"racecar\\", \\"level\\", \\"noon\\"} >>> find_palindromes(\\"hello world example\\") set() >>> find_palindromes(\\"wow anna civic\\") {\\"wow\\", \\"anna\\", \\"civic\\"}","solution":"def find_palindromes(words): Returns a set of palindromes in the given string. Parameters: words (str): A string of words separated by spaces. Returns: set: A set of palindrome words in the order they appeared. word_list = words.split() palindrome_set = {word for word in word_list if word == word[::-1]} return palindrome_set"},{"question":"def check_overlapping_tasks(tasks): Checks if there are any overlapping tasks within the project. Parameters: tasks (list of tuples): A list of tuples where each tuple contains two integers, the start and end time of a task. Returns: bool: True if there are overlapping tasks, False otherwise. Examples: >>> check_overlapping_tasks([(1, 5), (5, 8), (8, 12)]) False >>> check_overlapping_tasks([(2, 6), (1, 3), (5, 8)]) True >>> check_overlapping_tasks([(0, 2), (3, 5), (7, 9), (1, 4)]) True","solution":"def check_overlapping_tasks(tasks): Checks if there are any overlapping tasks within the project. Parameters: tasks (list of tuples): A list of tuples where each tuple contains two integers, the start and end time of a task. Returns: bool: True if there are overlapping tasks, False otherwise. # Sort tasks by start time tasks.sort() # Check for overlapping tasks for i in range(1, len(tasks)): if tasks[i][0] < tasks[i-1][1]: return True return False"},{"question":"def has_pair_with_sum(arr, target): Determines if there exist two distinct elements in arr that sum up to target. Args: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True","solution":"def has_pair_with_sum(arr, target): Determines if there exist two distinct elements in arr that sum up to target. Args: arr (list of int): The list of integers. target (int): The target sum. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if (target - num) in seen: return True seen.add(num) return False"},{"question":"def group_by_first_char(strings): Groups strings by their first character. :param strings: List of strings :return: Dictionary with first characters as keys and lists of strings as values >>> group_by_first_char([\\"apple\\", \\"apricot\\", \\"banana\\", \\"blueberry\\", \\"cherry\\", \\"cantaloupe\\"]) {'a': ['apple', 'apricot'], 'b': ['banana', 'blueberry'], 'c': ['cherry', 'cantaloupe']} >>> group_by_first_char([\\"dog\\", \\"cat\\", \\"deer\\", \\"camel\\", \\"dingo\\"]) {'d': ['dog', 'deer', 'dingo'], 'c': ['cat', 'camel']} >>> group_by_first_char([]) {} >>> group_by_first_char([\\"Aardvark\\", \\"apple\\", \\"apricot\\", \\"Banana\\", \\"blueberry\\", \\"Cherry\\", \\"cherry\\"]) {'A': ['Aardvark'], 'a': ['apple', 'apricot'], 'B': ['Banana'], 'b': ['blueberry'], 'C': ['Cherry'], 'c': ['cherry']}","solution":"def group_by_first_char(strings): Groups strings by their first character. :param strings: List of strings :return: Dictionary with first characters as keys and lists of strings as values result = {} for string in strings: first_char = string[0] if first_char not in result: result[first_char] = [] result[first_char].append(string) return result"},{"question":"def can_permute_palindrome(s: str) -> bool: Returns whether any permutation of the string can form a palindrome. Ignores spaces and considers only alphanumeric characters. >>> can_permute_palindrome(\\"aabb\\") == True >>> can_permute_palindrome(\\"abba\\") == True >>> can_permute_palindrome(\\"aabbc\\") == True >>> can_permute_palindrome(\\"ababc\\") == True >>> can_permute_palindrome(\\"aabc\\") == False >>> can_permute_palindrome(\\"abcde\\") == False >>> can_permute_palindrome(\\"\\") == True >>> can_permute_palindrome(\\"a\\") == True >>> can_permute_palindrome(\\"A man, a plan, a canal, Panama!\\") == True","solution":"def can_permute_palindrome(s): Returns whether any permutation of the string can form a palindrome. Ignores spaces and considers only alphanumeric characters. from collections import Counter # Filtering only alphanumeric characters and converting to lowercase filtered_chars = [c.lower() for c in s if c.isalnum()] # Counting the occurrences of each character char_count = Counter(filtered_chars) # Counting how many characters have odd occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For a permutation to be a palindrome, at most one character can have an odd count return odd_count <= 1"},{"question":"from typing import List def prime_factors(n: int) -> List[int]: Given a positive integer n, find its prime factorization. The prime factorization of an integer is a product of prime numbers that, when multiplied together, yield the original integer n. Parameters: n (int): The input integer to be factorized. Returns: List[int]: A list of prime factors in ascending order. Example: >>> prime_factors(315) [3, 3, 5, 7] >>> prime_factors(60) [2, 2, 3, 5] >>> prime_factors(9973) [9973] pass # Implement the function here # Unit Tests def test_prime_factors_basic(): assert prime_factors(315) == [3, 3, 5, 7] def test_prime_factors_small_prime(): assert prime_factors(7) == [7] def test_prime_factors_composite(): assert prime_factors(60) == [2, 2, 3, 5] def test_prime_factors_large_prime(): assert prime_factors(9973) == [9973] def test_prime_factors_power(): assert prime_factors(256) == [2, 2, 2, 2, 2, 2, 2, 2] # 2^8 def test_prime_factors_mixed(): assert prime_factors(5040) == [2, 2, 2, 2, 3, 3, 5, 7] def test_prime_factors_one(): assert prime_factors(1) == [] def test_prime_factors_large_composite(): assert prime_factors(1000000) == [2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5]","solution":"from typing import List def prime_factors(n: int) -> List[int]: Returns a list of prime factors of a given positive integer n in ascending order. factors = [] # Check for number of 2s that divide n while n % 2 == 0: factors.append(2) n = n // 2 # n must be odd at this point so we can skip even numbers for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: factors.append(i) n = n // i # This condition is to mention if n is a prime number # greater than 2 if n > 2: factors.append(n) return factors"},{"question":"def max_non_adjacent_sum(arr): Returns the maximum sum of a non-empty subsequence such that no two elements are adjacent in the original list. >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([-1, -2, -3, -4]) -1 >>> max_non_adjacent_sum([5]) 5 >>> max_non_adjacent_sum([-5]) -5 >>> max_non_adjacent_sum([5, 10]) 10 >>> max_non_adjacent_sum([-5, -10]) -5 >>> max_non_adjacent_sum([10, -1, 10, -1, 10]) 30 >>> max_non_adjacent_sum([-1, 10, -1, 10, -1]) 20 >>> max_non_adjacent_sum([10, 1] * 50000) 500000 >>> max_non_adjacent_sum([-1, -1] * 50000) -1","solution":"def max_non_adjacent_sum(arr): Returns the maximum sum of a non-empty subsequence such that no two elements are adjacent in the original list. if not arr: return 0 n = len(arr) # Special case for a single element if n == 1: return arr[0] # dp[i] represents the maximum sum we can obtain considering the first i+1 elements dp = [0] * n dp[0] = arr[0] dp[1] = max(arr[0], arr[1]) for i in range(2, n): dp[i] = max(dp[i-1], arr[i] + dp[i-2]) return dp[-1]"},{"question":"def rearrange_books(bookshelves): Rearranges books on bookshelves to ensure each row and column are sorted in increasing order. Parameters: bookshelves (list): A list of tuples, each containing (M, N, books). M is the number of rows, N is the number of columns, and books is a list of lists representing the heights of books. Returns: result (list): A list of the rearranged bookshelves. pass def parse_input(input_str): Parse input string to extract bookshelves information. Parameters: input_str (str): The input string containing the bookshelf data. Returns: bookshelves (list): A list of bookshelf data. pass def format_output(rearranged_bookshelves): Format the rearranged bookshelves for output. Parameters: rearranged_bookshelves (list): A list of the rearranged books. Returns: output_str (str): The formatted output string. pass def main(input_str): bookshelves = parse_input(input_str) rearranged_bookshelves = rearrange_books(bookshelves) return format_output(rearranged_bookshelves) if __name__ == \\"__main__\\": input_str = 2 3 3 2 1 6 5 4 0 0 print(main(input_str))","solution":"def rearrange_books(bookshelves): Rearranges books on bookshelves to ensure each row and column are sorted in increasing order. Parameters: bookshelves (list): A list of tuples, each containing (M, N, books). M is the number of rows, N is the number of columns, and books is a list of lists representing the heights of books. Returns: result (list): A list of the rearranged bookshelves. result = [] for M, N, books in bookshelves: # Flatten the bookshelf into a single list and sort it flattened_books = [book for row in books for book in row] flattened_books.sort() # Create the rearranged bookshelf in row-major order rearranged_shelf = [] for i in range(M): row = flattened_books[i * N:(i + 1) * N] rearranged_shelf.append(row) result.append(rearranged_shelf) return result def parse_input(input_str): Parse input string to extract bookshelves information. Parameters: input_str (str): The input string containing the bookshelf data. Returns: bookshelves (list): A list of bookshelf data. lines = input_str.strip().split(\\"n\\") bookshelves = [] i = 0 while i < len(lines): M, N = map(int, lines[i].split()) if M == 0 and N == 0: break i += 1 books = [] for _ in range(M): books.append(list(map(int, lines[i].split()))) i += 1 bookshelves.append((M, N, books)) return bookshelves def format_output(rearranged_bookshelves): Format the rearranged bookshelves for output. Parameters: rearranged_bookshelves (list): A list of the rearranged books. Returns: output_str (str): The formatted output string. result_lines = [] for shelf in rearranged_bookshelves: for row in shelf: result_lines.append(\\" \\".join(map(str, row))) return \\"n\\".join(result_lines) def main(input_str): bookshelves = parse_input(input_str) rearranged_bookshelves = rearrange_books(bookshelves) return format_output(rearranged_bookshelves)"},{"question":"def max_path_sum(grid: List[List[int]]) -> int: Determine the maximum sum of any path from the top-left corner to the bottom-right corner of the grid, where you can only move right or down at each step. If the input is not a grid or if the grid contains non-positive integers, return None. >>> max_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 12 >>> max_path_sum([[5]]) == 5 >>> max_path_sum(\\"not a grid\\") == None >>> max_path_sum(123) == None >>> max_path_sum([[1, -1, 1], [1, 5, 1], [4, 2, 1]]) == None >>> max_path_sum([[1, 10, 3, 8], [12, 2, 9, 6], [5, 7, 4, 11], [3, 7, 16, 5]]) == 53 >>> max_path_sum([[1, 2, 3, 4]]) == 10 >>> max_path_sum([[1], [2], [3], [4]]) == 10","solution":"def is_valid_grid(grid): if not isinstance(grid, list): return False for row in grid: if not isinstance(row, list): return False for cell in row: if not isinstance(cell, int) or cell <= 0: return False return True def max_path_sum(grid): if not is_valid_grid(grid): return None m, n = len(grid), len(grid[0]) # Create a 2D dp array with the same size as the grid dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]"},{"question":"def number_of_packages(n: int) -> int: Given an integer n (1 ≤ n ≤ 10^5), the number of items a customer purchases (including the free item(s)), determine the number of packages needed to follow the packing rule that the number of items in any two packages should not differ by more than 1. :param n: int :return: int >>> number_of_packages(1) 1 >>> number_of_packages(3) 1 >>> number_of_packages(7) 1 >>> number_of_packages(8) 2","solution":"def number_of_packages(n): Given an integer n (1 ≤ n ≤ 10^5), the number of items a customer purchases (including the free item(s)), determines the number of packages needed to follow the packing rule that the number of items in any two packages should not differ by more than 1. :param n: int :return: int # If n <= 7, they can be packed in one package if n <= 7: return 1 # If n is a multiple of 8, we can divide it into packages of 4 items each if n % 8 == 0: return 2 # Otherwise, we need to carefully split the items # We try to fit as many items into packages not differing by more than one item # Starting with a size 4, since 7 can be packed in one package, 8 packs into 2, over 8 will be the concern return 2"},{"question":"from typing import List def min_invitations(N: int, M: int, groups: List[List[int]]) -> int: Returns the minimal number of invitations required so that at least one person from each group attends the party. >>> min_invitations(5, 3, [[0, 1], [1, 2, 3], [3, 4]]) == 2 >>> min_invitations(5, 1, [[0, 1, 2, 3, 4]]) == 1 >>> min_invitations(5, 3, [[0], [1], [2]]) == 3 >>> min_invitations(4, 2, [[0, 1, 2, 3], [0, 1, 2, 3]]) == 1 >>> min_invitations(3, 3, [[0], [1], [2]]) == 3","solution":"def min_invitations(N, M, groups): Returns the minimal number of invitations required so that at least one person from each group attends the party. from itertools import combinations # Create a list of all individuals individuals = list(range(N)) # Iterate through all possible combinations of invitations (from size 1 to N) for r in range(1, N + 1): for comb in combinations(individuals, r): invited_set = set(comb) if all(any(member in invited_set for member in group) for group in groups): return r return N"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: You are given a directed graph with \`n\` vertices and \`m\` edges. Each edge has a weight which is a positive integer. You need to find the shortest paths from a given source vertex to all other vertices using Dijkstra's algorithm. Args: n (int): The number of vertices in the graph. edges (List[Tuple[int, int, int]]): A list of edges where each edge is represented as a tuple (u, v, w) indicating there is an edge from vertex u to vertex v with weight w. s (int): The source vertex from which shortest paths need to be calculated. Returns: List[int]: A list of shortest distances from the source vertex to each vertex. If there is no path to a vertex, return -1 for that vertex. Example: >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 4, 3), (4, 5, 1)], 1) [0, 2, 3, 6, 7] >>> dijkstra(5, [(1, 2, 2), (2, 3, 1)], 1) [0, 2, 3, -1, -1]","solution":"import heapq def dijkstra(n, edges, s): graph = [[] for _ in range(n)] for u, v, w in edges: graph[u-1].append((v-1, w)) distances = [float('inf')] * n distances[s-1] = 0 priority_queue = [(0, s-1)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return [d if d != float('inf') else -1 for d in distances]"},{"question":"from typing import List def can_become_palindrome(s: str) -> str: Determine if a binary string can be transformed into a palindrome by reversing any number of substrings of length 3. >>> can_become_palindrome(\\"101\\") \\"YES\\" >>> can_become_palindrome(\\"1110\\") \\"NO\\" >>> can_become_palindrome(\\"1100\\") \\"NO\\" >>> can_become_palindrome(\\"000\\") \\"YES\\" >>> can_become_palindrome(\\"101010\\") \\"YES\\" pass # Your implementation here def process_input(test_cases: List[str]) -> List[str]: Process multiple test cases and determine if each binary string can be made into a palindrome. >>> process_input([\\"101\\", \\"1110\\", \\"1100\\", \\"000\\", \\"101010\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\"] >>> process_input([\\"1\\", \\"01\\"]) [\\"YES\\", \\"NO\\"] pass # Your implementation here","solution":"def can_become_palindrome(s): n = len(s) # Helper function to determine if the suffix can balance the additional mismatches from prefix def check_palindrome_with_operations(s): mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatches += 1 # During these operations if our mismatch count allows for operations # in multiples of 3 then it can be solvable else not. # Also, if mismatches count is zero then already palindrome. return mismatches == 0 or (mismatches * 2) % 3 == 0 return \\"YES\\" if check_palindrome_with_operations(s) else \\"NO\\" def process_input(test_cases): results = [] for s in test_cases: results.append(can_become_palindrome(s)) return results"},{"question":"def merge_sorted_arrays(arr1, arr2): This function merges two sorted arrays into one sorted array without using built-in sort functions. >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6, 8]) [1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_arrays([0, 4, 10], [1, 5, 11]) [0, 1, 4, 5, 10, 11] >>> merge_sorted_arrays([], [1, 2, 3]) [1, 2, 3] >>> merge_sorted_arrays([1, 2, 3], []) [1, 2, 3] >>> merge_sorted_arrays([], []) [] >>> merge_sorted_arrays([1], [2]) [1, 2] >>> merge_sorted_arrays([2], [1]) [1, 2]","solution":"def merge_sorted_arrays(arr1, arr2): This function merges two sorted arrays into one sorted array without using built-in sort functions. merged_array = [] i = 0 j = 0 # Iterate over both arrays and append the smaller element to the merged_array while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements in arr1 (if any) while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Append remaining elements in arr2 (if any) while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def max_power(n, stones, k): Given the number of stones, their power levels, and the maximum allowable power level, returns the maximum power level achievable by combining stones under the constraints. Parameters: n (int): Number of stones. stones (list of int): The power levels of the stones. k (int): The maximum allowable power level for the resulting stone. Returns: int: The maximum power level achievable that does not exceed k. Example: >>> max_power(5, [2, 1, 3, 4, 1], 5) 5 >>> max_power(3, [10, 5, 20], 25) 20 # Your code here","solution":"def max_power(n, stones, k): Given the number of stones, their power levels, and the maximum allowable power level, returns the maximum power level achievable by combining stones under the constraints. max_power_level = 0 current_sum = 0 for stone in stones: if current_sum + stone <= k: current_sum += stone else: max_power_level = max(max_power_level, current_sum) if stone <= k: current_sum = stone else: current_sum = 0 max_power_level = max(max_power_level, current_sum) return max_power_level"},{"question":"def determine_winner(T: int, test_cases: List[str]) -> List[str]: Determine the winner of a string rearrangement game. Two players, Alice and Bob, are playing a game where they take turns rearranging a given string \`S\`. The players can rearrange the characters of the string \`S\` in any way they like and then remove any one character from the string. Alice always goes first. The player who cannot make a move (i.e., when the string becomes empty) loses the game. Determine who will win the game if both players play optimally. >>> determine_winner(3, [\\"abc\\", \\"abcd\\", \\"a\\"]) ['Alice', 'Bob', 'Alice'] >>> determine_winner(2, [\\"z\\", \\"zz\\"]) ['Alice', 'Bob']","solution":"def determine_winner(T, test_cases): results = [] for S in test_cases: if len(S) % 2 == 1: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results # Example usage: # T = 3 # test_cases = [\\"abc\\", \\"abcd\\", \\"a\\"] # print(determine_winner(T, test_cases)) # Output: ['Alice', 'Bob', 'Alice']"},{"question":"def findUnique(numbers: List[int]) -> int: Returns the integer that appears exactly once in the list \`numbers\`, where every other integer appears exactly twice. >>> findUnique([4, 3, 2, 4, 1, 3, 2]) 1 >>> findUnique([-1, -1, -2, -3, -3]) -2 >>> findUnique([1000000000, 1, 2, 3, 2, 3, 1]) 1000000000 >>> findUnique([0, 1, 0, 1, 2]) 2","solution":"def findUnique(numbers): Returns the integer that appears exactly once in the list \`numbers\`, where every other integer appears exactly twice. unique = 0 for num in numbers: unique ^= num return unique"},{"question":"def product_except_self(nums): Transforms an input array of integers such that each element in the output array represents the product of all the numbers in the original array except the one at the current index. Do not use division in your solution. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([5, 3, 2, 1]) [6, 10, 15, 30] >>> product_except_self([4, 3, 2, 1, 2]) [12, 16, 24, 48, 24] >>> product_except_self([10]) [1] >>> product_except_self([3, 7]) [7, 3] pass","solution":"def product_except_self(nums): Returns a list of products where at each index the product is the result of multiplying all elements in the original array except the one at the given index. n = len(nums) # List to store the result result = [1] * n # Calculate the prefix products prefix_product = 1 for i in range(n): result[i] = prefix_product prefix_product *= nums[i] # Calculate the suffix products and multiply with corresponding prefix products suffix_product = 1 for i in range(n-1, -1, -1): result[i] *= suffix_product suffix_product *= nums[i] return result"},{"question":"from typing import List, Tuple def can_reorder(A: List[int], B: List[int], N: int) -> str: Check if it is possible to reorder array A to satisfy the given condition with array B. If B[i] is even, then A[i] should be less than or equal to B[i]; If B[i] is odd, then A[i] should be greater than or equal to B[i]. Args: A (List[int]): The array to reorder. B (List[int]): The array to compare with. N (int): The size of the arrays. Returns: str: \\"YES\\" if it is possible to reorder array A to satisfy the condition, otherwise \\"NO\\". pass def reorder_arrays(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Process multiple test cases to determine if arrays A can be reordered to satisfy conditions with arrays B. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int], List[int]]]): Each test case represented as a tuple containing the length of the arrays and the arrays A and B. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. pass import pytest def test_can_reorder_cases(): assert can_reorder([1, 2, 3, 4, 5], [5, 4, 3, 2, 1], 5) == \\"YES\\" assert can_reorder([7, 8, 9], [6, 5, 4], 3) == \\"NO\\" def test_reorder_arrays(): test_cases = [ (5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]), (3, [7, 8, 9], [6, 5, 4]) ] assert reorder_arrays(2, test_cases) == [\\"YES\\", \\"NO\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def can_reorder(A, B, N): A.sort() # Sort array A even_B = sorted([B[i] for i in range(N) if B[i] % 2 == 0]) odd_B = sorted([B[i] for i in range(N) if B[i] % 2 == 1]) even_A = [] odd_A = [] # Split A into values to match with even B and odd B for value in A: if len(even_A) < len(even_B): even_A.append(value) else: odd_A.append(value) # Verify the conditions for i in range(len(even_B)): if even_A[i] > even_B[i]: return \\"NO\\" for i in range(len(odd_B)): if odd_A[i] < odd_B[i]: return \\"NO\\" return \\"YES\\" def reorder_arrays(T, test_cases): results = [] for i in range(T): N, A, B = test_cases[i] result = can_reorder(A, B, N) results.append(result) return results"},{"question":"def rearrangeArray(arr): Rearrange the elements of arr such that all even numbers appear on the left side and all odd numbers appear on the right side. This is done in linear time and in-place. Parameters: arr (list): The list of integers to rearrange. pass from solution import rearrangeArray def is_valid_rearrangement(arr): Helper function to validate the rearrangement. The function returns True if all even numbers are on the left side and all odd numbers are on the right side. odd_started = False for num in arr: if num % 2 == 0: if odd_started: return False else: odd_started = True return True def test_rearrange_array_example1(): arr = [1, 2, 3, 4, 5, 6] rearrangeArray(arr) assert is_valid_rearrangement(arr) def test_rearrange_array_example2(): arr = [12, 17, 70, 15, 22, 65, 21, 90] rearrangeArray(arr) assert is_valid_rearrangement(arr) def test_rearrange_array_all_even(): arr = [2, 4, 6, 8, 10] rearrangeArray(arr) assert is_valid_rearrangement(arr) assert arr == [2, 4, 6, 8, 10] # Should remain the same def test_rearrange_array_all_odd(): arr = [1, 3, 5, 7, 9] rearrangeArray(arr) assert is_valid_rearrangement(arr) assert arr == [1, 3, 5, 7, 9] # Should remain the same def test_rearrange_array_mixed(): arr = [7, 3, 2, 8, 5, 4, 1, 10] rearrangeArray(arr) assert is_valid_rearrangement(arr) # One possible correct form: [2, 8, 4, 10, 5, 7, 1, 3]","solution":"def rearrangeArray(arr): Rearrange the elements of arr such that all even numbers appear on the left side and all odd numbers appear on the right side. This is done in linear time and in-place. Parameters: arr (list): The list of integers to rearrange. left = 0 # Initialize a pointer to the beginning of the array right = len(arr) - 1 # Initialize a pointer to the end of the array while left < right: if arr[left] % 2 == 0: # If the number at left pointer is even, move the pointer to right left += 1 elif arr[right] % 2 == 1: # If the number at right pointer is odd, move the pointer to left right -= 1 else: # If left is odd and right is even, swap them arr[left], arr[right] = arr[right], arr[left] left += 1 right -= 1"},{"question":"def check_return_to_hub(n: int, instructions: str) -> str: Check if the drone returns to the central hub (0, 0) after executing all instructions. Parameters: - n (int): The number of instructions. - instructions (str): A string of length n consisting of characters 'U', 'D', 'L', 'R'. Returns: - str: \\"YES\\" if the drone returns to the central hub after all instructions, otherwise \\"NO\\". >>> check_return_to_hub(4, \\"UDLR\\") == \\"YES\\" >>> check_return_to_hub(3, \\"UDD\\") == \\"NO\\"","solution":"def check_return_to_hub(n, instructions): Check if the drone returns to the central hub (0, 0) after executing all instructions. Parameters: - n (int): The number of instructions. - instructions (str): A string of length n consisting of characters 'U', 'D', 'L', 'R'. Returns: - str: \\"YES\\" if the drone returns to the central hub after all instructions, otherwise \\"NO\\". x, y = 0, 0 # Initial position at the central hub (0, 0) for instruction in instructions: if instruction == 'U': y += 1 elif instruction == 'D': y -= 1 elif instruction == 'L': x -= 1 elif instruction == 'R': x += 1 if x == 0 and y == 0: return \\"YES\\" else: return \\"NO\\" # Example usage: # result = check_return_to_hub(4, \\"UDLR\\") # print(result) # Output: \\"YES\\""},{"question":"from typing import List def find_substring_indices(S: str, L: List[str]) -> List[int]: You are given a string S and a list of words L. The goal is to find all starting indices of substrings in S that are concatenation of all the words from L exactly once without overlapping. >>> find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) [0, 9] >>> find_substring_indices(\\"abcdef\\", [\\"gh\\", \\"ij\\"]) [-1] pass # Unit Test def test_find_substring_indices(): # Test cases from prompt assert find_substring_indices(\\"barfoothefoobarman\\", [\\"foo\\", \\"bar\\"]) == [0, 9] # No valid concatenation assert find_substring_indices(\\"abcdef\\", [\\"gh\\", \\"ij\\"]) == [-1] # Words in S but not concatenated correctly assert find_substring_indices(\\"foobar\\", [\\"bar\\", \\"foo\\", \\"foo\\"]) == [-1] # All words are the same assert find_substring_indices(\\"aaa\\", [\\"a\\", \\"a\\"]) == [0, 1] # Edge case assert find_substring_indices(\\"\\", [\\"foo\\", \\"bar\\"]) == [-1] # Longer string with multiple outputs assert find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"word\\"]) == [-1] assert find_substring_indices(\\"wordgoodgoodgoodbestword\\", [\\"word\\",\\"good\\",\\"best\\",\\"good\\"]) == [8] # Single word in list assert find_substring_indices(\\"hello\\", [\\"lo\\"]) == [3] # Words with multiple starting points assert find_substring_indices(\\"lingmindraboofooowingdingbarrwingmonkeypoundcake\\", [\\"fooo\\",\\"barr\\",\\"wing\\",\\"ding\\",\\"wing\\"]) == [13] # S where concatenation is at the end assert find_substring_indices(\\"aaaaaa\\", [\\"aa\\", \\"aa\\", \\"aa\\"]) == [0] # Test edge case: Single character S, Single word in L assert find_substring_indices(\\"a\\", [\\"a\\"]) == [0] # S contains repeated sequence of L assert find_substring_indices(\\"abababab\\", [\\"ab\\", \\"ab\\", \\"ab\\", \\"ab\\"]) == [0] test_find_substring_indices()","solution":"def find_substring_indices(S, L): from collections import Counter if not S or not L or not L[0]: return [-1] word_length = len(L[0]) num_words = len(L) concatenate_length = word_length * num_words words_counter = Counter(L) result_indices = [] for i in range(word_length): left = i right = i current_counter = Counter() while right + word_length <= len(S): word = S[right:right + word_length] right += word_length if word in words_counter: current_counter[word] += 1 while current_counter[word] > words_counter[word]: left_word = S[left:left + word_length] current_counter[left_word] -= 1 left += word_length if right - left == concatenate_length: result_indices.append(left) else: current_counter.clear() left = right return result_indices if result_indices else [-1]"},{"question":"from typing import List, Dict, Union def find_highest_power_level(num_cases: int, test_cases: List[Dict[str, Union[int, List[Dict[str, Union[int, float]]]]]]) -> List[str]: Determine the highest power level of an artifact that can be created given the available items. Args: num_cases (int): The number of test cases. test_cases (List[Dict[str, Union[int, List[Dict[str, Union[int, float]]]]]]): List of test cases, where each test case contains the number of items, the list of items, the number of artifacts, and the list of artifacts. Returns: List[str]: A list of strings representing the highest power level (rounded to three decimal places) for each test case. Example: >>> find_highest_power_level(1, [{'num_items': 3, 'items': [{'id': 1, 'effect': 100}, {'id': 2, 'effect': 200}, {'id': 3, 'effect': 300}], 'num_artifacts': 3, 'artifacts': [{'items': [1, 2], 'power': 1500.45}, {'items': [2, 3], 'power': 2000.50}, {'items': [1, 3], 'power': 1800.30}]}]) [\\"2000.500\\"]","solution":"def find_highest_power_level(num_cases, test_cases): results = [] for case in test_cases: items = case['items'] artifacts = case['artifacts'] # Convert item list to dict for quick lookup item_dict = {i['id']: i['effect'] for i in items} max_power_level = 0.0 for artifact in artifacts: # Check if all items required by the artifact are available if all(item in item_dict for item in artifact['items']): max_power_level = max(max_power_level, artifact['power']) results.append(f\\"{max_power_level:.3f}\\") return results # Example usage with input data test_cases = [ { 'num_items': 3, 'items': [ {'id': 1, 'effect': 100}, {'id': 2, 'effect': 200}, {'id': 3, 'effect': 300}, ], 'num_artifacts': 3, 'artifacts': [ {'items': [1, 2], 'power': 1500.45}, {'items': [2, 3], 'power': 2000.50}, {'items': [1, 3], 'power': 1800.30}, ] } ] num_cases = 1 print(find_highest_power_level(num_cases, test_cases))"},{"question":"def longest_unique_substring(s: str) -> str: Finds the longest substring of s that does not contain any repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") == \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") == \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") == \\"wke\\" >>> longest_unique_substring(\\"abcdefg\\") == \\"abcdefg\\"","solution":"def longest_unique_substring(s): Finds the longest substring of s that does not contain any repeating characters. n = len(s) if n == 0: return \\"\\" start = max_length = 0 used_char = {} result = \\"\\" for end in range(n): if s[end] in used_char and start <= used_char[s[end]]: start = used_char[s[end]] + 1 else: if (end - start + 1) > max_length: max_length = end - start + 1 result = s[start:end+1] used_char[s[end]] = end return result"},{"question":"from typing import List def findSpecialInteger(nums: List[int]) -> int: Returns the smallest integer x such that the sum of all integers in the list except x is exactly equal to x. >> findSpecialInteger([1, 2, 3, 6]) 6 >> findSpecialInteger([1, 1, 3, 2]) -1 >> findSpecialInteger([2, 2, 2, 2, 8]) 8 >> findSpecialInteger([10]) -1 >> findSpecialInteger([1, 2, 3, 4, 5]) -1 >> findSpecialInteger([1, 1, 1, 1]) -1 >> findSpecialInteger([1] * 99999 + [99999]) 99999 >> findSpecialInteger([5, 5, 5, 5, 5]) -1 >> findSpecialInteger([4, 1, 1, 2, 4, 4]) -1","solution":"def findSpecialInteger(nums): Returns the smallest integer x such that the sum of all integers in the list except x is exactly equal to x. total_sum = sum(nums) for num in nums: if num == total_sum - num: return num return -1"},{"question":"def max_pollution_difference(n: int, pollution_levels: List[int]) -> int: Returns the maximum possible absolute difference in pollution levels. Args: n: The number of cities in the array pollution_levels: A list of integers representing the pollution levels of the cities Returns: The maximum possible absolute difference in pollution levels >>> max_pollution_difference(6, [1, 2, 3, 4, 5, 6]) == 5 >>> max_pollution_difference(4, [10, 1, 10, 1]) == 9 >>> max_pollution_difference(5, [5, 5, 5, 5, 5]) == 0","solution":"def max_pollution_difference(n, pollution_levels): Returns the maximum possible absolute difference in pollution levels. min_pollution = min(pollution_levels) max_pollution = max(pollution_levels) return max_pollution - min_pollution"},{"question":"def largest_single_fruit_subgrid(orchard): Determine the largest possible rectangular sub-grid containing only one type of fruit tree. >>> orchard = [ [\\"a\\", \\"a\\", \\"a\\", \\"b\\"], [\\"a\\", \\"a\\", \\"a\\", \\"b\\"], [\\"c\\", \\"c\\", \\"c\\", \\"c\\"] ] >>> largest_single_fruit_subgrid(orchard) [2, 3, 0, 0] >>> orchard = [ [\\"a\\", \\"b\\"], [\\"c\\", \\"d\\"] ] >>> largest_single_fruit_subgrid(orchard) [0, 0, 0, 0]","solution":"def largest_single_fruit_subgrid(orchard): rows = len(orchard) cols = len(orchard[0]) # Helper function to check if a rectangle from (r1, c1) to (r2, c2) contains only one type of fruit tree def is_uniform(r1, c1, r2, c2): fruit = orchard[r1][c1] for r in range(r1, r2 + 1): for c in range(c1, c2 + 1): if orchard[r][c] != fruit: return False return True max_area = 0 result = [0, 0, 0, 0] for r1 in range(rows): for c1 in range(cols): for r2 in range(r1 + 1, rows): for c2 in range(c1 + 1, cols): if is_uniform(r1, c1, r2, c2): length = r2 - r1 + 1 width = c2 - c1 + 1 area = length * width if area > max_area: max_area = area result = [length, width, r1, c1] return result"},{"question":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): Initializes the LRU cache with a given capacity. pass def get(self, key: int) -> int: Returns the value for the given key if it exists, otherwise returns -1. pass def set(self, key: int, value: int) -> None: Sets the value for the key if the cache has space, otherwise evict the least recently used key. pass def delete(self, key: int) -> None: Deletes the key if it exists in the cache. pass def test_lru_cache_initialization(): cache = LRUCache(2) assert cache.capacity == 2 assert len(cache.cache) == 0 def test_lru_cache_set_and_get(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) assert cache.get(1) == 1 assert cache.get(2) == 2 assert cache.get(3) == -1 def test_lru_cache_eviction(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) cache.set(3, 3) assert cache.get(1) == -1 # 1 should be evicted assert cache.get(2) == 2 assert cache.get(3) == 3 def test_lru_cache_update(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) cache.set(1, 10) # update key 1 with new value assert cache.get(1) == 10 assert cache.get(2) == 2 def test_lru_cache_delete(): cache = LRUCache(2) cache.set(1, 1) cache.set(2, 2) cache.delete(1) assert cache.get(1) == -1 assert cache.get(2) == 2 def test_lru_cache_complex_usage(): cache = LRUCache(3) cache.set(1, 10) cache.set(2, 20) cache.set(3, 30) assert cache.get(1) == 10 cache.set(4, 40) assert cache.get(2) == -1 # 2 should be evicted assert cache.get(3) == 30 assert cache.get(4) == 40 cache.delete(4) assert cache.get(4) == -1","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = OrderedDict() def get(self, key: int) -> int: if key in self.cache: value = self.cache.pop(key) # move to the front (most recently used) self.cache[key] = value return value else: return -1 def set(self, key: int, value: int) -> None: if key in self.cache: # removing the old value self.cache.pop(key) elif len(self.cache) >= self.capacity: # remove the oldest item self.cache.popitem(last=False) # insert the new item as the most recently used self.cache[key] = value def delete(self, key: int) -> None: if key in self.cache: self.cache.pop(key)"},{"question":"from typing import List def generate_palindromic_permutations(s: str) -> List[str]: Given a string S, determine if S can be rearranged into a palindrome. Return all possible palindromic arrangements in any order. If no palindromic arrangement exists, return an empty list. >>> generate_palindromic_permutations(\\"aabb\\") [\\"abba\\", \\"baab\\"] >>> generate_palindromic_permutations(\\"abc\\") [] >>> generate_palindromic_permutations(\\"racecar\\") [\\"racecar\\", \\"rcaecar\\", \\"arcecra\\", ...] # Output will contain other valid permutations","solution":"from collections import Counter from itertools import permutations def can_form_palindrome(s): Check if the input string can be rearranged into a palindrome. count = Counter(s) odd_count = sum(1 for c in count if count[c] % 2 != 0) return odd_count <= 1 def generate_palindromic_permutations(s): Return all palindromic permutations of the input string. if not can_form_palindrome(s): return [] half = [] middle = [] count = Counter(s) for char, cnt in count.items(): half.extend(char * (cnt // 2)) if cnt % 2 != 0: middle.append(char) half = ''.join(half) unique_permutations = set(permutations(half)) palindromic_permutations = [] for perm in unique_permutations: half_str = ''.join(perm) palindromic_permutations.append(half_str + ''.join(middle) + half_str[::-1]) return palindromic_permutations"},{"question":"def check_pin(pin: str) -> bool: Determine if the input string is a valid PIN. A valid PIN satisfies the following criteria: - It must consist only of numeric digits (0-9). - It must be exactly 4 or exactly 6 characters long. >>> check_pin(\\"1234\\") == True >>> check_pin(\\"123456\\") == True >>> check_pin(\\"123\\") == False >>> check_pin(\\"12345a\\") == False >>> check_pin(\\"12345 \\") == False","solution":"def check_pin(pin): Determines if the input string is a valid PIN. Parameters: pin (str): The input string to be checked. Returns: bool: True if the input string is a valid PIN, False otherwise. return pin.isdigit() and (len(pin) == 4 or len(pin) == 6)"},{"question":"def minimum_segments(n: int, m: int, heights: List[int]) -> int: Determine the minimum number of segments needed to create a path with a sum of flower heights equal to n. Args: n (int): The desired sum of the heights of the flowers in the path. m (int): The number of different types of flower seeds. heights (List[int]): List of heights corresponding to each type of flower. Returns: int: The minimum number of segments needed, or -1 if it's impossible. >>> minimum_segments(10, 3, [2, 3, 7]) 2 >>> minimum_segments(10, 3, [11, 12, 13]) -1 >>> minimum_segments(10, 1, [10]) 1 >>> minimum_segments(10, 3, [1,1,1]) 10 >>> minimum_segments(6, 2, [6, 3]) 1 >>> minimum_segments(1000000, 2, [1, 2]) 500000","solution":"def minimum_segments(n, m, heights): # Initialize a list to store the minimum segments needed for each height sum from 0 to n dp = [float('inf')] * (n + 1) dp[0] = 0 # 0 height sum needs 0 segments # Iterate over each height type for height in heights: # Update dp table for j in range(height, n + 1): if dp[j - height] != float('inf'): dp[j] = min(dp[j], dp[j - height] + 1) # If dp[n] is still infinity, it means it's not possible to achieve sum n return dp[n] if dp[n] != float('inf') else -1"},{"question":"from typing import List def sort_book_titles(titles: List[str]) -> List[str]: Sorts the book titles in alphabetical order, ignoring capitalization, but maintains the original case of each word in the titles. >>> sort_book_titles([\\"the Great Gatsby\\", \\"to Kill a Mockingbird\\", \\"Pride and Prejudice\\", \\"the Catcher in the Rye\\"]) [\\"Pride and Prejudice\\", \\"the Catcher in the Rye\\", \\"the Great Gatsby\\", \\"to Kill a Mockingbird\\"] >>> sort_book_titles([\\"THE GREAT GATSBY\\", \\"TO KILL A MOCKINGBIRD\\", \\"PRIDE AND PREJUDICE\\", \\"THE CATCHER IN THE RYE\\"]) [\\"PRIDE AND PREJUDICE\\", \\"THE CATCHER IN THE RYE\\", \\"THE GREAT GATSBY\\", \\"TO KILL A MOCKINGBIRD\\"] >>> sort_book_titles([\\"The Great Gatsby\\", \\"to Kill a Mockingbird\\", \\"pride AND prejudice\\", \\"the Catcher IN the Rye\\"]) [\\"pride AND prejudice\\", \\"the Catcher IN the Rye\\", \\"The Great Gatsby\\", \\"to Kill a Mockingbird\\"] >>> sort_book_titles([\\"The Great Gatsby\\"]) [\\"The Great Gatsby\\"] >>> sort_book_titles([]) [] >>> sort_book_titles([\\"apple Pie\\", \\"Banana Bread\\", \\"cherry tart\\", \\"Apple turnover\\"]) [\\"apple Pie\\", \\"Apple turnover\\", \\"Banana Bread\\", \\"cherry tart\\"]","solution":"from typing import List def sort_book_titles(titles: List[str]) -> List[str]: Sorts the book titles in alphabetical order, ignoring capitalization, but maintains the original case of each word in the titles. return sorted(titles, key=lambda title: title.lower())"},{"question":"def generate_spiral_matrix(n: int) -> list[list[int]]: Generate a spiral matrix of size n x n for an odd integer n. >>> generate_spiral_matrix(3) [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] >>> generate_spiral_matrix(5) [ [1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9] ] >>> generate_spiral_matrix(1) [ [1] ]","solution":"def generate_spiral_matrix(n: int) -> list[list[int]]: Generate a spiral matrix of size n x n for an odd integer n. if n % 2 == 0: raise ValueError(\\"The input must be an odd integer\\") matrix = [[0] * n for _ in range(n)] num = 1 layers = (n + 1) // 2 for layer in range(layers): # Top row for i in range(layer, n - layer): matrix[layer][i] = num num += 1 # Right column for i in range(layer + 1, n - layer): matrix[i][n - layer - 1] = num num += 1 # Bottom row for i in range(n - layer - 2, layer - 1, -1): matrix[n - layer - 1][i] = num num += 1 # Left column for i in range(n - layer - 2, layer, -1): matrix[i][layer] = num num += 1 return matrix"},{"question":"from typing import List def maximum_product_of_three(nums: List[int]) -> int: Returns the maximum product of three distinct integers from the list nums. >>> maximum_product_of_three([1, 2, 3, 4]) == 24 >>> maximum_product_of_three([-10, -10, 1, 3, 2]) == 300 >>> maximum_product_of_three([-1, -2, -3, -4]) == -6 >>> maximum_product_of_three([-4, -3, -2, -1, 60]) == 720 >>> maximum_product_of_three([1000, 1000, 1000, 1, -1000]) == 1000000000 >>> maximum_product_of_three([1, 2, 3]) == 6","solution":"def maximum_product_of_three(nums): Returns the maximum product of three distinct integers from the list nums. nums.sort() max1 = nums[-1] * nums[-2] * nums[-3] max2 = nums[0] * nums[1] * nums[-1] return max(max1, max2) if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip() nums = list(map(int, input_data.split())) print(maximum_product_of_three(nums))"},{"question":"def update_inventory(initial_inventory, supplies, sales): Computes the final inventory for each product. Args: initial_inventory (dict): Initial count of each product. supplies (list of tuples): List of supply transactions (product name, count). sales (list of tuples): List of sales transactions (product name, count). Returns: dict: Final inventory count of each product. pass def test_update_inventory_basic(): assert update_inventory( {\\"bread\\": 10, \\"milk\\": 5}, [(\\"bread\\", 5), (\\"cookie\\", 10)], [(\\"milk\\", 2), (\\"bread\\", 7)] ) == {\\"bread\\": 8, \\"milk\\": 3, \\"cookie\\": 10} def test_update_inventory_add_new_items(): assert update_inventory( {\\"apple\\": 20}, [(\\"banana\\", 10)], [(\\"apple\\", 15), (\\"banana\\", 5)] ) == {\\"apple\\": 5, \\"banana\\": 5} def test_update_inventory_empty_initial(): assert update_inventory( {}, [(\\"flour\\", 10), (\\"sugar\\", 5)], [(\\"flour\\", 5)] ) == {\\"flour\\": 5, \\"sugar\\": 5} def test_update_inventory_no_transactions(): assert update_inventory( {\\"bread\\": 10, \\"milk\\": 5}, [], [] ) == {\\"bread\\": 10, \\"milk\\": 5} def test_update_inventory_all_products_sold(): assert update_inventory( {\\"bread\\": 10}, [], [(\\"bread\\", 10)] ) == {\\"bread\\": 0} def test_update_inventory_multiple_supplies_and_sales(): assert update_inventory( {\\"bread\\": 10, \\"milk\\": 20}, [(\\"bread\\", 10), (\\"milk\\", 10), (\\"cheese\\", 15)], [(\\"bread\\", 5), (\\"milk\\", 10)] ) == {\\"bread\\": 15, \\"milk\\": 20, \\"cheese\\": 15} def test_update_inventory_negative_stock(): assert update_inventory( {\\"bread\\": 10}, [], [(\\"bread\\", 15), (\\"milk\\", 5)] ) == {\\"bread\\": -5, \\"milk\\": -5}","solution":"def update_inventory(initial_inventory, supplies, sales): Computes the final inventory for each product. Args: initial_inventory (dict): Initial count of each product. supplies (list of tuples): List of supply transactions (product name, count). sales (list of tuples): List of sales transactions (product name, count). Returns: dict: Final inventory count of each product. inventory = initial_inventory.copy() # Process supplies for product, count in supplies: if product in inventory: inventory[product] += count else: inventory[product] = count # Process sales for product, count in sales: if product in inventory: inventory[product] -= count else: inventory[product] = -count return inventory"},{"question":"def minimum_possible_total_magical_value(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: Determine the minimum possible total magical value of the bridges that can be chosen to ensure that all islands are connected. >>> minimum_possible_total_magical_value(4, 5, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> minimum_possible_total_magical_value(3, 3, [(1, 2, 2), (2, 3, 2), (1, 3, 3)]) 4 pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, bridges): result = [] i = 0 e = 0 bridges = sorted(bridges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1: u, v, w = bridges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result) def minimum_possible_total_magical_value(n, m, bridges): return kruskal(n, bridges)"},{"question":"import math def digit_sum_factorial(n: int) -> int: Computes the sum of the digits of the factorial of n. Parameters: n (int): Non-negative integer whose factorial's digit sum is to be found. Returns: int: Sum of the digits of n! >>> digit_sum_factorial(10) 27 >>> digit_sum_factorial(0) 1 >>> digit_sum_factorial(5) 3","solution":"import math def digit_sum_factorial(n): Computes the sum of the digits of the factorial of n. Parameters: n (int): Non-negative integer whose factorial's digit sum is to be found. Returns: int: Sum of the digits of n! factorial = math.factorial(n) digit_sum = sum(int(digit) for digit in str(factorial)) return digit_sum"},{"question":"def can_form_with_one_swap(s1: str, s2: str) -> str: Determine if s1 can be rearranged to form s2 using only one swap of two characters within s1. >>> can_form_with_one_swap(\\"abcd\\", \\"acbd\\") == \\"Yes\\" >>> can_form_with_one_swap(\\"abcd\\", \\"abcd\\") == \\"No\\" >>> can_form_with_one_swap(\\"abcd\\", \\"abdc\\") == \\"Yes\\" >>> can_form_with_one_swap(\\"abcd\\", \\"abcc\\") == \\"No\\"","solution":"def can_form_with_one_swap(s1, s2): if len(s1) != len(s2): return \\"No\\" differences = [] for i in range(len(s1)): if s1[i] != s2[i]: differences.append(i) if len(differences) > 2: return \\"No\\" if len(differences) == 2: i, j = differences if s1[i] == s2[j] and s1[j] == s2[i]: return \\"Yes\\" return \\"No\\" # Example usage: # print(can_form_with_one_swap(\\"abcd\\", \\"acbd\\")) # Should print 'Yes'"},{"question":"def min_sprinklers_needed(n: int, m: int, garden: List[str]) -> int: Determine the minimum number of sprinklers needed to water all the plants in the garden. >>> min_sprinklers_needed(3, 4, [\\" .*..\\", \\"..*.\\", \\"....\\"]) 2 >>> min_sprinklers_needed(5, 5, [\\" .*..*\\", \\".....\\", \\"..*..\\", \\".....\\", \\"*..*.\\"]) 3","solution":"def min_sprinklers_needed(n, m, garden): rows_with_plants = set() cols_with_plants = set() for i in range(n): for j in range(m): if garden[i][j] == '*': rows_with_plants.add(i) cols_with_plants.add(j) # We need at least the number of rows or columns with plants, # whichever is less return min(len(rows_with_plants), len(cols_with_plants))"},{"question":"def number_of_paths(n: int, m: int, grid: str) -> int: Alice is working with a grid-based game where she can move her character on a 2D grid from the top-left corner (1, 1) to the bottom-right corner (n, m). The grid has some obstacles, which she cannot pass through. Alice can only move right or down at any step. Find the number of distinct paths she can take to reach her destination. Args: n (int): Number of rows. m (int): Number of columns. grid (str): A string representing the grid with n lines each containing m characters. Returns: int: The number of distinct paths from the top-left corner to the bottom-right corner, modulo 1000000007 (10^9 + 7). If the top-left or bottom-right cell is an obstacle, return 0. Examples: >>> number_of_paths(3, 3, \\"...n.#.n...\\") 2 >>> number_of_paths(3, 3, \\"...n.#.n..#\\") 0 pass def test_example_case_1(): n, m = 3, 3 grid = \\"...n.#.n...\\" assert number_of_paths(n, m, grid) == 2 def test_example_case_2(): n, m = 3, 3 grid = \\"...n.#.n..#\\" assert number_of_paths(n, m, grid) == 0 def test_corner_case_starting_point_blocked(): n, m = 3, 3 grid = \\"#..n.#.n...\\" assert number_of_paths(n, m, grid) == 0 def test_corner_case_ending_point_blocked(): n, m = 3, 3 grid = \\"...n.#.n..#\\" assert number_of_paths(n, m, grid) == 0 def test_case_no_obstacle(): n, m = 2, 2 grid = \\"..n..\\" assert number_of_paths(n, m, grid) == 2 def test_case_single_cell_no_obstacle(): n, m = 1, 1 grid = \\".\\" assert number_of_paths(n, m, grid) == 1 def test_case_single_cell_with_obstacle(): n, m = 1, 1 grid = \\"#\\" assert number_of_paths(n, m, grid) == 0","solution":"def num_paths_with_obstacles(grid): n = len(grid) m = len(grid[0]) MOD = 1000000007 if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] def number_of_paths(n, m, grid): grid = [list(row) for row in grid.split()] return num_paths_with_obstacles(grid)"},{"question":"def find_anagram_groups(target: str, words: List[str]) -> List[List[str]]: Returns anagram groups of the target string that exist in the array of words. >>> find_anagram_groups(\\"listen\\", [\\"enlist\\", \\"google\\", \\"inlets\\", \\"banana\\", \\"silent\\"]) [[\\"enlist\\", \\"inlets\\", \\"silent\\"]] >>> find_anagram_groups(\\"aba\\", [\\"aab\\", \\"baa\\", \\"aba\\", \\"xyz\\", \\"ab\\"]) [[\\"aab\\", \\"baa\\", \\"aba\\"]]","solution":"from collections import Counter def find_anagram_groups(target, words): Returns anagram groups of the target string that exist in the array of words. target_count = Counter(target) anagram_group = [] for word in words: if Counter(word) == target_count: anagram_group.append(word) return [anagram_group] if anagram_group else []"},{"question":"def generate_leaf_pattern(n): Generate a pattern of leaf arrangement for given integer N. >>> generate_leaf_pattern(1) ['O '] >>> generate_leaf_pattern(2) [' O ', 'O O '] >>> generate_leaf_pattern(3) [' O ', ' O O ', 'O O O '] def process_test_cases(test_cases): Process multiple test cases to generate corresponding leaf patterns. >>> process_test_cases([1]) ['O '] >>> process_test_cases([2]) [' O ', 'O O '] >>> process_test_cases([1, 2, 3]) ['O ', ' O ', 'O O ', ' O ', ' O O ', 'O O O '] def main(input_lines): Main function to handle input and output for leaf arrangement pattern generation. >>> input_lines = \\"4n1n2n3n4\\" >>> main(input_lines) 'O n O nO O n O n O O nO O O n O n O O n O O O nO O O O ' >>> input_lines = \\"1n3\\" >>> main(input_lines) ' O n O O nO O O '","solution":"def generate_leaf_pattern(n): result = [] for i in range(1, n + 1): result.append(' ' * (n - i) + 'O ' * i) return result def process_test_cases(test_cases): result = [] for n in test_cases: result.extend(generate_leaf_pattern(n)) return result def main(input_lines): input_data = input_lines.strip().split() X = int(input_data[0]) test_cases = [int(input_data[i]) for i in range(1, X + 1)] output = process_test_cases(test_cases) return \\"n\\".join(output)"},{"question":"def values_greater_than_fives(numbers): Returns a list of numbers greater than 5 from the provided list. Parameters: numbers (list): A list of numbers. Returns: list: A list of numbers greater than 5. >>> values_greater_than_fives([1, 6, 3, 7, 9]) -> [6, 7, 9] >>> values_greater_than_fives([10, 2, 8, 3, 12]) -> [10, 8, 12]","solution":"def values_greater_than_fives(numbers): Returns a list of numbers greater than 5 from the provided list. Parameters: numbers (list): A list of numbers. Returns: list: A list of numbers greater than 5. return [num for num in numbers if num > 5]"},{"question":"def parse_time(time_str: str) -> int: Parse a time string in HH:MM format and return the number of minutes since midnight. >>> parse_time(\\"09:00\\") 540 >>> parse_time(\\"17:00\\") 1020 >>> parse_time(\\"12:30\\") 750 def max_non_overlapping_bookings(data: str) -> List[int]: Find the maximum number of non-overlapping bookings that can be accommodated within the operating hours of the conference room. >>> max_non_overlapping_bookings(\\"3n09:00 11:00n13:00 15:00n10:00 12:00n0\\") [2] >>> max_non_overlapping_bookings(\\"3n09:00 11:00n13:00 15:00n10:00 12:00n4n09:00 10:30n11:00 12:30n12:00 13:00n14:00 15:30n0\\") [2, 3] >>> max_non_overlapping_bookings(\\"0n0\\") [] >>> max_non_overlapping_bookings(\\"4n09:00 12:00n11:30 14:00n13:00 16:00n15:00 17:00n0\\") [2]","solution":"def parse_time(time_str): hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes def max_non_overlapping_bookings(data): lines = data.strip().split(\\"n\\") results = [] idx = 0 while idx < len(lines): n = int(lines[idx]) if n == 0: break idx += 1 bookings = [] for _ in range(n): start, end = lines[idx].split() bookings.append((parse_time(start), parse_time(end))) idx += 1 bookings.sort(key=lambda x: x[1]) # Sort by end time last_end_time = 0 count = 0 for start, end in bookings: if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def max_delivery_points(tc, test_cases): Determine the maximum number of delivery points the truck can serve in one trip. Args: tc (int): The number of test cases. test_cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): A list of test cases, where each test case is a tuple containing: - n (int): The number of delivery points. - d (int): The maximum distance the truck can travel in total. - w (int): The maximum weight of packages the truck can carry. - deliveries (List[Tuple[int, int]]): A list of tuples, each containing: - distance_i (int): The distance to the i-th delivery point. - weight_i (int): The weight of packages for that point. Returns: List[int]: A list containing the maximum number of delivery points the truck can serve for each test case. >>> max_delivery_points(2, [ (5, 300, 200, [(50, 20), (60, 30), (70, 40), (80, 50), (90, 60)]), (4, 150, 100, [(40, 25), (50, 35), (60, 45), (70, 55)]) ]) [4, 2] pass # Unit tests def test_example_case_1(): assert max_delivery_points(2, [ (5, 300, 200, [(50, 20), (60, 30), (70, 40), (80, 50), (90, 60)]), (4, 150, 100, [(40, 25), (50, 35), (60, 45), (70, 55)]) ]) == [4, 2] def test_no_deliveries(): assert max_delivery_points(1, [ (0, 300, 200, []) ]) == [0] def test_single_delivery_within_limits(): assert max_delivery_points(1, [ (1, 100, 50, [(50, 20)]) ]) == [1] def test_single_delivery_exceeds_weight(): assert max_delivery_points(1, [ (1, 100, 50, [(50, 60)]) ]) == [0] def test_single_delivery_exceeds_distance(): assert max_delivery_points(1, [ (1, 40, 50, [(50, 20)]) ]) == [0] def test_multiple_deliveries_with_all_fitting(): assert max_delivery_points(1, [ (3, 150, 100, [(50, 20), (40, 25), (60, 45)]) ]) == [3] def test_multiple_deliveries_where_only_some_fit(): assert max_delivery_points(1, [ (4, 150, 100, [(30, 20), (100, 50), (110, 80), (40, 25)]) ]) == [2]","solution":"def max_delivery_points(tc, test_cases): results = [] for test_case in test_cases: n, d, w, deliveries = test_case sorted_deliveries = sorted(deliveries, key=lambda x: (x[0], x[1])) total_distance = 0 total_weight = 0 count = 0 for distance, weight in sorted_deliveries: if total_distance + distance <= d and total_weight + weight <= w: total_distance += distance total_weight += weight count += 1 else: break results.append(count) return results # Reading input tc = 2 test_cases = [ (5, 300, 200, [(50, 20), (60, 30), (70, 40), (80, 50), (90, 60)]), (4, 150, 100, [(40, 25), (50, 35), (60, 45), (70, 55)]) ] # Invoking the function print(max_delivery_points(tc, test_cases))"},{"question":"def count_palindromic_subarrays(test_cases): Find the number of palindromic subarrays in a list of test cases. >>> count_palindromic_subarrays([(4, [1, 2, 1, 2]), (5, [1, 2, 2, 1, 3])]) [6, 7] >>> count_palindromic_subarrays([(5, [1, 1, 1, 1, 1])]) [15]","solution":"def count_palindromic_subarrays(test_cases): def is_palindrome(arr): return arr == arr[::-1] results = [] for test in test_cases: N, array = test count = 0 for i in range(N): for j in range(i + 1, N + 1): if is_palindrome(array[i:j]): count += 1 results.append(count) return results"},{"question":"def robotMove(commands: str) -> list: Given a sequence of commands, find the robot's final position in the grid after executing all commands. Parameters: commands (str): A string of commands consisting of 'U', 'D', 'L', 'R' Returns: list: A list of two integers representing the final coordinates of the robot >>> robotMove(\\"UUDDRL\\") [0, 0] >>> robotMove(\\"UUUU\\") [0, 4] >>> robotMove(\\"DDDD\\") [0, -4] >>> robotMove(\\"LLLL\\") [-4, 0] >>> robotMove(\\"RRRR\\") [4, 0] >>> robotMove(\\"\\") [0, 0]","solution":"def robotMove(commands): Returns the final coordinates of the robot after executing all commands. Parameters: commands (str): A string of commands consisting of 'U', 'D', 'L', 'R' Returns: list: A list of two integers representing the final coordinates of the robot x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return [x, y]"},{"question":"def create_decorative_panel(n: int): Creates an n x n grid such that no row or column contains three consecutive tiles of the same color. Returns the valid grid or \\"IMPOSSIBLE\\" if it's not feasible. Input: - n (3 ≤ n ≤ 50): the length of the side of the grid. Output: - A list of strings representing the grid, or \\"IMPOSSIBLE\\" if the grid cannot be created. >>> create_decorative_panel(5) ['BWBWB', 'WBWBW', 'BWBWB', 'WBWBW', 'BWBWB'] >>> create_decorative_panel(3) \\"IMPOSSIBLE\\"","solution":"def create_decorative_panel(n): Creates an n x n grid such that no row or column contains three consecutive tiles of the same color. Returns the valid grid or \\"IMPOSSIBLE\\" if it's not feasible. if n < 3: return \\"IMPOSSIBLE\\" grid = [['' for _ in range(n)] for _ in range(n)] for i in range(n): for j in range(n): if (i + j) % 2 == 0: grid[i][j] = 'B' else: grid[i][j] = 'W' return [''.join(row) for row in grid]"},{"question":"import math def smallestSquareRootCeil(X: int) -> int: Given a number X, find the smallest integer greater than or equal to the square root of X. Args: X (int): The input number Returns: int: The smallest integer greater than or equal to the square root of X Examples: >>> smallestSquareRootCeil(17) 5 >>> smallestSquareRootCeil(25) 5 from solution import smallestSquareRootCeil def test_basic_cases(): assert smallestSquareRootCeil(17) == 5 assert smallestSquareRootCeil(25) == 5 def test_small_numbers(): assert smallestSquareRootCeil(1) == 1 assert smallestSquareRootCeil(2) == 2 assert smallestSquareRootCeil(3) == 2 assert smallestSquareRootCeil(4) == 2 def test_large_numbers(): assert smallestSquareRootCeil(99999) == 317 assert smallestSquareRootCeil(100000) == 317 def test_edge_cases(): assert smallestSquareRootCeil(100000) == 317 assert smallestSquareRootCeil(1000) == 32 assert smallestSquareRootCeil(9999) == 100 assert smallestSquareRootCeil(15241383936) == 123456","solution":"import math def smallestSquareRootCeil(X): Returns the smallest integer greater than or equal to the square root of X. return math.ceil(math.sqrt(X))"},{"question":"def word_frequencies(pages): This function takes a list of pages, each containing multiple words, and counts the frequency of each word in each page, then sorts them in descending order of their frequencies. In case of a tie in frequency, words are sorted lexicographically. Parameters: pages (list of str): A list where each element is a string representing words on a page. Returns: list of list of str: A list of lists where each inner list contains the words and frequencies formatted as \\"word:frequency\\". pass def format_output(results): This function formats the results of word frequencies into the specified output format. Parameters: results (list of list of str): The word frequency list for each page. Returns: str: The formatted output string. pass from solution import word_frequencies, format_output def test_word_frequencies_single_page(): pages = [\\"hello world hello\\"] expected_output = [ [\\"hello:2\\", \\"world:1\\"] ] assert word_frequencies(pages) == expected_output def test_word_frequencies_multiple_pages(): pages = [\\"hello world hello\\", \\"code code coder\\"] expected_output = [ [\\"hello:2\\", \\"world:1\\"], [\\"code:2\\", \\"coder:1\\"] ] assert word_frequencies(pages) == expected_output def test_word_frequencies_with_tie(): pages = [\\"banana apple apple banana banana\\"] expected_output = [ [\\"banana:3\\", \\"apple:2\\"] ] assert word_frequencies(pages) == expected_output def test_format_output_single_page(): results = [[\\"hello:2\\", \\"world:1\\"]] expected_output = \\"hello:2nworld:1\\" assert format_output(results) == expected_output def test_format_output_multiple_pages(): results = [ [\\"hello:2\\", \\"world:1\\"], [\\"code:2\\", \\"coder:1\\"] ] expected_output = \\"hello:2nworld:1nncode:2ncoder:1\\" assert format_output(results) == expected_output def test_format_output_with_tie(): results = [[\\"banana:3\\", \\"apple:2\\"]] expected_output = \\"banana:3napple:2\\" assert format_output(results) == expected_output","solution":"def word_frequencies(pages): This function takes a list of pages, each containing multiple words, and counts the frequency of each word in each page, then sorts them in descending order of their frequencies. In case of a tie in frequency, words are sorted lexicographically. Parameters: pages (list of str): A list where each element is a string representing words on a page. Returns: list of list of str: A list of lists where each inner list contains the words and frequencies formatted as \\"word:frequency\\". results = [] for page in pages: words = page.split() frequency_dict = {} for word in words: if word in frequency_dict: frequency_dict[word] += 1 else: frequency_dict[word] = 1 sorted_words = sorted(frequency_dict.items(), key=lambda x: (-x[1], x[0])) page_result = [f\\"{word}:{freq}\\" for word, freq in sorted_words] results.append(page_result) return results def format_output(results): This function formats the results of word frequencies into the specified output format. Parameters: results (list of list of str): The word frequency list for each page. Returns: str: The formatted output string. output_list = [] for page_result in results: output_list.append(\\"n\\".join(page_result)) return \\"nn\\".join(output_list)"},{"question":"from typing import List def generate_parentheses(N: int) -> List[str]: Generate all combinations of N pairs of balanced parentheses. :param N: int - Number of pairs of parentheses :return: List[str] - All combinations of balanced parentheses in dictionary order >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(N): Generate all combinations of N pairs of balanced parentheses. :param N: int - Number of pairs of parentheses :return: List[str] - All combinations of balanced parentheses in dictionary order def backtrack(S=\\"\\", left=0, right=0): if len(S) == 2 * N: result.append(S) return if left < N: backtrack(S + \\"(\\", left + 1, right) if right < left: backtrack(S + \\")\\", left, right + 1) result = [] backtrack() return sorted(result)"},{"question":"def is_palindrome(s: str) -> bool: Determine if a given string is a palindrome, ignoring spaces, case, and punctuation. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") == True >>> is_palindrome(\\"race a car\\") == False >>> is_palindrome(\\"No 'x' in Nixon\\") == True >>> is_palindrome(\\"Step on no pets\\") == True","solution":"def is_palindrome(s): Determines if a given string is a palindrome, ignoring spaces, case, and punctuation. :param s: String to check :return: True if the string is a palindrome, False otherwise import re # Remove all non-alphanumeric characters and convert to lower case cleaned_s = re.sub(r'[^w]', '', s).lower() # Check if the cleaned string is equal to its reverse return cleaned_s == cleaned_s[::-1]"},{"question":"def max_histogram_area(heights): Returns the maximum area of a rectangle that can be formed with contiguous buildings. Args: heights : list[int] A list of integers representing the heights of the buildings. Returns: int The maximum area of the contiguous rectangle. pass # Test cases def test_max_histogram_area(): assert max_histogram_area([2, 1, 5, 6, 2, 3, 1]) == 10 assert max_histogram_area([2, 4]) == 4 assert max_histogram_area([1, 1, 1, 1, 1]) == 5 assert max_histogram_area([2, 1, 2, 3, 3, 1]) == 6 assert max_histogram_area([1, 2, 3, 4, 5]) == 9 assert max_histogram_area([5, 4, 3, 2, 1]) == 9 assert max_histogram_area([1]) == 1 if __name__ == \\"__main__\\": test_max_histogram_area() print(\\"All tests passed!\\")","solution":"def max_histogram_area(heights): Returns the maximum area of a rectangle that can be formed with contiguous buildings. Args: heights : list[int] A list of integers representing the heights of the buildings. Returns: int The maximum area of the contiguous rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"def two_largest(arr): Returns a new array that contains the two largest elements in descending order. If the array has fewer than two elements, return an empty array. >>> two_largest([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [9, 6] >>> two_largest([10]) == [] >>> two_largest([-1, -2, -3, -4]) == [-1, -2] >>> two_largest([-1, 8, 7, -6, 5]) == [8, 7] >>> two_largest([4, 4, 4, 4]) == [4, 4] >>> two_largest([]) == [] >>> two_largest([1, 9]) == [9, 1]","solution":"def two_largest(arr): Returns a new array that contains the two largest elements in descending order. If the array has fewer than two elements, return an empty array. if len(arr) < 2: return [] sorted_arr = sorted(arr, reverse=True) return sorted_arr[:2]"},{"question":"from typing import List, Tuple def min_distance(n: int, m: int, k: int, lane_lengths: List[int], obstacles: List[Tuple[int, int, int]]) -> int: Determine the minimum distance a car must travel in lane k to reach the eastern end, avoiding all obstacles. >>> min_distance(3, 5, 2, [100, 200, 150], [(1, 10, 30), (2, 50, 70), (3, 75, 120), (2, 60, 80), (1, 20, 40)]) 200 >>> min_distance(2, 0, 1, [100, 200], []) 100 >>> min_distance(1, 1, 1, [100], [(1, 0, 100)]) -1 >>> min_distance(1, 1, 1, [100], [(1, 10, 20)]) 100 >>> min_distance(2, 4, 2, [150, 200], [(2, 0, 50), (2, 50, 100), (2, 100, 150), (2, 150, 200)]) -1","solution":"def min_distance(n, m, k, lane_lengths, obstacles): # Process obstacles to merge overlapping or adjacent ones lanes = [[] for _ in range(n)] for x, y, z in obstacles: lanes[x - 1].append((y, z)) def merge_intervals(intervals): intervals.sort() merged = [] for interval in intervals: if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1])) return merged lanes = [merge_intervals(lane) for lane in lanes] # Calculate required distance in lane k lane_k_obstacles = lanes[k - 1] if not lane_k_obstacles: return lane_lengths[k - 1] curr_position = 0 for start, end in lane_k_obstacles: if curr_position < start: curr_position = start curr_position = end if curr_position >= lane_lengths[k - 1]: return -1 else: return lane_lengths[k - 1]"},{"question":"def longest_substring_after_k_modifications(n: int, k: int, s: str) -> int: Returns the length of the longest substring containing the same character achievable by making up to k modifications. >>> longest_substring_after_k_modifications(6, 2, \\"abaccc\\") 5 >>> longest_substring_after_k_modifications(5, 1, \\"aaaaa\\") 5 def test_longest_substring_after_k_modifications(): n1, k1, s1 = 6, 2, \\"abaccc\\" assert longest_substring_after_k_modifications(n1, k1, s1) == 5 n2, k2, s2 = 5, 1, \\"aaaaa\\" assert longest_substring_after_k_modifications(n2, k2, s2) == 5 n3, k3, s3 = 8, 3, \\"aaabbbcc\\" assert longest_substring_after_k_modifications(n3, k3, s3) == 6 n4, k4, s4 = 10, 2, \\"abcabcabcd\\" assert longest_substring_after_k_modifications(n4, k4, s4) == 4 n5, k5, s5 = 7, 3, \\"abcdefg\\" assert longest_substring_after_k_modifications(n5, k5, s5) == 4 n6, k6, s6 = 1, 0, \\"a\\" assert longest_substring_after_k_modifications(n6, k6, s6) == 1 n7, k7, s7 = 10, 5, \\"aaaaabbbbb\\" assert longest_substring_after_k_modifications(n7, k7, s7) == 10","solution":"def longest_substring_after_k_modifications(n, k, s): Returns the length of the longest substring containing the same character achievable by making up to k modifications. max_len = 0 # Initialize the maximum length of substring found for char in set(s): # Check for each character left = 0 changes = 0 # Counter for the number of changes made for right in range(n): if s[right] != char: changes += 1 while changes > k: if s[left] != char: changes -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"from typing import List, Tuple def max_increasing_subsequence_score(arr: List[int]) -> int: Find the maximum possible 'score' of any increasing subsequence in the array. >>> max_increasing_subsequence_score([3, -1, 4, -2, 5]) 12 >>> max_increasing_subsequence_score([7, 7, 7, 7]) 7 def solution(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Process multiple test cases and return the results. >>> solution(2, [ ... (5, [3, -1, 4, -2, 5]), ... (4, [7, 7, 7, 7]) ... ]) [12, 7]","solution":"def max_increasing_subsequence_score(arr): n = len(arr) dp = [0] * n for i in range(n): dp[i] = arr[i] for j in range(i): if arr[j] < arr[i]: dp[i] = max(dp[i], dp[j] + arr[i]) return max(dp) def solution(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] results.append(max_increasing_subsequence_score(arr)) return results"},{"question":"def can_travel(n: int, cities: List[int], d: int) -> str: Determines if the electric car can travel from the first city to the last city via a series of direct travels between cities. :param n: Number of cities :param cities: List of city coordinates :param d: Maximum distance the car can travel in one go :return: 'YES' if it is possible to travel from the first to the last city, otherwise 'NO' >>> can_travel(5, [0, 3, 7, 10, 14], 5) 'YES' >>> can_travel(5, [0, 3, 7, 10, 14], 2) 'NO'","solution":"def can_travel(n, cities, d): Determines if the electric car can travel from the first city to the last city via a series of direct travels between cities. :param n: Number of cities :param cities: List of city coordinates :param d: Maximum distance the car can travel in one go :return: 'YES' if it is possible to travel from the first to the last city, otherwise 'NO' for i in range(1, n): if cities[i] - cities[i - 1] > d: return 'NO' return 'YES'"},{"question":"def min_length_substring(S: str) -> int: Determine the minimum length of the substring that contains at least one occurrence of every character present in the given string S. Parameters: S (str): The input string. Returns: int: The minimum length of the substring. Examples: >>> min_length_substring(\\"abcabcbb\\") 3 >>> min_length_substring(\\"aaabbb\\") 2 # Your code here from solution import min_length_substring def test_min_length_substring_example1(): assert min_length_substring(\\"abcabcbb\\") == 3 def test_min_length_substring_example2(): assert min_length_substring(\\"aaabbb\\") == 2 def test_min_length_substring_single_char(): assert min_length_substring(\\"a\\") == 1 def test_min_length_substring_different_chars(): assert min_length_substring(\\"abcdef\\") == 6 def test_min_length_substring_repeated_chars(): assert min_length_substring(\\"aaaabbbbcccc\\") == 3","solution":"def min_length_substring(S): Determine the minimum length of the substring that contains at least one occurrence of every character present in the given string S. from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # The minimum length of such a substring is equal to the number of unique characters return len(char_count)"},{"question":"from datetime import datetime def filter_logs(logs, start_time, end_time, keyword): Filters the log entries based on the given time range and keyword. Args: logs (list of tuples): List of log entries. Each entry is a tuple (timestamp, message). start_time (str): Start timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. end_time (str): End timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. keyword (str): Keyword to search for in log messages. Returns: list of tuples: Filtered and sorted list of log entries. Example: >>> logs = [ ... (\\"2023-10-01 10:00:00\\", \\"System started\\"), ... (\\"2023-10-01 10:30:00\\", \\"User login\\"), ... (\\"2023-10-01 11:00:00\\", \\"System shut down\\"), ... (\\"2023-10-01 12:00:00\\", \\"System update\\") ... ] >>> filter_logs(logs, \\"2023-10-01 09:00:00\\", \\"2023-10-01 11:00:00\\", \\"System\\") [(\\"2023-10-01 10:00:00\\", \\"System started\\"), (\\"2023-10-01 11:00:00\\", \\"System shut down\\")]","solution":"from datetime import datetime def filter_logs(logs, start_time, end_time, keyword): Filters the log entries based on the given time range and keyword. Args: logs (list of tuples): List of log entries. Each entry is a tuple (timestamp, message). start_time (str): Start timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. end_time (str): End timestamp in \\"YYYY-MM-DD HH:MM:SS\\" format. keyword (str): Keyword to search for in log messages. Returns: list of tuples: Filtered and sorted list of log entries. start_time = datetime.strptime(start_time, \\"%Y-%m-%d %H:%M:%S\\") end_time = datetime.strptime(end_time, \\"%Y-%m-%d %H:%M:%S\\") filtered_logs = [ log for log in logs if start_time <= datetime.strptime(log[0], \\"%Y-%m-%d %H:%M:%S\\") <= end_time and keyword in log[1] ] return sorted(filtered_logs, key=lambda log: log[0])"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit that can be achieved from the given list of stock prices. A list of integers represents the stock price of a company over multiple days. Write a function to determine the maximum profit that can be made by buying on one day and selling on another later day. If no profit can be made, return 0. You may not engage in multiple transactions (i.e., you must sell before you buy again). Parameters: prices (List[int]): A list of stock prices (integers) for a number of consecutive days. Returns: int: Maximum profit possible. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([5, 4, 3, 2, 1]) 0 >>> max_profit([]) 0 >>> max_profit([1]) 0 >>> max_profit([7, 7, 7, 7, 7]) 0 >>> max_profit([7, 8, 7, 8, 7]) 1 >>> max_profit([2, 4, 1, 3, 5]) 4 >>> max_profit([100, 180, 260, 310, 40, 535, 695]) 655 >>> max_profit([90, 90, 90, 90, 90]) 0 >>> max_profit([20, 18, 17, 14, 10, 8]) 0 >>> max_profit([1, 2, 1, 2, 1, 2]) 1","solution":"def max_profit(prices): Returns the maximum profit that can be achieved from the given list of stock prices. if not prices or len(prices) < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def process_test_cases(P: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple test cases to find the length of the longest subarray where the absolute difference between any two elements is ≤ K. Args: P (int): Number of test cases test_cases (List[Tuple[int, int, List[int]]]): List of tuples, each containing (M, K, B) where M: Size of array B K: Maximum allowed difference B: List of integers representing the array Returns: List[int]: List of lengths of the longest subarray for each test case. Example: >>> process_test_cases(2, [ ... (5, 3, [1, 5, 3, 3, 2]), ... (4, 2, [10, 12, 14, 10]) ... ]) [4, 2] >>> process_test_cases(1, [(1, 1, [100])]) [1] >>> process_test_cases(1, [(5, 5, [7, 7, 7, 7, 7])]) [5] >>> process_test_cases(1, [(5, 1000000, [2, 4, 6, 8, 10])]) [5] >>> process_test_cases(1, [(4, 1, [1, 10, 20, 30])]) [1]","solution":"def longest_subarray_length(M, K, B): Returns the length of the longest subarray where the absolute difference between any two elements is ≤ K. from collections import deque # To keep track of the minimum and maximum values in the current window min_deque = deque() max_deque = deque() left = 0 max_len = 0 for right in range(M): # Update the deques while min_deque and B[min_deque[-1]] > B[right]: min_deque.pop() min_deque.append(right) while max_deque and B[max_deque[-1]] < B[right]: max_deque.pop() max_deque.append(right) # Maintain the invariant of the condition while B[max_deque[0]] - B[min_deque[0]] > K: left += 1 if min_deque[0] < left: min_deque.popleft() if max_deque[0] < left: max_deque.popleft() # Update maximum length max_len = max(max_len, right - left + 1) return max_len def process_test_cases(P, test_cases): results = [] for i in range(P): M, K, B = test_cases[i] results.append(longest_subarray_length(M, K, B)) return results"},{"question":"def generate_led_board(m: int, n: int): Generates a board of size m x n filled with LEDs in such a way that no two LEDs are adjacent. Parameters: m (int): The number of rows. n (int): The number of columns. Returns: Tuple[int, List[str]]: A tuple containing the maximum number of LEDs and the board configuration. Example: >>> max_leds, board = generate_led_board(3, 3) >>> max_leds 5 >>> board ['O.O', '.O.', 'O.O'] >>> max_leds, board = generate_led_board(4, 5) >>> max_leds 10 >>> board ['O.O.O', '.O.O.', 'O.O.O', '.O.O.'] >>> max_leds, board = generate_led_board(1, 1) >>> max_leds 1 >>> board ['O'] >>> max_leds, board = generate_led_board(2, 3) >>> max_leds 3 >>> board in [['O.O', '.O.'], ['.O.', 'O.O']] True >>> max_leds, board = generate_led_board(3, 2) >>> max_leds 3 >>> board in [['O.', '.O', 'O.'], ['.O', 'O.', '.O']] True","solution":"def generate_led_board(m, n): Generates a board of size m x n filled with LEDs in such a way that no two LEDs are adjacent. Parameters: m (int): The number of rows. n (int): The number of columns. Returns: Tuple[int, List[str]]: A tuple containing the maximum number of LEDs and the board configuration. max_leds = (m * n + 1) // 2 board = [] for i in range(m): row = [] for j in range(n): if (i + j) % 2 == 0: row.append('O') else: row.append('.') board.append(''.join(row)) return max_leds, board"},{"question":"def gcd(a, b): Helper function to compute the greatest common divisor of a and b using Euclid's algorithm. >>> gcd(12, 18) 6 >>> gcd(100, 75) 25 >>> gcd(7, 13) 1 def common_divisors_count(n, m): Returns the number of common divisors between two numbers n and m. >>> common_divisors_count(12, 18) 4 >>> common_divisors_count(100, 75) 3 >>> common_divisors_count(7, 13) 1 def solve(T, cases): Solves the problem for T test cases. Parameters: T (int): The number of test cases. cases (list of tuple): Each tuple contains two integers (N, M). Returns: list of int: The number of common divisors for each pair (N, M). >>> solve(3, [(12, 18), (100, 75), (7, 13)]) [4, 3, 1] >>> solve(1, [(1, 1)]) [1] >>> solve(2, [(3, 9), (1000000, 1000000)]) [2, 49]","solution":"def gcd(a, b): Helper function to compute the greatest common divisor of a and b using Euclid's algorithm. while b: a, b = b, a % b return a def common_divisors_count(n, m): Returns the number of common divisors between two numbers n and m. common_gcd = gcd(n, m) count = 0 for i in range(1, common_gcd + 1): if common_gcd % i == 0: count += 1 return count def solve(T, cases): Solves the problem for T test cases. Parameters: T (int): The number of test cases. cases (list of tuple): Each tuple contains two integers (N, M). Returns: list of int: The number of common divisors for each pair (N, M). results = [] for n, m in cases: results.append(common_divisors_count(n, m)) return results"},{"question":"MOD = 1000000007 def count_valid_allocations(N): Returns the number of valid allocations for N participants such that the sum of any subset of the allocated bib numbers is unique. >>> count_valid_allocations(1) 1 >>> count_valid_allocations(2) 2 >>> count_valid_allocations(3) 6 def solve(T, test_cases): Solves the problem for multiple test cases. >>> solve(3, [1, 2, 3]) [1, 2, 6] >>> solve(5, [1, 2, 3, 4, 5]) [1, 2, 6, 24, 120]","solution":"MOD = 1000000007 def count_valid_allocations(N): Returns the number of valid allocations for N participants such that the sum of any subset of the allocated bib numbers is unique. if N == 1: return 1 # Using dynamic programming or precomputed values. dp = [0] * (N+1) dp[1] = 1 for i in range(2, N+1): dp[i] = dp[i-1] * i % MOD return dp[N] def solve(T, test_cases): Solves the problem for multiple test cases. results = [] for n in test_cases: results.append(count_valid_allocations(n)) return results # Example usage: # T = 3 # test_cases = [1, 2, 3] # print(solve(T, test_cases)) # Output: [1, 2, 6]"},{"question":"def countBuildingsWithView(arr: List[int]) -> int: Returns the number of buildings that have an unobstructed view of the sunset from the left side. >>> countBuildingsWithView([7, 4, 8, 2, 9]) == 3 >>> countBuildingsWithView([4, 3, 2, 5, 2]) == 2 pass def test_example_1(): arr = [7, 4, 8, 2, 9] assert countBuildingsWithView(arr) == 3 def test_example_2(): arr = [4, 3, 2, 5, 2] assert countBuildingsWithView(arr) == 2 def test_single_building(): arr = [5] assert countBuildingsWithView(arr) == 1 def test_all_same_height(): arr = [3, 3, 3, 3, 3] assert countBuildingsWithView(arr) == 1 def test_increasing_heights(): arr = [1, 2, 3, 4, 5] assert countBuildingsWithView(arr) == 5 def test_decreasing_heights(): arr = [5, 4, 3, 2, 1] assert countBuildingsWithView(arr) == 1 def test_random_heights(): arr = [2, 2, 2, 3, 1, 4, 2] assert countBuildingsWithView(arr) == 3","solution":"def countBuildingsWithView(arr): Returns the number of buildings that have an unobstructed view of the sunset from the left side. max_height = 0 count = 0 for height in arr: if height > max_height: count += 1 max_height = height return count"},{"question":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): Builds a binary tree from a list of nodes. Each node is defined by (node_id, val, left, right) pass def max_sum_path(root: TreeNode) -> int: Finds the maximum sum of digits from the root to any leaf in the binary tree. Args: root (TreeNode): The root of the binary tree. Returns: int: The maximum sum from root to any leaf. >>> build_tree([(0, 5, 1, 2), (1, 3, 3, -1), (2, 2, -1, 4), (3, 7, -1, -1), (4, 8, -1, -1)]) 20 >>> build_tree([(0, 1, -1, -1)]) 1 >>> build_tree([(0, 1, 1, -1), (1, 2, 2, -1), (2, 3, 3, -1), (3, 4, 4, -1), (4, 5, -1, -1)]) 15 def main(): Reads input in given format and outputs the maximum sum of digits from root to any leaf in the binary tree. pass","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def build_tree(nodes): if not nodes: return None node_map = {i: TreeNode(val) for i, val, left, right in nodes} for i, val, left, right in nodes: if left != -1: node_map[i].left = node_map[left] if right != -1: node_map[i].right = node_map[right] return node_map[0] def max_sum_path(root): if not root: return 0 def dfs(node): if not node: return 0 if not node.left and not node.right: return node.val left_sum = dfs(node.left) if node.left else 0 right_sum = dfs(node.right) if node.right else 0 return node.val + max(left_sum, right_sum) return dfs(root) def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") n = int(data[0]) nodes = [] for line in data[1:]: node_id, val, left, right = map(int, line.split()) nodes.append((node_id, val, left, right)) root = build_tree(nodes) result = max_sum_path(root) print(result)"},{"question":"import math from typing import List, Tuple def min_cost_to_build_railway(n: int, m: int, coordinates_a: List[Tuple[int, int]], coordinates_b: List[Tuple[int, int]]) -> float: Calculate the minimum cost to build the railway between stations in Town A and Town B using Euclidean distance. Parameters: n (int): Number of stations in Town A. m (int): Number of stations in Town B. coordinates_a (List[Tuple[int, int]]): Coordinates of stations in Town A. coordinates_b (List[Tuple[int, int]]): Coordinates of stations in Town B. Returns: float: Minimum cost of building railway rounded to 6 decimal places. Examples: >>> min_cost_to_build_railway(3, 2, [(1, 1), (2, 2), (3, 3)], [(4, 4), (5, 5)]) 1.414214 >>> min_cost_to_build_railway(2, 2, [(0, 0), (1, 0)], [(1, 1), (2, 1)]) 1.000000","solution":"import math def min_cost_to_build_railway(n, m, coordinates_a, coordinates_b): Returns the minimum cost to build the railway between stations in Town A and B. Parameters: n (int): Number of stations in Town A. m (int): Number of stations in Town B. coordinates_a (list): List of tuples representing coordinates of stations in Town A. coordinates_b (list): List of tuples representing coordinates of stations in Town B. Returns: float: Minimum cost of building railway rounded to 6 decimal places. min_distance = float('inf') for (x1, y1) in coordinates_a: for (x2, y2) in coordinates_b: distance = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) if distance < min_distance: min_distance = distance return round(min_distance, 6)"},{"question":"def is_cyclic_rotation(s1: str, s2: str) -> str: Determines if s2 is a cyclic rotation of s1. >>> is_cyclic_rotation(\\"abcde\\", \\"cdeab\\") \\"YES\\" >>> is_cyclic_rotation(\\"abcde\\", \\"abced\\") \\"NO\\"","solution":"def is_cyclic_rotation(s1, s2): Determines if s2 is a cyclic rotation of s1. if len(s1) != len(s2): return \\"NO\\" combined = s1 + s1 if s2 in combined: return \\"YES\\" else: return \\"NO\\" # Read input strings (this section would be used in an actual competition scenario) # s1 = input().strip() # s2 = input().strip() # print(is_cyclic_rotation(s1, s2))"},{"question":"def check_palindrome_substrings(test_cases): Given a list of test cases, check each one to see if there exists a contiguous substring in any row or column that reads the same forward and backward (i.e., is a palindrome). Parameters: test_cases (List[Tuple[List[str], int, int]]): List of tuples where each tuple contains the grid (list of strings) and its dimensions (n, m). Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> check_palindrome_substrings([([\\"abc\\", \\"aba\\", \\"xyz\\"], 3, 3)]) [\\"YES\\"] >>> check_palindrome_substrings([([\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"], 4, 4)]) [\\"NO\\"]","solution":"def is_palindrome(s): return s == s[::-1] def contains_palindrome(grid, n, m): # Check each row for palindromes for row in grid: for k in range(2, m+1): # Minimum palindrome length is 2 for i in range(m - k + 1): if is_palindrome(row[i:i+k]): return \\"YES\\" # Check each column for palindromes for col in range(m): for k in range(2, n+1): # Minimum palindrome length is 2 for i in range(n - k + 1): substring = ''.join(grid[i+j][col] for j in range(k)) if is_palindrome(substring): return \\"YES\\" return \\"NO\\" def check_palindrome_substrings(test_cases): results = [] for grid, n, m in test_cases: results.append(contains_palindrome(grid, n, m)) return results"},{"question":"def three_sum_zero(arr: List[int]) -> List[List[int]]: Function to find all unique triplets in the array which gives the sum of zero. Args: arr: List of integers Returns: List of unique triplets [Ai, Aj, Ak] that sum up to 0 >>> three_sum_zero([-1, 0, 1, 2, -1, -4]) [[-1, -1, 2], [-1, 0, 1]] >>> three_sum_zero([0, 0, 0, 0, 0]) [[0, 0, 0]] >>> three_sum_zero([]) [] >>> three_sum_zero([1, 2, 3, 4, 5]) [] >>> three_sum_zero([-2, -1, 0, 1, 2, 3]) [[-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] def find_unique_triplets(test_cases: List[List[int]]) -> List[List[List[int]]]: Function to handle multiple test cases and find unique triplets that sum to zero for each case. Args: test_cases: List of test cases, each test case being a list of integers. Returns: List of results, each result being a list of unique triplets [Ai, Aj, Ak] that sum up to zero for the corresponding test case. >>> find_unique_triplets([[-1, 0, 1, 2, -1, -4], [0, 0, 0, 0, 0]]) [[[[-1, -1, 2], [-1, 0, 1]], [[0, 0, 0]]]]","solution":"def three_sum_zero(arr): Function to find all unique triplets in the array which gives the sum of zero. arr.sort() result = [] for i in range(len(arr)-2): if i > 0 and arr[i] == arr[i-1]: continue left, right = i+1, len(arr)-1 while left < right: s = arr[i] + arr[left] + arr[right] if s == 0: result.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left+1]: left += 1 while left < right and arr[right] == arr[right-1]: right -= 1 left += 1 right -= 1 elif s < 0: left += 1 else: right -= 1 return result def find_unique_triplets(test_cases): Function to handle multiple test cases and find unique triplets that sum to zero for each case. results = [] for arr in test_cases: results.append(three_sum_zero(arr)) return results"},{"question":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be achieved by buying and selling stock on different days. >>> max_profit([100, 180, 260, 310, 40, 535, 695]) 655 >>> max_profit([190, 180, 170, 160, 150]) 0 def process_input(T, cases): Processes multiple test cases for the given input specifications. >>> process_input(2, [(7, [100, 180, 260, 310, 40, 535, 695]), (5, [190, 180, 170, 160, 150])]) [655, 0]","solution":"def max_profit(prices): This function takes a list of stock prices and returns the maximum profit that can be achieved by buying and selling stock on different days. if len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit def process_input(T, cases): Processes multiple test cases for the given input specifications. T : int : number of test cases cases : list of tuples : each tuple contains an integer N followed by N list of stock prices results = [] for case in cases: N, prices = case[0], case[1] results.append(max_profit(prices)) return results"},{"question":"def length_of_lis(arr): Function to find the length of the Longest Increasing Subsequence (LIS) in the given array. pass def check_subsequence(N, Q, arr, queries): For each query, determine if there exists a subsequence of length K that is strictly increasing. Return a list of \\"YES\\" or \\"NO\\" for each query. >>> N = 7 >>> Q = 4 >>> arr = [9, 1, 3, 7, 5, 6, 20] >>> queries = [3, 5, 8, 2] >>> check_subsequence(N, Q, arr, queries) [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> N = 5 >>> Q = 3 >>> arr = [10, 20, 10, 30, 20] >>> queries = [1, 2, 3] >>> check_subsequence(N, Q, arr, queries) [\\"YES\\", \\"YES\\", \\"YES\\"] pass from solution import length_of_lis, check_subsequence def test_length_of_lis(): assert length_of_lis([9, 1, 3, 7, 5, 6, 20]) == 5 assert length_of_lis([1, 1, 1, 1, 1]) == 1 assert length_of_lis([]) == 0 assert length_of_lis([10, 20, 30, 40, 50]) == 5 assert length_of_lis([50, 40, 30, 20, 10]) == 1 def test_check_subsequence(): N = 7 Q = 4 arr = [9, 1, 3, 7, 5, 6, 20] queries = [3, 5, 8, 2] assert check_subsequence(N, Q, arr, queries) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] N = 5 Q = 3 arr = [10, 20, 10, 30, 20] queries = [1, 2, 3] assert check_subsequence(N, Q, arr, queries) == [\\"YES\\", \\"YES\\", \\"YES\\"] N = 5 Q = 3 arr = [100, 1, 2, 50, 3] queries = [2, 3, 4] assert check_subsequence(N, Q, arr, queries) == [\\"YES\\", \\"YES\\", \\"NO\\"] N = 5 Q = 3 arr = [1, 1, 1, 1, 1] queries = [1, 2, 3] assert check_subsequence(N, Q, arr, queries) == [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def length_of_lis(arr): Function to find the length of the Longest Increasing Subsequence (LIS) in the given array. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def check_subsequence(N, Q, arr, queries): For each query, determine if there exists a subsequence of length K that is strictly increasing. Return a list of \\"YES\\" or \\"NO\\" for each query. results = [] lis_length = length_of_lis(arr) for k in queries: if k <= lis_length: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def determine_winner(nums: List[int]) -> str: Determine the winner of the game between Alice and Bob. Alice wins if the final integer is even, otherwise Bob wins. Both players play optimally. >>> determine_winner([1, 2, 3]) == \\"Alice\\" >>> determine_winner([1, 2, 5]) == \\"Bob\\" def test_alice_wins_with_even(): assert determine_winner([1, 2, 3]) == \\"Alice\\" # Alice can reduce to 2 or 6 (Sum is even) assert determine_winner([2]) == \\"Alice\\" # Single even number def test_bob_wins_with_all_odd(): assert determine_winner([1, 3, 5]) == \\"Bob\\" # All numbers are odd assert determine_winner([1]) == \\"Bob\\" # Single odd number assert determine_winner([1, 1, 1]) == \\"Bob\\" # All numbers are odd def test_mixed(): assert determine_winner([1, 4, 5, 7]) == \\"Alice\\" # Even number present assert determine_winner([7, 1, 2, 9]) == \\"Alice\\" # Even number present assert determine_winner([1, 3, 5, 7, 2]) == \\"Alice\\" # Even number present def test_large_numbers(): assert determine_winner([10**6, 999999, -10**6]) == \\"Alice\\" # Large numbers, including an even number assert determine_winner([999999989, 999999991, 999999993]) == \\"Bob\\" # Large odd numbers","solution":"from typing import List def determine_winner(nums: List[int]) -> str: Determine the winner of the game between Alice and Bob. Alice wins if the final integer is even, otherwise Bob wins. Both players play optimally. # Alice wins if there is any even number in the array because she can always reduce to that even number. for num in nums: if num % 2 == 0: return \\"Alice\\" # If all numbers are odd, Bob will sum them to get an odd number making him the winner. return \\"Bob\\""},{"question":"def max_building_index(n: int, l: int, heights: List[int], b: int) -> int: Determine the maximum building index that can be reached using the given ladder and bricks. >>> max_building_index(5, 1, [4, 2, 7, 6, 9], 5) 4 >>> max_building_index(5, 0, [4, 2, 7, 6, 9], 5) 3","solution":"import heapq def max_building_index(n, l, heights, b): # Min-heap to keep the smallest differences at the top min_heap = [] total_bricks = 0 for i in range(n - 1): height_diff = heights[i + 1] - heights[i] # Only consider gaps where next building is taller if height_diff > 0: heapq.heappush(min_heap, height_diff) # If there are more gap entries than ladders, use bricks for the smallest if len(min_heap) > l: total_bricks += heapq.heappop(min_heap) # If we run out of bricks before covering one of the gaps, stop if total_bricks > b: return i return n - 1"},{"question":"def longest_balanced_subarray(array: List[int], k: int) -> int: Find the length of the longest subarray where the balance (max - min) does not exceed k. >>> longest_balanced_subarray([1, 3, 6, 6, 7], 3) 3 >>> longest_balanced_subarray([8, 8, 8], 0) 3 def solve(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: For each test case, find the length of the longest subarray with balance not exceeding k. >>> t = 2 >>> test_cases = [ >>> (5, 3, [1, 3, 6, 6, 7]), >>> (3, 0, [8, 8, 8]) >>> ] >>> solve(t, test_cases) [3, 3]","solution":"def longest_balanced_subarray(array, k): Find the length of the longest subarray where the balance (max - min) does not exceed k. n = len(array) if n == 0: return 0 left = 0 result = 0 min_list = [] max_list = [] for right in range(n): while min_list and array[min_list[-1]] >= array[right]: min_list.pop() while max_list and array[max_list[-1]] <= array[right]: max_list.pop() min_list.append(right) max_list.append(right) while array[max_list[0]] - array[min_list[0]] > k: left += 1 if min_list[0] < left: min_list.pop(0) if max_list[0] < left: max_list.pop(0) result = max(result, right - left + 1) return result def solve(t, test_cases): results = [] for case in test_cases: n, k, array = case results.append(longest_balanced_subarray(array, k)) return results"},{"question":"def max_simultaneous_processes(n: int, intervals: List[Tuple[int, int]]) -> int: Determines the maximum number of processes running simultaneously given their start and end times. Args: n (int): The number of processes. intervals (List[Tuple[int, int]]): Each tuple contains two integers representing the start and end times of a process. Returns: int: The maximum number of processes running simultaneously. Examples: >>> max_simultaneous_processes(5, [(1, 5), (2, 6), (4, 8), (3, 7), (5, 9)]) 4 >>> max_simultaneous_processes(4, [(1, 3), (2, 4), (5, 6), (7, 9)]) 2","solution":"def max_simultaneous_processes(n, intervals): Finds the maximum number of processes running simultaneously given their start and end times. Args: n (int): The number of processes. intervals (list of tuples): Each tuple contains two integers representing the start and end times of a process. Returns: int: The maximum number of processes running simultaneously. events = [] for start, end in intervals: events.append((start, 'start')) events.append((end, 'end')) events.sort() max_processes = 0 current_processes = 0 for time, event_type in events: if event_type == 'start': current_processes += 1 max_processes = max(max_processes, current_processes) else: current_processes -= 1 return max_processes"},{"question":"def min_removals_to_strictly_increasing(arr): Determines the minimum number of leaves to remove to make the array strictly increasing. >>> min_removals_to_strictly_increasing([1, 3, 2, 4, 3, 5]) 2 >>> min_removals_to_strictly_increasing([5, 5, 5, 5, 5]) 4 >>> min_removals_to_strictly_increasing([1, 2, 3, 4, 5, 6, 7, 8]) 0 >>> min_removals_to_strictly_increasing([1]) 0 >>> min_removals_to_strictly_increasing([]) 0 >>> min_removals_to_strictly_increasing([1, 5, 10, 20]) 0 >>> min_removals_to_strictly_increasing([4, 3, 2, 1]) 3 >>> min_removals_to_strictly_increasing([1, 2, 2, 3, 4]) 1 >>> min_removals_to_strictly_increasing([3, 4, 2, 1, 10, 6, 15, 12, 9]) 5","solution":"def min_removals_to_strictly_increasing(arr): Determines the minimum number of leaves to remove to make the array strictly increasing. from bisect import bisect_left if not arr: return 0 # This will store the longest increasing subsequence lis = [] for leaf in arr: pos = bisect_left(lis, leaf) if pos == len(lis): lis.append(leaf) else: lis[pos] = leaf # Number of elements to remove is total elements minus length of lis return len(arr) - len(lis)"},{"question":"def exclusive_sort(arr) -> List[int]: Perform Exclusive Sort on a given array of integers. Args: arr (List[int]): The input array of integers. Returns: List[int]: The transformed array as per the Exclusive Sort algorithm. Examples: >>> exclusive_sort([10, 20, 10, 30, 20]) [1, 2, 1, 3, 2] >>> exclusive_sort([5, 5, 5, 5]) [1, 1, 1, 1] >>> exclusive_sort([1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6]","solution":"def exclusive_sort(arr): # Step 1: Extracting unique elements and sorting them unique_sorted_elements = sorted(set(arr)) # Step 2: Creating a mapping from element to its sorted position position_map = {element: idx + 1 for idx, element in enumerate(unique_sorted_elements)} # Step 3: Replace each element in the original array with its position in the sorted list return [position_map[element] for element in arr]"},{"question":"def track_workshop_signups(test_cases: List[Dict]) -> List[str]: Track participant sign-ups for various workshops. Args: test_cases (List[Dict]): List of test case dictionaries. Each dictionary contains the following keys: 'W' (int): Number of workshops. 'workshops' (List[Tuple]): List of tuples, each containing: - str: Workshop title - int: Maximum number of participants - int: Start time in minutes 'P' (int): Number of participants. 'participants' (List[Tuple]): List of tuples, each containing: - str: Participant name - str: Workshop title they want to sign up for Returns: List[str]: List of strings \\"Registered\\" or \\"Rejected\\" for each participant sign-up attempt. >>> track_workshop_signups([{'W': 3, 'workshops': [('Python Beginners', 10, 600), ('Data Science', 5, 900), ('Web Development', 7, 720)], 'P': 5, 'participants': [('Alice', 'Python Beginners'), ('Bob', 'Data Science'), ('Charlie', 'Python Beginners'), ('Diana', 'Web Development'), ('Eve', 'Data Science')}]) ['Registered', 'Registered', 'Registered', 'Registered', 'Registered'] >>> track_workshop_signups([{'W': 2, 'workshops': [('Python Beginners', 2, 600), ('Data Science', 1, 900)], 'P': 4, 'participants': [('Alice', 'Python Beginners'), ('Bob', 'Data Science'), ('Charlie', 'Python Beginners'), ('Diana', 'Data Science')}]) ['Registered', 'Registered', 'Registered', 'Rejected']","solution":"def track_workshop_signups(test_cases): results = [] for case in test_cases: W = case['W'] workshops = {} for entry in case['workshops']: title, max_participants, start_time = entry workshops[title] = { 'max_participants': max_participants, 'start_time': start_time, 'current_participants': 0 } P = case['P'] for participant in case['participants']: name, workshop_title = participant if workshops[workshop_title]['current_participants'] < workshops[workshop_title]['max_participants']: workshops[workshop_title]['current_participants'] += 1 results.append('Registered') else: results.append('Rejected') return results # Test case input test_cases_input = [ { 'W': 3, 'workshops': [ ('Python Beginners', 10, 600), ('Data Science', 5, 900), ('Web Development', 7, 720) ], 'P': 5, 'participants': [ ('Alice', 'Python Beginners'), ('Bob', 'Data Science'), ('Charlie', 'Python Beginners'), ('Diana', 'Web Development'), ('Eve', 'Data Science') ] } ] # Returning the output output = track_workshop_signups(test_cases_input) print(output) # Expected: ['Registered', 'Registered', 'Registered', 'Registered', 'Registered']"},{"question":"def calculate_minutes(time1: str, time2: str) -> int: Calculate the minutes between two timestamps in \\"HH:MM\\" format. >>> calculate_minutes(\\"09:00\\", \\"12:00\\") 180 >>> calculate_minutes(\\"13:00\\", \\"17:00\\") 240 >>> calculate_minutes(\\"08:30\\", \\"12:45\\") 255 >>> calculate_minutes(\\"14:15\\", \\"15:30\\") 75 >>> calculate_minutes(\\"16:00\\", \\"18:00\\") 120 def total_minutes_present(test_cases: List[Tuple[int, List[str]]]) -> List[int]: Calculate the total number of minutes the employee was present for each test case. >>> total_minutes_present([(4, [\\"09:00\\", \\"12:00\\", \\"13:00\\", \\"17:00\\"]), (6, [\\"08:30\\", \\"12:45\\", \\"14:15\\", \\"15:30\\", \\"16:00\\", \\"18:00\\"])]) [420, 450] def parse_input(input_str: str) -> List[Tuple[int, List[str]]]: Parse the input into a list of test cases. >>> parse_input(\\"2n4n09:00 12:00 13:00 17:00n6n08:30 12:45 14:15 15:30 16:00 18:00\\") [(4, [\\"09:00\\", \\"12:00\\", \\"13:00\\", \\"17:00\\"]), (6, [\\"08:30\\", \\"12:45\\", \\"14:15\\", \\"15:30\\", \\"16:00\\", \\"18:00\\"])]","solution":"def calculate_minutes(time1, time2): Calculate the minutes between two time stamps in \\"HH:MM\\" format h1, m1 = map(int, time1.split(':')) h2, m2 = map(int, time2.split(':')) return (h2 - h1) * 60 + (m2 - m1) def total_minutes_present(test_cases): results = [] for case in test_cases: N, timestamps = case total_minutes = 0 for i in range(0, N, 2): check_in = timestamps[i] check_out = timestamps[i+1] total_minutes += calculate_minutes(check_in, check_out) results.append(total_minutes) return results def parse_input(input_str): Parses the input from a single string representing the whole input lines = input_str.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N = int(lines[index]) index += 1 timestamps = lines[index].split() index += 1 test_cases.append((N, timestamps)) return test_cases"},{"question":"import json from typing import Dict def flatten_json(input_json: str) -> Dict[str, any]: Flattens a nested dictionary represented by a JSON string into a dictionary with dot-separated paths as keys. Args: input_json (str): A JSON string representing a nested dictionary. Returns: dict: A flat dictionary with keys as dot-separated paths. >>> flatten_json('{\\"a\\":1,\\"b\\":{\\"c\\":2,\\"d\\":{\\"e\\":3,\\"f\\":4}}}') {'a': 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': 4} >>> flatten_json('{\\"name\\":\\"John\\", \\"address\\": {\\"city\\": \\"New York\\", \\"details\\": {\\"zipcode\\": \\"10001\\", \\"street\\": \\"5th Avenue\\"}}}') {'name': 'John', 'address.city': 'New York', 'address.details.zipcode': '10001', 'address.details.street': '5th Avenue'} >>> flatten_json('{\\"key1\\":{\\"keyA\\":1,\\"keyB\\":2},\\"key2\\":3}') {'key1.keyA': 1, 'key1.keyB': 2, 'key2': 3} >>> flatten_json('{}') {} >>> flatten_json('{\\"a\\": 1, \\"b\\": 2}') {'a': 1, 'b': 2} >>> flatten_json('{\\"a\\": {\\"b\\": {\\"c\\": {\\"d\\": {\\"e\\": 5}}}}}') {'a.b.c.d.e': 5} >>> input_json = ''' { \\"a\\": 1, \\"b\\": { \\"b1\\": 2, \\"b2\\": { \\"b21\\": 3, \\"b22\\": { \\"b221\\": 4 } } }, \\"c\\": { \\"c1\\": { \\"c11\\": 5 } }, \\"d\\": { \\"d1\\": { \\"d11\\": { \\"d111\\": 6 }, \\"d12\\": 7 } } } ''' >>> flatten_json(input_json) {'a': 1, 'b.b1': 2, 'b.b2.b21': 3, 'b.b2.b22.b221': 4, 'c.c1.c11': 5, 'd.d1.d11.d111': 6, 'd.d1.d12': 7}","solution":"import json def flatten_json(input_json: str) -> dict: Flattens a nested dictionary represented by a JSON string into a dictionary with dot-separated paths as keys. Args: input_json (str): A JSON string representing a nested dictionary. Returns: dict: A flat dictionary with keys as dot-separated paths. def recurse(nested_dict, parent_key=\\"\\"): items = [] for key, value in nested_dict.items(): new_key = f\\"{parent_key}.{key}\\" if parent_key else key if isinstance(value, dict): items.extend(recurse(value, new_key).items()) else: items.append((new_key, value)) return dict(items) nested_dict = json.loads(input_json) return recurse(nested_dict)"},{"question":"from typing import List class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root: 'Node') -> List[List[int]]: Given a N-ary tree, return the level order traversal of its nodes' values. >>> levelOrder(None) [] >>> levelOrder(Node(1)) [[1]] >>> levelOrder(Node(1, [Node(2), Node(3), Node(4)])) [[1], [2, 3, 4]] >>> levelOrder(Node(1, [Node(3, [Node(5), Node(6)]), Node(2), Node(4)])) [[1], [3, 2, 4], [5, 6]] >>> levelOrder(Node(1, [Node(2, [Node(5)]), Node(3, [Node(6, [Node(7)])]), Node(4)])) [[1], [2, 3, 4], [5, 6], [7]]","solution":"from collections import deque from typing import List class Node: def __init__(self, val=None, children=None): self.val = val self.children = children if children is not None else [] def levelOrder(root: 'Node') -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) queue.extend(node.children) result.append(current_level) return result"},{"question":"def determine_fitness_activity(step_counts): Determines the fitness activity level based on weekly average steps. :param step_counts: List[int] - A list of integers representing daily step counts. :return: List[str] - A list containing \\"Active\\" or \\"Inactive\\" for each week. >>> determine_fitness_activity([12000, 11000, 8000, 9500, 10000, 10500, 11500]) [\\"Active\\"] >>> determine_fitness_activity([5000, 6000, 7000, 8000, 10000, 9000, 9100]) [\\"Inactive\\"] >>> step_counts = [12000, 11000, 8000, 9500, 10000, 10500, 11500, 5000, 6000, 7000, 8000, 10000, 9000, 9100] >>> determine_fitness_activity(step_counts) [\\"Active\\", \\"Inactive\\"] >>> step_counts = [12000, 11000, 13000, 16000, 14000, 15000, 12500, 15000, 14500, 13500, 14000, 15000, 15500, 16000] >>> determine_fitness_activity(step_counts) [\\"Active\\", \\"Active\\"] >>> step_counts = [5000, 6000, 6500, 7000, 7500, 8000, 8500, 4000, 4500, 5000, 5500, 6000, 6500, 7000] >>> determine_fitness_activity(step_counts) [\\"Inactive\\", \\"Inactive\\"]","solution":"def determine_fitness_activity(step_counts): Determines the fitness activity level based on weekly average steps. :param step_counts: List[int] - A list of integers representing daily step counts. :return: List[str] - A list containing \\"Active\\" or \\"Inactive\\" for each week. fitness_activity = [] steps_per_week = 7 for i in range(0, len(step_counts), steps_per_week): weekly_steps = step_counts[i:i+steps_per_week] average_steps = sum(weekly_steps) / steps_per_week if average_steps >= 10000: fitness_activity.append(\\"Active\\") else: fitness_activity.append(\\"Inactive\\") return fitness_activity"},{"question":"def can_place_tree(grid, x, y, w, h): Check if a tree can be placed in the grid at position (x, y) with width w and height h. >>> grid = [ >>> ['.', '.', '.'], >>> ['.', '.', '.'], >>> ['.', '.', '.'] >>> ] >>> can_place_tree(grid, 0, 0, 2, 2) True >>> grid = [ >>> ['.', '.', '.'], >>> ['.', '#', '.'], >>> ['.', '.', '.'] >>> ] >>> can_place_tree(grid, 0, 0, 2, 2) False pass def place_tree(grid, x, y, w, h): Place a tree in the grid at position (x, y) with width w and height h. pass def remove_tree(grid, x, y, w, h): Remove a tree from the grid at position (x, y) with width w and height h. pass def max_trees_planted(n, m, orchard, tree_types): Calculate the maximum number of different types of trees that can be planted in the orchard. >>> n = 5 >>> m = 5 >>> orchard = [ >>> \\".....\\", >>> \\"..#..\\", >>> \\".....\\", >>> \\"..#..\\", >>> \\".....\\" >>> ] >>> tree_types = [(2, 2, 1), (3, 1, 2), (1, 2, 1)] >>> max_trees_planted(n, m, orchard, tree_types) 3 pass def main(input_str): Process the input string and return the maximum number of different types of trees that can be planted. >>> input_str = '''5 5 >>> ..... >>> ..#.. >>> ..... >>> ..#.. >>> ..... >>> 3 >>> 2 2 1 >>> 3 1 2 >>> 1 2 1 >>> ''' >>> main(input_str) 3 pass def test_can_place_tree_true(): grid = [ ['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.'] ] assert can_place_tree(grid, 0, 0, 2, 2) == True def test_can_place_tree_false(): grid = [ ['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.'] ] assert can_place_tree(grid, 0, 0, 2, 2) == False def test_max_trees_planted(): input_str = 5 5 ..... ..#.. ..... ..#.. ..... 3 2 2 1 3 1 2 1 2 1 assert main(input_str) == 3 def test_max_trees_planted_example_2(): input_str = 3 3 ... .#. ... 1 2 2 1 assert main(input_str) == 0 def test_max_trees_planted_example_3(): input_str = 4 4 .... ..#. .... .... 2 2 2 1 1 1 1 assert main(input_str) == 2","solution":"def can_place_tree(grid, x, y, w, h): for i in range(h): for j in range(w): if grid[x + i][y + j] != '.': return False return True def place_tree(grid, x, y, w, h): for i in range(h): for j in range(w): grid[x + i][y + j] = 'T' def remove_tree(grid, x, y, w, h): for i in range(h): for j in range(w): grid[x + i][y + j] = '.' def max_trees_planted(n, m, orchard, tree_types): def dfs(grid, tree_types, idx, count): if idx == len(tree_types): return count w, h, c = tree_types[idx] max_count = count placements = [] for x in range(n - h + 1): for y in range(m - w + 1): if can_place_tree(grid, x, y, w, h): placements.append((x, y)) for x, y in placements: place_tree(grid, x, y, w, h) max_count = max(max_count, dfs(grid, tree_types, idx + 1, count + 1)) remove_tree(grid, x, y, w, h) max_count = max(max_count, dfs(grid, tree_types, idx + 1, count)) return max_count return dfs([list(row) for row in orchard], tree_types, 0, 0) def main(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) orchard = [lines[i + 1] for i in range(n)] t = int(lines[n + 1]) tree_types = [tuple(map(int, lines[n + 1 + i + 1].split())) for i in range(t)] return max_trees_planted(n, m, orchard, tree_types)"},{"question":"def trap(height): Calculate how much water can be trapped after rain, given the heights of the blocks. :param height: List[int] - list of non-negative integers representing the heights of blocks :return: int - the total amount of trapped water >>> trap([0,1,0,2,1,0,1,3,2,1,2,1]) == 6 >>> trap([]) == 0 >>> trap([1,1,1,1]) == 0 >>> trap([5]) == 0 >>> trap([2,1]) == 0 >>> trap([4,2,0,3,2,5]) == 9 >>> trap([3, 0, 0, 2, 0, 4]) == 10 >>> trap([4, 4, 4, 4]) == 0 >>> trap([3, 1, 2]) == 1","solution":"def trap(height): Calculate how much water can be trapped after rain, given the heights of the blocks. :param height: List[int] - list of non-negative integers representing the heights of blocks :return: int - the total amount of trapped water if not height or len(height) < 3: return 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] water_trapped = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, height[left]) water_trapped += max(0, left_max - height[left]) else: right -= 1 right_max = max(right_max, height[right]) water_trapped += max(0, right_max - height[right]) return water_trapped"},{"question":"def min_operations_to_sort(arr): Returns the minimum number of subarray reversals required to sort the array. >>> min_operations_to_sort([4, 3, 2, 1]) == 1 >>> min_operations_to_sort([1, 2, 3, 4, 5]) == 0 >>> min_operations_to_sort([1, 2, 5, 4, 3]) == 1 >>> min_operations_to_sort([1]) == 0 >>> min_operations_to_sort([2, 1]) == 1 pass def process_test_cases(T, test_cases): Processes T test cases and returns a list with the minimum number of operations for each case. >>> process_test_cases(2, [(4, [4, 3, 2, 1]), (5, [1, 2, 5, 4, 3])]) == [1, 1] pass","solution":"def min_operations_to_sort(arr): Returns the minimum number of subarray reversals required to sort the array. n = len(arr) if sorted(arr) == arr: return 0 for i in range(n - 1): if arr[i] > arr[i + 1]: # If we detect a point where the trend breaks, we need 1 reversal return 1 return 0 def process_test_cases(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] results.append(min_operations_to_sort(A)) return results"},{"question":"def lexicographically_smallest_binary_string(n: int, k: int, binary_string: str) -> str: Given a binary string of length n, perform exactly k operations to transform the string into the lexicographically smallest binary string possible. In one operation, you can choose any two different positions in the string and swap their values. Args: n (int): The length of the binary string. k (int): The number of operations allowed. binary_string (str): The binary string to transform. Returns: str: The lexicographically smallest binary string after exactly k operations. Examples: >>> lexicographically_smallest_binary_string(5, 2, \\"11001\\") '00111' >>> lexicographically_smallest_binary_string(5, 0, \\"11001\\") '11001' >>> lexicographically_smallest_binary_string(1, 1, \\"1\\") '1' >>> lexicographically_smallest_binary_string(3, 1, \\"101\\") '011' >>> lexicographically_smallest_binary_string(3, 10, \\"111\\") '111' >>> lexicographically_smallest_binary_string(4, 3, \\"0011\\") '0011'","solution":"def lexicographically_smallest_binary_string(n, k, binary_string): binary_list = list(binary_string) for i in range(n): if k <= 0: break # Find the smallest binary digit in the remaining part of the string to swap with current position min_index = i for j in range(i + 1, n): if binary_list[j] < binary_list[min_index]: min_index = j # If we have found a smaller element, swap it with the current position if min_index != i: binary_list[i], binary_list[min_index] = binary_list[min_index], binary_list[i] k -= 1 return ''.join(binary_list)"},{"question":"def max_profit(prices): Calculate the maximum profit that can be made by buying and selling one share of a stock. :param prices: List[int] - a list of stock prices where each element represents the price on a given day. :return: int - maximum profit that can be achieved. If no profit is possible, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([5]) 0 >>> max_profit([]) 0 >>> max_profit([10, 9, 8, 7, 6]) 0 >>> max_profit([1, 1000, 1, 1000]) 999 >>> max_profit([1, 2, 3, 4, 5, 0, 10]) 10","solution":"def max_profit(prices): Calculate the maximum profit that can be made by buying and selling one share of a stock. :param prices: List[int] - a list of stock prices where each element represents the price on a given day. :return: int - maximum profit that can be achieved. If no profit is possible, return 0. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def average_of_subarrays(arr: List[int]) -> List[float]: Given an array of integers, return an array of averages of all possible subarrays of length 3. >>> average_of_subarrays([1, 2, 3, 4, 5]) [2.0, 3.0, 4.0] >>> average_of_subarrays([5, 1, 3, 2, 8]) [3.0, 2.0, 4.3]","solution":"def average_of_subarrays(arr): Given an array of integers, returns an array of averages of all possible subarrays of length 3. n = len(arr) result = [(arr[i] + arr[i+1] + arr[i+2]) / 3 for i in range(n - 3 + 1)] return [round(avg, 1) for avg in result]"},{"question":"from typing import List def isLocked(passcodes: List[str], correct_passcode: str) -> bool: Simulate the behavior of a security system. A company has implemented a security system that locks the building if an incorrect passcode is attempted 3 times in a row. Given an array of passcode attempts and a correct passcode, determine if the building is locked. Example 1: >>> isLocked([\\"1234\\", \\"2345\\", \\"0000\\", \\"1111\\"], \\"9999\\"): False Example 2: >>> isLocked([\\"1234\\", \\"2345\\", \\"1234\\", \\"1234\\", \\"1234\\"], \\"9999\\"): True Example 3: >>> isLocked([\\"1234\\", \\"2345\\", \\"9999\\", \\"9999\\", \\"9999\\"], \\"9999\\"): False Constraints: - The length of the passcode attempts list is between 1 and 10^4. - Each passcode attempt is a string of 4 digits. - The correct passcode is a string of 4 digits.","solution":"from typing import List def isLocked(passcodes: List[str], correct_passcode: str) -> bool: incorrect_attempts = 0 for attempt in passcodes: if attempt != correct_passcode: incorrect_attempts += 1 if incorrect_attempts == 3: return True else: incorrect_attempts = 0 return False"},{"question":"def min_widgets_to_inspect(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of widgets you need to inspect to guarantee finding at least one functional widget. Args: t (int): Number of test cases. test_cases (List[Tuple[int, int]]): Each tuple contains the total number of widgets (n) and the number of functional widgets (k). Returns: List[int]: The minimum number of widgets you need to inspect for each test case. Example: >>> min_widgets_to_inspect(3, [(7, 3), (5, 5), (10, 1)]) [5, 1, 10]","solution":"def min_widgets_to_inspect(t, test_cases): results = [] for n, k in test_cases: results.append(n - k + 1) return results"},{"question":"def max_energy_path(n: int, energy_levels: List[int], edges: List[Tuple[int, int]]) -> int: Find the maximum possible sum of energy levels of zylons in a path between any two nodes in the tree. Args: n (int): The number of nodes. energy_levels (List[int]): The energy levels of zylons in treehouses. edges (List[Tuple[int, int]]): The edges between nodes. Returns: int: The maximum possible sum of energy levels. Example: >>> max_energy_path(5, [3, 2, 1, -5, 4], [(1, 2), (1, 3), (2, 4), (2, 5)]) 10 >>> max_energy_path(3, [1, 2, 3], [(1, 2), (2, 3)]) 6 pass # Unit tests def test_example_case(): n = 5 energy_levels = [3, 2, 1, -5, 4] edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert max_energy_path(n, energy_levels, edges) == 10 def test_single_path(): n = 3 energy_levels = [1, 2, 3] edges = [(1, 2), (2, 3)] assert max_energy_path(n, energy_levels, edges) == 6 def test_negative_values(): n = 4 energy_levels = [-1, -2, -3, -4] edges = [(1, 2), (2, 3), (3, 4)] assert max_energy_path(n, energy_levels, edges) == -1 def test_mixed_values(): n = 4 energy_levels = [-1, 2, 3, -4] edges = [(1, 2), (2, 3), (3, 4)] assert max_energy_path(n, energy_levels, edges) == 5 def test_large_positive_values(): n = 3 energy_levels = [10**9, 10**9, 10**9] edges = [(1, 2), (2, 3)] assert max_energy_path(n, energy_levels, edges) == 3 * (10**9)","solution":"def max_energy_path(n, energy_levels, edges): from collections import defaultdict import sys sys.setrecursionlimit(10**6) def dfs(node, parent): max1, max2 = 0, 0 # To store the top two max contributions from children for neighbor in tree[node]: if neighbor == parent: continue result = dfs(neighbor, node) if result > max1: max1, max2 = result, max1 elif result > max2: max2 = result # update global max_path_sum nonlocal max_path_sum max_path_sum = max(max_path_sum, max1 + max2 + energy_levels[node]) # return max contribution from this node (including its own energy level) return max1 + energy_levels[node] tree = defaultdict(list) for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) max_path_sum = -10**9 * n # Initialize with a very small number dfs(0, -1) return max_path_sum # Helper function to take input and call the main function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) energy_levels = list(map(int, data[1:n+1])) edges = [] index = n + 1 for _ in range(n-1): edges.append((int(data[index]), int(data[index+1]))) index += 2 result = max_energy_path(n, energy_levels, edges) print(result)"},{"question":"def find_majority_element(arr): Returns the majority element if one exists, otherwise returns -1. A majority element is one that appears more than n/2 times in the array. >>> find_majority_element([3, 3, 4, 2, 4, 4, 4]) 4 >>> find_majority_element([1, 2, 3, 4, 5, 6]) -1 >>> find_majority_element([1]) 1 >>> find_majority_element([1, 2]) -1 >>> find_majority_element([2, 2]) 2 >>> find_majority_element([7, 7, 7, 7, 7]) 7 >>> find_majority_element(list(range(1, 100001))) -1 >>> find_majority_element([2] * 500001 + [3] * 499999) 2 >>> find_majority_element([1, 1, 1, 2, 3, 1, 1]) 1","solution":"def find_majority_element(arr): Returns the majority element if one exists, otherwise returns -1. A majority element is one that appears more than n/2 times in the array. # Use Boyer-Moore Voting Algorithm candidate = None count = 0 # First pass to find the candidate for num in arr: if count == 0: candidate = num count = 1 elif num == candidate: count += 1 else: count -= 1 # Second pass to confirm the candidate if candidate is not None: count = sum(1 for num in arr if num == candidate) if count > len(arr) // 2: return candidate return -1"},{"question":"class RangeSumQuery: def __init__(self, nums): Initialize the data structure with the given list of integers. >>> rsq = RangeSumQuery([1, 2, 3, 4, 5]) >>> rsq.range_sum(0, 2) 6 >>> rsq.update(2, 10) >>> rsq.range_sum(0, 2) 13 # Implementation goes here def update(self, index, value): Update the value at the specified index to the new value. >>> rsq = RangeSumQuery([1, 2, 3, 4, 5]) >>> rsq.update(2, 10) >>> rsq.range_sum(0, 2) 13 # Implementation goes here def range_sum(self, left, right): Compute the sum of values within the specified range (inclusive of both ends). >>> rsq = RangeSumQuery([1, 2, 3, 4, 5]) >>> rsq.range_sum(0, 2) 6 # Implementation goes here def process_queries(n, q, nums, queries): Process the list of integers and queries, updating and calculating range sums as specified. >>> nums = [5, 8, 6, 3, 4, 7, 2] >>> queries = [[2, 2, 5], [1, 4, 10], [2, 4, 7], [2, 1, 3]] >>> process_queries(7, 4, nums, queries) [21, 23, 19] # Implementation goes here","solution":"class RangeSumQuery: def __init__(self, nums): self.n = len(nums) self.nums = nums # Initialize the segment tree self.tree = [0] * (2 * self.n) self._build() def _build(self): # Populate the leaves of the tree for i in range(self.n): self.tree[self.n + i] = self.nums[i] # Calculate the values for the internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def update(self, index, value): pos = index + self.n self.tree[pos] = value # Move up and update the ancestors while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] self.nums[index] = value def range_sum(self, left, right): # Adjust to the segment tree indexing left += self.n right += self.n summation = 0 while left <= right: if left % 2 == 1: summation += self.tree[left] left += 1 if right % 2 == 0: summation += self.tree[right] right -= 1 left //= 2 right //= 2 return summation # Helper function to process the input and handle the queries def process_queries(n, q, nums, queries): rsq = RangeSumQuery(nums) results = [] for query in queries: if query[0] == 1: _, index, value = query rsq.update(index - 1, value) elif query[0] == 2: _, left, right = query results.append(rsq.range_sum(left - 1, right - 1)) return results"},{"question":"import re from collections import Counter def most_frequent_word(text: str) -> str: Returns the most frequent word in the text. In case of a tie, returns the word that appears first in the text. Args: text (str): The input string containing a paragraph of words separated by spaces. Returns: str: The most frequent word. >>> text = \\"the quick brown fox jumps over the lazy dog the fox is quick\\" >>> most_frequent_word(text) 'the' from solution import most_frequent_word def test_single_word(): assert most_frequent_word(\\"hello\\") == \\"hello\\" def test_no_punctuation(): text = \\"the quick brown fox jumps over the lazy dog the fox is quick\\" assert most_frequent_word(text) == \\"the\\" def test_with_punctuation(): text = \\"Hello, hello! How are you? Hello, I'm fine.\\" assert most_frequent_word(text) == \\"Hello\\" def test_case_insensitivity(): text = \\"Apple apple APPLE Banana BANANA banana\\" assert most_frequent_word(text) == \\"Apple\\" def test_tie_words(): text = \\"a b c a b c a b\\" assert most_frequent_word(text) == \\"a\\" def test_other_characters(): text = \\"hello, world! Hello WORLD.\\" assert most_frequent_word(text) == \\"hello\\" def test_special_chars_in_words(): text = \\"cat cat's cats\\" assert most_frequent_word(text) == \\"cat\\" def test_empty_string(): assert most_frequent_word(\\"\\") == \\"\\" def test_numerical_words(): text = \\"one two three one two one\\" assert most_frequent_word(text) == \\"one\\"","solution":"import re from collections import Counter def most_frequent_word(text): Returns the most frequent word in the text. In case of a tie, returns the word that appears first in the text. Args: text (str): The input string containing a paragraph of words separated by spaces. Returns: str: The most frequent word. # Normalize and split the text into words, ignoring punctuation and case words = re.findall(r'bw+b', text.lower()) original_words = re.findall(r'bw+b', text) # Count the frequency of each word word_count = Counter(words) # Initialize max frequency and result word max_freq = 0 most_frequent = \\"\\" # Iterate over the original words to maintain the first appearance in the case of ties for word in original_words: word_lower = word.lower() if word_count[word_lower] > max_freq: max_freq = word_count[word_lower] most_frequent = word elif word_count[word_lower] == max_freq and most_frequent == \\"\\": most_frequent = word return most_frequent # Example usage text = \\"the quick brown fox jumps over the lazy dog the fox is quick\\" print(most_frequent_word(text)) # Output: 'the'"},{"question":"def sum_nested_dict_values(nested_dict): Takes a nested dictionary where values are lists of numbers and returns a dictionary with the sum of the numbers for each list. >>> sum_nested_dict_values({ ... \\"a\\": [1, 2, 3, 4], ... \\"b\\": [5, 6, 7, 8] ... }) == {\\"a\\": 10, \\"b\\": 26} >>> sum_nested_dict_values({ ... \\"x\\": [2, -3, 9, 10, 7], ... \\"y\\": [12, 6, 89, 45, 3], ... \\"z\\": [9, 12, 56, 10, 34] ... }) == {\\"x\\": 25, \\"y\\": 155, \\"z\\": 121} >>> sum_nested_dict_values({}) == {} >>> sum_nested_dict_values({ ... \\"a\\": [1.5, 2.5, -1.0], ... \\"b\\": [0.0, 0.0, 0.0, 0.0] ... }) == {\\"a\\": 3.0, \\"b\\": 0.0} >>> sum_nested_dict_values({ ... \\"p\\": [], ... \\"q\\": [100], ... \\"r\\": [-1, -1, -1, -1, -1] ... }) == {\\"p\\": 0, \\"q\\": 100, \\"r\\": -5} >>> sum_nested_dict_values({ ... \\"a\\": [1], ... \\"b\\": [-1], ... \\"c\\": [0] ... }) == {\\"a\\": 1, \\"b\\": -1, \\"c\\": 0}","solution":"def sum_nested_dict_values(nested_dict): Takes a nested dictionary where values are lists of numbers and returns a dictionary with the sum of the numbers for each list. return {key: sum(values) for key, values in nested_dict.items()}"},{"question":"def count_distinct_substrings(N: int, L: int, S: str) -> int: Returns the number of distinct substrings of length L that can be formed from S. >>> count_distinct_substrings(5, 3, 'ABCDE') 3 >>> count_distinct_substrings(6, 2, 'AAAAAA') 1 >>> count_distinct_substrings(6, 2, 'ABCDEF') 5 >>> count_distinct_substrings(4, 4, 'ABCD') 1 >>> count_distinct_substrings(4, 1, 'AABC') 3 >>> count_distinct_substrings(100000, 1, 'A' * 100000) 1","solution":"def count_distinct_substrings(N, L, S): Returns the number of distinct substrings of length L that can be formed from S. substrings = set() for i in range(N - L + 1): substrings.add(S[i:i+L]) return len(substrings)"},{"question":"def minRows(preferences: List[int], K: int) -> int: Determine the minimum number of rows required to seat all attendees based on their seating preferences. Args: preferences (List[int]): an array of integers where each integer represents the preferred row number of an attendee. K (int): an integer representing the maximum number of attendees that can be accommodated in a single row. Returns: int: the minimum number of rows needed to seat all attendees. >>> minRows([1, 2, 1, 2, 3, 1, 2, 3, 4, 4], 3) 4 >>> minRows([1, 1, 1, 1], 2) 2 >>> minRows([1, 2, 3, 4, 5], 2) 5 >>> minRows([1, 1, 1], 3) 1 >>> minRows([1] * 10000, 1000) 10","solution":"def minRows(preferences, K): from collections import Counter # Count occurrences of each preferred row number counter = Counter(preferences) # Calculate the minimum number of rows min_rows = 0 for count in counter.values(): min_rows += (count + K - 1) // K # Equivalent to math.ceil(count / K) return min_rows"},{"question":"def longest_unique_subarray_length(arr, queries): You are given an array consisting of n integers. You need to process q queries. In each query, you are given two integers l and r, and you need to find the length of the longest subarray within the range [l, r] (inclusive) that contains all unique elements. >>> longest_unique_subarray_length([1, 2, 1, 3, 4, 2, 5], [(1, 3), (2, 7), (4, 6)]) [2, 4, 3] >>> longest_unique_subarray_length([1, 2, 3, 4, 5], [(1, 5), (2, 4)]) [5, 3]","solution":"def longest_unique_subarray_length(arr, queries): def max_unique_in_range(l, r): seen = set() max_len = 0 current_len = 0 for i in range(l, r + 1): if arr[i] in seen: max_len = max(max_len, current_len) seen = set() current_len = 0 seen.add(arr[i]) current_len += 1 return max(max_len, current_len) results = [] for l, r in queries: results.append(max_unique_in_range(l - 1, r - 1)) return results"},{"question":"from typing import List def maxPreferenceScore(nums: List[int], k: int) -> int: Select \`k\` non-adjacent items from \`nums\` such that their preference scores have the maximum possible sum. Parameters: nums (List[int]): A list of integers representing the preference scores. k (int): The number of items to select. Returns: int: The maximum possible sum of the preference scores of the selected items. Examples: >>> maxPreferenceScore([1, 2, 3, 1, 2, 3], 2) 6 >>> maxPreferenceScore([5, 1, 1, 5, 1, 1, 5], 3) 15 >>> maxPreferenceScore([4, 10, 3, 1, 5], 2) 15","solution":"from typing import List import heapq def maxPreferenceScore(nums: List[int], k: int) -> int: # Create a max-heap with (-score, index) tuples max_heap = [(-nums[i], i) for i in range(len(nums))] heapq.heapify(max_heap) selected_scores = [] taken_indices = set() while len(selected_scores) < k: # Pop the maximum element from the heap (note the negation) score, index = heapq.heappop(max_heap) score = -score # Check if adjacent indices have been taken if index not in taken_indices and (index - 1) not in taken_indices and (index + 1) not in taken_indices: selected_scores.append(score) taken_indices.add(index) return sum(selected_scores)"},{"question":"def max_healing_effectiveness(T: int, test_cases: list) -> list: Determine the maximum healing effectiveness the hero can achieve by picking the best subarray. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, list of healing effectiveness) Returns: list: List of maximum healing effectiveness for each test case >>> max_healing_effectiveness(2, [(5, [-1, 2, 3, -4, 5]), (4, [1, 2, 3, 4])]) [6, 10] >>> max_healing_effectiveness(1, [(3, [-2, -3, -1])]) [-1]","solution":"def max_healing_effectiveness(T, test_cases): Returns the maximum healing effectiveness for each test case. Parameters: T (int): Number of test cases test_cases (list of tuples): Each tuple contains (N, list of healing effectiveness) Returns: list: List of maximum healing effectiveness for each test case results = [] for case in test_cases: N, effectiveness = case # Using Kadane's Algorithm to find the maximum subarray sum max_current = max_global = effectiveness[0] for i in range(1, N): max_current = max(effectiveness[i], max_current + effectiveness[i]) if max_current > max_global: max_global = max_current results.append(max_global) return results"},{"question":"def can_reach_treasure(n: int, m: int, grid: List[str]) -> str: Determines if there is a path from the top-left corner to the treasure (X) in the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: \\"YES\\" if there is a path from the top-left corner to the treasure, otherwise \\"NO\\" Examples: >>> can_reach_treasure(4, 4, [\\"....\\", \\"T.TT\\", \\"..T.\\", \\"...X\\"]) 'YES' >>> can_reach_treasure(4, 4, [\\"....\\", \\"TTTT\\", \\"...T\\", \\"...X\\"]) 'NO' pass def test_sample_input_1(): n, m = 4, 4 grid = [ \\"....\\", \\"T.TT\\", \\"..T.\\", \\"...X\\" ] assert can_reach_treasure(n, m, grid) == \\"YES\\" def test_sample_input_2(): n, m = 4, 4 grid = [ \\"....\\", \\"TTTT\\", \\"...T\\", \\"...X\\" ] assert can_reach_treasure(n, m, grid) == \\"NO\\" def test_no_treasure(): n, m = 4, 4 grid = [ \\"....\\", \\".TTT\\", \\"..T.\\", \\"...T\\" ] assert can_reach_treasure(n, m, grid) == \\"NO\\" def test_start_on_treasure(): n, m = 1, 1 grid = [ \\"X\\" ] assert can_reach_treasure(n, m, grid) == \\"YES\\" def test_direct_path(): n, m = 3, 3 grid = [ \\"...\\", \\"X..\\", \\"...\\" ] assert can_reach_treasure(n, m, grid) == \\"YES\\"","solution":"def can_reach_treasure(n, m, grid): Determines if there is a path from the top-left corner to the treasure (X) in the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: List of strings representing the grid :return: \\"YES\\" if there is a path from the top-left corner to the treasure, otherwise \\"NO\\" from collections import deque # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def is_within_bounds(x, y): return 0 <= x < n and 0 <= y < m def is_empty_or_treasure(x, y): return grid[x][y] == '.' or grid[x][y] == 'X' # BFS to find path from (0, 0) to 'X' queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if grid[x][y] == 'X': return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_within_bounds(nx, ny) and is_empty_or_treasure(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\" # Use this to verify function manually # n, m = 4, 4 # grid = [ # \\"....\\", # \\"T.TT\\", # \\"..T.\\", # \\"...X\\" # ] # print(can_reach_treasure(n, m, grid)) # Should return \\"YES\\""},{"question":"from typing import List def can_form_sequence(strings: List[str]) -> bool: Determine if the given list of strings can be rearranged to form a sequence such that each successive string differs from the previous one by exactly one character. >>> can_form_sequence([\\"abc\\", \\"bbc\\", \\"bac\\"]) True >>> can_form_sequence([\\"abc\\", \\"def\\", \\"ghi\\"]) False >>> can_form_sequence([\\"abc\\"]) True >>> can_form_sequence([\\"abc\\", \\"abd\\"]) True >>> can_form_sequence([\\"abc\\", \\"xyz\\"]) False >>> can_form_sequence([\\"abc\\", \\"abd\\", \\"acd\\", \\"bcd\\"]) True >>> can_form_sequence([\\"aaa\\", \\"bbb\\", \\"ccc\\", \\"ddd\\"]) False >>> can_form_sequence([\\"abc\\", \\"acc\\", \\"adc\\", \\"bcc\\", \\"bbc\\", \\"bdc\\", \\"ccc\\"]) True","solution":"from itertools import permutations def differ_by_one_char(s1, s2): Check if two strings differ by exactly one character. count_diff = 0 for a, b in zip(s1, s2): if a != b: count_diff += 1 if count_diff > 1: return False return count_diff == 1 def can_form_sequence(strings): Determine if the given list of strings can be rearranged to form a sequence such that each successive string differs from the previous one by exactly one character. for perm in permutations(strings): if all(differ_by_one_char(perm[i], perm[i+1]) for i in range(len(perm)-1)): return True return False"},{"question":"from typing import List def find_max_product(arr: List[int]) -> int: Returns the maximum product of any two integers in the array. >>> find_max_product([1, 2, 3, 4]) 12 >>> find_max_product([-10, -10, 5, 2]) 100 >>> find_max_product([0, 1, 2, 3]) 6","solution":"from typing import List def find_max_product(arr: List[int]) -> int: Returns the maximum product of any two integers in the array. if len(arr) < 2: raise ValueError(\\"Array must have at least two elements\\") # Sort the array arr.sort() # The maximum product can either be from the two largest numbers # or from the two smallest numbers (in case they are both negative). return max(arr[0] * arr[1], arr[-1] * arr[-2])"},{"question":"def restore_p(n, c): Given the array c, restore and return the array p. >>> restore_p(4, [4, 7, 8, 9]) [4, 3, 1, 1] >>> restore_p(2, [2, 4]) [2, 2] >>> restore_p(3, [1, 2, 4]) [1, 1, 2] import pytest def test_restore_p(): assert restore_p(4, [4, 7, 8, 9]) == [4, 3, 1, 1] assert restore_p(2, [2, 4]) == [2, 2] assert restore_p(3, [1, 2, 4]) == [1, 1, 2] assert restore_p(1, [1]) == [1] assert restore_p(5, [5, 10, 15, 20, 25]) == [5, 5, 5, 5, 5] assert restore_p(4, [4, 8, 8, 9]) == [4, 4, 0, 1] def test_solve_monocarp(): test_cases = [ (4, [4, 7, 8, 9]), (2, [2, 4]), (3, [1, 2, 4]) ] expected_output = [ [4, 3, 1, 1], [2, 2], [1, 1, 2] ] assert solve_monocarp(test_cases) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"def restore_p(n, c): Given array c, this function restores and returns array p. p = [0] * n p[0] = c[0] for i in range(1, n): p[i] = c[i] - max(c[:i]) return p def solve_monocarp(test_cases): results = [] for n, c in test_cases: results.append(restore_p(n, c)) return results"},{"question":"def min_distance(s: str, t: str) -> int: Computes the minimum number of operations required to convert string s into string t. Operations include insert, delete, and replace a character. Parameters: - s (str): The original string to be converted. - t (str): The target string to convert to. Returns: - int: The minimum number of operations required. Examples: >>> min_distance(\\"abc\\", \\"yabd\\") 2 >>> min_distance(\\"intention\\", \\"execution\\") 5","solution":"def min_distance(s, t): Computes the minimum number of operations required to convert string s into string t. Operations include insert, delete, and replace a character. m, n = len(s), len(t) # Create a dp array where dp[i][j] represents the min operations to convert s[:i] to t[:j] dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the dp array for i in range(m + 1): dp[i][0] = i # Deleting all characters from s to match an empty t for j in range(n + 1): dp[0][j] = j # Inserting all characters of t to match an empty s # Fill the dp array for i in range(1, m + 1): for j in range(1, n + 1): if s[i-1] == t[j-1]: dp[i][j] = dp[i-1][j-1] # Characters match, no new operation else: dp[i][j] = 1 + min(dp[i-1][j], # Deletion dp[i][j-1], # Insertion dp[i-1][j-1]) # Replacement return dp[m][n]"},{"question":"def find_number_in_canvas(n: int, m: int, x: int, y: int) -> int: Given a canvas of dimensions n x m, find the number at the (x, y) position. The canvas is filled in an alternating pattern: 1. Left to right for odd rows. 2. Top to bottom for even rows. 3. Left to right for 3rd rows, and so on. 4. Bottom to top for 4th rows, etc. Arguments: n -- number of rows. m -- number of columns. x -- the row number to find the value for. y -- the column number to find the value for. Returns: The value at the (x, y) position. >>> find_number_in_canvas(3, 3, 2, 2) 5 >>> find_number_in_canvas(3, 3, 1, 1) 1 >>> find_number_in_canvas(3, 3, 3, 3) 9 >>> find_number_in_canvas(4, 4, 2, 4) 5 >>> find_number_in_canvas(5, 3, 2, 3) 4 >>> find_number_in_canvas(10, 10, 10, 1) 100","solution":"def find_number_in_canvas(n, m, x, y): Given a canvas of dimensions n x m, find the number at the (x, y) position. The canvas is filled in an alternating pattern: 1. Left to right for odd rows. 2. Top to bottom for even rows. 3. Left to right for 3rd rows, and so on. 4. Bottom to top for 4th rows, etc. Arguments: n -- number of rows. m -- number of columns. x -- the row number to find the value for. y -- the column number to find the value for. Returns: The value at the (x, y) position. number = 0 if x % 2 != 0: # if x is odd number = (x - 1) * m + y else: # if x is even number = x * m - y + 1 return number"},{"question":"def row_and_column_sums(n, m, matrix): Given a matrix A of dimensions n x m, find the sum of each row and each column. Parameters: n (int): number of rows m (int): number of columns matrix (list of list of int): 2D list representing the matrix Returns: tuple: (list of row sums, list of column sums) Example: >>> row_and_column_sums(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9], ... ]) ([6, 15, 24], [12, 15, 18]) >>> row_and_column_sums(1, 5, [ ... [1, 2, 3, 4, 5], ... ]) ([15], [1, 2, 3, 4, 5])","solution":"def row_and_column_sums(n, m, matrix): Calculates the sum of each row and column in a given n x m matrix. Parameters: n (int): number of rows m (int): number of columns matrix (list of list of int): 2D list representing the matrix Returns: tuple: (list of row sums, list of column sums) row_sums = [sum(row) for row in matrix] column_sums = [sum(matrix[i][j] for i in range(n)) for j in range(m)] return row_sums, column_sums"},{"question":"def isValidParentheses(s: str) -> bool: Determine if the input string containing only parentheses is valid. :param s: str - input string containing only '(' and ')' :return: bool - True if the string is valid, False otherwise >>> isValidParentheses(\\"()\\") True >>> isValidParentheses(\\")(()\\") False >>> isValidParentheses(\\"(()))\\") False >>> isValidParentheses(\\"(())\\") True >>> isValidParentheses(\\"()()\\") True >>> isValidParentheses(\\"\\") True >>> isValidParentheses(\\"(((((((((())))))))))\\") True >>> isValidParentheses(\\"(()((())()))\\") True >>> isValidParentheses(\\"(()\\") False >>> isValidParentheses(\\")\\") False","solution":"def isValidParentheses(s): Determine if the input string containing only parentheses is valid. :param s: str - input string containing only '(' and ')' :return: bool - True if the string is valid, False otherwise stack = [] # Dictionary to match opening and closing parentheses parens_map = {')': '('} for char in s: if char == '(': stack.append(char) elif char == ')': # If stack is empty or top of stack does not match, return False if not stack or stack[-1] != parens_map[char]: return False stack.pop() # If stack is empty, all parentheses were matched correctly return not stack"},{"question":"def count_distinct_palindromic_substrings(T: int, strings: List[str]) -> List[int]: Given a string \`str\`, the task is to return a single integer denoting the number of distinct palindromic substrings present in the string. Parameters: T (int): The number of test cases. strings (List[str]): A list of strings as test cases. Returns: List[int]: A list containing the number of distinct palindromic substrings for each string. Examples: >>> count_distinct_palindromic_substrings(2, [\\"abaaa\\", \\"geek\\"]) [5, 4] >>> count_distinct_palindromic_substrings(1, [\\"aaaa\\"]) [4] from typing import List def test_count_distinct_palindromic_substrings(): assert count_distinct_palindromic_substrings(3, [\\"a\\", \\"b\\", \\"c\\"]) == [1, 1, 1] assert count_distinct_palindromic_substrings(2, [\\"abaaa\\", \\"geek\\"]) == [5, 4] assert count_distinct_palindromic_substrings(2, [\\"abc\\", \\"aaa\\"]) == [3, 3] assert count_distinct_palindromic_substrings(1, [\\"abcdefg\\"]) == [7] assert count_distinct_palindromic_substrings(1, [\\"aaaa\\"]) == [4] assert count_distinct_palindromic_substrings(1, [\\"\\"]) == [0]","solution":"def count_distinct_palindromic_substrings(T, strings): def is_palindrome(s): return s == s[::-1] results = [] for s in strings: palindromes = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): palindromes.add(substring) results.append(len(palindromes)) return results"},{"question":"def furthest_frog_leap(f: int, frog_data: List[Tuple[int, int]]) -> int: Returns the furthest point any frog can reach with one leap. :param f: Number of frogs (int) :param frog_data: List of tuples containing the position and jumping power of each frog (list of tuples) :return: The maximum distance a frog can jump (int) >>> furthest_frog_leap(3, [(2, 4), (7, 5), (10, 2)]) == 12 >>> furthest_frog_leap(2, [(5, 3), (8, 6)]) == 14 >>> furthest_frog_leap(1, [(1, 1)]) == 2 >>> furthest_frog_leap(3, [(1000, 100), (500, 50), (200, 150)]) == 1100 >>> furthest_frog_leap(3, [(10, 5), (10, 10), (10, 15)]) == 25 >>> furthest_frog_leap(3, [(1, 1), (2, 1), (3, 1)]) == 4","solution":"def furthest_frog_leap(f, frog_data): Returns the furthest point any frog can reach with one leap. :param f: Number of frogs (int) :param frog_data: List of tuples containing the position and jumping power of each frog (list of tuples) :return: The maximum distance a frog can jump (int) max_distance = 0 for pos, jump in frog_data: current_distance = pos + jump if current_distance > max_distance: max_distance = current_distance return max_distance"},{"question":"def reorder_sentence_by_word_length(sentence: str) -> str: Reorders the words in the sentence by their length in non-decreasing order. If two words have the same length, their order remains unchanged. >>> reorder_sentence_by_word_length(\\"this is a test sentence\\") == \\"a is this test sentence\\" >>> reorder_sentence_by_word_length(\\"sorting words by length is fun\\") == \\"by is fun words length sorting\\"","solution":"def reorder_sentence_by_word_length(sentence): Reorders the words in the sentence by their length in non-decreasing order. If two words have the same length, their order remains unchanged. :param sentence: str - input sentence of words separated by spaces :return: str - sentence with words reordered by length words = sentence.split() words.sort(key=len) return ' '.join(words)"},{"question":"def min_removals_to_palindrome(s: str) -> int: Given a string s, determine the minimum number of characters to remove to make it a palindrome. >>> min_removals_to_palindrome(\\"abca\\") 1 >>> min_removals_to_palindrome(\\"racecar\\") 0 >>> min_removals_to_palindrome(\\"abcdef\\") 5","solution":"def min_removals_to_palindrome(s): Returns the minimum number of characters to remove from s to make it a palindrome. def lcs(X, Y): m = len(X) n = len(Y) L = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: L[i][j] = 0 elif X[i - 1] == Y[j - 1]: L[i][j] = L[i - 1][j - 1] + 1 else: L[i][j] = max(L[i - 1][j], L[i][j - 1]) return L[m][n] reverse_s = s[::-1] lcs_length = lcs(s, reverse_s) return len(s) - lcs_length"},{"question":"def can_distribute_marbles_evenly(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determines if marbles can be evenly distributed among jars. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers M (number of marbles) and J (number of jars). Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. >>> can_distribute_marbles_evenly(3, [(10, 2), (15, 4), (100, 5)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> can_distribute_marbles_evenly(1, [(1, 1)]) [\\"YES\\"] >>> can_distribute_marbles_evenly(1, [(1000000000, 10)]) [\\"YES\\"] >>> can_distribute_marbles_evenly(1, [(7, 3)]) [\\"NO\\"] >>> can_distribute_marbles_evenly(1, [(999999937, 2)]) [\\"NO\\"]","solution":"def can_distribute_marbles_evenly(t, test_cases): Determines if marbles can be evenly distributed among jars. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers M (number of marbles) and J (number of jars). Returns: list of str: List containing \\"YES\\" or \\"NO\\" for each test case. results = [] for m, j in test_cases: if m % j == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def countBuildingsWithSunlight(n: int, heights: List[int]) -> int: Returns the number of buildings that receive sunlight. >>> countBuildingsWithSunlight(6, [3, 2, 4, 5, 1, 7]) 4 >>> countBuildingsWithSunlight(5, [1, 2, 3, 4, 5]) 5 >>> countBuildingsWithSunlight(5, [5, 4, 3, 2, 1]) 1 >>> countBuildingsWithSunlight(7, [1, 3, 2, 4, 2, 5, 2]) 4 >>> countBuildingsWithSunlight(1, [5]) 1 >>> countBuildingsWithSunlight(4, [3, 3, 3, 3]) 1 >>> countBuildingsWithSunlight(0, []) 0 pass","solution":"def countBuildingsWithSunlight(n, heights): Returns the number of buildings that receive sunlight. Parameters: n (int): Number of buildings. heights (List[int]): Heights of the buildings. Returns: int: Number of buildings that receive sunlight. if n == 0: return 0 max_height = heights[0] count = 1 for i in range(1, n): if heights[i] > max_height: count += 1 max_height = heights[i] return count"},{"question":"MOD = 10**9 + 7 def compute_prefix_products(arr): Compute prefix products for the array. >>> compute_prefix_products([1, 2, 3, 4, 5]) [1, 1, 2, 6, 24, 120] prefix_products = [1] * (len(arr) + 1) def range_product(L, R, prefix_products): Compute range product from index L to R using prefix products. >>> range_product(1, 3, [1, 1, 2, 6, 24, 120]) 6 def process_queries(N, arr, Q, queries): Process the queries to find the product of sublist elements from L to R modulo (10^9 + 7). >>> process_queries(5, [1, 2, 3, 4, 5], 3, [(1, 3), (2, 4), (1, 5)]) [6, 24, 120]","solution":"MOD = 10**9 + 7 def compute_prefix_products(arr): prefix_products = [1] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_products[i] = (prefix_products[i-1] * arr[i-1]) % MOD return prefix_products def range_product(L, R, prefix_products): return (prefix_products[R] * pow(prefix_products[L-1], MOD-2, MOD)) % MOD def process_queries(N, arr, Q, queries): prefix_products = compute_prefix_products(arr) results = [] for L, R in queries: results.append(range_product(L, R, prefix_products)) return results"},{"question":"def min_watering_uses(n, m, garden): Returns the minimum number of uses of the watering can required to water all the plants in the garden. Parameters: n (int): The number of rows in the garden. m (int): The number of columns in the garden. garden (list of list of str): The garden grid, where each element is either '.' or 'P'. Returns: int: The minimum number of watering uses >>> min_watering_uses(3, 3, [['P', 'P', 'P'], ['.', '.', '.'], ['.', '.', '.']]) 1 >>> min_watering_uses(3, 3, [['P', '.', '.'], ['P', '.', '.'], ['P', '.', '.']]) 1 >>> min_watering_uses(3, 3, [['P', '.', '.'], ['.', 'P', '.'], ['.', '.', 'P']]) 3","solution":"def min_watering_uses(n, m, garden): Returns the minimum number of uses of the watering can required to water all the plants in the garden. Parameters: n (int): The number of rows in the garden. m (int): The number of columns in the garden. garden (list of list of str): The garden grid, where each element is either '.' or 'P'. row_has_plant = [any(cell == 'P' for cell in row) for row in garden] col_has_plant = [any(garden[row][col] == 'P' for row in range(n)) for col in range(m)] rows_with_plants = sum(row_has_plant) cols_with_plants = sum(col_has_plant) return min(rows_with_plants, cols_with_plants)"},{"question":"def min_modifications_to_k_distinct(t: int, test_cases: List[Tuple[str, int]]) -> List[int]: Determine the minimum number of character modifications (additions or removals) required to make the number of distinct characters in a string equal to k. >>> t = 3 >>> test_cases = [(\\"abc\\", 2), (\\"a\\", 2), (\\"xyz\\", 5)] >>> min_modifications_to_k_distinct(t, test_cases) [1, 1, 2] >>> t = 2 >>> test_cases = [(\\"aaaa\\", 1), (\\"bbbb\\", 3)] >>> min_modifications_to_k_distinct(t, test_cases) [0, 2] >>> t = 2 >>> test_cases = [(\\"abcd\\", 2), (\\"efgh\\", 4)] >>> min_modifications_to_k_distinct(t, test_cases) [2, 0] >>> t = 2 >>> test_cases = [(\\"abcde\\", 5), (\\"xyz\\", 3)] >>> min_modifications_to_k_distinct(t, test_cases) [0, 0] >>> t = 2 >>> test_cases = [(\\"a\\", 1), (\\"a\\", 3)] >>> min_modifications_to_k_distinct(t, test_cases) [0, 2]","solution":"def min_modifications_to_k_distinct(t, test_cases): results = [] for case in test_cases: s, k = case[0], case[1] distinct_chars = len(set(s)) if distinct_chars == k: results.append(0) elif distinct_chars > k: results.append(distinct_chars - k) else: results.append(k - distinct_chars) return results"},{"question":"def longest_subsequence_length(n: int, arr: List[int]) -> int: Given an array of integers, find the longest subsequence such that every two consecutive elements differ by 1. Args: n (int): The number of elements in the array. arr (List[int]): The array of integers. Returns: int: The length of the longest subsequence where any two consecutive integers differ by exactly 1. >>> process_input(\\"7n10 9 4 5 4 8 6\\") 3 >>> process_input(\\"5n1 2 3 4 5\\") 5 >>> process_input(\\"4n7 7 7 7\\") 1 >>> process_input(\\"4n1 3 5 7\\") 1 >>> process_input(\\"3n1000000 999999 1000001\\") 2 >>> process_input(\\"5n-1 -2 -3 -4 -5\\") 5 >>> process_input(\\"6n-1 0 1 -2 2 -3\\") 4 >>> process_input(\\"1n5\\") 1 >>> process_input(\\"2n3 4\\") 2 >>> process_input(\\"2n1 3\\") 1 def process_input(data: str) -> int: Processes the input string to extract the integer array details and calls the function to get the length of the longest subsequence. Args: data (str): The input string containing the array details. Returns: int: The length of the longest subsequence where any two consecutive integers differ by exactly 1.","solution":"def longest_subsequence_length(n, arr): if n == 0: return 0 # Dictionary to store the length of the longest subsequence ending at each value. dp = {} for num in arr: if num - 1 in dp: dp[num] = max(dp.get(num, 0), dp[num - 1] + 1) if num + 1 in dp: dp[num] = max(dp.get(num, 0), dp[num + 1] + 1) dp[num] = max(dp.get(num, 0), 1) # Initialize/handle the current number case. return max(dp.values()) # Function to process the input data def process_input(data): lines = data.strip().split(\\"n\\") n = int(lines[0]) arr = list(map(int, lines[1].strip().split())) return longest_subsequence_length(n, arr)"},{"question":"def multiply_strings(num1: str, num2: str) -> str: Multiply two non-negative integers represented as strings and returns the product as a string. Do not use any built-in BigInteger library or directly convert the strings to integers. >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\" >>> multiply_strings(\\"2\\", \\"3\\") \\"6\\" >>> multiply_strings(\\"0\\", \\"0\\") \\"0\\"","solution":"def multiply_strings(num1: str, num2: str) -> str: if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0')) p1, p2 = i + j, i + j + 1 total = product + result[p2] result[p1] += total // 10 result[p2] = total % 10 result_str = ''.join(map(str, result)) return result_str.lstrip('0')"},{"question":"from typing import List def max_subgrid_sum(n: int, grid: List[List[int]], k: int) -> int: Calculate the maximum sum of a k x k subgrid within an n x n grid. >>> max_subgrid_sum(4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 2) 54 >>> max_subgrid_sum(3, [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], 2) -12 >>> max_subgrid_sum(4, [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]], 3) -9 >>> max_subgrid_sum(2, [[1, 2], [3, 4]], 1) 4 >>> max_subgrid_sum(2, [[1, 2], [3, 4]], 2) 10","solution":"from typing import List def max_subgrid_sum(n: int, grid: List[List[int]], k: int) -> int: # Initialize a variable to keep track of the maximum sum max_sum = float('-inf') # Create the prefix sum array prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] # Fill the prefix sum array for i in range(n): for j in range(n): prefix_sum[i + 1][j + 1] = grid[i][j] + prefix_sum[i + 1][j] + prefix_sum[i][j + 1] - prefix_sum[i][j] # Slide over each possible k x k subgrid and calculate the sum for i in range(k, n + 1): for j in range(k, n + 1): current_sum = prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_split_into_three_equal_sum_subarrays(nums): Determines if the array can be split into three non-empty contiguous subarrays with equal sum. >>> can_split_into_three_equal_sum_subarrays([1, 2, 1, 2, 1, 2]) \\"Yes\\" >>> can_split_into_three_equal_sum_subarrays([1, 1, 1, 1, 1]) \\"No\\"","solution":"def can_split_into_three_equal_sum_subarrays(nums): Determines if the array can be split into three non-empty contiguous subarrays with equal sum. total_sum = sum(nums) # If the total sum is not divisible by 3, we cannot split into 3 equal parts if total_sum % 3 != 0: return \\"No\\" target_sum = total_sum // 3 current_sum = 0 splits = 0 for num in nums: current_sum += num if current_sum == target_sum: splits += 1 current_sum = 0 # We need at least 3 splits to form 3 subarrays with the target_sum return \\"Yes\\" if splits >= 3 else \\"No\\""},{"question":"def sort_books(books): Sorts the given list of books based on the described criteria: 1. Primary sorting by book category in descending order. 2. Secondary sorting by book ID in ascending order within the same category. Args: books (list of tuple): A list of books where each book is represented as a tuple (category, id). Returns: list of tuple: A sorted list of books based on the specified criteria.","solution":"def sort_books(books): Sorts the given list of books based on the described criteria: 1. Primary sorting by book category in descending order. 2. Secondary sorting by book ID in ascending order within the same category. Args: books (list of tuple): A list of books where each book is represented as a tuple (category, id). Returns: list of tuple: A sorted list of books based on the specified criteria. # Sort books first by category in descending order, then by id in ascending order sorted_books = sorted(books, key=lambda x: (-x[0], x[1])) return sorted_books"},{"question":"def count_pairs(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the number of pairs (i, j) such that 1 ≤ i < j ≤ N and (B[i] + B[j]) % K == 0. Args: T (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): List of test cases. Each test case is a tuple where the first element is a tuple (N, K) and the second element is a list of N integers. Returns: List[int]: List of results, each result corresponding to a test case. Example: >>> T = 2 >>> test_cases = [((5, 3), [1, 2, 3, 4, 5]), ((4, 2), [2, 4, 6, 8])] >>> count_pairs(T, test_cases) [4, 6] from solution import count_pairs def test_count_pairs_sample_input(): T = 2 test_cases = [ [(5, 3), [1, 2, 3, 4, 5]], [(4, 2), [2, 4, 6, 8]], ] assert count_pairs(T, test_cases) == [4, 6] def test_count_pairs_no_pairs(): T = 1 test_cases = [ [(3, 10), [1, 2, 3]], ] assert count_pairs(T, test_cases) == [0] def test_count_pairs_all_divisible(): T = 1 test_cases = [ [(4, 2), [2, 2, 2, 2]], ] assert count_pairs(T, test_cases) == [6] def test_count_pairs_varied_numbers(): T = 1 test_cases = [ [(5, 5), [10, 20, 30, 40, 50]], ] assert count_pairs(T, test_cases) == [10] def test_count_pairs_single_pair(): T = 1 test_cases = [ [(2, 2), [1, 1]], ] assert count_pairs(T, test_cases) == [1]","solution":"def count_pairs(T, test_cases): results = [] for t in range(T): N, K = test_cases[t][0] B = test_cases[t][1] count = 0 for i in range(N): for j in range(i + 1, N): if (B[i] + B[j]) % K == 0: count += 1 results.append(count) return results"},{"question":"def max_non_overlapping_events(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of non-overlapping events that can be attended for each test case. Args: test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases where each test case consists of an integer \`n\` (the number of events) and a list of tuples representing the start and end times of events. Returns: List[int]: List of integers where each integer represents the maximum number of non-overlapping events for each test case. pass def process_input_output(input_data: str) -> None: Helper function to process input and output for the max_non_overlapping_events function. Args: input_data (str): The input data as a single string to be parsed and passed to the max_non_overlapping_events function. Example: >>> input_data = \\"2n3n1 5n2 6n8 10n4n1 3n2 4n3 5n8 9\\" >>> process_input_output(input_data) 2 3 pass # Test functions def test_max_non_overlapping_events(): input_data = 2 3 1 5 2 6 8 10 4 1 3 2 4 3 5 8 9 expected_output = [2, 3] import io import sys captured_output = io.StringIO() sys.stdout = captured_output process_input_output(input_data) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split(\\"n\\") output = [int(line.strip()) for line in output] assert output == expected_output def test_no_events(): input_data = 1 0 expected_output = [0] import io import sys captured_output = io.StringIO() sys.stdout = captured_output process_input_output(input_data) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split(\\"n\\") output = [int(line.strip()) for line in output] assert output == expected_output def test_single_event(): input_data = 1 1 0 1 expected_output = [1] import io import sys captured_output = io.StringIO() sys.stdout = captured_output process_input_output(input_data) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split(\\"n\\") output = [int(line.strip()) for line in output] assert output == expected_output def test_all_overlapping_events(): input_data = 1 3 1 4 2 5 3 6 expected_output = [1] import io import sys captured_output = io.StringIO() sys.stdout = captured_output process_input_output(input_data) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split(\\"n\\") output = [int(line.strip()) for line in output] assert output == expected_output","solution":"def max_non_overlapping_events(test_cases): results = [] for n, events in test_cases: # Sort events by end time events.sort(key=lambda x: x[1]) count = 0 last_end = -1 for start, end in events: if start >= last_end: count += 1 last_end = end results.append(count) return results # Helper function to format input and output for the problem def process_input_output(input_data): input_lines = input_data.strip().split(\\"n\\") T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(input_lines[index]) events = [] for i in range(n): start, end = map(int, input_lines[index + 1 + i].split()) events.append((start, end)) test_cases.append((n, events)) index += n + 1 results = max_non_overlapping_events(test_cases) for result in results: print(result)"},{"question":"from typing import List def canThreePartsEqualSum(arr: List[int]) -> bool: Determine if it's possible to split an array of integers into three contiguous subarrays such that the sum of the elements in each subarray is equal. >>> canThreePartsEqualSum([0,2,1,-6,6,-7,9,1,2,0,1]) True >>> canThreePartsEqualSum([0,2,1,-6,6,7,9,-1,2,0,1]) False >>> canThreePartsEqualSum([3,3,6,5,-2,2,5,1,-9,4]) True","solution":"from typing import List def canThreePartsEqualSum(arr: List[int]) -> bool: total_sum = sum(arr) if total_sum % 3 != 0: return False target_sum = total_sum // 3 current_sum, parts_found = 0, 0 for num in arr: current_sum += num if current_sum == target_sum: parts_found += 1 current_sum = 0 if parts_found == 2: return True return False"},{"question":"def reverse_words(sentence: str) -> str: Returns the sentence with all its words reversed but keeping the original word order. >>> reverse_words(\\"Hello World\\") \\"olleH dlroW\\" >>> reverse_words(\\"Welcome to the coding assessment\\") \\"emocleW ot eht gnidoc tnemssessa\\" >>> reverse_words(\\"Reverse the words\\") \\"esreveR eht sdrow\\"","solution":"def reverse_words(sentence): Returns the sentence with all its words reversed but keeping the original word order. words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def has_pair_with_difference(arr, k): Check if there exist two indices i and j such that abs(arr[i] - arr[j]) == k. >>> has_pair_with_difference([1, 5, 3, 4, 2], 2) \\"Yes\\" >>> has_pair_with_difference([7, 7, 7, 7], 0) \\"Yes\\" >>> has_pair_with_difference([8, 12, 16, 4, 0, 20], 4) \\"Yes\\" >>> has_pair_with_difference([1, 2, 3, 4, 5], 10) \\"No\\" >>> has_pair_with_difference([-1, -2, -3, -4], 1) \\"Yes\\" def process_test_cases(test_cases): Process multiple test cases to check if pairs with given difference exist. >>> process_test_cases([(5, 2, [1, 5, 3, 4, 2]), (4, 0, [7, 7, 7, 7]), (6, 4, [8, 12, 16, 4, 0, 20]), (3, 5, [1, 2, 8]), (5, 10, [1, 2, 3, 4, 5])]) ['Yes', 'Yes', 'Yes', 'No', 'No'] results = [] for case in test_cases: n, k, arr = case results.append(has_pair_with_difference(arr, k)) return results","solution":"def has_pair_with_difference(arr, k): Check if there exist two indices i and j such that abs(arr[i] - arr[j]) == k. num_set = set() for num in arr: if (num + k) in num_set or (num - k) in num_set: return \\"Yes\\" num_set.add(num) return \\"No\\" def process_test_cases(test_cases): results = [] for case in test_cases: n, k, arr = case results.append(has_pair_with_difference(arr, k)) return results"},{"question":"def count_combinations(N: int, X: int, S: int) -> int: You have a deck of cards, numbered from 1 to N. You want to find out in how many ways you can select X cards such that their sum is equal to S. Return the number of possible combinations, where the order of selection does not matter. As the answer can be very large, return it modulo 10^9 + 7. >>> count_combinations(5, 2, 5) 2 >>> count_combinations(6, 3, 10) 3 >>> count_combinations(4, 2, 8) 0","solution":"def count_combinations(N, X, S): MOD = 10**9 + 7 # dp[x][s] will store the number of ways to pick x cards that sum up to s dp = [[0] * (S + 1) for _ in range(X + 1)] dp[0][0] = 1 for n in range(1, N + 1): for x in range(X, 0, -1): for s in range(S, n - 1, -1): dp[x][s] = (dp[x][s] + dp[x - 1][s - n]) % MOD return dp[X][S]"},{"question":"def longest_prefix_suffix(S: str) -> int: Determine the length of the longest prefix of the string \`S\` that is also a suffix and does not overlap. >>> longest_prefix_suffix(\\"abcdabc\\") 3 >>> longest_prefix_suffix(\\"aaaaa\\") 4 >>> longest_prefix_suffix(\\"abcab\\") 2 >>> longest_prefix_suffix(\\"a\\") 0 >>> longest_prefix_suffix(\\"\\") 0 >>> longest_prefix_suffix(\\"ababab\\") 4 >>> longest_prefix_suffix(\\"abcababcab\\") 5 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process \`T\` number of test cases to determine the length of the longest prefix of each string \`S\` that is also a suffix and does not overlap. >>> process_test_cases(3, [\\"abcdabc\\", \\"aaaaa\\", \\"abcab\\"]) [3, 4, 2] >>> process_test_cases(2, [\\"a\\", \\"\\"]) [0, 0] >>> process_test_cases(3, [\\"ababab\\", \\"abcababcab\\", \\"xyzxyz\\"]) [4, 5, 3]","solution":"def longest_prefix_suffix(S): Function to determine the length of the longest prefix of string \`S\` that is also a suffix and does not overlap. if not S: return 0 n = len(S) # Creating LPS (Longest Prefix Suffix) array for pattern S lps = [0] * n # length of the previous longest prefix suffix length = 0 # the loop calculates lps[i] for i from 1 to n-1 i = 1 while i < n: if S[i] == S[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length-1] else: lps[i] = 0 i += 1 return lps[-1] def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(longest_prefix_suffix(S)) return results"},{"question":"def rotateClockwise(matrix): Rotates the matrix 90 degrees clockwise in-place. >>> rotateClockwise([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotateClockwise([ [1, 2, 3, 4], [5, 6, 7, 8] ]) [ [5, 1], [6, 2], [7, 3], [8, 4] ]","solution":"def rotateClockwise(matrix): Rotates the matrix 90 degrees clockwise in-place. N = len(matrix) M = len(matrix[0]) # Create a new transposed, reversed matrix new_matrix = [[0] * N for _ in range(M)] # Populate the new_matrix for i in range(N): for j in range(M): new_matrix[j][N-1-i] = matrix[i][j] # Copy new_matrix to the original matrix for r in range(M): for c in range(N): if r < len(matrix) and c < len(matrix[0]): matrix[r][c] = new_matrix[r][c] # Reshape original matrix if needed if len(matrix) != len(new_matrix): matrix[:] = new_matrix return matrix"},{"question":"def calculate_average_rating(movies: dict) -> dict: Calculate the average rating for each movie and round it to the nearest whole number. If a movie has no ratings, return 0 as the average rating. :param movies: A dictionary where keys are movie titles and values are lists of ratings. :return: A dictionary where keys are movie titles and values are average ratings. >>> calculate_average_rating({\\"Inception\\": [10, 9, 8, 9, 10]}) {'Inception': 9} >>> calculate_average_rating({ ... \\"Inception\\": [10, 9, 8, 9, 10], ... \\"Interstellar\\": [10, 10, 9], ... \\"The Matrix\\": [8, 8, 9, 8, 7, 8], ... \\"No Rating Movie\\": [] ... }) {'Inception': 9, 'Interstellar': 10, 'The Matrix': 8, 'No Rating Movie': 0} >>> calculate_average_rating({}) {} >>> calculate_average_rating({ ... \\"No Rating Movie 1\\": [], ... \\"No Rating Movie 2\\": [] ... }) {'No Rating Movie 1': 0, 'No Rating Movie 2': 0} >>> calculate_average_rating({\\"One Rating\\": [6]}) {'One Rating': 6}","solution":"def calculate_average_rating(movies): Calculate the average rating for each movie and round it to the nearest whole number. If a movie has no ratings, return 0 as the average rating. :param movies: A dictionary where keys are movie titles and values are lists of ratings. :return: A dictionary where keys are movie titles and values are average ratings. average_ratings = {} for movie, ratings in movies.items(): if ratings: average_ratings[movie] = round(sum(ratings) / len(ratings)) else: average_ratings[movie] = 0 return average_ratings"},{"question":"def num_distributions(n: int) -> int: Calculate the number of valid distributions of n types of cookies where no two adjacent friends receive the same type. Args: n (int): the number of different types of cookies. Returns: int: the number of valid distributions modulo 1,000,000,007. Examples: >>> num_distributions(1) 1 >>> num_distributions(2) 2 >>> num_distributions(3) 6 >>> num_distributions(5) 24 pass from solution import num_distributions def test_num_distributions(): assert num_distributions(1) == 1, \\"Test case 1 failed\\" assert num_distributions(2) == 2, \\"Test case 2 failed\\" assert num_distributions(3) == 6, \\"Test case 3 failed\\" assert num_distributions(4) == 24, \\"Test case 4 failed\\" assert num_distributions(5) == 120, \\"Test case 5 failed\\" assert num_distributions(10) == 3628800 % 1_000_000_007, \\"Test case 6 failed\\" def test_large_n(): assert num_distributions(100000) == 457992974, \\"Test case for n = 100000 failed\\"","solution":"MOD = 1_000_000_007 def num_distributions(n: int) -> int: Calculate the number of valid distributions of n types of cookies where no two adjacent friends receive the same type. if n == 1: return 1 # Using dynamic programming to store results for each sub-problem dp = [0] * n dp[0] = 1 # only one way to distribute 1 cookie type (to only 1 friend) dp[1] = 2 # for 2 cookie types, there are 2 ways: [1, 2] and [2, 1] for i in range(2, n): dp[i] = (i + 1) * dp[i - 1] % MOD return dp[n - 1]"},{"question":"from typing import List, Tuple def calculate_rankings(N: int, players: List[str], M: int, matches_played: List[Tuple[str, int, int, str]], target_player: str) -> List[int]: Calculate the potential rankings of a player after a certain number of rounds in a board game tournament. Args: N (int): The number of players. players (List[str]): The list of player names. M (int): The number of matches played so far. matches_played (List[Tuple[str, int, int, str]]): List of matches played so far. target_player (str): The name of the player whose rankings should be calculated. Returns: List[int]: The possible rankings of the specified player after each remaining match. pass def parse_input(input_str: str) -> Tuple[int, List[str], int, List[Tuple[str, int, int, str]], str]: Parse the input string and returns structured data. Args: input_str (str): The input string containing the tournament details. Returns: Tuple: A tuple containing number of players, list of player names, number of matches played, list of played matches and the target player name. pass # Unit tests def test_calculate_rankings_example(): input_str = 4 ALF BOB CAT DAN 3 ALF 2 - 1 BOB BOB 1 - 1 CAT CAT 0 - 0 DAN ALF N, players, M, matches_played, target_player = parse_input(input_str) expected_output = [1, 2, 3, 4] assert calculate_rankings(N, players, M, matches_played, target_player) == expected_output def test_calculate_rankings_single_player(): input_str = 1 ALF 0 ALF N, players, M, matches_played, target_player = parse_input(input_str) expected_output = [1] assert calculate_rankings(N, players, M, matches_played, target_player) == expected_output def test_calculate_rankings_no_matches_played(): input_str = 3 ALF BOB CAT 0 BOB N, players, M, matches_played, target_player = parse_input(input_str) expected_output = [1, 2, 3] assert calculate_rankings(N, players, M, matches_played, target_player) == expected_output def test_parse_input(): input_str = 4 ALF BOB CAT DAN 3 ALF 2 - 1 BOB BOB 1 - 1 CAT CAT 0 - 0 DAN ALF expected_output = (4, ['ALF', 'BOB', 'CAT', 'DAN'], 3, [ ('ALF', '2', '1', 'BOB'), ('BOB', '1', '1', 'CAT'), ('CAT', '0', '0', 'DAN') ], 'ALF') assert parse_input(input_str) == expected_output","solution":"from collections import defaultdict import itertools def calculate_rankings(N, players, M, matches_played, target_player): # Initialize player data player_data = {player: {'points': 0, 'wins': 0, 'losses': 0, 'draws': 0} for player in players} # Process the matches already played for match in matches_played: player1, score1, score2, player2 = match score1, score2 = int(score1), int(score2) if score1 > score2: player_data[player1]['points'] += 2 player_data[player1]['wins'] += 1 player_data[player2]['losses'] += 1 elif score1 < score2: player_data[player2]['points'] += 2 player_data[player2]['wins'] += 1 player_data[player1]['losses'] += 1 else: player_data[player1]['points'] += 1 player_data[player2]['points'] += 1 player_data[player1]['draws'] += 1 player_data[player2]['draws'] += 1 # Generate the possible remaining matches played_set = set((min(p1, p2), max(p1, p2)) for p1, _, _, p2 in matches_played) all_pairs = {frozenset([p1, p2]) for p1 in players for p2 in players if p1 != p2} remaining_matches = all_pairs - played_set # Simulate all possible outcomes of remaining matches possible_outcomes = [] for outcomes in itertools.product( ['win', 'lose', 'draw'], repeat=len(remaining_matches)): temp_data = {k: v.copy() for k, v in player_data.items()} for outcome, match in zip(outcomes, remaining_matches): player1, player2 = tuple(match) if outcome == 'win': temp_data[player1]['points'] += 2 temp_data[player1]['wins'] += 1 temp_data[player2]['losses'] += 1 elif outcome == 'lose': temp_data[player2]['points'] += 2 temp_data[player2]['wins'] += 1 temp_data[player1]['losses'] += 1 else: # draw temp_data[player1]['points'] += 1 temp_data[player2]['points'] += 1 temp_data[player1]['draws'] += 1 temp_data[player2]['draws'] += 1 possible_outcomes.append(temp_data) # Calculate the rankings for each possible outcome all_rankings = [] for outcome in possible_outcomes: sorted_players = sorted(players, key=lambda p: ( -outcome[p]['points'], outcome[p]['losses'], -outcome[p]['wins'], p)) rank = sorted_players.index(target_player) + 1 all_rankings.append(rank) # Output the distinct rankings in sorted order return sorted(set(all_rankings)) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") N = int(lines[0].strip()) players = [lines[i+1].strip() for i in range(N)] M = int(lines[N+1].strip()) matches_played = [] for i in range(M): match = lines[N+2+i].strip().split() player1, score1, _, score2, player2 = match matches_played.append((player1, score1, score2, player2)) target_player = lines[N+2+M].strip() return N, players, M, matches_played, target_player"},{"question":"def final_positions(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines the final positions in the queue after each person tries to move forward. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of test cases where each test case is a tuple containing the number of people (N) and their initial positions. Returns: List[str]: List of space-separated strings representing the final positions in the queue for each test case. >>> final_positions(1, [(5, [3, 9, 7, 1, 5])]) ['1 3 5 7 9'] >>> final_positions(1, [(4, [10, 3, 7, 5])]) ['3 5 7 10'] >>> final_positions(1, [(6, [1, 2, 3, 4, 5, 6])]) ['1 2 3 4 5 6'] >>> final_positions(1, [(3, [1, 2, 3])]) ['1 2 3'] >>> final_positions(1, [(4, [4, 3, 2, 1])]) ['1 2 3 4'] >>> final_positions(1, [(1, [9])]) ['9'] >>> final_positions(1, [(100000, list(range(1, 100001))[::-1])]) == [\\" \\".join(map(str, range(1, 100001)))] [True]","solution":"def final_positions(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] positions = test_cases[i][1] sorted_positions = sorted(positions) results.append(\\" \\".join(map(str, sorted_positions))) return results"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string s. >>> longest_palindromic_substring_length(\\"\\") == 0 >>> longest_palindromic_substring_length(\\"a\\") == 1 >>> longest_palindromic_substring_length(\\"aa\\") == 2 >>> longest_palindromic_substring_length(\\"ab\\") == 1 >>> longest_palindromic_substring_length(\\"babad\\") == 3 >>> longest_palindromic_substring_length(\\"aaaaa\\") == 5 >>> longest_palindromic_substring_length(\\"abacdfgdcaba\\") == 3 >>> longest_palindromic_substring_length(\\"abaxyzzyxf\\") == 6","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in the given string s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 if len(s) == 0: return 0 max_length = 1 for i in range(len(s)): len1 = expand_around_center(i, i) # Odd length palindromes len2 = expand_around_center(i, i + 1) # Even length palindromes max_length = max(max_length, len1, len2) return max_length"},{"question":"def word_search(m: int, n: int, grid: List[List[str]], word: str) -> str: Determine if the word exists in the grid in specified directions. >>> word_search(3, 4, [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"ABCCED\\") \\"YES\\" >>> word_search(3, 4, [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"SEE\\") \\"YES\\" >>> word_search(3, 4, [ ... ['A', 'B', 'C', 'E'], ... ['S', 'F', 'C', 'S'], ... ['A', 'D', 'E', 'E']], \\"ABCB\\") \\"NO\\" >>> word_search(1, 1, [['A']], \\"A\\") \\"YES\\" >>> word_search(2, 2, [['A', 'B'], ['C', 'D']], \\"ABCDE\\") \\"NO\\"","solution":"def exist(board, word): def dfs(board, word, i, j, m, n, index): if index == len(word): return True if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[index]: return False # temporarily mark the board cell as visited to avoid revisiting temp, board[i][j] = board[i][j], '#' # check all 8 directions directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)] for dir in directions: if dfs(board, word, i + dir[0], j + dir[1], m, n, index + 1): return True # restore the original value at board cell board[i][j] = temp return False m, n = len(board), len(board[0]) for i in range(m): for j in range(n): if dfs(board, word, i, j, m, n, 0): return True return False def word_search(m, n, grid, word): if exist(grid, word): return \\"YES\\" return \\"NO\\""},{"question":"def sieve_of_eratosthenes(n: int) -> List[bool]: Helper function to generate a list of booleans representing primality of numbers from 0 to n pass def find_sum_of_primes(N: int): Given an integer N, determine if it can be expressed as the sum of two prime numbers. If it can, return any pair of such prime numbers. If not, return -1. >>> find_sum_of_primes(34) (3, 31) >>> find_sum_of_primes(20) (3, 17) >>> find_sum_of_primes(1) -1 >>> find_sum_of_primes(3) -1 pass def test_small_prime_sum(): result = find_sum_of_primes(4) assert result == (2, 2) or result == (2, 2), \\"Test for N=4 failed.\\" def test_valid_prime_sum_34(): result = find_sum_of_primes(34) valid_results = [(3, 31), (5, 29), (11, 23), (17, 17)] assert result in valid_results, \\"Test for N=34 failed.\\" def test_valid_prime_sum_20(): result = find_sum_of_primes(20) valid_results = [(3, 17), (7, 13)] assert result in valid_results, \\"Test for N=20 failed.\\" def test_large_prime_sum(): result = find_sum_of_primes(1000000) assert result != -1, \\"Test for large N=1000000 failed.\\" def test_invalid_prime_sum(): result = find_sum_of_primes(1) assert result == -1, \\"Test for N=1 (non-valid input) failed.\\" def test_primes_too_small(): result = find_sum_of_primes(3) assert result == -1, \\"Test for N=3 (below valid range) failed.\\"","solution":"def sieve_of_eratosthenes(n): is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 is_prime[0] = is_prime[1] = False return is_prime def find_sum_of_primes(N): if N < 4: return -1 is_prime = sieve_of_eratosthenes(N) for i in range(2, N): if is_prime[i] and is_prime[N - i]: return i, N - i return -1"},{"question":"def determine_sequence_type(N, sequence): Given a sequence of N numbers, determine if it is increasing, decreasing, or neither. Parameters: N (int): The number of elements in the sequence. sequence (List[int]): The sequence of numbers. Returns: str: \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". pass def process_test_cases(T, test_cases): Process multiple test cases to determine the type of each sequence. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing N and the sequence. Returns: List[str]: List of results for each test case, either \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". pass def test_determine_sequence_type(): assert determine_sequence_type(5, [1, 2, 3, 4, 5]) == \\"Increasing\\" assert determine_sequence_type(4, [10, 8, 6, 2]) == \\"Decreasing\\" assert determine_sequence_type(6, [3, 3, 5, 4, 2, 1]) == \\"Neither\\" assert determine_sequence_type(3, [5, 5, 5]) == \\"Neither\\" assert determine_sequence_type(2, [1, 1]) == \\"Neither\\" assert determine_sequence_type(2, [2, 1]) == \\"Decreasing\\" def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5]), (4, [10, 8, 6, 2]), (6, [3, 3, 5, 4, 2, 1]) ] assert process_test_cases(3, test_cases) == [\\"Increasing\\", \\"Decreasing\\", \\"Neither\\"] test_cases = [ (3, [1, 2, 1]), (4, [1, 1, 1, 1]), (3, [3, 2, 1]) ] assert process_test_cases(3, test_cases) == [\\"Neither\\", \\"Neither\\", \\"Decreasing\\"]","solution":"def determine_sequence_type(N, sequence): Given a sequence of N numbers, determine if it is increasing, decreasing, or neither. Parameters: N (int): The number of elements in the sequence. sequence (List[int]): The sequence of numbers. Returns: str: \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". is_increasing = True is_decreasing = True for i in range(1, N): if sequence[i] <= sequence[i - 1]: is_increasing = False if sequence[i] >= sequence[i - 1]: is_decreasing = False if is_increasing: return \\"Increasing\\" elif is_decreasing: return \\"Decreasing\\" else: return \\"Neither\\" def process_test_cases(T, test_cases): Process multiple test cases to determine the type of each sequence. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing N and the sequence. Returns: List[str]: List of results for each test case, either \\"Increasing\\", \\"Decreasing\\", or \\"Neither\\". results = [] for N, sequence in test_cases: result = determine_sequence_type(N, sequence) results.append(result) return results"},{"question":"def isBalancedBraces(S: str) -> int: Returns 1 if the braces in string S are properly balanced, 0 otherwise. >>> isBalancedBraces(\\"{{{}}}\\") == 1 >>> isBalancedBraces(\\"{{{}}\\") == 0 >>> isBalancedBraces(\\"{{}}}\\") == 0 >>> isBalancedBraces(\\"{}{}{}\\") == 1 >>> isBalancedBraces(\\"}{\\") == 0 >>> isBalancedBraces(\\"\\") == 1 >>> isBalancedBraces(\\"{\\") == 0 >>> isBalancedBraces(\\"}\\") == 0 >>> isBalancedBraces(\\"{\\"*50000 + \\"}\\"*50000) == 1 >>> isBalancedBraces(\\"{\\"*50001 + \\"}\\"*50000) == 0","solution":"def isBalancedBraces(S): Returns 1 if the braces in string S are properly balanced, 0 otherwise. balance = 0 for char in S: if char == '{': balance += 1 elif char == '}': balance -= 1 if balance < 0: return 0 return 1 if balance == 0 else 0"},{"question":"def nearest_shops(N: int, M: int, houses: List[int], shops: List[int]) -> List[int]: Matches each house to the nearest shop. Args: N : int Number of houses. M : int Number of shops. houses : list of int Positions of houses on the number line. shops : list of int Positions of shops on the number line. Returns: list of int List containing the shop number that is nearest to each house. >>> nearest_shops(3, 4, [1, 5, 9], [2, 4, 6, 8]) [2, 4, 8] >>> nearest_shops(2, 2, [3, 8], [2, 9]) [2, 9] >>> nearest_shops(5, 5, [1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> nearest_shops(3, 3, [1, 1, 1], [2, 2, 2]) [2, 2, 2] >>> nearest_shops(5, 1, [3, 7, 9, 15, 18], [10]) [10, 10, 10, 10, 10]","solution":"def nearest_shops(N, M, houses, shops): Matches each house to the nearest shop. Args: N : int Number of houses. M : int Number of shops. houses : list of int Positions of houses on the number line. shops : list of int Positions of shops on the number line. Returns: list of int List containing the shop number that is nearest to each house. sorted_shops = sorted(shops) results = [] for house in houses: low, high = 0, M - 1 while low < high: mid = (low + high) // 2 if sorted_shops[mid] < house: low = mid + 1 else: high = mid nearest_shop = low if low > 0 and abs(sorted_shops[low] - house) >= abs(sorted_shops[low - 1] - house): nearest_shop = low - 1 results.append(sorted_shops[nearest_shop]) return results"},{"question":"def is_balanced_string(s: str) -> str: Returns \\"YES\\" if the count of 'A' is equal to the count of 'B' in the string s, otherwise returns \\"NO\\". >>> is_balanced_string(\\"ABAB\\") \\"YES\\" >>> is_balanced_string(\\"AABB\\") \\"YES\\" >>> is_balanced_string(\\"AAABBB\\") \\"YES\\" >>> is_balanced_string(\\"AAAABB\\") \\"NO\\" def check_balanced_strings(test_cases: List[str]) -> List[str]: Given a list of test case strings, returns a list of results for each test case by checking if they are balanced. >>> check_balanced_strings([\\"ABAB\\", \\"AABB\\", \\"AAABBB\\", \\"AAAABB\\"]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> check_balanced_strings([\\"BBAA\\", \\"BB\\", \\"AAAA\\", \\"AB\\"]) [\\"YES\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> check_balanced_strings([\\"AABABB\\", \\"BBBB\\", \\"ABBAAB\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> check_balanced_strings([]) []","solution":"def is_balanced_string(s): Returns \\"YES\\" if the count of 'A' is equal to the count of 'B' in the string s, otherwise returns \\"NO\\". return \\"YES\\" if s.count('A') == s.count('B') else \\"NO\\" def check_balanced_strings(test_cases): Given a list of test case strings, returns a list of results for each test case by checking if they are balanced. return [is_balanced_string(case) for case in test_cases]"},{"question":"def is_strictly_increasing(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: This function takes the number of test cases and a list of tuples containing the length of the list and the list itself, and returns a list of strings \\"true\\" or \\"false\\" indicating whether each list is strictly increasing. Parameters: T (int): Number of test cases. test_cases (list): List of tuples where each tuple contains: - (int): Length of the list. - (list): The list of integers. Returns: list: A list of strings \\"true\\" or \\"false\\". >>> is_strictly_increasing(3, [(5, [1, 2, 3, 4, 5]), (4, [5, 5, 10, 15]), (3, [10, 20, 30])]) [\\"true\\", \\"false\\", \\"true\\"] >>> is_strictly_increasing(1, [(1, [1])]) [\\"true\\"] >>> is_strictly_increasing(1, [(0, [])]) [\\"true\\"] >>> is_strictly_increasing(1, [(4, [2, 2, 2, 2])]) [\\"false\\"] >>> is_strictly_increasing(1, [(3, [3, 2, 1])]) [\\"false\\"] >>> is_strictly_increasing(1, [(4, [-4, -3, -2, -1])]) [\\"true\\"] >>> is_strictly_increasing(1, [(4, [-2, 0, 1, 3])]) [\\"true\\"]","solution":"def is_strictly_increasing(T, test_cases): This function takes the number of test cases and a list of tuples containing the length of the list and the list itself, and returns a list of strings \\"true\\" or \\"false\\" indicating whether each list is strictly increasing. Parameters: T (int): Number of test cases. test_cases (list): List of tuples where each tuple contains: - (int): Length of the list. - (list): The list of integers. Returns: list: A list of strings \\"true\\" or \\"false\\". results = [] for i in range(T): N, lst = test_cases[i] if all(lst[j] < lst[j + 1] for j in range(N - 1)): results.append(\\"true\\") else: results.append(\\"false\\") return results"},{"question":"def find_top_k_oldest(N: int, employee_data: List[Tuple[str, int]], K: int) -> List[Tuple[str, int]]: Returns the top K oldest employees sorted by age in descending order. Args: N (int): Number of employees employee_data (list of tuples): Each tuple contains the name (str) and age (int) of an employee K (int): Number of oldest employees to return Returns: list of tuples: Top K oldest employees sorted by age in descending order >>> find_top_k_oldest(5, [(\\"Alice\\", 45), (\\"Bob\\", 50), (\\"Charlie\\", 35), (\\"David\\", 45), (\\"Eve\\", 32)], 3) [(\\"Bob\\", 50), (\\"Alice\\", 45), (\\"David\\", 45)] >>> find_top_k_oldest(6, [(\\"Alice\\", 45), (\\"Bob\\", 50), (\\"Charlie\\", 35), (\\"David\\", 45), (\\"Eve\\", 32), (\\"Frank\\", 45)], 4) [(\\"Bob\\", 50), (\\"Alice\\", 45), (\\"David\\", 45), (\\"Frank\\", 45)] from typing import List, Tuple def test_find_top_k_oldest_basic(): assert find_top_k_oldest(5, [(\\"Alice\\", 45), (\\"Bob\\", 50), (\\"Charlie\\", 35), (\\"David\\", 45), (\\"Eve\\", 32)], 3) == [ (\\"Bob\\", 50), (\\"Alice\\", 45), (\\"David\\", 45) ] def test_find_top_k_oldest_tie_ages(): assert find_top_k_oldest(6, [(\\"Alice\\", 45), (\\"Bob\\", 50), (\\"Charlie\\", 35), (\\"David\\", 45), (\\"Eve\\", 32), (\\"Frank\\", 45)], 4) == [ (\\"Bob\\", 50), (\\"Alice\\", 45), (\\"David\\", 45), (\\"Frank\\", 45) ] def test_find_top_k_oldest_k_equals_n(): assert find_top_k_oldest(3, [(\\"Alice\\", 40), (\\"Bob\\", 42), (\\"Charlie\\", 41)], 3) == [ (\\"Bob\\", 42), (\\"Charlie\\", 41), (\\"Alice\\", 40) ] def test_find_top_k_oldest_single_employee(): assert find_top_k_oldest(1, [(\\"Alice\\", 40)], 1) == [ (\\"Alice\\", 40) ] def test_find_top_k_oldest_less_than_k_employees(): assert find_top_k_oldest(2, [(\\"Alice\\", 40), (\\"Bob\\", 42)], 3) == [ (\\"Bob\\", 42), (\\"Alice\\", 40) ]","solution":"def find_top_k_oldest(N, employee_data, K): Returns the top K oldest employees sorted by age in descending order. Args: N (int): Number of employees employee_data (list of tuples): Each tuple contains the name (str) and age (int) of an employee K (int): Number of oldest employees to return Returns: list of tuples: Top K oldest employees sorted by age in descending order # Sort the employee data by age in descending order # In case of a tie in age, the original order is maintained as sort is stable sorted_employee_data = sorted(employee_data, key=lambda x: x[1], reverse=True) # Return the top K oldest employees return sorted_employee_data[:K]"},{"question":"def count_trailing_zeros_in_factorial(n): This function takes a positive integer n and returns the number of trailing zeros in the factorial of n. def process_input(input_data): This function takes input data as a list of integers, processes each integer, and returns a list of results. from count_trailing_zeros_in_factorial import process_input def test_count_trailing_zeros_in_factorial(): assert count_trailing_zeros_in_factorial(5) == 1 assert count_trailing_zeros_in_factorial(10) == 2 assert count_trailing_zeros_in_factorial(25) == 6 assert count_trailing_zeros_in_factorial(100) == 24 assert count_trailing_zeros_in_factorial(1) == 0 assert count_trailing_zeros_in_factorial(0) == 0 def test_process_input(): input_data = [5, 10, 25, -1] expected_output = [1, 2, 6] assert process_input(input_data) == expected_output input_data = [100, 200, -1] expected_output = [24, 49] assert process_input(input_data) == expected_output input_data = [1, 2, 3, 4, -1] expected_output = [0, 0, 0, 0] assert process_input(input_data) == expected_output","solution":"def count_trailing_zeros_in_factorial(n): This function takes a positive integer n and returns the number of trailing zeros in the factorial of n. count = 0 power_of_5 = 5 while n >= power_of_5: count += n // power_of_5 power_of_5 *= 5 return count def process_input(input_data): This function takes input data as a list of integers, processes each integer, and returns a list of results. results = [] for n in input_data: if n == -1: break results.append(count_trailing_zeros_in_factorial(n)) return results"},{"question":"def maxWaterContainer(heights): Given a list of N integers, where each integer represents the height of a vertical line drawn on a Cartesian plane at that index. The widths between each pair of adjacent lines are all the same. Find the maximum amount of water a container formed by picking two of these lines can hold. Args: heights (List[int]): List of integers representing the heights. Returns: int: The maximum water that can be contained. Examples: >>> maxWaterContainer([1, 8, 6, 2, 5, 4, 8, 3, 7]) 49 >>> maxWaterContainer([3]) 0 >>> maxWaterContainer([4, 4, 4, 4, 4]) 16 >>> maxWaterContainer([1, 2, 3, 4, 5]) 6 >>> maxWaterContainer([5, 4, 3, 2, 1]) 6 >>> maxWaterContainer([0, 0, 0, 0]) 0 >>> maxWaterContainer([10000, 10000, 10000, 10000, 10000]) 40000 >>> maxWaterContainer([0, 10000]) 0","solution":"def maxWaterContainer(heights): Returns the maximum amount of water a container can hold by picking two lines. left, right = 0, len(heights) - 1 max_water = 0 while left < right: width = right - left height = min(heights[left], heights[right]) max_water = max(max_water, width * height) if heights[left] <= heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"class ElevationGrid: def __init__(self, grid): self.grid = grid def update(self, x, y, v): Update the elevation of the cell at row x and column y to v. pass def find_min(self, x1, y1, x2, y2): Find the minimum elevation within the subgrid from (x1, y1) to (x2, y2), inclusive. >>> eg = ElevationGrid([[5, 8, 6], [3, 2, 7], [9, 4, 1]]) >>> eg.find_min(1, 1, 2, 2) 2 pass def find_max(self, x1, y1, x2, y2): Find the maximum elevation within the subgrid from (x1, y1) to (x2, y2), inclusive. >>> eg = ElevationGrid([[5, 8, 6], [3, 2, 7], [9, 4, 1]]) >>> eg.find_max(2, 2, 3, 3) 7 pass def process_queries(n, m, elevations, q, queries): Process queries for the grid and return the results for \\"Min\\" and \\"Max\\" queries. >>> n, m = 3, 3 >>> elevations = [[5, 8, 6], [3, 2, 7], [9, 4, 1]] >>> q = 6 >>> queries = [\\"Min 1 1 2 2\\", \\"Max 2 2 3 3\\", \\"U 2 2 10\\", \\"Min 1 1 2 2\\", \\"Max 1 1 3 3\\", \\"Min 2 2 3 3\\"] >>> process_queries(n, m, elevations, q, queries) [2, 7, 3, 10, 1] pass # Test function def test_1(): n, m = 3, 3 elevations = [[5, 8, 6], [3, 2, 7], [9, 4, 1]] q = 6 queries = [\\"Min 1 1 2 2\\", \\"Max 2 2 3 3\\", \\"U 2 2 10\\", \\"Min 1 1 2 2\\", \\"Max 1 1 3 3\\", \\"Min 2 2 3 3\\"] expected_output = [2, 7, 3, 10, 1] results = process_queries(n, m, elevations, q, queries) assert results == expected_output def test_2(): n, m = 2, 2 elevations = [[1, 2], [3, 4]] q = 3 queries = [\\"Min 1 1 2 2\\", \\"Max 1 1 1 2\\", \\"U 2 1 5\\"] expected_output = [1, 2] results = process_queries(n, m, elevations, q, queries) assert results == expected_output def test_3(): n, m = 1, 1 elevations = [[5]] q = 2 queries = [\\"Min 1 1 1 1\\", \\"Max 1 1 1 1\\"] expected_output = [5, 5] results = process_queries(n, m, elevations, q, queries) assert results == expected_output if __name__ == '__main__': test_1() test_2() test_3()","solution":"class ElevationGrid: def __init__(self, grid): self.grid = grid def update(self, x, y, v): self.grid[x - 1][y - 1] = v def find_min(self, x1, y1, x2, y2): min_val = float('inf') for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): min_val = min(min_val, self.grid[i][j]) return min_val def find_max(self, x1, y1, x2, y2): max_val = float('-inf') for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): max_val = max(max_val, self.grid[i][j]) return max_val def process_queries(n, m, elevations, q, queries): grid = ElevationGrid(elevations) results = [] for query in queries: parts = query.split() if parts[0] == 'U': x, y, v = map(int, parts[1:]) grid.update(x, y, v) elif parts[0] == 'Min': x1, y1, x2, y2 = map(int, parts[1:]) results.append(grid.find_min(x1, y1, x2, y2)) elif parts[0] == 'Max': x1, y1, x2, y2 = map(int, parts[1:]) results.append(grid.find_max(x1, y1, x2, y2)) return results # Example usage: n, m = 3, 3 elevations = [ [5, 8, 6], [3, 2, 7], [9, 4, 1] ] q = 6 queries = [ \\"Min 1 1 2 2\\", \\"Max 2 2 3 3\\", \\"U 2 2 10\\", \\"Min 1 1 2 2\\", \\"Max 1 1 3 3\\", \\"Min 2 2 3 3\\" ] results = process_queries(n, m, elevations, q, queries) for result in results: print(result)"},{"question":"def count_popular_users(N: int, follow_count: List[int], follower_count: List[int]) -> int: Function to count the number of popular users in a social media app. Args: N : int : number of users follow_count : list of int : list where i-th element is the number of users the i-th user follows follower_count : list of int : list where i-th element is the number of followers of the i-th user Returns: int : number of popular users >>> count_popular_users(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 2 >>> count_popular_users(3, [0, 1, 2], [2, 1, 0]) 1 >>> count_popular_users(4, [0, 0, 0, 0], [0, 1, 2, 3]) 3","solution":"def count_popular_users(N, follow_count, follower_count): Function to count the number of popular users in a social media app. Args: N : int : number of users follow_count : list of int : list where i-th element is the number of users the i-th user follows follower_count : list of int : list where i-th element is the number of followers of the i-th user Returns: int : number of popular users popular_count = 0 for i in range(N): if follower_count[i] > follow_count[i]: popular_count += 1 return popular_count"},{"question":"def count_pairs_with_sum(arr, target): Returns the number of unique pairs in the array that add up to the target sum. >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) # Output: 2 >>> count_pairs_with_sum([1, 2, 3], 10) # Output: 0 >>> count_pairs_with_sum([0, 0, 0, 0], 0) # Output: 1 >>> count_pairs_with_sum([-2, -1, 0, 1, 2], 0) # Output: 2 >>> count_pairs_with_sum([1000, -1000, 500, -500, 0], 0) # Output: 2 >>> count_pairs_with_sum([1, 1, 1, 1], 2) # Output: 1 >>> count_pairs_with_sum([2, 4, 6, 8, 10, 2], 10) # Output: 2","solution":"def count_pairs_with_sum(arr, target): Returns the number of unique pairs in the array that add up to the target sum. seen = {} unique_pairs = set() for num in arr: complementary = target - num if complementary in seen: # To ensure unique pairs we insert a sorted tuple unique_pairs.add(tuple(sorted((num, complementary)))) seen[num] = seen.get(num, 0) + 1 return len(unique_pairs) # Example usage # print(count_pairs_with_sum([1, 5, 7, -1, 5], 6)) # Output: 2"},{"question":"def max_path_sum(n: int, vals: List[int], edges: List[Tuple[int, int]]) -> int: Given a tree with N nodes where each node has a value, returns the maximum possible sum of values of the nodes that can be collected by visiting nodes on exactly one simple path. Args: n: An integer, the number of nodes. vals: A list of integers, the values of the nodes. edges: A list of tuples, representing the edges of the tree. Returns: An integer, the maximum sum of values on one simple path. >>> max_path_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 12 >>> max_path_sum(2, [1, 2], [(1, 2)]) 3 >>> max_path_sum(4, [1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) 10 >>> max_path_sum(6, [1, 2, 3, 4, 5, 6], [(1, 2), (1, 3), (1, 4), (1, 5), (1, 6)]) 12 >>> max_path_sum(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 18","solution":"import sys from collections import defaultdict sys.setrecursionlimit(200000) def dfs(node, parent, values, adj_list): max1 = max2 = 0 for neighbor in adj_list[node]: if neighbor == parent: continue current_sum = dfs(neighbor, node, values, adj_list) if current_sum > max1: max1, max2 = current_sum, max1 elif current_sum > max2: max2 = current_sum global max_sum max_sum = max(max_sum, max1 + max2 + values[node]) return max1 + values[node] def max_path_sum(n, vals, edges): global max_sum max_sum = -sys.maxsize values = [0] + vals adj_list = defaultdict(list) for (u, v) in edges: adj_list[u].append(v) adj_list[v].append(u) dfs(1, -1, values, adj_list) return max_sum def parse_input(): import sys input = sys.stdin.read data = input().split() index = 0 n = int(data[index]) index += 1 vals = [] for _ in range(n): vals.append(int(data[index])) index += 1 edges = [] for _ in range(n - 1): u = int(data[index]) index += 1 v = int(data[index]) index += 1 edges.append((u, v)) return n, vals, edges"},{"question":"from typing import List, Union def can_form_special_pattern(n: int, titles: List[str]) -> Union[str, List[str]]: Determine if it is possible to rearrange the book titles in a special pattern where for every 1 ≤ i < n/2, the i-th title and (n-i+1)-th title are anagrams of each other. >>> can_form_special_pattern(4, [\\"listen\\", \\"silent\\", \\"evil\\", \\"vile\\"]) [\\"YES\\", \\"listen\\", \\"vile\\", \\"evil\\", \\"silent\\"] >>> can_form_special_pattern(3, [\\"rat\\", \\"tar\\", \\"art\\"]) \\"NO\\" from solution import can_form_special_pattern def test_even_anagrams(): n = 4 titles = [\\"listen\\", \\"silent\\", \\"evil\\", \\"vile\\"] output = can_form_special_pattern(n, titles) assert output[0] == \\"YES\\" assert len(output) == 5 def test_odd_titles(): n = 3 titles = [\\"rat\\", \\"tar\\", \\"art\\"] output = can_form_special_pattern(n, titles) assert output == \\"NO\\" def test_duplicate_anagrams(): n = 6 titles = [\\"note\\", \\"tone\\", \\"evil\\", \\"vile\\", \\"stop\\", \\"pots\\"] output = can_form_special_pattern(n, titles) assert output[0] == \\"YES\\" assert len(output) == 7 def test_non_anagrams(): n = 4 titles = [\\"abcd\\", \\"efgh\\", \\"ijkl\\", \\"mnop\\"] output = can_form_special_pattern(n, titles) assert output == \\"NO\\"","solution":"def can_form_special_pattern(n, titles): from collections import defaultdict def sort_string(s): return ''.join(sorted(s)) # Store titles grouped by their sorted characters anagram_groups = defaultdict(list) for title in titles: sorted_title = sort_string(title) anagram_groups[sorted_title].append(title) # Check if the number of titles and their frequencies allow a special pattern if n % 2 != 0: return \\"NO\\" result = [] used = set() for group in anagram_groups.values(): if len(group) % 2 != 0: return \\"NO\\" for i in range(0, len(group), 2): part1 = group[i] part2 = group[i+1] result.append(part1) used.add(part1) result.insert(0, part2) used.add(part2) if len(result) != n: return \\"NO\\" return [\\"YES\\"] + result # Example usage: n = 4 titles = [\\"listen\\", \\"silent\\", \\"evil\\", \\"vile\\"] output = can_form_special_pattern(n, titles) for line in output: print(line) n = 3 titles = [\\"rat\\", \\"tar\\", \\"art\\"] output = can_form_special_pattern(n, titles) for line in output: print(line)"},{"question":"def min_operations_to_uniform_decorator(T, test_cases): Calculate the minimum number of operations required to make all the decoration values the same. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing the number of villages and the decoration values. Returns: List[int]: A list of minimum number of operations required for each test case. Example: >>> min_operations_to_uniform_decorator(1, [(3, [1, 2, 3])]) [2] >>> min_operations_to_uniform_decorator(1, [(4, [10, 10, 20, 20])]) [20] pass # Unit Tests from solution import min_operations_to_uniform_decorator def test_single_village(): T = 1 test_cases = [(1, [5])] assert min_operations_to_uniform_decorator(T, test_cases) == [0] def test_two_villages(): T = 1 test_cases = [(2, [1, 2])] assert min_operations_to_uniform_decorator(T, test_cases) == [1] def test_three_villages(): T = 1 test_cases = [(3, [1, 2, 3])] assert min_operations_to_uniform_decorator(T, test_cases) == [2] def test_multiple_villages_with_same_value(): T = 1 test_cases = [(4, [5, 5, 5, 5])] assert min_operations_to_uniform_decorator(T, test_cases) == [0] def test_even_number_of_villages(): T = 1 test_cases = [(4, [10, 10, 20, 20])] assert min_operations_to_uniform_decorator(T, test_cases) == [20] def test_multiple_test_cases(): T = 2 test_cases = [(3, [1, 2, 3]), (4, [10, 10, 20, 20])] assert min_operations_to_uniform_decorator(T, test_cases) == [2, 20]","solution":"def min_operations_to_uniform_decorator(T, test_cases): results = [] for test_case in test_cases: N, P = test_case median = sorted(P)[N // 2] operations = sum(abs(x - median) for x in P) results.append(operations) return results"},{"question":"def determine_efficiency(test_cases): Determine the most efficient participant based on their minimum time to solve the problem successfully. Args: test_cases: List of tuples. Each tuple contains an integer N (the number of participants) and a list of lists where each inner list contains times and results for the participants. Returns: A list of strings indicating the most efficient participant or \\"TIE\\" if there is a tie for the minimum time. >>> determine_efficiency([(3, [[25, 'AC', 30, 'WA', 35, 'AC'], [20, 'WA', 15, 'AC', 50, 'WA'], [50, 'WA', 45, 'WA', 10, 'AC']])]) ['Participant 3'] >>> determine_efficiency([(2, [[40, 'WA', 20, 'AC'], [20, 'AC', 40, 'WA']])]) ['TIE'] pass def test_determine_efficiency(): test_cases = [ (3, [ [25, 'AC', 30, 'WA', 35, 'AC'], [20, 'WA', 15, 'AC', 50, 'WA'], [50, 'WA', 45, 'WA', 10, 'AC'] ]), (2, [ [40, 'WA', 20, 'AC'], [20, 'AC', 40, 'WA'] ]) ] expected_outputs = [\\"Participant 3\\", \\"TIE\\"] results = determine_efficiency(test_cases) assert results == expected_outputs def test_all_wrong(): test_cases = [ (2, [ [25, 'WA', 30, 'WA'], [20, 'WA', 50, 'WA'] ]) ] expected_outputs = [\\"TIE\\"] results = determine_efficiency(test_cases) assert results == expected_outputs def test_single_participant(): test_cases = [ (1, [ [25, 'AC', 30, 'WA'] ]) ] expected_outputs = [\\"Participant 1\\"] results = determine_efficiency(test_cases) assert results == expected_outputs def test_multiple_participants_with_tie(): test_cases = [ (3, [ [25, 'WA', 30, 'AC', 35, 'WA'], [25, 'WA', 30, 'AC', 50, 'WA'], [50, 'WA', 30, 'AC', 10, 'WA'] ]) ] expected_outputs = [\\"TIE\\"] results = determine_efficiency(test_cases) assert results == expected_outputs def test_edge_case_single_attempt(): test_cases = [ (2, [ [30, 'AC'], [20, 'WA'] ]) ] expected_outputs = [\\"Participant 1\\"] results = determine_efficiency(test_cases) assert results == expected_outputs","solution":"def determine_efficiency(test_cases): results = [] for test_case in test_cases: N = test_case[0] participants = test_case[1] min_times = [] for participant in participants: min_time = float('inf') for i in range(0, len(participant), 2): time, result = participant[i], participant[i + 1] if result == 'AC': min_time = min(min_time, time) min_times.append(min_time if min_time != float('inf') else None) min_time = min(filter(lambda x: x is not None, min_times), default=None) if min_time is None: results.append(\\"TIE\\") else: if min_times.count(min_time) > 1: results.append(\\"TIE\\") else: results.append(f\\"Participant {min_times.index(min_time) + 1}\\") return results"},{"question":"def can_buy_exactly(a: int, b: int, x: int, y: int) -> str: Given the cost of a cookie (a), the cost of a brownie (b), the total amount of money you have (x), and the total number of items you want to buy (y), determine if it is possible to buy exactly y items with the exact amount available. >>> can_buy_exactly(2, 3, 8, 4) \\"YES\\" >>> can_buy_exactly(3, 5, 10, 3) \\"NO\\" >>> can_buy_exactly(4, 4, 16, 4) \\"YES\\" from solution import can_buy_exactly def test_can_buy_exactly_case1(): assert can_buy_exactly(2, 3, 8, 4) == \\"YES\\" def test_can_buy_exactly_case2(): assert can_buy_exactly(3, 5, 10, 3) == \\"NO\\" def test_can_buy_exactly_case3(): assert can_buy_exactly(4, 4, 16, 4) == \\"YES\\" def test_can_buy_exactly_zero_money(): assert can_buy_exactly(2, 3, 0, 0) == \\"YES\\" assert can_buy_exactly(3, 5, 0, 1) == \\"NO\\" def test_can_buy_exactly_large_numbers(): assert can_buy_exactly(1, 1, 100000, 100000) == \\"YES\\" assert can_buy_exactly(10000, 10000, 100000, 10) == \\"YES\\" assert can_buy_exactly(10000, 10000, 1000000, 5) == \\"NO\\" def test_can_buy_exactly_same_cost(): assert can_buy_exactly(5, 5, 25, 5) == \\"YES\\" assert can_buy_exactly(5, 5, 24, 5) == \\"NO\\"","solution":"def can_buy_exactly(a, b, x, y): Determines if it is possible to buy exactly y items (cookies and brownies) with the exact amount x dollars. Arguments: a -- the cost of a cookie b -- the cost of a brownie x -- the total amount of money available y -- the total number of items to buy Returns: \\"YES\\" if it is possible to buy exactly y items with exactly x dollars, otherwise \\"NO\\". for cookies in range(min(y, x // a) + 1): brownies = y - cookies if brownies >= 0 and (cookies * a + brownies * b) == x: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def word_ladder_length(start: str, end: str, dictionary: List[str]) -> int: Returns the length of the shortest transformation sequence from start to end. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) 0 >>> word_ladder_length(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> word_ladder_length(\\"hit\\", \\"cog\\", []) 0 >>> word_ladder_length(\\"hit\\", \\"hit\\", [\\"hit\\"]) 1 >>> word_ladder_length(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2","solution":"from collections import deque def word_ladder_length(start, end, dictionary): Returns the length of the shortest transformation sequence from start to end. if end not in dictionary or not start or not end or len(start) != len(end): return 0 words = set(dictionary) queue = deque([(start, 1)]) while queue: current_word, steps = queue.popleft() if current_word == end: return steps for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': next_word = current_word[:i] + c + current_word[i+1:] if next_word in words: words.remove(next_word) queue.append((next_word, steps + 1)) return 0"},{"question":"def palindromic_sequence_steps(test_cases: List[int]) -> List[Union[int, str]]: Given a list of integers, determines the number of steps it takes for each integer to become a palindrome. A palindrome is generated by reversing and adding the original integer. If the integer does not become a palindrome within 1000 iterations, it is considered a failure. Args: test_cases (List[int]): List of integers to be processed. Returns: List[Union[int, str]]: Number of steps for each integer to become a palindrome, or \\"FAIL\\" if it does not become a palindrome within 1000 iterations. >>> palindromic_sequence_steps([23]) [1] >>> palindromic_sequence_steps([23, 87, 196]) [1, 4, \\"FAIL\\"] >>> palindromic_sequence_steps([89]) [24] >>> palindromic_sequence_steps([196]) [\\"FAIL\\"] >>> palindromic_sequence_steps([1]) [0] >>> palindromic_sequence_steps([121]) [0]","solution":"def is_palindrome(n): return str(n) == str(n)[::-1] def steps_to_palindrome(n): step_count = 0 while step_count < 1000: if is_palindrome(n): return step_count n = n + int(str(n)[::-1]) step_count += 1 return \\"FAIL\\" def palindromic_sequence_steps(test_cases): results = [] for n in test_cases: results.append(steps_to_palindrome(n)) return results"},{"question":"def determine_winner(A: int, B: int) -> str: Determines the winner of the Maximum Stones game. Parameters: - A (int): Number of stones in the first pile. - B (int): Number of stones in the second pile. Returns: - str: The name of the winning player, either \\"Alice\\" or \\"Bob\\". >>> determine_winner(3, 7) 'Alice' >>> determine_winner(4, 4) 'Bob'","solution":"def determine_winner(A, B): Determines the winner of the Maximum Stones game. Parameters: - A (int): Number of stones in the first pile. - B (int): Number of stones in the second pile. Returns: - str: The name of the winning player, either \\"Alice\\" or \\"Bob\\". if A != B: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def most_frequent_char_count(n: int, s: str) -> int: Returns the count of the most frequent character in a string s of length n. >>> most_frequent_char_count(7, 'abacabad') 4 >>> most_frequent_char_count(5, 'abcde') 1 >>> most_frequent_char_count(4, 'aaaa') 4 >>> most_frequent_char_count(6, 'aabbcc') 2 >>> most_frequent_char_count(1000000, 'a' * 1000000) 1000000 >>> most_frequent_char_count(1000000, 'a' * 500000 + 'b' * 300000 + 'c' * 200000) 500000 >>> most_frequent_char_count(1, 'z') 1","solution":"def most_frequent_char_count(n, s): Returns the count of the most frequent character in a string s of length n. from collections import Counter frequency = Counter(s) max_freq = max(frequency.values()) return max_freq"},{"question":"from typing import List def is_valid_expression(exp: str) -> bool: Checks if the expression is valid according to the rules specified. >>> is_valid_expression(\\"3 + 5 - 2\\") == True >>> is_valid_expression(\\"3 + -5\\") == False >>> is_valid_expression(\\"10 + 15 - 5\\") == True >>> is_valid_expression(\\"3-5\\") == False >>> is_valid_expression(\\"a + b\\") == False >>> is_valid_expression(\\"3 + 5 -\\") == False >>> is_valid_expression(\\"+ 3 5 - 2\\") == False >>> is_valid_expression(\\" 100 + 200 \\") == True def evaluate_expressions(expressions: List[str]) -> List[int]: Evaluates valid mathematical expressions from the input list and returns the results. >>> evaluate_expressions([\\"3 + 5 - 2\\", \\"3 + -5\\", \\"10 + 15 - 5\\"]) == [6, 20] >>> evaluate_expressions([\\"5 + 3\\", \\"10 - 2 + 1\\", \\"invalid\\"]) == [8, 9] >>> evaluate_expressions([\\"3 + 5 -\\", \\"5 - + 5\\", \\"7\\"]) == [] >>> evaluate_expressions([\\"7 + 3\\", \\"10 - 10\\", \\"20 - 5 + 5\\"]) == [10, 0, 20] >>> evaluate_expressions([\\"56\\", \\"12 + 4\\", \\"100 - 50 + 25\\"]) == [12 + 4, 100 - 50 + 25] >>> evaluate_expressions([]) == [] >>> evaluate_expressions([\\"3 + 2 - 1\\"]) == [4]","solution":"def is_valid_expression(exp): Checks if the expression is valid according to the rules specified. tokens = exp.strip().split() if len(tokens) < 3: return False # Check if first and last tokens are integers. if not tokens[0].isdigit() or not tokens[-1].isdigit(): return False # Check if the expression alternates correctly between integers and operators. for i in range(1, len(tokens) - 1, 2): if tokens[i] not in {'+', '-'} or not tokens[i - 1].isdigit() or not tokens[i + 1].isdigit(): return False return True def evaluate_expressions(expressions): Evaluates valid mathematical expressions from the input list and returns the results. results = [] for exp in expressions: if is_valid_expression(exp): results.append(eval(exp)) return results"},{"question":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def nodesAtDistanceK(root: TreeNode, target: int, K: int) -> List[int]: Given a binary tree, find the nodes at distance K from a given target node. Args: root (TreeNode): The root of the binary tree. target (int): The target node value. K (int): The distance from the target node. Returns: List[int]: The list of node values at distance K from the target node. Examples: >>> root = TreeNode(3) >>> root.left = TreeNode(5) >>> root.right = TreeNode(1) >>> root.left.left = TreeNode(6) >>> root.left.right = TreeNode(2) >>> root.right.left = TreeNode(0) >>> root.right.right = TreeNode(8) >>> root.left.right.left = TreeNode(7) >>> root.left.right.right = TreeNode(4) >>> nodesAtDistanceK(root, 5, 2) [7, 4, 1] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> nodesAtDistanceK(root, 2, 1) [1, 4, 5]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def nodesAtDistanceK(root, target, K): # Step 1: Create a map of parent pointers for each node parent_map = {} def fill_parent_map_and_find_target(node, parent): if not node: return None parent_map[node] = parent if node.val == target: return node left = fill_parent_map_and_find_target(node.left, node) if left: return left return fill_parent_map_and_find_target(node.right, node) # Step 2: Start BFS from the target node to find all nodes at distance K target_node = fill_parent_map_and_find_target(root, None) if not target_node: return [] queue = [(target_node, 0)] visited = set() visited.add(target_node) results = [] while queue: current, distance = queue.pop(0) if distance == K: results.append(current.val) if current.left and current.left not in visited: visited.add(current.left) queue.append((current.left, distance + 1)) if current.right and current.right not in visited: visited.add(current.right) queue.append((current.right, distance + 1)) parent = parent_map.get(current) if parent and parent not in visited: visited.add(parent) queue.append((parent, distance + 1)) return results"},{"question":"def minimum_total_cost(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Determine the minimum total cost required for registering the maximum number of complete teams such that no student is left without a team. >>> minimum_total_cost(3, [(5, 3, 200), (15, 4, 150), (7, 2, 100)]) [400, 600, 400] >>> minimum_total_cost(1, [(10, 5, 300)]) [600]","solution":"def minimum_total_cost(T, test_cases): results = [] for case in test_cases: M, K, Y = case teams_needed = (M + K - 1) // K # Minimum number of teams needed to accommodate all students results.append(teams_needed * Y) return results # Example of reading input # T = int(input()) # test_cases = [tuple(map(int, input().split())) for _ in range(T)] # results = minimum_total_cost(T, test_cases) # for result in results: # print(result)"},{"question":"from typing import List def can_reach_destination(n: int, m: int, k: int, grid: List[str]) -> str: Determine if there exists a path from the top-left corner to the bottom-right corner of the grid within k hours of walking. >>> can_reach_destination(5, 5, 10, ['00000', '01110', '01110', '01110', '00000']) 'YES' >>> can_reach_destination(3, 3, 2, ['000', '010', '011']) 'NO' pass","solution":"from collections import deque def can_reach_destination(n, m, k, grid): Determine if there exists a path from the top-left corner to the bottom-right corner of the grid within k hours of walking. if grid[0][0] == '1' or grid[n-1][m-1] == '1': return \\"NO\\" directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] visited = [[False] * m for _ in range(n)] queue = deque([(0, 0, 0)]) # (row, col, distance) visited[0][0] = True while queue: row, col, dist = queue.popleft() if row == n-1 and col == m-1: if dist <= k: return \\"YES\\" for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col] and grid[new_row][new_col] == '0': visited[new_row][new_col] = True queue.append((new_row, new_col, dist + 1)) return \\"NO\\" # Example usage # n, m, k = 5, 5, 10 # grid = ['00000', '01110', '01110', '01110', '00000'] # print(can_reach_destination(n, m, k, grid)) # Output: 'YES'"},{"question":"from typing import List def min_steps_to_palindrome(s: str) -> int: Returns the minimum number of steps required to make the string a palindrome. >>> min_steps_to_palindrome(\\"abba\\") 0 >>> min_steps_to_palindrome(\\"aab\\") 1 >>> min_steps_to_palindrome(\\"bba\\") 1 def process_test_cases(t: int, cases: List[str]) -> List[int]: Processes multiple test cases and returns the results as a list of integers. >>> process_test_cases(3, [\\"abba\\", \\"aab\\", \\"bba\\"]) [0, 1, 1] >>> process_test_cases(2, [\\"abcba\\", \\"xxz\\"]) [0, 1]","solution":"def min_steps_to_palindrome(s): Returns the minimum number of steps required to make the string a palindrome. n = len(s) steps = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: steps += 1 return steps def process_test_cases(t, cases): results = [] for case in cases: results.append(min_steps_to_palindrome(case)) return results"},{"question":"def find_missing_letter(chars: List[str]) -> str: Implement a function \`find_missing_letter(chars)\` that takes an array of consecutive (increasing) letters as input and returns the missing letter in the array. You will always get an array of at least two characters, and the array will always be consecutive except for the missing letter. The input array will always contain letters from only one alphabet case (either all capitals or all lowercase). Examples: >>> find_missing_letter(['a','b','c','d','f']) 'e' >>> find_missing_letter(['O','Q','R','S']) 'P'","solution":"def find_missing_letter(chars): Finds the missing letter from the array of consecutive (increasing) letters. :param chars: List of consecutive letters (all from the same case) :return: The missing letter for i in range(len(chars) - 1): if ord(chars[i + 1]) - ord(chars[i]) != 1: return chr(ord(chars[i]) + 1) # Since there is always a missing letter, this line should never be reached raise ValueError(\\"Should not reach here\\")"},{"question":"def letter_frequency(s: str) -> dict: Returns the frequency of each alphabet letter in a given string s. >>> letter_frequency(\\"Hello World\\") {'a': 0, 'b': 0, 'c': 0, 'd': 1, 'e': 1, 'f': 0, 'g': 0, 'h': 1, 'i': 0, 'j': 0, 'k': 0, 'l': 3, 'm': 0, 'n': 0, 'o': 2, 'p': 0, 'q': 0, 'r': 1, 's': 0, 't': 0, 'u': 0, 'v': 0, 'w': 1, 'x': 0, 'y': 0, 'z': 0} # Your code here def format_frequency_output(frequency_dict: dict) -> str: Format the frequency dictionary into the desired output format. >>> format_frequency_output({'a': 2, 'b': 1, 'c': 0}) 'a: 2nb: 1nc: 0' # Your code here","solution":"def letter_frequency(s): Returns the frequency of each alphabet letter in a given string s. # Create a dictionary to store frequency of each letter frequency = {chr(i): 0 for i in range(97, 123)} # Process the string to count frequencies while ignoring case and spaces for char in s.lower(): if char.isalpha(): frequency[char] += 1 return {k: frequency[k] for k in sorted(frequency)} def format_frequency_output(frequency_dict): Format the frequency dictionary into the desired output format. lines = [f\\"{letter}: {frequency_dict[letter]}\\" for letter in frequency_dict] return \\"n\\".join(lines)"},{"question":"def longest_sequence_of_same_stamps(test_cases): Determine the maximum length of a sequence where all the stamps are identical for each test case. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of stamps and the list of stamps. Returns: List[int]: A list of results where each result is the length of the longest sequence of identical stamps for a corresponding test case. >>> longest_sequence_of_same_stamps([(8, [2, 2, 1, 1, 1, 3, 3, 3])]) [3] >>> longest_sequence_of_same_stamps([(8, [2, 2, 1, 1, 1, 3, 3, 3]), (4, [5, 5, 5, 5])]) [3, 4] >>> longest_sequence_of_same_stamps([(0, [])]) [0] >>> longest_sequence_of_same_stamps([(5, [1, 2, 3, 4, 5])]) [1] >>> longest_sequence_of_same_stamps([(6, [8, 8, 8, 8, 8, 8])]) [6]","solution":"def longest_sequence_of_same_stamps(test_cases): results = [] for case in test_cases: N = case[0] stamps = case[1] if N == 0: results.append(0) continue max_length = 1 current_length = 1 for i in range(1, N): if stamps[i] == stamps[i-1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 results.append(max_length) return results"},{"question":"def validate_questions(questions_dict: dict) -> dict: Given a dictionary of questions, return a dictionary with only valid questions and answers. A question is valid if it has exactly 4 answer choices, and each choice should be a string between 1 and 50 characters long. If a question has any invalid choices, remove it entirely from the dictionary. Args: questions_dict (dict): Dictionary containing questions and their choices. Returns: dict: Dictionary with only valid questions and answers. >>> questions_dict = { ... 'Q1': {'question': 'What is the capital of France?', 'choices': ['Paris', 'Lyon', 'Marseille', 'Nice']}, ... 'Q2': {'question': 'What is 2 + 2?', 'choices': ['4', 'Four', '']}, ... 'Q3': {'question': 'What is the boiling point of water?', 'choices': ['100°C', 'Two Hundred Degrees', 'Too High', '']}, ... 'Q4': {'question': 'Which planet is known as the Red Planet?', 'choices': ['Mars', 'Jupiter', 'Saturn', 'Venus']}, ... } >>> validate_questions(questions_dict) { 'Q1': {'question': 'What is the capital of France?', 'choices': ['Paris', 'Lyon', 'Marseille', 'Nice']}, 'Q4': {'question': 'Which planet is known as the Red Planet?', 'choices': ['Mars', 'Jupiter', 'Saturn', 'Venus']} }","solution":"def validate_questions(questions_dict): valid_questions = {} for qid, data in questions_dict.items(): choices = data['choices'] if len(choices) != 4: continue if all(isinstance(choice, str) and 1 <= len(choice) <= 50 for choice in choices): valid_questions[qid] = data return valid_questions"},{"question":"from typing import List, Dict def calculate_parking_time(log: List[str]) -> Dict[str, int]: Analyze the log and find out the total parking time for each car. Args: log (List[str]): A list of strings formatted as \\"HH:MM CarId EventType\\" where EventType is either \\"enter\\" or \\"exit\\". Returns: Dict[str, int]: A dictionary where each key is a car's CarId and the corresponding value is the total time in minutes that the car spent in the parking lot. Example: >>> log = [\\"08:00 A1 enter\\", \\"09:30 A2 enter\\", \\"10:00 A1 exit\\", \\"11:00 A3 enter\\", \\"12:00 A2 exit\\", \\"12:30 A3 exit\\"] >>> calculate_parking_time(log) {\\"A1\\": 120, \\"A2\\": 150, \\"A3\\": 90} pass def test_calculate_parking_time_single_car(): log = [\\"08:00 A1 enter\\", \\"12:00 A1 exit\\"] result = calculate_parking_time(log) assert result == {\\"A1\\": 240}, f\\"Unexpected result: {result}\\" def test_calculate_parking_time_multiple_cars(): log = [\\"08:00 A1 enter\\", \\"09:30 A2 enter\\", \\"10:00 A1 exit\\", \\"12:00 A2 exit\\"] result = calculate_parking_time(log) assert result == {\\"A1\\": 120, \\"A2\\": 150}, f\\"Unexpected result: {result}\\" def test_calculate_parking_time_cars_overlapping_times(): log = [\\"08:00 A1 enter\\", \\"09:30 A2 enter\\", \\"10:00 A1 exit\\", \\"11:00 A3 enter\\", \\"12:00 A2 exit\\", \\"12:30 A3 exit\\"] result = calculate_parking_time(log) assert result == {\\"A1\\": 120, \\"A2\\": 150, \\"A3\\": 90}, f\\"Unexpected result: {result}\\" def test_calculate_parking_time_cars_non_overlapping_times(): log = [\\"10:00 B1 enter\\", \\"11:30 B1 exit\\", \\"12:00 B2 enter\\", \\"14:00 B2 exit\\"] result = calculate_parking_time(log) assert result == {\\"B1\\": 90, \\"B2\\": 120}, f\\"Unexpected result: {result}\\" def test_calculate_parking_time_only_exit(): log = [\\"09:00 C1 exit\\"] result = calculate_parking_time(log) assert result == {}, f\\"Unexpected result: {result}\\"","solution":"from typing import List, Dict def calculate_parking_time(log: List[str]) -> Dict[str, int]: parking_times = {} enter_times = {} for entry in log: time_str, car_id, event_type = entry.split() hh, mm = map(int, time_str.split(':')) minutes = hh * 60 + mm if event_type == \\"enter\\": enter_times[car_id] = minutes elif event_type == \\"exit\\": if car_id in enter_times: total_time = minutes - enter_times[car_id] parking_times[car_id] = total_time return parking_times"},{"question":"def minimal_square_sum(T, test_cases): Find the minimum number of perfect square numbers which sum to N for each test case. Parameters: T (int): The number of test cases. test_cases (list of int): A list of integers denoting N for each test case. Returns: list of str: Minimum number of perfect square numbers for each N or error messages if constraints are not met. pass def test_invalid_test_case_range(): assert minimal_square_sum(0, [1]) == [\\"Invalid Test\\"] assert minimal_square_sum(11, [1]) == [\\"Invalid Test\\"] def test_invalid_input_range(): assert minimal_square_sum(1, [-1]) == [\\"Invalid Input\\"] assert minimal_square_sum(1, [10001]) == [\\"Invalid Input\\"] def test_minimal_square_sum(): assert minimal_square_sum(3, [12, 0, 27]) == [\\"3\\", \\"0\\", \\"3\\"] assert minimal_square_sum(1, [1]) == [\\"1\\"] assert minimal_square_sum(1, [13]) == [\\"2\\"] assert minimal_square_sum(1, [10000]) == [\\"1\\"] def test_edge_cases(): assert minimal_square_sum(1, [0]) == [\\"0\\"] assert minimal_square_sum(1, [1]) == [\\"1\\"] assert minimal_square_sum(1, [2]) == [\\"2\\"] assert minimal_square_sum(1, [4]) == [\\"1\\"] assert minimal_square_sum(1, [5]) == [\\"2\\"]","solution":"def minimal_square_sum(T, test_cases): Find the minimum number of perfect square numbers which sum to N for each test case. Parameters: T (int): The number of test cases. test_cases (list of int): A list of integers denoting N for each test case. Returns: list of str: Minimum number of perfect square numbers for each N or error messages if constraints are not met. if T < 1 or T > 10: return [\\"Invalid Test\\"] def min_squares(n): if n == 0: return 0 dp = [float('inf')] * (n + 1) dp[0] = 0 for i in range(1, n + 1): j = 1 while j * j <= i: dp[i] = min(dp[i], dp[i - j * j] + 1) j += 1 return dp[n] results = [] for n in test_cases: if n < 0 or n > 10000: results.append(\\"Invalid Input\\") else: results.append(str(min_squares(n))) return results"},{"question":"def has_duplicates(matrix): Checks if there are duplicates in any row or column of the matrix. Args: matrix: A list of strings representing rows of the matrix. Returns: \\"Yes\\" if there is at least one duplicate letter in any row or column, otherwise \\"No\\". def process_test_cases(test_cases): Processes multiple test cases to check for duplicates in matrices. Args: test_cases: A list of matrices, where each matrix is represented by a list of strings. Returns: A list of results for each test case, where each result is \\"Yes\\" or \\"No\\". # Test cases def test_no_duplicates(): matrix = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\" ] assert has_duplicates(matrix) == \\"No\\" def test_row_duplicates(): matrix = [ \\"aabb\\", \\"ccdd\\", \\"eeff\\" ] assert has_duplicates(matrix) == \\"Yes\\" def test_no_duplicates_in_small_matrix(): matrix = [ \\"ab\\", \\"ba\\" ] assert has_duplicates(matrix) == \\"No\\" def test_column_duplicates(): matrix = [ \\"ab\\", \\"ac\\" ] assert has_duplicates(matrix) == \\"Yes\\" def test_mixed_case(): test_cases = [ ([ \\"abcd\\", \\"efgh\\", \\"ijkl\\" ], \\"No\\"), ([ \\"aabb\\", \\"ccdd\\", \\"eeff\\" ], \\"Yes\\"), ([ \\"ab\\", \\"ba\\" ], \\"No\\") ] test_matrices = [case[0] for case in test_cases] expected_results = [case[1] for case in test_cases] assert process_test_cases(test_matrices) == expected_results","solution":"def has_duplicates(matrix): Checks if there are duplicates in any row or column of the matrix. n = len(matrix) m = len(matrix[0]) # Check rows for duplicates for row in matrix: if len(set(row)) < len(row): return \\"Yes\\" # Check columns for duplicates for col in range(m): seen = set() for row in range(n): if matrix[row][col] in seen: return \\"Yes\\" seen.add(matrix[row][col]) return \\"No\\" def process_test_cases(test_cases): results = [] for case in test_cases: results.append(has_duplicates(case)) return results"},{"question":"def find_maximum_bandwidth(T: int, test_cases: List[Tuple[int, int, List[int], List[int]]]) -> List[int]: Find the maximum possible total bandwidth that can be allocated to devices without exceeding a given limit for each query. Args: T (int): Number of test cases. test_cases (List[Tuple[int, int, List[int], List[int]]]): List of test cases, each containing: N (int): Number of devices. Q (int): Number of queries. A (List[int]): List containing the bandwidth requirement of each device. C (List[int]): List of bandwidth limits for each query. Returns: List[int]: List of maximum possible total bandwidths for each query across all test cases. >>> find_maximum_bandwidth(1, [(5, 3, [1, 2, 3, 4, 5], [10, 15, 20])]) [10, 15, 15] >>> find_maximum_bandwidth(1, [(1, 2, [5], [5, 10])]) [5, 5]","solution":"def find_maximum_bandwidth(T, test_cases): results = [] for case in test_cases: N, Q, A, queries = case A.sort() prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + A[i - 1] for C in queries: if prefix_sum[N] <= C: results.append(prefix_sum[N]) else: low, high = 0, N while low < high: mid = (low + high) // 2 if prefix_sum[mid] <= C: low = mid + 1 else: high = mid results.append(prefix_sum[low - 1]) return results"},{"question":"def generate_palindromic_substrings(test_cases: List[str]) -> List[List[str]]: Generate all possible palindromic substrings of a given string. Each sublist contains the palindromic substrings of the corresponding input string. >>> generate_palindromic_substrings([\\"ababa\\"]) == [[\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"]] >>> generate_palindromic_substrings([\\"abc\\"]) == [[\\"a\\", \\"b\\", \\"c\\"]]","solution":"def find_all_palindromic_substrings(s): Returns a list of all unique palindromic substrings in the string s. def is_palindrome(sub): return sub == sub[::-1] result = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substring = s[i:j] if is_palindrome(substring): result.add(substring) return sorted(result) def generate_palindromic_substrings(test_cases): Generates all palindromic substrings for each test case and returns a list of results. Each result is a list of palindromic substrings sorted lexicographically. results = [] for s in test_cases: results.append(find_all_palindromic_substrings(s)) return results"},{"question":"from typing import List def longest_substring_with_k_distinct(S: str, K: int) -> str: Given a string S and an integer K, determine the longest substring of S that contains at most K distinct characters. If multiple substrings have the same maximum length, return the one that appears first. >>> longest_substring_with_k_distinct(\\"eceba\\", 2) 'ece' >>> longest_substring_with_k_distinct(\\"aa\\", 1) 'aa' pass def test_longest_substring_with_2_distinct_chars(): assert longest_substring_with_k_distinct(\\"eceba\\", 2) == \\"ece\\" def test_longest_substring_with_1_char(): assert longest_substring_with_k_distinct(\\"aa\\", 1) == \\"aa\\" def test_longest_substring_with_no_match(): assert longest_substring_with_k_distinct(\\"abc\\", 0) == \\"\\" def test_longest_substring_with_k_greater_than_num_chars(): assert longest_substring_with_k_distinct(\\"abc\\", 5) == \\"abc\\" def test_longest_substring_with_all_unique_chars(): assert longest_substring_with_k_distinct(\\"abcdef\\", 3) == \\"abc\\" def test_longest_substring_repeated_chars(): assert longest_substring_with_k_distinct(\\"aaaaa\\", 1) == \\"aaaaa\\" def test_longest_substring_mixed_case(): assert longest_substring_with_k_distinct(\\"aabacbebebe\\", 3) == \\"cbebebe\\"","solution":"def longest_substring_with_k_distinct(S, K): from collections import defaultdict n = len(S) if n == 0 or K == 0: return \\"\\" left, right = 0, 0 max_len = 0 max_start = 0 char_count = defaultdict(int) while right < n: char_count[S[right]] += 1 while len(char_count) > K: char_count[S[left]] -= 1 if char_count[S[left]] == 0: del char_count[S[left]] left += 1 if right - left + 1 > max_len: max_len = right - left + 1 max_start = left right += 1 return S[max_start:max_start + max_len]"},{"question":"def shortestPathGrid(grid, start, end): Find the shortest path between two points in a grid. Parameters: - grid (list of list of int): The grid, where 0 represents walkable and 1 represents blocked. - start (tuple of int, int): The starting point coordinates. - end (tuple of int, int): The ending point coordinates. Returns: - int: The length of the shortest path or -1 if no such path exists. >>> grid = [ ... [0, 0, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 1], ... [1, 0, 0, 0] ... ] >>> shortestPathGrid(grid, (0, 0), (3, 3)) 6 >>> grid = [ ... [0, 1, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 1, 1], ... [1, 0, 1, 0] ... ] >>> shortestPathGrid(grid, (0, 0), (3, 3)) -1","solution":"from collections import deque def shortestPathGrid(grid, start, end): Find the shortest path between two points in a grid. Parameters: - grid (list of list of int): The grid, where 0 represents walkable and 1 represents blocked. - start (tuple of int, int): The starting point coordinates. - end (tuple of int, int): The ending point coordinates. Returns: - int: The length of the shortest path or -1 if no such path exists. def is_valid(x, y): return 0 <= x < len(grid) and 0 <= y < len(grid[0]) and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0], start[1], 0)]) # (x, y, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def binarySearch(arr, target): Returns the index of the target in the sorted array arr if found, otherwise returns -1. Parameters: arr (list): A sorted list of integers target (int): The target value to search for in the array Returns: int: The index of the target in the array, or -1 if the target is not found Examples: >>> binarySearch([1, 2, 3, 4, 5], 3) 2 >>> binarySearch([1, 2, 3, 4, 5], 6) -1 >>> binarySearch([], 3) -1 >>> binarySearch([3], 3) 0 >>> binarySearch([3], 2) -1 >>> binarySearch([1, 2, 3, 4, 5], 1) 0 >>> binarySearch([1, 2, 3, 4, 5], 5) 4 >>> binarySearch([1, 3, 5, 7, 9], 7) 3 >>> binarySearch([1, 3, 5, 7], 3) 1 >>> binarySearch([-5, -3, -1, 0, 2], -3) 1","solution":"def binarySearch(arr, target): Returns the index of the target in the sorted array arr if found, otherwise returns -1. Parameters: arr (list): A sorted list of integers target (int): The target value to search for in the array Returns: int: The index of the target in the array, or -1 if the target is not found left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"def length_of_longest_substring(s: str) -> int: Given a string, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"au\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"abacd\\") 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. :param s: Input string :return: Length of the longest substring without repeating characters char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map: left = max(left, char_map[s[right]] + 1) char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"def max_magic_difference(N: int, M: int, magic_values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum difference in magic values between any two directly connected regions. :param N: The number of regions (nodes) :param M: The number of roads (edges) :param magic_values: A list of integers representing the magic values of the regions :param edges: A list of tuples representing the roads between regions :return: The maximum difference in magic values between any two directly connected regions >>> max_magic_difference(5, 4, [3, 1, 4, 1, 5], [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_magic_difference(3, 2, [8, 3, 7], [(1, 2), (1, 3)]) 5","solution":"def max_magic_difference(N, M, magic_values, edges): Calculate the maximum difference in magic values between any two directly connected regions. :param N: The number of regions (nodes) :param M: The number of roads (edges) :param magic_values: A list of integers representing the magic values of the regions :param edges: A list of tuples representing the roads between regions :return: The maximum difference in magic values between any two directly connected regions max_difference = 0 for u, v in edges: difference = abs(magic_values[u - 1] - magic_values[v - 1]) if difference > max_difference: max_difference = difference return max_difference # Example usage: # print(max_magic_difference(5, 4, [3, 1, 4, 1, 5], [(1, 2), (2, 3), (3, 4), (4, 5)])) # Output: 4 # print(max_magic_difference(3, 2, [8, 3, 7], [(1, 2), (1, 3)])) # Output: 5"},{"question":"def longest_palindrome(text: str) -> str: Write a function that takes a string of text as input and returns the longest palindrome within that text. A palindrome is a sequence of characters that reads the same backward as forward. You need to ignore case and consider only alphanumeric characters for the palindrome detection. Args: text (str): Input text Returns: str: The longest palindrome within the input text Examples: >>> longest_palindrome(\\"racecar\\") 'racecar' >>> longest_palindrome(\\"No 'x' in Nixon\\") 'noxinnixon' >>> longest_palindrome(\\"abacdfgdcaba\\") 'aba' >>> longest_palindrome(\\"A man, a plan, a canal, Panama\\") 'amanaplanacanalpanama' >>> pass from solution import longest_palindrome def test_simple_palindromes(): assert longest_palindrome(\\"racecar\\") == \\"racecar\\" assert longest_palindrome(\\"madam\\") == \\"madam\\" def test_palindrome_with_special_chars(): assert longest_palindrome(\\"A man, a plan, a canal, Panama\\") == \\"amanaplanacanalpanama\\" assert longest_palindrome(\\"No 'x' in Nixon\\") == \\"noxinnixon\\" def test_empty_string(): assert longest_palindrome(\\"\\") == \\"\\" def test_single_character(): assert longest_palindrome(\\"a\\") == \\"a\\" assert longest_palindrome(\\"z\\") == \\"z\\" def test_no_palindrome(): assert longest_palindrome(\\"abcde\\") == \\"a\\" def test_mixed_characters(): assert longest_palindrome(\\"abacdfgdcaba\\") == \\"aba\\" assert longest_palindrome(\\"abaxabaxabb\\") == \\"baxabaxab\\"","solution":"def longest_palindrome(text: str) -> str: import re text = re.sub(r'[^A-Za-z0-9]', '', text).lower() def expand_around_center(s, left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left+1:right] longest = \\"\\" for i in range(len(text)): # Odd-length palindromes odd_palindrome = expand_around_center(text, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even-length palindromes even_palindrome = expand_around_center(text, i, i+1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"from typing import List def binary_search(sorted_list: List[int], target: int) -> bool: Perform a binary search to find the target in the sorted_list. The function should return True if the target exists in the list, and False otherwise. >>> binary_search([1, 2, 3, 4, 5], 3) True >>> binary_search([1, 2, 3, 4, 5], 6) False","solution":"from typing import List def binary_search(sorted_list: List[int], target: int) -> bool: left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return True elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return False"},{"question":"def max_pairs(warriors: List[int]) -> int: Determine the maximum number of valid warrior pairs that can be formed. A pair (a, b) is considered valid if the strength of warrior a is greater than the strength of warrior b. >>> max_pairs([1, 2, 3, 4, 5]) == 2 >>> max_pairs([3, 1, 2]) == 1 >>> max_pairs([4, 4, 4, 4]) == 0 >>> max_pairs([1]) == 0 >>> max_pairs([2, 1]) == 1 >>> max_pairs([10, 9, 8]) == 1 >>> max_pairs([i for i in range(1, 100001)]) == 50000 To run tests, use: if __name__ == \\"__main__\\": import doctest doctest.testmod() from solution import max_pairs def test_example_1(): assert max_pairs([1, 2, 3, 4, 5]) == 2 def test_example_2(): assert max_pairs([3, 1, 2]) == 1 def test_example_3(): assert max_pairs([4, 4, 4, 4]) == 0 def test_single_element(): assert max_pairs([1]) == 0 def test_minimal_case(): assert max_pairs([2, 1]) == 1 def test_no_pairs_possible(): assert max_pairs([10, 9, 8]) == 1 def test_large_input(): assert max_pairs([i for i in range(1, 100001)]) == 50000","solution":"def max_pairs(warriors): Returns the maximum number of valid warrior pairs. A pair (a, b) is valid if strength of a > strength of b. warriors.sort() # Sort the warrior strengths left = 0 right = len(warriors) // 2 pairs = 0 while left < len(warriors) // 2 and right < len(warriors): if warriors[left] < warriors[right]: pairs += 1 left += 1 right += 1 return pairs"},{"question":"from typing import List def smallestDistinctSubstring(s: str) -> int: Given a string, find the length of the smallest contiguous substring that contains all the distinct characters of the original string at least once. >>> smallestDistinctSubstring(\\"aabcbcdbca\\") 4 >>> smallestDistinctSubstring(\\"aaab\\") 2","solution":"def smallestDistinctSubstring(s): Returns the length of the smallest contiguous substring that contains all the distinct characters of the original string. distinct_chars = set(s) n = len(s) min_length = float('inf') char_count = {} left = 0 for right in range(n): char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) == len(distinct_chars): min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length"},{"question":"from typing import List def top_k_frequent_words(K: int, S: List[str]) -> List[str]: Returns the top K most frequent words from an array of strings S. If two words have the same frequency, they are sorted lexicographically. >>> top_k_frequent_words(3, [\\"the quick brown fox\\", \\"jumps over the lazy dog\\", \\"the quick blue fox jumps high\\"]) [\\"the\\", \\"fox\\", \\"jumps\\"] >>> top_k_frequent_words(5, [\\"a a a a b b b c c d\\"]) [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> top_k_frequent_words(2, [\\"hello world hello hello\\"]) [\\"hello\\", \\"world\\"] >>> top_k_frequent_words(3, [\\"apple banana apple cherry banana cherry\\"]) [\\"apple\\", \\"banana\\", \\"cherry\\"] >>> top_k_frequent_words(4, [\\"a b c d a b c d e f g h\\"]) [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] >>> top_k_frequent_words(1, [\\"\\"]) [] pass def test_top_k_frequent_words_example(): K = 3 S = [\\"the quick brown fox\\", \\"jumps over the lazy dog\\", \\"the quick blue fox jumps high\\"] result = top_k_frequent_words(K, S) expected = [\\"the\\", \\"fox\\", \\"jumps\\"] assert result == expected def test_top_k_frequent_words_less_than_k_unique(): K = 5 S = [\\"a a a a b b b c c d\\"] result = top_k_frequent_words(K, S) expected = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert result == expected def test_top_k_frequent_words_single_string(): K = 2 S = [\\"hello world hello hello\\"] result = top_k_frequent_words(K, S) expected = [\\"hello\\", \\"world\\"] assert result == expected def test_top_k_frequent_words_ties(): K = 3 S = [\\"apple banana apple cherry banana cherry\\"] result = top_k_frequent_words(K, S) expected = [\\"apple\\", \\"banana\\", \\"cherry\\"] assert result == expected def test_top_k_frequent_words_with_multiple_ties(): K = 4 S = [\\"a b c d a b c d e f g h\\"] result = top_k_frequent_words(K, S) expected = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert result == expected def test_top_k_frequent_words_edge_case(): K = 1 S = [\\"\\"] result = top_k_frequent_words(K, S) expected = [] assert result == expected","solution":"from collections import Counter def top_k_frequent_words(K, S): Returns the top K most frequent words from an array of strings S. If two words have the same frequency, they are sorted lexicographically. word_count = Counter() # Combine all strings into a single list of words for string in S: words = string.split() word_count.update(words) # Create a sorted list of words based on frequency and lexicographical order sorted_words = sorted(word_count.keys(), key=lambda word: (-word_count[word], word)) # Return the top K frequent words or all words if fewer than K unique words return sorted_words[:K]"},{"question":"def check_consistent_growth(t: int, plant_measurements: List[List[int]]) -> List[str]: Analyze the list of measurements for each plant and determine if each plant exhibits consistent growth. Consistent growth means the height of a plant does not decrease on any day compared to the previous day. Args: t (int): Number of plants. plant_measurements (List[List[int]]): List of measurements for each plant. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each plant. Example: >>> check_consistent_growth(3, [ >>> [4, 2, 3, 3, 5], >>> [3, 5, 4, 6], >>> [5, 1, 2, 2, 2, 3] >>> ]) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def check_consistent_growth(t, plant_measurements): results = [] for plant in plant_measurements: k = plant[0] # first integer is the number of measurements heights = plant[1:] # rest are the height measurements consistent = True for i in range(1, k): if heights[i] < heights[i - 1]: consistent = False break if consistent: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def min_cost_to_connect_houses(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Find the minimum construction cost required to connect all the houses. Args: N (int): The number of houses. M (int): The number of possible pipe connections. connections (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers (a, b, c), representing a connection between house a and house b with construction cost c. Returns: int: The minimum cost to connect all the houses. If it's impossible to connect all the houses, returns -1. Examples: >>> min_cost_to_connect_houses(4, 5, [(1, 2, 10), (1, 3, 15), (2, 3, 5), (2, 4, 20), (3, 4, 10)]) 25 >>> min_cost_to_connect_houses(3, 1, [(1, 2, 5)]) -1 >>> min_cost_to_connect_houses(5, 7, [(1, 2, 1), (1, 3, 3), (2, 3, 1), (3, 4, 4), (4, 5, 2), (2, 5, 5), (1, 4, 3)]) 7","solution":"def find(parent, i): # This function finds the parent of a node i if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): # This function unions the sets containing x and y rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def min_cost_to_connect_houses(N, M, connections): if N == 1: return 0 # Initialize parent and rank arrays for union-find parent = [i for i in range(N)] rank = [0] * N # Sort connections based on cost connections.sort(key=lambda x: x[2]) total_cost = 0 edges_used = 0 for conn in connections: a, b, cost = conn if find(parent, a - 1) != find(parent, b - 1): union(parent, rank, a - 1, b - 1) total_cost += cost edges_used += 1 if edges_used == N - 1: return total_cost return -1 # To take input from standard input in competitive programming style def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) connections = [] for i in range(M): a = int(data[2 + 3*i]) b = int(data[3 + 3*i]) c = int(data[4 + 3*i]) connections.append((a, b, c)) print(min_cost_to_connect_houses(N, M, connections)) if __name__ == \\"__main__\\": main()"},{"question":"def smallest_possible_value(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the smallest possible value of the remaining element after performing the given operation any number of times on the list. >>> smallest_possible_value([(3, [1, 2, 3])]) [6] >>> smallest_possible_value([(4, [-1, 2, -3, 4])]) [2] >>> smallest_possible_value([(3, [1, 2, 3]), (4, [-1, 2, -3, 4])]) [6, 2] >>> smallest_possible_value([(3, [-1, -2, -3])]) [-6] >>> smallest_possible_value([(4, [0, 0, 0, 0])]) [0] >>> smallest_possible_value([(5, [100, -100, 100, -100, 50])]) [50]","solution":"def smallest_possible_value(test_cases): results = [] for case in test_cases: n = case[0] integers = case[1] results.append(sum(integers)) return results"},{"question":"def find_out_of_order(nums: List[int]) -> int: Write a function that takes a list of integers and returns the index position of the smaller number that first out of numerical order compared to the previous number. If the array is already sorted in ascending order, the function should return -1. Return the index starting from 0. Examples: >>> find_out_of_order([1, 2, 5, 6, 4, 7]) 4 >>> find_out_of_order([3, 1, 2, 3, 4, 5]) 1 >>> find_out_of_order([1, 2, 3, 4, 5]) -1","solution":"def find_out_of_order(nums): Returns the index position of the first number that is out of numerical order compared to the previous number If the array is already sorted in ascending order, returns -1. :param nums: List of integers to check :return: Index of the first out-of-order number, or -1 for i in range(1, len(nums)): if nums[i] < nums[i - 1]: return i return -1"},{"question":"def digit_count(test_cases): Returns the number of digits for each number in the list of test_cases. Parameters: test_cases (list): List of integers in string format Returns: list: List of integers representing the number of digits of each number Examples: >>> digit_count(['7']) [1] >>> digit_count(['123', '456', '7890']) [3, 3, 4] >>> large_num = '1' * 100 >>> digit_count([large_num]) [100]","solution":"def digit_count(test_cases): Returns the number of digits for each number in the list of test_cases. Parameters: test_cases (list): List of integers in string format Returns: list: List of integers representing the number of digits of each number return [len(str(num)) for num in test_cases]"},{"question":"def min_energy_required(N: int, M: int, grid: List[List[int]]) -> int: Calculate the minimum energy required to move from the top-left to the bottom-right corner of the grid. Parameters: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the energy costs of each cell in the grid. Returns: int: Minimum energy required to reach the bottom-right corner. >>> min_energy_required(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_energy_required(1, 4, [ ... [1, 2, 3, 4] ... ]) 10 >>> min_energy_required(4, 1, [ ... [1], ... [2], ... [3], ... [4] ... ]) 10 >>> min_energy_required(2, 2, [ ... [1000, 1000], ... [1000, 1000] ... ]) 3000 >>> min_energy_required(1, 1, [ ... [42] ... ]) 42","solution":"def min_energy_path(grid): Returns the minimum energy required to move from the top-left to the bottom-right corner of the grid. N = len(grid) M = len(grid[0]) # Create a 2D dp array to store the minimum energy required to reach each cell dp = [[0]*M for _ in range(N)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1] def min_energy_required(N, M, grid): return min_energy_path(grid)"},{"question":"class FileSystem: Implement a basic file system that supports creating and moving files. Methods: - create(path: str, size: int) -> None: Create a file at the specified 'path' with the given 'size'. - move(sourcePath: str, destinationPath: str) -> None: Move a file from 'sourcePath' to 'destinationPath'. >>> fs = FileSystem() >>> fs.create(\\"/a/b/c\\", 50) >>> fs.move(\\"/a/b/c\\", \\"/a/b/d\\")","solution":"class FileSystem: def __init__(self): self.files = {} self.directories = {'/'} def create(self, path: str, size: int) -> None: directories = path.split('/') current_path = '/' for directory in directories[:-1]: if directory: current_path = (current_path + directory + '/').lstrip('/') self.directories.add(current_path) self.files[path] = size def move(self, sourcePath: str, destinationPath: str) -> None: if sourcePath in self.files: size = self.files.pop(sourcePath) directories = destinationPath.split('/') current_path = '/' for directory in directories[:-1]: if directory: current_path = (current_path + directory + '/').lstrip('/') self.directories.add(current_path) self.files[destinationPath] = size"},{"question":"from typing import List def has_redundant_parentheses(expression: str) -> bool: Checks if the given mathematical expression has redundant parentheses. Args: expression (str): A string containing a valid mathematical expression. Returns: bool: True if there are redundant parentheses, otherwise False. Examples: >>> has_redundant_parentheses(\\"(a + b)\\") False >>> has_redundant_parentheses(\\"((a + b))\\") True >>> has_redundant_parentheses(\\"(a + (b - c))\\") False >>> has_redundant_parentheses(\\"(a + (b))\\") True","solution":"def has_redundant_parentheses(expression): Checks if the given mathematical expression has redundant parentheses. stack = [] operators = set(['+', '-', '*', '/']) for char in expression: if char == ')': top = stack.pop() elements_inside = False while stack and top != '(': if top in operators: elements_inside = True top = stack.pop() if not elements_inside: return True else: stack.append(char) return False"},{"question":"def longest_sequence_of_events(events): Find the longest sequence of non-overlapping events from a list of events. Each event is represented by its start and end time in 24-hour format (HH:MM). Args: events (List[Tuple[str, str]]): A list of events where each event is a tuple of start and end times. Returns: List[Tuple[str, str]]: The longest list of non-overlapping events. >>> longest_sequence_of_events([ (\\"09:00\\", \\"11:00\\"), (\\"11:00\\", \\"13:00\\"), (\\"10:00\\", \\"11:30\\"), (\\"13:00\\", \\"15:00\\"), (\\"12:00\\", \\"13:30\\"), ]) [('09:00', '11:00'), ('11:00', '13:00'), ('13:00', '15:00')] >>> longest_sequence_of_events([ (\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"12:00\\"), (\\"11:00\\", \\"13:00\\"), (\\"13:05\\", \\"14:00\\"), (\\"14:00\\", \\"16:00\\"), ]) [('09:00', '10:00'), ('10:30', '12:00'), ('13:05', '14:00'), ('14:00', '16:00')]","solution":"def longest_sequence_of_events(events): def convert_to_minutes(time_str): hours, minutes = map(int, time_str.split(\\":\\")) return hours * 60 + minutes def convert_to_time_str(minutes): hours = minutes // 60 minutes %= 60 return f\\"{hours:02}:{minutes:02}\\" events = [(convert_to_minutes(start), convert_to_minutes(end)) for start, end in events] events.sort(key=lambda x: x[1]) non_overlapping_events = [] last_end_time = -1 for start, end in events: if start >= last_end_time: non_overlapping_events.append((convert_to_time_str(start), convert_to_time_str(end))) last_end_time = end return non_overlapping_events"},{"question":"def max_non_attacking_rooks(R: int, C: int) -> int: Determine the maximum number of non-attacking rooks that can be placed on an R x C grid. >>> max_non_attacking_rooks(8, 8) 8 >>> max_non_attacking_rooks(3, 5) 3","solution":"def max_non_attacking_rooks(R, C): Returns the maximum number of non-attacking rooks that can be placed on an R x C grid. return min(R, C)"},{"question":"def rearrange_string(s: str) -> str: Given a string s consisting of lowercase English letters, rearrange it into a string where no two adjacent characters are the same. If such a rearrangement is not possible, output \\"Impossible\\". >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") 'Impossible'","solution":"from collections import Counter import heapq def rearrange_string(s): Rearranges the string s so that no two adjacent characters are the same. If not possible, returns \\"Impossible\\". # Count frequency of each character freq = Counter(s) # Max heap based on character frequency max_heap = [(-value, key) for key, value in freq.items()] heapq.heapify(max_heap) prev_char = None prev_count = 0 result = [] # Process the heap while max_heap or prev_count < 0: if not max_heap: return \\"Impossible\\" count, char = heapq.heappop(max_heap) # Append current character result.append(char) # If there was a previous character to re-insert, do it if prev_char and prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character prev_char = char prev_count = count + 1 # Increase the negative value towards 0 return \\"\\".join(result)"},{"question":"def update(array, x, y): Updates the element at position x in the array to y. >>> array = [1, 5, 2, 6, 3, 4] >>> update(array, 3, 7) >>> array [1, 5, 7, 6, 3, 4] pass def kth_one(array, l, r, k): Returns the k-th smallest element in the subarray from index l to r inclusive. >>> array = [1, 5, 7, 6, 3, 4] >>> kth_one(array, 2, 5, 3) 6 >>> kth_one(array, 1, 6, 4) 5 pass def process_queries(array, queries): Processes a list of queries on the array. >>> array = [1, 5, 2, 6, 3, 4] >>> queries = [\\"update 3 7\\", \\"kth_one 2 5 3\\", \\"kth_one 1 6 4\\"] >>> process_queries(array, queries) [6, 5] >>> array = [1, 3, 5, 7, 9, 11] >>> queries = [\\"kth_one 1 6 3\\"] >>> process_queries(array, queries) [5] >>> array = [10, 20, 30, 40] >>> queries = [\\"update 2 15\\", \\"kth_one 1 4 3\\"] >>> process_queries(array, queries) [30] pass","solution":"def update(array, x, y): Updates the element at position x in the array to y. array[x-1] = y def kth_one(array, l, r, k): Returns the k-th smallest element in the subarray from index l to r inclusive. subarray = array[l-1:r] subarray.sort() return subarray[k-1] def process_queries(array, queries): Processes a list of queries on the array. results = [] for query in queries: parts = query.split() if parts[0] == \\"update\\": update(array, int(parts[1]), int(parts[2])) elif parts[0] == \\"kth_one\\": result = kth_one(array, int(parts[1]), int(parts[2]), int(parts[3])) results.append(result) return results"},{"question":"def findUnique(arr): Returns the element that appears exactly once in the array. As each element appears exactly twice except for one, we use the XOR operation to find the unique element. :param arr: List of integers :return: The unique integer that appears only once >>> findUnique([4, 1, 2, 1, 2]) 4 >>> findUnique([2, 2, 1]) 1 >>> findUnique([1]) 1","solution":"def findUnique(arr): Returns the element that appears exactly once in the array. As each element appears exactly twice except for one, we use the XOR operation to find the unique element. :param arr: List of integers :return: The unique integer that appears only once unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def findTwoSum(nums, target): Given an array of integers nums and an integer target, find two distinct indices i and j in the array such that nums[i] + nums[j] equals target. Return these indices as a tuple (i, j). If no such indices exist, return (-1, -1). Examples: >>> findTwoSum([2, 7, 11, 15], 9) (0, 1) >>> findTwoSum([3, 2, 4], 6) (1, 2) >>> findTwoSum([3, 3], 6) (0, 1) >>> findTwoSum([1, 2, 3], 7) (-1, -1) >>> findTwoSum([5, 5, 5, 5], 20) (-1, -1) >>> findTwoSum([-3, 4, 3, 90], 0) (0, 2) >>> findTwoSum([1, -1, 1, 0], 0) (0, 1)","solution":"def findTwoSum(nums, target): Given an array of integers nums and an integer target, find two distinct indices i and j in the array such that nums[i] + nums[j] equals target. Return these indices as a tuple (i, j). If no such indices exist, return (-1, -1). lookup = {} for i, num in enumerate(nums): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i return (-1, -1)"},{"question":"def most_common_subsequence(S: str) -> str: Find the most common repeated non-overlapping subsequence of length exactly three characters that appears in the string S. If multiple such subsequences are found, return the lexicographically smallest one. If no such subsequence exists, return \\"NONE\\". >>> most_common_subsequence(\\"abacabadabacaba\\") 'aba' >>> most_common_subsequence(\\"abcabcabc\\") 'abc' >>> most_common_subsequence(\\"abcdefgh\\") 'NONE'","solution":"def most_common_subsequence(S): from collections import defaultdict subseq_freq = defaultdict(int) n = len(S) # Generate all subsequences of length 3 for i in range(n - 2): subseq = S[i:i+3] subseq_freq[subseq] += 1 # Filter the subsequences that appear more than once repeated_subseqs = {subseq: count for subseq, count in subseq_freq.items() if count > 1} if not repeated_subseqs: return \\"NONE\\" # Find the most common and lexicographically smallest subsequence max_freq = max(repeated_subseqs.values()) most_common = [subseq for subseq, count in repeated_subseqs.items() if count == max_freq] return min(most_common) # Example usage: # print(most_common_subsequence(\\"abacabadabacaba\\")) # Output: \\"aba\\""},{"question":"def is_book_borrowed(n: int, borrowed_books: List[str], check_book: str) -> str: This function checks if a book is currently borrowed or not. :param n: int : Number of borrowed books :param borrowed_books: List[str] : List of borrowed book titles :param check_book: str : The title of the book to check :return: str : 'Borrowed' if the book is borrowed, otherwise 'Available' >>> is_book_borrowed(4, [\\"Moby Dick\\", \\"Pride and Prejudice\\", \\"The Great Gatsby\\", \\"War and Peace\\"], \\"War and Peace\\") # 'Borrowed' >>> is_book_borrowed(3, [\\"The Alchemist\\", \\"1984\\", \\"To Kill a Mockingbird\\"], \\"The Great Gatsby\\") # 'Available' >>> is_book_borrowed(2, [\\"Moby Dick\\", \\"Pride and Prejudice\\"], \\"Anna Karenina\\") # 'Available' >>> is_book_borrowed(1, [\\"The Catcher in the Rye\\"], \\"The Catcher in the Rye\\") # 'Borrowed' >>> is_book_borrowed(1, [\\"Brave New World\\"], \\"1984\\") # 'Available'","solution":"def is_book_borrowed(n, borrowed_books, check_book): This function checks if a book is currently borrowed or not. Parameters: - n : int : Number of borrowed books - borrowed_books : list : List of borrowed book titles - check_book : str : The title of the book to check Returns: - str : 'Borrowed' if the book is borrowed, otherwise 'Available' if check_book in borrowed_books: return 'Borrowed' else: return 'Available' # Example usage: # n = 3 # borrowed_books = [\\"The Alchemist\\", \\"1984\\", \\"To Kill a Mockingbird\\"] # check_book = \\"The Great Gatsby\\" # print(is_book_borrowed(n, borrowed_books, check_book)) # Output: Available"},{"question":"def rearrange(arr): Rearranges the array such that positive and negative numbers alternate. Starts with a positive number and follows the order of their appearance. Args: arr (List[int]): List of integers containing both positive and negative numbers. Returns: List[int]: Rearranged list with alternating positive and negative numbers. Examples: >>> rearrange([1, 2, 3, -4, -1, 4]) [1, -4, 2, -1, 3, 4] >>> rearrange([5, -2, -3, 8, -4, -6, 9, -7]) [5, -2, 8, -3, 9, -4, -6, -7]","solution":"def rearrange(arr): Rearranges the array such that positive and negative numbers alternate. Starts with a positive number and follows the order of their appearance. pos = [x for x in arr if x >= 0] neg = [x for x in arr if x < 0] res = [] i, j = 0, 0 while i < len(pos) and j < len(neg): res.append(pos[i]) res.append(neg[j]) i += 1 j += 1 # Append remaining positive elements, if any while i < len(pos): res.append(pos[i]) i += 1 # Append remaining negative elements, if any while j < len(neg): res.append(neg[j]) j += 1 return res"},{"question":"def count_rectangles(m: int, n: int) -> int: Compute the total number of distinct rectangles that can be formed in an m x n grid. Parameters: m (int): the number of rows in the grid n (int): the number of columns in the grid Returns: int: the total number of distinct rectangles Examples: >>> count_rectangles(2, 3) 18 >>> count_rectangles(3, 3) 36","solution":"def count_rectangles(m, n): Returns the total number of distinct rectangles that can be formed in an m x n grid. # The total number of rectangles possible in an m x n grid can be found by: # Sum of all sub-rectangles possible which is: (m * (m + 1) / 2) * (n * (n + 1) / 2) return (m * (m + 1) // 2) * (n * (n + 1) // 2)"},{"question":"def count_keyword_occurrences(review: str, keyword: str) -> int: Counts the number of times the exact keyword appears in the review. Parameters: review (str): The customer review text. keyword (str): The keyword to search for in the review. Returns: int: The number of occurrences of the keyword in the review. >>> count_keyword_occurrences(\\"The product is great. The product is worth the money.\\", \\"product\\") 2 >>> count_keyword_occurrences(\\"Service was excellent; service quality made us happy.\\", \\"service\\") 1 # Your code here","solution":"def count_keyword_occurrences(review, keyword): Counts the number of times the exact keyword appears in the review. Parameters: review (str): The customer review text. keyword (str): The keyword to search for in the review. Returns: int: The number of occurrences of the keyword in the review. # Split the review into words based on whitespace and separators words = review.split() # Count the occurrences of keyword in the list of words return words.count(keyword)"},{"question":"from collections import deque from typing import List, Tuple def min_roads_to_travel(n: int, roads: List[Tuple[int, int]], initial_city: int, destination_city: int) -> int: Find the minimum number of roads that one has to travel to get from the initial city to the destination city in a graph of n cities connected by n-1 roads. >>> min_roads_to_travel(5, [(1, 2), (1, 3), (2, 4), (3, 5)], 1, 4) 2 >>> min_roads_to_travel(6, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)], 4, 3) 3 pass def test_min_roads_to_travel_example1(): n = 5 roads = [(1, 2), (1, 3), (2, 4), (3, 5)] initial_city = 1 destination_city = 4 assert min_roads_to_travel(n, roads, initial_city, destination_city) == 2 def test_min_roads_to_travel_example2(): n = 6 roads = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] initial_city = 4 destination_city = 3 assert min_roads_to_travel(n, roads, initial_city, destination_city) == 3 def test_min_roads_to_travel_no_path(): n = 2 roads = [(1, 2)] initial_city = 1 destination_city = 2 assert min_roads_to_travel(n, roads, initial_city, destination_city) == 1 def test_min_roads_to_travel_adjacent(): n = 4 roads = [(1, 2), (2, 3), (3, 4)] initial_city = 1 destination_city = 4 assert min_roads_to_travel(n, roads, initial_city, destination_city) == 3","solution":"from collections import deque def min_roads_to_travel(n, roads, initial_city, destination_city): # Build the adjacency list adj_list = {i: [] for i in range(1, n+1)} for u, v in roads: adj_list[u].append(v) adj_list[v].append(u) # Perform BFS to find the shortest path queue = deque([(initial_city, 0)]) # (current_city, distance) visited = set() visited.add(initial_city) while queue: current_city, distance = queue.popleft() if current_city == destination_city: return distance for neighbor in adj_list[current_city]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 # This line should never be reached due to the problem constraints"},{"question":"from typing import List, Tuple def max_scenic(m: int, n: int, scenic: List[int], streets: List[Tuple[int, int]]) -> int: Determine the maximum number of distinct scenic intersections that can be visited in a valid travel plan. Args: m (int): The number of intersections. n (int): The number of one-way streets. scenic (List[int]): A list indicating if an intersection is scenic (1) or not (0). streets (List[Tuple[int, int]]): A list of tuples representing the one-way streets. Returns: int: The maximum number of distinct scenic intersections visited in any valid travel plan. Examples: >>> max_scenic(5, 5, [1, 0, 1, 0, 1], [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) 3 >>> max_scenic(4, 4, [1, 1, 0, 1], [(1, 2), (2, 3), (3, 4), (4, 2)]) 2 >>> max_scenic(3, 3, [0, 0, 0], [(1, 2), (2, 3), (3, 1)]) 0 >>> max_scenic(4, 4, [1, 0, 0, 0], [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> max_scenic(6, 6, [1, 0, 1, 1, 0, 1], [(1, 2), (2, 1), (3, 4), (4, 3), (5, 6), (6, 5)]) 2","solution":"from collections import deque, defaultdict def max_scenic(m, n, scenic, streets): # Create adjacency list for the graph graph = defaultdict(list) for x, y in streets: graph[x].append(y) # Function to find the strongly connected components (SCC) def kosaraju_scc(m, graph): stack = [] visited = [False] * (m + 1) def fill_order(v): visited[v] = True for i in graph[v]: if not visited[i]: fill_order(i) stack.append(v) def dfs(v, transposed_graph): visited[v] = True scc[-1].append(v) for i in transposed_graph[v]: if not visited[i]: dfs(i, transposed_graph) # Fill vertices in stack according to their finishing times for i in range(1, m + 1): if not visited[i]: fill_order(i) # Create a reversed graph transposed_graph = defaultdict(list) for i in graph: for j in graph[i]: transposed_graph[j].append(i) # Process all vertices in order defined by stack visited = [False] * (m + 1) scc = [] while stack: i = stack.pop() if not visited[i]: scc.append([]) dfs(i, transposed_graph) return scc # Get all strongly connected components sccs = kosaraju_scc(m, graph) max_scenic_intersections = 0 for scc in sccs: unique_scenic_count = len(set(intersection for intersection in scc if scenic[intersection - 1] == 1)) max_scenic_intersections = max(max_scenic_intersections, unique_scenic_count) return max_scenic_intersections"},{"question":"def find_grid_size(m, n): This function calculates the smallest grid size to fit m coins within a maximum of n rows and n columns. Args: m (int): The number of coins. n (int): The maximum number of rows and columns the grid can have. Returns: tuple: A tuple of integers representing the smallest grid size (rows, columns) that fits all the coins. Examples: >>> find_grid_size(10, 4) (3, 4) >>> find_grid_size(8, 3) (3, 3) >>> find_grid_size(20, 5) (4, 5)","solution":"def find_grid_size(m, n): This function calculates the smallest grid size to fit m coins within a maximum of n rows and n columns. Args: m (int): The number of coins. n (int): The maximum number of rows and columns the grid can have. Returns: tuple: A tuple of integers representing the smallest grid size (rows, columns) that fits all the coins. for rows in range(1, n+1): for cols in range(rows, n+1): if rows * cols >= m: return (rows, cols) return (n, n)"},{"question":"def rearrangeString(s: str) -> str: Rearrange the characters in the string such that no two adjacent characters are the same. If it is not possible to rearrange the string, return an empty string. >>> rearrangeString(\\"aab\\") \\"aba\\" >>> rearrangeString(\\"aabc\\") \\"abac\\" or \\"acba\\" or \\"baca\\" or \\"caba\\" >>> rearrangeString(\\"aaab\\") \\"\\" >>> rearrangeString(\\"aaabb\\") \\"ababa\\"","solution":"import heapq from collections import Counter def rearrangeString(s: str) -> str: # Count the frequency of each character char_count = Counter(s) # Create a max heap with negative frequencies (since heapq is a min-heap) max_heap = [(-count, char) for char, count in char_count.items()] # Transform list into heap heapq.heapify(max_heap) # The result string result = [] prev_count, prev_char = 0, '' while max_heap: count, char = heapq.heappop(max_heap) # Append the current character to the result result.append(char) # If the previous character can still be used (count is negative because it was incremented) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update previous character and its count prev_count, prev_char = count + 1, char # If constructed result length in not equal to original string, it means it wasn't possible if len(result) != len(s): return \\"\\" return \\"\\".join(result)"},{"question":"def largest_prime_less_than_n(N): Returns the largest prime number strictly less than N. >>> largest_prime_less_than_n(10) == 7 >>> largest_prime_less_than_n(30) == 29 >>> largest_prime_less_than_n(17) == 13","solution":"def largest_prime_less_than_n(N): Returns the largest prime number strictly less than N. if N <= 2: return None # Function to determine if a number is prime def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num ** 0.5) + 1, 2): if num % i == 0: return False return True # Start from N-1 and find the highest prime number for number in range(N - 1, 1, -1): if is_prime(number): return number"},{"question":"def count_gemstones(n, string_list): Returns the number of gemstones in the list of strings. A gemstone is defined as a character that appears in every string. :param n: int - The number of strings in the list :param string_list: List - list of strings :return: int - number of gemstones >>> count_gemstones(3, [\\"abcdde\\", \\"baccd\\", \\"eeabg\\"]) 2 >>> count_gemstones(3, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"]) 0 >>> count_gemstones(2, [\\"xyz\\", \\"xyz\\"]) 3 >>> count_gemstones(1, [\\"abcde\\"]) 5 >>> count_gemstones(0, []) 0 >>> count_gemstones(3, [\\"\\", \\"\\", \\"\\"]) 0 >>> count_gemstones(3, [\\"aaa\\", \\"aaa\\", \\"aaa\\"]) 1 >>> count_gemstones(3, [\\"aab\\", \\"abbcc\\", \\"aabc\\"]) 2","solution":"def count_gemstones(n, string_list): Returns the number of gemstones in the list of strings. A gemstone is defined as a character that appears in every string. :param n: int - The number of strings in the list :param string_list: List - list of strings :return: int - number of gemstones if n == 0: return 0 # Initialize a set with characters from the first string gemstone_chars = set(string_list[0]) # Intersect with sets of characters from all other strings for i in range(1, n): gemstone_chars &= set(string_list[i]) # The number of gemstones is the size of the intersected set return len(gemstone_chars)"},{"question":"def max_packages(budget: int, distance: int, weight: int) -> (int, int): Determine the maximum number of packages that can be sent using standard and express delivery methods without exceeding the budget. >>> max_packages(500, 50, 20) (45, 22) >>> max_packages(1, 1, 1) (0, 0) >>> max_packages(10, 50, 20) (0, 0) >>> max_packages(1000000, 50, 20) (90909, 45454) >>> max_packages(500, 10000, 1000) (0, 0) >>> max_packages(100, 0, 0) (20, 10)","solution":"def max_packages(budget, distance, weight): # Calculate standard delivery cost per package standard_cost = 5 + (distance * 0.10) + (weight * 0.05) # Calculate express delivery cost per package express_cost = 10 + (distance * 0.20) + (weight * 0.10) # Calculate number of packages for each method standard_packages = budget // standard_cost express_packages = budget // express_cost return int(standard_packages), int(express_packages) # Example usage budget = 500 distance = 50 weight = 20 print(max_packages(budget, distance, weight)) # Output should be (45, 22)"},{"question":"def generate_matrix(n, m): Generates a matrix with n rows and m columns. Each row is in ascending order from left to right. Each column is in ascending order from top to bottom. >>> generate_matrix(3, 3) [[1, 2, 3], [2, 3, 4], [3, 4, 5]] >>> generate_matrix(2, 4) [[1, 2, 3, 4], [2, 3, 4, 5]] >>> generate_matrix(1, 5) [[1, 2, 3, 4, 5]] >>> generate_matrix(5, 1) [[1], [2], [3], [4], [5]] >>> generate_matrix(1, 1) [[1]] pass","solution":"def generate_matrix(n, m): Generates a matrix with n rows and m columns. Each row is in ascending order from left to right. Each column is in ascending order from top to bottom. matrix = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): matrix[i][j] = i + j + 1 return matrix"},{"question":"def minimum_sum(n: int, k: int, card_values: List[int]) -> int: Returns the minimum possible sum of values that can be obtained by picking exactly k cards. :param n: Number of cards each player is dealt. :param k: Number of cards to pick. :param card_values: List of integers representing the values of the cards each player is dealt. :return: Minimum possible sum of values that can be obtained by picking exactly k cards. >>> minimum_sum(5, 3, [7, 2, 3, 8, 9]) 12 >>> minimum_sum(4, 2, [10, 15, 10, 20]) 20 >>> minimum_sum(6, 4, [4, 1, 3, 2, 7, 5]) 10","solution":"def minimum_sum(n, k, card_values): Returns the minimum possible sum of values that can be obtained by picking exactly k cards. :param n: Number of cards each player is dealt. :param k: Number of cards to pick. :param card_values: List of integers representing the values of the cards each player is dealt. :return: Minimum possible sum of values that can be obtained by picking exactly k cards. # Sort the card values in ascending order card_values.sort() # Pick the first k values (They will be the smallest values since the list is sorted) return sum(card_values[:k])"},{"question":"def is_magic_square(grid): Determines if the given 3x3 grid forms a magic square. >>> is_magic_square([2, 7, 6, 9, 5, 1, 4, 3, 8]) == \\"YES\\" >>> is_magic_square([1, 2, 3, 4, 5, 6, 7, 8, 9]) == \\"NO\\"","solution":"def is_magic_square(grid): Determines if the given 3x3 grid forms a magic square. # Extract rows row1, row2, row3 = grid[:3], grid[3:6], grid[6:] # Calculate the sum of the first row magic_sum = sum(row1) # Check rows if sum(row1) != magic_sum or sum(row2) != magic_sum or sum(row3) != magic_sum: return \\"NO\\" # Check columns for col in range(3): if row1[col] + row2[col] + row3[col] != magic_sum: return \\"NO\\" # Check diagonals if row1[0] + row2[1] + row3[2] != magic_sum: return \\"NO\\" if row1[2] + row2[1] + row3[0] != magic_sum: return \\"NO\\" return \\"YES\\" # Function to parse the input and call the is_magic_square function def main(): import sys input = sys.stdin.read().strip().split() grid = list(map(int, input)) print(is_magic_square(grid))"},{"question":"def final_stacks_state(n, m, operations): Compute the final state of each stack after performing a series of operations. Args: n (int): number of stacks m (int): number of operations operations (list of tuples): list of operations, each represented by a tuple (t, s) Returns: list of int: final state of each stack pass import pytest def test_case_1(): n, m = 3, 5 operations = [(1, 1), (1, 2), (2, 1), (1, 3), (2, 3)] assert final_stacks_state(n, m, operations) == [0, 1, 0] def test_case_2(): n, m = 2, 4 operations = [(1, 1), (1, 1), (2, 1), (2, 2)] assert final_stacks_state(n, m, operations) == [1, 0] def test_case_ignore_remove_from_empty(): n, m = 1, 3 operations = [(2, 1), (2, 1), (1, 1)] assert final_stacks_state(n, m, operations) == [1] def test_case_multiple_additions_and_removals(): n, m = 4, 7 operations = [(1, 1), (1, 1), (1, 2), (2, 1), (1, 3), (2, 1), (2, 3)] assert final_stacks_state(n, m, operations) == [0, 1, 0, 0] def test_case_large_input(): n, m = 1000, 10000 operations = [(1, i % n + 1) for i in range(m)] assert final_stacks_state(n, m, operations) == [10] * n # Run the tests pytest.main()","solution":"def final_stacks_state(n, m, operations): Compute the final state of each stack after performing a series of operations. Args: n (int): number of stacks m (int): number of operations operations (list of tuples): list of operations, each represented by a tuple (t, s) Returns: list of int: final state of each stack stacks = [0] * n for operation in operations: t, s = operation if t == 1: stacks[s - 1] += 1 elif t == 2 and stacks[s - 1] > 0: stacks[s - 1] -= 1 return stacks # Example usage: # n = 3, m = 5 # operations = [(1, 1), (1, 2), (2, 1), (1, 3), (2, 3)] # print(final_stacks_state(n, m, operations)) # Output: [0, 1, 0]"},{"question":"from typing import List def rob(nums: List[int]) -> int: Determine the maximum amount of money you can rob tonight without alerting the police. Houses are arranged in a circular pattern. >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([5]) 5 >>> rob([2, 3]) 3 >>> rob([3, 2, 3, 2, 3]) 6 >>> rob([1000, 1000, 1000, 1000, 1000]) 2000 >>> rob([]) 0 >>> rob([0, 0, 0, 0]) 0","solution":"def rob(nums): Determine the maximum amount of money you can rob tonight without alerting the police. Houses are arranged in a circular pattern. if not nums: return 0 n = len(nums) if n == 1: return nums[0] def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr # Consider two cases: # Case 1: Do not rob the last house # Case 2: Do not rob the first house return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def lexicographically_minimum_string(strings): Returns a list of lexicographically minimum strings for each string in the input list. This is achievable by simply sorting the characters of each string. >>> lexicographically_minimum_string(['bdac']) ['abcd'] >>> lexicographically_minimum_string(['bdac', 'abba', 'xaybz']) ['abcd', 'aabb', 'abxyz'] >>> lexicographically_minimum_string(['abc', 'def']) ['abc', 'def'] >>> lexicographically_minimum_string(['aabbcc', 'bbaacc']) ['aabbcc', 'aabbcc'] >>> lexicographically_minimum_string(['a', 'z']) ['a', 'z'] >>> lexicographically_minimum_string(['']) [''] def process_input_output(t, string_list): Processes the input for the number of test cases and list of strings, returning the lexicographically minimum strings for each test case. >>> process_input_output(1, ['bdac']) ['abcd'] >>> process_input_output(3, ['bdac', 'abba', 'xaybz']) ['abcd', 'aabb', 'abxyz'] >>> process_input_output(2, ['abc', 'def']) ['abc', 'def'] >>> process_input_output(2, ['aabbcc', 'bbaacc']) ['aabbcc', 'aabbcc'] >>> process_input_output(2, ['a', 'z']) ['a', 'z'] >>> process_input_output(1, ['']) ['']","solution":"def lexicographically_minimum_string(strings): Returns a list of lexicographically minimum strings for each string in the input list. This is achievable by simply sorting the characters of each string. result = [] for s in strings: result.append(''.join(sorted(s))) return result def process_input_output(t, string_list): Processes the input for the number of test cases and list of strings, returning the lexicographically minimum strings for each test case. return lexicographically_minimum_string(string_list)"},{"question":"from typing import List def findUnique(arr: List[int]) -> int: Finds the integer that appears exactly once in the list, where every other integer appears exactly twice. >>> findUnique([1]) 1 >>> findUnique([1, 2, 3, 2, 1, 4, 4, 5, 3]) 5 >>> findUnique([-1, -1, 2, 2, 3, 3, 4]) 4 >>> findUnique([3, 5, 6, 3, 6, 7, 5]) 7 >>> arr = list(range(1, 1000001)) * 2 + [1000001] >>> findUnique(arr) 1000001","solution":"from typing import List def findUnique(arr: List[int]) -> int: Finds the element in the list that appears exactly once. unique = 0 for num in arr: unique ^= num return unique"},{"question":"class Node: def __init__(self, data: int): self.data = data self.next = None def findMiddle(head: Node) -> int: Finds the middle of a singly linked list and returns the data of the middle node. If there are two middle nodes, it returns the second middle node's data. pass import pytest def create_linked_list(elements): if not elements: return None head = Node(elements[0]) current = head for elem in elements[1:]: current.next = Node(elem) current = current.next return head def test_findMiddle_odd_elements(): elements = [1, 2, 3, 4, 5] head = create_linked_list(elements) assert findMiddle(head) == 3 def test_findMiddle_even_elements(): elements = [1, 2, 3, 4, 5, 6] head = create_linked_list(elements) assert findMiddle(head) == 4 def test_findMiddle_single_element(): elements = [1] head = create_linked_list(elements) assert findMiddle(head) == 1 def test_findMiddle_two_elements(): elements = [1, 2] head = create_linked_list(elements) assert findMiddle(head) == 2 def test_findMiddle_alternate_case(): elements = [10, 20, 30, 40, 50, 60, 70, 80] head = create_linked_list(elements) assert findMiddle(head) == 50 if __name__ == \\"__main__\\": pytest.main()","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None def findMiddle(head: Node) -> int: Finds the middle of a singly linked list and returns the data of the middle node. If there are two middle nodes, it returns the second middle node's data. slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next return slow.data"},{"question":"def longest_continuous_usage(logs: List[str]) -> int: Returns the resource with the longest continuous usage by a single user. If there is a tie, returns the smallest resource ID. >>> longest_continuous_usage([\\"123 1 100\\", \\"123 1 200\\", \\"123 2 300\\", \\"123 1 400\\", \\"124 1 500\\"]) 1 >>> longest_continuous_usage([\\"123 1 100\\", \\"123 2 200\\", \\"123 1 300\\", \\"123 1 400\\", \\"123 1 500\\"]) 1","solution":"def longest_continuous_usage(logs): from collections import defaultdict usage_data = defaultdict(lambda: defaultdict(list)) # Parse logs for log in logs: user, resource, timestamp = map(int, log.split()) usage_data[user][resource].append(timestamp) max_duration = 0 selected_resource = float('inf') # Find the user-resource pair with the longest continuous usage for user in usage_data: for resource in usage_data[user]: timestamps = sorted(usage_data[user][resource]) current_duration = 0 for i in range(1, len(timestamps)): if timestamps[i] - timestamps[i-1] > 1: current_duration = max(current_duration, timestamps[i-1] - timestamps[0]) timestamps = timestamps[i:] # reset continuous range break else: current_duration = timestamps[i] - timestamps[0] if current_duration > max_duration or (current_duration == max_duration and resource < selected_resource): max_duration = current_duration selected_resource = resource return selected_resource"},{"question":"def min_operations_to_transform_string(n: int, S: str, T: str) -> int: Determines the minimum number of operations required to transform string S into string T by moving characters from the start to the end of S. If transformation is not possible, returns -1. >>> min_operations_to_transform_string(5, 'abcde', 'cdeab') 2 >>> min_operations_to_transform_string(3, 'abc', 'def') -1 >>> min_operations_to_transform_string(4, 'abcd', 'abcd') 0 >>> min_operations_to_transform_string(3, 'abc', 'bca') 1 >>> min_operations_to_transform_string(6, 'abcdef', 'defabc') 3 >>> min_operations_to_transform_string(3, 'abc', 'abd') -1 >>> min_operations_to_transform_string(3, 'aab', 'abb') -1 >>> min_operations_to_transform_string(3, 'aaa', 'aaa') 0","solution":"def min_operations_to_transform_string(n, S, T): Determines the minimum number of operations required to transform string S into string T by moving characters from the start to the end of S. If transformation is not possible, returns -1. if sorted(S) != sorted(T): return -1 # Find the adjusting point for i in range(n): if S[i:] + S[:i] == T: return i return -1"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Find the subarray with the maximum possible sum in a list of integers. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4]) -1 pass","solution":"from typing import List def max_subarray_sum(arr: List[int]) -> int: # Using Kadane's algorithm to find the maximum subarray sum max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def summarize_grades(grades): Summarizes the highest grades achieved by each student in each subject. Parameters: grades (list): A list of lists where each inner list contains [subject, student, grade] Returns: dict: A dictionary where each key is a student's name, and each value is another dictionary with the subjects as keys and the highest grades as values. >>> grades = [ ... [\\"math\\", \\"Alice\\", 85], ... [\\"math\\", \\"Bob\\", 90], ... [\\"math\\", \\"Alice\\", 95], ... [\\"science\\", \\"Alice\\", 80], ... [\\"science\\", \\"Bob\\", 85], ... [\\"history\\", \\"Alice\\", 88], ... [\\"history\\", \\"Bob\\", 92] ... ] >>> summarize_grades(grades) {'Alice': {'math': 95, 'science': 80, 'history': 88}, 'Bob': {'math': 90, 'science': 85, 'history': 92}} >>> grades = [ ... [\\"math\\", \\"Alice\\", 85], ... [\\"math\\", \\"Bob\\", 90], ... [\\"math\\", \\"Alice\\", 95], ... ] >>> summarize_grades(grades) {'Alice': {'math': 95}, 'Bob': {'math': 90}} >>> grades = [ ... [\\"math\\", \\"Alice\\", 85], ... [\\"science\\", \\"Alice\\", 88], ... [\\"history\\", \\"Alice\\", 90], ... ] >>> summarize_grades(grades) {'Alice': {'math': 85, 'science': 88, 'history': 90}} >>> grades = [ ... [\\"math\\", \\"Alice\\", 85], ... [\\"math\\", \\"Bob\\", 90], ... [\\"math\\", \\"Alice\\", 80], ... [\\"math\\", \\"Alice\\", 95], ... ] >>> summarize_grades(grades) {'Alice': {'math': 95}, 'Bob': {'math': 90}} >>> grades = [] >>> summarize_grades(grades) {}","solution":"def summarize_grades(grades): Summarizes the highest grades achieved by each student in each subject. Parameters: grades (list): A list of lists where each inner list contains [subject, student, grade] Returns: dict: A dictionary where each key is a student's name, and each value is another dictionary with the subjects as keys and the highest grades as values. summary = {} for subject, student, grade in grades: if student not in summary: summary[student] = {} if subject not in summary[student] or grade > summary[student][subject]: summary[student][subject] = grade return summary"},{"question":"def can_rearrange(s: str) -> str: Determines if it is possible to rearrange the letters in the given string so that no two adjacent characters are the same. >>> can_rearrange(\\"aabb\\") 'YES' >>> can_rearrange(\\"aaab\\") 'NO' >>> can_rearrange(\\"abcabc\\") 'YES' >>> can_rearrange(\\"aabbccddeeffgg\\") 'YES'","solution":"def can_rearrange(s): Determines if it is possible to rearrange the letters in the given string so that no two adjacent characters are the same. from collections import Counter counts = Counter(s) max_freq = max(counts.values()) # If any character occurs more than (len(s) + 1) // 2 times, it's impossible to rearrange if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\" # Example usage: # s = input().strip() # print(can_rearrange(s))"},{"question":"def second_largest_unique_integer(n: int, integer_list: List[int]) -> int: Returns the second largest unique integer in the list or -1 if there is no such integer. >>> second_largest_unique_integer(5, [4, 2, 5, 2, 3]) 4 >>> second_largest_unique_integer(4, [2, 2, 2, 2]) -1 >>> second_largest_unique_integer(1, [10]) -1 >>> second_largest_unique_integer(2, [10, 20]) 10 >>> second_largest_unique_integer(1000000, list(range(1000000, 0, -1))) 999999","solution":"def second_largest_unique_integer(n, integer_list): Returns the second largest unique integer in the list or -1 if there is no such integer. unique_integers = list(set(integer_list)) if len(unique_integers) < 2: return -1 unique_integers.sort(reverse=True) return unique_integers[1] # Example usage # n = 5 # integer_list = [4, 2, 5, 2, 3] # print(second_largest_unique_integer(n, integer_list)) # Output: 4"},{"question":"def can_reach_within_sum(n: int, k: int, grid: List[List[int]]) -> str: Determine if there exists a path from the top-left corner of the grid to the bottom-right corner such that the sum of the numbers along the path is less than or equal to a given sum k. You can only move to the right or down from a cell, and you must visit each cell at most once. >>> can_reach_within_sum(3, 23, [ ... [5, 9, 1], ... [6, 7, 11], ... [8, 2, 3], ... ]) \\"YES\\" >>> can_reach_within_sum(3, 10, [ ... [5, 9, 1], ... [6, 7, 11], ... [8, 2, 3], ... ]) \\"NO\\" >>> can_reach_within_sum(1, 0, [ ... [0], ... ]) \\"YES\\" >>> can_reach_within_sum(2, 1000000000, [ ... [10000, 10000], ... [10000, 10000], ... ]) \\"YES\\" >>> can_reach_within_sum(2, 15, [ ... [10, 6], ... [7, 10], ... ]) \\"NO\\"","solution":"def can_reach_within_sum(n, k, grid): def path_exists(x, y, current_sum): if x == n - 1 and y == n - 1: return current_sum <= k if current_sum > k: return False right = down = False if x + 1 < n: # Move down down = path_exists(x + 1, y, current_sum + grid[x + 1][y]) if y + 1 < n: # Move right right = path_exists(y + 1, x, current_sum + grid[x][y + 1]) return down or right return \\"YES\\" if path_exists(0, 0, grid[0][0]) else \\"NO\\""},{"question":"from typing import List, Dict def minimal_travel_time(T: int, test_cases: List[Dict[str, object]]) -> List[int]: Calculate the minimal travel time needed to visit all stations starting from a given station S. Parameters: T (int): The number of test cases. test_cases (list): A list of dictionaries, each containing the number of stations (N), the time cost matrix (costs), and the starting station (S). Returns: List[int]: The minimal travel times for each of the test cases. Example: >>> minimal_travel_time(2, [{'N': 4, 'costs': [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], 'S': 1}, {'N': 3, 'costs': [[0, 5, 6], [5, 0, 7], [6, 7, 0]], 'S': 2}]) [80, 18] pass def process_input_output(input_data: str) -> str: Process the input and output data for the minimal travel time calculation. Parameters: input_data (str): The input data as a single string. Returns: str: The output data as a single string with minimal travel times for each test case. Example: >>> process_input_output(\\"2n4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0n1n3n0 5 6n5 0 7n6 7 0n2\\") '80n18' pass","solution":"import itertools def minimal_travel_time(T, test_cases): Calculate the minimal travel time needed to visit all stations starting from a given station S. Parameters: T (int): The number of test cases. test_cases (list): A list of dictionaries, each containing the number of stations (N), the time cost matrix (costs), and the starting station (S). Returns: result (list): The minimal travel times for each of the test cases. results = [] for case in test_cases: N = case['N'] costs = case['costs'] S = case['S'] - 1 # Adjust to 0-based index # Generate all permutations of the stations excluding the starting station stations = list(range(N)) stations.remove(S) permutations = itertools.permutations(stations) min_time = float('inf') # Calculate the travel time for each permutation for perm in permutations: current_time = 0 # Start from S current = S # Travel through the permutation for station in perm: current_time += costs[current][station] current = station # Return to the starting station current_time += costs[current][S] # Check if this is the minimal travel time if current_time < min_time: min_time = current_time results.append(min_time) return results def process_input_output(input_data): Process the input and output data for the minimal travel time calculation. Parameters: input_data (str): The input data as a single string. Returns: output_data (str): The output data as a single string with minimal travel times for each test case. data = input_data.strip().split('n') T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 costs = [] for _ in range(N): costs.append(list(map(int, data[index].split()))) index += 1 S = int(data[index]) index += 1 test_cases.append({'N': N, 'costs': costs, 'S': S}) results = minimal_travel_time(T, test_cases) return 'n'.join(map(str, results)) # Example for proper formatting minimal_travel_time(2, [ {'N': 4, 'costs': [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]], 'S': 1}, {'N': 3, 'costs': [[0, 5, 6], [5, 0, 7], [6, 7, 0]], 'S': 2} ])"}]`),j={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},E={class:"search-container"},P={class:"card-container"},C={key:0,class:"empty-state"},O=["disabled"],D={key:0},F={key:1};function I(n,e,u,_,i,a){const f=h("PoemCard");return s(),r("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",E,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>i.searchQuery=o),placeholder:"Search..."},null,512),[[b,i.searchQuery]]),i.searchQuery?(s(),r("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>i.searchQuery="")}," ✕ ")):l("",!0)]),t("div",P,[(s(!0),r(y,null,x(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),r("div",C,' No results found for "'+d(i.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),r("button",{key:0,class:"load-more-button",disabled:i.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[i.isLoading?(s(),r("span",F,"Loading...")):(s(),r("span",D,"See more"))],8,O)):l("",!0)])}const M=m(j,[["render",I],["__scopeId","data-v-c6721281"]]),z=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/68.md","filePath":"library/68.md"}'),B={name:"library/68.md"},G=Object.assign(B,{setup(n){return(e,u)=>(s(),r("div",null,[w(M)]))}});export{z as __pageData,G as default};
